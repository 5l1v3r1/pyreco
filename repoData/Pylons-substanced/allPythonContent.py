__FILENAME__ = resources
import colander
import datetime
import time
import deform.widget

from persistent import Persistent
from pyramid.security import (
    Allow,
    Everyone,
    )

from substanced.content import content
from substanced.folder import Folder
from substanced.property import PropertySheet
from substanced.root import Root
from substanced.schema import (
    Schema,
    NameSchemaNode,
    )
from substanced.util import renamer

@colander.deferred
def now_default(node, kw):
    return datetime.datetime.now()

class BlogEntrySchema(Schema):
    name = NameSchemaNode(
        editing=lambda c, r: r.registry.content.istype(c, 'BlogEntry')
        )
    title = colander.SchemaNode(
        colander.String(),
        )
    entry = colander.SchemaNode(
        colander.String(),
        widget = deform.widget.TextAreaWidget(rows=20, cols=70),
        )
    format = colander.SchemaNode(
        colander.String(),
        validator = colander.OneOf(['rst', 'html']),
        widget = deform.widget.SelectWidget(
            values=[('rst', 'rst'), ('html', 'html')]),
        )
    pubdate = colander.SchemaNode(
       colander.DateTime(default_tzinfo=None),
       default = now_default,
       )

class BlogEntryPropertySheet(PropertySheet):
    schema = BlogEntrySchema()

@content(
    'Blog Entry',
    icon='glyphicon glyphicon-book',
    add_view='add_blog_entry',
    propertysheets=(
        ('', BlogEntryPropertySheet),
        ),
    catalog=True,
    tab_order=('properties', 'contents', 'acl_edit'),
    )
class BlogEntry(Folder):

    name = renamer()

    def __init__(self, title, entry, format, pubdate):
        Folder.__init__(self)
        self.title = title
        self.entry = entry
        self.format = format
        self.pubdate = pubdate
        self['attachments'] = Attachments()
        self['comments'] = Comments()

    def __sdi_addable__(self, context, introspectable):
        return False

    def add_comment(self, comment):
        while 1:
            name = str(time.time())
            if not name in self:
                self['comments'][name] = comment
                break

class CommentSchema(Schema):
    commenter = colander.SchemaNode(
       colander.String(),
       )
    text = colander.SchemaNode(
       colander.String(),
       )
    pubdate = colander.SchemaNode(
       colander.DateTime(),
       default = now_default,
       )

class CommentPropertySheet(PropertySheet):
    schema = CommentSchema()

@content(
    'Comment',
    icon='glyphicon glyphicon-comment',
    add_view='add_comment',
    propertysheets = (
        ('', CommentPropertySheet),
        ),
    catalog = True,
    )
class Comment(Persistent):
    def __init__(self, commenter_name, text, pubdate):
        self.commenter_name = commenter_name
        self.text = text
        self.pubdate = pubdate

def comments_columns(folder, subobject, request, default_columnspec):
    pubdate = getattr(subobject, 'pubdate', None)
    if pubdate is not None:
        pubdate = pubdate.isoformat()

    return default_columnspec + [
        {'name': 'Publication date',
        'value': pubdate,
        'formatter': 'date',
        },
        ]

@content(
    'Comments',
    icon='glyphicon glyphicon-list',
    columns=comments_columns,
    )
class Comments(Folder):
    """ Folder for comments of a blog entry
    """
    def __sdi_addable__(self, context, introspectable):
        return introspectable.get('content_type') == 'Comment'

def attachments_columns(folder, subobject, request, default_columnspec):
    kb_size = None
    if getattr(subobject, 'get_size', None) and callable(subobject.get_size):
        kb_size = int(int(subobject.get_size())/1000)

    return default_columnspec + [
        {'name': 'Size',
        'value': "%s kB" % kb_size,
        },
        ]

@content(
    'Attachments',
    icon='glyphicon glyphicon-list',
    columns=attachments_columns,
    )
class Attachments(Folder):
    """ Folder for attachments of a blog entry
    """
    def __sdi_addable__(self, context, introspectable):
        return introspectable.get('content_type') == 'File'

class BlogSchema(Schema):
    """ The schema representing the blog root. """
    title = colander.SchemaNode(
        colander.String(),
        missing=''
        )
    description = colander.SchemaNode(
        colander.String(),
        missing=''
        )

class BlogPropertySheet(PropertySheet):
    schema = BlogSchema()

def blog_columns(folder, subobject, request, default_columnspec):
    title = getattr(subobject, 'title', None)
    pubdate = getattr(subobject, 'pubdate', None)
    if pubdate is not None:
        pubdate = pubdate.isoformat()

    return default_columnspec + [
        {'name': 'Title',
        'value': title,
        },
        {'name': 'Publication Date',
        'value': pubdate,
        'formatter': 'date',
        },
        ]

@content(
    'Root',
    icon='glyphicon glyphicon-home',
    propertysheets = (
        ('', BlogPropertySheet),
        ),
    after_create= ('after_create', 'after_create_blog'),
    columns=blog_columns,
    )
class Blog(Root):
    title = 'Substance D Blog'
    description = 'Description of this blog'

    def __sdi_addable__(self, context, introspectable):
        return introspectable.get('content_type') == 'Blog Entry'

    @property
    def sdi_title(self):
        return self.title

    @sdi_title.setter
    def sdi_title(self, value):
        self.title = value
    
    def after_create_blog(self, inst, registry):
        acl = getattr(self, '__acl__', [])
        acl.append((Allow, Everyone, 'view'))
        self.__acl__ = acl

########NEW FILE########
__FILENAME__ = import
# Requirements:
# Preserve existing URLs
# Map first line to title
# Ignore label
# Convert remainder of file to body
# For pubdate, use filename datestamp first; otherwise, use subversion last changed date
# Use HTML format for body text
# Take one or more file names in the /entries directory on the command line, follow
# process as laid out above
# Script opens database at the beginning, gets ahold of the container (blog),
# start looping the files
# Be able to run the script in "verbose" mode and "dry run" mode

from __future__ import print_function

import os
import datetime
import transaction
from optparse import OptionParser
from subprocess import Popen
from subprocess import PIPE

def main():
    from pyramid.paster import get_app
    from pyramid.scripting import get_root
    from ..resources import BlogEntry
    parser = OptionParser(description=__doc__, usage='usage: %prog [options]')
    parser.add_option('-c', '--config', dest='config',
                      help='Specify a paster config file.')
    parser.add_option('-n', '--name', dest='name', default='zodb',
                      help='Specify a section name.')
    options, args = parser.parse_args()
    config = options.config
    name = options.name
    if config is None:
       raise ValueError('must supply config file name')
    config = os.path.abspath(os.path.normpath(config))
    app = get_app(config, name)
    root, closer = get_root(app)
    for arg in args:
        print("filename:", arg)
        if not os.path.isfile(arg):
           print('not a file')
           continue
        path, filename = os.path.split(arg)
        id, ext = os.path.splitext(filename)
        print("id:", id)
        lines = open(arg, 'r').readlines()
        title = lines[0]
        print('title:', title)
        entry = '\n'.join(lines[2:])
        print('entry:', entry[:40])
        pieces = id.split('-')
        last = pieces[-1]
        pubdate = None
        if last.startswith('200'):
           if len(last) == 8:
              year, month, day = last[0:4], last[4:6], last[6:8]
              pubdate = datetime.date(int(year), int(month), int(day))
        if pubdate is None:
           p1 = Popen(["svn", "info", arg], stdout=PIPE)
           p2 = Popen(["grep", "Last Changed Date"], stdin=p1.stdout,
                      stdout=PIPE)
           output = p2.communicate()[0]
           lines = output.split(':', 1)
           datestr = lines[1].strip()
           datestr = datestr.split(' ', 1)[0]
           year, month, day = datestr[0:4], datestr[5:7], datestr[8:10]
           pubdate = datetime.date(int(year), int(month), int(day))
        print('pubdate:', pubdate)
        entry = BlogEntry(title.decode('UTF-8'), entry.decode('UTF-8'), 
                          id.decode('UTF-8'), pubdate, 'html', None, None)
        root[id] = entry
    transaction.commit()
           
if __name__ == '__main__':
   main()

########NEW FILE########
__FILENAME__ = makelots
import os
import datetime
import transaction
from optparse import OptionParser

LOREM_IPSUM = """\
Lorem ipsum dolor sit amet, consectetur adipisicing elit,
sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris
nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate 
velit esse cillum dolore eu fugiat nulla pariatur."""

def main():
    from pyramid.paster import bootstrap
    from ..resources import BlogEntry
    parser = OptionParser(description=__doc__, usage='usage: %prog [options]')
    parser.add_option('-c', '--config', dest='config',
                      help='Specify a paster config file.')
    parser.add_option('-i', '--num', dest='num', default='10000',
                      help='Specify the number of blog entries to add.')
    options, args = parser.parse_args()
    config = options.config
    num = int(options.num)
    if config is None:
       raise ValueError('must supply config file name')
    config = os.path.abspath(os.path.normpath(config))

    env = bootstrap(config)
    root = env['root']
    registry = env['registry']
    closer = env['closer']
    for n in range(0, num):
        print ("adding", n)
        entry = registry.content.create(
            'Blog Entry',
            'Title of blog entry %s' % n,
            LOREM_IPSUM,
            'html',
            datetime.date.today(),
            )
        id = 'blogentry_%s' % n
        root[id] = entry
        if n % 10000 == 0:
            print ('committing')
            transaction.commit()
    print ('committing')
    transaction.commit()
    root._p_jar._db.close()
    closer()
           
if __name__ == '__main__':
   main()

########NEW FILE########
__FILENAME__ = mgmt
from webob.exc import HTTPFound
from substanced.sdi import mgmt_view
from substanced.form import FormView

from ..resources import BlogEntrySchema

@mgmt_view(
    content_type='Root',
    name='add_blog_entry',
    permission='sdi.add-content', 
    renderer='substanced.sdi:templates/form.pt',
    tab_condition=False,
    )
class AddBlogEntryView(FormView):
    title = 'Add Blog Entry'
    schema = BlogEntrySchema()
    buttons = ('add',)

    def add_success(self, appstruct):
        name = appstruct.pop('name')
        request = self.request
        blogentry = request.registry.content.create('Blog Entry', **appstruct)
        self.context[name] = blogentry
        loc = request.mgmt_path(self.context, name, '@@properties')
        return HTTPFound(location=loc)


########NEW FILE########
__FILENAME__ = retail
import datetime
import pytz

from docutils.core import publish_parts
from webob import Response

from pyramid.decorator import reify
from pyramid.httpexceptions import HTTPFound
from pyramid.url import resource_url
from pyramid.view import (
    view_config,
    view_defaults,
    )

def _getentrybody(format, entry):
    if format == 'rst':
       body = publish_parts(entry, writer_name='html')['fragment']
    else:
       body = entry
    return body

@view_config(
    renderer='templates/frontpage.pt',
    content_type='Root',
    )
def blogview(context, request):
    blogentries = []
    for name, blogentry in context.items():
        if request.registry.content.istype(blogentry, 'Blog Entry'):
            blogentries.append(
                {'url': resource_url(blogentry, request),
                 'title': blogentry.title,
                 'body': _getentrybody(blogentry.format, blogentry.entry),
                 'pubdate': blogentry.pubdate,
                 'attachments': [{'name': a.__name__,
                                  'url': resource_url(a, request, 'download')} 
                                 for a in blogentry['attachments'].values()],
                 'numcomments': len(blogentry['comments'].values()),
                 })
    blogentries.sort(key=lambda x: x['pubdate'].isoformat())
    blogentries.reverse()
    return dict(blogentries = blogentries)

@view_defaults(
    content_type='Blog Entry',
    renderer='templates/blogentry.pt',
    )
class BlogEntryView(object):

    def __init__(self, context, request):
        self.context = context
        self.request = request
    
    @reify
    def blogentry(self):
        return _getentrybody(self.context.format, self.context.entry)

    @reify
    def comments(self):
        return self.context['comments'].values()

    @reify
    def attachments(self):
        return self.context['attachments'].values()

    @view_config(request_method='GET')
    def view_blogentry(self):
        return dict(error_message = '')

    @view_config(request_method='POST')
    def add_comment(self):
        params = self.request.params
        commenter_name = params.get('commenter_name')
        comment_text = params.get('comment_text')
        spambot = params.get('spambot')
        if spambot:
           message = 'Your comment could not be posted'
        elif comment_text == '' and commenter_name == '':
           message = 'Please enter your name and a comment'
        elif comment_text == '':
           message = 'Please enter a comment'
        elif commenter_name == '':
           message = 'Please enter your name'
        else: 
           pubdate = datetime.datetime.now()
           comment = self.request.registry.content.create(
               'Comment', commenter_name, comment_text, pubdate)
           self.context.add_comment(comment)
           return HTTPFound(location=self.request.resource_url(self.context))
           
        return dict(error_message=message)

@view_config(
    content_type='File',
    name='download',
    )
def download_attachment(context, request):
    f = context.blob.open()
    headers = [('Content-Type', str(context.mimetype)),
               ('Content-Disposition',
                    'attachment;filename=%s' % str(context.__name__)),
              ]
    response = Response(headerlist=headers, app_iter=f)
    return response

@view_defaults(
    content_type='Root',
    )
class FeedViews(object):
    def __init__(self, context, request):
        self.context = context
        self.request = request

    def _nowtz(self):
        now = datetime.datetime.utcnow() # naive
        y, mo, d, h, mi, s = now.timetuple()[:6]
        return datetime.datetime(y, mo, d, h, mi, s, tzinfo=pytz.utc)

    def _get_feed_info(self):
        context = self.context
        request = self.request
        feed = {"rss_url": request.application_url + "/rss.xml",
                "atom_url": request.application_url + "/index.atom",
                "blog_url": request.application_url,
                "title": context.sdi_title,
                "description": context.description,
                }

        def _add_updated_strings(updated, info):
            if getattr(updated, 'now', None) is None:
                y, mo, d, h, mi, s = updated.timetuple()[:6]
                updated = datetime.datetime(y, mo, d, h, mi, s, tzinfo=pytz.utc)
            info['updated_atom'] = updated.astimezone(pytz.utc).isoformat()
            info['updated_rss'] = updated.strftime('%a, %d %b %Y %H:%M:%S %z')

        blogentries = []
        for name, blogentry in context.items():
            if request.registry.content.istype(blogentry, 'Blog Entry'):
                updated = blogentry.pubdate
                info = {'url': resource_url(blogentry, request),
                        'title': blogentry.title,
                        'body': _getentrybody(blogentry.format,
                                              blogentry.entry),
                        'created': updated,
                        'pubdate': updated,
                       }
                _add_updated_strings(updated, info)
                blogentries.append((updated, info))
                
        blogentries.sort(key=lambda x: x[0].isoformat())
        blogentries = [entry[1] for entry in reversed(blogentries)][:15]
        updated = blogentries and blogentries[0]['pubdate'] or self._nowtz()
        _add_updated_strings(updated, feed)
        
        return feed, blogentries

    @view_config(
        name='rss.xml',
        renderer='templates/rss.pt',
        )
    def blog_rss(self):
        feed, blogentries = self._get_feed_info()
        self.request.response.content_type = 'application/rss+xml'
        return dict(
            feed = feed,
            blogentries = blogentries,
            )

    @view_config(
        name='index.atom',
        renderer='templates/atom.pt',
        )
    def blog_atom(self):
        feed, blogentries = self._get_feed_info()
        self.request.response.content_type = 'application/atom+xml'
        return dict(
            feed = feed,
            blogentries = blogentries,
            )

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# substanced documentation build configuration file
#
# This file is execfile()d with the current directory set to its containing
# dir.
#
# The contents of this file are pickled, so don't put values in the
# namespace that aren't pickleable (module imports are okay, they're
# removed automatically).
#
# All configuration values have a default value; values that are commented
# out serve to show the default value.

# If your extensions are in another directory, add it here. If the
# directory is relative to the documentation root, use os.path.abspath to
# make it absolute, like shown here.
#sys.path.append(os.path.abspath('some/directory'))


import sys, os, datetime

# Add and use Pylons theme
# if 'sphinx-build' in ' '.join(sys.argv): # protect against dumb importers
#     from subprocess import call, Popen, PIPE
#
#     p = Popen('which git', shell=True, stdout=PIPE)
#     git = p.stdout.read().strip()
#     cwd = os.getcwd()
#     _themes = os.path.join(cwd, '_themes')
#
#     if not os.path.isdir(_themes):
#         call([git, 'clone', 'git://github.com/Pylons/pylons_sphinx_theme.git',
#                 '_themes'])
#     else:
#         os.chdir(_themes)
#         call([git, 'checkout', 'master'])
#         call([git, 'pull'])
#         os.chdir(cwd)
#
#     sys.path.append(os.path.abspath('_themes'))

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.intersphinx',
    'repoze.sphinx.autointerface',
    ]

# Looks for pyramid's objects
intersphinx_mapping = {
    'pyramid':
    ('http://docs.pylonsproject.org/projects/pyramid/en/latest/', None),
}

# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# General substitutions.
project = 'substanced'
thisyear = datetime.datetime.now().year
copyright = '2011-%s, Agendaless Consulting' % thisyear

# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
#
# The short X.Y version.
version = '0.0'
# The full version, including alpha/beta/rc tags.
release = version

# There are two options for replacing |today|: either, you set today to
# some non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directories, that shouldn't be
# searched for source files.
#exclude_dirs = []

exclude_patterns = ['_themes/README.rst',]

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# Options for HTML output
# -----------------------

# Add and use Substance D theme
html_theme_path = ['_themes']
html_theme = 'substanced'
html_theme_options = dict(
    github_url='https://github.com/Pylons/substanced',
#    in_progress='true'
    )

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
# html_style = 'repoze.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as
# html_title.
#html_short_title = None

# The name of an image file (within the static path) to place at the top of
# the sidebar.
# html_logo = '.static/logo_hi.gif'

# The name of an image file (within the static path) to use as favicon of
# the docs.  This file should be a Windows icon file (.ico) being 16x16 or
# 32x32 pixels large.
html_favicon = '_themes/substanced/static/favicon.ico'

# Add any paths that contain custom static files (such as style sheets)
# here, relative to this directory. They are copied after the builtin
# static files, so a file named "default.css" will overwrite the builtin
# "default.css".
#html_static_path = ['.static']

# If not '', a 'Last updated on:' timestamp is inserted at every page
# bottom, using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = False

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as
# _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages
# will contain a <link> tag referring to it.  The value of this option must
# be the base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'atemplatedoc'


# Options for LaTeX output
# ------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, document class [howto/manual]).
latex_documents = [
  ('index', 'substanced.tex', 'Substance D Documentation',
   'Repoze Developers', 'manual'),
]

# The name of an image file (relative to this directory) to place at the
# top of the title page.
#latex_logo = '.static/logo_hi.gif'

# For "manual" documents, if this is true, then toplevel headings are
# parts, not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = substanced_theme_support
# -*- coding: utf-8 -*-
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class SubstanceDStyle(Style):
    """
    SubstanceD pygments style based on friendly style
    """

    # work in progress...

    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        Whitespace:                "#bbbbbb",
        Comment:                   "italic #60a0b0",
        Comment.Preproc:           "noitalic #007020",
        Comment.Special:           "noitalic bg:#fff0f0",

        Keyword:                   "bold #007020",
        Keyword.Pseudo:            "nobold",
        Keyword.Type:              "nobold #902000",

        Operator:                  "#666666",
        Operator.Word:             "bold #007020",

        Name.Builtin:              "#007020",
        Name.Function:             "#06287e",
        Name.Class:                "bold #0e84b5",
        Name.Namespace:            "bold #0e84b5",
        Name.Exception:            "#007020",
        Name.Variable:             "#bb60d5",
        Name.Constant:             "#60add5",
        Name.Label:                "bold #002070",
        Name.Entity:               "bold #d55537",
        Name.Attribute:            "#0e84b5",
        Name.Tag:                  "bold #062873",
        Name.Decorator:            "bold #555555",

        String:                    "#4070a0",
        String.Doc:                "italic",
        String.Interpol:           "italic #70a0d0",
        String.Escape:             "bold #4070a0",
        String.Regex:              "#235388",
        String.Symbol:             "#517918",
        String.Other:              "#c65d09",
        Number:                    "#40a070",

        Generic.Heading:           "bold #000080",
        Generic.Subheading:        "bold #800080",
        Generic.Deleted:           "#A00000",
        Generic.Inserted:          "#00A000",
        Generic.Error:             "#FF0000",
        Generic.Emph:              "italic",
        Generic.Strong:            "bold",
        Generic.Prompt:            "bold #c65d09",
        Generic.Output:            "#888",
        Generic.Traceback:         "#04D",

        Error:                     "#a40000 bg:#fbe3e4"
    }


class SubstanceDBWStyle(Style):

    background_color = "#ffffff"
    default_style = "bw"

    styles = {
        Error:                     ""
    }


########NEW FILE########
__FILENAME__ = evolve
from substanced.audit import (
    AuditLog,
    set_auditlog,
    )
from substanced.util import postorder

def remove_bogus_auditlogs(root):
    i = 0
    # Blow away even the root auditlog, as it will have references to
    # AuditLogEntry objects that inherit from Persistent
    for resource in postorder(root):
        i += 1
        if hasattr(resource, '__auditlog__'):
            del resource.__auditlog__
        resource._p_deactivate()
        if i % 1000 == 0:
            resource._p_jar.cacheGC()

def add_root_auditlog(root):
    root.__auditlog__ = AuditLog()

def use_external_db(root):
    if hasattr(root, '__auditlog__'):
        del root.__auditlog__
    set_auditlog(root)
        
def includeme(config):
    config.add_evolution_step(remove_bogus_auditlogs)
    config.add_evolution_step(add_root_auditlog)
    config.add_evolution_step(use_external_db)


########NEW FILE########
__FILENAME__ = subscribers
from pyramid.threadlocal import get_current_request
from pyramid.traversal import resource_path

from substanced.event import (
    subscribe_acl_modified,
    subscribe_will_be_removed,
    subscribe_added,
    subscribe_modified,
    subscribe_logged_in,
    subscribe_root_added,
    )

from substanced.util import (
    get_oid,
    postorder,
    get_auditlog,
    )

from . import set_auditlog

def _get_userinfo():
    request = get_current_request()
    user = getattr(request, 'user', None)
    userid = get_oid(user, None)
    username = getattr(user, '__name__', None)
    return {'oid':userid, 'name':username}

def _add_record(event_name, event, objects):
    log = get_auditlog(event.parent)
    if log is None:
        return
    userinfo = _get_userinfo()
    object_name = event.name
    for obj in objects:
        content_type = str(event.registry.content.typeof(obj))
        parent = obj.__parent__
        folder_path = resource_path(parent)
        folder_oid = get_oid(parent, None)
        object_oid = get_oid(obj, None)
        log.add(
            event_name,
            folder_oid, # this is an event related to the *container*
            object_oid=object_oid,
            folder_oid=folder_oid,
            folder_path=folder_path,
            object_name=object_name,
            content_type=content_type,
            userinfo=userinfo,
            )

@subscribe_acl_modified()
def acl_modified(event):
    """ Generates ACLModified audit events """
    log = get_auditlog(event.object)
    if log is None:
        return
    userinfo = _get_userinfo()
    oid = get_oid(event.object, None)
    old_acl = str(event.old_acl)
    new_acl = str(event.new_acl)
    path = resource_path(event.object)
    content_type = str(event.registry.content.typeof(event.object))
    log.add(
        'ACLModified',
        oid,
        object_path=path,
        old_acl=old_acl,
        new_acl=new_acl,
        userinfo=userinfo,
        content_type=content_type,
        )

@subscribe_added()
def content_added_moved_or_duplicated(event):
    """ Generates ContentAdded (and ContentMoved/ContentDuplicated)
    audit events """
    if event.moving is not None:
        return _add_record('ContentMoved', event, [event.object])
    elif event.duplicating is not None:
        return _add_record('ContentDuplicated', event, [event.object])
    else:
        return _add_record('ContentAdded', event, postorder(event.object))

@subscribe_will_be_removed()
def content_removed(event):
    """ Generates ContentRemoved audit events """
    if event.moving is not None:
        return # content_moved action is is handled by content_added_moved...
    return _add_record('ContentRemoved', event, [event.object])

@subscribe_modified()
def content_modified(event):
    log = get_auditlog(event.object)
    if log is None:
        return
    userinfo = _get_userinfo()
    oid = get_oid(event.object, None)
    object_path = resource_path(event.object)
    content_type = str(event.registry.content.typeof(event.object))
    log.add(
        'ContentModified',
        oid,
        object_oid=oid,
        object_path=object_path,
        content_type=content_type,
        userinfo=userinfo,
        )

@subscribe_logged_in()
def logged_in(event):
    context = event.request.context # event.context may be HTTPForbidden
    log = get_auditlog(context)
    if log is None:
        return
    user_oid = get_oid(event.user, None)
    log.add('LoggedIn', None, login=event.login, user_oid=user_oid)

@subscribe_root_added()
def root_added(event):
    """ Add an audit log to the audit connection root object; we cannot do this
    until the root object has a connection, therefore we subscribe to the root
    added event """
    root = event.object
    set_auditlog(root)

    

########NEW FILE########
__FILENAME__ = test_init
import unittest
from pyramid import testing

class AuditLogEntryTests(unittest.TestCase):
    def test_it(self):
        from .. import AuditLogEntry
        entry = AuditLogEntry('name', 'oid', 'payload', 'timestamp')
        self.assertEqual(entry.name, 'name')
        self.assertEqual(entry.oid, 'oid')
        self.assertEqual(entry.payload, 'payload')
        self.assertEqual(entry.timestamp, 'timestamp')

class AuditLogTests(unittest.TestCase):
    def _makeOne(self, max_layers=2, layer_size=2, entries=None):
        from .. import AuditLog
        return AuditLog(max_layers, layer_size, entries=entries)

    def test_add(self):
        import json
        entries = DummyAppendStack()
        inst = self._makeOne(entries=entries)
        inst.add('name', 1, a=1)
        self.assertEqual(len(entries.pushed), 1)
        pushed = entries.pushed[0]
        self.assertTrue(pushed.timestamp)
        self.assertEqual(pushed.oid, 1)
        self.assertEqual(pushed.name, 'name')
        payload = json.loads(pushed.payload)
        self.assertEqual(payload['a'], 1)

    def test_newer(self):
        entry = DummyAuditLogEntry()
        entries = DummyAppendStack([(0, 0, entry)])
        inst = self._makeOne(entries=entries)
        result = list(inst.newer(0, 0))
        self.assertEqual(result, [(0, 0, entry)])
        
    def test_newer_with_oid_filter(self):
        entry = DummyAuditLogEntry()
        entries = DummyAppendStack([(0, 0, entry)])
        inst = self._makeOne(entries=entries)
        result = list(inst.newer(0, 0, 2))
        self.assertEqual(result, [])

    def test_newer_with_oid_multifilter(self):
        entry = DummyAuditLogEntry()
        entries = DummyAppendStack([(0, 0, entry)])
        inst = self._makeOne(entries=entries)
        result = list(inst.newer(0, 0, [1, 2]))
        self.assertEqual(result, [(0, 0, entry)])

    def test_latest_id(self):
        entries = DummyAppendStack()
        inst = self._makeOne(entries=entries)
        self.assertEqual(inst.latest_id(), (0, 0))

    def test___len__(self):
        entry = DummyAuditLogEntry()
        entries = DummyAppendStack([(0, 0, entry)])
        inst = self._makeOne(entries=entries)
        result = len(inst)
        self.assertEqual(result, 1)

    def test___bool__(self):
        inst = self._makeOne()
        result = bool(inst)
        self.assertEqual(result, True)

    def test___iter__(self):
        entry = DummyAuditLogEntry()
        entries = DummyAppendStack([(0, 0, entry)])
        inst = self._makeOne(entries=entries)
        result = list(inst)
        self.assertEqual(result, [(0, 0, entry)])
        
class LayerTests(unittest.TestCase):

    def _getTargetClass(self):
        from .. import Layer
        return Layer

    def _makeOne(self, *args, **kw):
        return self._getTargetClass()(*args, **kw)

    def test_ctor_defaults(self):
        layer = self._makeOne()
        self.assertEqual(layer._max_length, 100)
        self.assertTrue(type(layer._stack) is list)
        self.assertEqual(layer._generation, 0)

    def test_ctor_w_positional(self):
        layer = self._makeOne(4, 14)
        self.assertEqual(layer._max_length, 4)
        self.assertTrue(type(layer._stack) is list)
        self.assertEqual(layer._generation, 14)

    def test_ctor_w_max_length(self):
        layer = self._makeOne(max_length=14)
        self.assertEqual(layer._max_length, 14)

    def test_ctor_w_generation(self):
        layer = self._makeOne(generation=12)
        self.assertEqual(layer._generation, 12)

    def test___iter___empty(self):
        layer = self._makeOne()
        self.assertEqual(list(layer), [])

    def test_newer_empty(self):
        layer = self._makeOne()
        self.assertEqual(list(layer.newer(0)), [])


    def test___iter___filled(self):
        layer = self._makeOne()
        OBJ1 = object()
        OBJ2 = object()
        OBJ3 = object()
        layer.push(OBJ1)
        layer.push(OBJ2)
        layer.push(OBJ3)
        self.assertEqual(list(layer), [(0, OBJ1), (1, OBJ2), (2, OBJ3)])

    def test_newer_miss(self):
        layer = self._makeOne()
        layer.push(object())
        self.assertEqual(list(layer.newer(0)), [])

    def test_newer_hit(self):
        layer = self._makeOne()
        OBJ1 = object()
        OBJ2 = object()
        OBJ3 = object()
        layer.push(OBJ1)
        layer.push(OBJ2)
        layer.push(OBJ3)
        self.assertEqual(list(layer.newer(0)),
                         [(1, OBJ2), (2, OBJ3)])

    def test_push_one(self):
        layer = self._makeOne()
        OBJ = object()
        layer.push(OBJ)
        self.assertEqual(list(layer), [(0, OBJ)])

    def test_push_many(self):
        layer = self._makeOne()
        OBJ1, OBJ2, OBJ3 = object(), object(), object()
        layer.push(OBJ1)
        layer.push(OBJ2)
        layer.push(OBJ3)
        self.assertEqual(list(layer), [(0, OBJ1),
                                       (1, OBJ2),
                                       (2, OBJ3),
                                      ])

    def test_push_overflow(self):
        from .. import LayerFull
        layer = self._makeOne(2)
        OBJ1, OBJ2, OBJ3 = object(), object(), object()
        layer.push(OBJ1)
        layer.push(OBJ2)
        self.assertRaises(LayerFull, layer.push, OBJ3)
        self.assertEqual(list(layer), [(0, OBJ1),
                                       (1, OBJ2),
                                      ])


class AppendStackTests(unittest.TestCase):

    def _getTargetClass(self):
        from .. import AppendStack
        return AppendStack

    def _makeOne(self, *args, **kw):
        return self._getTargetClass()(*args, **kw)

    def test_ctor_defaults(self):
        stack = self._makeOne()
        self.assertEqual(stack._max_layers, 10)
        self.assertEqual(stack._max_length, 100)

    def test_ctor_w_max_layers(self):
        stack = self._makeOne(max_layers=37)
        self.assertEqual(stack._max_layers, 37)

    def test_ctor_w_max_length(self):
        stack = self._makeOne(max_length=14)
        self.assertEqual(stack._max_length, 14)

    def test___iter___empty(self):
        stack = self._makeOne()
        self.assertEqual(list(stack), [])

    def test___len__(self):
        inst = self._makeOne()
        result = len(inst)
        self.assertEqual(result, 0)

    def test___bool__(self):
        inst = self._makeOne()
        result = bool(inst)
        self.assertEqual(result, True)
        
    def test_newer_empty(self):
        stack = self._makeOne()
        self.assertEqual(list(stack.newer(0, 0)), [])

    def test_newer_miss(self):
        stack = self._makeOne()
        stack.push(object())
        self.assertEqual(list(stack.newer(0, 0)), [])

    def test_newer_hit(self):
        stack = self._makeOne()
        OBJ1 = object()
        OBJ2 = object()
        OBJ3 = object()
        stack.push(OBJ1)
        stack.push(OBJ2)
        stack.push(OBJ3)
        result = list(stack.newer(0, 0))
        self.assertEqual(result, [(0, 1, OBJ2), (0, 2, OBJ3)])

    def test_newer_hit_across_layers(self):
        stack = self._makeOne(max_length=2)
        OBJ1 = object()
        OBJ2 = object()
        OBJ3 = object()
        stack.push(OBJ1)
        stack.push(OBJ2)
        stack.push(OBJ3)
        result = list(stack.newer(0, 0))
        self.assertEqual(result, [(0, 1, OBJ2), (1, 0, OBJ3)])

    def test_push_one(self):
        stack = self._makeOne()
        OBJ = object()
        stack.push(OBJ)
        self.assertEqual(list(stack), [(0, 0, OBJ)])
        self.assertEqual(len(stack._layers), 1)

    def test_push_many(self):
        stack = self._makeOne(max_length=2)
        OBJ1, OBJ2, OBJ3 = object(), object(), object()
        stack.push(OBJ1)
        stack.push(OBJ2)
        stack.push(OBJ3)
        self.assertEqual(
            list(stack), [(0, 0, OBJ1), (0, 1, OBJ2), (1, 0, OBJ3)]
            )
        self.assertEqual(len(stack._layers), 2)
        self.assertEqual(stack._layers[0]._generation, 0)
        self.assertEqual(stack._layers[1]._generation, 1)

    def test_push_trimming_layers(self):
        stack = self._makeOne(max_layers=4)
        for obj in range(1001):
            stack.push(obj)
        found = list(stack)
        self.assertEqual(len(found), 301)
        self.assertEqual(found[0], (7, 0, 700))
        self.assertEqual(found[-1], (10, 0, 1000))
        self.assertEqual(len(stack._layers), 4)
        self.assertEqual(stack._layers[0]._generation, 7)
        self.assertEqual(stack._layers[1]._generation, 8)
        self.assertEqual(stack._layers[2]._generation, 9)
        self.assertEqual(stack._layers[3]._generation, 10)

    def test_push_trimming_layers_with_archive_utility(self):
        _pruned = {}
        def _prune(generation, items):
            _pruned[generation] = items
        stack = self._makeOne(max_layers=4)
        for obj in range(1001):
            stack.push(obj, pruner=_prune)
        found = list(stack)
        self.assertEqual(len(found), 301)
        self.assertEqual(found[0], (7, 0, 700))
        self.assertEqual(found[-1], (10, 0, 1000))
        self.assertEqual(len(stack._layers), 4)
        self.assertEqual(stack._layers[0]._generation, 7)
        self.assertEqual(stack._layers[1]._generation, 8)
        self.assertEqual(stack._layers[2]._generation, 9)
        self.assertEqual(stack._layers[3]._generation, 10)
        self.assertEqual(len(_pruned), 7)
        self.assertEqual(_pruned[0], list(range(0, 100)))
        self.assertEqual(_pruned[1], list(range(100, 200)))
        self.assertEqual(_pruned[2], list(range(200, 300)))
        self.assertEqual(_pruned[3], list(range(300, 400)))
        self.assertEqual(_pruned[4], list(range(400, 500)))
        self.assertEqual(_pruned[5], list(range(500, 600)))
        self.assertEqual(_pruned[6], list(range(600, 700)))

    def test___getstate___empty(self):
        stack = self._makeOne()
        self.assertEqual(stack.__getstate__(), (10, 100, [(0, [])]))

    def test___getstate___filled(self):
        stack = self._makeOne(2, 3)
        for i in range(10):
            stack.push(i)
        self.assertEqual(stack.__getstate__(),
                        (2, 3, [(2, [6, 7, 8]), (3, [9])])
                         )

    def test___setstate___(self):
        stack = self._makeOne()
        STATE = (2,                 # _max_layers
                 3,                 # _max_length
                 [(2, [9]),        # _layers[0] as (generation, list)
                  (3, [6, 7, 8]),  # _layers[1] as (generation, list)
                 ],
                )
        stack.__setstate__(STATE)
        self.assertEqual(stack._max_layers, 2)
        self.assertEqual(stack._max_length, 3)
        self.assertEqual(list(stack), [(2, 0, 9),
                                       (3, 0, 6),
                                       (3, 1, 7),
                                       (3, 2, 8),
                                      ])

    def test__p_resolveConflict_mismatched_max_layers(self):
        from ZODB.POSException import ConflictError
        O_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9]),        # _layers[1] as (generation, list)
                   ],
                )
        C_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9]),        # _layers[1] as (generation, list)
                   ],
                )
        N_STATE = (3,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9]),        # _layers[1] as (generation, list)
                   ],
                )
        stack = self._makeOne()
        self.assertRaises(ConflictError, stack._p_resolveConflict,
                          O_STATE, C_STATE, N_STATE)

    def test__p_resolveConflict_mismatched_max_length(self):
        from ZODB.POSException import ConflictError
        O_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9]),        # _layers[1] as (generation, list)
                   ],
                )
        C_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9]),        # _layers[1] as (generation, list)
                   ],
                )
        N_STATE = (2,                 # _max_layers
                   2,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9]),        # _layers[1] as (generation, list)
                   ],
                )
        stack = self._makeOne()
        self.assertRaises(ConflictError, stack._p_resolveConflict,
                          O_STATE, C_STATE, N_STATE)

    def test__p_resolveConflict_old_latest_commited_earliest(self):
        from ZODB.POSException import ConflictError
        O_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9]),        # _layers[1] as (generation, list)
                   ],
                )
        C_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (4, [26, 27, 28]),  # _layers[0] as (generation, list)
                    (5, [29]),        # _layers[1] as (generation, list)
                   ],
                )
        N_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9, 10]),    # _layers[1] as (generation, list)
                   ],
                )
        stack = self._makeOne()
        self.assertRaises(ConflictError, stack._p_resolveConflict,
                          O_STATE, C_STATE, N_STATE)

    def test__p_resolveConflict_old_latest_new_earliest(self):
        from ZODB.POSException import ConflictError
        O_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9]),        # _layers[1] as (generation, list)
                   ],
                )
        C_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9, 10]),    # _layers[1] as (generation, list)
                   ],
                )
        N_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (4, [26, 27, 28]),  # _layers[0] as (generation, list)
                    (5, [29]),        # _layers[1] as (generation, list)
                   ],
                )
        stack = self._makeOne()
        self.assertRaises(ConflictError, stack._p_resolveConflict,
                          O_STATE, C_STATE, N_STATE)

    def test__p_resolveConflict_no_added_layers(self):
        O_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9]),        # _layers[1] as (generation, list)
                   ],
                )
        C_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9, 10]),    # _layers[1] as (generation, list)
                   ],
                )
        N_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9, 11]),    # _layers[1] as (generation, list)
                   ],
                )
        M_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9, 10, 11]),# _layers[1] as (generation, list)
                   ],
                )
        stack = self._makeOne()
        merged = stack._p_resolveConflict(O_STATE, C_STATE, N_STATE)
        self.assertEqual(merged, M_STATE)

    def test__p_resolveConflict_added_committed_layer(self):
        O_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9]),        # _layers[1] as (generation, list)
                   ],
                )
        C_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (3, [9, 10, 11]),# _layers[0] as (generation, list)
                    (4, [12]),       # _layers[1] as (generation, list)
                   ],
                )
        N_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9, 13]),    # _layers[1] as (generation, list)
                   ],
                )
        M_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (3, [9, 10, 11]),# _layers[0] as (generation, list)
                    (4, [12, 13]),   # _layers[1] as (generation, list)
                   ],
                )
        stack = self._makeOne()
        merged = stack._p_resolveConflict(O_STATE, C_STATE, N_STATE)
        self.assertEqual(merged, M_STATE)

    def test__p_resolveConflict_added_new_layer(self):
        O_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9]),        # _layers[1] as (generation, list)
                   ],
                )
        C_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (2, [6, 7, 8]),  # _layers[0] as (generation, list)
                    (3, [9, 10]),    # _layers[1] as (generation, list)
                   ],
                )
        N_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (3, [9, 11, 12]),# _layers[0] as (generation, list)
                    (4, [13, 14]),   # _layers[1] as (generation, list)
                   ],
                )
        M_STATE = (2,                 # _max_layers
                   3,                 # _max_length
                   [
                    (3, [9, 10, 11]),# _layers[0] as (generation, list)
                    (4, [12, 13, 14]),# _layers[1] as (generation, list)
                   ],
                )
        stack = self._makeOne()
        merged = stack._p_resolveConflict(O_STATE, C_STATE, N_STATE)
        self.assertEqual(merged, M_STATE)

class Test_set_auditlog(unittest.TestCase):
    def _callFUT(self, context):
        from .. import set_auditlog
        return set_auditlog(context)
    
    def test_it_keyerror(self):
        conn = DummyConnection(KeyError)
        context = testing.DummyResource()
        context._p_jar = conn
        self.assertEqual(self._callFUT(context), None)

    def test_it_auditlog_exists(self):
        root = {'auditlog':True}
        conn = DummyConnection(root=root)
        context = testing.DummyResource()
        context._p_jar = conn
        self.assertEqual(self._callFUT(context), None)
        self.assertEqual(root['auditlog'], True)

    def test_it_auditlog_notexists(self):
        root = {}
        conn = DummyConnection(root=root)
        context = testing.DummyResource()
        context._p_jar = conn
        self.assertEqual(self._callFUT(context), None)
        self.assertTrue('auditlog' in root)
        
class DummyConnection(object):
    def __init__(self, conn=None, root=None):
        if root is None:
            root = {}
        self._conn = conn
        self._root = root

    def get_connection(self, name):
        if self._conn is KeyError:
            raise KeyError
        return self

    def root(self):
        return self._root


class DummyLayer(object):
    _generation = 0
    _stack = (1,)

class DummyAppendStack(object):
    def __init__(self, result=None):
        self.pushed = []
        self.result = result
        self._layers = [DummyLayer()]

    def __len__(self):
        return len(self.result)

    def __iter__(self):
        return iter(self.result)
        
    def push(self, entry):
        self.pushed.append(entry)

    def newer(self, generation, index_id):
        return self.result

class DummyAuditLogEntry(object):
    oid = 1
    

########NEW FILE########
__FILENAME__ = test_subscribers
import json
import unittest
from pyramid import testing
import mock

class Test_acl_modified(unittest.TestCase):
    def setUp(self):
        self.request = testing.DummyRequest()
        self.config = testing.setUp(request=self.request)

    def tearDown(self):
        testing.tearDown()
        
    def _callFUT(self, event):
        from ..subscribers import acl_modified
        return acl_modified(event)

    @mock.patch('substanced.audit.subscribers.get_auditlog')
    def test_it(self, mock_get_auditlog):
        from substanced.audit import AuditLog
        self.request.user = Dummy({'__oid__':1, '__name__':'fred'})
        event = Dummy()
        context = testing.DummyResource()
        auditlog = AuditLog()
        mock_get_auditlog.side_effect = lambda c: auditlog
        context.__oid__ = 5
        event.registry = _makeRegistry()
        event.object = context
        event.old_acl = 'old_acl'
        event.new_acl = 'new_acl'
        self._callFUT(event)
        self.assertEqual(len(auditlog), 1)
        entries = list(auditlog.entries)
        entry = entries[0]
        self.assertEqual(entry[0], 0)
        self.assertEqual(entry[1], 0)
        self.assertEqual(entry[2].name, 'ACLModified')
        self.assertEqual(entry[2].oid, 5)
        self.assertEqual(
            json.loads(entry[2].payload),
            {
                'time':entry[2].timestamp,
                'old_acl': 'old_acl',
                'new_acl': 'new_acl',
                'userinfo':{'oid':1, 'name':'fred'},
                'object_path':'/',
                'content_type':'SteamingPile'
             }

            )

    @mock.patch('substanced.audit.subscribers.get_auditlog')
    def test_it_nolog(self, mock_get_auditlog):
        mock_get_auditlog.side_effect = lambda c: None
        event = Dummy()
        context = testing.DummyResource()
        context.__oid__ = 5
        event.object = context
        self.assertEqual(self._callFUT(event), None)

_marker = object()

class Test_content_added_moved_or_duplicated(unittest.TestCase):
    def setUp(self):
        self.request = testing.DummyRequest()
        self.config = testing.setUp(request=self.request)

    def tearDown(self):
        testing.tearDown()
        
    def _callFUT(self, event):
        from ..subscribers import content_added_moved_or_duplicated
        return content_added_moved_or_duplicated(event)

    @mock.patch('substanced.audit.subscribers.get_auditlog')
    def test_it_added(self, mock_get_auditlog):
        auditlog = _makeAuditLog()
        mock_get_auditlog.side_effect = lambda c: auditlog
        self.request.user = Dummy({'__oid__':1, '__name__':'fred'})
        event = _makeEvent()
        self._callFUT(event)
        self.assertEqual(len(auditlog), 1)
        entries = list(auditlog.entries)
        entry = entries[0]
        self.assertEqual(entry[0], 0)
        self.assertEqual(entry[1], 0)
        self.assertEqual(entry[2].name, 'ContentAdded')
        self.assertEqual(entry[2].oid, 10)
        self.assertEqual(
            json.loads(entry[2].payload),
            {
                'folder_path': '/',
                'folder_oid': 10,
                'object_name': 'objectname',
                'userinfo': {'oid': 1, 'name': 'fred'},
                'content_type': 'SteamingPile',
                'time': entry[2].timestamp,
                'object_oid': 5

                }
            )

    @mock.patch('substanced.audit.subscribers.get_auditlog')
    def test_it_added_noscribe(self, mock_get_auditlog):
        mock_get_auditlog.side_effect = lambda c: None
        event = _makeEvent()
        self._callFUT(event) # does not throw an exception
        
    @mock.patch('substanced.audit.subscribers.get_auditlog')
    def test_it_moved(self, mock_get_auditlog):
        auditlog = _makeAuditLog()
        mock_get_auditlog.side_effect = lambda c: auditlog
        self.request.user = Dummy({'__oid__':1, '__name__':'fred'})
        event = _makeEvent()
        event.moving = True
        event.duplicating = None
        self._callFUT(event)
        self.assertEqual(len(auditlog), 1)
        entries = list(auditlog.entries)
        entry = entries[0]
        self.assertEqual(entry[0], 0)
        self.assertEqual(entry[1], 0)
        self.assertEqual(entry[2].name, 'ContentMoved')
        self.assertEqual(entry[2].oid, 10)
        self.assertEqual(
            json.loads(entry[2].payload),
            {
                'folder_path': '/',
                'folder_oid': 10,
                'object_name': 'objectname',
                'userinfo': {'oid': 1, 'name': 'fred'},
                'content_type': 'SteamingPile',
                'time': entry[2].timestamp,
                'object_oid': 5

                }
            )

    @mock.patch('substanced.audit.subscribers.get_auditlog')
    def test_it_duplicated(self, mock_get_auditlog):
        auditlog = _makeAuditLog()
        mock_get_auditlog.side_effect = lambda c: auditlog
        self.request.user = Dummy({'__oid__':1, '__name__':'fred'})
        event = _makeEvent()
        event.moving = None
        event.duplicating = True
        self._callFUT(event)
        self.assertEqual(len(auditlog), 1)
        entries = list(auditlog.entries)
        entry = entries[0]
        self.assertEqual(entry[0], 0)
        self.assertEqual(entry[1], 0)
        self.assertEqual(entry[2].name, 'ContentDuplicated')
        self.assertEqual(entry[2].oid, 10)
        self.assertEqual(
            json.loads(entry[2].payload),
            {
                'folder_path': '/',
                'folder_oid': 10,
                'object_name': 'objectname',
                'userinfo': {'oid': 1, 'name': 'fred'},
                'content_type': 'SteamingPile',
                'time': entry[2].timestamp,
                'object_oid': 5

                }
            )
        
class Test_content_removed(unittest.TestCase):
    def setUp(self):
        self.request = testing.DummyRequest()
        self.config = testing.setUp(request=self.request)

    def tearDown(self):
        testing.tearDown()
        
    def _callFUT(self, event):
        from ..subscribers import content_removed
        return content_removed(event)
    
    def test_it_moving(self):
        event = Dummy()
        event.moving = True
        self.assertEqual(self._callFUT(event), None)

    @mock.patch('substanced.audit.subscribers.get_auditlog')
    def test_it(self, mock_get_auditlog):
        auditlog = _makeAuditLog()
        mock_get_auditlog.side_effect = lambda c: auditlog
        self.request.user = Dummy({'__oid__':1, '__name__':'fred'})
        event = _makeEvent()
        event.moving = None
        event.duplicating = None
        self._callFUT(event)
        self.assertEqual(len(auditlog), 1)
        entries = list(auditlog.entries)
        entry = entries[0]
        self.assertEqual(entry[0], 0)
        self.assertEqual(entry[1], 0)
        self.assertEqual(entry[2].name, 'ContentRemoved')
        self.assertEqual(entry[2].oid, 10)
        self.assertEqual(
            json.loads(entry[2].payload),
            {
                'folder_path': '/',
                'folder_oid': 10,
                'object_name': 'objectname',
                'userinfo': {'oid': 1, 'name': 'fred'},
                'content_type': 'SteamingPile',
                'time': entry[2].timestamp,
                'object_oid': 5

                }
            )

    
        
class Test_content_modified(unittest.TestCase):
    def setUp(self):
        self.request = testing.DummyRequest()
        self.config = testing.setUp(request=self.request)

    def tearDown(self):
        testing.tearDown()
        
    def _callFUT(self, event):
        from ..subscribers import content_modified
        return content_modified(event)

    @mock.patch('substanced.audit.subscribers.get_auditlog')
    def test_it_noscribe(self, mock_get_auditlog):
        mock_get_auditlog.side_effect = lambda c: None
        event = Dummy()
        context = testing.DummyResource()
        event.object = context
        self.assertEqual(self._callFUT(event), None)
        
    @mock.patch('substanced.audit.subscribers.get_auditlog')
    def test_it(self, mock_get_auditlog):
        auditlog = _makeAuditLog()
        mock_get_auditlog.side_effect = lambda c: auditlog
        self.request.user = Dummy({'__oid__':1, '__name__':'fred'})
        event = Dummy()
        context = testing.DummyResource()
        context.__oid__ = 5
        event.registry = _makeRegistry()
        event.object = context
        self._callFUT(event)
        self.assertEqual(len(auditlog), 1)
        entries = list(auditlog.entries)
        entry = entries[0]
        self.assertEqual(entry[0], 0)
        self.assertEqual(entry[1], 0)
        self.assertEqual(entry[2].name, 'ContentModified')
        self.assertEqual(entry[2].oid, 5)
        self.assertEqual(
            json.loads(entry[2].payload),
            {
                'object_oid': 5,
                'userinfo': {'oid': 1, 'name': 'fred'},
                'content_type': 'SteamingPile',
                'object_path': '/',
                'time': entry[2].timestamp,
                },
            )

class Test_logged_in(unittest.TestCase):
    def setUp(self):
        self.request = testing.DummyRequest()
        self.config = testing.setUp(request=self.request)

    def tearDown(self):
        testing.tearDown()
        
    def _callFUT(self, event):
        from ..subscribers import logged_in
        return logged_in(event)

    @mock.patch('substanced.audit.subscribers.get_auditlog')
    def test_it_noscribe(self, mock_get_auditlog):
        mock_get_auditlog.side_effect = lambda c: None
        event = Dummy()
        event.request = Dummy()
        context = testing.DummyResource()
        event.request.context = context
        self.assertEqual(self._callFUT(event), None)

    @mock.patch('substanced.audit.subscribers.get_auditlog')
    def test_it_user_has_oid(self, mock_get_auditlog):
        auditlog = _makeAuditLog()
        mock_get_auditlog.side_effect = lambda c: auditlog
        event = Dummy()
        event.request = Dummy()
        context = testing.DummyResource()
        event.request.context = context
        user = Dummy()
        user.__oid__ = 5
        event.user = user
        event.login = 'login'
        self._callFUT(event)
        self.assertEqual(len(auditlog), 1)
        entries = list(auditlog.entries)
        entry = entries[0]
        self.assertEqual(entry[0], 0)
        self.assertEqual(entry[1], 0)
        self.assertEqual(entry[2].name, 'LoggedIn')
        self.assertEqual(entry[2].oid, None)
        self.assertEqual(
            json.loads(entry[2].payload),
            {
                'user_oid': 5,
                'login': 'login',
                'time': entry[2].timestamp,
                },
            )

    @mock.patch('substanced.audit.subscribers.get_auditlog')
    def test_it_user_has_no_oid(self, mock_get_auditlog):
        auditlog = _makeAuditLog()
        mock_get_auditlog.side_effect = lambda c: auditlog
        event = Dummy()
        event.request = Dummy()
        context = testing.DummyResource()
        event.request.context = context
        user = Dummy()
        event.user = user
        event.login = 'login'
        self._callFUT(event)
        self.assertEqual(len(auditlog), 1)
        entries = list(auditlog.entries)
        entry = entries[0]
        self.assertEqual(entry[0], 0)
        self.assertEqual(entry[1], 0)
        self.assertEqual(entry[2].name, 'LoggedIn')
        self.assertEqual(entry[2].oid, None)
        self.assertEqual(
            json.loads(entry[2].payload),
            {
                'user_oid': None,
                'login': 'login',
                'time': entry[2].timestamp,
                },
            )

class Test_root_added(unittest.TestCase):
    def _callFUT(self, event):
        from ..subscribers import root_added
        return root_added(event)

    @mock.patch('substanced.audit.subscribers.set_auditlog')
    def test_it(self, mock_set_auditlog):
        event = Dummy()
        root = Dummy()
        def is_set(_root):
            self.assertEqual(_root,  root)
        mock_set_auditlog.side_effect = is_set
        event.object = root
        self._callFUT(event)
        
class Dummy(object):
    def __init__(self, kw=None):
        if kw:
            self.__dict__.update(kw)

class DummyContentRegistry(object):
    def typeof(self, content):
        return 'SteamingPile'
    
def _makeAuditLog():
    from substanced.audit import AuditLog
    auditlog = AuditLog()
    return auditlog

def _makeRegistry():
    registry = Dummy()
    registry.content = DummyContentRegistry()
    return registry

def _makeEvent():
    event = Dummy()
    event.moving = None
    event.duplicating = None
    event.parent = testing.DummyResource()
    event.parent.__oid__ = 10
    event.name = 'objectname'
    context = testing.DummyResource()
    context.__oid__ = 5
    context.__parent__ = event.parent
    event.registry = _makeRegistry()
    event.object = context
    event.old_acl = 'old_acl'
    event.new_acl = 'new_acl'
    return event


########NEW FILE########
__FILENAME__ = test_views
import unittest
from pyramid import testing

class Test_AuditLogEventStreamView(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..views import AuditLogEventStreamView
        view = AuditLogEventStreamView(context, request)
        view.logger = DummyLogger()
        return view

    def test_ctor(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        self.assertEqual(inst.context, context)
        self.assertEqual(inst.request, request)

    def test_auditstream_sse_no_auditlog(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.GET = GetAllDict()
        inst = self._makeOne(context, request)
        inst.get_auditlog = lambda c: None
        response = inst.auditstream_sse()
        self.assertEqual(response.detail, 'Auditing not configured')
        
    def test_auditstream_sse_no_last_event_id(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.GET = GetAllDict()
        inst = self._makeOne(context, request)
        inst.get_auditlog = lambda c: DummyAuditLog()
        response = inst.auditstream_sse()
        self.assertEqual(response.text, 'id: 0-1\nretry: 10000\ndata: \n\n')

    def test_auditstream_sse_with_last_event_id(self):
        context = testing.DummyResource()
        context.__oid__ = 5
        request = testing.DummyRequest()
        request.headers['Last-Event-Id'] = '1-1'
        request.GET = GetAllDict()
        inst = self._makeOne(context, request)
        auditlog = DummyAuditLog()
        inst.get_auditlog = lambda c: auditlog
        response = inst.auditstream_sse()
        self.assertEqual(
            response.text,
            ('id: 0-1\nevent: smellin\nretry: 10000\ndata: payload1\n\n'
             'id: 0-2\nevent: smellin\nretry: 10000\ndata: payload2\n\n')
            )
        self.assertEqual(auditlog.gen, 1)
        self.assertEqual(auditlog.idx, 1) 
        self.assertEqual(auditlog.oids, [5])

    def test_auditstream_sse_with_last_event_id_all(self):
        context = testing.DummyResource()
        context.__oid__ = 5
        request = testing.DummyRequest()
        request.headers['Last-Event-Id'] = '1-1'
        request.GET = GetAllDict()
        request.GET['all'] = '1'
        inst = self._makeOne(context, request)
        auditlog = DummyAuditLog()
        inst.get_auditlog = lambda c: auditlog
        response = inst.auditstream_sse()
        self.assertEqual(
            response.text,
            ('id: 0-1\nevent: smellin\nretry: 10000\ndata: payload1\n\n'
             'id: 0-2\nevent: smellin\nretry: 10000\ndata: payload2\n\n')
            )
        self.assertEqual(auditlog.gen, 1)
        self.assertEqual(auditlog.idx, 1) 
        self.assertEqual(auditlog.oids, ())
       
    def test_auditstream_sse_with_last_event_id_and_oids(self):
        context = testing.DummyResource()
        context.__oid__ = 5
        request = testing.DummyRequest()
        request.headers['Last-Event-Id'] = '1-1'
        request.GET = GetAllDict()
        request.GET['oid'] = '3'
        inst = self._makeOne(context, request)
        auditlog = DummyAuditLog()
        inst.get_auditlog = lambda c: auditlog
        response = inst.auditstream_sse()
        self.assertEqual(
            response.text,
            ('id: 0-1\nevent: smellin\nretry: 10000\ndata: payload1\n\n'
             'id: 0-2\nevent: smellin\nretry: 10000\ndata: payload2\n\n')
            )
        self.assertEqual(auditlog.gen, 1)
        self.assertEqual(auditlog.idx, 1) 
        self.assertEqual(list(auditlog.oids), [3])

    def test_auditing(self):
        import pytz
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.user = testing.DummyResource()
        request.user.timezone = pytz.timezone('UTC')
        inst = self._makeOne(context, request)
        inst.get_auditlog = lambda c: DummyAuditLog()
        result = inst.auditing()
        self.assertEqual(result['results'][0][0], 0)
        self.assertEqual(result['results'][0][1], 2)
        self.assertEqual(result['results'][0][2], '1970-01-01 00:00:01 UTC')
        self.assertEqual(result['results'][1][0], 0)
        self.assertEqual(result['results'][1][1], 1)
        self.assertEqual(result['results'][1][2], '1970-01-01 00:00:01 UTC')

    def test_auditing_no_log(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        inst.get_auditlog = lambda c: None
        result = inst.auditing()
        self.assertEqual(result['results'], [])
        
class GetAllDict(dict):
    def getall(self, name): # pragma: no cover
        result = self.get(name)
        if result:
            return [result]
        return []

class DummyEvent(object):
    def __init__(self, payload):
        self.payload = payload
        self.name = 'smellin'
        self.timestamp = 1
        
class DummyAuditLog(object):
    def latest_id(self):
        return 0, 1

    def __iter__(self):
        return iter(self.newer(0, 0))

    def newer(self, gen, idx, oids=()):
        self.gen = gen
        self.idx = idx
        self.oids = oids
        event1 = DummyEvent('payload1')
        event2 = DummyEvent('payload2')
        yield 0, 1, event1
        yield 0, 2, event2

class DummyLogger(object):
    def debug(self, msg):
        pass

########NEW FILE########
__FILENAME__ = views
import datetime
from logging import getLogger

from pyramid.view import view_defaults
from pyramid.httpexceptions import HTTPPreconditionFailed
from pyramid.compat import PY3, text_type
from substanced.sdi import mgmt_view, RIGHT
from substanced.util import (
    Batch,
    get_oid,
    get_auditlog,
    _,
    )

@view_defaults(
    permission='sdi.view-auditlog',
    http_cache=0,
    )
class AuditLogEventStreamView(object):
    get_auditlog = staticmethod(get_auditlog) # for test replacement
    logger = getLogger('substanced')

    def __init__(self, context, request):
        self.context = context
        self.request = request

    @mgmt_view(
        name='auditing',
        tab_title=_('Auditing'),
        renderer='templates/auditing.pt',
        tab_near=RIGHT,
        physical_path='/',
        )
    def auditing(self):
        log = self.get_auditlog(self.context)
        log_exists = False
        results = []
        if log is not None:
            log_exists = True
            for gen, idx, event in log:
                tz = self.request.user.timezone
                dt = datetime.datetime.fromtimestamp(event.timestamp, tz)
                time = dt.strftime('%Y-%m-%d %H:%M:%S %Z')
                results.insert(0, (gen, idx, time, event))
        batch = Batch(results, self.request, default_size=100)
        return {'batch':batch, 'results':results, 'log_exists':log_exists}

    @mgmt_view(name='auditstream-sse', tab_condition=False)
    def auditstream_sse(self):
        """Returns an event stream suitable for driving an HTML5 EventSource.
           The event stream will contain auditing events.

           Obtain events for the context of the view only::

            var source = new EventSource(
               "${request.sdiapi.mgmt_path(context, 'auditstream-sse')}");
           
           Obtain events for a single OID unrelated to the context::

            var source = new EventSource(
               "${request.sdiapi.mgmt_path(context, 'auditstream-sse', query={'oid':'12345'})}");

           Obtain events for a set of OIDs::

            var source = new EventSource(
               "${request.sdiapi.mgmt_path(context, 'auditstream-sse', query={'oid':['12345', '56789']})}");

           Obtain all events for all oids::

            var source = new EventSource(
               "${request.sdiapi.mgmt_path(context, 'auditstream-sse', query={'all':'1'})}");
           
           The executing user will need to possess the ``sdi.view-auditstream``
           permission against the context on which the view is invoked.
        """
        request = self.request
        response = request.response
        response.content_type = 'text/event-stream'
        last_event_id = request.headers.get('Last-Event-Id')
        log = self.get_auditlog(self.context)
        if log is None:
            return HTTPPreconditionFailed('Auditing not configured')
        if not last_event_id:
            # first call, set a baseline event id
            gen, idx = log.latest_id()
            msg = compose_message('%s-%s' % (gen, idx))
            response.text = msg
            self.logger.debug(
                'New SSE connection on %s, returning %s' % (
                    request.url, msg)
                )
            return response
        else:
            if request.GET.get('all'):
                oids = ()
            elif request.GET.get('oid'):
                oids = map(int, request.GET.getall('oid'))
            else:
                oids = [get_oid(self.context)]
            _gen, _idx = map(int, last_event_id.split('-', 1))
            events = log.newer(_gen, _idx, oids=oids)
            msg = text_type('')
            for gen, idx, event in events:
                event_id = '%s-%s' % (gen, idx)
                message = compose_message(event_id, event.name, event.payload)
                msg += message
            self.logger.debug(
                'SSE connection on %s with id %s-%s, returning %s' % (
                    request.url, _gen, _idx, msg)
                )
            response.text = msg
            return response

def compose_message(eventid, name=None, payload=''):
    msg = 'id: %s\n' % eventid
    if name:
        msg += 'event: %s\n' % name
    msg += 'retry: 10000\n'
    msg += 'data: %s\n' % payload
    msg += '\n'
    if PY3: # pragma: no cover
        return msg
    else: # pragma: no cover
        return msg.decode('utf-8')


########NEW FILE########
__FILENAME__ = deferred
import os

import logging
import persistent
import threading
import time
import transaction

from pyramid.settings import asbool
from pyramid.threadlocal import get_current_registry
from transaction.interfaces import ISavepointDataManager
from zope.interface import implementer
from ZODB.POSException import ConflictError

from .._compat import total_ordering
from ..interfaces import (
    IIndexingActionProcessor,
    MODE_DEFERRED,
    )
from ..objectmap import find_objectmap
from ..stats import statsd_gauge
from ..util import get_oid

logger = logging.getLogger(__name__)

class ResourceNotFound(Exception):
    def __init__(self, oid):
        self.oid = oid

    def __repr__(self):
        return 'Indexing error: cannot find resource for oid %s' % self.oid

class ObjectMapNotFound(Exception):
    def __init__(self, action):
        self.action = action

# functools.total_ordering allows us to define __eq__ and __lt__ and it takes
# care of the rest of the rich comparison methods (2.7+ only)

@total_ordering
class Action(object):

    oid = None
    index = None
    index_oid = None
    position = None
    logger = logger

    def __repr__(self):
        klass = self.__class__
        classname = '%s.%s' % (klass.__module__, klass.__name__)
        return '<%s object oid %r for index %r at %#x>' % (
            classname,
            self.oid,
            getattr(self.index, '__name__', self.index),
            id(self)
            )

    def __hash__(self):
        return hash((self.oid, self.index_oid))

    def __eq__(self, other):
        # Note that we don't take our class or position into account because
        # we want to compare equal to any other action that has the same
        # oid for the same index.
        return (self.oid, self.index_oid) == (other.oid, other.index_oid)

    def __lt__(self, other):
        # Note that during sorting we *do* take our position into account.
        self_cmp = (self.oid, self.index_oid, self.position)
        other_cmp = (other.oid, other.index_oid, other.position)
        return self_cmp < other_cmp

    def find_resource(self):
        objectmap = find_objectmap(self.index)
        if objectmap is None:
            raise ObjectMapNotFound(self)
        resource = objectmap.object_for(self.oid)
        if resource is None:
            raise ResourceNotFound(self.oid)
        return resource

class IndexAction(Action):

    position = 2

    def __init__(self, index, mode, oid, index_oid=None):
        self.index = index
        if index_oid is None:
            index_oid = get_oid(index)
        self.index_oid = index_oid
        self.mode = mode
        self.oid = oid

    def execute(self):
        try:
            resource = self.find_resource()
        except ObjectMapNotFound:
            self.logger.info('Objectmap not found for index %s' % (self.index,))
            return
        self.index.index_doc(self.oid, resource)

    def anti(self):
        return UnindexAction(self.index, self.mode, self.oid, self.index_oid)

class ReindexAction(Action):

    position = 1
    
    def __init__(self, index, mode, oid, index_oid=None):
        self.index = index
        if index_oid is None:
            index_oid = get_oid(index)
        self.index_oid = index_oid
        self.mode = mode
        self.oid = oid

    def execute(self):
        try:
            resource = self.find_resource()
        except ObjectMapNotFound:
            self.logger.info('Objectmap not found for index %s' % (self.index,))
            return
        self.index.reindex_doc(self.oid, resource)

    def anti(self):
        return self

class UnindexAction(Action):

    position = 0
    
    def __init__(self, index, mode, oid, index_oid=None):
        self.index = index
        if index_oid is None:
            index_oid = get_oid(index)
        self.index_oid = index_oid
        self.mode = mode
        self.oid = oid

    def execute(self):
        self.index.unindex_doc(self.oid)

    def anti(self):
        return IndexAction(self.index, self.mode, self.oid, self.index_oid)

class ActionsQueue(persistent.Persistent):

    logger = logger # for testing

    def __init__(self):
        self.gen = 0
        self.actions = []
        self.pactive = False

    def bumpgen(self):
        # At an average rate of 100 bumps per second, this value won't exceed
        # sys.maxint for:
        #
        # About 8 months on a 32-bit system.
        #
        # About 92 years on a 64-bit system.
        #
        # The software will work fine after it exceeds sys.maxint, it'll
        # overflow to a long integer and it'll just be slower to do the math to
        # bump.
        #
        # I choose to not care about the slowdown that overflowing to a long
        # integer on incredibly busy 32-bit systems will imply.  32-bit systems
        # will have a real chance of getting slower over time as this integer
        # continually increases and its long integer representation uses more
        # bits as it does.  If someone uses this software 100 years from now,
        # and they're still using a 64 bit CPU, they'll also need to deal with
        # the slowdown implied by overflowing to a long integer too, but that's
        # obviously not too concerning.
        #
        # It's possible to reset this value to 0 periodically.  Resetting this
        # value to 0 should only be done immediately after a pack.  It is only
        # used to compare old object revisions to newer ones, and after a pack,
        # there are no old object revisions anymore.  It would be ideal to be
        # able to hook into the pack process to do this automatically, but
        # there aren't really any hooks for it.
        self.gen = self.gen + 1

    def extend(self, actions):
        self.actions.extend(actions)
        self.bumpgen()

    def __len__(self):
        return len(self.actions)

    def popall(self):
        if not self.actions:
            return None
        actions = self.actions[:]
        self.actions = []
        self.bumpgen()
        return actions

    def _p_resolveConflict(self, old_state, committed_state, new_state):
        clsname = self.__class__.__name__
        self.logger.info(
            'Running _p_resolveConflict for %s' % clsname
            )

        # We only know how to merge actions and resolve the generation and undo
        # flag.  If anything else is different, puke.
        if set(new_state.keys()) != set(committed_state.keys()):
            self.logger.info(
                'Keys differ in new and committed states in _p_resolveConflict '
                'of %s (new: %r; committed: %r), cannot resolve' % (
                    clsname, new_state.keys(), committed_state.keys()
                    )
                )
            raise ConflictError

        for key, val in new_state.items():
            if key not in ('actions', 'gen'):
                if val != committed_state[key]:
                    self.logger.info(
                        'Unknown key %s differs in states, cannot resolve '
                        'conflict in _p_resolveConflict of %s' % (key, clsname)
                        )
                    raise ConflictError

        # If the new state's generation number is less than the old state's
        # generation number, we know we're in the process of undoing a
        # transaction that involved the queue.  This is because during an undo
        # the "new_state" state is the state of the queue in the transaction
        # prior to the undone transaction (the state that would have been
        # rolled back to if this conflict did not occur), and the "old_state"
        # is actually the state of the transaction we're trying to undo.
        undoing = (old_state['gen'] > new_state['gen'])

        gen = max(committed_state['gen'], new_state['gen'])

        # Get rid of duplicate actions so that each list has exactly one and
        # only one action per oid+index combination to prevent us from needing
        # to think about preserving ordering.
        optimize_states(old_state, committed_state, new_state)

        # A good bit of this code was cadged from zc.queue._queue
        old = old_state['actions']
        committed = committed_state['actions']
        new = new_state['actions']

        oldlen = len(old)
        committedlen = len(committed)
        newlen = len(new)

        old_set = set(old)
        committed_set = set(committed)
        new_set = set(new)

        # Make sure no state has an action that conflicts with an action in
        # another state.  For example, if the old state indicates it wants to
        # unindex a particular oid+index and the new state indicates it wants
        # to index the same oid+index, throw a conflict error.  On the other
        # hand, if one state says it wants to reindex, and another state says
        # it wants to index, prefer the index operation over the reindex one
        # and use it (don't conflict); and if one state says it wants to index
        # and the other state says it wants to index too, that's fine as well.
        for (s1, s2) in (
            (old_set, new_set),
            (new_set, committed_set),
            (old_set, committed_set)
            ):
            intersect = action_intersection(s1, s2)
            s1.update(intersect)
            s2.update(intersect)

        committed_added = committed_set - old_set
        committed_removed = old_set - committed_set

        new_added = new_set - old_set
        new_removed = old_set - new_set

        if undoing:

            gen = committed_state['gen'] + 1

            if new_removed:
                # During an undo, the "new_state" state is the state of the
                # queue in the transaction prior to the undone transaction (the
                # state that we're rolling back to), and the "old_state" is
                # actually the state of the transaction we're trying to undo.
                #
                # While we're undoing, it's not enough to just omit the removed
                # actions from the returned action state, as we do in the
                # non-undo case.  Instead we need to add anti-actions for every
                # action in the state that we're undoing.  For example, if we
                # determine via that an UnindexAction was in the old state,
                # we'll need to add an IndexAction to the returned state in
                # order to get the object into the indexed state eventually
                # (when the queue processor runs).  If there was an
                # IndexAction, we need to add an UnindexAction, and if there
                # was a ReindexAction in the old state, we need to add a
                # ReindexAction.
                #
                # NB: doing this before we compare committed_removed &
                # new_removed and conflict if there's an intersection prevents
                # an inappropriate conflict error.  If we didn't mutate
                # new_removed and new_added before this, an undo attempt that
                # involved the queue would almost always raise a conflict
                # error.
                #
                # Some inspiration from this undo logic comes from staring at
                # Products.QueueCatalog
                self.logger.info(
                    'generating anti-actions during undo in %s '
                    '_p_resolveConflict' % clsname
                    )
                for removed_action in list(new_removed):
                    anti = removed_action.anti()
                    if (anti in new_added) or (anti in committed_set):
                        raise ConflictError
                    new_added.add(anti)
                    new_removed.remove(removed_action)

        # It's theoretically possible to resolve cases where the new and
        # committed states remove/add the same oid+indexoid combination.  In
        # theory, the union of actions in new_removed and committed_removed
        # should be removed, and the union of actions in new_added and
        # committed_added should be added.  But note that when there are
        # individual actions within the removed or added sets that compare
        # equal, the actions are keyed in the set only by (oid,index) and their
        # __eq__ doesn't take into account the action type.  For example, there
        # might be two different actions which compare equal in the different
        # sets: a reindex action for oid 1 in the new_removed set and an
        # unindex action for the same oid in the committed_removed set.
        #
        # We could create an 'action_union' function which would return a union
        # of two sets composed of actions.  When two actions in the sets
        # compare otherwise equal it would return the "real" action or it would
        # conflict for two actions that compare equal but which are mutually
        # incompatible.  For example, if we had an index action for oid 1 in
        # new_removed, and a reindex action for oid 1 in committed_removed, the
        # index action would be returned (the reindex action would be
        # discarded).  There would be no conflict in this case. On the other
        # hand, the action_union function might raise a ConflictError if it
        # can't determine what to do; an example of a case where action_union
        # wouldn't know what to do is if there's an index action for oid 1 in
        # new_removed, and an unindex action for oid 1 in committed_removed.
        #
        # In practice, however, this strategy plays hell with undo.  For
        # example:
        #
        #   T1    unindex lots of objects
        #   T2    undo T1
        #   T3    process actions in T1 queue
        #
        # I had originally thought that all undo operations would call
        # _p_resolveConflict here, but it's not true; if an undo can just copy
        # an old record forward, it does so.  So in the sequence of events
        # above, T1 will commit OK, and then T2 will commit OK (without calling
        # _p_resolveConflict), and we'll be left with a conflict resolution
        # problem in the (non-undo) T3.
        #
        # If T3 causes conflict as above, the old state (T1) will contain lots
        # of unindex actions, and neither the new state (T3) nor committed
        # state (from T2) will contain any actions.  If we used the
        # "action_union" strategy, all of the actions would be perfectly
        # resolveable, and we'd wind up returning a state without any actions
        # in it.  However, this would also be completely wrong, because we
        # don't actually *want* the transaction state resulting from the
        # unindex actions; instead, we want T3 to conflict with T2, so the
        # executions of the unindex actions fail, because we don't actually
        # want the objects unindexed anymore.
        #
        # Such a problem is probably generalizable to any two transactions
        # which simultaneously remove actions that conflict, but I noticed it
        # in the undo case, so the description above focuses on it.  Also, the
        # only thing that removes actions is an actions processor thread.
        # Since there's generally only going to be one of those, undo will
        # typically be the only time an action is removed as the result of an
        # action taken by a human that has a possibility of the remove
        # conflicting with another transaction (the actions processor).

        if new_removed & committed_removed:
            self.logger.info(
                'Both the new state and the committed state removed an action '
                'related to the same oid+index in _p_resolveConflict of %s, '
                'cannot resolve ' % clsname
                )
            raise ConflictError

        if new_added & committed_added:
            self.logger.info(
                'Both the new state and the committed state added an action '
                'related to the same oid+index in _p_resolveConflict of %s, '
                'cannot resolve ' % clsname
                )
            raise ConflictError

        mod_committed = committed_set - new_removed
        mod_committed.update(new_added)

        # NB: ordering doesn't make a damn bit of difference because the
        # actions are already optimized and thus is impossible to have more
        # than one action per (oid,index) in the result, but we sort here to
        # listify and for ease of testing.
        committed_state['actions'] = sorted(mod_committed)
        committed_state['gen'] = gen

        actionslen = len(committed_state['actions'])

        self.logger.info(
            'resolved %s conflict in _p_resolveConflict: '
            'oldlen %s, committedlen %s, newlen %s, actionslen %s' % (
                clsname, oldlen, committedlen, newlen, actionslen)
            )

        return committed_state

def commit(tries, msg=''):
    def wrapper(wrapped):
        def retry(self, *arg, **kw):
            for _ in range(tries):
                self.sync()
                self.transaction.begin()
                try:
                    result = wrapped(self, *arg, **kw)
                    self.transaction.get().note(msg)
                    self.transaction.commit()
                    return result
                except ConflictError:
                    self.transaction.abort()
            raise ConflictError
        return retry
    return wrapper

class Break(Exception):
    pass

class BasicActionProcessor(object):

    logger = logger # for testing
    transaction = transaction # for testing
    queue_name = 'basic_action_queue'
    
    def __init__(self, context):
        self.context = context

    def get_root(self):
        jar = self.context._p_jar
        if jar is None:
            return None
        zodb_root = jar.root()
        return zodb_root

    def get_queue(self):
        zodb_root = self.get_root()
        if zodb_root is None:
            return None
        queue = zodb_root.get(self.queue_name)
        if queue is None:
            queue = ActionsQueue()
            zodb_root[self.queue_name] = queue
        return queue

    def active(self):
        queue = self.get_queue()
        if queue is None:
            return False
        return queue.pactive

    def sync(self):
        jar = self.context._p_jar
        if jar is not None:
            jar.sync()

    @commit(5, 'engaging actions processor')
    def engage(self):
        queue = self.get_queue()
        if queue is None:
            raise RuntimeError('Context has no jar')
        queue.pactive = True

    @commit(1, 'disengaging actions processor')
    def disengage(self):
        queue = self.get_queue()
        if queue is None:
            raise RuntimeError('Context has no jar')
        queue.pactive = False

    def add(self, actions):
        queue = self.get_queue()
        if queue is None:
            raise RuntimeError('Queue processor not engaged')
        queue.extend(actions)

    def process(self, sleep=5, once=False):
        self.logger.info('starting basic action processor')
        self.engage()
        i = 0
        while True:
            try:

                if not once: # pragma: no cover
                    time.sleep(sleep)

                self.sync()
                self.transaction.begin()

                executed = False
                commit = False

                queue = self.get_queue()
                queue_len = len(queue)
                actions = queue.popall()
                statsd_gauge('catalog.queue_length', queue_len, rate=.5)

                if actions is not None:
                    actions = optimize_actions(actions)
                    for action in actions:
                        self.logger.info('executing %s' % (action,))
                        try:
                            executed = True
                            action.execute()
                        except ResourceNotFound as e:
                            self.logger.info(repr(e))
                        except (SystemExit, KeyboardInterrupt, Break):
                            raise
                        except Exception as e:
                            self.logger.error(repr(e))
                        else:
                            commit = True

                if commit:
                    self.logger.info('committing')
                    try:
                        plural = 'action' if len(actions) == 1 else 'actions'
                        self.transaction.get().note(
                            'indexing action processor executed %s %s' %
                              (len(actions), plural)
                            )
                        self.transaction.commit()
                        self.logger.info('committed')
                    except ConflictError:
                        self.transaction.abort()
                        self.logger.info('aborted due to conflict error')

                if not executed:
                    if i % 12 == 0:
                        self.logger.info('no actions to execute')

                i += 1

                if once:
                    raise Break()

            except (SystemExit, KeyboardInterrupt, Break):
                once = True
                try:
                    self.logger.info('stopping basic action processor')
                    self.disengage()
                    break
                except ConflictError:
                    self.logger.info(
                        'couldnt disengage due to conflict, processing queue '
                        'once more'
                        )

class IndexActionSavepoint(object):
    """ Transaction savepoints  """

    def __init__(self, tm):
        self.tm = tm
        self.actions = tm.actions[:]

    def rollback(self):
        self.tm.actions = self.actions


@implementer(ISavepointDataManager)
class IndexActionTM(threading.local):
    # This is a data manager solely to provide savepoint support, we'd
    # otherwise be able to get away with just using a before commit hook to
    # call .process

    transaction = transaction # for testing
    logger = logger # for testing
    os = os # for testing
    
    def __init__(self, index):
        self.index = index
        self.oid = index.__oid__
        self.registered = False
        self.actions = []

    def register(self):
        if not self.registered:
            t = self.transaction.get()
            t.join(self)
            t.addBeforeCommitHook(self.flush, (False,))
            self.registered = True

    def savepoint(self):
        return IndexActionSavepoint(self)

    def tpc_begin(self, t):
        pass

    commit = tpc_vote = tpc_begin

    def tpc_finish(self, t):
        self.registered = False
        self.actions = []
        if self.index is not None:
            # NB: dont make setting _p_action_tm a method of the index,
            # it has a side effect of calling setstate at times when
            # the object state cannot be obtained
            self.index._p_action_tm = None
            self.index = None # break circref

    tpc_abort = abort = tpc_finish

    def sortKey(self):
        return 'IndexActionTM: %s' % self.oid

    def add(self, action):
        self.actions.append(action)

    def flush(self, all=True):
        if self.actions:
            actions = self.actions
            self.actions = []
            actions = optimize_actions(actions)
            self._process(actions, all=all)

    def _process(self, actions, all=True):
        registry = get_current_registry()

        self.logger.debug('begin index actions processing')

        if all:
            self.logger.debug('executing all actions immediately: "all" flag')
            self.execute_actions_immediately(actions)
            
        else:
            processor = registry.queryAdapter(
                self.index,
                IIndexingActionProcessor
                )

            force_deferred = asbool(
                self.os.environ.get(
                    'SUBSTANCED_CATALOGS_FORCE_DEFERRED',
                    registry.settings.get(
                        'substanced.catalogs.force_deferred', False)
                    ))

            if processor:
                active = processor.active()
                queue = processor.get_queue()
                if force_deferred:
                    if queue is not None:
                        self.logger.debug(
                            ('executing deferred actions: deferred mode '
                             'forced via "substanced.catalogs.force_deferred" '
                             'flag in configuration or envvar')
                            )
                        self.execute_actions_deferred(
                            actions, processor, force=True)
                    else:
                        # this can happen when a catalog is added to a newly
                        # created object (one that does not have a jar)
                        self.logger.debug(
                            'executing actions all immediately: no jar '
                            'available to find queue'
                            )
                        self.execute_actions_immediately(actions)
                elif active:
                    self.logger.debug(
                        'executing deferred actions: action processor '
                        'active'
                        )
                    self.execute_actions_deferred(actions, processor)
                else:
                    self.logger.debug(
                        'executing actions all immediately: inactive action '
                        'processor'
                        )
                    self.execute_actions_immediately(actions)

            else:
                self.logger.debug(
                    'executing actions all immediately: no action '
                    'processor'
                    )
                self.execute_actions_immediately(actions)

        self.logger.debug('done processing index actions')

    def execute_actions_immediately(self, actions):
        for action in actions:
            self.logger.debug('executing action %r' % (action,))
            action.execute()

    def execute_actions_deferred(self, actions, processor, force=False):
        deferred = []
        for action in actions:
            if force or action.mode is MODE_DEFERRED:
                self.logger.debug('adding deferred action %r' % (action,))
                deferred.append(action)
            else:
                self.logger.debug('executing action %r' % (action,))
                action.execute()
        if deferred:
            processor.add(deferred)

def action_intersection(s1, s2):
    """ Call which_action for each action in s1 that has an analogue in s2 to
    determine which of two actions that operate against the same oid+index
    should be preferred.  If neither is preferred, a ConflictError will be
    raised."""
    isect = s1 & s2
    L1 = [ ( (a.oid, a.index_oid), a) for a in s1 ]
    L2 = [ ( (a.oid, a.index_oid), a) for a in s2 ]
    ds1 = dict(L1)
    ds2 = dict(L2)
    for k1, action1 in ds1.items():
        action2 = ds2.get(k1)
        if action2 is not None:
            # replace action in union with correct one or conflict
            isect.add(which_action(action1, action2))
    return isect

def which_action(a1, a2):
    """
    Compare two actions and return 'the right' one, or raise a ConflictError.
    It's presumed that both actions share the same (oid,index).  We use this
    state chart to determine what is returned:

                             A1    INDEX      UNINDEX     REINDEX

       A2          INDEX           index      conflict*   index*

                 UNINDEX           conflict*  unindex     conflict*

                 REINDEX           index*     conflict*   reindex
    """
    def doconflict(a1, a2):
        raise ConflictError
    def dosecond(a1, a2):
        return a2
    def dofirst(a1, a2):
        return a1
    statefuncs = {
        (IndexAction, UnindexAction):doconflict,
        (UnindexAction, IndexAction):doconflict,
        (ReindexAction, UnindexAction):doconflict,
        (UnindexAction, ReindexAction):doconflict,
        (ReindexAction, IndexAction):dosecond,
        }
    return statefuncs.get((a1.__class__, a2.__class__), dofirst)(a1, a2)

def optimize_actions(actions):
    """
    State chart for optimization.  If the new action is X and the existing
    action is Y, generate the resulting action named in the chart cells.

                            New    INDEX    UNINDEX   REINDEX

       Existing    INDEX           index     nothing*   index*

                 UNINDEX           reindex*  unindex    reindex

                 REINDEX           index     unindex    reindex

    Starred entries in the chart above indicate special cases.  Typically
    the last action encountered in the actions list is the most optimal
    action, except for the starred cases.
    """
    result = {}

    def donothing(oid, index_oid, action1, action2):
        del result[(oid, index_oid)]

    def doadd(oid, index_oid, action1, action2):
        result[(oid, index_oid)] = action1

    def dochange(oid, index_oid, action1, action2):
        result[(oid, index_oid)] = ReindexAction(
            action2.index, action2.mode, oid,
            )

    def dodefault(oid, index_oid, action1, action2):
        result[(oid, index_oid)] = action2

    statefuncs = {
        # txn asked to remove an object that previously it was
        # asked to add, conclusion is to do nothing
        (IndexAction, UnindexAction):donothing,
        # txn asked to change an object that was not previously added,
        # concusion is to just do the add
        (IndexAction, ReindexAction):doadd,
        # txn action asked to remove an object then readd the same
        # object.  We translate this to a single change action.
        (UnindexAction, IndexAction):dochange,
        }

    for newaction in actions:
        oid = newaction.oid
        index_oid = newaction.index_oid
        oldaction = result.get((oid, index_oid))
        statefunc = statefuncs.get(
            (oldaction.__class__, newaction.__class__),
            dodefault,
            )
        statefunc(oid, index_oid, oldaction, newaction)

    result = list(sorted(result.values()))
    return result

def optimize_states(old_state, committed_state, new_state):
    """ Optimize actions in states during conflict resolution """
    old = old_state['actions']
    committed = committed_state['actions']
    new = new_state['actions']

    old, new, committed = map(optimize_actions, [old, new, committed])

    old_state['actions'] = old
    committed_state['actions'] = committed
    new_state['actions'] = new


########NEW FILE########
__FILENAME__ = discriminators
from zope.interface import providedBy

from pyramid.threadlocal import get_current_registry

from ..interfaces import IIndexView

_marker = object()

class IndexViewDiscriminator(object):
    get_current_registry = staticmethod(get_current_registry) # for testing
    
    def __init__(self, catalog_name, index_name):
        self.catalog_name = catalog_name
        self.index_name = index_name

    def __call__(self, resource, default):
        registry = self.get_current_registry() # XXX lame
        composite_name = '%s|%s' % (self.catalog_name, self.index_name)
        resource_iface = providedBy(resource)
        index_view = registry.adapters.lookup(
            (resource_iface,),
            IIndexView,
            name=composite_name,
            default=None,
            )
        if index_view is None:
            return default
        return index_view(resource, default)

class AllowedIndexDiscriminator(object):
    """ bw compat for unpickling only; safe to delete after system catalog has
    been resynced"""
    pass

def dummy_discriminator(object, default):
    return default

########NEW FILE########
__FILENAME__ = evolve
from substanced.catalog.indexes import PathIndex
from substanced.util import get_dotted_name
from substanced.objectmap import find_objectmap

def treesetify_catalog_pathindexes(root): # pragma: no cover
    # to avoid having huge pickles
    objectmap = find_objectmap(root)

    index_oids = objectmap.get_extent(get_dotted_name(PathIndex))

    for oid in index_oids:
        pathindex = objectmap.object_for(oid)
        pathindex._not_indexed = objectmap.family.IF.TreeSet(
            pathindex._not_indexed)

def includeme(config):
    config.add_evolution_step(treesetify_catalog_pathindexes)

########NEW FILE########
__FILENAME__ = factories
import pickle
import zlib

import BTrees
from zope.interface import implementer

from pyramid.traversal import resource_path

from ..interfaces import (
    ICatalogFactory,
    IIndexFactory,
    )
from ..util import get_dotted_name

from .indexes import (
    TextIndex,
    FieldIndex,
    KeywordIndex,
    FacetIndex,
    AllowedIndex,
    PathIndex,
    )

from .discriminators import IndexViewDiscriminator

@implementer(IIndexFactory)
class IndexFactory(object):

    def __init__(self, **kw):
        self.kw = kw

    def __call__(self, catalog_name, index_name):
        discriminator = IndexViewDiscriminator(catalog_name, index_name)
        index = self.index_type(discriminator=discriminator, **self.kw)
        index.__factory_hash__ = hash(self)
        return index

    def hashvalues(self):
        values = {}
        values.update(self.kw)
        values['class'] = get_dotted_name(self.__class__)
        family = values.get('family', None)
        if family is not None:
            if family == BTrees.family64:
                family = 'family64'
            elif family == BTrees.family32:
                family = 'family32'
            else:
                raise ValueError(family)
            values['family'] = family
        return values

    def __hash__(self):
        data = pickle.dumps(tuple(sorted(self.hashvalues().items())))
        return zlib.crc32(data) & 0xffffffff

    def is_stale(self, index):
        index_hash = getattr(index, '__factory_hash__', None)
        return index_hash != hash(self)

class Text(IndexFactory):
    index_type = TextIndex

    def hashvalues(self):
        values = IndexFactory.hashvalues(self)
        for name in ('lexicon', 'index'):
            attr = values.get(name, None)
            if attr is not None:
                clsname = attr.__class__.__name__
                values[name] = clsname
        return values

class Field(IndexFactory):
    index_type = FieldIndex
    
class Keyword(IndexFactory):
    index_type = KeywordIndex

class Facet(IndexFactory):
    index_type = FacetIndex

    def hashvalues(self):
        values = IndexFactory.hashvalues(self)
        facets = values.get('facets', ())
        values['facets'] = tuple(sorted([(x,y) for x, y in facets]))
        return values

class Allowed(IndexFactory):
    index_type = AllowedIndex

class Path(IndexFactory):
    index_type = PathIndex

@implementer(ICatalogFactory)
class CatalogFactory(object):
    def __init__(self, name, index_factories):
        self.name = name
        self.index_factories = index_factories

    def _remove_stale(self, catalog, output=None):
        catalog_path = resource_path(catalog)
        result = False
        for index_name, index in list(catalog.items()):
            if not index_name in self.index_factories:
                output and output(
                    '%s: removing stale index named %r' % (
                        catalog_path,
                        index_name,
                        )
                    )
                catalog.remove(index_name)
                result = True
        return result

    def replace(self, catalog, reindex=False, output=None, **reindex_kw):
        catalog_path = resource_path(catalog)

        to_reindex = set()

        changed = False

        for index_name, index_factory in self.index_factories.items():
            if index_name in catalog:
                verb = 'replacing'
            else:
                verb = 'adding'

            output and output(
                '%s: %s index named %r' % (catalog_path, verb, index_name),
                )

            index = index_factory(self.name, index_name)
            index.__sdi_deletable__ = False
            catalog.replace(index_name, index)
            to_reindex.add(index_name)
            changed = True

        removed_stale = self._remove_stale(catalog, output=output)

        if changed and reindex:
            catalog.reindex(indexes=to_reindex, output=output, **reindex_kw)

        return removed_stale or changed

    def sync(self, catalog, reindex=False, output=None, **reindex_kw):

        catalog_path = resource_path(catalog)

        to_reindex = set()
        changed = False

        for index_name, index_factory in self.index_factories.items():
            if not index_name in catalog:
                output and output(
                    '%s: adding index named %r' % (catalog_path, index_name),
                    )
                index = index_factory(self.name, index_name)
                catalog.add(index_name, index)
                changed = True
                to_reindex.add(index_name)

            index = catalog[index_name]

            if index_factory.is_stale(index):
                output and output(
                    '%s: replacing stale index named %r' % (
                        catalog_path,
                        index_name,
                        )
                    )
                index = index_factory(self.name, index_name)
                index.__sdi_deletable__ = False
                catalog.replace(index_name, index)
                to_reindex.add(index_name)
                changed = True

        removed_stale = self._remove_stale(catalog, output=output)

        if changed and reindex:
            catalog.reindex(indexes=to_reindex, output=output, **reindex_kw)

        return changed or removed_stale


########NEW FILE########
__FILENAME__ = indexes
import colander
import deform.widget
import re

import BTrees
import hypatia.query
import hypatia.interfaces
import hypatia.field
import hypatia.facet
import hypatia.keyword
import hypatia.text
import hypatia.util
from persistent import Persistent
from pyramid.compat import (
    url_unquote_text,
    is_nonstr_iter,
    )
from pyramid.settings import asbool
from pyramid.security import effective_principals
from pyramid.traversal import resource_path_tuple
from pyramid.interfaces import IRequest
from zope.interface import implementer

from ..content import content
from .. import interfaces as sd_interfaces
from ..interfaces import (
    MODE_IMMEDIATE,
    MODE_ATCOMMIT,
    )
from ..objectmap import find_objectmap
from ..property import PropertySheet
from ..schema import Schema
from ..stats import statsd_timer
from .._compat import STRING_TYPES
from .._compat import INT_TYPES
from .._compat import u

from .discriminators import dummy_discriminator
from .util import oid_from_resource

from . import deferred

PATH_WITH_OPTIONS = re.compile(r'\[(.+?)\](.+?)$')
_BLANK = u('')
_SLASH = u('/')

_marker = object()

class SDIndex(object):

    _p_action_tm = None
    action_mode = MODE_ATCOMMIT
    tm_class = deferred.IndexActionTM # for testing

    def resultset_from_query(self, query, names=None, resolver=None):
        # XXX we should probably flush pending atcommit actions before
        # executing the query; we can't just flush *this* index's actions,
        # we have to flush actions for all indexes in all catalogs related
        # to this query.
        if resolver is None:
            objectmap = find_objectmap(self)
            resolver = objectmap.object_for
        with statsd_timer('catalog.query'):
            query.flush()
            docids = query._apply(names)
            numdocs = len(docids)
            return hypatia.util.ResultSet(docids, numdocs, resolver)

    def get_action_tm(self):
        action_tm = self._p_action_tm
        if action_tm is None:
            action_tm = self._p_action_tm = self.tm_class(self)
            action_tm.register()
        return action_tm

    def flush(self, all=True):
        # This method will be called before query execution for every index
        # involved in a query.  It must be callable more than once without
        # having any issues.
        if self._p_action_tm is not None:
            self._p_action_tm.flush(all=all)

    def add_action(self, action):
        action_tm = self.get_action_tm()
        action_tm.add(action)

    def index_resource(self, resource, oid=None, action_mode=None):
        if oid is None:
            oid = oid_from_resource(resource)
        if action_mode is None:
            action_mode = self.action_mode
        if action_mode is MODE_IMMEDIATE:
            self.index_doc(oid, resource)
        else:
            action = deferred.IndexAction(self, action_mode, oid)
            self.add_action(action)

    def reindex_resource(self, resource, oid=None, action_mode=None):
        if oid is None:
            oid = oid_from_resource(resource)
        if action_mode is None:
            action_mode = self.action_mode
        if action_mode is MODE_IMMEDIATE:
            self.reindex_doc(oid, resource)
        else:
            action = deferred.ReindexAction(self, action_mode, oid)
            self.add_action(action)

    def unindex_resource(self, resource_or_oid, action_mode=None):
        if isinstance(resource_or_oid, INT_TYPES):
            oid = resource_or_oid
        else:
            oid = oid_from_resource(resource_or_oid)
        if action_mode is None:
            action_mode = self.action_mode
        if action_mode is MODE_IMMEDIATE:
            self.unindex_doc(oid)
        else:
            action = deferred.UnindexAction(self, action_mode, oid)
            self.add_action(action)

    def __repr__(self):
        klass = self.__class__
        classname = '%s.%s' % (klass.__module__, klass.__name__)
        return '<%s object %r at %#x>' % (classname,
                                          getattr(self, '__name__', None),
                                          id(self))

class FakeIndex(object):

    family = BTrees.family64

    def reset(self):
        self._not_indexed = self.family.IF.TreeSet()

    def index_doc(self, docid, obj):
        pass

    def unindex_doc(self, docid):
        pass

    def reindex_doc(self, docid, obj):
        pass

    def docids(self):
        return self.__parent__.objectids

    indexed = docids

    def not_indexed(self):
        return self._not_indexed

    
@content(
    'Path Index',
    icon='glyphicon glyphicon-search',
    is_index=True,
    )
@implementer(hypatia.interfaces.IIndex)
class PathIndex(SDIndex, hypatia.util.BaseIndexMixin, Persistent, FakeIndex):
    """ Uses the :meth:`substanced.objectmap.ObjectMap.pathlookup` to
    apply a query to retrieve object identifiers at or under a path.

    `path` can be passed to methods as:

    - resource object

    - tuple of strings (usually returned value of
      :func:`pyramid.traverse.resource_path_tuple`)

    - a string path (e.g. /foo/bar)

    Query methods accept following parameters:

    - `include_origin` (by default True), see
      :meth:`substanced.objectmap.ObjectMap.pathlookup` for explanation.

    - `depth` (by default None) see
      :meth:`substanced.objectmap.ObjectMap.pathlookup` for explanation.

    Query types supported:

    - Eq

    - NotEq

    """
    include_origin = True
    depth = None

    def __init__(self, discriminator=None, family=None):
        if family is not None:
            self.family = family
        self.reset()

    def document_repr(self, docid, default=None):
        objectmap = find_objectmap(self.__parent__)
        path = objectmap.path_for(docid)
        if path is None:
            return default
        return path

    def search(self, path_tuple, depth=None, include_origin=True):
        objectmap = find_objectmap(self.__parent__)
        return objectmap.pathlookup(path_tuple, depth, include_origin)

    def _parse_optionstr(self, optionstr):
        D = {}
        options = [ x.strip() for x in optionstr.split(',') ]
        for option in options:
            if '=' in option:
                name, val = [ x.strip() for x in option.split('=') ]
            else:
                name = option
                val = True
            D[name] = val
        return D
            
    def _parse_path_str(self, path_str):
        # /foo -> stuff under /foo with default depth and include_origin
        # [depth=2]/foo -> stuff under /foo with depth 2 and default i_o
        # [include_origin=false]/foo -> stuff under /foo without include_origin
        # [depth=2,include_origin=false]/foo -> combination of all options
        if path_str.startswith('[') and ']' in path_str:
            optionstr, path = PATH_WITH_OPTIONS.match(
                path_str).groups()
            optiondict = self._parse_optionstr(optionstr)
            depth = optiondict.get('depth', None)
            include_origin =  optiondict.get('include_origin', None)
            if depth is None:
                depth = self.depth
            else:
                depth = int(depth)
            if include_origin is None:
                include_origin = self.include_origin
            else:
                include_origin = asbool(include_origin)
        else:
            path = path_str
            depth = self.depth
            include_origin = self.include_origin
            
        if not path.startswith('/'):
            raise ValueError('Path must start with a slash')
        
        tmp = [x for x in url_unquote_text(path).split(_SLASH) if x]
        path_tuple = (_BLANK,) + tuple(tmp)
        return path_tuple, depth, include_origin

    def _parse_path(self, obj_or_path):
        depth = self.depth
        include_origin = self.include_origin
        path_tuple = obj_or_path
        if hasattr(obj_or_path, '__parent__'):
            path_tuple = resource_path_tuple(obj_or_path)
        elif isinstance(obj_or_path, STRING_TYPES):
            path_tuple, depth, include_origin = self._parse_path_str(
                obj_or_path)
        elif not isinstance(obj_or_path, tuple):
            raise ValueError(
                'Must be object, path string, or tuple, not %s' % (
                    obj_or_path,))
        return path_tuple, depth, include_origin

    def apply(self, obj_path_or_dict):
        if isinstance(obj_path_or_dict, dict):
            path_tuple, depth, include_origin = self._parse_path(
                obj_path_or_dict['path'])
            depth = obj_path_or_dict.get('depth', depth)
            include_origin = obj_path_or_dict.get('include_origin',
                                                  include_origin)
        else:
            path_tuple, depth, include_origin = self._parse_path(
                obj_path_or_dict)

        rs = self.search(path_tuple, depth, include_origin)

        if rs:
            return rs
        else:
            return self.family.IF.TreeSet()

    applyEq = apply

    def applyNotEq(self, *args, **kw):
        return self._negate(self.applyEq, *args, **kw)

    def eq(self, path, depth=None, include_origin=None):
        val = {'path':path}
        if depth is not None:
            val['depth'] = depth
        if include_origin is not None:
            val['include_origin'] = include_origin
        return hypatia.query.Eq(self, val)

    def noteq(self, path, depth=None, include_origin=None):
        val = {'path':path}
        if depth is not None:
            val['depth'] = depth
        if include_origin is not None:
            val['include_origin'] = include_origin
        return hypatia.query.NotEq(self, val)

class IndexSchema(Schema):
    """ The property schema for :class:`substanced.principal.Group`
    objects."""
    action_mode = colander.SchemaNode(
        colander.String(),
        missing=colander.null,
        widget=deform.widget.RadioChoiceWidget(
            values=(
                ('MODE_IMMEDIATE', 'Immediate'),
                ('MODE_ATCOMMIT', 'Defer Until Commit'),
                ('MODE_DEFERRED', 'Defer Until Action Processing'),
                )
            )
        )

class IndexPropertySheet(PropertySheet):
    schema = IndexSchema()

    def set(self, values):
        action_mode = values['action_mode']
        action_mode = getattr(sd_interfaces, action_mode)
        if action_mode != self.context.action_mode:
            self.context.action_mode = action_mode

    def get(self):
        action_mode = self.context.action_mode
        action_mode = action_mode.__name__
        return {'action_mode':action_mode}

@content(
    'Field Index',
    icon='glyphicon glyphicon-search',
    is_index=True,
    propertysheets = ( ('', IndexPropertySheet), ),
    )
class FieldIndex(SDIndex, hypatia.field.FieldIndex):
    def __init__(self, discriminator=None, family=None, action_mode=None):
        if discriminator is None:
            discriminator = dummy_discriminator
        hypatia.field.FieldIndex.__init__(self, discriminator, family=family)
        if action_mode is not None:
            self.action_mode = action_mode

@content(
    'Keyword Index',
    icon='glyphicon glyphicon-search',
    is_index=True,
    propertysheets = ( ('', IndexPropertySheet), ),
    )
class KeywordIndex(SDIndex, hypatia.keyword.KeywordIndex):
    def __init__(self, discriminator=None, family=None, action_mode=None):
        if discriminator is None:
            discriminator = dummy_discriminator
        hypatia.keyword.KeywordIndex.__init__(
            self, discriminator, family=family
            )
        if action_mode is not None:
            self.action_mode = action_mode

@content(
    'Text Index',
    icon='glyphicon glyphicon-search',
    is_index=True,
    propertysheets = ( ('', IndexPropertySheet), ),
    )
class TextIndex(SDIndex, hypatia.text.TextIndex):
    def __init__(
        self,
        discriminator=None,
        lexicon=None,
        index=None,
        family=None,
        action_mode=None,
        ):
        if discriminator is None:
            discriminator = dummy_discriminator
        hypatia.text.TextIndex.__init__(
            self, discriminator, lexicon=lexicon, index=index, family=family,
            )
        if action_mode is not None:
            self.action_mode = action_mode

@content(
    'Facet Index',
    icon='glyphicon glyphicon-search',
    is_index=True,
    propertysheets = ( ('', IndexPropertySheet), ),
    )
class FacetIndex(SDIndex, hypatia.facet.FacetIndex):
    def __init__(self, discriminator=None, facets=None, family=None,
                 action_mode=None):
        if discriminator is None:
            discriminator = dummy_discriminator
        if facets is None:
            facets = []
        hypatia.facet.FacetIndex.__init__(
            self, discriminator, facets=facets, family=family
            )
        if action_mode is not None:
            self.action_mode = action_mode

@content(
    'Allowed Index',
    icon='glyphicon glyphicon-search',
    is_index=True,
    propertysheets = ( ('', IndexPropertySheet), ),
    )
class AllowedIndex(SDIndex, hypatia.util.BaseIndexMixin, Persistent, FakeIndex):
    """ An index which defers to ``objectmap.allowed`` as part of a query
    intersection."""
    
    def __init__(self, discriminator, family=None):
        if family is not None:
            self.family = family
        
    def document_repr(self, docid, default=None):
        return 'N/A'

    def allows(self, principals, permission):
        """ ``principals`` may either be 1) a sequence of principal
        indentifiers, 2) a single principal identifier, or 3) a Pyramid
        request, which indicates that all the effective principals implied by
        the request are used.

        ``permission`` must be a permission name.
        """
        if IRequest.providedBy(principals):
            principals = effective_principals(principals)
        elif not is_nonstr_iter(principals):
            principals = (principals,)
        return AllowsComparator(self, (principals, permission))

class AllowsComparator(hypatia.query.Comparator):
    """ Comparator that only allows intersection; it's nonsensical to use an
    allows query as anything but a filter """
    def union(self, left, names):
        raise NotImplementedError
    
    def intersect(self, left, names):
        principals, permission = self._value
        omap = find_objectmap(self.index)
        result = self.family.IF.Set(
            list(omap.allowed(left, principals, permission))
            )
        return result

    def _apply(self, names):
        raise NotImplementedError

    def negate(self):
        raise NotImplementedError

    def __str__(self):
        return 'allows query'

########NEW FILE########
__FILENAME__ = subscribers
import logging
import os

from zope.interface.interfaces import ComponentLookupError

from pyramid.settings import asbool
from pyramid.events import (
    ApplicationCreated,
    subscriber,
    )
from pyramid.request import Request

from ..event import (
    subscribe_added,
    subscribe_removed,
    subscribe_modified,
    )

from ..objectmap import find_objectmap

from ..util import (
    postorder,
    get_oid,
    find_catalogs,
    )

from ..evolution import EvolutionManager

logger = logging.getLogger(__name__)

@subscribe_added()
def object_added(event):
    """ An IObjectAdded event subscriber which indexes an object and and its
    children in every catalog service in the lineage of the object. Depends
    upon the fact that ``substanced.objectmap.object_will_be_added`` to
    assign an ``__oid__`` to the object and its children will have been
    fired before this gets fired.
    """
    obj = event.object
    catalogs = find_catalogs(obj)
    if not catalogs:
        return

    reindex_only = False

    if event.moving is not None:
        # If we're being moved into a place with the same catalogs
        # as the old place, just reindex; don't add.  The object_removed
        # subscriber depends on this behavior.
        if event.parent is event.moving:
            # optimization to avoid calling find_catalogs during simple rename
            reindex_only = True 
        else:
            old_catalogs = find_catalogs(event.moving)
            if catalogs == old_catalogs:
                reindex_only = True

    # XXX note that adding objects to an unseated folder that itself contains a
    # catalog will cause rework to be done, as the below logic will fire once
    # for the children of the object that was added before the seating, then
    # once for the same children when the parent object is seated.

    for node in postorder(obj):
        oid = get_oid(node, None)
        if oid is not None:
            for catalog in catalogs:
                if reindex_only:
                    catalog.reindex_resource(node, oid=oid)
                else:
                    catalog.index_resource(node, oid=oid)

@subscribe_removed()
def object_removed(event):
    """ Unindex an object and its children from every catalog service object's
    lineage; an :class:`substanced.event.ObjectRemoved` event
    subscriber"""
    parent = event.parent
    catalogs = find_catalogs(parent)

    if event.moving is not None:
        # Don't actually unindex anything if we're moving to a place that has a
        # lineage with the same set of catalogs; the object_added event
        # subscriber will reindex everything, so there's no sense in actually
        # doing an unindex.
        rename_in_progress = parent is event.moving
        if rename_in_progress:
            # Common-case optimization to avoid calling find_catalogs below
            return 
        else:
            new_catalogs = find_catalogs(event.moving)
            if catalogs == new_catalogs:
                return

    # If this event is not a moving event, or if it is a moving event and the
    # set of catalogs differs between the object's old home and its new home,
    # unindex every object related to this removal.

    removed = event.removed_oids

    for catalog in catalogs:
        for oid in catalog.family.IF.intersection(removed, catalog.objectids):
            catalog.unindex_resource(oid)

@subscribe_modified()
def object_modified(event):
    """ Reindex a single object (non-recursive) in every catalog service in
    the object's lineage; an :class:`substanced.event.ObjectModifed` event
    subscriber"""
    obj = event.object
    oid = get_oid(obj, None)
    if oid is not None:
        catalogs = find_catalogs(obj)
        for catalog in catalogs:
            catalog.reindex_resource(obj, oid=oid)

@subscriber(ApplicationCreated)
def on_startup(event):
    app = event.object
    registry = app.registry
    settings = getattr(registry, 'settings', {})
    autosync = asbool(
        os.environ.get(
            'SUBSTANCED_CATALOGS_AUTOSYNC',
            settings.get(
                'substanced.catalogs.autosync',
                settings.get('substanced.autosync_catalogs', False) # bc
                )))
    autoreindex = asbool(
        os.environ.get(
            'SUBSTANCED_CATALOGS_AUTOREINDEX',
            settings.get(
                'substanced.catalogs.autoreindex',
                settings.get('substanced.autoreindex_catalogs', False) # bc
                )))
    if autosync:
        request = Request.blank('/autosync_catalogs') # path is meaningless
        request.registry = registry
        root = app.root_factory(request)
        em = EvolutionManager(root, registry)
        unfinished = list(em.get_unfinished_steps())
        if unfinished:
            # adding or removing indexes to/from an environment where evolution
            # is incomplete may lead to end-user-irreconcilable errors (cant
            # evolve because autosync is on and causes errors, cant autosync
            # because evolve steps havent been run), so we avoid doing any
            # sync if there are unfinished evolve steps
            logger.warn(
                'Cannot autosync/autoreindex catalog due to unfinished evolve '
                'steps'
                )
            return
        objectmap = find_objectmap(root)
        if objectmap is not None:
            content = registry.content
            factory_type = content.factory_type_for_content_type('Catalog')
            oids = objectmap.get_extent(factory_type)
            for oid in oids:
                catalog = objectmap.object_for(oid)
                if catalog is not None:
                    try:
                        catalog.update_indexes(
                            registry=registry,
                            reindex=autoreindex
                            )
                    except ComponentLookupError:
                        # could not find a catalog factory
                        pass
                    

########NEW FILE########
__FILENAME__ = system
from ..util import get_interfaces

from .factories import (
    Field,
    Keyword,
    Path,
    Allowed,
    Text,
    )

from . import (
    catalog_factory,
    indexview,
    indexview_defaults,
    )

from ..interfaces import (
    MODE_DEFERRED,
    )
from ..util import get_content_type

@indexview_defaults(catalog_name='system')
class SystemIndexViews(object):
    def __init__(self, resource):
        self.resource = resource

    @indexview()
    def interfaces(self, default):
        """ Return a set of all interfaces implemented by the object, including
        inherited interfaces (but no classes).
        """
        return get_interfaces(self.resource, classes=False)

    @indexview()
    def name(self, default):
        """ Returns the ``__name__`` of the object or ``default`` if the object
        has no ``__name__``."""
        name = getattr(self.resource, '__name__', default)
        if name is None: # deal with name = None at root
            return default
        return name

    @indexview()
    def content_type(self, default):
        """ Returns the Substance D content type of the resource """
        result = get_content_type(self.resource)
        if result is None:
            return default
        return result
 
    @indexview()
    def text(self, default):
        """ Returns a derivation of the name for text indexing.  If name has no
        separator characters in it, the function will return the name
        unchanged.  Otherwise it will return the name plus the derivation of
        splitting the name on the separator characters.  The separator
        characters are: ``, . - _``.  For example, if the name is
        ``foo-bar_baz.pt,foz``, the return value will be ``foo-bar_baz.pt,foz
        foo bar baz pt foz``.  This allows for the most common lookups of
        partial index values in the filter box."""
        name = self.name(default)
        if name is default:
            return default
        if not hasattr(name, 'split'):
            return name
        val = name
        for char in (',', '-', '_', '.'):
            val = ' '.join([x.strip() for x in val.split(char)])
        if val != name:
            return name + ' ' + val
        return name

@catalog_factory('system')
class SystemCatalogFactory(object):
    """ The default set of Substance D system indexes.

    - path (a PathIndex)

      Represents the path of the content object.

    - name (a FieldIndex)

      Represents the local name of the content object.

    - interfaces (a KeywordIndex)

      Represents the set of interfaces possessed by the content object.

    - content_type (a FieldIndex)

      Represents the Substance D content type of an added object.
      
    - allowed (an AllowedIndex)

      Can be used in a query to filter results using permissions and
      principals.
      
    - text (a TextIndex)

      Indexes text used for the Substance D folder contents filter box.

    """
    path = Path()

    # name is MODE_ATCOMMIT for next-request folder contents consistency
    name = Field()

    # interfaces is MODE_ATCOMMIT because code which creates one may
    # need to access it immediately.
    interfaces = Keyword()

    allowed = Allowed()

    text = Text(action_mode=MODE_DEFERRED)

    # content_type is MODE_ATCOMMIT because code which creates one may
    # need to access it immediately.
    content_type = Field()

########NEW FILE########
__FILENAME__ = test_catalog
import re
import unittest
from pyramid import testing
import BTrees

from zope.interface import (
    implementer,
    alsoProvides,
    )

from hypatia.interfaces import IIndex

from ..._compat import u
_BLANK = u('')
_A = u('a')
_B = u('b')

def _makeSite(**kw):
    from ...interfaces import IFolder
    from ...interfaces import IService
    site = testing.DummyResource(__provides__=kw.pop('__provides__', None))
    alsoProvides(site, IFolder)
    objectmap = kw.pop('objectmap', None)
    if objectmap is not None:
        site.__objectmap__ = objectmap
    for k, v in kw.items():
        site[k] = v
        v.__provides__ = IService
    return site

class TestCatalog(unittest.TestCase):
    family = BTrees.family64
    
    def setUp(self):
        self.config = testing.setUp()
        from zope.deprecation import __show__
        __show__.off()

    def tearDown(self):
        testing.tearDown()
        from zope.deprecation import __show__
        __show__.on()

    def _getTargetClass(self):
        from .. import Catalog
        return Catalog
        
    def _makeOne(self, *arg, **kw):
        cls = self._getTargetClass()
        inst = cls(*arg, **kw)
        inst.__name__ = 'catalog'
        return inst

    def test___sdi_addable__True(self):
        inst = self._makeOne()
        intr = {'meta':{'is_index':True}}
        self.assertTrue(inst.__sdi_addable__(None, intr))

    def test___sdi_addable__False(self):
        inst = self._makeOne()
        intr = {'meta':{}}
        self.assertFalse(inst.__sdi_addable__(None, intr))

    def test_klass_provides_ICatalog(self):
        klass = self._getTargetClass()
        from zope.interface.verify import verifyClass
        from ...interfaces import ICatalog
        verifyClass(ICatalog, klass)
        
    def test_inst_provides_ICatalog(self):
        from zope.interface.verify import verifyObject
        from ...interfaces import ICatalog
        inst = self._makeOne()
        verifyObject(ICatalog, inst)

    def test_flush(self):
        inst = self._makeOne()
        idx = DummyIndex()
        inst['name'] = idx
        inst.flush()
        self.assertEqual(idx.flushed, True)

    def test_reset(self):
        catalog = self._makeOne()
        idx = DummyIndex()
        catalog['name'] = idx
        catalog.reset()
        self.assertEqual(idx.cleared, True)
        
    def test_reset_objectids(self):
        inst = self._makeOne()
        inst.objectids.insert(1)
        inst.reset()
        self.assertEqual(list(inst.objectids), [])

    def test_ctor_defaults(self):
        catalog = self._makeOne()
        self.assertTrue(catalog.family is self.family)

    def test_ctor_explicit_family(self):
        catalog = self._makeOne(family=BTrees.family32)
        self.assertTrue(catalog.family is BTrees.family32)

    def test_index_resource_indexes(self):
        catalog = self._makeOne()
        idx = DummyIndex()
        catalog['name'] = idx
        catalog.index_resource('value', 1)
        self.assertEqual(idx.oid, 1)
        self.assertEqual(idx.resource, 'value')

    def test_index_resource_objectids(self):
        inst = self._makeOne()
        inst.index_resource(object(), 1)
        self.assertEqual(list(inst.objectids), [1])

    def test_index_resource_nonint_docid(self):
        catalog = self._makeOne()
        idx = DummyIndex()
        catalog['name'] = idx
        self.assertRaises(TypeError, catalog.index_resource, 'value', 'abc')

    def test_index_resource_oid_is_None(self):
        resource = testing.DummyResource()
        resource.__oid__ = 1
        catalog = self._makeOne()
        idx = DummyIndex()
        catalog['name'] = idx
        catalog.index_resource(resource)
        self.assertEqual(idx.oid, 1)
        self.assertEqual(idx.resource, resource)

    def test_index_doc(self):
        catalog = self._makeOne()
        idx = DummyIndex()
        catalog['name'] = idx
        catalog.index_doc(1, 'value')
        self.assertEqual(idx.oid, 1)
        self.assertEqual(idx.resource, 'value')

    def test_unindex_resource_indexes(self):
        catalog = self._makeOne()
        idx = DummyIndex()
        catalog['name'] = idx
        catalog.unindex_resource(1)
        self.assertEqual(idx.unindexed, 1)
        
    def test_unindex_resource_objectids_exists(self):
        inst = self._makeOne()
        inst.objectids.insert(1)
        inst.unindex_resource(1)
        self.assertEqual(list(inst.objectids), [])

    def test_unindex_resource_objectids_notexists(self):
        inst = self._makeOne()
        inst.unindex_resource(1)
        self.assertEqual(list(inst.objectids), [])

    def test_index_resource_or_oid_is_resource_without_oid(self):
        resource = testing.DummyResource()
        catalog = self._makeOne()
        self.assertRaises(ValueError, catalog.unindex_resource, resource)

    def test_index_resource_or_oid_is_noninteger(self):
        catalog = self._makeOne()
        self.assertRaises(ValueError, catalog.unindex_resource, 'foo')

    def test_unindex_doc(self):
        inst = self._makeOne()
        inst.objectids.insert(1)
        inst.unindex_doc(1)
        self.assertEqual(list(inst.objectids), [])

    def test_reindex_resource_indexes(self):
        catalog = self._makeOne()
        idx = DummyIndex()
        catalog['name'] = idx
        catalog.reindex_resource('value', 1)
        self.assertEqual(idx.reindexed_oid, 1)
        self.assertEqual(idx.reindexed_resource, 'value')

    def test_reindex_resource_objectids_exists(self):
        inst = self._makeOne()
        inst.objectids.insert(1)
        inst.reindex_resource(object(), 1)
        self.assertEqual(list(inst.objectids), [1])
        
    def test_reindex_resource_objectids_notexists(self):
        inst = self._makeOne()
        inst.reindex_resource(object(), 1)
        self.assertEqual(list(inst.objectids), [1])
        
    def test_reindex_resource_oid_is_None(self):
        resource = testing.DummyResource()
        resource.__oid__ = 1
        catalog = self._makeOne()
        idx = DummyIndex()
        catalog['name'] = idx
        catalog.reindex_resource(resource)
        self.assertEqual(idx.reindexed_oid, 1)
        self.assertEqual(idx.reindexed_resource, resource)

    def test_reindex_doc(self):
        catalog = self._makeOne()
        idx = DummyIndex()
        catalog['name'] = idx
        catalog.reindex_doc(1, 'value')
        self.assertEqual(idx.reindexed_oid, 1)
        self.assertEqual(idx.reindexed_resource, 'value')

    def test_reindex(self):
        a = testing.DummyModel()
        L = []
        transaction = DummyTransaction()
        inst = self._makeOne()
        inst.transaction = transaction
        objectmap = DummyObjectMap({1:[a, (_BLANK, _A)]})
        site = _makeSite(catalog=inst, objectmap=objectmap)
        site['a'] = a
        inst.objectids = [1]
        def reindex_resource(resource, oid=None, action_mode=None):
            L.append((oid, resource))
        inst.reindex_resource = reindex_resource
        inst.flush = lambda *arg, **kw: True
        out = []
        inst.reindex(output=out.append)
        self.assertEqual(len(L), 1)
        self.assertEqual(L[0][0], 1)
        self.assertEqual(L[0][1], a)
        self.assertEqual(out,
                          ["catalog reindexing /a",
                          '*** committing ***'])
        self.assertEqual(transaction.committed, 1)

    def test_reindex_with_missing_path(self):
        a = testing.DummyModel()
        L = []
        transaction = DummyTransaction()
        objectmap = DummyObjectMap(
            {1: [a, (_BLANK, _A)], 2:[None, (_BLANK, _B)]}
            )
        inst = self._makeOne()
        inst.transaction = transaction
        site = _makeSite(catalog=inst, objectmap=objectmap)
        site['a'] = a
        inst.objectids = [1, 2]
        def reindex_resource(resource, oid=None, action_mode=None):
            L.append((oid, resource))
        inst.reindex_resource = reindex_resource
        inst.flush = lambda *arg, **kw: True
        out = []
        inst.reindex(output=out.append)
        self.assertEqual(L[0][0], 1)
        self.assertEqual(L[0][1], a)
        self.assertEqual(out,
                          ["catalog reindexing /a",
                          "error: object at path /b not found",
                          '*** committing ***'])
        self.assertEqual(transaction.committed, 1)

    def test_reindex_with_missing_objectid(self):
        a = testing.DummyModel()
        L = []
        transaction = DummyTransaction()
        objectmap = DummyObjectMap()
        inst = self._makeOne()
        inst.transaction = transaction
        inst.flush = lambda *arg, **kw: True
        site = _makeSite(catalog=inst, objectmap=objectmap)
        site['a'] = a
        inst.objectids = [1]
        out = []
        inst.reindex(output=out.append)
        self.assertEqual(L, [])
        self.assertEqual(out,
                          ["error: no path for objectid 1 in object map",
                          '*** committing ***'])
        self.assertEqual(transaction.committed, 1)
        
        
    def test_reindex_pathre(self):
        a = testing.DummyModel()
        b = testing.DummyModel()
        L = []
        objectmap = DummyObjectMap({1: [a, (_BLANK, _A)],
                                    2: [b, (_BLANK, _B)]})
        transaction = DummyTransaction()
        inst = self._makeOne()
        inst.transaction = transaction
        inst.flush = lambda *arg, **kw: True
        site = _makeSite(catalog=inst, objectmap=objectmap)
        site['a'] = a
        site['b'] = b
        inst.objectids = [1, 2]
        def reindex_resource(resource, oid=None, action_mode=None):
            L.append((oid, resource))
        inst.reindex_resource = reindex_resource
        out = []
        inst.reindex(
            path_re=re.compile('/a'), 
            output=out.append
            )
        self.assertEqual(L[0][0], 1)
        self.assertEqual(L[0][1], a)
        self.assertEqual(out,
                          ['catalog reindexing /a',
                          '*** committing ***'])
        self.assertEqual(transaction.committed, 1)

    def test_reindex_dryrun(self):
        a = testing.DummyModel()
        b = testing.DummyModel()
        L = []
        objectmap = DummyObjectMap({1: [a, (_BLANK, _A)], 2: [b, (_BLANK, _B)]})
        transaction = DummyTransaction()
        inst = self._makeOne()
        inst.transaction = transaction
        site = _makeSite(catalog=inst, objectmap=objectmap)
        site['a'] = a
        site['b'] = b
        inst.objectids = [1,2]
        def reindex_resource(resource, oid, action_mode=None):
            L.append((oid, resource))
        inst.reindex_resource = reindex_resource
        inst.flush = lambda *arg, **kw: True
        out = []
        inst.reindex(dry_run=True, output=out.append)
        self.assertEqual(len(L), 2)
        L.sort()
        self.assertEqual(L[0][0], 1)
        self.assertEqual(L[0][1], a)
        self.assertEqual(L[1][0], 2)
        self.assertEqual(L[1][1], b)
        self.assertEqual(out,
                         ['catalog reindexing /a',
                          'catalog reindexing /b',
                          '*** aborting ***'])
        self.assertEqual(transaction.aborted, 1)
        self.assertEqual(transaction.committed, 0)

    def test_reindex_with_indexes(self):
        a = testing.DummyModel()
        L = []
        objectmap = DummyObjectMap({1: [a, (_BLANK, _A)]})
        transaction = DummyTransaction()
        inst = self._makeOne()
        inst.transaction = transaction
        site = _makeSite(catalog=inst, objectmap=objectmap)
        site['a'] = a
        inst.objectids = [1]
        index = DummyIndex()
        inst['index'] = index
        self.config.registry._substanced_indexes = {'index':index}
        def reindex_resource(resource, oid=None, action_mode=None):
            L.append((oid, resource))
        index.reindex_resource = reindex_resource
        inst.flush = lambda *arg, **kw: True
        out = []
        inst.reindex(indexes=('index',),  output=out.append)
        self.assertEqual(out,
                          ["catalog reindexing only indexes ('index',)",
                          'catalog reindexing /a',
                          '*** committing ***'])
        self.assertEqual(transaction.committed, 1)
        self.assertEqual(len(L), 1)
        self.assertEqual(L[0][0], 1)
        self.assertEqual(L[0][1], a)

    def _setup_factory(self, factory=None):
        from substanced.interfaces import ICatalogFactory
        registry = self.config.registry
        if factory is None:
            factory = DummyFactory(True)
        registry.registerUtility(factory, ICatalogFactory, name='catalog')

    def test_update_indexes_nothing_to_do(self):
        self._setup_factory(DummyFactory(False))
        registry = self.config.registry
        out = []
        inst = self._makeOne()
        transaction = DummyTransaction()
        inst.transaction = transaction
        inst.update_indexes(registry=registry,  output=out.append)
        self.assertEqual(
            out,  
            ['catalog update_indexes: no indexes added or removed'],
            )
        self.assertEqual(transaction.committed, 0)
        self.assertEqual(transaction.aborted, 0)

    def test_update_indexes_replace(self):
        self._setup_factory()
        registry = self.config.registry
        out = []
        inst = self._makeOne()
        transaction = DummyTransaction()
        inst.transaction = transaction
        inst.update_indexes(registry=registry, output=out.append, replace=True)
        self.assertEqual(out, ['*** committing ***'])
        self.assertEqual(transaction.committed, 1)
        self.assertEqual(transaction.aborted, 0)
        self.assertTrue(inst.replaced)

    def test_update_indexes_noreplace(self):
        self._setup_factory()
        registry = self.config.registry
        out = []
        inst = self._makeOne()
        transaction = DummyTransaction()
        inst.transaction = transaction
        inst.update_indexes(registry=registry, output=out.append)
        self.assertEqual(out, ['*** committing ***'])
        self.assertEqual(transaction.committed, 1)
        self.assertEqual(transaction.aborted, 0)
        self.assertTrue(inst.synced)

    def test_update_indexes_dryrun(self):
        self._setup_factory()
        registry = self.config.registry
        out = []
        inst = self._makeOne()
        transaction = DummyTransaction()
        inst.transaction = transaction
        inst.update_indexes(registry=registry, output=out.append, dry_run=True)
        self.assertEqual(out, ['*** aborting ***'])
        self.assertEqual(transaction.committed, 0)
        self.assertEqual(transaction.aborted, 1)

class Test_is_catalogable(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, resource, registry=None):
        from .. import is_catalogable
        return is_catalogable(resource, registry)

    def _registerIndexView(self):
        from zope.interface import Interface
        from substanced.interfaces import IIndexView
        self.config.registry.registerAdapter(True, (Interface,), IIndexView)

    def test_no_registry_passed(self):
        resource = Dummy()
        self._registerIndexView()
        self.assertTrue(self._callFUT(resource))

    def test_true(self):
        resource = Dummy()
        self._registerIndexView()
        registry = self.config.registry
        self.assertTrue(self._callFUT(resource, registry))

    def test_false(self):
        resource = Dummy()
        registry = self.config.registry
        self.assertFalse(self._callFUT(resource, registry))

class Test_add_catalog_factory(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _callFUT(self, config, name, factory):
        from .. import add_catalog_factory
        return add_catalog_factory(config, name, factory)

    def test_it(self):
        from substanced.interfaces import ICatalogFactory
        from substanced.catalog import Field
        config = DummyConfigurator(registry=self.config.registry)
        class Factory(object):
            index = Field()
        self._callFUT(config, 'name', Factory)
        self.assertEqual(len(config.actions), 1)
        action = config.actions[0]
        self.assertEqual(
            action['discriminator'],
            ('sd-catalog-factory', 'name')
            )
        self.assertEqual(
            action['introspectables'], (config.intr,)
            )
        self.assertEqual(config.intr['name'], 'name')
        self.assertEqual(config.intr['factory'].__class__.__name__,
                         'CatalogFactory')
        callable = action['callable']
        callable()
        self.assertEqual(
            self.config.registry.getUtility(ICatalogFactory, 'name'),
            config.intr['factory']
            )

class Test_add_indexview(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _callFUT(
        self,
        config,
        view,
        catalog_name,
        index_name,
        context=None,
        attr=None,
        ):
        from .. import add_indexview
        return add_indexview(
            config, view, catalog_name, index_name, context=context, attr=attr
            )

    def test_it_func(self):
        from zope.interface import Interface
        from substanced.interfaces import IIndexView
        config = DummyConfigurator(registry=self.config.registry)
        def view(resource, default): return True
        self._callFUT(config, view, 'catalog', 'index')
        self.assertEqual(len(config.actions), 1)
        action = config.actions[0]
        self.assertEqual(
            action['discriminator'],
            ('sd-index-view', 'catalog', 'index', Interface)
            )
        self.assertEqual(
            action['introspectables'], (config.intr,)
            )
        self.assertEqual(config.intr['catalog_name'], 'catalog')
        self.assertEqual(config.intr['index_name'], 'index')
        self.assertEqual(config.intr['name'], 'catalog|index')
        self.assertEqual(config.intr['callable'], view)
        self.assertEqual(config.intr['attr'], None)
        callable = action['callable']
        callable()
        wrapper = self.config.registry.adapters.lookup(
            (Interface,), IIndexView, name='catalog|index')
        self.assertEqual(config.intr['derived_callable'], wrapper)

    def test_it_cls_with_attr(self):
        from zope.interface import Interface
        from substanced.interfaces import IIndexView
        config = DummyConfigurator(registry=self.config.registry)
        class View(object):
            def amethod(self, default): pass
        self._callFUT(config, View, 'catalog', 'index', attr='amethod')
        self.assertEqual(len(config.actions), 1)
        action = config.actions[0]
        self.assertEqual(
            action['discriminator'],
            ('sd-index-view', 'catalog', 'index', Interface)
            )
        self.assertEqual(
            action['introspectables'], (config.intr,)
            )
        self.assertEqual(config.intr['catalog_name'], 'catalog')
        self.assertEqual(config.intr['index_name'], 'index')
        self.assertEqual(config.intr['name'], 'catalog|index')
        self.assertEqual(config.intr['callable'], View)
        self.assertEqual(config.intr['attr'], 'amethod')
        callable = action['callable']
        callable()
        wrapper = self.config.registry.adapters.lookup(
            (Interface,), IIndexView, name='catalog|index')
        self.assertEqual(config.intr['derived_callable'], wrapper)

class Test_catalog_factory(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self, name):
        from .. import catalog_factory
        return catalog_factory(name)

    def test_it(self):
        class Foo(object):
            pass
        inst = self._makeOne('catalog')
        venusian = DummyVenusian()
        inst.venusian = venusian
        context = testing.DummyResource()
        context.config = DummyConfigurator(None)
        result = inst(Foo)
        self.assertEqual(result, Foo)
        venusian.callback(context, None, 'abc')
        self.assertEqual(context.config.catalog_factory, ('catalog', Foo))

class Test_CatalogablePredicate(unittest.TestCase):
    def _makeOne(self, val, config):
        from .. import _CatalogablePredicate
        return _CatalogablePredicate(val, config)

    def test_text(self):
        config = Dummy()
        config.registry = Dummy()
        inst = self._makeOne(True, config)
        self.assertEqual(inst.text(), 'catalogable = True')

    def test_phash(self):
        config = Dummy()
        config.registry = Dummy()
        inst = self._makeOne(True, config)
        self.assertEqual(inst.phash(), 'catalogable = True')

    def test__call__(self):
        config = Dummy()
        config.registry = Dummy()
        inst = self._makeOne(True, config)
        def is_catalogable(context, registry):
            self.assertEqual(context, None)
            self.assertEqual(registry, config.registry)
            return True
        inst.is_catalogable = is_catalogable
        self.assertEqual(inst(None, None), True)

class Test_catalog_buttons(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def test_it(self):
        from .. import catalog_buttons
        context = testing.DummyResource()
        request = testing.DummyRequest()
        default_buttons = [1]
        buttons = catalog_buttons(context, request, default_buttons)
        self.assertEqual(buttons,
                         [
                             {'buttons':
                              [{'text': 'Reindex',
                                'class': 'btn-primary btn-sdi-sel',
                                'id': 'reindex',
                                'value': 'reindex',
                                'name': 'form.reindex'}],
                              'type': 'single'},
                             1])

class Test_IndexViewMapper(unittest.TestCase):
    def _makeOne(self, attr=None):
        from .. import _IndexViewMapper
        return _IndexViewMapper(attr=attr)

    def test_call_class(self):
        class Foo(object):
            def __init__(self, resource):
                self.resource = resource

            def __call__(self, default):
                return self.resource
        inst = self._makeOne()
        view = inst(Foo)
        result = view('123', None)
        self.assertEqual(result, '123')

    def test_call_class_with_attr(self):
        class Foo(object):
            def __init__(self, resource):
                self.resource = resource

            def meth(self, default):
                return self.resource
        inst = self._makeOne(attr='meth')
        view = inst(Foo)
        result = view('123', None)
        self.assertEqual(result, '123')

    def test_call_function(self):
        def foo(resource, default):
            return resource
        inst = self._makeOne()
        view = inst(foo)
        result = view('123', None)
        self.assertEqual(result, '123')

    def test_call_function_with_attr(self):
        def foo(): pass
        def bar(resource, default):
            return resource
        foo.bar = bar
        inst = self._makeOne(attr='bar')
        view = inst(foo)
        result = view('123', None)
        self.assertEqual(result, '123')

class TestCatalogsService(unittest.TestCase):
    def _makeOne(self, *arg, **kw):
        from .. import CatalogsService
        inst = CatalogsService(*arg, **kw)
        return inst

    def test_add_catalog_update_indexes_defaults_True(self):
        inst = self._makeOne()
        inst.Catalog = DummyCatalog
        catalog = inst.add_catalog('foo')
        self.assertTrue('foo' in inst)
        self.assertTrue(catalog.updated)
        self.assertEqual(catalog.indexed, [1])

    def test_add_catalog_update_indexes_false(self):
        inst = self._makeOne()
        inst.Catalog = DummyCatalog
        inst.add_catalog('foo', update_indexes=False)
        catalog = inst['foo']
        self.assertFalse(catalog.__sdi_deletable__)
        self.assertEqual(catalog.indexed, [1])

    def test_add_catalog_with_update_indexes(self):
        inst = self._makeOne()
        inst.Catalog = DummyCatalog
        catalog = inst.add_catalog('foo', update_indexes=True)
        self.assertTrue('foo' in inst)
        self.assertTrue(catalog.updated)

    def test___sdi_addable__(self):
        inst = self._makeOne()
        self.assertFalse(inst.__sdi_addable__(None, None))

class Test_indexview(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _getTargetClass(self):
        from substanced.catalog import indexview
        return indexview

    def _makeOne(self, *arg, **kw):
        return self._getTargetClass()(*arg, **kw)

    def test_create_defaults(self):
        decorator = self._makeOne()
        self.assertEqual(decorator.settings, {})

    def test_create_nondefaults(self):
        decorator = self._makeOne(
            catalog_name=None, index_name='fred'
            )
        self.assertEqual(decorator.settings['catalog_name'], None)
        self.assertEqual(decorator.settings['index_name'], 'fred')

    def test_call_as_method(self):
        decorator = self._makeOne(catalog_name='fred', context='context')
        venusian = DummyVenusian()
        decorator.venusian = venusian
        decorator.venusian.info.scope = 'class'
        def foo(self): pass
        def bar(self): pass
        class foo(object):
            foomethod = decorator(foo)
            barmethod = decorator(bar)
        config = call_venusian(venusian)
        settings = config.settings
        self.assertEqual(len(settings), 2)
        self.assertEqual(settings[0]['attr'], 'foo')
        self.assertEqual(settings[0]['index_name'], 'foo')
        self.assertEqual(settings[0]['catalog_name'], 'fred')
        self.assertEqual(settings[0]['context'], 'context')
        self.assertEqual(settings[1]['attr'], 'bar')
        self.assertEqual(settings[1]['catalog_name'], 'fred')
        self.assertEqual(settings[1]['index_name'], 'bar')
        self.assertEqual(settings[1]['context'], 'context')

    def test_call_as_method_with_indexname(self):
        decorator1 = self._makeOne(catalog_name='fred', context='context',
                                   index_name='abc')
        decorator2 = self._makeOne(catalog_name='fred', context='context',
                                   index_name='def')
        venusian = DummyVenusian()
        decorator1.venusian = venusian
        decorator1.venusian.info.scope = 'class'
        decorator2.venusian = venusian
        decorator2.venusian.info.scope = 'class'
        def foo(self): pass
        def bar(self): pass
        class foo(object):
            foomethod = decorator1(foo)
            barmethod = decorator2(bar)
        config = call_venusian(venusian)
        settings = config.settings
        self.assertEqual(len(settings), 2)
        self.assertEqual(settings[0]['attr'], 'foo')
        self.assertEqual(settings[0]['index_name'], 'abc')
        self.assertEqual(settings[0]['catalog_name'], 'fred')
        self.assertEqual(settings[0]['context'], 'context')
        self.assertEqual(settings[1]['attr'], 'bar')
        self.assertEqual(settings[1]['catalog_name'], 'fred')
        self.assertEqual(settings[1]['index_name'], 'def')
        self.assertEqual(settings[1]['context'], 'context')
        
    def test_call_withdepth(self):
        decorator = self._makeOne(_depth=1)
        venusian = DummyVenusian()
        decorator.venusian = venusian
        def bar(self): pass
        class foo(object):
            foomethod = decorator(bar)
        self.assertEqual(venusian.depth, 2)

        
class Test_indexview_defaults(unittest.TestCase):
    def test_it(self):
        from substanced.catalog import indexview_defaults
        @indexview_defaults(route_name='abc', renderer='def')
        class Foo(object): pass
        self.assertEqual(Foo.__view_defaults__['route_name'],'abc')
        self.assertEqual(Foo.__view_defaults__['renderer'],'def')

    def test_it_inheritance_not_overridden(self):
        from substanced.catalog import indexview_defaults
        @indexview_defaults(route_name='abc', renderer='def')
        class Foo(object): pass
        class Bar(Foo): pass
        self.assertEqual(Bar.__view_defaults__['route_name'],'abc')
        self.assertEqual(Bar.__view_defaults__['renderer'],'def')

    def test_it_inheritance_overriden(self):
        from substanced.catalog import indexview_defaults
        @indexview_defaults(route_name='abc', renderer='def')
        class Foo(object): pass
        @indexview_defaults(route_name='ghi')
        class Bar(Foo): pass
        self.assertEqual(Bar.__view_defaults__['route_name'],'ghi')
        self.assertFalse('renderer' in Bar.__view_defaults__)

    def test_it_inheritance_overriden_empty(self):
        from substanced.catalog import indexview_defaults
        @indexview_defaults(route_name='abc', renderer='def')
        class Foo(object): pass
        @indexview_defaults()
        class Bar(Foo): pass
        self.assertEqual(Bar.__view_defaults__, {})
        
class DummyIntrospectable(dict):
    pass

class DummyConfigurator(object):
    _ainfo = None
    def __init__(self, registry):
        self.actions = []
        self.intr = DummyIntrospectable()
        self.registry = registry
        self.indexes = []

    def action(self, discriminator, callable, order=None, introspectables=()):
        self.actions.append(
            {
            'discriminator':discriminator,
            'callable':callable,
            'order':order,
            'introspectables':introspectables,
            })

    def with_package(self, package):
        return self

    def introspectable(self, category, discriminator, name, single):
        return self.intr

    def add_catalog_factory(self, name, cls, **extra):
        self.catalog_factory = (name, cls)

    def maybe_dotted(self, view):
        return view

class DummyObjectMap(object):
    def __init__(self, objectid_to=None): 
        if objectid_to is None: objectid_to = {}
        self.objectid_to = objectid_to

    def path_for(self, objectid):
        data = self.objectid_to.get(objectid)
        if data is None: return
        return data[1]

    def object_for(self, objectid):
        data = self.objectid_to.get(objectid)
        if data is None:
            return
        return data[0]

    def add(self, node, path_tuple, duplicating=False, moving=False):
        pass

class DummyCatalog(dict):
    __oid__ = 1
    def __init__(self):
        self.indexed = []
        
    def update_indexes(self, *arg, **kw):
        self.updated = True

    def index_resource(self, resource, oid=None, action_mode=None):
        self.indexed.append(oid)

class DummyTransaction(object):
    def __init__(self):
        self.committed = 0
        self.aborted = 0
        
    def commit(self):
        self.committed += 1

    def abort(self):
        self.aborted += 1
        

@implementer(IIndex)
class DummyIndex(object):

    resource = None
    oid = None
    action_mode = None
    limit = None
    sort_type = None

    def __init__(self, *arg, **kw):
        self.arg = arg
        self.kw = kw

    def flush(self, all):
        self.flushed = all

    def index_resource(self, resource, oid=None, action_mode=None):
        self.resource = resource
        self.oid = oid
        self.action_mode = action_mode

    def unindex_resource(self, oid, action_mode=None):
        self.unindexed = oid

    def reindex_resource(self, resource, oid=None, action_mode=None):
        self.reindexed_oid = oid
        self.reindexed_resource = resource

    def reset(self):
        self.cleared = True

    def apply_intersect(self, query, docids): # pragma: no cover
        if docids is None:
            return self.arg[0]
        L = []
        for docid in self.arg[0]:
            if docid in docids:
                L.append(docid)
        return L

class Dummy(object):
    pass

class DummyFactory(object):
    def __init__(self, result):
        self.result = result
        
    def replace(self, catalog, **kw):
        catalog.replaced = True
        return self.result

    def sync(self, catalog, **kw):
        catalog.synced = True
        return self.result

class DummyVenusianInfo(object):
    scope = None
    codeinfo = None
    module = None
    def __init__(self, **kw):
        self.__dict__.update(kw)
    
class DummyVenusian(object):
    def __init__(self, info=None):
        if info is None:
            info = DummyVenusianInfo()
        self.info = info
        self.attachments = []
        
    def attach(self, wrapped, callback, category, depth=1):
        self.attachments.append((wrapped, callback, category))
        self.wrapped = wrapped
        self.callback = callback
        self.category = category
        self.depth = depth
        return self.info

class DummyRegistry(object):
    pass

class DummyConfig(object):
    def __init__(self):
        self.settings = []
        self.registry = DummyRegistry()

    def add_indexview(self, ob, **kw):
        self.settings.append(kw)

    def with_package(self, pkg):
        self.pkg = pkg
        return self
    
class DummyVenusianContext(object):
    def __init__(self):
        self.config = DummyConfig()
    
def call_venusian(venusian, context=None):
    if context is None:
        context = DummyVenusianContext()
    for wrapped, callback, category in venusian.attachments:
        callback(context, None, None)
    return context.config
    

########NEW FILE########
__FILENAME__ = test_deferred
import unittest
from pyramid import testing

class TestAction(unittest.TestCase):
    def _makeOne(self):
        from ..deferred import Action
        return Action()

    def test___repr__(self):
        inst = self._makeOne()
        result = repr(inst)
        self.assertTrue(
            result.startswith(
                '<substanced.catalog.deferred.Action object oid None for '
                'index None at')
            )

    def test___hash__(self):
        inst = self._makeOne()
        self.assertEqual(hash(inst), hash((inst.oid, inst.index_oid)))

    def test___eq__True(self):
        inst = self._makeOne()
        other = self._makeOne()
        self.assertTrue(inst == other)

    def test___eq__False(self):
        inst = self._makeOne()
        other = self._makeOne()
        other.oid = 123
        self.assertFalse(inst == other)

    def test___lt__(self):
        inst = self._makeOne()
        other = self._makeOne()
        other.oid = 2
        inst.oid = 1
        self.assertTrue(inst < other)
        
    def test___gt__(self):
        # wrapped with total_ordering from functools, so this should work
        inst = self._makeOne()
        other = self._makeOne()
        other.oid = 2
        inst.oid = 1
        self.assertTrue(other.__gt__(inst))

    def test_find_resource_resource_cant_be_found(self):
        from ..deferred import ResourceNotFound
        index = testing.DummyResource()
        index.__objectmap__ = DummyObjectmap(None)
        inst = self._makeOne()
        inst.index = index
        inst.oid = 1
        self.assertRaises(ResourceNotFound, inst.find_resource)

    def test_find_resource_objectmap_cant_be_found(self):
        from ..deferred import ObjectMapNotFound
        index = testing.DummyResource()
        inst = self._makeOne()
        inst.index = index
        inst.oid = 1
        self.assertRaises(ObjectMapNotFound, inst.find_resource)

    def test_find_resource(self):
        index = testing.DummyResource()
        index.__objectmap__ = DummyObjectmap('abc')
        inst = self._makeOne()
        inst.index = index
        inst.oid = 1
        self.assertEqual(inst.find_resource(), 'abc')

class TestResourceNotFound(unittest.TestCase):
    def _makeOne(self, action):
        from ..deferred import ResourceNotFound
        return ResourceNotFound(action)

    def test___repr__(self):
        inst = self._makeOne(1)
        self.assertEqual(
            repr(inst),
            'Indexing error: cannot find resource for oid 1'
            )

class TestIndexAction(unittest.TestCase):
    def _makeOne(self, index, mode='mode', oid='oid'):
        from ..deferred import IndexAction
        return IndexAction(index, mode, oid)

    def test_index_oid_from_index(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        self.assertEqual(inst.index_oid, index.__oid__)

    def test_execute(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        resource = testing.DummyResource()
        inst.find_resource = lambda *arg: resource
        inst.execute()
        self.assertEqual(index.oid, 'oid')
        self.assertEqual(index.resource, resource)

    def test_execute_objectmap_not_found(self):
        from ..deferred import ObjectMapNotFound
        index = DummyIndex()
        inst = self._makeOne(index)
        logger = DummyLogger()
        inst.logger = logger
        def find_resource():
            raise ObjectMapNotFound(None)
        inst.find_resource = find_resource
        inst.execute()
        self.assertEqual(len(logger.messages), 1)
        self.assertEqual(index.oid, None)

    def test_anti(self):
        from ..deferred import UnindexAction
        index = testing.DummyResource()
        index.__oid__ = 1
        inst = self._makeOne(index)
        result = inst.anti()
        self.assertEqual(result.__class__, UnindexAction)
        self.assertEqual(result.index, index) 
        self.assertEqual(result.index_oid, 1)
        self.assertEqual(result.mode, 'mode')
        self.assertEqual(result.oid, 'oid')

class TestReindexAction(unittest.TestCase):
    def _makeOne(self, index, mode='mode', oid='oid'):
        from ..deferred import ReindexAction
        return ReindexAction(index, mode, oid)

    def test_index_oid_from_index(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        self.assertEqual(inst.index_oid, index.__oid__)

    def test_execute(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        resource = testing.DummyResource()
        inst.find_resource = lambda *arg: resource
        inst.execute()
        self.assertEqual(index.oid, 'oid')
        self.assertEqual(index.resource, resource)

    def test_execute_objectmap_not_found(self):
        from ..deferred import ObjectMapNotFound
        index = DummyIndex()
        inst = self._makeOne(index)
        logger = DummyLogger()
        inst.logger = logger
        def find_resource():
            raise ObjectMapNotFound(None)
        inst.find_resource = find_resource
        inst.execute()
        self.assertEqual(index.oid, None)
        self.assertEqual(len(logger.messages), 1)

    def test_anti(self):
        from ..deferred import ReindexAction
        index = testing.DummyResource()
        index.__oid__ = 1
        inst = self._makeOne(index)
        result = inst.anti()
        self.assertEqual(result.__class__, ReindexAction)
        self.assertEqual(result.index, index)
        self.assertEqual(result.index_oid, 1)
        self.assertEqual(result.mode, 'mode')
        self.assertEqual(result.oid, 'oid')

class TestUnindexAction(unittest.TestCase):
    def _makeOne(self, index, mode='mode', oid='oid'):
        from ..deferred import UnindexAction
        return UnindexAction(index, mode, oid)

    def test_index_oid_from_index(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        self.assertEqual(inst.index_oid, index.__oid__)

    def test_execute(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        inst.execute()
        self.assertEqual(index.oid, 'oid')

    def test_anti(self):
        from ..deferred import IndexAction
        index = testing.DummyResource()
        index.__oid__ = 1
        inst = self._makeOne(index)
        result = inst.anti()
        self.assertEqual(result.__class__, IndexAction)
        self.assertEqual(result.index, index)
        self.assertEqual(result.index_oid, 1)
        self.assertEqual(result.mode, 'mode')
        self.assertEqual(result.oid, 'oid')

class TestActionsQueue(unittest.TestCase):
    def _makeOne(self):
        from ..deferred import ActionsQueue
        return ActionsQueue()

    def test_extend(self):
        inst = self._makeOne()
        inst.extend([1])
        self.assertEqual(inst.actions, [1])
        # cant check for _p_changed getting set, some magic goes on that causes
        # it to be false, bleh
        self.assertEqual(inst.gen, 1)

    def test_len(self):
        inst = self._makeOne()
        inst.extend([1])
        self.assertEqual(len(inst), 1)

    def test_popall_no_actions(self):
        inst = self._makeOne()
        self.assertEqual(inst.popall(), None)
        self.assertEqual(inst.gen, 0)

    def test_popall_with_actions(self):
        inst = self._makeOne()
        inst.actions = [1, 2]
        self.assertEqual(inst.popall(), [1,2])
        self.assertEqual(inst.actions, [])
        self.assertEqual(inst.gen, 1)

    def test__p_resolveConflict_states_have_different_keys(self):
        from ZODB.POSException import ConflictError
        inst = self._makeOne()
        self.assertRaises(
            ConflictError,
            inst._p_resolveConflict, None, {'a':1}, {'b':2}
            )
        
    def test__p_resolveConflict_unknown_state_value_change(self):
        from ZODB.POSException import ConflictError
        inst = self._makeOne()
        self.assertRaises(
            ConflictError,
            inst._p_resolveConflict, None, {'a':1}, {'a':2}
            )

    def test__p_resolveConflict_states_get_optimized(self):
        inst = self._makeOne()
        logger = DummyLogger()
        inst.logger = logger
        a1 = DummyAction(1)
        old = state([])
        committed = state([a1, a1])
        new = state([])
        result = inst._p_resolveConflict(old, committed, new)
        self.assertEqual(len(logger.messages), 2)
        self.assertEqual(result['actions'], [a1])

    def test__p_resolveConflict_action_intersection_states_conflict(self):
        from ZODB.POSException import ConflictError
        from ..deferred import IndexAction, UnindexAction
        inst = self._makeOne()
        logger = DummyLogger()
        inst.logger = logger
        index = DummyIndex()
        a1 = IndexAction(index, 'mode', 'oid')
        a2 = UnindexAction(index, 'mode', 'oid')
        old = state([a1])
        committed = state([a2])
        new = state([])
        self.assertRaises(
            ConflictError, inst._p_resolveConflict, old, committed, new)

    def test__p_resolveConflict_action_intersection_states_resolveable(self):
        from ..deferred import IndexAction, ReindexAction
        inst = self._makeOne()
        logger = DummyLogger()
        inst.logger = logger
        index = DummyIndex()
        a1 = IndexAction(index, 'mode', 'oid')
        a2 = ReindexAction(index, 'mode', 'oid')
        old = state([a1])
        committed = state([a2])
        new = state([])
        result = inst._p_resolveConflict(old, committed, new)
        self.assertEqual(len(logger.messages), 2)
        self.assertEqual(result['actions'], [])

    def test__p_resolveConflict_both_new_and_commited_remove_same(self):
        from ZODB.POSException import ConflictError
        inst = self._makeOne()
        logger = DummyLogger()
        inst.logger = logger
        a1 = DummyAction(1)
        old = state([a1])
        committed = state([])
        new = state([])
        self.assertRaises(
            ConflictError,
            inst._p_resolveConflict,
            old,
            committed,
            new)
        self.assertEqual(len(logger.messages), 2)

    def test__p_resolveConflict_new_and_commited_remove_different(self):
        inst = self._makeOne()
        logger = DummyLogger()
        inst.logger = logger
        a1 = DummyAction(1)
        a2 = DummyAction(2)
        old = state([a1, a2])
        committed = state([a1])
        new = state([a2])
        result = inst._p_resolveConflict(old, committed, new)
        self.assertEqual(len(logger.messages), 2)
        self.assertEqual(result['actions'], [])

    def test__p_resolveConflict_both_new_and_commited_add_same(self):
        from ZODB.POSException import ConflictError
        inst = self._makeOne()
        logger = DummyLogger()
        inst.logger = logger
        a1 = DummyAction(1)
        old = state([])
        committed = state([a1])
        new = state([a1])
        self.assertRaises(
            ConflictError,
            inst._p_resolveConflict,
            old,
            committed,
            new
            )
        self.assertEqual(len(logger.messages), 2)

    def test__p_resolveConflict_new_and_commited_add_different(self):
        inst = self._makeOne()
        logger = DummyLogger()
        inst.logger = logger
        a1 = DummyAction(1)
        a2 = DummyAction(2)
        old = state([])
        committed = state([a1])
        new = state([a2])
        result = inst._p_resolveConflict(old, committed, new)
        self.assertEqual(len(logger.messages), 2)
        self.assertEqual(result['actions'], [a1, a2])
        
    def test__p_resolveConflict_with_committed_added_new_not_added(self):
        inst = self._makeOne()
        a1 = DummyAction(1)
        old = state([])
        committed = state([a1])
        new = state([])
        logger = DummyLogger()
        inst.logger = logger
        result = inst._p_resolveConflict(old, committed, new)
        self.assertEqual(len(logger.messages), 2)
        self.assertEqual(result['actions'], [a1])

    def test__p_resolveConflict_with_new_removed(self):
        inst = self._makeOne()
        a1 = DummyAction(1)
        a2 = DummyAction(2)
        old = state([a1])
        committed = state([a1, a2])
        new = state([])
        logger = DummyLogger()
        inst.logger = logger
        result = inst._p_resolveConflict(old, committed, new)
        self.assertEqual(len(logger.messages), 2)
        self.assertEqual(result['actions'], [a2])

    def test__p_resolveConflict_undo_generates_antiactions_for_removed(self):
        inst = self._makeOne()
        a1 = DummyAction(1)
        a2 = DummyAction(2)
        a3 = DummyAction(3)
        old = state([a1, a2], gen=1)
        committed = state([a3], gen=0)
        new = state([], gen=0)
        logger = DummyLogger()
        inst.logger = logger
        result = inst._p_resolveConflict(old, committed, new)
        self.assertEqual(len(logger.messages), 3)
        actions = result['actions']
        self.assertEqual(result['gen'], 1)
        self.assertEqual(actions[0].oid, 1)
        self.assertEqual(actions[1].oid, 2)
        self.assertEqual(actions[2].oid, 3)
        self.assertTrue(actions[0]._anti)
        self.assertTrue(actions[1]._anti)
        self.assertFalse(actions[2]._anti)

    def test__p_resolveConflict_undo_no_antiactions_to_generate(self):
        inst = self._makeOne()
        a1 = DummyAction(1)
        a2 = DummyAction(2)
        old = state([a1, a2], gen=1)
        committed = state([a1, a2], gen=0)
        new = state([a1, a2], gen=0)
        logger = DummyLogger()
        inst.logger = logger
        result = inst._p_resolveConflict(old, committed, new)
        self.assertEqual(len(logger.messages), 2)
        actions = result['actions']
        self.assertEqual(actions, [a1, a2])
        self.assertEqual(result['gen'], 1)

    def test__p_resolveConflict_undo_anti_already_in_new_added(self):
        from ZODB.POSException import ConflictError
        inst = self._makeOne()
        a1 = DummyAction(1)
        a2 = DummyAction(2, antiresult=a1)
        old = state([a2], gen=1)
        committed = state([], gen=0)
        new = state([a1], gen=0)
        logger = DummyLogger()
        inst.logger = logger
        self.assertRaises(
            ConflictError,
            inst._p_resolveConflict, old, committed, new
            )

    def test__p_resolveConflict_undo_anti_already_in_committed(self):
        from ZODB.POSException import ConflictError
        inst = self._makeOne()
        a1 = DummyAction(1)
        a2 = DummyAction(2, antiresult=a1)
        old = state([a2], gen=1)
        committed = state([a1], gen=0)
        new = state([], gen=0)
        logger = DummyLogger()
        inst.logger = logger
        self.assertRaises(
            ConflictError,
            inst._p_resolveConflict, old, committed, new
            )

    def test__p_resolveConflict_resolved_returns_higher_generation_number(self):
        inst = self._makeOne()
        old = state([], gen=0)
        committed = state([], gen=2)
        new = state([], gen=1)
        logger = DummyLogger()
        inst.logger = logger
        result = inst._p_resolveConflict(old, committed, new)
        self.assertEqual(len(logger.messages), 2)
        self.assertEqual(result['actions'], [])
        self.assertEqual(result['gen'], 2)

    def test__p_resolveConflict_resolved_returns_agreed_upon_pactive(self):
        inst = self._makeOne()
        old = state([], gen=0)
        committed = state([], gen=2)
        new = state([], gen=1)
        logger = DummyLogger()
        inst.logger = logger
        result = inst._p_resolveConflict(old, committed, new)
        self.assertEqual(len(logger.messages), 2)
        self.assertEqual(result['actions'], [])
        self.assertEqual(result['pactive'], True)

class Test_which_action(unittest.TestCase):
    def _callFUT(self, a1, a2):
        from ..deferred import which_action
        return which_action(a1, a2)

    def test_conflict_I_U(self):
        from ZODB.POSException import ConflictError
        from ..deferred import IndexAction, UnindexAction
        index = DummyIndex()
        a1 = IndexAction(index, 'mode', 'oid')
        a2 = UnindexAction(index, 'mode', 'oid')
        self.assertRaises(ConflictError, self._callFUT, a1, a2)
    
    def test_conflict_U_I(self):
        from ZODB.POSException import ConflictError
        from ..deferred import IndexAction, UnindexAction
        index = DummyIndex()
        a1 = UnindexAction(index, 'mode', 'oid')
        a2 = IndexAction(index, 'mode', 'oid')
        self.assertRaises(ConflictError, self._callFUT, a1, a2)

    def test_conflict_R_U(self):
        from ZODB.POSException import ConflictError
        from ..deferred import ReindexAction, UnindexAction
        index = DummyIndex()
        a1 = ReindexAction(index, 'mode', 'oid')
        a2 = UnindexAction(index, 'mode', 'oid')
        self.assertRaises(ConflictError, self._callFUT, a1, a2)

    def test_conflict_U_R(self):
        from ZODB.POSException import ConflictError
        from ..deferred import ReindexAction, UnindexAction
        index = DummyIndex()
        a1 = UnindexAction(index, 'mode', 'oid')
        a2 = ReindexAction(index, 'mode', 'oid')
        self.assertRaises(ConflictError, self._callFUT, a1, a2)

    def test_second_R_I(self):
        from ..deferred import ReindexAction, IndexAction
        index = DummyIndex()
        a1 = ReindexAction(index, 'mode', 'oid')
        a2 = IndexAction(index, 'mode', 'oid')
        self.assertEqual(self._callFUT(a1, a2), a2)

    def test_first_I_R(self):
        from ..deferred import ReindexAction, IndexAction
        index = DummyIndex()
        a1 = IndexAction(index, 'mode', 'oid')
        a2 = ReindexAction(index, 'mode', 'oid')
        self.assertEqual(self._callFUT(a1, a2), a1)

    def test_first_I_I(self):
        from ..deferred import IndexAction
        index = DummyIndex()
        a1 = IndexAction(index, 'mode', 'oid')
        a2 = IndexAction(index, 'mode', 'oid')
        self.assertEqual(self._callFUT(a1, a2), a1)

class Test_action_intersection(unittest.TestCase):
    def _callFUT(self, a1, a2):
        from ..deferred import action_intersection
        return action_intersection(a1, a2)

    def test_conflict_I_U(self):
        from ZODB.POSException import ConflictError
        from ..deferred import IndexAction, UnindexAction
        index = DummyIndex()
        a1 = IndexAction(index, 'mode', 'oid')
        a2 = UnindexAction(index, 'mode', 'oid')
        s1 = set([a1])
        s2 = set([a2])
        self.assertRaises(ConflictError, self._callFUT, s1, s2)

    def test_index_replaces_reindex(self):
        from ..deferred import IndexAction, ReindexAction
        index = DummyIndex()
        a1 = IndexAction(index, 'mode', 'oid')
        a2 = ReindexAction(index, 'mode', 'oid')
        s1 = set([a1])
        s2 = set([a2])
        result = self._callFUT(s1, s2)
        self.assertEqual(list(result), [a1])

    def test_no_matches(self):
        from ..deferred import IndexAction, ReindexAction
        index = DummyIndex()
        a1 = IndexAction(index, 'mode', 'oid1')
        a2 = ReindexAction(index, 'mode', 'oid2')
        a3 = IndexAction(index, 'mode', 'oid3')
        s1 = set([a1, a3])
        s2 = set([a2])
        result = self._callFUT(s1, s2)
        self.assertEqual(sorted(list(result)), [])

    def test_only_some_matches(self):
        from ..deferred import IndexAction, ReindexAction
        index = DummyIndex()
        a1_a = IndexAction(index, 'mode', 'oid1')
        a1_b = ReindexAction(index, 'mode', 'oid1')
        a2 = IndexAction(index, 'mode', 'oid2')
        s1 = set([a1_a, a2])
        s2 = set([a1_b])
        result = self._callFUT(s1, s2)
        self.assertEqual(sorted(list(result)), [a1_a])

class Test_commit(unittest.TestCase):
    def _makeOne(self, tries, meth):
        from ..deferred import commit
        return commit(tries)(meth)

    def test_gardenpath(self):
        ap = DummyActionProcessor(None)
        def fakemethod(ap):
            ap.called += 1
        inst = self._makeOne(3, fakemethod)
        inst(ap)
        self.assertEqual(ap.synced, 1)
        self.assertEqual(ap.called, 1)
        self.assertEqual(ap.transaction.begun, 1)
        self.assertEqual(ap.transaction.committed, 1)

    def test_conflict_overflow(self):
        from ZODB.POSException import ConflictError
        ap = DummyActionProcessor(
            None, [ConflictError, ConflictError, ConflictError]
            )
        def fakemethod(ap):
            ap.called += 1
        inst = self._makeOne(3, fakemethod)
        self.assertRaises(ConflictError, inst, ap)
        self.assertEqual(ap.synced, 3)
        self.assertEqual(ap.called, 3)
        self.assertEqual(ap.transaction.begun, 3)
        self.assertEqual(ap.transaction.committed, 0)
        self.assertEqual(ap.transaction.aborted, 3)

    def test_conflicts_but_success(self):
        from ZODB.POSException import ConflictError
        ap = DummyActionProcessor(
            None,
            [ConflictError, ConflictError]
            )
        def fakemethod(ap):
            ap.called += 1
        inst = self._makeOne(3, fakemethod)
        inst(ap)
        self.assertEqual(ap.synced, 3)
        self.assertEqual(ap.called, 3)
        self.assertEqual(ap.transaction.begun, 3)
        self.assertEqual(ap.transaction.committed, 1)
        self.assertEqual(ap.transaction.aborted, 2)

class TestBasicActionProcessor(unittest.TestCase):
    def _makeOne(self, context):
        from ..deferred import BasicActionProcessor
        return BasicActionProcessor(context)

    def test_get_root_no_jar(self):
        context = testing.DummyResource()
        context._p_jar = None
        inst = self._makeOne(context)
        self.assertTrue(inst.get_root() is None)

    def test_get_root_with_jar(self):
        context = testing.DummyResource()
        context._p_jar = DummyJar('root')
        inst = self._makeOne(context)
        self.assertEqual(inst.get_root(), 'root')

    def test_get_queue_no_root(self):
        context = testing.DummyResource()
        context._p_jar = None
        inst = self._makeOne(context)
        self.assertTrue(inst.get_queue() is None)
        
    def test_get_queue_with_root(self):
        context = testing.DummyResource()
        inst = self._makeOne(context)
        context._p_jar = DummyJar({inst.queue_name:'queue'})
        self.assertEqual(inst.get_queue(), 'queue')

    def test_active_True(self):
        context = testing.DummyResource()
        inst = self._makeOne(context)
        queue = DummyQueue()
        queue.pactive = True
        context._p_jar = DummyJar({inst.queue_name:queue})
        self.assertTrue(inst.active())
        
    def test_active_False_no_queue(self):
        context = testing.DummyResource()
        context._p_jar = None
        inst = self._makeOne(context)
        self.assertFalse(inst.active())

    def test_active_False_processor_not_active(self):
        context = testing.DummyResource()
        queue = DummyQueue()
        queue.pactive = False
        inst = self._makeOne(context)
        context._p_jar = DummyJar({inst.queue_name:queue})
        self.assertFalse(inst.active())

    def test_engage_queue_already_present(self):
        context = testing.DummyResource()
        queue = DummyQueue()
        inst = self._makeOne(context)
        inst.transaction = DummyTransaction()
        context._p_jar = DummyJar({inst.queue_name:queue})
        self.assertEqual(inst.engage(), None)
        self.assertTrue(queue.pactive)

    def test_engage_queue_missing_context_has_no_jar(self):
        context = testing.DummyResource()
        inst = self._makeOne(context)
        inst.transaction = DummyTransaction()
        context._p_jar = DummyJar(None)
        self.assertRaises(RuntimeError, inst.engage)

    def test_engage_queue_added(self):
        context = testing.DummyResource()
        inst = self._makeOne(context)
        transaction = DummyTransaction()
        inst.transaction = transaction
        root = {}
        context._p_jar = DummyJar(root)
        self.assertEqual(inst.engage(), None)
        queue = root[inst.queue_name]
        self.assertTrue(transaction.committed)
        self.assertTrue(queue.pactive)

    def test_disengage_no_queue(self):
        context = testing.DummyResource()
        inst = self._makeOne(context)
        context._p_jar = None
        self.assertRaises(RuntimeError, inst.disengage)

    def test_disengage(self):
        context = testing.DummyResource()
        inst = self._makeOne(context)
        queue = DummyQueue()
        root = {inst.queue_name:queue}
        transaction = DummyTransaction()
        inst.transaction = transaction
        context._p_jar = DummyJar(root)
        inst.disengage()
        self.assertEqual(queue.pactive, False)
        self.assertTrue(transaction.committed)

    def test_add_not_engaged(self):
        context = testing.DummyResource()
        context._p_jar = None
        inst = self._makeOne(context)
        self.assertRaises(RuntimeError, inst.add, [1])

    def test_add_extends(self):
        context = testing.DummyResource()
        inst = self._makeOne(context)
        root = {inst.queue_name:[1]}
        context._p_jar = DummyJar(root)
        inst.add([2,3])
        self.assertEqual(root[inst.queue_name], [1,2,3])

    def test_process_gardenpath(self):
        context = testing.DummyResource()
        inst = self._makeOne(context)
        transaction = DummyTransaction()
        inst.transaction = transaction
        logger = DummyLogger()
        inst.logger = logger
        a1 = DummyAction(1)
        queue = DummyQueue([a1])
        root = {inst.queue_name:queue}
        jar = DummyJar(root)
        context._p_jar = jar
        inst.process(once=True)
        self.assertTrue(jar.synced)
        self.assertEqual(queue.result, [])
        self.assertTrue(a1.executed)
        self.assertTrue(transaction.begun)
        self.assertEqual(transaction.committed, 3) # engage, process, disengage
        self.assertEqual(
            logger.messages,
            ['starting basic action processor',
             'executing action 1',
             'committing',
             'committed',
             'stopping basic action processor']
            )

    def test_process_gardenpath_no_actions(self):
        context = testing.DummyResource()
        inst = self._makeOne(context)
        transaction = DummyTransaction()
        inst.transaction = transaction
        logger = DummyLogger()
        inst.logger = logger
        queue = DummyQueue([])
        root = {inst.queue_name:queue}
        jar = DummyJar(root)
        context._p_jar = jar
        inst.process(once=True)
        self.assertTrue(jar.synced)
        self.assertEqual(queue.result, [])
        self.assertTrue(transaction.begun)
        self.assertEqual(transaction.committed, 2) # engage, disengage
        self.assertEqual(
            logger.messages,
            ['starting basic action processor',
             'no actions to execute',
             'stopping basic action processor']
            )

    def test_process_conflicterror_at_initial_commit(self):
        from ZODB.POSException import ConflictError
        context = testing.DummyResource()
        inst = self._makeOne(context)
        transaction = DummyTransaction([ConflictError])
        inst.transaction = transaction
        logger = DummyLogger()
        inst.logger = logger
        inst.engage = lambda *arg, **kw: False
        inst.disengage = lambda *arg, **kw: False
        a1 = DummyAction(1)
        queue = DummyQueue([a1])
        root = {inst.queue_name:queue}
        jar = DummyJar(root)
        context._p_jar = jar
        inst.process(once=True)
        self.assertTrue(jar.synced)
        self.assertEqual(queue.result, [])
        self.assertTrue(a1.executed)
        self.assertTrue(transaction.begun)
        self.assertTrue(transaction.aborted)
        self.assertEqual(
            logger.messages,
            ['starting basic action processor',
             'executing action 1',
             'committing',
             'aborted due to conflict error',
             'stopping basic action processor']
            )

    def test_process_conflicterror_at_disengage(self):
        from ZODB.POSException import ConflictError
        context = testing.DummyResource()
        inst = self._makeOne(context)
        transaction = DummyTransaction([None, ConflictError])
        inst.transaction = transaction
        logger = DummyLogger()
        inst.logger = logger
        inst.engage = lambda *arg, **kw: False
        L = [ConflictError]
        def disengage(*arg, **kw):
            if L:
                raise L.pop(0)
        inst.disengage = disengage
        a1 = DummyAction(1)
        queue = DummyQueue([a1])
        root = {inst.queue_name:queue}
        jar = DummyJar(root)
        context._p_jar = jar
        inst.process(once=True)
        self.assertTrue(jar.synced)
        self.assertEqual(queue.result, [])
        self.assertTrue(a1.executed)
        self.assertEqual(
            logger.messages,
            ['starting basic action processor',
             'executing action 1',
             'committing',
             'committed',
             'stopping basic action processor',
             'couldnt disengage due to conflict, processing queue once more',
             'stopping basic action processor']            
            )

    def test_process_resource_not_found_at_execute(self):
        from ..deferred import ResourceNotFound
        context = testing.DummyResource()
        inst = self._makeOne(context)
        transaction = DummyTransaction()
        inst.transaction = transaction
        logger = DummyLogger()
        inst.logger = logger
        inst.engage = lambda *arg, **kw: False
        inst.disengage = lambda *arg, **kw: False
        a1 = DummyAction(1)
        a1.raises = ResourceNotFound(1)
        queue = DummyQueue([a1])
        root = {inst.queue_name:queue}
        jar = DummyJar(root)
        context._p_jar = jar
        inst.process(once=True)
        self.assertTrue(jar.synced)
        self.assertEqual(queue.result, [])
        self.assertFalse(a1.executed)
        self.assertTrue(transaction.begun)
        self.assertFalse(transaction.committed)
        self.assertEqual(
            logger.messages,
            ['starting basic action processor',
             'executing action 1',
             'Indexing error: cannot find resource for oid 1',
             'stopping basic action processor']
            )

    def test_process_execute_raises_Break(self):
        from ..deferred import Break
        context = testing.DummyResource()
        inst = self._makeOne(context)
        transaction = DummyTransaction()
        inst.transaction = transaction
        logger = DummyLogger()
        inst.logger = logger
        inst.engage = lambda *arg, **kw: False
        inst.disengage = lambda *arg, **kw: False
        a1 = DummyAction(1)
        a1.raises = Break(1)
        queue = DummyQueue([a1])
        root = {inst.queue_name:queue}
        jar = DummyJar(root)
        context._p_jar = jar
        inst.process(once=True)
        self.assertTrue(jar.synced)
        self.assertEqual(queue.result, [])
        self.assertFalse(a1.executed)
        self.assertTrue(transaction.begun)
        self.assertFalse(transaction.committed)
        self.assertEqual(
            logger.messages,
            ['starting basic action processor',
             'executing action 1',
             'stopping basic action processor']
            )

    def test_process_execute_raises_user_error(self):
        context = testing.DummyResource()
        inst = self._makeOne(context)
        transaction = DummyTransaction()
        inst.transaction = transaction
        logger = DummyLogger()
        inst.logger = logger
        inst.engage = lambda *arg, **kw: False
        inst.disengage = lambda *arg, **kw: False
        a1 = DummyAction(1)
        a1.raises = ValueError()
        queue = DummyQueue([a1])
        root = {inst.queue_name:queue}
        jar = DummyJar(root)
        context._p_jar = jar
        inst.process(once=True)
        self.assertTrue(jar.synced)
        self.assertEqual(queue.result, [])
        self.assertFalse(a1.executed)
        self.assertTrue(transaction.begun)
        self.assertFalse(transaction.committed)
        self.assertEqual(
            logger.messages,
            ['starting basic action processor',
             'executing action 1',
             'ValueError()',
             'stopping basic action processor']
            )
        
class TestIndexActionSavepoint(unittest.TestCase):
    def _makeOne(self, tm):
        from ..deferred import IndexActionSavepoint
        return IndexActionSavepoint(tm)

    def test_rollback(self):
        tm = DummyIndexActionTM([1])
        inst = self._makeOne(tm)
        tm.actions = None
        inst.rollback()
        self.assertEqual(tm.actions, [1])

class TestIndexActionTM(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self, index):
        from ..deferred import IndexActionTM
        return IndexActionTM(index)

    def test_register(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        transaction = DummyTransaction()
        inst.transaction = transaction
        inst.register()
        self.assertTrue(transaction.joined)
        self.assertEqual(transaction.beforecommit_fn, inst.flush)
        self.assertEqual(transaction.beforecommit_args, (False,))
        self.assertTrue(inst.registered)

    def test_register_already_registered(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        transaction = DummyTransaction()
        inst.transaction = transaction
        inst.registered = True
        inst.register()
        self.assertFalse(transaction.joined)

    def test_savepoint(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        sp = inst.savepoint()
        self.assertEqual(sp.tm, inst)

    def test_tpc_begin(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        self.assertEqual(inst.tpc_begin(None), None)

    def test_tpc_finish(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        self.assertEqual(inst.tpc_finish(None), None)
        self.assertEqual(index._p_action_tm, None)
        self.assertEqual(inst.index, None)
        self.assertFalse(inst.registered)
        self.assertEqual(inst.actions, [])

    def test_sortKey(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        self.assertEqual(inst.sortKey(), 'IndexActionTM: 1')

    def test_add(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        inst.add(1)
        self.assertEqual(inst.actions, [1])

    def test_flush(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        a1 = DummyAction(1)
        inst.actions = [a1]
        L = []
        inst._process = lambda actions, all=None: L.append((actions, all))
        inst.flush(all=False)
        self.assertEqual(L, [([a1], False)])

    def test_flush_no_actions(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        L = []
        inst._process = lambda actions, all=None: L.append((actions, all))
        inst.flush(all=False)
        self.assertEqual(L, [])

    def test__process_all_True(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        logger = DummyLogger()
        inst.logger = logger
        a1 = DummyAction(1)
        inst._process([a1])
        self.assertTrue(a1.executed)
        self.assertEqual(
            logger.messages,
            ['begin index actions processing',
             'executing all actions immediately: "all" flag',
             'executing action action 1',
             'done processing index actions']
            )

    def test__process_all_False_no_action_processor(self):
        index = DummyIndex()
        inst = self._makeOne(index)
        logger = DummyLogger()
        inst.logger = logger
        a1 = DummyAction(1)
        inst._process([a1], all=False)
        self.assertTrue(a1.executed)
        self.assertEqual(
            logger.messages,
            ['begin index actions processing',
             'executing actions all immediately: no action processor',
             'executing action action 1',
             'done processing index actions']
            )

    def test__process_all_False_no_action_processor_force_deferred(self):
        self.config.registry.settings[
            'substanced.catalogs.force_deferred'] = True
        index = DummyIndex()
        inst = self._makeOne(index)
        logger = DummyLogger()
        inst.logger = logger
        a1 = DummyAction(1)
        inst._process([a1], all=False)
        self.assertTrue(a1.executed)
        self.assertEqual(
            logger.messages,
            ['begin index actions processing',
             'executing actions all immediately: no action processor',
             'executing action action 1',
             'done processing index actions']
            )
        
    def test__process_all_False_inactive_action_processor(self):
        from substanced.interfaces import IIndexingActionProcessor
        from zope.interface import Interface
        self.config.registry.registerAdapter(
            DummyActionProcessor, (Interface,), IIndexingActionProcessor
            )
        index = DummyIndex()
        index.active = False
        index.queue = True
        inst = self._makeOne(index)
        logger = DummyLogger()
        inst.logger = logger
        a1 = DummyAction(1)
        inst._process([a1], all=False)
        self.assertTrue(a1.executed)
        self.assertEqual(
            logger.messages,
            ['begin index actions processing',
             'executing actions all immediately: inactive action processor',
             'executing action action 1',
             'done processing index actions']
            )

    def test__process_all_False_inactive_action_processor_force_deferred(self):
        self.config.registry.settings[
            'substanced.catalogs.force_deferred'] = True
        from substanced.interfaces import IIndexingActionProcessor
        from zope.interface import Interface
        self.config.registry.registerAdapter(
            DummyActionProcessor, (Interface,), IIndexingActionProcessor
            )
        index = DummyIndex()
        index._p_jar = DummyJar(None)
        index.active = False
        index.queue = True
        inst = self._makeOne(index)
        logger = DummyLogger()
        inst.logger = logger
        a1 = DummyAction(1)
        inst._process([a1], all=False)
        self.assertFalse(a1.executed)
        self.assertEqual(
            logger.messages,
            ['begin index actions processing',
             'executing deferred actions: deferred mode forced via "substanced.catalogs.force_deferred" flag in configuration or envvar',
             'adding deferred action action 1',
             'done processing index actions']
            )

    def test__process_all_False_force_deferred_no_jar(self):
        self.config.registry.settings[
            'substanced.catalogs.force_deferred'] = True
        from substanced.interfaces import IIndexingActionProcessor
        from zope.interface import Interface
        self.config.registry.registerAdapter(
            DummyActionProcessor, (Interface,), IIndexingActionProcessor
            )
        index = DummyIndex()
        index._p_jar = DummyJar(None)
        index.active = False
        index.queue = None
        inst = self._makeOne(index)
        logger = DummyLogger()
        inst.logger = logger
        a1 = DummyAction(1)
        inst._process([a1], all=False)
        self.assertTrue(a1.executed)
        self.assertEqual(
            logger.messages,
            ['begin index actions processing',
             'executing actions all immediately: no jar available to find queue',
             'executing action action 1',
             'done processing index actions']
            )
        
    def test__process_all_False_active_action_processor(self):
        from substanced.interfaces import (
            IIndexingActionProcessor,
            MODE_DEFERRED,
            MODE_ATCOMMIT,
            )
        from zope.interface import Interface
        self.config.registry.registerAdapter(
            DummyActionProcessor, (Interface,), IIndexingActionProcessor
            )
        index = DummyIndex()
        index.active = True
        index.queue = True
        inst = self._makeOne(index)
        logger = DummyLogger()
        inst.logger = logger
        a1 = DummyAction(1)
        a1.mode = MODE_DEFERRED
        a2 = DummyAction(2)
        a2.mode = MODE_ATCOMMIT
        inst._process([a1, a2], all=False)
        self.assertFalse(a1.executed)
        self.assertTrue(a2.executed)
        self.assertEqual(index.added, [a1])
        self.assertEqual(
            logger.messages,
            ['begin index actions processing',
             'executing deferred actions: action processor active',
             'adding deferred action action 1',
             'executing action action 2',
             'done processing index actions']
            )

class Test_optimize_actions(unittest.TestCase):
    def _callFUT(self, actions):
        from ..deferred import optimize_actions
        return optimize_actions(actions)

    def test_donothing(self):
        from ..deferred import IndexAction, UnindexAction
        index = DummyIndex()
        actions = [ IndexAction(index, 'mode', 'oid'),
                    UnindexAction(index, 'mode', 'oid') ]
        result = self._callFUT(actions)
        self.assertEqual(result, [])

    def test_doadd(self):
        from ..deferred import IndexAction, ReindexAction
        index = DummyIndex()
        actions = [ IndexAction(index, 'mode', 'oid'),
                    ReindexAction(index, 'mode', 'oid') ]
        result = self._callFUT(actions)
        self.assertEqual(result, [actions[0]])

    def test_dochange(self):
        from ..deferred import IndexAction, UnindexAction, ReindexAction
        index = DummyIndex()
        actions = [ UnindexAction(index, 'mode', 'oid'),
                    IndexAction(index, 'mode', 'oid') ]
        result = self._callFUT(actions)
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0].__class__, ReindexAction)
        self.assertEqual(result[0].index, index)
        self.assertEqual(result[0].oid, 'oid')

    def test_dodefault(self):
        from ..deferred import IndexAction
        index = DummyIndex()
        actions = [ IndexAction(index, 'mode', 'oid'),
                    IndexAction(index, 'mode', 'oid') ]
        result = self._callFUT(actions)
        self.assertEqual(result, [actions[-1]])

    def test_sorting(self):
        from ..deferred import IndexAction, ReindexAction, UnindexAction
        index1 = DummyIndex()
        index1.__name__ = 'index1'
        index2 = DummyIndex()
        index2.__oid__ = 2
        index2.__name__ = 'index2'
        a1 = IndexAction(index2, 'mode', 'oid1')
        a2 = ReindexAction(index1, 'mode', 'oid3')
        a3 = IndexAction(index2, 'mode', 'oid2')
        a4 = IndexAction(index2, 'mode', 'oid3')
        a5 = UnindexAction(index1, 'mode', 'oid1')
        actions = [a1, a2, a3, a4, a5]
        result = self._callFUT(actions)
        self.assertEqual(result, [a5, a1, a3, a2, a4])

class DummyIndexActionTM(object):
    def __init__(self, actions):
        self.actions = actions

class DummyIndex(object):
    __oid__ = 1
    oid = None
    def index_doc(self, oid, resource):
        self.oid = oid
        self.resource = resource

    reindex_doc = index_doc

    def unindex_doc(self, oid):
        self.oid = oid

class DummyLogger(object):
    def __init__(self):
        self.messages = []
    def info(self, msg):
        self.messages.append(msg)
    debug = info
    error = info
        

class DummyJar(object):
    def __init__(self, result):
        self.result = result

    def root(self):
        return self.result

    def sync(self):
        self.synced = True


class DummyTransaction(object):
    joined = False
    def __init__(self, raises=None):
        if raises is None:
            raises = []
        self.raises = raises
        self.committed = 0
        self.aborted = 0
        self.begun = 0

    def begin(self):
        self.begun += 1

    def commit(self):
        if self.raises:
            result = self.raises.pop(0)
            if result is not None:
                raise result
        self.committed += 1

    def abort(self):
        self.aborted += 1

    def note(self, msg):
        self._note = msg

    def get(self):
        return self

    def join(self, tm):
        self.joined = tm

    def addBeforeCommitHook(self, fn, args):
        self.beforecommit_fn = fn
        self.beforecommit_args = args

from substanced._compat import total_ordering

@total_ordering
class DummyAction(object):
    index = testing.DummyResource()
    index.__oid__ = 1
    executed = False
    mode = None

    def __init__(self, oid, index_oid=1, position=1, raises=None, anti=False,
                 antiresult=None):
        self.oid = oid
        self.index_oid = index_oid
        self.position = position
        self.raises = raises
        self._anti = anti
        self.antiresult = antiresult

    def execute(self):
        if self.raises:
            raise self.raises
        self.executed = True

    def __repr__(self):
        return 'action %s' % self.oid

    def __lt__(self, other):
        return self.oid < other.oid

    def anti(self):
        if self.antiresult:
            return self.antiresult
        return DummyAction(self.oid, anti=True)

class DummyQueue(object):
    def __init__(self, result=()):
        self.result = result
    def popall(self):
        result = self.result[:]
        self.result = []
        return result
    def __len__(self):
        return len(self.result)

class DummyActionProcessor(object):
    def __init__(self, context, commit_raises=None):
        self.context = context
        if commit_raises is None:
            commit_raises = []
        self.transaction = DummyTransaction(commit_raises)
        self.synced = 0
        self.called = 0

    def active(self):
        return self.context.active

    def sync(self):
        self.synced+=1

    def add(self, actions):
        self.context.added = actions

    def get_queue(self):
        return self.context.queue
    
class DummyObjectmap(object):
    def __init__(self, result):
        self.result = result

    def object_for(self, oid):
        return self.result
    
def state(actions, gen=0, pactive=True, undo=False):
    return dict(locals())

########NEW FILE########
__FILENAME__ = test_discriminators
import unittest
from pyramid import testing

class TestIndexViewDiscriminator(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self, catalog_name, index_name):
        from ..discriminators import IndexViewDiscriminator
        return IndexViewDiscriminator(catalog_name, index_name)

    def test_ctor(self):
        inst = self._makeOne('system', 'attr')
        self.assertEqual(inst.catalog_name, 'system')
        self.assertEqual(inst.index_name, 'attr')

    def test_call_no_index_view(self):
        inst = self._makeOne('system', 'attr')
        result = inst(None, True)
        self.assertEqual(result, True)

    def test_call_with_index_view(self):
        from zope.interface import Interface
        from substanced.interfaces import IIndexView
        registry = self.config.registry
        resource = testing.DummyResource()
        def view(_resource, default):
            self.assertEqual(default, True)
            self.assertEqual(_resource, resource)
            return True
        registry.registerAdapter(view, (Interface,), IIndexView, 'system|attr')
        inst = self._makeOne('system', 'attr')
        result = inst(resource, True)
        self.assertEqual(result, True)
        
            

class Test_dummy_discriminator(unittest.TestCase):
    def _callFUT(self, object, default):
        from ..discriminators import dummy_discriminator
        return dummy_discriminator(object, default)

    def test_it(self):
        result = self._callFUT(None, '123')
        self.assertEqual(result, '123')


########NEW FILE########
__FILENAME__ = test_factories
import unittest
from pyramid import testing

class TestIndexFactory(unittest.TestCase):
    def _makeOne(self, **kw):
        from ..factories import IndexFactory
        inst = IndexFactory(**kw)
        def index_type(discriminator, **kw):
            return inst.idx
        inst.index_type = index_type
        inst.idx = testing.DummyResource()
        return inst

    def test_ctor(self):
        inst = self._makeOne(a=1)
        self.assertEqual(inst.kw, {'a':1})

    def test_call_and_hash(self):
        inst = self._makeOne(a=1)
        index = inst('catalog', 'index')
        self.assertEqual(index, inst.idx)
        self.assertEqual(index.__factory_hash__, hash(inst))

    def test_hashvalues_family32(self):
        import BTrees
        inst = self._makeOne(a=1, family=BTrees.family32)
        values = inst.hashvalues()
        self.assertEqual(
            values,
            {'a':1,
             'family':'family32',
             'class':'substanced.catalog.factories.IndexFactory'}
            )

    def test_hashvalues_family64(self):
        import BTrees
        inst = self._makeOne(a=1, family=BTrees.family64)
        values = inst.hashvalues()
        self.assertEqual(
            values,
            {'a':1,
             'family':'family64',
             'class':'substanced.catalog.factories.IndexFactory'}
            )

    def test_hashvalues_family_unknown(self):
        inst = self._makeOne(a=1, family=True)
        self.assertRaises(ValueError, inst.hashvalues)

    def test_is_stale(self):
        inst = self._makeOne(a=1)
        index = testing.DummyResource()
        index.__factory_hash__ = None
        self.assertTrue(inst.is_stale(index))

    def test_is_not_stale(self):
        inst = self._makeOne(a=1)
        index = testing.DummyResource()
        index.__factory_hash__ = hash(inst)
        self.assertFalse(inst.is_stale(index))

class TestText(unittest.TestCase):
    def _makeOne(self, **kw):
        from ..factories import Text
        return Text(**kw)

    def test_call(self):
        inst = self._makeOne()
        result = inst('catalog', 'index')
        self.assertEqual(result.__class__.__name__, 'TextIndex')
        self.assertEqual(
            result.discriminator.__class__.__name__,
            'IndexViewDiscriminator'
            )
        self.assertTrue(hasattr(result, '__factory_hash__'))

    def test_hashvalues(self):
        inst = self._makeOne()
        result = inst.hashvalues()
        self.assertEqual(
            result,
            {'class': 'substanced.catalog.factories.Text'}
            )

    def test_hashvalues_with_lexicon_and_index(self):
        dummy = testing.DummyResource()
        inst = self._makeOne(lexicon=dummy, index=dummy)
        result = inst.hashvalues()
        self.assertEqual(
            result,
            {'index': 'DummyResource',
             'lexicon': 'DummyResource',
             'class': 'substanced.catalog.factories.Text'}
            )

        
class TestField(unittest.TestCase):
    def _makeOne(self, **kw):
        from ..factories import Field
        return Field(**kw)

    def test_call(self):
        inst = self._makeOne()
        result = inst('catalog', 'index')
        self.assertEqual(result.__class__.__name__, 'FieldIndex')
        self.assertEqual(
            result.discriminator.__class__.__name__,
            'IndexViewDiscriminator'
            )
        self.assertTrue(hasattr(result, '__factory_hash__'))

    def test_hashvalues(self):
        inst = self._makeOne()
        result = inst.hashvalues()
        self.assertEqual(
            result,
            {'class': 'substanced.catalog.factories.Field'}
            )

class TestKeyword(unittest.TestCase):
    def _makeOne(self, **kw):
        from ..factories import Keyword
        return Keyword(**kw)

    def test_call(self):
        inst = self._makeOne()
        result = inst('catalog', 'index')
        self.assertEqual(result.__class__.__name__, 'KeywordIndex')
        self.assertEqual(
            result.discriminator.__class__.__name__,
            'IndexViewDiscriminator'
            )
        self.assertTrue(hasattr(result, '__factory_hash__'))

    def test_hashvalues(self):
        inst = self._makeOne()
        result = inst.hashvalues()
        self.assertEqual(
            result,
            {'class': 'substanced.catalog.factories.Keyword'}
            )

class TestFacet(unittest.TestCase):
    def _makeOne(self, **kw):
        from ..factories import Facet
        return Facet(**kw)

    def test_call(self):
        inst = self._makeOne(facets=[(1,2)])
        result = inst('catalog', 'index')
        self.assertEqual(result.__class__.__name__, 'FacetIndex')
        self.assertEqual(
            result.discriminator.__class__.__name__,
            'IndexViewDiscriminator'
            )
        self.assertTrue(hasattr(result, '__factory_hash__'))

    def test_hashvalues(self):
        inst = self._makeOne(facets=[(1,2)])
        result = inst.hashvalues()
        self.assertEqual(
            result,
            {'class': 'substanced.catalog.factories.Facet',
             'facets':((1,2),)}
            )

class TestPath(unittest.TestCase):
    def _makeOne(self, **kw):
        from ..factories import Path
        return Path(**kw)

    def test_call(self):
        inst = self._makeOne()
        result = inst('catalog', 'index')
        self.assertEqual(result.__class__.__name__, 'PathIndex')
        self.assertTrue(hasattr(result, '__factory_hash__'))

    def test_hashvalues(self):
        inst = self._makeOne()
        result = inst.hashvalues()
        self.assertEqual(
            result,
            {'class': 'substanced.catalog.factories.Path'}
            )

class TestAllowed(unittest.TestCase):
    def _makeOne(self, **kw):
        from ..factories import Allowed
        return Allowed(**kw)

    def test_call(self):
        inst = self._makeOne()
        result = inst('catalog', 'index')
        self.assertEqual(result.__class__.__name__, 'AllowedIndex')
        self.assertTrue(hasattr(result, '__factory_hash__'))

class TestCatalogFactory(unittest.TestCase):
    def _makeOne(self, name, index_factories):
        from ..factories import CatalogFactory
        return CatalogFactory(name, index_factories)

    def test_ctor(self):
        inst = self._makeOne('name', 'factories')
        self.assertEqual(inst.name, 'name')
        self.assertEqual(inst.index_factories, 'factories')

    def test_replace(self):
        L = []
        output = L.append
        factory = DummyIndexFactory()
        index_factories = {'a':factory}
        inst = self._makeOne('name', index_factories)
        catalog = DummyCatalog()
        index = testing.DummyResource()
        catalog['a'] = index
        result = inst.replace(catalog, output=output)
        self.assertTrue(result)
        self.assertEqual(factory.catalog_name, 'name')
        self.assertFalse(catalog.reindexed)
        self.assertEqual(catalog['a'], factory)
        self.assertTrue(L)

    def test_replace_add(self):
        L = []
        output = L.append
        factory = DummyIndexFactory()
        index_factories = {'a':factory}
        inst = self._makeOne('name', index_factories)
        catalog = DummyCatalog()
        result = inst.replace(catalog, output=output)
        self.assertTrue(result)
        self.assertEqual(factory.catalog_name, 'name')
        self.assertFalse(catalog.reindexed)
        self.assertEqual(catalog['a'], factory)
        self.assertTrue(L)

    def test_replace_reindex_true(self):
        L = []
        output = L.append
        factory = DummyIndexFactory()
        index_factories = {'a':factory}
        inst = self._makeOne('name', index_factories)
        catalog = DummyCatalog()
        result = inst.replace(catalog, output=output, reindex=True)
        self.assertTrue(result)
        self.assertEqual(factory.catalog_name, 'name')
        self.assertEqual(catalog.reindexed['indexes'], set(['a']))
        self.assertEqual(catalog['a'], factory)
        self.assertTrue(L)

    def test_replace_remove_stale(self):
        L = []
        output = L.append
        index_factories = {}
        inst = self._makeOne('name', index_factories)
        index = testing.DummyResource()
        catalog = DummyCatalog()
        catalog['index'] = index
        result = inst.replace(catalog, output=output)
        self.assertTrue(result)
        self.assertFalse('index' in catalog)
        self.assertTrue(L)

    def test_sync_replace_stale(self):
        L = []
        output = L.append
        factory = DummyIndexFactory(True)
        index_factories = {'a':factory}
        inst = self._makeOne('name', index_factories)
        catalog = DummyCatalog()
        index = testing.DummyResource()
        catalog['a'] = index
        result = inst.sync(catalog, output=output)
        self.assertTrue(result)
        self.assertEqual(factory.catalog_name, 'name')
        self.assertFalse(catalog.reindexed)
        self.assertEqual(catalog['a'], factory)
        self.assertTrue(L)

    def test_sync_keep_notstale(self):
        L = []
        output = L.append
        factory = DummyIndexFactory(False)
        index_factories = {'a':factory}
        inst = self._makeOne('name', index_factories)
        catalog = DummyCatalog()
        index = testing.DummyResource()
        catalog['a'] = index
        result = inst.sync(catalog, output=output)
        self.assertFalse(result)
        self.assertFalse(catalog.reindexed)
        self.assertEqual(catalog['a'], index)
        self.assertFalse(L)

    def test_sync_add_and_remove_stale(self):
        L = []
        output = L.append
        factory = DummyIndexFactory(False)
        index_factories = {'b':factory}
        inst = self._makeOne('name', index_factories)
        catalog = DummyCatalog()
        index = testing.DummyResource()
        catalog['a'] = index
        result = inst.sync(catalog, output=output)
        self.assertTrue(result)
        self.assertEqual(factory.catalog_name, 'name')
        self.assertFalse(catalog.reindexed)
        self.assertEqual(catalog['b'], factory)
        self.assertFalse('a' in catalog)
        self.assertTrue(L)

    def test_sync_reindex_true(self):
        L = []
        output = L.append
        factory = DummyIndexFactory()
        index_factories = {'a':factory}
        inst = self._makeOne('name', index_factories)
        catalog = DummyCatalog()
        result = inst.sync(catalog, output=output, reindex=True)
        self.assertTrue(result)
        self.assertEqual(factory.catalog_name, 'name')
        self.assertEqual(catalog.reindexed['indexes'], set(['a']))
        self.assertEqual(catalog['a'], factory)
        self.assertTrue(L)

class DummyIndexFactory(object):
    def __init__(self, result=None):
        self.result = result

    def __call__(self, catalog_name, index_name):
        self.catalog_name = catalog_name
        self.index_name = index_name
        return self

    def is_stale(self, index):
        return self.result
        

class DummyCatalog(testing.DummyResource):
    reindexed = False
    __name__ = 'catalog'
    __parent__ = None
    def add(self, name, value, send_events=True):
        self[name] = value

    def replace(self, name, value, send_events=True):
        self[name] = value

    def reindex(self, **kw):
        self.reindexed = kw

    def remove(self, name, send_events=True):
        del self[name]
        

########NEW FILE########
__FILENAME__ = test_indexes
import unittest
from pyramid import testing

import BTrees

from ..._compat import u
_BLANK = u('')
_A = u('a')
_ABC = u('abc')

def _makeSite(**kw):
    from ...interfaces import IFolder
    from ...interfaces import IService
    from zope.interface import alsoProvides
    site = testing.DummyResource(__provides__=kw.pop('__provides__', None))
    alsoProvides(site, IFolder)
    for k, v in kw.items():
        site[k] = v
        alsoProvides(v, IService)
    return site

class TestFakeIndex(unittest.TestCase):
    def _makeOne(self):
        from ..indexes import FakeIndex
        return FakeIndex()

    def test_reset(self):
        inst = self._makeOne()
        inst.reset()
        self.assertEqual(list(inst._not_indexed), [])

    def test_index_doc(self):
        inst = self._makeOne()
        self.assertEqual(inst.index_doc(1, None), None)
        
    def test_unindex_doc(self):
        inst = self._makeOne()
        self.assertEqual(inst.unindex_doc(1), None)

    def test_reindex_doc(self):
        inst = self._makeOne()
        self.assertEqual(inst.reindex_doc(1, None), None)

    def test_docids(self):
        inst = self._makeOne()
        fake_catalog = Dummy()
        fake_catalog.objectids = [1]
        inst.__parent__ =  fake_catalog
        self.assertEqual(inst.docids(), [1])

    def test_indexed(self):
        inst = self._makeOne()
        fake_catalog = Dummy()
        fake_catalog.objectids = [1]
        inst.__parent__ =  fake_catalog
        self.assertEqual(inst.indexed(), [1])

    def test_not_indexed(self):
        inst = self._makeOne()
        inst._not_indexed = [1]
        self.assertEqual(inst.not_indexed(), [1])
        
        
class TestSDIndex(unittest.TestCase):
    def _makeOne(self, oid=1):
        from ..indexes import SDIndex
        index = SDIndex()
        index.__oid__ = oid
        return index

    def test_resultset_from_query_no_resolver(self):
        inst = self._makeOne()
        inst.__objectmap__ = DummyObjectmap()
        query = DummyQuery()
        resultset = inst.resultset_from_query(query)
        self.assertEqual(resultset.ids, [1,2,3])
        self.assertEqual(resultset.resolver, inst.__objectmap__.object_for)
        self.assertTrue(query.flushed)

    def test_resultset_from_query_with_resolver(self):
        inst = self._makeOne()
        inst.__objectmap__ = DummyObjectmap()
        query = DummyQuery()
        resolver = object()
        resultset = inst.resultset_from_query(query, resolver=resolver)
        self.assertEqual(resultset.ids, [1,2,3])
        self.assertEqual(resultset.resolver, resolver)
        self.assertTrue(query.flushed)

    def test_get_action_tm_existing_action_tm(self):
        inst = self._makeOne()
        tm = DummyActionTM(None)
        inst._p_action_tm = tm
        self.assertEqual(inst.get_action_tm(), tm)
        
    def test_get_action_tm_no_existing_action_tm(self):
        inst = self._makeOne()
        inst.tm_class = DummyActionTM
        result = inst.get_action_tm()
        self.assertEqual(result.__class__, DummyActionTM)
        self.assertEqual(result.index, inst)
        self.assertTrue(result.registered)

    def test_flush(self):
        inst = self._makeOne()
        tm = DummyActionTM(None)
        inst._p_action_tm = tm
        inst.flush('abc')
        self.assertEqual(tm.flushed, 'abc')

    def test_flush_no_tm(self):
        inst = self._makeOne()
        inst._p_action_tm = None
        self.assertEqual(inst.flush(), None)

    def test_add_action(self):
        inst = self._makeOne()
        tm = DummyActionTM(None)
        inst._p_action_tm = tm
        inst.add_action(True)
        self.assertEqual(tm.actions, [True])

    def test_index_resource_default_action_mode_is_MODE_ATCOMMIT(self):
        resource = testing.DummyResource()
        inst = self._makeOne()
        tm = DummyActionTM(None)
        inst._p_action_tm = tm
        inst.index_resource(resource, 1)
        self.assertEqual(len(tm.actions), 1)

    def test_index_resource_action_MODE_IMMEDIATE(self):
        from substanced.interfaces import MODE_IMMEDIATE
        resource = testing.DummyResource()
        inst = self._makeOne()
        L = []
        inst.index_doc = lambda oid, resource: L.append((oid, resource))
        inst.index_resource(resource, 1, action_mode=MODE_IMMEDIATE)
        self.assertEqual(L, [(1, resource)])

    def test_index_resource_action_MODE_ATCOMMIT(self):
        from substanced.interfaces import MODE_ATCOMMIT
        resource = testing.DummyResource()
        inst = self._makeOne()
        tm = DummyActionTM(None)
        inst._p_action_tm = tm
        inst.index_resource(resource, 1, action_mode=MODE_ATCOMMIT)
        self.assertEqual(len(tm.actions), 1)
        action = tm.actions[0]
        self.assertEqual(action.__class__.__name__, 'IndexAction')
        self.assertEqual(action.oid, 1)
        self.assertEqual(action.mode, MODE_ATCOMMIT)
        self.assertEqual(action.index, inst)

    def test_index_resource_oid_is_None(self):
        from substanced.interfaces import MODE_IMMEDIATE
        resource = testing.DummyResource()
        resource.__oid__ = 1
        inst = self._makeOne()
        L = []
        inst.index_doc = lambda oid, resource: L.append((oid, resource))
        inst.index_resource(resource, action_mode=MODE_IMMEDIATE)
        self.assertEqual(L, [(1, resource)])

    def test_reindex_resource_default_action_mode_is_MODE_ATCOMMIT(self):
        resource = testing.DummyResource()
        inst = self._makeOne()
        inst = self._makeOne()
        tm = DummyActionTM(None)
        inst._p_action_tm = tm
        inst.reindex_resource(resource, 1)
        self.assertEqual(len(tm.actions), 1)

    def test_reindex_resource_action_MODE_IMMEDIATE(self):
        from substanced.interfaces import MODE_IMMEDIATE
        resource = testing.DummyResource()
        inst = self._makeOne()
        L = []
        inst.reindex_doc = lambda oid, resource: L.append((oid, resource))
        inst.reindex_resource(resource, 1, action_mode=MODE_IMMEDIATE)
        self.assertEqual(L, [(1, resource)])

    def test_reindex_resource_action_MODE_ATCOMMIT(self):
        from substanced.interfaces import MODE_ATCOMMIT
        resource = testing.DummyResource()
        inst = self._makeOne()
        tm = DummyActionTM(None)
        inst._p_action_tm = tm
        inst.reindex_resource(resource, 1, action_mode=MODE_ATCOMMIT)
        self.assertEqual(len(tm.actions), 1)
        action = tm.actions[0]
        self.assertEqual(action.__class__.__name__, 'ReindexAction')
        self.assertEqual(action.oid, 1)
        self.assertEqual(action.mode, MODE_ATCOMMIT)
        self.assertEqual(action.index, inst)

    def test_reindex_resource_no_oid(self):
        from substanced.interfaces import MODE_IMMEDIATE
        resource = testing.DummyResource()
        resource.__oid__ = 1
        inst = self._makeOne()
        L = []
        inst.reindex_doc = lambda oid, resource: L.append((oid, resource))
        inst.reindex_resource(resource, action_mode=MODE_IMMEDIATE)
        self.assertEqual(L, [(1, resource)])

    def test_unindex_resource_default_mode_is_MODE_ATCOMMIT(self):
        inst = self._makeOne()
        tm = DummyActionTM(None)
        inst._p_action_tm = tm
        inst.unindex_resource(1)
        self.assertEqual(len(tm.actions), 1)

    def test_unindex_resource_action_MODE_IMMEDIATE(self):
        from substanced.interfaces import MODE_IMMEDIATE
        inst = self._makeOne()
        L = []
        inst.unindex_doc = lambda oid: L.append(oid)
        inst.unindex_resource(1, action_mode=MODE_IMMEDIATE)
        self.assertEqual(L, [1])

    def test_unindex_resource_action_MODE_ATCOMMIT(self):
        from substanced.interfaces import MODE_ATCOMMIT
        inst = self._makeOne()
        tm = DummyActionTM(None)
        inst._p_action_tm = tm
        inst.unindex_resource(1, action_mode=MODE_ATCOMMIT)
        self.assertEqual(len(tm.actions), 1)
        action = tm.actions[0]
        self.assertEqual(action.__class__.__name__, 'UnindexAction')
        self.assertEqual(action.oid, 1)
        self.assertEqual(action.mode, MODE_ATCOMMIT)
        self.assertEqual(action.index, inst)

    def test_unindex_resource_resource_is_not_oid(self):
        from substanced.interfaces import MODE_IMMEDIATE
        resource = testing.DummyResource()
        resource.__oid__ = 1
        inst = self._makeOne()
        L = []
        inst.unindex_doc = lambda oid: L.append(oid)
        inst.unindex_resource(resource, action_mode=MODE_IMMEDIATE)
        self.assertEqual(L, [1])

    def test_repr(self):
        inst = self._makeOne()
        inst.__name__ = 'fred'
        r = repr(inst)
        self.assertTrue(r.startswith(
           "<substanced.catalog.indexes.SDIndex object 'fred' at"))
        
        

class TestPathIndex(unittest.TestCase):
    def _makeOne(self, family=None):
        from ..indexes import PathIndex
        from ...objectmap import ObjectMap
        catalog = DummyCatalog()
        index = PathIndex(family=family)
        index.__parent__ = catalog
        site = _makeSite(catalog=catalog)
        objectmap = ObjectMap(site)
        site.__objectmap__ = objectmap
        return index

    def _acquire(self, inst, name):
        from substanced.util import acquire
        return acquire(inst, name)

    def test_document_repr(self):
        from substanced.util import get_oid
        inst = self._makeOne()
        obj = testing.DummyResource()
        objectmap = self._acquire(inst, '__objectmap__')
        objectmap.add(obj, (_BLANK,))
        result = inst.document_repr(get_oid(obj))
        self.assertEqual(result, (_BLANK,))

    def test_document_repr_missing(self):
        inst = self._makeOne()
        result = inst.document_repr(1)
        self.assertEqual(result, None)

    def test_ctor_alternate_family(self):
        inst = self._makeOne(family=BTrees.family32)
        self.assertEqual(inst.family, BTrees.family32)

    def test_index_doc(self):
        inst = self._makeOne()
        result = inst.index_doc(1, None)
        self.assertEqual(result, None)

    def test_unindex_doc(self):
        inst = self._makeOne()
        result = inst.unindex_doc(1)
        self.assertEqual(result, None)

    def test_reindex_doc(self):
        inst = self._makeOne()
        result = inst.reindex_doc(1, None)
        self.assertEqual(result, None)

    def test_docids(self):
        inst = self._makeOne()
        result = inst.docids()
        self.assertEqual(list(result),  [])

    def test_not_indexed(self):
        inst = self._makeOne()
        result = inst.not_indexed()
        self.assertEqual(list(result),  [])
        
    def test_search(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        objectmap = self._acquire(inst, '__objectmap__')
        objectmap._v_nextid = 1
        objectmap.add(obj, (_BLANK,))
        result = inst.search((_BLANK,))
        self.assertEqual(list(result),  [1])

    def test_apply_obj(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        objectmap = self._acquire(inst, '__objectmap__')
        objectmap._v_nextid = 1
        objectmap.add(obj, (_BLANK,))
        result = inst.apply(obj)
        self.assertEqual(list(result),  [1])

    def test_apply_obj_noresults(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        result = inst.apply(obj)
        self.assertEqual(list(result),  [])
        
    def test_apply_path(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        objectmap = self._acquire(inst, '__objectmap__')
        objectmap._v_nextid = 1
        objectmap.add(obj, (_BLANK,))
        result = inst.apply((_BLANK,))
        self.assertEqual(list(result),  [1])

    def test_apply_dict(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        objectmap = self._acquire(inst, '__objectmap__')
        objectmap._v_nextid = 1
        objectmap.add(obj, (_BLANK,))
        obj2 = testing.DummyResource(__name__='a')
        obj2.__parent__ = obj
        objectmap.add(obj2, (_BLANK, _A))
        result = inst.apply({'path':obj})
        self.assertEqual(list(result),  [1, 2])

    def test_apply_dict_withdepth(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        objectmap = self._acquire(inst, '__objectmap__')
        objectmap._v_nextid = 1
        objectmap.add(obj, (_BLANK,))
        obj2 = testing.DummyResource(__name__='a')
        obj2.__parent__ = obj
        objectmap.add(obj2, (_BLANK, _A))
        result = inst.apply({'path':obj, 'depth':0})
        self.assertEqual(list(result),  [1])

    def test_apply_dict_with_include_origin_false(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        objectmap = self._acquire(inst, '__objectmap__')
        objectmap._v_nextid = 1
        objectmap.add(obj, (_BLANK,))
        obj2 = testing.DummyResource(__name__='a')
        obj2.__parent__ = obj
        objectmap.add(obj2, (_BLANK, _A))
        result = inst.apply({'path':obj, 'include_origin':False})
        self.assertEqual(list(result),  [2])

    def test_applyNotEq(self):
        inst = self._makeOne()
        catalog = inst.__parent__
        obj = testing.DummyResource()
        objectmap = self._acquire(inst, '__objectmap__')
        objectmap._v_nextid = 1
        objectmap.add(obj, (_BLANK,))
        catalog.objectids = catalog.family.IF.TreeSet([1])
        result = inst.applyNotEq(obj)
        self.assertEqual(list(result),  [])

    def test__parse_path_obj(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        result = inst._parse_path(obj)
        self.assertEqual(result, ((_BLANK,), None, True))
        
    def test__parse_path_path_tuple(self):
        inst = self._makeOne()
        result = inst._parse_path((_BLANK,))
        self.assertEqual(result, ((_BLANK,), None, True))

    def test__parse_path_path_str(self):
        inst = self._makeOne()
        result = inst._parse_path('/')
        self.assertEqual(result, ((_BLANK,), None, True))

    def test__parse_path_path_str_with_depth(self):
        inst = self._makeOne()
        result = inst._parse_path('[depth=2]/abc')
        self.assertEqual(result, ((_BLANK, _ABC), 2, True))

    def test__parse_path_path_str_with_origin_false(self):
        inst = self._makeOne()
        result = inst._parse_path('[include_origin=false]/abc')
        self.assertEqual(result, ((_BLANK, _ABC), None, False))
        
    def test__parse_path_path_str_with_depth_and_origin(self):
        inst = self._makeOne()
        result = inst._parse_path('[depth=2,include_origin=false]/abc')
        self.assertEqual(result, ((_BLANK, _ABC), 2, False))

    def test__parse_path_path_str_with_depth_and_origin_no_val(self):
        inst = self._makeOne()
        result = inst._parse_path('[depth=2,include_origin]/abc')
        self.assertEqual(result, ((_BLANK, _ABC), 2, True))

    def test__parse_path_path_invalid(self):
        inst = self._makeOne()
        self.assertRaises(ValueError, inst._parse_path, None)

    def test__parse_path_path_invalid_string_no_begin_slash(self):
        inst = self._makeOne()
        self.assertRaises(ValueError, inst._parse_path, 'abc/def')

    def test_apply_intersect(self):
        # ftest to make sure we have the right kind of Sets
        inst = self._makeOne()
        obj = testing.DummyResource()
        objectmap = self._acquire(inst, '__objectmap__')
        objectmap._v_nextid = 1
        objectmap.add(obj, (_BLANK,))
        result = inst.apply_intersect(obj, objectmap.family.IF.Set([1]))
        self.assertEqual(list(result),  [1])

    def test_eq_defaults(self):
        inst = self._makeOne()
        result = inst.eq('/abc')
        self.assertEqual(
            result._value,
            {'path': '/abc'}
            )

    def test_eq_include_origin_is_False(self):
        inst = self._makeOne()
        inst.depth = 10
        result = inst.eq('/abc', include_origin=False)
        self.assertEqual(
            result._value,
            {'path': '/abc', 'include_origin': False}
            )

    def test_eq_include_depth_is_not_None(self):
        inst = self._makeOne()
        inst.depth = 10
        result = inst.eq('/abc', depth=1)
        self.assertEqual(
            result._value,
            {'path': '/abc', 'depth': 1}
            )

    def test_noteq_defaults(self):
        inst = self._makeOne()
        result = inst.noteq('/abc')
        self.assertEqual(
            result._value,
            {'path': '/abc'}
            )

    def test_noteq_include_origin_is_False(self):
        inst = self._makeOne()
        inst.depth = 10
        result = inst.noteq('/abc', include_origin=False)
        self.assertEqual(
            result._value,
            {'path': '/abc', 'include_origin': False}
            )

    def test_noteq_include_depth_is_not_None(self):
        inst = self._makeOne()
        inst.depth = 10
        result = inst.noteq('/abc', depth=1)
        self.assertEqual(
            result._value,
            {'path': '/abc', 'depth': 1}
            )

class TestFieldIndex(unittest.TestCase):
    def _makeOne(self, discriminator=None, family=None, action_mode=None):
        from ..indexes import FieldIndex
        return FieldIndex(discriminator, family, action_mode=action_mode)
    
    def test_ctor_with_discriminator(self):
        inst = self._makeOne('abc')
        self.assertEqual(inst.discriminator, 'abc')

    def test_ctor_without_discriminator(self):
        inst = self._makeOne()
        self.assertEqual(inst.discriminator.__class__, type(lambda x: True))

    def test_ctor_with_action_mode(self):
        from substanced.interfaces import MODE_IMMEDIATE
        inst = self._makeOne('abc', action_mode=MODE_IMMEDIATE)
        self.assertEqual(inst.action_mode, MODE_IMMEDIATE)

    def test_ctor_without_action_mode(self):
        from substanced.interfaces import MODE_ATCOMMIT
        inst = self._makeOne('abc')
        self.assertEqual(inst.action_mode, MODE_ATCOMMIT)

class TestKeywordIndex(unittest.TestCase):
    def _makeOne(self, discriminator=None, family=None, action_mode=None):
        from ..indexes import KeywordIndex
        return KeywordIndex(discriminator, family, action_mode=action_mode)
    
    def test_ctor_with_discriminator(self):
        inst = self._makeOne('abc')
        self.assertEqual(inst.discriminator, 'abc')

    def test_ctor_without_discriminator(self):
        inst = self._makeOne()
        self.assertEqual(inst.discriminator.__class__, type(lambda x: True))

    def test_ctor_with_action_mode(self):
        from substanced.interfaces import MODE_IMMEDIATE
        inst = self._makeOne('abc', action_mode=MODE_IMMEDIATE)
        self.assertEqual(inst.action_mode, MODE_IMMEDIATE)

    def test_ctor_without_action_mode(self):
        from substanced.interfaces import MODE_ATCOMMIT
        inst = self._makeOne('abc')
        self.assertEqual(inst.action_mode, MODE_ATCOMMIT)

class TestFacetIndex(unittest.TestCase):
    def _makeOne(self, discriminator=None, facets=None, family=None,
                 action_mode=None):
        from ..indexes import FacetIndex
        return FacetIndex(discriminator, facets, family,
                          action_mode=action_mode)
    
    def test_ctor_with_discriminator(self):
        inst = self._makeOne('abc')
        self.assertEqual(inst.discriminator, 'abc')
        self.assertEqual(list(inst.facets), [])

    def test_ctor_without_discriminator(self):
        inst = self._makeOne()
        self.assertEqual(inst.discriminator.__class__, type(lambda x: True))

    def test_ctor_with_action_mode(self):
        from substanced.interfaces import MODE_IMMEDIATE
        inst = self._makeOne('abc', action_mode=MODE_IMMEDIATE)
        self.assertEqual(inst.action_mode, MODE_IMMEDIATE)

    def test_ctor_without_action_mode(self):
        from substanced.interfaces import MODE_ATCOMMIT
        inst = self._makeOne('abc')
        self.assertEqual(inst.action_mode, MODE_ATCOMMIT)

class TestTextIndex(unittest.TestCase):
    def _makeOne(
        self,
        discriminator=None,
        lexicon=None,
        index=None,
        family=None,
        action_mode=None,
        ):
        from ..indexes import TextIndex
        return TextIndex(discriminator, family, action_mode=action_mode)
    
    def test_ctor_with_discriminator(self):
        inst = self._makeOne('abc')
        self.assertEqual(inst.discriminator, 'abc')

    def test_ctor_without_discriminator(self):
        inst = self._makeOne()
        self.assertEqual(inst.discriminator.__class__, type(lambda x: True))

    def test_ctor_with_action_mode(self):
        from substanced.interfaces import MODE_IMMEDIATE
        inst = self._makeOne(action_mode=MODE_IMMEDIATE)
        self.assertEqual(inst.action_mode, MODE_IMMEDIATE)

    def test_ctor_without_action_mode(self):
        from substanced.interfaces import MODE_ATCOMMIT
        inst = self._makeOne()
        self.assertEqual(inst.action_mode, MODE_ATCOMMIT)

class TestAllowedIndex(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self, discriminator=None, family=None):
        from ..indexes import AllowedIndex
        index = AllowedIndex(discriminator, family=family)
        return index

    def test_alt_family(self):
        index = self._makeOne(None, family='foo')
        self.assertEqual(index.family, 'foo')

    def test_document_repr(self):
        index = self._makeOne(None)
        self.assertEqual(index.document_repr(None), 'N/A')

    def test_allows_request(self):
        index = self._makeOne(None)
        request = testing.DummyRequest()
        q = index.allows(request, 'edit')
        self.assertEqual(q._value, (['system.Everyone'], 'edit'))

    def test_allows_iterable(self):
        index = self._makeOne(None)
        q = index.allows(['bob', 'joe'], 'edit')
        self.assertEqual(q._value, (['bob', 'joe'], 'edit'))

    def test_allows_single(self):
        index = self._makeOne(None)
        q = index.allows('bob', 'edit')
        self.assertEqual(q._value, (('bob',), 'edit'))

class TestAllowsComparator(unittest.TestCase):
    def _makeOne(self, index, value):
        from ..indexes import AllowsComparator
        return AllowsComparator(index, value)

    def test_union(self):
        inst = self._makeOne(None, None)
        self.assertRaises(NotImplementedError, inst.union, None, None)

    def test__apply(self):
        inst = self._makeOne(None, None)
        self.assertRaises(NotImplementedError, inst._apply, None)

    def test_negate(self):
        inst = self._makeOne(None, None)
        self.assertRaises(NotImplementedError, inst.negate)

    def test___str__(self):
        inst = self._makeOne(None, None)
        self.assertEqual(inst.__str__(), 'allows query')

    def test_intersect(self):
        objectmap = DummyObjectmap()
        context = Dummy()
        context.__objectmap__ = objectmap
        inst = self._makeOne(context, (('fred',), 'edit'))
        result = inst.intersect([1], [])
        self.assertEqual(list(result), [1])
        
class TestIndexPropertySheet(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..indexes import IndexPropertySheet
        return IndexPropertySheet(context, request)

    def test_set_action_mode_different(self):
        from substanced.interfaces import (
            MODE_IMMEDIATE,
            MODE_ATCOMMIT,
            )
        context = testing.DummyResource()
        context.action_mode = MODE_ATCOMMIT
        inst = self._makeOne(context, None)
        inst.set({'action_mode':'MODE_IMMEDIATE'})
        self.assertEqual(context.action_mode, MODE_IMMEDIATE)

    def test_set_action_mode_same(self):
        from substanced.interfaces import MODE_ATCOMMIT
        context = testing.DummyResource()
        context.action_mode = MODE_ATCOMMIT
        inst = self._makeOne(context, None)
        inst.set({'action_mode':'MODE_ATCOMMIT'})
        self.assertEqual(context.action_mode, MODE_ATCOMMIT)

    def test_get_action_mode(self):
        from substanced.interfaces import MODE_IMMEDIATE
        context = testing.DummyResource()
        context.action_mode = MODE_IMMEDIATE
        inst = self._makeOne(context, None)
        result = inst.get()
        self.assertEqual(result['action_mode'], 'MODE_IMMEDIATE')

class Dummy(object):
    pass

class DummyCatalog(object):
    family = BTrees.family64
    def __init__(self, objectids=None):
        if objectids is None:
            objectids = self.family.II.TreeSet()
        self.objectids = objectids

class DummyObjectmap(object):
    def object_for(self, docid): return 'a'

    def allowed(self, theset, principals, permission): return theset

class DummyQuery(object):
    def flush(self, *arg, **kw):
        self.flushed = True
        
    def _apply(self, names):
        return [1,2,3]
    
class DummyDiscriminator(object):
    permissions = (1, 2)
    def __call__(self): pass

class DummyActionTM(object):
    def __init__(self, index):
        self.index = index
        self.actions = []
    def register(self):
        self.registered = True
    def flush(self, all):
        self.flushed = all
    def add(self, action):
        self.actions.append(action)
        

########NEW FILE########
__FILENAME__ = test_subscribers
import unittest
import BTrees

from zope.interface import alsoProvides

from pyramid import testing

def _makeSite(**kw):
    from ...interfaces import IFolder
    from ...interfaces import IService
    site = testing.DummyResource(__provides__=kw.pop('__provides__', None))
    alsoProvides(site, IFolder)
    objectmap = kw.pop('objectmap', None)
    if objectmap is not None:
        site.__objectmap__ = objectmap
    for k, v in kw.items():
        if k == 'catalog':
            catalogs = testing.DummyResource(
                __provides__=(IFolder, IService),
                )
            site['catalogs'] = catalogs
            catalogs['system'] = v
    return site

class Test_object_added(unittest.TestCase):
    def _callFUT(self, event):
        from ..subscribers import object_added
        return object_added(event)

    def test_no_catalog(self):
        model = testing.DummyResource()
        event = testing.DummyResource(object=model)
        self._callFUT(event) # doesnt blow up

    def test_catalogable_objects(self):
        from ...interfaces import IFolder
        catalog = DummyCatalog()
        objectmap = DummyObjectMap()
        site = _makeSite(objectmap=objectmap, catalog=catalog)
        model1 = testing.DummyResource(__provides__=(IFolder,))
        model1.__oid__ = 1
        model2 = testing.DummyResource()
        model2.__oid__ = 2
        model1['model2'] = model2
        site['model1'] = model1
        event = DummyEvent(model1, None)
        self._callFUT(event)
        indexed = catalog.indexed
        self.assertEqual(len(indexed), 2)
        self.assertEqual(indexed[0][0], model2)
        self.assertEqual(indexed[0][1], 2)
        self.assertEqual(indexed[1][0], model1)
        self.assertEqual(indexed[1][1], 1)
        
    def test_catalogable_objects_disjoint(self):
        from ...interfaces import IFolder
        catalog = DummyCatalog()
        objectmap = DummyObjectMap()
        site = _makeSite(objectmap=objectmap, catalog=catalog)
        model1 = testing.DummyResource(__provides__=IFolder)
        model2 = testing.DummyResource()
        model2.__oid__ = 1
        model1['model2'] = model2
        site['model1'] = model1
        event = DummyEvent(model1, None)
        self._callFUT(event)
        indexed = catalog.indexed
        self.assertEqual(len(indexed), 1)
        self.assertEqual(indexed[0][0], model2)
        self.assertEqual(indexed[0][1], 1)

    def test_multiple_catalogs(self):
        from ...interfaces import IFolder
        catalog1 = DummyCatalog()
        catalog2 = DummyCatalog()
        objectmap = DummyObjectMap()
        inner_site = _makeSite(catalog=catalog2)
        inner_site.__oid__ = -1
        outer_site = _makeSite(objectmap=objectmap, catalog=catalog1)
        outer_site['inner'] = inner_site
        model1 = testing.DummyResource(__provides__=(IFolder,))
        model1.__oid__ = 1
        model2 = testing.DummyResource()
        model2.__oid__ = 2
        model1['model2'] = model2
        inner_site['model1'] = model1
        event = DummyEvent(model1, None)
        self._callFUT(event)
        for catalog in (catalog1, catalog2):
            indexed = catalog.indexed
            self.assertEqual(len(indexed), 2)
            self.assertEqual(indexed[0][0], model2)
            self.assertEqual(indexed[0][1], 2)
            self.assertEqual(indexed[1][0], model1)
            self.assertEqual(indexed[1][1], 1)

    def test_moving_rename(self):
        from ...interfaces import IFolder
        catalog = DummyCatalog()
        objectmap = DummyObjectMap()
        site = _makeSite(objectmap=objectmap, catalog=catalog)
        model1 = testing.DummyResource(__provides__=(IFolder,))
        model1.__oid__ = 1
        model2 = testing.DummyResource()
        model2.__oid__ = 2
        model1['model2'] = model2
        site['model1'] = model1
        event = DummyEvent(model1, site, moving=site)
        self._callFUT(event)
        reindexed = catalog.reindexed
        self.assertEqual(len(reindexed), 2)
        self.assertEqual(reindexed[0][0], model2)
        self.assertEqual(reindexed[0][1], 2)
        self.assertEqual(reindexed[1][0], model1)
        self.assertEqual(reindexed[1][1], 1)

    def test_moving_not_rename_same_catalogs(self):
        from ...interfaces import IFolder
        catalog = DummyCatalog()
        objectmap = DummyObjectMap()
        site = _makeSite(objectmap=objectmap, catalog=catalog)
        model1 = testing.DummyResource(__provides__=(IFolder,))
        model1.__oid__ = 1
        model2 = testing.DummyResource()
        model2.__oid__ = 2
        model1['model2'] = model2
        site['model1'] = model1
        foo = site['foo'] = testing.DummyResource()
        event = DummyEvent(model1, site, moving=foo)
        self._callFUT(event)
        reindexed = catalog.reindexed
        self.assertEqual(len(reindexed), 2)
        self.assertEqual(reindexed[0][0], model2)
        self.assertEqual(reindexed[0][1], 2)
        self.assertEqual(reindexed[1][0], model1)
        self.assertEqual(reindexed[1][1], 1)
        
    def test_moving_not_rename_different_catalogs(self):
        from ...interfaces import IFolder
        catalog = DummyCatalog()
        catalog2 = DummyCatalog()
        objectmap = DummyObjectMap()
        site = _makeSite(objectmap=objectmap, catalog=catalog)
        site2 = _makeSite(catalog=catalog2)
        model1 = testing.DummyResource(__provides__=(IFolder,))
        model1.__oid__ = 1
        model2 = testing.DummyResource()
        model2.__oid__ = 2
        model1['model2'] = model2
        site['model1'] = model1
        event = DummyEvent(model1, site, moving=site2)
        self._callFUT(event)
        indexed = catalog.indexed
        self.assertEqual(len(indexed), 2)
        self.assertEqual(indexed[0][0], model2)
        self.assertEqual(indexed[0][1], 2)
        self.assertEqual(indexed[1][0], model1)
        self.assertEqual(indexed[1][1], 1)

class Test_object_removed(unittest.TestCase):
    def _callFUT(self, event):
        from ..subscribers import object_removed
        return object_removed(event)

    def test_no_objectmap(self):
        model = testing.DummyResource()
        parent = testing.DummyResource()
        event = DummyEvent(object=model, parent=parent)
        event.removed_oids = None
        self._callFUT(event) # doesnt blow up

    def test_no_catalog(self):
        site = _makeSite()
        event = DummyEvent(None, site)
        self._callFUT(event) # doesnt blow up

    def test_with_removed_oids(self):
        catalog = DummyCatalog()
        catalog.objectids = catalog.family.IF.Set([1,2])
        site = _makeSite(catalog=catalog)
        event = DummyEvent(None, site)
        event.removed_oids = catalog.family.IF.Set([1,2])
        self._callFUT(event)
        self.assertEqual(catalog.unindexed, [1,2])

    def test_with_pathlookup_limited_by_objectids(self):
        catalog = DummyCatalog()
        catalog.objectids = catalog.family.IF.Set([1])
        site = _makeSite(catalog=catalog)
        event = DummyEvent(None, site)
        event.removed_oids = catalog.family.IF.Set([1,2])
        self._callFUT(event)
        self.assertEqual(catalog.unindexed, [1])

    def test_multiple_catalogs(self):
        catalog1 = DummyCatalog()
        catalog1.objectids = catalog1.family.IF.Set([1])
        catalog2 = DummyCatalog()
        catalog2.objectids = catalog2.family.IF.Set([2])
        outer = _makeSite(catalog=catalog1)
        inner = _makeSite(catalog=catalog2)
        inner.__oid__ = -1
        outer['inner'] = inner
        event = DummyEvent(None, inner)
        event.removed_oids = catalog1.family.IF.Set([1,2])
        self._callFUT(event)
        self.assertEqual(catalog1.unindexed, [1])
        self.assertEqual(catalog2.unindexed, [2])

    def test_moving_rename(self):
        catalog = DummyCatalog()
        catalog.objectids = catalog.family.IF.Set([1,2])
        site = _makeSite(catalog=catalog)
        event = DummyEvent(None, site, moving=site)
        event.removed_oids = catalog.family.IF.Set([1,2])
        self._callFUT(event)
        self.assertEqual(catalog.unindexed, [])
        
    def test_moving_not_rename_same_catalogs(self):
        catalog = DummyCatalog()
        catalog.objectids = catalog.family.IF.Set([1,2])
        site = _makeSite(catalog=catalog)
        foo = site['foo'] = testing.DummyResource()
        event = DummyEvent(None, site, moving=foo)
        event.removed_oids = catalog.family.IF.Set([1,2])
        self._callFUT(event)
        self.assertEqual(catalog.unindexed, [])

    def test_moving_not_rename_different_catalogs(self):
        catalog = DummyCatalog()
        catalog.objectids = catalog.family.IF.Set([1,2])
        catalog2 = DummyCatalog()
        site = _makeSite(catalog=catalog)
        site2 = _makeSite(catalog=catalog2)
        event = DummyEvent(None, site, moving=site2)
        event.removed_oids = catalog.family.IF.Set([1,2])
        self._callFUT(event)
        self.assertEqual(catalog.unindexed, [1,2])
        
class Test_object_modified(unittest.TestCase):
    def _callFUT(self, event):
        from ..subscribers import object_modified
        return object_modified(event)

    def test_no_catalog(self):
        objectmap = DummyObjectMap()
        site = _makeSite(objectmap=objectmap)
        model = testing.DummyResource()
        model.__oid__ = 1
        site['model'] = model
        event = DummyEvent(model, site)
        content = DummyContent()
        registry = DummyRegistry(content=content)
        event.registry = registry
        self._callFUT(event) # doesnt blow up
        
    def test_catalogable_object(self):
        objectmap = DummyObjectMap()
        catalog = DummyCatalog()
        site = _makeSite(objectmap=objectmap, catalog=catalog)
        model = testing.DummyResource()
        model.__oid__ = 1
        site['model'] = model
        event = DummyEvent(model, site)
        content = DummyContent()
        registry = DummyRegistry(content=content)
        event.registry = registry
        self._callFUT(event)
        reindexed = catalog.reindexed
        self.assertEqual(len(reindexed), 1)
        self.assertEqual(reindexed[0][0], model)
        self.assertEqual(reindexed[0][1], 1)

    def test_multiple_catalogs(self):
        objectmap = DummyObjectMap()
        catalog1 = DummyCatalog()
        catalog2 = DummyCatalog()
        outer = _makeSite(objectmap=objectmap, catalog=catalog1)
        inner = _makeSite(catalog=catalog2)
        inner.__oid__ = -1
        outer['inner'] = inner
        model = testing.DummyResource()
        model.__oid__ = 1
        inner['model'] = model
        outer['inner'] = inner
        event = DummyEvent(model, None)
        content = DummyContent()
        registry = DummyRegistry(content=content)
        event.registry = registry
        self._callFUT(event)
        for catalog in (catalog1, catalog2):
            reindexed = catalog.reindexed
            self.assertEqual(len(reindexed), 1)
            self.assertEqual(reindexed[0][0], model)
            self.assertEqual(reindexed[0][1], 1)

class Test_on_startup(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, event):
        from ..subscribers import on_startup
        return on_startup(event)

    def test_autosync_false_from_ini(self):
        registry = self.config.registry
        registry.content = DummyContentRegistry()
        registry.settings['substanced.catalogs.autosync'] = 'false'
        app = testing.DummyResource()
        app.registry = registry
        event = DummyEvent(app, None)
        result = self._callFUT(event)
        self.assertEqual(result, None)

    def test_autosync_false_from_ini_bc(self):
        registry = self.config.registry
        registry.content = DummyContentRegistry()
        registry.settings['substanced.autosync_catalogs'] = 'false'
        app = testing.DummyResource()
        app.registry = registry
        event = DummyEvent(app, None)
        result = self._callFUT(event)
        self.assertEqual(result, None)
        
    def test_autosync_missing_from_ini(self):
        registry = self.config.registry
        registry.content = DummyContentRegistry()
        app = testing.DummyResource()
        app.registry = registry
        event = DummyEvent(app, None)
        result = self._callFUT(event)
        self.assertEqual(result, None)

    def test_autosync_true_from_ini_unfinished_evolve_steps(self):
        from substanced.interfaces import IEvolutionSteps
        from substanced.evolution import FINISHED_KEY
        registry = self.config.registry
        registry.content = DummyContentRegistry()
        registry.settings['substanced.catalogs.autosync'] = 'true'
        steps = testing.DummyResource()
        steps.sorted = lambda: [('a', ('b', 'b'))]
        registry.registerUtility(steps, IEvolutionSteps)
        app = testing.DummyResource()
        app.registry = registry
        root = testing.DummyResource()
        root._p_jar = testing.DummyResource()
        trueroot = {}
        trueroot[FINISHED_KEY] = {}
        root._p_jar.root = lambda: trueroot
        app.root_factory = lambda *arg: root
        event = DummyEvent(app, None)
        result = self._callFUT(event)
        self.assertEqual(result, None)

    def test_autosync_true_from_ini_no_objectmap(self):
        registry = self.config.registry
        registry.content = DummyContentRegistry()
        registry.settings['substanced.catalogs.autosync'] = 'true'
        app = testing.DummyResource()
        app.registry = registry
        root = testing.DummyResource()
        app.root_factory = lambda *arg: root
        event = DummyEvent(app, None)
        result = self._callFUT(event)
        self.assertEqual(result, None)

    def test_autosync_false_from_environ(self):
        import os
        from mock import patch
        with patch.dict(os.environ, {'SUBSTANCED_CATALOGS_AUTOSYNC':'false'}):
            registry = self.config.registry
            registry.content = DummyContentRegistry()
            registry.settings['substanced.catalogs.autosync'] = 'true'
            app = testing.DummyResource()
            app.registry = registry
            event = DummyEvent(app, None)
            result = self._callFUT(event)
            self.assertEqual(result, None)

    def test_autosync_true_from_environ_no_objectmap(self):
        from mock import patch
        import os
        with patch.dict(os.environ, {'SUBSTANCED_CATALOGS_AUTOSYNC':'true'}):
            registry = self.config.registry
            registry.content = DummyContentRegistry()
            registry.settings['substanced.catalogs.autosync'] = 'false'
            app = testing.DummyResource()
            app.registry = registry
            root = testing.DummyResource()
            app.root_factory = lambda *arg: root
            event = DummyEvent(app, None)
            result = self._callFUT(event)
            self.assertEqual(result, None)
        
    def test_autosync_true_no_oids(self):
        registry = self.config.registry
        registry.content = DummyContentRegistry()
        registry.settings['substanced.catalogs.autosync'] = 'true'
        app = testing.DummyResource()
        app.registry = registry
        root = testing.DummyResource()
        root.__objectmap__ = DummyObjectMap([])
        app.root_factory = lambda *arg: root
        event = DummyEvent(app, None)
        result = self._callFUT(event)
        self.assertEqual(result, None)

    def test_autosync_true_with_oids(self):
        registry = self.config.registry
        registry.content = DummyContentRegistry()
        registry.settings['substanced.catalogs.autosync'] = 'true'
        app = testing.DummyResource()
        app.registry = registry
        root = testing.DummyResource()
        catalog = DummyCatalog()
        root.__objectmap__ = DummyObjectMap([1], catalog)
        app.root_factory = lambda *arg: root
        event = DummyEvent(app, None)
        result = self._callFUT(event)
        self.assertEqual(result, None)
        self.assertTrue(catalog.updated)

    def test_autosync_true_with_oids_raises(self):
        from zope.interface.interfaces import ComponentLookupError
        registry = self.config.registry
        registry.content = DummyContentRegistry()
        registry.settings['substanced.catalogs.autosync'] = 'true'
        app = testing.DummyResource()
        app.registry = registry
        root = testing.DummyResource()
        catalog = DummyCatalog(raises=ComponentLookupError)
        root.__objectmap__ = DummyObjectMap([1], catalog)
        app.root_factory = lambda *arg: root
        event = DummyEvent(app, None)
        result = self._callFUT(event)
        self.assertEqual(result, None)
        self.assertFalse(catalog.updated)

class DummyCatalog(dict):
    
    family = BTrees.family64
    updated = False
    
    def __init__(self, result=None, raises=None):
        self.queries = []
        self.indexed = []
        self.unindexed = []
        self.reindexed = []
        self.objectids = self.family.II.TreeSet()
        self.result = result
        self.raises = raises

    def __eq__(self, other):
        return other is self

    def index_resource(self, resource, oid=None):
        self.indexed.append((resource, oid))

    def unindex_resource(self, resource_or_oid):
        self.unindexed.append(resource_or_oid)

    def reindex_resource(self, resource, oid=None):
        self.reindexed.append((resource, oid))

    def update_indexes(self, *arg, **kw):
        if self.raises:
            raise self.raises
        self.updated = True
        return self.result

class DummyObjectMap:
    family = BTrees.family64

    def __init__(self, result=None, object_result=None):
        self.result = result
        self.object_result = object_result

    def get_extent(self, name):
        return self.result

    def object_for(self, oid):
        return self.object_result
    
class DummyEvent(object):
    removed_oids = None
    def __init__(self, object, parent, registry=None, moving=None):
        self.object = object
        self.parent = parent
        self.registry = registry
        self.moving = moving
        
class DummyContent(object):
    pass

class DummyRegistry(object):
    def __init__(self, content):
        self.content = content
        
class DummyContentRegistry(object):
    def __init__(self, result=None):
        self.result = result

    def factory_type_for_content_type(self, content_type):
        return self.result
    

########NEW FILE########
__FILENAME__ = test_system
import unittest
from pyramid import testing

from zope.interface import Interface
from zope.interface import alsoProvides

class TestSystemIndexViews(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self, resource):
        from ..system import SystemIndexViews
        return SystemIndexViews(resource)

    def test_interfaces(self):
        resource = testing.DummyResource()
        class Dummy1(Interface):
            pass
        class Dummy2(Interface):
            pass
        alsoProvides(resource, Dummy1)
        alsoProvides(resource, Dummy2)
        inst = self._makeOne(resource)
        result = inst.interfaces(None)
        self.assertEqual(len(result), 3)
        self.assertTrue(Dummy1 in result)
        self.assertTrue(Dummy2 in result)
        self.assertTrue(Interface in result)

    def test_name_has_no_name(self):
        resource = object()
        inst = self._makeOne(resource)
        result = inst.name(None)
        self.assertEqual(result, None)

    def test_name_has_name(self):
        resource = testing.DummyResource()
        resource.__name__ = 'foo'
        inst = self._makeOne(resource)
        result = inst.name(None)
        self.assertEqual(result, 'foo')

    def test_name_has_name_None(self):
        resource = testing.DummyResource()
        resource.__name__ = None
        inst = self._makeOne(resource)
        result = inst.name('abc')
        self.assertEqual(result, 'abc')

    def test_text_name_doesnt_exist(self):
        resource = testing.DummyResource()
        inst = self._makeOne(resource)
        result = inst.text(None)
        self.assertEqual(result, None)

    def test_text_name_is_not_string(self):
        resource = testing.DummyResource()
        resource.__name__ = False
        inst = self._makeOne(resource)
        result = inst.text(None)
        self.assertEqual(result, False)

    def test_text_name_has_no_separators(self):
        resource = testing.DummyResource()
        resource.__name__ = 'foobar'
        inst = self._makeOne(resource)
        result = inst.text(None)
        self.assertEqual(result, 'foobar')

    def test_text_name_has_separators(self):
        resource = testing.DummyResource()
        resource.__name__ = 'foo-bar_baz.pt,foz'
        inst = self._makeOne(resource)
        result = inst.text(None)
        self.assertEqual(result, 'foo-bar_baz.pt,foz foo bar baz pt foz')

    def test_content_type(self):
        resource = testing.DummyResource()
        content = testing.DummyResource()
        def typeof(resrc):
            self.assertEqual(resrc, resource)
            return 'foo'
        content.typeof = typeof
        self.config.registry.content = content
        inst = self._makeOne(resource)
        result = inst.content_type(None)
        self.assertEqual(result, 'foo')

    def test_content_type_None(self):
        resource = testing.DummyResource()
        content = testing.DummyResource()
        def typeof(resrc):
            self.assertEqual(resrc, resource)
            return None
        content.typeof = typeof
        self.config.registry.content = content
        inst = self._makeOne(resource)
        result = inst.content_type('default')
        self.assertEqual(result, 'default')
        

########NEW FILE########
__FILENAME__ = test_util
import unittest
from pyramid import testing


class Test_oid_from_resource(unittest.TestCase):
    def _callFUT(self, resource):
        from ..util import oid_from_resource
        return oid_from_resource(resource)

    def test_it_resource_is_None(self):
        self.assertRaises(ValueError, self._callFUT, None)

    def test_it_resource_has_no_oid(self):
        resource = testing.DummyResource()
        self.assertRaises(ValueError, self._callFUT, resource)

    def test_it_resource_has_oid(self):
        resource = testing.DummyResource()
        resource.__oid__ = 1
        self.assertEqual(self._callFUT(resource), 1)


########NEW FILE########
__FILENAME__ = util
from ..util import get_oid
from .._compat import INT_TYPES

def oid_from_resource(resource):
    oid = get_oid(resource, None)
    if not isinstance(oid, INT_TYPES):
        raise ValueError(
            'Resource must be an object with an integer __oid__ attribute'
            )
    return oid

########NEW FILE########
__FILENAME__ = catalog
import colander
import deform.widget

from hypatia.interfaces import IIndex
from hypatia.query import parse_query

from pyramid.httpexceptions import HTTPFound

from pyramid.view import view_defaults

from substanced.catalog import logger
from substanced.form import FormView
from substanced.interfaces import ICatalog, IFolder
from substanced.objectmap import find_objectmap
from substanced.schema import Schema
from substanced.sdi import mgmt_view

def context_is_an_index(context, request):
    return request.registry.content.metadata(context, 'is_index', False)

@view_defaults(
    name='manage_catalog',
    context=ICatalog,
    renderer='templates/catalog.pt',
    permission='sdi.manage-catalog'
    )
class ManageCatalog(object):
    def __init__(self, context, request):
        self.context = context
        self.request = request

    @property
    def redir_location(self):
        return self.request.sdiapi.mgmt_path(self.context, '@@manage_catalog')
        
    @mgmt_view(request_method='GET', tab_title='Manage')
    def view(self):
        cataloglen = len(self.context.objectids)
        return dict(cataloglen=cataloglen)

    @mgmt_view(request_method='POST', request_param='reindex', check_csrf=True)
    def reindex(self):
        self.context.reindex()
        self.request.sdiapi.flash('Catalog reindexed')
        return HTTPFound(location=self.redir_location)

    @mgmt_view(request_method='POST', request_param='update', check_csrf=True)
    def update(self):
        self.context.update_indexes()
        self.request.sdiapi.flash('Catalog index definitions updated')
        return HTTPFound(location=self.redir_location)

@view_defaults(
    name='manage_index',
    context=IIndex,
    renderer='templates/index.pt',
    permission='sdi.manage-catalog')
class ManageIndex(object):
    def __init__(self, context, request):
        self.context = context
        self.request = request

    @property
    def redir_location(self):
        return self.request.sdiapi.mgmt_path(self.context, '@@manage_index')

    @mgmt_view(request_method='GET', tab_title='Manage')
    def view(self):
        index = self.context
        indexed = index.indexed_count()
        not_indexed = index.not_indexed_count()
        index_name = index.__name__
        return dict(
            indexed=indexed,
            not_indexed=not_indexed,
            index_name=index_name,
            index_type = index.__class__.__name__,
            )

    @mgmt_view(request_method='POST', request_param='reindex', check_csrf=True)
    def reindex(self):
        index_name = self.context.__name__
        catalog  = self.context.__parent__
        if ICatalog.providedBy(catalog):
            catalog.reindex(indexes=[index_name])
            self.request.sdiapi.flash('Index "%s" reindexed' % index_name,
                                       'success')
        else:
            self.request.sdiapi.flash(
                'Cannot reindex an index unless it is contained in a catalog',
                'danger'
                )
        return HTTPFound(location=self.redir_location)

class SearchSchema(Schema):
    cqe_expression = colander.SchemaNode(
        colander.String(),
        widget = deform.widget.TextAreaWidget(rows=10, cols=120),
        title='CQE Expression',
        )

@mgmt_view(context=ICatalog, name='search_catalog', 
           permission='sdi.manage-catalog', 
           renderer='templates/search.pt', tab_title='Search')
class SearchCatalogView(FormView):
    schema = SearchSchema(title='Expression')
    buttons = ('search',)
    catalog_results = None
    logger = logger
    parse_query = staticmethod(parse_query) # for testing
    find_objectmap = staticmethod(find_objectmap) # for testing

    def search_success(self, appstruct):
        """ Accept a CQE expression and a permitted value and return a 
        sequence of object renderings """
        self.request.session['catalogsearch.appstruct'] = appstruct
        context = self.context
        return HTTPFound(
            location=self.request.sdiapi.mgmt_path(context, '@@search_catalog')
            )

    def show(self, form):
        appstruct = self.request.session.pop('catalogsearch.appstruct',
                                             colander.null)
        searchresults = ()
        if appstruct:
            expr = appstruct['cqe_expression']
            try:
                q = self.parse_query(expr, self.context)
                resultset = q.execute().all(resolve=False)
            except Exception as e:
                self.logger.exception('During search')
                cls_name = e.__class__.__name__
                msg = 'Query failed (%s: %s)' % (cls_name, e.args[0])
                self.request.sdiapi.flash(msg, 'danger')
            else:
                objectmap = self.find_objectmap(self.context)
                resolve = objectmap.object_for
                searchresults = list([(oid, resolve(oid)) for oid in resultset])
                if not searchresults:
                    searchresults = [('', 'No results')]
                self.request.sdiapi.flash('Query succeeded', 'success')
        return {
            'searchresults':searchresults,
            'form':form.render(appstruct=appstruct),
            }

# reindex button handler

@mgmt_view(
    context=IFolder,
    content_type='Catalog',
    name='contents',
    request_param='form.reindex',
    request_method='POST',
    renderer='substanced.folder:templates/contents.pt',
    permission='sdi.manage-contents',
    tab_condition=False,
    )
def reindex_indexes(context, request):
    toreindex_str = request.POST.get('item-modify', '')
    toreindex = [x for x in toreindex_str.split('/') if x]
    toreindex_fmt = ', '.join(toreindex)
    if toreindex:
        context.reindex(indexes=toreindex, registry=request.registry)
        request.sdiapi.flash(
            'Reindex of selected indexes %s succeeded' % (toreindex_fmt,),
            'success'
            )
    else:
        request.sdiapi.flash(
            'No indexes selected to reindex',
            'danger'
            )
        
    return HTTPFound(request.sdiapi.mgmt_path(context, '@@contents'))

########NEW FILE########
__FILENAME__ = indexing
from pyramid.view import view_defaults
from pyramid.httpexceptions import HTTPFound
from pyramid.session import check_csrf_token

from substanced.interfaces import MODE_IMMEDIATE
from substanced.util import (
    get_oid,
    find_catalogs,
    _,
    )

from substanced.sdi import (
    mgmt_view,
    RIGHT,
    )

@view_defaults(
    catalogable=True,
    name='indexing',
    permission='sdi.manage-catalog',
    )
class IndexingView(object):

    def __init__(self, context, request):
        self.context = context
        self.request = request
    
    @mgmt_view(
        renderer='templates/indexing.pt',
        tab_title=_('Indexing'),
        tab_near=RIGHT, # try not to be the default tab, we're too obscure
        )
    def show(self):
        oid = get_oid(self.context)
        catalogs = []
        for catalog in find_catalogs(self.context):
            indexes = []
            catalogs.append((catalog, indexes))
            for index in catalog.values():
                docrepr = index.document_repr(oid, '(not indexed)')
                indexes.append({'index':index, 'value':docrepr})
        return {'catalogs':catalogs}

    @mgmt_view(request_method='POST', tab_condition=False)
    def reindex(self):
        context = self.context
        request = self.request
        check_csrf_token(request)
        oid = get_oid(context)
        for catalog in find_catalogs(context):
            catalog.reindex_resource(
                context, oid=oid, action_mode=MODE_IMMEDIATE
                )
        request.sdiapi.flash_with_undo('Object reindexed', 'success')
        return HTTPFound(request.sdiapi.mgmt_url(context, '@@indexing'))

########NEW FILE########
__FILENAME__ = test_catalog
import unittest
from pyramid import testing

class TestManageCatalog(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..catalog import ManageCatalog
        return ManageCatalog(context, request)

    def test_view(self):
        context = DummyCatalog()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        result = inst.view()
        self.assertEqual(result['cataloglen'], 0)

    def test_reindex(self):
        context = DummyCatalog()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        result = inst.reindex()
        self.assertEqual(result.location, '/mgmt_path')
        self.assertEqual(context.reindexed, None)

    def test_update(self):
        context = DummyCatalog()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        result = inst.update()
        self.assertEqual(result.location, '/mgmt_path')
        self.assertEqual(context.updated, True)

class TestManageIndex(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..catalog import ManageIndex
        return ManageIndex(context, request)

    def test_view(self):
        context = DummyIndex()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        result = inst.view()
        self.assertEqual(result['indexed'], 1)
        self.assertEqual(result['not_indexed'], 1)
        self.assertEqual(result['index_name'], 'name')
        self.assertEqual(result['index_type'], 'DummyIndex')

    def test_reindex_parent_not_icatalog(self):
        context = DummyIndex(False)
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        result = inst.reindex()
        self.assertEqual(result.location, '/mgmt_path')
        self.assertEqual(
            request.sdiapi.flashed,
            'Cannot reindex an index unless it is contained in a catalog')

    def test_reindex_parent_is_icatalog(self):
        from zope.interface import alsoProvides
        from substanced.interfaces import ICatalog
        catalog = DummyCatalog()
        alsoProvides(catalog, ICatalog)
        context = DummyIndex(catalog)
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        result = inst.reindex()
        self.assertEqual(result.location, '/mgmt_path')
        self.assertEqual(catalog.indexes, ['name'])
        self.assertEqual(
            request.sdiapi.flashed, 'Index "name" reindexed')

class TestSearchCatalogView(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..catalog import SearchCatalogView
        return SearchCatalogView(context, request)

    def test_search_success(self):
        request = testing.DummyRequest()
        context = testing.DummyResource()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        resp = inst.search_success({'a':1})
        self.assertEqual(request.session['catalogsearch.appstruct'], {'a':1})
        self.assertEqual(resp.location, '/mgmt_path')

    def test_show_no_appstruct(self):
        request = testing.DummyRequest()
        context = testing.DummyResource()
        form = DummyForm()
        inst = self._makeOne(context, request)
        result = inst.show(form)
        self.assertEqual(result, {'searchresults': (),
                                  'form':'form'})

    def test_show_with_appstruct_no_results(self):
        request = testing.DummyRequest()
        context = testing.DummyResource()
        appstruct = {'cqe_expression':"name=='abc'"}
        request.session['catalogsearch.appstruct'] = appstruct
        request.sdiapi = DummySDIAPI()
        form = DummyForm()
        inst = self._makeOne(context, request)
        q = DummyQuery([])
        objectmap = DummyObjectmap()
        def parse_query(expr, catalog):
            return q
        def find_objectmap(context):
            return objectmap 
        inst.parse_query = parse_query
        inst.find_objectmap = find_objectmap
        result = inst.show(form)
        self.assertEqual(result, {'searchresults': [('', 'No results')],
                                  'form':'form'})
        self.assertEqual(request.sdiapi.flashed, 'Query succeeded')

    def test_show_with_appstruct_and_results(self):
        request = testing.DummyRequest()
        context = testing.DummyResource()
        appstruct = {'cqe_expression':"name=='abc'"}
        request.session['catalogsearch.appstruct'] = appstruct
        request.sdiapi = DummySDIAPI()
        form = DummyForm()
        inst = self._makeOne(context, request)
        q = DummyQuery([1,2])
        objectmap = DummyObjectmap()
        def parse_query(expr, catalog):
            return q
        def find_objectmap(context):
            return objectmap 
        inst.parse_query = parse_query
        inst.find_objectmap = find_objectmap
        result = inst.show(form)
        self.assertEqual(result, {'searchresults': [(1,1), (2,2)],
                                  'form':'form'})
        self.assertEqual(request.sdiapi.flashed, 'Query succeeded')

    def test_show_with_appstruct_query_exception(self):
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        context = testing.DummyResource()
        appstruct = {'cqe_expression':"name=='abc'"}
        request.session['catalogsearch.appstruct'] = appstruct
        form = DummyForm()
        inst = self._makeOne(context, request)
        inst.logger = DummyLogger()
        result = inst.show(form)
        self.assertEqual(result, {'searchresults': (),
                                  'form':'form'})
        self.assertEqual(request.sdiapi.flashed,
                         'Query failed (KeyError: name)')

class Test_content_is_an_index(unittest.TestCase):
    def setUp(self):
        testing.setUp()
    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, context, request):
        from ..catalog import context_is_an_index
        return context_is_an_index(context, request)
    
    def test_it_true(self):
        request = testing.DummyRequest()
        request.registry.content = DummyContent(True)
        context = testing.DummyResource()
        self.assertEqual(self._callFUT(context, request), True)
        
    def test_it_false(self):
        request = testing.DummyRequest()
        request.registry.content = DummyContent(False)
        context = testing.DummyResource()
        self.assertEqual(self._callFUT(context, request), False)

class Test_reindex_indexes(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, context, request):
        from ..catalog import reindex_indexes
        return reindex_indexes(context, request)

    def test_with_indexes(self):
        context = DummyCatalog()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST = {'item-modify':'a'}
        result = self._callFUT(context, request)
        self.assertEqual(result.location, '/mgmt_path')
        self.assertEqual(
            request.sdiapi.flashed,
            'Reindex of selected indexes a succeeded')
        self.assertEqual(context.reindexed, ['a'])

    def test_without_indexes(self):
        context = DummyCatalog()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST = testing.DummyResource()
        request.POST.getall = {}.get
        result = self._callFUT(context, request)
        self.assertEqual(result.location, '/mgmt_path')
        self.assertEqual(
            request.sdiapi.flashed,
            'No indexes selected to reindex')

class DummyContent(object):
    def __init__(self, result):
        self.result = result

    def metadata(self, context, name, default=None):
        return self.result
    

class DummyForm(object):
    def render(self, appstruct):
        return 'form'

class DummyLogger(object):
    def exception(self, msg):
        pass
        
class DummyCatalog(object):
    def __init__(self):
        self.objectids = ()

    def reindex(self, indexes=None, registry=None):
        self.indexes = indexes
        self.reindexed = indexes

    def update_indexes(self):
        self.updated = True

class DummyIndex(object):
    def __init__(self, parent=None):
        if parent is None:
            parent = DummyCatalog()
        self.__parent__ = parent
        self.__name__ = 'name'

    def indexed_count(self):
        return 1

    def not_indexed_count(self):
        return 1
    
class DummyResultSet(object):
    def __init__(self, results):
        self.results = results
    def all(self, resolve=False):
        return self.results

class DummyQuery(object):
    def __init__(self, results):
        self.results = results
    def execute(self):
        return DummyResultSet(self.results)

class DummyObjectmap(object):
    def object_for(self, oid):
        return oid
    
class DummySDIAPI(object):
    def mgmt_path(self, *arg, **kw):
        return '/mgmt_path'
    def flash(self, msg, queue='info'):
        self.flashed = msg


########NEW FILE########
__FILENAME__ = test_indexing
import unittest

from pyramid import testing

class TestIndexingView(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from  ..indexing import IndexingView
        return IndexingView(context, request)

    def _makeCatalogContainer(self):
        from substanced.interfaces import IFolder
        from substanced.interfaces import IService
        catalogs = testing.DummyResource(
            __provides__=(IFolder, IService)
            )
        return catalogs

    def test_show(self):
        from substanced.interfaces import IFolder
        context = testing.DummyResource(__provides__=IFolder)
        request = testing.DummyRequest()
        context.__oid__ = 1
        catalog = DummyCatalog()
        catalogs = self._makeCatalogContainer()
        catalogs['catalog'] = catalog
        context['catalogs'] = catalogs
        inst = self._makeOne(context, request)
        result = inst.show()
        self.assertEqual(
            result,
            {'catalogs':[(catalog, [{'index':catalog.index, 'value':'repr'}])]}
            )

    def test_reindex(self):
        from substanced.interfaces import IFolder
        context = testing.DummyResource(__provides__=IFolder)
        request = testing.DummyRequest()
        token = request.session.new_csrf_token()
        request.POST['csrf_token'] = token
        request.sdiapi = DummySDIAPI()
        context.__oid__ = 1
        catalog = DummyCatalog()
        catalogs = self._makeCatalogContainer()
        catalogs['catalog'] = catalog
        context['catalogs'] = catalogs
        inst = self._makeOne(context, request)
        result = inst.reindex()
        self.assertEqual(result.__class__.__name__, 'HTTPFound')
        self.assertEqual(catalog.oid, 1)
        self.assertEqual(catalog.content, context)
        self.assertEqual(request.sdiapi.flashed,
                         ('Object reindexed', 'success') )

class DummyIndex(object):
    def document_repr(self, oid, default=None):
        return 'repr'

class DummyCatalog(object):
    def __init__(self):
        from zope.interface import directlyProvides
        from ....interfaces import IService
        directlyProvides(self, IService)
        self.index = DummyIndex()

    def values(self):
        return (self.index,)

    def reindex_doc(self, oid, content):
        self.oid = oid
        self.content = content

    def reindex_resource(self, content, oid=None, action_mode=None):
        self.action_mode = action_mode
        return self.reindex_doc(oid, content)

class DummySDIAPI(object):
    def mgmt_url(self, *arg, **kw):
        return 'http://mgmt_url'

    def flash_with_undo(self, message, status):
        self.flashed = (message, status)
        

########NEW FILE########
__FILENAME__ = tests
import sys
import unittest

from pyramid import testing

class TestContentRegistry(unittest.TestCase):
    def _makeOne(self, registry=None):
        from . import ContentRegistry
        return ContentRegistry(registry)

    def test_add(self):
        inst = self._makeOne()
        inst.add('ct', 'ft', None)
        self.assertEqual(inst.factory_types['ft'], 'ct')
        self.assertEqual(inst.content_types['ct'], None)
        self.assertEqual(inst.meta['ct'], {})

    def test_add_with_meta(self):
        inst = self._makeOne()
        inst.add('ct', 'ft', None, icon='fred')
        self.assertEqual(inst.content_types['ct'], None)
        self.assertEqual(inst.meta['ct'], {'icon':'fred'})
        
    def test_create(self):
        registry = DummyRegistry()
        inst = self._makeOne(registry)
        inst._utcnow = lambda *a: 1
        content = testing.DummyResource()
        inst.content_types['dummy'] = lambda a: content
        inst.meta['dummy'] = {}
        self.assertEqual(inst.create('dummy', 'a'), content)
        self.assertTrue(registry.notified)

    def test_create_with_oid(self):
        registry = DummyRegistry()
        inst = self._makeOne(registry)
        inst._utcnow = lambda *a: 1
        content = testing.DummyResource()
        inst.content_types['dummy'] = lambda a: content
        inst.meta['dummy'] = {}
        self.assertEqual(inst.create('dummy', 'a', __oid=2), content)
        self.assertEqual(content.__oid__, 2)

    def test_create_with_after_create_str(self):
        registry = DummyRegistry()
        inst = self._makeOne(registry)
        class Dummy(object):
            def after_create(self, inst, registry):
                self.after_created = True
        inst.content_types['dummy'] = Dummy
        inst.meta['dummy'] = {'after_create':'after_create'}
        ob = inst.create('dummy')
        self.assertEqual(ob.__class__, Dummy)
        self.assertTrue(ob.after_created)

    def test_create_with_after_create_nonstr(self):
        registry = DummyRegistry()
        inst = self._makeOne(registry)
        class Dummy(object):
            pass
        def after_create(ob, registry):
            self.assertEqual(ob.__class__, Dummy)
            ob.after_created = True
        inst.content_types['dummy'] = Dummy
        inst.meta['dummy'] = {'after_create':after_create}
        ob = inst.create('dummy')
        self.assertEqual(ob.__class__, Dummy)
        self.assertTrue(ob.after_created)

    def test_create_with_after_create_sequence(self):
        registry = DummyRegistry()
        inst = self._makeOne(registry)
        class Dummy(object):
            pass
        def after_create1(ob, registry):
            self.assertEqual(ob.__class__, Dummy)
            L = getattr(ob, 'after', [])
            L.append(1)
            ob.after = L
        def after_create2(ob, registry):
            self.assertEqual(ob.__class__, Dummy)
            L = getattr(ob, 'after', [])
            L.append(2)
            ob.after = L
        inst.content_types['dummy'] = Dummy
        inst.meta['dummy'] = {'after_create':(after_create1, after_create2)}
        ob = inst.create('dummy')
        self.assertEqual(ob.__class__, Dummy)
        self.assertEqual(ob.after, [1,2])

    def test_typeof(self):
        inst = self._makeOne()
        dummy = Dummy()
        dummy.__factory_type__ = 'dummy'
        inst.factory_types['dummy'] = 'ct'
        self.assertEqual(inst.typeof(dummy), 'ct')

    def test_typeof_ct_missing(self):
        inst = self._makeOne()
        dummy = Dummy()
        dummy.__factory_type__ = 'dummy'
        self.assertEqual(inst.typeof(dummy), None)

    def test_istype_true(self):
        inst = self._makeOne()
        dummy = Dummy()
        dummy.__factory_type__ = 'dummy'
        inst.factory_types['dummy'] = 'ct'
        self.assertTrue(inst.istype(dummy, 'ct'))

    def test_istype_false(self):
        inst = self._makeOne()
        dummy = Dummy()
        dummy.__factory_type__ = 'notdummy'
        inst.factory_types['dummy'] = 'ct'
        self.assertFalse(inst.istype(dummy, 'dummy'))

    def test_exists(self):
        inst = self._makeOne()
        inst.content_types['category'] = True
        self.assertTrue(inst.exists('category'))
        self.assertFalse(inst.exists('foobar'))
        
    def test_metadata(self):
        inst = self._makeOne()
        inst.factory_types['dummy'] = 'ct'
        inst.content_types['ct'] = True
        inst.meta['ct'] = {'icon':'icon-name'}
        dummy = Dummy()
        dummy.__factory_type__ = 'dummy'
        self.assertEqual(inst.metadata(dummy, 'icon'), 'icon-name')

    def test_metadata_notfound(self):
        inst = self._makeOne()
        inst.factory_types['dummy'] = 'ct'
        inst.content_types['ct'] = True
        inst.meta['dummy'] = {'icon':'icon-name'}
        dummy = Dummy()
        dummy.__factory_type__ = 'dummy'
        self.assertEqual(inst.metadata(dummy, 'doesntexist'), None)

    def test_all(self):
        inst = self._makeOne()
        inst.content_types['dummy'] = True
        inst.content_types['category'] = True
        self.assertEqual(sorted(inst.all()), ['category', 'dummy'])

    def test_find(self):
        root = Dummy()
        root.__factory_type__ = 'dummy'
        resource = Dummy()
        resource.__factory_type__ = 'notdummy'
        resource.__parent__ = root
        inst = self._makeOne()
        inst.factory_types['dummy'] = 'ContentType'
        self.assertEqual(inst.find(resource, 'ContentType'), root)

    def test_factory_type_for_content_type_exists(self):
        inst = self._makeOne()
        inst.factory_types['dummy'] = 'ct'
        self.assertEqual(inst.factory_type_for_content_type('ct'), 'dummy')

    def test_factory_type_for_content_type_notexists(self):
        inst = self._makeOne()
        self.assertEqual(inst.factory_type_for_content_type('ct'), None)
        
class Test_content(unittest.TestCase):
    def _makeOne(self, content_type):
        from ..content import content
        return content(content_type)

    def test_decorates_class(self):
        decorator = self._makeOne('special')
        venusian = DummyVenusian()
        decorator.venusian = venusian
        decorator.venusian.info.scope = 'class'
        class Dummy(object):
            pass
        wrapped = decorator(Dummy)
        self.assertTrue(wrapped is Dummy)
        config = call_venusian(venusian)
        ct = config.content_types
        self.assertEqual(len(ct), 1)

    def test_decorates_function(self):
        decorator = self._makeOne('special')
        venusian = DummyVenusian()
        decorator.venusian = venusian
        decorator.venusian.info.scope = 'class'
        def dummy(): pass
        wrapped = decorator(dummy)
        self.assertTrue(wrapped is dummy)
        config = call_venusian(venusian)
        ct = config.content_types
        self.assertEqual(len(ct), 1)

class Test_service(Test_content):
    def _makeOne(self, content_type):
        from ..content import service
        return service(content_type)
    
    def test_is_service_in_meta(self):
        inst = self._makeOne('Special')
        self.assertTrue('is_service' in inst.meta)

class Test_add_content_type(unittest.TestCase):
    def _callFUT(self, *arg, **kw):
        from . import add_content_type
        return add_content_type(*arg, **kw)

    def test_success_function(self):
        dummy = Dummy()
        def factory(): return dummy
        config = DummyConfig()
        config.registry.content = DummyContentRegistry()
        self._callFUT(config, 'foo', factory, category=Dummy)
        self.assertEqual(len(config.actions), 2)
        ft = config.actions[0][0][0]
        self.assertEqual(
            ft,
            ('sd-factory-type', 'substanced.content.tests.factory')
            )
        self.assertEqual(
            config.actions[1][0][0],
            ('sd-content-type', 'foo')
            )
        config.actions[1][1]['callable']()
        self.assertEqual(
            config.registry.content.added[0][1]['category'], Dummy)
        self.assertEqual(
            config.registry.content.added[0][0][0], 'foo')
        self.assertEqual(
            config.registry.content.added[0][0][2](), dummy)

    def test_success_class(self):
        config = DummyConfig()
        config.registry.content = DummyContentRegistry()
        class Foo(object):
            pass
        self._callFUT(config, 'foo', Foo, category=Dummy)
        self.assertEqual(len(config.actions), 2)
        ft = config.actions[0][0][0]
        self.assertEqual(
            ft,
            ('sd-factory-type', 'substanced.content.tests.Foo')
            )
        self.assertEqual(
            config.actions[1][0][0],
            ('sd-content-type', 'foo')
            )
        config.actions[1][1]['callable']()
        self.assertEqual(
            config.registry.content.added[0][1]['category'], Dummy)
        self.assertEqual(
            config.registry.content.added[0][0][0], 'foo')
        content = config.registry.content.added[0][0][2]()
        self.assertEqual(content.__class__, Foo)

    def test_with_extra_flag(self):
        config = DummyConfig()
        config.registry.content = DummyContentRegistry()
        class Foo(object):
            pass
        self._callFUT(config, 'foo', Foo, catalog=True)
        self.assertEqual(len(config.actions), 2)
        meta = config.actions[1][1]['introspectables'][0]['meta']
        self.assertEqual(meta['catalog'], True)

class Test_add_service_type(Test_add_content_type):
    def _callFUT(self, *arg, **kw):
        from . import add_service_type
        return add_service_type(*arg, **kw)

    def test_is_service_in_meta(self):
        config = DummyConfig()
        config.registry.content = DummyContentRegistry()
        class Foo(object):
            pass
        self._callFUT(config, 'foo', Foo)
        self.assertEqual(len(config.actions), 2)
        meta = config.actions[1][1]['introspectables'][0]['meta']
        self.assertEqual(meta['is_service'], True)
    

class Test__wrap_factory(unittest.TestCase):
    def _callFUT(self, factory, factory_type):
        from . import _wrap_factory
        return _wrap_factory(factory, factory_type)

    def test_content_factory_isclass_factory_type_is_not_supplied(self):
        class Foo(object):
            pass
        factory_type, factory = self._callFUT(Foo, None)
        self.assertTrue(factory is Foo)
        self.assertEqual(factory_type, 'substanced.content.tests.Foo')

    def test_content_factory_isclass_factory_type_is_supplied(self):
        class Foo(object):
            pass
        factory_type, factory = self._callFUT(Foo, 'dummy')
        self.assertFalse(factory is Foo)
        self.assertEqual(factory_type, 'dummy')
        self.assertTrue(factory.__factory__ is Foo)
        ob = factory()
        self.assertTrue(ob.__class__ is Foo)
        self.assertEqual(ob.__factory_type__, 'dummy')

    def test_content_factory_isfunction_factory_type_not_supplied(self):
        class Foo(object):
            pass
        foo = Foo()
        def ctor():
            return foo
        factory_type, factory = self._callFUT(ctor, None)
        self.assertFalse(factory is ctor)
        self.assertTrue(factory.__factory__ is ctor)
        ob = factory()
        self.assertTrue(ob is foo)
        self.assertEqual(ob.__factory_type__, 'substanced.content.tests.ctor')

    def test_content_factory_isfunction_factory_type_is_supplied(self):
        class Foo(object):
            pass
        foo = Foo()
        def ctor():
            return foo
        factory_type, factory = self._callFUT(ctor, 'dummy')
        self.assertFalse(factory is ctor)
        self.assertTrue(factory.__factory__ is ctor)
        ob = factory()
        self.assertTrue(ob is foo)
        self.assertEqual(ob.__factory_type__, 'dummy')

class Test_ContentTypePredicate(unittest.TestCase):
    def _makeOne(self, val, config):
        from . import _ContentTypePredicate
        return _ContentTypePredicate(val, config)

    def _makeConfig(self, result):
        config = Dummy()
        config.registry = Dummy()
        config.registry.content = Dummy()
        config.registry.content.istype = lambda *x: result
        return config
    
    def test___call___true(self):
        config = self._makeConfig(True)
        inst = self._makeOne('abc', config)
        context = Dummy()
        result = inst(context, None)
        self.assertTrue(result)

    def test___call___false(self):
        config = self._makeConfig(False)
        inst = self._makeOne('abc', config)
        context = Dummy()
        result = inst(context, None)
        self.assertFalse(result)

    def test___call___no_cregistry_False(self):
        config = self._makeConfig(False)
        del config.registry.content
        inst = self._makeOne('abc', config)
        context = Dummy()
        result = inst(context, None)
        self.assertFalse(result)

    def test_text(self):
        config = self._makeConfig(True)
        inst = self._makeOne('abc', config)
        self.assertEqual(inst.text(), 'content_type = abc')

    def test_phash(self):
        config = self._makeConfig(True)
        inst = self._makeOne('abc', config)
        self.assertEqual(inst.phash(), 'content_type = abc')

class DummyContentRegistry(object):
    def __init__(self):
        self.added = []

    def add(self, *arg, **meta):
        self.added.append((arg, meta))

class Dummy(object):
    pass

class DummyIntrospectable(dict):
    def __init__(self, *arg, **kw):
        pass

class DummyConfig(object):
    introspectable = DummyIntrospectable
    def __init__(self):
        self.registry = Dummy()
        self.actions = []
        self.content_types = []
    def action(self, *arg, **kw):
        self.actions.append((arg, kw))
    def with_package(self, module):
        return self
    def add_content_type(self, *arg, **kw):
        self.content_types.append((arg, kw))
        
class DummyVenusianContext(object):
    def __init__(self):
        self.config = DummyConfig()

def call_venusian(venusian, context=None):
    if context is None:
        context = DummyVenusianContext()
    for wrapped, callback, category in venusian.attachments:
        callback(context, None, None)
    return context.config
        
class DummyVenusianInfo(object):
    scope = 'notaclass'
    module = sys.modules['substanced.content.tests']
    codeinfo = 'codeinfo'

class DummyVenusian(object):
    def __init__(self, info=None):
        if info is None:
            info = DummyVenusianInfo()
        self.info = info
        self.attachments = []

    def attach(self, wrapped, callback, category=None):
        self.attachments.append((wrapped, callback, category))
        return self.info

class DummyRegistry(object):
    def subscribers(self, dumb, dumber):
        self.notified = dumb
        

########NEW FILE########
__FILENAME__ = test_init
import unittest
from pyramid import testing

class Test_root_factory(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _callFUT(self, request, transaction, get_connection, evolve_packages):
        from .. import root_factory
        return root_factory(request, transaction, get_connection,
                            evolve_packages)

    def _makeRequest(self, app_root=None):
        request = Dummy()
        request.registry = DummyRegistry()
        request.registry.content = Dummy()
        request.registry.content.create = lambda *arg: app_root
        return request

    def test_without_app_root(self):
        txn = DummyTransaction()
        root = {}
        gc = Dummy_get_connection(root)
        ep = DummyFunction(True)
        app_root = object()
        request = self._makeRequest(app_root)
        result = self._callFUT(request, txn, gc, ep)
        self.assertEqual(result, app_root)
        self.assertTrue(txn.committed)
        self.assertTrue(txn.savepointed)
        self.assertTrue(ep.called)
        
    def test_with_app_root(self):
        txn = DummyTransaction()
        app_root = object()
        root = {'app_root':app_root}
        gc = Dummy_get_connection(root)
        ep = DummyFunction(True)
        request = testing.DummyRequest()
        result = self._callFUT(request, txn, gc, ep)
        self.assertEqual(result, app_root)
        self.assertFalse(txn.committed)

class DummyTransaction(object):
    committed = False
    savepointed = False
    def commit(self):
        self.committed = True

    def savepoint(self):
        self.savepointed = True

class Dummy_get_connection(object):
    def __init__(self, root):
        self._root = root

    def root(self):
        return self._root

    def __call__(self, request):
        return self

class DummyFunction(object):
    called = False
    def __init__(self, result):
        self.result = result
    def __call__(self, *args, **kw):
        self.called = True
        self.args = args
        self.kw = kw
        return self.result

class Dummy(object):
    pass

class DummyRegistry(object):
    def notify(self, event):
        self.event = event


########NEW FILE########
__FILENAME__ = test_views
import unittest
from pyramid import testing

class TestManageDatabase(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..views import ManageDatabase
        return ManageDatabase(context, request)

    def test_view_with_activity_monitor(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        am = DummyActivityMonitor()
        conn = DummyConnection(am=am)
        inst.get_connection = lambda *arg: conn
        result = inst.view()
        self.assertEqual(result['data_connections'], '[[1000, 1], [1000, 1]]')
        self.assertEqual(result['data_object_loads'], '[[1000, 1], [1000, 1]]')
        self.assertEqual(result['data_object_stores'], '[[1000, 1], [1000, 1]]')

    def test_view_no_activity_monitor(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        conn = DummyConnection(am=None)
        inst.get_connection = lambda *arg: conn
        result = inst.view()
        self.assertEqual(result['data_connections'], '[]')
        self.assertEqual(result['data_object_loads'], '[]')
        self.assertEqual(result['data_object_stores'], '[]')

    def test_pack(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        conn = DummyConnection(am=None)
        inst.get_connection = lambda *arg: conn
        request.POST['days'] = '5'
        request.sdiapi = DummySDIAPI()
        resp = inst.pack()
        self.assertEqual(conn._db.packed, 5)
        self.assertEqual(resp.location, '/mgmt_path')

    def test_pack_invalid_days(self):
        from pyramid.httpexceptions import HTTPFound
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        conn = DummyConnection(am=None)
        inst.get_connection = lambda *arg: conn
        request.POST['days'] = 'p'
        request.sdiapi = DummySDIAPI()
        self.assertRaises(HTTPFound, inst.pack)

    def test_pack_blobstorage_error(self):
        from ZODB.blob import BlobStorageError
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        conn = DummyConnection(am=None, packraises=BlobStorageError)
        inst.get_connection = lambda *arg: conn
        request.POST['days'] = '5'
        request.sdiapi = DummySDIAPI()
        resp = inst.pack()
        self.assertEqual(conn._db.packed, 5)
        self.assertEqual(resp.location, '/mgmt_path')
        self.assertEqual(request.sdiapi.flashed, 'Already packing')
        
    def test_flush_cache(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        conn = DummyConnection(am=None)
        inst.get_connection = lambda *arg: conn
        request.POST['days'] = '5'
        request.sdiapi = DummySDIAPI()
        resp = inst.flush_cache()
        self.assertTrue(conn._db.minimized)
        self.assertEqual(resp.location, '/mgmt_path')

    def test_show_evolve(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        inst.EvolutionManager = DummyEvolutionManager()

        resp = inst.show_evolve()
        self.assertEqual(
            resp['finished_steps'], ["1", "2", "3"])
        self.assertEqual(
            resp['unfinished_steps'], [('4', '4'), ('5', '5'), ('6', '6')])

    def test_evolve(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        inst.EvolutionManager = DummyEvolutionManager()

        resp = inst.evolve()
        self.assertEqual(resp.location, '/mgmt_path')
        self.assertEqual(request.sdiapi.flashed,
                         "3 evolution steps executed successfully")

    def test_evolve_empty(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        inst.EvolutionManager = DummyEvolutionManager([])

        resp = inst.evolve()
        self.assertEqual(resp.location, '/mgmt_path')
        self.assertEqual(request.sdiapi.flashed,
                         "No evolution steps to execute")

    def test_dryrun(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        inst.EvolutionManager = DummyEvolutionManager()

        resp = inst.dryrun()
        self.assertEqual(resp.location, '/mgmt_path')
        self.assertEqual(request.sdiapi.flashed,
                         "3 evolution steps dry-run successfully")

    def test_dryrun_empty(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        inst.EvolutionManager = DummyEvolutionManager([])

        resp = inst.dryrun()
        self.assertEqual(resp.location, '/mgmt_path')
        self.assertEqual(request.sdiapi.flashed,
                         "No evolution steps to dry-run")

    def test_evolve_finished(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST['step'] = '4'
        inst = self._makeOne(context, request)
        inst.EvolutionManager = DummyEvolutionManager()

        resp = inst.evolve_finished()
        self.assertEqual(resp.location, '/mgmt_path')
        self.assertEqual(request.sdiapi.flashed,
                         "Step 4 marked as finished")
        self.assertEqual(inst.EvolutionManager.finished_steps, ["4"])

    def test_evolve_finished_unknown(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST['step'] = '4'
        inst = self._makeOne(context, request)
        inst.EvolutionManager = DummyEvolutionManager([])

        resp = inst.evolve_finished()
        self.assertEqual(resp.location, '/mgmt_path')
        self.assertEqual(request.sdiapi.flashed,
                         "Unknown step 4, not marking as finished")

    def test_evolve_finished_already(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST['step'] = '1'
        inst = self._makeOne(context, request)
        inst.EvolutionManager = DummyEvolutionManager()

        resp = inst.evolve_finished()
        self.assertEqual(resp.location, '/mgmt_path')
        self.assertEqual(request.sdiapi.flashed,
                         "Step 1 already marked as finished")

    def test_evolve_unfinished(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST['step'] = '1'
        inst = self._makeOne(context, request)
        inst.EvolutionManager = DummyEvolutionManager()

        resp = inst.evolve_unfinished()
        self.assertEqual(resp.location, '/mgmt_path')
        self.assertEqual(request.sdiapi.flashed,
                         "Step 1 marked as unfinished")
        self.assertEqual(inst.EvolutionManager.removed_finished_steps, ["1"])

    def test_evolve_unfinished_unknown(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST['step'] = '9'
        inst = self._makeOne(context, request)
        inst.EvolutionManager = DummyEvolutionManager()

        resp = inst.evolve_unfinished()
        self.assertEqual(resp.location, '/mgmt_path')
        self.assertEqual(request.sdiapi.flashed,
                         "Unknown step 9, not marking as unfinished")

    def test_evolve_unfinished_already(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST['step'] = '4'
        inst = self._makeOne(context, request)
        inst.EvolutionManager = DummyEvolutionManager()

        resp = inst.evolve_unfinished()
        self.assertEqual(resp.location, '/mgmt_path')
        self.assertEqual(request.sdiapi.flashed,
                         "Step 4 already marked as unfinished")


    def test_format_timestamp(self):
        from ..views import _format_timestamp
        dt = _format_timestamp(1374121920.462345, 'UTC')
        self.assertEqual(dt, '2013-07-18 04:32:00 UTC')


class DummyDB(object):
    def __init__(self, am=None, packraises=None):
        self.am = am
        self.packraises = packraises

    def getActivityMonitor(self):
        return self.am

    def pack(self, days=None):
        self.packed = days
        if self.packraises:
            raise self.packraises

    def cacheMinimize(self):
        self.minimized = True

class DummyActivityMonitor(object):
    def getActivityAnalysis(self):
        return [{'end':1, 'connections':1, 'stores':1, 'loads':1}]*2

class DummyConnection(object):
    def __init__(self, am=None, packraises=None):
        self._db = DummyDB(am=am, packraises=packraises)

    def db(self):
        return self._db

class DummySDIAPI(object):
    def mgmt_path(self, *arg, **kw):
        return '/mgmt_path'
    def flash(self, msg, queue='info'):
        self.flashed = msg

class DummyEvolutionManager(object):

    def __init__(self, unfinished_steps=None):
        if unfinished_steps is None:
            self.unfinished_steps = ["4", "5", "6"]
        else:
            self.unfinished_steps = unfinished_steps
        self.finished_steps = []
        self.removed_finished_steps = []

    def __call__(self, root, registry):
        self.root = root
        self.registry = registry
        return self

    def get_unfinished_steps(self):
        return zip(self.unfinished_steps, self.unfinished_steps)

    def get_finished_steps_by_value(self):
        return ["1", "2", "3"]

    def get_finished_steps(self):
        return ["1", "2", "3"]

    def evolve(self, commit):
        return self.unfinished_steps

    def add_finished_step(self, step):
        self.finished_steps.append(step)

    def remove_finished_step(self, step):
        self.removed_finished_steps.append(step)


########NEW FILE########
__FILENAME__ = views
import json
import datetime
import transaction
import pytz

from ZODB.blob import BlobStorageError
from ZODB.FileStorage.FileStorage import FileStorageError

from pyramid_zodbconn import get_connection

from pyramid.httpexceptions import HTTPFound
from pyramid.view import view_defaults
from pyramid.traversal import find_root

from ..sdi import mgmt_view
from ..evolution import EvolutionManager
from ..util import _


@view_defaults(
    physical_path='/',
    name='database',
    renderer='templates/db.pt',
    permission='sdi.manage-database'
    )
class ManageDatabase(object):
    get_connection = staticmethod(get_connection)
    EvolutionManager = staticmethod(EvolutionManager)

    def __init__(self, context, request):
        self.context = context
        self.request = request

    @mgmt_view(request_method='GET', tab_title=_('Database'))
    def view(self):
        conn = self.get_connection(self.request)
        db = conn.db()
        am = db.getActivityMonitor()

        data_connections = []
        data_object_stores = []
        data_object_loads = []

        if am:
            # we multiply datetime by 1000 to get JavaScript representation of
            # unix timestamp
            # TODO: add timezone support
            for data in am.getActivityAnalysis():
                data_connections.append(
                    [int(data['end']*1000), data['connections']])
                data_object_stores.append(
                    [int(data['end']*1000), data['stores']])
                data_object_loads.append(
                    [int(data['end']*1000), data['loads']])
        return dict(
            am=am,
            db=db,
            conn=conn,
            data_connections=json.dumps(data_connections),
            data_object_stores=json.dumps(data_object_stores),
            data_object_loads=json.dumps(data_object_loads),
            )

    @mgmt_view(request_method='POST', request_param='pack', check_csrf=True)
    def pack(self):
        try:
            days = int(self.request.POST['days'])
        except:
            self.request.sdiapi.flash('Invalid number of days', 'danger')
            raise HTTPFound(location=self.request.sdiapi.mgmt_path(
                self.context, '@@database'))
        conn = self.get_connection(self.request)
        try:
            conn.db().pack(days=days)
        except (BlobStorageError, FileStorageError):
            self.request.sdiapi.flash('Already packing', 'danger')
        else:
            self.request.sdiapi.flash('Database packed to %s days' % days,
                                      'success')
        return HTTPFound(location=self.request.sdiapi.mgmt_path(
            self.context, '@@database'))

    @mgmt_view(request_method='POST', request_param='flush_cache',
               check_csrf=True)
    def flush_cache(self):
        conn = self.get_connection(self.request)
        conn.db().cacheMinimize()
        self.request.sdiapi.flash('Database flushed cache', 'success')
        return HTTPFound(location=self.request.sdiapi.mgmt_path(
            self.context, '@@database'))

    @mgmt_view(request_param='show_evolve',
               tab_title=_('Database'),
               renderer='templates/db_show_evolve.pt',
              )
    def show_evolve(self):
        root = find_root(self.request.context)
        manager = self.EvolutionManager(root, self.request.registry)

        return dict(
            unfinished_steps=list(manager.get_unfinished_steps()),
            finished_steps=list(manager.get_finished_steps_by_value()),
            format_timestamp=_format_timestamp,
            )

    @mgmt_view(request_method='POST',
               request_param='dryrun',
               check_csrf=True)
    def dryrun(self):
        root = find_root(self.request.context)
        manager = self.EvolutionManager(root, self.request.registry)
        complete = manager.evolve(commit=False)
        if complete:
            self.request.sdiapi.flash(
                '%d evolution steps dry-run successfully' % len(complete),
                'success')
        else:
            self.request.sdiapi.flash('No evolution steps to dry-run', 'info')
        return HTTPFound(location=self.request.sdiapi.mgmt_path(
            self.context, '@@database'))

    @mgmt_view(request_method='POST',
               request_param='evolve',
               check_csrf=True)
    def evolve(self):
        root = find_root(self.request.context)
        manager = self.EvolutionManager(root, self.request.registry)
        complete = manager.evolve(commit=True)
        if complete:
            self.request.sdiapi.flash(
                '%d evolution steps executed successfully' % len(complete),
                'success')
        else:
            self.request.sdiapi.flash('No evolution steps to execute', 'info')
        return HTTPFound(location=self.request.sdiapi.mgmt_path(
            self.context, '@@database'))

    @mgmt_view(request_method='POST',
               request_param='evolve_finished',
               check_csrf=True)
    def evolve_finished(self):
        root = find_root(self.request.context)
        manager = self.EvolutionManager(root, self.request.registry)
        step = self.request.POST['step']

        finished_steps = manager.get_finished_steps()
        unfinished_steps = dict(manager.get_unfinished_steps())

        if step in finished_steps:
            self.request.sdiapi.flash(
                'Step %s already marked as finished' % step, 'warning')
        else:
            if step in unfinished_steps:
                manager.add_finished_step(step)
                self.request.sdiapi.flash('Step %s marked as finished' % step,
                                          'success')
                t = transaction.get()
                t.note('Marked %s evolution step as finished' % step)
            else:
                self.request.sdiapi.flash(
                    'Unknown step %s, not marking as finished' % step, 'danger')
        return HTTPFound(location=self.request.sdiapi.mgmt_path(
            self.context, '@@database', query=dict(show_evolve=True)))

    @mgmt_view(request_method='POST',
               request_param='evolve_unfinished',
               check_csrf=True)
    def evolve_unfinished(self):
        root = find_root(self.request.context)
        manager = self.EvolutionManager(root, self.request.registry)
        step = self.request.POST['step']

        finished_steps = manager.get_finished_steps()
        unfinished_steps = dict(manager.get_unfinished_steps())

        if step in finished_steps:
            manager.remove_finished_step(step)
            self.request.sdiapi.flash(
                'Step %s marked as unfinished' % step, 'success')
            t = transaction.get()
            t.note('Marked %s evolution step as unfinished' % step)
        else:
            if step in unfinished_steps:
                self.request.sdiapi.flash(
                    'Step %s already marked as unfinished' % step, 'warning')
            else:
                self.request.sdiapi.flash(
                    'Unknown step %s, not marking as unfinished' % step,
                    'danger')
        return HTTPFound(location=self.request.sdiapi.mgmt_path(
            self.context, '@@database', query=dict(show_evolve=True)))


def _format_timestamp(t, tz):
    if hasattr(tz, 'upper'): # it's a timezone name, not a timezone object
        tz = pytz.timezone(tz)
    return datetime.datetime.fromtimestamp(t, tz).strftime(
        '%Y-%m-%d %H:%M:%S %Z')

########NEW FILE########
__FILENAME__ = tests
import unittest
from pyramid import testing

class Test_set_yaml(unittest.TestCase):
    def _callFUT(self, registry):
        from . import set_yaml
        return set_yaml(registry)

    def test_loader_and_dumper_set(self):
        registry = DummyRegistry(None)
        self._callFUT(registry)
        self.assertEqual(registry['yaml_loader'].__name__, 'SLoader')
        self.assertEqual(registry['yaml_dumper'].__name__, 'SDumper')

    def test_iface_representer(self):
        import io
        import yaml
        registry = DummyRegistry(None)
        self._callFUT(registry)
        stream = io.BytesIO()
        yaml.dump(DummyInterface, stream, Dumper=registry['yaml_dumper'],
                  encoding='utf-8')
        self.assertEqual(
            stream.getvalue(),
            b"!interface 'substanced.dump.tests.DummyInterface'\n"
            )

    def test_iface_constructor(self):
        import io
        import yaml
        registry = DummyRegistry(None)
        self._callFUT(registry)
        stream = io.BytesIO(
            b"!interface 'substanced.dump.tests.DummyInterface'\n"
            )
        result = yaml.load(stream, Loader=registry['yaml_loader'])
        self.assertEqual(result, DummyInterface)

    def test_blob_representer(self):
        import io
        import yaml
        from ZODB.blob import Blob
        registry = DummyRegistry(None)
        self._callFUT(registry)
        stream = io.BytesIO()
        blob = Blob(b'abc')
        yaml.dump(blob, stream, Dumper=registry['yaml_dumper'],
                  encoding='utf-8')
        self.assertEqual(
            stream.getvalue(),
            b"!blob 'YWJj\n\n  '\n"
            )

    def test_blob_constructor(self):
        import io
        import yaml
        registry = DummyRegistry(None)
        self._callFUT(registry)
        stream = io.BytesIO(
            b"!blob 'YWJj\n\n  '\n"
            )
        result = yaml.load(stream, Loader=registry['yaml_loader'])
        with result.open('r') as f:
            self.assertEqual(f.read(), b'abc')

class Test_get_dumpers(unittest.TestCase):
    def _callFUT(self, registry):
        from . import get_dumpers
        return get_dumpers(registry)

    def test_ordered_is_not_None(self):
        def f(n, reg):
            self.assertEqual(n, 1)
            self.assertEqual(reg, registry)
            return 'dumpers'
        registry = DummyRegistry([(1, f)])
        result = self._callFUT(registry)
        self.assertEqual(result, ['dumpers'])

    def test_ordered_is_None(self):
        def f(n, reg):
            self.assertEqual(n, 1)
            self.assertEqual(reg, registry)
            return 'dumpers'
        registry = DummyRegistry(None)
        registry['_sd_dumpers'] = [(1, f, None, None)]
        result = self._callFUT(registry)
        self.assertEqual(result, ['dumpers'])
        self.assertEqual(registry.ordered, [(1, f)])

class Test_DumpAndLoad(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self):
        from . import _DumpAndLoad
        return _DumpAndLoad()

    def test__make_dump_context(self):
        inst = self._makeOne()
        c = inst._make_dump_context('dir', 'reg', 'dumpers', True, False)
        self.assertEqual(c.__class__.__name__, '_ResourceDumpContext')

    def test__make_load_context(self):
        inst = self._makeOne()
        c = inst._make_load_context('dir', 'reg', 'dumpers', True, False)
        self.assertEqual(c.__class__.__name__, '_ResourceLoadContext')

    def test_dump_no_subresources(self):
        inst = self._makeOne()
        resource = testing.DummyResource()
        context = DummyResourceDumpContext()
        inst._make_dump_context = lambda *arg, **kw: context
        inst.dump(resource, 'directory', subresources=False)
        self.assertEqual(context.dumped, resource)

    def test_dump_with_subresources_resource_is_not_folder(self):
        inst = self._makeOne()
        resource = testing.DummyResource()
        resource['a'] = testing.DummyResource()
        context = DummyResourceDumpContext()
        inst._make_dump_context = lambda *arg, **kw: context
        inst.dump(resource, 'directory', subresources=True)
        self.assertEqual(context.dumped, resource)

    def test_dump_with_subresources_resource_is_folder(self):
        from zope.interface import directlyProvides
        from substanced.interfaces import IFolder
        inst = self._makeOne()
        resource = testing.DummyResource()
        directlyProvides(resource, IFolder)
        resource['a'] = testing.DummyResource()
        context = DummyResourceDumpContext()
        inst._make_dump_context = lambda *arg, **kw: context
        inst.dump(resource, 'directory', subresources=True)
        self.assertEqual(context.dumped, resource['a'])

    def test_dump_callbacks(self):
        from zope.interface import directlyProvides
        from substanced.interfaces import IFolder
        self.config.registry
        inst = self._makeOne()
        def callback(rsrc):
            self.assertEqual(rsrc, resource)
        self.config.registry['dumper_callbacks'] = [callback]
        resource = testing.DummyResource()
        directlyProvides(resource, IFolder)
        context = DummyResourceDumpContext()
        inst._make_dump_context = lambda *arg, **kw: context
        inst.dump(resource, 'directory', subresources=True)
        self.assertEqual(context.dumped, resource)

    def test_load_no_subresources(self):
        inst = self._makeOne()
        resource = testing.DummyResource()
        context = DummyResourceDumpContext(resource)
        inst._make_load_context = lambda *arg, **kw: context
        result = inst.load('directory', subresources=False)
        self.assertEqual(result, resource)

    def test_load_with_subresources(self):
        inst = self._makeOne()
        inst.ospath = DummyOSPath()
        inst.oslistdir = DummyOSListdir(['a'])
        resource = testing.DummyResource()
        context = DummyResourceDumpContext(resource)
        inst._make_load_context = lambda *arg, **kw: context
        result = inst.load('directory', subresources=True)
        self.assertEqual(result, resource)

    def test_load_loader_callbacks(self):
        inst = self._makeOne()
        resource = testing.DummyResource()
        def cb(rsrc):
            self.assertEqual(rsrc, resource)
        self.config.registry['loader_callbacks'] = [cb]
        context = DummyResourceDumpContext(resource)
        inst._make_load_context = lambda *arg, **kw: context
        result = inst.load('directory', subresources=False)
        self.assertEqual(result, resource)

class Test_FileOperations(unittest.TestCase):
    def _makeOne(self):
        from . import _FileOperations
        return _FileOperations()

    def test__makedirs(self):
        import os, tempfile, shutil
        inst = self._makeOne()
        try:
            td = tempfile.mkdtemp()
            dn = os.path.join(td, 'foo')
            inst._makedirs(dn)
            self.assertTrue(os.path.isdir(dn))
        finally:
            shutil.rmtree(td)

    def test__open(self):
        import os
        foo = os.path.join(
            os.path.dirname(os.path.abspath(__file__)),
            'fixture', 'foo.txt'
            )
        inst = self._makeOne()
        with inst._open(foo, 'rb') as fp:
            self.assertEqual(fp.read(), b'Foo.\n')

    def test__exists(self):
        import os
        foo = os.path.join(
            os.path.dirname(os.path.abspath(__file__)),
            'fixture', 'foo.txt'
            )
        inst = self._makeOne()
        self.assertTrue(inst._exists(foo))

    def test__get_fullpath_makedirs_true(self):
        import os
        inst = self._makeOne()
        prefix = os.path.dirname(os.path.abspath(__file__))
        def makedirs(dn):
            self.assertEqual(os.path.normpath(dn), os.path.normpath(prefix))
        inst._exists = lambda *arg: False
        inst._makedirs = makedirs
        inst.directory = os.path.join(prefix)
        result = inst._get_fullpath('bar', makedirs=True)
        self.assertEqual(result, os.path.join(prefix, 'bar'))

    def test__get_fullpath_makedirs_false(self):
        import os
        inst = self._makeOne()
        prefix = os.path.dirname(os.path.abspath(__file__))
        inst.directory = os.path.join(prefix)
        result = inst._get_fullpath('bar', makedirs=False)
        self.assertEqual(result, os.path.join(prefix, 'bar'))

    def test_openfile_w(self):
        inst = self._makeOne()
        def _get_fullpath(fn, makedirs):
            self.assertEqual(fn, 'a')
            self.assertEqual(makedirs, True)
            return fn
        inst._get_fullpath = _get_fullpath
        def _open(path, mode):
            self.assertEqual(path, 'a')
            self.assertEqual(mode, 'w')
            return 'fp'
        inst._open = _open
        self.assertEqual(inst.openfile_w('a'), 'fp')

    def test_openfile_r(self):
        inst = self._makeOne()
        def _get_fullpath(fn, makedirs=False):
            self.assertEqual(fn, 'a')
            self.assertEqual(makedirs, False)
            return fn
        inst._get_fullpath = _get_fullpath
        def _open(path, mode):
            self.assertEqual(path, 'a')
            self.assertEqual(mode, 'r')
            return 'fp'
        inst._open = _open
        self.assertEqual(inst.openfile_r('a'), 'fp')

    def test_exists(self):
        inst = self._makeOne()
        def _get_fullpath(fn, makedirs=False):
            self.assertEqual(fn, 'a')
            self.assertEqual(makedirs, False)
            return fn
        inst._get_fullpath = _get_fullpath
        def _exists(path):
            self.assertEqual(path, 'a')
            return True
        inst._exists = _exists
        self.assertEqual(inst.exists('a'), True)

class Test_YAMLOperations(unittest.TestCase):
    def _makeOne(self):
        from . import _YAMLOperations
        return _YAMLOperations()

    def test_load_yaml(self):
        import contextlib
        import io
        from yaml.loader import Loader
        inst = self._makeOne()
        stream = io.BytesIO(b'foo 1')
        @contextlib.contextmanager
        def openfile(fn, mode):
            self.assertEqual(fn, 'fn')
            self.assertEqual(mode, 'rb')
            yield stream
        inst.openfile_r = openfile
        inst.registry = {'yaml_loader':Loader}
        result = inst.load_yaml('fn')
        self.assertEqual(result, 'foo 1')

    def test_dump_yaml(self):
        import contextlib
        import io
        from yaml.dumper import Dumper
        inst = self._makeOne()
        stream = io.BytesIO()
        @contextlib.contextmanager
        def openfile(fn, mode):
            self.assertEqual(fn, 'fn')
            self.assertEqual(mode, 'wb')
            yield stream
        inst.openfile_w = openfile
        inst.registry = {'yaml_dumper':Dumper}
        result = inst.dump_yaml('abc', 'fn')
        self.assertEqual(result, None)
        self.assertEqual(stream.getvalue(), b'abc\n...\n')

class Test_ResourceContext(unittest.TestCase):
    def _makeOne(self):
        from . import _ResourceContext
        return _ResourceContext()

    def test_resolve_dotted_name(self):
        import substanced.dump.tests
        inst = self._makeOne()
        result = inst.resolve_dotted_name('substanced.dump.tests')
        self.assertEqual(result, substanced.dump.tests)

    def test_get_dotted_name(self):
        import substanced.dump.tests
        inst = self._makeOne()
        result = inst.get_dotted_name(substanced.dump.tests)
        self.assertEqual(result, 'substanced.dump.tests')

class Test_ResourceDumpContext(unittest.TestCase):
    def _makeOne(self, directory, registry, dumpers, verbose, dry_run):
        from . import _ResourceDumpContext
        return _ResourceDumpContext(
            directory, registry, dumpers, verbose, dry_run
            )

    def test_dump_resource(self):
        from zope.interface import directlyProvides
        from ..interfaces import IService
        registry = {}
        inst = self._makeOne(None, registry, None, None, None)
        resource = testing.DummyResource()
        resource.__name__ = 'foo'
        directlyProvides(resource, IService)
        def get_content_type(rsrc, reg):
            self.assertEqual(rsrc, resource)
            self.assertEqual(reg, registry)
            return 'ct'
        def get_oid(resource):
            return 'oid'
        def dump_yaml(data, filename):
            self.assertEqual(data['content_type'], 'ct')
            self.assertEqual(data['name'], resource.__name__)
            self.assertEqual(data['oid'], 'oid')
            return 'dumped'
        inst.get_content_type = get_content_type
        inst.get_oid = get_oid
        inst.dump_yaml = dump_yaml
        result = inst.dump_resource(resource)
        self.assertEqual(result, 'dumped')

    def test_dump(self):
        resource = testing.DummyResource()
        dumper = DummyDumperAndLoader()
        inst = self._makeOne(None, None, [dumper], None, None)
        def dump_resource(rsrc):
            self.assertEqual(rsrc, resource)
        inst.dump_resource = dump_resource
        inst.dump(resource)
        self.assertEqual(dumper.context, inst)

    def test_add_callback(self):
        registry = {}
        inst = self._makeOne(None, registry, None, None, None)
        inst.add_callback(True)
        self.assertEqual(registry['dumper_callbacks'], [True])

class Test_ResourceLoadContext(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, directory, registry, dumpers, verbose, dry_run):
        from . import _ResourceLoadContext
        return _ResourceLoadContext(
            directory, registry, dumpers, verbose, dry_run
            )

    def test_load_resource(self):
        import datetime
        from . import RESOURCE_FILENAME
        from ..interfaces import IService
        registry = self.config.registry
        resource = testing.DummyResource()
        content = DummyContentRegistry(resource)
        registry.content = content
        now = datetime.datetime.now()
        data = {
            'name':'name',
            'oid':1,
            'created':now,
            'content_type':'content_type',
            }
        def load_yaml(fn):
            self.assertEqual(fn, RESOURCE_FILENAME)
            return data
        inst = self._makeOne(None, registry, None, None, None)
        inst.load_yaml = load_yaml
        name, result = inst.load_resource()
        self.assertEqual(name, 'name')
        self.assertEqual(result, resource)
        self.assertEqual(resource.__name__, 'name')
        self.assertEqual(resource.__oid__, 1)
        self.assertEqual(content.content_type, 'content_type')
        self.assertEqual(content.oid, 1)

    def test_load_resource_create_exc(self):
        import datetime
        from . import RESOURCE_FILENAME
        registry = self.config.registry
        resource = testing.DummyResource()
        content = DummyContentRegistry(resource, raises=ValueError)
        registry.content = content
        now = datetime.datetime.now()
        data = {
            'name':'name',
            'oid':1,
            'created':now,
            'content_type':'content_type',
            }
        def load_yaml(fn):
            self.assertEqual(fn, RESOURCE_FILENAME)
            return data
        inst = self._makeOne(None, registry, None, None, None)
        inst.load_yaml = load_yaml
        class DummyLogger(object):
            def __init__(self):
                self._errors = []
            def error(self, *args, **kw):
                self._errors.append((args, kw))
        inst.logger = logger = DummyLogger()
        self.assertRaises(ValueError, inst.load_resource)

    def test_load(self):
        resource = testing.DummyResource()
        def load_resource():
            return 'name', resource
        loader = DummyDumperAndLoader()
        registry = self.config.registry
        inst = self._makeOne(None, registry, [loader], None, None)
        inst.load_resource = load_resource
        parent = DummyParent()
        result = inst.load(parent)
        self.assertEqual(result, resource)
        self.assertEqual(parent.name, 'name')
        self.assertEqual(parent.resource, resource)
        self.assertEqual(loader.context, inst)

    def test_add_callback(self):
        registry = {}
        inst = self._makeOne(None, registry, None, None, None)
        inst.add_callback(True)
        self.assertEqual(registry['loader_callbacks'], [True])

class TestACLDumper(unittest.TestCase):
    def _makeOne(self, name, registry):
        from . import ACLDumper
        return ACLDumper(name, registry)

    def test_init_adds_yaml_stuff(self):
        from pyramid.security import ALL_PERMISSIONS
        from .._compat import u
        yamlthing = DummyYAMLDumperLoader()
        registry = {'yaml_loader':yamlthing, 'yaml_dumper':yamlthing}
        self._makeOne('name', registry)
        self.assertEqual(len(yamlthing.constructors), 1)
        self.assertEqual(len(yamlthing.representers), 1)
        self.assertEqual(
            yamlthing.constructors[0][1](None, None), ALL_PERMISSIONS
            )
        dumper = testing.DummyResource()
        def represent_scalar(one, two):
            self.assertEqual(one, u('!all_permissions'))
        dumper.represent_scalar = represent_scalar
        yamlthing.representers[0][1](dumper, None)

    def test_dump_no_acl(self):
        yamlthing = DummyYAMLDumperLoader()
        registry = {'yaml_loader':yamlthing, 'yaml_dumper':yamlthing}
        inst = self._makeOne('name', registry)
        context = testing.DummyResource()
        resource = testing.DummyResource()
        context.resource = resource
        result = inst.dump(context)
        self.assertEqual(result, None)

    def test_dump_with_acl(self):
        yamlthing = DummyYAMLDumperLoader()
        registry = {'yaml_loader':yamlthing, 'yaml_dumper':yamlthing}
        inst = self._makeOne('name', registry)
        resource = testing.DummyResource()
        resource.__acl__ = []
        context = DummyResourceDumpContext(resource)
        context.resource = resource
        result = inst.dump(context)
        self.assertEqual(result, None)
        self.assertEqual(context.dumped, [])

    def test_load(self):
        yamlthing = DummyYAMLDumperLoader()
        registry = {'yaml_loader':yamlthing, 'yaml_dumper':yamlthing}
        inst = self._makeOne('name', registry)
        resource = testing.DummyResource()
        context = DummyResourceDumpContext([])
        context.resource = resource
        inst.load(context)
        self.assertEqual(resource.__acl__, [])

class TestWorkflowDumper(unittest.TestCase):
    def _makeOne(self, name, registry):
        from . import WorkflowDumper
        return WorkflowDumper(name, registry)

    def test_dump(self):
        from . import STATE_ATTR
        def dump_yaml(v, fn):
            self.assertEqual(v, True)
            self.assertEqual(fn, 'name.yaml')
        context = testing.DummyResource()
        context.dump_yaml = dump_yaml
        resource = testing.DummyResource()
        context.resource = resource
        setattr(resource, STATE_ATTR, True)
        inst = self._makeOne('name', None)
        inst.dump(context)

    def test_load(self):
        from . import STATE_ATTR
        def load_yaml(fn):
            self.assertEqual(fn, 'name.yaml')
            return True
        context = testing.DummyResource()
        context.exists = lambda *arg: True
        context.load_yaml = load_yaml
        resource = testing.DummyResource()
        context.resource = resource
        inst = self._makeOne('name', None)
        inst.load(context)
        self.assertEqual(getattr(resource, STATE_ATTR), True)

class TestReferencesDumper(unittest.TestCase):
    def _makeOne(self, name, registry):
        from . import ReferencesDumper
        return ReferencesDumper(name, registry)

    def test_dump(self):
        context = testing.DummyResource()
        resource = testing.DummyResource()
        context.resource = resource
        inst = self._makeOne('name', None)
        objectmap = DummyObjectmap([1], [2])
        inst.find_objectmap = lambda *arg: objectmap
        def dump_yaml(references, fn):
            self.assertEqual(
                references,
                {'reftype': {'sources': [1], 'targets': [2]}}
                )
            self.assertEqual(fn, 'name.yaml')
        context.dump_yaml = dump_yaml
        inst.dump(context)

    def test_load(self):
        context = testing.DummyResource()
        context.exists = lambda *arg: True
        resource = testing.DummyResource()
        context.resource = resource
        inst = self._makeOne('name', None)
        inst.get_oid = lambda *arg: 0
        objectmap = DummyObjectmap([1], [2])
        inst.find_objectmap = lambda *arg: objectmap
        def load_yaml(fn):
            self.assertEqual(fn, 'name.yaml')
            return {'reftype': {'sources': [1], 'targets': [2]}}
        callbacks = []
        def add_callback(f):
            callbacks.append(f)
        context.load_yaml = load_yaml
        context.add_callback = add_callback
        inst.load(context)
        self.assertEqual(len(callbacks), 1)
        callbacks[0](inst)
        self.assertEqual(
            objectmap.connected,
            [(0, 2, 'reftype'), (1, 0, 'reftype')]
            )

class TestSDIPropertiesDumper(unittest.TestCase):
    def _makeOne(self, name, registry):
        from . import SDIPropertiesDumper
        return SDIPropertiesDumper(name, registry)

    def test_dump(self):
        context = testing.DummyResource()
        resource = testing.DummyResource()
        def _p_activate():
            pass # this will not be covered if not run
        context.resource = resource
        resource._p_activate = _p_activate
        resource.__sdi_hidden__ = True
        def dump_yaml(v, fn):
            self.assertEqual(v, {'__sdi_hidden__':True})
            self.assertEqual(fn, 'name.yaml')
        context.dump_yaml = dump_yaml
        inst = self._makeOne('name', None)
        inst.dump(context)

    def test_load(self):
        context = testing.DummyResource()
        resource = testing.DummyResource()
        context.exists = lambda *arg: True
        def _p_activate():
            pass # this will not be covered if not run
        context.resource = resource
        resource._p_activate = _p_activate
        def load_yaml(fn):
            self.assertEqual(fn, 'name.yaml')
            return {'a':1}
        context.load_yaml = load_yaml
        inst = self._makeOne('name', None)
        inst.load(context)
        self.assertTrue(resource._p_changed)
        self.assertEqual(resource.a, 1)

class TestDirectlyProvidedInterfacesDumper(unittest.TestCase):
    def _makeOne(self, name, registry):
        from . import DirectlyProvidedInterfacesDumper
        return DirectlyProvidedInterfacesDumper(name, registry)

    def test_dump(self):
        from zope.interface import directlyProvides
        context = testing.DummyResource()
        resource = testing.DummyResource()
        context.resource = resource
        def get_dotted_name(i):
            return 'substanced.dump.IDummy'
        context.get_dotted_name = get_dotted_name
        directlyProvides(resource, IDummy)
        def dump_yaml(v, fn):
            self.assertEqual(v, ['substanced.dump.IDummy'])
            self.assertEqual(fn, 'name.yaml')
        context.dump_yaml = dump_yaml
        inst = self._makeOne('name', None)
        inst.dump(context)

    def test_load(self):
        from zope.interface import directlyProvidedBy
        context = testing.DummyResource()
        resource = testing.DummyResource()
        context.exists = lambda *arg: True
        context.resource = resource
        def resolve_dotted_name(n):
            return IDummy
        context.resolve_dotted_name = resolve_dotted_name
        def load_yaml(fn):
            self.assertEqual(fn, 'name.yaml')
            return ['substanced.dump.IDummy']
        context.load_yaml = load_yaml
        inst = self._makeOne('name', None)
        inst.load(context)
        self.assertEqual(list(directlyProvidedBy(resource).interfaces()),
                         [IDummy])

class TestFolderOrderDumper(unittest.TestCase):
    def _makeOne(self, name, registry):
        from . import FolderOrderDumper
        return FolderOrderDumper(name, registry)

    def test_dump(self):
        from zope.interface import directlyProvides
        from substanced.interfaces import IFolder
        context = testing.DummyResource()
        resource = testing.DummyResource()
        resource.order = ['a']
        context.resource = resource
        def is_ordered():
            return True
        resource.is_ordered = is_ordered
        directlyProvides(resource, IFolder)
        def dump_yaml(v, fn):
            self.assertEqual(v, ['a'])
            self.assertEqual(fn, 'name.yaml')
        context.dump_yaml = dump_yaml
        inst = self._makeOne('name', None)
        inst.dump(context)

    def test_load(self):
        context = testing.DummyResource()
        resource = testing.DummyResource()
        context.exists = lambda *arg: True
        context.resource = resource
        def load_yaml(fn):
            self.assertEqual(fn, 'name.yaml')
            return ['a']
        context.load_yaml = load_yaml
        callbacks = []
        def add_callback(f):
            callbacks.append(f)
        context.add_callback = add_callback
        registry = {}
        inst = self._makeOne('name', registry)
        inst.load(context)
        callbacks[0](inst)
        self.assertEqual(resource.order, ['a'])

class TestPropertySheetDumper(unittest.TestCase):
    def _makeOne(self, name, registry):
        from . import PropertySheetDumper
        return PropertySheetDumper(name, registry)

    def test_init_adds_yaml_stuff(self):
        import colander
        from .._compat import u
        yamlthing = DummyYAMLDumperLoader()
        registry = {'yaml_loader':yamlthing, 'yaml_dumper':yamlthing}
        self._makeOne('name', registry)
        self.assertEqual(len(yamlthing.constructors), 1)
        self.assertEqual(len(yamlthing.representers), 2)
        self.assertEqual(
            yamlthing.constructors[0][1](None, None), colander.null
            )
        dumper = testing.DummyResource()
        def represent_scalar(one, two):
            self.assertEqual(one, u('!colander_null'))
        dumper.represent_scalar = represent_scalar
        yamlthing.representers[0][1](dumper, None)

    def test__get_sheets(self):
        yamlthing = DummyYAMLDumperLoader()
        registry = DummyRegistry(None)
        registry.update({'yaml_loader':yamlthing, 'yaml_dumper':yamlthing})
        inst = self._makeOne('name', registry)
        context = testing.DummyResource()
        resource = testing.DummyResource()
        context.exists = lambda *arg: True
        context.resource = resource
        sheet = DummySheet(None)
        def sheetfactory(rsrc, req):
            self.assertEqual(rsrc, resource)
            self.assertEqual(req.__class__.__name__, 'Request')
            return sheet
        content = DummyContentRegistry([('', sheetfactory)])
        registry.content = content
        val = inst._get_sheets(context)
        result = list(val)
        self.assertEqual(
            result,
            [('__unnamed__', sheet)]
            )
        self.assertEqual(sheet.deleted, '_csrf_token_')

    def test_dump(self):
        yamlthing = DummyYAMLDumperLoader()
        registry = DummyRegistry(None)
        registry.update({'yaml_loader':yamlthing, 'yaml_dumper':yamlthing})
        inst = self._makeOne('name', registry)
        context = testing.DummyResource()
        sheet = DummySheet({'a':1})
        def _get_sheets(ctx):
            self.assertEqual(ctx, context)
            return [('sheet', sheet)]
        inst._get_sheets = _get_sheets
        def dump_yaml(cstruct, fn):
            self.assertEqual(cstruct, {'a':1})
            self.assertEqual(fn, 'propsheets/sheet/properties.yaml')
        context.dump_yaml = dump_yaml
        inst.dump(context)

    def test_load(self):
        yamlthing = DummyYAMLDumperLoader()
        registry = DummyRegistry(None)
        registry.update({'yaml_loader':yamlthing, 'yaml_dumper':yamlthing})
        inst = self._makeOne('name', registry)
        context = testing.DummyResource()
        def add_callback(cb):
            context.cb = cb
        context.exists = lambda *arg: True
        context.add_callback = add_callback
        sheet = DummySheet(None)
        def _get_sheets(ctx):
            self.assertEqual(ctx, context)
            return [('', sheet)]
        inst._get_sheets = _get_sheets
        def load_yaml(fn):
            self.assertEqual(fn, 'propsheets/__unnamed__/properties.yaml')
            return {'a':1}
        context.load_yaml = load_yaml
        inst.load(context)
        context.cb(None)
        self.assertEqual(sheet.appstruct, {'a':1})

class TestAdhocAttrDumper(unittest.TestCase):
    def _makeOne(self, name, registry):
        from . import AdhocAttrDumper
        return AdhocAttrDumper(name, registry)

    def test_dump(self):
        def dump_yaml(v, fn):
            self.assertEqual(v, {'a':1})
            self.assertEqual(fn, 'name.yaml')
        context = testing.DummyResource()
        context.dump_yaml = dump_yaml
        resource = testing.DummyResource()
        context.resource = resource
        def dump():
            return {'a':1}
        resource.__dump__ = dump
        inst = self._makeOne('name', None)
        inst.dump(context)

    def test_load(self):
        def load_yaml(fn):
            self.assertEqual(fn, 'name.yaml')
            return {'a':1}
        context = testing.DummyResource()
        context.exists = lambda *arg: True
        context.load_yaml = load_yaml
        resource = testing.DummyResource()
        context.resource = resource
        def load(values):
            self.assertEqual(values, {'a':1})
        resource.__load__ = load
        inst = self._makeOne('name', None)
        inst.load(context)

    def test_load_without_underunder_load(self):
        def load_yaml(fn):
            self.assertEqual(fn, 'name.yaml')
            return {'a':1}
        context = testing.DummyResource()
        context.exists = lambda *arg: True
        context.load_yaml = load_yaml
        resource = testing.DummyResource()
        context.resource = resource
        inst = self._makeOne('name', None)
        inst.load(context)
        self.assertEqual(resource.a, 1)

class Test_add_dumper(unittest.TestCase):
    def _callFUT(
        self, config, dumper_name, dumper_factory, before=None, after=None
        ):
        from . import add_dumper
        return add_dumper(
            config, dumper_name, dumper_factory, before=before, after=after
            )

    def test_it(self):
        config = DummyConfigurator()
        registry = {}
        config.registry = registry
        self._callFUT(config, 'dumper', 'factory', 'before', 'after')
        self.assertEqual(config.discriminator, ('sd_dumper', 'dumper'))
        config.callable()
        self.assertEqual(
            registry['_sd_dumpers'],
            [['dumper', 'factory', 'before', 'after']]
            )

from zope.interface import Interface

class IDummy(Interface):
    pass

class DummyConfigurator(object):
    def action(self, discriminator, callable=None):
        self.discriminator = discriminator
        self.callable = callable

class DummySheet(object):
    def __init__(self, result):
        self.result = result

    def get_schema(self):
        return self

    def set_schema(self, schema):
        self._schema = schema

    schema = property(get_schema, set_schema)

    def __contains__(self, val):
        return True

    def __delitem__(self, val):
        self.deleted = val

    def bind(self, request=None, context=None, loading=None):
        self.request = request
        self.context = context
        self.loading = loading

    def get(self):
        return self.result

    def set(self, appstruct):
        self.appstruct = appstruct

    def serialize(self, appstruct):
        return appstruct

    def deserialize(self, cstruct):
        return cstruct


class DummyObjectmap(object):
    def __init__(self, sourceids, targetids):
        self._sourceids = sourceids
        self._targetids = targetids
        self.connected = []

    def has_references(self, resource):
        return True

    def get_reftypes(self):
        return ['reftype']

    def sourceids(self, resource, reftype):
        return self._sourceids

    def targetids(self, resource, reftype):
        return self._targetids

    def connect(self, oid, target, reftype):
        self.connected.append((oid, target, reftype))

class DummyYAMLDumperLoader(object):
    def __init__(self):
        self.constructors = []
        self.representers = []
    def add_constructor(self, spec, ctor):
        self.constructors.append((spec, ctor))
    def add_representer(self, thing, repr):
        self.representers.append((thing, repr))

class DummyContentRegistry(object):
    def __init__(self, result, raises=None):
        self.result = result
        self.raises = raises

    def create(self, content_type, **kw):
        self.content_type = content_type
        self.oid = kw['__oid']
        if self.raises:
            raise self.raises
        return self.result

    def metadata(self, resource, what, default=None):
        return self.result

class DummyParent(object):
    def load(self, name, resource, registry=None):
        self.name = name
        self.resource = resource
        self.registry = registry

class DummyDumperAndLoader(object):
    def dump(self, context):
        self.context = context

    load = dump

class DummyResourceDumpContext(object):
    def __init__(self, result=None):
        self.result = result

    def dump(self, resource):
        self.dumped = resource

    def load(self, parent):
        return self.result

    def dump_yaml(self, obj, fn):
        self.dumped = obj

    def load_yaml(self, fn):
        return self.result

    def exists(self, fn):
        return True

class DummyInterface(Interface):
    pass

class DummyRegistry(dict):
    def __init__(self, result):
        self.result = result
        dict.__init__(self)

    def queryUtility(self, iface, default=None):
        return self.result

    def registerUtility(self, ordered, iface):
        self.ordered = ordered

class DummyOSPath(object):
    def join(self, directory, other):
        return other

    def exists(self, dir):
        return True

    def abspath(self, path):
        return path

    def normpath(self, path):
        return path

    def isdir(self, dir):
        return True

class DummyOSListdir(object):
    def __init__(self, results):
        self.results = results

    def __call__(self, dir):
        if self.results:
            return self.results.pop(0)
        return []

########NEW FILE########
__FILENAME__ = tests
import unittest
from pyramid import testing

class TestFileEditable(unittest.TestCase):

    def _getTargetClass(self):
        from . import FileEditable
        return FileEditable

    def _makeOne(self, context=None, request=None):
        if context is None:
            context = object()
        if request is None:
            request = object()
        return self._getTargetClass()(context, request)

    def test_class_conforms_to_IEditable(self):
        from zope.interface.verify import verifyClass
        from . import IEditable
        verifyClass(IEditable, self._getTargetClass())

    def test_instance_conforms_to_IEditable(self):
        from zope.interface.verify import verifyObject
        from . import IEditable
        verifyObject(IEditable, self._makeOne())

    def test_get_context_has_mimetype(self):
        from pyramid.testing import DummyRequest
        from pyramid.testing import DummyResource
        context = DummyResource()
        context.mimetype = 'application/foo'
        blob = DummyResource()
        here = __file__
        def committed():
            return here
        blob.committed = committed
        context.blob = blob
        request = DummyRequest()
        inst = self._makeOne(context, request)
        iterable, mimetype = inst.get()
        self.assertEqual(mimetype, 'application/foo')
        self.assertEqual(type(next(iterable)), bytes)

    def test_get_context_has_no_mimetype(self):
        from pyramid.testing import DummyRequest
        from pyramid.testing import DummyResource
        context = DummyResource()
        context.mimetype = None
        blob = DummyResource()
        here = __file__
        def committed():
            return here
        blob.committed = committed
        context.blob = blob
        request = DummyRequest()
        inst = self._makeOne(context, request)
        iterable, mimetype = inst.get()
        self.assertEqual(mimetype, 'application/octet-stream')
        self.assertEqual(type(next(iterable)), bytes)

    def test_put(self):
        from pyramid.testing import DummyRequest
        from pyramid.testing import DummyResource
        context = DummyResource()
        fp = 'fp'
        def upload(_fp):
            self.assertEqual(_fp, fp)
        context.upload = upload
        request = DummyRequest()
        inst = self._makeOne(context, request)
        inst.put(fp)

class Test_register_editable_adapter(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, config, adapter, iface):
        from . import register_editable_adapter
        return register_editable_adapter(config, adapter, iface)

    def test_it(self):
        from zope.interface import Interface
        from . import IEditable
        class ITesting(Interface):
            pass
        config = DummyConfigurator(self.config.registry)
        def _editable_factory(context, reqeust): #pragma NO COVER
            pass
        self._callFUT(config, _editable_factory, ITesting)
        self.assertEqual(len(config.actions), 1)
        action = config.actions[0]
        self.assertEqual(action['discriminator'],
                         ('sd-editable-adapter', ITesting))
        self.assertEqual(
            action['introspectables'], (config.intr,)
            )
        callable = action['callable']
        callable()
        wrapper = self.config.registry.adapters.lookup(
            (ITesting, Interface), IEditable)
        self.assertEqual(config.intr['registered'], wrapper)

class Test_get_editable_adapter(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, context, request):
        from . import get_editable_adapter
        return get_editable_adapter(context, request)

    def test_it_with_registration(self):
        from zope.interface import Interface
        from . import IEditable
        request = testing.DummyRequest()
        context = testing.DummyResource()
        class adapter(object):
            def __init__(self, context, request):
                pass
        request.registry.registerAdapter(adapter, (Interface, Interface),
                                         IEditable)
        result = self._callFUT(context, request)
        self.assertEqual(result.__class__, adapter)

    def test_it_without_registration(self):
        request = testing.DummyRequest()
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(result, None)

    
class DummyIntrospectable(dict):
    pass

class DummyConfigurator(object):
    _ainfo = None
    def __init__(self, registry):
        self.actions = []
        self.intr = DummyIntrospectable()
        self.registry = registry
        self.indexes = []

    def action(self, discriminator, callable, order=None, introspectables=()):
        self.actions.append(
            {
            'discriminator':discriminator,
            'callable':callable,
            'order':order,
            'introspectables':introspectables,
            })

    def introspectable(self, category, discriminator, name, single):
        return self.intr


########NEW FILE########
__FILENAME__ = tests
import unittest

from pyramid import testing

from zope.interface import Interface

class IDummy(Interface):
    pass

class Test_ContentEventSubscriber(unittest.TestCase):
    
    event = IDummy

    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, obj=None, **predicates):
        from . import _ContentEventSubscriber
        class Subscriber(_ContentEventSubscriber):
            event = self.event
        return Subscriber(obj=obj, **predicates)

    def test_register_defaults(self):
        dec = self._makeOne()
        def foo(event): pass
        config = DummyConfigurator()
        scanner = Dummy()
        scanner.config = config
        dec.register(scanner, None, foo)
        self.assertEqual(len(config.subscribed), 1)
        subscriber = config.subscribed[0]
        self.assertEqual(subscriber['wrapped'], foo)
        self.assertEqual(subscriber['ifaces'],
                         [self.event, Interface])
        
    def test_register_object_only(self):
        class IFoo(Interface): pass
        dec = self._makeOne(IFoo)
        def foo(event): pass
        config = DummyConfigurator()
        scanner = Dummy()
        scanner.config = config
        dec.register(scanner, None, foo)
        self.assertEqual(len(config.subscribed), 1)
        subscriber = config.subscribed[0]
        self.assertEqual(subscriber['wrapped'], foo)
        self.assertEqual(subscriber['ifaces'],
                         [self.event, IFoo])

    def test_with_predicates(self):
        class IFoo(Interface): pass
        dec = self._makeOne(IFoo, a=1)
        def foo(event): pass
        config = DummyConfigurator()
        scanner = Dummy()
        scanner.config = config
        dec.register(scanner, None, foo)
        self.assertEqual(len(config.subscribed), 1)
        subscriber = config.subscribed[0]
        self.assertEqual(subscriber['wrapped'], foo)
        self.assertEqual(subscriber['ifaces'],
                         [self.event, IFoo])
        self.assertEqual(subscriber['predicates'], {'a':1})

    def test___call__(self):
        dec = self._makeOne()
        dummy_venusian = DummyVenusian()
        dec.venusian = dummy_venusian
        def foo(): pass
        dec(foo)
        self.assertEqual(dummy_venusian.attached,
                         [(foo, dec.register, 'substanced')])

class Test_FolderEventSubscriber(unittest.TestCase):
    event = IDummy

    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, obj=None, container=None, **predicates):
        from . import _FolderEventSubscriber
        class Subscriber(_FolderEventSubscriber):
            event = self.event
        return Subscriber(obj=obj, container=container, **predicates)

    def test_register_object_only(self):
        class IFoo(Interface): pass
        dec = self._makeOne(IFoo)
        def foo(event): pass
        config = DummyConfigurator()
        scanner = Dummy()
        scanner.config = config
        dec.register(scanner, None, foo)
        self.assertEqual(len(config.subscribed), 1)
        subscriber = config.subscribed[0]
        self.assertEqual(subscriber['wrapped'], foo)
        self.assertEqual(subscriber['ifaces'],
                         [self.event, IFoo, Interface])

    def test_register_neither_object_nor_container(self):
        class IFoo(Interface): pass
        class IBar(Interface): pass
        dec = self._makeOne()
        def foo(event): pass
        config = DummyConfigurator()
        scanner = Dummy()
        scanner.config = config
        dec.register(scanner, None, foo)
        self.assertEqual(len(config.subscribed), 1)
        subscriber = config.subscribed[0]
        self.assertEqual(subscriber['wrapped'], foo)
        self.assertEqual(subscriber['ifaces'],
                         [self.event, Interface, Interface])

    def test_register_container_only(self):
        class IFoo(Interface): pass
        dec = self._makeOne(container=IFoo)
        def foo(event): pass
        config = DummyConfigurator()
        scanner = Dummy()
        scanner.config = config
        dec.register(scanner, None, foo)
        self.assertEqual(len(config.subscribed), 1)
        subscriber = config.subscribed[0]
        self.assertEqual(subscriber['wrapped'], foo)
        self.assertEqual(subscriber['ifaces'],
                         [self.event, Interface, IFoo])

    def test_register_object_and_container(self):
        class IFoo(Interface): pass
        class IBar(Interface): pass
        dec = self._makeOne(obj=IFoo, container=IBar)
        def foo(event): pass
        config = DummyConfigurator()
        scanner = Dummy()
        scanner.config = config
        dec.register(scanner, None, foo)
        self.assertEqual(len(config.subscribed), 1)
        subscriber = config.subscribed[0]
        self.assertEqual(subscriber['wrapped'], foo)
        self.assertEqual(subscriber['ifaces'],
                         [self.event, IFoo, IBar])

    
class Test_SimpleSubscriber(unittest.TestCase):
    
    event = IDummy

    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, **predicates):
        from . import _SimpleSubscriber
        class Subscriber(_SimpleSubscriber):
            event = self.event
        return Subscriber(**predicates)

    def test_register_defaults(self):
        dec = self._makeOne()
        def foo(event): pass
        config = DummyConfigurator()
        scanner = Dummy()
        scanner.config = config
        dec.register(scanner, None, foo)
        self.assertEqual(len(config.subscribed), 1)
        subscriber = config.subscribed[0]
        wrapper = subscriber['wrapped']
        event = Dummy()
        self.assertEqual(wrapper(event), None)
        self.assertEqual(event.registry, scanner.config.registry)
        self.assertEqual(wrapper.wrapped, foo)
        self.assertEqual(subscriber['ifaces'], self.event)
        
    def test_with_predicates(self):
        class IFoo(Interface): pass
        dec = self._makeOne(a=1)
        def foo(event): pass
        config = DummyConfigurator()
        scanner = Dummy()
        scanner.config = config
        dec.register(scanner, None, foo)
        self.assertEqual(len(config.subscribed), 1)
        subscriber = config.subscribed[0]
        self.assertEqual(subscriber['wrapped'].wrapped, foo)
        self.assertEqual(subscriber['ifaces'], self.event)
        self.assertEqual(subscriber['predicates'], {'a':1})

    def test___call__(self):
        dec = self._makeOne()
        dummy_venusian = DummyVenusian()
        dec.venusian = dummy_venusian
        def foo(): pass
        dec(foo)
        self.assertEqual(dummy_venusian.attached,
                         [(foo, dec.register, 'substanced')])

class TestObjectWillBeRemoved(unittest.TestCase):
    def _makeOne(self, *arg, **kw):
        from . import ObjectWillBeRemoved
        return ObjectWillBeRemoved(*arg, **kw)

    def test_removed_oids_objectmap_is_None(self):
        obj = testing.DummyResource()
        parent = testing.DummyResource()
        name = 'name'
        inst = self._makeOne(obj, parent, name)
        self.assertEqual(inst.removed_oids, [])
        
    def test_removed_oids_objectmap_is_not_None(self):
        obj = testing.DummyResource()
        parent = testing.DummyResource()
        objectmap = testing.DummyResource()
        objectmap.pathlookup = lambda *arg: [1]
        parent.__objectmap__ = objectmap
        name = 'name'
        inst = self._makeOne(obj, parent, name)
        self.assertEqual(inst.removed_oids, [1])

class Test_add_content_subscriber(unittest.TestCase):
    def _callFUT(self, config, subscriber, iface=None, **predicates):
        from . import add_content_subscriber
        return add_content_subscriber(config, subscriber, iface=iface,
                                      **predicates)

    def test_register_wrapper(self):
        class IFoo(Interface): pass
        class IBar(Interface): pass
        def foo(event):
            return 'abc'
        config = DummyConfigurator()
        self._callFUT(config, foo, [IFoo, IBar])
        subscriber = config.subscribed[0]
        wrapper = subscriber['wrapped']
        self.assertEqual(wrapper.wrapped, foo)
        event = Dummy()
        self.assertEqual(wrapper(event, None, None), 'abc')
        self.assertEqual(event.registry, config.registry)

class Test_ContentTypePredicate(unittest.TestCase):
    def _makeOne(self, val, config):
        from . import _ContentTypePredicate
        return _ContentTypePredicate(val, config)

    def _makeConfig(self, result):
        config = Dummy()
        config.registry = Dummy()
        config.registry.content = Dummy()
        config.registry.content.istype = lambda *x: result
        return config
    
    def test___call___true(self):
        config = self._makeConfig(True)
        inst = self._makeOne('abc', config)
        event = Dummy()
        event.object = Dummy()
        result = inst(event)
        self.assertTrue(result)

    def test___call___false(self):
        config = self._makeConfig(False)
        inst = self._makeOne('abc', config)
        event = Dummy()
        event.object = Dummy()
        result = inst(event)
        self.assertFalse(result)
        
    def test_text(self):
        config = self._makeConfig(True)
        inst = self._makeOne('abc', config)
        self.assertEqual(inst.text(), 'content_type = abc')

    def test_phash(self):
        config = self._makeConfig(True)
        inst = self._makeOne('abc', config)
        self.assertEqual(inst.phash(), 'content_type = abc')

class Dummy:
    pass
        
registry = Dummy()
class DummyConfigurator(object):
    def __init__(self):
        self.subscribed = []
        self.registry = registry

    def add_content_subscriber(self, wrapped, ifaces, **predicates):
        self.subscribed.append(
            {'wrapped':wrapped, 'ifaces':ifaces, 'predicates':predicates}
            )

    add_subscriber = add_content_subscriber

class DummyRegistry(object):
    pass
        
class DummyVenusian(object):
    def __init__(self):
        self.attached = []

    def attach(self, wrapped, fn, category=None):
        self.attached.append((wrapped, fn, category))


########NEW FILE########
__FILENAME__ = evolve1
from substanced.util import postorder
import logging

_marker = object()

logger = logging.getLogger('evolution')

def evolve(root):
    logger.info(
        'Running substanced evolve step 1: convert __objectid__ to __oid__'
        )
    for obj in postorder(root):
        logger.info(
            'Substanced evolve step 1: trying %s' % (obj,)
            )
        objectid = getattr(obj, '__objectid__', _marker)
        if objectid is _marker:
            continue
        if hasattr(obj, '__oid__'):
            continue
        obj.__oid__ = objectid
        del obj.__objectid__

########NEW FILE########
__FILENAME__ = evolve10
import logging

logger = logging.getLogger('evolution')

def evolve(root):
    logger.info(
        'substanced evolve step 10: add created index'
    )
    catalog = root['catalogs']['system']
    catalog.update_indexes()
    if catalog.get('created'):
        catalog.reindex(indexes=('created',))

########NEW FILE########
__FILENAME__ = evolve2
import logging

from substanced.util import postorder
from substanced.interfaces import PrincipalToACLBearing
from substanced.objectmap import find_objectmap
from substanced._compat import INT_TYPES

_marker = object()

logger = logging.getLogger('evolution')

_TO_APPEND = INT_TYPES + (tuple,)

def _referenceable_principals(acl):
    result = set()
    for ace in (acl or ()):
        principal_id = ace[1]
        if isinstance(principal_id, _TO_APPEND):
            result.add(principal_id)
    return result

def evolve(root):
    logger.info(
        'Running substanced evolve step 2: add PRINCIPAL_TO_ACL_BEARING '
        'relationships'
        )
    objectmap = find_objectmap(root)
    if objectmap is None:
        return
    for obj in postorder(root):
        logger.info(
            'Substanced evolve step 2: trying %s' % (obj,)
            )
        acl = getattr(obj, '__acl__', _marker)
        if acl is _marker:
            continue
        for princid in _referenceable_principals(acl):
            objectmap.connect(
                princid, obj, PrincipalToACLBearing,
                )

########NEW FILE########
__FILENAME__ = evolve3
from substanced.util import postorder
import logging

_marker = object()

logger = logging.getLogger('evolution')

def evolve(root):
    logger.info(
        'Running substanced evolve step 3: evolve __services__ into '
        '__is_service__'
        )
    for obj in postorder(root):
        logger.info(
            'Substanced evolve step 3: trying %s' % (obj,)
            )
        services = getattr(obj, '__services__', None)
        if services:
            for name in services:
                obj[name].__is_service__ = True
            del obj.__services__

########NEW FILE########
__FILENAME__ = evolve4
from substanced.objectmap import (
    ExtentMap,
    find_objectmap,
    )
import logging

_marker = object()

logger = logging.getLogger('evolution')

def evolve(root):
    logger.info(
        'Running substanced evolve step 4: add an extentmap to the objectmap'
        )
    objectmap = find_objectmap(root)
    if objectmap is not None:
        objectmap.extentmap = ExtentMap()
    for oid in objectmap.objectid_to_path:
        obj = objectmap.object_for(oid, root)
        logger.info('Adding oid %s to extentmap' % oid)
        if obj is not None:
            objectmap.extentmap.add(obj, oid)

########NEW FILE########
__FILENAME__ = evolve5
from substanced.objectmap import (
    find_objectmap,
    )
import logging
from substanced.catalog import Catalog
from substanced.util import get_dotted_name

_marker = object()

logger = logging.getLogger('evolution')

def evolve(root):
    logger.info(
        'Running substanced evolve step 5: remove None as default for index '
        'action mode (MODE_ATCOMMIT should be implicit default)'
        )
    objectmap = find_objectmap(root)
    if objectmap is not None:
        oids = objectmap.get_extent(get_dotted_name(Catalog))
        for oid in oids:
            catalog = objectmap.object_for(oid)
            if catalog is not None:
                for index in catalog.values():
                    # wake up index via getattr first
                    if (index.action_mode is None and
                        'action_mode' in index.__dict__):
                        del index.action_mode

########NEW FILE########
__FILENAME__ = evolve6
from substanced.objectmap import (
    find_objectmap,
    )
import logging
from substanced.file import File
from substanced.util import get_dotted_name
from pyramid.compat import string_types

_marker = object()

logger = logging.getLogger('evolution')

def evolve(root):
    logger.info(
        'Running substanced evolve step 6: files should not have USE_MAGIC '
        'as a mimetype or any other non-string value'
        )
    objectmap = find_objectmap(root)
    if objectmap is not None:
        oids = objectmap.get_extent(get_dotted_name(File))
        if oids is not None:
            for oid in oids:
                f = objectmap.object_for(oid)
                if not type(f.mimetype) in string_types:
                    f.mimetype = 'application/octet-stream'

########NEW FILE########
__FILENAME__ = evolve7
import logging

from pyramid.traversal import resource_path
from ZODB.POSException import POSKeyError
from ZODB.blob import Blob

from substanced.objectmap import find_objectmap
from substanced.file import File
from substanced.util import (
    get_dotted_name,
    chunks,
    )
from substanced.file import magic


_marker = object()

logger = logging.getLogger('evolution')

def evolve(root):
    logger.info(
        'Running substanced evolve step 7: reset all blob mimetypes '
        'to nominal USE_MAGIC value'
        )
    if magic:
        objectmap = find_objectmap(root)
        if objectmap is not None:
            oids = objectmap.get_extent(get_dotted_name(File))
            if oids is not None:
                for oid in oids:
                    f = objectmap.object_for(oid)
                    try:
                        if f.get_size():
                            blob = f.blob
                            fp = blob.open('r')
                            for chunk in chunks(fp):
                                m = magic.Magic(mime=True)
                                mimetype = m.from_buffer(chunk)
                                f.mimetype = mimetype
                                break
                    except POSKeyError:
                        logger.error(
                            'Missing blob for file %s, overwriting with '
                            'empty blob' % resource_path(f)
                            )
                        f.blob = Blob()
                        f.mimetype = 'application/octet-stream'

########NEW FILE########
__FILENAME__ = evolve8
from pyramid.compat import string_types

from substanced.util import (
    get_oid,
    is_folder,
    )
    
import logging

_marker = object()

logger = logging.getLogger('evolution')

def postorder(startnode):
    """ Cannot use utils.postorder because it uses node.values """
    def visit(node):
        if is_folder(node):
            for child in node.data.values():
                for result in visit(child):
                    yield result
        yield node
    return visit(startnode)

def evolve(root):
    logger.info(
        'Running substanced evolve step 8: add explicit oid ordering to folders'
        )
    for obj in postorder(root):
        if is_folder(obj):
            order = getattr(obj, '_order', None)
            if order is not None:
                oid_order = ()
                name_order = ()
                if order:
                    if isinstance(order[0], string_types):
                        # handle master branch
                        name_order = obj._order
                        oid_order = []
                        for name in name_order:
                            oid_order.append(get_oid(obj.data[name]))
                    else:
                        # handle ree-ordering-clientside-foo-bar-baz branch
                        name_order = [x[0] for x in order]
                        oid_order = [x[1] for x in order]
                obj._order = tuple(name_order)
                obj._order_oids = tuple(oid_order)

########NEW FILE########
__FILENAME__ = evolve9
from pyramid.traversal import find_interface

from substanced.util import get_dotted_name
from substanced.objectmap import find_objectmap

from substanced.catalog.indexes import AllowedIndex
from substanced.catalog import Catalog

import logging

_marker = object()

logger = logging.getLogger('evolution')

def evolve(root):
    logger.info(
        'Running substanced evolve step 9: reindex all allowed indices '
        'due to change in discriminator principal repr'
        )

    site = root

    objectmap = find_objectmap(site)

    index_oids = objectmap.get_extent(get_dotted_name(AllowedIndex))

    for oid in index_oids:
        index = objectmap.object_for(oid)
        catalog = find_interface(index, Catalog)
        catalog.reindex(indexes=(index.__name__,))

########NEW FILE########
__FILENAME__ = subscribers
import logging
import os

from pyramid.events import (
    ApplicationCreated,
    subscriber,
    )
from pyramid.request import Request
from pyramid.settings import asbool

from . import EvolutionManager

logger = logging.getLogger(__name__)

@subscriber(ApplicationCreated)
def on_startup(event):
    app = event.object
    registry = app.registry
    settings = getattr(registry, 'settings', {})
    autoevolve = asbool(
        os.environ.get('SUBSTANCED_AUTOEVOLVE',
                       settings.get('substanced.autoevolve', False))
        )
    if autoevolve:
        request = Request.blank('/') # path is meaningless
        request.registry = registry
        root = app.root_factory(request)
        em = EvolutionManager(root, registry)
        complete = em.evolve(commit=True)
        if complete:
            for step in complete:
                logger.info('Ran evolution step: %s', step)
        else:
            logger.info('No evolution steps to run.')

########NEW FILE########
__FILENAME__ = test_evolution
import unittest

class TestEvolutionManager(unittest.TestCase):
    def _makeOne(self, context, registry, txn):
        from .. import EvolutionManager
        return EvolutionManager(context, registry, txn)

    def test_ctor_real_txn_module(self):
        import transaction
        inst = self._makeOne(None, None, None)
        self.assertEqual(inst.transaction, transaction)

    def test_ctor_provided_txn_module(self):
        txn = DummyTransaction()
        inst = self._makeOne(None, None, txn)
        self.assertEqual(inst.transaction, txn)

    def test_get_zodb_root(self):
        root = DummyRoot()
        inst = self._makeOne(root, None, None)
        zodb_root = inst.get_zodb_root()
        self.assertEqual(zodb_root, root._p_jar._root)

    def test_get_finished_steps(self):
        from .. import FINISHED_KEY
        root = DummyRoot()
        inst = self._makeOne(root, None, None)
        steps = inst.get_finished_steps()
        self.assertEqual(steps, root._p_jar._root[FINISHED_KEY])

    def test_get_finished_steps_by_value(self):
        root = DummyRoot()
        inst = self._makeOne(root, None, None)
        inst.add_finished_step('abc')
        inst.add_finished_step('def')
        steps = inst.get_finished_steps_by_value()
        self.assertEqual(list(x[1] for x in steps), ['abc', 'def'])

    def test_add_finished_step(self):
        from .. import FINISHED_KEY
        root = DummyRoot()
        inst = self._makeOne(root, None, None)
        inst.add_finished_step('foo')
        steps = root._p_jar._root[FINISHED_KEY]
        self.assertTrue('foo' in steps)

    def test_remove_finished_step(self):
        root = DummyRoot()
        inst = self._makeOne(root, None, None)
        steps = inst.get_finished_steps()
        steps['foo'] = 1
        inst.remove_finished_step('foo')
        self.assertFalse('foo' in steps)

    def test_get_unifinished_steps_no_utility(self):
        registry = DummyRegistry(None)
        inst = self._makeOne(None, registry, None)
        result = inst.get_unfinished_steps()
        self.assertEqual(list(result), [])
        
    def test_get_unifinished_steps(self):
        steps = DummySteps(
            [(None, ('foo', None)),
             (None, ('bar', None))]
            )
        root = DummyRoot()
        registry = DummyRegistry(steps)
        inst = self._makeOne(root, registry, None)
        finished = inst.get_finished_steps()
        finished['foo'] = 1
        result = inst.get_unfinished_steps()
        self.assertEqual(list(result), [('bar', None)])

    def test_mark_unfinished_as_finished(self):
        steps = DummySteps(
            [(None, ('foo', None)),
             (None, ('bar', None))]
            )
        root = DummyRoot()
        registry = DummyRegistry(steps)
        inst = self._makeOne(root, registry, None)
        finished = inst.get_finished_steps()
        finished['foo'] = 1
        inst.mark_unfinished_as_finished()
        self.assertEqual(list(sorted(finished)), ['bar', 'foo'])

    def test_evolve_commit_false(self):
        root = DummyRoot()
        txn = DummyTransaction()
        inst = self._makeOne(root, None, txn)
        def func(context):
            self.assertEqual(context, root)
        inst.get_unfinished_steps = lambda *arg: [('name', func)]
        log = []
        inst.out = log.append
        result = inst.evolve(False)
        self.assertEqual(log, ['Executing evolution step name'])
        self.assertEqual(result, ['name'])
        self.assertEqual(txn.committed, 1)
        self.assertEqual(txn.begun, 1)
        self.assertEqual(txn.notes, [])
        self.assertEqual(txn.was_aborted, True)

    def test_evolve_commit_true(self):
        root = DummyRoot()
        txn = DummyTransaction()
        inst = self._makeOne(root, None, txn)
        def func(context):
            self.assertEqual(context, root)
        inst.get_unfinished_steps = lambda *arg: [('name', func)]
        log = []
        inst.out = log.append
        result = inst.evolve(True)
        self.assertEqual(log, ['Executing evolution step name'])
        self.assertEqual(result, ['name'])
        self.assertEqual(txn.committed, 2)
        self.assertEqual(txn.begun, 1)
        self.assertEqual(txn.notes, ['Executed evolution step name'])
        self.assertEqual(txn.was_aborted, False)

class Test_mark_unfinished_as_finished(unittest.TestCase):
    def _callFUT(self, app_root, registry, t):
        from .. import mark_unfinished_as_finished
        return mark_unfinished_as_finished(app_root, registry, t)

    def test_it(self):
        from .. import FINISHED_KEY
        steps = DummySteps(
            [(None, ('foo', None)),
             (None, ('bar', None))]
            )
        root = DummyRoot()
        registry = DummyRegistry(steps)
        txn = DummyTransaction()
        self._callFUT(root, registry, txn)
        self.assertEqual(list(sorted(root._p_jar._root[FINISHED_KEY])),
                         ['bar', 'foo'])

class Test_add_evolution_step(unittest.TestCase):
    def _callFUT(self, config, *arg, **kw):
        from .. import add_evolution_step
        return add_evolution_step(config, *arg, **kw)

    def test_simple(self):
        from substanced.interfaces import IEvolutionSteps
        registry = DummyRegistry(None)
        config = DummyConfig(registry)
        self._callFUT(config, dummystep)
        self.assertEqual(len(config.actions), 1)
        action = config.actions[0]
        self.assertEqual(
            action['discriminator'],
            ('evolution step',
             'substanced.evolution.tests.test_evolution.dummystep')
            )
        self.assertEqual(
            action['introspectables'],
            ({'after': None,
              'name': 'substanced.evolution.tests.test_evolution.dummystep',
              'func': dummystep,
              'before': None},)
            )
        action['register']()
        utility, iface = config.registry.registered
        self.assertEqual(utility.__class__.__name__,
                         'TopologicalSorter')
        self.assertEqual(
            utility.names,
            ['substanced.evolution.tests.test_evolution.dummystep'])
        self.assertEqual(iface, IEvolutionSteps)

    def test_with_before_and_after_strings(self):
        from substanced.interfaces import IEvolutionSteps
        registry = DummyRegistry(None)
        config = DummyConfig(registry)
        self._callFUT(config, dummystep, before='foo', after='bar')
        self.assertEqual(len(config.actions), 1)
        action = config.actions[0]
        self.assertEqual(
            action['discriminator'],
            ('evolution step',
             'substanced.evolution.tests.test_evolution.dummystep')
            )
        self.assertEqual(
            action['introspectables'],
            ({'after': 'bar',
              'name': 'substanced.evolution.tests.test_evolution.dummystep',
              'func': dummystep,
              'before': 'foo'},)
            )
        action['register']()
        utility, iface = config.registry.registered
        self.assertEqual(utility.__class__.__name__,
                         'TopologicalSorter')
        self.assertEqual(
            utility.names,
            ['substanced.evolution.tests.test_evolution.dummystep'])
        self.assertEqual(iface, IEvolutionSteps)

    def test_with_before_and_after_funcs(self):
        from substanced.interfaces import IEvolutionSteps
        registry = DummyRegistry(None)
        config = DummyConfig(registry)
        self._callFUT(config, dummystep, before=dummybefore, after=dummyafter)
        self.assertEqual(len(config.actions), 1)
        action = config.actions[0]
        self.assertEqual(
            action['discriminator'],
            ('evolution step',
             'substanced.evolution.tests.test_evolution.dummystep')
            )
        self.assertEqual(
            action['introspectables'],
            ({'after': 'substanced.evolution.tests.test_evolution.dummyafter',
              'name': 'substanced.evolution.tests.test_evolution.dummystep',
              'func': dummystep,
              'before': 'substanced.evolution.tests.test_evolution.dummybefore'},
             )
            )
        action['register']()
        utility, iface = config.registry.registered
        self.assertEqual(utility.__class__.__name__,
                         'TopologicalSorter')
        self.assertEqual(
            utility.names,
            ['substanced.evolution.tests.test_evolution.dummystep'])
        self.assertEqual(iface, IEvolutionSteps)

    def test_with_custom_name(self):
        from substanced.interfaces import IEvolutionSteps
        registry = DummyRegistry(None)
        config = DummyConfig(registry)
        self._callFUT(config, dummystep, name='fred')
        self.assertEqual(len(config.actions), 1)
        action = config.actions[0]
        self.assertEqual(
            action['discriminator'],
            ('evolution step',
             'fred')
            )
        self.assertEqual(
            action['introspectables'],
            ({'after': None,
              'name': 'fred',
              'func': dummystep,
              'before': None},
             )
            )
        action['register']()
        utility, iface = config.registry.registered
        self.assertEqual(utility.__class__.__name__,
                         'TopologicalSorter')
        self.assertEqual(
            utility.names,
            ['fred'])
        self.assertEqual(iface, IEvolutionSteps)

def dummystep(root): pass

def dummybefore(root): pass

def dummyafter(root): pass
   

class DummyTransaction(object):
    def __init__(self):
        self.begun = 0
        self.committed = 0
        self.notes = []
        self.was_aborted = False

    def begin(self):
        self.begun += 1

    def commit(self):
        self.committed += 1

    def note(self, msg):
        self.notes.append(msg)

    def get(self):
        return self

    def abort(self):
        self.was_aborted = True


class DummyJar(object):
    def __init__(self):
        self._root = {}
    def root(self):
        return self._root

class DummyRoot(object):
    def __init__(self):
        self._p_jar = DummyJar()
        
class DummyRegistry(object):
    def __init__(self, utility):
        self.utility = utility

    def queryUtility(self, iface):
        return self.utility

    def registerUtility(self, utility, iface):
        self.registered = utility, iface

class DummySteps(object):
    def __init__(self, result):
        self.result = result

    def sorted(self):
        return self.result

class DummyConfig(object):
    def __init__(self, registry):
        self.registry = registry
        self.actions = []
        
    def object_description(self, func):
        return func.__name__

    def introspectable(self, title, discriminator, desc, titles):
        self.intr = {}
        return self.intr

    def action(self, discriminator, register, introspectables):
        self.actions.append(
            {'discriminator':discriminator,
             'register':register,
             'introspectables':introspectables}
            )

########NEW FILE########
__FILENAME__ = test_subscribers
import unittest

import mock
from pyramid import testing

class Test_on_startup(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, event):
        from ..subscribers import on_startup
        return on_startup(event)

    @mock.patch('substanced.evolution.subscribers.EvolutionManager')
    def test_autoevolve_false(self, mock_EvolutionManager):
        registry = self.config.registry
        registry.settings['substanced.autoevolve'] = 'false'
        app = testing.DummyResource()
        app.registry = registry
        event = DummyEvent(app, None)
        self._callFUT(event)
        self.assertEqual(mock_EvolutionManager.mock_calls, [])

    @mock.patch('substanced.evolution.subscribers.EvolutionManager')
    def test_autoevolve_missing(self, mock_EvolutionManager):
        registry = self.config.registry
        app = testing.DummyResource()
        app.registry = registry
        event = DummyEvent(app, None)
        self._callFUT(event)
        self.assertEqual(mock_EvolutionManager.mock_calls, [])

    @mock.patch('substanced.evolution.subscribers.EvolutionManager')
    def test_autosync_no_steps(self, mock_EvolutionManager):
        returnFalse = lambda *x: False
        # Python3 / Py3k
        mock_EvolutionManager().evolve().__nonzero__ = returnFalse
        mock_EvolutionManager().evolve().__bool__ = returnFalse
        registry = self.config.registry
        registry.settings['substanced.autoevolve'] = 'true'
        app = testing.DummyResource()
        app.registry = registry
        root = testing.DummyResource()
        app.root_factory = lambda *arg: root
        event = DummyEvent(app, None)
        self._callFUT(event)
        mock_EvolutionManager().evolve.assert_called_with(commit=True)

    @mock.patch('substanced.evolution.subscribers.EvolutionManager')
    def test_autoevolve_run_steps(self, mock_EvolutionManager):
        mock_EvolutionManager().evolve().__iter__ = mock.Mock(
            return_value=iter(["a", "b"]))
        registry = self.config.registry
        registry.settings['substanced.autoevolve'] = 'true'
        app = testing.DummyResource()
        app.registry = registry
        root = testing.DummyResource()
        app.root_factory = lambda *arg: root
        event = DummyEvent(app, None)
        self._callFUT(event)
        mock_EvolutionManager().evolve.assert_called_with(commit=True)

class DummyEvent(object):
    removed_oids = None

    def __init__(self, object, parent, registry=None, moving=None):
        self.object = object
        self.parent = parent
        self.registry = registry
        self.moving = moving

########NEW FILE########
__FILENAME__ = test_init
import io
import os
import unittest
from pyramid import testing

class Test_file_upload_widget(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, node, kw):
        from .. import file_upload_widget
        return file_upload_widget(node, kw)

    def test_loading(self):
        kw = {'loading':True}
        self.assertEqual(self._callFUT(None, kw), None)

    def test_it(self):
        here = os.path.dirname(__file__)
        request = testing.DummyRequest()
        request.registry.settings['substanced.uploads_tempdir'] = here
        kw = {}
        kw['request'] = request
        widget = self._callFUT(None, kw)
        self.assertEqual(widget.__class__.__name__, 'FileUploadWidget')

class TestFileUploadPropertySheet(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from .. import FileUploadPropertySheet
        return FileUploadPropertySheet(context, request)

    def test_get_not_an_image(self):
        context = testing.DummyResource()
        context.__oid__ = 'oid'
        context.get_size = lambda *arg: 80
        context.mimetype = 'application/octet-stream'
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        file = {'fp':None, 'uid':'oid', 'filename':'', 'size':80}
        self.assertEqual(
            inst.get(),
            {'file':file}
            )

    def test_get_is_an_image(self):
        context = testing.DummyResource()
        context.__oid__ = 'oid'
        context.get_size = lambda *arg: 80
        context.mimetype = 'image/foo'
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        file = {'fp':None,
                'uid':'oid',
                'filename':'',
                'preview_url':'/mgmt_path',
                'size':80}
        self.assertEqual(
            inst.get(),
            {'file':file}
            )

    def test_set_no_fp(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        inst.set({'file':{}})

    def test_set_with_fp_and_filename(self):
        fp = io.BytesIO(b'abc')
        fp.seek(2)
        def upload(_fp, mimetype_hint=None):
            self.assertEqual(_fp, fp)
            self.assertEqual(mimetype_hint, 'foo.pt')
            context.uploaded = True
        context = testing.DummyResource()
        context.upload = upload
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        inst.set({'file':{'fp':fp, 'filename':'foo.pt'}})
        self.assertTrue(context.uploaded)
        self.assertEqual(fp.tell(), 0)

    def test_set_with_fp_no_filename(self):
        from .. import USE_MAGIC
        fp = io.BytesIO(b'abc')
        fp.seek(2)
        def upload(_fp, mimetype_hint=None):
            self.assertEqual(_fp, fp)
            self.assertEqual(mimetype_hint, USE_MAGIC)
            context.uploaded = True
        context = testing.DummyResource()
        context.upload = upload
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        inst.set({'file':{'fp':fp}})
        self.assertTrue(context.uploaded)
        self.assertEqual(fp.tell(), 0)

    def test_after_set(self):
        context = testing.DummyResource()
        here = os.path.dirname(__file__)
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.registry.settings = {}
        request.registry.settings['substanced.uploads_tempdir'] = here
        request.session['substanced.tempstore'] = {'1':{}}
        inst = self._makeOne(context, request)
        inst.after_set(True)
        self.assertEqual(request.session.get('substanced.tempstore'), None)

class TestFile(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, stream, mimetype, title=None):
        from .. import File
        return File(stream, mimetype, title)

    def test_ctor_no_stream(self):
        inst = self._makeOne(None, None)
        self.assertEqual(inst.mimetype, 'application/octet-stream')

    def test_ctor_no_title(self):
        from substanced._compat import u
        inst = self._makeOne(None, None)
        self.assertEqual(inst.title, u(''))

    def test_ctor_with_None_title(self):
        from substanced._compat import u
        inst = self._makeOne(None, None, None)
        self.assertEqual(inst.title, u(''))

    def test_ctor_with_with_title(self):
        inst = self._makeOne(None, None, 'abc')
        self.assertEqual(inst.title, 'abc')

    def test_ctor_with_stream_mimetype_None(self):
        stream = io.BytesIO(b'abc')
        inst = self._makeOne(stream, None)
        self.assertEqual(inst.mimetype, 'application/octet-stream')
        with inst.blob.open('r') as fp:
            fp.seek(0)
            self.assertEqual(fp.read(), b'abc')

    def test_ctor_with_stream_mimetype_USE_MAGIC(self):
        from .. import USE_MAGIC
        stream = io.BytesIO(b'abc')
        inst = self._makeOne(stream, USE_MAGIC)
        self.assertEqual(inst.mimetype, 'text/plain')
        with inst.blob.open('r') as fp:
            fp.seek(0)
            self.assertEqual(fp.read(), b'abc')

    def test_ctor_with_mimetype_no_stream(self):
        inst = self._makeOne(None, 'text/plain')
        self.assertEqual(inst.mimetype, 'text/plain')

    def test_ctor_with_mimetype_and_stream(self):
        stream = io.BytesIO(b'abc')
        inst = self._makeOne(stream, 'text/foo')
        self.assertEqual(inst.mimetype, 'text/foo')
        with inst.blob.open('r') as fp:
            fp.seek(0)
            self.assertEqual(fp.read(), b'abc')

    def test_ctor_mimetype_is_USE_MAGIC_no_stream(self):
        from .. import USE_MAGIC
        inst = self._makeOne(None, USE_MAGIC)
        self.assertEqual(inst.mimetype, 'application/octet-stream')

    def test_upload_stream_is_None(self):
        inst = self._makeOne(None, None)
        inst.upload(None)
        with inst.blob.open('r') as f:
            self.assertEqual(f.read(), b'')

    def test_upload_stream_is_not_None(self):
        stream = io.BytesIO(b'abc')
        inst = self._makeOne(None, None)
        inst.upload(stream)
        with inst.blob.open('r') as f:
            self.assertEqual(f.read(), b'abc')

    def test_upload_stream_mimetype_hint_USE_MAGIC(self):
        from .. import USE_MAGIC
        stream = io.BytesIO(b'abc')
        inst = self._makeOne(None, None)
        self.assertEqual(inst.mimetype, 'application/octet-stream')
        inst.upload(stream, mimetype_hint=USE_MAGIC)
        self.assertEqual(inst.mimetype, 'text/plain')

    def test_upload_stream_mimetype_hint_filename(self):
        stream = io.BytesIO(b'abc')
        inst = self._makeOne(None, None)
        self.assertEqual(inst.mimetype, 'application/octet-stream')
        inst.upload(stream, mimetype_hint='foo.gif')
        self.assertEqual(inst.mimetype, 'image/gif')

    def test_upload_stream_mimetype_hint_filename_unknown_extension(self):
        stream = io.BytesIO(b'abc')
        inst = self._makeOne(None, None)
        self.assertEqual(inst.mimetype, 'application/octet-stream')
        inst.upload(stream, mimetype_hint='foo')
        self.assertEqual(inst.mimetype, 'application/octet-stream')

    def test_upload_stream_mimetype_hint_None(self):
        stream = io.BytesIO(b'abc')
        inst = self._makeOne(None, None)
        self.assertEqual(inst.mimetype, 'application/octet-stream')
        inst.upload(stream, mimetype_hint=None)
        self.assertEqual(inst.mimetype, 'application/octet-stream')

    def test_get_response_no_ct(self):
        inst = self._makeOne(None, 'text/plain')
        inst.blob = DummyBlob()
        response = inst.get_response()
        self.assertTrue(response.body)
        self.assertEqual(response.content_type, 'text/plain')

    def test_get_response_with_ct(self):
        inst = self._makeOne(None, 'text/plain')
        inst.blob = DummyBlob()
        response = inst.get_response(content_type='text/other')
        self.assertTrue(response.body)
        self.assertEqual(response.content_type, 'text/other')

    def test_get_size(self):
        inst = self._makeOne(None, None)
        inst.blob = DummyBlob()
        size = inst.get_size()
        self.assertEqual(size, os.stat(__file__).st_size)

    def test_get_etag_blob_newer(self):
        # E.g. if upload after setting title
        from ZODB.utils import oid_repr
        inst = self._makeOne(None, None)
        inst._p_serial = b'DEADBEEF'
        blob = inst.blob = DummyBlob()
        blob._p_serial = b'EDABEDAC'
        etag = inst.get_etag()
        self.assertEqual(etag, oid_repr(b'EDABEDAC'))

    def test_get_etag_file_newer(self):
        # E.g. if title is updated after upload
        from ZODB.utils import oid_repr
        inst = self._makeOne(None, None)
        inst._p_serial = b'EDABEDAC'
        blob = inst.blob = DummyBlob()
        blob._p_serial = b'DEADBEEF'
        etag = inst.get_etag()
        self.assertEqual(etag, oid_repr(b'EDABEDAC'))

    def test_get_etag_file_newer_w_ghost_blob(self):
        # E.g. if title is updated after upload
        from ZODB.utils import oid_repr
        from ZODB.utils import z64
        inst = self._makeOne(None, None)
        inst._p_serial = b'EDABEDAC'
        blob = inst.blob = DummyBlob()
        blob._p_serial = z64
        etag = inst.get_etag()
        self.assertEqual(etag, oid_repr(b'EDABEDAC'))

class Test_context_is_a_file(unittest.TestCase):
    def _callFUT(self, context, request):
        from .. import context_is_a_file
        return context_is_a_file(context, request)

    def test_it_true(self):
        registry = DummyRegistry(True)
        request = testing.DummyRequest()
        request.registry = registry
        self.assertTrue(self._callFUT(None, request))

    def test_it_false(self):
        registry = DummyRegistry(False)
        request = testing.DummyRequest()
        request.registry = registry
        self.assertFalse(self._callFUT(None, request))

class DummyContent(object):
    def __init__(self, result):
        self.result = result
    def istype(self, context, t):
        return self.result

class DummyRegistry(object):
    def __init__(self, result):
        self.content = DummyContent(result)

class DummyBlob(object):
    def committed(self):
        return os.path.abspath(__file__)
    def _p_activate(self):
        self._p_serial = b'CACAFADA'

class DummySDIAPI(object):
    def mgmt_path(self, *arg, **kw):
        return '/mgmt_path'


########NEW FILE########
__FILENAME__ = test_views
import io
import os
import unittest

import colander
import pkg_resources
from pyramid import testing

class Test_view_file(unittest.TestCase):
    def _callFUT(self, context, request):
        from ..views import view_file
        return view_file(context, request)

    def test_it(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        def get_response(**kw):
            self.assertEqual(kw['request'], request)
            return 'response'
        context.get_response = get_response
        result = self._callFUT(context, request)
        self.assertEqual(result, 'response')

class Test_view_tab(unittest.TestCase):
    def _callFUT(self, context, request):
        from ..views import view_tab
        return view_tab(context, request)

    def test_it(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        result = self._callFUT(context, request)
        self.assertEqual(result.location, '/mgmt_path')

class Test_name_or_file(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, node, kw):
        from ..views import name_or_file
        return name_or_file(node, kw)

    def test_no_file_no_name(self):
        inst = self._makeOne(None, None)
        self.assertRaises(
            colander.Invalid, inst, None, {'file':None, 'name':None}
            )

    def test_no_name_no_filename(self):
        inst = self._makeOne(None, None)
        self.assertRaises(
            colander.Invalid, inst, None, {'file':{'a':1}, 'name':None}
            )

    def test_no_name_with_filename(self):
        context = testing.DummyResource()
        context.check_name = lambda name: name
        request = testing.DummyRequest()
        request.registry.content = DummyContent(False)
        node = {'file':None}
        inst = self._makeOne(node, {'context':context, 'request':request})
        result = inst(node, {'file':{'filename':'another'}, 'name':None})
        self.assertEqual(result, None)

class TestAddFileView(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from ..views import AddFileView
        return AddFileView(context, request)

    def test_add_success_no_filedata(self):
        created = testing.DummyResource()
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent(created)
        appstruct = {
            'name':'abc',
            'file':None,
            'title':None,
            'mimetype':'',
            }
        inst = self._makeOne(context, request)
        result = inst.add_success(appstruct)
        self.assertEqual(result.location, '/mgmt_path')
        self.assertEqual(context['abc'], created)

    def test_add_success_with_filedata_no_name(self):
        created = testing.DummyResource()
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent(created)
        fp = io.BytesIO(b'abc')
        appstruct = {
            'name':None,
            'title':None,
            'file':{'fp':fp, 'filename':'filename'},
            'mimetype':'',
            }
        inst = self._makeOne(context, request)
        result = inst.add_success(appstruct)
        self.assertEqual(result.location, '/mgmt_path')
        self.assertEqual(context['filename'], created)

    def test_add_success_with_filedata_and_name(self):
        created = testing.DummyResource()
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent(created)
        fp = io.BytesIO(b'abc')
        appstruct = {
            'name':'abc',
            'file':{'fp':fp, 'filename':'filename'},
            'title':None,
            'mimetype':'',
            }
        inst = self._makeOne(context, request)
        result = inst.add_success(appstruct)
        self.assertEqual(result.location, '/mgmt_path')
        self.assertEqual(context['abc'], created)

    def test_add_success_with_filedata_but_no_fp(self):
        from substanced.file import USE_MAGIC
        created = testing.DummyResource()
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        content_reg = DummyContent(created)
        request.registry.content = content_reg
        appstruct = {
            'name':'abc',
            'file':{'fp':None, 'filename':'filename'},
            'title':None,
            'mimetype':'',
            }
        inst = self._makeOne(context, request)
        result = inst.add_success(appstruct)
        self.assertEqual(result.location, '/mgmt_path')
        self.assertEqual(context['abc'], created)
        self.assertEqual(content_reg.created_args[1]['mimetype'], USE_MAGIC)

    def test_add_success_with_mimetype(self):
        created = testing.DummyResource()
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        content_reg = DummyContent(created)
        request.registry.content = content_reg
        appstruct = {
            'name':'abc',
            'file':None,
            'title':None,
            'mimetype':'text/xml',
            }
        inst = self._makeOne(context, request)
        result = inst.add_success(appstruct)
        self.assertEqual(result.location, '/mgmt_path')
        self.assertEqual(context['abc'], created)
        self.assertEqual(content_reg.created_args[1]['mimetype'], 'text/xml')


class Test_preview_image_upload(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, request):
        from ..views import preview_image_upload
        return preview_image_upload(request)

    def test_without_fp(self):
        here = os.path.dirname(__file__)
        request = testing.DummyRequest()
        request.subpath = ('abc',)
        request.registry.settings['substanced.uploads_tempdir'] = here
        response = self._callFUT(request)
        self.assertEqual(response.content_type, 'image/gif')
        fn = pkg_resources.resource_filename(
            'substanced.sdi', 'static/img/onepixel.gif')
        with open(fn, 'rb') as f:
            expected = f.read()
        self.assertEqual(response.body, expected)

    def test_with_fp(self):
        here = os.path.dirname(__file__)
        request = testing.DummyRequest()
        request.subpath = ('abc',)
        request.registry.settings['substanced.uploads_tempdir'] = here
        fp = io.BytesIO(b'abc')
        request.session['substanced.tempstore'] = {
            'abc':{'fp':fp, 'filename':'foo.jpg'}}
        response = self._callFUT(request)
        self.assertEqual(response.content_type, 'image/jpeg')
        self.assertEqual(response.body, b'abc')

class DummyContent(object):
    def __init__(self, result):
        self.result = result

    def istype(self, *arg, **kw):
        return self.result

    def create(self, *arg, **kw):
        self.created_args = (arg, kw)
        return self.result

class DummySDIAPI(object):
    def mgmt_path(self, *arg, **kw):
        return '/mgmt_path'

########NEW FILE########
__FILENAME__ = views
import pkg_resources
import mimetypes
import colander
import deform.schema

from pyramid.httpexceptions import HTTPFound
from pyramid.response import Response
from pyramid.security import NO_PERMISSION_REQUIRED

from ..form import FormView

from ..file import (
    FilePropertiesSchema,
    FileUploadTempStore,
    file_upload_widget,
    file_name_node,
    USE_MAGIC,
    )

from ..interfaces import (
    IFile,
    IFolder,
    )

from ..sdi import mgmt_view

@mgmt_view(
    context=IFile,
    name='', 
    permission='sdi.view',
    tab_condition=False,
    http_cache=0,
    )
def view_file(context, request):
    return context.get_response(request=request)

@mgmt_view(
    context=IFile,
    name='view',
    tab_title='View',
    permission='sdi.view'
    )
def view_tab(context, request):
    return HTTPFound(location=request.sdiapi.mgmt_path(context))

class AddFileSchema(FilePropertiesSchema):
    file = colander.SchemaNode(
        deform.schema.FileData(),
        widget = file_upload_widget,
        missing = colander.null,
        )

@colander.deferred
def name_or_file(node, kw):
    def _name_or_file(node, struct):
        if not struct['file'] and not struct['name']:
            raise colander.Invalid(node, 'One of name or file is required')
        if not struct['name']:
            filename = struct['file'].get('filename')
            if filename:
                name_node = file_name_node.bind(
                    context=kw['context'], request=kw['request']
                    )
                name_node.validator(node['file'], filename)
            else:
                raise colander.Invalid(
                    node,
                    'If no name is supplied, a file must be supplied.'
                    )
    return _name_or_file

@mgmt_view(
    context=IFolder,
    name='add_file',
    tab_title='Add File', 
    permission='sdi.add-content', 
    renderer='substanced.sdi:templates/form.pt',
    tab_condition=False
    )
class AddFileView(FormView):
    title = 'Add File'
    schema = AddFileSchema(validator=name_or_file).clone()
    schema['name'].missing = colander.null
    schema['mimetype'].missing = colander.null
    buttons = ('add',)

    def _makeob(self, stream, title, mimetype):
        return self.request.registry.content.create(
            'File',
            stream=stream,
            mimetype=mimetype,
            title=title,
            )

    def add_success(self, appstruct):
        name = appstruct['name']
        title = appstruct['title'] or None
        filedata = appstruct['file']
        mimetype = appstruct['mimetype'] or USE_MAGIC
        stream = None
        filename = None
        if filedata:
            filename = filedata['filename']
            stream = filedata['fp']
            if stream:
                stream.seek(0)
            else:
                stream = None
        name = name or filename
        fileob = self._makeob(stream, title, mimetype)
        self.context[name] = fileob
        return HTTPFound(self.request.sdiapi.mgmt_path(self.context))

onepixel = pkg_resources.resource_filename(
    'substanced.sdi', 'static/img/onepixel.gif')

# this doesn't require a permission, because it's based on session data
# which the user would have to put there anyway
@mgmt_view(
    name='preview_image_upload',
    tab_condition=False,
    permission=NO_PERMISSION_REQUIRED
    )
def preview_image_upload(request):
    uid = request.subpath[0]
    tempstore = FileUploadTempStore(request)
    filedata = tempstore.get(uid, {})
    fp = filedata.get('fp')
    filename = ''
    if fp is not None:
        fp.seek(0)
        filename = filedata['filename']
    mimetype = mimetypes.guess_type(filename, strict=False)[0]
    if not mimetype or not mimetype.startswith('image/'):
        mimetype = 'image/gif'
        fp = open(onepixel, 'rb')
    response = Response(content_type=mimetype, app_iter=fp)
    return response

########NEW FILE########
__FILENAME__ = evolve
from zope.interface import alsoProvides

from ..interfaces import IService
from ..interfaces import MODE_IMMEDIATE

def convert_services_to_IService(root):
    # can't use find_catalog because we changed it to expect IService, which
    # we are in the process of bootstrapping.
    catalog = root['catalogs']['system']
    index = catalog['interfaces']
    for val in root.values():
        try:
            del val.__is_service__
        except AttributeError:
            pass
        else:
            alsoProvides(val, IService)
            index.reindex_resource(val, action_mode=MODE_IMMEDIATE)

def includeme(config):
    config.add_evolution_step(convert_services_to_IService)

########NEW FILE########
__FILENAME__ = test_init
import unittest
from pyramid import testing

from zope.interface import (
    Interface,
    directlyProvides
    )
from zope.interface.verify import (
    verifyObject,
    verifyClass
    )

class TestFolder(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _getTargetClass(self):
        from .. import Folder
        return Folder

    def _makeSite(self, objectmap=None):
        from substanced.interfaces import IFolder
        from zope.interface import alsoProvides
        site = testing.DummyResource()
        if objectmap:
            site.__objectmap__ = objectmap
        alsoProvides(site, IFolder)
        return site

    def _makeOne(self, data=None, family=None):
        klass = self._getTargetClass()
        return klass(data, family=family)

    def test_klass_provides_IFolder(self):
        klass = self._getTargetClass()
        from substanced.interfaces import IFolder
        verifyClass(IFolder, klass)

    def test_inst_provides_IFolder(self):
        from substanced.interfaces import IFolder
        inst = self._makeOne()
        verifyObject(IFolder, inst)

    def test_ctor_alternate_family(self):
        import BTrees
        inst = self._makeOne(family=BTrees.family32)
        self.assertEqual(inst.family, BTrees.family32)

    def _registerEventListener(self, listener, iface):
        self.config.registry.registerHandler(
            listener, (iface, Interface, Interface))

    def test_keys(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        self.assertEqual(list(folder.keys()), ['a', 'b'])

    def test_set_order_not_all_names_mentioned(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        self.assertRaises(ValueError, folder.set_order, ['a'])

    def test_set_order_name_mentioned_more_than_once(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        self.assertRaises(ValueError, folder.set_order, ['a', 'a', 'b'])

    def test_set_order_influences_is_ordered(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        folder.set_order(['b', 'a'])
        self.assertTrue(folder.is_ordered())

    def test_set_order_impacts_keys(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        folder.set_order(['b', 'a'])
        self.assertEqual(list(folder.keys()), ['b', 'a'])

    def test_unset_order_not_reorderable(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        folder.set_order(['b', 'a'])
        self.assertTrue(folder.is_ordered())
        self.assertFalse(folder.is_reorderable())
        self.assertEqual(list(folder.keys()), ['b', 'a'])
        folder.unset_order()
        self.assertEqual(list(folder.keys()), ['a', 'b'])
        self.assertEqual(folder._order, None)
        self.assertEqual(folder._order_oids, None)
        self.assertEqual(folder._reorderable, None)
        self.assertFalse(folder.is_ordered())
        self.assertFalse(folder.is_reorderable())

    def test_unset_order_reorderable(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        folder.set_order(['b', 'a'], reorderable=True)
        self.assertTrue(folder.is_ordered())
        self.assertTrue(folder.is_reorderable())
        self.assertEqual(list(folder.keys()), ['b', 'a'])
        folder.unset_order()
        self.assertEqual(list(folder.keys()), ['a', 'b'])
        self.assertEqual(folder._order, None)
        self.assertEqual(folder._order_oids, None)
        self.assertEqual(folder._reorderable, None)
        self.assertFalse(folder.is_ordered())
        self.assertFalse(folder.is_reorderable())

    def test_set_order_is_non_reorderable_by_default(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        folder.set_order(['a', 'b'])
        self.assertFalse(folder.is_reorderable())

    def test_set_order_reorderable_false(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        folder.set_order(['a', 'b'], reorderable=False)
        self.assertFalse(folder.is_reorderable())

    def test_set_order_reorderable_true(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        folder.set_order(['a', 'b'], reorderable=True)
        self.assertTrue(folder.is_reorderable())

    def test_is_ordered_false_by_default(self):
        folder = self._makeOne({'a': 1, 'b': 2})
        self.assertFalse(folder.is_ordered())

    def test_sort_with_explicit_folder_order(self):
        model1 = DummyModel()
        model1.__oid__ = 1
        model2 = DummyModel()
        model2.__oid__ = 2
        folder = self._makeOne({'a': model1, 'b': model2})
        folder.set_order(['a', 'b'])
        result = folder.sort([1,2])
        self.assertEqual(result, [1, 2])

    def test_sort_no_reverse_no_limit(self):
        model1 = DummyModel()
        model1.__oid__ = 1
        model2 = DummyModel()
        model2.__oid__ = 2
        folder = self._makeOne({'a': model1, 'b': model2})
        result = folder.sort([1,2])
        self.assertEqual(result, [1, 2])

    def test_sort_no_reverse_no_limit_catalog_has_more_results_than_fold(self):
        model1 = DummyModel()
        model1.__oid__ = 1
        model2 = DummyModel()
        model2.__oid__ = 2
        folder = self._makeOne({'a': model1, 'b': model2})
        result = folder.sort([1,2,3])
        self.assertEqual(result, [1, 2])

    def test_sort_no_reverse_no_limit_fold_has_more_results_than_catalog(self):
        model1 = DummyModel()
        model1.__oid__ = 1
        model2 = DummyModel()
        model2.__oid__ = 2
        folder = self._makeOne({'a': model1, 'b': model2})
        result = folder.sort([1])
        self.assertEqual(result, [1])

    def test_sort_reverse_no_limit(self):
        model1 = DummyModel()
        model1.__oid__ = 1
        model2 = DummyModel()
        model2.__oid__ = 2
        folder = self._makeOne({'a': model1, 'b': model2})
        result = folder.sort([1, 2], reverse=True)
        self.assertEqual(result, [2, 1])

    def test_sort_reverse_limit(self):
        model1 = DummyModel()
        model1.__oid__ = 1
        model2 = DummyModel()
        model2.__oid__ = 2
        folder = self._makeOne({'a': model1, 'b': model2})
        result = folder.sort([1, 2], reverse=True, limit=1)
        self.assertEqual(result, [2])

    def test_sort_forward_limit(self):
        model1 = DummyModel()
        model1.__oid__ = 1
        model2 = DummyModel()
        model2.__oid__ = 2
        folder = self._makeOne({'a': model1, 'b': model2})
        result = folder.sort([1, 2], limit=1)
        self.assertEqual(result, [1])

    def test__iter__(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        self.assertEqual(list(folder), ['a', 'b'])

    def test__iter___with_order(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        folder.set_order(['b', 'a'])
        self.assertEqual(list(folder), ['b', 'a'])

    def test_values(self):
        folder = self._makeOne({'a': 1, 'b': 2})
        self.assertEqual(list(folder.values()), [1, 2])

    def test_values_with_order(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        folder.set_order(['b', 'a'])
        self.assertEqual(list(folder.values()), [model2, model1])

    def test_items(self):
        folder = self._makeOne({'a': 1, 'b': 2})
        self.assertEqual(list(folder.items()), [('a', 1), ('b', 2)])

    def test_items_with_order(self):
        model1 = DummyModel()
        model2 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2})
        folder.set_order(['b', 'a'])
        self.assertEqual(list(folder.items()), [('b', model2), ('a', model1)])

    def test__len__(self):
        folder = self._makeOne({'a': 1, 'b': 2})
        self.assertEqual(len(folder), 2)
        del folder['a']
        self.assertEqual(len(folder), 1)

    def test__contains__(self):
        folder = self._makeOne({'a': 1, 'b': 2})
        self.assertTrue('a' in folder)
        self.assertFalse('c' in folder)

    def test___nonzero__(self):
        folder = self._makeOne()
        self.assertTrue(folder)

    def test___setitem__nonstring(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.__setitem__, None, None)

    def test___setitem__8bitstring(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.__setitem__, b'\xff', None)

    def test___setitem__empty(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.__setitem__, '', None)

    def test___setitem__(self):
        from substanced.interfaces import IObjectEvent
        from substanced.interfaces import IObjectWillBeAdded
        from substanced.interfaces import IObjectAdded
        events = []
        def listener(event, obj, container):
            events.append(event)
        self._registerEventListener(listener, IObjectEvent)
        dummy = DummyModel()
        folder = self._makeOne()
        self.assertEqual(folder._num_objects(), 0)
        folder['a'] = dummy
        self.assertEqual(folder._num_objects(), 1)
        self.assertEqual(len(events), 2)
        self.assertTrue(IObjectWillBeAdded.providedBy(events[0]))
        self.assertEqual(events[0].object, dummy)
        self.assertEqual(events[0].parent, folder)
        self.assertEqual(events[0].name, 'a')
        self.assertTrue(IObjectAdded.providedBy(events[1]))
        self.assertEqual(events[1].object, dummy)
        self.assertEqual(events[1].parent, folder)
        self.assertEqual(events[1].name, 'a')
        self.assertEqual(folder['a'], dummy)

    def test_validate_name_non_string(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.validate_name, object())

    def test_validate_name_empty_string(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.validate_name, '')

    def test_validate_name_non_decdable_string(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.validate_name, b'\x80')

    def test_validate_name_reserved(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.validate_name, 'foo',
                                      reserved_names=['foo', 'bar'])

    def test_validate_name_startswith_goggles(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.validate_name, '@@foo')

    def test_validate_name_startswith_slash(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.validate_name, '/foo')

    def test_validate_name_endswith_slash(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.validate_name, 'foo/')

    def test_validate_name_with_slash(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.validate_name, 'foo/bar')

    def test_validate_name_ok(self):
        folder = self._makeOne()
        self.assertEqual(folder.validate_name('foo'), 'foo')

    def test_add_name_wrongtype(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.add, 1, 'foo')

    def test_add_name_empty(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.add, '', 'foo')

    def test_add_reserved_name(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.add, 'foo', None,
                          reserved_names=('foo',))

    def test_add_with_slash_in_name(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.add, '/abc', None)

    def test_add_begins_with_atat(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.add, '@@abc', None)

    def test_check_name(self):
        folder = self._makeOne()
        self.assertRaises(ValueError, folder.check_name, '@@abc')

    def test_add_send_events(self):
        from substanced.interfaces import IObjectEvent
        from substanced.interfaces import IObjectWillBeAdded
        from substanced.interfaces import IObjectAdded
        events = []
        def listener(event, obj, container):
            events.append(event)
        self._registerEventListener(listener, IObjectEvent)
        dummy = DummyModel()
        folder = self._makeOne()
        self.assertEqual(folder._num_objects(), 0)
        folder.add('a', dummy, send_events=True)
        self.assertEqual(folder._num_objects(), 1)
        self.assertEqual(len(events), 2)
        self.assertTrue(IObjectWillBeAdded.providedBy(events[0]))
        self.assertEqual(events[0].object, dummy)
        self.assertEqual(events[0].parent, folder)
        self.assertEqual(events[0].name, 'a')
        self.assertTrue(IObjectAdded.providedBy(events[1]))
        self.assertEqual(events[1].object, dummy)
        self.assertEqual(events[1].parent, folder)
        self.assertEqual(events[1].name, 'a')
        self.assertEqual(folder['a'], dummy)

    def test_add_suppress_events(self):
        from substanced.interfaces import IObjectEvent
        events = []
        def listener(event, obj, container):
            events.append(event) #pragma NO COVER
        self._registerEventListener(listener, IObjectEvent)
        dummy = DummyModel()
        folder = self._makeOne()
        self.assertEqual(folder._num_objects(), 0)
        folder.add('a', dummy, send_events=False)
        self.assertEqual(folder._num_objects(), 1)
        self.assertEqual(len(events), 0)
        self.assertEqual(folder['a'], dummy)

    def test_add_with_order_appends_name_and_oid(self):
        folder = self._makeOne()
        folder.set_order([])
        folder.add('a', DummyModel())
        self.assertEqual(folder._order, ('a',))
        self.assertEqual(folder._order_oids, (1,))
        folder.add('b', DummyModel())
        self.assertEqual(folder._order, ('a', 'b'))
        self.assertEqual(folder._order_oids, (1, 1))

    def test_add_with_object_has_parent(self):
        folder = self._makeOne()
        objectmap = DummyObjectMap()
        folder.__objectmap__ = objectmap
        site = self._makeSite()
        a = site['a'] = DummyModel()
        self.assertRaises(ValueError, folder.add, 'a', a)

    def test_add_with_objectmap(self):
        folder = self._makeOne()
        objectmap = DummyObjectMap()
        folder.__objectmap__ = objectmap
        a = DummyModel()
        folder.add('a', a)
        self.assertEqual(objectmap.added, [(a, ('', 'a'))])

    def test_add_with_objectmap_object_has_children(self):
        from substanced.interfaces import IFolder
        folder = self._makeOne()
        objectmap = DummyObjectMap()
        folder.__objectmap__ = objectmap
        one = testing.DummyModel(__provides__=IFolder)
        two = testing.DummyModel()
        one['two'] = two
        folder.add('one', one)
        self.assertEqual(
            objectmap.added,
            [(two, ('', 'one', 'two')), (one, ('', 'one'))]
        )

    def test_add_with_objectmap_object_has_children_object_has_no_name(self):
        from substanced.interfaces import IFolder
        folder = self._makeOne()
        objectmap = DummyObjectMap()
        folder.__objectmap__ = objectmap
        one = testing.DummyModel(__provides__=IFolder)
        two = testing.DummyModel()
        one['two'] = two
        del one.__name__
        folder.add('one', one)
        self.assertEqual(
            objectmap.added,
            [(two, ('', 'one', 'two')), (one, ('', 'one'))]
        )

    def test_add_with_objectmap_object_has_children_not_adding_to_root(self):
        from substanced.interfaces import IFolder
        folder = self._makeOne()
        objectmap = DummyObjectMap()
        site = self._makeSite(objectmap)
        site['folder'] = folder
        one = testing.DummyModel(__provides__=IFolder)
        two = testing.DummyModel()
        one['two'] = two
        folder.add('one', one)
        self.assertEqual(
            objectmap.added,
            [(two, ('', 'folder', 'one', 'two')), (one, ('', 'folder', 'one'))]
        )

    def test___setitem__exists(self):
        from .. import FolderKeyError
        dummy = DummyModel()
        folder = self._makeOne({'a': dummy})
        self.assertEqual(folder._num_objects(), 1)
        self.assertRaises(FolderKeyError, folder.__setitem__, 'a', dummy)
        self.assertEqual(folder._num_objects(), 1)

    def test___delitem__(self):
        from substanced.interfaces import IObjectEvent
        from substanced.interfaces import IObjectRemoved
        from substanced.interfaces import IObjectWillBeRemoved
        events = []
        def listener(event, obj, container):
            events.append(event)
        self._registerEventListener(listener, IObjectEvent)
        dummy = DummyModel()
        dummy.__parent__ = None
        dummy.__name__ = None
        folder = self._makeOne({'a': dummy})
        self.assertEqual(folder._num_objects(), 1)
        del folder['a']
        self.assertEqual(folder._num_objects(), 0)
        self.assertEqual(len(events), 2)
        self.assertTrue(IObjectWillBeRemoved.providedBy(events[0]))
        self.assertTrue(IObjectRemoved.providedBy(events[1]))
        self.assertEqual(events[0].object, dummy)
        self.assertEqual(events[0].parent, folder)
        self.assertEqual(events[0].name, 'a')
        self.assertEqual(events[1].object, dummy)
        self.assertEqual(events[1].parent, folder)
        self.assertEqual(events[1].name, 'a')
        self.assertFalse(hasattr(dummy, '__parent__'))
        self.assertFalse(hasattr(dummy, '__name__'))

    def test_remove_miss(self):
        folder = self._makeOne()
        self.assertRaises(KeyError, folder.remove, "nonesuch")

    def test_remove_broken(self):
        from ZODB.interfaces import IBroken
        from zope.interface import implementer
        from substanced import util

        @implementer(IBroken)
        class Broken(object):

            def __init__(self):
                self.__Broken_state__ = dict(__name__="name",
                        __parent__="parent")

        resource = Broken()
        folder = self._makeOne({'broken': resource})
        result = folder.remove('broken')
        self.assertTrue(isinstance(result, util.BrokenWrapper))
        self.assertTrue('broken' not in folder)

    def test_remove_returns_object(self):
        dummy = DummyModel()
        dummy.__parent__ = None
        dummy.__name__ = None
        folder = self._makeOne({'a': dummy})
        self.assertTrue(folder.remove("a") is dummy)

    def test_remove_send_events(self):
        from substanced.interfaces import IObjectEvent
        from substanced.interfaces import IObjectRemoved
        from substanced.interfaces import IObjectWillBeRemoved
        events = []
        def listener(event, obj, container):
            events.append(event)
        self._registerEventListener(listener, IObjectEvent)
        dummy = DummyModel()
        dummy.__parent__ = None
        dummy.__name__ = None
        folder = self._makeOne({'a': dummy})
        self.assertEqual(folder._num_objects(), 1)
        folder.remove('a', send_events=True)
        self.assertEqual(folder._num_objects(), 0)
        self.assertEqual(len(events), 2)
        self.assertTrue(IObjectWillBeRemoved.providedBy(events[0]))
        self.assertTrue(IObjectRemoved.providedBy(events[1]))
        self.assertEqual(events[0].object, dummy)
        self.assertEqual(events[0].parent, folder)
        self.assertEqual(events[0].name, 'a')
        self.assertFalse(events[0].moving)
        self.assertEqual(events[1].object, dummy)
        self.assertEqual(events[1].parent, folder)
        self.assertEqual(events[1].name, 'a')
        self.assertFalse(events[1].moving)

        self.assertFalse(hasattr(dummy, '__parent__'))
        self.assertFalse(hasattr(dummy, '__name__'))

    def test_remove_suppress_events(self):
        from substanced.interfaces import IObjectEvent
        events = []
        def listener(event, obj, container):
            events.append(event) #pragma NO COVER
        self._registerEventListener(listener, IObjectEvent)
        dummy = DummyModel()
        dummy.__parent__ = None
        dummy.__name__ = None
        folder = self._makeOne({'a': dummy})
        self.assertEqual(folder._num_objects(), 1)
        folder.remove('a', send_events=False)
        self.assertEqual(folder._num_objects(), 0)
        self.assertEqual(len(events), 0)
        self.assertFalse(hasattr(dummy, '__parent__'))
        self.assertFalse(hasattr(dummy, '__name__'))

    def test_remove_moving(self):
        from substanced.interfaces import IObjectEvent
        from substanced.interfaces import IObjectRemoved
        from substanced.interfaces import IObjectWillBeRemoved
        events = []
        def listener(event, obj, container):
            events.append(event) #pragma NO COVER
        self._registerEventListener(listener, IObjectEvent)
        dummy = DummyModel()
        dummy.__parent__ = None
        dummy.__name__ = None
        folder = self._makeOne({'a': dummy})
        self.assertEqual(folder._num_objects(), 1)
        folder.remove('a', moving=True)
        self.assertEqual(folder._num_objects(), 0)
        self.assertFalse(hasattr(dummy, '__parent__'))
        self.assertFalse(hasattr(dummy, '__name__'))
        self.assertEqual(len(events), 2)
        self.assertTrue(IObjectWillBeRemoved.providedBy(events[0]))
        self.assertTrue(IObjectRemoved.providedBy(events[1]))
        self.assertEqual(events[0].object, dummy)
        self.assertEqual(events[0].parent, folder)
        self.assertEqual(events[0].name, 'a')
        self.assertTrue(events[0].moving)
        self.assertEqual(events[1].object, dummy)
        self.assertEqual(events[1].parent, folder)
        self.assertEqual(events[1].name, 'a')
        self.assertTrue(events[1].moving)

    def test_remove_with_objectmap(self):
        dummy = DummyModel()
        dummy.__parent__ = None
        dummy.__name__ = None
        dummy.__oid__ = 1
        folder = self._makeOne({'a': dummy})
        objectmap = DummyObjectMap()
        folder.__objectmap__ = objectmap
        folder.remove("a")
        self.assertEqual(objectmap.removed, [1])
        self.assertFalse(objectmap.moving)

    def test_remove_with_objectmap_moving(self):
        dummy = DummyModel()
        dummy.__parent__ = None
        dummy.__name__ = None
        dummy.__oid__ = 1
        folder = self._makeOne({'a': dummy})
        objectmap = DummyObjectMap()
        folder.__objectmap__ = objectmap
        folder.remove("a", moving=True)
        self.assertEqual(objectmap.removed, [1])
        self.assertTrue(objectmap.moving)

    def test_move_no_newname(self):
        folder = self._makeOne()
        other = self._makeOne()
        model = DummyModel()
        folder['a'] = model
        folder.move('a', other)
        self.assertEqual(other['a'], model)
        self.assertEqual(other['a'].__name__, 'a')
        self.assertEqual(other['a'].__parent__, other)
        self.assertFalse('a' in folder)

    def test_move_newname(self):
        folder = self._makeOne()
        other = self._makeOne()
        model = DummyModel()
        folder['a'] = model
        folder.move('a', other, 'b')
        self.assertEqual(other['b'], model)
        self.assertEqual(other['b'].__name__, 'b')
        self.assertEqual(other['b'].__parent__, other)
        self.assertFalse('a' in other)
        self.assertFalse('a' in folder)

    def test_move_is_service(self):
        from ...interfaces import IService
        folder = self._makeOne()
        other = self._makeOne()
        model = DummyModel()
        model.__provides__ = IService
        folder['a'] = model
        folder.move('a', other)
        self.assertEqual(other['a'], model)
        self.assertTrue(IService.providedBy(other['a']))

    def test_copy_no_newname(self):
        folder = self._makeOne()
        other = self._makeOne()
        model = testing.DummyResource()
        folder['a'] = model
        folder.copy('a', other)
        self.assertEqual(other['a'].__name__, 'a')
        self.assertEqual(other['a'].__parent__, other)
        self.assertTrue('a' in folder)

    def test_copy_newname(self):
        folder = self._makeOne()
        other = self._makeOne()
        model = testing.DummyResource()
        folder['a'] = model
        folder.copy('a', other, 'b')
        self.assertEqual(other['b'].__name__, 'b')
        self.assertEqual(other['b'].__parent__, other)
        self.assertFalse('a' in other)
        self.assertTrue('a' in folder)

    def test_rename(self):
        folder = self._makeOne()
        model = DummyModel()
        folder['a'] = model
        folder.rename('a', 'b')
        self.assertEqual(folder['b'], model)
        self.assertEqual(folder['b'].__name__, 'b')
        self.assertEqual(folder['b'].__parent__, folder)
        self.assertFalse('a' in folder)

    def test_remove_with_order_removes_name(self):
        folder = self._makeOne()
        folder['a'] = DummyModel()
        folder['b'] = DummyModel()
        folder.set_order(['a', 'b'])
        folder.remove('a')
        self.assertEqual(folder._order, ('b',))
        self.assertEqual(folder._order_oids, (1,))

    def test_replace_existing(self):
        folder = self._makeOne()
        other = self._makeOne()
        model = DummyModel()
        folder['a'] = model
        folder.replace('a', other)
        self.assertEqual(folder['a'], other)
        self.assertEqual(other.__name__, 'a')
        self.assertEqual(other.__parent__, folder)

    def test_replace_nonexisting(self):
        folder = self._makeOne()
        other = self._makeOne()
        folder.replace('a', other)
        self.assertEqual(folder['a'], other)
        self.assertEqual(other.__name__, 'a')
        self.assertEqual(other.__parent__, folder)

    def test_load_with_registry(self):
        registry = self.config.registry
        folder = self._makeOne()
        one = testing.DummyResource()
        two = testing.DummyResource()
        folder['a'] = one
        result = []
        folder.remove = lambda *arg, **kw: result.append(('removed', kw))
        folder.add = lambda *arg, **kw: result.append(('added', kw))
        folder.load('a', two, registry=registry)
        self.assertEqual(
            result,
            [
                ('removed', {'loading':True}),
                ('added', {'loading':True, 'registry':registry}),
                ])

    def test_load_no_registry(self):
        registry = self.config.registry
        folder = self._makeOne()
        one = testing.DummyResource()
        two = testing.DummyResource()
        folder['a'] = one
        result = []
        folder.remove = lambda *arg, **kw: result.append(('removed', kw))
        folder.add = lambda *arg, **kw: result.append(('added', kw))
        folder.load('a', two)
        self.assertEqual(
            result,
            [
                ('removed', {'loading':True}),
                ('added', {'loading':True, 'registry':registry}),
                ])

    def test_pop_success(self):
        from substanced.interfaces import IObjectEvent
        from substanced.interfaces import IObjectRemoved
        from substanced.interfaces import IObjectWillBeRemoved
        dummy = DummyModel()
        dummy.__parent__ = None
        dummy.__name__ = None
        events = []
        def listener(event, obj, container):
            events.append(event)
        self._registerEventListener(listener, IObjectEvent)
        folder = self._makeOne({'a': dummy})
        result = folder.pop('a')
        self.assertEqual(result, dummy)
        self.assertEqual(folder._num_objects(), 0)
        self.assertEqual(len(events), 2)
        self.assertTrue(IObjectWillBeRemoved.providedBy(events[0]))
        self.assertTrue(IObjectRemoved.providedBy(events[1]))
        self.assertEqual(events[0].object, dummy)
        self.assertEqual(events[0].parent, folder)
        self.assertEqual(events[0].name, 'a')
        self.assertEqual(events[1].object, dummy)
        self.assertEqual(events[1].parent, folder)
        self.assertEqual(events[1].name, 'a')
        self.assertFalse(hasattr(dummy, '__parent__'))
        self.assertFalse(hasattr(dummy, '__name__'))

    def test_pop_fail_nodefault(self):
        folder = self._makeOne()
        self.assertRaises(KeyError, folder.pop, 'nonesuch')

    def test_pop_fail_withdefault(self):
        folder = self._makeOne()
        result = folder.pop('a', 123)
        self.assertEqual(result, 123)

    def test_repr(self):
        folder = self._makeOne()
        folder.__name__ = 'thefolder'
        r = repr(folder)
        self.assertTrue(
            r.startswith("<substanced.folder.Folder object 'thefolder"))
        self.assertTrue(r.endswith('>'))

    def test_str(self):
        folder = self._makeOne()
        folder.__name__ = 'thefolder'
        r = str(folder)
        self.assertTrue(
            r.startswith("<substanced.folder.Folder object 'thefolder"))
        self.assertTrue(r.endswith('>'))

    def test_unresolveable_unicode_setitem(self):
        from substanced._compat import u
        name = u(b'La Pe\xc3\xb1a', 'utf-8').encode('latin-1')
        folder = self._makeOne()
        self.assertRaises(ValueError,
                          folder.__setitem__, name, DummyModel())

    def test_resolveable_unicode_setitem(self):
        name = 'La'
        folder = self._makeOne()
        folder[name] = DummyModel()
        self.assertTrue(folder.get(name))

    def test_unresolveable_unicode_getitem(self):
        from substanced._compat import u
        name = u(b'La Pe\xc3\xb1a', 'utf-8').encode('latin-1')
        folder = self._makeOne()
        self.assertRaises(UnicodeDecodeError, folder.__getitem__, name)

    def test_resolveable_unicode_getitem(self):
        name = 'La'
        folder = self._makeOne()
        folder[name] = DummyModel()
        self.assertTrue(folder[name])

    def test_get_broken(self):
        from ZODB.interfaces import IBroken
        from zope.interface import implementer

        @implementer(IBroken)
        class Broken(object):

            def __init__(self):
                pass

        folder = self._makeOne()
        folder['broken'] = Broken()
        result = folder.get('broken')
        from substanced import util
        self.assertTrue(isinstance(result, util.BrokenWrapper))

    def test_find_service_missing(self):
        inst = self._makeOne()
        self.assertEqual(inst.find_service('abc'), None)

    def test_find_service_found(self):
        from ...interfaces import IService
        inst = self._makeOne()
        inst2 = self._makeOne()
        inst2.__provides__ = IService
        inst.add('inst2', inst2)
        self.assertEqual(inst.find_service('inst2'), inst2)

    def test_find_services_missing(self):
        inst = self._makeOne()
        self.assertEqual(inst.find_services('abc'), [])

    def test_find_services_found(self):
        from ...interfaces import IService
        inst = self._makeOne()
        inst2 = self._makeOne()
        inst2.__provides__ = IService
        inst.add('inst2', inst2)
        self.assertEqual(inst.find_services('inst2'), [inst2])

    def test_add_service(self):
        from ...interfaces import IService
        inst = self._makeOne()
        foo = testing.DummyResource()
        class IFoo(Interface):
            pass
        directlyProvides(foo, IFoo)
        inst.add_service('foo', foo)
        self.assertEqual(inst['foo'], foo)
        self.assertTrue(IService.providedBy(foo))
        self.assertTrue(IFoo.providedBy(foo))

    def test_add_service_withregistry(self):
        from ...interfaces import IService
        inst = self._makeOne()
        foo = testing.DummyResource()
        inst.add_service('foo', foo, registry=self.config.registry)
        self.assertEqual(inst['foo'], foo)
        self.assertTrue(IService.providedBy(foo))

    def test__notify_no_registry(self):
        def f(t, n):
            self.assertEqual(t, (event, event.object, inst))
            self.assertEqual(n, None)
        self.config.registry.subscribers = f
        inst = self._makeOne()
        event = DummyModel()
        event.object = DummyModel()
        inst._notify(event)

    def test_ordered_folder_oids(self):
        model1 = DummyModel()
        model2 = DummyModel()
        model2.__oid__ = 2
        folder = self._makeOne({'a': model1, 'b': model2})
        folder.set_order(['b', 'a'])
        self.assertEqual(folder._order_oids, (2, 1))

    def test_reorder_folder(self):
        model1 = DummyModel()
        model2 = DummyModel()
        model3 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2, 'c': model3})
        folder.set_order(['a', 'b', 'c'], reorderable=True)
        folder.reorder(['b', 'c'], 'a')
        self.assertEqual(list(folder), ['b', 'c', 'a'])

    def test_reorder_folder_item_before_itself(self):
        model1 = DummyModel(1)
        model2 = DummyModel(2)
        model3 = DummyModel(3)
        model4 = DummyModel(4)
        folder = self._makeOne({'a': model1, 'b': model2, 'c': model3,
                                'd':model4})
        folder.set_order(['a', 'b', 'c', 'd'], reorderable=True)
        folder.reorder(['d', 'a', 'b'], 'b')
        self.assertEqual(list(folder), ['d', 'a', 'b', 'c'])

    def test_reorder_folder_item_before_itself_2(self):
        model1 = DummyModel(1)
        model2 = DummyModel(2)
        model3 = DummyModel(3)
        model4 = DummyModel(4)
        folder = self._makeOne({'a': model1, 'b': model2, 'c': model3,
                                'd':model4})
        folder.set_order(['a', 'b', 'c', 'd'], reorderable=True)
        folder.reorder(['b', 'a', 'c'], 'a')
        self.assertEqual(list(folder), ['b', 'a', 'c', 'd'])

    def test_reorder_folder_afterlast(self):
        model1 = DummyModel()
        model2 = DummyModel()
        model3 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2, 'c': model3})
        folder.set_order(['a', 'b', 'c'], reorderable=True)
        folder.reorder(['a', 'b'], None)
        self.assertEqual(list(folder), ['c', 'a', 'b'])

    def test_reorder_folder_no_such_before(self):
        model1 = DummyModel()
        model2 = DummyModel()
        model3 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2, 'c': model3})
        folder.set_order(['a', 'b', 'c'], reorderable=True)
        self.assertRaises(KeyError,
               folder.reorder, ['a', 'b'], 'NOSUCH')

    def test_reorder_folder_no_such_item(self):
        model1 = DummyModel()
        model2 = DummyModel()
        model3 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2, 'c': model3})
        folder.set_order(['a', 'b', 'c'], reorderable=True)
        self.assertRaises(KeyError,
               folder.reorder, ['a', 'z'], 'c')

    def test_reorder_folder_repeated_name(self):
        model1 = DummyModel(1)
        model2 = DummyModel(2)
        model3 = DummyModel(3)
        model4 = DummyModel(4)
        folder = self._makeOne({'a': model1, 'b': model2, 'c': model3,
                                'd':model4})
        folder.set_order(['a', 'b', 'c', 'd'], reorderable=True)
        self.assertRaises(ValueError, folder.reorder, ['b', 'b'], 'a')

    def test_reorder_folder_non_reorderable(self):
        model1 = DummyModel()
        model2 = DummyModel()
        model3 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2, 'c': model3})
        folder.set_order(['a', 'b', 'c'], reorderable=False)
        self.assertRaises(ValueError, folder.reorder, ['b', 'c'], 'a')

    def test_order_property_get_set_and_del(self):
        model1 = DummyModel()
        model2 = DummyModel()
        model3 = DummyModel()
        folder = self._makeOne({'a': model1, 'b': model2, 'c': model3})
        self.assertEqual(list(folder.order), ['a', 'b', 'c'])
        folder.order = ['c', 'b', 'a']
        self.assertEqual(list(folder.order), ['c', 'b', 'a'])
        del folder.order
        self.assertEqual(list(folder.order), ['a', 'b', 'c'])



class TestSequentialAutoNamingFolder(unittest.TestCase):
    def _makeOne(self, d=None, autoname_length=None, autoname_start=None):
        from .. import SequentialAutoNamingFolder
        return SequentialAutoNamingFolder(
            d,
            autoname_length=autoname_length,
            autoname_start=autoname_start
            )

    def test_next_name_empty(self):
        inst = self._makeOne()
        self.assertEqual(inst.next_name(None), '0'.zfill(7))

    def test_next_name_nonempty(self):
        ob = DummyModel()
        inst = self._makeOne({'000000000':ob})
        self.assertEqual(inst.next_name(None), '1'.zfill(7))

    def test_next_name_alternate_autoname_length(self):
        inst = self._makeOne(autoname_length=5)
        self.assertEqual(inst.next_name(None), '0'.zfill(5))

    def test_next_name_alternate_autoname_start(self):
        inst = self._makeOne(autoname_start=0)
        self.assertEqual(inst.next_name(None), '1'.zfill(7))

    def test_next_name_empty_autoname_reset(self):
        inst = self._makeOne()
        inst._autoname_reset = True
        self.assertEqual(inst.next_name(None), '0'.zfill(7))
        self.assertFalse(inst._autoname_reset)

    def test_next_name_nonempty_autoname_reset(self):
        ob = DummyModel()
        inst = self._makeOne({'0000005':ob})
        inst._autoname_reset = True
        self.assertEqual(inst.next_name(None), '0'.zfill(7))
        self.assertFalse(inst._autoname_reset)

    def test_add_not_intifiable(self):
        ob = DummyModel()
        inst = self._makeOne()
        self.assertRaises(ValueError, inst.add, 'abcdef', ob)

    def test_add_intifiable(self):
        ob = DummyModel()
        inst = self._makeOne()
        inst.add('1', ob)
        self.assertTrue('1'.zfill(7) in inst)

    def test_add_next(self):
        ob = DummyModel()
        inst = self._makeOne()
        result = inst.add_next(ob)
        name = '0'.zfill(7)
        self.assertEqual(ob.__name__, name)
        self.assertTrue(name in inst)
        self.assertEqual(name, result)

class TestRandomAutoNamingFolder(unittest.TestCase):
    def _makeOne(self, d=None, autoname_length=None):
        from .. import RandomAutoNamingFolder
        return RandomAutoNamingFolder(d, autoname_length=autoname_length)

    def test_next_name_doesntexist(self):
        inst = self._makeOne()
        inst._randomchoice = lambda *arg: 'x'
        self.assertEqual(inst.next_name(None), 'x' * 7)

    def test_next_name_exists(self):
        inst = self._makeOne()
        L = ['x'] * 7
        L.extend(['y'] * 7)
        def choice(vals):
            v = L.pop()
            return v
        inst._randomchoice = choice
        self.assertEqual(inst.next_name(None), 'y' * 7)

    def test_next_name_alternate_length(self):
        inst = self._makeOne(autoname_length=5)
        self.assertEqual(len(inst.next_name(None)), 5)

    def test_add_next(self):
        ob = DummyModel()
        inst = self._makeOne()
        result = inst.add_next(ob)
        self.assertEqual(ob.__name__, result)
        self.assertTrue(result in inst)
        self.assertEqual(len(result), 7)

class TestCopyHook(unittest.TestCase):
    def _makeOne(self, context):
        from .. import CopyHook
        return CopyHook(context)

    def test_nonpersistent(self):
        from zope.copy.interfaces import ResumeCopy
        inst = self._makeOne({})
        self.assertRaises(ResumeCopy, inst, None, None)

    def test_persistent_not_child(self):
        from persistent import Persistent
        class Resource(Persistent):
            pass
        child = Resource()
        child.__parent__ = None
        parent = Resource()
        parent.__parent__ = None
        inst = self._makeOne(child)
        self.assertEqual(inst(parent, None), child)

    def test_persistent_is_child(self):
        from zope.copy.interfaces import ResumeCopy
        from persistent import Persistent
        class Resource(Persistent):
            pass
        parent = Resource()
        parent.__parent__ = None
        child = Resource()
        child.__parent__ = parent
        inst = self._makeOne(child)
        self.assertRaises(ResumeCopy, inst, parent, None)

class DummyModel(object):
    def __init__(self, oid=1):
        self.__oid__ = oid

class DummyObjectMap(object):
    def __init__(self):
        self.added = []
        self.removed = []
        self.moving = False

    def add(self, obj, path, duplicating=False, moving=False):
        self.added.append((obj, path))
        objectid = getattr(obj, '__oid__', None)
        if objectid is None:
            objectid = 1
            obj.__oid__ = objectid
        return objectid

    def remove(self, objectid, moving=False):
        self.moving = moving
        self.removed.append(objectid)
        return [objectid]

########NEW FILE########
__FILENAME__ = test_views
import sys
import colander
import unittest

from pyramid import testing
from pyramid.httpexceptions import HTTPFound
import mock

from substanced._compat import u
_FOOBAR = u('foobar')

class Test_name_validator(unittest.TestCase):
    def _callFUT(self, node, kw):
        from ..views import name_validator
        return name_validator(node, kw)

    def _makeKw(self, exc=None):
        request = testing.DummyRequest()
        request.context = DummyContainer(exc)
        return dict(request=request)

    def test_it_exception(self):
        exc = KeyError('wrong')
        kw = self._makeKw(exc)
        node = object()
        v = self._callFUT(node, kw)
        self.assertRaises(colander.Invalid, v, node, 'abc')

    def test_it_no_exception(self):
        kw = self._makeKw()
        node = object()
        v = self._callFUT(node, kw)
        result = v(node, 'abc')
        self.assertEqual(result, None)

class Test_rename_duplicated_resource(unittest.TestCase):
    def _callFUT(self, context, name):
        from ..views import rename_duplicated_resource
        return rename_duplicated_resource(context, name)
        
    def test_rename_first(self):
        context = testing.DummyResource()
        new_name = self._callFUT(context, 'foobar')
        self.assertEqual(new_name, 'foobar')

    def test_rename_second(self):
        context = testing.DummyResource()
        context['foobar'] = testing.DummyResource()
        new_name = self._callFUT(context, 'foobar')
        self.assertEqual(new_name, 'foobar-1')

    def test_rename_twentyfirst(self):
        context = testing.DummyResource()
        context['foobar-21'] = testing.DummyResource()
        new_name = self._callFUT(context, 'foobar-21')
        self.assertEqual(new_name, 'foobar-22')

    def test_rename_multiple_dashes(self):
        context = testing.DummyResource()
        context['foo-bar'] = testing.DummyResource()
        new_name = self._callFUT(context, 'foo-bar')
        self.assertEqual(new_name, 'foo-bar-1')

    def test_rename_take_fisrt_available(self):
        context = testing.DummyResource()
        context['foobar'] = testing.DummyResource()
        context['foobar-1'] = testing.DummyResource()
        context['foobar-2'] = testing.DummyResource()
        context['foobar-4'] = testing.DummyResource()
        new_name = self._callFUT(context, 'foobar')
        self.assertEqual(new_name, 'foobar-3')

class TestAddFolderView(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..views import AddFolderView
        return AddFolderView(context, request)

    def _makeRequest(self, **kw):
        request = testing.DummyRequest()
        request.registry.content = DummyContent(**kw)
        request.sdiapi = DummySDIAPI()
        return request

    def test_add_success(self):
        resource = testing.DummyResource()
        request = self._makeRequest(Folder=resource)
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        resp = inst.add_success({'name': 'name'})
        self.assertEqual(context['name'], resource)
        self.assertEqual(resp.location, '/mgmt_path')

class TestFolderContents(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from ..views import FolderContents
        return FolderContents(context, request)

    def _makeRequest(self, **kw):
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent(**kw)
        return request

    def test_get_buttons_is_None(self):
        context = testing.DummyResource()
        request = self._makeRequest(buttons=None)
        inst = self._makeOne(context, request)
        result = inst.get_buttons()
        self.assertEqual(result, [])

    def test_get_buttons_is_clbl(self):
        context = testing.DummyResource()
        def sdi_buttons(context, request, default_buttons):
            return 'abc'
        request = self._makeRequest(buttons=sdi_buttons)
        inst = self._makeOne(context, request)
        result = inst.get_buttons()
        self.assertEqual(result, 'abc')

    def test_get_columns_custom_columns_is_None(self):
        context = testing.DummyResource()
        request = self._makeRequest(columns=None)
        inst = self._makeOne(context, request)
        result = inst.get_columns(None)
        self.assertEqual(result, [])

    def test_get_columns_custom_columns_doesnt_exist(self):
        context = testing.DummyResource()
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        result = inst.get_columns(None)
        self.assertEqual(len(result), 1)
        
    def test_get_columns_custom_columns_exists(self):
        context = testing.DummyResource()
        def columns(context, subobject, request, columns):
            self.assertEqual(len(columns), 1)
            return ['abc', '123', 'def']
        request = self._makeRequest(columns=columns)
        inst = self._makeOne(context, request)
        result = inst.get_columns(None)
        self.assertEqual(len(result), 3)

    def test__column_headers_for_non_sortable_columns(self):
        context = testing.DummyResource(is_ordered=lambda: False)
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        columns = [
            {'name': 'Col 1',
             'value': 'col1',
             'sorter':True},
            {'name': 'Col 2',
             'value': 'col2'}
            ]
        result = inst._column_headers(columns)
        self.assertEqual(len(result), 2)

        col = result[0]
        self.assertEqual(col['id'], 'Col 1')
        self.assertEqual(col['field'], 'Col 1')
        self.assertEqual(col['name'], 'Col 1')
        self.assertEqual(col['width'], 120)
        self.assertEqual(col['formatterName'], '')
        self.assertEqual(col['cssClass'], 'cell-Col-1')
        self.assertEqual(col['sortable'], True)

        col = result[1]
        self.assertEqual(col['id'], 'Col 2')
        self.assertEqual(col['field'], 'Col 2')
        self.assertEqual(col['name'], 'Col 2')
        self.assertEqual(col['width'], 120)
        self.assertEqual(col['formatterName'], '')
        self.assertEqual(col['cssClass'], 'cell-Col-2')
        self.assertEqual(col['sortable'], False)

    def test__column_headers_sortable_false_for_ordered_folder(self):
        context = testing.DummyResource(is_ordered=lambda: True)
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        columns = [
                {'name': 'Col 1',
                 'value': 'col1',
                 'sorter': True},
                {'name': 'Col 2',
                 'value': 'col2',
                 'sorter': True}
                ]
        result = inst._column_headers(columns)
        self.assertEqual(len(result), 2)

        col = result[0]
        self.assertEqual(col['field'], 'Col 1')
        self.assertEqual(col['sortable'], False)

        col = result[1]
        self.assertEqual(col['field'], 'Col 2')
        self.assertEqual(col['sortable'], False)

    def test__column_headers_sortable_false_for_nonresortable(self):
        context = testing.DummyResource(is_ordered = lambda *arg: False)
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        columns = [
                {'name': 'Col 1',
                 'value': 'col1',
                 'sorter': True,
                 'resortable':False,},
                ]
        result = inst._column_headers(columns)
        self.assertEqual(len(result), 1)

        col = result[0]
        self.assertEqual(col['field'], 'Col 1')
        self.assertEqual(col['sortable'], False)

    def test__column_headers_no_custom(self):
        context = testing.DummyResource(is_ordered=lambda: False)
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        default_columns =  [
            {'name': 'Name',
             'value': 'myname',
             'formatter': 'icon_label_url',
             'sorter': True}
            ]
        result = inst._column_headers(default_columns)
        self.assertEqual(len(result), 1)
        self.assertEqual(
            result[0],
            {'minWidth': 120,
             'field': 'Name',
             'sortable': True,
             'name': 'Name',
             'width': 120,
             'formatterName': 'icon_label_url',
             'cssClass': 'cell-Name',
             'id': 'Name',
             'validatorName':'',
             'editorName':'',
             }
        )

    def test__column_headers_None(self):
        context = testing.DummyResource()
        context.is_ordered = lambda: False
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        result = inst._column_headers([])
        self.assertEqual(len(result), 0)

    def test__column_headers_cssClass(self):
        context = testing.DummyResource(is_ordered=lambda: False)
        request = self._makeRequest()

        inst = self._makeOne(context, request)
        columns = [
            {'name': 'Col 1',
             'value': 'col1',
             'sorter': True,
             'css_class': 'customClass'},
            {'name': 'Col 2',
             'value': 'col2',
             'sorter': True},
            {'name': 'Col 3',
             'value': 'col3',
             'sorter': True,
             'css_class': 'customClass1 customClass2'},
            ]
        result = inst._column_headers(columns)
        self.assertEqual(len(result), 3)
        self.assertEqual(result[0]['cssClass'], 'cell-Col-1 customClass')
        self.assertEqual(result[1]['cssClass'], 'cell-Col-2')
        self.assertEqual(
            result[2]['cssClass'], 'cell-Col-3 customClass1 customClass2')

    def test__sort_info_context_is_ordered(self):
        context = testing.DummyResource(
            is_ordered=lambda: True,
            sort=lambda resultset, **kw: resultset
            )
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        result = inst._sort_info([])
        self.assertEqual(result['column'], None)
        sorter = result['sorter']
        resultset = DummyResultSet([1])
        self.assertEqual(
            sorter(context, resultset, reverse=True, limit=1),
            resultset
            )
        self.assertEqual(result['column_name'], None)

    def test__sort_info_context_unordered_default_sort_column(self):
        context = testing.DummyResource(
            is_ordered=lambda: False,
            )
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        columns = [{'name':'col1'}, {'name':'col2', 'sorter':True}]
        result = inst._sort_info(columns)
        self.assertEqual(result['column'], columns[1])
        self.assertEqual(result['sorter'], True)
        self.assertEqual(result['column_name'], 'col2')

    def test__sort_info_context_unordered_nondefault_sort_column_exists(self):
        context = testing.DummyResource(
            is_ordered=lambda: False,
            )
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        columns = [{'name':'col1', 'sorter':'a'}, {'name':'col2', 'sorter':'b'}]
        result = inst._sort_info(columns, sort_column_name='col2')
        self.assertEqual(result['column'], columns[1])
        self.assertEqual(result['sorter'], 'b')
        self.assertEqual(result['column_name'], 'col2')

    def test__sort_info_context_unordered_nondefault_sort_column_notexist(self):
        context = testing.DummyResource(
            is_ordered=lambda: False,
            )
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        columns = [{'name':'col1', 'sorter':'a'}, {'name':'col2', 'sorter':'b'}]
        result = inst._sort_info(columns, sort_column_name='col3')
        self.assertEqual(result['column'], None)
        self.assertEqual(result['sorter'], None)
        self.assertEqual(result['column_name'], 'col3')
        
    def test__sort_info_context_unordered_default_sort_column_via_initial(self):
        context = testing.DummyResource(
            is_ordered=lambda: False,
            )
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        columns = [{'name':'col1', 'sorter':True},
                   {'name':'col2', 'sorter':True,
                    'initial_sort_column':True}]
        result = inst._sort_info(columns)
        self.assertEqual(result['column'], columns[1])
        self.assertEqual(result['sorter'], True)
        self.assertEqual(result['column_name'], 'col2')
        
    def test__folder_contents_columns_callable(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        request = self._makeRequest()
        context['catalogs'] = _makeCatalogs(oids=[1])
        result = testing.DummyResource()
        result.col1 = 'val1'
        result.col2 = 'val2'
        result.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap(result)
        def get_columns(folder, subobject, request, default_columns):
            self.assertEqual(len(default_columns), 1)
            return [{'name': 'Col 1',
                     'value': getattr(subobject, 'col1', None)},
                    {'name': 'Col 2',
                     'value': getattr(subobject, 'col2', None)}]
        inst = self._makeOne(context, request)
        request.registry.content = DummyContent(columns=get_columns)
        info = inst._folder_contents()
        length, records = info['length'], info['records']
        self.assertEqual(length, 1)
        self.assertEqual(len(records), 1)
        item = records[0]
        self.assertEqual(item['Col 1'], 'val1')
        self.assertEqual(item['Col 2'], 'val2')

    def test__folder_contents_columns_None(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        request = self._makeRequest()
        context['catalogs'] = _makeCatalogs(oids=[1])
        result = testing.DummyResource()
        result.col1 = 'val1'
        result.col2 = 'val2'
        result.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap(result)
        inst = self._makeOne(context, request)
        request.registry.content = DummyContent(columns=None)
        info = inst._folder_contents()
        length, records = info['length'], info['records']
        self.assertEqual(length, 1)
        self.assertEqual(len(records), 1)
        item = records[0]
        self.assertEqual(
            item,
            {'name': 'fred',
             'disable': [],
             'id': 'fred'}
            )

    def test__folder_contents_with_global_filter_value(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        request = self._makeRequest()
        context['catalogs'] = _makeCatalogs(oids=[1])
        result = testing.DummyResource()
        result.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap(result)
        inst = self._makeOne(context, request)
        request.registry.content = DummyContent()
        info = inst._folder_contents(filter_values=[('', 'abc')])
        length, records = info['length'], info['records']
        self.assertEqual(length, 1)
        self.assertEqual(len(records), 1)

    def test__folder_contents_with_global_filter_value_with_phrases(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        request = self._makeRequest()
        context['catalogs'] = _makeCatalogs(oids=[1])
        result = testing.DummyResource()
        result.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap(result)
        inst = self._makeOne(context, request)
        request.registry.content = DummyContent()
        info = inst._folder_contents(filter_values=[('', '"abc" def')])
        length, records = info['length'], info['records']
        self.assertEqual(length, 1)
        self.assertEqual(len(records), 1)
        
    def test__folder_contents_with_global_filter_value_multiple_words(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        request = self._makeRequest()
        context['catalogs'] = _makeCatalogs(oids=[1])
        result = testing.DummyResource()
        result.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap(result)
        inst = self._makeOne(context, request)
        request.registry.content = DummyContent()
        info = inst._folder_contents(filter_values=[('', 'abc def')])
        length, records = info['length'], info['records']
        self.assertEqual(length, 1)
        self.assertEqual(len(records), 1)

    def test__folder_contents_with_nonglobal_filter_value(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        request = self._makeRequest()
        context['catalogs'] = _makeCatalogs(oids=[1])
        result = testing.DummyResource()
        result.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap(result)
        inst = self._makeOne(context, request)
        content = DummyContent()
        def filt(ctx, val, q):
            self.assertEqual(ctx, context)
            self.assertEqual(val, 'woo')
            self.assertEqual(q.__class__, DummyIndex)
            return q
        def cols(*arg):
            return [{'name':'colname', 'filter':filt, 'value':'val'}]
        content.columns = cols
        request.registry.content = content
        info = inst._folder_contents(filter_values=[('colname', 'woo')])
        length, records = info['length'], info['records']
        self.assertEqual(length, 1)
        self.assertEqual(len(records), 1)
        
    def test__folder_contents_with_nonglobal__and_global_filter_values(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        request = self._makeRequest()
        context['catalogs'] = _makeCatalogs(oids=[1])
        result = testing.DummyResource()
        result.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap(result)
        inst = self._makeOne(context, request)
        def gtf(ctx, val, q):
            self.assertEqual(val, 'boo')
            q.gtf_called = True
            return q
        inst._global_text_filter = gtf
        content = DummyContent()
        def filt(ctx, val, q):
            self.assertTrue(q.gtf_called)
            self.assertEqual(ctx, context)
            self.assertEqual(val, 'woo')
            self.assertEqual(q.__class__, DummyIndex)
            return q
        def cols(*arg):
            return [{'name':'colname', 'filter':filt, 'value':'val'}]
        content.columns = cols
        request.registry.content = content
        info = inst._folder_contents(
            filter_values=[('', 'boo'), ('colname', 'woo')]
            )
        length, records = info['length'], info['records']
        self.assertEqual(length, 1)
        self.assertEqual(len(records), 1)

    def test__folder_contents_columns_initial_sort_reverse(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        request = self._makeRequest()
        context['catalogs'] = _makeCatalogs(oids=[1])
        result = testing.DummyResource()
        result.col1 = 'val1'
        result.col2 = 'val2'
        result.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap(result)
        inst = self._makeOne(context, request)
        def sorter(context, resultset, reverse, limit):
            self.assertTrue(reverse)
            return resultset
        def get_columns(folder, subobject, request, default_columns):
            self.assertEqual(len(default_columns), 1)
            return [{'name': 'Col 1',
                     'value': getattr(subobject, 'col1', None),
                     'sorter':sorter,
                     'initial_sort_reverse':True,}]
        request.registry.content = DummyContent(columns=get_columns)
        inst._folder_contents()
        
    def test__folder_contents_button_enabled_for_true(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        context['catalogs'] = _makeCatalogs(oids=[1])
        result = testing.DummyResource()
        result.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap(result)
        def sdi_buttons(contexr, request, default_buttons):
            return [{'type': 'single',
                     'buttons': [{'enabled_for': lambda x,y,z: True,
                                  'id': 'Button'}]}]
        request = self._makeRequest(buttons=sdi_buttons)
        inst = self._makeOne(context, request)
        folder_contents = inst._folder_contents()
        length, records = folder_contents['length'], folder_contents['records']
        self.assertEqual(length, 1)
        self.assertEqual(records[0]['disable'], [])

    def test__folder_contents_button_enabled_for_false(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        context['catalogs'] = _makeCatalogs(oids=[1])
        result = testing.DummyResource()
        result.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap(result)
        def sdi_buttons(context, request, default_buttons):
            return [{'type': 'single',
                     'buttons': [{'enabled_for': lambda x,y,z: False,
                                  'id': 'Button'}]}]
        request = self._makeRequest(buttons=sdi_buttons)
        inst = self._makeOne(context, request)
        folder_contents = inst._folder_contents()
        length, records = folder_contents['length'], folder_contents['records']
        self.assertEqual(length, 1)
        self.assertEqual(records[0]['disable'], ['Button'])

    def test__folder_contents_button_enabled_for_non_callable(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        context['catalogs'] = _makeCatalogs(oids=[1])
        result = testing.DummyResource()
        result.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap(result)
        def sdi_buttons(contexr, request, default_buttons):
            return [{'type': 'single',
                     'buttons': [{'enabled_for': 'not callable',
                                  'id': 'Button'}]}]
        request = self._makeRequest(buttons=sdi_buttons)
        inst = self._makeOne(context, request)
        folder_contents = inst._folder_contents()
        length, records = folder_contents['length'], folder_contents['records']
        self.assertEqual(length, 1)
        self.assertEqual(records[0]['disable'], [])

    def test_get_filter_values(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        request = self._makeRequest()
        request.params = DummyContent()
        request.params.items = lambda *arg: [
                ('filter.', 'abc'),
                ('filter.foo', 'def'),
                ('filter.bar', 'ghi'),
                ]
        inst = self._makeOne(context, request)
        result = inst.get_filter_values()
        self.assertEqual(result, [
                ('', 'abc'),
                ('foo', 'def'),
                ('bar', 'ghi'),
                ])
        
    def test_get_filter_values_with_None_and_empty(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        request = self._makeRequest()
        request.params = DummyContent()
        request.params.items = lambda *arg: [
                ('filter.', 'abc'),
                ('filter.foo', None),
                ('filter.bar', ''),
                ]
        inst = self._makeOne(context, request)
        result = inst.get_filter_values()
        self.assertEqual(result, [
                ('', 'abc'),
                ('bar', ''),
                ])
        
    def test__folder_contents_folder_is_ordered(self):
        from substanced.interfaces import IFolder
        context = DummyFolder(__provides__=IFolder)
        context.sort = lambda resultset, **kw: resultset
        request = self._makeRequest()
        context['catalogs'] = _makeCatalogs(oids=[1])
        result = testing.DummyResource()
        result.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap(result)
        inst = self._makeOne(context, request)
        context.is_ordered = lambda *arg: True
        context.oids = lambda *arg: [1, 2]
        request.registry.content = DummyContent()
        info = inst._folder_contents()
        length, records = info['length'], info['records']
        self.assertEqual(length, 1)
        self.assertEqual(len(records), 1)

    def test_show_no_columns(self):
        folder_contents = {
            'length':1,
            'sort_column_name':None,
            'show_checkbox_column':True,
            'sort_reverse':True,
            'columns':[],
            'records': [{
                    'name': 'the_name',
                    'name_url': 'http://foo.bar',
                    'id': 'the_name',
                    'name_icon': 'the_icon',
                    }]
            }
        context = testing.DummyResource()
        request = self._makeRequest(columns=None)
        inst = self._makeOne(context, request)
        inst._folder_contents = mock.Mock(
            return_value=folder_contents
            )
        inst.sdi_add_views = mock.Mock(return_value=('b',))
        context.is_reorderable = mock.Mock(return_value=False)
        context.is_ordered = mock.Mock(return_value=False)
        result = inst.show()
        self.assertTrue('slickgrid_wrapper_options' in result)
        slickgrid_wrapper_options = result['slickgrid_wrapper_options']
        self.assertTrue('slickgridOptions' in slickgrid_wrapper_options)
        self.assertEqual(
            slickgrid_wrapper_options['configName'],
            'sdi-content-grid'
            )
        # None because it cannot be sorted.  
        self.assertEqual(slickgrid_wrapper_options['isReorderable'], False)
        self.assertEqual(slickgrid_wrapper_options['showCheckboxColumn'], True)
        self.assertEqual(slickgrid_wrapper_options['sortCol'], None)   
        self.assertEqual(slickgrid_wrapper_options['sortDir'], False)
        self.assertEqual(slickgrid_wrapper_options['url'], '')
        self.assertTrue('items' in slickgrid_wrapper_options)
        self.assertEqual(slickgrid_wrapper_options['items']['from'], 0)
        self.assertEqual(slickgrid_wrapper_options['items']['total'], 1)
        self.assertTrue('records' in slickgrid_wrapper_options['items'])
        records = slickgrid_wrapper_options['items']['records']
        self.assertEqual(len(records), 1)
        self.assertEqual(records[0], {
            'name': 'the_name',
            'name_url': 'http://foo.bar',
            'id': 'the_name',
            'name_icon': 'the_icon',
            })
        addables = result['addables']
        self.assertEqual(addables, ('b',))
        buttons = result['buttons']
        self.assertEqual(len(buttons), 2)

    def test_show_with_columns(self):
        columns = [
            {
            'name': 'col1',
            'sorter':True,
            },
            {
            'name': 'col2',
            }
            ]
        folder_contents = {
            'length':1,
            'show_checkbox_column':True,
            'sort_column_name':'col1',
            'sort_reverse':False,
            'columns': columns,
            'records':[{
                    'name': 'the_name',
                    'col1': 'value4col1',
                    'col2': 'value4col2',
                    'name_url': 'http://foo.bar',
                    'id': 'the_name',
                    'name_icon': 'the_icon',
                    }]
            }
        context = testing.DummyResource()
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        inst._folder_contents = mock.Mock(
            return_value=folder_contents
            )
        inst.sdi_add_views = mock.Mock(return_value=('b',))
        context.is_reorderable = mock.Mock(return_value=False)
        context.is_ordered = mock.Mock(return_value=False)
        with mock.patch(
            'substanced.folder.views.find_catalog') as find_catalog:
            find_catalog.return_value = {'col1': 'COL1', 'col2': 'COL2'}
            result = inst.show()
        self.assertTrue('slickgrid_wrapper_options' in result)
        slickgrid_wrapper_options = result['slickgrid_wrapper_options']
        self.assertTrue('slickgridOptions' in slickgrid_wrapper_options)
        self.assertEqual(
            slickgrid_wrapper_options['configName'], 'sdi-content-grid'
            )
        self.assertEqual(slickgrid_wrapper_options['isReorderable'], False)
        self.assertEqual(slickgrid_wrapper_options['sortCol'], 'col1')  
        self.assertEqual(slickgrid_wrapper_options['sortDir'], True)
        self.assertEqual(slickgrid_wrapper_options['url'], '')
        self.assertTrue('items' in slickgrid_wrapper_options)
        self.assertEqual(slickgrid_wrapper_options['items']['from'], 0)
        self.assertEqual(slickgrid_wrapper_options['items']['total'], 1)
        self.assertTrue('records' in slickgrid_wrapper_options['items'])
        records = slickgrid_wrapper_options['items']['records']
        self.assertEqual(len(records), 1)
        self.assertEqual(records[0], {
            'name': 'the_name',
            'col1': 'value4col1',
            'col2': 'value4col2',
            'name_url': 'http://foo.bar',
            'id': 'the_name',
            'name_icon': 'the_icon',
            })

        addables = result['addables']
        self.assertEqual(addables, ('b',))
        buttons = result['buttons']
        self.assertEqual(len(buttons), 2)

    def test_show_json(self):
        folder_contents = {
            'length':1,
            'sort_column_name':None,
            'records': [{
                    'name': 'the_name',
                    'name_url': 'http://foo.bar',
                    'id': 'the_name',
                    'name_icon': 'the_icon',
                    }]
            }

        context = testing.DummyResource()
        request = self._makeRequest()
        request.params['from'] = '1'
        request.params['to'] = '2'
        inst = self._makeOne(context, request)
        inst._folder_contents = mock.Mock(
            return_value=folder_contents
            )
        result = inst.show_json()
        self.assertEqual(
            result,
            {'from':1, 'records':folder_contents['records'], 'total':1}
            )

    def test_show_json_no_from(self):
        context = testing.DummyResource()
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        result = inst.show_json()
        self.assertEqual(
            result,
            {}
            )

    def test_delete_none_deleted(self):
        context = testing.DummyResource()
        request = self._makeRequest()
        request.POST = DummyPost()
        inst = self._makeOne(context, request)
        result = inst.delete()
        self.assertEqual(request.sdiapi.flashed, 'Deleted 0 items')
        self.assertEqual(result.location, '/mgmt_path')

    def test_delete_one_deleted(self):
        context = testing.DummyResource()
        context['a'] = testing.DummyResource()
        request = self._makeRequest()
        request.POST = DummyPost(None, 'a')
        inst = self._makeOne(context, request)
        result = inst.delete()
        self.assertEqual(request.sdiapi.flashed, 'Deleted 1 item')
        self.assertEqual(result.location, '/mgmt_path')
        self.assertFalse('a' in context)

    def test_delete_multiple_deleted(self):
        context = testing.DummyResource()
        context['a'] = testing.DummyResource()
        context['b'] = testing.DummyResource()
        request = self._makeRequest()
        request.POST = DummyPost(None, 'a/b')
        inst = self._makeOne(context, request)
        result = inst.delete()
        self.assertEqual(request.sdiapi.flashed, 'Deleted 2 items')
        self.assertEqual(result.location, '/mgmt_path')
        self.assertFalse('a' in context)
        self.assertFalse('b' in context)

    def test_delete_undeletable_item(self):
        context = testing.DummyResource()
        context['a'] = testing.DummyResource()
        request = self._makeRequest()
        request.POST = DummyPost(None, 'a/b')
        inst = self._makeOne(context, request)
        result = inst.delete()
        self.assertEqual(request.sdiapi.flashed, 'Deleted 1 item')
        self.assertEqual(result.location, '/mgmt_path')
        self.assertFalse('a' in context)

    @mock.patch('substanced.folder.views.rename_duplicated_resource')
    def test_duplicate_multiple(self, mock_rename_duplicated_resource):
        context = mock.Mock()
        request = mock.Mock()
        request.localizer = testing.DummyRequest().localizer
        request.view_name = 'contents'
        request.params = {}
        request.POST.get.return_value = 'a/b'
        mock_rename_duplicated_resource.side_effect = ['a-1', 'b-1']

        inst = self._makeOne(context, request)
        inst.duplicate()

        mock_rename_duplicated_resource.assert_any_call(context, 'a')
        mock_rename_duplicated_resource.assert_any_call(context, 'b')
        request.sdiapi.flash_with_undo.assert_called_once_with(
            'Duplicated 2 items', 'success')
        request.sdiapi.mgmt_path.called_once_with(context, '@@contents')
        context.copy.assert_any_call('a', context, 'a-1')
        context.copy.assert_any_call('b', context, 'b-1')

    def test_duplicate_none(self):
        context = mock.Mock()
        request = mock.Mock()
        request.localizer = testing.DummyRequest().localizer
        request.view_name = 'contents'
        request.params = {}
        request.POST.get.return_value = ''
        inst = self._makeOne(context, request)
        inst.duplicate()

        self.assertEqual(context.mock_calls, [])
        request.sdiapi.flash_with_undo.assert_called_once_with('Duplicated 0 items', 'success')
        request.sdiapi.mgmt_path.called_once_with(context, '@@contents')

    @mock.patch('substanced.folder.views.rename_duplicated_resource')
    def test_duplicate_one(self, mock_rename_duplicated_resource):
        mock_rename_duplicated_resource.side_effect = ['a-1']
        context = mock.Mock()
        request = mock.Mock()
        request.localizer = testing.DummyRequest().localizer
        request.view_name = 'contents'
        request.params = {}
        request.POST.get.return_value = 'a'
        inst = self._makeOne(context, request)
        inst.duplicate()

        mock_rename_duplicated_resource.assert_any_call(context, 'a')
        context.copy.assert_any_call('a', context, 'a-1')
        request.sdiapi.flash_with_undo.assert_called_once_with(
            'Duplicated 1 item', 'success')
        request.sdiapi.mgmt_path.called_once_with(context, '@@contents')

    def test_rename_one(self):
        context = testing.DummyResource()
        context['foobar'] = testing.DummyResource()
        request = self._makeRequest()
        request.POST = DummyPost(None, 'foobar')
        inst = self._makeOne(context, request)
        result = inst.rename()
        self.assertEqual(result, {'torename': [context['foobar']]})

    def test_rename_missing_child(self):
        context = testing.DummyResource()
        context['foobar'] = testing.DummyResource()
        request = self._makeRequest()
        request.POST = DummyPost(None, 'foobar/foobar1')
        inst = self._makeOne(context, request)
        result = inst.rename()
        self.assertEqual(result, {'torename': [context['foobar']]})

    def test_rename_multiple(self):
        context = testing.DummyResource()
        context['foobar'] = testing.DummyResource()
        context['foobar2'] = testing.DummyResource()
        context['foobar3'] = testing.DummyResource()
        request = self._makeRequest()
        request.POST = DummyPost(None, 'foobar/foobar3')
        inst = self._makeOne(context, request)
        result = inst.rename()
        self.assertEqual(result, {'torename': [context['foobar'],
                                               context['foobar3']]})

    def test_rename_none(self):
        context = testing.DummyResource()
        context['foobar'] = testing.DummyResource()
        context['foobar2'] = testing.DummyResource()
        context['foobar3'] = testing.DummyResource()
        request = self._makeRequest()
        request.POST = DummyPost(None, '')
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        result = inst.rename()
        self.assertEqual(request.sdiapi.flashed, 'No items renamed')
        self.assertEqual(result.location, '/mgmt_path')

    def test_rename_finish(self):
        context = mock.Mock()
        request = mock.Mock()
        request.view_name = 'contents'
        request.params = {}
        request.localizer = testing.DummyRequest().localizer
        request.POST.getall.return_value = ('foobar',)
        request.POST.get.side_effect = lambda x: {
            'foobar': 'foobar2',
            'form.rename_finish': 'rename_finish'}[x]

        inst = self._makeOne(context, request)
        inst.rename_finish()
        request.sdiapi.flash_with_undo.assert_called_once_with(
            'Renamed 1 item', 'success')
        context.rename.assert_called_once_with('foobar', 'foobar2')

    def test_rename_finish_multiple(self):
        context = mock.Mock()
        request = mock.Mock()
        request.view_name = 'contents'
        request.params = {}
        request.localizer = testing.DummyRequest().localizer
        request.POST.getall.return_value = ('foobar', 'foobar1')
        request.POST.get.side_effect = lambda x: {
            'foobar': 'foobar0',
            'foobar1': 'foobar11',
            'form.rename_finish': 'rename_finish'}[x]

        inst = self._makeOne(context, request)
        inst.rename_finish()

        request.sdiapi.flash_with_undo.assert_called_once_with(
            'Renamed 2 items', 'success')
        context.rename.assert_any_call('foobar', 'foobar0')
        context.rename.assert_any_call('foobar1', 'foobar11')

    def test_rename_finish_cancel(self):
        context = mock.Mock()
        request = mock.Mock()
        request.view_name = 'contents'
        request.params = {}
        request.POST.getall.return_value = ('foobar',)
        request.POST.get.side_effect = lambda x: {
            'foobar': 'foobar0',
            'form.rename_finish': 'cancel'}[x]
        inst = self._makeOne(context, request)
        inst.rename_finish()

        request.sdiapi.flash.assert_called_once_with('No items renamed')
        self.assertFalse(context.rename.called)

    def test_rename_finish_already_exists(self):
        from .. import FolderKeyError
        context = mock.MagicMock()
        context.rename.side_effect = FolderKeyError(_FOOBAR)
        request = mock.Mock()
        request.view_name = 'contents'
        request.params = {}
        request.POST.getall.return_value = ('foobar',)
        request.POST.get.side_effect = lambda x: {
            'foobar': 'foobar0',
            'foobar1': 'foobar0',
            'form.rename_finish': 'rename_finish'}[x]
        inst = self._makeOne(context, request)

        self.assertRaises(HTTPFound, inst.rename_finish)
        context.rename.assert_any_call('foobar', 'foobar0')
        request.sdiapi.flash.assert_called_once_with(_FOOBAR, 'danger')

    @mock.patch('substanced.folder.views.get_oid')
    def test_copy_one(self, mock_get_oid):
        context = mock.Mock()
        context.get.side_effect = lambda x: {
            'foobar': 'foobar',
            'foobar1': 'foobar1'}[x]
        request = mock.MagicMock()
        request.POST.get.return_value = 'foobar'

        inst = self._makeOne(context, request)
        inst.copy()

        request.sdiapi.flash.assert_called_once_with(
            'Choose where to copy the items:', 'info')
        self.assertEqual(mock_get_oid.mock_calls, [mock.call('foobar')])
        self.assertTrue(request.session.__setitem__.called)

    @mock.patch('substanced.folder.views.get_oid')
    def test_copy_multi(self, mock_get_oid):
        context = mock.Mock()
        context.get.side_effect = lambda x: {'foobar': 'foobar',
                                             'foobar1': 'foobar1',
                                             'foobar2': 'foobar2'}[x]
        request = mock.MagicMock()
        request.POST.get.return_value = 'foobar/foobar1'

        inst = self._makeOne(context, request)
        inst.copy()

        request.sdiapi.flash.assert_called_once_with(
            'Choose where to copy the items:', 'info')
        self.assertEqual(mock_get_oid.mock_calls,
                         [mock.call('foobar'), mock.call('foobar1')])
        self.assertTrue(request.session.__setitem__.called)

    @mock.patch('substanced.folder.views.get_oid')
    def test_copy_missing_child(self, mock_get_oid):
        context = mock.Mock()
        context.get.side_effect = lambda x: {
            'foobar': 'foobar',
            'foobar2': 'foobar2'}.get(x, None)
        request = mock.MagicMock()
        request.POST.get.return_value = 'foobar/foobar1'

        inst = self._makeOne(context, request)
        inst.copy()
        request.sdiapi.flash.assert_called_once_with(
            'Choose where to copy the items:', 'info')
        self.assertEqual(mock_get_oid.mock_calls, [mock.call('foobar')])
        self.assertTrue(request.session.__setitem__.called)

    @mock.patch('substanced.folder.views.get_oid')
    def test_copy_none(self, mock_get_oid):
        context = mock.Mock()
        context.__contains__ = mock.Mock(return_value=True)
        request = mock.MagicMock()
        request.POST.get.return_value = ''

        inst = self._makeOne(context, request)
        inst.copy()

        request.sdiapi.flash.assert_called_once_with(
            'No items to copy', 'warning')
        self.assertFalse(mock_get_oid.called)

    def test_copy_finish_cancel(self):
        context = mock.Mock()
        request = mock.MagicMock()
        request.POST.get.return_value = ('foobar',)
        request.POST.get.side_effect = lambda x: {
            'foobar': 'foobar0',
            'form.copy_finish_cancel': 'cancel'}[x]
        inst = self._makeOne(context, request)
        inst.copy_finish_cancel()

        request.sdiapi.flash.assert_called_once_with(
            'No items copied', 'success')
        self.assertEqual(request.session.__delitem__.call_args,
                         mock.call('tocopy'))

    @mock.patch('substanced.folder.views.find_objectmap')
    def test_copy_finish_zero(self, mock_find_objectmap):
        context = mock.MagicMock()
        mock_folder = mock_find_objectmap().object_for()
        mock_folder.__parent__ = mock.MagicMock()
        mock_folder.__name__ = mock.sentinel.name
        request = mock.MagicMock()
        request.localizer = testing.DummyRequest().localizer
        request.session.__getitem__.return_value = [123]
        request.POST.get.side_effect = lambda x: {
            'form.copy_finish': 'copy_finish'}[x]

        inst = self._makeOne(context, request)

        # content type wont be addable, because we haven't patched
        # sdi_add_views to return a valid content type set

        inst.copy_finish()

        request.sdiapi.flash_with_undo.assert_called_once_with(
            'Copied 0 items', 'success')
        request.sdiapi.flash.assert_called_once_with(
            '"%s" is of a type (%s) that is not addable here, refusing to copy' % (
                mock.sentinel.name, request.registry.content.typeof(None)
                ), 'danger',
            )
            
        self.assertEqual(request.session.__delitem__.call_args,
                         mock.call('tocopy'))
        
    @mock.patch('substanced.folder.views.find_objectmap')
    def test_copy_finish_one(self, mock_find_objectmap):
        context = mock.MagicMock()
        mock_folder = mock_find_objectmap().object_for()
        mock_folder.__parent__ = mock.MagicMock()
        mock_folder.__name__ = mock.sentinel.name
        request = mock.MagicMock()
        request.localizer = testing.DummyRequest().localizer
        request.session.__getitem__.return_value = [123]
        request.POST.get.side_effect = lambda x: {
            'form.copy_finish': 'copy_finish'}[x]

        inst = self._makeOne(context, request)
        ct = request.registry.content.typeof(None)
        inst.sdi_add_views = lambda *arg: [ {'content_type':ct} ]
        inst.copy_finish()

        self.assertEqual(mock_folder.__parent__.copy.call_args,
                         mock.call(mock.sentinel.name, context))
        request.sdiapi.flash_with_undo.assert_called_once_with(
            'Copied 1 item', 'success')
        self.assertEqual(request.session.__delitem__.call_args,
                         mock.call('tocopy'))

    @mock.patch('substanced.folder.views.find_objectmap')
    def test_copy_finish_multi(self, mock_find_objectmap):
        context = mock.MagicMock()
        mock_folder = mock_find_objectmap().object_for()
        mock_folder.__parent__ = mock.MagicMock()
        mock_folder.__name__ = mock.sentinel.name
        request = mock.MagicMock()
        request.localizer = testing.DummyRequest().localizer
        request.session.__getitem__.return_value = [123, 456]
        request.POST.get.side_effect = lambda x: {
            'form.copy_finish': 'copy_finish'}[x]

        inst = self._makeOne(context, request)
        ct = request.registry.content.typeof(None)
        inst.sdi_add_views = lambda *arg: [ {'content_type':ct} ]
        inst.copy_finish()

        self.assertTrue(mock.call(123) in
                        mock_find_objectmap().object_for.mock_calls)
        self.assertTrue(mock.call(456) in
                        mock_find_objectmap().object_for.mock_calls)
        self.assertEqual(mock_folder.__parent__.copy.call_args,
                         mock.call(mock.sentinel.name, context))
        request.sdiapi.flash_with_undo.assert_called_once_with(
            'Copied 2 items', 'success')
        self.assertEqual(request.session.__delitem__.call_args,
                         mock.call('tocopy'))

    @mock.patch('substanced.folder.views.find_objectmap')
    def test_copy_finish_already_exists(self, mock_find_objectmap):
        from .. import FolderKeyError
        context = mock.MagicMock()
        mock_folder = mock_find_objectmap().object_for()
        mock_folder.__parent__ = mock.MagicMock()
        mock_folder.__parent__.copy.side_effect = FolderKeyError(_FOOBAR)
        mock_folder.__name__ = mock.sentinel.name
        request = mock.MagicMock()
        request.session.__getitem__.return_value = [123]
        request.POST.get.side_effect = lambda x: {
            'form.copy_finish': 'copy_finish'}[x]

        inst = self._makeOne(context, request)
        ct = request.registry.content.typeof(None)
        inst.sdi_add_views = lambda *arg: [ {'content_type':ct} ]
        self.assertRaises(HTTPFound, inst.copy_finish)
        request.sdiapi.flash.assert_called_once_with(_FOOBAR, 'danger')

    @mock.patch('substanced.folder.views.get_oid')
    def test_move_one(self, mock_get_oid):
        context = mock.Mock()
        context.get.side_effect = lambda x: {
            'foobar': 'foobar',
            'foobar1': 'foobar1'}[x]
        request = mock.MagicMock()
        request.POST.get.return_value = 'foobar'

        inst = self._makeOne(context, request)
        inst.move()

        request.sdiapi.flash.assert_called_once_with(
            'Choose where to move the items:', 'info')
        self.assertEqual(mock_get_oid.mock_calls, [mock.call('foobar')])
        self.assertTrue(request.session.__setitem__.call_args,
                        [mock.call('tomove')])

    @mock.patch('substanced.folder.views.get_oid')
    def test_move_multi(self, mock_get_oid):
        context = mock.Mock()
        context.get.side_effect = lambda x: {'foobar': 'foobar',
                                             'foobar1': 'foobar1'}[x]
        request = mock.MagicMock()
        request.POST.get.return_value = 'foobar/foobar1'

        inst = self._makeOne(context, request)
        inst.move()

        request.sdiapi.flash.assert_called_once_with(
            'Choose where to move the items:', 'info')
        self.assertEqual(mock_get_oid.mock_calls,
                         [mock.call('foobar'), mock.call('foobar1')])
        self.assertTrue(request.session.__setitem__.call_args,
                        [mock.call('tomove')])

    @mock.patch('substanced.folder.views.get_oid')
    def test_move_missing_child(self, mock_get_oid):
        context = mock.Mock()
        context.get.side_effect = lambda x: {'foobar': 'foobar',
                                             'foobar1': 'foobar1'}.get(x, None)
        request = mock.MagicMock()
        request.POST.get.return_value = 'foobar/foobar2'

        inst = self._makeOne(context, request)
        inst.move()

        request.sdiapi.flash.assert_called_once_with(
            'Choose where to move the items:', 'info')
        self.assertEqual(mock_get_oid.mock_calls, [mock.call('foobar')])
        self.assertTrue(request.session.__setitem__.call_args,
                        [mock.call('tomove')])

    @mock.patch('substanced.folder.views.get_oid')
    def test_move_none(self, mock_get_oid):
        context = mock.Mock()
        context.get.side_effect = lambda x: {'foobar': 'foobar',
                                             'foobar1': 'foobar1'}.get(x, None)
        request = mock.MagicMock()
        request.POST.get.return_value = ''

        inst = self._makeOne(context, request)
        inst.move()

        request.sdiapi.flash.assert_called_once_with(
            'No items to move', 'warning')
        self.assertFalse(mock_get_oid.called)
        self.assertFalse(request.session.__setitem__.called)

    def test_move_finish_cancel(self):
        context = mock.Mock()
        request = mock.MagicMock()
        request.POST.get.return_value = 'foobar'
        request.POST.get.side_effect = lambda x: {
            'foobar': 'foobar0',
            'form.move_finish': 'cancel'}[x]
        inst = self._makeOne(context, request)
        inst.move_finish_cancel()

        request.sdiapi.flash.assert_called_once_with(
            'No items moved', 'success')
        self.assertEqual(request.session.__delitem__.call_args,
                         mock.call('tomove'))

    @mock.patch('substanced.folder.views.find_objectmap')
    def test_move_finish_zero(self, mock_find_objectmap):
        context = mock.MagicMock()
        mock_folder = mock_find_objectmap().object_for()
        mock_folder.__parent__ = mock.MagicMock()
        mock_folder.__name__ = mock.sentinel.name
        request = mock.MagicMock()
        request.localizer = testing.DummyRequest().localizer
        request.session.__getitem__.return_value = [123]
        request.POST.get.side_effect = lambda x: {
            'form.move_finish': 'move_finish'}[x]

        inst = self._makeOne(context, request)

        # content type wont be addable, because we haven't patched
        # sdi_add_views to return a valid content type set

        inst.move_finish()

        call_list = request.sdiapi.flash.call_args_list

        request.sdiapi.flash_with_undo.assert_called_once_with(
            'Moved 0 items', 'success')
        request.sdiapi.flash.assert_called_once_with(
            '"%s" is of a type (%s) that is not addable here, refusing to move' % (
                mock.sentinel.name, request.registry.content.typeof(None)
                ), 'danger',
            )
            
        self.assertEqual(request.session.__delitem__.call_args,
                         mock.call('tomove'))
        
    @mock.patch('substanced.folder.views.find_objectmap')
    def test_move_finish_one(self, mock_find_objectmap):
        context = mock.MagicMock()
        mock_folder = mock_find_objectmap().object_for()
        mock_folder.__parent__ = mock.MagicMock()
        mock_folder.__name__ = mock.sentinel.name
        request = mock.MagicMock()
        request.localizer = testing.DummyRequest().localizer
        request.session.__getitem__.return_value = [123]
        request.POST.get.side_effect = lambda x: {
            'form.move_finish': 'move_finish'}[x]

        inst = self._makeOne(context, request)
        ct = request.registry.content.typeof(None)
        inst.sdi_add_views = lambda *arg: [ {'content_type':ct} ]
        inst.move_finish()

        self.assertEqual(mock_folder.__parent__.move.call_args,
                         mock.call(mock.sentinel.name, context))
        request.sdiapi.flash_with_undo.assert_called_once_with(
            'Moved 1 item', 'success')
        self.assertEqual(request.session.__delitem__.call_args,
                         mock.call('tomove'))

    @mock.patch('substanced.folder.views.find_objectmap')
    def test_move_finish_multi(self, mock_find_objectmap):
        context = mock.MagicMock()
        mock_folder = mock_find_objectmap().object_for()
        mock_folder.__parent__ = mock.MagicMock()
        mock_folder.__name__ = mock.sentinel.name
        request = mock.MagicMock()
        request.localizer = testing.DummyRequest().localizer
        request.session.__getitem__.return_value = [123, 456]
        request.POST.get.side_effect = lambda x: {
            'form.move_finish': 'move_finish'}[x]

        inst = self._makeOne(context, request)
        ct = request.registry.content.typeof(None)
        inst.sdi_add_views = lambda *arg: [ {'content_type':ct} ]
        inst.move_finish()

        self.assertTrue(mock.call(123) in
                        mock_find_objectmap().object_for.mock_calls)
        self.assertTrue(mock.call(456) in
                        mock_find_objectmap().object_for.mock_calls)
        self.assertEqual(mock_folder.__parent__.move.call_args,
                         mock.call(mock.sentinel.name, context))
        self.assertEqual(request.session.__delitem__.call_args,
                         mock.call('tomove'))
        request.sdiapi.flash_with_undo.assert_called_once_with(
            'Moved 2 items', 'success')

    @mock.patch('substanced.folder.views.find_objectmap')
    def test_move_finish_already_exists(self, mock_find_objectmap):
        from .. import FolderKeyError
        context = mock.MagicMock()
        mock_folder = mock_find_objectmap().object_for()
        mock_folder.__parent__ = mock.MagicMock()
        mock_folder.__parent__.move.side_effect = FolderKeyError(_FOOBAR)
        mock_folder.__name__ = mock.sentinel.name
        request = mock.MagicMock()
        request.session.__getitem__.return_value = [123]
        request.POST.get.side_effect = lambda x: {
            'form.move_finish': 'move_finish'}[x]

        inst = self._makeOne(context, request)
        ct = request.registry.content.typeof(None)
        inst.sdi_add_views = lambda *arg: [ {'content_type':ct} ]
        self.assertRaises(HTTPFound, inst.move_finish)
        request.sdiapi.flash.assert_called_once_with(_FOOBAR, 'danger')

    def test_reorder_rows(self):
        context = testing.DummyResource()
        request = self._makeRequest()
        request.params['item-modify'] = 'a/b'
        request.params['insert-before'] = 'c'
        def reorder(item_modify, insert_before):
            self.assertEqual(item_modify, ['a', 'b'])
            self.assertEqual(insert_before, 'c')
        context.reorder = reorder
        inst = self._makeOne(context, request)
        def _get_json():
            return {'foo':'bar'}
        inst._get_json = _get_json
        mockundowrapper = mock.Mock(
            return_value='STATUSMESSG<a>Undo</a>'
            )
        request.sdiapi.get_flash_with_undo_snippet = mockundowrapper
        result = inst.reorder_rows()
        mockundowrapper.assert_called_once_with('2 rows moved.')
        self.assertEqual(
            result,
            {'foo': 'bar', 'flash': 'STATUSMESSG<a>Undo</a>',
             'flash_queue':'success'}
            )

    def test_reorder_rows_after_last(self):
        context = testing.DummyResource()
        request = self._makeRequest()
        request.params['item-modify'] = 'a/b'
        request.params['insert-before'] = ''
        def reorder(item_modify, insert_before):
            self.assertEqual(item_modify, ['a', 'b'])
            self.assertEqual(insert_before, None)
        context.reorder = reorder
        inst = self._makeOne(context, request)
        def _get_json():
            return {'foo':'bar'}
        inst._get_json = _get_json
        mockundowrapper = mock.Mock(
            return_value='STATUSMESSG<a>Undo</a>'
            )
        request.sdiapi.get_flash_with_undo_snippet = mockundowrapper
        result = inst.reorder_rows()
        mockundowrapper.assert_called_once_with('2 rows moved.')
        self.assertEqual(
            result,
            {'foo': 'bar', 'flash': 'STATUSMESSG<a>Undo</a>',
             'flash_queue':'success'}
            )

    def test__name_sorter_index_is_None(self):
        context = testing.DummyResource()
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        resource = testing.DummyResource()
        resultset = 123
        inst.system_catalog = {}
        result = inst._name_sorter(resource, resultset, 1, True)
        self.assertEqual(result, resultset)
        
    def test__name_sorter_index_is_not_None(self):
        context = testing.DummyResource()
        request = self._makeRequest()
        resource = testing.DummyResource()
        catalog = DummyCatalog()
        class ResultSet(object):
            def sort(innerself, index, limit=None, reverse=None):
                self.assertEqual(index.__class__.__name__, 'DummyIndex')
                self.assertEqual(limit, 1)
                self.assertEqual(reverse, True)
                return innerself
        resultset = ResultSet()
        inst = self._makeOne(context, request)
        inst.system_catalog = catalog
        result = inst._name_sorter(resource, resultset, 1, True)
        self.assertEqual(result, resultset)

    def test_get_columns_no_icon(self):
        fred = testing.DummyResource()
        fred.__name__ = 'fred'
        request = self._makeRequest(icon=None)
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        result = inst.get_columns(fred)
        self.assertEqual(
           result,
           [
                {'sorter': inst._name_sorter, 
                 'name': 'Name',
                 'formatter':'html',
                 'value':('<i class="" title="Type \'fred\'"> </i> '
                          '<a href="/mgmt_path">fred</a>')},
                ]
           )

    def test_get_columns_named_icon(self):
        fred = testing.DummyResource()
        fred.__name__ = 'fred'
        request = self._makeRequest(icon='icon')
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        result = inst.get_columns(fred)
        self.assertEqual(
           result,
           [
                {'sorter': inst._name_sorter, 
                 'name': 'Name',
                 'formatter':'html',
                 'value':('<i class="icon" title="Type \'fred\'"> </i> '
                          '<a href="/mgmt_path">fred</a>')},
                ]
           )

    def test_get_columns_with_callable_icon(self):
        fred = testing.DummyResource()
        fred.__name__ = 'fred'
        request = self._makeRequest(icon=lambda *arg: 'icon')
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        result = inst.get_columns(fred)
        self.assertEqual(
           result,
           [
                {'sorter': inst._name_sorter, 
                 'name': 'Name',
                 'formatter':'html',
                 'value':('<i class="icon" title="Type \'fred\'"> </i> '
                          '<a href="/mgmt_path">fred</a>')},
                ]
           )
        
    def test_get_buttons_novals(self):
        self.config.testing_securitypolicy(permissive=True)
        request = self._makeRequest()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        result = inst.get_buttons()
        self.assertEqual(len(result), 2)
        main_buttons = result[0]
        self.assertEqual(main_buttons['type'], 'group')
        buttons = main_buttons['buttons']
        self.assertEqual(len(buttons), 4)
        self.assertEqual(buttons[0]['text'], 'Rename')
        self.assertEqual(buttons[1]['text'], 'Copy')
        self.assertEqual(buttons[2]['text'], 'Move')
        self.assertEqual(buttons[3]['text'], 'Duplicate')
        self.assertEqual(result[1]['type'], 'group')

        buttons = result[1]['buttons']
        self.assertEqual(len(buttons), 1)
        delete_button = buttons[0]
        self.assertEqual(delete_button['text'], 'Delete')
        self.assertEqual(delete_button['class'], 'btn-danger btn-sdi-sel')
        self.assertEqual(delete_button['name'], 'form.delete')
        self.assertEqual(delete_button['value'], 'delete')
        self.assertEqual(delete_button['id'], 'delete')
        self.assertTrue(delete_button['enabled_for'])

    def test_get_buttons_delete_enabled_for_no_sdi_deletable_attr_can_mg(self):
        self.config.testing_securitypolicy(permissive=True)
        request = self._makeRequest()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        result = inst.get_buttons()
        delete_button = result[1]['buttons'][0]
        delete_enabled_for = delete_button['enabled_for']
        result = delete_enabled_for(context, context, request)
        self.assertTrue(result)

    def test_get_buttons_delete_enabled_for_no_sdi_deletable_attr_cant_mg(self):
        self.config.testing_securitypolicy(permissive=False)
        request = self._makeRequest()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        result = inst.get_buttons()
        delete_button = result[1]['buttons'][0]
        delete_enabled_for = delete_button['enabled_for']
        result = delete_enabled_for(context, context, request)
        self.assertFalse(result)
        
    def test_get_buttons_delete_enabled_for_callable_sdi_deletable_attr(self):
        self.config.testing_securitypolicy(permissive=True)
        request = self._makeRequest()
        context = testing.DummyResource()
        subobject = testing.DummyResource()
        def deletable(_subobject, _request):
            self.assertEqual(_subobject, subobject)
            self.assertEqual(_request, request)
            return False
        subobject.__sdi_deletable__ = deletable
        inst = self._makeOne(context, request)
        result = inst.get_buttons()
        delete_button = result[1]['buttons'][0]
        delete_enabled_for = delete_button['enabled_for']
        result = delete_enabled_for(context, subobject, request)
        self.assertFalse(result)

    def test_get_buttons_delete_enabled_for_boolean_sdi_deletable_attr(self):
        self.config.testing_securitypolicy(permissive=True)
        request = self._makeRequest()
        context = testing.DummyResource()
        subobject = testing.DummyResource()
        subobject.__sdi_deletable__ = False
        inst = self._makeOne(context, request)
        result = inst.get_buttons()
        delete_button = result[1]['buttons'][0]
        delete_enabled_for = delete_button['enabled_for']
        result = delete_enabled_for(context, subobject, request)
        self.assertFalse(result)
        
    def test_get_buttons_tocopy(self):
        self.config.testing_securitypolicy(permissive=True)
        request = self._makeRequest()
        context = testing.DummyResource()
        request.session['tocopy'] = True
        inst = self._makeOne(context, request)
        result = inst.get_buttons()
        self.assertEqual(
            result,
            [
              {'buttons': 
                [{'text': 'Copy here', 
                  'class': 'btn-primary btn-sdi-act', 
                  'id': 'copy_finish', 
                  'value': 'copy_finish', 
                  'name': 'form.copy_finish'}, 
                 {'text': 'Cancel', 
                  'class': 'btn-danger btn-sdi-act', 
                  'id': 'cancel', 
                  'value': 'cancel', 
                  'name': 'form.copy_finish_cancel'}],
               'type': 'single'}
               ]
               )

    def test_get_buttons_tomove(self):
        self.config.testing_securitypolicy(permissive=True)
        request = self._makeRequest()
        context = testing.DummyResource()
        request.session['tomove'] = True
        inst = self._makeOne(context, request)
        result = inst.get_buttons()
        self.assertEqual(
            result, [
            {'buttons': [
                {'text': 'Move here',
                 'class': 'btn-primary btn-sdi-act',
                 'id': 'move_finish',
                 'value': 'move_finish',
                 'name': 'form.move_finish'},
                {'text': 'Cancel',
                 'class': 'btn-danger btn-sdi-act',
                 'id': 'cancel',
                 'value': 'cancel',
                 'name':'form.move_finish_cancel'}],
             'type': 'single'}
            ]            
            )

    def test_get_default_query(self):
        from zope.interface import directlyProvides
        from ...interfaces import IFolder
        from ...interfaces import IService
        context = testing.DummyResource()
        directlyProvides(context, IFolder)
        context['catalogs'] = _makeCatalogs(oids=[1])
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        query = inst.get_default_query()
        self.assertTrue(isinstance(query, DummyIndex))
        self.assertEqual(query.name, 'path')
        self.assertEqual(query.queried,
                         ('eq', (context,), {'depth': 1,
                                             'include_origin': False}))
        self.assertEqual(query.anded_with[0].name, 'interfaces')
        self.assertEqual(query.anded_with[0].queried,
                         ('notany', ([IService],), {}))
        self.assertEqual(query.anded_with[1].name, 'allowed')
        self.assertEqual(query.anded_with[1].queried,
                         ('allows', (request, 'sdi.view'), {}))

    def test_no_content_types(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.registry.content = DummyContent()
        request.registry.introspector = DummyIntrospector()
        inst = self._makeOne(None, request)
        result = inst.sdi_add_views()
        self.assertEqual(result, [])  

    def test_one_content_type_content(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.registry.content = DummyContent()
        request.sdiapi = DummySDIAPI()
        ct_intr = {}
        ct_intr['meta'] = {'add_view':'abc'}
        ct_intr['content_type'] = 'Content'
        ct_intr = DummyIntrospectable(introspectable=ct_intr)
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'abc'
        view_intr1['context'] = None
        view_intr1['derived_callable'] = None
        intr = {}
        intr['tab_title'] = 'abc'
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr1,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(ct_intr,), (intr,)])
        context = testing.DummyResource()
        inst = self._makeOne(context, request) 
        result = inst.sdi_add_views()
        self.assertEqual(
            result,
            [{
                    'url': '/mgmt_path',
                    'type_name': 'Content',
                    'icon': '',
                    'content_type':'Content',
                    }])

    def test_one_content_type_service(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.registry.content = DummyContent()
        request.sdiapi = DummySDIAPI()
        ct_intr = {}
        ct_intr['meta'] = {'add_view':'abc', 'is_service': True}
        ct_intr['content_type'] = 'Content'
        ct_intr = DummyIntrospectable(introspectable=ct_intr)
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'abc'
        view_intr1['context'] = None
        view_intr1['derived_callable'] = None
        intr = {}
        intr['tab_title'] = 'abc'
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr1,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(ct_intr,), (intr,)])
        context = testing.DummyResource()
        inst = self._makeOne(context, request) 
        result = inst.sdi_add_views()
        self.assertEqual(result, [])

    def test_one_content_type_not_addable(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.registry.content = DummyContent()
        request.sdiapi = DummySDIAPI()
        context = testing.DummyResource()
        context.__sdi_addable__ = ('Not Content',)
        ct_intr = {}
        ct_intr['meta'] = {'add_view':'abc'}
        ct_intr['content_type'] = 'Content'
        ct_intr = DummyIntrospectable(introspectable=ct_intr)
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'abc'
        view_intr1['context'] = None
        view_intr1['derived_callable'] = None
        intr = {}
        intr['tab_title'] = 'abc'
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr1,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(ct_intr,), (intr,)])
        inst = self._makeOne(context, request) 
        result = inst.sdi_add_views()
        self.assertEqual(result, [])

    def test_one_content_type_not_addable_callable(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.registry.content = DummyContent()
        request.sdiapi = DummySDIAPI()
        context = testing.DummyResource()
        context.__sdi_addable__ = lambda *arg: False
        ct_intr = {}
        ct_intr['meta'] = {'add_view':'abc'}
        ct_intr['content_type'] = 'Content'
        ct_intr = DummyIntrospectable(introspectable=ct_intr)
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'abc'
        view_intr1['context'] = None
        view_intr1['derived_callable'] = None
        intr = {}
        intr['tab_title'] = 'abc'
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr1,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(ct_intr,), (intr,)])
        inst = self._makeOne(context, request) 
        result = inst.sdi_add_views()
        self.assertEqual(result, [])

    def test_content_type_not_addable_to(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.registry.content = DummyContent()
        request.sdiapi = DummySDIAPI()
        context = testing.DummyResource()
        context.__content_type__ = 'Foo'
        ct_intr = {}
        ct_intr['meta'] = {'add_view':lambda *arg: 'abc'}
        ct_intr['content_type'] = 'Content'
        ct_intr = DummyIntrospectable(introspectable=ct_intr)
        ct2_intr = {}
        checked = []
        def check(context, request):
            checked.append(True)
        ct2_intr['meta'] = {'add_view':check}
        ct2_intr['content_type'] = 'Content'
        ct2_intr = DummyIntrospectable(introspectable=ct2_intr)
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'abc'
        view_intr1['context'] = None
        view_intr1['derived_callable'] = None
        intr = {}
        intr['tab_title'] = 'abc'
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr1,), introspectable=intr)
        request.registry.introspector = DummyIntrospector(
            [(ct_intr, ct2_intr), (intr,)])
        inst = self._makeOne(context, request) 
        result = inst.sdi_add_views()
        self.assertEqual(checked, [True])
        self.assertEqual(
            result,
            [
                {'url': '/mgmt_path',
                 'type_name': 'Content',
                 'icon': '',
                 'content_type':'Content',
                 }])

class Test_folder_contents_views_decorator(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _getTargetClass(self):
        from ..views import folder_contents_views
        return folder_contents_views

    def _makeOne(self, *arg, **kw):
        return self._getTargetClass()(*arg, **kw)

    def test_create_defaults(self):
        decorator = self._makeOne()
        self.assertEqual(decorator.settings, {})

    def test_create_nondefaults(self):
        decorator = self._makeOne(
            name='frank',
            match_param='match_param',
            )
        self.assertEqual(decorator.settings['name'], 'frank')
        self.assertEqual(decorator.settings['match_param'], 'match_param')

    def test_call_class(self):
        decorator = self._makeOne()
        venusian = DummyVenusian()
        decorator.venusian = venusian
        class foo(object): pass
        wrapped = decorator(foo)
        self.assertTrue(wrapped is foo)
        config = call_venusian(venusian)
        settings = config.settings
        self.assertEqual(len(settings), 1)
        self.assertEqual(len(settings[0]), 2)
        self.assertEqual(settings[0]['cls'], None) # comes from call_venusian
        self.assertEqual(settings[0]['_info'], 'codeinfo')

    def test_stacking(self):
        decorator1 = self._makeOne(name='1')
        venusian1 = DummyVenusian()
        decorator1.venusian = venusian1
        venusian2 = DummyVenusian()
        decorator2 = self._makeOne(name='2')
        decorator2.venusian = venusian2
        def foo(): pass
        wrapped1 = decorator1(foo)
        wrapped2 = decorator2(wrapped1)
        self.assertTrue(wrapped1 is foo)
        self.assertTrue(wrapped2 is foo)
        config1 = call_venusian(venusian1)
        self.assertEqual(len(config1.settings), 1)
        self.assertEqual(config1.settings[0]['name'], '1')
        config2 = call_venusian(venusian2)
        self.assertEqual(len(config2.settings), 1)
        self.assertEqual(config2.settings[0]['name'], '2')

    def test_with_custom_predicates(self):
        decorator = self._makeOne(custom_predicates=(1,))
        venusian = DummyVenusian()
        decorator.venusian = venusian
        def foo(context, request): pass
        decorated = decorator(foo)
        self.assertTrue(decorated is foo)
        config = call_venusian(venusian)
        settings = config.settings
        self.assertEqual(settings[0]['custom_predicates'], (1,))

    def test_call_withdepth(self):
        decorator = self._makeOne(_depth=1)
        venusian = DummyVenusian()
        decorator.venusian = venusian
        def foo(): pass
        decorator(foo)
        self.assertEqual(venusian.depth, 2)

class Test_add_folder_contents_views(unittest.TestCase):
    def _callFUT(self, config, **kw):
        from ..views import add_folder_contents_views
        return add_folder_contents_views(config, **kw)
    
    def test_it_gardenpath(self):
        from ..views import FolderContents
        from substanced.interfaces import IFolder
        config = DummyConfig()
        self._callFUT(config)
        self.assertEqual(len(config.settings), 13)
        self.assertEqual(config.settings[0]['view'], FolderContents)
        self.assertEqual(config.settings[0]['context'], IFolder)

    def test_it_override_context_and_cls(self):
        config = DummyConfig()
        class Foo(object): pass
        self._callFUT(config, cls=Foo, context=Foo)
        self.assertEqual(config.settings[0]['view'], Foo)
        self.assertEqual(config.settings[0]['context'], Foo)

    def test_it_with_extra_predicates(self):
        config = DummyConfig()
        class Foo(object): pass
        self._callFUT(config, slamdunk=1)
        self.assertEqual(config.settings[0]['slamdunk'], 1)

class Test_has_services(unittest.TestCase):
    def _callFUT(self, context, request):
        from ..views import has_services
        return has_services(context, request)
 
    def _makeRequest(self, **kw):
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent(**kw)
        return request
    
    def test_it(self):
        from zope.interface import directlyProvides
        from ...interfaces import IFolder
        context = testing.DummyResource()
        directlyProvides(context, IFolder)
        context['catalogs'] = _makeCatalogs(oids=[1])
        request = self._makeRequest()
        result = self._callFUT(context, request)
        self.assertEqual(result, True)

class FolderServicesTest(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from ..views import FolderServices
        return FolderServices(context, request)

    def _makeRequest(self, **kw):
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent(**kw)
        return request

    def test_get_default_query(self):
        from zope.interface import directlyProvides
        from ...interfaces import IFolder
        from ...interfaces import IService
        context = testing.DummyResource()
        directlyProvides(context, IFolder)
        context['catalogs'] = _makeCatalogs(oids=[1])
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        query = inst.get_default_query()
        self.assertTrue(isinstance(query, DummyIndex))
        self.assertEqual(query.name, 'path')
        self.assertEqual(query.queried,
                         ('eq', (context,), {'depth': 1,
                                             'include_origin': False}))
        self.assertEqual(query.anded_with[0].name, 'interfaces')
        self.assertEqual(query.anded_with[0].queried,
                         ('any', ([IService],), {}))
        self.assertEqual(query.anded_with[1].name, 'allowed')
        self.assertEqual(query.anded_with[1].queried,
                         ('allows', (request, 'sdi.view'), {}))

    def test_no_content_types(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.registry.content = DummyContent()
        request.registry.introspector = DummyIntrospector()
        inst = self._makeOne(None, request)
        result = inst.sdi_add_views()
        self.assertEqual(result, [])  

    def test_one_content_type_content(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.registry.content = DummyContent()
        request.sdiapi = DummySDIAPI()
        ct_intr = {}
        ct_intr['meta'] = {'add_view':'abc'}
        ct_intr['content_type'] = 'Content'
        ct_intr = DummyIntrospectable(introspectable=ct_intr)
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'abc'
        view_intr1['context'] = None
        view_intr1['derived_callable'] = None
        intr = {}
        intr['tab_title'] = 'abc'
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr1,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(ct_intr,), (intr,)])
        context = testing.DummyResource()
        inst = self._makeOne(context, request) 
        result = inst.sdi_add_views()
        self.assertEqual(result, [])

    def test_one_content_type_service(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.registry.content = DummyContent()
        request.sdiapi = DummySDIAPI()
        ct_intr = {}
        ct_intr['meta'] = {'add_view':'abc', 'is_service':True}
        ct_intr['content_type'] = 'Content'
        ct_intr = DummyIntrospectable(introspectable=ct_intr)
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'abc'
        view_intr1['context'] = None
        view_intr1['derived_callable'] = None
        intr = {}
        intr['tab_title'] = 'abc'
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr1,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(ct_intr,), (intr,)])
        context = testing.DummyResource()
        inst = self._makeOne(context, request) 
        result = inst.sdi_add_views()
        self.assertEqual(
            result,
            [{
                    'url': '/mgmt_path',
                    'type_name': 'Content',
                    'icon': '',
                    'content_type':'Content',
                    }])

class Test_generate_text_filter_terms(unittest.TestCase):
    def _callFUT(self, filter_text):
        from substanced.folder.views import generate_text_filter_terms
        return generate_text_filter_terms(filter_text)

    def test_with_glob_pattern(self):
        filter_text = 'foo bar*'
        terms = self._callFUT(filter_text)
        self.assertEqual(terms, ['foo*', 'bar*'])

    def test_without_glob_pattern(self):
        filter_text = 'foo bar'
        terms = self._callFUT(filter_text)
        self.assertEqual(terms, ['foo*', 'bar*'])

    def test_without_glob_pattern_term_is_single_letter(self):
        filter_text = 'foo b'
        terms = self._callFUT(filter_text)
        self.assertEqual(terms, ['foo*'])
        
    def test_with_phrase_pattern(self):
        filter_text = 'foo "bar baz" "bar"'
        terms = self._callFUT(filter_text)
        self.assertEqual(terms, ['"bar baz"', '"bar"', 'foo*'])

    def test_with_phrase_pattern_no_end_quote(self):
        filter_text = 'foo "bar baz bar'
        terms = self._callFUT(filter_text)
        self.assertEqual(terms, ['"bar baz bar"', 'foo*'])

    def test_with_phrase_pattern_no_end_quote2(self):
        filter_text = 'foo "bar baz bar" "ab'
        terms = self._callFUT(filter_text)
        self.assertEqual(terms, ['"bar baz bar"', '"ab"', 'foo*'])
        
class DummyContainer(object):
    oid_store = {}

    def __init__(self, exc=None):
        self.exc = exc

    def check_name(self, name):
        if self.exc:
            raise self.exc
        return name

class DummyContent(object):
    def __init__(self, **kw):
        self.__dict__.update(kw)

    def create(self, iface, *arg, **kw):
        return getattr(self, iface, None)

    def metadata(self, context, name, default=None):
        return getattr(self, name, default)

    def typeof(self, resource):
        return 'Type'

class DummyPost(dict):
    def __init__(self, getall_result=(), get_result=None):
        self.getall_result = getall_result
        self.get_result = get_result

    def getall(self, name): # pragma: no cover
        return self.getall_result

    def get(self, name, default=None):
        if self.get_result is None: # pragma: no cover
            return default
        return self.get_result

class DummySDIAPI(object):
    def mgmt_path(self, *arg, **kw):
        return '/mgmt_path'
    def flash(self, msg, queue='info'):
        self.flashed = msg
    flash_with_undo = flash

class DummyFolder(testing.DummyResource):
    def is_ordered(self):
        return False

class DummyCatalogs(testing.DummyResource):
    def __init__(self):
        from zope.interface import directlyProvides
        from ...interfaces import IService
        testing.DummyResource.__init__(self)
        directlyProvides(self, IService)

class DummyCatalog(object):
    def __init__(self, result=()):
        if result is not None:
            result = DummyResultSet(result)
        self.result = result

    def __getitem__(self, name):
        result = self.result
        if result is not None:
            result = DummyIndex(name, self.result)
        return result

    def get(self, name, default=None):
        return self[name]

class DummyResultSet(object):
    def __init__(self, result):
        self.ids = result

    def sort(self, *arg, **kw):
        return self

    def __len__(self):
        return len(self.ids)

class DummyIndex(object):
    def __init__(self, name, result):
        self.name = name
        self.result = result
        self.queried = None
        self.anded_with = []

    def execute(self):
        return self.result
        
    def eq(self, *arg, **kw):
        self.queried = ('eq', arg, kw)
        return self

    def notany(self, *arg, **kw):
        self.queried = ('notany', arg, kw)
        return self

    def any(self, *arg, **kw):
        self.queried = ('any', arg, kw)
        return self

    def __and__(self, other):
        self.anded_with.append(other)
        return self

    def check_query(self, querytext):
        return True

    def allows(self, *arg, **kw):
        self.queried = ('allows', arg, kw)
        return self

def _makeCatalogs(oids=()):
    from zope.interface import directlyProvides
    from ...interfaces import IFolder
    from ...interfaces import IService
    catalogs = DummyCatalogs()
    directlyProvides(catalogs, (IFolder, IService))
    catalog = DummyCatalog(oids)
    catalogs['system'] = catalog
    return catalogs
    
class DummyObjectMap(object):
    def __init__(self, result):
        self.result = result
    def object_for(self, oid):
        return self.result

class DummyVenusianInfo(object):
    scope = 'notaclass'
    module = sys.modules['substanced.folder.tests.test_views']
    codeinfo = 'codeinfo'

class DummyVenusian(object):
    def __init__(self, info=None):
        if info is None:
            info = DummyVenusianInfo()
        self.info = info
        self.attachments = []

    def attach(self, wrapped, callback, category=None, depth=1):
        self.attachments.append((wrapped, callback, category))
        self.depth = depth
        return self.info

class DummyRegistry(object):
    pass

class DummyConfig(object):
    _ainfo = None
    def __init__(self):
        self.settings = []
        self.registry = DummyRegistry()

    def add_folder_contents_views(self, **kw):
        self.settings.append(kw)

    add_mgmt_view = add_folder_contents_views

    def with_package(self, pkg):
        self.pkg = pkg
        return self

class Dummy(object):
    pass

class DummyVenusianContext(object):
    def __init__(self):
        self.config = DummyConfig()
    
def call_venusian(venusian, context=None):
    if context is None:
        context = DummyVenusianContext()
    for wrapped, callback, category in venusian.attachments:
        callback(context, None, None)
    return context.config

class DummyIntrospector(object):
    def __init__(self, results=()):
        self.results = list(results)

    def get_category(self, *arg):
        if self.results:
            return self.results.pop(0)
        return ()

class DummyIntrospectable(dict):
    def __init__(self, **kw):
        dict.__init__(self, **kw)


########NEW FILE########
__FILENAME__ = views
import functools
import itertools
import operator
import re

import colander
import venusian

from pyramid.decorator import reify
from pyramid.httpexceptions import HTTPFound
from pyramid.security import has_permission
from pyramid.util import action_method

from substanced._compat import escape
from substanced.form import FormView
from substanced.interfaces import IFolder
from substanced.interfaces import IService
from substanced.objectmap import find_objectmap
from substanced.schema import Schema
from substanced.util import (
    JsonDict,
    get_oid,
    find_catalog,
    get_icon_name,
    )
from substanced._compat import u

from ..sdi import (
    default_sdi_addable,
    mgmt_view,
    sdi_mgmt_views,
    RIGHT,
    )
from ..util import _

from . import FolderKeyError

_marker = object()


class folder_contents_views(object):
    """ Decorator which causes a set of custom folder contents views to be
    added to the system; declarative variant of
    ``config.add_folder_contents_views``. Accepts the same arguments as
    ``add_folder_contents_views`` in its constructor, e.g.::

      from substanced.sdi,folder import (
          FolderContents,
          folder_contents_views,
          )
      
      @folder_contents_views(name='mycontents')
      class MyFolderContents(FolderContents):
          pass

    This is equivalent to imperatively registering new folder contents views
    like so::

      config.add_folder_contents_views(
          cls=MyFolderContents, name='mycontents'
          )

    Like ``view_config``, and ``mgmt_view``, the decorator must be found via a
    scan to have any effect.
    
    """
    venusian = venusian # for testing injection
    def __init__(self, **settings):
        self.settings = settings

    def __call__(self, wrapped):
        settings = self.settings.copy()
        depth = settings.pop('_depth', 0)
        
        def callback(context, name, ob):
            config = context.config.with_package(info.module)
            config.add_folder_contents_views(cls=ob, **settings)

        info = self.venusian.attach(
            wrapped,
            callback,
            category='substanced',
            depth=depth+1
            )

        settings['_info'] = info.codeinfo # fbo "action_method"
        return wrapped

def rename_duplicated_resource(context, name):
    """Finds next available name inside container by appending
    dash and positive number.
    """
    if name not in context:
        return name

    m = re.search(r'-(\d+)$', name)
    if m:
        new_id = int(m.groups()[0]) + 1
        new_name = name.rsplit('-', 1)[0] + u('-%d') % new_id
    else:
        new_name = name + u('-1')

    if new_name in context:
        return rename_duplicated_resource(context, new_name)
    else:
        return new_name

@colander.deferred
def name_validator(node, kw):
    context = kw['request'].context

    def namecheck(node, value):
        try:
            context.check_name(value)
        except Exception as e:
            raise colander.Invalid(node, e.args[0], value)

    return colander.All(
        colander.Length(min=1, max=100),
        namecheck,
        )

class AddFolderSchema(Schema):
    name = colander.SchemaNode(
        colander.String(),
        validator=name_validator,
        )

@mgmt_view(
    context=IFolder,
    name='add_folder',
    tab_condition=False,
    permission='sdi.add-content',
    renderer='substanced.sdi:templates/form.pt'
    )
class AddFolderView(FormView):
    title = _('Add Folder')
    schema = AddFolderSchema()
    buttons = ('add',)

    def add_success(self, appstruct):
        registry = self.request.registry
        name = appstruct['name']
        folder = registry.content.create('Folder')
        self.context[name] = folder
        return HTTPFound(location=self.request.sdiapi.mgmt_path(self.context))

@folder_contents_views()
class FolderContents(object):
    """ The default folder contents views class """

    minimum_load = 40

    def __init__(self, context, request):
        self.context = context
        self.request = request
        
    def get_default_buttons(self):
        """ The default buttons content-type hook """
        context = self.context
        request = self.request
        
        buttons = []
        finish_buttons = []

        if 'tocopy' in request.session:
            finish_buttons.extend(
                [
                {'id': 'copy_finish',
                  'name': 'form.copy_finish',
                  'class': 'btn-primary btn-sdi-act',
                  'value': 'copy_finish',
                  'text': _('Copy here')},
                {'id': 'cancel',
                 'name': 'form.copy_finish_cancel',
                 'class': 'btn-danger btn-sdi-act',
                 'value': 'cancel',
                 'text': _('Cancel')},
                ])

        if 'tomove' in request.session:
            finish_buttons.extend(
                [{'id': 'move_finish',
                  'name': 'form.move_finish',
                  'class': 'btn-primary btn-sdi-act',
                  'value': 'move_finish',
                  'text': _('Move here')},
                 {'id': 'cancel',
                  'name': 'form.move_finish_cancel',
                  'class': 'btn-danger btn-sdi-act',
                  'value': 'cancel',
                  'text': _('Cancel')}])

        if finish_buttons:
            buttons.append(
              {'type':'single', 'buttons':finish_buttons}
              )

        if not 'tomove' in request.session and not 'tocopy' in request.session:

            can_manage = bool(
                has_permission('sdi.manage-contents', context, request)
                )

            def delete_enabled_for(folder, resource, request):
                """
                This function considers a subobject 'deletable' if the user has
                the ``sdi.manage-contents`` permission on ``folder`` or if the
                subobject has a ``__sdi_deletable__`` attribute which resolves
                to a boolean ``True`` value.

                This function honors one subobject hook::
                ``__sdi_deletable__``.  If a subobject has an attribute named
                ``__sdi_deletable__``, it is expected to be either a boolean or
                a callable.  If ``__sdi_deletable__`` is a boolean, the value
                is used verbatim.  If ``__sdi_deletable__`` is a callable, the
                callable is called with two positional arguments: the subobject
                and the request; the result is expected to be a boolean.  If a
                subobject has an ``__sdi_deletable__`` attribute, and its
                resolved value is not ``None``, the delete button will be off
                if it's a boolean False.  If ``__sdi_deletable__`` does not
                exist on a subobject or resolves to ``None``, the delete button
                will be turned off if current user does not have the
                ``sdi.manage-contents`` permission on the ``folder``.
                """
                deletable = getattr(resource, '__sdi_deletable__', None)
                if deletable is not None:
                    if callable(deletable):
                        deletable = deletable(resource, request)
                if deletable is None:
                    deletable = can_manage
                deletable = bool(deletable) # cast return/attr value to bool
                return deletable

            main_buttons = [
                 {'id': 'rename',
                  'name': 'form.rename',
                  'class': 'btn-default btn-sdi-sel',
                  'enabled_for':delete_enabled_for,
                  'value': 'rename',
                  'text': _('Rename')},
                  {'id': 'copy',
                  'name': 'form.copy',
                  'class': 'btn-default btn-sdi-sel',
                  'value': 'copy',
                  'text': _('Copy')},
                  {'id': 'move',
                  'name': 'form.move',
                  'class': 'btn-default btn-sdi-sel',
                  'enabled_for':delete_enabled_for,
                  'value': 'move',
                  'text': _('Move')},
                  {'id': 'duplicate',
                  'name': 'form.duplicate',
                  'class': 'btn-default btn-sdi-sel',
                  'value': 'duplicate',
                  'text': _('Duplicate')}
                  ]

            buttons.append({'type': 'group', 'buttons':main_buttons})

            delete_buttons = [
                  {'id': 'delete',
                   'name': 'form.delete',
                   'class': 'btn-danger btn-sdi-sel',
                   'enabled_for':delete_enabled_for,
                   'value': 'delete',
                   'text': _('Delete')},
                   ]

            buttons.append({'type': 'group', 'buttons':delete_buttons})

        return buttons

    def get_buttons(self):
        context = self.context
        request = self.request
        defaults = self.get_default_buttons()
        buttonsfn = request.registry.content.metadata(
            context,
            'buttons',
            _marker
            )
        if buttonsfn is None:
            return []
        if buttonsfn is _marker:
            return defaults
        else:
            return buttonsfn(context, request, defaults)

    def get_default_columns(self, resource):
        request = self.request
        name = getattr(resource, '__name__', '')
        icon = get_icon_name(resource, request) or ''
        url = request.sdiapi.mgmt_path(resource, '@@manage_main')
        ct = self.request.registry.content.typeof(resource) or ''
        title = "%s '%s'" % (ct, escape(name, True)) # True==quote quotechars
        value = (
            '<i class="%s" title="%s"> </i> <a href="%s">%s</a>' %
                (icon, title, url, name)
            )
        columns = [
            {'name': request.localizer.translate(_('Name')),
             'value': value,
             'formatter': 'html',
             'sorter': self._name_sorter}
            ]
        return columns

    def get_columns(self, resource):
        context = self.context
        request = self.request
        defaults = self.get_default_columns(resource)
        columnsfn = request.registry.content.metadata(
            context,
            'columns',
            _marker
            )
        if columnsfn is None:
            return []
        if columnsfn is _marker:
            return defaults
        else:
            return columnsfn(context, resource, request, defaults)

    def get_options(self):
        # #33, allow overriding the grid's rowHeight among other
        # grid options. Like get_columns, you subclass to let a
        # custom contents view change the behavior of the grid.

        return dict(
            editable=False,
            enableAddRow=False,
            enableCellNavigation=True,
            asyncEditorLoading=True,
            forceFitColumns=True,
            rowHeight=35,
            )

    def get_default_query(self):
        """ The default query function for a folder """
        system_catalog = self.system_catalog
        folder = self.context
        path = system_catalog['path']
        interfaces = system_catalog['interfaces']
        allowed = system_catalog['allowed']
        q = ( path.eq(folder, depth=1, include_origin=False) &
              interfaces.notany([IService]) &
              allowed.allows(self.request, 'sdi.view')
            )
        return q

    get_query = get_default_query

    @reify
    def system_catalog(self):
        return find_catalog(self.context, 'system')

    def modified_items(self):
        items = self.request.POST.get('item-modify', '').split('/')
        modified = [x for x in  items if x] # remove empty
        return modified

    def get_filter_values(self):
        request = self.request
        filter_values = []
        for k, v in request.params.items():
            if v is not None and k.startswith('filter'):
                name = k[6:]
                if name.startswith('.'):
                    name = name[1:]
                filter_values.append((name, v))
        return filter_values

    def get_redirect_response(self):
        request = self.request
        context = self.context
        qs = [ ('filter.' + k, v) for k, v in self.get_filter_values() ]
        return HTTPFound(
            request.sdiapi.mgmt_path(context, '@@' + request.view_name,
                                     _query=qs)
            )

    def show_checkbox_column(self, button_groups, columns, resultset):
        show_checkbox_column = False
        for button_group in button_groups:
            if len(button_group.get('buttons', [])):
                show_checkbox_column = True
        return show_checkbox_column

    def _name_sorter(self, resource, resultset, limit=None, reverse=False):
        index = self.system_catalog.get('name')
        if index is not None:
            resultset = resultset.sort(index, limit=limit, reverse=reverse)
        return resultset

    def _column_headers(self, columns):
        is_ordered = self.context.is_ordered()

        headers = []

        for order, column in enumerate(columns):
            name = column['name']
            sortable = column.get('sorter', None) is not None
            if sortable and not column.get('resortable', True):
                # allow column to specify a sorter but claim it's not resortable
                sortable = False

            if is_ordered:
                # We don't currently allow ordered folders to be resorted by
                # columns
                sortable = False

            formatter = column.get('formatter', '')
            editor = column.get('editor', '')
            validator = column.get('validator', '')
            width = int(column.get('width', 120))
            min_width = int(column.get('min_width', 120))

            css_class = column.get('css_class', '')
            css_name = name.replace(' ', '-')
            css_class = ("cell-%s %s" % (css_name, css_class)).strip()

            # XXX CM: Do we really need all of "id", "name", and "field" below?
            # Ree XXX RB The names are a bit messed up, the way slickgrid
            # defines them.  We probably only need 2 of id, name, field (the
            # field identifier called 'field', and the field label that is
            # called 'name') and could generate the third one on the client.

            headers.append({
                "id": name,
                "name": name,
                "field": name,
                "width": width,
                "minWidth": min_width,
                "cssClass": css_class,
                "sortable": sortable,
                "formatterName": formatter,
                "editorName": editor,
                "validatorName": validator,
            })

        return headers

    def _sort_info(self, columns, sort_column_name=None):
        context = self.context

        sort_column = None
        sorter = None
        
        # Is the folder content ordered?
        is_ordered = context.is_ordered()

        if is_ordered:
            # If the folder is ordered, use the folder itself as the sort
            # index; ordered folders cannot currently be viewed reordered
            # by anything except their explicit ordering.
            def sorter(folder, resultset, reverse=False, limit=None):
                return resultset.sort(folder, limit=limit, reverse=reverse)

        elif sort_column_name is None:
            # The default sort always uses the intitial_sort_column, defaulting
            # to the first column with a sorter if no initial_sort_colun is
            # found
            first = True
            for col in columns:
                if col.get('sorter'):
                    if first is True or col.get('initial_sort_column'):
                        sort_column_name = col['name']
                        sort_column = col
                        first = False

        else:
            # Nondefault sort column
            for col in columns:
                if col.get('name') == sort_column_name:
                    sort_column = col
                    break

        if sort_column is not None:
            sorter = sort_column['sorter']
            
        return {
            'column':sort_column,
            'column_name':sort_column_name,
            'sorter':sorter,
            }
   
    def _global_text_filter(self, context, filter_text, q):
        terms = generate_text_filter_terms(filter_text)
        text = self.system_catalog['text']
        for term in terms:
            if text.check_query(term):
                q = q & text.eq(term)
        return q
    
    def _folder_contents(
        self,
        start=None,
        end=None,
        reverse=None,
        sort_column_name=None,
        filter_values=(),
        ):

        """
        Returns a dictionary containing:

        ``length``

          The folder's length (ie. `len(folder)`)
          
        ``records``

          A sequence of dictionaries that represent the folder's subobjects.
          The sequence is implemented as a generator.  Each dictionary in the
          ``records`` sequence reflects information about a single subobject in
          the folder, and will have the following keys:

          ``name``

            The name of the subobject.

          ``url``

            The URL to the subobject.  This will be
            ``/path/to/subob/@@manage_main``.

          ``columns``

            The column values obtained from this subobject's attributes, as
            defined by the ``columns`` content-type hook (or the default
            columns, if no hook was supplied).
          
        ``sort_column_name``

          The crrent sort_column_name

        ``sort_reverse``

          True if the current sort should be reversed.

        ``columns``

          A sequence of column header values.
        
        XXX TODO Document ``sort_column_name``, ``reverse``, and
        ``filter_values`` arguments.  Document ``columns`` return value.
        """
        folder = self.context
        request = self.request
        objectmap = find_objectmap(folder)

        if start is None:
            start = 0

        if end is None:
            end = start + self.minimum_load

        q = self.get_query()

        columns = self.get_columns(None)

        for name, value in filter_values:
            if name:
                for col in columns:
                    if col['name'] == name:
                        filt = col.get('filter')
                        if filt is not None:
                            q = filt(folder, value, q)
            else:
                q = self._global_text_filter(folder, value, q)

        resultset = q.execute()
        # NB: must take snapshot of folder_length before limiting the length
        # of the resultset via any sort
        folder_length = len(resultset)
        sort_info = self._sort_info(
            columns,
            sort_column_name=sort_column_name,
            )

        sorter = sort_info['sorter']
        sort_column_name = sort_info['column_name']
        if reverse is None:
            reverse = False
            column = sort_info['column']
            if column:
                reverse = column.get('initial_sort_reverse', False)

        if sorter is not None:
            resultset = sorter(
                folder, resultset, reverse=reverse, limit=end
                )

        buttons = self.get_buttons()
        show_checkbox_column = self.show_checkbox_column(
            buttons, columns, resultset)

        records = []

        for oid in itertools.islice(resultset.ids, start, end):
            resource = objectmap.object_for(oid)
            name = getattr(resource, '__name__', '')
            record = dict(
                # Use the unique name as an id.  (A unique row id is needed
                # for slickgrid.  In addition, we will pass back this same id
                # from the client, when a row is selected for an operation.)
                id=name,
                name=name,
                )
            cols = self.get_columns(resource)
            for col in cols:
                # XXX CM: adding arbitrary keys to the record based on
                # configuration input is a bad idea here because we can't
                # guarantee a column name won't override the "reserved" names
                # (name, id) added to the record above.  Ree?
                cname = col['name']
                record[cname] = col['value']
            disable = []
            for button_group in buttons:
                for button in button_group['buttons']:
                    if 'enabled_for' not in button:
                        continue
                    condition = button['enabled_for']
                    if not callable(condition):
                        continue
                    if not condition(folder, resource, request):
                        disable.append(button['id'])
            record['disable'] = disable
            records.append(record)

        return {
            'length':folder_length,
            'records':records,
            'sort_column_name':sort_column_name,
            'sort_reverse':reverse,
            'columns':columns,
            'show_checkbox_column':show_checkbox_column,
            }

    def show(self):
        request = self.request
        context = self.context

        buttons = self.get_buttons()

        addables = self.sdi_add_views()

        # construct the default slickgrid widget options
        slickgrid_options = self.get_options()

        is_reorderable = context.is_reorderable()

        end = self.minimum_load # load at least this many records.
        start = 0 # start at record number zero

        filter_values = self.get_filter_values()
        folder_contents = self._folder_contents(
            start,
            end,
            filter_values=filter_values
            )

        records = folder_contents['records']
        folder_length = folder_contents['length']
        sort_column_name = folder_contents['sort_column_name']
        sort_reverse = folder_contents['sort_reverse']
        show_checkbox_column = folder_contents['show_checkbox_column']
        column_headers = self._column_headers(folder_contents['columns'])

        items  = {
            'from':start,
            'records':records,
            'total':folder_length,
            }

        # We pass the wrapper options which contains all information
        # needed to configure the several components of the grid config.

        slickgrid_wrapper_options = JsonDict(
            # below line refers to slickgrid-config.js
            configName = 'sdi-content-grid',
            columns = column_headers,
            slickgridOptions = slickgrid_options,
            items = items,
            # initial sorting (The grid will really not sort the initial data,
            # just display it in the order we provide it. It will use the
            # information to just visually show in the headers the sorted
            # column.)
            sortCol = sort_column_name,
            sortDir = (not sort_reverse),
            # is the grid reorderable?
            isReorderable = is_reorderable,
            #
            # Parameters for the remote data model
            url = '',   # use same url for ajax
            minimumLoad = end,
            showCheckboxColumn = show_checkbox_column,
            # csrf needed for post requests
            csrfToken = request.session.get_csrf_token(),
            )

        result = dict(
            addables = addables,
            buttons = buttons,
            slickgrid_wrapper_options = slickgrid_wrapper_options,
            )

        return result

    def show_json(self):
        return self._get_json()

    def _get_json(self):
        request = self.request
        if 'from' in request.params:
            start = int(request.params.get('from'))
            end = int(request.params.get('to'))
            sort_column_name = request.params.get('sortCol')
            sort_dir = request.params.get('sortDir') in ('true', 'True')
            filter_values = self.get_filter_values()

            reverse = (not sort_dir)

            folder_contents = self._folder_contents(
                start,
                end,
                reverse=reverse,
                filter_values=filter_values,
                sort_column_name=sort_column_name,
                )

            folder_length = folder_contents['length']
            records = folder_contents['records']

            items = {
                'from': start,
                'records': records,
                'total': folder_length,
                }
        else:
            # If the request did not ask for an data update,
            # just return an empty dict.
            items = {}

        return items

    def delete(self):
        request = self.request
        context = self.context
        todelete = self.modified_items()
        deleted = 0
        for name in todelete:
            v = context.get(name)
            if v is not None:
                del context[name]
                deleted += 1
        ungettext = request.localizer.pluralize
        msg = ungettext('Deleted ${num} item',
                        'Deleted ${num} items',
                         deleted,
                         domain="substanced",
                         mapping=dict(num=deleted))
        request.sdiapi.flash_with_undo(msg, 'success')
        return self.get_redirect_response()

    def duplicate(self):
        request = self.request
        context = self.context
        toduplicate = self.modified_items()
        for name in toduplicate:
            newname = rename_duplicated_resource(context, name)
            context.copy(name, context, newname)
        ungettext = request.localizer.pluralize
        msg = ungettext('Duplicated ${num} item',
                        'Duplicated ${num} items',
                         len(toduplicate),
                         domain="substanced",
                         mapping=dict(num=len(toduplicate)))
        request.sdiapi.flash_with_undo(msg, 'success')
        return self.get_redirect_response()

    def rename(self):
        request = self.request
        context = self.context
        torename = self.modified_items()
        if not torename:
            request.sdiapi.flash('No items renamed', 'warning')
            return self.get_redirect_response()
        return dict(torename=[context.get(name)
                              for name in torename
                              if name in context])

    def rename_finish(self):
        request = self.request
        context = self.context

        if self.request.POST.get('form.rename_finish') == "cancel":
            request.sdiapi.flash(_('No items renamed'))
            return self.get_redirect_response()

        torename = request.POST.getall('item-rename')
        try:
            for old_name in torename:
                new_name = request.POST.get(old_name)
                context.rename(old_name, new_name)
        except FolderKeyError as e:
            self.request.sdiapi.flash(e.args[0], 'danger')
            raise self.get_redirect_response()

        ungettext = request.localizer.pluralize
        msg = ungettext('Renamed ${num} item',
                        'Renamed ${num} items',
                         len(torename),
                         domain="substanced",
                         mapping=dict(num=len(torename)))
        request.sdiapi.flash_with_undo(msg, 'success')
        return self.get_redirect_response()

    def copy(self):
        request = self.request
        context = self.context
        tocopy = self.modified_items()
        
        if tocopy:
            l = []
            for name in tocopy:
                obj = context.get(name)
                if obj is not None:
                    l.append(get_oid(obj))
            request.session['tocopy'] = l
            request.sdiapi.flash(_('Choose where to copy the items:'), 'info')
        else:
            request.sdiapi.flash(_('No items to copy'), 'warning')

        return self.get_redirect_response()

    def copy_finish_cancel(self):
        request = self.request
        del request.session['tocopy']
        request.sdiapi.flash(_('No items copied'), 'success')
        return self.get_redirect_response()

    def copy_finish(self):
        request = self.request
        context = self.context
        objectmap = find_objectmap(context)
        tocopy = request.session['tocopy']
        del request.session['tocopy']

        num_copied = 0

        try:
            for oid in tocopy:
                obj = objectmap.object_for(oid)
                copied = self.move_here_if_addable(obj, copy=True)
                if copied:
                    num_copied += 1
        except FolderKeyError as e:
            self.request.sdiapi.flash(e.args[0], 'danger')
            raise self.get_redirect_response()

        ungettext = request.localizer.pluralize
        msg = ungettext('Copied ${num} item',
                        'Copied ${num} items',
                         num_copied,
                         domain="substanced",
                         mapping=dict(num=num_copied))
        request.sdiapi.flash_with_undo(msg, 'success')
        return self.get_redirect_response()

    def move(self):
        request = self.request
        context = self.context
        tomove = self.modified_items()

        if tomove:
            l = []
            for name in tomove:
                obj = context.get(name)
                if obj is not None:
                    l.append(get_oid(obj))
            request.session['tomove'] = l
            request.sdiapi.flash(_('Choose where to move the items:'), 'info')
        else:
            request.sdiapi.flash(_('No items to move'), 'warning')

        return self.get_redirect_response()

    def move_finish_cancel(self):
        request = self.request
        del request.session['tomove']
        request.sdiapi.flash(_('No items moved'), 'success')
        return self.get_redirect_response()

    def move_finish(self):
        request = self.request
        context = self.context
        objectmap = find_objectmap(context)
        tomove = request.session['tomove']
        del request.session['tomove']

        num_moved = 0

        try:
            for oid in tomove:
                obj = objectmap.object_for(oid)
                moved = self.move_here_if_addable(obj)
                if moved:
                    num_moved += 1
        except FolderKeyError as e:
            self.request.sdiapi.flash(e.args[0], 'danger')
            raise self.get_redirect_response()

        ungettext = request.localizer.pluralize
        msg = ungettext('Moved ${num} item',
                        'Moved ${num} items',
                         num_moved,
                         domain="substanced",
                         mapping=dict(num=num_moved))
        request.sdiapi.flash_with_undo(msg, 'success')
        return self.get_redirect_response()

    def reorder_rows(self):
        request = self.request
        context = self.context
        item_modify = self.modified_items()
        insert_before = request.params.get('insert-before')
        if not insert_before:
            # '' or None means appending after the last item.
            insert_before = None
        context.reorder(item_modify, insert_before)
        msg = _('${i} rows moved.', mapping=dict(i=len(item_modify)))
        msg = request.sdiapi.get_flash_with_undo_snippet(
            request.localizer.translate(msg)
            )
        results = {
            'flash': msg,
            'flash_queue':'success',
            }
        # Generate content update as requested by the client.
        results.update(self._get_json())
        return results

    def get_addable_content_types(self):
        add_views = self.sdi_add_views()
        content_types = set([ x['content_type'] for x in add_views ])
        return content_types

    def move_here_if_addable(self, obj, copy=False):
        request = self.request
        context = self.context
        content_types = self.get_addable_content_types()
        obj_type = request.registry.content.typeof(obj)
        obj_name = obj.__name__
        if obj_type in content_types:
            if copy:
                obj.__parent__.copy(obj_name, context)
            else:
                obj.__parent__.move(obj_name, context)
            return True
        if copy:
            msg = _('"${obj_name}" is of a type (${obj_type}) that is not '
                    'addable here, refusing to copy',
                    mapping=dict(obj_name=obj_name, obj_type=obj_type))
        else:
            msg = _('"${obj_name}" is of a type (${obj_type}) that is not '
                    'addable here, refusing to move',
                    mapping=dict(obj_name=obj_name, obj_type=obj_type))
        self.request.sdiapi.flash(request.localizer.translate(msg), 'danger')
        return False

    def sdi_addable_content(self):
        registry = self.request.registry
        introspector = registry.introspector
        cts = []

        for data in introspector.get_category('substance d content types'):
            intr = data['introspectable']
            meta = intr['meta']

            if not meta.get('is_service', None):
                cts.append(data)

        return cts

    def sdi_add_views(self):
        candidates = {}

        for data in self.sdi_addable_content():
            intr = data['introspectable']
            meta = intr['meta']
            content_type = intr['content_type']
            viewname = meta.get('add_view')
            if viewname:
                if callable(viewname):
                    viewname = viewname(self.context, self.request)
                    if not viewname:
                        continue
                addable_here = getattr(
                    self.context,
                    '__sdi_addable__',
                    default_sdi_addable
                    )
                if addable_here is not None:
                    if callable(addable_here):
                        if not addable_here(self.context, intr):
                            continue
                    else:
                        if not content_type in addable_here:
                            continue
                type_name = meta.get('name', content_type)
                icon = meta.get('icon', '')
                data = dict(
                    type_name=type_name,
                    icon=icon,
                    content_type=content_type
                    )
                candidates[viewname] = data

        candidate_names = candidates.keys()
        views = sdi_mgmt_views(
            self.context,
            self.request,
            names=candidate_names
            )

        L = []

        for view in views:
            view_name = view['view_name']
            url = self.request.sdiapi.mgmt_path(self.context, '@@' + view_name)
            data = candidates[view_name]
            data['url'] = url
            L.append(data)

        L.sort(key=operator.itemgetter('type_name'))

        return L

def has_services(context, request):
    catalog = find_catalog(context, 'system')
    ifaces = catalog['interfaces']
    path = catalog['path']
    q = (
        path.eq(context, depth=1, include_origin=False) &
        ifaces.any([IService])
        )
    result = bool(len(q.execute()))
    return result

@folder_contents_views(
    name='services',
    tab_title=_('Services'),
    tab_near=RIGHT,
    view_permission='sdi.view-services',
    tab_condition=has_services,
    )
class FolderServices(FolderContents):

    def sdi_addable_content(self):
        registry = self.request.registry
        introspector = registry.introspector
        cts = []

        for data in introspector.get_category('substance d content types'):
            intr = data['introspectable']
            meta = intr['meta']

            if meta.get('is_service', None):
                cts.append(data)

        return cts

    def get_default_query(self):
        """ The default query function for a folder """
        system_catalog = self.system_catalog
        folder = self.context
        path = system_catalog['path']
        interfaces = system_catalog['interfaces']
        allowed = system_catalog['allowed']
        q = ( path.eq(folder, depth=1, include_origin=False) &
              interfaces.any([IService]) &
              allowed.allows(self.request, 'sdi.view')
            )
        return q

    get_query = get_default_query

PHRASE_RE = re.compile(r'"([^"]*)"?')

def generate_text_filter_terms(filter_text):
    terms = ['"%s"' % x for x in PHRASE_RE.findall(filter_text) ]
    remainder = PHRASE_RE.sub('', filter_text)
    # NB: do not try to glob terms less than 2 characters for performance
    # reasons
    nonphrases = [x for x in remainder.split() if len(x.strip()) > 1]
    for word in nonphrases:
        glob = word
        if not word.endswith('*'):
            glob = word + '*'
        terms.append(glob)
    return terms
        
@action_method
def add_folder_contents_views(
    config,
    cls=None,
    name='contents',
    context=None,
    renderer='substanced.folder:templates/contents.pt', # do not abbreviate
    view_permission='sdi.view',
    manage_contents_permission='sdi.manage-contents',
    tab_title=_("Contents"),
    tab_condition=True,
    tab_before=None,
    tab_after=None,
    tab_near=None,
    **predicates
    ):
    """
    A directive which adds a set of folder contents views.
    
    XXX the below was ripped out of its context from another method's docstring
    and needs to be recontextualized here.
    
    This function honors three content type hooks: ``icon``, ``buttons``,
    and ``columns``.

    The first content type hook is named ``icon``.  If the ``icon``
    supplied to the content type configuration of a subobject is a
    callable, the callable will be passed the subobject and the
    ``request``; it is expected to return an icon name or ``None``.
    ``icon`` may alternately be either ``None`` or a string representing a
    icon name instead of a callable.

    The second content type hook is named ``buttons``.  The folder contents
    view is a good place to wire up application specific functionality that
    depends on content selection, so the button toolbar that shows up at
    the bottom of the page is customizable. The default buttons can be
    overridden by supplying a ``buttons`` keyword argument to the content
    type argument list.  It must be a callable object which accepts
    ``context, request, default_buttonspec`` and which returns a list of
    dictionaries; each dictionary represents a button or a button group.

    The ``buttons`` callable you supply will be passed the ``context`` and
    the ``request`` and ``buttonspec`` (a sequence of default button
    specifications). It must return a list of dictionaries representing
    button specifications with at least a ``type`` key for the button
    specification type and a ``buttons`` key with a list of dictionaries
    representing the buttons. The ``type`` should be one of the string
    values ``group`` or ``single``. A group will display its buttons side
    by side, with no margin, while the single type will display each button
    separately.

    Each button in a ``buttons`` dictionary is rendered using the button
    tag and requires five keys: ``id`` for the button's id attribute,
    ``name`` for the button's name attribute, ``class`` for any additional
    css classes to be applied to it (see below), ``value`` for the value
    that will be passed as a request parameter when the form is submitted
    and ``text`` for the button's text.

    The ``class`` value is special because it will define the button's
    behavior. There are four mutually exclusive class names that can be
    used. ``btn-sdi-act`` is for buttons that will always be enabled,
    independently of any selected content items. ``btn-sdi-sel`` means
    the button will start as disabled and will only be enabled once one
    or more items are selected. ``btn-sdi-one`` means the button will
    only be enabled if there's exactly one item selected. Finally,
    ``btn-sdi-del`` means the button will stay disabled until one or
    more *deletable* items are selected. You *must* use one of these
    classes for the button to be enabled.
    
    The ``class`` value can contain several classes separated by spaces.
    In addition to the classes mentioned above, any custom css class or any
    bootstrap button class can be used.
    
    Finally, each button can optionally include an ``enabled_for`` key,
    which will point to a callable that will be passed a subobject from the
    current folder and must return True if the button should be enabled for
    that subobject or False if not.

    Most of the time, the best strategy for using the buttons callable will
    be to return a value containing the default buttonspec sequence passed
    in to the function (it will be a list).::

      def custom_buttons(context, request, default_buttonspec):
          def some_condition(folder, subobject, request):
              return getattr(context, 'can_use_button1', False)

          custom_buttonspec = [{'type': 'single',
                               'buttons': [{'id': 'button1',
                                            'name': 'button1',
                                            'class': 'btn-sdi-sel',
                                            'enabled_for': some_condition,
                                            'value': 'button1',
                                            'text': 'Button 1'},
                                           {'id': 'button2',
                                            'name': 'button2',
                                            'class': 'btn-sdi-act',
                                            'value': 'button2',
                                            'text': 'Button 2'}]}]
          return default_buttonspec + custom_buttonspec

      @content(
          'My Custom Folder',
          buttons=custom_buttons,
          )
      class MyCustomFolder(Persistent):
          pass

    Once the buttons are defined, a view needs to be registered to handle
    the new buttons. The view configuration has to set Folder as a context
    and include a ``request_param`` predicate with the same name as the
    ``value`` defined for the corresponding button. The following template
    can be used to register such views, changing only the ``request_param``
    value::

      @mgmt_view(
      context=IFolder,
      name='contents',
      renderer='substanced.folder:templates/contents.pt',
      permission='sdi.manage-contents',
      request_method='POST',
      request_param='button1',
      tab_condition=False,
      )
      def button1(context, request):
          # add button functionality here, then go back to contents
          request.sdiapi.flash('Just did what button1 does')
          return HTTPFound(request.sdiapi.mgmt_path(context, '@@contents'))

    Note that context has to be IFolder for this to work. If you need to
    restrict a button to some specific list of content types, the Pyramid
    ``content_type`` predicate can be used.

    The third content-type hook is named ``columns``.  To display the
    contents using a table with any given subobject attributes, a callable
    named ``columns`` can be passed to a content type as metadata.  When
    the folder contents SDI view is invoked against an object of the type,
    the ``columns`` callable will be passed the folder, a subobject, the
    ``request``, and a default column specification. It will be called once
    for every object in the folder to obtain column representations for
    each of its subobjects.  It must return a list of dictionaries with at
    least a ``name`` key for the column header and a ``value`` key with
    the correct column value given the subobject. The callable **must** be
    prepared to receive subobjects that will *not* have the desired
    attributes (the subobject passed will be ``None`` at least once in
    order for the system to compute headers).

    In addition to ``name`` and ``value``, the column dictionary may
    contain the keys ``sorter``, ``initial_sort_column``,
    ``initial_sort_reverse``, and ``formatter``. The ``sorter`` will either
    be ``None`` if the column is not sortable, or a callback which accepts
    a resource (the folder), a resultset, a ``limit`` keyword argument, and
    a ``reverse`` keyword argument and which must return a sorted result
    set.  The default ``sorter`` value is ``None``. The
    ``initial_sort_column`` should be the ``True`` if this column should
    be the initial sort column (it must also have a ``sorter``).  If no
    column is marked as the initial sort column, the first column with a
    ``sorter`` will be used as the initial sort column.  The
    ``initial_sort_reverse`` key can be ``True`` or ``False`` if you want
    the initial rendering to be sorted reverse or not.  The last key,
    ``formatter``, can give the name of a javascript method for formatting
    the ``value``.  Currently, available formatters are ``icon_label_url``
    and ``date``.
    
    The ``icon_label_url`` formatter gets the URL and icon (if any) of the
    subobject and creates a link using ``value`` as link text. The ``date``
    formatter expects that ``value`` is an ISO date and returns a text date
    in the format "<month name> <day>, <year>".

    Here's an example of using the ``columns`` content type hook::

      from substanced.util import find_index

      def sorter(folder, resultset, reverse=False, limit=None):
          index = find_index(folder, 'mycatalog', 'date')
          if index is not None:
              resultset = resultset.sort(
                                   index, reverse=reverse, limit=limit)
          return resultset

      def custom_columns(folder, subobject, request, default_columnspec):
          return default_columnspec + [
              {'name': 'Review Date',
               'value': getattr(subobject, 'review_date', ''),
               'sorter': sorter,
               'formatter': 'date'},
              {'name': 'Rating',
               'value': getattr(subobject, 'rating', '')}
              ]

      @content(
          'My Custom Folder',
          columns=custom_columns,
          )
      class MyCustomFolder(Persistent):
          pass
          
    In some cases, it might be needed to override the custom columns
    defined for an already existing content type. This can be accomplished
    by registering the content type a second time, but passing the columns
    then. For example, to add columns to the user folder content listing
    from substanced::
    
      from substanced import root_factory
      from substanced.interfaces import IUsers
      from substanced.principal import Users
      from myapp import custom_user_columns
      
      def main(global_config, **settings):
          config = Configurator(
              root_factory=root_factory,
              settings=settings
              )
          config.include('substanced')
          config.add_content_type(
              IUsers,
              factory=Users,
              icon='icon-list-alt',
              columns=custom_user_columns
              )
          config.scan()

    """

    if cls is None:
        cls = FolderContents

    if context is None:
        context = IFolder
        
    add_fc_view = functools.partial(
        config.add_mgmt_view,
        view=cls,
        name=name,
        renderer=renderer,
        context=context,
        tab_condition=False,
        **predicates
        )

    add_fc_view(
        request_method='GET',
        permission=view_permission,
        tab_condition=tab_condition,
        tab_before=tab_before,
        tab_after=tab_after,
        tab_near=tab_near,
        tab_title=tab_title,
        xhr=False,
        attr='show',
        )
    add_fc_view(
        request_method='GET',
        permission=view_permission,
        xhr=True,
        renderer='json',
        attr='show_json',
        )
    add_fc_view(
        request_method='POST',
        request_param='form.delete',
        permission=manage_contents_permission,
        check_csrf=True,
        attr='delete',
        )
    add_fc_view(
        request_method='POST',
        request_param='form.duplicate',
        permission=manage_contents_permission,
        check_csrf=True,
        attr='duplicate',
        )
    add_fc_view(
        request_method='POST',
        request_param='form.rename',
        permission=manage_contents_permission,
        renderer='templates/rename.pt',
        check_csrf=True,
        attr='rename',
        )
    add_fc_view(
        request_method='POST',
        request_param='form.rename_finish',
        permission=manage_contents_permission,
        check_csrf=True,
        attr='rename_finish',
        )
    add_fc_view(
        request_method='POST',
        request_param='form.copy',
        permission=view_permission,
        check_csrf=True,
        attr='copy',
        )
    add_fc_view(
        request_method='POST',
        request_param='form.copy_finish',
        permission=manage_contents_permission,
        check_csrf=True,
        attr='copy_finish',
        )
    add_fc_view(
        request_method='POST',
        request_param='form.copy_finish_cancel',
        permission=view_permission,
        check_csrf=True,
        attr='copy_finish_cancel',
        )
    add_fc_view(
        request_method='POST',
        request_param='form.move',
        permission=view_permission,
        check_csrf=True,
        attr='move',
        )
    add_fc_view(
        request_method='POST',
        request_param='form.move_finish',
        permission=manage_contents_permission,
        check_csrf=True,
        attr='move_finish',
        )
    add_fc_view(
        request_method='POST',
        request_param='form.move_finish_cancel',
        permission=view_permission,
        check_csrf=True,
        attr='move_finish_cancel',
        )
    add_fc_view(
        request_method='POST',
        renderer='json',
        request_param='ajax.reorder',
        permission=manage_contents_permission,
        check_csrf=True,
        attr='reorder_rows',
        )
        
def includeme(config): # pragma: no cover
    config.add_directive(
        'add_folder_contents_views',
        add_folder_contents_views,
        action_wrap=False
        )

########NEW FILE########
__FILENAME__ = tests
import os
import tempfile
import shutil
import unittest
from pyramid import testing
from pyramid.exceptions import ConfigurationError

class TestFormView(unittest.TestCase):
    def _getTargetClass(self):
        from . import FormView
        return FormView
        
    def _makeOne(self, context, request):
        klass = self._getTargetClass()
        inst = klass(context, request)
        return inst

    def test___call__show(self):
        schema = DummySchema()
        request = testing.DummyRequest()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        inst.schema = schema
        inst.form_class = DummyForm
        result = inst()
        self.assertEqual(result,
                         {'css_links': (), 'js_links': (), 'form': 'rendered'})

    def test___call__show_result_response(self):
        from webob import Response
        schema = DummySchema()
        request = testing.DummyRequest()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        inst.schema = schema
        inst.form_class = DummyForm
        response = Response()
        inst.show = lambda *arg: response
        result = inst()
        self.assertEqual(result, response)

    def test___call__button_in_request(self):
        schema = DummySchema()
        request = testing.DummyRequest()
        context = testing.DummyResource()
        request.POST['submit'] = True
        inst = self._makeOne(context, request)
        inst.schema = schema
        inst.buttons = (DummyButton('submit'), )
        inst.submit_success = lambda *x: 'success'
        inst.form_class = DummyForm
        result = inst()
        self.assertEqual(result, 'success')

    def test___call__button_in_request_validation_fails_w_handler(self):
        import deform.exception
        schema = DummySchema()
        request = testing.DummyRequest()
        context = testing.DummyResource()
        request.POST['submit'] = True
        def _validate(*args):
            exc = deform.exception.ValidationFailure(None, None, None)
            exc.render = lambda *arg: 'failure'
            raise exc
        inst = self._makeOne(context, request)
        inst.schema = schema
        inst.buttons = (DummyButton('submit'), )
        form, reqts = inst._build_form()
        form.validate = _validate
        inst._build_form = lambda *arg: (form, {'js': (), 'css': ()})
        def raiseit(*arg): #pragma NO COVER
            self.fail()
        inst.submit_success = raiseit # shouldn't get there
        inst.form_class = DummyForm
        result = inst()
        self.assertEqual(result,
                         {'css_links': (), 'js_links': (), 'form': 'failure'})

    def test___call__button_in_request_validateion_fails_wo_handler(self):
        import deform.exception
        schema = DummySchema()
        request = testing.DummyRequest()
        context = testing.DummyResource()
        request.POST['submit'] = True
        def _validate(*args):
            exc = deform.exception.ValidationFailure(None, None, None)
            exc.render = lambda *arg: 'failure'
            raise exc
        inst = self._makeOne(context, request)
        inst.schema = schema
        inst.buttons = (DummyButton('submit'), )
        form, reqts = inst._build_form()
        form.validate = _validate
        inst._build_form = lambda *arg: (form, {'js': (), 'css': ()})
        def raiseit(*arg): #pragma NO COVER
            self.fail()
        inst.submit_success = raiseit # shouldn't get there
        inst.form_class = DummyForm
        result = inst()
        self.assertEqual(result,
                         {'css_links': (), 'js_links': (), 'form': 'failure'})

    def test___call__button_in_request_fail(self):
        from . import FormError
        schema = DummySchema()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        context = testing.DummyResource()
        request.POST['submit'] = True
        inst = self._makeOne(context, request)
        inst.schema = schema
        inst.buttons = (DummyButton('submit'), )
        def raiseit(*arg):
            raise FormError()
        inst.submit_success = raiseit
        inst.form_class = DummyForm
        inst.submit_failure = lambda *arg: 'failure'
        result = inst()
        self.assertEqual(result,
                         {'css_links': (), 'js_links': (), 'form': 'rendered'})
        self.assertEqual(request.sdiapi.flashed,
                         '<div class="error">Failed: </div>')


class TestFileUploadTempStore(unittest.TestCase):
    def setUp(self):
        self.tempdir = tempfile.mkdtemp()

    def tearDown(self):
        shutil.rmtree(self.tempdir)
        
    def _getTargetClass(self):
        from . import FileUploadTempStore
        return FileUploadTempStore

    def _makeOne(self, request):
        return self._getTargetClass()(request)

    def _makeRequest(self):
        request = testing.DummyRequest()
        request.registry.settings = {}
        request.registry.settings['substanced.uploads_tempdir'] = self.tempdir
        request.session = DummySession()
        return request

    def test_no_tempdir_in_settings(self):
        request = testing.DummyRequest()
        request.registry.settings = {}
        self.assertRaises(ConfigurationError, self._makeOne, request)

    def test_preview_url(self):
        request = self._makeRequest()
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(request)
        self.assertEqual(inst.preview_url(None), '/mgmt_path')

    def test_contains_true(self):
        request = self._makeRequest()
        inst = self._makeOne(request)
        inst.session['substanced.tempstore'] = {}
        inst.session['substanced.tempstore']['a'] = 1
        self.assertTrue('a' in inst)
        
    def test_contains_false(self):
        request = self._makeRequest()
        inst = self._makeOne(request)
        self.assertFalse('a' in inst)

    def test_setitem_stream_None(self):
        request = self._makeRequest()
        inst = self._makeOne(request)
        inst['a'] = {}
        self.assertEqual(inst.session['substanced.tempstore']['a'], {})

    def test_setitem_stream_file(self):
        request = self._makeRequest()
        inst = self._makeOne(request)
        here = os.path.dirname(__file__)
        thisfile = os.path.join(here, 'tests.py')
        with open(thisfile, 'rb') as f:
            inst['a'] = {'fp': f}
            randid = inst.session['substanced.tempstore']['a']['randid']
            self.assertTrue(randid)
        with open(thisfile, 'rb') as g:
            fn = os.path.join(self.tempdir, randid)
            with open(fn, 'rb') as h:
                self.assertEqual(h.read(), g.read())

    def test_get_data_None(self):
        request = self._makeRequest()
        inst = self._makeOne(request)
        self.assertEqual(inst.get('a', True), True)

    def test_get_no_randid(self):
        request = self._makeRequest()
        inst = self._makeOne(request)
        inst.session['substanced.tempstore'] = {}
        inst.session['substanced.tempstore']['a'] = {'fp':True}
        self.assertEqual(inst.get('a'), {'fp':True})

    def test_get_with_randid(self):
        request = self._makeRequest()
        inst = self._makeOne(request)
        fn = os.path.join(self.tempdir, '1234')
        with open(fn, 'wb') as f:
            f.write(b'abc')
        inst.session['substanced.tempstore'] = {}
        inst.session['substanced.tempstore']['a'] = {'randid':'1234'}
        with open(fn, 'rb') as f:
            with inst.get('a')['fp'] as g:
                self.assertEqual(g.read(), f.read())

    def test_get_with_randid_file_doesntexist(self):
        request = self._makeRequest()
        inst = self._makeOne(request)
        inst.session['substanced.tempstore'] = {}
        inst.session['substanced.tempstore']['a'] = {'randid':'1234'}
        self.assertFalse('fp' in inst.get('a'))

    def test___getitem___notfound(self):
        request = self._makeRequest()
        inst = self._makeOne(request)
        self.assertRaises(KeyError, inst.__getitem__, 'a')
        
    def test___getitem___found(self):
        request = self._makeRequest()
        inst = self._makeOne(request)
        inst.session['substanced.tempstore'] = {}
        inst.session['substanced.tempstore']['a'] = {}
        self.assertEqual(inst['a'], {})

    def test_clear_exists(self):
        request = self._makeRequest()
        inst = self._makeOne(request)
        tmpfile = os.path.join(self.tempdir, 'abc')
        with open(tmpfile, 'wb') as f:
            f.write(b'foo')
        inst['a'] = {'randid':'abc'}
        inst.clear()
        self.assertFalse(os.path.exists(tmpfile))

    def test_clear_doesntexist(self):
        request = self._makeRequest()
        inst = self._makeOne(request)
        inst['a'] = {'randid':'abc'}
        inst.clear() # doesn't choke

class TestDeformRenderer(unittest.TestCase):
    def setUp(self):
        config = testing.setUp()
        config.include('pyramid_chameleon')

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self, dirs):
        from . import get_deform_renderer
        return get_deform_renderer(dirs)

    def test_functional_using_searchpath(self):
        from pkg_resources import resource_filename
        from .._compat import u
        default_dir = resource_filename('substanced.form', 'fixtures/')
        renderer = self._makeOne((default_dir,))
        result = renderer('test')
        self.assertEqual(result.strip(), u('<div>Test</div>'))

    def test_functional_using_assetspec(self):
        from .._compat import u
        renderer = self._makeOne(())
        result = renderer('substanced.form:fixtures/test.pt')
        self.assertEqual(result.strip(), u('<div>Test</div>'))

class DummyWidget(object):
    pass

class DummyForm(object):
    def __init__(self, schema, action=None, method=None, buttons=None,
                 formid=None, use_ajax=False, ajax_options='',
                 autocomplete=None):
        self.schema = schema
        self.action = action
        self.method = method
        self.buttons = buttons
        self.formid = formid
        self.use_ajax = use_ajax
        self.ajax_options = ajax_options
        self.autocomplete = autocomplete
        self.widget = DummyWidget()

    def get_widget_resources(self):
        return {'js':(), 'css':()}

    def render(self, appstruct=None):
        self.appstruct = appstruct
        return 'rendered'

    def validate(self, controls):
        return {'_csrf_token_':'abc', 'validated':'validated'}

class DummySchema(object):
    name = 'schema'
    title = 'Schema'
    description = 'Dummy schema for testing'
    required = True
    children = ()
    typ = None
    def bind(self, **kw):
        self.kw = kw
        return self
    def serialize(self, appstruct):
        return appstruct
    def cstruct_children(self, cstruct):
        return ()
    
class DummyButton(object):
    def __init__(self, name):
        self.name = name
        
class DummySession(dict):
    pass

class DummySDIAPI(object):
    def mgmt_path(self, *arg, **kw):
        return '/mgmt_path'
    def flash(self, msg, queue='info', allow_duplicate=True):
        self.flashed = msg

########NEW FILE########
__FILENAME__ = interfaces
#
#   This file is an always-safe-to-import API for substanced.
#
import datetime

from zope.interface.interfaces import IObjectEvent

from zope.interface import (
    Interface,
    Attribute,
    )

from zope.interface.interface import InterfaceClass

#
#   Interface-like base for defining reference types.
#
class ReferenceClass(InterfaceClass):
    def __init__(self, *arg, **kw):
        try:
            attrs = arg[2] or {}
        except IndexError:
            attrs = kw.get('attrs', {})
        si = attrs.pop('source_integrity', False)
        ti = attrs.pop('target_integrity', False)
        so = attrs.pop('source_ordered', False)
        to = attrs.pop('target_ordered', False)
        InterfaceClass.__init__(self, *arg, **kw)
        self.setTaggedValue('source_integrity', si)
        self.setTaggedValue('target_integrity', ti)
        self.setTaggedValue('source_ordered', so)
        self.setTaggedValue('target_ordered', to)

ReferenceType = ReferenceClass(
    "ReferenceType", __module__ = 'substanced.interfaces')

#
# subtanced.audit APIs
#
EARLIEST_DATE = datetime.datetime(1970, 1, 1)

#
# subtanced.catalog APIs
#
class ICatalog(Interface):
    """ A collection of indices. """

    objectids = Attribute(
        'a sequence of objectids that are cataloged in this catalog')

    def index_resource(resource, oid=None, action_mode=None):
        """Register the resource in indexes of this catalog using objectid
        ``oid``.  If ``oid`` is not supplied, the ``__oid__`` of the
        ``resource`` will be used.  ``action_mode``, if supplied, should be one
        of ``None``, :attr:`~substanced.interfaces.MODE_IMMEDIATE`,
        :attr:`~substanced.interfaces.MODE_ATCOMMIT` or
        :attr:`~substanced.interfaces.MODE_DEFERRED`."""

    def reindex_resource(resource, oid=None, action_mode=None):
        """Register the resource in indexes of this catalog using objectid
        ``oid``.  If ``oid`` is not supplied, the ``__oid__`` of the
        ``resource`` will be used.  ``action_mode``, if supplied, should be one
        of ``None``, :attr:`~substanced.interfaces.MODE_IMMEDIATE`,
        :attr:`~substanced.interfaces.MODE_ATCOMMIT` or
        :attr:`~substanced.interfaces.MODE_DEFERRED` indicating when the
        updates should take effect.  The ``action_mode`` value will overrule
        any action mode that a member index has been configured with.

        The result of calling this method is logically the same as calling
        ``unindex_resource``, then ``index_resource`` for the same resource/oid
        combination, but calling those two methods in succession is often more
        expensive than calling this single method, as member indexes can choose
        to do smarter things during a reindex than what they would do during an
        unindex then an index.
        """

    def unindex_resource(resource_or_oid, action_mode=None):
        """Deregister the resource in indexes of this catalog using objectid or
        resource ``resource_or_oid``.  If ``resource_or_oid`` is an integer, it
        will be used as the oid; if ``resource_or_oid`` is a resource, its
        ``__oid__`` attribute will be used as the oid.  ``action_mode``, if
        supplied, should be one of ``None``,
        :attr:`~substanced.interfaces.MODE_IMMEDIATE`,
        :attr:`~substanced.interfaces.MODE_ATCOMMIT` or
        :attr:`~substanced.interfaces.MODE_DEFERRED`."""

    def __getitem__(name):
        """ Return the index named ``name``"""

    def reset():
        """ Clear all indexes in this catalog and clear self.objectids. """

    def flush(immediate=True):
        """ Flush any pending indexing actions for all indexes in this catalog.
        If ``immediate`` is ``True``, *all* actions will be immediately
        executed.  If ``immediate`` is ``False``,
        :attr:`~substanced.interfaces.MODE_DEFERRED` actions will be sent to
        the actions processor if one is active, and all other actions will be
        executed immediately."""

    def reindex(dry_run=False, commit_interval=200, indexes=None,
                path_re=None, output=None):
        """\
        Reindex all objects in this collection of indexes.

        If ``dry_run`` is ``True``, do no actual work but send what would be
        changed to the logger.

        ``commit_interval`` controls the number of objects indexed between
        each call to ``transaction.commit()`` (to control memory
        consumption).

        ``indexes``, if not ``None``, should be a list of index names that
        should be reindexed.  If ``indexes`` is ``None``, all indexes are
        reindexed.

        ``path_re``, if it is not ``None`` should be a regular expression
        object that will be matched against each object's path.  If the
        regular expression matches, the object will be reindexed, if it does
        not, it won't.

        ``output``, if passed should be one of ``None``, ``False`` or a
        function.  If it is a function, the function should accept a single
        message argument that will be used to record the actions taken during
        the reindex.  If ``False`` is passed, no output is done.  If ``None``
        is passed (the default), the output will wind up in the
        ``substanced.catalog`` Python logger output at ``info`` level.
        """

    def update_indexes(
        registry=None,
        dry_run=False,
        output=None,
        replace=False,
        reindex=False,
        **kw):
        """ Use the candidate indexes registered via
        ``config.add_catalog_factory`` to populate this catalog."""

class ICatalogFactory(Interface):
    def replace(folder, reindex=False):
        """ Replace all the indexes in ``folder`` with the ones implied by this
        factory.  Reindex any added indexes if ``reindex`` is true."""

    def sync(folder, reindex=False):
        """ Synchronize all the indexes in ``folder`` with the ones implied by
        this factory.  Reindex any added indexes if ``reindex`` is true. """

class IIndexFactory(Interface):
    """ A factory for an index """

class IIndexView(Interface):
    def __call__(resource, default):
        """ Return a result for the index value related to the resource or the
        default."""

class IIndexingActionProcessor(Interface):
    """ Processor of deferred indexing/unindexing actions of
    catalogs in the system"""

# MODE_ sentinels are classes so that when one is pickled, then unpickled, the
# result can be compared against an imported version using "is".  They are
# interfaces so they have a stable __hash__ (their __hash__ will be called as a
# result of substanced.catalog.factory is_stale and other stuff in there).

class MODE_IMMEDIATE(Interface):
    """ Sentinel indicating that an indexing action should take place as
    immediately as possible."""

class MODE_ATCOMMIT(Interface):
    """ Sentinel indicating that an indexing action should take place at the
    successful end of the current transaction."""

class MODE_DEFERRED(Interface):
    """ Sentinel indicating that an indexing action should be performed by an
    external indexing processor (e.g. ``drain_catalog_indexing``) if one is
    active at the successful end of the current transaction.  If an indexing
    processor is unavailable at the successful end of the current transaction,
    this mode will be taken to imply the same thing as
    :attr:`~substanced.interfaces.MODE_ATCOMMIT`."""

#
# subtanced.editable APIs
#
class IEditable(Interface):
    """ Adapter interface for editing content as a file.
    """
    def get():
        """ Return ``(body_iter, mimetype)`` representing the context.

        - ``body_iter`` is an iterable, whose chunks are bytes represenating
          the context as an editable file.

        - ``mimetype`` is the MIMEType corresponding to ``body_iter``.
        """

    def put(fileish):
        """ Update context based on the contents of ``fileish``.

        - ``fileish`` is a file-type object:  its ``read`` method should
          return the (new) file representation of the context.
        """

#
# subtanced.event APIs
#
class IObjectWillBeAdded(IObjectEvent):
    """ An event type sent when an before an object is added """
    object = Attribute('The object being added')
    parent = Attribute('The folder to which the object is being added')
    name = Attribute('The name which the object is being added to the folder '
                     'with')
    moving = Attribute('None or the folder from which the object being added '
                       'was moved')
    loading = Attribute('Boolean indicating that this add is part of a load '
                        '(during a dump load process)')
    duplicating = Attribute('The object being duplicated or ``None``')

class IObjectAdded(IObjectEvent):
    """ An event type sent when an object is added """
    object = Attribute('The object being added')
    parent = Attribute('The folder to which the object is being added')
    name = Attribute('The name of the object within the folder')
    moving = Attribute('None or the folder from which the object being added '
                       'was moved')
    loading = Attribute('Boolean indicating that this add is part of a load '
                        '(during a dump load process)')
    duplicating = Attribute('The object being duplicated or ``None``')

class IObjectWillBeRemoved(IObjectEvent):
    """ An event type sent before an object is removed """
    object = Attribute('The object being removed')
    parent = Attribute('The folder from which the object is being removed')
    name = Attribute('The name of the object within the folder')
    moving = Attribute('None or the folder to which the object being removed '
                       'will be moved')
    loading = Attribute('Boolean indicating that this remove is part of a '
                        'load (during a dump load process)')

class IObjectRemoved(IObjectEvent):
    """ An event type sent when an object is removed """
    object = Attribute('The object being removed')
    parent = Attribute('The folder from which the object is being removed')
    name = Attribute('The name of the object within the folder')
    moving = Attribute('None or the folder to which the object being removed '
                       'will be moved')
    loading = Attribute('Boolean indicating that this remove is part of a '
                        'load (during a dump load process)')
    removed_oids = Attribute('The set of oids removed as the result of '
                             'this object being removed (including the oid '
                             'of the object itself).  This may be any number '
                             'of oids if the object was folderish')

class IObjectModified(IObjectEvent):
    """ May be sent when an object is modified """
    object = Attribute('The object being modified')

class IACLModified(IObjectEvent):
    """ May be sent when an object's ACL is modified """
    object = Attribute('The object being modified')
    old_acl = Attribute('The object ACL before the modification')
    new_acl = Attribute('The object ACL after the modification')

class IContentCreated(Interface):
    """ An event type sent when a Substance D content object is created
    via ``registry.content.create``"""
    object = Attribute('The freshly created content object.  It will not yet '
                       'have been seated into any folder.')
    content_type = Attribute('The content type of the object that was created')
    meta = Attribute('The metainformation about the content type in the '
                     'content registry')

class ILoggedIn(Interface):
    """ An event type sent when a user supplies a valid username and password
    to a login view.  Note that this event is not sent on *every* request that
    the user initiates, just ones which result in an interactive login."""
    login = Attribute('The login name used by the user')
    user = Attribute('The user object computed by Substance D')
    context = Attribute('The context resource that was active during login')
    request = Attribute('The request which resulted in the login')

class IRootAdded(Interface):
    """ An event type sent when the Substance D root object has a connection to
    the database as its ``_p_jar`` attribute. """
    object = Attribute('The root object')

#
# subtanced.evolution APIs
#

class IEvolutionSteps(Interface):
    """ Utility for obtaining evolution step data """

#
# subtanced.file APIs
#
class IFile(Interface):
    """ An object representing file content """

    blob = Attribute('The ZODB blob object holding the file content')

    mimetype = Attribute('The mimetype of the file content')

    def upload(stream, mimetype_hint=False):
        """ Replace the current contents of this file's blob with the
        contents of ``stream``.  ``mimetype_hint`` can be any of the
        folliwing:

        - ``None``, meaning don't reset the current mimetype.  This is the
          default.

        - A string containing a filename with an extension; the mimetype will
          be derived from the extension in the filename.

        - The constant :attr:`substanced.file.USE_MAGIC`, which will derive the
          content type using the ``python-magic`` library based on the
          stream's actual content.
        """

    def get_response(self, **kw):
        """ Return a WebOb-compatible response object which uses the blob
        content as the stream data and the mimetype of the file as the
        content type.  The ``**kw`` arguments will be passed to the
        :class:`pyramid.response.FileResponse` constructor as its keyword
        arguments."""

    def get_size(self):
        """ Return the size in bytes of the data in the blob associated with
        the file"""

#
# subtanced.folder APIs
#
marker = object() # default for pop(), etc.

class IFolder(Interface):
    """ A Folder which stores objects using Unicode keys.

    All methods which accept a ``name`` argument expect the
    name to either be Unicode or a byte string decodable using the
    default system encoding or the UTF-8 encoding."""

    def set_order(value, reorderable=None):
        """Makes the folder orderable and sets its order to the list of
        names provided in value. Names should be existing names for objects
        contained in the folder at the time order is set.

        If ``reorderable`` is passed, value, it must be ``None``, ``True`` or
        ``False``.  If it is ``None``, the reorderable flag will not be reset
        from its current value.  If it is anything except ``None``, it will be
        treated as a boolean and the reorderable flag will be set to that
        value.  The ``reorderable`` value of a folder will be returned by that
        folder's :meth:`~substanced.folder.Folder.is_reorderable` method.

        The :meth:`~substanced.folder.Folder.is_reorderable` method is used by
        the SDI folder contents view to indicate that the folder can or cannot
        be reordered via the web UI.

        If ``reorderable`` is set to ``True``, the
        :meth:`~substanced.folder.Folder.reorder` method will work properly,
        otherwise it will raise a :exc:`ValueError` when called.
        """

    def unset_order():
        """Removes the folder internal ordering, making it an unordered
        folder."""

    def is_ordered():
        """ Return ``True`` if the folder has a manual ordering (e.g. its
        ``order`` attribute has been set), ``False`` otherwise."""

    def is_reorderable():
        """ Return true if the folder can be reordered, false otherwise."""

    def reorder(items, before):
        """ Move one or more items from a folder into new positions inside that
        folder. ``items`` is a list of ids of existing folder items, which will
        be inserted in order before the item named ``before``. All other items
        are left in the original order.  If this method is called on a folder
        which does not have an order set, or which is not reorderable, a
        :exc:`ValueError` will be raised."""

    def sort(oids, reverse=False, limit=None):
        """ Return the intersection of the oids of the folder's order with the
        oids passed in.  If ``reverse`` is True, reverse the result set.  If
        ``limit`` is an integer, return only that number of items (after
        reversing, if reverse is True)."""

    def keys():
        """ Return an iterable sequence of object names present in the folder.

        Respect ``order``, if set.
        """

    def __iter__():
        """ An alias for ``keys``.

        Respect ``order``, if set.
        """

    def values():
        """ Return an iterable sequence of the values present in the folder.

        Respect ``order``, if set.
        """

    def items():
        """ Return an iterable sequence of (name, value) pairs in the folder.

        Respect ``order``, if set.
        """

    def get(name, default=None):
        """ Return the object named by ``name`` or the default.

        ``name`` must be a Unicode object or a bytestring object.

        If ``name`` is a bytestring object, it must be decodable using the
        system default encoding or the UTF-8 encoding.
        """

    def __contains__(name):
        """ Does the container contains an object named by name?

        ``name`` must be a Unicode object or a bytestring object.

        If ``name`` is a bytestring object, it must be decodable using the
        system default encoding or the UTF-8 encoding.
        """

    def __nonzero__():
        """ Always return True
        """

    def __len__():
        """ Return the number of subobjects in this folder.
        """

    def __getitem__(name):
        """ Return the object represented by ``name`` in this folder or raise
        a KeyError if no such object exists. """

    def __setitem__(name, other):
        """ Set object ``other`` into this folder under the name ``name``.

        ``name`` must be a Unicode object or a bytestring object.

        If ``name`` is a bytestring object, it must be decodable using the
        system default encoding or the UTF-8 encoding.

        ``name`` cannot be the empty string.

        When ``other`` is seated into this folder, it will also be
        decorated with a ``__parent__`` attribute (a reference to the
        folder into which it is being seated) and ``__name__``
        attribute (the name passed in to this function.

        If a value already exists in the foldr under the name ``name``, raise
        :exc:`KeyError`.

        When this method is called, emit an ``IObjectWillBeAdded`` event
        before the object obtains a ``__name__`` or ``__parent__`` value.
        Emit an ``IObjectAdded`` event after the object obtains a ``__name__``
        and ``__parent__`` value.
        """

    def add(name, other, send_events=True, reserved_names=(),
            duplicating=None, moving=None, loading=False, registry=None):
        """ Same as ``__setitem__``.

        If ``send_events`` is false, suppress the sending of folder events.
        Disallow the addition of the name provided is in the ``reserved_names``
        list.  If ``duplicating`` is not None, it must be the object being
        duplicated; when non-None, the ObjectWillBeAdded and ObjectAdded events
        sent will be marked as 'duplicating', which typically has the effect
        that the subobject's object id will be overwritten instead of reused.
        If ``registry`` is passed, it should be a Pyramid registry object;
        otherwise the :func:`pyramid.threadlocal.get_current_registry`
        function is used to look up the current registry.

        This method returns the name used to place the subobject in the
        folder (a derivation of ``name``, usually the result of
        ``self.check_name(name)``).
        """

    def validate_name(name, reserved_names=()):
        """
        Checks the name passed for validity.  If the name is valid and is not
        present in ``reserved_names`` returns a validated name.  Otherwise a
        :exc:`ValueError` will be raised."""

    def check_name(name, reserved_names=()):
        """ Performs all checks associated with ``validate_name`` but also
        raises a :class:`substanced.folder.FolderKeyError` if an object with
        the name ``name`` already exists in the folder.  Returns the name (with
        any modifications) returned by ``validate_name``."""

    def pop(name, default=None):
        """ Remove the item stored in the under ``name`` and return it.

        If ``name`` doesn't exist in the folder, and ``default`` **is not**
        passed, raise a :exc:`KeyError`.

        If ``name`` doesn't exist in the folder, and ``default`` **is**
        passed, return ``default``.

        When the object stored under ``name`` is removed from this folder,
        remove its ``__parent__`` and ``__name__`` values.

        When this method is called, emit an ``IObjectWillBeRemoved`` event
        before the object loses its ``__name__`` or ``__parent__`` values.
        Emit an ``ObjectRemoved`` after the object loses its ``__name__``
        and ``__parent__`` value,
        """

    def __delitem__(name):
        """ Remove the object from this folder stored under ``name``.

        ``name`` must be a Unicode object or a bytestring object.

        If ``name`` is a bytestring object, it must be decodable using the
        system default encoding or the UTF-8 encoding.

        If no object is stored in the folder under ``name``, raise a
        :exc:`KeyError`.

        When the object stored under ``name`` is removed from this folder,
        remove its ``__parent__`` and ``__name__`` values.

        When this method is called, emit an ``IObjectWillBeRemoved`` event
        before the object loses its ``__name__`` or ``__parent__`` values.
        Emit an ``IObjectRemoved`` after the object loses its ``__name__``
        and ``__parent__`` value,
        """

    def remove(name, send_events=True, moving=None, loading=False):
        """ Same thing as ``__delitem__``.

        If ``send_events`` is false, suppress the sending of folder events.  If
        ``moving`` is not ``None``, it should be the folder object from which
        the object is being moved; the events sent will indicate that a move is
        in process.
        """

    def move(name, other, newname=None):
        """
        Move a subobject named ``name`` from this folder to the folder
        represented by ``other``.  If ``newname`` is not none, it is used as
        the target object name; otherwise the existing subobject name is
        used.

        This operation is done in terms of a remove and an add.  The Removed
        and WillBeRemoved events sent will indicate that the object is
        moving.
        """

    def rename(oldname, newname):
        """
        Rename a subobject from oldname to newname.

        This operation is done in terms of a remove and an add.  The Removed
        and WillBeRemoved events sent will indicate that the object is
        moving.
        """
    def replace(name, newobject):
        """ Replace an existing object named ``name`` in this folder with a
        new object ``newobject``.  If there isn't an object named ``name`` in
        this folder, an exception will *not* be raised; instead, the new
        object will just be added.

        This operation is done in terms of a remove and an add.  The Removed
        and WillBeRemoved events will be sent for the old object, and the
        WillBeAdded and Add events will be sent for the new object.
        """

    def load(name, newobject):
        """
        Same as :meth:`substanced.interfaces.IFolder.replace` except it causes
        the ``loading`` flag of added and removed events sent during the add
        and remove events implied by the replacement to be ``True``.
        """

class IAutoNamingFolder(IFolder):
    def next_name(subobject):
        """Return a name (a string) based on the autonaming policy for this
        folder.  ``subobject`` is the object being added to the folder.
        Implementations are free to ignore the ``subobject`` that is passed.
        Implementations which don't require the subobject to generate a name
        should support ``None`` as the ``subobject`` argument, in case
        calling code just needs to generate a name without actually adding a
        subobject."""

    def add_next(
        subobject,
        send_events=True,
        duplicating=None,
        moving=None,
        registry=None,
        ):
        """Add a subobject, naming it automatically, giving it the name
        returned by this folder's ``next_name`` method.  It has the same
        effect as calling :meth:`substanced.folder.Folder.add`, but you
        needn't provide a name argument.

        This method returns the name of the subobject.
        """

#
# subtanced.locking APIs
#

class UserToLock(ReferenceType):
    """ A reference type which represents the relationship from a user to
    his set of locks """

class WriteLock(ReferenceType):
    """ Represents a DAV-style writelock.  It's a Substance D reference type
    from resource object to lock object"""

class ILockService(IAutoNamingFolder):
    def lock(resource, owner_or_ownerid, timeout=None, locktype=WriteLock):
        """

        Lock a resource using the lock service.  If the resource is already
        locked by the owner supplied as owner_or_ownerid, calling this method
        will refresh the lock.  If the resource is not already locked by
        another user, calling this method will create a new lock.  If the
        resource is already locked by a different user, a
        :class:`substanced.locking.LockError` will be raised.

        .. warning::

            Callers should assert that the owner has the ``sdi.lock``
            permission against the resource before calling this function to
            ensure that a user can't lock a resource he is not permitted to.

       """

    def unlock(resource, owner_or_ownerid):
        """

        Unlock a resource using the lock service.  If the resource is already
        locked by a user other than the owner supplied as owner_or_ownerid or
        the resource isn't already locked with this lock type, calling this
        method will raise a :class:`substanced.locking.LockError` exception.
        Otherwise the lock will be removed.

        .. warning::

           Callers should assert that the owner has the ``sdi.lock`` permission
           against the resource before calling this function to ensure that a
           user can't lock a resource he is not permitted to.
       """

#
# subtanced.objectmap APIs
#
class IObjectMap(Interface):
    """ A map of objects to paths and a reference engine """
    def objectid_for(obj_or_path_tuple):
        """ Return the object id for obj_or_path_tuple """

    def path_for(objectid):
        """ Return the path tuple for objectid """

    def object_for(objectid):
        """ Return the object associated with ``objectid`` or ``None`` if the
        object cannot be found."""

    def add(obj):
        """ Add a new object to the object map.  Assigns a new objectid to
        obj.__oid__ to the object if it doesn't already have one.  The
        object's path or objectid must not already exist in the map.  Returns
        the object id.
        """

    def remove(obj_objectid_or_path_tuple):
        """ Removes an object from the object map using the object itself, an
        object id, or a path tuple.  Returns a set of objectids (children,
        inclusive) removed as the result of removing this object from the
        object map."""

    def pathlookup(obj_or_path_tuple, depth=None, include_origin=True):
        """ Returns an iterator of document ids within
        obj_or_path_tuple (a traversable object or a path tuple).  If depth
        is specified, returns only objects at that depth.  If
        ``include_origin`` is ``True``, returns the docid of the object
        passed as ``obj_or_path_tuple`` in the returned set, otherwise it
        omits it."""

    def connect(src, target, reftype):
        """Connect ``src_object`` to ``target_object`` using the reference
        type ``reftype``.  ``src`` and ``target`` may be objects or object
        identifiers."""

    def disconnect(src, target, reftype):
        """Disonnect ``src_object`` from ``target_object`` using the
        reference type ``reftype``. ``src`` and ``target`` may be objects or
        object identifiers"""

    def sources(obj, reftype):
        """ Return a generator consisting of objects which have ``obj`` as a
        relationship source using ``reftype``.  ``obj`` can be an object or
        an object id."""

    def targets(obj, reftype):
        """ Return a generator consisting of objects which have ``obj`` as a
        relationship target using ``reftype``. ``obj`` can be an object or an
        object id."""

    def targetids(obj, reftype):
        """ Return a set of objectids which have ``obj`` as a relationship
        target using ``reftype``.  ``obj`` can be an object or an object id."""

    def sourceids(obj, reftype):
        """ Return a set of objectids which have ``obj`` as a relationship
        source using ``reftype``.  ``obj`` can be an object or an object id."""

#
# subtanced.prinicpal APIs
#
class IPrincipal(Interface):
    """ Marker interface representing a user or group """

class IUser(IPrincipal):
    """ Marker interface representing a user """

class IGroup(IPrincipal):
    """ Marker interface representing a group """

class IUsers(Interface):
    """ Marker interface representing a collection of users """

class IGroups(Interface):
    """ Marker interface representing a collection of groups """

class IPrincipals(Interface):
    """ Marker interface representing a container of users and groups """

class IPasswordResets(Interface):
    """ Marker interface representing a collection of password reset requests
    """

class IPasswordReset(Interface):
    """ Marker interface represent a password reset request """

class UserToGroup(ReferenceType):
    pass

class PrincipalToACLBearing(ReferenceType):
    source_integrity = True

class UserToPasswordReset(ReferenceType):
    pass

class IUserLocator(Interface):
    """ Adapter responsible for returning a user by his login name and/or
    userid as well as group objects of a user by his userid."""

    def get_user_by_login(login):
        """ Return an IUser object or ``None`` if no such user exists. The
        ``login`` argument is the *login name* of the user, not an oid."""

    def get_user_by_userid(userid):
        """ Return an IUser object or ``None`` if no such user exists. The
        ``userid`` argument is the *user id* of the user (usually an oid)."""

    def get_user_by_email(email):
        """ Return an IUser object or ``None`` if no such user exists. The
        ``email`` argument is the *email address* of the user."""

    def get_groupids(userid):
        """ Return all the group-related principal identifiers for a user with
        the user principal identifier ``userid`` as a sequence.  If no user
        exists under ``userid``, return ``None``."""

#
# subtanced.property APIs
#
class IPropertySheet(Interface):
    """ Interface for objects with a set of properties defined by a Colander
    schema.  The class :class:`substanced.property.PropertySheet` (which is
    meant to be subclassed for specialization) implements this interface."""
    context = Attribute('The context of the property sheet (a resource)')
    request = Attribute('The current request')
    schema = Attribute('The Colander schema instance which defines '
                       'the fields related to this property sheet')

    def get():
        """ Return a dictionary representing the current property state
        compatible with the schema for serialization"""

    def set(struct, omit=()):
        """ Accept ``struct`` (a dictionary representing the property state)
        and persist it to the context, refraining from persisting the keys in
        the struct that are named in ``omit`` (a sequence of strings or a
        string).  The data structure will have already been validated against
        the propertysheet schema.

        You can return a value from this method.  It will be passed as
        ``changed`` into the ``after_set`` method.  It should be ``False`` if
        your ``set`` implementation *did not* change any persistent data.  Any
        other return value will be conventionally interpreted as the
        implementation having changed persistent data.
        """

    def after_set(changed):
        """ Perform operations after a successful set.  ``changed`` is the
        value returned from the ``set`` method.

        The default propertysheet implementation sends an ObjectModified event
        if the ``changed`` value is not ``False.``
        """

#
# subtanced.root APIs
#
class IRoot(IFolder):
    pass

#
#   substanced.sdi APIs
#
class IService(Interface):
    """ Marker for items which are showin in the "Services" tab.
    """

class ISDIAPI(Interface):
    """  Easy access to common templating operations on all views.
    This object is available as ``request.sdiapi``.
    """

    main_template = Attribute("""The loaded ``master.pt`` which can
    be used in view templates with
    ``metal:use-macro="request.sdiapi.main_template"``.""")

    def get_macro(asset_spec, name=None):
        """ Return a Chameleon template macro based on the asset spec
        (e.g. ``somepackage:templates/foo.pt``) and the name.  If the name is
        None, the bare template implementation is returned, otherwise the named
        macro from within the template is returned. """

    def flash_with_undo(msg, queue='', allow_duplicate=True):
        """Display a Pyramid ``flash message`` to the appropriate
        queue with a button to allow an undo of the commit."""

    def mgmt_path(obj, *arg, **kw):
        """ Return the route_path inside the SDI for an object """

    def mgmt_url(obj, *arg, **kw):
        """ Return the route_url inside the SDI for an object """

    def breadcrumbs():
        """Return a sequence of dicts for the breadcrumb information.
        Each dict contains:

        - ``url``: The ``request.mgmt_path`` to that resource

        - ``name``: The resource ``__name__`` or 'Home' for the root

        - ``active``: Boolean representing whether the resource is
          in the breadcrumb is the current context

        - ``icon``: The full path to the icon for that resource type
        """

    def sdi_title():
        """ The ``sdi_title`` of the virtual root or "Substance D" if
         not defined """

    def mgmt_views(context):
        """ The list of management views on a resource """

#
# subtanced.workflow APIs
#
class IWorkflow(Interface):
    """ """

    def add_state(name, callback=None, **kw):
        """ """

    def add_transition(name, from_state, to_state, callback=None, **kw):
        """ """

    def check():
        """ """

    def state_of(content):
        """ """

    def has_state(content):
        """ """

    def get_states(content, request, from_state=None):
        """ """

    def initialize(content, request=None):
        """ """

    def reset(content, request=None):
        """ """

    def transition(content, request, transition_name):
        """ """
    def transition_to_state(content, request, to_state,
                            skip_same=True):
        """ """

    def get_transitions(content, request, from_state=None):
        """ """

class IDefaultWorkflow(Interface):
    """ Marker interface used internally for workflows that aren't
    associated with a particular content type"""

########NEW FILE########
__FILENAME__ = evolve
from pyramid.threadlocal import get_current_registry

def add_lock_service(root):
    if not 'locks' in root:
        registry = get_current_registry()
        locks = registry.content.create('Lock Service')
        root.add_service('locks', locks, registry=registry)
    locks = root['locks']
    locks.__sdi_deletable__ = False

def includeme(config):
    config.add_evolution_step(
        add_lock_service,
        after='substanced.audit.evolve.add_root_auditlog',
        )

########NEW FILE########
__FILENAME__ = subscribers
from substanced.interfaces import IUser

from substanced.event import subscribe_will_be_removed
from substanced.util import find_objectmap

from . import (
    UserToLock,
    WriteLock,
    )

@subscribe_will_be_removed()
def delete_locks_for_resource(event):
    """ Remove all lock objects associated with an resource when it is about to
    be removed """
    if event.moving is not None: # it's not really being removed
        return
    if event.loading: # fbo dump/load
        return
    objectmap = find_objectmap(event.parent)
    if objectmap is not None: # might be None if parent is not seated
        for oid in event.removed_oids:
            locks = objectmap.targets(oid, WriteLock)
            for lock in locks:
                lock.commit_suicide()

@subscribe_will_be_removed(IUser)
def delete_locks_for_user(event):
    """ Remove all lock objects associated with a user when it is about to be
    removed"""
    # if the principal service containing the user is removed (or any parent of
    # the user) this event won't be fired
    if event.moving is not None: # it's not really being removed
        return
    if event.loading: # fbo dump/load
        return
    objectmap = find_objectmap(event.parent)
    if objectmap is not None: # might be None if parent is not seated
        locks = objectmap.targets(event.object, UserToLock)
        for lock in locks:
            lock.commit_suicide()

########NEW FILE########
__FILENAME__ = test_init
import unittest

from pyramid import testing

class TestLockError(unittest.TestCase):
    def _makeOne(self, lock):
        from .. import LockError
        return LockError(lock)

    def test_ctor(self):
        inst = self._makeOne('lock')
        self.assertEqual(inst.lock, 'lock')

class TestUnlockError(unittest.TestCase):
    def _makeOne(self, lock):
        from .. import UnlockError
        return UnlockError(lock)

    def test_ctor(self):
        inst = self._makeOne('lock')
        self.assertEqual(inst.lock, 'lock')

class Test_now(unittest.TestCase):
    def _callFUT(self):
        from .. import now
        return now()

    def test_it(self):
        from pytz import UTC
        result = self._callFUT()
        self.assertEqual(result.tzinfo, UTC)

class TestLockOwnerSchema(unittest.TestCase):
    def _makeOne(self):
        from .. import LockOwnerSchema
        return LockOwnerSchema()

    def test_widget(self):
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        from substanced.interfaces import IService
        inst = self._makeOne()
        resource = testing.DummyResource()
        alsoProvides(resource, IFolder)
        principals = testing.DummyResource(__provides__=IService)
        resource['principals'] = principals
        principals['users'] = DummyUsers()
        inst.bindings = {}
        inst.bindings['context'] = resource
        widget = inst.widget
        self.assertEqual(widget.values, [(1, 'name')])

    def test_widget_principals_is_None(self):
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        inst = self._makeOne()
        resource = testing.DummyResource()
        alsoProvides(resource, IFolder)
        inst.bindings = {}
        inst.bindings['context'] = resource
        widget = inst.widget
        self.assertEqual(widget.values, [])

    def test_validator_success(self):
        inst = self._makeOne()
        resource = testing.DummyResource()
        resource.__objectmap__ = DummyObjectMap({1:True})
        inst.bindings = {}
        inst.bindings['context'] = resource
        result = inst.validator(None, 1)
        self.assertEqual(result, None) # doesnt raise

    def test_validator_failure(self):
        from colander import Invalid
        inst = self._makeOne()
        resource = testing.DummyResource()
        resource.__objectmap__ = DummyObjectMap({1:True})
        inst.bindings = {}
        inst.bindings['context'] = resource
        self.assertRaises(Invalid, inst.validator, None, 2)

class TestLockResourceSchema(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self):
        from .. import LockResourceSchema
        return LockResourceSchema()

    def test_preparer_value_is_path_allowed(self):
        self.config.testing_securitypolicy(permissive=True)
        inst = self._makeOne()
        resource = testing.DummyResource()
        resource.__objectmap__ = DummyObjectMap(resource)
        inst.bindings = {}
        inst.bindings['context'] = resource
        inst.bindings['request'] = testing.DummyRequest()
        result = inst.preparer('/abc/def')
        self.assertEqual(result, resource)

    def test_preparer_value_is_path_ValueError(self):
        self.config.testing_securitypolicy(permissive=True)
        inst = self._makeOne()
        resource = testing.DummyResource()
        resource.__objectmap__ = DummyObjectMap(resource, raises=ValueError)
        inst.bindings = {}
        inst.bindings['context'] = resource
        inst.bindings['request'] = testing.DummyRequest()
        result = inst.preparer('/abc/def')
        self.assertEqual(result, None)

    def test_preparer_value_is_path_not_allowed(self):
        self.config.testing_securitypolicy(permissive=False)
        inst = self._makeOne()
        resource = testing.DummyResource()
        resource.__objectmap__ = DummyObjectMap(resource)
        inst.bindings = {}
        inst.bindings['context'] = resource
        inst.bindings['request'] = testing.DummyRequest()
        result = inst.preparer('/abc/def')
        self.assertEqual(result, False)

    def test_preparer_value_is_colander_null(self):
        import colander
        self.config.testing_securitypolicy(permissive=True)
        inst = self._makeOne()
        resource = testing.DummyResource()
        resource.__objectmap__ = DummyObjectMap(resource)
        inst.bindings = {}
        inst.bindings['context'] = resource
        inst.bindings['request'] = testing.DummyRequest()
        result = inst.preparer(colander.null)
        self.assertEqual(result, colander.null)

    def test_validator_value_None(self):
        from colander import Invalid
        inst = self._makeOne()
        self.assertRaises(Invalid, inst.validator, None, None)

    def test_validator_value_False(self):
        from colander import Invalid
        inst = self._makeOne()
        self.assertRaises(Invalid, inst.validator, None, False)

    def test_validator_value_valid(self):
        inst = self._makeOne()
        result = inst.validator(None, 'valid')
        self.assertEqual(result, None) # doesnt raise

class TestLockPropertySheet(unittest.TestCase):
    def _makeOne(self, context, request):
        from .. import LockPropertySheet
        return LockPropertySheet(context, request)

    def test_get_resource_is_None(self):
        import colander
        context = testing.DummyResource()
        context.resource = None
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        result = inst.get()
        self.assertEqual(result['resource'], colander.null)

    def test_get_resource_is_valid(self):
        context = testing.DummyResource()
        resource = testing.DummyResource()
        context.resource = resource
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        result = inst.get()
        self.assertEqual(result['resource'], '/')

    def test_set_resource_is_null(self):
        import colander
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        inst.set({'resource':colander.null})
        self.assertEqual(context.resource, None)

    def test_set_resource_is_not_null(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        inst.set({'resource':'abc'})
        self.assertEqual(context.resource, 'abc')

class TestLock(unittest.TestCase):
    def _makeOne(self,
                 infinite=False,
                 timeout=3600,
                 comment=None,
                 last_refresh=None,
                ):
        from .. import Lock
        return Lock(infinite=infinite,
                    timeout=timeout,
                    comment=comment,
                    last_refresh=last_refresh,
                   )

    def test_ctor(self):
        inst = self._makeOne(False, 5000, 'comment', 1000)
        self.assertEqual(inst.infinite, False)
        self.assertEqual(inst.timeout, 5000)
        self.assertEqual(inst.last_refresh, 1000)
        self.assertEqual(inst.comment, 'comment')

    def test_refresh(self):
        import datetime
        inst = self._makeOne()
        now = datetime.datetime.utcnow()
        inst.refresh(when=now)
        self.assertEqual(inst.last_refresh, now)

    def test_refresh_with_timeout(self):
        import datetime
        inst = self._makeOne()
        now = datetime.datetime.utcnow()
        inst.refresh(timeout=30, when=now)
        self.assertEqual(inst.last_refresh, now)
        self.assertEqual(inst.timeout, 30)

    def test_expires_timeout_is_None(self):
        inst = self._makeOne()
        inst.timeout = None
        self.assertEqual(inst.expires(), None)

    def test_expires_timeout_is_int(self):
        import datetime
        inst = self._makeOne()
        inst.timeout = 30
        now = datetime.datetime.utcnow()
        inst.last_refresh = now
        self.assertEqual(inst.expires(), now + datetime.timedelta(seconds=30))

    def test_is_valid_expires_timeout_is_None(self):
        inst = self._makeOne()
        inst.timeout = None
        self.assertTrue(inst.is_valid())

    def test_is_valid_expires_timeout_is_int(self):
        import datetime
        inst = self._makeOne()
        inst.timeout = 30
        now = datetime.datetime.utcnow()
        future = now + datetime.timedelta(seconds=60)
        inst.last_refresh = now
        self.assertTrue(inst.is_valid(now))
        self.assertFalse(inst.is_valid(future))

    def test_is_valid_expires_resource_id_exists(self):
        import datetime
        inst = self._makeOne()
        inst.timeout = 30
        now = datetime.datetime.utcnow()
        inst.last_refresh = now
        inst.__objectmap__ = DummyObjectMap([1])
        self.assertTrue(inst.is_valid(now))

    def test_is_valid_expires_resource_id_notexist(self):
        import datetime
        inst = self._makeOne()
        inst.timeout = 30
        now = datetime.datetime.utcnow()
        inst.last_refresh = now
        inst.__objectmap__ = DummyObjectMap([])
        self.assertFalse(inst.is_valid(now))

    def test_depth_wo_infinite(self):
        inst = self._makeOne(infinite=False)
        self.assertEqual(inst.depth, '0')

    def test_depth_w_infinite(self):
        inst = self._makeOne(infinite=True)
        self.assertEqual(inst.depth, 'infinity')

    def test_commit_suicide(self):
        inst = self._makeOne()
        parent = testing.DummyResource()
        parent['foo'] = inst
        inst.commit_suicide()
        self.assertFalse('foo' in parent)

class TestLockService(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self):
        from .. import LockService
        return LockService()

    def test_next_name(self):
        inst = self._makeOne()
        self.assertTrue(inst.next_name(None))

    def test__get_ownerid_object(self):
        resource = testing.DummyResource()
        resource.__oid__ = 1
        inst = self._makeOne()
        result = inst._get_ownerid(resource)
        self.assertEqual(result, 1)

    def test__get_ownerid_oid(self):
        inst = self._makeOne()
        result = inst._get_ownerid(1)
        self.assertEqual(result, 1)

    def test__get_ownerid_bogus(self):
        inst = self._makeOne()
        self.assertRaises(ValueError, inst._get_ownerid, 'bogus')

    def test_borrow_lock_without_existing_lock(self):
        inst = self._makeOne()
        inst.__objectmap__ = DummyObjectMap([])
        resource = testing.DummyResource()
        self.assertTrue(inst.borrow_lock(resource, 1) is None)

    def test_borrow_lock_with_invalid_existing_lock(self):
        inst = self._makeOne()
        lock = testing.DummyResource()
        def commit_suicide():
            lock.suicided = True
        lock.commit_suicide = commit_suicide
        lock.is_valid = lambda: False
        resource = testing.DummyResource()
        inst.__objectmap__ = DummyObjectMap([lock])
        self.config.registry.content = DummyContentRegistry(lock)
        self.assertTrue(inst.borrow_lock(resource, 1) is None)
        self.assertTrue(lock.suicided)

    def test_borrow_lock_with_valid_existing_lock_different_userid(self):
        from substanced.locking import LockError
        inst = self._makeOne()
        existing_lock = testing.DummyResource()
        existing_lock.ownerid = 2
        existing_lock.is_valid = lambda: True
        resource = testing.DummyResource()
        inst.__objectmap__ = DummyObjectMap([existing_lock])
        self.assertRaises(LockError, inst.borrow_lock, resource, 1)

    def test_borrow_lock_with_valid_existing_lock_same_userid(self):
        inst = self._makeOne()
        lock = testing.DummyResource()
        lock.ownerid = 1
        lock.is_valid = lambda: True
        lock.timeout = None
        def refresh(timeout, when): #pragma NO COVER
            lock.timeout = timeout
        lock.refresh = refresh
        resource = testing.DummyResource()
        inst.__objectmap__ = DummyObjectMap([lock])
        result = inst.borrow_lock(resource, 1)
        self.assertEqual(result.timeout, None)

    def test_lock_without_existing_lock(self):
        inst = self._makeOne()
        lock = testing.DummyResource()
        resource = testing.DummyResource()
        self.config.registry.content = DummyContentRegistry(lock)
        inst.__objectmap__ = DummyObjectMap([])
        result = inst.lock(resource, 1)
        self.assertEqual(result, lock)
        self.assertEqual(result.ownerid, 1)
        self.assertEqual(result.resource, resource)
        self.assertEqual(result.infinite, False)

    def test_lock_without_existing_lock_w_infinite(self):
        inst = self._makeOne()
        lock = testing.DummyResource()
        resource = testing.DummyResource()
        self.config.registry.content = DummyContentRegistry(lock)
        inst.__objectmap__ = DummyObjectMap([])
        result = inst.lock(resource, 1, infinite=True)
        self.assertEqual(result, lock)
        self.assertEqual(result.ownerid, 1)
        self.assertEqual(result.resource, resource)
        self.assertEqual(result.infinite, True)

    def test_lock_with_invalid_existing_lock(self):
        inst = self._makeOne()
        lock = testing.DummyResource()
        def commit_suicide():
            lock.suicided = True
        lock.commit_suicide = commit_suicide
        lock.is_valid = lambda: False
        resource = testing.DummyResource()
        inst.__objectmap__ = DummyObjectMap([lock])
        self.config.registry.content = DummyContentRegistry(lock)
        result = inst.lock(resource, 1)
        self.assertEqual(result, lock)
        self.assertEqual(result.ownerid, 1)
        self.assertEqual(result.resource, resource)
        self.assertTrue(lock.suicided)

    def test_lock_with_valid_existing_lock_different_userid(self):
        from substanced.locking import LockError
        inst = self._makeOne()
        existing_lock = testing.DummyResource()
        existing_lock.ownerid = 2
        existing_lock.is_valid = lambda: True
        resource = testing.DummyResource()
        inst.__objectmap__ = DummyObjectMap([existing_lock])
        self.assertRaises(LockError, inst.lock, resource, 1)

    def test_lock_with_valid_existing_lock_same_userid(self):
        inst = self._makeOne()
        lock = testing.DummyResource()
        lock.ownerid = 1
        lock.is_valid = lambda: True
        def refresh(timeout, when):
            lock.timeout = timeout
            lock.when = when
        lock.refresh = refresh
        resource = testing.DummyResource()
        inst.__objectmap__ = DummyObjectMap([lock])
        result = inst.lock(resource, 1, timeout=3600)
        self.assertEqual(result.timeout, 3600)
        self.assertTrue(result.when)

    def test_unlock_without_existing_lock(self):
        from substanced.locking import UnlockError
        inst = self._makeOne()
        resource = testing.DummyResource()
        inst.__objectmap__ = DummyObjectMap([])
        self.assertRaises(UnlockError, inst.unlock, resource, 1)

    def test_unlock_with_invalid_existing_lock(self):
        from substanced.locking import UnlockError
        inst = self._makeOne()
        lock = testing.DummyResource()
        lock.ownerid = 1
        lock.is_valid = lambda: False
        def commit_suicide():
            lock.suicided = True
        lock.commit_suicide = commit_suicide
        resource = testing.DummyResource()
        inst.__objectmap__ = DummyObjectMap([lock])
        self.assertRaises(UnlockError, inst.unlock, resource, 1)
        self.assertTrue(lock.suicided)

    def test_unlock_with_valid_existing_lock_same_userid(self):
        inst = self._makeOne()
        lock = testing.DummyResource()
        lock.ownerid = 1
        lock.is_valid = lambda: True
        def commit_suicide():
            lock.suicided = True
        lock.commit_suicide = commit_suicide
        resource = testing.DummyResource()
        inst.__objectmap__ = DummyObjectMap([lock])
        inst.unlock(resource, 1)
        self.assertTrue(lock.suicided)

    def test_unlock_token_wo_lock(self):
        from substanced.locking import UnlockError
        inst = self._makeOne()
        resource = testing.DummyResource()
        self.assertRaises(UnlockError, inst.unlock_token, 'NONESUCH', 1)

    def test_unlock_token_w_invalid_lock(self):
        from substanced.locking import UnlockError
        inst = self._makeOne()
        lock = inst['INVALID'] = testing.DummyResource()
        lock.is_valid = lambda: False
        def commit_suicide():
            lock.suicided = True
        lock.commit_suicide = commit_suicide
        self.assertRaises(UnlockError, inst.unlock_token, 'INVALID', 1)
        self.assertTrue(lock.suicided)

    def test_unlock_token_w_valid_lock_not_owned_by_user(self):
        from substanced.locking import UnlockError
        inst = self._makeOne()
        lock = inst['OWNEDBYOTHER'] = testing.DummyResource()
        lock.ownerid = 2
        lock.is_valid = lambda: True
        lock.suicided = False
        def commit_suicide(): #pragma NO COVER
            lock.suicided = True
        lock.commit_suicide = commit_suicide
        self.assertRaises(UnlockError, inst.unlock_token, 'OWNEDBYOTHER', 1)
        self.assertFalse(lock.suicided)

    def test_unlock_token_w_valid_lock_owned_by_user(self):
        inst = self._makeOne()
        lock = inst['VALID'] = testing.DummyResource()
        lock.ownerid = 1
        lock.is_valid = lambda: True
        def commit_suicide():
            lock.suicided = True
        lock.commit_suicide = commit_suicide
        inst.unlock_token('VALID', 1)
        self.assertTrue(lock.suicided)

    def test_discover_filter_invalid(self):
        root = testing.DummyResource()
        context = root['context'] = testing.DummyResource()
        inst = self._makeOne()
        lock1 = testing.DummyResource()
        lock1.is_valid = lambda: True
        lock2 = testing.DummyResource()
        lock2.is_valid = lambda: False
        def _targets(resource, type):
            if resource.__name__ == 'context':
                return [lock1, lock2]
            return ()
        inst.__objectmap__ = DummyObjectMap(None)
        inst.__objectmap__.targets = _targets
        result = inst.discover(context)
        self.assertEqual(result, [lock1])

    def test_discover_default(self):
        root = testing.DummyResource()
        context = root['context'] = testing.DummyResource()
        inst = self._makeOne()
        lock1 = testing.DummyResource()
        lock1.is_valid = lambda: True
        lock2 = testing.DummyResource()
        lock2.is_valid = lambda: False
        lock3 = testing.DummyResource()
        lock3.is_valid = lambda: True
        def _targets(resource, type):
            if resource.__name__ == 'context':
                return [lock1, lock2]
            return [lock3]
        inst.__objectmap__ = DummyObjectMap(None)
        inst.__objectmap__.targets = _targets
        result = inst.discover(context)
        # Lineage included by default
        self.assertEqual(result, [lock1, lock3])

    def test_discover_w_include_lineage(self):
        root = testing.DummyResource()
        context = root['context'] = testing.DummyResource()
        inst = self._makeOne()
        lock1 = testing.DummyResource()
        lock1.is_valid = lambda: True
        lock2 = testing.DummyResource()
        lock2.is_valid = lambda: False
        lock3 = testing.DummyResource()
        lock3.is_valid = lambda: True
        def _targets(resource, type):
            if resource.__name__ == 'context':
                return [lock1, lock2]
            return [lock3]
        inst.__objectmap__ = DummyObjectMap(None)
        inst.__objectmap__.targets = _targets
        result = inst.discover(context, include_lineage=True)
        self.assertEqual(result, [lock1, lock3])

    def test_discover_wo_include_lineage(self):
        root = testing.DummyResource()
        context = root['context'] = testing.DummyResource()
        inst = self._makeOne()
        lock1 = testing.DummyResource()
        lock1.is_valid = lambda: True
        lock2 = testing.DummyResource()
        lock2.is_valid = lambda: False
        def _targets(resource, type):
            return [lock1, lock2]
        inst.__objectmap__ = DummyObjectMap(None)
        inst.__objectmap__.targets = _targets
        result = inst.discover(context, include_lineage=False)
        self.assertEqual(result, [lock1])

    def test_discover_invalid_not_filtered_when_include_invalid(self):
        root = testing.DummyResource()
        context = root['context'] = testing.DummyResource()
        inst = self._makeOne()
        lock1 = testing.DummyResource()
        lock1.is_valid = lambda: True
        lock2 = testing.DummyResource()
        lock2.is_valid = lambda: False
        def _targets(resource, type):
            if resource.__name__ == 'context':
                return [lock1, lock2]
            return ()
        inst.__objectmap__ = DummyObjectMap(None)
        inst.__objectmap__.targets = _targets
        result = inst.discover(context, include_invalid=True)
        self.assertEqual(result, [lock1, lock2])

class Test_lock_resource(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, resource, owner_or_ownerid, timeout=None,
                 infinite=False):
        from substanced.locking import lock_resource
        return lock_resource(resource, owner_or_ownerid,
                              timeout=timeout, infinite=infinite)

    def test_it_with_existing_lock_service(self):
        from substanced.locking import WriteLock
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        resource = testing.DummyResource()
        alsoProvides(resource, IFolder)
        lockservice = DummyLockService()
        resource['locks'] = lockservice
        result = self._callFUT(resource, 1, 3600, infinite=True)
        self.assertEqual(result, True)
        self.assertEqual(lockservice.resource, resource)
        self.assertEqual(lockservice.owner, 1)
        self.assertEqual(lockservice.timeout, 3600)
        self.assertEqual(lockservice.locktype, WriteLock)
        self.assertEqual(lockservice.infinite, True)

    def test_it_with_missing_lock_service(self):
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        resource = testing.DummyResource()
        alsoProvides(resource, IFolder)
        self.assertRaises(ValueError, self._callFUT, resource, 1, 3600)

class Test_could_lock_resource(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, resource, owner_or_ownerid):
        from substanced.locking import could_lock_resource
        return could_lock_resource(resource, owner_or_ownerid)

    def test_it_with_existing_lock_service(self):
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        resource = testing.DummyResource()
        alsoProvides(resource, IFolder)
        lockservice = DummyLockService()
        resource['locks'] = lockservice
        result = self._callFUT(resource, 1)
        self.assertEqual(result, True)
        self.assertEqual(lockservice.borrowed, resource)

    def test_it_with_missing_lock_service(self):
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        resource = testing.DummyResource()
        alsoProvides(resource, IFolder)
        self.assertRaises(ValueError, self._callFUT, resource, 1)

class Test_unlock_resource(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, resource, owner_or_ownerid):
        from substanced.locking import unlock_resource
        return unlock_resource(resource, owner_or_ownerid)

    def test_it_with_existing_lock_service(self):
        from substanced.locking import WriteLock
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        resource = testing.DummyResource()
        alsoProvides(resource, IFolder)
        lockservice = DummyLockService()
        resource['locks'] = lockservice
        result = self._callFUT(resource, 1)
        self.assertEqual(result, True)
        self.assertEqual(lockservice.resource, resource)
        self.assertEqual(lockservice.owner, 1)
        self.assertEqual(lockservice.locktype, WriteLock)

    def test_it_with_missing_lock_service(self):
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        resource = testing.DummyResource()
        resource.add_service = resource.__setitem__
        alsoProvides(resource, IFolder)
        self.assertRaises(ValueError, self._callFUT, resource, 1)

class Test_unlock_token(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, resource, token, ownerid):
        from substanced.locking import unlock_token
        return unlock_token(resource, token, ownerid)

    def test_it_with_existing_lock_service(self):
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        resource = testing.DummyResource()
        alsoProvides(resource, IFolder)
        lockservice = resource['locks'] = DummyLockService()
        result = self._callFUT(resource, 'TOKEN', 1)
        self.assertEqual(result, True)
        self.assertEqual(lockservice.token, 'TOKEN')
        self.assertEqual(lockservice.owner, 1)

    def test_it_with_missing_lock_service(self):
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        resource = testing.DummyResource()
        resource.add_service = resource.__setitem__
        alsoProvides(resource, IFolder)
        self.assertRaises(ValueError, self._callFUT, resource, 'TOKEN', 1)

class Test_discover_resource_locks(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, resource, **kw):
        from substanced.locking import discover_resource_locks
        return discover_resource_locks(resource, **kw)

    def test_it_with_existing_lock_service(self):
        from substanced.locking import WriteLock
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        resource = testing.DummyResource()
        alsoProvides(resource, IFolder)
        lockservice = DummyLockService()
        resource['locks'] = lockservice
        result = self._callFUT(resource)
        self.assertEqual(result, True)
        self.assertEqual(lockservice.resource, resource)
        self.assertEqual(lockservice.locktype, WriteLock)
        self.assertEqual(lockservice.include_invalid, False)
        self.assertEqual(lockservice.include_lineage, True)

    def test_it_with_include_lineage_False(self):
        from substanced.locking import WriteLock
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        resource = testing.DummyResource()
        alsoProvides(resource, IFolder)
        lockservice = DummyLockService()
        resource['locks'] = lockservice
        result = self._callFUT(resource, include_lineage=False)
        self.assertEqual(result, True)
        self.assertEqual(lockservice.resource, resource)
        self.assertEqual(lockservice.locktype, WriteLock)
        self.assertEqual(lockservice.include_invalid, False)
        self.assertEqual(lockservice.include_lineage, False)

    def test_it_with_missing_lock_service(self):
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        resource = testing.DummyResource()
        alsoProvides(resource, IFolder)
        self.assertRaises(ValueError, self._callFUT, resource)

class DummyObjectMap(object):
    def __init__(self, result, raises=None):
        self.result = result
        self.raises = raises
    def sourceids(self, resource, reftype):
        return self.result
    @property
    def objectid_to_path(self):
        return self.result
    def object_for(self, value):
        if self.raises is not None:
            raise self.raises
        return self.result
    def targets(self, resource, type):
        return self.result
    def add(self, *arg, **kw):
        self.added = True

class DummyContentRegistry(object):
    def __init__(self, result):
        self.result = result

    def create(self, *arg, **kw):
        return self.result

class DummyUsers(object):
    def items(self):
        ob = testing.DummyResource()
        ob.__oid__ = 1
        yield 'name', ob

class DummyLockService(object):
    def __init__(self):
        from zope.interface import directlyProvides
        from ...interfaces import IService
        directlyProvides(self, IService)

    def lock(self, resource, owner,
             timeout=None, comment=None, locktype=None, infinite=False):
        self.resource = resource
        self.owner = owner
        self.timeout = timeout
        self.comment = comment
        self.locktype = locktype
        self.infinite = infinite
        return True

    def borrow_lock(self, resource, owner, locktype=None):
        self.borrowed = resource
        return True

    unlock = lock

    def unlock_token(self, token, owner):
        self.token = token
        self.owner = owner
        return True

    def discover(self, resource,
                 include_invalid=False, include_lineage=True, locktype=None,
                ):
        self.resource = resource
        self.locktype = locktype
        self.include_invalid = include_invalid
        self.include_lineage = include_lineage
        return True

########NEW FILE########
__FILENAME__ = test_subscribers
import unittest

from pyramid import testing

class Test_delete_locks_for_resource(unittest.TestCase):
    def _callFUT(self, event):
        from ..subscribers import delete_locks_for_resource
        return delete_locks_for_resource(event)

    def test_event_moving(self):
        event = testing.DummyResource()
        event.loading = False
        event.moving = True
        result = self._callFUT(event)
        self.assertEqual(result, None)

    def test_event_loading(self):
        event = testing.DummyResource()
        event.loading = True
        event.moving = None
        result = self._callFUT(event)
        self.assertEqual(result, None)
        
    def test_objectmap_is_None(self):
        event = testing.DummyResource()
        event.moving = None
        event.loading = False
        event.object = None
        event.parent = testing.DummyResource()
        result = self._callFUT(event)
        self.assertEqual(result, None)

    def test_it(self):
        event = testing.DummyResource()
        event.moving = None
        event.loading = False
        resource = testing.DummyResource()
        parent = testing.DummyResource()
        event.object = resource
        event.removed_oids = [1, 2]
        event.parent = parent
        lock = testing.DummyResource()
        lock.suicided = 0
        def commit_suicide():
            lock.suicided+=1
        lock.commit_suicide = commit_suicide
        parent.__objectmap__ = DummyObjectMap([lock])
        result = self._callFUT(event)
        self.assertEqual(result, None)
        self.assertEqual(lock.suicided, 2)

class Test_delete_locks_for_user(unittest.TestCase):
    def _callFUT(self, event):
        from ..subscribers import delete_locks_for_user
        return delete_locks_for_user(event)
    
    def test_event_moving(self):
        event = testing.DummyResource()
        event.loading = False
        event.moving = True
        result = self._callFUT(event)
        self.assertEqual(result, None)

    def test_event_loading(self):
        event = testing.DummyResource()
        event.loading = True
        event.moving = None
        result = self._callFUT(event)
        self.assertEqual(result, None)
        
    def test_objectmap_is_None(self):
        event = testing.DummyResource()
        event.moving = None
        event.loading = False
        event.object = None
        event.parent = testing.DummyResource()
        result = self._callFUT(event)
        self.assertEqual(result, None)

    def test_it(self):
        from zope.interface import alsoProvides
        from substanced.interfaces import IUser
        event = testing.DummyResource()
        event.moving = None
        event.loading = False
        resource = testing.DummyResource()
        parent = testing.DummyResource()
        alsoProvides(resource, IUser)
        event.object = resource
        event.parent = parent
        lock = testing.DummyResource()
        lock.suicided = 0
        def commit_suicide():
            lock.suicided+=1
        lock.commit_suicide = commit_suicide
        parent.__objectmap__ = DummyObjectMap([lock])
        result = self._callFUT(event)
        self.assertEqual(result, None)
        self.assertEqual(lock.suicided, 1)
    
        
class DummyObjectMap(object):
    def __init__(self, result):
        self.result = result
    def targets(self, resource, type):
        return self.result


########NEW FILE########
__FILENAME__ = test_views
import unittest

from pyramid import testing

class Test_add_lock_service(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _callFUT(self, context, request):
        from ..views import add_lock_service
        return add_lock_service(context, request)

    def test_it(self):
        context = testing.DummyResource()
        context.add_service = context.__setitem__
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI('/foo')
        request.registry = self.config.registry
        service = testing.DummyResource()
        content = DummyContentRegistry(service)
        request.registry.content = content
        response = self._callFUT(context, request)
        self.assertEqual(response.location, '/foo/@@services')
        self.assertEqual(context['locks'], service)

class TestAddLockView(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self, context, request):
        from ..views import AddLockView
        return AddLockView(context, request)

    def test_add_success(self):
        context = testing.DummyResource()
        def add_next(obj):
            context.next = obj
        context.add_next = add_next
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI('/foo')
        request.registry = self.config.registry
        lock = testing.DummyResource()
        content = DummyContentRegistry(lock)
        request.registry.content = content
        appstruct = {
            'timeout':None,
            'last_refresh':None,
            'ownerid':1,
            'resource':context}
        inst = self._makeOne(context, request)
        response = inst.add_success(appstruct)
        self.assertEqual(lock.ownerid, 1)
        self.assertEqual(lock.resource, context)
        self.assertEqual(response.location, '/foo/@@contents')

class TestLockServiceFolderContents(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..views import LockServiceFolderContents
        return LockServiceFolderContents(context, request)

    def test_get_buttons(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        inst.get_default_buttons = lambda: [{}]
        groups = inst.get_buttons()
        self.assertEqual(len(groups), 2)

    def test_get_columns_subobject_is_None(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        inst.get_default_columns = lambda *arg: [{}]
        columns = inst.get_columns(None)
        self.assertEqual(len(columns), 4)
        self.assertEqual(columns[1]['value'], None)
        self.assertEqual(columns[2]['value'], None)
        self.assertEqual(columns[3]['value'], None)

    def test_get_columns_subobject_is_lock(self):
        import datetime
        import pytz
        context = testing.DummyResource()
        owner = testing.DummyResource()
        owner.__name__ = 'owner'
        context.owner = owner
        resource = testing.DummyResource()
        context.resource = resource
        now = datetime.datetime(2012, 10, 12)
        context.expires = lambda: now
        request = testing.DummyRequest()
        request.user = testing.DummyResource()
        request.user.timezone = pytz.timezone('UTC')
        inst = self._makeOne(context, request)
        inst.get_default_columns = lambda *arg: [{}]
        columns = inst.get_columns(context)
        self.assertEqual(len(columns), 4)
        self.assertEqual(columns[1]['value'], 'owner')
        self.assertEqual(columns[2]['value'], '/')
        self.assertEqual(columns[3]['value'], '2012-10-12 00:00:00 UTC')

    def test_get_columns_subobject_is_lock_w_expires_returning_None(self):
        context = testing.DummyResource()
        owner = testing.DummyResource()
        owner.__name__ = 'owner'
        context.owner = owner
        resource = testing.DummyResource()
        context.resource = resource
        context.expires = lambda: None
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        inst.get_default_columns = lambda *arg: [{}]
        columns = inst.get_columns(context)
        self.assertEqual(len(columns), 4)
        self.assertEqual(columns[1]['value'], 'owner')
        self.assertEqual(columns[2]['value'], '/')
        self.assertEqual(columns[3]['value'], None)

    def test_delete_expires(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI('/foo')
        lock = testing.DummyResource()
        def commit_suicide():
            lock.suicided = True
        lock.commit_suicide = commit_suicide
        lock.is_valid = lambda: False
        context['lock1'] = lock
        inst = self._makeOne(context, request)
        response = inst.delete_expired()
        self.assertEqual(response.location, '/foo/@@')
        self.assertTrue(lock.suicided)
        
        
class DummyContentRegistry(object):
    def __init__(self, result):
        self.result = result

    def create(self, *arg, **kw):
        return self.result

class DummySDIAPI(object):
    def __init__(self, result):
        self.result = result

    def mgmt_path(self, *arg, **kw):
        return '/'.join([self.result] + list(arg[1:]))
    

########NEW FILE########
__FILENAME__ = views
from pyramid.traversal import resource_path

from pyramid.httpexceptions import HTTPFound

from substanced.interfaces import (
    ILockService,
    IFolder,
    )
from substanced.form import FormView
from substanced.sdi import mgmt_view
from substanced.folder.views import (
    FolderContents,
    folder_contents_views,
    )

from . import LockSchema
from ..util import _

@mgmt_view(
    context=IFolder,
    name='add_lock_service',
    tab_condition=False,
    permission='sdi.add-services',
    )
def add_lock_service(context, request):
    service = request.registry.content.create('Lock Service')
    context.add_service('locks', service)
    return HTTPFound(location=request.sdiapi.mgmt_path(context, '@@services'))

@mgmt_view(
    context=ILockService,
    name='add_lock',
    permission='sdi.add-content', 
    renderer='substanced.sdi.views:templates/form.pt',
    tab_condition=False
    )
class AddLockView(FormView):
    title = 'Add Lock'
    schema = LockSchema()
    buttons = ('add',)

    def add_success(self, appstruct):
        registry = self.request.registry
        lock = registry.content.create(
            'Lock',
            timeout=appstruct['timeout'],
            last_refresh=appstruct['last_refresh'],
            )
        self.context.add_next(lock)
        lock.ownerid = appstruct['ownerid']
        lock.resource = appstruct['resource']
        return HTTPFound(
            self.request.sdiapi.mgmt_path(self.context, '@@contents')
            )

@folder_contents_views(
    context=ILockService,
    )
class LockServiceFolderContents(FolderContents):
    def get_buttons(self):
        button_groups = self.get_default_buttons()[-1:]
        new_buttons = [
            {'id':'delete_expired',
             'name':'form.delete_expired',
             'class':'btn-sdi-act',
             'value':'delete_expired',
             'text': _('Delete Expired')
             },
            ]
        button_groups.append(
            {'type':'group', 'buttons':new_buttons}
            )
        return button_groups

    def get_columns(self, subobject):
        columns = self.get_default_columns(subobject)
        owner = getattr(subobject, 'owner', None)
        if owner is not None:
            owner = owner.__name__
        resource = getattr(subobject, 'resource', None)
        if resource is not None:
            resource = resource_path(resource)
        expires = getattr(subobject, 'expires', None)
        if expires is not None:
            expires = expires()
        if expires is not None:
            tz = self.request.user.timezone
            expires = expires.replace(tzinfo=None) # in case it's not naive
            expires = tz.localize(expires).strftime('%Y-%m-%d %H:%M:%S %Z')
        
        columns.extend((
            {'name':_('Owner'),
             'value':owner,
             },
            {'name':_('Resource'),
             'value':resource,
             },
            {'name':_('Expires'),
             'value':expires,
             },
            ))

        return columns

    def delete_expired(self):
        todelete = []
        # build a secondary list so we don't mutate the BTree while iterating
        for lock in self.context.values():
            if not lock.is_valid():
                todelete.append(lock)
        for item in todelete:
            item.commit_suicide()
        return self.get_redirect_response()
    
def includeme(config): # pragma: no cover
    config.add_mgmt_view(
        LockServiceFolderContents,
        context=ILockService,
        name='contents',
        permission='sdi.manage-content',
        request_method='POST',
        request_param='form.delete_expired',
        tab_condition=False,
        attr='delete_expired',
        )

########NEW FILE########
__FILENAME__ = evolve
import BTrees

from substanced._compat import u

from logging import getLogger

from substanced.util import (
    get_acl,
    postorder,
    )

_SLASH = u('/')

logger = getLogger(__name__)

def oobtreeify_referencemap(root): # pragma: no cover
    objectmap = root.__objectmap__
    refmap = objectmap.referencemap.refmap
    for k, refset in refmap.items():
        refset.src2target = BTrees.family64.OO.BTree(refset.src2target)
        refset.target2src = BTrees.family64.OO.BTree(refset.target2src)

def oobtreeify_object_to_path(root): # pragma: no cover
    objectmap = root.__objectmap__
    oobtree = BTrees.family64.OO.BTree
    objectmap.objectid_to_path = oobtree(objectmap.objectid_to_path)
    objectmap.path_to_objectid = oobtree(objectmap.path_to_objectid)

def treesetify_objectmap_pathindex(root): # pragma: no cover
    # to avoid having huge pickles
    objectmap = root.__objectmap__
    pathindex = objectmap.pathindex
    for path, not_treesets in list(pathindex.items()):
        for d, not_treeset in list(not_treesets.items()):
            treeset = objectmap.family.IF.TreeSet(not_treeset)
            not_treesets[d] = treeset

def treesetify_referencesets(root): # pragma: no cover
    # to avoid having huge pickles
    objectmap = root.__objectmap__
    refmap = objectmap.referencemap.refmap
    for name, refset in list(refmap.items()):
        for reftype, oidset in list(refset.src2target.items()):
            if oidset.__class__ != refset.oidset_class:
                refset.src2target[reftype] = refset.oidset_class(oidset)
        for reftype, oidset in list(refset.target2src.items()):
            if oidset.__class__ != refset.oidset_class:
                refset.target2src[reftype] = refset.oidset_class(oidset)

def add_path_to_acl_to_objectmap(root):
    objectmap = root.__objectmap__
    objectmap.path_to_acl = objectmap.family.OO.BTree()
    logger.info('Populating path_to_acl in objectmap (expensive evolve step)')
    for obj in postorder(root):
        oid = objectmap.objectid_for(obj)
        path = objectmap.path_for(oid)
        upath = _SLASH.join(path)
        acl = get_acl(obj, None)
        suffix = '(no acl)'
        if acl is not None:
            objectmap.set_acl(obj, acl)
            suffix = '(indexed acl)'
        logger.info('%s %s' % (upath, suffix))

def includeme(config): # pragma: no cover
    config.add_evolution_step(oobtreeify_referencemap)
    config.add_evolution_step(oobtreeify_object_to_path)
    config.add_evolution_step(treesetify_objectmap_pathindex)
    config.add_evolution_step(treesetify_referencesets)
    config.add_evolution_step(add_path_to_acl_to_objectmap)
    

########NEW FILE########
__FILENAME__ = subscribers
from ..event import subscribe_acl_modified

from . import find_objectmap

@subscribe_acl_modified()
def acl_modified(event):
    """ When the ACL of any object is modified, fix the objectmap's
    path_to_acl mapping. """
    objectmap = find_objectmap(event.object)

    if objectmap is not None: # object might not yet be seated
        objectmap.set_acl(event.object, event.new_acl)


########NEW FILE########
__FILENAME__ = test_init
import sys
import unittest
from zope.interface import implementer

from pyramid import testing

IS_32_BIT = sys.maxsize == 2**32

from substanced._compat import u
_BLANK = u('')
_SLASH = u('/')
_A = u('a')
_B = u('b')
_C = u('c')
_Z = u('z')

class TestObjectMap(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, root=None, family=None):
        from .. import ObjectMap
        if root is None:
            root = DummyRoot()
        return ObjectMap(root, family=family)

    def test_ctor_alternate_family(self):
        import BTrees
        inst = self._makeOne(family=BTrees.family32)
        self.assertEqual(inst.family, BTrees.family32)

    def test_new_objectid_empty(self):
        inst = self._makeOne()
        times = [0]
        def randrange(frm, to):
            val = times[0]
            times[0] = times[0] + 1
            return val
        inst._randrange = randrange
        result = inst.new_objectid()
        # cant get 0 back, it's irresolveable
        self.assertEqual(result, 1)
        
    def test_new_objectid_notempty(self):
        inst = self._makeOne()
        times = [0]
        def randrange(frm, to):
            val = times[0]
            times[0] = times[0] + 1
            return val
        inst._randrange = randrange
        inst.objectid_to_path[1] = True
        result = inst.new_objectid()
        self.assertEqual(result, 2)

    def test_new_objectid_gt_maxint(self):
        inst = self._makeOne()
        oob = inst.family.maxint + 1
        times = [oob, 5]
        def randrange(frm, to):
            val = times.pop(0)
            return val
        inst._randrange = randrange
        result = inst.new_objectid()
        self.assertEqual(result, 5)

    def test_objectid_for_object(self):
        obj = testing.DummyResource()
        inst = self._makeOne()
        inst.path_to_objectid[(_BLANK,)] = 1
        self.assertEqual(inst.objectid_for(obj), 1)

    def test_objectid_for_path_tuple(self):
        inst = self._makeOne()
        inst.path_to_objectid[(_BLANK,)] = 1
        self.assertEqual(inst.objectid_for((_BLANK,)), 1)

    def test_objectid_for_nonsense(self):
        inst = self._makeOne()
        self.assertRaises(ValueError, inst.objectid_for, 'a')

    def test_path_for(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = 'abc'
        self.assertEqual(inst.path_for(1), 'abc')

    def test_object_for_int(self):
        a = testing.DummyResource()
        inst = self._makeOne()
        inst.objectid_to_path[1] = 'abc'
        inst._find_resource = lambda *arg: a
        self.assertEqual(inst.object_for(1), a)

    if IS_32_BIT: # pragma: no cover
        def test_object_for_long(self):
            a = testing.DummyResource()
            inst = self._makeOne()
            oid = sys.maxint + 1
            inst.objectid_to_path[oid] = 'abc'
            inst._find_resource = lambda *arg: a
            self.assertEqual(inst.object_for(oid), a)

    def test_object_for_path_tuple(self):
        a = testing.DummyResource()
        inst = self._makeOne()
        inst.objectid_to_path[1] = 'abc'
        inst._find_resource = lambda *arg: a
        self.assertEqual(inst.object_for((_BLANK,)), a)

    def test_object_for_cantbefound(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = 'abc'
        def find_resource(*arg):
            raise KeyError('a')
        inst._find_resource = find_resource
        self.assertEqual(inst.object_for(1), None)
        
    def test_object_for_path_tuple_alternate_context(self):
        a = testing.DummyResource()
        inst = self._makeOne()
        inst.objectid_to_path[1] = 'abc'
        L= []
        def find_resource(context, path_tuple):
            L.append(context)
            return a
        inst._find_resource = find_resource
        self.assertEqual(inst.object_for((_BLANK,), 'a'), a)
        self.assertEqual(L, ['a'])

    def test_object_for_path_not_in_objectid_to_path(self):
        inst = self._makeOne()
        self.assertEqual(inst.object_for(1), None)

    def test__find_resource_no_context(self):
        self.config.testing_resources({'/a':1})
        inst = self._makeOne()
        inst.root = None
        self.assertEqual(inst._find_resource(None, ('', 'a')), 1)

    def test__find_resource_with_alternate_context(self):
        self.config.testing_resources({'/a':1})
        inst = self._makeOne()
        ctx = testing.DummyResource()
        self.assertEqual(inst._find_resource(ctx, ('', 'a')), 1)

    def test_add_moving_and_duplicating(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        self.assertRaises(ValueError, inst.add,
                          obj, (_BLANK,), True, True)
        
    def test_add_already_in_path_to_objectid(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        obj.__oid__ = 1
        inst.path_to_objectid[(_BLANK,)] = 1
        self.assertRaises(ValueError, inst.add, obj, (_BLANK,))

    def test_add_duplicating(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        obj.__oid__ = 1
        inst.path_to_objectid[(_BLANK,)] = 1
        self.assertRaises(ValueError, inst.add, obj, (_BLANK,), True)

    def test_add_already_in_objectid_to_path(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        obj.__oid__ = 1
        inst.objectid_to_path[1] = True
        self.assertRaises(ValueError, inst.add, obj, (_BLANK,))

    def test_add_not_a_path_tuple(self):
        inst = self._makeOne()
        self.assertRaises(ValueError, inst.add, None, None)

    def test_add_traversable_object(self):
        inst = self._makeOne()
        inst._v_nextid = 1
        obj = testing.DummyResource()
        inst.add(obj, (_BLANK,))
        self.assertEqual(inst.objectid_to_path[1], (_BLANK,))
        self.assertEqual(obj.__oid__, 1)
        
    def test_add_with_acl(self):
        inst = self._makeOne()
        inst._v_nextid = 1
        obj = testing.DummyResource()
        obj.__acl__ = [('Allow', 'fred', 'view')]
        inst.add(obj, (_BLANK,))
        self.assertEqual(
            inst.path_to_acl[(_BLANK,)],
            (('Allow', 'fred', 'view'),)
            )
        self.assertEqual(obj.__oid__, 1)
        
    def test_add_not_valid(self):
        inst = self._makeOne()
        self.assertRaises(AttributeError, inst.add, 'a', (_BLANK,))

    def test_remove_not_an_int_or_tuple(self):
        inst = self._makeOne()
        self.assertRaises(ValueError, inst.remove, 'a')

    def test_remove_int(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        inst.path_to_objectid[(_BLANK,)] = 1
        inst.pathindex[(_BLANK,)] = {0:[1]}
        inst.path_to_acl[(_BLANK,)] = True
        inst.remove(1)
        self.assertEqual(dict(inst.objectid_to_path), {})
        self.assertEqual(dict(inst.path_to_acl), {})

    if IS_32_BIT: # pragma: no cover
        def test_remove_long(self):
            inst = self._makeOne()
            oid = sys.maxint + 1
            inst.objectid_to_path[oid] = (_BLANK,)
            inst.path_to_objectid[(_BLANK,)] = oid
            inst.pathindex[(_BLANK,)] = {0:[oid]}
            inst.remove(oid)
            self.assertEqual(dict(inst.objectid_to_path), {})
        
    def test_remove_traversable_object(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        inst.path_to_objectid[(_BLANK,)] = 1
        inst.pathindex[(_BLANK,)] = {0:[1]}
        obj = testing.DummyResource()
        inst.remove(obj)
        self.assertEqual(dict(inst.objectid_to_path), {})
        
    def test_remove_no_omap(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        result = inst.remove((_BLANK,))
        self.assertEqual(list(result), [])

    def test_pathlookup_not_valid(self):
        inst = self._makeOne()
        self.assertRaises(ValueError, inst.pathlookup, 1)

    def test_pathlookup_traversable_object(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        gen = inst.pathlookup(obj)
        result = list(gen)
        self.assertEqual(result, [])

    def test_pathcount_not_valid(self):
        inst = self._makeOne()
        self.assertRaises(ValueError, inst.pathcount, 1)
        
    def test_pathcount_traversable_object(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        result = inst.pathcount(obj)
        self.assertEqual(result, 0)

    def test_navgen_bad_obj_or_path_tuple(self):
        inst = self._makeOne()
        self.assertRaises(ValueError, inst.navgen, None, 99)
        
    def test_navgen_notexist(self):
        inst = self._makeOne()
        result = inst.navgen((_BLANK,), 99)
        self.assertEqual(result, [])

    def test_navgen_bigdepth(self):
        inst = self._makeOne()
        root = resource('/')
        a = resource('/a')
        ab = resource('/a/b')
        abc = resource('/a/b/c')
        z = resource('/z')
        for thing in root, a, ab, abc, z:
            inst.add(thing, thing.path_tuple)
        result = inst.navgen(root, 99)
        self.assertEqual(
            result, 
            [{'path': ('', _A), 
              'name':_A,
              'children': [{'path': ('', _A, _B), 
                            'name':_B,
                            'children': [{'path': ('', _A, _B, _C), 
                                          'name':_C,
                                          'children': []}]}]}, 
             {'path': ('', _Z), 
              'name':_Z,
              'children': []}]
            )

    def test_navgen_bigdepth_notroot(self):
        inst = self._makeOne()
        root = resource('/')
        a = resource('/a')
        ab = resource('/a/b')
        abc = resource('/a/b/c')
        z = resource('/z')
        for thing in root, a, ab, abc, z:
            inst.add(thing, thing.path_tuple)
        result = inst.navgen(a, 99)
        self.assertEqual(
            result,
            [{'path': ('', _A, _B), 
              'name':_B,
              'children': [{'path': ('', _A, _B, _C), 
                            'name':_C,
                            'children': []}]}]
            )
        
    def test_navgen_smalldepth(self):
        inst = self._makeOne()
        root = resource('/')
        a = resource('/a')
        ab = resource('/a/b')
        abc = resource('/a/b/c')
        z = resource('/z')
        for thing in root, a, ab, abc, z:
            inst.add(thing, thing.path_tuple)
        result = inst.navgen(root, 1)
        self.assertEqual(
            result,
            [{'path': ('', _A), 
              'name':'a',
              'children': []},
             {'path': ('', _Z), 
              'name':_Z,
              'children': []}]
            )

    def test_navgen_smalldepth_notroot(self):
        inst = self._makeOne()
        root = resource('/')
        a = resource('/a')
        ab = resource('/a/b')
        abc = resource('/a/b/c')
        z = resource('/z')
        for thing in root, a, ab, abc, z:
            inst.add(thing, thing.path_tuple)
        result = inst.navgen(a, 1)
        self.assertEqual(
            result,
            [{'path': ('', _A, _B), 
              'name':_B,
              'children': []}]
            )
        
    def test_navgen_nodepth(self):
        inst = self._makeOne()
        root = resource('/')
        a = resource('/a')
        ab = resource('/a/b')
        abc = resource('/a/b/c')
        z = resource('/z')
        for thing in root, a, ab, abc, z:
            inst.add(thing, thing.path_tuple)
        result = inst.navgen(root, 0)
        self.assertEqual(result, [])

    def test_navgen_nodepth_notroot(self):
        inst = self._makeOne()
        root = resource('/')
        a = resource('/a')
        ab = resource('/a/b')
        abc = resource('/a/b/c')
        z = resource('/z')
        for thing in root, a, ab, abc, z:
            inst.add(thing, thing.path_tuple)
        result = inst.navgen(a, 0)
        self.assertEqual(result, [])

    def test_get_extent(self):
        inst = self._makeOne()
        root = resource('/')
        a = resource('/a')
        ab = resource('/a/b')
        abc = resource('/a/b/c')
        z = resource('/z')
        for thing in root, a, ab, abc, z:
            inst.add(thing, thing.path_tuple)
        result = inst.get_extent('pyramid.testing.DummyResource')
        self.assertEqual(len(sorted(list(result))), 5)

    def test_get_extent_missing_default(self):
        inst = self._makeOne()
        result = inst.get_extent('pyramid.testing.DummyResource')
        self.assertEqual(result, ())

    def test_get_extent_missing_nondefault(self):
        inst = self._makeOne()
        result = inst.get_extent('pyramid.testing.DummyResource', None)
        self.assertEqual(result, None)

    def test_set_acl(self):
        inst = self._makeOne()
        inst.set_acl((_BLANK,), [('Allow', 'fred', 'view')])
        self.assertEqual(
            dict(inst.path_to_acl),
            {
                (_BLANK,):
                    (('Allow', 'fred', 'view'),)
                }
            )

    def test_allowed_path_to_acl_is_None(self):
        oids = [1]
        inst = self._makeOne()
        inst.path_to_acl = None
        result = inst.allowed(oids, 'fred', 'view')
        self.assertEqual(list(result), [])
        
    def test_allowed_no_oids_in_objectid_to_path(self):
        oids = [1]
        inst = self._makeOne()
        result = inst.allowed(oids, 'fred', 'view')
        self.assertEqual(list(result), [])

    def test_allowed_no_acls_in_path_to_acl(self):
        oids = [1]
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        result = inst.allowed(oids, 'fred', 'view')
        self.assertEqual(list(result), [])
        
    def test_allowed_explicit_deny(self):
        oids = [1]
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        inst.path_to_acl[(_BLANK,)] = (('Deny', 'fred', 'view'),)
        result = inst.allowed(oids, 'fred', 'view')
        self.assertEqual(list(result), [])

    def test_allowed_explicit_allow(self):
        oids = [1]
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        inst.path_to_acl[(_BLANK,)] = (('Allow', 'fred', 'view'),)
        result = inst.allowed(oids, 'fred', 'view')
        self.assertEqual(list(result), [1])

    def test_allowed_explicit_allow_and_explicit_deny(self):
        oids = [1, 2]
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK, '1')
        inst.objectid_to_path[2] = (_BLANK, '2')
        inst.path_to_acl[(_BLANK, '1')] = (('Allow', 'fred', 'view'),)
        inst.path_to_acl[(_BLANK, '2')] = (('Deny', 'fred', 'view'),)
        result = inst.allowed(oids, 'fred', 'view')
        self.assertEqual(list(result), [1])

    def test_allowed_explicit_allow_and_inherited_deny(self):
        oids = [1, 2]
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK, '1')
        inst.objectid_to_path[2] = (_BLANK, '2')
        inst.path_to_acl[(_BLANK, '1')] = (('Allow', 'fred', 'view'),)
        inst.path_to_acl[(_BLANK,)] = (('Deny', 'fred', 'view'),)
        result = inst.allowed(oids, 'fred', 'view')
        self.assertEqual(list(result), [1])

    def test_allowed_implicit_deny(self):
        oids = [1]
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK, '1')
        inst.path_to_acl[(_BLANK,)] = (('Allow', 'fred', 'read'),)
        result = inst.allowed(oids, 'fred', 'view')
        self.assertEqual(list(result), [])
        
    def test_functional(self):

        def l(path, depth=None, include_origin=True):
            path_tuple = split(path)
            oids = sorted(
                list(objmap.pathlookup(path_tuple, depth, include_origin))
                )
            count = objmap.pathcount(path_tuple, depth, include_origin)
            return oids, count

        objmap = self._makeOne()
        objmap._v_nextid = 1

        root = resource('/')
        a = resource('/a')
        ab = resource('/a/b')
        abc = resource('/a/b/c')
        z = resource('/z')

        oid1 = objmap.add(ab, ab.path_tuple)
        oid2 = objmap.add(abc, abc.path_tuple)
        oid3 = objmap.add(a, a.path_tuple)
        oid4 = objmap.add(root, root.path_tuple)
        oid5 = objmap.add(z, z.path_tuple)

        # /
        nodepth = l('/')
        assert nodepth == ([oid1, oid2, oid3, oid4, oid5], 5), nodepth
        depth0 = l('/', depth=0)
        assert depth0 == ([oid4], 1), depth0
        depth1 = l('/', depth=1)
        assert depth1 == ([oid3, oid4, oid5], 3), depth1
        depth2 = l('/', depth=2)
        assert depth2 == ([oid1, oid3, oid4, oid5], 4), depth2
        depth3 = l('/', depth=3)
        assert depth3 == ([oid1, oid2, oid3, oid4, oid5], 5), depth3
        depth4 = l('/', depth=4)
        assert depth4 == ([oid1, oid2, oid3, oid4, oid5], 5), depth4

        # /a
        nodepth = l('/a')
        assert nodepth == ([oid1, oid2, oid3], 3), nodepth
        depth0 = l('/a', depth=0)
        assert depth0 == ([oid3], 1), depth0
        depth1 = l('/a', depth=1)
        assert depth1 == ([oid1, oid3], 2), depth1
        depth2 = l('/a', depth=2)
        assert depth2 == ([oid1, oid2, oid3], 3), depth2
        depth3 = l('/a', depth=3)
        assert depth3 == ([oid1, oid2, oid3], 3), depth3

        # /a/b
        nodepth = l('/a/b')
        assert nodepth == ([oid1, oid2], 2), nodepth
        depth0 = l('/a/b', depth=0)
        assert depth0 == ([oid1], 1), depth0
        depth1 = l('/a/b', depth=1)
        assert depth1 == ([oid1, oid2], 2), depth1
        depth2 = l('/a/b', depth=2)
        assert depth2 == ([oid1, oid2], 2), depth2

        # /a/b/c
        nodepth = l('/a/b/c')
        assert nodepth == ([oid2], 1), nodepth
        depth0 = l('/a/b/c', depth=0)
        assert depth0 == ([oid2], 1), depth0
        depth1 = l('/a/b/c', depth=1)
        assert depth1 == ([oid2], 1), depth1

        # remove '/a/b'
        removed = objmap.remove(oid1)
        assert set(removed) == set([1,2])

        # /a/b/c
        nodepth = l('/a/b/c')
        assert nodepth == ([], 0), nodepth
        depth0 = l('/a/b/c', depth=0)
        assert depth0 == ([], 0), depth0
        depth1 = l('/a/b/c', depth=1)
        assert depth1 == ([], 0), depth1

        # /a/b
        nodepth = l('/a/b')
        assert nodepth == ([], 0), nodepth
        depth0 = l('/a/b', depth=0)
        assert depth0 == ([], 0), depth0
        depth1 = l('/a/b', depth=1)
        assert depth1 == ([], 0), depth1

        # /a
        nodepth = l('/a')
        assert nodepth == ([oid3], 1), nodepth
        depth0 = l('/a', depth=0)
        assert depth0 == ([oid3], 1), depth0
        depth1 = l('/a', depth=1)
        assert depth1 == ([oid3], 1), depth1

        # /
        nodepth = l('/')
        assert nodepth == ([oid3, oid4, oid5], 3), nodepth
        depth0 = l('/', depth=0)
        assert depth0 == ([oid4], 1), depth0
        depth1 = l('/', depth=1)
        assert depth1 == ([oid3, oid4, oid5], 3), depth1

        # test include_origin false with /, no depth
        nodepth = l('/', include_origin=False)
        assert nodepth == ([oid3, oid5], 2), nodepth

        # test include_origin false with /, depth=1
        depth1 = l('/', include_origin=False, depth=0)
        assert depth1 == ([], 0), depth1
        
        pathindex = objmap.pathindex
        keys = list(pathindex.keys())

        self.assertEqual(
            keys,
            [(_BLANK,), (_BLANK, _A), (_BLANK, _Z)]
        )

        root = pathindex[(_BLANK,)]
        self.assertEqual(len(root), 2)
        self.assertEqual(set(root[0]), set([4]))
        self.assertEqual(set(root[1]), set([3,5]))

        a = pathindex[(_BLANK, _A)]
        self.assertEqual(len(a), 1)
        self.assertEqual(set(a[0]), set([3]))

        z = pathindex[(_BLANK, _Z)]
        self.assertEqual(len(z), 1)
        self.assertEqual(set(z[0]), set([5]))
        
        self.assertEqual(
            dict(objmap.objectid_to_path),
            {3: (_BLANK, _A), 4: (_BLANK,), 5: (_BLANK, _Z)})
        self.assertEqual(
            dict(objmap.path_to_objectid),
            {(_BLANK, _Z): 5, (_BLANK, _A): 3, (_BLANK,): 4})

        # remove '/'
        removed = objmap.remove((_BLANK,))
        self.assertEqual(set(removed), set([3,4,5]))

        assert dict(objmap.pathindex) == {}
        assert dict(objmap.objectid_to_path) == {}
        assert dict(objmap.path_to_objectid) == {}

    def test__refids_for_source_missing(self):
        inst = self._makeOne()
        self.assertRaises(ValueError, inst._refids_for, 1, 2)
        
    def test__refids_for_target_missing(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        self.assertRaises(ValueError, inst._refids_for, 1, 2)

    def test__refids_for_success_oids(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        inst.objectid_to_path[2] = (_BLANK,)
        s, t = inst._refids_for(1, 2)
        self.assertEqual(s, 1)
        self.assertEqual(t, 2)

    def test__refids_for_success_objects(self):
        inst = self._makeOne()
        one = testing.DummyResource()
        one.__oid__ = 1
        two = testing.DummyResource()
        two.__oid__ = 2
        inst.objectid_to_path[1] = (_BLANK,)
        inst.objectid_to_path[2] = (_BLANK,)
        s, t = inst._refids_for(one, two)
        self.assertEqual(s, 1)
        self.assertEqual(t, 2)
        
    def test__refid_for_missing(self):
        inst = self._makeOne()
        self.assertRaises(ValueError, inst._refid_for, 1)
        
    def test__refid_for_success_oid(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        oid = inst._refid_for(1)
        self.assertEqual(oid, 1)

    def test__refid_for_success_object(self):
        inst = self._makeOne()
        obj = testing.DummyResource()
        obj.__oid__ = 1
        inst.objectid_to_path[1] = (_BLANK,)
        oid = inst._refid_for(obj)
        self.assertEqual(oid, 1)

    def test_connect(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        inst.objectid_to_path[2] = (_BLANK, _A)
        inst.referencemap = DummyReferenceMap()
        inst.connect(1, 2, 'ref')
        self.assertEqual(inst.referencemap['ref'], (1, 2))

    def test_disconnect(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        inst.objectid_to_path[2] = (_BLANK, _A)
        inst.referencemap = DummyReferenceMap()
        inst.referencemap['ref'] = True
        inst.disconnect(1, 2, 'ref')
        self.assertTrue('ref' not in inst.referencemap)

    def test_disconnect_with_objects(self):
        one = testing.DummyResource(__oid__=1)
        two = testing.DummyResource(__oid__=2)
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        inst.objectid_to_path[2] = (_BLANK, _A)
        inst.referencemap = DummyReferenceMap()
        inst.referencemap['ref'] = True
        inst.disconnect(one, two, 'ref')
        self.assertTrue('ref' not in inst.referencemap)

    def test__oidset_not_listset(self):
        inst = self._makeOne()
        oidset = inst._oidset([1,2,3])
        self.assertEqual(oidset.__class__, inst.family.OO.Set)
        self.assertEqual(list(sorted(list(oidset))), [1,2,3])
        
    def test__oidset_is_listset(self):
        from substanced.objectmap import ListSet
        inst = self._makeOne()
        listset = ListSet([1,2,3])
        oidset = inst._oidset(listset)
        self.assertEqual(oidset.__class__, ListSet)
        self.assertTrue(oidset is not listset)
        self.assertEqual(list(sorted(list(oidset))), [1,2,3])
        
    def test_sourceids(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        inst.referencemap = DummyReferenceMap(sourceids=[2])
        self.assertEqual(list(inst.sourceids(1, 'ref')), [2])
        
    def test_targetids(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        inst.referencemap = DummyReferenceMap(targetids=[2])
        self.assertEqual(list(inst.targetids(1, 'ref')), [2])

    def test_sources(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        inst.objectid_to_path[2] = (_BLANK, _A)
        inst.objectid_to_path[3] = (_BLANK, _B)
        inst.referencemap = DummyReferenceMap(sourceids=[2, 3])
        obj = object()
        inst._find_resource = lambda *arg: obj
        self.assertEqual(list(inst.sources(1, 'ref')), [obj, obj])
        
    def test_targets(self):
        inst = self._makeOne()
        inst.objectid_to_path[1] = (_BLANK,)
        inst.objectid_to_path[2] = (_BLANK, _A)
        inst.objectid_to_path[3] = (_BLANK, _B)
        inst.referencemap = DummyReferenceMap(targetids=[2, 3])
        obj = object()
        inst._find_resource = lambda *arg: obj
        self.assertEqual(list(inst.targets(1, 'ref')), [obj, obj])

    def test_has_references_obj(self):
        inst = self._makeOne()
        inst.referencemap = DummyReferenceMap(has_references=True)
        inst.objectid_to_path[1] = (_BLANK,)
        obj = testing.DummyResource()
        obj.__oid__ = 1
        self.assertTrue(inst.has_references(obj))
        self.assertEqual(inst.referencemap.oid_arg, 1)
        self.assertEqual(inst.referencemap.reftype_arg, None)

    def test_has_references_oid(self):
        inst = self._makeOne()
        inst.referencemap = DummyReferenceMap(has_references=True)
        inst.objectid_to_path[1] = (_BLANK,)
        self.assertTrue(inst.has_references(1))
        self.assertEqual(inst.referencemap.oid_arg, 1)
        self.assertEqual(inst.referencemap.reftype_arg, None)

    def test_has_references_with_reftype(self):
        inst = self._makeOne()
        inst.referencemap = DummyReferenceMap(has_references=True)
        inst.objectid_to_path[1] = (_BLANK,)
        self.assertTrue(inst.has_references(1, 'abc'))
        self.assertEqual(inst.referencemap.oid_arg, 1)
        self.assertEqual(inst.referencemap.reftype_arg, 'abc')

    def test_get_reftypes(self):
        inst = self._makeOne()
        inst.referencemap = DummyReferenceMap(reftypes=(1,2))
        self.assertTrue(inst.get_reftypes(), (1,2))

    def test_order_sources_order_is_None(self):
        inst = self._makeOne()
        refmap = DummyReferenceMap()
        inst.referencemap = refmap
        result = inst.order_sources(1, 'reftype', None)
        self.assertEqual(refmap.sources_ordered, [(1, 'reftype', None)])
        self.assertEqual(result, None)

    def test_order_sources_order_is__marker(self):
        from substanced.objectmap import _marker
        inst = self._makeOne()
        refmap = DummyReferenceMap()
        inst.referencemap = refmap
        result = inst.order_sources(1, 'reftype', _marker)
        self.assertEqual(refmap.sources_ordered, [(1, 'reftype', _marker)])
        self.assertEqual(result, _marker)

    def test_order_sources_order_is_oidlist(self):
        inst = self._makeOne()
        refmap = DummyReferenceMap()
        inst.referencemap = refmap
        inst.objectid_to_path = {2:True, 3:True}
        result = inst.order_sources(1, 'reftype', [2,3])
        self.assertEqual(refmap.sources_ordered, [(1, 'reftype', [2,3])])
        self.assertEqual(result, [2,3])

    def test_order_sources_order_is_objectlist(self):
        inst = self._makeOne()
        refmap = DummyReferenceMap()
        inst.referencemap = refmap
        one = testing.DummyResource()
        one.__oid__ = 1
        two = testing.DummyResource()
        two.__oid__ = 2
        inst.objectid_to_path = {1:True, 2:True}
        result = inst.order_sources(1, 'reftype', [one, two])
        self.assertEqual(refmap.sources_ordered, [(1, 'reftype', [1,2])])
        self.assertEqual(result, [1,2])

    def test_order_targets_order_is_None(self):
        inst = self._makeOne()
        refmap = DummyReferenceMap()
        inst.referencemap = refmap
        result = inst.order_targets(1, 'reftype', None)
        self.assertEqual(refmap.targets_ordered, [(1, 'reftype', None)])
        self.assertEqual(result, None)

    def test_order_targets_order_is__marker(self):
        from substanced.objectmap import _marker
        inst = self._makeOne()
        refmap = DummyReferenceMap()
        inst.referencemap = refmap
        result = inst.order_targets(1, 'reftype', _marker)
        self.assertEqual(refmap.targets_ordered, [(1, 'reftype', _marker)])
        self.assertEqual(result, _marker)

    def test_order_targets_order_is_oidlist(self):
        inst = self._makeOne()
        refmap = DummyReferenceMap()
        inst.referencemap = refmap
        inst.objectid_to_path = {2:True, 3:True}
        result = inst.order_targets(1, 'reftype', [2,3])
        self.assertEqual(refmap.targets_ordered, [(1, 'reftype', [2,3])])
        self.assertEqual(result, [2,3])

    def test_order_targets_order_is_objectlist(self):
        inst = self._makeOne()
        refmap = DummyReferenceMap()
        inst.referencemap = refmap
        one = testing.DummyResource()
        one.__oid__ = 1
        two = testing.DummyResource()
        two.__oid__ = 2
        inst.objectid_to_path = {1:True, 2:True}
        result = inst.order_targets(1, 'reftype', [one, two])
        self.assertEqual(refmap.targets_ordered, [(1, 'reftype', [1,2])])
        self.assertEqual(result, [1,2])
        
class TestReferenceSet(unittest.TestCase):
    def _makeOne(self):
        from .. import ReferenceSet
        return ReferenceSet()

    def test_connect_empty(self):
        refset = self._makeOne()
        refset.connect(1, 2)
        self.assertEqual(list(refset.src2target[1]), [2])
        self.assertEqual(list(refset.target2src[2]), [1])
        
    def test_connect_nonempty_overlap(self):
        refset = self._makeOne()
        refset.src2target[1] = DummyTreeSet([2])
        refset.target2src[2] = DummyTreeSet([1])
        refset.connect(1, 2)
        self.assertEqual(list(refset.src2target[1]), [2])
        self.assertEqual(list(refset.target2src[2]), [1])

    def test_connect_nonempty_nonoverlap(self):
        refset = self._makeOne()
        refset.src2target[1] = DummyTreeSet([3])
        refset.target2src[2] = DummyTreeSet([4])
        refset.connect(1, 2)
        self.assertEqual(sorted(list(refset.src2target[1])), [2, 3])
        self.assertEqual(sorted(list(refset.target2src[2])), [1, 4])

    def test_disconnect_empty(self):
        refset = self._makeOne()
        refset.disconnect(1, 2)
        self.assertEqual(list(refset.src2target.keys()), [])
        self.assertEqual(list(refset.target2src.keys()), [])
        
    def test_disconnect_nonempty(self):
        refset = self._makeOne()
        refset.src2target[1] = DummyTreeSet([2, 3])
        refset.target2src[2] = DummyTreeSet([1, 4])
        refset.disconnect(1, 2)
        self.assertEqual(list(refset.src2target[1]), [3])
        self.assertEqual(list(refset.target2src[2]), [4])

    def test_disconnect_keyerrors(self):
        refset = self._makeOne()
        refset.src2target[1] = DummyTreeSet()
        refset.target2src[2] = DummyTreeSet()
        refset.disconnect(1, 2)
        self.assertEqual(list(refset.src2target[1]), [])
        self.assertEqual(list(refset.target2src[2]), [])

    def test_targetids(self):
        refset = self._makeOne()
        dummyset = DummyTreeSet([1])
        refset.src2target[1] = dummyset
        self.assertEqual(refset.targetids(1), dummyset)
        
    def test_sourceids(self):
        refset = self._makeOne()
        dummyset = DummyTreeSet([1])
        refset.target2src[1] = dummyset
        self.assertEqual(refset.sourceids(1), dummyset)

    def test_remove_empty(self):
        refset = self._makeOne()
        self.assertEqual(list(refset.remove([1,2])), [])

    def test_remove_notempty(self):
        # emulate the result of:
        # connect(1, 2)
        # connect(3, 4)
        # connect(2, 4)
        # connect(2, 1)
        # connect(3, 5)
        src2target = {1:DummyTreeSet([2]), 3:DummyTreeSet([4, 5]), 
                      2:DummyTreeSet([4, 1])}
        target2src = {2:DummyTreeSet([1]), 4:DummyTreeSet([3, 2]),
                      1:DummyTreeSet([2]), 5:DummyTreeSet([3])}
        refset = self._makeOne()
        refset.src2target = src2target
        refset.target2src = target2src
        oids = [1,4, 10]
        result = refset.remove(oids)
        self.assertEqual(list(result), [1,4]) # 10 unmentioned
        self.assertEqual(
            src2target,
            {3:DummyTreeSet([5])}
            )
        self.assertEqual(
            target2src,
            {5:DummyTreeSet([3])}
            )

    def test_is_target_True(self):
        refset = self._makeOne()
        refset.target2src[1] = True
        self.assertTrue(refset.is_target(1))

    def test_is_target_False(self):
        refset = self._makeOne()
        self.assertFalse(refset.is_target(1))

    def test_is_source_True(self):
        refset = self._makeOne()
        refset.src2target[1] = True
        self.assertTrue(refset.is_source(1))

    def test_is_source_False(self):
        refset = self._makeOne()
        self.assertFalse(refset.is_source(1))

    def test_order_targets_oid_exists_order_is_None(self):
        refset = self._makeOne()
        refset.src2target[1] = refset.oidlist_class([2])
        oids = refset.order_targets(1, None)
        self.assertEqual(oids.__class__, refset.oidset_class)
        self.assertEqual(list(oids), [2])

    def test_order_targets_oid_missing_order_is_None(self):
        refset = self._makeOne()
        oids = refset.order_targets(1, None)
        self.assertEqual(list(oids), [])
        self.assertFalse(1 in refset.src2target)

    def test_order_targets_oid_points_at_OOSet_order_is_None(self):
        refset = self._makeOne()
        oidset = refset.oidset_class([1])
        refset.src2target[1] = oidset
        oids = refset.order_targets(1, None)
        self.assertTrue(oids is oidset)
        self.assertTrue(refset.src2target[1] is oidset)

    def test_order_targets_invalid_extra_oid_doesnt_exist(self):
        refset = self._makeOne()
        self.assertRaises(ValueError, refset.order_targets, 1, [2])

    def test_order_targets_invalid_extra_oid_exists(self):
        refset = self._makeOne()
        oidset = refset.oidset_class([1])
        refset.src2target[1] = oidset
        self.assertRaises(ValueError, refset.order_targets, 1, [2])

    def test_order_targets_invalid_missing_oid_doesnt_exist(self):
        refset = self._makeOne()
        oidset = refset.oidset_class([1, 2])
        refset.src2target[1] = oidset
        self.assertRaises(ValueError, refset.order_targets, 1, [2])

    def test_order_targets_invalid_missing_oid_exists(self):
        refset = self._makeOne()
        oidset = refset.oidset_class([1, 2])
        refset.src2target[1] = oidset
        self.assertRaises(ValueError, refset.order_targets, 1, [2])

    def test_order_targets_valid_oid_doesnt_exist_with_missing_default(self):
        refset = self._makeOne()
        oids = refset.order_targets(1)
        self.assertEqual(refset.oidlist_class(), oids)

    def test_order_targets_valid_oid_doesnt_exist_with_missing_speced(self):
        refset = self._makeOne()
        oids = refset.order_targets(1, [])
        self.assertEqual(refset.oidlist_class(), oids)
        
    def test_order_targets_valid_oid_exists(self):
        refset = self._makeOne()
        oidset = refset.oidset_class([2, 3])
        refset.src2target[1] = oidset
        oids = refset.order_targets(1, [3,2])
        self.assertEqual(oids, refset.oidlist_class([3,2]))
        self.assertEqual(oids, refset.src2target[1])

    def test_order_sources_oid_exists_order_is_None(self):
        refset = self._makeOne()
        refset.target2src[1] = refset.oidlist_class([2])
        oids = refset.order_sources(1, None)
        self.assertEqual(oids.__class__, refset.oidset_class)
        self.assertEqual(list(oids), [2])

    def test_order_sources_oid_missing_order_is_None(self):
        refset = self._makeOne()
        oids = refset.order_sources(1, None)
        self.assertEqual(list(oids), [])
        self.assertFalse(1 in refset.target2src)

    def test_order_sources_oid_points_at_OOSet_order_is_None(self):
        refset = self._makeOne()
        oidset = refset.oidset_class([1])
        refset.target2src[1] = oidset
        oids = refset.order_sources(1, None)
        self.assertTrue(oids is oidset)
        self.assertTrue(refset.target2src[1] is oidset)

    def test_order_sources_invalid_extra_oid_doesnt_exist(self):
        refset = self._makeOne()
        self.assertRaises(ValueError, refset.order_sources, 1, [2])

    def test_order_sources_invalid_extra_oid_exists(self):
        refset = self._makeOne()
        oidset = refset.oidset_class([1])
        refset.target2src[1] = oidset
        self.assertRaises(ValueError, refset.order_sources, 1, [2])

    def test_order_sources_invalid_missing_oid_doesnt_exist(self):
        refset = self._makeOne()
        oidset = refset.oidset_class([1, 2])
        refset.target2src[1] = oidset
        self.assertRaises(ValueError, refset.order_sources, 1, [2])

    def test_order_sources_invalid_missing_oid_exists(self):
        refset = self._makeOne()
        oidset = refset.oidset_class([1, 2])
        refset.target2src[1] = oidset
        self.assertRaises(ValueError, refset.order_sources, 1, [2])

    def test_order_sources_valid_oid_doesnt_exist_with_missing_default(self):
        refset = self._makeOne()
        oids = refset.order_sources(1)
        self.assertEqual(refset.oidlist_class(), oids)

    def test_order_sources_valid_oid_doesnt_exist_with_missing_speced(self):
        refset = self._makeOne()
        oids = refset.order_sources(1, [])
        self.assertEqual(refset.oidlist_class(), oids)
        
    def test_order_sources_valid_oid_exists(self):
        refset = self._makeOne()
        oidset = refset.oidset_class([2, 3])
        refset.target2src[1] = oidset
        oids = refset.order_sources(1, [3,2])
        self.assertEqual(oids, refset.oidlist_class([3,2]))
        self.assertEqual(oids, refset.target2src[1])

class TestListSet(unittest.TestCase):
    def _makeOne(self, *arg, **kw):
        from substanced.objectmap import ListSet
        return ListSet(*arg, **kw)

    def test_insert(self):
        inst = self._makeOne()
        inst.insert('foo')
        self.assertEqual(inst, self._makeOne(['foo']))

    def test___repr__(self):
        inst = self._makeOne(['foo'])
        self.assertEqual(repr(inst), "<ListSet: ['foo']>")
        
class TestReferenceMap(unittest.TestCase):
    def _makeOne(self, map=None):
        from .. import ReferenceMap
        return ReferenceMap(map)

    def test_ctor(self):
        refs = self._makeOne()
        self.assertEqual(refs.refmap.__class__.__name__, 'OOBTree')

    def test_connect(self):
        refset = DummyReferenceSet()
        map = {'reftype':refset}
        refs = self._makeOne(map)
        refs.connect('a', 'b', 'reftype')
        self.assertEqual(refset.connected, [('a', 'b')])
        
    def test_disconnect(self):
        refset = DummyReferenceSet()
        map = {'reftype':refset}
        refs = self._makeOne(map)
        refs.disconnect('a', 'b', 'reftype')
        self.assertEqual(refset.disconnected, [('a', 'b')])

    def test_targetids_no_refset(self):
        refs = self._makeOne()
        self.assertEqual(list(refs.targetids('a', 'reftype')), [])
        
    def test_targetids_with_refset(self):
        refset = DummyReferenceSet(['123'])
        map = {'reftype':refset}
        refs = self._makeOne(map)
        self.assertEqual(list(refs.targetids('a', 'reftype')), ['123'])

    def test_sourceids_no_refset(self):
        refs = self._makeOne()
        self.assertEqual(list(refs.sourceids('a', 'reftype')), [])
        
    def test_sourceids_with_refset(self):
        refset = DummyReferenceSet(['123'])
        map = {'reftype':refset}
        refs = self._makeOne(map)
        self.assertEqual(list(refs.sourceids('a', 'reftype')), ['123'])

    def test_remove(self):
        L = []
        refset1 = DummyReferenceSet()
        refset2 = DummyReferenceSet()
        refset1.remove = lambda oids: L.append(oids)
        refset2.remove = lambda oids: L.append(oids)
        map = {'reftype':refset1, 'reftype2':refset2}
        refs = self._makeOne(map)
        refs.remove([1,2])
        self.assertEqual(L, [[1,2], [1,2]])

    def test_has_references_True(self):
        refset = DummyReferenceSet(True)
        map = {'reftype':refset}
        refs = self._makeOne(map)
        self.assertTrue(refs.has_references(1))

    def test_has_references_False(self):
        refset = DummyReferenceSet(False)
        map = {'reftype':refset}
        refs = self._makeOne(map)
        self.assertFalse(refs.has_references(1))

    def test_has_references_with_reftype(self):
        refset = DummyReferenceSet(True)
        map = {'reftype':refset}
        refs = self._makeOne(map)
        self.assertTrue(refs.has_references(1, 'reftype'))

    def test_get_reftypes(self):
        map = {'reftype':None}
        refs = self._makeOne(map)
        self.assertEqual(list(refs.get_reftypes()), ['reftype'])

    def test_order_sources_with_refset(self):
        refset = DummyReferenceSet()
        map = {'reftype':refset}
        refs = self._makeOne(map)
        result = refs.order_sources('a', 'reftype', [1, 2, 3])
        self.assertEqual(result, [1,2,3])
        self.assertEqual(refset.sources_ordered, [('a', [1,2,3])])

    def test_order_sources_without_refset(self):
        refs = self._makeOne()
        result = refs.order_sources('a', 'reftype', [])
        self.assertEqual(result, [])
        refset = refs.refmap['reftype']
        self.assertEqual(
            refset.target2src['a'], refset.oidlist_class()
            )

    def test_order_sources_without_refset_order_missing(self):
        refs = self._makeOne()
        result = refs.order_sources('a', 'reftype')
        self.assertEqual(result, [])
        refset = refs.refmap['reftype']
        self.assertEqual(
            refset.target2src['a'], refset.oidlist_class()
            )
        
    def test_order_targets_with_refset(self):
        refset = DummyReferenceSet()
        map = {'reftype':refset}
        refs = self._makeOne(map)
        result = refs.order_targets('a', 'reftype', [1, 2, 3])
        self.assertEqual(result, [1,2,3])
        self.assertEqual(refset.targets_ordered, [('a', [1,2,3])])

    def test_order_targets_without_refset(self):
        refs = self._makeOne()
        result = refs.order_targets('a', 'reftype', [])
        self.assertEqual(result, [])
        refset = refs.refmap['reftype']
        self.assertEqual(
            refset.src2target['a'], refset.oidlist_class()
            )
        
    def test_order_targets_without_refset_order_missing(self):
        refs = self._makeOne()
        result = refs.order_targets('a', 'reftype')
        self.assertEqual(result, [])
        refset = refs.refmap['reftype']
        self.assertEqual(
            refset.src2target['a'], refset.oidlist_class()
            )
        
        
class TestExtentMap(unittest.TestCase):
    def _makeOne(self):
        from .. import ExtentMap
        return ExtentMap()

    def test_ctor(self):
        inst = self._makeOne()
        self.assertEqual(list(inst.extent_to_oids.items()), [])
        self.assertEqual(list(inst.oid_to_extents.items()), [])

    def test_add_and_remove(self):
        inst = self._makeOne()
        obj = Dummy()
        inst.add(obj, 1)
        inst.add(obj, 2)
        dummy_dotted = 'substanced.objectmap.tests.test_init.Dummy'
        self.assertEqual(
            list(inst.extent_to_oids.keys()),
            [dummy_dotted]
            )
        self.assertEqual(
            sorted(list(inst.extent_to_oids[dummy_dotted])),
            [1, 2]
            )
        self.assertEqual(
            sorted(list(inst.oid_to_extents.keys())),
            [1, 2]
            )
        self.assertEqual(
            list(inst.oid_to_extents[1]),
            [dummy_dotted]
            )
        inst.remove([2])
        self.assertEqual(
            list(inst.extent_to_oids.keys()),
            [dummy_dotted]
            )
        self.assertEqual(
            sorted(list(inst.extent_to_oids[dummy_dotted])),
            [1]
            )
        self.assertEqual(
            sorted(list(inst.oid_to_extents.keys())),
            [1]
            )
        self.assertEqual(
            list(inst.oid_to_extents[1]),
            [dummy_dotted]
            )
        inst.remove([1])
        self.assertEqual(
            list(inst.extent_to_oids.keys()),
            []
            )
        self.assertFalse(dummy_dotted in inst.extent_to_oids)

    def test_get(self):
        inst = self._makeOne()
        dummy_dotted = 'substanced.objectmap.tests.test_init.Dummy'
        obj = Dummy()
        inst.add(obj, 1)
        self.assertEqual(
            sorted(list(inst.get(dummy_dotted))),
            [1]
            )
        self.assertEqual(inst.get('foo', 'bar'), 'bar')
        self.assertEqual(inst.get('foo'), None)

class Test_reference_sourceid_property(unittest.TestCase):
    def setUp(self):
        from substanced.interfaces import IFolder
        @implementer(IFolder)
        class DummyFolder(dict):
            pass
        self.DummyFolder = DummyFolder

    def _makeInst(self, reftype=None):
        if reftype is None:
            reftype = Dummy
        from .. import reference_sourceid_property
        class Inner(self.DummyFolder):
            prop = reference_sourceid_property(reftype)
        inst = Inner()
        return inst

    def test_get_no_targetids(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        self.assertEqual(inst.prop, None)

    def test_get_one_targetid(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        self.assertEqual(inst.prop, 1)

    def test_get_get_one_targetid(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,2))
        inst.__objectmap__ = objectmap
        self.assertRaises(AssertionError, getattr, inst, 'prop')

    def test_del_no_target_id(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(inst.prop, None)

    def test_del_one_targetid(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(objectmap.disconnected, [(inst, 1, Dummy)])

    def test_set_None(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        inst.prop = None
        self.assertEqual(objectmap.connected, [])

    def test_set_colander_null(self):
        from colander import null
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = null
        self.assertEqual(inst.prop, 1)
        self.assertEqual(objectmap.disconnected, [])

    def test_set_not_None(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap 
        inst.prop = 2
        self.assertEqual(objectmap.connected, [(inst, 2, Dummy)])

class Test_reference_targetid_property(unittest.TestCase):
    def setUp(self):
        from substanced.interfaces import IFolder
        @implementer(IFolder)
        class DummyFolder(dict):
            pass
        self.DummyFolder = DummyFolder

    def _makeInst(self, reftype=None):
        if reftype is None:
            reftype = Dummy
        from .. import reference_targetid_property
        class Inner(self.DummyFolder):
            prop = reference_targetid_property(reftype)
        inst = Inner()
        return inst

    def test_get_no_sourceids(self):
        inst = self._makeInst()
        inst.__objectmap__ = DummyObjectMap(sourceids=())
        self.assertEqual(inst.prop, None)

    def test_get_one_sourceid(self):
        inst = self._makeInst()
        inst.__objectmap__ = DummyObjectMap(sourceids=(1,))
        self.assertEqual(inst.prop, 1)

    def test_get_gt_one_sourceid(self):
        inst = self._makeInst()
        inst.__objectmap__ = DummyObjectMap(sourceids=(1,2))
        self.assertRaises(AssertionError, getattr, inst, 'prop')

    def test_del_no_source_id(self):
        inst = self._makeInst()
        inst.__objectmap__ = DummyObjectMap(sourceids=())
        del inst.prop
        self.assertEqual(inst.prop, None)

    def test_del_one_sourceid(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(objectmap.disconnected, [(1, inst, Dummy)])

    def test_set_None(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        inst.prop = None
        self.assertEqual(objectmap.connected, [])

    def test_set_colander_null(self):
        from colander import null
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = null
        self.assertEqual(inst.prop, 1)
        self.assertEqual(objectmap.disconnected, [])

    def test_set_not_None(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        inst.prop = 2
        self.assertEqual(objectmap.connected, [(2, inst, Dummy)])

class Test_reference_source_property(unittest.TestCase):
    def setUp(self):
        from substanced.interfaces import IFolder
        @implementer(IFolder)
        class DummyFolder(dict):
            pass
        self.DummyFolder = DummyFolder

    def _makeInst(self, reftype=None):
        if reftype is None:
            reftype = Dummy
        from .. import reference_source_property
        class Inner(self.DummyFolder):
            prop = reference_source_property(reftype)
        inst = Inner()
        inst.__oid__ = 1
        return inst

    def test_get_no_targetids(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(), result=1)
        inst.__objectmap__ = objectmap
        self.assertEqual(inst.prop, None)

    def test_get_one_targetid(self):
        inst = self._makeInst()
        ob = object()
        objectmap = DummyObjectMap(targetids=(1,), result=ob)
        inst.__objectmap__ = objectmap
        self.assertEqual(inst.prop, ob)

    def test_get_gt_one_targetid(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,2))
        inst.__objectmap__ = objectmap
        self.assertRaises(AssertionError, getattr, inst, 'prop')

    def test_del_no_target_id(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(inst.prop, None)

    def test_del_one_targetid(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(objectmap.disconnected, [(inst, 1, Dummy)])

    def test_set_None(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        inst.prop = None
        self.assertEqual(objectmap.connected, [])

    def test_set_colander_null(self):
        from colander import null
        inst = self._makeInst()
        ob = object()
        objectmap = DummyObjectMap(targetids=(1,), result=ob)
        inst.__objectmap__ = objectmap
        inst.prop = null
        self.assertEqual(inst.prop, ob)
        self.assertEqual(objectmap.disconnected, [])

    def test_set_not_None(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        inst.prop = 2
        self.assertEqual(objectmap.connected, [(inst, 2, Dummy)])

class Test_reference_target_property(unittest.TestCase):
    def setUp(self):
        from substanced.interfaces import IFolder
        @implementer(IFolder)
        class DummyFolder(dict):
            pass
        self.DummyFolder = DummyFolder

    def _makeInst(self, reftype=None):
        if reftype is None:
            reftype = Dummy
        from .. import reference_target_property
        class Inner(self.DummyFolder):
            prop = reference_target_property(reftype)
        inst = Inner()
        inst.__oid__ = 1
        return inst

    def test_get_no_sourceids(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        self.assertEqual(inst.prop, None)

    def test_get_one_sourceid(self):
        inst = self._makeInst()
        ob = object()
        objectmap = DummyObjectMap(sourceids=(1,), result=ob)
        inst.__objectmap__ = objectmap
        self.assertEqual(inst.prop, ob)

    def test_get_gt_one_sourceid(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,2))
        inst.__objectmap__ = objectmap
        self.assertRaises(AssertionError, getattr, inst, 'prop')

    def test_del_no_source_id(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(inst.prop, None)

    def test_del_one_sourceid(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(objectmap.disconnected, [(1, inst, Dummy)])

    def test_set_None(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        inst.prop = None
        self.assertEqual(objectmap.connected, [])

    def test_set_colander_null(self):
        from colander import null
        inst = self._makeInst()
        ob = object()
        objectmap = DummyObjectMap(sourceids=(1,), result=ob)
        inst.__objectmap__ = objectmap
        inst.prop = null
        self.assertEqual(inst.prop, ob)
        self.assertEqual(objectmap.disconnected, [])

    def test_set_not_None(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        inst.prop = 2
        self.assertEqual(objectmap.connected, [(2, inst, Dummy)])

class Test_multireference_sourceid_property(unittest.TestCase):
    def setUp(self):
        from substanced.interfaces import IFolder
        @implementer(IFolder)
        class DummyFolder(dict):
            pass
        self.DummyFolder = DummyFolder

    def _makeInst(self, reftype=None, ignore_missing=False, ordered=False):
        if reftype is None:
            reftype = Dummy
        from .. import multireference_sourceid_property
        class Inner(self.DummyFolder):
            prop = multireference_sourceid_property(
                reftype,
                ignore_missing=ignore_missing,
                ordered=ordered,
                )
        inst = Inner()
        inst.__oid__ = -1
        return inst

    def test_get_zero(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        self.assertEqual(list(inst.prop), [])

    def test_get_one(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        self.assertEqual(list(inst.prop), [1])

    def test_get_two(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,2))
        inst.__objectmap__ = objectmap
        self.assertEqual(list(inst.prop), [1,2])

    def test_del_zero(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(list(inst.prop), [])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_del_one(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(objectmap.disconnected, [(-1, 1, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_del_two(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,2))
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(objectmap.disconnected,
                         [(-1, 1, Dummy), (-1, 2, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_set_None(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        self.assertRaises(ValueError, inst.__setattr__, 'prop', None)
        self.assertEqual(objectmap.targets_ordered, [])

    def test_set_colander_null(self):
        from colander import null
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = null
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.targets_ordered, [])

    def test_set_zero(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = []
        self.assertEqual(objectmap.disconnected, [(-1, 1, Dummy)])
        self.assertEqual(objectmap.connected, [])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)]*2)

    def test_set_one(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = [2]
        self.assertEqual(objectmap.disconnected, [(-1, 1, Dummy)])
        self.assertEqual(objectmap.connected, [(-1, 2, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)]*2)

    def test_set_two(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = [2, 3]
        self.assertEqual(objectmap.disconnected, [(-1, 1, Dummy)])
        self.assertEqual(objectmap.connected,
                         [(-1, 2, Dummy), (-1, 3, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)]*2)

    def test_clear(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop.clear()
        self.assertEqual(objectmap.disconnected, [(-1, 1, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_connect(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        inst.prop.connect([2,3])
        self.assertEqual(objectmap.connected,
                         [(-1, 2, Dummy), (-1, 3, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_connect_with_ordering(self):
        inst = self._makeInst(ordered=True)
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        inst.prop.connect([2,3])
        self.assertEqual(objectmap.connected,
                         [(-1, 2, Dummy), (-1, 3, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, ())])
        
    def test_connect_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        self.assertRaises(ValueError, inst.prop.connect, [2,3])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_connect_with_ignore_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        inst.prop.connect([2,3], ignore_missing=True)
        self.assertEqual(objectmap.connected, [])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_disconnect(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3])
        self.assertEqual(objectmap.disconnected,
                         [(-1, 2, Dummy), (-1, 3, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])
        
    def test_disconnect_with_ordering(self):
        inst = self._makeInst(ordered=True)
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3])
        self.assertEqual(objectmap.disconnected,
                         [(-1, 2, Dummy), (-1, 3, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, ())])
        
    def test_disconnect_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        self.assertRaises(ValueError, inst.prop.disconnect, [2,3])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_disconnect_with_ignore_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3], ignore_missing=True)
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_ignore_missing_implicit(self):
        inst = self._makeInst(ignore_missing=True)
        objectmap = DummyObjectMap(targetids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3])
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

class Test_multireference_source_property(unittest.TestCase):
    def setUp(self):
        from substanced.interfaces import IFolder
        @implementer(IFolder)
        class DummyFolder(dict):
            pass
        self.DummyFolder = DummyFolder

    def _makeInst(self, reftype=None, ignore_missing=False, ordered=False):
        if reftype is None:
            reftype = Dummy
        from .. import multireference_source_property
        class Inner(self.DummyFolder):
            prop = multireference_source_property(
                reftype,
                ignore_missing=ignore_missing,
                ordered=ordered,
                )
        inst = Inner()
        inst.__oid__ = -1
        return inst

    def test_get_zero(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        self.assertEqual(list(inst.prop), [])

    def test_get_one(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,), result=object)
        inst.__objectmap__ = objectmap
        self.assertEqual(list(inst.prop), [object])

    def test_get_two(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,2), result=object)
        inst.__objectmap__ = objectmap
        self.assertEqual(list(inst.prop), [object, object])

    def test_del_zero(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(list(inst.prop), [])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_del_one(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(objectmap.disconnected, [(-1, 1, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_del_two(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,2))
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(objectmap.disconnected,
                         [(-1, 1, Dummy), (-1, 2, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_set_None(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        self.assertRaises(ValueError, inst.__setattr__, 'prop', None)
        self.assertEqual(objectmap.targets_ordered, [])

    def test_set_colander_null(self):
        from colander import null
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = null
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.targets_ordered, [])

    def test_set_zero(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = []
        self.assertEqual(objectmap.disconnected, [(-1, 1, Dummy)])
        self.assertEqual(objectmap.connected, [])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)]*2)

    def test_set_one(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = [2]
        self.assertEqual(objectmap.disconnected, [(-1, 1, Dummy)])
        self.assertEqual(objectmap.connected, [(-1, 2, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)]*2)

    def test_set_two(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = [2, 3]
        self.assertEqual(objectmap.disconnected, [(-1, 1, Dummy)])
        self.assertEqual(objectmap.connected,
                         [(-1, 2, Dummy), (-1, 3, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)]*2)

    def test_clear(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop.clear()
        self.assertEqual(objectmap.disconnected, [(-1, 1, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_connect(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        inst.prop.connect([2,3])
        self.assertEqual(objectmap.connected,
                         [(-1, 2, Dummy), (-1, 3, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])
        
    def test_connect_with_ordering(self):
        inst = self._makeInst(ordered=True)
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        inst.prop.connect([2,3])
        self.assertEqual(objectmap.connected,
                         [(-1, 2, Dummy), (-1, 3, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, ())])
        
    def test_connect_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        self.assertRaises(ValueError, inst.prop.connect, [2,3])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_connect_with_ignore_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        inst.prop.connect([2,3], ignore_missing=True)
        self.assertEqual(objectmap.connected, [])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_disconnect(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3])
        self.assertEqual(objectmap.disconnected,
                         [(-1, 2, Dummy), (-1, 3, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])
        
    def test_disconnect_with_ordering(self):
        inst = self._makeInst(ordered=True)
        objectmap = DummyObjectMap(targetids=())
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3])
        self.assertEqual(objectmap.disconnected,
                         [(-1, 2, Dummy), (-1, 3, Dummy)])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, ())])
        
    def test_disconnect_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        self.assertRaises(ValueError, inst.prop.disconnect, [2,3])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_disconnect_with_ignore_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(targetids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3], ignore_missing=True)
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

    def test_disconnect_ignore_missing_implicit(self):
        inst = self._makeInst(ignore_missing=True)
        objectmap = DummyObjectMap(targetids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3])
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.targets_ordered, [(-1, Dummy, None)])

class Test_multireference_targetid_property(unittest.TestCase):
    def setUp(self):
        from substanced.interfaces import IFolder
        @implementer(IFolder)
        class DummyFolder(dict):
            pass
        self.DummyFolder = DummyFolder

    def _makeInst(self, reftype=None, ignore_missing=False, ordered=False):
        if reftype is None:
            reftype = Dummy
        from .. import multireference_targetid_property
        class Inner(self.DummyFolder):
            prop = multireference_targetid_property(
                reftype,
                ignore_missing=ignore_missing,
                ordered=ordered,
                )
        inst = Inner()
        inst.__oid__ = -1
        return inst

    def test_get_zero(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        self.assertEqual(list(inst.prop), [])

    def test_get_one(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        self.assertEqual(list(inst.prop), [1])

    def test_get_two(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,2))
        inst.__objectmap__ = objectmap
        self.assertEqual(list(inst.prop), [1,2])

    def test_del_zero(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(list(inst.prop), [])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_del_one(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(objectmap.disconnected, [(1, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_del_two(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,2))
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(objectmap.disconnected,
                         [(1, -1, Dummy), (2, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_set_None(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        self.assertRaises(ValueError, inst.__setattr__, 'prop', None)
        self.assertEqual(objectmap.sources_ordered, [])

    def test_set_colander_null(self):
        from colander import null
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = null
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.sources_ordered, [])

    def test_set_zero(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = []
        self.assertEqual(objectmap.disconnected, [(1, -1, Dummy)])
        self.assertEqual(objectmap.connected, [])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)]*2)

    def test_set_one(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = [2]
        self.assertEqual(objectmap.disconnected, [(1, -1, Dummy)])
        self.assertEqual(objectmap.connected, [(2, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)]*2)

    def test_set_two(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = [2, 3]
        self.assertEqual(objectmap.disconnected, [(1, -1, Dummy)])
        self.assertEqual(objectmap.connected,
                         [(2, -1, Dummy), (3, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)]*2)

    def test_clear(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop.clear()
        self.assertEqual(objectmap.disconnected, [(1, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_connect(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        inst.prop.connect([2,3])
        self.assertEqual(objectmap.connected,
                         [(2, -1, Dummy), (3, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])
        
    def test_connect_with_ordering(self):
        inst = self._makeInst(ordered=True)
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        inst.prop.connect([2,3])
        self.assertEqual(objectmap.connected,
                         [(2, -1, Dummy), (3, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, ())])
        
    def test_connect_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        self.assertRaises(ValueError, inst.prop.connect, [2,3])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_connect_with_ignore_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        inst.prop.connect([2,3], ignore_missing=True)
        self.assertEqual(objectmap.connected, [])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_disconnect(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3])
        self.assertEqual(objectmap.disconnected,
                         [(2, -1, Dummy), (3, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])
        
    def test_disconnect_with_ordering(self):
        inst = self._makeInst(ordered=True)
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3])
        self.assertEqual(objectmap.disconnected,
                         [(2, -1, Dummy), (3, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, ())])
        
    def test_disconnect_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        self.assertRaises(ValueError, inst.prop.disconnect, [2,3])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_disconnect_with_ignore_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3], ignore_missing=True)
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_disconnect_ignore_missing_implicit(self):
        inst = self._makeInst(ignore_missing=True)
        objectmap = DummyObjectMap(sourceids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3])
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

class Test_multireference_target_property(unittest.TestCase):
    def setUp(self):
        from substanced.interfaces import IFolder
        @implementer(IFolder)
        class DummyFolder(dict):
            pass
        self.DummyFolder = DummyFolder

    def _makeInst(self, reftype=None, ignore_missing=False, ordered=False):
        if reftype is None:
            reftype = Dummy
        from .. import multireference_target_property
        class Inner(self.DummyFolder):
            prop = multireference_target_property(
                reftype,
                ignore_missing=ignore_missing,
                ordered=ordered,
                )
        inst = Inner()
        inst.__oid__ = -1
        return inst

    def test_get_zero(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        self.assertEqual(list(inst.prop), [])

    def test_get_one(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,), result=object)
        inst.__objectmap__ = objectmap
        self.assertEqual(list(inst.prop), [object])

    def test_get_two(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,2), result=object)
        inst.__objectmap__ = objectmap
        self.assertEqual(list(inst.prop), [object, object])

    def test_del_zero(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(list(inst.prop), [])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_del_one(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(objectmap.disconnected, [(1, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_del_two(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,2))
        inst.__objectmap__ = objectmap
        del inst.prop
        self.assertEqual(objectmap.disconnected,
                         [(1, -1, Dummy), (2, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_set_None(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        self.assertRaises(ValueError, inst.__setattr__, 'prop', None)

    def test_set_colander_null(self):
        from colander import null
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = null
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.sources_ordered, [])

    def test_set_zero(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = []
        self.assertEqual(objectmap.disconnected, [(1, -1, Dummy)])
        self.assertEqual(objectmap.connected, [])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)]*2)

    def test_set_one(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = [2]
        self.assertEqual(objectmap.disconnected, [(1, -1, Dummy)])
        self.assertEqual(objectmap.connected, [(2, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)]*2)

    def test_set_two(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop = [2, 3]
        self.assertEqual(objectmap.disconnected, [(1, -1, Dummy)])
        self.assertEqual(objectmap.connected,
                         [(2, -1, Dummy), (3, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)]*2)

    def test_clear(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(1,))
        inst.__objectmap__ = objectmap
        inst.prop.clear()
        self.assertEqual(objectmap.disconnected, [(1, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_connect(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        inst.prop.connect([2,3])
        self.assertEqual(objectmap.connected,
                         [(2, -1, Dummy), (3, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])
        
    def test_connect_with_ordering(self):
        inst = self._makeInst(ordered=True)
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        inst.prop.connect([2,3])
        self.assertEqual(objectmap.connected,
                         [(2, -1, Dummy), (3, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, ())])
        
    def test_connect_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        self.assertRaises(ValueError, inst.prop.connect, [2,3])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_connect_with_ignore_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        inst.prop.connect([2,3], ignore_missing=True)
        self.assertEqual(objectmap.connected, [])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_disconnect(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3])
        self.assertEqual(objectmap.disconnected,
                         [(2, -1, Dummy), (3, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])
        
    def test_disconnect_with_ordering(self):
        inst = self._makeInst(ordered=True)
        objectmap = DummyObjectMap(sourceids=())
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3])
        self.assertEqual(objectmap.disconnected,
                         [(2, -1, Dummy), (3, -1, Dummy)])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, ())])
        
    def test_disconnect_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        self.assertRaises(ValueError, inst.prop.disconnect, [2,3])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_disconnect_with_ignore_missing(self):
        inst = self._makeInst()
        objectmap = DummyObjectMap(sourceids=(),
                                   toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3], ignore_missing=True)
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

    def test_disconnect_ignore_missing_implicit(self):
        inst = self._makeInst(ignore_missing=True)
        objectmap = DummyObjectMap(sourceids=(),
                                           toraise=ValueError('a'))
        inst.__objectmap__ = objectmap
        inst.prop.disconnect([2,3])
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.sources_ordered, [(-1, Dummy, None)])

class TestMultireference(unittest.TestCase):
    def _makeOne(
        self,
        context,
        oids,
        objectmap,
        ignore_missing=False,
        resolve=False,
        orientation='source'
        ):
        from .. import Multireference
        m = Multireference(
            context,
            objectmap,
            'reftype',
            ignore_missing=ignore_missing,
            resolve=resolve,
            orientation=orientation
            )
        m.get_oids = lambda: oids
        return m

    def _makeContext(self):
        resource = testing.DummyResource()
        resource.__oid__ = -1
        return resource

    def test___nonzero__True(self):
        inst = self._makeOne(None, [1], None)
        self.assertTrue(inst.__nonzero__())
        
    def test___nonzero__False(self):
        inst = self._makeOne(None, [], None)
        self.assertFalse(inst.__nonzero__())

    def test___getitem__(self):
        inst = self._makeOne(None, [1], None)
        self.assertEqual(inst[0], 1)

    def test___getitem___with_resolve(self):
        objectmap = DummyObjectMap(result=object)
        inst = self._makeOne(None, [1], objectmap, resolve=True)
        self.assertEqual(inst[0], object)
        
    def test___contains__True(self):
        inst = self._makeOne(None, [1], None)
        self.assertTrue(inst.__contains__(1))
        
    def test___contains__False(self):
        inst = self._makeOne(None, [], None)
        self.assertFalse(inst.__contains__(1))
            
    def test___contains___withresolve_True(self):
        objectmap = DummyObjectMap(result=object)
        inst = self._makeOne(None, [1], objectmap, resolve=True)
        self.assertTrue(inst.__contains__(object))
        
    def test___contains___withresolve_False_empty(self):
        objectmap = DummyObjectMap(result=object)
        inst = self._makeOne(None, [], objectmap, resolve=True)
        self.assertFalse(inst.__contains__(object))

    def test___contains___withresolve_False_nonempty(self):
        objectmap = DummyObjectMap(result=object)
        inst = self._makeOne(None, [1], objectmap, resolve=True)
        self.assertFalse(inst.__contains__(None))

    def test___iter__(self):
        inst = self._makeOne(None, [1], None)
        self.assertEqual(list(inst.__iter__()), [1])

    def test___iter__withresolve(self):
        objectmap = DummyObjectMap(result=object)
        inst = self._makeOne(None, [1], objectmap, resolve=True)
        self.assertEqual(list(inst.__iter__()), [object])

    def test___len__(self):
        inst = self._makeOne(None, [1], None)
        self.assertEqual(len(inst), 1)

    def test_connect_zero(self):
        objectmap = DummyObjectMap()
        context = self._makeContext()
        inst = self._makeOne(context, [1], objectmap)
        inst.connect([])
        self.assertEqual(objectmap.connected, [])
        
    def test_connect_one(self):
        objectmap = DummyObjectMap()
        context = self._makeContext()
        inst = self._makeOne(context, [1], objectmap)
        inst.connect([1])
        self.assertEqual(objectmap.connected, [(-1, 1, 'reftype')])
        self.assertEqual(objectmap.targets_ordered, [(-1, 'reftype', None)])
        
    def test_connect_two(self):
        objectmap = DummyObjectMap()
        context = self._makeContext()
        inst = self._makeOne(context, [1, 2], objectmap)
        inst.connect([1, 2])
        self.assertEqual(
            objectmap.connected,
            [(-1, 1, 'reftype'), (-1, 2, 'reftype')]
            )
        self.assertEqual(objectmap.targets_ordered, [(-1, 'reftype', None)])

    def test_connect_ignore_missing_explicit(self):
        objectmap = DummyObjectMap(toraise=ValueError('a'))
        context = self._makeContext()
        inst = self._makeOne(context, [1, 2], objectmap)
        inst.connect([1, 2], ignore_missing=True)
        self.assertEqual(objectmap.connected, [])
        self.assertEqual(objectmap.targets_ordered, [(-1, 'reftype', None)])

    def test_connect_ignore_missing_implicit(self):
        objectmap = DummyObjectMap(toraise=ValueError('a'))
        context = self._makeContext()
        inst = self._makeOne(context, [1, 2], objectmap, ignore_missing=True)
        inst.connect([1, 2])
        self.assertEqual(objectmap.connected, [])
        self.assertEqual(objectmap.targets_ordered, [(-1, 'reftype', None)])

    def test_connect_nonsource(self):
        objectmap = DummyObjectMap()
        context = self._makeContext()
        inst = self._makeOne(context, [1, 2], objectmap, orientation='target')
        inst.connect([1, 2])
        self.assertEqual(
            objectmap.connected,
            [(1, -1, 'reftype'), (2, -1, 'reftype')]
            )
        self.assertEqual(objectmap.sources_ordered, [(-1, 'reftype', None)])

    def test_disconnect_zero(self):
        objectmap = DummyObjectMap()
        context = self._makeContext()
        inst = self._makeOne(context, [1], objectmap)
        inst.disconnect([])
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.targets_ordered, [(-1, 'reftype', None)])
        
    def test_disconnect_one(self):
        objectmap = DummyObjectMap()
        context = self._makeContext()
        inst = self._makeOne(context, [1], objectmap)
        inst.disconnect([1])
        self.assertEqual(objectmap.disconnected, [(-1, 1, 'reftype')])
        self.assertEqual(objectmap.targets_ordered, [(-1, 'reftype', None)])

    def test_disconnect_two(self):
        objectmap = DummyObjectMap()
        context = self._makeContext()
        inst = self._makeOne(context, [1, 2], objectmap)
        inst.disconnect([1, 2])
        self.assertEqual(
            objectmap.disconnected,
            [(-1, 1, 'reftype'), (-1, 2, 'reftype')]
            )
        self.assertEqual(objectmap.targets_ordered, [(-1, 'reftype', None)])

    def test_disconnect_ignore_missing_explicit(self):
        objectmap = DummyObjectMap(toraise=ValueError('a'))
        context = self._makeContext()
        inst = self._makeOne(context, [1, 2], objectmap)
        inst.disconnect([1, 2], ignore_missing=True)
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.targets_ordered, [(-1, 'reftype', None)])
        
    def test_disconnect_ignore_missing_implicit(self):
        objectmap = DummyObjectMap(toraise=ValueError('a'))
        context = self._makeContext()
        inst = self._makeOne(context, [1, 2], objectmap, ignore_missing=True)
        inst.disconnect([1, 2])
        self.assertEqual(objectmap.disconnected, [])
        self.assertEqual(objectmap.targets_ordered, [(-1, 'reftype', None)])

    def test_disconnect_nonsource(self):
        objectmap = DummyObjectMap()
        context = self._makeContext()
        inst = self._makeOne(context, [1, 2], objectmap, orientation='target')
        inst.disconnect([1, 2])
        self.assertEqual(
            objectmap.disconnected,
            [(1, -1, 'reftype'), (2, -1, 'reftype')]
            )
        self.assertEqual(objectmap.sources_ordered, [(-1, 'reftype', None)])

    def test_clear(self):
        objectmap = DummyObjectMap()
        context = self._makeContext()
        inst = self._makeOne(context, [1, 2], objectmap)
        inst.clear()
        self.assertEqual(
            objectmap.disconnected,
            [(-1, 1, 'reftype'), (-1, 2, 'reftype')]
            )
        self.assertEqual(objectmap.targets_ordered, [(-1, 'reftype', None)])

    def test_set_ordered_as_source(self):
        objectmap = DummyObjectMap()
        context = self._makeContext()
        inst = self._makeOne(context, [1, 2], objectmap, orientation='source')
        inst.set_ordered(context.__oid__)
        self.assertEqual(objectmap.targets_ordered,  [(-1, 'reftype', [1, 2])])

    def test_set_ordered_as_target(self):
        objectmap = DummyObjectMap()
        context = self._makeContext()
        inst = self._makeOne(context, [1, 2], objectmap, orientation='target')
        inst.set_ordered(context.__oid__)
        self.assertEqual(objectmap.sources_ordered,  [(-1, 'reftype', [1, 2])])

    def test_set_unordered_as_source(self):
        objectmap = DummyObjectMap()
        context = self._makeContext()
        inst = self._makeOne(context, [1, 2], objectmap, orientation='source')
        inst.set_unordered(context.__oid__)
        self.assertEqual(objectmap.targets_ordered,  [(-1, 'reftype', None)])

    def test_set_unordered_as_target(self):
        objectmap = DummyObjectMap()
        context = self._makeContext()
        inst = self._makeOne(context, [1, 2], objectmap, orientation='target')
        inst.set_unordered(context.__oid__)
        self.assertEqual(objectmap.sources_ordered,  [(-1, 'reftype', None)])
        
class Test_ReferencedPredicate(unittest.TestCase):
    def _makeOne(self, val, config):
        from .. import _ReferencedPredicate
        return _ReferencedPredicate(val, config)

    def test_text(self):
        config = Dummy()
        config.registry = Dummy()
        inst = self._makeOne(True, config)
        self.assertEqual(inst.text(), 'referenced = True')

    def test_phash(self):
        config = Dummy()
        config.registry = Dummy()
        inst = self._makeOne(True, config)
        self.assertEqual(inst.phash(), 'referenced = True')

    def test__call__(self):
        config = Dummy()
        config.registry = Dummy()
        inst = self._makeOne(True, config)
        def has_references(context):
            self.assertEqual(context, None)
            return True
        inst.has_references = has_references
        self.assertEqual(inst(None, None), True)

class Test_has_references(unittest.TestCase):
    def _callFUT(self, context):
        from .. import has_references
        return has_references(context)
    
    def test_objectmap_is_None(self):
        result = self._callFUT(None)
        self.assertEqual(result, False)

    def test_oid_is_None(self):
        context = testing.DummyResource()
        context.__objectmap__ = True
        result = self._callFUT(context)
        self.assertEqual(result, False)

    def test_gardenpath(self):
        context = testing.DummyResource()
        context.__objectmap__ = DummyObjectMap(result=True)
        context.__oid__ = 1
        result = self._callFUT(context)
        self.assertEqual(result, True)

class Test_referential_integrity(unittest.TestCase):
    def _callFUT(self, event):
        from .. import referential_integrity
        return referential_integrity(event)

    def test_moving(self):
        event = DummyEvent(None, moving=True)
        self.assertFalse(self._callFUT(event))

    def test_no_objectmap(self):
        event = DummyEvent(None)
        self.assertFalse(self._callFUT(event))

    def test_no_reftypes(self):
        obj = testing.DummyResource()
        obj.__objectmap__ = DummyObjectMap()
        event = DummyEvent(obj)
        self.assertFalse(self._callFUT(event))

    def test_reftype_without_integrity(self):
        obj = testing.DummyResource()
        obj.__objectmap__ = DummyObjectMap(reftypes=('abc',))
        event = DummyEvent(obj)
        self.assertFalse(self._callFUT(event))

    def test_reftype_with_source_integrity_no_targetids(self):
        from substanced.interfaces import ReferenceType
        obj = testing.DummyResource()
        class Reference(ReferenceType):
            source_integrity = True
        obj.__objectmap__ = DummyObjectMap(reftypes=(Reference,))
        event = DummyEvent(obj)
        self.assertFalse(self._callFUT(event))

    def test_reftype_with_source_integrity_with_targetids(self):
        from substanced.interfaces import ReferenceType
        from .. import SourceIntegrityError
        obj = testing.DummyResource()
        class Reference(ReferenceType):
            source_integrity = True
        obj.__objectmap__ = DummyObjectMap(
            reftypes=(Reference,), targetids=(1,)
            )
        event = DummyEvent(obj)
        self.assertRaises(SourceIntegrityError, self._callFUT, event)

    def test_reftype_with_source_integrity_with_only_self_targetid(self):
        from substanced.interfaces import ReferenceType
        obj = testing.DummyResource()
        class Reference(ReferenceType):
            source_integrity = True
        obj.__objectmap__ = DummyObjectMap(
            reftypes=(Reference,), targetids=set([100])
            )
        event = DummyEvent(obj)
        self.assertEqual(None, self._callFUT(event)) # self-reference ignored

    def test_reftype_with_target_integrity_no_sourceids(self):
        from substanced.interfaces import ReferenceType
        obj = testing.DummyResource()
        class Reference(ReferenceType):
            target_integrity = True
        obj.__objectmap__ = DummyObjectMap(reftypes=(Reference,))
        event = DummyEvent(obj)
        self.assertFalse(self._callFUT(event))

    def test_reftype_with_target_integrity_with_sourceids(self):
        from substanced.interfaces import ReferenceType
        from .. import TargetIntegrityError
        obj = testing.DummyResource()
        class Reference(ReferenceType):
            target_integrity = True
        obj.__objectmap__ = DummyObjectMap(
            reftypes=(Reference,), sourceids=(1,)
            )
        event = DummyEvent(obj)
        self.assertRaises(TargetIntegrityError, self._callFUT, event)

    def test_reftype_with_target_integrity_with_only_self_sourceid(self):
        from substanced.interfaces import ReferenceType
        obj = testing.DummyResource()
        class Reference(ReferenceType):
            target_integrity = True
        obj.__objectmap__ = DummyObjectMap(
            reftypes=(Reference,), sourceids=set([100])
            )
        event = DummyEvent(obj)
        self.assertEqual(None, self._callFUT(event)) # self-reference ignored

class TestReferentialIntegrityError(unittest.TestCase):
    def _makeOne(self, obj, reftype, oids):
        from .. import ReferentialIntegrityError
        return ReferentialIntegrityError(obj, reftype, oids)

    def test_get_objects(self):
        objectmap = DummyObjectMap(result='one')
        obj = testing.DummyResource()
        obj.__objectmap__ = objectmap
        inst = self._makeOne(obj, 'reftype', (1,))
        self.assertEqual(list(inst.get_objects()), ['one'])

    def test_get_paths(self):
        objectmap = DummyObjectMap(result='one')
        obj = testing.DummyResource()
        obj.__objectmap__ = objectmap
        inst = self._makeOne(obj, 'reftype', (1,))
        self.assertEqual(list(inst.get_paths()), ['o/n/e'])


class DummyEvent(object):
    def __init__(self, object, moving=None):
        self.object = object
        self.moving = moving

    removed_oids = (100,)

class Dummy(object):
    pass

def resource(path):
    path_tuple = split(path)
    parent = None
    for element in path_tuple:
        obj = testing.DummyResource()
        obj.__parent__ = parent
        obj.__name__ = element
        parent = obj
    obj.path_tuple = path_tuple
    return obj
                
        
def split(s):
    return (_BLANK,) + tuple(filter(None, s.split(_SLASH)))

_marker = object()

class DummyObjectMap(object):
    def __init__(self, targetids=(), sourceids=(), result=None, toraise=None,
                 reftypes=()):
        self.added = []
        self.removed = []
        self.connected = []
        self.disconnected = []
        self._targetids = targetids
        self._sourceids = sourceids
        self._reftypes = reftypes
        self.result = result
        self.toraise = toraise
        self.sources_ordered = []
        self.targets_ordered = []

    def object_for(self, objectid):
        return self.result

    def path_for(self, objectid):
        return self.result

    def targetids(self, context, reftype):
        return self._targetids

    def sourceids(self, context, reftype):
        return self._sourceids

    def disconnect(self, source, target, reftype):
        if self.toraise:
            raise self.toraise
        self.disconnected.append((source, target, reftype))

    def connect(self, source, target, reftype):
        if self.toraise:
            raise self.toraise
        self.connected.append((source, target, reftype))

    def has_references(self, oid):
        return self.result

    def get_reftypes(self):
        return self._reftypes

    def order_sources(self, oid, reftype, order=_marker):
        self.sources_ordered.append((oid, reftype, order))

    def order_targets(self, oid, reftype, order=_marker):
        self.targets_ordered.append((oid, reftype, order))
        
class DummyTreeSet(set):
    def insert(self, val):
        self.add(val)

class DummyReferenceSet(object):
    def __init__(self, result=True):
        self.result = result
        self.connected = []
        self.disconnected = []
        self.sources_ordered = []
        self.targets_ordered = []

    def order_sources(self, oid, order):
        self.sources_ordered.append((oid, order))
        return order

    def order_targets(self, oid, order):
        self.targets_ordered.append((oid, order))
        return order
        
    def connect(self, src, target):
        self.connected.append((src, target))

    def disconnect(self, src, target):
        self.disconnected.append((src, target))

    def targetids(self, src):
        return self.result

    def sourceids(self, src):
        return self.result

    def is_target(self, oid):
        return self.result

    is_source = is_target

class DummyReferenceMap(dict):
    oid_args = None

    def __init__(self, sourceids=(), targetids=(), has_references=False,
                 reftypes=()):
        self._sourceids = sourceids
        self._targetids = targetids
        self._has_references = has_references
        self._reftypes = reftypes
        self.sources_ordered = []
        self.targets_ordered = []
        
    def connect(self, src, target, reftype):
        self[reftype] = (src, target)

    def disconnect(self, src, target, reftype):
        del self[reftype]

    def sourceids(self, oid, reftype):
        return self._sourceids

    def targetids(self, oid, reftype):
        return self._targetids

    def has_references(self, oid, reftype):
        self.oid_arg = oid
        self.reftype_arg = reftype
        return self._has_references

    def get_reftypes(self):
        return self._reftypes

    def order_sources(self, oid, reftype, order):
        self.sources_ordered.append((oid, reftype, order))
        return order

    def order_targets(self, oid, reftype, order):
        self.targets_ordered.append((oid, reftype, order))
        return order
    
class DummyRoot(object):
    pass

########NEW FILE########
__FILENAME__ = test_subscribers
import unittest

class Test_acl_modified(unittest.TestCase):
    def _callFUT(self, event):
        from ..subscribers import acl_modified
        return acl_modified(event)
    
    def test_it_no_objectmap(self):
        event = Dummy()
        event.object = Dummy()
        result = self._callFUT(event)
        self.assertEqual(result, None)

    def test_it_with_objectmap(self):

        acls = []

        def set_acl(obj, acl):
            acls.append((obj, acl))

        context = Dummy()
        context.__objectmap__ = Dummy()
        context.__objectmap__.set_acl = set_acl
        acl = [('Allow', 'fred', 'view')]
        event = Dummy()
        event.object = context
        event.new_acl = acl
        self._callFUT(event)

        self.assertEqual(acls, [(context, acl)])
    

class Dummy(object):
    pass

########NEW FILE########
__FILENAME__ = test_views
import unittest

from pyramid import testing

class TestReferencedView(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from  ..views import ReferencedView
        return ReferencedView(context, request)

    def test_show(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        context.__oid__ = 1
        objectmap = DummyObjectMap(('foo-to-bar',), (1,), (2,))
        context.__objectmap__ = objectmap
        inst = self._makeOne(context, request)
        result = inst.show()
        sources = result['sources']
        self.assertEqual(len(sources), 1)
        self.assertEqual(sources[0][0], 'foo-to-bar')
        self.assertEqual(list(sources[0][1]), ['/a/b'])
        targets = result['targets']
        self.assertEqual(len(targets), 1)
        self.assertEqual(targets[0][0], 'foo-to-bar')
        self.assertEqual(list(targets[0][1]), ['/a/b'])

class DummyObjectMap(object):
    def __init__(self, reftypes=(), targetids=(), sourceids=()):
        self._reftypes = reftypes
        self._targetids = targetids
        self._sourceids = sourceids
        
    def sourceids(self, oid, reftype):
        return self._sourceids

    def targetids(self, oid, reftype):
        return self._targetids

    def get_reftypes(self):
        return self._reftypes

    def path_for(self, oid):
        return ('', 'a', 'b')
    

########NEW FILE########
__FILENAME__ = views
from pyramid.view import view_defaults
from pyramid.security import NO_PERMISSION_REQUIRED

from . import (
    find_objectmap,
    ReferentialIntegrityError,
    )
from ..util import get_oid

from ..sdi import (
    mgmt_view,
    RIGHT,
    )

@view_defaults(
    referenced=True,
    name='references',
    permission='sdi.manage-references',
    )
class ReferencedView(object):

    def __init__(self, context, request):
        self.context = context
        self.request = request
    
    @mgmt_view(
        renderer='templates/referenced.pt',
        tab_title='References',
        tab_near=RIGHT, # try not to be the default tab, we're too obscure
        )
    def show(self):
        oid = get_oid(self.context)
        objectmap = find_objectmap(self.context)
        targets = []
        sources = []
        for reftype in objectmap.get_reftypes():
            targetids = objectmap.targetids(oid, reftype)
            if targetids:
                targets.append((reftype, self._paths(targetids, objectmap)))
            sourceids = objectmap.sourceids(oid, reftype)
            if sourceids:
                sources.append((reftype, self._paths(sourceids, objectmap)))
        return {'targets':targets, 'sources':sources}

    def _paths(self, ids, objectmap):
        for id in ids:
            path_tuple = objectmap.path_for(id)
            path = '/'.join(path_tuple)
            yield path

@mgmt_view(
    context=ReferentialIntegrityError,
    renderer='templates/integrityerror.pt',
    permission=NO_PERMISSION_REQUIRED,
    )
def integrityerror(context, request): # pragma: no cover
    return {}
    

########NEW FILE########
__FILENAME__ = subscribers
from pyramid.security import Allow

from ..event import (
    subscribe_added,
    subscribe_will_be_removed,
    subscribe_acl_modified,
    )
from ..interfaces import (
    IUser,
    IPrincipal,
    UserToPasswordReset,
    PrincipalToACLBearing,
    )
from ..objectmap import find_objectmap
from ..util import (
    get_oid,
    get_acl,
    postorder,
    set_acl,
    find_service,
    )
from .._compat import INT_TYPES

@subscribe_added(IUser)
def user_added(event):
    """ Give each user permission to change their own password."""
    if event.loading: # fbo dump/load
        return
    user = event.object
    user_oid = get_oid(user)
    # When a user is added to a user folder which is not yet seated in a place
    # that has an objectmap, the call to get_oid(user) above will raise an
    # AttributeError.
    set_acl(
        user,
        [(Allow, user_oid, ('sdi.view',
                            'sdi.edit-properties',
                            'sdi.change-password',
                           ))],
        registry=event.registry,
        )
    # When set_acl is called, it will end up sending an ACLModified event,
    # which will cause the acl_modified function below to be called.

@subscribe_will_be_removed(IUser)
def user_will_be_removed(event):
    """ Remove all password reset objects associated with a user when the user
    is removed """
    # if the principal service containing the user (or any other containment
    # parent of the user) is removed, this event won't be fired
    if event.moving is not None: # it's not really being removed
        return
    if event.loading: # fbo dump/load
        return
    user = event.object
    objectmap = find_objectmap(user)
    if objectmap is not None:
        resets = objectmap.targets(user, UserToPasswordReset)
        for reset in resets:
            reset.commit_suicide()

@subscribe_added(IPrincipal)
def principal_added(event):
    """ Prevent same-named users and groups from being added to the system.
    An :class:`substanced.event.IObjectAdded` event subscriber."""
    if event.loading: # fbo dump/load
        return

    # NB: don't return on event.moving; it's possible the user is being moved
    # between locations that have different user folders.

    # disallow same-named groups and users for human sanity (not because
    # same-named users and groups are disallowed by the system)
    principal = event.object
    principals = find_service(principal, 'principals')
    if principals is None:
        # fire when trying to add a principal to a folder which hasn't
        # yet been seated (raise an appropriate error, rather than letting
        # it fall through to erroring out on principals['groups'] below)
        raise ValueError(
            'No principals service in lineage when adding a principal'
            )

    principal_name = principal.__name__
    
    if IUser.providedBy(principal):
        # it's a user
        groups = principals['groups']
        if principal_name in groups:
            raise ValueError(
                'Cannot add a user with a login name the same as the '
                'group name %s' % principal_name
                )
    else:
        # it's a group
        users = principals['users']
        if principal_name in users:
            raise ValueError(
                'Cannot add a group with a name the same as the '
                'user with the login name %s' % principal_name
            )

_TO_APPEND = INT_TYPES + (tuple,)
def _referenceable_principals(acl):
    result = set()
    for ace in (acl or ()):
        principal_id = ace[1]
        if isinstance(principal_id, _TO_APPEND):
            result.add(principal_id)
    return result

@subscribe_added()
def acl_maybe_added(event):
    if event.moving is not None or event.loading:
        return False # meaningful only to tests

    obj = event.object
    objectmap = find_objectmap(obj)

    if objectmap is not None: # object might not yet be seated
        for resource in postorder(obj):
            acl = get_acl(resource, None)
            if acl is not None:
                for princid in _referenceable_principals(acl):
                    objectmap.connect(
                        princid, resource, PrincipalToACLBearing
                        )

@subscribe_acl_modified()
def acl_modified(event):
    """ When the ACL of any object is modified, using the object map, form
    references between the principal objects named in the ACL and the
    ACL-bearing object."""
    objectmap = find_objectmap(event.object)

    if objectmap is not None: # object might not yet be seated

        old_principals = _referenceable_principals(event.old_acl)
        new_principals = _referenceable_principals(event.new_acl)

        principals_removed = old_principals.difference(new_principals)
        principals_added = new_principals.difference(old_principals)

        for princid in principals_removed:
            objectmap.disconnect(
                princid,
                event.object,
                PrincipalToACLBearing
                )

        for princid in principals_added:
            objectmap.connect(
                princid,
                event.object,
                PrincipalToACLBearing
                )

########NEW FILE########
__FILENAME__ = test_principal
import unittest
from pyramid import testing
import colander
from zope.interface import implementer

class Test_locale_widget(unittest.TestCase):
    def _callFUT(self, node, kw):
        from substanced.principal import locale_widget
        return locale_widget(node, kw)

    def test_it(self):
        result = self._callFUT(None, None)
        self.assertTrue( ('en', 'en') in result.values)

class TestPrincipals(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self):
        from .. import Principals
        return Principals()

    def test___sdi_addable__True(self):
        intr = {'content_type':'Users'}
        inst = self._makeOne()
        self.assertTrue(inst.__sdi_addable__(None, intr))

    def test___sdi_addable__False(self):
        intr = {'content_type':'Wrong'}
        inst = self._makeOne()
        self.assertFalse(inst.__sdi_addable__(None, intr))

    def test_after_create(self):
        inst = self._makeOne()
        D = {}
        def add(name, val, registry=None):
            D[name] = val
        inst.add = add
        ob = testing.DummyResource()
        content = DummyContentRegistry(ob)
        registry = testing.DummyResource()
        registry.content = content
        inst.after_create(None, registry)
        self.assertEqual(D['users'], ob)
        self.assertEqual(D['groups'], ob)
        self.assertEqual(D['resets'], ob)

    def test_add_user(self):
        inst = self._makeOne()
        users = inst['users'] = testing.DummyResource()
        ob = testing.DummyResource()
        content = DummyContentRegistry(ob)
        self.config.registry.content = content
        user = inst.add_user('login', 'password')
        self.assertTrue('login' in users)
        self.assertEqual(user.__name__, 'login')

    def test_add_group(self):
        inst = self._makeOne()
        groups = inst['groups'] = testing.DummyResource()
        ob = testing.DummyResource()
        content = DummyContentRegistry(ob)
        self.config.registry.content = content
        group = inst.add_group('groupname')
        self.assertTrue('groupname' in groups)
        self.assertEqual(group.__name__, 'groupname')

    def test_add_reset(self):
        from .. import UserToPasswordReset
        ob = testing.DummyResource()
        content = DummyContentRegistry(ob)
        self.config.registry.content = content
        resets = testing.DummyResource()
        inst = self._makeOne()
        objectmap = DummyObjectMap()
        inst.__objectmap__ = objectmap
        inst.add('resets', resets)
        user = testing.DummyResource()
        reset = inst.add_reset(user)
        self.assertEqual(
            objectmap.connections,
            [(user, reset, UserToPasswordReset)])
        self.assertTrue(reset.__acl__)
        self.assertEqual(len(inst), 1)

class TestMultiplePrincipalsServices(unittest.TestCase):

    def _makeSite(self):
        from ...testing import make_site

        site = make_site()
        self.l0_principals = site['principals']

        l1 = site['level1'] = DummyFolder()
        self.l1_principals = l1['principals'] = self._makePrincipals()

        l2 = site['level1']['level2'] = DummyFolder()
        self.l2_principals = l2['principals'] = self._makePrincipals()

        return site

    def _makePrincipals(self):
        from .. import Principals
        from ...interfaces import IFolder
        from ...interfaces import IService
        from zope.interface import directlyProvides
        inst = Principals()
        directlyProvides(inst, (IFolder, IService))
        content = DummyContentRegistry()
        registry = testing.DummyResource()
        registry.content = content
        def subscribers(*args):
            pass
        registry.subscribers = subscribers
        inst.after_create(None, registry)
        return inst

    def _makeUserLocator(self, context=None, request=None):
        from .. import DefaultUserLocator
        return DefaultUserLocator(context, request)

    def test_multiple_principals_services(self):
        from pyramid.testing import DummyModel

        site = self._makeSite()
        root_phred = self.l0_principals['users']['phred'] = DummyModel()
        level1_phred = self.l1_principals['users']['phred'] = DummyModel()
        level2_phred = self.l2_principals['users']['phred'] = DummyModel()

        adapter = self._makeUserLocator(site, testing.DummyRequest())
        self.assertTrue(adapter.get_user_by_login('phred') is root_phred)

        adapter = self._makeUserLocator(site['level1'], testing.DummyRequest())
        self.assertTrue(adapter.get_user_by_login('phred') is level1_phred)

        adapter = self._makeUserLocator(site['level1']['level2'], 
                                        testing.DummyRequest())
        self.assertTrue(adapter.get_user_by_login('phred') is level2_phred)


class TestUsers(unittest.TestCase):
    def _makeOne(self):
        from .. import Users
        return Users()

    def test___sdi_addable__True(self):
        intr = {'content_type':'User'}
        inst = self._makeOne()
        self.assertTrue(inst.__sdi_addable__(None, intr))

    def test___sdi_addable__False(self):
        intr = {'content_type':'Wrong'}
        inst = self._makeOne()
        self.assertFalse(inst.__sdi_addable__(None, intr))

class TestGroups(unittest.TestCase):
    def _makeOne(self):
        from .. import Groups
        return Groups()

    def test___sdi_addable__True(self):
        intr = {'content_type':'Group'}
        inst = self._makeOne()
        self.assertTrue(inst.__sdi_addable__(None, intr))

    def test___sdi_addable__False(self):
        intr = {'content_type':'Wrong'}
        inst = self._makeOne()
        self.assertFalse(inst.__sdi_addable__(None,  intr))

class Test_groupname_validator(unittest.TestCase):
    def _makeOne(self, node, kw):
        from .. import groupname_validator
        return groupname_validator(node, kw)
    
    def _makeKw(self):
        from ...interfaces import IService
        request = testing.DummyRequest()
        context = DummyFolder()
        principals = DummyFolder()
        principals.__provides__ = IService
        groups = DummyFolder()
        users = DummyFolder()
        context['principals'] = principals
        context['principals']['groups'] = groups
        context['principals']['users'] = users
        request.context = context
        return dict(request=request, context=context)

    def test_it_not_adding_with_exception(self):
        kw = self._makeKw()
        request = kw['request']
        request.registry.content = DummyContentRegistry(True)
        kw['request'].context['abc'] = testing.DummyResource()
        def check_name(*arg, **kw):
            raise Exception('fred')
        kw['context']['principals']['groups'].check_name = check_name
        node = object()
        v = self._makeOne(node, kw)
        self.assertRaises(colander.Invalid, v, node, 'abc')

    def test_it_adding_with_exception(self):
        kw = self._makeKw()
        request = kw['request']
        request.registry.content = DummyContentRegistry(False)
        request.context['abc'] = testing.DummyResource()
        node = object()
        v = self._makeOne(node, kw)
        self.assertRaises(colander.Invalid, v, node, 'abc')

    def test_it_adding_with_exception_exists_in_users(self):
        kw = self._makeKw()
        request = kw['request']
        request.registry.content = DummyContentRegistry(False)
        principals = kw['context']['principals']
        principals['users']['abc'] = testing.DummyResource()
        node = object()
        v = self._makeOne(node, kw)
        self.assertRaises(colander.Invalid, v, node, 'abc')

class Test_members_choices(unittest.TestCase):
    def _makeOne(self, context, request):
        from .. import members_choices
        return members_choices(context, request)

    def test_it(self):
        from ...testing import make_site
        site = make_site()
        user = testing.DummyResource()
        user.__oid__ = 1
        site['principals']['users']['user'] = user
        request = testing.DummyRequest()
        result = self._makeOne(site, request)
        self.assertEqual(result, [(1, 'user')])

    def test_it_no_principals_service(self):
        site = testing.DummyResource()
        request = testing.DummyRequest()
        result = self._makeOne(site, request)
        self.assertEqual(result, ())

class TestGroup(unittest.TestCase):
    def _makeOne(self, description=''):
        from .. import Group
        return Group(description)

    def test_ctor(self):
        inst = self._makeOne('abc')
        self.assertEqual(inst.description, 'abc')

class Test_login_validator(unittest.TestCase):
    def _makeOne(self, node, kw):
        from .. import login_validator
        return login_validator(node, kw)

    def test_adding_check_name_fails(self):
        from ...testing import make_site
        site = make_site()
        user = testing.DummyResource()
        user.__oid__ = 1
        def check_name(v): raise ValueError(v)
        user.check_name = check_name
        site['principals']['users']['user'] = user
        request = testing.DummyRequest()
        request.context = user
        request.registry.content = DummyContentRegistry(False)
        kw = dict(request=request)
        inst = self._makeOne(None, kw)
        self.assertRaises(colander.Invalid, inst, None, 'name')

    def test_not_adding_check_name_fails(self):
        from ...testing import make_site
        site = make_site()
        user = testing.DummyResource()
        user.__oid__ = 1
        def check_name(*arg):
            raise ValueError('a')
        users = site['principals']['users']
        users['user'] = user
        users.check_name = check_name
        request = testing.DummyRequest()
        request.context = user
        request.registry.content = DummyContentRegistry(True)
        kw = dict(request=request)
        inst = self._makeOne(None, kw)
        self.assertRaises(colander.Invalid, inst, None, 'newname')

    def test_not_adding_newname_same_as_old(self):
        from ...testing import make_site
        site = make_site()
        user = testing.DummyResource()
        user.__oid__ = 1
        def check_name(v): raise ValueError(v)
        user.check_name = check_name
        site['principals']['users']['user'] = user
        request = testing.DummyRequest()
        request.context = user
        request.registry.content = DummyContentRegistry(True)
        kw = dict(request=request)
        inst = self._makeOne(None, kw)
        self.assertEqual(inst(None, 'user'), None)

    def test_groupname_exists(self):
        from ...testing import make_site
        site = make_site()
        user = testing.DummyResource()
        user.__oid__ = 1
        def check_name(v): raise ValueError(v)
        user.check_name = check_name
        group = testing.DummyResource()
        site['principals']['users']['user'] = user
        site['principals']['groups']['group'] = group
        request = testing.DummyRequest()
        request.context = user
        request.registry.content = DummyContentRegistry(True)
        kw = dict(request=request)
        inst = self._makeOne(None, kw)
        self.assertRaises(colander.Invalid, inst, None, 'group')

class Test_groups_choices(unittest.TestCase):
    def _makeOne(self, context, request):
        from .. import groups_choices
        return groups_choices(context, request)

    def test_it(self):
        from ...testing import make_site
        site = make_site()
        group = testing.DummyResource()
        group.__oid__ = 1
        site['principals']['groups']['group'] = group
        request = testing.DummyRequest()
        result = self._makeOne(site, request)
        self.assertEqual(result, [(1, 'group')])

    def test_it_no_principals_service(self):
        site = testing.DummyResource()
        request = testing.DummyRequest()
        result = self._makeOne(site, request)
        self.assertEqual(result, ())

class TestUser(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()
        self.config.include('pyramid_chameleon')

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self, password, email='', tzname=None):
        from .. import User
        return User(password, email, tzname)

    def test___dump__(self):
        inst = self._makeOne('abc')
        result = inst.__dump__()
        self.assertTrue(inst.pwd_manager.check(result['password'], 'abc'))

    def test_check_password(self):
        inst = self._makeOne('abc')
        self.assertTrue(inst.check_password('abc'))
        self.assertFalse(inst.check_password('abcdef'))

    def test_check_password_gt_4096_bytes(self):
        inst = self._makeOne('abc')
        self.assertRaises(ValueError, inst.check_password, 'a'*4097)
        
    def test_set_password(self):
        inst = self._makeOne('abc')
        inst.set_password('abcdef')
        self.assertTrue(inst.pwd_manager.check(inst.password, 'abcdef'))

    def test_email_password_reset(self):
        from ...testing import make_site
        from pyramid_mailer import get_mailer
        site = make_site()
        principals = site['principals']
        principals['resets'] = testing.DummyResource()
        def add_reset(user):
            self.assertEqual(user, inst)
        principals.add_reset = add_reset
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.virtual_root = site
        inst = self._makeOne('password')
        inst.email = 'foo@example.com'
        principals['users']['user'] = inst
        with testing.testConfig() as config:
            config.include('pyramid_mailer.testing')
            config.include('pyramid_chameleon')
            inst.email_password_reset(request)
            self.assertTrue(get_mailer(request).outbox)

    def test_email_password_user_has_no_email(self):
        from ...testing import make_site
        site = make_site()
        principals = site['principals']
        principals['resets'] = testing.DummyResource()
        def add_reset(user):
            self.assertEqual(user, inst)
        principals.add_reset = add_reset
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.virtual_root = site
        self.config.include('pyramid_mailer.testing')
        inst = self._makeOne('password')
        inst.email = None
        principals['users']['user'] = inst
        self.assertRaises(ValueError, inst.email_password_reset, request)

    def test_timezone_default(self):
        import pytz
        inst = self._makeOne('abc')
        self.assertEqual(inst.timezone, pytz.UTC)
        
    def test_timezone_nondefault(self):
        import pytz
        inst = self._makeOne('abc', tzname='US/Eastern')
        self.assertEqual(inst.timezone, pytz.timezone('US/Eastern'))

class TestPasswordResets(unittest.TestCase):
    def _makeOne(self):
        from .. import PasswordResets
        return PasswordResets()

    def test___sdi_addable__True(self):
        intr = {'content_type':'Password Reset'}
        inst = self._makeOne()
        self.assertTrue(inst.__sdi_addable__(None, intr))

    def test___sdi_addable__False(self):
        intr = {'content_type':'Wrong'}
        inst = self._makeOne()
        self.assertFalse(inst.__sdi_addable__(None, intr))

class TestPasswordReset(unittest.TestCase):
    def _makeOne(self):
        from .. import PasswordReset
        return PasswordReset()

    def test_reset_password(self):
        from ...interfaces import IFolder
        parent = testing.DummyResource(__provides__=IFolder)
        user = testing.DummyResource()
        def set_password(password):
            user.password = password
        user.set_password = set_password
        objectmap = DummyObjectMap((user,))
        inst = self._makeOne()
        parent.__objectmap__ = objectmap
        parent['reset'] = inst
        inst.reset_password('password')
        self.assertEqual(user.password, 'password')
        self.assertFalse('reset' in parent)

class TestDefaultUserLocator(unittest.TestCase):
    def _getTargetClass(self):
        from .. import DefaultUserLocator
        return DefaultUserLocator

    def _makeOne(self, context=None, request=None):
        return self._getTargetClass()(context, request)

    def test_class_conforms_to_IUserLocator(self):
        from zope.interface.verify import verifyClass
        from ...interfaces import IUserLocator
        verifyClass(IUserLocator, self._getTargetClass())

    def test_instance_conforms_to_IUserLocator(self):
        from zope.interface.verify import verifyObject
        from ...interfaces import IUserLocator
        context = object()
        request = {}
        verifyObject(IUserLocator, self._makeOne())

    def test_get_user_by_login(self):
        from pyramid.testing import DummyModel
        from pyramid.testing import DummyRequest
        from zope.interface import directlyProvides
        from ...interfaces import IFolder
        from ...interfaces import IService
        context = DummyModel()
        directlyProvides(context, IFolder)
        principals = context['principals'] = DummyModel()
        directlyProvides(principals, (IFolder, IService))
        users = principals['users'] = DummyModel()
        phred = users['phred'] = DummyModel()
        adapter = self._makeOne(context, DummyRequest())
        self.assertTrue(adapter.get_user_by_login('phred') is phred)
        self.assertTrue(adapter.get_user_by_login('bharney') is None)

    def test_get_user_by_userid(self):
        from pyramid.testing import DummyModel
        from pyramid.testing import DummyRequest
        from zope.interface import directlyProvides
        from ...interfaces import IFolder
        from ...interfaces import IService
        context = DummyModel()
        directlyProvides(context, IFolder)
        principals = context['principals'] = DummyModel()
        directlyProvides(principals, (IFolder, IService))
        users = principals['users'] = DummyModel()
        phred = users['phred'] = DummyModel()
        adapter = self._makeOne(context, DummyRequest())
        omap = context.__objectmap__ = DummyObjectMap(oid123=phred)
        self.assertTrue(adapter.get_user_by_userid('oid123') is phred)
        self.assertTrue(adapter.get_user_by_userid('nonesuch') is None)

    def test_get_user_by_email(self):
        from pyramid.testing import DummyModel
        from pyramid.testing import DummyRequest
        from zope.interface import directlyProvides
        from ...interfaces import IFolder
        from ...interfaces import IService
        context = DummyModel()
        directlyProvides(context, IFolder)
        principals = context['principals'] = DummyModel()
        directlyProvides(principals, (IFolder, IService))
        users = principals['users'] = DummyModel()
        bharney = users['bharney'] = DummyModel(email='bharney@example.com')
        phred = users['phred'] = DummyModel(email='phred@example.com')
        adapter = self._makeOne(context, DummyRequest())
        self.assertTrue(
            adapter.get_user_by_email('phred@example.com') is phred)
        self.assertTrue(
            adapter.get_user_by_email('nonesuch@example.com') is None)

    def test_get_groupids(self):
        from pyramid.testing import DummyModel
        from pyramid.testing import DummyRequest
        from zope.interface import directlyProvides
        from ...interfaces import IFolder
        from ...interfaces import IService
        context = DummyModel()
        directlyProvides(context, IFolder)
        principals = context['principals'] = DummyModel(__provides__=IService)
        directlyProvides(principals, IFolder)
        users = principals['users'] = DummyModel()
        phred = users['phred'] = DummyModel()
        phred.groupids = ['phlyntstones']
        adapter = self._makeOne(context, DummyRequest())
        omap = context.__objectmap__ = DummyObjectMap(oid123=phred)
        self.assertEqual(adapter.get_groupids('oid123'), ['phlyntstones'])

class Test_groupfinder(unittest.TestCase):
    def _callFUT(self, userid, request):
        from .. import groupfinder
        return groupfinder(userid, request)

    def test_with_no_objectmap(self):
        from ...interfaces import IFolder
        request = testing.DummyRequest()
        context = testing.DummyResource(__provides__=IFolder)
        request.context = context
        result = self._callFUT(1, request)
        self.assertEqual(result, None)
    
    def test_with_objectmap_no_user(self):
        from ...interfaces import IFolder
        request = testing.DummyRequest()
        context = testing.DummyResource(__provides__=IFolder)
        omap = testing.DummyResource()
        omap.object_for = lambda *arg: None
        context.__objectmap__ = omap
        request.context = context
        result = self._callFUT(1, request)
        self.assertEqual(result, None)

    def test_w_adapter(self):
        from pyramid.testing import testConfig
        from zope.interface import Interface
        from ...interfaces import IFolder
        from ...interfaces import IUserLocator
        request = testing.DummyRequest()
        context = testing.DummyResource(__provides__=IFolder)
        request.context = context
        locator = DummyLocator((1, 2))
        def _locator(context, request):
            return locator
        with testConfig() as config:
            config.registry.registerAdapter(_locator, (Interface, Interface),
                                            IUserLocator)
            result = self._callFUT(1, request)
        self.assertEqual(result, (1, 2))

    def test_garden_path(self):
        from ...interfaces import IFolder
        request = testing.DummyRequest()
        context = testing.DummyResource(__provides__=IFolder)
        omap = testing.DummyResource()
        user = testing.DummyResource()
        user.groupids = (1, 2)
        omap.object_for = lambda *arg: user
        context.__objectmap__ = omap
        request.context = context
        result = self._callFUT(1, request)
        self.assertEqual(result, (1, 2))

class Test_set_user_locator(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, config, cls):
        from .. import set_user_locator
        return set_user_locator(config, cls)

    def test_it(self):
        from zope.interface import Interface
        from substanced.interfaces import IUserLocator
        config = DummyConfigurator(registry=self.config.registry)
        class UserLocator(object):
            def __init__(self, context, request):
                self.group_ids = ['group1', 'group2']
            def get_groupids(self, userid):
                return self.group_ids
        self._callFUT(config, UserLocator)
        self.assertEqual(len(config.actions), 1)
        action = config.actions[0]
        self.assertEqual(
            action['discriminator'],
            ('sd-user-locator',)
            )
        self.assertEqual(
            action['introspectables'], (config.intr,)
            )
        self.assertEqual(config.intr['cls'], UserLocator)
        callable = action['callable']
        callable()
        adapter = self.config.registry.getMultiAdapter((Interface, Interface),
                IUserLocator)
        self.assertEqual(
                adapter.get_groupids('user'), ['group1', 'group2']
            )

        
from ...interfaces import IFolder

@implementer(IFolder)
class DummyFolder(testing.DummyResource):
    def check_name(self, value):
        if value in self:
            raise KeyError(value)

class DummyObjectMap(object):
    def __init__(self, result=(), **kw):
        self.result = result
        self.connections = []
        self.map = kw

    def sources(self, object, reftype):
        return self.result

    def object_for(self, oid):
        return self.map.get(oid)

    def connect(self, source, target, reftype):
        self.connections.append((source, target, reftype))

    def add(self, node, path_tuple, duplicating=False, moving=False):
        pass

class DummyContentRegistry(object):
    def __init__(self, result=None):
        self.result = result

    def istype(self, context, type):
        return self.result

    def create(self, name, *arg, **kw):
        if self.result is None:
            return testing.DummyResource()
        return self.result
    
class DummySDIAPI(object):
    def mgmt_path(self, *arg, **kw):
        return '/mgmt_path'


class DummyLocator(object):
    def __init__(self, group_ids=None):
        self._group_ids = group_ids

    def get_groupids(self, userid):
        self._userid = userid
        return self._group_ids

class DummyIntrospectable(dict):
    pass

class DummyConfigurator(object):
    _ainfo = None
    def __init__(self, registry):
        self.actions = []
        self.intr = DummyIntrospectable()
        self.registry = registry
        self.indexes = []

    def action(self, discriminator, callable, order=None, introspectables=()):
        self.actions.append(
            {
            'discriminator':discriminator,
            'callable':callable,
            'order':order,
            'introspectables':introspectables,
            })

    def introspectable(self, category, discriminator, title, type_name):
        return self.intr


########NEW FILE########
__FILENAME__ = test_subscribers
import unittest
from pyramid import testing

class Test_principal_added(unittest.TestCase):
    def _callFUT(self, event):
        from ..subscribers import principal_added
        return principal_added(event)

    def test_event_wo_loading_attr(self):
        event = testing.DummyResource()
        event.object = testing.DummyResource()
        self.assertRaises(AttributeError, self._callFUT, event)

    def test_event_w_loading_True(self):
        event = testing.DummyResource(loading=True)
        result = self._callFUT(event)
        self.assertEqual(result, None)

    def test_wo_principals_service(self):
        from zope.interface import directlyProvides
        from ...interfaces import IFolder
        event = testing.DummyResource(loading=False)
        root = testing.DummyResource()
        directlyProvides(root, IFolder)
        event.object = root['testing'] = testing.DummyResource()
        self.assertRaises(ValueError, self._callFUT, event)
        
    def test_user_not_in_groups(self):
        from ...testing import make_site
        from ...interfaces import IUser
        site = make_site()
        user = testing.DummyResource(__provides__=IUser)
        site['user'] = user
        event = testing.DummyResource(object=user, loading=False)
        self._callFUT(event) # doesnt blow up

    def test_user_in_groups(self):
        from ...testing import make_site
        from ...interfaces import IUser
        site = make_site()
        groups = site['principals']['groups']
        groups['user'] = testing.DummyResource()
        user = testing.DummyResource(__provides__=IUser)
        site['user'] = user
        event = testing.DummyResource(object=user, loading=False)
        self.assertRaises(ValueError, self._callFUT, event)

    def test_group_not_in_users(self):
        from ...testing import make_site
        site = make_site()
        group = testing.DummyResource()
        site['groups'] = group
        event = testing.DummyResource(object=group, loading=False)
        self._callFUT(event) # doesnt blow up

    def test_group_in_users(self):
        from ...testing import make_site
        site = make_site()
        users = site['principals']['users']
        users['group'] = testing.DummyResource()
        group = testing.DummyResource()
        site['group'] = group
        event = testing.DummyResource(object=group, loading=False)
        self.assertRaises(ValueError, self._callFUT, event)

class Test_user_will_be_removed(unittest.TestCase):
    def _callFUT(self, event):
        from ..subscribers import user_will_be_removed
        return user_will_be_removed(event)

    def test_loading(self):
        event = testing.DummyResource(loading=True, moving=None)
        result = self._callFUT(event)
        self.assertEqual(result, None)

    def test_moving(self):
        event = testing.DummyResource(loading=False, moving=True)
        result = self._callFUT(event)
        self.assertEqual(result, None)
        
    def test_it(self):
        from ...interfaces import IFolder
        parent = testing.DummyResource(__provides__=IFolder)
        user = testing.DummyResource()
        reset = testing.DummyResource()
        def commit_suicide():
            reset.committed = True
        reset.commit_suicide = commit_suicide
        objectmap = DummyObjectMap((reset,))
        parent.__objectmap__ = objectmap
        parent['user'] = user
        event = testing.DummyResource(object=user, loading=False, moving=None)
        self._callFUT(event)
        self.assertTrue(reset.committed)

    def test_it_moving(self):
        event = testing.DummyResource(object=None, loading=False)
        event.moving = True
        self.assertEqual(self._callFUT(event), None)

class Test_user_added(unittest.TestCase):
    def _callFUT(self, event):
        from ..subscribers import user_added
        return user_added(event)

    def test_loading(self):
        event = testing.DummyResource(loading=True)
        result = self._callFUT(event)
        self.assertEqual(result, None)

    def test_it_user_has_no_oid(self):
        user = testing.DummyResource()
        event = testing.DummyResource(object=user, loading=False)
        event.registry = DummyRegistry()
        self.assertRaises(AttributeError, self._callFUT, event)
        
    def test_it(self):
        from pyramid.security import Allow
        user = testing.DummyResource()
        user.__oid__ = 1
        event = testing.DummyResource(object=user, loading=False)
        event.registry = DummyRegistry()
        self._callFUT(event)
        self.assertEqual(
            user.__acl__,
            [(Allow, 1, ('sdi.view',
                         'sdi.edit-properties',
                         'sdi.change-password',
                        ))])

class Test_acl_maybe_added(unittest.TestCase):
    def _callFUT(self, event):
        from ..subscribers import acl_maybe_added
        return acl_maybe_added(event)

    def test_moving(self):
        event = DummyEvent(moving=True, loading=False)
        self.assertEqual(self._callFUT(event), False)

    def test_loading(self):
        event = DummyEvent(moving=None, loading=True)
        self.assertEqual(self._callFUT(event), False)

    def test_objectmap_is_None(self):
        event = DummyEvent(moving=None, object=None, loading=False)
        self.assertEqual(self._callFUT(event), None)

    def test_no_acls(self):
        from substanced.interfaces import IFolder
        resource1 = testing.DummyResource(__provides__=IFolder)
        resource2 = testing.DummyResource()
        resource1['resource2'] = resource2
        objectmap = DummyObjectMap()
        resource1.__objectmap__ = objectmap
        event = DummyEvent(moving=None, object=resource1, loading=False)
        self._callFUT(event)
        self.assertEqual(objectmap.connections, [])

    def test_with_acls(self):
        from ...interfaces import PrincipalToACLBearing
        from substanced.interfaces import IFolder
        resource1 = testing.DummyResource(__provides__=IFolder)
        resource2 = testing.DummyResource()
        resource1['resource2'] = resource2
        resource1.__acl__ = [(None, 'fred', None), (None, 1, None)]
        resource2.__acl__ = [(None, 'bob', None), (None, 2, None)]
        objectmap = DummyObjectMap()
        resource1.__objectmap__ = objectmap
        event = DummyEvent(moving=None, object=resource1, loading=False)
        self._callFUT(event)
        self.assertEqual(
            objectmap.connections,
            [(2, resource2, PrincipalToACLBearing),
             (1, resource1, PrincipalToACLBearing)]
            )

class Test_acl_modified(unittest.TestCase):
    def _callFUT(self, event):
        from ..subscribers import acl_modified
        return acl_modified(event)

    def test_objectmap_is_None(self):
        event = DummyEvent(object=None)
        self.assertEqual(self._callFUT(event), None)

    def test_gardenpath(self):
        from ...interfaces import PrincipalToACLBearing
        resource = testing.DummyResource()
        objectmap = DummyObjectMap()
        resource.__objectmap__ = objectmap
        event = DummyEvent(
            object=resource,
            new_acl=[(None, 'fred', None), (None, 1, None)],
            old_acl=[(None, 'bob', None), (None, 2, None)],
            )
        self._callFUT(event) 
        self.assertEqual(
            objectmap.connections,
            [(1, resource, PrincipalToACLBearing)]
            )
        self.assertEqual(
            objectmap.disconnections,
            [(2, resource, PrincipalToACLBearing)]
            )
           

class DummyObjectMap(object):
    def __init__(self, result=()):
        self.result = result
        self.connections = []
        self.disconnections = []

    def targets(self, object, reftype):
        return self.result

    def connect(self, source, target, reftype):
        self.connections.append((source, target, reftype))

    def disconnect(self, source, target, reftype):
        self.disconnections.append((source, target, reftype))
    
class DummyEvent(object):
    def __init__(self, **kw):
        self.__dict__.update(kw)
        
class DummyRegistry(object):
    def subscribers(self, *arg):
        return
    

########NEW FILE########
__FILENAME__ = test_views
import unittest
import colander
from pyramid import testing

class Test_add_principals_service(unittest.TestCase):
    def _callFUT(self, context, request):
        from ..views import add_principals_service
        return add_principals_service(context, request)

    def test_it(self):
        context = testing.DummyResource()
        context.add_service = context.__setitem__
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        service = testing.DummyResource()
        request.registry.content = DummyContentRegistry(service)
        result = self._callFUT(context, request)
        self.assertEqual(context['principals'], service)
        self.assertEqual(result.location, '/mgmt_path/@@services')

class TestAddUserView(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..views import AddUserView
        return AddUserView(context, request)

    def _makeRequest(self, resource):
        request = testing.DummyRequest()
        request.registry = testing.DummyResource()
        request.registry.content = DummyContentRegistry(resource)
        request.sdiapi = DummySDIAPI()
        return request

    def test_add_success(self):
        resource = DummyPrincipal()
        request = self._makeRequest(resource)
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        resp = inst.add_success({'name':'name', 'groupids':(1,)})
        self.assertEqual(context['name'], resource)
        self.assertEqual(resp.location, '/mgmt_path/@@contents')
        self.assertEqual(resource.groupids, (1,))

class TestAddGroupView(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..views import AddGroupView
        return AddGroupView(context, request)

    def _makeRequest(self, resource):
        request = testing.DummyRequest()
        request.registry = testing.DummyResource()
        request.registry.content = DummyContentRegistry(resource)
        request.sdiapi = DummySDIAPI()
        return request

    def test_add_success(self):
        resource = DummyPrincipal()
        request = self._makeRequest(resource)
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        resp = inst.add_success({'name':'name', 'memberids':(1,)})
        self.assertEqual(context['name'], resource)
        self.assertEqual(resp.location, '/mgmt_path/@@contents')
        self.assertEqual(resource.memberids, (1,))

class Test_password_validator(unittest.TestCase):
    def _makeOne(self, node, kw):
        from ..views import password_validator
        return password_validator(node, kw)

    def test_it_success(self):
        request = testing.DummyRequest()
        context = testing.DummyResource()
        def check_password(pwd):
            return True
        context.check_password = check_password
        kw = dict(request=request, context=context)
        inst = self._makeOne(None, kw)
        self.assertEqual(inst(None, 'pwd'), None)

    def test_it_failure(self):
        request = testing.DummyRequest()
        context = testing.DummyResource()
        def check_password(pwd):
            return False
        context.check_password = check_password
        kw = dict(request=request, context=context)
        inst = self._makeOne(None, kw)
        self.assertRaises(colander.Invalid, inst, None, 'pwd')

class TestChangePasswordView(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..views import ChangePasswordView
        return ChangePasswordView(context, request)

    def test_change_success(self):
        context = DummyPrincipal()
        request = testing.DummyRequest()
        user = DummyPrincipal()
        request.user = user
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        resp = inst.change_success(
            {'password':'password', 'current_user_password':'abcdef'})
        self.assertEqual(context.password, 'password')
        self.assertEqual(resp.location, '/mgmt_path/@@change_password')
        self.assertTrue(request.sdiapi.flashed)
        self.assertTrue(user.checked, 'abcdef')

    def test_change_check_fail(self):
        context = DummyPrincipal()
        request = testing.DummyRequest()
        user = DummyPrincipal()
        user.check_password = lambda *arg: False
        request.user = user
        request.sdiapi = DummySDIAPI()
        inst = self._makeOne(context, request)
        resp = inst.change_success(
            {'password':'password', 'current_user_password':'abcdef'})
        self.assertEqual(resp.location, '/mgmt_path/@@change_password')
        self.assertEqual(
            request.sdiapi.flashed,
            'Incorrect current user password'
            )

class TestRequestResetView(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..views import ResetRequestView
        return ResetRequestView(context, request)

    def _makeRequest(self):
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        return request

    def _makeSite(self):
        from substanced.testing import make_site
        return make_site()

    def test_send_success(self):
        site = self._makeSite()
        user = DummyPrincipal()
        site['principals']['users']['user'] = user
        request = self._makeRequest()
        inst = self._makeOne(site, request)
        resp = inst.send_success({'login':'user'})
        self.assertEqual(resp.location, '/mgmt_path')
        self.assertTrue(user.emailed_password_reset)

class TestResetView(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..views import ResetView
        return ResetView(context, request)

    def _makeRequest(self):
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        return request

    def test_reset_success(self):
        context = testing.DummyResource()
        def reset_password(password):
            self.assertEqual(password, 'thepassword')
        context.reset_password = reset_password
        request = self._makeRequest()
        inst = self._makeOne(context, request)
        resp = inst.reset_success({'new_password':'thepassword'})
        self.assertEqual(resp.location, '/mgmt_path')
    

class Test_login_validator(unittest.TestCase):
    def _makeOne(self, node, kw):
        from ..views import login_validator
        return login_validator(node, kw)

    def _makeSite(self):
        from substanced.interfaces import IFolder
        from substanced.interfaces import IService
        site = testing.DummyResource(__provides__=IFolder)
        principals = testing.DummyResource(__provides__=IService)
        users = testing.DummyResource()
        site['principals'] = principals
        principals['users'] = users
        return site

    def test_no_such_user(self):
        request = testing.DummyRequest()
        site = self._makeSite()
        inst = self._makeOne(None, dict(request=request, context=site))
        self.assertRaises(colander.Invalid, inst, None, 'fred')

    def test_user_exists(self):
        request = testing.DummyRequest()
        site = self._makeSite()
        fred = testing.DummyResource()
        site['principals']['users']['fred'] = fred
        inst = self._makeOne(None, dict(request=request, context=site))
        self.assertEqual(inst(None, 'fred'), None)

class DummyPrincipal(object):
    def set_password(self, password):
        self.password = password

    def email_password_reset(self, request):
        self.emailed_password_reset = True

    def check_password(self, password):
        self.checked = password
        return True

class DummyContentRegistry(object):
    def __init__(self, resource):
        self.resource = resource

    def create(self, iface, *arg, **kw):
        return self.resource
        
class DummySDIAPI(object):
    def mgmt_path(self, *arg, **kw):
        return '/'.join(['/mgmt_path'] + list(arg[1:]))
    def flash(self, msg, queue='info'):
        self.flashed = msg

########NEW FILE########
__FILENAME__ = views
import colander
import deform.widget

from pyramid.httpexceptions import HTTPFound
from pyramid.security import NO_PERMISSION_REQUIRED

from ..form import FormView
from ..schema import Schema

from ..interfaces import (
    IUsers,
    IUser,
    IGroups,
    IPasswordReset,
    )

from ..sdi import mgmt_view

from . import (
    UserSchema,
    UserGroupsSchema,
    GroupSchema,
    )

from ..util import find_service, _

class AddUserSchema(UserGroupsSchema, UserSchema):
    password = colander.SchemaNode(
        colander.String(),
        widget = deform.widget.CheckedPasswordWidget(),
        validator=colander.Length(min=3, max=100),
        )

@mgmt_view(
    name='add_principals_service',
    tab_condition=False,
    permission='sdi.add-services',
    )
def add_principals_service(context, request):
    service = request.registry.content.create('Principals')
    context.add_service('principals', service)
    return HTTPFound(location=request.sdiapi.mgmt_path(context, '@@services'))

@mgmt_view(
    context=IUsers,
    name='add_user',
    permission='sdi.add-user', 
    renderer='substanced.sdi:templates/form.pt',
    tab_condition=False
    )
class AddUserView(FormView):
    title = 'Add User'
    schema = AddUserSchema()
    buttons = ('add',)

    def add_success(self, appstruct):
        registry = self.request.registry
        name = appstruct.pop('name')
        groupids = appstruct.pop('groupids')
        user = registry.content.create('User', **appstruct)
        self.context[name] = user
        user.groupids = groupids
        return HTTPFound(
            self.request.sdiapi.mgmt_path(self.context, '@@contents')
            )

@mgmt_view(
    context=IGroups,
    name='add_group',
    permission='sdi.add-group', 
    renderer='substanced.sdi:templates/form.pt',
    tab_condition=False
    )
class AddGroupView(FormView):
    title = 'Add Group'
    schema = GroupSchema()
    buttons = ('add',)

    def add_success(self, appstruct):
        registry = self.request.registry
        name = appstruct.pop('name')
        memberids = appstruct.pop('memberids')
        group = registry.content.create('Group', **appstruct)
        self.context[name] = group
        group.memberids = memberids
        return HTTPFound(
            self.request.sdiapi.mgmt_path(self.context, '@@contents')
            )

@colander.deferred
def password_validator(node, kw):
    """ Returns a ``colander.Function`` validator that uses the context (user)
    to validate the password."""
    context = kw['context']
    return colander.Function(
        lambda pwd: context.check_password(pwd),
        'Invalid password'
        )

class UserPasswordSchema(Schema):
    """ The schema for validating password change requests."""
    current_user_password = colander.SchemaNode(
        colander.String(),
        title='Your Current Password',
        widget = deform.widget.PasswordWidget(redisplay=False),
        )
    password = colander.SchemaNode(
        colander.String(),
        title='New Password',
        validator = colander.Length(min=3, max=100),
        widget = deform.widget.CheckedPasswordWidget(redisplay=False),
        )

@mgmt_view(
    context=IUser,
    name='change_password',
    tab_title=_('Change Password'),
    permission='sdi.change-password',
    renderer='substanced.sdi:templates/form.pt',
    )
class ChangePasswordView(FormView):
    title = 'Change Password'
    schema = UserPasswordSchema()
    buttons = ('change',)

    def change_success(self, appstruct):
        user = self.context
        current_user_password = appstruct['current_user_password']
        if not self.request.user.check_password(current_user_password):
            self.request.sdiapi.flash('Incorrect current user password',
                                      'danger')
        else:
            password = appstruct['password']
            user.set_password(password)
            self.request.sdiapi.flash('Password changed', 'success')
        return HTTPFound(
            self.request.sdiapi.mgmt_path(user, '@@change_password')
            )

@colander.deferred
def login_validator(node, kw):
    context = kw['context']
    def _login_validator(node, value):
        principals = find_service(context, 'principals')
        users = principals['users']
        if not value in users:
            raise colander.Invalid(node, 'No such user %s' % value)
    return _login_validator

class ResetRequestSchema(Schema):
    """ The schema for validating password reset requests."""
    login = colander.SchemaNode(
        colander.String(),
        validator = login_validator,
        )

@mgmt_view(
    name='resetpassword',
    tab_condition=False,
    renderer='substanced.sdi:templates/form.pt',
    permission=NO_PERMISSION_REQUIRED,
    )
class ResetRequestView(FormView):
    title = 'Request Password Reset'
    schema = ResetRequestSchema()
    buttons = ('send',)

    def send_success(self, appstruct):
        request = self.request
        context = self.context
        login = appstruct['login']
        principals = find_service(context, 'principals')
        users = principals['users']
        user = users[login]
        user.email_password_reset(request)
        request.sdiapi.flash('Emailed password reset instructions', 'success')
        home = request.sdiapi.mgmt_path(request.virtual_root)
        return HTTPFound(location=home)
        
class ResetSchema(Schema):
    """ The schema for validating password reset requests."""
    new_password = colander.SchemaNode(
        colander.String(),
        validator = colander.Length(min=3, max=100),
        widget = deform.widget.CheckedPasswordWidget(),
        )

@mgmt_view(
    context=IPasswordReset,
    name='',
    tab_condition=False,
    renderer='substanced.sdi:templates/form.pt',
    permission=NO_PERMISSION_REQUIRED,
    )
class ResetView(FormView):
    title = 'Reset Password'
    schema = ResetSchema()
    buttons = ('reset',)
    
    def reset_success(self, appstruct):
        request = self.request
        context = self.context
        context.reset_password(appstruct['new_password'])
        request.sdiapi.flash('Password reset, you may now log in', 'success')
        home = request.sdiapi.mgmt_path(request.virtual_root)
        return HTTPFound(location=home)

########NEW FILE########
__FILENAME__ = test_init
import unittest
from pyramid import testing

import colander

class TestPropertySheet(unittest.TestCase):
    def _makeOne(self, context, request):
        from .. import PropertySheet
        return PropertySheet(context, request)

    def test_get(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        inst.schema = [DummySchemaNode('title'),
                       DummySchemaNode('description'),
                       DummySchemaNode('another')]
        context.title = 'title'
        context.description = 'description'
        vals = inst.get()
        self.assertEqual(vals['title'], 'title')
        self.assertEqual(vals['description'], 'description')
        self.assertEqual(vals['another'], colander.null)

    def test_set(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        context.title = 'title'
        context.description = 'description'
        inst.schema = [DummySchemaNode('title'),
                       DummySchemaNode('description')]
        inst.set(dict(title='t', description='d'))
        self.assertEqual(context.title, 't')
        self.assertEqual(context.description, 'd')

    def test_set_schema_missing_value(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        context.title = 'title'
        context.description = 'description'
        inst.schema = [DummySchemaNode('title')]
        inst.set(dict(title='t', description='d'))
        self.assertEqual(context.title, 't')
        self.assertEqual(context.description, 'description')

    def test_set_nochange(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        inst.schema = [DummySchemaNode('title'),
                       DummySchemaNode('description')]
        context.title = 't'
        context.description = 'd'
        inst.set(dict(title='t', description='d'))
        self.assertEqual(context.title, 't')
        self.assertEqual(context.description, 'd')

    def test_set_with_omit_iter(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        context.title = 'title'
        context.description = 'description'
        inst.schema = [DummySchemaNode('title'),
                       DummySchemaNode('description')]
        inst.set(dict(title='t', description='d'), omit=('title',))
        self.assertEqual(context.title, 'title')
        self.assertEqual(context.description, 'd')

    def test_set_with_omit_noniter(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        context.title = 'title'
        context.description = 'description'
        inst.schema = [DummySchemaNode('title'),
                       DummySchemaNode('description')]
        inst.set(dict(title='t', description='d'), omit='title')
        self.assertEqual(context.title, 'title')
        self.assertEqual(context.description, 'd')

    def test_after_set_changed_True(self):
        from substanced.event import ObjectModified
        request = testing.DummyRequest()
        request.registry = DummyRegistry()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        inst.after_set(True)
        subscribed = request.registry.subscribed[0]
        self.assertEqual(subscribed[1], None)
        self.assertEqual(subscribed[0][0].__class__, ObjectModified)
        self.assertEqual(subscribed[0][1], context)

    def test_after_set_changed_False(self):
        request = testing.DummyRequest()
        request.registry = DummyRegistry()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        inst.after_set(False)
        subscribed = request.registry.subscribed
        self.assertEqual(len(subscribed), 0)
        
class Test_is_propertied(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, resource, registry=None):
        from .. import is_propertied
        return is_propertied(resource, registry)

    def test_no_registry_passed(self):
        resource = Dummy()
        self.config.registry.content = DummyContent(True)
        self.assertTrue(self._callFUT(resource))

    def test_true(self):
        resource = Dummy()
        registry = Dummy()
        registry.content = DummyContent(())
        self.assertTrue(self._callFUT(resource, registry))

    def test_false(self):
        resource = Dummy()
        registry = Dummy()
        registry.content = DummyContent(None)
        self.assertFalse(self._callFUT(resource, registry))

class Test_PropertiedPredicate(unittest.TestCase):
    def _makeOne(self, val, config):
        from .. import _PropertiedPredicate
        return _PropertiedPredicate(val, config)

    def test_text(self):
        config = Dummy()
        config.registry = Dummy()
        inst = self._makeOne(True, config)
        self.assertEqual(inst.text(), 'propertied = True')

    def test_phash(self):
        config = Dummy()
        config.registry = Dummy()
        inst = self._makeOne(True, config)
        self.assertEqual(inst.phash(), 'propertied = True')

    def test__call__(self):
        config = Dummy()
        config.registry = Dummy()
        inst = self._makeOne(True, config)
        def is_propertied(context, registry):
            self.assertEqual(context, None)
            self.assertEqual(registry, config.registry)
            return True
        inst.is_propertied = is_propertied
        self.assertEqual(inst(None, None), True)

class Dummy(object):
    pass

class DummyRegistry(object):
    def __init__(self):
        self.subscribed = []
    
    def subscribers(self, *args):
        self.subscribed.append(args)
        
class DummyContent(object):
    def __init__(self, result=None):
        self.result = result
        
    def metadata(self, *arg, **kw):
        return self.result

class DummySchemaNode(object):
    def __init__(self, name):
        self.name = name

########NEW FILE########
__FILENAME__ = test_views
import unittest
from pyramid import testing

class TestPropertySheetsView(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self, request):
        from ..views import PropertySheetsView
        return PropertySheetsView(request)

    def test_ctor_no_viewable_sheet_factories(self):
        from pyramid.httpexceptions import HTTPNotFound
        request = testing.DummyRequest()
        request.registry = testing.DummyResource()
        request.registry.content = DummyContent([])
        resource = testing.DummyResource()
        request.context = resource
        self.assertRaises(HTTPNotFound, self._makeOne, request)

    def test_ctor_no_subpath(self):
        request = testing.DummyRequest()
        request.registry = testing.DummyResource()
        request.registry.content = DummyContent([('name', DummyPropertySheet)])
        resource = testing.DummyResource()
        request.context = resource
        inst = self._makeOne(request)
        self.assertEqual(inst.active_sheet_name, 'name')
        self.assertTrue(inst.schema, 'schema')
        self.assertEqual(inst.sheet_names, ['name'])

    def test_ctor_with_subpath(self):
        request = testing.DummyRequest()
        request.subpath = ('othername',)
        request.registry = testing.DummyResource()
        request.registry.content = DummyContent(
            [('othername', DummyPropertySheet)])
        resource = testing.DummyResource()
        request.context = resource
        inst = self._makeOne(request)
        self.assertEqual(inst.active_sheet_name, 'othername')
        self.assertTrue(inst.schema, 'schema')
        self.assertEqual(inst.sheet_names, ['othername'])

    def test_save_success_no_change_permission(self):
        from pyramid.httpexceptions import HTTPForbidden
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        sheet_factory = DummySheetFactory([('change', 'sdi.change')])
        request.registry.content = DummyContent(
            [('name', sheet_factory)])
        resource = testing.DummyResource()
        request.context = resource
        inst = self._makeOne(request)
        self.config.testing_securitypolicy(permissive=False)
        self.assertRaises(HTTPForbidden, inst.save_success, {'a':1})

    def test_save_success_cannot_lock(self):
        from zope.interface import alsoProvides
        from substanced.form import FormError
        from substanced.interfaces import IFolder
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent(
            [('name', DummyPropertySheet)])
        resource = testing.DummyResource()
        alsoProvides(resource, IFolder)
        resource['locks'] = DummyLockService(False)
        request.context = resource
        inst = self._makeOne(request)
        self.assertRaises(FormError, inst.save_success, {'a':1})

    def test_save_success_ok(self):
        from zope.interface import alsoProvides
        from substanced.interfaces import IFolder
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent(
            [('name', DummyPropertySheet)])
        resource = testing.DummyResource()
        alsoProvides(resource, IFolder)
        resource['locks'] = DummyLockService(True)
        request.context = resource
        inst = self._makeOne(request)
        response = inst.save_success({'a':1})
        self.assertEqual(response.location, '/mgmt_path')
        self.assertEqual(inst.active_sheet.struct, {'a': 1})
        self.assertTrue(inst.active_sheet.after)
        self.assertEqual(request.sdiapi.flashed,
                         ('Updated properties', 'success') )

    def test_before(self):
        request = testing.DummyRequest()
        request.registry = testing.DummyResource()
        request.registry.content = DummyContent(
            [('name', DummyPropertySheet)])
        resource = testing.DummyResource()
        request.context = resource
        inst = self._makeOne(request)
        _called_with = []
        def _before_render(form):
            _called_with.append(form)
        inst.active_sheet.before_render = _before_render
        form = DummyForm()
        inst.before(form)
        self.assertEqual(_called_with, [form])

    def test_show(self):
        request = testing.DummyRequest()
        request.registry = testing.DummyResource()
        request.registry.content = DummyContent(
            [('name', DummyPropertySheet)])
        resource = testing.DummyResource()
        request.context = resource
        inst = self._makeOne(request)
        form = DummyForm()
        result = inst.show(form)
        self.assertTrue(form.rendered)
        self.assertEqual(result['form'], None)

    def test_has_permission_to_no_permissions(self):
        request = testing.DummyRequest()
        request.registry = testing.DummyResource()
        request.registry.content = DummyContent(
            [('name', DummyPropertySheet)])
        resource = testing.DummyResource()
        request.context = resource
        inst = self._makeOne(request)
        result = inst.has_permission_to('view', DummyPropertySheet)
        self.assertTrue(result)

    def test_has_permission_to_no_specific_permission(self):
        request = testing.DummyRequest()
        request.registry = testing.DummyResource()
        sheet_factory = DummySheetFactory([('edit', 'sdi.edit')])
        request.registry.content = DummyContent(
            [('name', sheet_factory)])
        resource = testing.DummyResource()
        request.context = resource
        inst = self._makeOne(request)
        result = inst.has_permission_to('view', DummyPropertySheet)
        self.assertTrue(result)
        
    def test_has_permission_to_denied(self):
        request = testing.DummyRequest()
        request.registry = self.config.registry
        sheet_factory = DummySheetFactory([('view', 'sdi.view')])
        request.registry.content = DummyContent(
            [('name', sheet_factory)])
        resource = testing.DummyResource()
        request.context = resource
        inst = self._makeOne(request)
        self.config.testing_securitypolicy(permissive=False)
        result = inst.has_permission_to('view', sheet_factory)
        self.assertFalse(result)

    def test_viewable_sheet_factories_no_permission(self):
        sheet_factory = DummySheetFactory([('view', 'sdi.view')])
        request = testing.DummyRequest()
        request.registry.content = DummyContent(
            [('name', sheet_factory)])
        resource = testing.DummyResource()
        request.context = resource
        inst = self._makeOne(request)
        self.config.testing_securitypolicy(permissive=False)
        result = inst.viewable_sheet_factories()
        self.assertEqual(result, [])
        

class Test_has_permission_to_view_any_propertysheet(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, context, request):
        from ..views import has_permission_to_view_any_propertysheet
        return has_permission_to_view_any_propertysheet(context, request)
        
    def test_no_candidates(self):
        request = testing.DummyRequest()
        request.registry.content = DummyContent([])
        context = testing.DummyResource()
        self.assertFalse(self._callFUT(context, request))
        
    def test_no_permission_required(self):
        request = testing.DummyRequest()
        request.registry.content = DummyContent([(True, True)])
        context = testing.DummyResource()
        self.assertTrue(self._callFUT(context, request))

    def test_permission_required_denied(self):
        self.config.testing_securitypolicy(permissive=False)
        request = testing.DummyRequest()
        sheet_factory = DummySheetFactory([('view', 'sdi.view')])
        request.registry.content = DummyContent([('sheet', sheet_factory)])
        context = testing.DummyResource()
        self.assertFalse(self._callFUT(context, request))

    def test_permission_required_allowed(self):
        self.config.testing_securitypolicy(permissive=True)
        request = testing.DummyRequest()
        sheet_factory = DummySheetFactory([('view', 'sdi.view')])
        request.registry.content = DummyContent([('sheet', sheet_factory)])
        context = testing.DummyResource()
        self.assertTrue(self._callFUT(context, request))

    def test_no_view_permission_required_allowed(self):
        request = testing.DummyRequest()
        sheet_factory = DummySheetFactory([('edit', 'sdi.edit')])
        request.registry.content = DummyContent([('sheet', sheet_factory)])
        context = testing.DummyResource()
        self.assertTrue(self._callFUT(context, request))


class DummySheetFactory(object):

    def __init__(self, permissions, schema=None):
        self.permissions = permissions
        self.schema = schema

    def __call__(self, *args):
        return self

class DummyForm(object):
    def __init__(self):
        self.rendered = []
        
    def render(self, appstruct=None, readonly=False):
        self.rendered.append((appstruct, readonly))

class DummyPropertySheet(object):
    schema = 'schema'
    def __init__(self, context, request):
        self.context = context
        self.request = request

    def get(self):
        return {}

    def set(self, struct):
        self.struct = struct

    def after_set(self, changed):
        self.changed = changed
        self.after = True

class DummyContent(object):
    def __init__(self, result):
        self.result = result

    def metadata(self, context, name, default=None):
        return self.result
    
class Dummy(object):
    pass

class DummySDIAPI(object):
    def mgmt_path(self, *arg, **kw):
        return '/mgmt_path'

    def flash_with_undo(self, msg, category):
        self.flashed = (msg, category)

class DummyUser(object):
    def __init__(self, owner):
        self.__name__ = owner

class DummyLock(object):
    def __init__(self, owner, comment):
        self.owner = DummyUser(owner)
        self.comment = comment

class DummyLockService(object):
    def __init__(self, can_lock):
        from zope.interface import directlyProvides
        from ...interfaces import IService
        self._can_lock = can_lock
        directlyProvides(self, IService)

    def borrow_lock(self, resource, owner, locktype=None):
        from substanced.locking import LockError
        if not self._can_lock:
            raise LockError(DummyLock('otheruser', 'existing'))
        return True

########NEW FILE########
__FILENAME__ = views
from pyramid.httpexceptions import (
    HTTPFound,
    HTTPForbidden,
    HTTPNotFound,
    )
from pyramid.security import (
    authenticated_userid,
    has_permission,
    )

from ..form import FormError
from ..form import FormView
from ..locking import LockError
from ..locking import could_lock_resource
from ..sdi import mgmt_view
from ..util import _

def has_permission_to_view_any_propertysheet(context, request):
    candidates = request.registry.content.metadata(
        context, 'propertysheets', [])
    sheet_factories = [ x[1] for x in candidates ]
    for sheet_factory in sheet_factories:
        permissions = getattr(sheet_factory, 'permissions', None)
        if not permissions:
            return True
        view_permission = dict(permissions).get('view')
        if view_permission:
            if has_permission(view_permission, context, request):
                return True
        else:
            return True
    return False

@mgmt_view(
    propertied=True,
    name='properties',
    renderer='templates/propertysheets.pt',
    tab_title=_('Properties'),
    tab_condition=has_permission_to_view_any_propertysheet,
    permission='sdi.view',
    )
class PropertySheetsView(FormView):
    buttons = (_('save'),)

    def __init__(self, request):
        self.request = request
        self.context = request.context
        viewable_sheet_factories = self.viewable_sheet_factories()
        if not viewable_sheet_factories:
            raise HTTPNotFound('No viewable property sheets')
        subpath = request.subpath
        active_factory = None
        if subpath:
            active_sheet_name = subpath[0]
            active_factory = dict(viewable_sheet_factories).get(
                active_sheet_name)
        if not active_factory:
            active_sheet_name, active_factory = viewable_sheet_factories[0]
        self.active_sheet_name = active_sheet_name
        self.active_factory = active_factory
        self.active_sheet = active_factory(self.context, self.request)
        self.sheet_names = [x[0] for x in viewable_sheet_factories]
        self.schema = self.active_sheet.schema

    def has_permission_to(self, perm, sheet_factory):
        permissions = getattr(sheet_factory, 'permissions', None)
        if permissions is not None:
            permission = dict(permissions).get(perm)
            if permission:
                return has_permission(permission, self.context, self.request)
        return True

    def viewable_sheet_factories(self):
        L = []
        candidates = self.request.registry.content.metadata(
            self.context, 'propertysheets', [])
        for name, factory in candidates:
            if not self.has_permission_to('view', factory):
                continue
            L.append((name, factory))
        return L

    def save_success(self, appstruct):
        if not self.has_permission_to('change', self.active_factory):
            raise HTTPForbidden(
                "You don't have permission to change properties of this "
                "property sheet")
        try:
            ownerid = authenticated_userid(self.request)
            if could_lock_resource(self.context, ownerid): #may raise
                changed = self.active_sheet.set(appstruct)
        except LockError as e:
            raise FormError('locked by "%s"' % e.lock.owner.__name__)
        self.active_sheet.after_set(changed)
        self.request.sdiapi.flash_with_undo('Updated properties', 'success')
        return HTTPFound(self.request.sdiapi.mgmt_path(
            self.context, '@@properties', self.active_sheet_name))

    def before(self, form):
        self.active_sheet.before_render(form)

    def show(self, form):
        readonly = not self.has_permission_to('change', self.active_factory)
        appstruct = self.active_sheet.get()
        return {'form':form.render(appstruct=appstruct, readonly=readonly)}


########NEW FILE########
__FILENAME__ = tests
import unittest
from pyramid import testing

class TestRoot(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self):
        from . import Root
        inst = Root()
        return inst

    def test_ctor(self):
        inst = self._makeOne()
        self.assertEqual(list(inst.items()), [])

    def _makeRegistry(self, settings):
        created = testing.DummyResource()
        group = testing.DummyResource()
        def connect(other):
            group.connected = other
        memberids = testing.DummyResource()
        memberids.connect = connect
        group.memberids = memberids
        group.__oid__ = 1
        user = testing.DummyResource()
        catalog = testing.DummyResource()
        catalog.update_indexes = lambda *arg, **kw: True
        catalog.index_doc = lambda *arg, **kw: True
        def add_user(*arg, **kw):
            return user
        def add_group(*arg, **kw):
            return group
        def add_catalog(name):
            return catalog
        created_stack = []
        created.add_user = add_user
        created.add_group = add_group
        created2 = testing.DummyResource()
        created2.add_catalog = add_catalog
        locks = testing.DummyResource()
        created_stack = [created2, created, locks]
        registry = testing.DummyResource()
        registry.settings = settings
        registry.content = testing.DummyResource()
        def create(type, *arg, **kw):
            return created_stack.pop(0)
        registry.content.create = create
        registry.group = group
        registry.user = user
        registry.created = created
        registry.subscribers = lambda *arg: True
        return registry

    def test_after_create_with_password(self):
        from ..interfaces import IService
        settings = {
            'substanced.initial_password':'pass',
            'substanced.initial_login':'login',
            'substanced.initial_email':'email@example.com',
            }
        registry = self._makeRegistry(settings)
        inst = self._makeOne()
        inst.__oid__ = 1
        inst.after_create(inst, registry)
        self.assertTrue('__objectmap__' in inst.__dict__)
        principals = inst['principals']
        locks = inst['locks']
        self.assertTrue(IService.providedBy(principals))
        self.assertTrue(registry.group.connected)
        self.assertTrue(inst.__acl__)
        self.assertFalse(registry.created.__sdi_deletable__)
        self.assertTrue(IService.providedBy(locks))

    def test_after_create_without_password(self):
        from pyramid.exceptions import ConfigurationError
        settings = {}
        registry = self._makeRegistry(settings)
        inst = self._makeOne()
        self.assertRaises(ConfigurationError, inst.after_create, inst, registry)

########NEW FILE########
__FILENAME__ = resources
import colander
import deform.widget

from persistent import Persistent

from substanced.content import content
from substanced.property import PropertySheet
from substanced.schema import (
    Schema,
    NameSchemaNode
    )
from substanced.util import renamer

def context_is_a_document(context, request):
    return request.registry.content.istype(context, 'Document')

class DocumentSchema(Schema):
    name = NameSchemaNode(
        editing=context_is_a_document,
        )
    title = colander.SchemaNode(
        colander.String(),
        )
    body = colander.SchemaNode(
        colander.String(),
        widget=deform.widget.RichTextWidget()
        )

class DocumentPropertySheet(PropertySheet):
    schema = DocumentSchema()

@content(
    'Document',
    icon='glyphicon glyphicon-align-left',
    add_view='add_document',
    propertysheets=(
        ('Basic', DocumentPropertySheet),
        ),
    )
class Document(Persistent):

    name = renamer()

    def __init__(self, title='', body=''):
        self.title = title
        self.body = body

########NEW FILE########
__FILENAME__ = views
from pyramid.renderers import get_renderer
from pyramid.view import view_config
from ..resources import Document

#
#   Default "retail" view
#
@view_config(
    renderer='templates/splash.pt',
    )
def splash_view(request):
    manage_prefix = request.registry.settings.get('substanced.manage_prefix',
                                                  '/manage')
    return {'manage_prefix': manage_prefix}

#
#   "Retail" view for documents.
#
@view_config(
    context=Document,
    renderer='templates/document.pt',
    )
def document_view(context, request):
    return {'title': context.title,
            'body': context.body,
            'master': get_renderer('templates/master.pt').implementation(),
           }


########NEW FILE########
__FILENAME__ = views
from pyramid.httpexceptions import HTTPFound

from substanced.sdi import mgmt_view
from substanced.form import FormView
from substanced.interfaces import IFolder

from .resources import DocumentSchema

#
#   SDI "add" view for documents
#
@mgmt_view(
    context=IFolder,
    name='add_document',
    tab_title='Add Document',
    permission='sdi.add-content',
    renderer='substanced.sdi:templates/form.pt',
    tab_condition=False,
    )
class AddDocumentView(FormView):
    title = 'Add Document'
    schema = DocumentSchema()
    buttons = ('add',)

    def add_success(self, appstruct):
        registry = self.request.registry
        name = appstruct.pop('name')
        document = registry.content.create('Document', **appstruct)
        self.context[name] = document
        return HTTPFound(
            self.request.sdiapi.mgmt_path(self.context, '@@contents')
            )

########NEW FILE########
__FILENAME__ = tests
import os
import pkg_resources
import shutil
import subprocess
import tempfile
import time

try:
    import httplib
except ImportError: # pragma: no cover
    import http.client as httplib

from pyramid.scaffolds.tests import TemplateTest

class SubstanceDTemplateTest(TemplateTest):
    # Override to avoid pyramid-specific stuff
    def install(self, tmpl_name): # pragma: no cover
        try:
            self.old_cwd = os.getcwd()
            self.directory = tempfile.mkdtemp()
            self.make_venv(self.directory)
            os.chdir(pkg_resources.get_distribution('substanced').location)
            subprocess.check_call(
                [os.path.join(self.directory, 'bin', 'python'),
                 'setup.py', 'develop'])
            os.chdir(self.directory)
            subprocess.check_call(['bin/pcreate', '-s', tmpl_name, 'Dingle'])
            os.chdir('Dingle')
            py = os.path.join(self.directory, 'bin', 'python')
            subprocess.check_call([py, 'setup.py', 'install'])
            subprocess.check_call([py, 'setup.py', 'test'])
            pserve = os.path.join(self.directory, 'bin', 'pserve')
            for ininame, hastoolbar in (('development.ini', True),
                                        ('production.ini', False)):
                proc = subprocess.Popen([pserve, ininame])
                try:
                    time.sleep(5)
                    proc.poll()
                    if proc.returncode is not None:
                        raise RuntimeError('%s didnt start' % ininame)
                    conn = httplib.HTTPConnection('localhost:6543')
                    conn.request('GET', '/')
                    resp = conn.getresponse()
                    assert resp.status == 200, ininame
                    data = resp.read()
                    toolbarchunk = b'<div id="pDebug"'
                    if hastoolbar:
                        assert toolbarchunk in data, ininame
                    else:
                        assert not toolbarchunk in data, ininame
                finally:
                    proc.terminate()
        finally:
            shutil.rmtree(self.directory)
            os.chdir(self.old_cwd)


if __name__ == '__main__':     # pragma: no cover
    test = SubstanceDTemplateTest()
    test.install('substanced')

########NEW FILE########
__FILENAME__ = tests
import unittest
from pyramid import testing
import colander

class TestCSRFToken(unittest.TestCase):
    def _getTargetClass(self):
        from . import CSRFToken
        return CSRFToken

    def _makeOne(self):
        return self._getTargetClass()()

    def test_serialize_no_bindings(self):
        inst = self._makeOne()
        result = inst.serialize()
        self.assertEqual(result, colander.drop)

    def test_serialize_bindings_dont_contain_token(self):
        inst = self._makeOne()
        inst.bindings = {}
        result = inst.serialize()
        self.assertEqual(result, colander.drop)

    def test_serialize_bindings_contains_token(self):
        inst = self._makeOne()
        inst.bindings = {'_csrf_token_':'123'}
        result = inst.serialize()
        self.assertEqual(result, colander.null)

    def test_deserialize_no_bindings(self):
        inst = self._makeOne()
        result = inst.deserialize()
        self.assertEqual(result, colander.drop)

    def test_deserialize_bindings_dont_contain_token(self):
        inst = self._makeOne()
        inst.bindings = {}
        result = inst.deserialize()
        self.assertEqual(result, colander.drop)

    def test_deserialize_bindings_contains_token(self):
        inst = self._makeOne()
        inst.bindings = {'_csrf_token_':'123'}
        result = inst.deserialize('123')
        self.assertEqual(result, '123')
        
class TestSchema(unittest.TestCase):
    def _getTargetClass(self):
        from . import Schema
        return Schema

    def _makeOne(self):
        return self._getTargetClass()()

    def test_validate_failure(self):
        from colander import Invalid
        inst = self._makeOne()
        request = DummyRequest()
        inst2 = inst.bind(_csrf_token_='123', request=request)
        self.assertEqual(inst2['_csrf_token_'].default, 'csrf_token')
        self.assertRaises(Invalid, inst2.deserialize, {'_csrf_token_':'wrong'})

    def test_validate_missing(self):
        from colander import Invalid
        inst = self._makeOne()
        request = DummyRequest()
        inst2 = inst.bind(_csrf_token_='123', request=request)
        self.assertEqual(inst2['_csrf_token_'].default, 'csrf_token')
        self.assertRaises(Invalid, inst2.deserialize, {})

    def test_validate_success(self):
        inst = self._makeOne()
        request = DummyRequest()
        inst2 = inst.bind(request=request, _csrf_token_='123')
        self.assertEqual(inst2.deserialize({'_csrf_token_':'123'}),{})

class TestRemoveCSRFMapping(unittest.TestCase):
    def _makeOne(self):
        from . import RemoveCSRFMapping
        return RemoveCSRFMapping()

    def test_deserialize_colander_null(self):
        inst = self._makeOne()
        node = object()
        result = inst.deserialize(node, colander.null)
        self.assertEqual(result, colander.null)

    def test_deserialize_real_mapping(self):
        inst = self._makeOne()
        node = colander.SchemaNode(colander.Mapping())
        a = colander.SchemaNode(colander.String(), name='a')
        node.add(a)
        result = inst.deserialize(node, {'_csrf_token_':'token', 'a':'1'})
        self.assertEqual(result, {'a':'1'})

class TestNameSchemaNode(unittest.TestCase):
    def _makeOne(self, **kw):
        from . import NameSchemaNode
        return NameSchemaNode(**kw)

    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()
    
    def _makeBindings(self):
        request = testing.DummyRequest()
        context = testing.DummyResource()
        return dict(request=request, context=context)

    def test_it_invalid_len(self):
        bindings = self._makeBindings()
        node = self._makeOne()
        def check_name(value): return value
        bindings['context'].check_name = check_name
        bindings['request'].registry.content = DummyContent(True)
        node.bindings = bindings
        node.max_len = 1
        self.assertRaises(colander.Invalid, node.validator, node, 'abc')

    def test_it_invalid_check_name(self):
        bindings = self._makeBindings()
        node = self._makeOne()
        def check_name(value):
            self.assertEqual(value, 'abc')
            raise ValueError('abc')
        bindings['context'].check_name = check_name
        bindings['request'].registry.content = DummyContent(True)
        node.bindings = bindings
        self.assertRaises(colander.Invalid, node.validator, node, 'abc')

    def test_it_valid(self):
        bindings = self._makeBindings()
        node = self._makeOne()
        def check_name(value): return value
        bindings['context'].check_name = check_name
        bindings['request'].registry.content = DummyContent(True)
        node.bindings = bindings
        self.assertEqual(node.validator(node, 'abc'), None)

    def test_it_editing_True_invalid(self):
        bindings = self._makeBindings()
        parent = testing.DummyResource()
        def check_name(value):
            raise ValueError('foo')
        parent.validate_name = check_name
        bindings['context'].__parent__ = parent
        bindings['request'].registry.content = DummyContent(True)
        node = self._makeOne(editing=True)
        node.bindings = bindings
        self.assertRaises(colander.Invalid, node.validator, node, 'abc')

    def test_it_editing_True_valid(self):
        bindings = self._makeBindings()
        parent = testing.DummyResource()
        def check_name(value): return value
        parent.validate_name = check_name
        bindings['context'].__parent__ = parent
        bindings['request'].registry.content = DummyContent(True)
        node = self._makeOne(editing=True)
        node.bindings = bindings
        self.assertEqual(node.validator(node, 'abc'), None)

    def test_it_editing_is_callable(self):
        bindings = self._makeBindings()
        parent = testing.DummyResource()
        def check_name(value): return value
        parent.validate_name = check_name
        bindings['context'].__parent__ = parent
        bindings['request'].registry.content = DummyContent(True)
        def editing(context, request):
            self.assertEqual(context, bindings['context'])
            self.assertEqual(request, bindings['request'])
            return True
        node = self._makeOne(editing=editing)
        node.bindings = bindings
        self.assertEqual(node.validator(node, 'abc'), None)

class TestPermissionsSchemaNode(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self):
        from . import PermissionsSchemaNode
        return PermissionsSchemaNode()

    def test_widget(self):
        request = testing.DummyRequest()
        bindings = {'request':request}
        inst = self._makeOne()
        inst._get_all_permissions = lambda *arg: ['one', 'two']
        inst.bindings = bindings
        result = inst.widget
        self.assertEqual(result.values, [('one', 'one'), ('two', 'two')])

    def test_validator_invalid(self):
        import colander
        request = testing.DummyRequest()
        bindings = {'request':request}
        inst = self._makeOne()
        inst._get_all_permissions = lambda *arg: ['one', 'two']
        inst.bindings = bindings
        self.assertRaises(colander.Invalid, inst.validator, None, ('nope',))

    def test_validator_valid(self):
        request = testing.DummyRequest()
        bindings = {'request':request}
        inst = self._makeOne()
        inst._get_all_permissions = lambda *arg: ['one', 'two']
        inst.bindings = bindings
        self.assertEqual(inst.validator(None, ('one',)), None)

    def test_schema_type(self):
        inst = self._makeOne()
        result = inst.schema_type()
        self.assertEqual(result.__class__.__name__, 'Set')

class TestIdSet(unittest.TestCase):
    def _makeOne(self):
        from . import IdSet
        return IdSet()

    def test_serialize_null(self):
        inst = self._makeOne()
        result = inst.serialize(None, colander.null)
        self.assertEqual(result, colander.null)

    def test_serialize_noniterable(self):
        inst = self._makeOne()
        self.assertRaises(colander.Invalid, inst.serialize, None, None)

    def test_serialize_non_null(self):
        inst = self._makeOne()
        result = inst.serialize(None, [1,2,3])
        self.assertEqual(result, ['1','2','3'])

    def test_deserialize_null(self):
        inst = self._makeOne()
        result = inst.deserialize(None, colander.null)
        self.assertEqual(result, colander.null)

    def test_deserialize_noniterable(self):
        inst = self._makeOne()
        self.assertRaises(colander.Invalid, inst.deserialize, None, None)

    def test_deserialize_non_null(self):
        inst = self._makeOne()
        result = inst.deserialize(None, ['1','2','3'])
        self.assertEqual(result, [1,2,3])

    def test_cstruct_children(self):
        inst = self._makeOne()
        self.assertEqual(inst.cstruct_children(None, None), [])

class TestMultireferenceIdSchemaNode(unittest.TestCase):
    def _makeOne(self):
        from . import MultireferenceIdSchemaNode
        return MultireferenceIdSchemaNode()

    def test__get_choices(self):
        inst = self._makeOne()
        inst.bindings = {'context':None, 'request':None}
        inst.choices_getter = lambda *arg: 123
        self.assertEqual(inst._get_choices(), 123)

    def test_widget(self):
        inst = self._makeOne()
        inst._get_choices = lambda: [1]
        widget = inst.widget
        self.assertEqual(widget.values, [1])
        self.assertTrue(widget.multiple)

class DummySession(dict):
    def get_csrf_token(self):
        return 'csrf_token'

class DummyRequest(testing.DummyRequest):
    def __init__(self, *arg, **kw):
        testing.DummyRequest.__init__(self, *arg, **kw)
        self.session = DummySession()
    

class DummyContent(object):
    def __init__(self, result):
        self.result = result

########NEW FILE########
__FILENAME__ = add_user
"""Add an admin user.
"""

from optparse import OptionParser
import sys

from pyramid.paster import (
    setup_logging,
    bootstrap,
    )
import transaction

def main():
    parser = OptionParser(description=__doc__,
                          usage="%prog <config_uri> <username> <password>",
                         )

    options, args = parser.parse_args()

    try:
        config_uri, username, password = args
    except:
        parser.print_usage()
        sys.exit(1)

    setup_logging(config_uri)
    env = bootstrap(config_uri)
    site = env['root']

    principals = env['root']['principals']
    users = principals['users']
    admins = principals['groups']['admins']
    user = principals.add_user(username, password=password)
    admins.memberids.connect([user])
    transaction.commit()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = drain_indexing
""" Drain deferred indexing actions """

from optparse import OptionParser

from pyramid.paster import (
    setup_logging,
    bootstrap,
    )

from substanced.catalog.deferred import BasicActionProcessor

def main():
    parser = OptionParser(description=__doc__)

    options, args = parser.parse_args()

    if args:
        config_uri = args[0]
    else:
        parser.error("Requires a config_uri as an argument")

    setup_logging(config_uri)
    env = bootstrap(config_uri)
    site = env['root']

    processor = BasicActionProcessor(site)
    processor.process() # loops

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = dump
""" Dump an object (and its subobjects) to the filesystem:

sd_dump [--source=ZODB-PATH] [--dest=FILESYSTEM-PATH] config_uri
  Dumps the object at ZODB-PATH and all of its subobjects to a
  filesystem path.  Such a dump can be loaded (programmatically)
  by using the substanced.dump.load function

e.g. sd_dump --source=/ --dest=/my/dump etc/development.ini
"""

import os
import sys
from optparse import OptionParser

from pyramid.paster import (
    setup_logging,
    bootstrap,
    )
from pyramid.traversal import traverse

from substanced.dump import dump

def _print(msg):
    sys.stdout.write('%s\n' % msg)

def usage(e=None):
    if e is not None:
        _print(e)
        _print('')
    sys.exit(2)

def main():
    parser = OptionParser(description=__doc__)
    parser.add_option('-s', '--source', dest='source',
        action="store", default='/', metavar='ZODB-PATH',
        help="The ZODB source path to dump (e.g. /foo/bar or /)")
    parser.add_option('-d', '--dest', dest='dest',
        action="store", default='dump', metavar='FILESYSTEM-PATH',
        help="The destination filesystem path to dump to.")

    options, args = parser.parse_args()

    if args:
        config_uri = args[0]
    else:
        parser.error("Requires a config_uri as an argument")

    source = options.source
    dest = os.path.expanduser(os.path.normpath(options.dest))

    setup_logging(config_uri)
    env = bootstrap(config_uri)
    root = env['root']

    traversed = traverse(root, source)

    if traversed['view_name']:
        parser.error('No dumpable object at %s' % source)
        
    source = traversed['context']

    dump(source, dest)



########NEW FILE########
__FILENAME__ = evolve
""" Run database evolution steps """

import datetime
import getopt
import sys
import transaction

from pyramid.paster import (
    setup_logging,
    bootstrap,
    )

def _print(msg):
    sys.stdout.write('%s\n' % msg)

def main(argv=sys.argv): # pragma: no cover
    from substanced.evolution import EvolutionManager

    def usage(e=None):
        if e is not None:
            _print(e)
            _print('')
        _print("""\
    sd_evolve [--latest] [--dry-run] [--mark-finished=stepname] [--mark-unfinished=stepname] config_uri
      Evolves new database with changes from scripts in evolve packages
         - with no arguments, evolve displays finished and unfinished steps
         - with the --latest argument, evolve runs scripts as necessary
         - with the --dry-run argument, evolve runs scripts but does not issue any commits
         - with the --mark-finished argument, marks the stepname as finished
         - with the --mark-unfinished argument, marks the stepname as unfinished

    e.g. sd_evolve --latest etc/development.ini""")
        sys.exit(2)

    name, argv = argv[0], argv[1:]
    latest = False
    dry_run = False
    mark_finished = []
    mark_unfinished = []

    try:
        opts, args = getopt.getopt(argv, 'l?hdu:f:',
                                         ['latest',
                                          'help',
                                          'dry-run',
                                          'mark-unfinished=',
                                          'mark-finished=',
                                         ])
    except getopt.GetoptError as e:
        usage(e)

    if args:
        config_uri = args[0]
    else:
        usage('Requires a config_uri as an argument')

    for k, v in opts:
        if k in ('-h', '-?', '--help'):
            usage()
        if k in ('-l', '--latest'):
            latest = True
        if k in ('-d', '--dry-run'):
            dry_run = True
        if k in ('-f', '--mark-finished'):
            mark_finished.append(v)
        if k in ('-u', '--mark-unfinished'):
            mark_unfinished.append(v)

    if latest and dry_run:
        usage('--latest and --dry-run cannot be used together')

    if (latest or dry_run) and (mark_finished or mark_unfinished):
        usage('--latest/--dry-run cannot be used with --mark-finished/--mark-unfinished')

    setup_logging(config_uri)
    env = bootstrap(config_uri)
    root = env['root']
    registry = env['registry']

    manager = EvolutionManager(root, registry)

    if latest or dry_run:
        complete = manager.evolve(latest)

        if complete:
            if dry_run:
                _print('Evolution steps dry-run:')
            else:
                _print('Evolution steps executed:')
            for item in complete:
                _print('   %s' % item)
        else:
            if dry_run:
                _print('No evolution steps dry-run')
            else:
                _print('No evolution steps executed')

    elif mark_finished or mark_unfinished:
        t = transaction.get()

        for step in mark_finished:
            finished_steps = manager.get_finished_steps()
            unfinished_steps = dict(manager.get_unfinished_steps())
            if step in finished_steps:
                _print('Step %s already marked as finished' % step)
            else:
                if step in unfinished_steps:
                    manager.add_finished_step(step)
                    _print('Step %s marked as finished' % step)
                    t.note('Marked %s evolution step as finished' % step)
                else:
                    _print('Unknown step %s, not marking as finished' % step)

        for step in mark_unfinished:
            finished_steps = manager.get_finished_steps()
            unfinished_steps = dict(manager.get_unfinished_steps())
            if step in finished_steps:
                manager.remove_finished_step(step)
                _print('Step %s marked as unfinished' % step)
                t.note('Marked %s evolution step as unfinished' % step)
            else:
                if step in unfinished_steps:
                    _print('Step %s already marked as unfinished' % step)
                else:
                    _print('Unknown step %s, not marking as unfinished' % step)

        t.commit()

    else:
        _print('Finished steps:\n')
        for ts, stepname in manager.get_finished_steps_by_value():
            tp = datetime.datetime.fromtimestamp(ts).strftime(
                '%Y-%m-%d %H:%M:%S')
            _print('    %s %s' % (tp, stepname))
        _print ('\nUnfinished steps:\n')
        for stepname, func in manager.get_unfinished_steps():
            _print(' '*24 + stepname)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = reindex
""" Reindex the catalog  """

import re
from optparse import OptionParser

from pyramid.paster import (
    setup_logging,
    bootstrap,
    )

from pyramid.traversal import resource_path

from substanced.objectmap import find_objectmap

from substanced.catalog import Catalog

from substanced.util import get_dotted_name

def main():
    parser = OptionParser(description=__doc__)
    parser.add_option('-d', '--dry-run', dest='dry_run',
        action="store_true", default=False,
        help="Don't commit the transactions")
    parser.add_option('-i', '--interval', dest='commit_interval',
        action="store", default=3000,
        help="Commit every N transactions")
    parser.add_option('-p', '--path', dest='path',
        action="store", default=None, metavar='EXPR',
        help="Reindex only objects whose path matches a regular expression")
    parser.add_option('-n', '--index', dest='indexes',
        action="append", help="Reindex only the given index (can be repeated)")
    parser.add_option('-c', '--catalog', dest='catalog_specs', action="append",
        help=("Reindex only the catalog provided (may be a path or a name "
              "and may be specified multiple times)"))

    options, args = parser.parse_args()

    if args:
        config_uri = args[0]
    else:
        parser.error("Requires a config_uri as an argument")

    commit_interval = int(options.commit_interval)
    if options.path:
        path_re = re.compile(options.path)
    else:
        path_re = None

    kw = {}
    if options.indexes:
        kw['indexes'] = options.indexes

    setup_logging(config_uri)
    env = bootstrap(config_uri)
    site = env['root']
    registry = env['registry']

    kw['registry'] = registry

    objectmap = find_objectmap(site)

    catalog_oids = objectmap.get_extent(get_dotted_name(Catalog))

    for oid in catalog_oids:

        catalog = objectmap.object_for(oid)

        path = resource_path(catalog)

        if options.catalog_specs:

            if ( (not path in options.catalog_specs) and 
                 (not catalog.__name__ in options.catalog_specs) ):
                    continue

        catalog.reindex(path_re=path_re, commit_interval=commit_interval,
                        dry_run=options.dry_run, **kw)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = test_sdi
import unittest
from pyramid import testing

class Test_add_mgmt_view(unittest.TestCase):
    def _callFUT(self, config, **kw):
        from .. import add_mgmt_view
        return add_mgmt_view(config, **kw)

    def _makeConfig(self):
        config = DummyConfigurator()
        return config

    def test_default_permission_is_sdi_view(self):
        config = self._makeConfig()
        self._callFUT(config)
        self.assertEqual(config._added['permission'], 'sdi.view')

    def test_with_request_method(self):
        config = self._makeConfig()
        self._callFUT(config, request_method=('HEAD', 'GET'))
        self.assertEqual(config._added['request_method'], ('HEAD', 'GET'))
        self.assertTrue(config._actions)

    def test_view_isclass_with_attr(self):
        class AView(object):
            pass
        config = self._makeConfig()
        self._callFUT(config, view=AView, attr='foo')
        self.assertTrue(config.desc.startswith('method'))

    def test_discriminator(self):
        config = self._makeConfig()
        self._callFUT(config)
        discrim = config._actions[0][0]
        self.assertEqual(discrim.resolve(),
                         ('sdi view', None, '', 'substanced_manage', 'hash')
                         )

    def test_intr_action(self):
        config = self._makeConfig()
        self._callFUT(config)
        self.assertEqual(config._actions[0][1][0], config._intr)

    def test_intr_related(self):
        config = self._makeConfig()
        self._callFUT(config)
        self.assertTrue('views' in config._intr.related)

    def test_intr_values(self):
        config = self._makeConfig()
        self._callFUT(
            config,
            tab_title='tab_title',
            tab_condition='tab_condition',
            check_csrf=True
            )
        self.assertEqual(config._intr['tab_title'], 'tab_title')
        self.assertEqual(config._intr['tab_condition'], 'tab_condition')
        self.assertEqual(config._intr.related['views'].resolve(),
                         ('view', None, '', 'substanced_manage', 'hash'))

    def test_with_tab_near_and_tab_before(self):
        from pyramid.exceptions import ConfigurationError
        from .. import MIDDLE
        config = self._makeConfig()
        self.assertRaises(
            ConfigurationError,
            self._callFUT,
            config,
            tab_near=MIDDLE,
            tab_before='tab2',
            )

    def test_with_tab_near_and_tab_after(self):
        from pyramid.exceptions import ConfigurationError
        from .. import MIDDLE
        config = self._makeConfig()
        self.assertRaises(
            ConfigurationError,
            self._callFUT,
            config,
            tab_near=MIDDLE,
            tab_after='tab2',
            )

    def test_with_tab_near_left(self):
        from .. import LEFT, FIRST, CENTER1
        config = self._makeConfig()
        self._callFUT(
            config,
            tab_near=LEFT,
            )
        self.assertEqual(config._intr['tab_before'], CENTER1)
        self.assertEqual(config._intr['tab_after'], FIRST)
        self.assertEqual(config._intr['tab_near'], LEFT)

    def test_with_tab_near_middle(self):
        from .. import MIDDLE, CENTER1, CENTER2
        config = self._makeConfig()
        self._callFUT(
            config,
            tab_near=MIDDLE,
            )
        self.assertEqual(config._intr['tab_before'], CENTER2)
        self.assertEqual(config._intr['tab_after'], CENTER1)
        self.assertEqual(config._intr['tab_near'], MIDDLE)
        
    def test_with_tab_near_right(self):
        from .. import RIGHT, CENTER2, LAST
        config = self._makeConfig()
        self._callFUT(
            config,
            tab_near=RIGHT,
            )
        self.assertEqual(config._intr['tab_before'], LAST)
        self.assertEqual(config._intr['tab_after'], CENTER2)
        self.assertEqual(config._intr['tab_near'], RIGHT)

    def test_with_tab_near_unknown(self):
        from pyramid.exceptions import ConfigurationError
        config = self._makeConfig()
        self.assertRaises(
            ConfigurationError,
            self._callFUT,
            config,
            tab_near='wontwork',
            )

class Test_mgmt_view(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _getTargetClass(self):
        from .. import mgmt_view
        return mgmt_view

    def _makeOne(self, *arg, **kw):
        return self._getTargetClass()(*arg, **kw)

    def test_create_defaults(self):
        decorator = self._makeOne()
        self.assertEqual(decorator.__dict__, {})

    def test_create_nondefaults(self):
        decorator = self._makeOne(
            name=None,
            request_type=None,
            permission='foo',
            mapper='mapper',
            decorator='decorator',
            match_param='match_param',
            )
        self.assertEqual(decorator.name, None)
        self.assertEqual(decorator.request_type, None)
        self.assertEqual(decorator.permission, 'foo')
        self.assertEqual(decorator.mapper, 'mapper')
        self.assertEqual(decorator.decorator, 'decorator')
        self.assertEqual(decorator.match_param, 'match_param')
        
    def test_call_function(self):
        decorator = self._makeOne()
        venusian = DummyVenusian()
        decorator.venusian = venusian
        def foo(): pass
        wrapped = decorator(foo)
        self.assertTrue(wrapped is foo)
        context = testing.DummyResource()
        context.config = DummyConfigurator()
        venusian.callback(context, None, 'abc')
        self.assertEqual(context.config.view, 'abc')

    def test_call_class_no_attr(self):
        decorator = self._makeOne()
        info = DummyVenusianInfo(scope='class')
        venusian = DummyVenusian(info)
        decorator.venusian = venusian
        def foo(): pass
        wrapped = decorator(foo)
        self.assertTrue(wrapped is foo)
        context = testing.DummyResource()
        context.config = DummyConfigurator()
        venusian.callback(context, None, None)
        self.assertEqual(context.config.settings['attr'], 'foo')

    def test_call_class_with_attr(self):
        decorator = self._makeOne(attr='bar')
        info = DummyVenusianInfo(scope='class')
        venusian = DummyVenusian(info)
        decorator.venusian = venusian
        def foo(): pass
        wrapped = decorator(foo)
        self.assertTrue(wrapped is foo)
        context = testing.DummyResource()
        context.config = DummyConfigurator()
        venusian.callback(context, None, None)
        self.assertEqual(context.config.settings['attr'], 'bar')

class Test_sdi_mgmt_views(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _callFUT(self, context, request, names=None):
        from .. import sdi_mgmt_views
        return sdi_mgmt_views(context, request, names)

    def test_context_has_no_name(self):
        result = self._callFUT(None, None)
        self.assertEqual(result, [])

    def test_no_views_found(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.registry.content = DummyContent()
        request.registry.introspector = DummyIntrospector()
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(result, [])

    def test_no_related_view(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.registry.content = DummyContent()
        intr = {}
        intr['tab_title'] = None
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(intr,)])
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(result, [])

    def test_one_related_view_gardenpath(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        request.view_name = 'name'
        view_intr = DummyIntrospectable()
        view_intr.category_name = 'views'
        view_intr['name'] = 'name'
        view_intr['context'] = None
        view_intr['derived_callable'] = None
        intr = {}
        intr['tab_title'] = None
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(intr,)])
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0]['view_name'], 'name')
        self.assertEqual(result[0]['title'], 'Name')
        self.assertEqual(result[0]['class'], 'active')
        self.assertEqual(result[0]['url'], '/mgmt_path')

    def test_one_related_view_somecontext_tabcondition_None(self):
        from zope.interface import Interface
        class IFoo(Interface):
            pass
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        view_intr = DummyIntrospectable()
        view_intr.category_name = 'views'
        view_intr['name'] = 'name'
        view_intr['context'] = IFoo
        view_intr['derived_callable'] = None
        intr = {}
        intr['tab_title'] = None
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(intr,)])
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(result, [])

    def test_one_related_view_instcontext_tabcondition_None(self):
        class Foo(object):
            pass
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        view_intr = DummyIntrospectable()
        view_intr.category_name = 'views'
        view_intr['name'] = 'name'
        view_intr['context'] = Foo
        view_intr['derived_callable'] = None
        intr = {}
        intr['tab_title'] = None
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(intr,)])
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(result, [])

    def test_one_related_view_anycontext_tabcondition_False(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        view_intr = DummyIntrospectable()
        view_intr.category_name = 'views'
        view_intr['name'] = 'name'
        view_intr['context'] = None
        view_intr['derived_callable'] = None
        intr = {}
        intr['tab_title'] = None
        intr['tab_condition'] = False
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(intr,)])
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(result, [])

    def test_one_related_view_anycontext_tabcondition_True(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        view_intr = DummyIntrospectable()
        view_intr.category_name = 'views'
        view_intr['name'] = 'name'
        view_intr['context'] = None
        view_intr['derived_callable'] = None
        intr = {}
        intr['tab_title'] = None
        intr['tab_condition'] = True
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(intr,)])
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(len(result), 1)

    def test_one_related_view_anycontext_tabcondition_callable(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        view_intr = DummyIntrospectable()
        view_intr.category_name = 'views'
        view_intr['name'] = 'name'
        view_intr['context'] = None
        view_intr['derived_callable'] = None
        intr = {}
        def tabcondition(context, request):
            return False
        intr['tab_title'] = None
        intr['tab_condition'] = tabcondition
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(intr,)])
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(result, [])

    def test_one_related_view_anycontext_tabcondition_None_not_in_names(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        view_intr = DummyIntrospectable()
        view_intr.category_name = 'views'
        view_intr['name'] = 'name'
        view_intr['context'] = None
        view_intr['derived_callable'] = None
        intr = {}
        intr['tab_title'] = None
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(intr,)])
        context = testing.DummyResource()
        result = self._callFUT(context, request, names=('fred',))
        self.assertEqual(result, [])

    def test_one_related_view_anycontext_tabcondition_None_predicatefail(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        view_intr = DummyIntrospectable()
        view_intr.category_name = 'views'
        view_intr['name'] = 'name'
        view_intr['context'] = None
        class Thing(object):
            def __predicated__(self, context, request):
                return False
        thing = Thing()
        view_intr['derived_callable'] = thing
        intr = {}
        intr['tab_title'] = None
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(intr,)])
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(result, [])

    def test_one_related_view_anycontext_tabcondition_None_permissionfail(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        view_intr = DummyIntrospectable()
        view_intr.category_name = 'views'
        view_intr['name'] = 'name'
        view_intr['context'] = None
        class Thing(object):
            def __permitted__(self, context, request):
                return False
        thing = Thing()
        view_intr['derived_callable'] = thing
        intr = {}
        intr['tab_title'] = None
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr,), introspectable=intr)
        request.registry.introspector = DummyIntrospector([(intr,)])
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(result, [])

    def test_one_related_view_two_tabs_gardenpath_tab_title_sorting(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        view_intr = DummyIntrospectable()
        view_intr.category_name = 'views'
        view_intr['name'] = 'name'
        view_intr['context'] = None
        view_intr['derived_callable'] = None
        intr = {}
        intr['tab_title'] = 'b'
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr2 = {}
        intr2['tab_title'] = 'a'
        intr2['tab_condition'] = None
        intr2['tab_before'] = None
        intr2['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr,), introspectable=intr)
        intr2 = DummyIntrospectable(related=(view_intr,), introspectable=intr2)
        request.registry.introspector = DummyIntrospector([(intr, intr2)])
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0]['view_name'], 'name')
        self.assertEqual(result[0]['title'], 'b')
        self.assertEqual(result[0]['class'], None)
        self.assertEqual(result[0]['url'], '/mgmt_path')
        # "a" is gone because we choose the first view data item via sort-break

    def test_one_related_view_gardenpath_with_taborder(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent(tab_order=('b',))
        request.view_name = 'b'
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'b'
        view_intr1['context'] = None
        view_intr1['derived_callable'] = None
        view_intr2 = DummyIntrospectable()
        view_intr2.category_name = 'views'
        view_intr2['name'] = 'a'
        view_intr2['context'] = None
        view_intr2['derived_callable'] = None
        intr = {}
        intr['tab_title'] = 'b'
        intr['tab_condition'] = None
        intr['tab_before'] = None
        intr['tab_after'] = None
        intr2 = {}
        intr2['tab_title'] = 'a'
        intr2['tab_condition'] = None
        intr2['tab_before'] = None
        intr2['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr1,), introspectable=intr)
        intr2 = DummyIntrospectable(related=(view_intr2,), introspectable=intr2)
        request.registry.introspector = DummyIntrospector([(intr, intr2)])
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(len(result), 2)
        self.assertEqual(result[0]['view_name'], 'b')
        self.assertEqual(result[0]['title'], 'b')
        self.assertEqual(result[0]['class'], 'active')
        self.assertEqual(result[0]['url'], '/mgmt_path')
        self.assertEqual(result[1]['view_name'], 'a')
        self.assertEqual(result[1]['title'], 'a')
        self.assertEqual(result[1]['class'], None)
        self.assertEqual(result[1]['url'], '/mgmt_path')

    def test_one_related_view_gardenpath_with_tab_before(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        request.view_name = 'b'
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'b'
        view_intr1['context'] = None
        view_intr1['derived_callable'] = None
        view_intr2 = DummyIntrospectable()
        view_intr2.category_name = 'views'
        view_intr2['name'] = 'a'
        view_intr2['context'] = None
        view_intr2['derived_callable'] = None
        intr = {}
        intr['tab_title'] = 'b'
        intr['tab_condition'] = None
        intr['tab_before'] = 'a'
        intr['tab_after'] = None
        intr2 = {}
        intr2['tab_title'] = 'a'
        intr2['tab_condition'] = None
        intr2['tab_before'] = None
        intr2['tab_after'] = None
        intr = DummyIntrospectable(related=(view_intr1,), introspectable=intr)
        intr2 = DummyIntrospectable(related=(view_intr2,), introspectable=intr2)
        request.registry.introspector = DummyIntrospector([(intr, intr2)])
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(len(result), 2)
        self.assertEqual(result[0]['view_name'], 'b')
        self.assertEqual(result[0]['title'], 'b')
        self.assertEqual(result[0]['class'], 'active')
        self.assertEqual(result[0]['url'], '/mgmt_path')
        self.assertEqual(result[1]['view_name'], 'a')
        self.assertEqual(result[1]['title'], 'a')
        self.assertEqual(result[1]['class'], None)
        self.assertEqual(result[1]['url'], '/mgmt_path')

    def test_gardenpath_with_tab_before_and_after(self):
        from substanced.sdi import CENTER1, CENTER2, FIRST, LAST
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        request.view_name = 'b'
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'c'
        view_intr1['context'] = None
        view_intr1['derived_callable'] = None
        view_intr2 = DummyIntrospectable()
        view_intr2.category_name = 'views'
        view_intr2['name'] = 'a'
        view_intr2['context'] = None
        view_intr2['derived_callable'] = None
        view_intr3 = DummyIntrospectable()
        view_intr3.category_name = 'views'
        view_intr3['name'] = 'b'
        view_intr3['context'] = None
        view_intr3['derived_callable'] = None
        view_intr4 = DummyIntrospectable()
        view_intr4.category_name = 'views'
        view_intr4['name'] = 'd'
        view_intr4['context'] = None
        view_intr4['derived_callable'] = None
        intr = {}
        intr['tab_title'] = 'c'
        intr['tab_condition'] = None
        intr['tab_before'] = CENTER1
        intr['tab_after'] = FIRST
        intr2 = {}
        intr2['tab_title'] = 'a'
        intr2['tab_condition'] = None
        intr2['tab_before'] = LAST
        intr2['tab_after'] = CENTER2
        intr3 = {}
        intr3['tab_title'] = 'b'
        intr3['tab_condition'] = None
        intr3['tab_before'] = CENTER2
        intr3['tab_after'] = CENTER1
        intr4 = {}
        intr4['tab_title'] = 'd'
        intr4['tab_condition'] = None
        intr4['tab_before'] = CENTER2
        intr4['tab_after'] = CENTER1
        
        intr = DummyIntrospectable(related=(view_intr1,), introspectable=intr)
        intr2 = DummyIntrospectable(related=(view_intr2,), introspectable=intr2)
        intr3 = DummyIntrospectable(related=(view_intr3,), introspectable=intr3)
        intr4 = DummyIntrospectable(related=(view_intr4,), introspectable=intr4)
        request.registry.introspector = DummyIntrospector(
            [(intr, intr2, intr3, intr4)]
            )
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(len(result), 4)
        self.assertEqual(result[0]['view_name'], 'c')
        self.assertEqual(result[0]['title'], 'c')
        self.assertEqual(result[0]['class'], None)
        self.assertEqual(result[0]['url'], '/mgmt_path')
        self.assertEqual(result[1]['view_name'], 'b')
        self.assertEqual(result[1]['title'], 'b')
        self.assertEqual(result[1]['class'], 'active')
        self.assertEqual(result[1]['url'], '/mgmt_path')
        self.assertEqual(result[2]['view_name'], 'd')
        self.assertEqual(result[2]['title'], 'd')
        self.assertEqual(result[2]['class'], None)
        self.assertEqual(result[2]['url'], '/mgmt_path')
        self.assertEqual(result[3]['view_name'], 'a')
        self.assertEqual(result[3]['title'], 'a')
        self.assertEqual(result[3]['class'], None)
        self.assertEqual(result[3]['url'], '/mgmt_path')

    def test_duplicate_view_names_ordering_context_is_iface(self):
        from zope.interface import Interface
        from zope.interface import directlyProvides
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        request.view_name = 'name'
        class I1(Interface):
            pass
        class I2(Interface):
            pass
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'name'
        view_intr1['context'] = I1
        view_intr1['derived_callable'] = None
        intr1 = {}
        intr1['tab_title'] = 'One'
        intr1['tab_condition'] = None
        intr1['tab_before'] = None
        intr1['tab_after'] = None
        intr1 = DummyIntrospectable(related=(view_intr1,), introspectable=intr1)
        view_intr2 = DummyIntrospectable()
        view_intr2.category_name = 'views'
        view_intr2['name'] = 'name'
        view_intr2['context'] = I2
        view_intr2['derived_callable'] = None
        intr2 = {}
        intr2['tab_title'] = 'Two'
        intr2['tab_condition'] = None
        intr2['tab_before'] = None
        intr2['tab_after'] = None
        intr2 = DummyIntrospectable(related=(view_intr2,), introspectable=intr2)
        request.registry.introspector = DummyIntrospector([(intr1, intr2)])
        context = testing.DummyResource()
        directlyProvides(context, (I2, I1))
        result = self._callFUT(context, request)
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0]['view_name'], 'name')
        self.assertEqual(result[0]['title'], 'Two')

    def test_duplicate_view_names_ordering_context_is_class(self):
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        request.view_name = 'name'
        class MoreDirectContext(testing.DummyResource):
            pass
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'name'
        view_intr1['context'] = MoreDirectContext
        view_intr1['derived_callable'] = None
        intr1 = {}
        intr1['tab_title'] = 'One'
        intr1['tab_condition'] = None
        intr1['tab_before'] = None
        intr1['tab_after'] = None
        intr1 = DummyIntrospectable(related=(view_intr1,), introspectable=intr1)
        view_intr2 = DummyIntrospectable()
        view_intr2.category_name = 'views'
        view_intr2['name'] = 'name'
        view_intr2['context'] = testing.DummyResource
        view_intr2['derived_callable'] = None
        intr2 = {}
        intr2['tab_title'] = 'Two'
        intr2['tab_condition'] = None
        intr2['tab_before'] = None
        intr2['tab_after'] = None
        intr2 = DummyIntrospectable(related=(view_intr2,), introspectable=intr2)
        request.registry.introspector = DummyIntrospector([(intr1, intr2)])
        context = MoreDirectContext()
        result = self._callFUT(context, request)
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0]['view_name'], 'name')
        self.assertEqual(result[0]['title'], 'One')

    def test_duplicate_view_names_ordering_context_iface_doesnt_match(self):
        from zope.interface import Interface
        class I1(Interface): pass
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        request.view_name = 'name'
        class MoreDirectContext(testing.DummyResource):
            pass
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'name'
        view_intr1['context'] = MoreDirectContext
        view_intr1['derived_callable'] = None
        intr1 = {}
        intr1['tab_title'] = 'One'
        intr1['tab_condition'] = None
        intr1['tab_before'] = None
        intr1['tab_after'] = None
        intr1 = DummyIntrospectable(related=(view_intr1,), introspectable=intr1)
        view_intr2 = DummyIntrospectable()
        view_intr2.category_name = 'views'
        view_intr2['name'] = 'name'
        view_intr2['context'] = I1
        view_intr2['derived_callable'] = None
        intr2 = {}
        intr2['tab_title'] = 'Two'
        intr2['tab_condition'] = None
        intr2['tab_before'] = None
        intr2['tab_after'] = None
        intr2 = DummyIntrospectable(related=(view_intr2,), introspectable=intr2)
        request.registry.introspector = DummyIntrospector([(intr1, intr2)])
        context = MoreDirectContext()
        result = self._callFUT(context, request)
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0]['view_name'], 'name')
        self.assertEqual(result[0]['title'], 'One')

    def test_duplicate_view_names_ordering_context_neither_iface_nor_cls_match(
        self):
        from zope.interface import Interface
        class I1(Interface): pass
        request = testing.DummyRequest()
        request.matched_route = None
        request.sdiapi = DummySDIAPI()
        request.registry.content = DummyContent()
        request.view_name = 'name'
        class MoreDirectContext(object):
            pass
        view_intr1 = DummyIntrospectable()
        view_intr1.category_name = 'views'
        view_intr1['name'] = 'name'
        view_intr1['context'] = MoreDirectContext
        view_intr1['derived_callable'] = None
        intr1 = {}
        intr1['tab_title'] = 'One'
        intr1['tab_condition'] = None
        intr1['tab_before'] = None
        intr1['tab_after'] = None
        intr1 = DummyIntrospectable(related=(view_intr1,), introspectable=intr1)
        view_intr2 = DummyIntrospectable()
        view_intr2.category_name = 'views'
        view_intr2['name'] = 'name'
        view_intr2['context'] = I1
        view_intr2['derived_callable'] = None
        intr2 = {}
        intr2['tab_title'] = 'Two'
        intr2['tab_condition'] = None
        intr2['tab_before'] = None
        intr2['tab_after'] = None
        intr2 = DummyIntrospectable(related=(view_intr2,), introspectable=intr2)
        request.registry.introspector = DummyIntrospector([(intr1, intr2)])
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(len(result), 0)
        
class Test_default_sdi_addable(unittest.TestCase):
    def _callFUT(self, context, intr):
        from .. import default_sdi_addable
        return default_sdi_addable(context, intr)

    def test_is_service_with_service_name_in_context(self):
        context = {'catalog':True}
        intr = {'meta':{'is_service':True, 'service_name':'catalog'}}
        self.assertFalse(self._callFUT(context, intr))
                         
    def test_is_service_with_service_name_not_in_context(self):
        context = {}
        intr = {'meta':{'is_service':True, 'service_name':'catalog'}}
        self.assertTrue(self._callFUT(context, intr))
    
    def test_is_service_without_service_name(self):
        context = {'catalog':True}
        intr = {'meta':{'is_service':True}}
        self.assertTrue(self._callFUT(context, intr))

    def test_is_not_service(self):
        context = {'catalog':True}
        intr = {'meta':{}}
        self.assertTrue(self._callFUT(context, intr))

class Test_user(unittest.TestCase):
    def _callFUT(self, request):
        from .. import user
        return user(request)

    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def test_userid_is_None(self):
        self.config.testing_securitypolicy(permissive=False)
        request = testing.DummyRequest()
        self.assertEqual(self._callFUT(request), None)

    def test_userid_is_not_None(self):
        from ...interfaces import IFolder
        self.config.testing_securitypolicy(permissive=True, userid='fred')
        request = testing.DummyRequest()
        context = testing.DummyResource(__provides__=IFolder)
        objectmap = testing.DummyResource()
        objectmap.object_for = lambda *arg: 'foo'
        context.__objectmap__ = objectmap
        request.context = context
        self.assertEqual(self._callFUT(request), 'foo')

class Test_sdiapi(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()
        self.config.include('pyramid_chameleon')

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self, request):
        from .. import sdiapi
        return sdiapi(request)

    def test_conforms_to_ISDIAPI(self):
        from zope.interface.verify import verifyClass
        from ...interfaces import ISDIAPI
        from .. import sdiapi
        verifyClass(ISDIAPI, sdiapi)

    def test_main_template(self):
        self.config.testing_securitypolicy(permissive=False)
        request = testing.DummyRequest()
        inst = self._makeOne(request)
        with testing.testConfig() as config:
            config.include('pyramid_chameleon')
            self.assertTrue(inst.main_template)

    def test_flash_with_undo_no_permission(self):
        self.config.testing_securitypolicy(permissive=False)
        request = testing.DummyRequest()
        inst = self._makeOne(request)
        connection = DummyConnection()
        inst.get_connection = lambda *arg: connection
        inst.transaction = DummyTransaction()
        inst.flash_with_undo('message')
        self.assertEqual(request.session['_f_info'], ['message'])
        self.assertFalse(inst.transaction.notes)

    def test_flash_with_undo_db_doesnt_support_undo(self):
        self.config.testing_securitypolicy(permissive=True)
        request = testing.DummyRequest()
        inst = self._makeOne(request)
        connection = DummyConnection(supports_undo=False)
        inst.get_connection = lambda *arg: connection
        inst.transaction = DummyTransaction()
        inst.flash_with_undo('message')
        self.assertEqual(request.session['_f_info'], ['message'])
        self.assertFalse(inst.transaction.notes)

    def test_flash_with_undo_gardenpath(self):
        from ..._compat import u
        self.config.testing_securitypolicy(permissive=True)
        request = testing.DummyRequest()
        inst = self._makeOne(request)
        connection = DummyConnection()
        inst.get_connection = lambda *arg: connection
        inst.transaction = DummyTransaction()
        inst.mgmt_path = lambda *arg, **kw: '/mg'
        inst.flash_with_undo('message')
        self.assertEqual(request.session['_f_info'],
                         [u('<span>message <a href="/mg" class="btn btn-xs '
                            'btn-info">Undo</a></span>\n')])
        self.assertTrue(inst.transaction.notes)

    def test_flash_gardenpath(self):
        request = testing.DummyRequest()
        inst = self._makeOne(request)
        inst.flash('message')
        self.assertEqual(request.session['_f_info'], ['message'])

    def test_flash_gardenpath_altqueue(self):
        request = testing.DummyRequest()
        inst = self._makeOne(request)
        inst.flash('message', 'danger')
        self.assertEqual(request.session['_f_danger'], ['message'])

    def test_flash_error_converted_to_danger(self):
        request = testing.DummyRequest()
        inst = self._makeOne(request)
        inst.flash('message', 'error')
        self.assertEqual(request.session['_f_danger'], ['message'])
        
    def test_mgmt_path(self):
        from .. import MANAGE_ROUTE_NAME
        request = testing.DummyRequest()
        context = testing.DummyResource()
        def resource_path(resource, *arg, **kw):
            self.assertEqual(arg, ('a',))
            self.assertEqual(kw, {'b':1, 'route_name':MANAGE_ROUTE_NAME})
            return '/path'
        request.resource_path = resource_path
        inst = self._makeOne(request)
        result = inst.mgmt_path(context, 'a', b=1)
        self.assertEqual(result, '/path')

    def test_mgmt_path_with_alt_route_name(self):
        route_name = 'foo'
        request = testing.DummyRequest()
        context = testing.DummyResource()
        def resource_path(resource, *arg, **kw):
            self.assertEqual(arg, ('a',))
            self.assertEqual(kw, {'b':1, 'route_name':route_name})
            return '/path'
        request.resource_path = resource_path
        inst = self._makeOne(request)
        result = inst.mgmt_path(context, 'a', b=1, route_name=route_name)
        self.assertEqual(result, '/path')
        
    def test_mgmt_url(self):
        from .. import MANAGE_ROUTE_NAME
        request = testing.DummyRequest()
        context = testing.DummyResource()
        def resource_url(resource, *arg, **kw):
            self.assertEqual(arg, ('a',))
            self.assertEqual(kw, {'b':1, 'route_name':MANAGE_ROUTE_NAME})
            return 'http://example.com/path'
        request.resource_url = resource_url
        inst = self._makeOne(request)
        result = inst.mgmt_url(context, 'a', b=1)
        self.assertEqual(result, 'http://example.com/path')

    def test_mgmt_url_with_alt_route_name(self):
        route_name = 'foo'
        request = testing.DummyRequest()
        context = testing.DummyResource()
        def resource_url(resource, *arg, **kw):
            self.assertEqual(arg, ('a',))
            self.assertEqual(kw, {'b':1, 'route_name':route_name})
            return 'http://example.com/path'
        request.resource_url = resource_url
        inst = self._makeOne(request)
        result = inst.mgmt_url(context, 'a', b=1, route_name=route_name)
        self.assertEqual(result, 'http://example.com/path')
        
    def test_breadcrumbs_no_permissions(self):
        self.config.testing_securitypolicy(permissive=False)
        resource = testing.DummyResource()
        request = testing.DummyRequest()
        request.context = resource
        inst = self._makeOne(request)
        result = inst.breadcrumbs()
        self.assertEqual(result, [])
        
    def test_breadcrumbs_with_permissions(self):
        self.config.testing_securitypolicy(permissive=True)
        resource = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.context = resource
        request.registry.content = DummyContent()
        inst = self._makeOne(request)
        result = inst.breadcrumbs()
        self.assertEqual(
            result,
             [{'url': '/mgmt_path',
               'active': 'active',
               'content_type':'Type',
               'name': 'Home',
               'icon': None}]
            )

    def test_breadcrumbs_with_sdi_title(self):
        self.config.testing_securitypolicy(permissive=True)
        resource = testing.DummyResource()
        resource.sdi_title = 'foo'
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.context = resource
        request.registry.content = DummyContent()
        inst = self._makeOne(request)
        result = inst.breadcrumbs()
        self.assertEqual(
            result,
             [{'url': '/mgmt_path',
               'active': 'active',
               'content_type':'Type',
               'name': 'foo',
               'icon': None}]
            )
    def test_breadcrumbs_with_vroot(self):
        self.config.testing_securitypolicy(permissive=True)
        resource = testing.DummyResource()
        second = testing.DummyResource()
        second.__parent__ = resource
        second.__name__ = 'second'
        request = testing.DummyRequest()
        request.virtual_root = second
        request.sdiapi = DummySDIAPI()
        request.context = second
        request.registry.content = DummyContent()
        inst = self._makeOne(request)
        result = inst.breadcrumbs()
        self.assertEqual(
            result,
             [{'url': '/mgmt_path',
               'active': 'active',
               'name': 'second',
               'content_type':'Type',
               'icon': None}]
            )
        
    def test_sdi_title_exists(self):
        resource = testing.DummyResource()
        resource.sdi_title = 'My Title'
        request = testing.DummyRequest()
        request.context = resource
        inst = self._makeOne(request)
        result = inst.sdi_title()
        self.assertEqual(result, 'My Title')

    def test_sdi_title_missing(self):
        resource = testing.DummyResource()
        request = testing.DummyRequest()
        request.context = resource
        inst = self._makeOne(request)
        result = inst.sdi_title()
        self.assertEqual(result, 'Substance D')

    def test_mgmt_views(self):
        resource = testing.DummyResource()
        request = testing.DummyRequest()
        request.context = resource
        inst = self._makeOne(request)
        inst.sdi_mgmt_views = lambda *arg, **kw: True
        self.assertEqual(inst.mgmt_views(resource), True)

    def test_get_macro_without_name(self):
        request = testing.DummyRequest()
        inst = self._makeOne(request)
        with testing.testConfig() as config:
            config.include('pyramid_chameleon')
            macro = inst.get_macro('substanced.sdi.views:templates/master.pt')
        self.assertTrue(macro.macros)
        
    def test_get_macro_with_name(self):
        request = testing.DummyRequest()
        inst = self._makeOne(request)
        with testing.testConfig() as config:
            config.include('pyramid_chameleon')
            macro = inst.get_macro(
                'substanced.sdi.views:templates/master.pt', 'main')
        self.assertTrue(macro.include)

    def test_is_mgmt_true(self):
        request = testing.DummyRequest()
        request.matched_route = Dummy()
        request.matched_route.name = 'substanced_manage'
        inst = self._makeOne(request)
        self.assertTrue(inst.is_mgmt())
        
    def test_is_mgmt_false_wrong_name(self):
        request = testing.DummyRequest()
        request.matched_route = Dummy()
        request.matched_route.name = 'not_substanced_manage'
        inst = self._makeOne(request)
        self.assertFalse(inst.is_mgmt())

    def test_is_mgmt_false_missing_matched_route(self):
        request = testing.DummyRequest()
        inst = self._makeOne(request)
        self.assertFalse(inst.is_mgmt())
        
class Test_mgmt_path(unittest.TestCase):
    def _callFUT(self, *arg, **kw):
        from .. import mgmt_path
        return mgmt_path(*arg, **kw)

    def test_it(self):
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        result = self._callFUT(request, None)
        self.assertEqual(result, '/mgmt_path')

class Test_mgmt_url(unittest.TestCase):
    def _callFUT(self, *arg, **kw):
        from .. import mgmt_url
        return mgmt_url(*arg, **kw)

    def test_it(self):
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        result = self._callFUT(request, None)
        self.assertEqual(result, 'http://mgmt_url')

class Test_flash_with_undo(unittest.TestCase):
    def _callFUT(self, *arg, **kw):
        from .. import flash_with_undo
        return flash_with_undo(*arg, **kw)

    def test_it(self):
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        self._callFUT(request, 'a')
        self.assertEqual(request.sdiapi.flashed, 'a')

class Test__bwcompat_kw(unittest.TestCase):
    def _callFUT(self, kw):
        from .. import _bwcompat_kw
        return _bwcompat_kw(kw)

    def test_call_with_all(self):
        kw = {
            '_query':'query',
            '_anchor':'anchor',
            '_app_url':'app_url',
            '_host':'host',
            '_scheme':'scheme',
            '_port':'port'
            }
        result = self._callFUT(kw)
        self.assertEqual(
            result,
            {
                'query':'query',
                'anchor':'anchor',
                'app_url':'app_url',
                'host':'host',
                'scheme':'scheme',
                'port':'port'
                }
            )
        

class DummyContent(object):
    def __init__(self, **kw):
        self.__dict__.update(kw)
        
    def metadata(self, context, name, default=None):
        return getattr(self, name, default)

    def typeof(self, resource):
        return 'Type'

class DummyIntrospector(object):
    def __init__(self, results=()):
        self.results = list(results)
        
    def get_category(self, *arg):
        if self.results:
            return self.results.pop(0)
        return ()

class DummyVenusianInfo(object):
    scope = None
    codeinfo = None
    module = None
    def __init__(self, **kw):
        self.__dict__.update(kw)
    
class DummyVenusian(object):
    def __init__(self, info=None):
        if info is None:
            info = DummyVenusianInfo()
        self.info = info
        
    def attach(self, wrapped, callback, category):
        self.wrapped = wrapped
        self.callback = callback
        self.category = category
        return self.info

class DummyPredicateList(object):
    def make(self, config, **pvals):
        return 1, (), 'hash'

class DummyConfigurator(object):
    _ainfo = None
    def __init__(self):
        self._intr = DummyIntrospectable()
        self._actions = []
        self._added = None
        self.get_predlist = lambda *arg: DummyPredicateList()

    def object_description(self, ob):
        return ob
        
    def maybe_dotted(self, thing):
        return thing

    def add_view(self, **kw):
        self._added = kw

    def add_mgmt_view(self, view=None, **settings):
        self.view = view
        self.settings = settings

    def with_package(self, other):
        return self

    def introspectable(self, category, discrim, desc, name):
        self.desc = desc
        return self._intr

    def action(self, discriminator, introspectables):
        self._actions.append((discriminator, introspectables))
    
class DummyIntrospectable(dict):
    def __init__(self, **kw):
        dict.__init__(self, **kw)
        self.related = {}
        
    def relate(self, category, discrim):
        self.related[category] = discrim

class Dummy(object):
    pass

class DummyDB(object):
    def __init__(self, supports_undo, undo_info, undo_exc=None):
        self.supports_undo = supports_undo
        self.undo_info = undo_info
        self.undone = []
        self.undo_exc = undo_exc

    def supportsUndo(self):
        return self.supports_undo

class DummyConnection(object):
    def __init__(self, supports_undo=True, undo_info=(), undo_exc=None):
        self._db = DummyDB(supports_undo, undo_info, undo_exc)

    def db(self):
        return self._db

class DummyTransaction(object):
    def __init__(self):
        self.notes = []
        
    def get(self):
        return self

    def note(self, note):
        self.notes.append(note)

    def setExtendedInfo(self, name, value):
        self.extinfo = (name, value)

class DummySDIAPI(object):
    def __init__(self, result=None):
        self.result = result
        
    def mgmt_path(self, obj, *arg, **kw):
        return self.result or '/mgmt_path'

    def mgmt_url(self, obj, *arg, **kw):
        return self.result or 'http://mgmt_url'

    def flash_with_undo(self, val):
        self.flashed = val
    

########NEW FILE########
__FILENAME__ = acl
import logging

from pyramid.security import (
    NO_PERMISSION_REQUIRED,
    ALL_PERMISSIONS,
    DENY_ALL,
    Deny,
    Everyone,
    Authenticated,
    )
from pyramid.compat import is_nonstr_iter
from pyramid.session import check_csrf_token
from pyramid.view import view_defaults
from pyramid.location import lineage

from ...objectmap import find_objectmap
from ...util import (
    get_oid,
    get_acl,
    get_all_permissions,
    set_acl,
    find_service,
    )
from ..._compat import STRING_TYPES
from ...util import _

from .. import mgmt_view

logger = logging.getLogger(__name__)

NO_INHERIT = (Deny, Everyone, ALL_PERMISSIONS)

@view_defaults(name='acl_edit', permission='sdi.change-acls',
               renderer='templates/acl.pt')
class ACLEditViews(object):

    get_all_permissions = staticmethod(get_all_permissions) # for testing

    def __init__(self, context, request):
        self.context = context
        self.request = request
        self.acl = self.original_acl = get_acl(context, [])
        if self.acl and self.acl[-1] == NO_INHERIT:
            self.acl = self.acl[:-1]
            self.epilog = [NO_INHERIT]
        else:
            self.epilog = []

    @mgmt_view(tab_title=_('Security'))
    def acl_view(self):
        return self.finish_acl_edit()

    @mgmt_view(tab_condition=False, name='inherited_acl',
               renderer='templates/acl#inherited_acl.pt')
    def inherited_acl(self):
        return self.finish_acl_edit()

    @mgmt_view(tab_condition=False, name='local_acl', tab_title=_('Security'),
               renderer='templates/acl#local_acl.pt')
    def local_acl(self):
        return self.finish_acl_edit()
    
    @mgmt_view(request_param='form.move_up', tab_title=_('Security'))
    def move_up(self):
        check_csrf_token(self.request)
        index = int(self.request.POST['index'])
        if index > 0:
            new = self.acl[:]
            new[index-1], new[index] = new[index], new[index-1]
            self.acl = new
        self.request.sdiapi.flash_with_undo('ACE moved up', 'success')
        return self.finish_acl_edit()

    @mgmt_view(request_param='form.move_down', tab_title=_('Security'))
    def move_down(self):
        check_csrf_token(self.request)
        index = int(self.request.POST['index'])
        if index < len(self.acl) - 1:
            new = self.acl[:]
            new[index+1], new[index] = new[index], new[index+1]
            self.acl = new
        self.request.sdiapi.flash_with_undo('ACE moved down', 'success')
        return self.finish_acl_edit()

    @mgmt_view(request_param='form.remove', tab_title=_('Security'))
    def remove(self):
        check_csrf_token(self.request)
        index = int(self.request.POST['index'])
        new = self.acl[:]
        del new[index]
        self.acl = new
        self.request.sdiapi.flash_with_undo('ACE removed', 'success')
        return self.finish_acl_edit()

    @mgmt_view(request_param='form.add', tab_title=_('Security'))
    def add(self):
        check_csrf_token(self.request)
        objectmap = find_objectmap(self.context)
        verb = self.request.POST['verb']
        principal_id_str = self.request.POST['principal']
        if principal_id_str in (Everyone, Authenticated):
            principal_id = principal_id_str
        else:
            try:
                principal_id = int(principal_id_str)
            except ValueError:
                principal_id = None
                
        if principal_id is None:
            self.request.sdiapi.flash('No principal selected', 'danger')
            
        else:
            if principal_id not in (Everyone, Authenticated):
                if objectmap.object_for(principal_id) is None:
                    self.request.sdiapi.flash(
                        'Unknown user or group when adding ACE',
                        'danger')
                    principal_id = None
                    
            if principal_id is not None:
                permissions = self.request.POST.getall('permissions')
                if not permissions:
                    permissions = ()
                if '-- ALL --' in permissions:
                    permissions = ALL_PERMISSIONS
                if (verb, principal_id, permissions) == DENY_ALL:
                    if self.context.__parent__ is not None:
                        self.request.sdiapi.flash(
                            'DENY_ALL not supported:  '
                                'select "Disabled" under "Inherit Parent ACL',
                                    'danger')
                    else:
                        self.request.sdiapi.flash(
                            'DENY_ALL not supported at the root', 'danger')
                else:
                    new = self.acl[:]
                    new.append((verb, principal_id, permissions))
                    self.acl = new
                    self.request.sdiapi.flash_with_undo('New ACE added',
                                                        'success')
        return self.finish_acl_edit()
                
    @mgmt_view(request_param='form.inherit', tab_title=_('Security'))
    def inherit(self):
        check_csrf_token(self.request)
        no_inherit = self.request.POST['inherit'] == 'disabled'
        if no_inherit:
            self.epilog = [NO_INHERIT]
            self.request.sdiapi.flash_with_undo(
                'ACL will *not* inherit from parent', 'success')
        else:
            self.epilog = []
            self.request.sdiapi.flash_with_undo(
                'ACL will inherit from parent', 'success')
        return self.finish_acl_edit()

    def get_principal_name(self, principal_id):
        objectmap = find_objectmap(self.context)
        if principal_id  in (Everyone, Authenticated):
            pname = principal_id
        else:
            principal = objectmap.object_for(principal_id)
            if principal is None:
                pname = '<deleted principal>'
            else:
                pname = principal.__name__
        return pname

    def get_parent_acl(self, parent):
        parent_acl = []

        while parent is not None:
            p_acl = get_acl(parent, ())
            stop = False
            for ace in p_acl:
                if ace == NO_INHERIT:
                    stop = True
                else:
                    principal_id = ace[1]
                    pname = self.get_principal_name(principal_id)
                    if ace[2] == ALL_PERMISSIONS:
                        perms =  ('-- ALL --',)
                    else:
                        perms = ace[2]
                    if not is_nonstr_iter(perms):
                        perms = (perms,)
                    new_ace = (ace[0], pname, perms)
                    parent_acl.append(new_ace)
            if stop:
                break
            parent = parent.__parent__
        return parent_acl

    def get_local_acl(self):
        local_acl = []
        inheriting = 'enabled'
        l_acl = get_acl(self.context, ())
        for l_ace in l_acl:
            principal_id = l_ace[1]
            permissions = l_ace[2]
            if l_ace == NO_INHERIT:
                inheriting = 'disabled'
                break
            if permissions == ALL_PERMISSIONS:
                permissions = ('-- ALL --',)
            if (isinstance(permissions, STRING_TYPES) or
                not hasattr(permissions, '__iter__')):
                permissions = (permissions,)
            pname = self.get_principal_name(principal_id)
            new_ace = (l_ace[0], pname, permissions)
            local_acl.append(new_ace)
        return inheriting, local_acl


    def finish_acl_edit(self):
        principal_service = find_service(self.context, 'principals')
        objectmap = find_objectmap(self.context)
        registry = self.request.registry
        self.acl = self.acl + self.epilog

        if self.acl != self.original_acl:
            set_acl(self.context, self.acl, registry=registry)

        parent = self.context.__parent__
        parent_acl = self.get_parent_acl(parent)

        inheriting, local_acl = self.get_local_acl()

        permissions = set(['-- ALL --'])
        registered_permissions = self.get_all_permissions(registry)
        for name in registered_permissions:
            if name != NO_PERMISSION_REQUIRED:
                permissions.add(name)
        permissions = list(permissions)
        permissions.sort()

        users = principal_service['users'].values()
        users = [ (get_oid(user), user.__name__) for user in users ]
        groups = principal_service['groups'].values()
        groups = [ (get_oid(group), group.__name__) for group in groups ]
        groups += [ (Everyone, Everyone), (Authenticated, Authenticated) ]

        oids = [ get_oid(x) for x in lineage(self.context) ]

        pathcount = objectmap.pathcount(self.context)

        return dict(
            parent_acl=parent_acl or (),
            local_acl=local_acl,
            permissions=permissions,
            inheriting=inheriting,
            users=users,
            groups=groups,
            oids=oids,
            pathcount=pathcount,
            )


########NEW FILE########
__FILENAME__ = folder
# b/c shim for old location
from substanced.folder.views import *

########NEW FILE########
__FILENAME__ = login
from pyramid.httpexceptions import (
    HTTPForbidden,
    HTTPFound
    )
from pyramid.renderers import get_renderer
from pyramid.session import check_csrf_token
from pyramid.security import (
    remember,
    forget,
    Authenticated,
    NO_PERMISSION_REQUIRED,
    )

from ...util import get_oid

from .. import mgmt_view

from substanced.interfaces import IUserLocator
from substanced.principal import DefaultUserLocator
from substanced.event import LoggedIn

@mgmt_view(
    name='login',
    renderer='templates/login.pt',
    tab_condition=False,
    permission=NO_PERMISSION_REQUIRED
    )
@mgmt_view(
    renderer='templates/login.pt',
    context=HTTPForbidden,
    permission=NO_PERMISSION_REQUIRED,
    tab_condition=False
    )
@mgmt_view(
    renderer='templates/forbidden.pt',
    context=HTTPForbidden,
    permission=NO_PERMISSION_REQUIRED,
    effective_principals=Authenticated,
    tab_condition=False
    )
def login(context, request):
    login_url = request.sdiapi.mgmt_path(request.context, 'login')
    referrer = request.url
    if '/auditstream-sse' in referrer:
        # If we're being invoked as the result of a failed request to the
        # auditstream sse view, bail.  Otherwise the came_from will be set to
        # the auditstream URL, and the user who this happens to will eventually
        # be redirected to it and they'll be left scratching their head when
        # they see e.g. "id: 0-10\ndata: " when they log in successfully.
        return HTTPForbidden()
    if login_url in referrer:
        # never use the login form itself as came_from
        referrer = request.sdiapi.mgmt_path(request.virtual_root)
    came_from = request.session.setdefault('sdi.came_from', referrer)
    login = ''
    password = ''
    if 'form.submitted' in request.params:
        try:
            check_csrf_token(request)
        except:
            request.sdiapi.flash('Failed login (CSRF)', 'danger')
        else:
            login = request.params['login']
            password = request.params['password']
            adapter = request.registry.queryMultiAdapter(
                (context, request),
                IUserLocator
                )
            if adapter is None:
                adapter = DefaultUserLocator(context, request)
            user = adapter.get_user_by_login(login)
            if user is not None and user.check_password(password):
                request.session.pop('sdi.came_from', None)
                headers = remember(request, get_oid(user))
                request.registry.notify(LoggedIn(login, user, context, request))
                return HTTPFound(location = came_from, headers = headers)
            request.sdiapi.flash('Failed login', 'danger')

    # Pass this through FBO views (e.g., forbidden) which use its macros.
    template = get_renderer('substanced.sdi.views:templates/login.pt'
                           ).implementation()
    return dict(
        url = request.sdiapi.mgmt_path(request.virtual_root, '@@login'),
        came_from = came_from,
        login = login,
        password = password,
        login_template = template,
        )

@mgmt_view(
    name='logout',
    tab_condition=False,
    permission=NO_PERMISSION_REQUIRED
    )
def logout(request):
    headers = forget(request)
    return HTTPFound(location = request.sdiapi.mgmt_path(request.context),
                     headers = headers)

########NEW FILE########
__FILENAME__ = manage
from pyramid.security import NO_PERMISSION_REQUIRED
from pyramid.httpexceptions import (
    HTTPFound,
    HTTPForbidden,
    )

from .. import (
    mgmt_view,
    sdi_mgmt_views,
    )

class ManagementViews(object):
    # these defined as staticmethods only for test overriding
    sdi_mgmt_views = staticmethod(sdi_mgmt_views)
    
    def __init__(self, context, request):
        self.context = context
        self.request = request

    @mgmt_view(
        tab_condition=False,
        permission=NO_PERMISSION_REQUIRED,
        )
    @mgmt_view(
        name='manage_main',
        tab_condition=False,
        permission=NO_PERMISSION_REQUIRED,
        )
    def manage_main(self):
        request = self.request
        view_data = self.sdi_mgmt_views(self.context, request)
        if not view_data:
            request.session['came_from'] = request.url
            raise HTTPForbidden(
                location=request.sdiapi.mgmt_path(
                    request.virtual_root, '@@login')
                )
        view_name = '@@%s' % (view_data[0]['view_name'],)
        return HTTPFound(
            location=request.sdiapi.mgmt_path(request.context, view_name)
            )

########NEW FILE########
__FILENAME__ = test_acl
import unittest

from pyramid import testing

from ...._compat import u
_JOHN = u('john')
_MARY = u('mary')

class TestACLView(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from ..acl import ACLEditViews
        return ACLEditViews(context, request).acl_view

    def test_view(self):
        from ....testing import make_site
        request = testing.DummyRequest()
        site = make_site()
        site['page'] = context = testing.DummyResource()
        context.__oid__ = 5
        site.__acl__ = context.__acl__ = [(None, 1, (None,))]
        user = DummyUser(1, _JOHN)
        site['principals']['users']['john'] = user
        site.__objectmap__ = DummyObjectMap({1:user})
        inst = self._makeOne(context, request)
        resp = inst()
        self.assertEqual(resp['parent_acl'], [(None, _JOHN, (None,))])
        self.assertEqual(resp['users'], [(1, _JOHN)])
        self.assertEqual(resp['groups'], [('system.Everyone',
                                          'system.Everyone'),
                                          ('system.Authenticated',
                                          'system.Authenticated')])
        self.assertEqual(resp['local_acl'], [(None, _JOHN, (None,))])
        self.assertEqual(resp['permissions'], ['-- ALL --'])
        self.assertEqual(resp['inheriting'], 'enabled')

class TestInheritedACL(TestACLView):

    def _makeOne(self, context, request):
        from ..acl import ACLEditViews
        return ACLEditViews(context, request).inherited_acl

class TestLocaldACL(TestACLView):

    def _makeOne(self, context, request):
        from ..acl import ACLEditViews
        return ACLEditViews(context, request).local_acl

class TestMoveUp(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from ..acl import ACLEditViews
        return ACLEditViews(context, request).move_up

    def test_view(self):
        from ....testing import make_site
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        token = request.session.new_csrf_token()
        request.POST['csrf_token'] = token
        request.POST['index'] = 1
        site = make_site()
        site['page'] = context = testing.DummyResource()
        site.__acl__ = [(None, 1, (None,))]
        context.__acl__ = [(None, 1, (None,)),
                           (None, 2, (None,))]
        context.__oid__ = 5
        user = DummyUser(1, _JOHN)
        user2 = DummyUser(2, _MARY)
        site['principals']['users']['john'] = user
        site.__objectmap__ = DummyObjectMap({1:user, 2:user2})
        inst = self._makeOne(context, request)
        resp = inst()
        self.assertEqual(resp['parent_acl'], [(None, _JOHN, (None,))])
        self.assertEqual(resp['users'], [(1, _JOHN)])
        self.assertEqual(resp['groups'], [('system.Everyone',
                                          'system.Everyone'),
                                          ('system.Authenticated',
                                          'system.Authenticated')])
        self.assertEqual(resp['local_acl'], [(None, _MARY, (None,)),
                                             (None, _JOHN, (None,))])
        self.assertEqual(resp['permissions'], ['-- ALL --'])
        self.assertEqual(resp['inheriting'], 'enabled')
        self.assertEqual(request.sdiapi.flashed, 'ACE moved up')

class TestMoveDown(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from ..acl import ACLEditViews
        return ACLEditViews(context, request).move_down

    def test_view(self):
        from ....testing import make_site
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        token = request.session.new_csrf_token()
        request.POST['csrf_token'] = token
        request.POST['index'] = 0
        site = make_site()
        site['page'] = context = testing.DummyResource()
        site.__acl__ = [(None, 1, (None,))]
        context.__acl__ = [(None, 1, (None,)),
                           (None, 2, (None,))]
        context.__oid__ = 5
        user = DummyUser(1, _JOHN)
        user2 = DummyUser(2, _MARY)
        site['principals']['users']['john'] = user
        site.__objectmap__ = DummyObjectMap({1:user, 2:user2})
        inst = self._makeOne(context, request)
        resp = inst()
        self.assertEqual(resp['parent_acl'], [(None, _JOHN, (None,))])
        self.assertEqual(resp['users'], [(1, _JOHN)])
        self.assertEqual(resp['groups'], [('system.Everyone',
                                          'system.Everyone'),
                                          ('system.Authenticated',
                                          'system.Authenticated')])
        self.assertEqual(resp['local_acl'], [(None, _MARY, (None,)),
                                             (None, _JOHN, (None,))])
        self.assertEqual(resp['permissions'], ['-- ALL --'])
        self.assertEqual(resp['inheriting'], 'enabled')
        self.assertEqual(request.sdiapi.flashed, 'ACE moved down')

class TestRemove(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from ..acl import ACLEditViews
        return ACLEditViews(context, request).remove

    def test_view(self):
        from ....testing import make_site
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        token = request.session.new_csrf_token()
        request.POST['csrf_token'] = token
        request.POST['index'] = 0
        site = make_site()
        site['page'] = context = testing.DummyResource()
        site.__acl__ = [(None, 1, (None,))]
        context.__acl__ = [(None, 1, (None,)),
                           (None, 2, (None,))]
        context.__oid__ = 5
        user = DummyUser(1, _JOHN)
        user2 = DummyUser(2, _MARY)
        site['principals']['users']['john'] = user
        site.__objectmap__ = DummyObjectMap({1:user, 2:user2})
        inst = self._makeOne(context, request)
        resp = inst()
        self.assertEqual(resp['parent_acl'], [(None, _JOHN, (None,))])
        self.assertEqual(resp['users'], [(1, _JOHN)])
        self.assertEqual(resp['groups'], [('system.Everyone',
                                          'system.Everyone'),
                                          ('system.Authenticated',
                                          'system.Authenticated')])
        self.assertEqual(resp['local_acl'], [(None, _MARY, (None,))])
        self.assertEqual(resp['permissions'], ['-- ALL --'])
        self.assertEqual(resp['inheriting'], 'enabled')
        self.assertEqual(request.sdiapi.flashed, 'ACE removed')

class TestAdd(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from ..acl import ACLEditViews
        return ACLEditViews(context, request).add

    def test_add(self):
        from ....testing import make_site
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST = DummyPost(getall_result=('test',))
        token = request.session.get_csrf_token()
        request.params['csrf_token'] = token
        request.POST['verb'] = 'Allow'
        request.POST['principal'] = '1'
        request.POST['permissions'] = 'test'
        site = make_site()
        site['page'] = context = testing.DummyResource()
        site.__acl__ = [(None, 1, (None,))]
        context.__acl__ = [(None, 1, (None,)),
                           (None, 2, (None,))]
        context.__oid__ = 5
        user = DummyUser(1, _JOHN)
        user2 = DummyUser(2, _MARY)
        site['principals']['users']['john'] = user
        site.__objectmap__ = DummyObjectMap({1:user, 2:user2})
        inst = self._makeOne(context, request)
        resp = inst()
        self.assertEqual(resp['parent_acl'], [(None, _JOHN, (None,))])
        self.assertEqual(resp['users'], [(1, _JOHN)])
        self.assertEqual(resp['groups'], [('system.Everyone',
                                          'system.Everyone'),
                                          ('system.Authenticated',
                                          'system.Authenticated')])
        self.assertEqual(resp['local_acl'], [(None, _JOHN, (None,)),
                                             (None, _MARY, (None,)),
                                             ('Allow', _JOHN, ('test',))])
        self.assertEqual(resp['permissions'], ['-- ALL --'])
        self.assertEqual(resp['inheriting'], 'enabled')
        self.assertEqual(request.sdiapi.flashed, 'New ACE added')

    def test_add_no_principal_selected(self):
        from ....testing import make_site
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST = DummyPost(getall_result=('test',))
        token = request.session.get_csrf_token()
        request.params['csrf_token'] = token
        request.POST['verb'] = 'Allow'
        request.POST['principal'] = ''
        request.POST['permissions'] = 'test'
        site = make_site()
        site['page'] = context = testing.DummyResource()
        site.__acl__ = [(None, 1, (None,))]
        context.__acl__ = [(None, 1, (None,)),
                           (None, 2, (None,))]
        context.__oid__ = 5
        user = DummyUser(1, _JOHN)
        user2 = DummyUser(2, _MARY)
        site['principals']['users']['john'] = user
        site.__objectmap__ = DummyObjectMap({1:user, 2:user2})
        inst = self._makeOne(context, request)
        resp = inst()
        self.assertEqual(resp['parent_acl'], [(None, _JOHN, (None,))])
        self.assertEqual(resp['users'], [(1, _JOHN)])
        self.assertEqual(resp['groups'], [('system.Everyone',
                                          'system.Everyone'),
                                          ('system.Authenticated',
                                          'system.Authenticated')])
        self.assertEqual(resp['local_acl'], [(None, _JOHN, (None,)),
                                             (None, _MARY, (None,))])
        self.assertEqual(resp['permissions'], ['-- ALL --'])
        self.assertEqual(resp['inheriting'], 'enabled')
        self.assertEqual(request.sdiapi.flashed, 'No principal selected')

    def test_add_puns_DENY_ALL_root(self):
        from ....testing import make_site
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST = DummyPost(getall_result=('-- ALL --',))
        token = request.session.get_csrf_token()
        request.params['csrf_token'] = token
        request.POST['verb'] = 'Deny'
        request.POST['principal'] = 'system.Everyone'
        request.POST['permissions'] = '-- ALL --'
        site = make_site()
        site.__acl__ = [(None, 1, (None,)),
                           (None, 2, (None,))]
        user = DummyUser(1, _JOHN)
        user2 = DummyUser(2, _MARY)
        site['principals']['users']['john'] = user
        site.__objectmap__ = DummyObjectMap({1:user, 2:user2})
        inst = self._makeOne(site, request)
        resp = inst()
        self.assertEqual(resp['parent_acl'], ())
        self.assertEqual(resp['users'], [(1, _JOHN)])
        self.assertEqual(resp['groups'], [('system.Everyone',
                                          'system.Everyone'),
                                          ('system.Authenticated',
                                          'system.Authenticated')])
        self.assertEqual(resp['local_acl'], [(None, _JOHN, (None,)),
                                             (None, _MARY, (None,))])
        self.assertEqual(resp['permissions'], ['-- ALL --'])
        self.assertEqual(resp['inheriting'], 'enabled')
        self.assertEqual(request.sdiapi.flashed,
                         'DENY_ALL not supported at the root')

    def test_add_puns_DENY_ALL_non_root(self):
        from ....testing import make_site
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST = DummyPost(getall_result=('-- ALL --',))
        token = request.session.get_csrf_token()
        request.params['csrf_token'] = token
        request.POST['verb'] = 'Deny'
        request.POST['principal'] = 'system.Everyone'
        request.POST['permissions'] = '-- ALL --'
        site = make_site()
        site['page'] = context = testing.DummyResource()
        site.__acl__ = [(None, 1, (None,))]
        context.__acl__ = [(None, 1, (None,)),
                           (None, 2, (None,))]
        context.__oid__ = 5
        user = DummyUser(1, _JOHN)
        user2 = DummyUser(2, _MARY)
        site['principals']['users']['john'] = user
        site.__objectmap__ = DummyObjectMap({1:user, 2:user2})
        inst = self._makeOne(context, request)
        resp = inst()
        self.assertEqual(resp['parent_acl'], [(None, _JOHN, (None,))])
        self.assertEqual(resp['users'], [(1, _JOHN)])
        self.assertEqual(resp['groups'], [('system.Everyone',
                                          'system.Everyone'),
                                          ('system.Authenticated',
                                          'system.Authenticated')])
        self.assertEqual(resp['local_acl'], [(None, _JOHN, (None,)),
                                             (None, _MARY, (None,))])
        self.assertEqual(resp['permissions'], ['-- ALL --'])
        self.assertEqual(resp['inheriting'], 'enabled')
        self.assertEqual(request.sdiapi.flashed,
                         'DENY_ALL not supported:  '
                                'select "Disabled" under "Inherit Parent ACL')

    def test_add_unknown_user(self):
        from ....testing import make_site
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST = DummyPost(getall_result=('test',))
        token = request.session.get_csrf_token()
        request.params['csrf_token'] = token
        request.POST['verb'] = 'Allow'
        request.POST['principal'] = '3'
        request.POST['permissions'] = 'test'
        site = make_site()
        site['page'] = context = testing.DummyResource()
        site.__acl__ = [(None, 1, (None,))]
        context.__acl__ = [(None, 1, (None,)),
                           (None, 2, (None,))]
        context.__oid__ = 5
        user = DummyUser(1, _JOHN)
        user2 = DummyUser(2, _MARY)
        site['principals']['users']['john'] = user
        site.__objectmap__ = DummyObjectMap({1:user, 2:user2})
        inst = self._makeOne(context, request)
        resp = inst()
        self.assertEqual(resp['parent_acl'], [(None, _JOHN, (None,))])
        self.assertEqual(resp['users'], [(1, _JOHN)])
        self.assertEqual(resp['groups'], [('system.Everyone',
                                          'system.Everyone'),
                                          ('system.Authenticated',
                                          'system.Authenticated')])
        self.assertEqual(resp['local_acl'], [(None, _JOHN, (None,)),
                                             (None, _MARY, (None,))])
        self.assertEqual(resp['permissions'], ['-- ALL --'])
        self.assertEqual(resp['inheriting'], 'enabled')
        self.assertEqual(request.sdiapi.flashed,
                         'Unknown user or group when adding ACE')

    def test_add_no_permission(self):
        from ....testing import make_site
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST = DummyPost(getall_result=None)
        token = request.session.get_csrf_token()
        request.params['csrf_token'] = token
        request.POST['verb'] = 'Allow'
        request.POST['principal'] = '1'
        request.POST['permissions'] = 'test'
        site = make_site()
        context = site['page'] = testing.DummyResource()
        site.__acl__ = [(None, 1, (None,))]
        context.__acl__ = [(None, 1, (None,)),
                           (None, 2, (None,))]
        context.__oid__ = 5
        user = DummyUser(1, _JOHN)
        site['principals']['users']['john'] = user
        site.__objectmap__ = DummyObjectMap({1:user})
        inst = self._makeOne(context, request)
        resp = inst()
        self.assertEqual(context.__acl__[-1], ('Allow', 1, ()))
        self.assertEqual(resp['inheriting'], 'enabled')
        self.assertEqual(request.sdiapi.flashed, 'New ACE added')

    def test_add_all_permissions(self):
        from pyramid.security import ALL_PERMISSIONS
        from ....testing import make_site
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST = DummyPost(getall_result=('-- ALL --,'))
        token = request.session.get_csrf_token()
        request.params['csrf_token'] = token
        request.POST['verb'] = 'Allow'
        request.POST['principal'] = '1'
        request.POST['permissions'] = 'test'
        site = make_site()
        context = site['page'] = testing.DummyResource()
        site.__acl__ = [(None, 1, (None,))]
        context.__acl__ = [(None, 1, (None,)),
                           (None, 2, (None,))]
        context.__oid__ = 5
        user = DummyUser(1, _JOHN)
        site['principals']['users']['john'] = user
        site.__objectmap__ = DummyObjectMap({1:user})
        inst = self._makeOne(context, request)
        resp = inst()
        self.assertEqual(context.__acl__[-1], ('Allow', 1, ALL_PERMISSIONS))
        self.assertEqual(resp['inheriting'], 'enabled')
        self.assertEqual(request.sdiapi.flashed, 'New ACE added')

    def test_add_Everyone(self):
        from pyramid.security import Everyone
        from ....testing import make_site
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST = DummyPost(getall_result=('view'))
        token = request.session.get_csrf_token()
        request.params['csrf_token'] = token
        request.POST['verb'] = 'Allow'
        request.POST['principal'] = Everyone
        request.POST['permissions'] = 'test'
        site = make_site()
        context = site['pagge'] = testing.DummyResource()
        context.__oid__ = 5
        context.__acl__ = []
        context.__objectmap__ = DummyObjectMap({})
        inst = self._makeOne(context, request)
        resp = inst()
        self.assertEqual(context.__acl__[-1], ('Allow', Everyone, 'view'))
        self.assertEqual(resp['inheriting'], 'enabled')
        self.assertEqual(request.sdiapi.flashed, 'New ACE added')

class TestInherit(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from ..acl import ACLEditViews
        return ACLEditViews(context, request).inherit

    def test_inherit_enabled(self):
        from ....testing import make_site
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        token = request.session.new_csrf_token()
        request.POST['csrf_token'] = token
        request.POST['inherit'] = 'enabled'
        site = make_site()
        site['page'] = context = testing.DummyResource()
        site.__acl__ = [(None, 1, (None,))]
        context.__acl__ = [(None, 1, (None,)),
                           (None, 2, (None,))]
        context.__oid__ = 5
        user = DummyUser(1, _JOHN)
        user2 = DummyUser(2, _MARY)
        site['principals']['users']['john'] = user
        site.__objectmap__ = DummyObjectMap({1:user, 2:user2})
        inst = self._makeOne(context, request)
        resp = inst()
        self.assertEqual(resp['parent_acl'], [(None, _JOHN, (None,))])
        self.assertEqual(resp['users'], [(1, _JOHN)])
        self.assertEqual(resp['groups'], [('system.Everyone',
                                          'system.Everyone'),
                                          ('system.Authenticated',
                                          'system.Authenticated')])
        self.assertEqual(resp['local_acl'], [(None, _JOHN, (None,)),
                                             (None, _MARY, (None,))])
        self.assertEqual(resp['permissions'], ['-- ALL --'])
        self.assertEqual(resp['inheriting'], 'enabled')
        self.assertEqual(request.sdiapi.flashed,
                         'ACL will inherit from parent')

    def test_inherit_disabled(self):
        from ....testing import make_site
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        token = request.session.new_csrf_token()
        request.POST['csrf_token'] = token
        request.POST['inherit'] = 'disabled'
        site = make_site()
        site['page'] = context = testing.DummyResource()
        site.__acl__ = [(None, 1, (None,))]
        context.__acl__ = [(None, 1, (None,)),
                           (None, 2, (None,))]
        context.__oid__ = 5
        user = DummyUser(1, _JOHN)
        user2 = DummyUser(2, _MARY)
        site['principals']['users']['john'] = user
        site.__objectmap__ = DummyObjectMap({1:user, 2:user2})
        inst = self._makeOne(context, request)
        resp = inst()
        self.assertEqual(resp['parent_acl'], [(None, _JOHN, (None,))])
        self.assertEqual(resp['users'], [(1, _JOHN)])
        self.assertEqual(resp['groups'], [('system.Everyone',
                                          'system.Everyone'),
                                          ('system.Authenticated',
                                          'system.Authenticated')])
        self.assertEqual(resp['local_acl'], [(None, _JOHN, (None,)),
                                             (None, _MARY, (None,))])
        self.assertEqual(resp['permissions'], ['-- ALL --'])
        self.assertEqual(resp['inheriting'], 'disabled')
        self.assertEqual(request.sdiapi.flashed,
                         'ACL will *not* inherit from parent')

class TestOther(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from ..acl import ACLEditViews
        return ACLEditViews(context, request)

    def _makeSite(self):
        from ....testing import make_site
        site = make_site()
        context = testing.DummyResource()
        context.__oid__ = 5
        site['context'] = context
        return site

    def test_finish_acl_edit_with_registered_permissions(self):
        from pyramid.security import NO_PERMISSION_REQUIRED
        request = testing.DummyRequest()
        site = self._makeSite()
        context = site['context']
        context.__acl__ = []
        context.__objectmap__ = DummyObjectMap({})
        inst = self._makeOne(context, request)
        inst.get_all_permissions = lambda *arg: [NO_PERMISSION_REQUIRED,'view']
        result = inst.finish_acl_edit()
        self.assertEqual(result['permissions'], ['-- ALL --', 'view'])

    def test_get_local_acl_with_no_inherit(self):
        request = testing.DummyRequest()
        site = self._makeSite()
        context = site['context']
        from ..acl import NO_INHERIT
        context.__acl__ = [NO_INHERIT]
        inst = self._makeOne(context, request)
        result = inst.get_local_acl()
        self.assertEqual(result, ('disabled', []))

    def test_get_local_acl_with_all_permissions(self):
        from pyramid.security import ALL_PERMISSIONS, Allow
        request = testing.DummyRequest()
        site = self._makeSite()
        user = testing.DummyResource()
        user.__name__ = 'fred'
        site.__objectmap__ = DummyObjectMap({1:user})
        context = site['context']
        context.__acl__ = [ (Allow, 1, ALL_PERMISSIONS),
                            (Allow, 1, 'view') ]
        inst = self._makeOne(context, request)
        result = inst.get_local_acl()
        self.assertEqual(
            result,
            ('enabled',
             [('Allow', 'fred', ('-- ALL --',)),
              ('Allow', 'fred', ('view',)),
             ])
            )

    def test_get_parent_acl_with_no_inherit(self):
        from ..acl import NO_INHERIT
        request = testing.DummyRequest()
        context = testing.DummyResource()
        context.__acl__ = [ NO_INHERIT ]
        context.__parent__ = None
        inst = self._makeOne(context, request)
        result = inst.get_parent_acl(context)
        self.assertEqual(result, [])

    def test_get_parent_acl_with_noniter_permission(self):
        from pyramid.security import Allow
        request = testing.DummyRequest()
        context = testing.DummyResource()
        context.__acl__ = [(Allow, 1, 'edit')]
        context.__parent__ = None
        inst = self._makeOne(context, request)
        user = testing.DummyResource()
        user.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap({1:user})
        result = inst.get_parent_acl(context)
        self.assertEqual(result, [(Allow, 'fred', ('edit',))])

    def test_get_parent_acl_with_all_permissions(self):
        from pyramid.security import Allow, ALL_PERMISSIONS
        request = testing.DummyRequest()
        context = testing.DummyResource()
        context.__acl__ = [ (Allow, 1, ALL_PERMISSIONS) ]
        context.__parent__ = None
        inst = self._makeOne(context, request)
        user = testing.DummyResource()
        user.__name__ = 'fred'
        context.__objectmap__ = DummyObjectMap({1:user})
        result = inst.get_parent_acl(context)
        self.assertEqual(result, [(Allow, 'fred', ('-- ALL --',))])

    def test_get_principal_name_deleted_principal(self):
        request = testing.DummyRequest()
        context = testing.DummyResource()
        context.__parent__ = None
        inst = self._makeOne(context, request)
        context.__objectmap__ = DummyObjectMap({1:None})
        result = inst.get_principal_name(1)
        self.assertEqual(result, '<deleted principal>')

    def test_get_principal_name_Everyone(self):
        from pyramid.security import Everyone
        request = testing.DummyRequest()
        context = testing.DummyResource()
        context.__parent__ = None
        inst = self._makeOne(context, request)
        context.__objectmap__ = DummyObjectMap({1:Everyone})
        result = inst.get_principal_name(Everyone)
        self.assertEqual(result, Everyone)

class DummyUser(object):
    def __init__(self, oid, name):
        self.__oid__ = oid
        self.__name__ = name

class DummyPost(dict):
    def __init__(self, getall_result=(), get_result=None):
        self.getall_result = getall_result
        self.get_result = get_result

    def getall(self, name): # pragma: no cover
        return self.getall_result

    def get(self, name, default=None): # pragma: no cover
        if self.get_result is None: 
            return default
        return self.get_result

class DummyObjectMap(object):
    def __init__(self, objectmap):
        self.objectmap = objectmap
    def object_for(self, oid):
        return self.objectmap.get(oid, None)
    def pathcount(self, context):
        return 0

class DummySDIAPI(object):
    def flash(self, message, queue='info'):
        self.flashed = message
    flash_with_undo = flash


########NEW FILE########
__FILENAME__ = test_login
import unittest
from pyramid import testing

class Test_logout(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _callFUT(self, request):
        from ..login import logout
        return logout(request)

    def test_it(self):
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        response = self._callFUT(request)
        self.assertEqual(response.location, '/mgmt_path')

class Test_login(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _callFUT(self, context, request):
        from ..login import login
        return login(context, request)

    def test_referrer_is_auditstream(self):
        from pyramid.httpexceptions import HTTPForbidden
        request = testing.DummyRequest()
        request.url = '/auditstream-sse'
        request.sdiapi = DummySDIAPI()
        context = testing.DummyResource()
        result = self._callFUT(context, request)
        self.assertEqual(result.__class__, HTTPForbidden)

    def test_referrer_is_login_view(self):
        from pyramid.testing import testConfig
        request = testing.DummyRequest()
        request.url = '/mgmt_path'
        request.sdiapi = DummySDIAPI()
        context = testing.DummyResource()
        with testConfig() as config:
            config.testing_add_renderer(
                    'substanced.sdi.views:templates/login.pt')
            result = self._callFUT(context, request)
        self.assertEqual(result['url'], '/mgmt_path')
        self.assertEqual(result['came_from'], '/mgmt_path')
        self.assertEqual(result['login'], '')
        self.assertEqual(result['password'], '')
        self.assertEqual(request.session['sdi.came_from'], '/mgmt_path')
        
    def test_form_not_submitted(self):
        from pyramid.testing import testConfig
        class DummyRenderer(object):
            def __init__(self, macros):
                self.macros = macros
            def implementation(self):
                return self
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        context = testing.DummyResource()
        form, reset = object(), object()
        renderer = DummyRenderer(
                    {'login-form': form, 'password-reset-link': reset})
        with testConfig() as config:
            config.testing_add_renderer(
                    'substanced.sdi.views:templates/login.pt', renderer)
            result = self._callFUT(context, request)
        self.assertEqual(result['url'], '/mgmt_path')
        self.assertEqual(result['came_from'], 'http://example.com')
        self.assertEqual(result['login'], '')
        self.assertEqual(result['password'], '')
        self.assertTrue(result['login_template'] is renderer)
        self.assertEqual(request.session['sdi.came_from'],
                         'http://example.com')

    def test_form_submitted_csrf_error(self):
        from pyramid.testing import testConfig
        request = testing.DummyRequest()
        request.params['form.submitted'] = True
        request.sdiapi = DummySDIAPI()
        context = testing.DummyResource()
        with testConfig() as config:
            config.testing_add_renderer(
                    'substanced.sdi.views:templates/login.pt')
            result = self._callFUT(context, request)
        self.assertEqual(result['url'], '/mgmt_path')
        self.assertEqual(result['came_from'], 'http://example.com')
        self.assertEqual(result['login'], '')
        self.assertEqual(result['password'], '')
        self.assertEqual(request.sdiapi.flashed, 'Failed login (CSRF)')
        self.assertEqual(request.session['sdi.came_from'], 'http://example.com')
        
    def test_form_submitted_failed_login_no_user(self):
        from pyramid.testing import testConfig
        from ....testing import make_site
        request = testing.DummyRequest()
        request.params['form.submitted'] = True
        request.params['login'] = 'login'
        request.params['password'] = 'password'
        request.sdiapi = DummySDIAPI()
        request.params['csrf_token'] = request.session.get_csrf_token()
        context = make_site()
        with testConfig() as config:
            config.testing_add_renderer(
                    'substanced.sdi.views:templates/login.pt')
            result = self._callFUT(context, request)
        self.assertEqual(result['url'], '/mgmt_path')
        self.assertEqual(result['came_from'], 'http://example.com')
        self.assertEqual(result['login'], 'login')
        self.assertEqual(result['password'], 'password')
        self.assertEqual(request.sdiapi.flashed, 'Failed login')
        self.assertEqual(request.session['sdi.came_from'], 'http://example.com')

    def test_form_submitted_failed_login_wrong_password(self):
        from pyramid.testing import testConfig
        from ....testing import make_site
        request = testing.DummyRequest()
        request.params['form.submitted'] = True
        request.params['login'] = 'login'
        request.params['password'] = 'password'
        request.sdiapi = DummySDIAPI()
        request.params['csrf_token'] = request.session.get_csrf_token()
        context = make_site()
        context['principals']['users']['login'] = DummyUser(0)
        with testConfig() as config:
            config.testing_add_renderer(
                    'substanced.sdi.views:templates/login.pt')
            result = self._callFUT(context, request)
        self.assertEqual(result['url'], '/mgmt_path')
        self.assertEqual(result['came_from'], 'http://example.com')
        self.assertEqual(result['login'], 'login')
        self.assertEqual(result['password'], 'password')
        self.assertEqual(request.sdiapi.flashed, 'Failed login')
        self.assertEqual(request.session['sdi.came_from'], 'http://example.com')

    def test_form_submitted_success_w_locator_adapter(self):
        from pyramid.testing import testConfig
        from zope.interface import Interface
        from ....interfaces import IUserLocator
        from ....testing import make_site
        request = testing.DummyRequest()
        request.params['form.submitted'] = True
        request.params['login'] = 'login'
        request.params['password'] = 'password'
        request.sdiapi = DummySDIAPI()
        request.params['csrf_token'] = request.session.get_csrf_token()
        context = make_site()
        user = DummyUser(1)
        user.__oid__ = 2
        locator = DummyLocator(user)
        def _locator(context, request):
            return locator
        with testConfig() as config:
            config.testing_add_renderer(
                    'substanced.sdi.views:templates/login.pt')
            config.registry.registerAdapter(_locator, (Interface, Interface),
                                            IUserLocator)
            result = self._callFUT(context, request)
        self.assertEqual(result.location, 'http://example.com')
        self.assertTrue(result.headers)
        self.assertTrue('sdi.came_from' not in request.session)

    def test_form_submitted_success(self):
        from pyramid.testing import testConfig
        from ....testing import make_site
        request = testing.DummyRequest()
        request.params['form.submitted'] = True
        request.params['login'] = 'login'
        request.params['password'] = 'password'
        request.sdiapi = DummySDIAPI()
        request.params['csrf_token'] = request.session.get_csrf_token()
        context = make_site()
        user = DummyUser(1)
        user.__oid__ = 1
        context['principals']['users']['login'] = user
        with testConfig() as config:
            config.testing_add_renderer(
                    'substanced.sdi.views:templates/login.pt')
            result = self._callFUT(context, request)
        self.assertEqual(result.location, 'http://example.com')
        self.assertTrue(result.headers)
        self.assertTrue('sdi.came_from' not in request.session)

class DummyUser(object):
    def __init__(self, result):
        self.result = result

    def check_password(self, password):
        return self.result

class DummySDIAPI(object):
    def mgmt_path(self, *arg, **kw):
        return '/mgmt_path'
    def flash(self, msg, queue='info'):
        self.flashed = msg

class DummyLocator(object):
    def __init__(self, user=None):
        self._user = user

    def get_user_by_login(self, login):
        self._login = login
        return self._user

########NEW FILE########
__FILENAME__ = test_manage
import unittest
from pyramid import testing

class TestManagementViews(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..manage import ManagementViews
        return ManagementViews(context, request)

    def test_manage_main_no_view_data(self):
        from pyramid.httpexceptions import HTTPForbidden
        context = testing.DummyResource()
        request = testing.DummyRequest()
        def mgmt_path(ctx, value):
            self.assertEqual(value, '@@login')
            return '/path'
        request.sdiapi = Dummy()
        request.sdiapi.mgmt_path = mgmt_path
        inst = self._makeOne(context, request)
        inst.sdi_mgmt_views = lambda *arg: []
        self.assertRaises(HTTPForbidden, inst.manage_main)
        self.assertEqual(request.session['came_from'], 'http://example.com')

    def test_manage_main_with_view_data(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        def mgmt_path(ctx, value):
            self.assertEqual(value, '@@fred')
            return '/path'
        request.sdiapi = Dummy()
        request.sdiapi.mgmt_path = mgmt_path
        inst = self._makeOne(context, request)
        inst.sdi_mgmt_views = lambda *arg: [{'view_name':'fred'}]
        result = inst.manage_main()
        self.assertEqual(result.location, '/path')

class Dummy(object):
    pass

########NEW FILE########
__FILENAME__ = test_undo
import unittest
from pyramid import testing

class TestUndoViews(unittest.TestCase):
    def _makeOne(self, context, request):
        from ..undo import UndoViews
        return UndoViews(context, request)

    def test_undo_recent_no_referrer(self):
        conn = DummyConnection()
        request = testing.DummyRequest()
        request._primary_zodb_conn = conn # XXX not an API, will break
        request.sdiapi = DummySDIAPI()
        request.referrer = None
        request.params['undohash'] = 'undohash'
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        resp = inst.undo_recent()
        self.assertEqual(resp.location, '/mgmt_path')
        
    def test_undo_recent_with_referrer(self):
        conn = DummyConnection()
        request = testing.DummyRequest()
        request._primary_zodb_conn = conn # XXX not an API, will break
        request.sdiapi = DummySDIAPI()
        request.referrer = 'loc'
        request.params['undohash'] = 'undohash'
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        resp = inst.undo_recent()
        self.assertEqual(resp.location, 'loc')

    def test_undo_recent_no_undo_info(self):
        conn = DummyConnection()
        request = testing.DummyRequest()
        request._primary_zodb_conn = conn # XXX not an API, will break
        request.sdiapi = DummySDIAPI()
        request.referrer = 'loc'
        request.params['undohash'] = 'undohash'
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        inst.undo_recent()
        self.assertEqual(request.sdiapi.flashed, 'Could not undo, sorry')
        
    def test_undo_recent_with_undo_info_no_match(self):
        record = {'description':'desc', 'id':'abc'}
        conn = DummyConnection(undo_info=[record])
        request = testing.DummyRequest()
        request._primary_zodb_conn = conn # XXX not an API, will break
        request.sdiapi = DummySDIAPI()
        request.referrer = 'loc'
        request.params['undohash'] = 'undohash'
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        inst.undo_recent()
        self.assertEqual(request.sdiapi.flashed, 'Could not undo, sorry')

    def test_undo_recent_with_undo_info_match(self):
        record = {'undohash':'abc', 'id':'abc', 'description':'desc'}
        conn = DummyConnection(undo_info=[record])
        request = testing.DummyRequest()
        request._primary_zodb_conn = conn # XXX not an API, will break
        request.sdiapi = DummySDIAPI()
        request.referrer = 'loc'
        request.params['undohash'] = 'abc'
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        transaction = DummyTransaction()
        inst.transaction = transaction
        inst.undo_recent()
        self.assertTrue(request.sdiapi.flashed)
        self.assertEqual(transaction.committed, True)

    def test_undo_recent_with_undo_info_POSError(self):
        from ZODB.POSException import POSError
        record = {'undohash':'abc', 'id':'abc'}
        conn = DummyConnection(undo_info=[record], undo_exc=POSError)
        request = testing.DummyRequest()
        request._primary_zodb_conn = conn # XXX not an API, will break
        request.sdiapi = DummySDIAPI()
        request.referrer = 'loc'
        request.params['undohash'] = 'abc'
        transaction = DummyTransaction()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        inst.transaction = transaction
        inst.undo_recent()
        self.assertTrue(request.sdiapi.flashed)
        self.assertEqual(len(conn._db.undone), 0)
        self.assertEqual(transaction.aborted, True)

    def test__get_db(self):
        request = testing.DummyRequest()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        conn = DummyConnection()
        def get_connection(req):
            self.assertEqual(req, request)
            return conn
        inst.get_connection = get_connection
        db = inst._get_db()
        self.assertEqual(db, conn._db)

    def test__undoable_transactions(self):
        import datetime
        import time
        from pytz import UTC
        request = testing.DummyRequest()
        request.user = testing.DummyResource()
        request.user.timezone = UTC
        context = testing.DummyResource()
        now = time.time()
        now_ctime = datetime.datetime.fromtimestamp(now).strftime(
            '%Y-%m-%d %H:%M:%S UTC')
        record1 = dict(
            time=now,
            description=b'abc',
            user_name=b'1',
            id=b'0',
            )
        record2 = dict(
            time=now,
            description=b'abc',
            user_name=b'cantintify',
            id=b'1',
            )
        record3 = dict(
            time=now,
            description=b'',
            user_name=b'cantintify',
            id=b'1',
            )
        record4 = dict(
            time=now,
            description=b'a'*81,
            user_name=b'1',
            id=b'1',
            )
        records = [record1, record2, record3, record4]
        db = DummyDB(True, records)
        def _get_db():
            return db
        inst = self._makeOne(context, request)
        inst._get_db = _get_db
        user = testing.DummyResource(__name__='fred')
        objectmap = DummyObjectmap(user)
        def find_objectmap(ctx):
            self.assertEqual(ctx, context)
            return objectmap
        inst.find_objectmap = find_objectmap
        result = inst._undoable_transactions(0, 10)
        self.assertEqual(db.first, 0)
        self.assertEqual(db.last, 10)
        self.assertEqual(
            result,
            [
                {'description': b'abc',
                 'user_name': b'fred',
                 'id': b'MA==\n abc',
                 'time': now_ctime},
                {'description': b'abc',
                 'user_name': b'cantintify',
                 'id': b'MQ==\n abc',
                 'time': now_ctime},
                {'description': b'',
                 'user_name': b'cantintify',
                 'id': b'MQ==\n ',
                 'time': now_ctime},
                {'description': (b'a'*81),
                 'user_name': b'fred',
                 'id': b'MQ==\n ' + (b'a' * 76) + b' ...',
                 'time': now_ctime}
                ]
            )

    def test_undo_multiple(self):
        import binascii
        request = testing.DummyRequest()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        conn = DummyConnection()
        def get_connection(req):
            self.assertEqual(req, request)
            return conn
        inst.get_connection = get_connection
        def authenticated_userid(req):
            self.assertEqual(req, request)
            return 1
        post = testing.DummyResource()
        enca = binascii.b2a_base64(b'a')
        encb = binascii.b2a_base64(b'b')
        info = [enca + b' b', encb + b' f']
        def getall(n):
            self.assertEqual(n, 'transaction')
            return info
        post.getall = getall
        request.POST = post
        request.sdiapi = DummySDIAPI()
        inst.authenticated_userid = authenticated_userid
        txn = DummyTransaction()
        inst.transaction = txn
        result = inst.undo_multiple()
        self.assertEqual(result.location, '/mgmt_path')
        self.assertEqual(conn._db.tids, [b'a', b'b'])
        self.assertTrue(txn.committed)
        self.assertEqual(txn.user, 1)

    def test_undo_multiple_with_text_in_POST(self):
        import binascii
        request = testing.DummyRequest()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        conn = DummyConnection()
        def get_connection(req):
            self.assertEqual(req, request)
            return conn
        inst.get_connection = get_connection
        def authenticated_userid(req):
            self.assertEqual(req, request)
            return 1
        post = testing.DummyResource()
        enca = binascii.b2a_base64(b'a').decode('ascii')
        encb = binascii.b2a_base64(b'b').decode('ascii')
        info = [enca + ' b', encb + ' f']
        def getall(n):
            self.assertEqual(n, 'transaction')
            return info
        post.getall = getall
        request.POST = post
        request.sdiapi = DummySDIAPI()
        inst.authenticated_userid = authenticated_userid
        txn = DummyTransaction()
        inst.transaction = txn
        result = inst.undo_multiple()
        self.assertEqual(result.location, '/mgmt_path')
        self.assertEqual(conn._db.tids, [b'a', b'b'])
        self.assertTrue(txn.committed)
        self.assertEqual(txn.user, 1)

    def test_undo_multiple_with_exception(self):
        import binascii
        from ZODB.POSException import POSError
        request = testing.DummyRequest()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        conn = DummyConnection()
        def get_connection(req):
            self.assertEqual(req, request)
            return conn
        conn._db.undo_exc = POSError
        inst.get_connection = get_connection
        def authenticated_userid(req):
            self.assertEqual(req, request)
            return 1
        post = testing.DummyResource()
        enca = binascii.b2a_base64(b'a')
        encb = binascii.b2a_base64(b'b')
        info = [enca + b' b', encb + b' f']
        def getall(n):
            self.assertEqual(n, 'transaction')
            return info
        post.getall = getall
        request.POST = post
        request.sdiapi = DummySDIAPI()
        inst.authenticated_userid = authenticated_userid
        txn = DummyTransaction()
        inst.transaction = txn
        result = inst.undo_multiple()
        self.assertEqual(result.location, '/mgmt_path')
        self.assertTrue(txn.aborted)
        self.assertEqual(
            request.sdiapi.flashed,
            'Could not undo, sorry'
            )

    def test_undo_no_transactions(self):
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        def _undoable_transactions(first, last):
            return []
        inst._undoable_transactions = _undoable_transactions
        result = inst.undo()
        self.assertEqual(
            result,
            {'batch_num': 0, 'earlier': None, 'batch': [], 'later': None}
            )

    def test_undo_some_transactions_first(self):
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        def _undoable_transactions(first, last):
            return [None] * 10
        inst._undoable_transactions = _undoable_transactions
        result = inst.undo()
        self.assertEqual(
            result,
            {'batch_num': 0,
             'earlier': '/mgmt_path',
             'batch': [None] * 10,
             'later': None,
             }
            )

    def test_undo_some_transactions_notfirst(self):
        request = testing.DummyRequest()
        request.GET['first'] = '10'
        request.sdiapi = DummySDIAPI()
        context = testing.DummyResource()
        inst = self._makeOne(context, request)
        def _undoable_transactions(first, last):
            return [None] * 10
        inst._undoable_transactions = _undoable_transactions
        result = inst.undo()
        self.assertEqual(
            result,
            {'batch_num': 1,
             'earlier': '/mgmt_path',
             'batch': [None] * 10,
             'later': '/mgmt_path'}
            )

class Test_encode64(unittest.TestCase):
    def _callFUT(self, v):
        from ..undo import encode64
        return encode64(v)
    
    def test_it_len_lt_58(self):
        import binascii
        result = self._callFUT(b'a')
        self.assertEqual(result, binascii.b2a_base64(b'a'))
        
    def test_it_len_gt_58(self):
        import binascii
        result = self._callFUT(b'a'*80)
        self.assertEqual(result, binascii.b2a_base64(b'a'*80)[:-1])

class Test_decode64(unittest.TestCase):
    def _callFUT(self, v):
        from ..undo import decode64
        return decode64(v)
    
    def test_it_len_lt_58(self):
        import binascii
        send = binascii.b2a_base64(b'a')
        result = self._callFUT(send)
        self.assertEqual(result, b'a')
    

class DummyDB(object):
    def __init__(self, supports_undo, undo_info, undo_exc=None):
        self.supports_undo = supports_undo
        self.undo_info = undo_info
        self.undone = []
        self.undo_exc = undo_exc

    def undoLog(self, first, last):
        self.first = first
        self.last = last
        return self.undo_info

    def undo(self, id):
        if self.undo_exc:
            raise self.undo_exc
        self.undone.append(id)

    def undoMultiple(self, tids):
        if self.undo_exc:
            raise self.undo_exc
        self.tids = tids
        
class DummyConnection(object):
    def __init__(self, supports_undo=True, undo_info=(), undo_exc=None):
        self._db = DummyDB(supports_undo, undo_info, undo_exc)

    def db(self):
        return self._db

class DummySDIAPI(object):
    def mgmt_path(self, *arg, **kw):
        return '/mgmt_path'
    def flash(self, msg, queue='info'):
        self.flashed = msg

class DummyTransaction(object):
    def commit(self):
        self.committed = True

    def abort(self):
        self.aborted = True

    def note(self, msg):
        self._note = msg

    def get(self):
        return self

    def setUser(self, user):
        self.user = user
        
class DummyObjectmap(object):
    def __init__(self, result):
        self.result = result
    def object_for(self, other):
        return self.result

########NEW FILE########
__FILENAME__ = undo
import datetime
import transaction
import ZODB.POSException

from pyramid_zodbconn import get_connection
from pyramid.httpexceptions import HTTPFound
from pyramid.security import authenticated_userid

from .. import mgmt_view
from ...objectmap import find_objectmap
from ...util import _

class UndoViews(object):
    transaction = transaction # for tests
    get_connection = staticmethod(get_connection) # for tests
    find_objectmap = staticmethod(find_objectmap) # for tests
    authenticated_userid = staticmethod(authenticated_userid) # for tests

    def __init__(self, context, request):
        self.context = context
        self.request = request

    def _get_db(self):
        request = self.request
        conn = self.get_connection(request)
        db = conn.db()
        return db

    @mgmt_view(
        name='undo_recent',
        tab_condition=False, 
        check_csrf=True,
        permission='sdi.view',
        )
    def undo_recent(self):
        request = self.request
        undohash = request.params['undohash']
        undo = None
        db = self._get_db()
        userid = self.authenticated_userid(request)
        # I am permitted to undo it if:
        #
        # - It happend within the most recent 50 transactions.
        #
        # - I personally did it.
        #
        # NB: do not break these assertions, as this view is protected only by
        # sdi.view permission.
        for record in db.undoLog(0, -50):
            try:
                r_userid = int(record.get('user_name', None))
            except:
                r_userid = None
            if (record.get('undohash') == undohash and r_userid == userid):
                undo = dict(record)
                break
        if undo is None:
            request.sdiapi.flash('Could not undo, sorry', 'danger')
        else:
            tid = undo['id']
            try:
                db.undo(tid)
                # provoke MultipleUndoErrors exception immediately
                msg = 'Undid: %s' % undo['description']
                self.transaction.get().note(msg)
                self.transaction.commit() 
                request.sdiapi.flash(msg, 'success')
            except ZODB.POSException.POSError:
                self.transaction.abort()
                msg = _('Could not undo, sorry')
                request.sdiapi.flash(msg, 'error')
        return HTTPFound(
            request.referrer or request.sdiapi.mgmt_path(request.context)
            )

    @mgmt_view(
        name='undo_multiple',
        tab_condition=False, 
        check_csrf=True,
        physical_path='/',
        permission='sdi.undo',
        )
    def undo_multiple(self):
        request = self.request

        transaction_info = self.request.POST.getall('transaction')

        tids = []
        descriptions = []

        uid = self.authenticated_userid(request)

        for tid in transaction_info:
            if not isinstance(tid, bytes): #pragma NO COVER Py3k
                tid = tid.encode('ascii', 'surrogateescape')
            tid = tid.split(b' ', 1)
            if tid:
                tids.append(decode64(tid[0]))
                descriptions.append(tid[1].decode('ascii', 'surrogateescape'))

        if tids:
            undid = "Undid: %s" % ' '.join(descriptions)
            t = self.transaction.get()
            t.note(undid)
            t.setUser(uid)
            try:
                self._get_db().undoMultiple(tids)
                # provoke MultipleUndoErrors exception immediately
                self.transaction.commit() 
                request.sdiapi.flash(undid, 'success')
            except ZODB.POSException.POSError:
                self.transaction.abort()
                msg = _('Could not undo, sorry')
                request.sdiapi.flash(msg, 'error')

        return HTTPFound(request.sdiapi.mgmt_path(request.context, 'undo'))

    def _undoable_transactions(self, first, last):
        db = self._get_db()

        objectmap = self.find_objectmap(self.context)

        r = db.undoLog(first, last)

        tz = self.request.user.timezone
        
        for d in r:
            t = datetime.datetime.fromtimestamp(d['time'])
            t = tz.localize(t).strftime('%Y-%m-%d %H:%M:%S %Z')
            d['time'] = t
            desc = d['description'] or b''
            tid = d['id']
            un = d['user_name']
            try:
                un = objectmap.object_for(int(un.split()[-1].strip()))
                d['user_name'] = un.__name__.encode('ascii', 'surrogateescape')
            except: # use original username if any trouble
                pass
            if len(desc) > 80:
                desc = desc[:76] + b' ...'
            tid = encode64(tid) + b' ' + desc
            d['id'] = tid

        return r

    @mgmt_view(
        name='undo',
        tab_title=_('Undo'),
        renderer='templates/undo.pt',
        physical_path='/',
        permission='sdi.undo',
        )
    def undo(self):
        first = int(self.request.GET.get('first', 0))
        size = 10
        last = first + size

        batch = self._undoable_transactions(first, last)

        if len(batch) < size:
            earlier = None
        else:
            earlier = last
            earlier = self.request.sdiapi.mgmt_path(
                self.context, 'undo', query={'first':earlier}
                )
        if first <= 0:
            later = None
        else:
            later = first - size
            later = self.request.sdiapi.mgmt_path(
                self.context, 'undo', query={'first':later}
                )

        batch_num = first / size
        
        return {'batch':batch, 'earlier':earlier, 'later':later,
                'batch_num':batch_num}
        
        
            
########################################################################
# Blech, need this cause binascii.b2a_base64 is too picky (from Zope)

import binascii

def encode64(s, b2a=binascii.b2a_base64):
    if len(s) < 58:
        return b2a(s)
    r = []
    a = r.append
    for i in range(0, len(s), 57):
        a(b2a(s[i:i+57])[:-1])
    return b''.join(r)


def decode64(s, a2b=binascii.a2b_base64):
    return a2b(s + b'\n')

del binascii

########NEW FILE########
__FILENAME__ = subscribers
from pyramid.events import (
    ApplicationCreated,
    subscriber
    )

from . import statsd_incr

@subscriber(ApplicationCreated)
def on_startup(event):
    statsd_incr('started')
    

########NEW FILE########
__FILENAME__ = test_stats
import unittest
from pyramid import testing

class TestStatsdHelper(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()
        
    def _makeOne(self):
        from .. import StatsdHelper
        return StatsdHelper()

    def test_get_client_with_registry(self):
        registry = {'statsd_client':True}
        inst = self._makeOne()
        self.assertEqual(inst.get_client(registry), True)
        
    def test_get_client_with_no_registry(self):
        self.config.registry['statsd_client'] = True
        inst = self._makeOne()
        self.assertEqual(inst.get_client(), True)

    def test_timer_no_client(self):
        self.config.registry['statsd_client'] = None
        inst = self._makeOne()
        timer = inst.timer('timer')
        with timer as t:
            self.assertEqual(t, None)
        
    def test_timer_with_client(self):
        client = DummyClient(True)
        self.config.registry['statsd_client'] = client
        inst = self._makeOne()
        timer = inst.timer('timer', .5)
        self.assertEqual(timer, True)
        self.assertEqual(client.timer_name, 'timer')
        self.assertEqual(client.timer_rate, .5)

    def test_gauge(self):
        client = DummyClient(True)
        self.config.registry['statsd_client'] = client
        inst = self._makeOne()
        result = inst.gauge('name', 'value')
        self.assertEqual(result, True)
        self.assertEqual(client.gauge_name, 'name')
        self.assertEqual(client.gauge_value, 'value')
        self.assertEqual(client.gauge_rate, 1)
        
    def test_incr(self):
        client = DummyClient(True)
        self.config.registry['statsd_client'] = client
        inst = self._makeOne()
        result = inst.incr('name', 5)
        self.assertEqual(result, True)
        self.assertEqual(client.incr_name, 'name')
        self.assertEqual(client.incr_value, 5)
        self.assertEqual(client.incr_rate, 1)
        
        
class DummyClient(object):
    def __init__(self, result):
        self.result = result

    def timer(self, timer_name, rate=1):
        self.timer_name = timer_name
        self.timer_rate = rate
        return self.result

    def gauge(self, name, value, rate=1):
        self.gauge_name = name
        self.gauge_value = value
        self.gauge_rate = rate
        return self.result
    
    def incr(self, name, value=1, rate=1):
        self.incr_name = name
        self.incr_value = value
        self.incr_rate = rate
        return self.result
    
        
    

########NEW FILE########
__FILENAME__ = test_subscribers
import unittest

class Test_on_startup(unittest.TestCase):
    def test_it(self):
        from .. import subscribers
        def dummy_incr(value):
            self.assertEqual(value, 'started')
        try:
            old_statsd_incr = subscribers.statsd_incr
            subscribers.statsd_incr = dummy_incr
            subscribers.on_startup(None)
        finally:
            subscribers.statsd_incr = old_statsd_incr
            

########NEW FILE########
__FILENAME__ = testing
from .objectmap import ObjectMap
from .folder import Folder

def make_site():
    context = Folder()
    context.__oid__ = 1
    ObjectMap(context)
    users = Folder()
    users._oid__ = 2
    groups = Folder()
    groups.__oid__ = 3
    principals = Folder()
    principals.__oid__ = 4
    principals['groups'] = groups
    principals['users'] = users
    context.add_service('principals', principals)
    return context


########NEW FILE########
__FILENAME__ = tests
import unittest

from pyramid import testing

from . import _marker

class Test__postorder(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, node):
        from . import postorder
        return postorder(node)

    def test_None_node(self):
        result = list(self._callFUT(None))
        self.assertEqual(result, [None])

    def test_IFolder_node_no_children(self):
        from ..interfaces import IFolder
        model = testing.DummyResource(__provides__=IFolder)
        result = list(self._callFUT(model))
        self.assertEqual(result, [model])

    def test_IFolder_node_nonfolder_children(self):
        from ..interfaces import IFolder
        model = testing.DummyResource(__provides__=IFolder)
        one = testing.DummyResource()
        two = testing.DummyResource()
        model['one'] = one
        model['two'] = two
        result = list(self._callFUT(model))
        self.assertEqual(result, [one, two, model])

    def test_IFolder_node_folder_children(self):
        from ..interfaces import IFolder
        model = testing.DummyResource(__provides__=IFolder)
        one = testing.DummyResource()
        two = testing.DummyResource(__provides__=IFolder)
        model['one'] = one
        model['two'] = two
        three = testing.DummyResource()
        four = testing.DummyResource()
        two['three'] = three
        two['four'] = four
        result = list(self._callFUT(model))
        self.assertEqual(result, [one, four, three, two, model])

class Test_get_oid(unittest.TestCase):
    def _callFUT(self, obj, default=_marker):
        from . import get_oid
        return get_oid(obj, default)

    def test_gardenpath(self):
        obj = testing.DummyResource()
        obj.__oid__ = 1
        self.assertEqual(self._callFUT(obj), 1)

    def test_no_objectid_no_default(self):
        obj = testing.DummyResource()
        self.assertRaises(AttributeError, self._callFUT, obj)

    def test_no_objectid_with_default(self):
        obj = testing.DummyResource()
        self.assertEqual(self._callFUT(obj, 1), 1)

class Test_set_oid(unittest.TestCase):
    def _callFUT(self, obj, val):
        from . import set_oid
        return set_oid(obj, val)

    def test_gardenpath(self):
        obj = testing.DummyResource()
        self._callFUT(obj, 1)
        self.assertEqual(obj.__oid__, 1)

class TestBatch(unittest.TestCase):
    def _makeOne(self, seq, request, url=None, default_size=15, seqlen=None):
        from . import Batch
        return Batch(seq, request, url, default_size, seqlen=seqlen)

    def test_it_first_batch_of_3(self):
        seq = [1,2,3,4,5,6,7]
        request = testing.DummyRequest()
        request.params['batch_num'] = 0
        request.params['batch_size'] = 3
        request.url = 'http://example.com'
        inst = self._makeOne(seq, request)
        self.assertEqual(inst.items, [1,2,3])
        self.assertEqual(inst.num, 0)
        self.assertEqual(inst.size, 3)
        self.assertEqual(inst.length, 3)
        self.assertEqual(inst.last, 2)
        self.assertEqual(inst.required, True)
        self.assertEqual(inst.first_url, None)
        self.assertEqual(inst.prev_url, None)
        self.assertEqual(inst.next_url,
                         'http://example.com?batch_num=1&batch_size=3')
        self.assertEqual(inst.last_url,
                         'http://example.com?batch_num=2&batch_size=3')
        self.assertEqual(inst.startitem, 0)
        self.assertEqual(inst.enditem, 2)
        self.assertEqual(inst.seqlen, 7)

    def test_it_first_batch_of_3_generator(self):
        def gen():
            for x in [1,2,3,4,5,6,7]:
                yield x
        seq = gen()
        request = testing.DummyRequest()
        request.params['batch_num'] = 0
        request.params['batch_size'] = 3
        request.url = 'http://example.com'
        inst = self._makeOne(seq, request, seqlen=7)
        self.assertEqual(inst.items, [1,2,3])
        self.assertEqual(inst.num, 0)
        self.assertEqual(inst.size, 3)
        self.assertEqual(inst.length, 3)
        self.assertEqual(inst.last, 2)
        self.assertEqual(inst.required, True)
        self.assertEqual(inst.first_url, None)
        self.assertEqual(inst.prev_url, None)
        self.assertEqual(inst.next_url,
                         'http://example.com?batch_num=1&batch_size=3')
        self.assertEqual(inst.last_url,
                         'http://example.com?batch_num=2&batch_size=3')
        self.assertEqual(inst.startitem, 0)
        self.assertEqual(inst.enditem, 2)
        self.assertEqual(inst.seqlen, 7)

    def test_it_second_batch_of_3(self):
        seq = [1,2,3,4,5,6,7]
        request = testing.DummyRequest()
        request.params['batch_num'] = 1
        request.params['batch_size'] = 3
        request.url = 'http://example.com'
        inst = self._makeOne(seq, request)
        self.assertEqual(inst.items, [4,5,6])
        self.assertEqual(inst.num, 1)
        self.assertEqual(inst.size, 3)
        self.assertEqual(inst.length, 3)
        self.assertEqual(inst.last, 2)
        self.assertEqual(inst.required, True)
        self.assertEqual(inst.first_url,
                         'http://example.com?batch_num=0&batch_size=3')
        self.assertEqual(inst.prev_url,
                         'http://example.com?batch_num=0&batch_size=3')
        self.assertEqual(inst.next_url,
                         'http://example.com?batch_num=2&batch_size=3')
        self.assertEqual(inst.last_url,
                         'http://example.com?batch_num=2&batch_size=3')
        self.assertEqual(inst.startitem, 3)
        self.assertEqual(inst.enditem, 5)
        self.assertEqual(inst.seqlen, 7)

    def test_it_second_batch_of_3_generator(self):
        def gen():
            for x in [1,2,3,4,5,6,7]:
                yield x
        seq = gen()
        request = testing.DummyRequest()
        request.params['batch_num'] = 1
        request.params['batch_size'] = 3
        request.url = 'http://example.com'
        inst = self._makeOne(seq, request, seqlen=7)
        self.assertEqual(inst.items, [4,5,6])
        self.assertEqual(inst.num, 1)
        self.assertEqual(inst.size, 3)
        self.assertEqual(inst.length, 3)
        self.assertEqual(inst.last, 2)
        self.assertEqual(inst.required, True)
        self.assertEqual(inst.first_url,
                         'http://example.com?batch_num=0&batch_size=3')
        self.assertEqual(inst.prev_url,
                         'http://example.com?batch_num=0&batch_size=3')
        self.assertEqual(inst.next_url,
                         'http://example.com?batch_num=2&batch_size=3')
        self.assertEqual(inst.last_url,
                         'http://example.com?batch_num=2&batch_size=3')
        self.assertEqual(inst.startitem, 3)
        self.assertEqual(inst.enditem, 5)
        self.assertEqual(inst.seqlen, 7)

    def test_it_third_batch_of_3(self):
        seq = [1,2,3,4,5,6,7]
        request = testing.DummyRequest()
        request.params['batch_num'] = 2
        request.params['batch_size'] = 3
        request.url = 'http://example.com'
        inst = self._makeOne(seq, request)
        self.assertEqual(inst.items, [7])
        self.assertEqual(inst.num, 2)
        self.assertEqual(inst.size, 3)
        self.assertEqual(inst.length, 1)
        self.assertEqual(inst.last, 2)
        self.assertEqual(inst.required, True)
        self.assertEqual(inst.first_url,
                         'http://example.com?batch_num=0&batch_size=3')
        self.assertEqual(inst.prev_url,
                         'http://example.com?batch_num=1&batch_size=3')
        self.assertEqual(inst.next_url, None)
        self.assertEqual(inst.last_url, None)
        self.assertEqual(inst.startitem, 6)
        self.assertEqual(inst.enditem, 6)
        self.assertEqual(inst.seqlen, 7)

    def test_it_third_batch_of_3_generator(self):
        def gen():
            for x in [1,2,3,4,5,6,7]:
                yield x
        seq = gen()
        request = testing.DummyRequest()
        request.params['batch_num'] = 2
        request.params['batch_size'] = 3
        request.url = 'http://example.com'
        inst = self._makeOne(seq, request, seqlen=7)
        self.assertEqual(inst.items, [7])
        self.assertEqual(inst.num, 2)
        self.assertEqual(inst.size, 3)
        self.assertEqual(inst.length, 1)
        self.assertEqual(inst.last, 2)
        self.assertEqual(inst.required, True)
        self.assertEqual(inst.first_url,
                         'http://example.com?batch_num=0&batch_size=3')
        self.assertEqual(inst.prev_url,
                         'http://example.com?batch_num=1&batch_size=3')
        self.assertEqual(inst.next_url, None)
        self.assertEqual(inst.last_url, None)
        self.assertEqual(inst.startitem, 6)
        self.assertEqual(inst.enditem, 6)
        self.assertEqual(inst.seqlen, 7)

    def test_it_invalid_batch_num(self):
        seq = [1,2,3,4,5,6,7]
        request = testing.DummyRequest()
        request.params['batch_num'] = None
        request.params['batch_size'] = 3
        request.url = 'http://example.com'
        inst = self._makeOne(seq, request)
        self.assertEqual(inst.items, [1,2,3])
        self.assertEqual(inst.num, 0)

    def test_it_negative_batch_num(self):
        seq = [1,2,3,4,5,6,7]
        request = testing.DummyRequest()
        request.params['batch_num'] = -1
        request.params['batch_size'] = 3
        request.url = 'http://example.com'
        inst = self._makeOne(seq, request)
        self.assertEqual(inst.items, [1,2,3])
        self.assertEqual(inst.num, 0)

    def test_it_invalid_batch_size(self):
        seq = [1,2,3,4,5,6,7]
        request = testing.DummyRequest()
        request.params['batch_num'] = 0
        request.params['batch_size'] = None
        request.url = 'http://example.com'
        inst = self._makeOne(seq, request)
        self.assertEqual(inst.items, seq)
        self.assertEqual(inst.size, 15)

    def test_it_negative_batch_size(self):
        seq = [1,2,3,4,5,6,7]
        request = testing.DummyRequest()
        request.params['batch_num'] = 0
        request.params['batch_size'] = -1
        request.url = 'http://example.com'
        inst = self._makeOne(seq, request)
        self.assertEqual(inst.items, seq)
        self.assertEqual(inst.size, 15)

    def test_it_size_zero(self):
        seq = [1,2,3,4,5,6,7]
        request = testing.DummyRequest()
        request.params['batch_num'] = 0
        request.params['batch_size'] = 0
        request.url = 'http://example.com'
        inst = self._makeOne(seq, request)
        self.assertEqual(inst.items, seq)
        self.assertEqual(inst.size, 15)

    def test_it_multicolumn_toggle_text(self):
        seq = [1,2,3,4,5,6]
        request = testing.DummyRequest()
        request.params['multicolumn'] = 'True'
        inst = self._makeOne(seq, request)
        self.assertEqual(inst.toggle_text, 'Single column')

    def test_it_not_multicolumn_toggle_text(self):
        seq = [1,2,3,4,5,6]
        request = testing.DummyRequest()
        request.params['multicolumn'] = 'False'
        inst = self._makeOne(seq, request)
        self.assertEqual(inst.toggle_text, 'Multi-column')

    def test_it_make_columns(self):
        seq = [1,2,3,4,5,6]
        request = testing.DummyRequest()
        inst = self._makeOne(seq, request)
        cols = inst.make_columns(column_size=2, num_columns=3)
        expected = [ [1,2], [3,4], [5,6] ]
        self.assertEqual(cols, expected)

    def test___iter__(self):
        seq = [1,2,3,4,5,6,7]
        request = testing.DummyRequest()
        request.params['batch_num'] = 0
        request.params['batch_size'] = 3
        request.url = 'http://example.com'
        inst = self._makeOne(seq, request)
        self.assertEqual(list(iter(inst)), [1,2,3])

    def test___len__(self):
        seq = [1,2,3,4,5,6,7]
        request = testing.DummyRequest()
        request.params['batch_num'] = 0
        request.params['batch_size'] = 3
        request.url = 'http://example.com'
        inst = self._makeOne(seq, request)
        self.assertEqual(len(inst), 3)
        
class Test_merge_url_qs(unittest.TestCase):
    def _callFUT(self, url, **kw):
        from . import merge_url_qs
        return merge_url_qs(url, **kw)

    def test_with_no_qs(self):
        url = 'http://example.com'
        result = self._callFUT(url, a=1, b=2)
        self.assertEqual(result, 'http://example.com?a=1&b=2')

    def test_with_existing_qs_overlap(self):
        url = 'http://example.com?a=3'
        result = self._callFUT(url, a=1, b=2)
        self.assertEqual(result, 'http://example.com?a=1&b=2')

    def test_with_existing_qs_no_overlap(self):
        url = 'http://example.com?c=3'
        result = self._callFUT(url, a=1, b=2)
        self.assertEqual(result, 'http://example.com?a=1&b=2&c=3')

class Test_acquire(unittest.TestCase):
    def _callFUT(self, node, name, default=None):
        from . import acquire
        if default is None:
            return acquire(node, name)
        else:
            return acquire(node, name, default)

    def test_missing_with_default(self):
        inst = DummyContent(None)
        marker = object()
        self.assertEqual(self._callFUT(inst, 'abc', marker), marker)

    def test_missing_no_default(self):
        inst = DummyContent(None)
        self.assertRaises(AttributeError, self._callFUT, inst, 'abc')

    def test_hit(self):
        inst = DummyContent(None)
        inst.abc = '123'
        self.assertEqual(self._callFUT(inst, 'abc'), '123')

class Test_coarse_datetime_repr(unittest.TestCase):
    def _callFUT(self, d):
        from . import coarse_datetime_repr
        return coarse_datetime_repr(d)

    def test_it(self):
        import calendar
        import datetime
        d = datetime.datetime.utcnow()
        result = self._callFUT(d)
        timetime = calendar.timegm(d.timetuple())
        val = int(timetime) // 100        
        self.assertEqual(result, val)

class Test_renamer(unittest.TestCase):
    def _makeOne(self):
        from . import renamer
        return renamer()

    def test_get_has_no_name(self):
        class Foo(object):
            name = self._makeOne()
        foo = Foo()
        self.assertEqual(foo.name, None)

    def test_get_has_a_name(self):
        class Foo(object):
            name = self._makeOne()
        foo = Foo()
        foo.__name__ = 'fred'
        self.assertEqual(foo.name, 'fred')

    def test_set_has_no_parent(self):
        class Foo(object):
            name = self._makeOne()
        foo = Foo()
        foo.__name__ = 'fred'
        foo.name = 'bar' # doesn't blow up
        self.assertEqual(foo.name, 'fred')

    def test_set_has_parent_same_value(self):
        class Foo(object):
            name = self._makeOne()
        foo = Foo()
        foo.__name__ = 'fred'
        parent = DummyContent()
        foo.__parent__ = parent
        foo.name = 'fred' # doesn't blow up
        self.assertEqual(foo.name, 'fred')
        self.assertEqual(parent.renamed_from, None)

    def test_set_has_parent_different_value(self):
        class Foo(object):
            name = self._makeOne()
        foo = Foo()
        foo.__name__ = 'fred'
        parent = DummyContent()
        foo.__parent__ = parent
        foo.name = 'bob'
        self.assertEqual(parent.renamed_from, 'fred')
        self.assertEqual(parent.renamed_to, 'bob')

class Test_get_acl(unittest.TestCase):
    def _callFUT(self, obj, default=_marker):
        from . import get_acl
        return get_acl(obj, default)

    def test_gardenpath(self):
        obj = testing.DummyResource()
        obj.__acl__ = 1
        self.assertEqual(self._callFUT(obj), 1)

    def test_no_objectid_no_default(self):
        obj = testing.DummyResource()
        self.assertRaises(AttributeError, self._callFUT, obj)

    def test_no_objectid_with_default(self):
        obj = testing.DummyResource()
        self.assertEqual(self._callFUT(obj, 1), 1)

class Test_set_acl(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, context, acl, registry=None):
        from . import set_acl
        return set_acl(context, acl, registry)

    def test_no_change_context_has_no_acl(self):
        context = testing.DummyResource()
        result = self._callFUT(context, None)
        self.assertFalse(result)

    def test_change_context_has_no_acl(self):
        context = testing.DummyResource()
        registry = DummyRegistry()
        result = self._callFUT(context, 1, registry)
        self.assertTrue(result)
        self.assertEqual(registry.event.old_acl, None)
        self.assertEqual(registry.event.new_acl, 1)
        self.assertEqual(context.__acl__, 1)

    def test_change_remove_acl(self):
        context = testing.DummyResource()
        context.__acl__ = 1
        registry = DummyRegistry()
        result = self._callFUT(context, None, registry)
        self.assertTrue(result)
        self.assertEqual(registry.event.old_acl, 1)
        self.assertEqual(registry.event.new_acl, None)
        self.assertFalse(hasattr(context, '__acl__'))
        
    def test_no_registry(self):
        context = testing.DummyResource()
        L = []
        self.config.registry.subscribers = lambda *arg: L.append(arg)
        result = self._callFUT(context, 1)
        self.assertTrue(result)
        self.assertEqual(context.__acl__, 1)
        self.assertEqual(L[0][1], None)

class Test_get_dotted_name(unittest.TestCase):
    def _callFUT(self, obj):
        from . import get_dotted_name
        return get_dotted_name(obj)

    def test_module(self):
        from substanced import util
        result = self._callFUT(util)
        self.assertEqual(result, 'substanced.util')

    def test_nonmodule(self):
        result = self._callFUT(self.__class__)
        self.assertEqual(result, 'substanced.util.tests.Test_get_dotted_name')

class Test_get_content_type(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, resource, registry=None):
        from . import get_content_type
        return get_content_type(resource, registry=registry)

    def test_without_registry(self):
        self.config.registry.content = DummyContentRegistry()
        resource = Dummy()
        resource.type = 'foo'
        self.assertEqual(self._callFUT(resource), 'foo')
        
    def test_with_registry(self):
        registry = Dummy()
        registry.content = DummyContentRegistry()
        resource = Dummy()
        resource.type = 'bar'
        self.assertEqual(self._callFUT(resource, registry), 'bar')

class Test_find_content(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, resource, content_type, registry=None):
        from . import find_content
        return find_content(resource, content_type, registry)

    def test_without_registry(self):
        self.config.registry.content = DummyContentRegistry()
        resource = Dummy()
        self.assertEqual(self._callFUT(resource, 1), resource)
        
    def test_with_registry(self):
        registry = Dummy()
        registry.content = DummyContentRegistry()
        resource = Dummy()
        self.assertEqual(self._callFUT(resource, 1, registry), resource)

class Test_find_service(unittest.TestCase):
    def _callFUT(self, context, name, *subnames):
        from . import find_service
        return find_service(context, name, *subnames)
    
    def test_unfound(self):
        from ..interfaces import IFolder
        site = testing.DummyResource(__provides__=IFolder)
        self.assertEqual(self._callFUT(site, 'catalog'), None)
        
    def test_found(self):
        from ..interfaces import IFolder
        from ..interfaces import IService
        site = testing.DummyResource(__provides__=IFolder)
        catalog = testing.DummyResource(__provides__=IService)
        site['catalog'] = catalog
        self.assertEqual(self._callFUT(site, 'catalog'), catalog)

    def test_unfound_with_subnames(self):
        from ..interfaces import IFolder
        from ..interfaces import IService
        site = testing.DummyResource(__provides__=IFolder)
        catalog = testing.DummyResource(__provides__=IService)
        site['catalog'] = catalog
        result = self._callFUT(site, 'catalog', 'a', 'b')
        self.assertEqual(result, None)

    def test_unfound_with_subnames_inner_not_folder(self):
        from ..interfaces import IFolder
        from ..interfaces import IService
        site = testing.DummyResource(__provides__=IFolder)
        catalog = testing.DummyResource(__provides__=(IService, IFolder))
        site['catalog'] = catalog
        catalog['a'] = testing.DummyResource()
        result = self._callFUT(site, 'catalog', 'a', 'b')
        self.assertEqual(result, None)

    def test_found_with_subnames_missing(self):
        from ..interfaces import IFolder
        from ..interfaces import IService
        site = testing.DummyResource(__provides__=IFolder)
        catalog = testing.DummyResource(__provides__=(IService, IFolder))
        site['catalog'] = catalog
        catalog['a'] = testing.DummyResource(__provides__=IFolder)
        catalog['a']['b'] = testing.DummyResource()
        result = self._callFUT(site, 'catalog', 'a', 'c')
        self.assertEqual(result, None)

    def test_found_with_subnames(self):
        from ..interfaces import IFolder
        from ..interfaces import IService
        site = testing.DummyResource(__provides__=IFolder)
        catalog = testing.DummyResource(__provides__=(IService, IFolder))
        site['catalog'] = catalog
        catalog['a'] = testing.DummyResource(__provides__=IFolder)
        catalog['a']['b'] = testing.DummyResource()
        result = self._callFUT(site, 'catalog', 'a', 'b')
        self.assertEqual(result, catalog['a']['b'])


class Test_find_services(unittest.TestCase):
    def _callFUT(self, context, name, *subnames):
        from . import find_services
        return find_services(context, name, *subnames)
    
    def test_one_found(self):
        from ..interfaces import IFolder
        from ..interfaces import IService
        site = testing.DummyResource(__provides__=IFolder)
        catalog = testing.DummyResource(__provides__=IService)
        site['catalog'] = catalog
        self.assertEqual(self._callFUT(site, 'catalog'), [catalog])
        
    def test_two_found(self):
        from ..interfaces import IFolder
        from ..interfaces import IService
        folder = testing.DummyResource(__provides__=IFolder)
        catalog1 = testing.DummyResource(__provides__=IService)
        folder['catalog'] = catalog1
        site = testing.DummyResource(__provides__=IFolder)
        catalog2 = testing.DummyResource(__provides__=IService)
        site['catalog'] = catalog2
        site['folder'] = folder
        self.assertEqual(self._callFUT(folder, 'catalog'), [catalog1, catalog2])
    
    def test_unfound(self):
        from ..interfaces import IFolder
        site = testing.DummyResource(__provides__=IFolder)
        self.assertEqual(self._callFUT(site, 'catalog'), [])

    def test_unfound2(self):
        from ..interfaces import IFolder
        site = testing.DummyResource(__provides__=IFolder)
        self.assertEqual(self._callFUT(site, 'catalog'), [])

    def test_unfound_with_subnames(self):
        from ..interfaces import IFolder
        from ..interfaces import IService
        site = testing.DummyResource(__provides__=IFolder)
        catalog = testing.DummyResource(__provides__=IService)
        site['catalog'] = catalog
        result = self._callFUT(site, 'catalog', 'a', 'b')
        self.assertEqual(result, [])

    def test_unfound_with_subnames_inner_not_folder(self):
        from ..interfaces import IFolder
        from ..interfaces import IService
        site = testing.DummyResource(__provides__=IFolder)
        catalog = testing.DummyResource(__provides__=(IFolder, IService))
        site['catalog'] = catalog
        catalog['a'] = testing.DummyResource()
        result = self._callFUT(site, 'catalog', 'a', 'b')
        self.assertEqual(result, [])

    def test_found_with_subnames_missing(self):
        from ..interfaces import IFolder
        from ..interfaces import IService
        site = testing.DummyResource(__provides__=IFolder)
        catalog = testing.DummyResource(__provides__=(IFolder, IService))
        site['catalog'] = catalog
        catalog['a'] = testing.DummyResource(__provides__=IFolder)
        catalog['a']['b'] = testing.DummyResource()
        result = self._callFUT(site, 'catalog', 'a', 'c')
        self.assertEqual(result, [])

    def test_found_with_subnames(self):
        from ..interfaces import IFolder
        from ..interfaces import IService
        site = testing.DummyResource(__provides__=IFolder)
        catalog = testing.DummyResource(__provides__=(IFolder, IService))
        site['catalog'] = catalog
        catalog['a'] = testing.DummyResource(__provides__=IFolder)
        catalog['a']['b'] = testing.DummyResource()
        result = self._callFUT(site, 'catalog', 'a', 'b')
        self.assertEqual(result, [catalog['a']['b']])


class Test_get_factory_type(unittest.TestCase):
    def _callFUT(self, resource):
        from . import get_factory_type
        return get_factory_type(resource)

    def test_has_ft_attr(self):
        resource = Dummy()
        resource.__factory_type__ = 'abc'
        self.assertEqual(self._callFUT(resource), 'abc')

    def test_without_ft_attr(self):
        resource = Dummy()
        self.assertEqual(self._callFUT(resource),
                         'substanced.util.tests.Dummy')

class Test_get_interfaces(unittest.TestCase):
    def _callFUT(self, resource, classes=True):
        from . import get_interfaces
        return get_interfaces(resource, classes=classes)

    def test_with_classes(self):
        from zope.interface import Interface, implementer
        class IFoo(Interface):
            pass
        @implementer(IFoo)
        class Foo(object):
            pass
        foo = Foo()
        result = self._callFUT(foo)
        self.assertEqual(result, set([IFoo, Interface, Foo]))
        
    def test_without_classes(self):
        from zope.interface import Interface, implementer
        class IFoo(Interface):
            pass
        @implementer(IFoo)
        class Foo(object):
            pass
        foo = Foo()
        result = self._callFUT(foo, classes=False)
        self.assertEqual(result, set([IFoo, Interface]))
        
class Test_find_catalogs(unittest.TestCase):
    def _callFUT(self, resource, name=None):
        from . import find_catalogs
        return find_catalogs(resource, name=name)

    def _makeTree(self):
        from substanced.interfaces import IFolder
        from substanced.interfaces import IService
        root = testing.DummyResource(__provides__=IFolder)
        catalogs1 = root['catalogs'] = testing.DummyResource(
            __provides__=IService)
        catalog1 = testing.DummyResource()
        catalogs1['catalog1'] = catalog1
        sub = testing.DummyResource(__provides__=IFolder)
        root['sub'] = sub
        catalogs2 = sub['catalogs'] = testing.DummyResource(
                                        __provides__=IService)
        catalog2 = testing.DummyResource()
        catalog1_2 = testing.DummyResource()
        sub['catalogs'] = catalogs2
        catalogs2['catalog2'] = catalog2
        catalogs2['catalog1'] = catalog1_2
        return root

    def test_no_catalogs(self):
        resource = testing.DummyResource()
        self.assertEqual(self._callFUT(resource), [])

    def test_with_multiple_catalogs_no_name(self):
        root = self._makeTree()
        sub = root['sub']
        catalog2 = sub['catalogs']['catalog2']
        catalog1_2 = sub['catalogs']['catalog1']
        catalog1 = root['catalogs']['catalog1']
        result = set(self._callFUT(sub))
        self.assertEqual(len(result), 3)
        self.assertTrue(catalog1 in result)
        self.assertTrue(catalog2 in result)
        self.assertTrue(catalog1_2 in result)

    def test_with_multiple_catalogs_and_name(self):
        root = self._makeTree()
        sub = root['sub']
        catalog1_2 = sub['catalogs']['catalog1']
        catalog1 = root['catalogs']['catalog1']
        result = list(enumerate(self._callFUT(sub, 'catalog1')))
        self.assertEqual(
            result,
            [ (0, catalog1_2), (1, catalog1) ],
            )

    def test_nosuch_catalog(self):
        root = self._makeTree()
        sub = root['sub']
        result = list(enumerate(self._callFUT(sub, 'catalog3')))
        self.assertEqual(
            result,
            [],
            )

class Test_find_catalog(unittest.TestCase):
    def _callFUT(self, resource, name):
        from . import find_catalog
        return find_catalog(resource, name)

    def _makeTree(self):
        from substanced.interfaces import IFolder
        from substanced.interfaces import IService
        root = testing.DummyResource(__provides__=IFolder)
        catalogs1 = root['catalogs'] = testing.DummyResource(
            __provides__=IService)
        catalog1 = testing.DummyResource()
        catalogs1['catalog1'] = catalog1
        sub = testing.DummyResource(__provides__=IFolder)
        root['sub'] = sub
        catalogs2 = sub['catalogs'] = testing.DummyResource(
                                        __provides__=IService)
        catalog2 = testing.DummyResource()
        catalog1_2 = testing.DummyResource()
        sub['catalogs'] = catalogs2
        catalogs2['catalog2'] = catalog2
        catalogs2['catalog1'] = catalog1_2
        return root

    def test_no_catalogs(self):
        resource = testing.DummyResource()
        self.assertEqual(self._callFUT(resource, 'catalog1'), None)

    def test_with_multiple_catalogs(self):
        root = self._makeTree()
        sub = root['sub']
        catalog2 = sub['catalogs']['catalog2']
        catalog1_2 = sub['catalogs']['catalog1']
        catalog1 = root['catalogs']['catalog1']
        result = self._callFUT(sub, 'catalog2')
        self.assertEqual(result, catalog2)
        result = self._callFUT(sub, 'catalog1')
        self.assertEqual(result, catalog1_2)
        result = self._callFUT(root, 'catalog1')
        self.assertEqual(result, catalog1)

    def test_nosuch_catalog(self):
        root = self._makeTree()
        sub = root['sub']
        result = self._callFUT(sub, 'catalog3')
        self.assertEqual(
            result,
            None,
            )

class Test_find_index(unittest.TestCase):
    def _callFUT(self, resource, catalog_name, index_name):
        from . import find_index
        return find_index(resource, catalog_name, index_name)

    def _makeTree(self):
        from substanced.interfaces import IFolder
        from substanced.interfaces import IService
        root = testing.DummyResource(__provides__=IFolder)
        catalogs1 = root['catalogs'] = testing.DummyResource(
            __provides__=IService)
        catalog1 = testing.DummyResource()
        catalogs1['catalog1'] = catalog1
        sub = testing.DummyResource(__provides__=IFolder)
        root['sub'] = sub
        catalogs2 = sub['catalogs'] = testing.DummyResource(
                                            __provides__=IService)
        catalog2 = testing.DummyResource()
        catalog1_2 = testing.DummyResource()
        sub['catalogs'] = catalogs2
        catalogs2['catalog2'] = catalog2
        catalogs2['catalog1'] = catalog1_2
        return root

    def test_no_such_catalog(self):
        resource = testing.DummyResource()
        self.assertEqual(self._callFUT(resource, 'catalog1', 'index'), None)

    def test_no_such_index(self):
        resource = self._makeTree()
        self.assertEqual(self._callFUT(resource, 'catalog1', 'index'), None)

    def test_index_found(self):
        resource = self._makeTree()
        index = testing.DummyResource()
        resource['catalogs']['catalog1']['index'] = index
        self.assertEqual(self._callFUT(resource, 'catalog1', 'index'), index)
        
class TestJsonDict(unittest.TestCase):
    def test_it(self):
        from . import JsonDict
        import json
        val = {'a':1}
        d = JsonDict(val)
        self.assertEqual(str(d), json.dumps(val))

class Test_get_principal_repr(unittest.TestCase):
    def _callFUT(self, princ):
        from . import get_principal_repr
        return get_principal_repr(princ)

    def test_int(self):
        result = self._callFUT(1)
        self.assertEqual(result, '1')

    def test_largeint(self):
        result = self._callFUT(2 << 64)
        self.assertEqual(result, '36893488147419103232')

    def test_str(self):
        result = self._callFUT('foo')
        self.assertEqual(result, 'foo')

    def test_inst_with_principal_repr(self):
        class Principal(object):
            __oid__ = 1
            def __principal_repr__(self):
                return 'me'

        inst = Principal()
        result = self._callFUT(inst)
        self.assertEqual(result, 'me')

    def test_inst_with_oid(self):
        class Principal(object):
            __oid__ = 1

        inst = Principal()
        result = self._callFUT(inst)
        self.assertEqual(result, '1')

    def test_inst_without_principal_repr_or_oid(self):
        class Principal(object):
            pass

        inst = Principal()
        self.assertRaises(ValueError, self._callFUT, inst)

class Test_find_objectmap(unittest.TestCase):
    def _callFUT(self, context):
        from . import find_objectmap
        return find_objectmap(context)

    def test_found(self):
        inst = Dummy()
        inst.__objectmap__ = '123'
        self.assertEqual(self._callFUT(inst), '123')

    def test_unfound(self):
        inst = Dummy()
        self.assertEqual(self._callFUT(inst), None)

class Test_get_icon_name(unittest.TestCase):
    def _callFUT(self, resource, request):
        from . import get_icon_name
        return get_icon_name(resource, request)
    
    def test_callable(self):
        registry = Dummy()
        request = testing.DummyRequest()
        def icon(_resource, _request):
            self.assertEqual(_resource, resource)
            self.assertEqual(_request, request)
            return 'icon'
        registry.content = DummyContentRegistry(icon)
        request.registry = registry
        resource = Dummy()
        self.assertEqual(self._callFUT(resource, request), 'icon')

    def test_noncallable(self):
        registry = Dummy()
        request = testing.DummyRequest()
        registry.content = DummyContentRegistry('icon')
        request.registry = registry
        resource = Dummy()
        self.assertEqual(self._callFUT(resource, request), 'icon')


class Test_get_auditlog(unittest.TestCase):
    def _callFUT(self, context):
        from . import get_auditlog
        return get_auditlog(context)

    def test_get_auditlog__p_jar_is_None(self):
        context = testing.DummyResource()
        context._p_jar = None
        inst = self._callFUT(context)
        self.assertEqual(inst, None)

    def test_get_auditlog_exists(self):
        context = testing.DummyResource()
        auditlog = testing.DummyResource()
        root = {'auditlog':auditlog}
        context._p_jar = DummyConnection(root=root)
        inst = self._callFUT(context)
        self.assertEqual(inst, auditlog)

    def test_get_auditlog_notexists(self):
        context = testing.DummyResource()
        root = {}
        context._p_jar = DummyConnection(root=root)
        inst = self._callFUT(context)
        self.assertEqual(inst, None)

    def test_get_auditlog_get_connection_keyerror(self):
        context = testing.DummyResource()
        context._p_jar = DummyConnection(KeyError())
        inst = self._callFUT(context)
        self.assertEqual(inst, None)


class Test_is_broken(unittest.TestCase):
    def _callFUT(self, context):
        from . import is_broken
        return is_broken(context)

    def test_with_broken(self):
        from ZODB.interfaces import IBroken
        from zope.interface import implementer

        @implementer(IBroken)
        class Broken(object):

            def __init__(self):
                pass

        resource = Broken()
        result = self._callFUT(resource)
        self.assertTrue(result)

    def test_not_broken(self):
        resource = DummyContent()
        result = self._callFUT(resource)
        self.assertFalse(result)


class Test_wrap_if_broken(unittest.TestCase):
    def _callFUT(self, context):
        from . import wrap_if_broken
        return wrap_if_broken(context)

    def test_with_broken(self):
        from ZODB.interfaces import IBroken
        from zope.interface import implementer

        @implementer(IBroken)
        class Broken(object):

            def __init__(self):
                pass

        resource = Broken()
        result = self._callFUT(resource)

        from . import BrokenWrapper
        self.assertTrue(isinstance(result, BrokenWrapper))

    def test_not_broken(self):
        resource = DummyContent()
        result = self._callFUT(resource)
        self.assertTrue(isinstance(result, DummyContent))


class Test_BrokenWrapper(unittest.TestCase):
    def _makeOne(self, context):
        from . import BrokenWrapper
        return BrokenWrapper(context)

    def test_getattr(self):
        from ZODB.interfaces import IBroken
        from zope.interface import implementer

        @implementer(IBroken)
        class Broken(object):

            def __init__(self):
                self.__Broken_state__ = dict(title='title')

        resource = Broken()
        inst = self._makeOne(resource)

        self.assertEqual(inst.title, 'title')
        self.assertRaises(AttributeError, inst.__getattr__, 'attribute')


class DummyContent(object):
    renamed_from = None
    renamed_to = None
    def __init__(self, result=None):
        self.result = result

    def rename(self, old, new):
        self.renamed_from = old
        self.renamed_to = new

class DummyRegistry(object):
    def subscribers(self, event_context, whatever):
        self.event, self.context = event_context
        self.whatever = whatever

class DummyContentRegistry(object):
    def __init__(self, result=None):
        self.result = result
    
    def metadata(self, resource, name, default=None):
        return self.result
    
    def typeof(self, resource):
        return resource.type

    def find(self, resource, content_type):
        return resource

class Dummy(object):
    pass

class DummyConnection(object):
    def __init__(self, conn=None, root=None):
        self._conn = conn
        self._root = root

    def root(self):
        return self._root

    def get_connection(self, name):
        conn = self._conn
        if isinstance(conn, KeyError):
            raise KeyError
        return self


########NEW FILE########
__FILENAME__ = subscribers
from ..util import (
    postorder,
    get_content_type,
    )

from ..event import subscribe_added

@subscribe_added()
def init_workflows_for_object(event):
    """Initialize workflows when object is added to db.
    """
    if event.moving is not None: # it's being moved
        return

    added = event.object
    registry = event.registry

    for obj in postorder(added):
        # XXX note that this logic will be called for the same set of
        # objects more than once in this scenario:
        #
        # f1 = Folder()
        # f2 = Folder()
        # someobject = SomeContentType()
        # f2['someobject'] = someobject # executed once for someobject
        # f1['f2'] = f2 # executed once for f2, then someobject
        #
        content_type = get_content_type(obj)
        if content_type is not None:
            # XXX maybe we should register workflows not relevant
            # to specific content type?
            for wf in registry.workflow.get_all_types(content_type):
                if not wf.has_state(obj):
                    wf.initialize(obj)


########NEW FILE########
__FILENAME__ = test_subscribers
import unittest
import mock
from pyramid import testing

class init_workflows_for_objectTests(unittest.TestCase):
    def setUp(self):
        testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, event):
        from substanced.workflow.subscribers import init_workflows_for_object
        return init_workflows_for_object(event)

    def test_event_moving(self):
        event = mock.Mock()
        event.moving = True
        self.assertEqual(self._callFUT(event), None)
        
    @mock.patch('substanced.workflow.subscribers.get_content_type')
    def test_no_workflows(self, mock_get_content_type):
        from substanced.workflow import WorkflowRegistry
        mock_get_content_type.return_value = "Folder"
        obj = mock.Mock()
        event = mock.Mock()
        event.registry = mock.Mock()
        event.registry.workflow = WorkflowRegistry()
        event.object = obj
        event.moving = None
        self._callFUT(event)
        self.assertEqual(obj.mock_calls, [])

    @mock.patch('substanced.workflow.subscribers.get_content_type')
    def test_no_content_type(self, mock_get_content_type):
        from substanced.interfaces import IDefaultWorkflow
        from substanced.workflow import WorkflowRegistry
        mock_get_content_type.return_value = None
        workflow = WorkflowRegistry()
        wf = mock.Mock()
        workflow.add(wf, IDefaultWorkflow)
        obj = mock.Mock()
        event = mock.Mock()
        event.registry = mock.Mock()
        event.registry.workflow = workflow
        event.object = obj
        event.moving = None
        self._callFUT(event)
        self.assertEqual(obj.mock_calls, [])

    @mock.patch('substanced.workflow.subscribers.get_content_type')
    def test_content_type_overrides_default(self, mock_get_content_type):
        from substanced.interfaces import IDefaultWorkflow
        from substanced.workflow import WorkflowRegistry
        mock_get_content_type.return_value = "Folder"
        workflow = WorkflowRegistry()
        wf = mock.Mock()
        wf.type = "basic"
        wf_specific = mock.Mock()
        wf_specific.type = "basic"
        wf_specific.has_state.return_value = False
        workflow.add(wf, IDefaultWorkflow)
        workflow.add(wf_specific, 'Folder')
        obj = mock.Mock()
        event = mock.Mock()
        event.registry = mock.Mock()
        event.registry.workflow = workflow
        event.object = obj
        event.moving = None
        self._callFUT(event)
        self.assertEqual(obj.mock_calls, [])
        self.assertEqual(wf.mock_calls, [])
        self.assertEqual(wf_specific.mock_calls,
                         [mock.call.has_state(obj),
                          mock.call.initialize(obj)])

    @mock.patch('substanced.workflow.subscribers.get_content_type')
    def test_apply_defaults_and_specific(self, mock_get_content_type):
        from substanced.interfaces import IDefaultWorkflow
        from substanced.workflow import WorkflowRegistry
        mock_get_content_type.return_value = "Folder"
        workflow = WorkflowRegistry()
        wf = mock.Mock()
        wf.type = "basic"
        wf.has_state.return_value = False
        wf_specific = mock.Mock()
        wf_specific.type = "basic_2"
        wf_specific.has_state.return_value = False
        workflow.add(wf, IDefaultWorkflow)
        workflow.add(wf_specific, 'Folder')
        obj = mock.Mock()
        event = mock.Mock()
        event.object = obj
        event.registry = mock.Mock()
        event.registry.workflow = workflow
        event.object = obj
        event.moving = None
        self._callFUT(event)
        self.assertEqual(obj.mock_calls, [])
        self.assertEqual(
            wf.mock_calls,
            [mock.call.has_state(obj), mock.call.initialize(obj)]
            )
        self.assertEqual(
            wf_specific.mock_calls,
            [mock.call.has_state(obj), mock.call.initialize(obj)])

    @mock.patch('substanced.workflow.subscribers.get_content_type')
    def test_apply_only_specific(self, mock_get_content_type):
        from substanced.workflow import WorkflowRegistry
        mock_get_content_type.return_value = "Folder"
        workflow = WorkflowRegistry()
        wf = mock.Mock()
        wf.type = "basic"
        wf.has_state.return_value = False
        workflow.add(wf, 'Folder')
        obj = mock.Mock()
        event = mock.Mock()
        event.registry = mock.Mock()
        event.registry.workflow = workflow
        event.object = obj
        event.moving = None
        self._callFUT(event)
        self.assertEqual(obj.mock_calls, [])
        self.assertEqual(
            wf.mock_calls,
            [mock.call.has_state(obj),
             mock.call.initialize(obj),]
            )

    @mock.patch('substanced.workflow.subscribers.get_content_type')
    def test_apply_hierarchy(self, mock_get_content_type):
        from zope.interface import directlyProvides
        from substanced.interfaces import IFolder
        from substanced.workflow import WorkflowRegistry
        mock_get_content_type.return_value = "Folder"
        workflow = WorkflowRegistry()
        wf = mock.Mock()
        wf.type = "basic"
        wf.has_state.return_value = False
        workflow.add(wf, 'Folder')
        obj = DummyContent()
        obj2 = mock.Mock()
        obj.items = lambda *arg: [('obj2', obj2)]
        directlyProvides(obj, IFolder)
        event = mock.Mock()
        event.registry = mock.Mock()
        event.registry.workflow = workflow
        event.object = obj
        event.moving = None
        self._callFUT(event)
        self.assertEqual(obj2.mock_calls, [])
        self.assertEqual(
            wf.mock_calls,
            [
                mock.call.has_state(obj2),
                mock.call.initialize(obj2),
                mock.call.has_state(obj),
                mock.call.initialize(obj)
                ]
            )

class DummyContent:
    pass


########NEW FILE########
__FILENAME__ = test_views
import unittest

from pyramid import testing

class TestIndexingView(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _makeOne(self, context, request):
        from  ..views import WorkflowViews
        return WorkflowViews(context, request)

    def test__get_workflows(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.registry.content = DummyContent()
        workflow = DummyWorkflow('result')
        request.registry.workflow = DummyWorkflowRegistry([workflow])
        inst = self._makeOne(context, request)
        results = inst._get_workflows()
        self.assertEqual(results, [workflow])
        

    def test_show(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        inst = self._makeOne(context, request)
        workflow = DummyWorkflow('result')
        inst._get_workflows = lambda: [workflow]
        result = inst.show()
        self.assertEqual(
            result,
            {'workflows': [
                {'states': 'result',
                 'transitions': 'result',
                 'id': 'workflow',
                 'current_state':'result',
                 'workflow': workflow}]
             }
            )

    def test_reindex(self):
        context = testing.DummyResource()
        request = testing.DummyRequest()
        request.sdiapi = DummySDIAPI()
        request.POST['wfid'] = 'workflow'
        request.POST['transition'] = 'doit'
        workflow = DummyWorkflow('result')
        inst = self._makeOne(context, request)
        inst._get_workflows = lambda: [workflow]
        result = inst.transition()
        self.assertEqual(result.__class__.__name__, 'HTTPFound')
        self.assertTrue(workflow.transitioned, True)

class DummyWorkflow(object):
    type = 'workflow'
    name = 'workflow'
    def __init__(self, result):
        self.result = result

    def get_transitions(self, *arg):
        return self.result

    def get_states(self, *arg):
        return self.result

    def transition(self, context, request, name):
        self.transitioned = True

    def state_of(self, context):
        return self.result
        
class DummyWorkflowRegistry(object):
    def __init__(self, result):
        self.result = result

    def get_all_types(self, content_type):
        return self.result
    
class DummyContent(object):
    def typeof(self, context):
        return 'abc'

class DummySDIAPI(object):
    def mgmt_url(self, *arg, **kw):
        return 'http://mgmt_url'

    def flash(self, msg, queue='info'):
        self.flashed = msg

########NEW FILE########
__FILENAME__ = test_workflow
import unittest
import mock

from pyramid import testing

class WorkflowTests(unittest.TestCase):

    def _getTargetClass(self):
        from substanced.workflow import Workflow
        return Workflow

    def _makeOne(self, initial_state='pending', type='basic'):
        klass = self._getTargetClass()
        return klass(initial_state, type)

    def _makePopulated(self, state_callback=None, transition_callback=None):
        sm = self._makeOne()
        sm._states['pending'] = {'callback': state_callback}
        sm._states['published'] = {'callback': state_callback}
        sm._states['private'] = {'callback': state_callback}
        tdata = sm._transitions
        tdata['publish'] = dict(name='publish',
                                from_state='pending',
                                to_state='published',
                                callback=transition_callback)
        tdata['reject'] = dict(name='reject',
                               from_state='pending',
                               to_state='private',
                               callback=transition_callback)
        tdata['retract'] = dict(name='retract',
                                from_state='published',
                                to_state='pending',
                                callback=transition_callback)
        tdata['submit'] = dict(name='submit',
                               from_state='private',
                               to_state='pending',
                               callback=transition_callback)
        return sm

    def _makePopulatedOverlappingTransitions(
            self, state_callback=None, transition_callback=None):
        sm = self._makePopulated(state_callback, transition_callback)

        sm._transitions['submit2'] = dict(
            name='submit2',
            from_state='private',
            to_state='pending',
            callback=transition_callback,
            )
        return sm

    @mock.patch('substanced.workflow.has_permission')
    def test_transition_to_state_two_transitions_second_works(
            self, mock_has_permission):
        args = []
        def dummy(content, **info):
            args.append((content, info))

        sm = self._makePopulatedOverlappingTransitions(
            transition_callback=dummy,
            )

        sm._transitions['submit']['permission'] = 'forbidden'
        sm._transitions['submit2']['permission'] = 'allowed'

        mock_has_permission.side_effect = lambda p, c, r: p != 'forbidden'
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'private'}
        sm.transition_to_state(ob, object(), 'pending')
        self.assertEqual(len(args), 1)
        self.assertEqual(args[0][1]['transition']['name'], 'submit2')

    @mock.patch('substanced.workflow.has_permission')
    def test_transition_to_state_two_transitions_none_works(
            self, mock_has_permission):
        callback_args = []
        def dummy(content, info):  # pragma NO COVER
            callback_args.append((content, info))

        sm = self._makePopulatedOverlappingTransitions(
            transition_callback=dummy,
            )

        sm._transitions['submit']['permission'] = 'forbidden1'
        sm._transitions['submit2']['permission'] = 'forbidden2'

        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'private'}
        request = object()
        from substanced.workflow import WorkflowError
        mock_has_permission.return_value = False
        self.assertRaises(WorkflowError, sm.transition_to_state,
                          ob, request, 'pending')
        self.assertEqual(len(callback_args), 0)
        pcalls = sorted(mock_has_permission.mock_calls)
        self.assertEqual(pcalls[0], mock.call('forbidden1', ob, request))
        self.assertEqual(pcalls[1], mock.call('forbidden2', ob, request))

    def test_class_conforms_to_IWorkflow(self):
        from zope.interface.verify import verifyClass
        from substanced.interfaces import IWorkflow
        verifyClass(IWorkflow, self._getTargetClass())

    def test_instance_conforms_to_IWorkflow(self):
        from zope.interface.verify import verifyObject
        from substanced.interfaces import IWorkflow
        verifyObject(IWorkflow, self._makeOne())

    def test_has_state_false(self):
        sm = self._makeOne()
        self.assertEqual(sm.has_state(None), False)

    def test_has_state_true(self):
        sm = self._makeOne()
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'abc'}
        self.assertEqual(sm.has_state(ob), True)

    def test_state_of_uninitialized(self):
        sm = self._makeOne()
        ob = DummyContent()
        self.assertEqual(sm.state_of(ob), None)

    def test_state_of_initialized(self):
        sm = self._makeOne()
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'pending'}
        self.assertEqual(sm.state_of(ob), 'pending')

    def test_state_of_no_workflow_is_None(self):
        sm = self._makeOne()
        sm.add_state('pending')
        ob = DummyContent()
        self.assertEqual(sm.state_of(ob), None)

    def test_state_of_nondefault(self):
        sm = self._makeOne()
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'pending'}
        self.assertEqual(sm.state_of(ob), 'pending')

    def test_state_of_None_is_None(self):
        sm = self._makeOne()
        self.assertEqual(sm.state_of(None), None)

    def test_add_state_state_exists(self):
        from substanced.workflow import WorkflowError
        sm = self._makeOne()
        sm._states = {'foo': {'c': 5}}
        self.assertRaises(WorkflowError, sm.add_state, 'foo')

    def test_add_state_info_state_doesntexist(self):
        sm = self._makeOne()
        callback = object()
        sm.add_state('foo', callback, a=1, b=2)
        self.assertEqual(sm._states,
                         {'foo': {'callback': callback, 'a': 1, 'b': 2}})

    def test_add_state_defaults(self):
        sm = self._makeOne()
        sm.add_state('foo')
        self.assertEqual(sm._states, {'foo': {'callback': None}})

    def test_add_state_w_custom_factory(self):
        sm = self._makeOne()
        _THE_STATE = object()
        _called_with = []
        def _factory(*args, **kw):
            _called_with.append((args, kw))
            return _THE_STATE
        sm._state_factory = _factory
        sm.add_state('foo')
        self.assertEqual(sm._states, {'foo': _THE_STATE})
        self.assertEqual(_called_with, [((), {'callback': None})])

    def test_add_transition_transition_name_already_exists(self):
        from substanced.workflow import WorkflowError
        sm = self._makeOne()
        sm.add_state('public')
        sm.add_state('private')
        sm.add_transition('make_public', 'private', 'public', None, a=1)
        self.assertRaises(WorkflowError, sm.add_transition, 'make_public',
                          'private', 'public')

    def test_add_transition_from_state_doesnt_exist(self):
        from substanced.workflow import WorkflowError
        sm = self._makeOne()
        sm.add_state('public')
        self.assertRaises(WorkflowError, sm.add_transition, 'make_public',
                          'private', 'public')

    def test_add_transition_to_state_doesnt_exist(self):
        from substanced.workflow import WorkflowError
        sm = self._makeOne()
        sm.add_state('private')
        self.assertRaises(WorkflowError, sm.add_transition, 'make_public',
                          'private', 'public')

    def test_add_transition(self):
        sm = self._makeOne()
        sm.add_state('public')
        sm.add_state('private')
        sm.add_transition('make_public', 'private', 'public', None, a=1)
        sm.add_transition('make_private', 'public', 'private', None, b=2)
        self.assertEqual(len(sm._transitions), 2)
        make_public = sm._transitions['make_public']
        self.assertEqual(make_public['name'], 'make_public')
        self.assertEqual(make_public['from_state'], 'private')
        self.assertEqual(make_public['to_state'], 'public')
        self.assertEqual(make_public['callback'], None)
        self.assertEqual(make_public['a'], 1)
        make_private = sm._transitions['make_private']
        self.assertEqual(make_private['name'], 'make_private')
        self.assertEqual(make_private['from_state'], 'public')
        self.assertEqual(make_private['to_state'], 'private')
        self.assertEqual(make_private['callback'], None)
        self.assertEqual(make_private['b'], 2)
        self.assertEqual(len(sm._states), 2)

    def test_add_transition_w_custom_factory(self):
        sm = self._makeOne()
        _THE_TRANSITION = object()
        _called_with = []
        def _factory(*args, **kw):
            _called_with.append((args, kw))
            return _THE_TRANSITION
        sm._transition_factory = _factory
        sm.add_state('public')
        sm.add_state('private')
        sm.add_transition('make_public', 'private', 'public', None, a=1)
        self.assertEqual(sm._transitions, {'make_public': _THE_TRANSITION})
        self.assertEqual(_called_with,
                         [((), {'name': 'make_public',
                                'from_state': 'private',
                                'to_state': 'public',
                                'permission': None,
                                'callback': None,
                                'a': 1})])

    def test_check_fails(self):
        from substanced.workflow import WorkflowError
        sm = self._makeOne()
        self.assertRaises(WorkflowError, sm.check)

    def test_check_succeeds(self):
        sm = self._makeOne()
        sm.add_state('pending')
        self.assertEqual(sm.check(), None)

    def test__get_transitions_default_from_state(self):
        import operator
        sm = self._makePopulated()
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'pending'}
        result = sorted(sm._get_transitions(ob),
                        key=operator.itemgetter('name'))
        self.assertEqual(len(result), 2)
        self.assertEqual(result[0]['name'], 'publish')
        self.assertEqual(result[1]['name'], 'reject')

    def test__get_transitions_overridden_from_state(self):
        sm = self._makePopulated()
        ob = DummyContent()
        result = sm._get_transitions(ob, from_state='private')
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0]['name'], 'submit')

    def test__get_transitions_content_has_state(self):
        sm = self._makePopulated()
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'published'}
        result = sm._get_transitions(ob)
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0]['name'], 'retract')

    def test__transition(self):
        args = []
        def dummy(content, **kw):
            args.append((content, kw))
        sm = self._makePopulated(transition_callback=dummy)
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'pending'}
        sm._transition(ob, 'publish')
        self.assertEqual(ob.__workflow_state__['basic'], 'published')
        sm._transition(ob, 'retract')
        self.assertEqual(ob.__workflow_state__['basic'], 'pending')
        sm._transition(ob, 'reject')
        self.assertEqual(ob.__workflow_state__['basic'], 'private')
        sm._transition(ob, 'submit')
        self.assertEqual(ob.__workflow_state__['basic'], 'pending')

        self.assertEqual(len(args), 4)
        self.assertEqual(args[0][0], ob)
        info = args[0][1]
        self.assertEqual(info['transition'], {'from_state': 'pending',
                                              'callback': dummy,
                                              'to_state': 'published',
                                              'name': 'publish'})
        self.assertEqual(info['workflow'], sm)
        self.assertEqual(args[1][0], ob)
        info = args[1][1]
        self.assertEqual(info['transition'], {'from_state': 'published',
                                              'callback': dummy,
                                              'to_state': 'pending',
                                              'name': 'retract'})
        self.assertEqual(args[1][0], ob)
        self.assertEqual(args[2][0], ob)
        info = args[2][1]
        self.assertEqual(info['transition'], {'from_state': 'pending',
                                              'callback': dummy,
                                              'to_state': 'private',
                                              'name': 'reject'})
        self.assertEqual(info['workflow'], sm)
        self.assertEqual(args[3][0], ob)
        info = args[3][1]
        self.assertEqual(info['transition'], {'from_state': 'private',
                                              'callback': dummy,
                                              'to_state': 'pending',
                                              'name': 'submit'})
        self.assertEqual(info['workflow'], sm)

    def test__transition_with_state_callback(self):
        def dummy(content, **kw):
            content.info = kw
        sm = self._makePopulated(state_callback=dummy)
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'pending'}
        sm._transition(ob, 'publish')
        self.assertEqual(ob.info['transition'],
                         {'from_state': 'pending',
                          'callback': None,
                          'to_state':
                          'published',
                          'name': 'publish'})
        self.assertEqual(ob.info['workflow'], sm)

    def test__transition_with_custom_state_callback(self):
        class _State(dict):
            _called = None
            def __call__(self, content, **kw):
                self._called = (content, kw)
        sm = self._makeOne()
        sm._state_factory = _State
        sm.add_state('pending')
        sm.add_state('published')
        sm.add_transition('publish', 'pending', 'published')
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'pending'}
        sm._transition(ob, 'publish')
        called = sm._states['published']._called
        self.assertEqual(called[0], ob)
        self.assertEqual(called[1], {'request': None,
                                     'transition': {'from_state': 'pending',
                                                    'callback': None,
                                                    'to_state': 'published',
                                                    'permission': None,
                                                    'name': 'publish',
                                                   },
                                     'workflow': sm,
                                    })

    def test__transition_error(self):
        sm = self._makeOne(initial_state='pending')
        sm.add_state('pending')
        ob = DummyContent()
        from substanced.workflow import WorkflowError
        self.assertRaises(WorkflowError, sm._transition, ob, 'nosuch')

    def test__transition_to_state_same(self):
        sm = self._makePopulated()
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'pending'}
        sm._transition_to_state(ob, 'pending')
        self.assertEqual(ob.__workflow_state__['basic'], 'pending')

    def test__transition_to_state(self):
        args = []
        def dummy(content, **info):
            args.append((content, info))
        sm = self._makePopulated(transition_callback=dummy)
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'pending'}
        sm._transition_to_state(ob, 'published')
        self.assertEqual(ob.__workflow_state__['basic'], 'published')
        sm._transition_to_state(ob, 'pending')
        self.assertEqual(ob.__workflow_state__['basic'], 'pending')
        sm._transition_to_state(ob, 'private')
        self.assertEqual(ob.__workflow_state__['basic'], 'private')
        sm._transition_to_state(ob, 'pending')

        self.assertEqual(len(args), 4)
        self.assertEqual(args[0][0], ob)
        info = args[0][1]
        self.assertEqual(info['transition'], {'from_state': 'pending',
                                              'callback': dummy,
                                              'to_state': 'published',
                                              'name': 'publish'})
        self.assertEqual(info['workflow'], sm)
        self.assertEqual(args[1][0], ob)
        info = args[1][1]
        self.assertEqual(info['transition'], {'from_state': 'published',
                                              'callback': dummy,
                                              'to_state': 'pending',
                                              'name': 'retract'})
        self.assertEqual(info['workflow'], sm)
        self.assertEqual(args[2][0], ob)
        info = args[2][1]
        self.assertEqual(info['transition'], {'from_state': 'pending',
                                              'callback': dummy,
                                              'to_state': 'private',
                                              'name': 'reject'})
        self.assertEqual(info['workflow'], sm)
        self.assertEqual(args[3][0], ob)
        info = args[3][1]
        self.assertEqual(info['transition'], {'from_state': 'private',
                                              'callback': dummy,
                                              'to_state': 'pending',
                                              'name': 'submit'})
        self.assertEqual(info['workflow'], sm)

    def test__transition_to_state_error(self):
        sm = self._makeOne(initial_state='pending')
        sm.add_state('pending')
        ob = DummyContent()
        from substanced.workflow import WorkflowError
        self.assertRaises(WorkflowError, sm._transition_to_state, ob,
                          'nosuch')

    def test__transition_to_state_skip_same_false(self):
        sm = self._makeOne(initial_state='pending')
        sm.add_state('pending')
        ob = DummyContent()
        from substanced.workflow import WorkflowError
        self.assertRaises(WorkflowError, sm._transition_to_state, ob, None,
                          'pending', (), False)

    def test__transition_to_state_skip_same_true(self):
        sm = self._makeOne(initial_state='pending')
        ob = DummyContent()
        ob.__workflow_state__ = {}
        ob.__workflow_state__['basic'] = 'pending'
        self.assertEqual(sm._transition_to_state(ob, 'pending', (), True),
                         None)

    def test__state_with_title(self):
        sm = self._makeOne()
        sm.add_state('pending', title='Pending')
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'pending'}
        result = sm._get_states(ob)

        state = result[0]
        self.assertEqual(state['initial'], True)
        self.assertEqual(state['current'], True)
        self.assertEqual(state['name'], 'pending')
        self.assertEqual(state['title'], 'Pending')
        self.assertEqual(state['data'], {'callback': None, 'title': 'Pending'})
        self.assertEqual(len(state['transitions']), 0)

    def test__get_states_pending(self):
        from operator import itemgetter
        sm = self._makePopulated()
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'pending'}
        result = sorted(sm._get_states(ob), key=itemgetter('name'))
        self.assertEqual(len(result), 3)

        state = result[0]
        self.assertEqual(state['name'], 'pending')
        self.assertEqual(state['initial'], True)
        self.assertEqual(state['current'], True)
        self.assertEqual(state['title'], 'pending')
        self.assertEqual(state['data'], {'callback': None})
        self.assertEqual(len(state['transitions']), 0)

        state = result[1]
        self.assertEqual(state['name'], 'private')
        self.assertEqual(state['initial'], False)
        self.assertEqual(state['current'], False)
        self.assertEqual(state['title'], 'private')
        self.assertEqual(state['data'], {'callback': None})
        self.assertEqual(len(state['transitions']), 1)
        self.assertEqual(state['transitions'][0]['name'], 'reject')

        state = result[2]
        self.assertEqual(state['name'], 'published')
        self.assertEqual(state['initial'], False)
        self.assertEqual(state['current'], False)
        self.assertEqual(state['title'], 'published')
        self.assertEqual(state['data'], {'callback': None})
        self.assertEqual(len(state['transitions']), 1)
        self.assertEqual(state['transitions'][0]['name'], 'publish')

    def test__get_states_published(self):
        from operator import itemgetter
        sm = self._makePopulated()
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'published'}
        result = sorted(sm._get_states(ob), key=itemgetter('name'))
        self.assertEqual(len(result), 3)

        state = result[0]
        self.assertEqual(state['name'], 'pending')
        self.assertEqual(state['initial'], True)
        self.assertEqual(state['current'], False)
        self.assertEqual(state['title'], 'pending')
        self.assertEqual(state['data'], {'callback': None})
        self.assertEqual(len(state['transitions']), 1)
        self.assertEqual(state['transitions'][0]['name'], 'retract')

        state = result[1]
        self.assertEqual(state['name'], 'private')
        self.assertEqual(state['initial'], False)
        self.assertEqual(state['current'], False)
        self.assertEqual(state['title'], 'private')
        self.assertEqual(state['data'], {'callback': None})
        self.assertEqual(len(state['transitions']), 0)

        state = result[2]
        self.assertEqual(state['name'], 'published')
        self.assertEqual(state['initial'], False)
        self.assertEqual(state['current'], True)
        self.assertEqual(state['title'], 'published')
        self.assertEqual(state['data'], {'callback': None})
        self.assertEqual(len(state['transitions']), 0)

    def test__get_states_private(self):
        from operator import itemgetter
        sm = self._makePopulated()
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'private'}
        result = sorted(sm._get_states(ob), key=itemgetter('name'))
        self.assertEqual(len(result), 3)

        state = result[0]
        self.assertEqual(state['name'], 'pending')
        self.assertEqual(state['initial'], True)
        self.assertEqual(state['current'], False)
        self.assertEqual(state['title'], 'pending')
        self.assertEqual(state['data'], {'callback': None})
        self.assertEqual(len(state['transitions']), 1)
        self.assertEqual(state['transitions'][0]['name'], 'submit')

        state = result[1]
        self.assertEqual(state['name'], 'private')
        self.assertEqual(state['initial'], False)
        self.assertEqual(state['current'], True)
        self.assertEqual(state['title'], 'private')
        self.assertEqual(state['data'], {'callback': None})
        self.assertEqual(len(state['transitions']), 0)

        state = result[2]
        self.assertEqual(state['name'], 'published')
        self.assertEqual(state['initial'], False)
        self.assertEqual(state['current'], False)
        self.assertEqual(state['title'], 'published')
        self.assertEqual(state['data'], {'callback': None})
        self.assertEqual(len(state['transitions']), 0)

    def test_initialize_no_initializer(self):
        sm = self._makeOne(initial_state='pending')
        sm.add_state('pending')
        ob = DummyContent()
        state, msg = sm.initialize(ob)
        self.assertEqual(ob.__workflow_state__['basic'], 'pending')
        self.assertEqual(msg, None)
        self.assertEqual(state, 'pending')

    def test_initialize_with_initializer(self):
        def initializer(content, **kw):
            content.initialized = True
            return 'abc'
        sm = self._makeOne(initial_state='pending')
        sm.add_state('pending', initializer)
        ob = DummyContent()
        state, msg = sm.initialize(ob)
        self.assertEqual(ob.__workflow_state__['basic'], 'pending')
        self.assertEqual(ob.initialized, True)
        self.assertEqual(msg, 'abc')
        self.assertEqual(state, 'pending')

    def test_reset_content_has_no_state(self):
        from persistent.mapping import PersistentMapping
        def callback(content, **kw):
            content.called_back = True
            return '123'
        sm = self._makeOne(initial_state='pending')
        sm.add_state('pending', callback=callback)
        ob = DummyContent()
        state, msg = sm.reset(ob)
        self.assertEqual(ob.__workflow_state__.__class__, PersistentMapping)
        self.assertEqual(ob.__workflow_state__['basic'], 'pending')
        self.assertEqual(ob.called_back, True)
        self.assertEqual(state, 'pending')
        self.assertEqual(msg, '123')

    def test_reset_content_no_callback(self):
        sm = self._makeOne(initial_state='pending')
        sm.add_state('pending',)
        ob = DummyContent()
        state, msg = sm.reset(ob)
        self.assertEqual(ob.__workflow_state__['basic'], 'pending')
        self.assertEqual(state, 'pending')
        self.assertEqual(msg, None)

    def test_reset_content_has_state(self):
        def callback(content, **kw):
            content.called_back = True
            return '123'
        sm = self._makeOne(initial_state='pending')
        sm.add_state('pending')
        sm.add_state('private', callback=callback)
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'private'}
        state, msg = sm.reset(ob)
        self.assertEqual(ob.__workflow_state__['basic'], 'private')
        self.assertEqual(ob.called_back, True)
        self.assertEqual(state, 'private')
        self.assertEqual(msg, '123')

    def test_reset_content_has_state_not_in_workflow(self):
        from substanced.workflow import WorkflowError
        sm = self._makeOne(initial_state='pending')
        sm.add_state('pending')
        ob = DummyContent()
        ob.__workflow_state__ = {'basic': 'supersecret'}
        self.assertRaises(WorkflowError, sm.reset, ob)

    def test_transition_permission_is_None(self):
        workflow = self._makeOne()
        transitioned = []
        def append(content, name, context=None, request=None):
            D = {'content': content, 'name': name, 'request': request,
                 'context': context}
            transitioned.append(D)
        workflow._transition = lambda *arg, **kw: append(*arg, **kw)
        content = DummyContent()
        content.__workflow_state__ = {'basic': 'pending'}
        request = object()
        workflow.transition(content, request, 'publish')
        self.assertEqual(len(transitioned), 1)
        transitioned = transitioned[0]
        self.assertEqual(transitioned['content'], content)
        self.assertEqual(transitioned['name'], 'publish')
        self.assertEqual(transitioned['request'], request)
        self.assertEqual(transitioned['context'], None)

    @mock.patch('substanced.workflow.has_permission')
    def test_transition_to_state_not_permissive(self, mock_has_permission):
        mock_has_permission.return_value = False
        workflow = self._makeOne()
        transitioned = []
        def append(content, name, context=None, request=None,
                   skip_same=True):
            D = {'content': content, 'name': name, 'request': request,
                 'context': context, 'skip_same': skip_same}
            transitioned.append(D)
        workflow._transition_to_state = lambda *arg, **kw: append(*arg, **kw)
        request = object()
        content = DummyContent()
        content.__workflow_state__ = {'basic': 'pending'}
        workflow.transition_to_state(content, request, 'published')
        self.assertEqual(len(transitioned), 1)
        transitioned = transitioned[0]
        self.assertEqual(transitioned['content'], content)
        self.assertEqual(transitioned['name'], 'published')
        self.assertEqual(transitioned['request'], request)
        self.assertEqual(transitioned['context'], None)
        self.assertEqual(transitioned['skip_same'], True)

    def test_transition_to_state_request_is_None(self):
        workflow = self._makeOne()
        transitioned = []
        def append(content, name, context=None, request=None,
                   skip_same=True):
            D = {'content': content, 'name': name, 'request': request,
                 'context': context, 'skip_same': skip_same}
            transitioned.append(D)
        workflow._transition_to_state = lambda *arg, **kw: append(*arg, **kw)
        content = DummyContent()
        content.__workflow_state__ = {'basic': 'pending'}
        workflow.transition_to_state(content, None, 'published')
        self.assertEqual(len(transitioned), 1)
        transitioned = transitioned[0]
        self.assertEqual(transitioned['content'], content)
        self.assertEqual(transitioned['name'], 'published')
        self.assertEqual(transitioned['request'], None)
        self.assertEqual(transitioned['context'], None)
        self.assertEqual(transitioned['skip_same'], True)

    def test_transition_to_state_permission_is_None(self):
        workflow = self._makeOne()
        transitioned = []
        def append(content, name, context=None, request=None,
                   skip_same=True):
            D = {'content': content, 'name': name, 'request': request,
                 'context': context, 'skip_same': skip_same}
            transitioned.append(D)
        workflow._transition_to_state = lambda *arg, **kw: append(*arg, **kw)
        content = DummyContent()
        content.__workflow_state__ = {'basic': 'pending'}
        request = object()
        workflow.transition_to_state(content, request, 'published')
        self.assertEqual(len(transitioned), 1)
        transitioned = transitioned[0]
        self.assertEqual(transitioned['content'], content)
        self.assertEqual(transitioned['name'], 'published')
        self.assertEqual(transitioned['request'], request)
        self.assertEqual(transitioned['context'], None)
        self.assertEqual(transitioned['skip_same'], True)

    @mock.patch('substanced.workflow.has_permission')
    def test_get_transitions_permissive(self, mock_has_permission):
        mock_has_permission.return_value = True
        workflow = self._makeOne()
        workflow._get_transitions = \
            lambda *arg, **kw: [{'permission': 'view'}, {}]
        transitions = workflow.get_transitions(None, None, 'private')
        self.assertEqual(len(transitions), 2)
        self.assertEqual(mock_has_permission.mock_calls,
                         [mock.call('view', None, None)])

    @mock.patch('substanced.workflow.has_permission')
    def test_get_transitions_nonpermissive(self, mock_has_permission):
        mock_has_permission.return_value = False
        workflow = self._makeOne()
        workflow._get_transitions = \
            lambda *arg, **kw: [{'permission': 'view'}, {}]
        transitions = workflow.get_transitions(None, 'private')
        self.assertEqual(len(transitions), 1)
        self.assertEqual(mock_has_permission.mock_calls,
                         [mock.call('view', None, 'private')])

    @mock.patch('substanced.workflow.has_permission')
    def test_get_states_permissive(self, mock_has_permission):
        mock_has_permission.return_value = True
        state_info = []
        state_info.append({'transitions': [{'permission': 'view'}, {}]})
        state_info.append({'transitions': [{'permission': 'view'}, {}]})
        workflow = self._makeOne()
        workflow._get_states = lambda *arg, **kw: state_info
        request = object()
        result = workflow.get_states(request, 'whatever')
        self.assertEqual(result, state_info)
        self.assertEqual(mock_has_permission.mock_calls,
                         [mock.call('view', request, 'whatever'),
                          mock.call('view', request, 'whatever')])

    @mock.patch('substanced.workflow.has_permission')
    def test_get_states_nonpermissive(self, mock_has_permission):
        mock_has_permission.return_value = False
        state_info = []
        state_info.append({'transitions': [{'permission': 'view'}, {}]})
        state_info.append({'transitions': [{'permission': 'view'}, {}]})
        workflow = self._makeOne()
        workflow._get_states = lambda *arg, **kw: state_info
        request = object()
        result = workflow.get_states(request, 'whatever')
        self.assertEqual(result, [{'transitions': [{}]},
                                  {'transitions': [{}]}])
        self.assertEqual(mock_has_permission.mock_calls,
                         [mock.call('view', request, 'whatever'),
                          mock.call('view', request, 'whatever')])

    def test_callbackinfo_has_request(self):
        def transition_cb(content, **info):
            self.assertEqual(info['request'], request)
        def state_cb(content, **kw):
            self.assertEqual(kw['request'], request)
        wf = self._makeOne('initial')
        wf.add_state('initial', callback=state_cb)
        wf.add_state('new')
        wf.add_transition('tonew',
                          'initial',
                          'new',
                          callback=transition_cb)
        request = object()
        content = DummyContent()
        wf.initialize(content, request=request)
        wf.transition_to_state(content, request, 'new')

class GetWorkflowTests(unittest.TestCase):

    def setUp(self):
        from substanced.workflow import includeme
        self.config = testing.setUp()
        includeme(self.config)

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, content_type, type=''):
        from substanced.workflow import get_workflow
        return get_workflow(testing.DummyRequest(), type, content_type)

    def _registerWorkflowList(self, content_type, workflows):
        for wf in workflows:
            wf.type = ''
            self.config.registry.workflow.add(wf, content_type)

    def test_content_type_is_None_no_registered_workflows(self):
        self.assertEqual(self._callFUT(None, ''), None)

    def test_content_type_is_IDefaultWorkflow_no_registered_workflows(self):
        from substanced.interfaces import IDefaultWorkflow
        self.assertEqual(self._callFUT(IDefaultWorkflow, ''), None)

    def test_content_type_is_None_registered_workflow(self):
        from substanced.interfaces import IDefaultWorkflow
        workflow = mock.Mock()
        self._registerWorkflowList(IDefaultWorkflow, [workflow])
        result = self._callFUT(None)
        self.assertEqual(result, workflow)

    def test_content_type_is_class_registered_workflow(self):
        from substanced.interfaces import IDefaultWorkflow
        workflow = mock.Mock()
        self._registerWorkflowList(IDefaultWorkflow, [workflow])
        result = self._callFUT('Folder')
        self.assertEqual(result, workflow)

    def test_content_type_is_IDefaultWorkflow_registered_workflow(self):
        from substanced.interfaces import IDefaultWorkflow
        workflow = mock.Mock()
        self._registerWorkflowList(IDefaultWorkflow, [workflow])
        self.assertEqual(self._callFUT(IDefaultWorkflow),
                         workflow)

    def test_content_type_is_Folder_no_registered_workflows(self):
        self.assertEqual(self._callFUT('Folder', ''), None)

    def test_content_type_is_Folder_finds_default(self):
        from substanced.interfaces import IDefaultWorkflow
        workflow = mock.Mock()
        self._registerWorkflowList(IDefaultWorkflow, [workflow])
        self.assertEqual(self._callFUT('Folder'), workflow)

    def test_content_type_is_Folder_finds_specific(self):
        workflow = mock.Mock()
        self._registerWorkflowList('Folder', [workflow])
        self.assertEqual(self._callFUT('Folder'), workflow)

    def test_content_type_is_Folder_finds_more_specific_first(self):
        from substanced.interfaces import IDefaultWorkflow
        default_workflow = mock.Mock()
        specific_workflow = mock.Mock()
        self._registerWorkflowList('Folder', [specific_workflow])
        self._registerWorkflowList(IDefaultWorkflow, [default_workflow])
        self.assertEqual(
            self._callFUT('Folder'),
            specific_workflow)
        self.assertEqual(
            self._callFUT(None),
            default_workflow)

class add_workflowTests(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp()
        from substanced.workflow import includeme
        includeme(self.config)

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, workflow, config, content_types=(None,)):
        from substanced.workflow import add_workflow
        add_workflow(config, workflow, content_types)

    def _makeWorkflow(self):
        from zope.interface import implementer
        from substanced.interfaces import IWorkflow
        @implementer(IWorkflow)
        class _Workflow(object):
            type = 'testing'
            def check(self):
                pass
        return _Workflow()

    def test_add_workflow_doesnt_implement_iworkflow(self):
        config = mock.Mock()
        self.assertRaises(ValueError, self._callFUT, object(), config)

    def test_add_workflow_global(self):
        from substanced.interfaces import IWorkflow
        from substanced.workflow import register_workflow
        config = mock.MagicMock()
        wf = self._makeWorkflow()
        self._callFUT(wf, config)

        self.assertEqual(config.action.mock_calls, [
            mock.call((IWorkflow, None, wf.type),
                      callable=register_workflow,
                      introspectables=(mock.ANY,),
                      order=9999,
                      args=(config, wf, wf.type, None))
        ])

    def test_add_workflow_multi_content_types(self):
        from substanced.interfaces import IWorkflow
        from substanced.workflow import register_workflow
        config = mock.MagicMock()
        wf = self._makeWorkflow()
        self._callFUT(wf, config, content_types=('Folder', 'File'))

        self.assertEqual(config.action.mock_calls, [
            mock.call((IWorkflow, 'Folder', wf.type),
                      callable=register_workflow,
                      introspectables=(mock.ANY,),
                      order=9999,
                      args=(config, wf, wf.type, 'Folder')),
            mock.call((IWorkflow, 'File', wf.type),
                      callable=register_workflow,
                      introspectables=(mock.ANY,),
                      order=9999,
                      args=(config, wf, wf.type, 'File')),
        ])

    def test_add_workflow_check_error(self):
        from pyramid.config import ConfigurationError
        from substanced.workflow import WorkflowError
        config = mock.Mock()
        wf = self._makeWorkflow()
        def _check():
            raise WorkflowError('bogus')
        wf.check = _check
        self.assertRaises(ConfigurationError, self._callFUT, wf, config)

class register_workflowTests(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp()
        self.config.registry.content = mock.Mock()
        from substanced.workflow import includeme
        includeme(self.config)

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, config, workflow, type_,
                 content_type=None):
        from substanced.workflow import register_workflow
        workflow.type = type_
        register_workflow(config, workflow, type_, content_type)

    def test_register_workflow_global(self):
        from substanced.interfaces import IDefaultWorkflow
        from substanced._compat import u
        wf = mock.Mock()
        self._callFUT(self.config, wf, 'basic')

        self.assertEqual({'basic': {IDefaultWorkflow: wf}},
                         self.config.registry.workflow.types)
        self.assertEqual({IDefaultWorkflow: {u('basic'): wf}},
                         self.config.registry.workflow.content_types)

    def test_register_workflow_global_skip_if_exists(self):
        from substanced.interfaces import IDefaultWorkflow
        from substanced._compat import u
        wf = mock.Mock()
        self._callFUT(self.config, wf, 'basic')
        self.assertEqual({'basic': {IDefaultWorkflow: wf}},
                         self.config.registry.workflow.types)
        self.assertEqual({IDefaultWorkflow: {u('basic'): wf}},
                         self.config.registry.workflow.content_types)

        self._callFUT(self.config, wf, 'basic')
        self.assertEqual({'basic': {IDefaultWorkflow: wf}},
                         self.config.registry.workflow.types)
        self.assertEqual({IDefaultWorkflow: {u('basic'): wf}},
                         self.config.registry.workflow.content_types)

    def test_register_workflow_two_types(self):
        from substanced._compat import u
        wf = mock.Mock()
        self._callFUT(self.config, wf, 'basic', 'File')
        self._callFUT(self.config, wf, 'basic', 'Folder')

        self.assertEqual({'basic': {'File': wf, 'Folder': wf}},
                         self.config.registry.workflow.types)
        self.assertEqual({'File': {u('basic'): wf}, 'Folder': {u('basic'): wf}},
                         self.config.registry.workflow.content_types)
        self.config.registry.content.exists.assert_any_call('File')
        self.config.registry.content.exists.assert_any_call('Folder')

    def test_register_workflow_no_such_content_type(self):
        from pyramid.config import ConfigurationError
        self.config.registry.content.exists.return_value = False
        wf = mock.Mock()
        self.assertRaises(ConfigurationError,
                          self._callFUT,
                          self.config,
                          wf,
                          'basic',
                          'Foobar')
        self.config.registry.content.exists.assert_call('Foobar')

class Test_WorkflowedPredicate(unittest.TestCase):
    def _makeOne(self, val, config):
        from substanced.workflow import _WorkflowedPredicate
        return _WorkflowedPredicate(val, config)

    def test_text(self):
        config = DummyContent()
        config.registry = DummyContent()
        inst = self._makeOne(True, config)
        self.assertEqual(inst.text(), 'workflowed = True')

    def test_phash(self):
        config = DummyContent()
        config.registry = DummyContent()
        inst = self._makeOne(True, config)
        self.assertEqual(inst.phash(), 'workflowed = True')

    def test__call__(self):
        config = DummyContent()
        config.registry = DummyContent()
        inst = self._makeOne(True, config)
        def is_workflowed(context, registry):
            self.assertEqual(context, None)
            self.assertEqual(registry, config.registry)
            return True
        inst.is_workflowed = is_workflowed
        self.assertEqual(inst(None, None), True)

class Test_is_workflowed(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def _callFUT(self, context, registry):
        from substanced.workflow import is_workflowed
        return is_workflowed(context, registry)

    def test_no_workflow_registry(self):
        content = DummyContent()
        registry = DummyContent()
        self.assertEqual(self._callFUT(content, registry), False)

    def test_no_content_type(self):
        content = DummyContent()
        registry = DummyContent()
        registry.workflow = True
        registry.content = DummyContentRegistry(None)
        self.assertEqual(self._callFUT(content, registry), False)

    def test_gardenpath(self):
        content = DummyContent()
        registry = DummyContent()
        workflow = DummyContent()
        registry.workflow = DummyWorkflowRegistry(workflow)
        registry.content = DummyContentRegistry('abc')
        self.assertEqual(self._callFUT(content, registry), True)


class ACLStateTests(unittest.TestCase):

    def _getTargetClass(self):
        from substanced.workflow import ACLState
        return ACLState

    def _makeOne(self, acl=None):
        klass = self._getTargetClass()
        return klass(acl)

    def test___call___wo_acl(self):
        state = self._makeOne()
        # no raise, no mutation
        state(object(), request={}, transition='dummy', workflow=object())

    def test___call___w_acl(self):
        from pyramid.security import Allow
        from pyramid.security import Everyone
        from pyramid.security import ALL_PERMISSIONS
        class _Content(object):
            pass
        content = _Content()
        AFTER = [(Allow, Everyone, ALL_PERMISSIONS)]
        state = self._makeOne(AFTER)
        state(content, request={}, transition='dummy', workflow=object())
        self.assertEqual(content.__acl__, AFTER)

class DummyContent:
    pass

class DummyContentRegistry(object):
    def __init__(self, result):
        self.result = result
    def typeof(self, context):
        return self.result

class DummyWorkflowRegistry(object):
    def __init__(self, result):
        self.result = result
    def get_all_types(self, content_type):
        return self.result

########NEW FILE########
__FILENAME__ = views
import operator

from pyramid.httpexceptions import HTTPFound
from pyramid.view import view_defaults

from ..sdi import (
    mgmt_view,
    RIGHT,
    )
from ..util import get_content_type

@view_defaults(
    permission='sdi.manage-workflow',
    name='workflows',
    workflowed=True,
    )
class WorkflowViews(object):
    def __init__(self, context, request):
        self.context = context
        self.request = request

    def _get_workflows(self):
        content_type = get_content_type(self.context)
        workflow_reg = self.request.registry.workflow
        workflows = sorted(
            workflow_reg.get_all_types(content_type),
            key = operator.attrgetter('name')
            )
        return workflows

    @mgmt_view(
        renderer='templates/workflow.pt',
        tab_title='Workflows',
        tab_near=RIGHT, # try not to be the default tab, we're too obscure
        )
    def show(self):
        results = []
        workflows = self._get_workflows()
        for workflow in workflows:
            transitions = workflow.get_transitions(self.context, self.request)
            states = workflow.get_states(self.context, self.request)
            wfid = str(workflow.type)
            current_state = workflow.state_of(self.context)
            result = {
                'id':wfid,
                'workflow':workflow,
                'transitions':transitions,
                'states':states,
                'current_state':current_state,
                }
            results.append(result)
        return {'workflows':results}

    @mgmt_view(
        request_method='POST',
        check_csrf=True,
        )
    def transition(self):
        workflows = self._get_workflows()
        wfid = self.request.POST['wfid']
        transition = self.request.POST['transition']
        for workflow in workflows:
            if str(workflow.type) == wfid:
                workflow.transition(self.context, self.request, transition)
                self.request.sdiapi.flash(
                    'Transitioned %s using %s' % (
                        workflow.name or workflow.type, transition),
                    'success',
                    )
                break
        return HTTPFound(
            self.request.sdiapi.mgmt_url(self.context, '@@workflows')
            )

########NEW FILE########
__FILENAME__ = _compat

try:
    STRING_TYPES = (str, unicode)
except NameError: #pragma NO COVER Python >= 3.0
    STRING_TYPES = (str,)

try:
    u = unicode
except NameError: #pragma NO COVER Python >= 3.0
    TEXT = str
    def u(x, encoding='ascii'):
        if isinstance(x, str):
            return x
        if isinstance(x, bytes):
            return x.decode(encoding)
    b = bytes
else: #pragma NO COVER Python < 3.0
    TEXT = unicode
    b = str

try:
    INT_TYPES = (int, long)
except NameError: #pragma NO COVER Python >= 3.0
    INT_TYPES = (int,)

try: # pragma: no cover Python < 3.0
    from base64 import decodebytes
    from base64 import encodebytes
except ImportError: #pragma NO COVER
    from base64 import decodestring as decodebytes
    from base64 import encodestring as encodebytes

try:
    from urllib.parse import parse_qsl
except ImportError: #pragma NO COVER
    from cgi import parse_qsl

try:
    from urllib.parse import urlsplit
except ImportError: #pragma NO COVER
    from urlparse import urlsplit
    from urlparse import urlunsplit
else: #pragma NO COVER
    from urllib.parse import urlunsplit

import string
try:
    _LETTERS = string.letters
except AttributeError: #pragma NO COVER
    _LETTERS = string.ascii_letters
del string

try: # pragma: no cover
    from functools import total_ordering
except ImportError: # pragma: no cover
    # this doesn't exist in Python < 2.7
    def total_ordering(cls): # pragma: no cover
        """Class decorator that fills in missing ordering methods"""
        convert = {
            '__lt__': [('__gt__', lambda self, other: not (self < other or self == other)),
                       ('__le__', lambda self, other: self < other or self == other),
                       ('__ge__', lambda self, other: not self < other)],
            '__le__': [('__ge__', lambda self, other: not self <= other or self == other),
                       ('__lt__', lambda self, other: self <= other and not self == other),
                       ('__gt__', lambda self, other: not self <= other)],
            '__gt__': [('__lt__', lambda self, other: not (self > other or self == other)),
                       ('__ge__', lambda self, other: self > other or self == other),
                       ('__le__', lambda self, other: not self > other)],
            '__ge__': [('__le__', lambda self, other: (not self >= other) or self == other),
                       ('__gt__', lambda self, other: self >= other and not self == other),
                       ('__lt__', lambda self, other: not self >= other)]
        }
        roots = set(dir(cls)) & set(convert)
        if not roots:
            raise ValueError('must define at least one ordering operation: < > <= >=')
        root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__
        for opname, opfunc in convert[root]:
            if opname not in roots:
                opfunc.__name__ = opname
                opfunc.__doc__ = getattr(int, opname).__doc__
                setattr(cls, opname, opfunc)
        return cls

try:
    from html import escape # py3
except ImportError: #pragma NO COVER
    from cgi import escape
    

########NEW FILE########
