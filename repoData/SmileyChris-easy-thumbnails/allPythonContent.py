__FILENAME__ = authors
#!/usr/bin/env python
"""
Get a git project's authors (ordered by most contributions).
"""

import re
import subprocess
from operator import itemgetter

from django.utils import six

re_line = re.compile(six.b(r'(\d+)\s+(\d+)\s+[^<]+$'))
re_author = re.compile(six.b(r'.+<(.+)>$'))


def get_authors(exclude_primary_author=True):
    git_log = subprocess.Popen(
        ["git", "log", "--format=%aN <%aE>", "--numstat"],
        stdout=subprocess.PIPE)

    output = git_log.communicate()[0]

    authors = {}
    author = None
    for line in output.splitlines():
        match = re_line.match(line)
        if not match:
            if line:
                author = line
            continue
        authors[author] = authors.get(author, 0) + max([
            int(num) for num in match.groups()])

    # Combine duplicate authors (by email).
    emails = {}
    for author, changes in list(authors.items()):
        match = re_author.match(author)
        if not match:
            continue
        author_emails = match.group(1)
        for email in author_emails.split(six.b(',')):
            if six.b('@') not in email:
                continue
            if email in emails:
                remove_author = emails[email]
                if remove_author not in authors:
                    continue
                if changes < authors[remove_author]:
                    author, remove_author = remove_author, author
                authors[author] = authors[author] + authors[remove_author]
                del authors[remove_author]
            else:
                emails[email] = author

    # Sort authors list.
    list_authors = sorted(authors.items(), key=itemgetter(1), reverse=True)

    total = float(sum(authors.values()))

    if exclude_primary_author:
        top_author = list_authors.pop(0)
        total -= top_author[1]

    return [
        (author.decode(), changes, changes / total * 100)
        for author, changes in list_authors]


if __name__ == '__main__':
    for author, changes, percent in get_authors():
        print(author)

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# easy-thumbnails documentation build configuration file, created by
# sphinx-quickstart on Sun Aug  9 17:04:20 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys
from django.conf import settings

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
settings.configure(SECRET_KEY='easy')

import easy_thumbnails

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'easy-thumbnails'
copyright = u'2009, Chris Beaven'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '%s.%s' % tuple(easy_thumbnails.VERSION[:2])
# The full version, including alpha/beta/rc tags.
release = easy_thumbnails.get_version()

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
#html_theme = 'default'
html_theme = 'agogo'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'easy-thumbnailsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ('index', 'easy-thumbnails.tex', u'easy-thumbnails Documentation',
     u'Chris Beaven', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = alias
from django.utils import six

from easy_thumbnails.conf import settings


class Aliases(object):
    """
    A container which stores and retrieves named easy-thumbnail options
    dictionaries.
    """

    def __init__(self, populate_from_settings=True):
        """
        Initialize the Aliases object.

        :param populate_from_settings: If ``True`` (default) then populate the
            initial aliases from settings. See :meth:`populate_from_settings`.
        """
        self._aliases = {}
        if populate_from_settings:
            self.populate_from_settings()

    def populate_from_settings(self):
        """
        Populate the aliases from the ``THUMBNAIL_ALIASES`` setting.
        """
        settings_aliases = settings.THUMBNAIL_ALIASES
        if settings_aliases:
            for target, aliases in settings_aliases.items():
                target_aliases = self._aliases.setdefault(target, {})
                target_aliases.update(aliases)

    def set(self, alias, options, target=None):
        """
        Add an alias.

        :param alias: The name of the alias to add.
        :param options: The easy-thumbnails options dictonary for this alias
            (should include ``size``).
        :param target: A field, model, or app to limit this alias to
            (optional).
        """
        target = self._coerce_target(target) or ''
        target_aliases = self._aliases.setdefault(target, {})
        target_aliases[alias] = options

    def get(self, alias, target=None):
        """
        Get a dictionary of aliased options.

        :param alias: The name of the aliased options.
        :param target: Get alias for this specific target (optional).

        If no matching alias is found, returns ``None``.
        """
        for target_part in reversed(list(self._get_targets(target))):
            options = self._get(target_part, alias)
            if options:
                return options

    def all(self, target=None, include_global=True):
        """
        Get a dictionary of all aliases and their options.

        :param target: Include aliases for this specific field, model or app
            (optional).
        :param include_global: Include all non target-specific aliases
            (default ``True``).

        For example::

            >>> aliases.all(target='my_app.MyModel')
            {'small': {'size': (100, 100)}, 'large': {'size': (400, 400)}}
        """
        aliases = {}
        for target_part in self._get_targets(target, include_global):
            aliases.update(self._aliases.get(target_part, {}))
        return aliases

    def _get(self, target, alias):
        """
        Internal method to get a specific alias.
        """
        if target not in self._aliases:
            return
        return self._aliases[target].get(alias)

    def _get_targets(self, target, include_global=True):
        """
        Internal iterator to split up a complete target into the possible parts
        it may match.

        For example::

            >>> list(aliases._get_targets('my_app.MyModel.somefield'))
            ['', 'my_app', 'my_app.MyModel', 'my_app.MyModel.somefield']
        """
        target = self._coerce_target(target)
        if include_global:
            yield ''
        if not target:
            return
        target_bits = target.split('.')
        for i in range(len(target_bits)):
            yield '.'.join(target_bits[:i + 1])

    def _coerce_target(self, target):
        """
        Internal method to coerce a target to a string.

        The assumption is that if it is not ``None`` and not a string, it is
        a Django ``FieldFile`` object.
        """
        if not target or isinstance(target, six.string_types):
            return target
        if not hasattr(target, 'instance'):
            return None
        model = target.instance.__class__
        return '%s.%s.%s' % (
            model._meta.app_label,
            model.__name__,
            target.field.name,
        )


aliases = Aliases()

########NEW FILE########
__FILENAME__ = conf
from django.conf import settings as django_settings
try:
    from django.conf import BaseSettings
except ImportError:  # Django <= 1.2
    from django.conf import Settings as BaseSettings


class AppSettings(BaseSettings):
    """
    A holder for app-specific settings.

    When :attr:`isolated` is ``False`` (the default) the holder returns
    attributes from the project's setting module, falling back to the default
    attributes provided in this module if the attribute wasn't found.
    """

    def __init__(self, isolated=False, *args, **kwargs):
        self.isolated = isolated
        self._changed = {}
        self._added = []
        super(AppSettings, self).__init__(*args, **kwargs)

    def get_isolated(self):
        return self._isolated

    def set_isolated(self, value):
        if value:
            self._isolated_overrides = BaseSettings()
        self._isolated = value

    isolated = property(get_isolated, set_isolated)

    def revert(self):
        """
        Revert any changes made to settings.
        """
        for attr, value in self._changed.items():
            setattr(django_settings, attr, value)
        for attr in self._added:
            delattr(django_settings, attr)
        self._changed = {}
        self._added = []
        if self.isolated:
            self._isolated_overrides = BaseSettings()

    def __getattribute__(self, attr):
        if attr == attr.upper():
            if self.isolated:
                try:
                    return getattr(self._isolated_overrides, attr)
                except AttributeError:
                    pass
            else:
                try:
                    return getattr(django_settings, attr)
                except AttributeError:
                    pass
        try:
            return super(AppSettings, self).__getattribute__(attr)
        except AttributeError:
            if not self.isolated:
                raise
            return getattr(django_settings, attr)

    def __setattr__(self, attr, value):
        if attr == attr.upper():
            if self.isolated:
                try:
                    super(AppSettings, self).__getattribute__(attr)
                except AttributeError:
                    pass
                else:
                    # Set the app setting to an isolated overrides that gets
                    # checked before the project's settings.
                    return setattr(self._isolated_overrides, attr, value)
            # Keep track of any project settings changes so they can be
            # reverted.
            if attr not in self._added:
                try:
                    self._changed.setdefault(
                        attr, getattr(django_settings, attr))
                except AttributeError:
                    self._added.append(attr)
            return setattr(django_settings, attr, value)
        return super(AppSettings, self).__setattr__(attr, value)


class Settings(AppSettings):
    """
    These default settings for easy-thumbnails can be specified in your Django
    project's settings module to alter the behaviour of easy-thumbnails.
    """

    THUMBNAIL_DEBUG = False
    """
    If this boolean setting is set to ``True``, display errors creating a
    thumbnail when using the :ref:`thumbnail_tag` rather than failing silently.
    """

    THUMBNAIL_DEFAULT_STORAGE = (
        'easy_thumbnails.storage.ThumbnailFileSystemStorage')
    """
    The default Django storage for *saving* generated thumbnails.
    """
    THUMBNAIL_MEDIA_ROOT = ''
    """
    Used by easy-thumbnail's default storage to locate where thumbnails are
    stored on the file system.

    If not provided, Django's standard ``MEDIA_ROOT`` setting is used.
    """
    THUMBNAIL_MEDIA_URL = ''
    """
    Used by easy-thumbnail's default storage to build the absolute URL for a
    generated thumbnail.

    If not provided, Django's standard ``MEDIA_URL`` setting is used.
    """

    THUMBNAIL_BASEDIR = ''
    """
    Save thumbnail images to a directory directly off ``MEDIA_ROOT``, still
    keeping the relative directory structure of the source image.

    For example, using the ``{% thumbnail "photos/1.jpg" 150x150 %}`` tag
    with a ``THUMBNAIL_BASEDIR`` of ``'thumbs'`` would result in the
    following thumbnail filename::

        MEDIA_ROOT + 'thumbs/photos/1_jpg_150x150_q85.jpg'
    """
    THUMBNAIL_SUBDIR = ''
    """
    Save thumbnail images to a sub-directory relative to the source image.

    For example, using the ``{% thumbnail "photos/1.jpg" 150x150 %}`` tag with
    a ``THUMBNAIL_SUBDIR`` of ``'thumbs'`` would result in the following
    thumbnail filename::

        MEDIA_ROOT + 'photos/thumbs/1_jpg_150x150_q85.jpg'
    """
    THUMBNAIL_PREFIX = ''
    """
    Prepend thumbnail filenames with the specified prefix.

    For example, using the ``{% thumbnail "photos/1.jpg" 150x150 %}`` tag with
    a ``THUMBNAIL_PREFIX`` of ``'thumbs_'`` would result in the following
    thumbnail filename::

        MEDIA_ROOT + 'photos/thumbs_1_jpg_150x150_q85.jpg'
    """

    THUMBNAIL_QUALITY = 85
    """
    The default quality level for JPG images on a scale from 1 (worst) to 95
    (best). Technically, values up to 100 are allowed, but this is not
    recommended.
    """

    THUMBNAIL_EXTENSION = 'jpg'
    """
    The type of image to save thumbnails with no transparency layer as.

    Note that changing the extension will most likely cause the
    ``THUMBNAIL_QUALITY`` setting to have no effect.
    """
    THUMBNAIL_PRESERVE_EXTENSIONS = None
    """
    To preserve specific extensions, for instance if you always want to create
    lossless PNG thumbnails from PNG sources, you can specify these extensions
    using this setting, for example::

        THUMBNAIL_PRESERVE_EXTENSIONS = ('png',)

    All extensions should be lowercase.

    Instead of a tuple, you can also set this to ``True`` in order to always
    preserve the original extension.
    """
    THUMBNAIL_TRANSPARENCY_EXTENSION = 'png'
    """
    The type of image to save thumbnails with a transparency layer (e.g. GIFs
    or transparent PNGs).
    """
    THUMBNAIL_NAMER = 'easy_thumbnails.namers.default'
    """
    The function used to generate the filename for thumbnail images.

    Three namers are included in easy_thumbnails:

    ``easy_thumbnails.namers.default``
        Descriptive filename containing the source and options like
        ``source.jpg.100x100_q80_crop_upscale.jpg``.

    ``easy_thumbnails.namers.hashed``
        Short hashed filename like ``1xedFtqllFo9.jpg``.

    ``easy_thumbnails.namers.source_hashed``
        Filename with source hashed, size, then options hashed like
        ``1xedFtqllFo9_100x100_QHCa6G1l.jpg``.

    To write a custom namer, always catch all other keyword arguments arguments
    (with \*\*kwargs). You have access to the following arguments:
    ``thumbnailer``, ``source_filename``, ``thumbnail_extension`` (does *not*
    include the ``'.'``), ``thumbnail_options``, ``prepared_options``.

    The ``thumbnail_options`` are a copy of the options dictionary used to
    build the thumbnail, ``prepared_options`` is a list of options prepared as
    text, and excluding options that shouldn't be included in the filename.
    """

    THUMBNAIL_PROCESSORS = (
        'easy_thumbnails.processors.colorspace',
        'easy_thumbnails.processors.autocrop',
        'easy_thumbnails.processors.scale_and_crop',
        'easy_thumbnails.processors.filters',
        'easy_thumbnails.processors.background',
    )
    """
    Defaults to::

        THUMBNAIL_PROCESSORS = (
            'easy_thumbnails.processors.colorspace',
            'easy_thumbnails.processors.autocrop',
            'easy_thumbnails.processors.scale_and_crop',
            'easy_thumbnails.processors.filters',
            'easy_thumbnails.processors.background',
        )

    The :doc:`processors` through which the source image is run when you create
    a thumbnail.

    The order of the processors is the order in which they are sequentially
    called to process the image.
    """
    THUMBNAIL_SOURCE_GENERATORS = (
        'easy_thumbnails.source_generators.pil_image',
    )
    """
    The :doc:`source_generators` through which the base image is created from
    the source file.

    The order of the processors is the order in which they are sequentially
    tried.
    """

    THUMBNAIL_CHECK_CACHE_MISS = False
    """
    If this boolean setting is set to ``True``, and a thumbnail cannot
    be found in the database tables, we ask the storage if it has the
    thumbnail. If it does we add the row in the database, and we don't
    need to generate the thumbnail.

    Switch this to True if your easy_thumbnails_thumbnail table has been wiped
    but your storage still has the thumbnail files.
    """

    THUMBNAIL_ALIASES = None
    """
    A dictionary of predefined alias options for different targets. See the
    :ref:`usage documentation <thumbnail-aliases>` for details.
    """

    THUMBNAIL_DEFAULT_OPTIONS = None
    """
    Set this to a dictionary of options to provide as the default for all
    thumbnail calls. For example, to make all images greyscale::

        THUMBNAIL_DEFAULT_OPTIONS = {'bw': True}
    """

    THUMBNAIL_HIGH_RESOLUTION = False
    """
    Enables thumbnails for retina displays.

    Creates a version of the thumbnails in high resolution that can be used by
    a javascript layer to display higher quality thumbnails for high DPI
    displays.

    This can be overridden at a per-thumbnail level with the
    ``HIGH_RESOLUTION`` thumbnail option::

        opts = {'size': (100, 100), 'crop': True, HIGH_RESOLUTION: False}
        only_basic = get_thumbnailer(obj.image).get_thumbnail(opts)

    In a template tag, use a value of ``0`` to force the disabling of a high
    resolution version or just the option name to enable it::

        {% thumbnail obj.image 50x50 crop HIGH_RESOLUTION=0 %}  {# no hires #}
        {% thumbnail obj.image 50x50 crop HIGH_RESOLUTION %}  {# force hires #}
    """

    THUMBNAIL_HIGHRES_INFIX = '@2x'
    """
    Sets the infix used to distinguish thumbnail images for retina displays.

    Thumbnails generated for retina displays are distinguished from the
    standard resolution counterparts, by adding an infix to the filename just
    before the dot followed by the extension.

    Apple Inc., formerly suggested to use ``@2x`` as infix, but later changed
    their mind and now suggests to use ``_2x``, since this is more portable.
    """

    THUMBNAIL_CACHE_DIMENSIONS = False
    """
    Save thumbnail dimensions to the database.

    When using remote storage backends it can be a slow process to get image
    dimensions for a thumbnailed file. This option will store them in
    the database to be recalled quickly when required. Note: the old method
    still works as a fall back.
    """

settings = Settings()

########NEW FILE########
__FILENAME__ = engine
import os
try:
    from cStringIO import cStringIO as BytesIO
except ImportError:
    from django.utils.six import BytesIO

try:
    from PIL import Image
except ImportError:
    import Image

from easy_thumbnails import utils
from easy_thumbnails.conf import settings
from easy_thumbnails.options import ThumbnailOptions


class NoSourceGenerator(Exception):
    """
    Exception that is raised if no source generator can process the source
    file.
    """

    def __unicode__(self):
        return "Tried {0} source generators with no success".format(
            len(self.args))


def process_image(source, processor_options, processors=None):
    """
    Process a source PIL image through a series of image processors, returning
    the (potentially) altered image.
    """
    processor_options = ThumbnailOptions(processor_options)
    if processors is None:
        processors = [
            utils.dynamic_import(name)
            for name in settings.THUMBNAIL_PROCESSORS]
    image = source
    for processor in processors:
        image = processor(image, **processor_options)
    return image


def save_image(image, destination=None, filename=None, **options):
    """
    Save a PIL image.
    """
    if destination is None:
        destination = BytesIO()
    filename = filename or ''
    # Ensure plugins are fully loaded so that Image.EXTENSION is populated.
    Image.init()
    format = Image.EXTENSION.get(os.path.splitext(filename)[1].lower(), 'JPEG')
    if format in ('JPEG', 'WEBP'):
        options.setdefault('quality', 85)
    if format == 'JPEG':
        try:
            image.save(destination, format=format, optimize=1, **options)
        except IOError:
            # Try again, without optimization (PIL can't optimize an image
            # larger than ImageFile.MAXBLOCK, which is 64k by default)
            pass
    image.save(destination, format=format, **options)
    if hasattr(destination, 'seek'):
        destination.seek(0)
    return destination


def generate_source_image(source_file, processor_options, generators=None,
                          fail_silently=True):
    """
    Processes a source ``File`` through a series of source generators, stopping
    once a generator returns an image.

    The return value is this image instance or ``None`` if no generators
    return an image.

    If the source file cannot be opened, it will be set to ``None`` and still
    passed to the generators.
    """
    processor_options = ThumbnailOptions(processor_options)
    # Keep record of whether the source file was originally closed. Not all
    # file-like objects provide this attribute, so just fall back to False.
    was_closed = getattr(source_file, 'closed', False)
    if generators is None:
        generators = [
            utils.dynamic_import(name)
            for name in settings.THUMBNAIL_SOURCE_GENERATORS]
    exceptions = []
    try:
        for generator in generators:
            source = source_file
            # First try to open the file.
            try:
                source.open()
            except Exception:
                # If that failed, maybe the file-like object doesn't support
                # reopening so just try seeking back to the start of the file.
                try:
                    source.seek(0)
                except Exception:
                    source = None
            try:
                image = generator(source, **processor_options)
            except Exception as e:
                if not fail_silently:
                    if len(generators) == 1:
                        raise
                    exceptions.append(e)
                image = None
            if image:
                return image
    finally:
        # Attempt to close the file if it was closed originally (but fail
        # silently).
        if was_closed:
            try:
                source_file.close()
            except Exception:
                pass
    if exceptions and not fail_silently:
        raise NoSourceGenerator(*exceptions)

########NEW FILE########
__FILENAME__ = exceptions
class EasyThumbnailsError(Exception):
    pass


class InvalidImageFormatError(EasyThumbnailsError):
    pass


# Make this error silent when it crops up in a template (most likely via
# Thumbnailer.__getitem__).
InvalidImageFormatError.silent_variable_failure = True

########NEW FILE########
__FILENAME__ = fields
from django.db.models.fields.files import FileField, ImageField
from easy_thumbnails import files


class ThumbnailerField(FileField):
    """
    A file field which provides easier access for retrieving (and generating)
    thumbnails.

    To use a different file storage for thumbnails, provide the
    ``thumbnail_storage`` keyword argument.
    """
    attr_class = files.ThumbnailerFieldFile

    def __init__(self, *args, **kwargs):
        # Arguments not explicitly defined so that the normal ImageField
        # positional arguments can be used.
        self.thumbnail_storage = kwargs.pop('thumbnail_storage', None)

        super(ThumbnailerField, self).__init__(*args, **kwargs)

    def south_field_triple(self):
        """
        Return a suitable description of this field for South.
        """
        from south.modelsinspector import introspector
        field_class = 'django.db.models.fields.files.FileField'
        args, kwargs = introspector(self)
        return (field_class, args, kwargs)


class ThumbnailerImageField(ThumbnailerField, ImageField):
    """
    An image field which provides easier access for retrieving (and generating)
    thumbnails.

    To use a different file storage for thumbnails, provide the
    ``thumbnail_storage`` keyword argument.

    To thumbnail the original source image before saving, provide the
    ``resize_source`` keyword argument, passing it a usual thumbnail option
    dictionary. For example::

        ThumbnailerImageField(
            ..., resize_source=dict(size=(100, 100), sharpen=True))
    """
    attr_class = files.ThumbnailerImageFieldFile

    def __init__(self, *args, **kwargs):
        # Arguments not explicitly defined so that the normal ImageField
        # positional arguments can be used.
        self.resize_source = kwargs.pop('resize_source', None)

        super(ThumbnailerImageField, self).__init__(*args, **kwargs)

    def south_field_triple(self):
        """
        Return a suitable description of this field for South.
        """
        from south.modelsinspector import introspector
        field_class = 'django.db.models.fields.files.ImageField'
        args, kwargs = introspector(self)
        return (field_class, args, kwargs)

########NEW FILE########
__FILENAME__ = files
import os
from django.utils import six

from django.core.files.base import File, ContentFile
from django.core.files.storage import (
    default_storage, Storage)
from django.db.models.fields.files import ImageFieldFile, FieldFile
from django.core.files.images import get_image_dimensions

from django.utils.safestring import mark_safe
from django.utils.html import escape
from django.utils import timezone

from easy_thumbnails import engine, exceptions, models, utils, signals, storage
from easy_thumbnails.alias import aliases
from easy_thumbnails.conf import settings
from easy_thumbnails.options import ThumbnailOptions


def get_thumbnailer(obj, relative_name=None):
    """
    Get a :class:`Thumbnailer` for a source file.

    The ``obj`` argument is usually either one of the following:

        * ``FieldFile`` instance (i.e. a model instance file/image field
          property).

        * A string, which will be used as the relative name (the source will be
          set to the default storage).

        * ``Storage`` instance - the ``relative_name`` argument must also be
          provided.

    Or it could be:

        * A file-like instance - the ``relative_name`` argument must also be
          provided.

          In this case, the thumbnailer won't use or create a cached reference
          to the thumbnail (i.e. a new thumbnail will be created for every
          :meth:`Thumbnailer.get_thumbnail` call).

    If ``obj`` is a ``Thumbnailer`` instance, it will just be returned. If it's
    an object with an ``easy_thumbnails_thumbnailer`` then the attribute is
    simply returned under the assumption it is a Thumbnailer instance)
    """
    if hasattr(obj, 'easy_thumbnails_thumbnailer'):
        return obj.easy_thumbnails_thumbnailer
    if isinstance(obj, Thumbnailer):
        return obj
    elif isinstance(obj, FieldFile):
        if not relative_name:
            relative_name = obj.name
        return ThumbnailerFieldFile(obj.instance, obj.field, relative_name)

    source_storage = None

    if isinstance(obj, six.string_types):
        relative_name = obj
        obj = None

    if not relative_name:
        raise ValueError(
            "If object is not a FieldFile or Thumbnailer instance, the "
            "relative name must be provided")

    if isinstance(obj, File):
        obj = obj.file
    if isinstance(obj, Storage) or obj == default_storage:
        source_storage = obj
        obj = None

    return Thumbnailer(
        file=obj, name=relative_name, source_storage=source_storage,
        remote_source=obj is not None)


def generate_all_aliases(fieldfile, include_global):
    """
    Generate all of a file's aliases.

    :param fieldfile: A ``FieldFile`` instance.
    :param include_global: A boolean which determines whether to generate
        thumbnails for project-wide aliases in addition to field, model, and
        app specific aliases.
    """
    all_options = aliases.all(fieldfile, include_global=include_global)
    if all_options:
        thumbnailer = get_thumbnailer(fieldfile)
        for options in all_options.values():
            thumbnailer.get_thumbnail(options)


def database_get_image_dimensions(file, close=False, dimensions=None):
    """
    Returns the (width, height) of an image, given ThumbnailFile.  Set
    'close' to True to close the file at the end if it is initially in an open
    state.

    Will attempt to get the dimensions from the file itself if they aren't
    in the db.
    """
    storage_hash = utils.get_storage_hash(file.storage)
    dimensions = None
    dimensions_cache = None
    try:
        thumbnail = models.Thumbnail.objects.select_related('dimensions').get(
            storage_hash=storage_hash, name=file.name)
    except models.Thumbnail.DoesNotExist:
        thumbnail = None
    else:
        try:
            dimensions_cache = thumbnail.dimensions
        except models.ThumbnailDimensions.DoesNotExist:
            dimensions_cache = None
        if dimensions_cache:
            return dimensions_cache.width, dimensions_cache.height
    dimensions = get_image_dimensions(file, close=close)
    if settings.THUMBNAIL_CACHE_DIMENSIONS and thumbnail:
        dimensions_cache = models.ThumbnailDimensions(thumbnail=thumbnail)
        dimensions_cache.width, dimensions_cache.height = dimensions
        dimensions_cache.save()
    return dimensions


class FakeField(object):
    name = 'fake'

    def __init__(self, storage=None):
        if storage is None:
            storage = default_storage
        self.storage = storage

    def generate_filename(self, instance, name, *args, **kwargs):
        return name


class FakeInstance(object):
    def save(self, *args, **kwargs):
        pass


class ThumbnailFile(ImageFieldFile):
    """
    A thumbnailed file.

    This can be used just like a Django model instance's property for a file
    field (i.e. an ``ImageFieldFile`` object).
    """
    def __init__(self, name, file=None, storage=None, thumbnail_options=None,
                 *args, **kwargs):
        fake_field = FakeField(storage=storage)
        super(ThumbnailFile, self).__init__(
            FakeInstance(), fake_field, name, *args, **kwargs)
        del self.field
        if file:
            self.file = file
        if thumbnail_options is None:
            thumbnail_options = ThumbnailOptions()
        elif not isinstance(thumbnail_options, ThumbnailOptions):
            thumbnail_options = ThumbnailOptions(thumbnail_options)
        self.thumbnail_options = thumbnail_options

    def save(self, *args, **kwargs):
        # Can't save a ``ThumbnailFile`` directly.
        raise NotImplementedError()

    def delete(self, *args, **kwargs):
        # Can't delete a ``ThumbnailFile`` directly, it doesn't have a
        # reference to the source image, so it can't update the cache. If you
        # really need to do this, do it with ``self.storage.delete`` directly.
        raise NotImplementedError()

    # Be consistant with standard behaviour, even though these methods don't
    # actually alter data any more.
    save.alters_data = True
    delete.alters_data = True

    def _get_image(self):
        """
        Get a PIL Image instance of this file.

        The image is cached to avoid the file needing to be read again if the
        function is called again.
        """
        if not hasattr(self, '_image_cache'):
            from easy_thumbnails.source_generators import pil_image
            self.image = pil_image(self)
        return self._image_cache

    def _set_image(self, image):
        """
        Set the image for this file.

        This also caches the dimensions of the image.
        """
        if image:
            self._image_cache = image
            self._dimensions_cache = image.size
        else:
            if hasattr(self, '_image_cache'):
                del self._cached_image
            if hasattr(self, '_dimensions_cache'):
                del self._dimensions_cache

    image = property(_get_image, _set_image)

    def tag(self, alt='', use_size=None, **attrs):
        """
        Return a standard XHTML ``<img ... />`` tag for this field.

        :param alt: The ``alt=""`` text for the tag. Defaults to ``''``.

        :param use_size: Whether to get the size of the thumbnail image for use
            in the tag attributes. If ``None`` (default), the size will only
            be used it if won't result in a remote file retrieval.

        All other keyword parameters are added as (properly escaped) extra
        attributes to the `img` tag.
        """
        if use_size is None:
            if getattr(self, '_dimensions_cache', None):
                use_size = True
            else:
                try:
                    self.storage.path(self.name)
                    use_size = True
                except NotImplementedError:
                    use_size = False
        attrs['alt'] = alt
        attrs['src'] = self.url
        if use_size:
            attrs.update(dict(width=self.width, height=self.height))
        attrs = ' '.join(['%s="%s"' % (key, escape(value))
                          for key, value in sorted(attrs.items())])
        return mark_safe('<img %s />' % attrs)

    def _get_file(self):
        self._require_file()
        if not hasattr(self, '_file') or self._file is None:
            self._file = self.storage.open(self.name, 'rb')
        return self._file

    def _set_file(self, value):
        if value is not None and not isinstance(value, File):
            value = File(value)
        self._file = value
        self._committed = False

    def _del_file(self):
        del self._file

    file = property(_get_file, _set_file, _del_file)

    def open(self, mode=None, *args, **kwargs):
        if self.closed and self.name:
            mode = mode or getattr(self, 'mode', None) or 'rb'
            self.file = self.storage.open(self.name, mode)
        else:
            return super(ThumbnailFile, self).open(mode, *args, **kwargs)

    def _get_image_dimensions(self):
        if not hasattr(self, '_dimensions_cache'):
            close = self.closed
            self.open()
            self._dimensions_cache = database_get_image_dimensions(
                self, close=close)
        return self._dimensions_cache

    def set_image_dimensions(self, thumbnail):
        """
        Set image dimensions from the cached dimensions of a ``Thumbnail``
        model instance.
        """
        try:
            dimensions = getattr(thumbnail, 'dimensions', None)
        except models.ThumbnailDimensions.DoesNotExist:
            dimensions = None
        if not dimensions:
            return False
        self._dimensions_cache = dimensions.size
        return self._dimensions_cache


class Thumbnailer(File):
    """
    A file-like object which provides some methods to generate thumbnail
    images.

    You can subclass this object and override the following properties to
    change the defaults (pulled from the default settings):

        * source_generators
        * thumbnail_processors
    """
    #: A list of source generators to use. If ``None``, will use the default
    #: generators defined in settings.
    source_generators = None
    #: A list of thumbnail processors. If ``None``, will use the default
    #: processors defined in settings.
    thumbnail_processors = None

    def __init__(self, file=None, name=None, source_storage=None,
                 thumbnail_storage=None, remote_source=False, generate=True,
                 *args, **kwargs):
        super(Thumbnailer, self).__init__(file, name, *args, **kwargs)
        if source_storage is None:
            source_storage = default_storage
        self.source_storage = source_storage
        if thumbnail_storage is None:
            thumbnail_storage = storage.thumbnail_default_storage
        self.thumbnail_storage = thumbnail_storage
        self.remote_source = remote_source
        self.alias_target = None
        self.generate = generate

        # Set default properties. For backwards compatibilty, check to see
        # if the attribute exists already (it could be set as a class property
        # on a subclass) before getting it from settings.
        for default in (
                'basedir', 'subdir', 'prefix', 'quality', 'extension',
                'preserve_extensions', 'transparency_extension',
                'check_cache_miss', 'high_resolution', 'highres_infix',
                'namer'):
            attr_name = 'thumbnail_%s' % default
            if getattr(self, attr_name, None) is None:
                value = getattr(settings, attr_name.upper())
                setattr(self, attr_name, value)

    def __getitem__(self, alias):
        """
        Retrieve a thumbnail matching the alias options (or raise a
        ``KeyError`` if no such alias exists).
        """
        options = aliases.get(alias, target=self.alias_target)
        if not options:
            raise KeyError(alias)
        return self.get_thumbnail(options, silent_template_exception=True)

    def get_options(self, thumbnail_options, **kwargs):
        """
        Get the thumbnail options that includes the default options for this
        thumbnailer (and the project-wide default options).
        """
        if isinstance(thumbnail_options, ThumbnailOptions):
            return thumbnail_options
        args = []
        if thumbnail_options is not None:
            args.append(thumbnail_options)
        opts = ThumbnailOptions(*args, **kwargs)
        if 'quality' not in thumbnail_options:
            opts['quality'] = self.thumbnail_quality
        return opts

    def generate_thumbnail(self, thumbnail_options, high_resolution=False,
                           silent_template_exception=False):
        """
        Return an unsaved ``ThumbnailFile`` containing a thumbnail image.

        The thumbnail image is generated using the ``thumbnail_options``
        dictionary.
        """
        thumbnail_options = self.get_options(thumbnail_options)
        orig_size = thumbnail_options['size']  # remember original size
        # Size sanity check.
        min_dim, max_dim = 0, 0
        for dim in orig_size:
            try:
                dim = int(dim)
            except (TypeError, ValueError):
                continue
            min_dim, max_dim = min(min_dim, dim), max(max_dim, dim)
        if max_dim == 0 or min_dim < 0:
            raise exceptions.EasyThumbnailsError(
                "The source image is an invalid size (%sx%s)" % orig_size)

        if high_resolution:
            thumbnail_options['size'] = (orig_size[0] * 2, orig_size[1] * 2)
        image = engine.generate_source_image(
            self, thumbnail_options, self.source_generators,
            fail_silently=silent_template_exception)
        if image is None:
            raise exceptions.InvalidImageFormatError(
                "The source file does not appear to be an image")

        thumbnail_image = engine.process_image(image, thumbnail_options,
                                               self.thumbnail_processors)
        if high_resolution:
            thumbnail_options['size'] = orig_size  # restore original size

        filename = self.get_thumbnail_name(
            thumbnail_options,
            transparent=utils.is_transparent(thumbnail_image),
            high_resolution=high_resolution)
        quality = thumbnail_options['quality']
        subsampling = thumbnail_options['subsampling']

        img = engine.save_image(
            thumbnail_image, filename=filename, quality=quality,
            subsampling=subsampling)
        data = img.read()

        thumbnail = ThumbnailFile(
            filename, file=ContentFile(data), storage=self.thumbnail_storage,
            thumbnail_options=thumbnail_options)
        thumbnail.image = thumbnail_image
        thumbnail._committed = False

        return thumbnail

    def get_thumbnail_name(self, thumbnail_options, transparent=False,
                           high_resolution=False):
        """
        Return a thumbnail filename for the given ``thumbnail_options``
        dictionary and ``source_name`` (which defaults to the File's ``name``
        if not provided).
        """
        thumbnail_options = self.get_options(thumbnail_options)
        path, source_filename = os.path.split(self.name)
        source_extension = os.path.splitext(source_filename)[1][1:]
        preserve_extensions = self.thumbnail_preserve_extensions
        if preserve_extensions and (
                preserve_extensions is True or
                source_extension.lower() in preserve_extensions):
            extension = source_extension
        elif transparent:
            extension = self.thumbnail_transparency_extension
        else:
            extension = self.thumbnail_extension
        extension = extension or 'jpg'

        prepared_opts = thumbnail_options.prepared_options()
        opts_text = '_'.join(prepared_opts)

        data = {'opts': opts_text}
        basedir = self.thumbnail_basedir % data
        subdir = self.thumbnail_subdir % data

        if isinstance(self.thumbnail_namer, six.string_types):
            namer_func = utils.dynamic_import(self.thumbnail_namer)
        else:
            namer_func = self.thumbnail_namer
        filename = namer_func(
            thumbnailer=self,
            source_filename=source_filename,
            thumbnail_extension=extension,
            thumbnail_options=thumbnail_options,
            prepared_options=prepared_opts,
        )
        if high_resolution:
            filename = self.thumbnail_highres_infix.join(
                os.path.splitext(filename))
        filename = '%s%s' % (self.thumbnail_prefix, filename)

        return os.path.join(basedir, path, subdir, filename)

    def get_existing_thumbnail(self, thumbnail_options, high_resolution=False):
        """
        Return a ``ThumbnailFile`` containing an existing thumbnail for a set
        of thumbnail options, or ``None`` if not found.
        """
        thumbnail_options = self.get_options(thumbnail_options)
        names = [
            self.get_thumbnail_name(
                thumbnail_options, transparent=False,
                high_resolution=high_resolution)]
        transparent_name = self.get_thumbnail_name(
            thumbnail_options, transparent=True,
            high_resolution=high_resolution)
        if transparent_name not in names:
            names.append(transparent_name)

        for filename in names:
            exists = self.thumbnail_exists(filename)
            if exists:
                thumbnail_file = ThumbnailFile(
                    name=filename, storage=self.thumbnail_storage,
                    thumbnail_options=thumbnail_options)
                if settings.THUMBNAIL_CACHE_DIMENSIONS:
                    # If this wasn't local storage, exists will be a thumbnail
                    # instance so we can store the image dimensions now to save
                    # a future potential query.
                    thumbnail_file.set_image_dimensions(exists)
                return thumbnail_file

    def get_thumbnail(self, thumbnail_options, save=True, generate=None,
                      silent_template_exception=False):
        """
        Return a ``ThumbnailFile`` containing a thumbnail.

        If a matching thumbnail already exists, it will simply be returned.

        By default (unless the ``Thumbnailer`` was instanciated with
        ``generate=False``), thumbnails that don't exist are generated.
        Otherwise ``None`` is returned.

        Force the generation behaviour by setting the ``generate`` param to
        either ``True`` or ``False`` as required.

        The new thumbnail image is generated using the ``thumbnail_options``
        dictionary. If the ``save`` argument is ``True`` (default), the
        generated thumbnail will be saved too.
        """
        thumbnail_options = self.get_options(thumbnail_options)
        if generate is None:
            generate = self.generate

        thumbnail = self.get_existing_thumbnail(thumbnail_options)
        if not thumbnail:
            if generate:
                thumbnail = self.generate_thumbnail(
                    thumbnail_options,
                    silent_template_exception=silent_template_exception)
                if save:
                    self.save_thumbnail(thumbnail)
            else:
                signals.thumbnail_missed.send(
                    sender=self, options=thumbnail_options,
                    high_resolution=False)

        if 'HIGH_RESOLUTION' in thumbnail_options:
            generate_high_resolution = thumbnail_options.get('HIGH_RESOLUTION')
        else:
            generate_high_resolution = self.thumbnail_high_resolution
        if generate_high_resolution:
            thumbnail.high_resolution = self.get_existing_thumbnail(
                thumbnail_options, high_resolution=True)
            if not thumbnail.high_resolution:
                if generate:
                    thumbnail.high_resolution = self.generate_thumbnail(
                        thumbnail_options, high_resolution=True,
                        silent_template_exception=silent_template_exception)
                    if save:
                        self.save_thumbnail(thumbnail.high_resolution)
                else:
                    signals.thumbnail_missed.send(
                        sender=self, options=thumbnail_options,
                        high_resolution=False)

        return thumbnail

    def save_thumbnail(self, thumbnail):
        """
        Save a thumbnail to the thumbnail_storage.

        Also triggers the ``thumbnail_created`` signal and caches the
        thumbnail values and dimensions for future lookups.
        """
        filename = thumbnail.name
        try:
            self.thumbnail_storage.delete(filename)
        except Exception:
            pass
        self.thumbnail_storage.save(filename, thumbnail)

        thumb_cache = self.get_thumbnail_cache(
            thumbnail.name, create=True, update=True)

        # Cache thumbnail dimensions.
        if settings.THUMBNAIL_CACHE_DIMENSIONS:
            dimensions_cache, created = (
                models.ThumbnailDimensions.objects.get_or_create(
                    thumbnail=thumb_cache,
                    defaults={'width': thumbnail.width,
                              'height': thumbnail.height}))
            if not created:
                dimensions_cache.width = thumbnail.width
                dimensions_cache.height = thumbnail.height
                dimensions_cache.save()

        signals.thumbnail_created.send(sender=thumbnail)

    def thumbnail_exists(self, thumbnail_name):
        """
        Calculate whether the thumbnail already exists and that the source is
        not newer than the thumbnail.

        If the source and thumbnail file storages are local, their file
        modification times are used. Otherwise the database cached modification
        times are used.
        """
        if self.remote_source:
            return False

        if utils.is_storage_local(self.source_storage):
            source_modtime = utils.get_modified_time(
                self.source_storage, self.name)
        else:
            source = self.get_source_cache()
            if not source:
                return False
            source_modtime = source.modified

        if not source_modtime:
            return False

        local_thumbnails = utils.is_storage_local(self.thumbnail_storage)
        if local_thumbnails:
            thumbnail_modtime = utils.get_modified_time(
                self.thumbnail_storage, thumbnail_name)
            if not thumbnail_modtime:
                return False
            return source_modtime <= thumbnail_modtime

        thumbnail = self.get_thumbnail_cache(thumbnail_name)
        if not thumbnail:
            return False
        thumbnail_modtime = thumbnail.modified

        if thumbnail.modified and source_modtime <= thumbnail.modified:
            return thumbnail
        return False

    def get_source_cache(self, create=False, update=False):
        if self.remote_source:
            return None
        if hasattr(self, '_source_cache') and not update:
            if self._source_cache or not create:
                return self._source_cache
        update_modified = (update or create) and timezone.now()
        self._source_cache = models.Source.objects.get_file(
            create=create, update_modified=update_modified,
            storage=self.source_storage, name=self.name,
            check_cache_miss=self.thumbnail_check_cache_miss)
        return self._source_cache

    def get_thumbnail_cache(self, thumbnail_name, create=False, update=False):
        if self.remote_source:
            return None
        source = self.get_source_cache(create=True)
        update_modified = (update or create) and timezone.now()
        return models.Thumbnail.objects.get_file(
            create=create, update_modified=update_modified,
            storage=self.thumbnail_storage, source=source, name=thumbnail_name,
            check_cache_miss=self.thumbnail_check_cache_miss)

    def open(self, mode=None):
        if self.closed:
            mode = mode or getattr(self, 'mode', None) or 'rb'
            self.file = self.source_storage.open(self.name, mode)
        else:
            self.seek(0)

    # open() doesn't alter the file's contents, but it does reset the pointer.
    open.alters_data = True


class ThumbnailerFieldFile(FieldFile, Thumbnailer):
    """
    A field file which provides some methods for generating (and returning)
    thumbnail images.
    """
    def __init__(self, *args, **kwargs):
        super(ThumbnailerFieldFile, self).__init__(*args, **kwargs)
        self.source_storage = self.field.storage
        thumbnail_storage = getattr(self.field, 'thumbnail_storage', None)
        if thumbnail_storage:
            self.thumbnail_storage = thumbnail_storage
        self.alias_target = self

    def save(self, name, content, *args, **kwargs):
        """
        Save the file, also saving a reference to the thumbnail cache Source
        model.
        """
        super(ThumbnailerFieldFile, self).save(name, content, *args, **kwargs)
        self.get_source_cache(create=True, update=True)

    def delete(self, *args, **kwargs):
        """
        Delete the image, along with any generated thumbnails.
        """
        source_cache = self.get_source_cache()
        # First, delete any related thumbnails.
        self.delete_thumbnails(source_cache)
        # Next, delete the source image.
        super(ThumbnailerFieldFile, self).delete(*args, **kwargs)
        # Finally, delete the source cache entry.
        if source_cache:
            source_cache.delete()

    delete.alters_data = True

    def delete_thumbnails(self, source_cache=None):
        """
        Delete any thumbnails generated from the source image.

        :arg source_cache: An optional argument only used for optimisation
          where the source cache instance is already known.
        :returns: The number of files deleted.
        """
        source_cache = self.get_source_cache()
        deleted = 0
        if source_cache:
            thumbnail_storage_hash = utils.get_storage_hash(
                self.thumbnail_storage)
            for thumbnail_cache in source_cache.thumbnails.all():
                # Only attempt to delete the file if it was stored using the
                # same storage as is currently used.
                if thumbnail_cache.storage_hash == thumbnail_storage_hash:
                    self.thumbnail_storage.delete(thumbnail_cache.name)
                    # Delete the cache thumbnail instance too.
                    thumbnail_cache.delete()
                    deleted += 1
        return deleted

    delete_thumbnails.alters_data = True

    def get_thumbnails(self, *args, **kwargs):
        """
        Return an iterator which returns ThumbnailFile instances.
        """
        # First, delete any related thumbnails.
        source_cache = self.get_source_cache()
        if source_cache:
            thumbnail_storage_hash = utils.get_storage_hash(
                self.thumbnail_storage)
            for thumbnail_cache in source_cache.thumbnails.all():
                # Only iterate files which are stored using the current
                # thumbnail storage.
                if thumbnail_cache.storage_hash == thumbnail_storage_hash:
                    yield ThumbnailFile(name=thumbnail_cache.name,
                                        storage=self.thumbnail_storage)


class ThumbnailerImageFieldFile(ImageFieldFile, ThumbnailerFieldFile):
    """
    A field file which provides some methods for generating (and returning)
    thumbnail images.
    """

    def save(self, name, content, *args, **kwargs):
        """
        Save the image.

        The image will be resized down using a ``ThumbnailField`` if
        ``resize_source`` (a dictionary of thumbnail options) is provided by
        the field.
        """
        options = getattr(self.field, 'resize_source', None)
        if options:
            if 'quality' not in options:
                options['quality'] = self.thumbnail_quality
            content = Thumbnailer(content, name).generate_thumbnail(options)
            # If the generated extension differs from the original, use it
            # instead.
            orig_name, ext = os.path.splitext(name)
            generated_ext = os.path.splitext(content.name)[1]
            if generated_ext.lower() != ext.lower():
                name = orig_name + generated_ext
        super(ThumbnailerImageFieldFile, self).save(name, content, *args,
                                                    **kwargs)

########NEW FILE########
__FILENAME__ = get_version
from __future__ import unicode_literals

import datetime
import os
import subprocess


def get_version(version=None):
    "Returns a PEP 386-compliant version number from VERSION."
    if version is None:
        from easy_thumbnails import VERSION as version
    else:
        assert len(version) == 5
        assert version[3] in ('alpha', 'beta', 'rc', 'final')

    # Now build the two parts of the version number:
    # main = X.Y[.Z]
    # sub = .devN - for pre-alpha releases
    #     | {a|b|c}N - for alpha, beta and rc releases

    parts = 2 if version[2] == 0 else 3
    main = '.'.join(str(x) for x in version[:parts])

    sub = ''
    if version[3] == 'post':
        sub_v = version[4] or get_git_changeset()
        sub = '.post%s' % sub_v

    elif version[3] == 'alpha' and version[4] == 0:
        git_changeset = get_git_changeset()
        if git_changeset:
            sub = '.dev%s' % git_changeset

    elif version[3] != 'final':
        mapping = {'alpha': 'a', 'beta': 'b', 'rc': 'c'}
        sub = mapping[version[3]] + str(version[4])

    return str(main + sub)


def get_git_changeset():
    """Returns a numeric identifier of the latest git changeset.

    The result is the UTC timestamp of the changeset in YYYYMMDDHHMMSS format.
    This value isn't guaranteed to be unique, but collisions are very unlikely,
    so it's sufficient for generating the development version numbers.
    """
    repo_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    git_log = subprocess.Popen(
        'git log --pretty=format:%ct --quiet -1 HEAD',
        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        shell=True, cwd=repo_dir, universal_newlines=True)
    timestamp = git_log.communicate()[0]
    try:
        timestamp = datetime.datetime.utcfromtimestamp(int(timestamp))
    except ValueError:
        return None
    return timestamp.strftime('%Y%m%d%H%M%S')

########NEW FILE########
__FILENAME__ = thumbnail_cleanup
import gc
import os
import time
from datetime import datetime, date, timedelta
from optparse import make_option

from django.core.files.storage import get_storage_class
from django.core.management.base import BaseCommand
from easy_thumbnails.conf import settings
from easy_thumbnails.models import Source


class ThumbnailCollectionCleaner(object):
    """
    Remove thumbnails and DB references to non-existing source images.
    """
    sources = 0
    thumbnails = 0
    thumbnails_deleted = 0
    source_refs_deleted = 0
    execution_time = 0

    def _get_absolute_path(self, path):
        return os.path.join(settings.MEDIA_ROOT, path)

    def _get_relative_path(self, path):
        return os.path.relpath(path, settings.MEDIA_ROOT)

    def _check_if_exists(self, storage, path):
        try:
            return storage.exists(path)
        except Exception as e:
            print("Something went wrong when checking existance of %s:" % path)
            print(str(e))

    def _delete_sources_by_id(self, ids):
        Source.objects.all().filter(id__in=ids).delete()

    def clean_up(self, dry_run=False, verbosity=1, last_n_days=0,
                 cleanup_path=None, storage=None):
        """
        Iterate through sources. Delete database references to sources
        not existing, including its corresponding thumbnails (files and
        database references).
        """
        if dry_run:
            print ("Dry run...")

        if not storage:
            storage = get_storage_class(settings.THUMBNAIL_DEFAULT_STORAGE)()

        sources_to_delete = []
        time_start = time.time()

        query = Source.objects.all()
        if last_n_days > 0:
            today = date.today()
            query = query.filter(
                modified__range=(today - timedelta(days=last_n_days), today))
        if cleanup_path:
            query = query.filter(name__startswith=cleanup_path)

        for source in queryset_iterator(query):
            self.sources += 1
            abs_source_path = self._get_absolute_path(source.name)

            if not self._check_if_exists(storage, abs_source_path):
                if verbosity > 0:
                    print ("Source not present:", abs_source_path)
                self.source_refs_deleted += 1
                sources_to_delete.append(source.id)

                for thumb in source.thumbnails.all():
                    self.thumbnails_deleted += 1
                    abs_thumbnail_path = self._get_absolute_path(thumb.name)

                    if self._check_if_exists(storage, abs_thumbnail_path):
                        if not dry_run:
                            storage.delete(abs_thumbnail_path)
                        if verbosity > 0:
                            print ("Deleting thumbnail:", abs_thumbnail_path)

            if len(sources_to_delete) >= 1000 and not dry_run:
                self._delete_sources_by_id(sources_to_delete)
                sources_to_delete = []

        if not dry_run:
            self._delete_sources_by_id(sources_to_delete)
        self.execution_time = round(time.time() - time_start)

    def print_stats(self):
        """
        Print statistics about the cleanup performed.
        """
        print(
            "{:-<48}".format(str(datetime.now().strftime('%Y-%m-%d %H:%M '))))
        print("{:<40} {:>7}".format("Sources checked:", self.sources))
        print("{:<40} {:>7}".format(
            "Source references deleted from DB:", self.source_refs_deleted))
        print("{:<40} {:>7}".format("Thumbnails deleted from disk:",
                                    self.thumbnails_deleted))
        print("(Completed in %s seconds)\n" % self.execution_time)


def queryset_iterator(queryset, chunksize=1000):
    """
    The queryset iterator helps to keep the memory consumption down.
    And also making it easier to process for weaker computers.
    """

    primary_key = 0
    last_pk = queryset.order_by('-pk')[0].pk
    queryset = queryset.order_by('pk')
    while primary_key < last_pk:
        for row in queryset.filter(pk__gt=primary_key)[:chunksize]:
            primary_key = row.pk
            yield row
        gc.collect()


class Command(BaseCommand):
    help = """ Deletes thumbnails that no longer have an original file. """

    option_list = BaseCommand.option_list + (
        make_option(
            '--dry-run',
            action='store_true',
            dest='dry_run',
            default=False,
            help='Dry run the execution.'),
        make_option(
            '--last-n-days',
            action='store',
            dest='last_n_days',
            default=0,
            type='int',
            help='The number of days back in time to clean thumbnails for.'),
        make_option(
            '--path',
            action='store',
            dest='cleanup_path',
            type='string',
            help='Specify a path to clean up.'),
    )

    def handle(self, *args, **options):
        tcc = ThumbnailCollectionCleaner()
        tcc.clean_up(
            dry_run=options.get('dry_run', False),
            verbosity=int(options.get('verbosity', 1)),
            last_n_days=int(options.get('last_n_days', 0)),
            cleanup_path=options.get('cleanup_path'))
        tcc.print_stats()

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf8
from django.db import models, migrations
import django.utils.timezone


class Migration(migrations.Migration):

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Source',
            fields=[
                (u'id', models.AutoField(verbose_name=u'ID', serialize=False, auto_created=True, primary_key=True)),
                ('storage_hash', models.CharField(max_length=40, db_index=True)),
                ('name', models.CharField(max_length=255, db_index=True)),
                ('modified', models.DateTimeField(default=django.utils.timezone.now)),
            ],
            options={
                u'unique_together': set([('storage_hash', 'name')]),
                u'abstract': False,
            },
            bases=(models.Model,),
        ),
        migrations.CreateModel(
            name='Thumbnail',
            fields=[
                (u'id', models.AutoField(verbose_name=u'ID', serialize=False, auto_created=True, primary_key=True)),
                ('storage_hash', models.CharField(max_length=40, db_index=True)),
                ('name', models.CharField(max_length=255, db_index=True)),
                ('modified', models.DateTimeField(default=django.utils.timezone.now)),
                ('source', models.ForeignKey(to='easy_thumbnails.Source', to_field=u'id')),
            ],
            options={
                u'unique_together': set([('storage_hash', 'name', 'source')]),
            },
            bases=(models.Model,),
        ),
    ]

########NEW FILE########
__FILENAME__ = 0002_thumbnaildimensions
# encoding: utf8
from django.db import models, migrations


class Migration(migrations.Migration):

    dependencies = [
        ('easy_thumbnails', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='ThumbnailDimensions',
            fields=[
                (u'id', models.AutoField(verbose_name=u'ID', serialize=False, auto_created=True, primary_key=True)),
                ('thumbnail', models.OneToOneField(to='easy_thumbnails.Thumbnail', to_field=u'id')),
                ('width', models.PositiveIntegerField(null=True)),
                ('height', models.PositiveIntegerField(null=True)),
            ],
            options={
            },
            bases=(models.Model,),
        ),
    ]

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils import timezone

from easy_thumbnails import utils, signal_handlers
from easy_thumbnails.conf import settings


class FileManager(models.Manager):

    def get_file(self, storage, name, create=False, update_modified=None,
                 check_cache_miss=False, **kwargs):
        kwargs.update(dict(storage_hash=utils.get_storage_hash(storage),
                           name=name))
        if create:
            if update_modified:
                defaults = kwargs.setdefault('defaults', {})
                defaults['modified'] = update_modified
            obj, created = self.get_or_create(**kwargs)
        else:
            created = False
            kwargs.pop('defaults', None)
            try:
                manager = self._get_thumbnail_manager()
                obj = manager.get(**kwargs)
            except self.model.DoesNotExist:

                if check_cache_miss and storage.exists(name):
                    # File already in storage, update cache
                    obj = self.create(**kwargs)
                    created = True
                else:
                    return

        if update_modified and not created:
            if obj.modified != update_modified:
                self.filter(pk=obj.pk).update(modified=update_modified)

        return obj

    def _get_thumbnail_manager(self):
        if settings.THUMBNAIL_CACHE_DIMENSIONS:
            return self.select_related("dimensions")
        return self


class File(models.Model):
    storage_hash = models.CharField(max_length=40, db_index=True)
    name = models.CharField(max_length=255, db_index=True)
    modified = models.DateTimeField(default=timezone.now)

    objects = FileManager()

    class Meta:
        abstract = True
        unique_together = (('storage_hash', 'name'),)

    def __unicode__(self):
        return self.name


class Source(File):
    pass


class Thumbnail(File):
    source = models.ForeignKey(Source, related_name='thumbnails')

    class Meta:
        unique_together = (('storage_hash', 'name', 'source'),)


class ThumbnailDimensions(models.Model):
    thumbnail = models.OneToOneField(Thumbnail, related_name="dimensions")
    width = models.PositiveIntegerField(null=True)
    height = models.PositiveIntegerField(null=True)

    def __unicode__(self):
        return "%sx%s" % (self.width, self.height)

    @property
    def size(self):
        return self.width, self.height


models.signals.pre_save.connect(signal_handlers.find_uncommitted_filefields)
models.signals.post_save.connect(signal_handlers.signal_committed_filefields)

########NEW FILE########
__FILENAME__ = namers
from __future__ import unicode_literals
import base64
import hashlib
import os


def default(thumbnailer, prepared_options, source_filename,
            thumbnail_extension, **kwargs):
    """
    Easy-thumbnails' default name processor.

    For example: ``source.jpg.100x100_q80_crop_upscale.jpg``
    """
    filename_parts = [source_filename]
    if ('%(opts)s' in thumbnailer.thumbnail_basedir or
            '%(opts)s' in thumbnailer.thumbnail_subdir):
        if thumbnail_extension != os.path.splitext(source_filename)[1][1:]:
            filename_parts.append(thumbnail_extension)
    else:
        filename_parts += ['_'.join(prepared_options), thumbnail_extension]
    return '.'.join(filename_parts)


def hashed(source_filename, prepared_options, thumbnail_extension, **kwargs):
    """
    Generate a short hashed thumbnail filename.

    Creates a 12 character url-safe base64 sha1 filename (plus the extension),
    for example: ``6qW1buHgLaZ9.jpg``.
    """
    parts = ':'.join([source_filename] + prepared_options)
    short_sha = hashlib.sha1(parts.encode('utf-8')).digest()
    short_hash = base64.urlsafe_b64encode(short_sha[:9]).decode('utf-8')
    return '.'.join([short_hash, thumbnail_extension])


def source_hashed(source_filename, prepared_options, thumbnail_extension,
                  **kwargs):
    """
    Generate a thumbnail filename of the source filename and options separately
    hashed, along with the size.

    The format of the filename is a 12 character base64 sha1 hash of the source
    filename, the size surrounded by underscores, and an 8 character options
    base64 sha1 hash of the thumbnail options. For example:
    ``1xedFtqllFo9_100x100_QHCa6G1l.jpg``.
    """
    source_sha = hashlib.sha1(source_filename.encode('utf-8')).digest()
    source_hash = base64.urlsafe_b64encode(source_sha[:9]).decode('utf-8')
    parts = ':'.join(prepared_options[1:])
    parts_sha = hashlib.sha1(parts.encode('utf-8')).digest()
    options_hash = base64.urlsafe_b64encode(parts_sha[:6]).decode('utf-8')
    return '%s_%s_%s.%s' % (
        source_hash, prepared_options[0], options_hash, thumbnail_extension)

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
from easy_thumbnails.conf import Settings


class OptimizeSettings(Settings):
    THUMBNAIL_OPTIMIZE_COMMAND = {'png': None, 'jpeg': None, 'gif': None}
    """
    Postprocess thumbnails of type PNG, GIF or JEPG after transformation but
    before storage.

    Apply an external post processing program to images after they have been
    manipulated by PIL or Pillow. This is strongly recommended by tools such as
    Google's PageSpeed on order to reduce the payload of the thumbnailed image
    files.

    Example::

      THUMBNAIL_OPTIMIZE_COMMAND = {
          'png': '/usr/bin/optipng {filename}',
          'gif': '/usr/bin/optipng {filename}',
          'jpeg': '/usr/bin/jpegoptim {filename}'
      }

    Note that ``optipng`` can also optimize images of type GIF.
    """

settings = OptimizeSettings()

########NEW FILE########
__FILENAME__ = post_processor
# -*- coding: utf-8 -*-
import logging
import subprocess
from imghdr import what as determinetype
from django.core.files.base import ContentFile
from django.core.files.temp import NamedTemporaryFile
from easy_thumbnails.optimize.conf import settings


try:
    from subprocess import check_output
except ImportError:
    def check_output(*popenargs, **kwargs):
        """
        Run command with arguments and return its output as a byte string.

        Backported from Python 2.7 as it's implemented as pure python on
        stdlib.
        """
        process = subprocess.Popen(
            stdout=subprocess.PIPE, *popenargs, **kwargs)
        output, unused_err = process.communicate()
        retcode = process.poll()
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            error = subprocess.CalledProcessError(retcode, cmd)
            error.output = output
            raise error
        return output


logger = logging.getLogger('easy_thumbnails.optimize')


def optimize_thumbnail(thumbnail):
    '''Optimize thumbnail images by removing unnecessary data'''
    try:
        optimize_command = settings.THUMBNAIL_OPTIMIZE_COMMAND[
            determinetype(thumbnail.path)]
        if not optimize_command:
            return
    except (TypeError, KeyError, NotImplementedError):
        return
    storage = thumbnail.storage
    try:
        with NamedTemporaryFile() as temp_file:
            thumbnail.seek(0)
            temp_file.write(thumbnail.read())
            temp_file.flush()
            optimize_command = optimize_command.format(filename=temp_file.name)
            output = check_output(
                optimize_command, stderr=subprocess.STDOUT, shell=True)
            if output:
                logger.warn(
                    '{0} returned {1}'.format(optimize_command, output))
            else:
                logger.info('{0} returned nothing'.format(optimize_command))
            with open(temp_file.name, 'rb') as f:
                thumbnail.file = ContentFile(f.read())
                storage.delete(thumbnail.path)
                storage.save(thumbnail.path, thumbnail)
    except Exception as e:
        logger.error(e)

########NEW FILE########
__FILENAME__ = options
from __future__ import unicode_literals

from django.utils import six
from easy_thumbnails.conf import settings


class ThumbnailOptions(dict):

    def __init__(self, *args, **kwargs):
        self._prepared_options = None
        super(ThumbnailOptions, self).__init__(*args, **kwargs)
        if settings.THUMBNAIL_DEFAULT_OPTIONS:
            for key, value in six.iteritems(
                    settings.THUMBNAIL_DEFAULT_OPTIONS):
                self.setdefault(key, value)
        self.setdefault('quality', settings.THUMBNAIL_QUALITY)
        self.setdefault('subsampling', 2)

    def prepared_options(self):
        prepared_opts = ['%sx%s' % tuple(self['size'])]

        subsampling = six.text_type(self['subsampling'])
        if subsampling == '2':
            subsampling_text = ''
        else:
            subsampling_text = 'ss%s' % subsampling
        prepared_opts.append('q%s%s' % (self['quality'], subsampling_text))

        for key, value in sorted(six.iteritems(self)):
            if key == key.upper():
                # Uppercase options aren't used by prepared options (a primary
                # use of prepared options is to generate the filename -- these
                # options don't alter the filename).
                continue
            if not value or key in ('size', 'quality', 'subsampling'):
                continue
            if value is True:
                prepared_opts.append(key)
                continue
            if not isinstance(value, six.string_types):
                try:
                    value = ','.join([six.text_type(item) for item in value])
                except TypeError:
                    value = six.text_type(value)
            prepared_opts.append('%s-%s' % (key, value))

        return prepared_opts

########NEW FILE########
__FILENAME__ = processors
import itertools
import re

from django.utils import six
try:
    from PIL import Image, ImageChops, ImageFilter
except ImportError:
    import Image
    import ImageChops
    import ImageFilter

from easy_thumbnails import utils


def _compare_entropy(start_slice, end_slice, slice, difference):
    """
    Calculate the entropy of two slices (from the start and end of an axis),
    returning a tuple containing the amount that should be added to the start
    and removed from the end of the axis.

    """
    start_entropy = utils.image_entropy(start_slice)
    end_entropy = utils.image_entropy(end_slice)
    if end_entropy and abs(start_entropy / end_entropy - 1) < 0.01:
        # Less than 1% difference, remove from both sides.
        if difference >= slice * 2:
            return slice, slice
        half_slice = slice // 2
        return half_slice, slice - half_slice
    if start_entropy > end_entropy:
        return 0, slice
    else:
        return slice, 0


def _points_table():
    """
    Iterable to map a 16 bit grayscale image to 8 bits.
    """
    for i in range(256):
        for j in itertools.repeat(i, 256):
            yield j


def colorspace(im, bw=False, replace_alpha=False, **kwargs):
    """
    Convert images to the correct color space.

    A passive option (i.e. always processed) of this method is that all images
    (unless grayscale) are converted to RGB colorspace.

    This processor should be listed before :func:`scale_and_crop` so palette is
    changed before the image is resized.

    bw
        Make the thumbnail grayscale (not really just black & white).

    replace_alpha
        Replace any transparency layer with a solid color. For example,
        ``replace_alpha='#fff'`` would replace the transparency layer with
        white.

    """
    if im.mode == 'I':
        # PIL (and pillow) have can't convert 16 bit grayscale images to lower
        # modes, so manually convert them to an 8 bit grayscale.
        im = im.point(list(_points_table()), 'L')

    is_transparent = utils.is_transparent(im)
    is_grayscale = im.mode in ('L', 'LA')
    new_mode = im.mode
    if is_grayscale or bw:
        new_mode = 'L'
    else:
        new_mode = 'RGB'

    if is_transparent:
        if replace_alpha:
            if im.mode != 'RGBA':
                im = im.convert('RGBA')
            base = Image.new('RGBA', im.size, replace_alpha)
            base.paste(im, mask=im)
            im = base
        else:
            new_mode = new_mode + 'A'

    if im.mode != new_mode:
        im = im.convert(new_mode)

    return im


def autocrop(im, autocrop=False, **kwargs):
    """
    Remove any unnecessary whitespace from the edges of the source image.

    This processor should be listed before :func:`scale_and_crop` so the
    whitespace is removed from the source image before it is resized.

    autocrop
        Activates the autocrop method for this image.

    """
    if autocrop:
        # If transparent, flatten.
        if utils.is_transparent(im) and False:
            no_alpha = Image.new('L', im.size, (255))
            no_alpha.paste(im, mask=im.split()[-1])
        else:
            no_alpha = im.convert('L')
        # Convert to black and white image.
        bw = no_alpha.convert('L')
        # bw = bw.filter(ImageFilter.MedianFilter)
        # White background.
        bg = Image.new('L', im.size, 255)
        bbox = ImageChops.difference(bw, bg).getbbox()
        if bbox:
            im = im.crop(bbox)
    return im


def scale_and_crop(im, size, crop=False, upscale=False, zoom=None, target=None,
                   **kwargs):
    """
    Handle scaling and cropping the source image.

    Images can be scaled / cropped against a single dimension by using zero
    as the placeholder in the size. For example, ``size=(100, 0)`` will cause
    the image to be resized to 100 pixels wide, keeping the aspect ratio of
    the source image.

    crop
        Crop the source image height or width to exactly match the requested
        thumbnail size (the default is to proportionally resize the source
        image to fit within the requested thumbnail size).

        By default, the image is centered before being cropped. To crop from
        the edges, pass a comma separated string containing the ``x`` and ``y``
        percentage offsets (negative values go from the right/bottom). Some
        examples follow:

        * ``crop="0,0"`` will crop from the left and top edges.

        * ``crop="-10,-0"`` will crop from the right edge (with a 10% offset)
          and the bottom edge.

        * ``crop=",0"`` will keep the default behavior for the x axis
          (horizontally centering the image) and crop from the top edge.

        The image can also be "smart cropped" by using ``crop="smart"``. The
        image is incrementally cropped down to the requested size by removing
        slices from edges with the least entropy.

        Finally, you can use ``crop="scale"`` to simply scale the image so that
        at least one dimension fits within the size dimensions given (you may
        want to use the upscale option too).

    upscale
        Allow upscaling of the source image during scaling.

    zoom
        A percentage to zoom in on the scaled image. For example, a zoom of
        ``40`` will clip 20% off each side of the source image before
        thumbnailing.

    target
        Set the focal point as a percentage for the image if it needs to be
        cropped (defaults to ``(50, 50)``).

        For example, ``target="10,20"`` will set the focal point as 10% and 20%
        from the left and top of the image, respectively. If the image needs to
        be cropped, it will trim off the right and bottom edges until the focal
        point is centered.

        Can either be set as a two-item tuple such as ``(20, 30)`` or a comma
        separated string such as ``"20,10"``.

        A null value such as ``(20, None)`` or ``",60"`` will default to 50%.
    """
    source_x, source_y = [float(v) for v in im.size]
    target_x, target_y = [int(v) for v in size]

    if crop or not target_x or not target_y:
        scale = max(target_x / source_x, target_y / source_y)
    else:
        scale = min(target_x / source_x, target_y / source_y)

    # Handle one-dimensional targets.
    if not target_x:
        target_x = round(source_x * scale)
    elif not target_y:
        target_y = round(source_y * scale)

    if zoom:
        if not crop:
            target_x = round(source_x * scale)
            target_y = round(source_y * scale)
            crop = True
        scale *= (100 + int(zoom)) / 100.0

    if scale < 1.0 or (scale > 1.0 and upscale):
        # Resize the image to the target size boundary. Round the scaled
        # boundary sizes to avoid floating point errors.
        im = im.resize((int(round(source_x * scale)),
                        int(round(source_y * scale))),
                       resample=Image.ANTIALIAS)

    if crop:
        # Use integer values now.
        source_x, source_y = im.size
        # Difference between new image size and requested size.
        diff_x = int(source_x - min(source_x, target_x))
        diff_y = int(source_y - min(source_y, target_y))
        if crop != 'scale' and (diff_x or diff_y):
            if isinstance(target, six.string_types):
                target = re.match(r'(\d+)?,(\d+)?$', target)
                if target:
                    target = target.groups()
            if target:
                focal_point = [int(n) if (n or n == 0) else 50 for n in target]
            else:
                focal_point = 50, 50
            # Crop around the focal point
            halftarget_x, halftarget_y = int(target_x / 2), int(target_y / 2)
            focal_point_x = int(source_x * focal_point[0] / 100)
            focal_point_y = int(source_y * focal_point[1] / 100)
            box = [
                max(0, min(source_x - target_x, focal_point_x - halftarget_x)),
                max(0, min(source_y - target_y, focal_point_y - halftarget_y)),
            ]
            box.append(min(source_x, box[0] + target_x))
            box.append(min(source_y, box[1] + target_y))
            # See if an edge cropping argument was provided.
            edge_crop = (isinstance(crop, six.string_types) and
                         re.match(r'(?:(-?)(\d+))?,(?:(-?)(\d+))?$', crop))
            if edge_crop and filter(None, edge_crop.groups()):
                x_right, x_crop, y_bottom, y_crop = edge_crop.groups()
                if x_crop:
                    offset = min(int(target_x) * int(x_crop) // 100, diff_x)
                    if x_right:
                        box[0] = diff_x - offset
                        box[2] = source_x - offset
                    else:
                        box[0] = offset
                        box[2] = source_x - (diff_x - offset)
                if y_crop:
                    offset = min(int(target_y) * int(y_crop) // 100, diff_y)
                    if y_bottom:
                        box[1] = diff_y - offset
                        box[3] = source_y - offset
                    else:
                        box[1] = offset
                        box[3] = source_y - (diff_y - offset)
            # See if the image should be "smart cropped".
            elif crop == 'smart':
                left = top = 0
                right, bottom = source_x, source_y
                while diff_x:
                    slice = min(diff_x, max(diff_x // 5, 10))
                    start = im.crop((left, 0, left + slice, source_y))
                    end = im.crop((right - slice, 0, right, source_y))
                    add, remove = _compare_entropy(start, end, slice, diff_x)
                    left += add
                    right -= remove
                    diff_x = diff_x - add - remove
                while diff_y:
                    slice = min(diff_y, max(diff_y // 5, 10))
                    start = im.crop((0, top, source_x, top + slice))
                    end = im.crop((0, bottom - slice, source_x, bottom))
                    add, remove = _compare_entropy(start, end, slice, diff_y)
                    top += add
                    bottom -= remove
                    diff_y = diff_y - add - remove
                box = (left, top, right, bottom)
            # Finally, crop the image!
            im = im.crop(box)
    return im


def filters(im, detail=False, sharpen=False, **kwargs):
    """
    Pass the source image through post-processing filters.

    sharpen
        Sharpen the thumbnail image (using the PIL sharpen filter)

    detail
        Add detail to the image, like a mild *sharpen* (using the PIL
        ``detail`` filter).

    """
    if detail:
        im = im.filter(ImageFilter.DETAIL)
    if sharpen:
        im = im.filter(ImageFilter.SHARPEN)
    return im


def background(im, size, background=None, crop=None, replace_alpha=None,
               **kwargs):
    """
    Add borders of a certain color to make the resized image fit exactly within
    the dimensions given.

    background
        Background color to use
    """
    if not background:
        # Primary option not given, nothing to do.
        return im
    if not size[0] or not size[1]:
        # One of the dimensions aren't specified, can't do anything.
        return im
    x, y = im.size
    if x >= size[0] and y >= size[1]:
        # The image is already equal to (or larger than) the expected size, so
        # there's nothing to do.
        return im
    im = colorspace(im, replace_alpha=background, **kwargs)
    new_im = Image.new('RGB', size, background)
    if new_im.mode != im.mode:
        new_im = new_im.convert(im.mode)
    offset = (size[0]-x)//2, (size[1]-y)//2
    new_im.paste(im, offset)
    return new_im

########NEW FILE########
__FILENAME__ = signals
import django.dispatch

saved_file = django.dispatch.Signal(providing_args=['fieldfile'])
"""
A signal sent for each ``FileField`` saved when a model is saved.

* The ``sender`` argument will be the model class.
* The ``fieldfile`` argument will be the instance of the field's file that was
  saved.
"""

thumbnail_created = django.dispatch.Signal()
"""
A signal that gets sent every time a new thumbnail is created.

* The ``sender`` argument is the created ``ThumbnailFile``
"""

thumbnail_missed = django.dispatch.Signal(
    providing_args=['options', 'high_resolution'])
"""
A signal that gets sent whenever a thumbnail is passively requested (i.e. when
no render-time generation is wanted, via the ``generate=False`` argument).

* The ``sender`` argument is the ``Thumbnailer``
* The ``options`` are the thumbnail options requested.
* The ``high_resolution`` boolean argument is set to ``True`` if this is the 2x
  resolution thumbnail that was missed.
"""

########NEW FILE########
__FILENAME__ = signal_handlers
from django.db.models.fields.files import FileField

from easy_thumbnails import signals


def find_uncommitted_filefields(sender, instance, **kwargs):
    """
    A pre_save signal handler which attaches an attribute to the model instance
    containing all uncommitted ``FileField``s, which can then be used by the
    :func:`signal_committed_filefields` post_save handler.
    """
    uncommitted = instance._uncommitted_filefields = []

    fields = sender._meta.fields
    if kwargs.get('update_fields', None):
        update_fields = set(kwargs['update_fields'])
        fields = update_fields.intersection(fields)
    for field in fields:
        if isinstance(field, FileField):
            if not getattr(instance, field.name)._committed:
                uncommitted.append(field.name)


def signal_committed_filefields(sender, instance, **kwargs):
    """
    A post_save signal handler which sends a signal for each ``FileField`` that
    was committed this save.
    """
    for field_name in getattr(instance, '_uncommitted_filefields', ()):
        fieldfile = getattr(instance, field_name)
        # Don't send the signal for deleted files.
        if fieldfile:
            signals.saved_file.send_robust(sender=sender, fieldfile=fieldfile)


def generate_aliases(fieldfile, **kwargs):
    """
    A saved_file signal handler which generates thumbnails for all field,
    model, and app specific aliases matching the saved file's field.
    """
    # Avoids circular import.
    from easy_thumbnails.files import generate_all_aliases
    generate_all_aliases(fieldfile, include_global=False)


def generate_aliases_global(fieldfile, **kwargs):
    """
    A saved_file signal handler which generates thumbnails for all field,
    model, and app specific aliases matching the saved file's field, also
    generating thumbnails for each project-wide alias.
    """
    # Avoids circular import.
    from easy_thumbnails.files import generate_all_aliases
    generate_all_aliases(fieldfile, include_global=True)

########NEW FILE########
__FILENAME__ = source_generators
try:
    from cStringIO import cStringIO as BytesIO
except ImportError:
    from django.utils.six import BytesIO

try:
    from PIL import Image
except ImportError:
    import Image

from easy_thumbnails import utils


def pil_image(source, exif_orientation=True, **options):
    """
    Try to open the source file directly using PIL, ignoring any errors.

    exif_orientation

        If EXIF orientation data is present, perform any required reorientation
        before passing the data along the processing pipeline.

    """
    # Use a BytesIO wrapper because if the source is an incomplete file like
    # object, PIL may have problems with it. For example, some image types
    # require tell and seek methods that are not present on all storage
    # File objects.
    if not source:
        return
    source = BytesIO(source.read())

    image = Image.open(source)
    # Fully load the image now to catch any problems with the image contents.
    try:
        # An "Image file truncated" exception can occur for some images that
        # are still mostly valid -- we'll swallow the exception.
        image.load()
    except IOError:
        pass
    # Try a second time to catch any other potential exceptions.
    image.load()

    if exif_orientation:
        image = utils.exif_orientation(image)
    return image

########NEW FILE########
__FILENAME__ = 0001_initial

from south.db import db
from django.db import models
from easy_thumbnails.models import *

class Migration:
    
    def forwards(self, orm):
        
        # Adding model 'Source'
        db.create_table('easy_thumbnails_source', (
            ('id', orm['easy_thumbnails.Source:id']),
            ('storage', orm['easy_thumbnails.Source:storage']),
            ('name', orm['easy_thumbnails.Source:name']),
            ('modified', orm['easy_thumbnails.Source:modified']),
        ))
        db.send_create_signal('easy_thumbnails', ['Source'])
        
        # Adding model 'Storage'
        db.create_table('easy_thumbnails_storage', (
            ('hash', orm['easy_thumbnails.Storage:hash']),
            ('pickle', orm['easy_thumbnails.Storage:pickle']),
        ))
        db.send_create_signal('easy_thumbnails', ['Storage'])
        
        # Adding model 'Thumbnail'
        db.create_table('easy_thumbnails_thumbnail', (
            ('id', orm['easy_thumbnails.Thumbnail:id']),
            ('storage', orm['easy_thumbnails.Thumbnail:storage']),
            ('name', orm['easy_thumbnails.Thumbnail:name']),
            ('modified', orm['easy_thumbnails.Thumbnail:modified']),
            ('source', orm['easy_thumbnails.Thumbnail:source']),
        ))
        db.send_create_signal('easy_thumbnails', ['Thumbnail'])
        
    
    
    def backwards(self, orm):
        
        # Deleting model 'Source'
        db.delete_table('easy_thumbnails_source')
        
        # Deleting model 'Storage'
        db.delete_table('easy_thumbnails_storage')
        
        # Deleting model 'Thumbnail'
        db.delete_table('easy_thumbnails_thumbnail')
        
    
    
    models = {
        'easy_thumbnails.source': {
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2009, 11, 22, 21, 16, 23, 523494)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"})
        },
        'easy_thumbnails.storage': {
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'primary_key': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.thumbnail': {
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2009, 11, 22, 21, 16, 23, 523494)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"})
        }
    }
    
    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0002_filename_indexes

from south.db import db
from django.db import models
from easy_thumbnails.models import *

class Migration:
    
    def forwards(self, orm):
        db.create_index('easy_thumbnails_source', ['name'])
        db.create_index('easy_thumbnails_thumbnail', ['name'])
        db.create_index('easy_thumbnails_storage', ['hash'])
    
    
    def backwards(self, orm):
        db.delete_index('easy_thumbnails_source', ['name'])
        db.delete_index('easy_thumbnails_thumbnail', ['name'])
        db.delete_index('easy_thumbnails_storage', ['hash'])
    
    
    models = {
        'easy_thumbnails.source': {
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2009, 11, 22, 21, 17, 49, 7917)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"})
        },
        'easy_thumbnails.storage': {
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'primary_key': 'True', 'db_index': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.thumbnail': {
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2009, 11, 22, 21, 17, 49, 7917)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"})
        }
    }
    
    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0003_auto__add_storagenew
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'StorageNew'
        db.create_table('easy_thumbnails_storagenew', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('hash', self.gf('django.db.models.fields.CharField')(max_length=40, db_index=True)),
            ('pickle', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('easy_thumbnails', ['StorageNew'])


    def backwards(self, orm):
        
        # Deleting model 'StorageNew'
        db.delete_table('easy_thumbnails_storagenew')


    models = {
        'easy_thumbnails.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 11, 43, 389353)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"})
        },
        'easy_thumbnails.storage': {
            'Meta': {'object_name': 'Storage', 'db_table': "'easy_thumbnails_storage_tmp'"},
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'primary_key': 'True', 'db_index': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.storagenew': {
            'Meta': {'object_name': 'StorageNew'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.thumbnail': {
            'Meta': {'object_name': 'Thumbnail'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 11, 43, 389353)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"})
        }
    }

    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0004_auto__add_field_source_storage_new__add_field_thumbnail_storage_new
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Source.storage_new'
        db.add_column('easy_thumbnails_source', 'storage_new', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['easy_thumbnails.StorageNew'], null=True), keep_default=False)

        # Adding field 'Thumbnail.storage_new'
        db.add_column('easy_thumbnails_thumbnail', 'storage_new', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['easy_thumbnails.StorageNew'], null=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Source.storage_new'
        db.delete_column('easy_thumbnails_source', 'storage_new_id')

        # Deleting field 'Thumbnail.storage_new'
        db.delete_column('easy_thumbnails_thumbnail', 'storage_new_id')


    models = {
        'easy_thumbnails.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 17, 31, 982538)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"}),
            'storage_new': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.StorageNew']", 'null': 'True'})
        },
        'easy_thumbnails.storage': {
            'Meta': {'object_name': 'Storage'},
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'primary_key': 'True', 'db_index': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.storagenew': {
            'Meta': {'object_name': 'StorageNew'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.thumbnail': {
            'Meta': {'object_name': 'Thumbnail'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 17, 31, 982538)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"}),
            'storage_new': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.StorageNew']", 'null': 'True'})
        }
    }

    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0005_storage_fks_null
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Changing field 'Source.storage'
        db.alter_column('easy_thumbnails_source', 'storage_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['easy_thumbnails.Storage'], null=True))

        # Changing field 'Thumbnail.storage'
        db.alter_column('easy_thumbnails_thumbnail', 'storage_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['easy_thumbnails.Storage'], null=True))


    def backwards(self, orm):

        # Changing field 'Source.storage'
        db.alter_column('easy_thumbnails_source', 'storage_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['easy_thumbnails.Storage']))

        # Changing field 'Thumbnail.storage'
        db.alter_column('easy_thumbnails_thumbnail', 'storage_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['easy_thumbnails.Storage']))


    models = {
        'easy_thumbnails.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 30, 21, 952191)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']", 'null': 'True'}),
            'storage_new': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.StorageNew']", 'null': 'True'})
        },
        'easy_thumbnails.storage': {
            'Meta': {'object_name': 'Storage'},
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'primary_key': 'True', 'db_index': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.storagenew': {
            'Meta': {'object_name': 'StorageNew'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.thumbnail': {
            'Meta': {'object_name': 'Thumbnail'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 30, 21, 952191)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']", 'null': 'True'}),
            'storage_new': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.StorageNew']", 'null': 'True'})
        }
    }

    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0006_copy_storage
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def copy(self, orm, OldModel, NewModel):
        old_field = new_field = None
        for field in orm.Source._meta.fields:
            if isinstance(field, models.ForeignKey):
                if field.rel.to == orm.Storage:
                    old_field = field
                elif field.rel.to == orm.StorageNew:
                    new_field = field
        assert old_field and new_field
        for storage in OldModel.objects.all():
            new_storage = NewModel()
            for key in [f.attname for f in OldModel._meta.fields]:
                setattr(new_storage, key, getattr(storage, key))
            new_storage.save()
            filter_kwargs = {old_field.name: storage}
            update_kwargs = {new_field.name: new_storage}
            for Model in (orm.Source, orm.Thumbnail):
                Model.objects.filter(**filter_kwargs).update(**update_kwargs)
    
    
    def forwards(self, orm):
        self.copy(orm, orm.Storage, orm.StorageNew)


    def backwards(self, orm):
        self.copy(orm, orm.StorageNew, orm.Storage)


    models = {
        'easy_thumbnails.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 17, 31, 982538)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']", 'null': 'True'}),
            'storage_new': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.StorageNew']", 'null': 'True'})
        },
        'easy_thumbnails.storage': {
            'Meta': {'object_name': 'Storage'},
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'primary_key': 'True', 'db_index': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.storagenew': {
            'Meta': {'object_name': 'StorageNew'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.thumbnail': {
            'Meta': {'object_name': 'Thumbnail'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 17, 31, 982538)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']", 'null': 'True'}),
            'storage_new': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.StorageNew']", 'null': 'True'})
        }
    }

    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0007_storagenew_fks_not_null
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Changing field 'Source.storage_new'
        db.alter_column('easy_thumbnails_source', 'storage_new_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['easy_thumbnails.StorageNew']))

        # Changing field 'Thumbnail.storage_new'
        db.alter_column('easy_thumbnails_thumbnail', 'storage_new_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['easy_thumbnails.StorageNew']))


    def backwards(self, orm):
        
        # Changing field 'Source.storage_new'
        db.alter_column('easy_thumbnails_source', 'storage_new_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['easy_thumbnails.StorageNew'], null=True))

        # Changing field 'Thumbnail.storage_new'
        db.alter_column('easy_thumbnails_thumbnail', 'storage_new_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['easy_thumbnails.StorageNew'], null=True))


    models = {
        'easy_thumbnails.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 30, 21, 952191)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']", 'null': 'True'}),
            'storage_new': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.StorageNew']"})
        },
        'easy_thumbnails.storage': {
            'Meta': {'object_name': 'Storage'},
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'primary_key': 'True', 'db_index': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.storagenew': {
            'Meta': {'object_name': 'StorageNew'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.thumbnail': {
            'Meta': {'object_name': 'Thumbnail'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 30, 21, 952191)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']", 'null': 'True'}),
            'storage_new': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.StorageNew']"})
        }
    }

    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0008_auto__del_field_source_storage__del_field_thumbnail_storage
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'Source.storage'
        db.delete_column('easy_thumbnails_source', 'storage_id')

        # Deleting field 'Thumbnail.storage'
        db.delete_column('easy_thumbnails_thumbnail', 'storage_id')


    def backwards(self, orm):
        
        # Adding field 'Source.storage'
        db.add_column('easy_thumbnails_source', 'storage', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['easy_thumbnails.Storage'], null=True), keep_default=False)

        # Adding field 'Thumbnail.storage'
        db.add_column('easy_thumbnails_thumbnail', 'storage', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['easy_thumbnails.Storage'], null=True), keep_default=False)


    models = {
        'easy_thumbnails.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 30, 33, 144413)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage_new': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.StorageNew']"})
        },
        'easy_thumbnails.storage': {
            'Meta': {'object_name': 'Storage'},
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'primary_key': 'True', 'db_index': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.storagenew': {
            'Meta': {'object_name': 'StorageNew'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.thumbnail': {
            'Meta': {'object_name': 'Thumbnail'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 30, 33, 144413)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage_new': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.StorageNew']"})
        }
    }

    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0009_auto__del_storage
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting model 'Storage'
        db.delete_table('easy_thumbnails_storage')


    def backwards(self, orm):
        
        # Adding model 'Storage'
        db.create_table('easy_thumbnails_storage', (
            ('pickle', self.gf('django.db.models.fields.TextField')()),
            ('hash', self.gf('django.db.models.fields.CharField')(max_length=40, primary_key=True, db_index=True)),
        ))
        db.send_create_signal('easy_thumbnails', ['Storage'])


    models = {
        'easy_thumbnails.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 34, 17, 1330)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage_new': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.StorageNew']"})
        },
        'easy_thumbnails.storagenew': {
            'Meta': {'object_name': 'StorageNew'},
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.thumbnail': {
            'Meta': {'object_name': 'Thumbnail'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 34, 17, 1330)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage_new': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.StorageNew']"})
        }
    }

    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0010_rename_storage
# encoding: utf-8
import sys
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        using_mysql = db.backend_name == 'mysql'
        db.rename_table('easy_thumbnails_storagenew', 'easy_thumbnails_storage')
        if using_mysql:
            try:
                db.drop_foreign_key('easy_thumbnails_source', 'storage_new_id')
            except ValueError:
                e = sys.exc_info()[1]   # Python 2.5 compatable "as e"
                # e.g MyISAM tables don't support foreign key constraints
                print("Could not remove foreign key contraint: %s" % e)
        db.rename_column('easy_thumbnails_source', 'storage_new_id', 'storage_id')
        if using_mysql:
            try:
                db.execute('ALTER TABLE easy_thumbnails_source ADD CONSTRAINT '
                           'sourcestorage_id_fk_to_storage FOREIGN KEY (storage_id) '
                           'REFERENCES easy_thumbnails_storage(id)')
            except Exception:
                e = sys.exc_info()[1]   # Python 2.5 compatable "as e"
                print("Could not add contraint: %s" % e)

        if using_mysql:
            try:
                db.drop_foreign_key('easy_thumbnails_thumbnail', 'storage_new_id')
            except ValueError:
                e = sys.exc_info()[1]   # Python 2.5 compatable "as e"
                # e.g MyISAM tables don't support foreign key constraints
                print("Could not remove foreign key contraint: %s" % e)
        db.rename_column('easy_thumbnails_thumbnail', 'storage_new_id', 'storage_id')
        if using_mysql:
            try:
                db.execute('ALTER TABLE easy_thumbnails_thumbnail ADD CONSTRAINT '
                           'thumbnailstorage_id_fk_to_storage FOREIGN KEY (storage_id) '
                           'REFERENCES easy_thumbnails_storage(id)')
            except Exception:
                e = sys.exc_info()[1]   # Python 2.5 compatable "as e"
                print("Could not add contraint: %s" % e)


    def backwards(self, orm):
        db.rename_table('easy_thumbnails_storage', 'easy_thumbnails_storagenew')
        db.rename_column('easy_thumbnails_source', 'storage_id', 'storage_new_id')
        db.rename_column('easy_thumbnails_thumbnail', 'storage_id', 'storage_new_id')


    models = {
        'easy_thumbnails.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 35, 38, 822349)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"})
        },
        'easy_thumbnails.storage': {
            'Meta': {'object_name': 'Storage'},
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.thumbnail': {
            'Meta': {'object_name': 'Thumbnail'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 7, 21, 4, 35, 38, 822349)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"})
        }
    }

    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0011_auto__add_field_source_storage_hash__add_field_thumbnail_storage_hash
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Source.storage_hash'
        db.add_column('easy_thumbnails_source', 'storage_hash', self.gf('django.db.models.fields.CharField')(default='', max_length=40), keep_default=False)

        # Adding field 'Thumbnail.storage_hash'
        db.add_column('easy_thumbnails_thumbnail', 'storage_hash', self.gf('django.db.models.fields.CharField')(default='', max_length=40), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Source.storage_hash'
        db.delete_column('easy_thumbnails_source', 'storage_hash')

        # Deleting field 'Thumbnail.storage_hash'
        db.delete_column('easy_thumbnails_thumbnail', 'storage_hash')


    models = {
        'easy_thumbnails.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 9, 8, 0, 31, 16, 27396)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"}),
            'storage_hash': ('django.db.models.fields.CharField', [], {'max_length': '40'})
        },
        'easy_thumbnails.storage': {
            'Meta': {'object_name': 'Storage'},
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.thumbnail': {
            'Meta': {'object_name': 'Thumbnail'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 9, 8, 0, 31, 16, 27396)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"}),
            'storage_hash': ('django.db.models.fields.CharField', [], {'max_length': '40'})
        }
    }

    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0012_build_storage_hashes
# encoding: utf-8
import datetime
import hashlib
from south.db import db
from south.v2 import DataMigration
from django.db import models
from django.core.files.storage import default_storage
import pickle


class Migration(DataMigration):
    """
    Migrate storage hashes.

    """

    def get_storage_hash(self, storage):
        """
        Return a hex string hash for a storage object (or string containing a
        pickle of a storage object).

        """
        try:
            # Make sure that pickle is getting a string, since it can choke
            # with unicode.
            storage_obj = pickle.loads(str(self.pickle))
        except:
            # We need to return some storage, and if there's an exception then
            # it is most likely the default_storage (since that fails with a
            # recursion error due to LazyObject "awesomeness").
            storage_obj = default_storage
        storage_cls = storage_obj.__class__
        name = '%s.%s' % (storage_cls.__module__, storage_cls.__name__)
        return hashlib.md5(name).hexdigest()

    def forwards(self, orm):
        "Write your forwards methods here."
        for storage in orm.Storage.objects.all():
            storage_hash = self.get_storage_hash(storage)
            orm.Source.objects.filter(storage=storage).update(
                                        storage_hash=storage_hash)
            orm.Thumbnail.objects.filter(storage=storage).update(
                                        storage_hash=storage_hash)

    def backwards(self, orm):
        "Write your backwards methods here."


    models = {
        'easy_thumbnails.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 9, 8, 0, 32, 41, 855399)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"}),
            'storage_hash': ('django.db.models.fields.CharField', [], {'max_length': '40'})
        },
        'easy_thumbnails.storage': {
            'Meta': {'object_name': 'Storage'},
            'hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pickle': ('django.db.models.fields.TextField', [], {})
        },
        'easy_thumbnails.thumbnail': {
            'Meta': {'object_name': 'Thumbnail'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 9, 8, 0, 32, 41, 855399)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['easy_thumbnails.Storage']"}),
            'storage_hash': ('django.db.models.fields.CharField', [], {'max_length': '40'})
        }
    }

    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0013_auto__del_storage__del_field_source_storage__del_field_thumbnail_stora
# encoding: utf-8
import datetime
import hashlib
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from django.core.files.storage import default_storage
import pickle


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Deleting model 'Storage'
        db.delete_table('easy_thumbnails_storage')

        # Deleting field 'Source.storage'
        db.delete_column('easy_thumbnails_source', 'storage_id')

        # Adding index on 'Source', fields ['storage_hash']
        db.create_index('easy_thumbnails_source', ['storage_hash'])

        # Deleting field 'Thumbnail.storage'
        db.delete_column('easy_thumbnails_thumbnail', 'storage_id')

        # Adding index on 'Thumbnail', fields ['storage_hash']
        db.create_index('easy_thumbnails_thumbnail', ['storage_hash'])


    def backwards(self, orm):

        # Removing index on 'Thumbnail', fields ['storage_hash']
        db.delete_index('easy_thumbnails_thumbnail', ['storage_hash'])

        # Removing index on 'Source', fields ['storage_hash']
        db.delete_index('easy_thumbnails_source', ['storage_hash'])

        # Adding model 'Storage'
        db.create_table('easy_thumbnails_storage', (
            ('pickle', self.gf('django.db.models.fields.TextField')()),
            ('hash', self.gf('django.db.models.fields.CharField')(max_length=40, db_index=True)),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        ))
        db.send_create_signal('easy_thumbnails', ['Storage'])

        # Create a storage object. This may obviously not be the storage
        # object which the source / thumbnail objects actually belong to but
        # at least it lets us reverse migrate.
        storage = orm.Storage()
        storage.pickle = pickle.dumps(default_storage)
        storage.hash = hashlib.md5(storage.pickle).hexdigest()
        storage.save()

        # Adding field 'Source.storage'
        db.add_column('easy_thumbnails_source', 'storage', self.gf('django.db.models.fields.related.ForeignKey')(default=storage.pk, to=orm['easy_thumbnails.Storage']), keep_default=False)

        # Adding field 'Thumbnail.storage'
        db.add_column('easy_thumbnails_thumbnail', 'storage', self.gf('django.db.models.fields.related.ForeignKey')(default=storage.pk, to=orm['easy_thumbnails.Storage']), keep_default=False)


    models = {
        'easy_thumbnails.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 10, 6, 7, 59, 6, 528762)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage_hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'})
        },
        'easy_thumbnails.thumbnail': {
            'Meta': {'object_name': 'Thumbnail'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2010, 10, 6, 7, 59, 6, 528762)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage_hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'})
        }
    }

    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0014_auto__add_unique_source_name_storage_hash__add_unique_thumbnail_name_s
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding unique constraint on 'Source', fields ['name', 'storage_hash']
        db.create_unique('easy_thumbnails_source', ['name', 'storage_hash'])

        # Adding unique constraint on 'Thumbnail', fields ['name', 'storage_hash']
        db.create_unique('easy_thumbnails_thumbnail', ['name', 'storage_hash'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Thumbnail', fields ['name', 'storage_hash']
        db.delete_unique('easy_thumbnails_thumbnail', ['name', 'storage_hash'])

        # Removing unique constraint on 'Source', fields ['name', 'storage_hash']
        db.delete_unique('easy_thumbnails_source', ['name', 'storage_hash'])


    models = {
        'easy_thumbnails.source': {
            'Meta': {'unique_together': "(('storage_hash', 'name'),)", 'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2011, 7, 30, 22, 15, 11, 681413)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage_hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'})
        },
        'easy_thumbnails.thumbnail': {
            'Meta': {'unique_together': "(('storage_hash', 'name'),)", 'object_name': 'Thumbnail'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2011, 7, 30, 22, 15, 11, 681413)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage_hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'})
        }
    }

    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0015_auto__del_unique_thumbnail_name_storage_hash__add_unique_thumbnail_sou
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Removing unique constraint on 'Thumbnail', fields ['name', 'storage_hash']
        db.delete_unique('easy_thumbnails_thumbnail', ['name', 'storage_hash'])

        # Adding unique constraint on 'Thumbnail', fields ['source', 'name', 'storage_hash']
        db.create_unique('easy_thumbnails_thumbnail', ['source_id', 'name', 'storage_hash'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Thumbnail', fields ['source', 'name', 'storage_hash']
        db.delete_unique('easy_thumbnails_thumbnail', ['source_id', 'name', 'storage_hash'])

        # Adding unique constraint on 'Thumbnail', fields ['name', 'storage_hash']
        db.create_unique('easy_thumbnails_thumbnail', ['name', 'storage_hash'])


    models = {
        'easy_thumbnails.source': {
            'Meta': {'unique_together': "(('storage_hash', 'name'),)", 'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2011, 9, 16, 9, 47, 8, 272761)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage_hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'})
        },
        'easy_thumbnails.thumbnail': {
            'Meta': {'unique_together': "(('storage_hash', 'name', 'source'),)", 'object_name': 'Thumbnail'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2011, 9, 16, 9, 47, 8, 272761)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': "orm['easy_thumbnails.Source']"}),
            'storage_hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'})
        }
    }

    complete_apps = ['easy_thumbnails']

########NEW FILE########
__FILENAME__ = 0016_auto__add_thumbnaildimensions
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'ThumbnailDimensions'
        db.create_table(u'easy_thumbnails_thumbnaildimensions', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('thumbnail', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['easy_thumbnails.Thumbnail'], unique=True)),
            ('width', self.gf('django.db.models.fields.PositiveIntegerField')(null=True)),
            ('height', self.gf('django.db.models.fields.PositiveIntegerField')(null=True)),
        ))
        db.send_create_signal(u'easy_thumbnails', ['ThumbnailDimensions'])


    def backwards(self, orm):
        # Deleting model 'ThumbnailDimensions'
        db.delete_table(u'easy_thumbnails_thumbnaildimensions')


    models = {
        u'easy_thumbnails.source': {
            'Meta': {'unique_together': "(('storage_hash', 'name'),)", 'object_name': 'Source'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'storage_hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'})
        },
        u'easy_thumbnails.thumbnail': {
            'Meta': {'unique_together': "(('storage_hash', 'name', 'source'),)", 'object_name': 'Thumbnail'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'thumbnails'", 'to': u"orm['easy_thumbnails.Source']"}),
            'storage_hash': ('django.db.models.fields.CharField', [], {'max_length': '40', 'db_index': 'True'})
        },
        u'easy_thumbnails.thumbnaildimensions': {
            'Meta': {'object_name': 'ThumbnailDimensions'},
            'height': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'thumbnail': ('django.db.models.fields.related.OneToOneField', [], {'to': u"orm['easy_thumbnails.Thumbnail']", 'unique': 'True'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'})
        }
    }

    complete_apps = ['easy_thumbnails']
########NEW FILE########
__FILENAME__ = storage
from django.core.files.storage import FileSystemStorage, get_storage_class
from django.utils.functional import LazyObject

from easy_thumbnails.conf import settings


class ThumbnailFileSystemStorage(FileSystemStorage):
    """
    Standard file system storage.

    The default ``location`` and ``base_url`` are set to
    ``THUMBNAIL_MEDIA_ROOT`` and ``THUMBNAIL_MEDIA_URL``, falling back to the
    standard ``MEDIA_ROOT`` and ``MEDIA_URL`` if the custom settings are blank.
    """
    def __init__(self, location=None, base_url=None, *args, **kwargs):
        if location is None:
            location = settings.THUMBNAIL_MEDIA_ROOT or None
        if base_url is None:
            base_url = settings.THUMBNAIL_MEDIA_URL or None
        super(ThumbnailFileSystemStorage, self).__init__(
            location, base_url, *args, **kwargs)


class ThumbnailDefaultStorage(LazyObject):
    def _setup(self):
        self._wrapped = get_storage_class(
            settings.THUMBNAIL_DEFAULT_STORAGE)()


thumbnail_default_storage = ThumbnailDefaultStorage()

########NEW FILE########
__FILENAME__ = thumbnail
import re
from django.utils import six

from django.template import (
    Library, Node, VariableDoesNotExist, TemplateSyntaxError)
from django.utils.html import escape

from easy_thumbnails import utils
from easy_thumbnails.alias import aliases
from easy_thumbnails.conf import settings
from easy_thumbnails.files import get_thumbnailer

register = Library()

RE_SIZE = re.compile(r'(\d+)x(\d+)$')

VALID_OPTIONS = utils.valid_processor_options()
VALID_OPTIONS.remove('size')


def split_args(args):
    """
    Split a list of argument strings into a dictionary where each key is an
    argument name.

    An argument looks like ``crop``, ``crop="some option"`` or ``crop=my_var``.
    Arguments which provide no value get a value of ``True``.
    """
    args_dict = {}
    for arg in args:
        split_arg = arg.split('=', 1)
        if len(split_arg) > 1:
            value = split_arg[1]
        else:
            value = True
        args_dict[split_arg[0]] = value
    return args_dict


class ThumbnailNode(Node):
    def __init__(self, source_var, opts, context_name=None):
        self.source_var = source_var
        self.opts = opts
        self.context_name = context_name

    def render(self, context):
        # Note that this isn't a global constant because we need to change the
        # value for tests.
        raise_errors = settings.THUMBNAIL_DEBUG
        # Get the source file.
        try:
            source = self.source_var.resolve(context)
        except VariableDoesNotExist:
            if raise_errors:
                raise VariableDoesNotExist(
                    "Variable '%s' does not exist." % self.source_var)
            return self.bail_out(context)
        if not source:
            if raise_errors:
                raise TemplateSyntaxError(
                    "Variable '%s' is an invalid source." % self.source_var)
            return self.bail_out(context)
        # Resolve the thumbnail option values.
        try:
            opts = {}
            for key, value in six.iteritems(self.opts):
                if hasattr(value, 'resolve'):
                    value = value.resolve(context)
                opts[str(key)] = value
        except Exception:
            if raise_errors:
                raise
            return self.bail_out(context)
        # Size variable can be either a tuple/list of two integers or a
        # valid string.
        size = opts['size']
        if isinstance(size, six.string_types):
            m = RE_SIZE.match(size)
            if m:
                opts['size'] = (int(m.group(1)), int(m.group(2)))
            else:
                # Size variable may alternatively be referencing an alias.
                alias = aliases.get(size, target=source)
                if alias:
                    del opts['size']
                    opts = dict(alias, **opts)
                else:
                    if raise_errors:
                        raise TemplateSyntaxError(
                            "%r is not a valid size." % size)
                    return self.bail_out(context)
        # Ensure the quality is an integer.
        if 'quality' in opts:
            try:
                opts['quality'] = int(opts['quality'])
            except (TypeError, ValueError):
                if raise_errors:
                    raise TemplateSyntaxError(
                        "%r is an invalid quality." % opts['quality'])
                return self.bail_out(context)
        # Ensure the subsampling level is an integer.
        if 'subsampling' in opts:
            try:
                opts['subsampling'] = int(opts['subsampling'])
            except (TypeError, ValueError):
                if raise_errors:
                    raise TemplateSyntaxError(
                        "%r is an invalid subsampling level." %
                        opts['subsampling'])
                return self.bail_out(context)

        try:
            thumbnail = get_thumbnailer(source).get_thumbnail(opts)
        except Exception:
            if raise_errors:
                raise
            return self.bail_out(context)
        # Return the thumbnail file url, or put the file on the context.
        if self.context_name is None:
            return escape(thumbnail.url)
        else:
            context[self.context_name] = thumbnail
            return ''

    def bail_out(self, context):
        if self.context_name:
            context[self.context_name] = ''
        return ''


def thumbnail(parser, token):
    """
    Creates a thumbnail of an ImageField.

    Basic tag Syntax::

        {% thumbnail [source] [size] [options] %}

    *source* must be a ``File`` object, usually an Image/FileField of a model
    instance.

    *size* can either be:

    * the name of an alias

    * the size in the format ``[width]x[height]`` (for example,
      ``{% thumbnail person.photo 100x50 %}``) or

    * a variable containing a valid size (i.e. either a string in the
      ``[width]x[height]`` format or a tuple containing two integers):
      ``{% thumbnail person.photo size_var %}``.

    *options* are a space separated list of options which are used when
    processing the image to a thumbnail such as ``sharpen``, ``crop`` and
    ``quality=90``.

    If *size* is specified as an alias name, *options* are used to override
    and/or supplement the options defined in that alias.

    The thumbnail tag can also place a
    :class:`~easy_thumbnails.files.ThumbnailFile` object in the context,
    providing access to the properties of the thumbnail such as the height and
    width::

        {% thumbnail [source] [size] [options] as [variable] %}

    When ``as [variable]`` is used, the tag doesn't output anything. Instead,
    use the variable like a standard ``ImageFieldFile`` object::

        {% thumbnail obj.picture 200x200 upscale as thumb %}
        <img href="{{ thumb.url }}"
             width="{{ thumb.width }}"
             height="{{ thumb.height }}" />

    **Debugging**

    By default, if there is an error creating the thumbnail or resolving the
    image variable then the thumbnail tag will just return an empty string (and
    if there was a context variable to be set then it will also be set to an
    empty string).

    For example, you will not see an error if the thumbnail could not
    be written to directory because of permissions error. To display those
    errors rather than failing silently, set ``THUMBNAIL_DEBUG = True`` in
    your Django project's settings module.

    """
    args = token.split_contents()
    tag = args[0]

    # Check to see if we're setting to a context variable.
    if len(args) > 4 and args[-2] == 'as':
        context_name = args[-1]
        args = args[:-2]
    else:
        context_name = None

    if len(args) < 3:
        raise TemplateSyntaxError(
            "Invalid syntax. Expected "
            "'{%% %s source size [option1 option2 ...] %%}' or "
            "'{%% %s source size [option1 option2 ...] as variable %%}'" %
            (tag, tag))

    opts = {}

    # The first argument is the source file.
    source_var = parser.compile_filter(args[1])

    # The second argument is the requested size. If it's the static "10x10"
    # format, wrap it in quotes so that it is compiled correctly.
    size = args[2]
    match = RE_SIZE.match(size)
    if match:
        size = '"%s"' % size
    opts['size'] = parser.compile_filter(size)

    # All further arguments are options.
    args_list = split_args(args[3:]).items()
    for arg, value in args_list:
        if arg in VALID_OPTIONS:
            if value and value is not True:
                value = parser.compile_filter(value)
            opts[arg] = value
        else:
            raise TemplateSyntaxError("'%s' tag received a bad argument: "
                                      "'%s'" % (tag, arg))
    return ThumbnailNode(source_var, opts=opts, context_name=context_name)


def thumbnailer(obj, relative_name=None):
    """
    Creates a thumbnailer from an object (usually a ``FileField``).

    Example usage::

        {% with photo=person.photo|thumbnailer %}
        {% if photo %}
            <a href="{{ photo.large.url }}">
                {{ photo.square.tag }}
            </a>
        {% else %}
            <img src="{% static 'template/fallback.png' %}" alt="" />
        {% endif %}
        {% endwith %}

    If you know what you're doing, you can also pass the relative name::

        {% with photo=storage|thumbnailer:'some/file.jpg' %}...
    """
    return get_thumbnailer(obj, relative_name=relative_name)


def thumbnailer_passive(obj):
    """
    Creates a thumbnailer from an object (usually a ``FileFile``) that won't
    generate new thumbnails.

    This is useful if you are using another process to generate the thumbnails
    rather than having them generated on the fly if they are missing.

    Example usage::

        {% with avatar=person.avatar|thumbnailer_passive %}
            {% with avatar_thumb=avatar.small %}
                {% if avatar_thumb %}
                    <img src="{{ avatar_thumb.url }}" alt="" />
                {% else %}
                    <img src="{% static 'img/default-avatar-small.png' %}"
                        alt="" />
                {% endif %}
            {% endwith %}
        {% endwith %}
    """
    thumbnailer = get_thumbnailer(obj)
    thumbnailer.generate = False
    return thumbnailer


def thumbnail_url(source, alias):
    """
    Return the thumbnail url for a source file using an aliased set of
    thumbnail options.

    If no matching alias is found, returns an empty string.

    Example usage::

        <img src="{{ person.photo|thumbnail_url:'small' }}" alt="">
    """
    try:
        thumb = get_thumbnailer(source)[alias]
    except Exception:
        return ''
    return thumb.url


register.tag(thumbnail)
register.filter(thumbnailer)
register.filter(thumbnailer_passive)
register.filter(thumbnail_url)

########NEW FILE########
__FILENAME__ = mockoptim
#!/usr/bin/env python
"""
This file does nothing except to open the file as specified on the command
line, reading it into a buffer and writing the same content back to the file.

This script is used to simulate the optimization of an image file without
actually doing it.
"""
import sys

if len(sys.argv) < 2:
    raise Exception('Missing filename')
with open(sys.argv[1], 'rb') as reader:
    buf = reader.read()
with open(sys.argv[1], 'wb') as writer:
    writer.write(buf)

########NEW FILE########
__FILENAME__ = mockoptim_fail
#!/usr/bin/env python
"""
This file does nothing except to mock a optimizer which does not work.
"""
import sys

print('Bad JPEG file')
sys.exit(1)

########NEW FILE########
__FILENAME__ = settings
import os

SITE_ID = 1

MEDIA_ROOT = os.path.normcase(os.path.dirname(os.path.abspath(__file__)))
MEDIA_URL = '/media/'

DATABASE_ENGINE = 'sqlite3'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': ':memory:',
    }
}

INSTALLED_APPS = [
    'django.contrib.contenttypes',
    'django.contrib.sites',
    'django.contrib.auth',
    'django.contrib.admin',
    'easy_thumbnails',
    'easy_thumbnails.optimize',
    # 'easy_thumbnails.tests',
]

# This is only needed for the 1.4.X test environment
USE_TZ = True

SECRET_KEY = 'easy'

########NEW FILE########
__FILENAME__ = settings_old
"""
Allow older versions of Django to use the same test discovery runner method.
"""
from .settings import *   # NOQA

TEST_RUNNER = 'discover_runner.DiscoverRunner'

########NEW FILE########
__FILENAME__ = test_aliases
from django.db import models

from easy_thumbnails import files, fields, signals, signal_handlers
from easy_thumbnails.alias import aliases
from easy_thumbnails.conf import settings
from easy_thumbnails.tests import utils as test


class Profile(models.Model):
    avatar = fields.ThumbnailerField(upload_to='avatars')
    logo = models.FileField(upload_to='avatars')

    class Meta:
        app_label = 'some_app'


class BaseTest(test.BaseTest):
    create_file = False

    def setUp(self):
        super(BaseTest, self).setUp()
        settings.THUMBNAIL_ALIASES = {
            '': {
                'large': {'size': (500, 500)},
                'medium': {'size': (300, 300)},
                'small': {'size': (100, 100)},
            },
            'some_app.Profile': {
                'large': {'size': (200, 200)},
                'banner': {'size': (600, 80), 'crop': True},
            },
            'some_app.Profile.avatar': {
                'avatar': {'size': (80, 80), 'crop': True},
                'small': {'size': (20, 20), 'crop': True},
            },
            'other_app': {
                'sidebar': {'size': (150, 250)},
            }
        }
        self.__aliases = aliases._aliases
        aliases._aliases = {}
        aliases.populate_from_settings()

        if self.create_file:
            self.storage = test.TemporaryStorage()
            # Save a test image.
            self.create_image(self.storage, 'avatars/test.jpg')
            # Set the test model to use the current temporary storage.
            Profile._meta.get_field('avatar').storage = self.storage
            Profile._meta.get_field('avatar').thumbnail_storage = self.storage

    def tearDown(self):
        aliases._aliases = self.__aliases
        if self.create_file:
            self.storage.delete_temporary_storage()
        super(BaseTest, self).tearDown()


class AliasTest(BaseTest):

    def test_global(self):
        self.assertEqual(aliases.get('invalid'), None)
        self.assertEqual(aliases.get('small'), {'size': (100, 100)})
        self.assertEqual(aliases.get('avatar'), None)
        self.assertEqual(aliases.get('banner'), None)

    def test_target(self):
        self.assertEqual(
            aliases.get('avatar', target='some_app.Profile.avatar'),
            {'size': (80, 80), 'crop': True})
        self.assertEqual(
            aliases.get('small', target='some_app.Profile.avatar'),
            {'size': (20, 20), 'crop': True})

    def test_partial_target(self):
        self.assertEqual(
            aliases.get('banner', target='some_app.Profile.avatar'),
            {'size': (600, 80), 'crop': True})
        self.assertEqual(
            aliases.get('banner', target='some_app.Profile'),
            {'size': (600, 80), 'crop': True})
        self.assertEqual(aliases.get('banner', target='some_app'), None)

    def test_target_fallback(self):
        # Unknown target.
        self.assertEqual(
            aliases.get('small', target='some_app.Profile.not_avatar'),
            {'size': (100, 100)})
        # Known target with no matching alias (but a matching global alias).
        self.assertEqual(
            aliases.get('medium', target='some_app.Profile.avatar'),
            {'size': (300, 300)})
        # Known target with no matching alias.
        self.assertEqual(
            aliases.get('invalid', target='some_app.Profile.avatar'),
            None)

    def test_all(self):
        self.assertEqual(
            aliases.all(),
            {
                'large': {'size': (500, 500)},
                'medium': {'size': (300, 300)},
                'small': {'size': (100, 100)},
            })

        self.assertEqual(
            aliases.all('unknown_app'),
            {
                'large': {'size': (500, 500)},
                'medium': {'size': (300, 300)},
                'small': {'size': (100, 100)},
            })

        self.assertEqual(
            aliases.all('some_app.Profile'),
            {
                'banner': {'size': (600, 80), 'crop': True},
                'large': {'size': (200, 200)},
                'medium': {'size': (300, 300)},
                'small': {'size': (100, 100)},
            })

        self.assertEqual(
            aliases.all('some_app.Profile.avatar'),
            {
                'avatar': {'size': (80, 80), 'crop': True},
                'banner': {'size': (600, 80), 'crop': True},
                'large': {'size': (200, 200)},
                'medium': {'size': (300, 300)},
                'small': {'crop': True, 'size': (20, 20)},
            })

    def test_all_no_global(self):

        self.assertEqual(
            aliases.all('some_app.Profile', include_global=False),
            {
                'banner': {'size': (600, 80), 'crop': True},
                'large': {'size': (200, 200)},
            })

        self.assertEqual(
            aliases.all('some_app.Profile.avatar', include_global=False),
            {
                'avatar': {'size': (80, 80), 'crop': True},
                'banner': {'size': (600, 80), 'crop': True},
                'large': {'size': (200, 200)},
                'small': {'crop': True, 'size': (20, 20)},
            })


class AliasThumbnailerTest(BaseTest):
    create_file = True

    def test_thumbnailer(self):
        thumbnailer = files.get_thumbnailer(self.storage, 'avatars/test.jpg')
        thumbnailer.thumbnail_storage = self.storage
        thumb = thumbnailer['small']
        self.assertEqual((thumb.width, thumb.height), (100, 75))

    def test_thumbnailer_fieldfile(self):
        profile = Profile(avatar='avatars/test.jpg')
        thumbnailer = files.get_thumbnailer(profile.avatar)
        thumb = thumbnailer['small']
        self.assertEqual((thumb.width, thumb.height), (20, 20))


class GenerationBase(BaseTest):
    create_file = True

    def get_signal_handler(self):
        return NotImplementedError("Subclasses should return the handler")

    def setUp(self):
        super(GenerationBase, self).setUp()
        signals.saved_file.connect(self.get_signal_handler(), sender=Profile)
        # Fix the standard storage to use the test's temporary location.
        settings.MEDIA_ROOT = self.storage.temporary_location

    def tearDown(self):
        signals.saved_file.disconnect(
            self.get_signal_handler(), sender=Profile)
        super(GenerationBase, self).tearDown()

    def fake_save(self, instance):
        cls = instance.__class__
        models.signals.pre_save.send(sender=cls, instance=instance)
        for field in cls._meta.fields:
            if isinstance(field, models.FileField):
                getattr(instance, field.name)._committed = True
        models.signals.post_save.send(sender=cls, instance=instance)
        return self.storage.listdir('avatars')[1]


class GenerationTest(GenerationBase):
    """
    Test the ``generate_aliases`` signal handler behaviour.
    """

    def get_signal_handler(self):
        return signal_handlers.generate_aliases

    def test_empty(self):
        """
        Thumbnails are not generated if there isn't anything to generate...
        """
        profile = Profile(avatar=None)
        files = self.fake_save(profile)
        self.assertEqual(len(files), 1)

    def test_no_change(self):
        """
        Thumbnails are only generated when the file is modified.
        """
        profile = Profile(avatar='avatars/test.jpg')
        files = self.fake_save(profile)
        self.assertEqual(len(files), 1)

    def test_changed(self):
        """
        When a file is modified, thumbnails are built for all matching
        non-global aliases.
        """
        profile = Profile(avatar='avatars/test.jpg')
        profile.avatar._committed = False
        files = self.fake_save(profile)
        # 1 source, 4 thumbs.
        self.assertEqual(len(files), 5)

    def test_deleted(self):
        profile = Profile(avatar='avatars/test.jpg')
        profile.avatar.delete(save=False)
        files = self.fake_save(profile)
        self.assertEqual(len(files), 0)

    def test_standard_filefield(self):
        profile = Profile(avatar='avatars/test.jpg')
        # Attach a File object to the FileField descriptor, emulating an
        # upload.
        profile.logo = self.storage.open(
            self.create_image(self.storage, 'avatars/second.jpg'))
        list_files = self.fake_save(profile)
        # 2 source, 2 thumbs.
        self.assertEqual(len(list_files), 4)


class GlobalGenerationTest(GenerationBase):
    """
    Test the ``generate_aliases_global`` signal handler behaviour.
    """

    def get_signal_handler(self):
        return signal_handlers.generate_aliases_global

    def test_no_change(self):
        """
        Thumbnails are only generated when the file is modified.
        """
        profile = Profile(avatar='avatars/test.jpg')
        files = self.fake_save(profile)
        self.assertEqual(len(files), 1)

    def test_changed(self):
        """
        When a file is modified, thumbnails are built for all matching and
        project-wide aliases.
        """
        profile = Profile(avatar='avatars/test.jpg')
        profile.avatar._committed = False
        files = self.fake_save(profile)
        # 1 source, 4 specific thumbs, 1 project-wide thumb.
        self.assertEqual(len(files), 6)

########NEW FILE########
__FILENAME__ = test_fields
import os

from django.core.files.base import ContentFile
from django.db import models

from easy_thumbnails.fields import ThumbnailerField, ThumbnailerImageField
from easy_thumbnails.tests import utils as test
from easy_thumbnails.tests.test_aliases import BaseTest as AliasBaseTest
from easy_thumbnails.exceptions import (
    InvalidImageFormatError, EasyThumbnailsError)


class TestModel(models.Model):
    avatar = ThumbnailerField(upload_to='avatars')
    picture = ThumbnailerImageField(upload_to='pictures',
                                    resize_source=dict(size=(10, 10)))


class ThumbnailerFieldTest(AliasBaseTest):
    def setUp(self):
        super(ThumbnailerFieldTest, self).setUp()
        self.storage = test.TemporaryStorage()
        # Save a test image.
        self.create_image(self.storage, 'avatars/avatar.jpg')
        # Set the test model to use the current temporary storage.
        for name in ('avatar', 'picture'):
            field = TestModel._meta.get_field(name)
            field.storage = self.storage
            field.thumbnail_storage = self.storage

    def tearDown(self):
        self.storage.delete_temporary_storage()
        super(ThumbnailerFieldTest, self).tearDown()

    def test_generate_thumbnail(self):
        instance = TestModel(avatar='avatars/avatar.jpg')
        thumb = instance.avatar.generate_thumbnail({'size': (300, 300)})
        self.assertEqual((thumb.width, thumb.height), (300, 225))

    def test_generate_thumbnail_bad_image(self):
        text_file = ContentFile("Lorem ipsum dolor sit amet. Not an image.")
        self.storage.save('avatars/invalid.jpg', text_file)
        instance = TestModel(avatar='avatars/invalid.jpg')
        generate = lambda: instance.avatar.generate_thumbnail(
            {'size': (300, 300)})
        self.assertRaises(IOError, generate)

    def test_generate_thumbnail_alias_bad_image(self):
        text_file = ContentFile("Lorem ipsum dolor sit amet. Not an image.")
        self.storage.save('avatars/invalid.jpg', text_file)
        instance = TestModel(avatar='avatars/invalid.jpg')
        generate = lambda: instance.avatar['small']
        self.assertRaises(InvalidImageFormatError, generate)

    def test_generate_thumbnail_alias_0x0_size(self):
        instance = TestModel(avatar='avatars/avatar.jpg')
        self.assertRaises(
            EasyThumbnailsError,
            instance.avatar.generate_thumbnail, {'size': (0, 0)})

    def test_delete(self):
        instance = TestModel(avatar='avatars/avatar.jpg')
        source_path = instance.avatar.path
        thumb_paths = (
            instance.avatar.get_thumbnail({'size': (300, 300)}).path,
            instance.avatar.get_thumbnail({'size': (200, 200)}).path,
            instance.avatar.get_thumbnail({'size': (100, 100)}).path,
        )
        self.assertTrue(os.path.exists(source_path))
        for path in thumb_paths:
            self.assertTrue(os.path.exists(path))
        instance.avatar.delete(save=False)
        self.assertFalse(os.path.exists(source_path))
        for path in thumb_paths:
            self.assertFalse(os.path.exists(path))

    def test_delete_thumbnails(self):
        instance = TestModel(avatar='avatars/avatar.jpg')
        source_path = instance.avatar.path
        thumb_paths = (
            instance.avatar.get_thumbnail({'size': (300, 300)}).path,
            instance.avatar.get_thumbnail({'size': (200, 200)}).path,
            instance.avatar.get_thumbnail({'size': (100, 100)}).path,
        )
        self.assertTrue(os.path.exists(source_path))
        for path in thumb_paths:
            self.assertTrue(os.path.exists(path))
        instance.avatar.delete_thumbnails()
        self.assertTrue(os.path.exists(source_path))
        for path in thumb_paths:
            self.assertFalse(os.path.exists(path))

    def test_get_thumbnails(self):
        instance = TestModel(avatar='avatars/avatar.jpg')
        instance.avatar.get_thumbnail({'size': (300, 300)})
        instance.avatar.get_thumbnail({'size': (200, 200)})
        self.assertEqual(len(list(instance.avatar.get_thumbnails())), 2)

    def test_saving_image_field_with_resize_source(self):
        # Ensure that saving ThumbnailerImageField with resize_source enabled
        # using instance.field.save() does not fail
        instance = TestModel(avatar='avatars/avatar.jpg')
        instance.picture.save(
            'file.jpg', ContentFile(instance.avatar.file.read()), save=False)
        self.assertEqual(instance.picture.width, 10)

    def test_saving_image_field_with_resize_source_different_ext(self):
        instance = TestModel(avatar='avatars/avatar.jpg')
        instance.picture.save(
            'file.gif', ContentFile(instance.avatar.file.read()), save=False)
        self.assertEqual(instance.picture.name, 'pictures/file.jpg')

########NEW FILE########
__FILENAME__ = test_files
try:
    from cStringIO import cStringIO as BytesIO
except ImportError:
    from django.utils.six import BytesIO
from os import path

from django.test import TestCase
from django.utils import six, unittest
from easy_thumbnails import files, utils, signals, exceptions, models, engine
from easy_thumbnails.conf import settings
from easy_thumbnails.options import ThumbnailOptions
from easy_thumbnails.tests import utils as test
try:
    from PIL import Image
except ImportError:
    import Image
try:
    from testfixtures import LogCapture
except ImportError:
    LogCapture = None


class FilesTest(test.BaseTest):

    def setUp(self):
        super(FilesTest, self).setUp()
        self.storage = test.TemporaryStorage()
        self.remote_storage = test.FakeRemoteStorage()

        # Save a test image in both storages.
        filename = self.create_image(self.storage, 'test.jpg')
        self.thumbnailer = files.get_thumbnailer(self.storage, filename)
        self.thumbnailer.thumbnail_storage = self.storage

        filename = self.create_image(self.remote_storage, 'test.jpg')
        self.remote_thumbnailer = files.get_thumbnailer(
            self.remote_storage, filename)
        self.remote_thumbnailer.thumbnail_storage = self.remote_storage

        # Create another thumbnailer for extension test.
        self.ext_thumbnailer = files.get_thumbnailer(self.storage, filename)
        self.ext_thumbnailer.thumbnail_storage = self.storage

        # Generate test transparent images.
        filename = self.create_image(
            self.storage, 'transparent.png', image_mode='RGBA',
            image_format='PNG')
        self.transparent_thumbnailer = files.get_thumbnailer(
            self.storage, filename)
        self.transparent_thumbnailer.thumbnail_storage = self.storage

        filename = self.create_image(
            self.storage, 'transparent-greyscale.png', image_mode='LA',
            image_format='PNG')
        self.transparent_greyscale_thumbnailer = files.get_thumbnailer(
            self.storage, filename)
        self.transparent_greyscale_thumbnailer.thumbnail_storage = self.storage

    def tearDown(self):
        self.storage.delete_temporary_storage()
        self.remote_storage.delete_temporary_storage()
        super(FilesTest, self).tearDown()

    def assertRegex(self, *args, **kwargs):
        func = getattr(super(FilesTest, self), 'assertRegex', None)
        if func is None:
            func = self.assertRegexpMatches
        return func(*args, **kwargs)

    def test_tag(self):
        local = self.thumbnailer.get_thumbnail({'size': (100, 100)})
        remote = self.remote_thumbnailer.get_thumbnail({'size': (100, 100)})

        self.assertEqual(
            local.tag(), '<img alt="" height="75" src="%s" width="100" '
            '/>' % local.url)
        self.assertEqual(
            local.tag(alt='A & B'), '<img alt="A &amp; B" height="75" '
            'src="%s" width="100" />' % local.url)

        # Can turn off dimensions.
        self.assertEqual(
            remote.tag(use_size=False), '<img alt="" src="%s" />' % remote.url)

        # Even a remotely generated thumbnail has the dimensions cached if it
        # was just created.
        self.assertEqual(
            remote.tag(),
            '<img alt="" height="75" src="%s" width="100" />' % remote.url)

        # Future requests to thumbnails on remote storage don't get
        # dimensions...
        remote = self.remote_thumbnailer.get_thumbnail({'size': (100, 100)})
        self.assertEqual(
            remote.tag(), '<img alt="" src="%s" />' % remote.url)
        # ...unless explicitly requested.
        self.assertEqual(
            remote.tag(use_size=True),
            '<img alt="" height="75" src="%s" width="100" />' % remote.url)

        # All other arguments are passed through as attributes.
        self.assertEqual(
            local.tag(**{'rel': 'A&B', 'class': 'fish'}),
            '<img alt="" class="fish" height="75" rel="A&amp;B" '
            'src="%s" width="100" />' % local.url)

    def test_tag_cached_dimensions(self):
        settings.THUMBNAIL_CACHE_DIMENSIONS = True
        self.remote_thumbnailer.get_thumbnail({'size': (100, 100)})

        # Look up thumbnail again to ensure dimensions are a *really* cached.
        remote = self.remote_thumbnailer.get_thumbnail({'size': (100, 100)})
        self.assertEqual(
            remote.tag(),
            '<img alt="" height="75" src="%s" width="100" />' % remote.url)

    def test_transparent_thumbnailing(self):
        thumb_file = self.thumbnailer.get_thumbnail(
            {'size': (100, 100)})
        thumb_file.seek(0)
        thumb = Image.open(thumb_file)
        self.assertFalse(
            utils.is_transparent(thumb),
            "%s shouldn't be transparent." % thumb_file.name)

        thumb_file = self.transparent_thumbnailer.get_thumbnail(
            {'size': (100, 100)})
        thumb_file.seek(0)
        thumb = Image.open(thumb_file)
        self.assertTrue(
            utils.is_transparent(thumb),
            "%s should be transparent." % thumb_file.name)

        thumb_file = self.transparent_greyscale_thumbnailer.get_thumbnail(
            {'size': (100, 100)})
        thumb_file.seek(0)
        thumb = Image.open(thumb_file)
        self.assertTrue(
            utils.is_transparent(thumb),
            "%s should be transparent." % thumb_file.name)

    def test_missing_thumb(self):
        opts = {'size': (100, 100)}
        thumb = self.thumbnailer.get_thumbnail(opts)
        thumb_cache = self.thumbnailer.get_thumbnail_cache(
            thumbnail_name=thumb.name)
        thumb_cache.delete()
        thumb.storage.delete(thumb.name)
        self.thumbnailer.get_thumbnail(opts)

    def test_missing_thumb_from_storage(self):
        opts = {'size': (100, 100)}
        thumb = self.thumbnailer.get_thumbnail(opts)
        thumb.storage.delete(thumb.name)
        new_thumb = self.thumbnailer.get_thumbnail(opts)
        self.assertEqual(thumb.name, new_thumb.name)
        self.assertTrue(thumb.storage.exists(new_thumb.name))

    def test_missing_remote_thumb(self):
        opts = {'size': (100, 100)}
        thumb = self.remote_thumbnailer.get_thumbnail(opts)
        thumb_cache = self.remote_thumbnailer.get_thumbnail_cache(
            thumbnail_name=thumb.name)
        thumb_cache.delete()
        thumb.storage.delete(thumb.name)
        self.remote_thumbnailer.get_thumbnail(opts)

    def test_missing_source(self):
        opts = {'size': (100, 100)}
        self.storage.delete(self.thumbnailer.name)
        self.assertRaises(
            exceptions.InvalidImageFormatError,
            self.thumbnailer.get_thumbnail, opts)

    def test_extensions(self):
        self.ext_thumbnailer.thumbnail_extension = 'png'
        thumb = self.ext_thumbnailer.get_thumbnail({'size': (100, 100)})
        self.assertEqual(path.splitext(thumb.name)[1], '.png')

        self.ext_thumbnailer.thumbnail_preserve_extensions = ('foo',)
        thumb = self.ext_thumbnailer.get_thumbnail({'size': (100, 100)})
        self.assertEqual(path.splitext(thumb.name)[1], '.png')

        self.ext_thumbnailer.thumbnail_preserve_extensions = True
        thumb = self.ext_thumbnailer.get_thumbnail({'size': (100, 100)})
        self.assertEqual(path.splitext(thumb.name)[1], '.jpg')

        self.ext_thumbnailer.thumbnail_preserve_extensions = ('foo', 'jpg')
        thumb = self.ext_thumbnailer.get_thumbnail({'size': (100, 100)})
        self.assertEqual(path.splitext(thumb.name)[1], '.jpg')

    def test_high_resolution(self):
        self.ext_thumbnailer.thumbnail_high_resolution = True
        thumb = self.ext_thumbnailer.get_thumbnail({'size': (100, 100)})
        base, ext = path.splitext(thumb.path)
        hires_thumb_file = ''.join([base + '@2x', ext])
        self.assertTrue(path.isfile(hires_thumb_file))
        thumb = Image.open(hires_thumb_file)
        self.assertEqual(thumb.size, (200, 150))

    def test_subsampling(self):
        samplings = {
            0: (1, 1, 1, 1, 1, 1),
            1: (2, 1, 1, 1, 1, 1),
            2: (2, 2, 1, 1, 1, 1),
        }
        thumb = self.ext_thumbnailer.get_thumbnail({'size': (100, 100)})
        im = Image.open(thumb.path)
        self.assertNotIn('ss', thumb.name)
        sampling = im.layer[0][1:3] + im.layer[1][1:3] + im.layer[2][1:3]
        self.assertEqual(sampling, samplings[2])

        thumb = self.ext_thumbnailer.get_thumbnail(
            {'size': (100, 100), 'subsampling': 1})
        im = Image.open(thumb.path)
        self.assertIn('ss1', thumb.name)
        sampling = im.layer[0][1:3] + im.layer[1][1:3] + im.layer[2][1:3]
        self.assertEqual(sampling, samplings[1])

        thumb = self.ext_thumbnailer.get_thumbnail(
            {'size': (100, 100), 'subsampling': 0})
        im = Image.open(thumb.path)
        self.assertIn('ss0', thumb.name)
        sampling = im.layer[0][1:3] + im.layer[1][1:3] + im.layer[2][1:3]
        self.assertEqual(sampling, samplings[0])

    def test_default_subsampling(self):
        settings.THUMBNAIL_DEFAULT_OPTIONS = {'subsampling': 1}
        thumb = self.ext_thumbnailer.get_thumbnail({'size': (100, 100)})
        im = Image.open(thumb.path)
        self.assertIn('ss1', thumb.name)
        sampling = im.layer[0][1:3] + im.layer[1][1:3] + im.layer[2][1:3]
        self.assertEqual(sampling, (2, 1, 1, 1, 1, 1))

    def test_high_resolution_force_off(self):
        self.ext_thumbnailer.thumbnail_high_resolution = True
        thumb = self.ext_thumbnailer.get_thumbnail(
            {'size': (100, 100), 'HIGH_RESOLUTION': False})
        base, ext = path.splitext(thumb.path)
        hires_thumb_file = ''.join([base + '@2x', ext])
        self.assertFalse(path.exists(hires_thumb_file))

    def test_high_resolution_force(self):
        thumb = self.ext_thumbnailer.get_thumbnail(
            {'size': (100, 100), 'HIGH_RESOLUTION': True})
        base, ext = path.splitext(thumb.path)
        hires_thumb_file = ''.join([base + '@2x', ext])
        self.assertTrue(path.isfile(hires_thumb_file))
        thumb = Image.open(hires_thumb_file)
        self.assertEqual(thumb.size, (200, 150))

    def test_highres_infix(self):
        self.ext_thumbnailer.thumbnail_high_resolution = True
        self.ext_thumbnailer.thumbnail_highres_infix = '_2x'
        thumb = self.ext_thumbnailer.get_thumbnail({'size': (100, 100)})
        base, ext = path.splitext(thumb.path)
        hires_thumb_file = ''.join([base + '_2x', ext])
        self.assertTrue(path.isfile(hires_thumb_file))
        thumb = Image.open(hires_thumb_file)
        self.assertEqual(thumb.size, (200, 150))

    @unittest.skipIf(
        'easy_thumbnails.optimize' not in settings.INSTALLED_APPS,
        'optimize app not installed')
    @unittest.skipIf(LogCapture is None, 'testfixtures not installed')
    def test_postprocessor(self):
        """use a mock image optimizing post processor doing nothing"""
        settings.THUMBNAIL_OPTIMIZE_COMMAND = {
            'png': 'easy_thumbnails/tests/mockoptim.py {filename}'}
        with LogCapture() as logcap:
            self.ext_thumbnailer.thumbnail_extension = 'png'
            self.ext_thumbnailer.get_thumbnail({'size': (10, 10)})
            actual = tuple(logcap.actual())[0]
            self.assertEqual(actual[0], 'easy_thumbnails.optimize')
            self.assertEqual(actual[1], 'INFO')
            self.assertRegex(
                actual[2],
                '^easy_thumbnails/tests/mockoptim.py [^ ]+ returned nothing$')

    @unittest.skipIf(
        'easy_thumbnails.optimize' not in settings.INSTALLED_APPS,
        'optimize app not installed')
    @unittest.skipIf(LogCapture is None, 'testfixtures not installed')
    def test_postprocessor_fail(self):
        """use a mock image optimizing post processor doing nothing"""
        settings.THUMBNAIL_OPTIMIZE_COMMAND = {
            'png': 'easy_thumbnails/tests/mockoptim_fail.py {filename}'}
        with LogCapture() as logcap:
            self.ext_thumbnailer.thumbnail_extension = 'png'
            self.ext_thumbnailer.get_thumbnail({'size': (10, 10)})
            actual = tuple(logcap.actual())[0]
            self.assertEqual(actual[0], 'easy_thumbnails.optimize')
            self.assertEqual(actual[1], 'ERROR')
            self.assertRegex(
                actual[2], r'^Command\ .+returned non-zero exit status 1$')

    def test_USE_TZ(self):
        settings.USE_TZ = True
        self.thumbnailer.get_thumbnail({'size': (10, 20)})

        settings.USE_TZ = False
        self.thumbnailer.get_thumbnail({'size': (20, 40)})

    def test_thumbnailfile_options(self):
        opts = {'size': (50, 50), 'crop': True, 'upscale': True}
        thumb = self.thumbnailer.get_thumbnail(opts)
        self.assertEqual(thumb.thumbnail_options, ThumbnailOptions(opts))

    def test_get_thumbnail_name(self):
        opts = {
            'size': (50, 50), 'crop': 'smart', 'upscale': True,
            'target': (10, 10)}
        self.assertEqual(
            self.thumbnailer.get_thumbnail_name(opts),
            'test.jpg.50x50_q85_crop-smart_target-10,10_upscale.jpg')

    def test_default_options_setting(self):
        settings.THUMBNAIL_DEFAULT_OPTIONS = {'crop': True}
        opts = {'size': (50, 50)}
        thumb = self.thumbnailer.get_thumbnail(opts)
        self.assertEqual((thumb.width, thumb.height), (50, 50))

    def test_dimensions_of_cached_image(self):
        opts = {'size': (50, 50)}
        thumb = self.thumbnailer.get_thumbnail(opts)
        self.assertEqual((thumb.width, thumb.height), (50, 38))
        # Now the thumb has been created, check that retrieving this still
        # gives access to the dimensions.
        thumb = self.thumbnailer.get_thumbnail(opts)
        self.assertEqual((thumb.width, thumb.height), (50, 38))

    def test_cached_dimensions_of_cached_image(self):
        settings.THUMBNAIL_CACHE_DIMENSIONS = True
        opts = {'size': (50, 50)}
        thumb = self.thumbnailer.get_thumbnail(opts)
        self.assertEqual((thumb.width, thumb.height), (50, 38))
        # Now the thumb has been created, check that dimesions are in the
        # database.
        dimensions = models.ThumbnailDimensions.objects.all()[0]
        self.assertEqual(
            (thumb.width, thumb.height),
            (dimensions.width, dimensions.height))

    def test_remote_cached_dimensions_queries(self):
        settings.THUMBNAIL_CACHE_DIMENSIONS = True
        opts = {'size': (50, 50)}
        thumb = self.remote_thumbnailer.get_thumbnail(opts)
        thumb.height   # Trigger dimension caching.
        # Get thumb again (which now has cached dimensions).
        thumb = self.remote_thumbnailer.get_thumbnail(opts)
        with self.assertNumQueries(0):
            self.assertEqual(thumb.width, 50)

    def test_add_dimension_cache(self):
        settings.THUMBNAIL_CACHE_DIMENSIONS = True
        opts = {'size': (50, 50)}
        thumb = self.thumbnailer.get_thumbnail(opts)
        self.assertEqual((thumb.width, thumb.height), (50, 38))
        # Delete the created dimensions.
        models.ThumbnailDimensions.objects.all().delete()
        # Now access the thumbnail again.
        thumb = self.thumbnailer.get_thumbnail(opts)
        self.assertEqual(models.ThumbnailDimensions.objects.count(), 0)
        thumb.height
        dimensions = models.ThumbnailDimensions.objects.get()
        # and make sure they match when fetched again.
        thumb = self.thumbnailer.get_thumbnail(opts)
        self.assertEqual(
            (thumb.width, thumb.height),
            (dimensions.width, dimensions.height))

    def test_thumbnail_created_signal(self):

        def signal_handler(sender, **kwargs):
            sender.signal_received = True

        signals.thumbnail_created.connect(signal_handler)
        try:
            thumb = self.thumbnailer.get_thumbnail({'size': (10, 20)})
            self.assertTrue(hasattr(thumb, 'signal_received'))
        finally:
            signals.thumbnail_created.disconnect(signal_handler)

    def test_passive_thumbnailer(self):
        options = {'size': (10, 10)}

        # Explicitly using the generate=False option on get_thumbnail won't
        # generate a missing thumb.
        thumb = self.thumbnailer.get_thumbnail(options, generate=False)
        self.assertEqual(thumb, None)

        # If the thumbnailer has generate=False, get_thumbnail won't generate a
        # missing thumb by default.
        self.thumbnailer.generate = False
        thumb = self.thumbnailer.get_thumbnail(options)
        self.assertEqual(thumb, None)

        # If the thumbnailer has generate=False, get_thumbnail with
        # generate=True will stiff force generation a missing thumb.
        thumb = self.thumbnailer.get_thumbnail(options, generate=True)
        self.assertTrue(thumb)

        # If the thumbnailer has generate=False, get_thumbnail will still
        # return existing thumbnails.
        thumb = self.thumbnailer.get_thumbnail(options)
        self.assertTrue(thumb)

        # Explicitly using the generate=False option on get_thumbnail will
        # still return existing thumbnails.
        thumb = self.thumbnailer.get_thumbnail(options, generate=False)
        self.assertTrue(thumb)

    def test_thumbnail_missed_signal(self):

        def signal_handler(sender, **kwargs):
            sender.missed_signal = kwargs.get('options')

        signals.thumbnail_missed.connect(signal_handler)
        try:
            # Standard generation doesn't trigger signal.
            self.thumbnailer.get_thumbnail({'size': (100, 100)})
            self.assertFalse(hasattr(self.thumbnailer, 'missed_signal'))
            # Retrieval doesn't trigger signal.
            self.thumbnailer.get_thumbnail(
                {'size': (100, 100)}, generate=False)
            self.assertFalse(hasattr(self.thumbnailer, 'missed_signal'))
            # A thumbnail miss does trigger it.
            options = {'size': (10, 20)}
            thumb = self.thumbnailer.get_thumbnail(options, generate=False)
            self.assertEqual(thumb, None)
            self.assertEqual(
                self.thumbnailer.missed_signal, ThumbnailOptions(options))
        finally:
            signals.thumbnail_created.disconnect(signal_handler)


class FakeSourceGenerator(object):

    def __init__(self, fail=False):
        self.fail = fail

    def __call__(self, source, **kwargs):
        if self.fail:
            raise ValueError("Fake source generator failed")
        return source


class EngineTest(TestCase):

    def setUp(self):
        self.source = BytesIO(six.b('file-contents'))

    def test_single_fail(self):
        source_generators = [FakeSourceGenerator(fail=True)]
        self.assertRaises(
            ValueError, engine.generate_source_image,
            self.source, {}, source_generators, fail_silently=False)

    def test_single_silent_fail(self):
        source_generators = [FakeSourceGenerator(fail=True)]
        image = engine.generate_source_image(
            self.source, {}, source_generators)
        self.assertEqual(image, None)

    def test_multiple_fail(self):
        source_generators = [
            FakeSourceGenerator(fail=True), FakeSourceGenerator(fail=True)]
        self.assertRaises(
            engine.NoSourceGenerator, engine.generate_source_image,
            self.source, {}, source_generators, fail_silently=False)

    def test_multiple_silent_fail(self):
        source_generators = [
            FakeSourceGenerator(fail=True), FakeSourceGenerator(fail=True)]
        image = engine.generate_source_image(
            self.source, {}, source_generators)
        self.assertEqual(image, None)

########NEW FILE########
__FILENAME__ = test_management
from easy_thumbnails.tests import utils as test


class ThumbnailCleanupTests(test.BaseTest):

    def test_can_import(self):
        """
        Just a simple test to see if we can actually import the command without
        any syntax errors.
        """
        import easy_thumbnails.management.commands.thumbnail_cleanup   # NOQA

########NEW FILE########
__FILENAME__ = test_models
"""Tests for the models module.
"""

from easy_thumbnails import utils
from easy_thumbnails.models import Thumbnail, Source
from easy_thumbnails.tests import utils as test


class FileManagerTest(test.BaseTest):
    """Test for FileManager"""

    def setUp(self):
        super(FileManagerTest, self).setUp()

        self.storage = test.TemporaryStorage()
        self.storage_hash = utils.get_storage_hash(self.storage)
        self.source = Source.objects.create(
            name='Test source',
            storage_hash=self.storage_hash)

        # Generate a test image, save it.
        self.filename = self.create_image(self.storage, 'test.jpg')

    def tearDown(self):
        self.storage.delete_temporary_storage()
        super(FileManagerTest, self).tearDown()

    def test_create_file(self):
        """Create a new Thumbnail in the database"""
        img = Thumbnail.objects.get_file(
            self.storage,
            self.filename,
            create=True,
            source=self.source)

        self.assertEqual(img.name, self.filename)

    def test_get_file(self):
        """Fetch an existing thumb from database"""
        created = Thumbnail.objects.create(
            storage_hash=self.storage_hash,
            name=self.filename,
            source=self.source)

        fetched = Thumbnail.objects.get_file(
            self.storage,
            self.filename,
            create=False)

        self.assertTrue(fetched)
        self.assertEqual(created, fetched)

    def test_get_file_check_cache(self):
        """Fetch a thumb that is in the storage but not in the database"""

        # It's not in the database yet
        try:
            Thumbnail.objects.get(name=self.filename)
            self.fail('Thumb should not exist yet')
        except Thumbnail.DoesNotExist:
            pass

        Thumbnail.objects.get_file(
            self.storage,
            self.filename,
            source=self.source,
            check_cache_miss=True)

        # Now it is
        try:
            Thumbnail.objects.get(name=self.filename)
        except Thumbnail.DoesNotExist:
            self.fail('Thumb should exist now')

########NEW FILE########
__FILENAME__ = test_namers
from django.test import TestCase

from easy_thumbnails import namers


class FakeThumbnailer(object):

    def __init__(self, basedir='', subdir=''):
        self.thumbnail_basedir = basedir
        self.thumbnail_subdir = subdir


class Default(TestCase):

    def test_basic(self):
        filename = namers.default(
            thumbnailer=FakeThumbnailer(),
            prepared_options=['100x100', 'q80', 'crop', 'upscale'],
            source_filename='source.jpg',
            thumbnail_extension='jpg',
        )
        self.assertEqual(filename, 'source.jpg.100x100_q80_crop_upscale.jpg')

    def test_subdir_opts(self):
        filename = namers.default(
            thumbnailer=FakeThumbnailer(subdir='%(opts)s'),
            prepared_options=['100x100', 'q80', 'crop', 'upscale'],
            source_filename='source.gif',
            thumbnail_extension='png',
        )
        self.assertEqual(filename, 'source.gif.png')

    def test_basedir_opts(self):
        filename = namers.default(
            thumbnailer=FakeThumbnailer(basedir='%(opts)s'),
            prepared_options=['100x100', 'q80', 'crop', 'upscale'],
            source_filename='source.gif',
            thumbnail_extension='png',
        )
        self.assertEqual(filename, 'source.gif.png')


class Hashed(TestCase):

    def test_basic(self):
        filename = namers.hashed(
            thumbnailer=FakeThumbnailer(),
            prepared_options=['100x100', 'q80', 'crop', 'upscale'],
            source_filename='source.jpg',
            thumbnail_extension='jpg',
        )
        self.assertEqual(filename, '6qW1buHgLaZ9.jpg')


class SourceHashed(TestCase):

    def test_basic(self):
        filename = namers.source_hashed(
            thumbnailer=FakeThumbnailer(),
            prepared_options=['100x100', 'q80', 'crop', 'upscale'],
            source_filename='source.jpg',
            thumbnail_extension='jpg',
        )
        self.assertEqual(filename, '1xedFtqllFo9_100x100_QHCa6G1l.jpg')

########NEW FILE########
__FILENAME__ = test_processors
try:
    from PIL import Image, ImageChops, ImageDraw
except ImportError:
    import Image
    import ImageChops
    import ImageDraw
from easy_thumbnails import processors
from unittest import TestCase


def create_image(mode='RGB', size=(800, 600)):
    image = Image.new(mode, size, (255, 255, 255))
    draw = ImageDraw.Draw(image)
    x_bit, y_bit = size[0] // 10, size[1] // 10
    draw.rectangle((x_bit, y_bit * 2, x_bit * 7, y_bit * 3), 'red')
    draw.rectangle((x_bit * 2, y_bit, x_bit * 3, y_bit * 8), 'red')
    return image


class ScaleAndCropTest(TestCase):
    def assertImagesEqual(self, im1, im2, msg=None):
        if im1.size != im2.size or (
                ImageChops.difference(im1, im2).getbbox() is not None):
            raise self.failureException(
                msg or 'The two images were not identical')

    def test_scale(self):
        image = create_image()

        scaled = processors.scale_and_crop(image, (100, 100))
        self.assertEqual(scaled.size, (100, 75))

        not_scaled = processors.scale_and_crop(image, (1000, 1000))
        self.assertEqual(not_scaled.size, (800, 600))

        upscaled = processors.scale_and_crop(image, (1000, 1000), upscale=True)
        self.assertEqual(upscaled.size, (1000, 750))

    def test_crop(self):
        image = create_image()

        both_cropped = processors.scale_and_crop(image, (100, 100), crop=True)
        self.assertEqual(both_cropped.size, (100, 100))

        not_cropped = processors.scale_and_crop(image, (1000, 1000), crop=True)
        self.assertEqual(not_cropped.size, (800, 600))

        x_cropped = processors.scale_and_crop(image, (600, 600), crop=True)
        expected = image.crop([100, 0, 700, 600])
        self.assertImagesEqual(x_cropped, expected)

        y_cropped = processors.scale_and_crop(image, (1000, 100), crop=True)
        expected = image.crop([0, 250, 800, 350])
        self.assertImagesEqual(y_cropped, expected)

    def test_crop_corner(self):
        image = create_image()

        tl_crop = processors.scale_and_crop(image, (100, 600), crop='0,0')
        expected = image.crop([0, 0, 100, 600])
        self.assertImagesEqual(tl_crop, expected)

        br_crop = processors.scale_and_crop(image, (100, 600), crop='-0,-0')
        expected = image.crop([700, 0, 800, 600])
        self.assertImagesEqual(br_crop, expected)

        x_offset_crop = processors.scale_and_crop(
            image, (150, 600), crop='10,-10')
        expected = image.crop([15, 0, 165, 600])

        self.assertImagesEqual(x_offset_crop, expected)

        y_offset_crop = processors.scale_and_crop(image, (800, 150),
                                                  crop='10,-10')
        expected = image.crop([0, 435, 800, 585])
        self.assertImagesEqual(y_offset_crop, expected)

        only_x_crop = processors.scale_and_crop(image, (100, 600), crop='0,')
        expected = image.crop([0, 0, 100, 600])
        self.assertImagesEqual(only_x_crop, expected)

        only_y_crop = processors.scale_and_crop(image, (800, 100), crop=',0')
        expected = image.crop([0, 0, 800, 100])
        self.assertImagesEqual(only_y_crop, expected)

    def test_crop_smart(self):
        image = create_image()

        smart_crop = processors.scale_and_crop(image, (600, 600), crop='smart')
        expected = image.crop([78, 0, 678, 600])
        self.assertImagesEqual(smart_crop, expected)

    def test_crop_scale(self):
        image = create_image(size=(200, 400))

        scaled = processors.scale_and_crop(image, (100, 100), crop='scale')
        self.assertEqual(scaled.size, (100, 200))

        scaled = processors.scale_and_crop(image, (600, 600), crop='scale')
        self.assertEqual(scaled.size, (200, 400))
        scaled = processors.scale_and_crop(image, (600, 600), crop='scale',
                                           upscale=True)
        self.assertEqual(scaled.size, (600, 1200))

    def test_one_dimension_scale(self):
        image = create_image()

        scaled = processors.scale_and_crop(image, (100, 0))
        self.assertEqual(scaled.size, (100, 75))
        scaled = processors.scale_and_crop(image, (0, 100))
        self.assertEqual(scaled.size, (133, 100))

    def test_one_dimension_crop(self):
        image = create_image()

        cropped = processors.scale_and_crop(image, (100, 0), crop=True)
        self.assertEqual(cropped.size, (100, 75))
        cropped = processors.scale_and_crop(image, (0, 100), crop=True)
        self.assertEqual(cropped.size, (133, 100))

    def test_croup_rounding(self):
        image = create_image(size=(2400, 3620))

        size = (110, 1000)
        cropped = processors.scale_and_crop(image, size, crop=True)
        self.assertEqual(cropped.size, size)

    def test_zoom_scale(self):
        image = create_image(size=(2400, 3620))

        size = (100, 100)
        scaled = processors.scale_and_crop(image, size, zoom=40)
        self.assertEqual(scaled.size, (66, 100))

    def test_zoom_crop(self):
        image = create_image(size=(2400, 3620))

        size = (110, 1000)
        cropped = processors.scale_and_crop(image, size, crop=True, zoom=40)
        self.assertEqual(cropped.size, size)

    def test_crop_target(self):
        image = create_image()

        # Try bottom right target.
        target = (95, 100)

        tl_crop = processors.scale_and_crop(
            image, size=(100, 600), crop=True, target=target)
        expected = image.crop([700, 0, 800, 600])
        self.assertImagesEqual(tl_crop, expected)

        tl_crop = processors.scale_and_crop(
            image, size=(800, 100), crop=True, target=target)
        expected = image.crop([0, 500, 800, 600])
        self.assertImagesEqual(tl_crop, expected)

        # Top left target.
        target = (0, 5)

        tl_crop = processors.scale_and_crop(
            image, size=(100, 600), crop=True, target=target)
        expected = image.crop([0, 0, 100, 600])
        self.assertImagesEqual(tl_crop, expected)

        tl_crop = processors.scale_and_crop(
            image, size=(800, 100), crop=True, target=target)
        expected = image.crop([0, 0, 800, 100])
        self.assertImagesEqual(tl_crop, expected)

    def test_crop_target_text(self):
        image = create_image()
        # Near centre target.
        target = '45,55'

        tl_crop = processors.scale_and_crop(
            image, size=(100, 600), crop=True, target=target)
        expected = image.crop([310, 0, 410, 600])
        self.assertImagesEqual(tl_crop, expected)

        tl_crop = processors.scale_and_crop(
            image, size=(800, 100), crop=True, target=target)
        expected = image.crop([0, 280, 800, 380])
        self.assertImagesEqual(tl_crop, expected)


class ColorspaceTest(TestCase):

    def test_standard(self):
        image = Image.new('RGB', (800, 600))
        processed = processors.colorspace(image)
        self.assertEqual(processed.mode, 'RGB')

        image = Image.new('L', (800, 600))
        processed = processors.colorspace(image)
        self.assertEqual(processed.mode, 'L')

    def test_transparent(self):
        image = Image.new('RGBA', (800, 600))
        processed = processors.colorspace(image)
        self.assertEqual(processed.mode, 'RGBA')

        image = Image.new('LA', (800, 600))
        processed = processors.colorspace(image)
        self.assertEqual(processed.mode, 'LA')

    def test_replace_alpha(self):
        image = Image.new('RGBA', (800, 600))
        self.assertEqual(image.load()[0, 0], (0, 0, 0, 0))
        processed = processors.colorspace(image, replace_alpha='#fefdfc')
        self.assertEqual(processed.mode, 'RGB')
        self.assertEqual(processed.load()[0, 0], (254, 253, 252))

        image = Image.new('LA', (800, 600))
        self.assertEqual(image.load()[0, 0], (0, 0))
        processed = processors.colorspace(image, replace_alpha='#fefdfc')
        self.assertEqual(processed.mode, 'L')
        self.assertEqual(processed.load()[0, 0], 253)

    def test_bw(self):
        image = Image.new('RGB', (800, 600))
        processed = processors.colorspace(image, bw=True)
        self.assertEqual(processed.mode, 'L')

        image = Image.new('RGBA', (800, 600))
        processed = processors.colorspace(image, bw=True)
        self.assertEqual(processed.mode, 'LA')

        image = Image.new('L', (800, 600))
        processed = processors.colorspace(image, bw=True)
        self.assertEqual(processed.mode, 'L')

        image = Image.new('LA', (800, 600))
        processed = processors.colorspace(image, bw=True)
        self.assertEqual(processed.mode, 'LA')


class AutocropTest(TestCase):

    def test_standard(self):
        processed = processors.autocrop(create_image(), autocrop=True)
        self.assertEqual(processed.size, (481, 421))


class BackgroundTest(TestCase):

    def test_basic(self):
        image = create_image()
        processed = processors.background(
            image, background='#fff', size=(800, 800))
        self.assertEqual(processed.size, (800, 800))

    def test_grayscale(self):
        image = create_image().convert('L')
        processed = processors.background(
            image, background='#fff', size=(800, 800))
        self.assertEqual(processed.size, (800, 800))
        self.assertEqual(processed.mode, 'L')

    def test_mode_alpha(self):
        image = create_image().convert('RGBA')
        processed = processors.background(
            image, background='#fff', size=(800, 800))
        self.assertEqual(processed.size, (800, 800))
        self.assertEqual(processed.mode, 'RGB')

        image = create_image().convert('LA')
        processed = processors.background(
            image, background='#fff', size=(800, 800))
        self.assertEqual(processed.size, (800, 800))
        self.assertEqual(processed.mode, 'L')

########NEW FILE########
__FILENAME__ = test_source_generators
import base64
from django.utils import six

try:
    from cStringIO import cStringIO as BytesIO
except ImportError:
    from django.utils.six import BytesIO

try:
    from PIL import Image, ImageChops
except ImportError:
    import Image
    import ImageChops

from easy_thumbnails import source_generators
from easy_thumbnails.tests import utils as test

EXIF_REFERENCE = '/9j/4AAQSkZJRgABAQEASABIAAD/4QAiRXhpZgAASUkqAAgAAAABABIBAwABAAAAAQAAAAAAAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH//gAdQ3JlYXRlZCB3aXRoIEdJTVAgb24gYSBNYWMA/8AACwgAHgAeAQERAP/EABgAAAMBAQAAAAAAAAAAAAAAAAAICgkL/8QAPhAAAAIGBgQGEwAAAAAAAAAABxYABAUGFRcICRMUGCUDChkaIyc3ZoinJDQ1OUVHSVdYZ2imqLjI1tfm5//aAAgBAQAAPwC/hBBBIA9tpWdekz1M0ffxQlftVwNon0jKCYGDKMrzHESXxmaY3jgrvO9ES8MQguqx8ndVksNgqdzYLDZah2Ay1W8XW9LVuu6dYWNMU5xtE8HJXS4eYuGM7RnJXea98hBRh3d5ktS73eKL3atha2/D2tlobNAMbVJ3zm+5gffaiKruy/tsfDd/e0QAbdYb2CInvNVN4QsVuFKC8fs/5Fn2ejvMmkpyVyUGIrFacRL5R3jjZcMeUReBMt/6sus03i6dnEng7wdy38ZGIOYuIM+8wgQKJRkhznj5n8CwXNtVNmX67Orf99TVROQLrR3f16c3Rm+Tyj6m/wBqMflRehN9XCX+J//Z'
EXIF_ORIENTATION = {
    2: '/9j/4AAQSkZJRgABAQEASABIAAD/4QAiRXhpZgAASUkqAAgAAAABABIBAwABAAAAAgAAAAAAAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH//gAdQ3JlYXRlZCB3aXRoIEdJTVAgb24gYSBNYWMA/8AACwgAHgAeAQERAP/EABgAAAMBAQAAAAAAAAAAAAAAAAAJCggL/8QAQRAAAAEKAQQJFQAAAAAAAAAAFgAEBQYHCBQVFxgDCQoTGQIaJCUmNkaIpxIjJzU3OUlXWGVmZ2imqLjI1tfm5//aAAgBAQAAPwC/ggggkA3tPO+M33MZ99qE391xd1naMwlRlyXJJzlZEyJpkkoJHo+Jl64rCijPcaKNDEwwdCYGJrgdYNcLSaLS4vV42zxMTZqAy5z7TzrnVrtuLTadVFrYMuBjPlunARpGHuPaqLPL5eJ052qgYuO3dEwxnDoB12mU68pnoZd9/FBVUasv12dG/wC+kgF9rOaNTo8603JxWT3F26AzsyXI0iGNXWfKo3bueUEaeHg9U8LceU5NpHPN7ZlJ0eOyvNba6G3AmwqwoN8pLpKrXST/AMwO6AUC26emInGPJ4Pb+aq2sv7bHw3f3sqqC5AudHd/Xfm5s3yeO+k/7MY/Ci8yb6uCv8L/2Q==',
    3: '/9j/4AAQSkZJRgABAQEASABIAAD/4QAiRXhpZgAASUkqAAgAAAABABIBAwABAAAAAwAAAAAAAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH//gAdQ3JlYXRlZCB3aXRoIEdJTVAgb24gYSBNYWMA/8AACwgAHgAeAQERAP/EABgAAAMBAQAAAAAAAAAAAAAAAAAICgkL/8QAQxAAAAEIAwcODwAAAAAAAAAAFQAFBgcIFBYXCRMZAwQKGCUmJxojJCg0NTY3ODlER4inSVdYZWZnaKaouMjW1+bn/9oACAEBAAA/AL+C5AuFHc+u3N2Zvk8Z9Lf7AY/Ci9ib6uCv8LAHHaad8ZvuYr77UIsS6MWkX25LZLM04mkVxcY6x5zNBK9iKX2ixEM0FWLXQdAzQEIGg6LmLISLmt/CxQ6Pp5v04nG+0AbnUkrCgRldZNozipY1sbT9y0kK9I9kXCMq+UmdlxQtC04lj8C4cG4jzjFwgxBaAW2lJ15TPcyz7+KCqosy/XZ3b/vpP+pJWUnFYIyrgbiOHBrLIaEPgukJ2P29z+dHd3FHXd13raiv1qtqbmgFJpRl2i8k9NknZOzI6t5hRFMKAvT1BwgIgfzo/inQnLZeVepl/bY+G7+9lVQQQQX/2Q==',
    4: '/9j/4AAQSkZJRgABAQEASABIAAD/4QAiRXhpZgAASUkqAAgAAAABABIBAwABAAAABAAAAAAAAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH//gAdQ3JlYXRlZCB3aXRoIEdJTVAgb24gYSBNYWMA/8AACwgAHgAeAQERAP/EABkAAAIDAQAAAAAAAAAAAAAAAAAJBwgKC//EAD4QAAADBQQEBBcAAAAAAAAAAAcVFgAFBggUCRcYJgQKGTc2OYinExojJCU1Q0ZJV1hkZWdopqi4yNbX5uf/2gAIAQEAAD8A38NyBdaO49eebkzfJ5L6z/tRj8KLyJvq4bf42APbaWnXlM8zMvv4oZv8rlkFZ2WroEwNP5P5Lzf3NqPamvYFi9kcgtVd1sYxCC8CZEBcTA6DRxEQaBzBsNZag1zmZOcvkwf7wer106f8EssVjpxcQZYdMRe+TOYgi6sbot3m/aKxPTyevPjngsRmx52cMi1zl5jamd8ZvuYH32o1Vell/bY+G7+9s/6SWWXB1LEGUuK2vFu6Weck2kThXCDFcd8Hj+Jy8vU5V2806roa7rapo9HJmpZcRiJzsjkcpO9tQmKhIPT7jo6Mj86qKruHQOrVV2Zfrs5t/wB9ZqjDDDf/2Q==',
    5: '/9j/4AAQSkZJRgABAQEASABIAAD/4QAiRXhpZgAASUkqAAgAAAABABIBAwABAAAABQAAAAAAAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH//gAdQ3JlYXRlZCB3aXRoIEdJTVAgb24gYSBNYWMA/8AACwgAHgAeAQERAP/EABgAAAMBAQAAAAAAAAAAAAAAAAgJCgAL/8QAPhAAAAIGBwIFFQAAAAAAAAAABxYABQYUFRcDBAgJExglCho4R2aHqBkjJCYnNDU2OUVIWGmGiLe4xsfY6P/aAAgBAQAAPwC/hIA77TynVpnmZ+n0KEapsy/psfDd+e0qoTIAA23XFhO0YJ7TDKMoGHESWxgpjaOZoxM9ES8zypZVT6OyogqNQ1NzUKjVdQ7AVdVeHV6rWPXaesVimlX2hsbRPuEcoXUm2mypZrZ/z90Vnh0Psi5KSr4SapGIrFacQj+JZcjZj7Y4vCFFC5rN6Ov1/Xm6M1jz9fU6/SAANtueTgntMHErjGXILrJ2hD5F2eVK+8HFFaO7vFHXv6nxcDH61i4NGla80uy94ukn3bMneTuZHFvmDmLmDIXL0ECiUZIcp4+Z/MsF1ZVe4x+1F6E39cJf4iAbbXCdE33M+XzKIVV2Xx2c2/36jVE//9k=',
    6: '/9j/4AAQSkZJRgABAQEASABIAAD/4QAiRXhpZgAASUkqAAgAAAABABIBAwABAAAABgAAAAAAAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH//gAdQ3JlYXRlZCB3aXRoIEdJTVAgb24gYSBNYWMA/8AACwgAHgAeAQERAP/EABkAAAIDAQAAAAAAAAAAAAAAAAkKAAcIC//EAEAQAAAACgQICA8AAAAAAAAAAAAEBQYHCBUWFxgDCRMUAgoaJCUmNkYSGSM1NziHqDlHSFhlZmmGiLe4xsfY6P/aAAgBAQAAPwB/gAArtdZ1JvuZ8vjUDVVWX47Ozf79AqgQKAPdVxBKRjnKZ5HkYzZOQs3JpFJ5jxJ95Z5PFCUJ5mSjhERChsRARFaDkBWitLK1peHTYdJSYalmM0LtLO1Okk/FxJNl0mLmRjJqYj5Lr4wigJDzp2NRJ7vO9E8+dlmG1m5pxpM0js9VfKjq9fz5u7Mp5+vodfoAArtV50nSzqTVcZXYiw6czXKNroth7kfGofez0IznZ7Pedlc+D17uN+za83MXFWs0rLlXTk67SFSFPJu3NJFaaRgen1dHFcWXT1xed8d3ne05lXIY/ai9yb+uAf8AAQDrtPCdLM9jP0+ooAqmLL+Wx8N357BqgP/Z',
    7: '/9j/4AAQSkZJRgABAQEASABIAAD/4QAiRXhpZgAASUkqAAgAAAABABIBAwABAAAABwAAAAAAAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH//gAdQ3JlYXRlZCB3aXRoIEdJTVAgb24gYSBNYWMA/8AACwgAHgAeAQERAP/EABkAAAIDAQAAAAAAAAAAAAAAAAkKAAcIC//EAEAQAAABCQEIDQ0AAAAAAAAAABUABQYHCAkUFhcTBBgZGiUnN0cDCiMkJik0NTg5RIeoSFhlZmmGiLe4xsfY6P/aAAgBAQAAPwB/ggAttdJ1ZvuZ8vkULVTsvXZ3b/fpFULkC40c/X8+bwzMefr6T/jkvjF3YrMzZLZOeJpFcVZqjrH0ezFT5oJa6rEQ4IKskdAzQEIGg6LmLISLmuPCxQ6Rp5u04nG6zUqyUkrBTg3ThGZcmMNGctJCd4wIjw7n47HSHhxS7uS2Frb7va2Ww2dqkgHiMftRfBN/XBb/AFJNz4BFWCMum6XX1t6kNZ/Z2oXPtdEhOzSmiuUVxStK1YpL0jpGNy5MeSBcCNZqXZbzTCL1szJ0do7TfWRUKYqhT76hIOEBEj+lI8U7FBb7KoUJAN9p1nTTPcz9PqqCKptZfy2Phu/PZNUF/9k=',
    8: '/9j/4AAQSkZJRgABAQEASABIAAD/4QAiRXhpZgAASUkqAAgAAAABABIBAwABAAAACAAAAAAAAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH//gAdQ3JlYXRlZCB3aXRoIEdJTVAgb24gYSBNYWMA/8AACwgAHgAeAQERAP/EABgAAAMBAQAAAAAAAAAAAAAAAAgJCgAL/8QAPxAAAAMGAQQJFQAAAAAAAAAABxUWAAUGCBQXCQQYGiYKEyMnNjc4h6gkJSk1OUNGR0hYZGVphoi3uMbH2Oj/2gAIAQEAAD8Av4aAPG07p1MzzM/T6FDNU2Mv5bHw3fntqqG5AulHY6/nzdGaTz9fWt9wgpXAJxXcOyXmfyfyBr9zaj3dm7AsKaMQtVdrRyEwF4E1EBeIQ6DRxEQaBzBsNatQa5zMnOXyYP8AeD1euXPTllkllik6W2biGVuriptZa5iDFxwkT9PcO4ricvL1O/O1VDV13V1TTZHTlU0Aegx+1F6E39cM/wCkl7DpLEGWHFyi83RZ78nFEsbuiDFY7cXm+enk9c9LcOX4bEZ51tMid3tUllmazjFtqSjkcm/CRQmKhP8A1A46OjI/Sqiq7xtG7FU2ZAM7XKdE33M+X0KMVWGX47Obf79Zqjf/2Q==',
}


def near_identical(im1, im2):
    """
    Check if two images are identical (or near enough).
    """
    diff = ImageChops.difference(im1, im2).histogram()
    for color in diff[2:]:
        if color:
            return False
    return True


def image_from_b64(data):
    return Image.open(BytesIO(base64.b64decode(data)))


class PilImageTest(test.BaseTest):

    def test_not_image(self):
        """
        Non-images raise an exception.
        """
        self.assertRaises(
            IOError,
            source_generators.pil_image, BytesIO(six.b('not an image')))

    def test_nearly_image(self):
        """
        Truncated images *don't* raise an exception if they can still be read.
        """
        data = self.create_image(None, None)
        reference = source_generators.pil_image(data)
        data.seek(0)
        trunc_data = BytesIO()
        trunc_data.write(data.read()[:-10])
        trunc_data.seek(0)
        im = source_generators.pil_image(trunc_data)
        # im will be truncated, but it should be the same dimensions.
        self.assertEqual(im.size, reference.size)
        # self.assertRaises(IOError, source_generators.pil_image, trunc_data)

    def test_exif_orientation(self):
        """
        Images with EXIF orientation data are reoriented.
        """
        reference = image_from_b64(EXIF_REFERENCE)
        for exif_orientation, data in six.iteritems(EXIF_ORIENTATION):
            im = image_from_b64(data)
            self.assertEqual(exif_orientation, im._getexif().get(0x0112))
            self.assertFalse(near_identical(reference, im))

            im = source_generators.pil_image(BytesIO(base64.b64decode(data)))
            self.assertTrue(
                near_identical(reference, im),
                'EXIF orientation %s did not match reference image' %
                exif_orientation)

    def test_switch_off_exif_orientation(self):
        """
        Images with EXIF orientation data are not reoriented if the
        ``exif_orientation`` parameter is ``False``.
        """
        reference = image_from_b64(EXIF_REFERENCE)
        data = EXIF_ORIENTATION[2]
        im = image_from_b64(data)
        self.assertFalse(near_identical(reference, im))

        im = source_generators.pil_image(
            BytesIO(base64.b64decode(data)), exif_orientation=False)
        self.assertFalse(
            near_identical(reference, im),
            'Image should not have been modified')

########NEW FILE########
__FILENAME__ = test_templatetags
from django.template import Template, Context, TemplateSyntaxError
try:
    from PIL import Image
except ImportError:
    import Image

from django.core.files import storage as django_storage

from easy_thumbnails import alias, storage
from easy_thumbnails.conf import settings
from easy_thumbnails.files import get_thumbnailer
from easy_thumbnails.tests import utils as test


class Base(test.BaseTest):

    def setUp(self):
        super(Base, self).setUp()
        self.storage = test.TemporaryStorage()
        # Save a test image.
        self.filename = self.create_image(self.storage, 'test.jpg')

        # Required so that IOError's get wrapped as TemplateSyntaxError
        settings.TEMPLATE_DEBUG = True

    def tearDown(self):
        self.storage.delete_temporary_storage()
        super(Base, self).tearDown()

    def render_template(self, source):
        source_image = get_thumbnailer(self.storage, self.filename)
        source_image.thumbnail_storage = self.storage
        context = Context({
            'source': source_image,
            'storage': self.storage,
            'filename': self.filename,
            'invalid_filename': 'not%s' % self.filename,
            'size': (90, 100),
            'invalid_size': (90, 'fish'),
            'strsize': '80x90',
            'invalid_strsize': ('1notasize2'),
            'invalid_q': 'notanumber'})
        source = '{% load thumbnail %}' + source
        return Template(source).render(context)

    def verify_thumbnail(self, expected_size, options, source_filename=None,
                         transparent=False):
        if source_filename is None:
            source_filename = self.filename
        self.assertTrue(isinstance(options, dict))
        # Verify that the thumbnail file exists
        thumbnailer = get_thumbnailer(self.storage, source_filename)
        expected_filename = thumbnailer.get_thumbnail_name(
            options, transparent=transparent)

        self.assertTrue(
            self.storage.exists(expected_filename),
            'Thumbnail file %r not found' % expected_filename)

        # Verify the thumbnail has the expected dimensions
        image = Image.open(self.storage.open(expected_filename))
        self.assertEqual(image.size, expected_size)

        return expected_filename


class ThumbnailTagTest(Base):
    restore_settings = ['THUMBNAIL_DEBUG', 'TEMPLATE_DEBUG']

    def testTagInvalid(self):
        # No args, or wrong number of args
        src = '{% thumbnail %}'
        self.assertRaises(TemplateSyntaxError, self.render_template, src)
        src = '{% thumbnail source %}'
        self.assertRaises(TemplateSyntaxError, self.render_template, src)
        src = '{% thumbnail source 80x80 as variable crop %}'
        self.assertRaises(TemplateSyntaxError, self.render_template, src)

        # Invalid option
        src = '{% thumbnail source 240x200 invalid %}'
        self.assertRaises(TemplateSyntaxError, self.render_template, src)

        # Old comma separated options format can only have an = for quality
        src = '{% thumbnail source 80x80 crop=1,quality=1 %}'
        self.assertRaises(TemplateSyntaxError, self.render_template, src)

        # Invalid quality
        src_invalid = '{% thumbnail source 240x200 quality=invalid_q %}'
        src_missing = '{% thumbnail source 240x200 quality=missing_q %}'
        # ...with THUMBNAIL_DEBUG = False
        settings.THUMBNAIL_DEBUG = False
        self.assertEqual(self.render_template(src_invalid), '')
        self.assertEqual(self.render_template(src_missing), '')
        # ...and with THUMBNAIL_DEBUG = True
        settings.THUMBNAIL_DEBUG = True
        self.assertRaises(TemplateSyntaxError, self.render_template,
                          src_invalid)
        self.assertRaises(TemplateSyntaxError, self.render_template,
                          src_missing)

        # Invalid source
        src = '{% thumbnail invalid_source 80x80 %}'
        src_on_context = '{% thumbnail invalid_source 80x80 as thumb %}'
        # ...with THUMBNAIL_DEBUG = False
        settings.THUMBNAIL_DEBUG = False
        self.assertEqual(self.render_template(src), '')
        # ...and with THUMBNAIL_DEBUG = True
        settings.THUMBNAIL_DEBUG = True
        self.assertRaises(TemplateSyntaxError, self.render_template, src)
        self.assertRaises(TemplateSyntaxError, self.render_template,
                          src_on_context)

        # Non-existant source
        src = '{% thumbnail non_existant_source 80x80 %}'
        src_on_context = '{% thumbnail non_existant_source 80x80 as thumb %}'
        # ...with THUMBNAIL_DEBUG = False
        settings.THUMBNAIL_DEBUG = False
        self.assertEqual(self.render_template(src), '')
        # ...and with THUMBNAIL_DEBUG = True
        settings.THUMBNAIL_DEBUG = True
        self.assertRaises(TemplateSyntaxError, self.render_template, src)

        # Invalid size as a tuple:
        src = '{% thumbnail source invalid_size %}'
        # ...with THUMBNAIL_DEBUG = False
        settings.THUMBNAIL_DEBUG = False
        self.assertEqual(self.render_template(src), '')
        # ...and THUMBNAIL_DEBUG = True
        settings.THUMBNAIL_DEBUG = True
        self.assertRaises(ValueError, self.render_template, src)
        # Invalid size as a string:
        src = '{% thumbnail source invalid_strsize %}'
        # ...with THUMBNAIL_DEBUG = False
        settings.THUMBNAIL_DEBUG = False
        self.assertEqual(self.render_template(src), '')
        # ...and THUMBNAIL_DEBUG = True
        settings.THUMBNAIL_DEBUG = True
        self.assertRaises(TemplateSyntaxError, self.render_template, src)

        # Non-existant size
        src = '{% thumbnail source non_existant_size %}'
        # ...with THUMBNAIL_DEBUG = False
        settings.THUMBNAIL_DEBUG = False
        self.assertEqual(self.render_template(src), '')
        # ...and THUMBNAIL_DEBUG = True
        settings.THUMBNAIL_DEBUG = True
        self.assertRaises(TemplateSyntaxError, self.render_template, src)

    def testTag(self):
        # Set THUMBNAIL_DEBUG = True to make it easier to trace any failures
        settings.THUMBNAIL_DEBUG = True

        # Basic
        output = self.render_template(
            'src="{% thumbnail source 240x240 %}"')
        expected = self.verify_thumbnail((240, 180), {'size': (240, 240)})
        expected_url = ''.join((settings.MEDIA_URL, expected))
        self.assertEqual(output, 'src="%s"' % expected_url)

        # Size from context variable
        # as a tuple:
        output = self.render_template(
            'src="{% thumbnail source size %}"')
        expected = self.verify_thumbnail((90, 68), {'size': (90, 100)})
        expected_url = ''.join((settings.MEDIA_URL, expected))
        self.assertEqual(output, 'src="%s"' % expected_url)
        # as a string:
        output = self.render_template(
            'src="{% thumbnail source strsize %}"')
        expected = self.verify_thumbnail((80, 60), {'size': (80, 90)})
        expected_url = ''.join((settings.MEDIA_URL, expected))
        self.assertEqual(output, 'src="%s"' % expected_url)

        # On context
        output = self.render_template(
            'height:{% thumbnail source 240x240 as thumb %}{{ thumb.height }}')
        self.assertEqual(output, 'height:180')

        # With options and quality
        output = self.render_template(
            'src="{% thumbnail source 240x240 sharpen crop quality=95 %}"')
        # Note that the opts are sorted to ensure a consistent filename.
        expected = self.verify_thumbnail(
            (240, 240),
            {'size': (240, 240), 'crop': True, 'sharpen': True, 'quality': 95})
        expected_url = ''.join((settings.MEDIA_URL, expected))
        self.assertEqual(output, 'src="%s"' % expected_url)

        # With option and quality on context (also using its unicode method to
        # display the url)
        output = self.render_template(
            '{% thumbnail source 240x240 sharpen crop quality=95 as thumb %}'
            'width:{{ thumb.width }}, url:{{ thumb.url }}')
        self.assertEqual(output, 'width:240, url:%s' % expected_url)

        # One dimensional resize
        output = self.render_template('src="{% thumbnail source 100x0 %}"')
        expected = self.verify_thumbnail((100, 75), {'size': (100, 0)})
        expected_url = ''.join((settings.MEDIA_URL, expected))
        self.assertEqual(output, 'src="%s"' % expected_url)


class ThumbnailerBase(Base):
    restore_settings = ['THUMBNAIL_ALIASES', 'THUMBNAIL_MEDIA_ROOT']

    def setUp(self):
        super(ThumbnailerBase, self).setUp()
        settings.THUMBNAIL_MEDIA_ROOT = self.storage.path('')
        settings.THUMBNAIL_ALIASES = {
            '': {
                'small': {'size': (20, 20), 'crop': True},
            },
        }
        alias.aliases.populate_from_settings()
        # Make the temporary storage location the default storage for now.
        self._old_default_storage = django_storage.default_storage._wrapped
        django_storage.default_storage._wrapped = self.storage
        self._old_thumbnail_default_storage = storage.thumbnail_default_storage
        storage.thumbnail_default_storage = self.storage

    def tearDown(self):
        # Put the default storage back how we found it.
        storage.thumbnail_default_storage = self._old_thumbnail_default_storage
        django_storage.default_storage._wrapped = self._old_default_storage
        super(ThumbnailerBase, self).tearDown()
        # Repopulate the aliases (setting reverted by super)
        alias.aliases.populate_from_settings()


class ThumbnailerFilterTest(ThumbnailerBase):

    def test_get(self):
        src = (
            '{% with t=filename|thumbnailer %}'
            '{{ t.small.url }}{% endwith %}'
        )
        output = self.render_template(src)
        expected = self.verify_thumbnail(
            (20, 20), settings.THUMBNAIL_ALIASES['']['small'])
        expected_url = ''.join((settings.MEDIA_URL, expected))
        self.assertEqual(output, expected_url)

    def test_relative_name(self):
        src = (
            '{% with t=storage|thumbnailer:filename %}'
            '{{ t.small.url }}{% endwith %}'
        )
        output = self.render_template(src)
        expected = self.verify_thumbnail(
            (20, 20), settings.THUMBNAIL_ALIASES['']['small'])
        expected_url = ''.join((settings.MEDIA_URL, expected))
        self.assertEqual(output, expected_url)

    def test_invalid(self):
        src = (
            '{% with t=invalid_filename|thumbnailer %}'
            '{{ t.small.url }}{% endwith %}'
        )
        output = self.render_template(src)
        self.assertEqual(output, '')


class ThumbnailerPassiveFilterTest(ThumbnailerBase):

    def test_check_generate(self):
        src = (
            '{% with t=filename|thumbnailer_passive %}'
            '{{ t.generate }}{% endwith %}'
        )
        output = self.render_template(src)
        self.assertEqual(output, 'False')

    def test_get_existing(self):
        options = settings.THUMBNAIL_ALIASES['']['small']
        # Pregenerate the thumbnail.
        get_thumbnailer(self.storage, self.filename).get_thumbnail(options)

        src = (
            '{% with t=filename|thumbnailer_passive %}'
            '{{ t.small.url }}{% endwith %}'
        )
        output = self.render_template(src)
        expected = self.verify_thumbnail((20, 20), options)
        expected_url = ''.join((settings.MEDIA_URL, expected))
        self.assertEqual(output, expected_url)

    def test_get_missing(self):
        src = (
            '{% with t=filename|thumbnailer_passive %}'
            '{{ t.small.url }}{% endwith %}'
        )
        output = self.render_template(src)
        self.assertEqual(output, '')

    def test_invalid(self):
        src = (
            '{% with t=invalid_filename|thumbnailer_passive %}'
            '{{ t.small.url }}{% endwith %}'
        )
        output = self.render_template(src)
        self.assertEqual(output, '')


class ThumbnailTagAliasTest(ThumbnailerBase):
    def assertCorrectOutput(self, src, alias_name, **overrides):
        options = settings.THUMBNAIL_ALIASES[''][alias_name]
        options.update(overrides)
        output = self.render_template(src)
        expected = self.verify_thumbnail(options['size'], options)
        expected_url = ''.join((settings.MEDIA_URL, expected))
        self.assertEqual(output, expected_url)

    def test_invalid_alias_name(self):
        self.assertEqual(
            self.render_template('{% thumbnail filename "notanalias" %}'),
            ''
        )

    def test_correct_alias(self):
        self.assertCorrectOutput('{% thumbnail filename "small" %}', 'small')

    def test_alias_overrides(self):
        self.assertCorrectOutput(
            '{% thumbnail filename "small" upscale %}',
            'small',
            upscale=True,
        )
        self.assertCorrectOutput(
            '{% thumbnail filename "small" upscale bw %}',
            'small',
            bw=True,
            upscale=True,
        )

########NEW FILE########
__FILENAME__ = test_widgets
from easy_thumbnails import widgets
from django.core.files.uploadedfile import SimpleUploadedFile
from django.forms.widgets import ClearableFileInput
from easy_thumbnails.tests import utils as test


class ImageClearableFileInput(test.BaseTest):

    def setUp(self):
        super(ImageClearableFileInput, self).setUp()
        self.storage = test.TemporaryStorage()

    def tearDown(self):
        self.storage.delete_temporary_storage()
        super(ImageClearableFileInput, self).tearDown()

    def test_options_default(self):
        """
        If thumbnail options are not passed, default options will be used.
        """
        widget = widgets.ImageClearableFileInput()
        self.assertEqual(widget.thumbnail_options, {'size': (80, 80)})

    def test_options_custom(self):
        """
        A dictionary can be passed as the thumbnail options. The dictionary is
        copied so it isn't just a mutable reference of the original.
        """
        options = {'size': (300, 100), 'crop': True}
        widget = widgets.ImageClearableFileInput(thumbnail_options=options)
        # Changing the options won't change the thumbnail options in the widget
        # now.
        options['crop'] = False
        self.assertEqual(
            widget.thumbnail_options, {'size': (300, 100), 'crop': True})

    def test_render(self):
        """
        The output contains a link to both the source image and the thumbnail.
        """
        source_filename = self.create_image(self.storage, 'test.jpg')
        widget = widgets.ImageClearableFileInput()
        source_file = self.storage.open(source_filename)
        source_file.storage = self.storage
        source_file.thumbnail_storage = self.storage
        html = widget.render('photo', source_file)
        self.assertIn(source_filename, html)
        self.assertIn('.80x80_', html)

    def test_render_custom(self):
        """
        The thumbnail is generated using the options provided to the widget.
        """
        source_filename = self.create_image(self.storage, 'test.jpg')
        options = {'size': (100, 500), 'quality': 90, 'crop': True}
        widget = widgets.ImageClearableFileInput(thumbnail_options=options)
        source_file = self.storage.open(source_filename)
        source_file.storage = self.storage
        source_file.thumbnail_storage = self.storage
        html = widget.render('photo', source_file)
        self.assertIn(source_filename, html)
        self.assertIn('.100x500_q90_crop.jpg', html)

    def test_custom_template(self):
        """
        The template used to render the thumbnail and the standard
        ``ClearableFileInput`` output can be customized.
        """
        source_filename = self.create_image(self.storage, 'test.jpg')
        widget = widgets.ImageClearableFileInput()
        widget.template_with_thumbnail = (
            u'%(template)s<br />'
            u'<a href="%(source_url)s">%(thumb)s</a> FOO'
        )
        source_file = self.storage.open(source_filename)
        source_file.storage = self.storage
        source_file.thumbnail_storage = self.storage
        html = widget.render('photo', source_file)
        self.assertIn(source_filename, html)
        self.assertIn('.80x80_', html)
        self.assertIn('FOO', html)

    def test_render_without_value(self):
        """
        If value not passed, use super widget.
        """
        widget = widgets.ImageClearableFileInput()
        base_widget = ClearableFileInput()
        html = widget.render('photo', None)
        base_html = base_widget.render('photo', None)
        self.assertEqual(base_html, html)

    def test_render_uploaded(self):
        """
        The widget treats UploadedFile as no input.

        Rationale:
        When widget is used in ModelForm and the form (submitted with upload)
        is not valid, widget should discard the value (just like standard
        Django ClearableFileInput does).
        """
        widget = widgets.ImageClearableFileInput()
        base_widget = ClearableFileInput()
        file_name = 'test.jpg'
        # storage=None to get raw content.
        image = self.create_image(None, file_name)
        upload_file = SimpleUploadedFile(file_name, image.getvalue())
        html = widget.render('photo', upload_file)
        base_html = base_widget.render('photo', upload_file)
        self.assertEqual(base_html, html)
        self.assertNotIn(file_name, html)   # Widget is empty.

########NEW FILE########
__FILENAME__ = utils
import shutil
import tempfile
try:
    from cStringIO import cStringIO as BytesIO
except ImportError:
    from django.utils.six import BytesIO
try:
    from unittest import skipUnless
except ImportError:  # Python 2.6
    from django.utils.unittest import skipUnless

import django
from django.core.exceptions import ImproperlyConfigured
from django.core.files.base import ContentFile
from django.core.files.storage import FileSystemStorage
from django.test import TestCase
try:
    from PIL import Image
except ImportError:
    import Image

from easy_thumbnails.conf import settings


class TemporaryStorage(FileSystemStorage):
    """
    A storage class useful for tests that uses a temporary location to store
    all files and provides a method to remove this location when it is finished
    with.
    """

    def __init__(self, location=None, *args, **kwargs):
        """
        Create the temporary location.
        """
        if location is None:
            location = tempfile.mkdtemp()
            self.temporary_location = location
        super(TemporaryStorage, self).__init__(location=location, *args,
                                               **kwargs)

    def delete_temporary_storage(self):
        """
        Delete the temporary directory created during initialisation.
        This storage class should not be used again after this method is
        called.
        """
        temporary_location = getattr(self, 'temporary_location', None)
        if temporary_location:
            shutil.rmtree(temporary_location)


class FakeRemoteStorage(TemporaryStorage):
    """
    A temporary storage class that acts similar to remote storage.

    It's not thread safe.
    """
    remote_mode = False

    def path(self, *args, **kwargs):
        """
        Raise ``NotImplementedError``, since this is the way that
        easy-thumbnails determines if a storage is remote.
        """
        if self.remote_mode:
            raise NotImplementedError
        return super(FakeRemoteStorage, self).path(*args, **kwargs)

    def exists(self, *args, **kwargs):
        original_remote_mode = self.remote_mode
        self.remote_mode = False
        try:
            return super(FakeRemoteStorage, self).exists(*args, **kwargs)
        finally:
            self.remote_mode = original_remote_mode

    def save(self, *args, **kwargs):
        self.remote_mode = False
        try:
            return super(FakeRemoteStorage, self).save(*args, **kwargs)
        finally:
            self.remote_mode = True

    def open(self, *args, **kwargs):
        self.remote_mode = False
        try:
            return super(FakeRemoteStorage, self).open(*args, **kwargs)
        finally:
            self.remote_mode = True

    def delete(self, *args, **kwargs):
        self.remote_mode = False
        try:
            return super(FakeRemoteStorage, self).delete(*args, **kwargs)
        finally:
            self.remote_mode = True


class BaseTest(TestCase):
    """
    Remove any customised THUMBNAIL_* settings in a project's ``settings``
    configuration module before running the tests to ensure there is a
    consistent test environment.
    """

    def setUp(self):
        """
        Isolate all settings.
        """
        output = super(BaseTest, self).setUp()
        settings.isolated = True
        return output

    def tearDown(self):
        """
        Restore settings to their original state.
        """
        settings.isolated = False
        settings.revert()
        return super(BaseTest, self).tearDown()

    def create_image(self, storage, filename, size=(800, 600),
                     image_mode='RGB', image_format='JPEG'):
        """
        Generate a test image, returning the filename that it was saved as.

        If ``storage`` is ``None``, the BytesIO containing the image data
        will be passed instead.
        """
        data = BytesIO()
        Image.new(image_mode, size).save(data, image_format)
        data.seek(0)
        if not storage:
            return data
        image_file = ContentFile(data.read())
        return storage.save(filename, image_file)


class SouthSupportTest(TestCase):
    @skipUnless(django.VERSION < (1, 7), "test only applies to 1.6 and below")
    def test_import_migrations_module(self):
        try:
            from easy_thumbnails.migrations import __doc__  # noqa
        except ImproperlyConfigured as e:
            exception = e
        self.assertIn("SOUTH_MIGRATION_MODULES", exception.args[0])

########NEW FILE########
__FILENAME__ = utils
import hashlib
import inspect
import math
from django.utils import six

from django.utils.functional import LazyObject
from django.utils import timezone


try:
    from PIL import Image
except ImportError:
    import Image

from easy_thumbnails.conf import settings


def image_entropy(im):
    """
    Calculate the entropy of an image. Used for "smart cropping".
    """
    if not isinstance(im, Image.Image):
        # Can only deal with PIL images. Fall back to a constant entropy.
        return 0
    hist = im.histogram()
    hist_size = float(sum(hist))
    hist = [h / hist_size for h in hist]
    return -sum([p * math.log(p, 2) for p in hist if p != 0])


def dynamic_import(import_string):
    """
    Dynamically import a module or object.
    """
    # Use rfind rather than rsplit for Python 2.3 compatibility.
    lastdot = import_string.rfind('.')
    if lastdot == -1:
        return __import__(import_string, {}, {}, [])
    module_name, attr = import_string[:lastdot], import_string[lastdot + 1:]
    parent_module = __import__(module_name, {}, {}, [attr])
    return getattr(parent_module, attr)


def valid_processor_options(processors=None):
    """
    Return a list of unique valid options for a list of image processors
    (and/or source generators)
    """
    if processors is None:
        processors = [
            dynamic_import(p) for p in
            settings.THUMBNAIL_PROCESSORS +
            settings.THUMBNAIL_SOURCE_GENERATORS]
    valid_options = set(['size', 'quality', 'subsampling'])
    for processor in processors:
        args = inspect.getargspec(processor)[0]
        # Add all arguments apart from the first (the source image).
        valid_options.update(args[1:])
    return list(valid_options)


def is_storage_local(storage):
    """
    Check to see if a file storage is local.
    """
    try:
        storage.path('test')
    except NotImplementedError:
        return False
    return True


def get_storage_hash(storage):
    """
    Return a hex string hash for a storage object (or string containing
    'full.path.ClassName' referring to a storage object).
    """
    # If storage is wrapped in a lazy object we need to get the real thing.
    if isinstance(storage, LazyObject):
        if storage._wrapped is None:
            storage._setup()
        storage = storage._wrapped
    if not isinstance(storage, six.string_types):
        storage_cls = storage.__class__
        storage = '%s.%s' % (storage_cls.__module__, storage_cls.__name__)
    return hashlib.md5(storage.encode('utf8')).hexdigest()


def is_transparent(image):
    """
    Check to see if an image is transparent.
    """
    if not isinstance(image, Image.Image):
        # Can only deal with PIL images, fall back to the assumption that that
        # it's not transparent.
        return False
    return (image.mode in ('RGBA', 'LA') or
            (image.mode == 'P' and 'transparency' in image.info))


def exif_orientation(im):
    """
    Rotate and/or flip an image to respect the image's EXIF orientation data.
    """
    try:
        exif = im._getexif()
    except (AttributeError, IndexError, KeyError, IOError):
        exif = None
    if exif:
        orientation = exif.get(0x0112)
        if orientation == 2:
            im = im.transpose(Image.FLIP_LEFT_RIGHT)
        elif orientation == 3:
            im = im.rotate(180)
        elif orientation == 4:
            im = im.transpose(Image.FLIP_TOP_BOTTOM)
        elif orientation == 5:
            im = im.rotate(-90).transpose(Image.FLIP_LEFT_RIGHT)
        elif orientation == 6:
            im = im.rotate(-90)
        elif orientation == 7:
            im = im.rotate(90).transpose(Image.FLIP_LEFT_RIGHT)
        elif orientation == 8:
            im = im.rotate(90)
    return im


def get_modified_time(storage, name):
    """
    Get modified time from storage, ensuring the result is a timezone-aware
    datetime.
    """
    try:
        modified_time = storage.modified_time(name)
    except OSError:
        return 0
    except NotImplementedError:
        return None
    if modified_time and timezone.is_naive(modified_time):
        if getattr(settings, 'USE_TZ', False):
            default_timezone = timezone.get_default_timezone()
            return timezone.make_aware(modified_time, default_timezone)
    return modified_time

########NEW FILE########
__FILENAME__ = widgets
from django.forms.widgets import ClearableFileInput
from django.utils.safestring import mark_safe
from easy_thumbnails.files import get_thumbnailer


class ImageClearableFileInput(ClearableFileInput):
    template_with_initial = (
        u'%(clear_template)s<br />'
        u'%(input_text)s: %(input)s'
    )
    template_with_thumbnail = (
        u'%(template)s<br />'
        u'<a href="%(source_url)s" target="_blank">%(thumb)s</a>'
    )

    def __init__(self, thumbnail_options=None, attrs=None):
        thumbnail_options = thumbnail_options or {}
        thumbnail_options = thumbnail_options.copy()
        if 'size' not in thumbnail_options:
            thumbnail_options['size'] = (80, 80)
        self.thumbnail_options = thumbnail_options.copy()
        super(ImageClearableFileInput, self).__init__(attrs)

    def thumbnail_id(self, name):
        return '%s_thumb_id' % name

    def get_thumbnail(self, value):
        thumbnailer = get_thumbnailer(value, value.name)
        thumbnailer.source_storage = value.storage
        if hasattr(value, 'thumbnail_storage'):
            thumbnailer.thumbnail_storage = value.thumbnail_storage
        return thumbnailer.get_thumbnail(self.thumbnail_options)

    def render(self, name, value, attrs=None):
        output = super(ImageClearableFileInput, self).render(
            name, value, attrs)
        if not value or not hasattr(value, 'storage'):
            return output
        thumb = self.get_thumbnail(value)
        substitution = {
            'template': output,
            'thumb': thumb.tag(id=self.thumbnail_id(name)),
            'source_url': value.storage.url(value.name),
        }
        return mark_safe(self.template_with_thumbnail % substitution)

########NEW FILE########
