__FILENAME__ = conftest

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# handy documentation build configuration file, created by
# sphinx-quickstart on Fri May 11 20:35:04 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.coverage', 'sphinx.ext.intersphinx']

intersphinx_mapping = {'python': ('http://docs.python.org/2', None)}

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'handy'
copyright = u'2012, Alexander Schepanovski'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.2.4'
# The full version, including alpha/beta/rc tags.
release = '0.2.4'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'
html_style = 'overrides.css' # Supress RTD washy theme

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'handydoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'handy.tex', u'handy Documentation',
   u'Alexander Schepanovski', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'handy', u'handy Documentation',
     [u'Alexander Schepanovski'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'handy', u'handy Documentation',
   u'Alexander Schepanovski', 'handy', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = ajax
# -*- coding: utf-8 -*-
import re, datetime
from functools import wraps
import pytz

from django.http import HttpResponse
try:
    from django.utils.timezone import get_default_timezone
except ImportError:
    from django.conf import settings
    _default_timezone = pytz.timezone(settings.TIME_ZONE)
    get_default_timezone = lambda: _default_timezone

from .decorators import render_to_json


class AjaxException(Exception):
    def __init__(self, error='', **kwargs):
        defaults = {'success': False, 'error': error, 'data': {}}
        self.params = dict(defaults, **kwargs)

class Ajax(object):
    error = AjaxException

    def __call__(self, func):
        @wraps(func)
        def wrapper(request, *args, **kwargs):
            try:
                data = func(request, *args, **kwargs)
                if isinstance(data, HttpResponse):
                    return data
                return {'success': True, 'data': data}
            except self.error, e:
                return e.params
        return render_to_json(default=encode_object)(wrapper)

    def catch(self, *exceptions):
        assert exceptions, 'at least one exception type is required'
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                try:
                    return func(*args, **kwargs)
                except self.error:
                    raise
                except exceptions, e:
                    error_name = camel_to_underscores(e.__class__.__name__)
                    error_text = e.args[0] if e.args else ''
                    raise self.error(error_name, error_text=error_text)
            return wrapper
        return decorator

    def login_required(self, func):
        @wraps(func)
        def wrapper(request, *args, **kwargs):
            if request.user.is_anonymous():
                raise self.error('login_required')
            else:
                return func(request, *args, **kwargs)
        return wrapper

ajax = Ajax()


def camel_to_underscores(name):
    words = re.findall(r'[A-Z][a-z0-9]+', name)
    return '_'.join(w.lower() for w in words)


### Encoding object to json
from pytz.tzinfo import DstTzInfo
DstTzInfo.__json__ = lambda self: self.zone

UTC = pytz.timezone('UTC')
EPOCH = datetime.datetime(1970,1,1,0,0,0, tzinfo=UTC)

# TODO: add support for querysets and models
def encode_object(obj):
    if hasattr(obj, '__json__'):
        return obj.__json__()
    elif isinstance(obj, datetime.datetime):
        delta = to_default(obj) - EPOCH
        return {'_type': 'date', 'ms': int(delta.total_seconds() * 1000)}
    elif isinstance(obj, datetime.date):
        return datetime.datetime(*obj.timetuple()[:6])
    else:
        raise TypeError('%s is not JSON serializable' % obj.__class__.__name__)

def to_default(dt):
    if dt.tzinfo is None:
        return get_default_timezone().localize(dt)
    else:
        return dt.astimezone(get_default_timezone())


########NEW FILE########
__FILENAME__ = cross
import django

# django.utils.simplejson is deprecated in Django 1.5
if django.VERSION >= (1, 5):
    import json
else:
    from django.utils import simplejson as json

########NEW FILE########
__FILENAME__ = data
# -*- coding: utf-8 -*-
from itertools import chain, izip, tee


def with_prev(coll, key=None):
    if key is not None:
        coll = sorted(coll, key=key)
    a, b = tee(coll)
    return izip(a, chain([None], b))

def with_next(coll, key=None):
    if key is not None:
        coll = sorted(coll, key=key)
    a, b = tee(coll)
    return izip(a, padnone(skip(b)))

def padnone(iterable):
    """Returns the sequence elements and then returns None indefinitely.

    Useful for emulating the behavior of the built-in map() function.
    """
    return chain(iterable, repeat(None))

########NEW FILE########
__FILENAME__ = db
# -*- coding: utf-8 -*-
from functools import wraps
from operator import itemgetter
from collections import namedtuple
from contextlib import closing, contextmanager

from django.db import transaction, connections


__all__ = ('commit_on_success_on',
           'queryset_iterator', 'queryset_chunks',
           'fetch_all', 'fetch_row', 'fetch_col', 'fetch_val', 'do_sql',
           'fetch_named', 'fetch_named_row')


def commit_on_success_on(*databases):
    databases = set(databases)
    def decorator(func):
        for db in databases:
            func = transaction.commit_on_success(db)(func)
        return wraps(func)(func)
    return decorator


def queryset_iterator(queryset, chunksize=1000):
    pk = 0
    try:
        last_pk = queryset.order_by('-pk')[0].pk
    except IndexError:
        raise StopIteration
    queryset = queryset.order_by('pk')
    while pk < last_pk:
        # Use iterator to bypass queryset cache
        for row in queryset.filter(pk__gt=pk)[:chunksize].iterator():
            pk = row.pk
            yield row

def queryset_chunks(queryset, chunksize=1000):
    pk = 0
    while True:
        chunk = list(queryset.order_by('pk').filter(pk__gt=pk)[:chunksize])
        if chunk:
            pk = chunk[-1].pk
            yield chunk
        else:
            break


### A couple of low-level utilities

def fetch_all(sql, params=(), server='default'):
    with db_execute(sql, params, server) as cursor:
        return cursor.fetchall()

def fetch_row(sql, params=(), server='default'):
    with db_execute(sql, params, server) as cursor:
        return cursor.fetchone()

def fetch_col(sql, params=(), server='default'):
    return [row[0] for row in fetch_all(sql, params, server)]

def fetch_val(sql, params=(), server='default'):
    return silent_first(fetch_row(sql, params, server))

def do_sql(sql, params=(), server='default'):
    with db_execute(sql, params, server) as _:
        pass

# A low level cursor access context manager
@contextmanager
def db_execute(sql, params=(), server='default'):
    with closing(connections[server].cursor()) as cursor:
        cursor.execute(sql, params)
        yield cursor


def fetch_named(sql, params=(), server='default'):
    with db_execute(sql, params, server) as cursor:
        rec_class = _row_namedtuple(cursor)
        return map(rec_class._make, cursor.fetchall())

def fetch_named_row(sql, params=(), server='default'):
    with db_execute(sql, params, server) as cursor:
        rec_class = _row_namedtuple(cursor)
        return rec_class._make(cursor.fetchone())

def _row_namedtuple(cursor):
    field_names = map(itemgetter(0), cursor.description)
    return namedtuple('TableRow', field_names)


def silent_first(seq):
    try:
        return seq[0]
    except (IndexError, TypeError):
        return None


########NEW FILE########
__FILENAME__ = decorators
# -*- coding: utf-8 -*-
from functools import wraps
from datetime import datetime

from django.conf import settings
from django.template import loader, RequestContext
from django.http import HttpResponse
from django.utils.http import http_date

from handy.cross import json


def template_guess(func):
    template_dir = func.__module__.replace('.views', '').replace('.', '/')
    return template_dir + '/' +                                                     \
           func.__name__ + getattr(settings, 'TEMPLATE_DEFAULT_EXTENSION', '.html')


def render_dict(request, output):
    # extracting hook keys
    template = output.pop('TEMPLATE')
    kwargs = dict((k.lower(), output.pop(k)) for k in ('STATUS', 'CONTENT_TYPE') if k in output)
    # rendering remplate and wrapping it into HttpResponse
    rendered = loader.render_to_string(template, output, RequestContext(request))
    return HttpResponse(rendered, **kwargs)


def render_to(template=None):
    """
    Renders view result to template. Inspired by `@render_to()` decorator
    from django-annoying package.
    """
    def decorator(func):
        template_default = template or template_guess(func)

        @wraps(func)
        def wrapper(request, *args, **kwargs):
            output = func(request, *args, **kwargs)
            if not isinstance(output, dict):
                return output

            output.setdefault('TEMPLATE', template_default)
            response = render_dict(request, output)
            if 'COOKIES' in output:
                cookies = (output['COOKIES'],) if isinstance(output['COOKIES'], dict) else output['COOKIES']
                for i in cookies:
                    response.set_cookie(**i)
            return response

        return wrapper
    return decorator


def _json_default(obj):
    # TODO: unify json func here, in ajax, and the one used by JSONField
    if isinstance(obj, datetime):
        return obj.isoformat()
    raise TypeError

def render_to_json(ensure_ascii=True, default=_json_default):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            response = func(*args, **kwargs)
            if isinstance(response, HttpResponse):
                return response
            elif isinstance(response, str):
                json_data = response
            else:
                if settings.DEBUG:
                    json_data = json.dumps(response, sort_keys=True, indent=4, ensure_ascii=False, default=default)
                else:
                    json_data = json.dumps(response, ensure_ascii=ensure_ascii, separators=(',',':'), default=default)
            return HttpResponse(json_data, mimetype='application/json; charset=utf-8')
        return wrapper
    return decorator


def last_modified(func):
    @wraps(func)
    def wrapper(request, *args, **kwargs):
        response = func(request, *args, **kwargs)
        response['Last-Modified'] = http_date()
        return response
    return wrapper

########NEW FILE########
__FILENAME__ = widgets
# -*- coding: utf-8 -*-
from django import forms
from django.utils.safestring import mark_safe


class SimpleWidget(forms.Widget):
    def __init__(self, format='%(value)s'):
        super(SimpleWidget, self).__init__()
        self.format = format

    def render(self, name, value, attrs=None):
        return mark_safe(self.format % {'name': name, 'value': value})


class CommaSeparatedInput(forms.TextInput):
    def _format_value(self, value):
        if isinstance(value, basestring):
            return value
        else:
            return ','.join(map(unicode, value))

    def value_from_datadict(self, data, files, name):
        value = data.get(name, '').strip()
        if value in ['', None]:
            return []
        return value.split(',')


class MultilineInput(forms.Textarea):
    def _format_value(self, value):
        if isinstance(value, basestring):
            return value
        else:
            return '\n'.join(value)

########NEW FILE########
__FILENAME__ = http
# -*- coding: utf-8 -*-
import re, urlparse
from httplib import HTTPConnection, _CS_IDLE


def raw_pipeline(domain, pages, max_out_bound=4, method='GET', timeout=None, debuglevel=0):
    pagecount = len(pages)
    conn = HTTPConnection(domain, timeout=timeout)
    conn.set_debuglevel(debuglevel)
    respobjs = [None] * pagecount
    finished = [False] * pagecount
    responses = [None] * pagecount
    data = [None] * pagecount
    headers = {'Host': domain, 'Content-Length': 0, 'Connection': 'Keep-Alive'}

    while not all(finished):
        # Send
        out_bound = 0
        for i, page in enumerate(pages):
            if out_bound >= max_out_bound:
                break
            elif page and not finished[i] and respobjs[i] is None:
                if debuglevel > 0:
                    print 'Sending request for %r...' % (page,)
                conn._HTTPConnection__state = _CS_IDLE # FU private variable!
                conn.request(method, page, None, headers)
                respobjs[i] = conn.response_class(conn.sock, strict=conn.strict, method=conn._method)
                out_bound += 1

        # Try to read a response
        for i, resp in enumerate(respobjs):
            if resp is None:
                continue
            if debuglevel > 0:
                print 'Retrieving %r...' % (pages[i],)
            out_bound -= 1
            skip_read = False
            resp.begin()
            if debuglevel > 0:
                print '    %d %s' % (resp.status, resp.reason)
            if 200 <= resp.status < 300:
                # Ok
                data[i] = resp.read()
                cookie = resp.getheader('Set-Cookie')
                if cookie is not None:
                    headers['Cookie'] = cookie
                skip_read = True
                finished[i] = True
                responses[i] = respobjs[i]
                respobjs[i] = None
            elif 300 <= resp.status < 400:
                # Redirect
                loc = resp.getheader('Location')
                respobjs[i] = None
                parsed = loc and urlparse.urlparse(loc)
                if not parsed:
                    # Missing or empty location header
                    data[i] = (resp.status, resp.reason)
                    finished[i] = True
                elif parsed.netloc != '' and parsed.netloc != domain:
                    # Redirect to another domain
                    data[i] = (resp.status, resp.reason, loc)
                    finished[i] = True
                else:
                    path = urlparse.urlunparse(parsed._replace(scheme='',netloc='',fragment=''))
                    if debuglevel > 0:
                        print '  Updated %r to %r' % (pages[i],path)
                    pages[i] = path
            elif resp.status >= 400:
                # Failed
                data[i] = (resp.status, resp.reason)
                finished[i] = True
                responses[i] = respobjs[i]
                respobjs[i] = None
            if resp.will_close:
                # Connection (will be) closed, need to resend
                conn.close()
                if debuglevel > 0:
                    print '  Connection closed'
                for j, f in enumerate(finished):
                    if not f and respobjs[j] is not None:
                        if debuglevel > 0:
                            print '  Discarding out-bound request for %r' % (pages[j],)
                        respobjs[j] = None
                break
            elif not skip_read:
                resp.read() # read any data
            if any(not f and respobjs[j] is None for j,f in enumerate(finished)):
                # Send another pending request
                break
        else:
            break # All respobjs are None?
    return responses, data


def pipeline(urls, **kwargs):
    url_index = dict((u, i) for i, u in enumerate(urls))
    responses, data = [None] * len(urls), [''] * len(urls)

    # Grouping urls by domain
    urls = sorted(re.match(r'http://([^/]+)(.*)$',u).groups() for u in url_index)
    groups = group(urls, 0)

    # Executing requests in each group
    for g in groups:
        pages = [url[1] for url in g]
        g_responses, g_data = raw_pipeline(g.grouper, pages, **kwargs)

        for i, page in enumerate(pages):
            url = 'http://%s%s' % (g.grouper, page)
            index = url_index[url]
            responses[index] = g_responses[i]
            data[index] = data[i]

    # Some urls may have been doubled,
    # copy responses and data for them
    if len(url_index) < len(urls):
        for i, res in enumerate(responses):
            if res is None:
                index = url_index[urls[i]]
                responses[i] = responses[index]
                data[i] = data[index]

    return responses, data


def group(object_list, key, min_group=1):
    groups = []
    group = None
    prev = None

    for obj in object_list:
        val = getattr(obj, key) if isinstance(key, str) and hasattr(obj, key) else obj[key]
        if val != prev:
            if group and len(group) < min_group:
                group.grouper += ', ' + val
            else:
                group = Group()
                group.grouper = val
                groups.append(group)
        group.append(obj)
        prev = val

    return groups


if __name__ == '__main__':
    domain = 'en.wikipedia.org:80'
    pages = ('/wiki/HTTP_pipelining', '/wiki/HTTP', '/wiki/HTTP_persistent_connection')
    data = raw_pipeline(domain, pages, debuglevel=1, method='HEAD', max_out_bound=6, timeout=1)
    for i,page in enumerate(data):
        print
        print '==== Page %r ====' % (pages[i],)
        #print page[:512]

########NEW FILE########
__FILENAME__ = logger
# -*- coding: utf-8 -*-
import logging, logging.handlers

from django.conf import settings


def get_logger(name, level=logging.INFO, format='[%(asctime)s] %(message)s', handler=None, filename=None):
    new_logger = logging.getLogger(name)
    new_logger.setLevel(level)

    if not handler:
        filename = filename or '%s/logs/%s.log' % (settings.HOME_DIR, name)
        handler = logging.FileHandler(filename)

    handler.setFormatter(logging.Formatter(format))
    new_logger.addHandler(handler)

    return new_logger


if hasattr(settings, 'LOG_FILENAME') and not logger:
    handler = logging.handlers.TimedRotatingFileHandler(settings.LOG_FILENAME, when = 'midnight')
    logger = get_logger('default', handler=handler)

########NEW FILE########
__FILENAME__ = mail
# -*- coding: utf-8 -*-
import re, sys, traceback
from smtplib import SMTPRecipientsRefused

from django.conf import settings
from django.core.mail import EmailMessage, mail_admins as django_mail_admins
from django.template import loader, RequestContext
from django.core.files.uploadedfile import InMemoryUploadedFile


def parse_email_data(content):
    lines = content.splitlines()

    subject, content_subtype = None, None
    headers = {}

    for i, line in enumerate(lines):
        # Headers read?
        if not line and subject:
            lines = lines[i+1:]
            break

        m = re.search(r'^([\w-]+): (.+)', line.strip())
        if not m:
            raise ValueError('Email subject required\nPrepend email content with "Subject:\s<subject>\\n\\n"')
        name, value = m.groups()

        if name == 'Subject':
            subject = value
        elif name == 'Content-Type':
            m = re.search('^text/([\w-]+)', value)
            if not m:
                raise ValueError('Erroneous email content type %s' % value)
            content_subtype = m.group(1)
        else:
            headers[name] = value
    return subject, content_subtype, headers, '\n'.join(lines)


def render_to_email(email, template_name, data=None, request=None, from_email=None, attachment=None):
    if not email:
        return

    context = RequestContext(request) if request else None
    content = loader.render_to_string(template_name, data or {}, context)

    subject, content_subtype, headers, email_text = parse_email_data(content)

    if not isinstance(email, (list, tuple)):
        email = [email]

    message = EmailMessage(subject, email_text, from_email, email, headers=headers)
    if content_subtype:
        message.content_subtype = content_subtype

    if attachment:
        add_attach = lambda uploadedFile: message.attach(uploadedFile.name, uploadedFile.read(), uploadedFile.content_type)

        if isinstance(attachment, list):
            for attach in attachment:
                if isinstance(attach, InMemoryUploadedFile):
                    add_attach(attach)
        elif isinstance(attachment, InMemoryUploadedFile):
            add_attach(attachment)

    try:
        message.send()
    except SMTPRecipientsRefused:
        pass

    if settings.DEBUG:
        print u'To: %s' % ', '.join(message.to)
        print u'From: %s' % message.from_email
        print u'Subject: %s' % message.subject
        print message.body


def mail_admins(subject, message='', trace=True):
    if trace:
        exc_info = sys.exc_info()
        if exc_info:
            message += ("\n\n" if message else '') + ''.join(traceback.format_exception(*exc_info))
    django_mail_admins(subject, message, fail_silently=True)

########NEW FILE########
__FILENAME__ = middleware
# -*- coding: utf-8 -*-
import re

class StripWhitespace(object):
    """
    Strips leading and trailing whitespace from response content.
    """
    NEWLINE_RE = re.compile(r'>\s*\n\s*<')
    SPACES_RE = re.compile(r'>\s{2,}<')

    def process_response(self, request, response):
        if response['Content-Type'].startswith('text/html'):
            content = response.content
            content = self.NEWLINE_RE.sub('>\n<', content)
            content = self.SPACES_RE.sub('> <', content)
            response.content = content
        return response

########NEW FILE########
__FILENAME__ = fields
# -*- coding: utf-8 -*-
try:
    import cPickle as pickle
except ImportError:
    import pickle

import re, datetime
from django.db import models
from django import forms
from django.core import exceptions, validators
from django.utils.text import capfirst
from django.utils.translation import ugettext_lazy as _
from django.conf import settings

from handy.cross import json
from handy.forms import CommaSeparatedInput, MultilineInput
from handy.utils import get_module_attr


__all__ = ['AdditionalAutoField', 'AdditionalAutoFieldManager',
           'BigAutoField', 'IntegerArrayField', 'BigIntegerArrayField',
           'StringArrayField', 'BigIntegerField', 'JSONField']


class AdditionalAutoField(models.Field):
    """
    Дополнительный AutoField делает ещё одно auto поле не являющееся primary key
    Не поддерживается всеми бэкендами! viva la PostgreSQL :)

    Требуется использовать AdditionalAutoFieldManager в качестве базового менеджера, чтобы null не пропускались в базу:
        class MyModel(models.Model):
            _base_manager = AdditionalAutoFieldManager()
    """
    empty_strings_allowed = False
    def __init__(self, *args, **kwargs):
        kwargs['blank'] = True
        models.Field.__init__(self, *args, **kwargs)

    def get_internal_type(self):
        return "AutoField"

    def to_python(self, value):
        if value is None:
            return value
        try:
            return int(value)
        except (TypeError, ValueError):
            raise exceptions.ValidationError(
                _("This value must be an integer."))

    def get_db_prep_value(self, value):
        if value is None:
            return None
        return int(value)

    def contribute_to_class(self, cls, name):
        models.Field.contribute_to_class(self, cls, name)

    def formfield(self, **kwargs):
        if self.primary_key:
            return None
        defaults = {'form_class': forms.IntegerField, 'widget': forms.HiddenInput}
        defaults.update(kwargs)
        return models.Field.formfield(self, **defaults)


class AdditionalAutoFieldManager(models.Manager):
    def _insert(self, values, **kwargs):
        # Значение по умолчанию выставлется базой
        values = [v for v in values if v[1] is not None or not isinstance(v[0], AdditionalAutoField)]
        return super(AdditionalAutoFieldManager, self)._insert(values, **kwargs)


class BigAutoField(models.AutoField):
    def __init__(self, verbose_name=None, name=None, external_sequence=False, **kwargs):
        self.external_sequence = external_sequence
        models.AutoField.__init__(self, verbose_name, name, **kwargs)

    def db_type(self, connection):
        return 'bigint' if self.external_sequence else 'bigserial'

    # Использует патч ForeignKey
    def rel_db_type(self, connection):
        return 'bigint'


class UntypedMultipleField(forms.Field):
    def __init__(self, *args, **kwargs):
        self.coerce = kwargs.pop('coerce', lambda val: val)
        super(UntypedMultipleField, self).__init__(*args, **kwargs)


class TypedMultipleField(UntypedMultipleField):
    def to_python(self, value):
        value = super(TypedMultipleField, self).to_python(value)
        if value not in validators.EMPTY_VALUES:
            try:
                value = map(self.coerce, value)
            except (ValueError, TypeError):
                raise exceptions.ValidationError(self.error_messages['invalid'])
        return value

class TypedMultipleChoiceField(TypedMultipleField, forms.MultipleChoiceField):
    def validate(self, value):
        pass


class ArrayField(models.Field):
    def value_to_string(self, obj):
        return self.get_prep_value(self._get_val_from_obj(obj))

    def validate(self, value, model_instance):
        # Это по-большей части скопировано с Field.validate
        # К сожалению приходится копипастить т.к. там неправильно проверяется
        # принадлежность к choices для многозначных полей
        if not self.editable:
            return

        if value is None and not self.null:
            raise exceptions.ValidationError(self.error_messages['null'])

        if not self.blank and value in validators.EMPTY_VALUES:
            raise exceptions.ValidationError(self.error_messages['blank'])

        # TODO: validate choices

    def formfield(self, **kwargs):
        if self.choices:
            # Тоже скопипащено из Field.formfield
            defaults = {
                'choices': self.choices,
                'coerce': self.coerce,
                'required': not self.blank,
                'label': capfirst(self.verbose_name),
                'help_text': self.help_text,
                'widget': forms.CheckboxSelectMultiple
            }
            defaults.update(kwargs)
            return TypedMultipleChoiceField(**defaults)
        else:
            defaults = {
                'form_class': TypedMultipleField,
                'coerce': self.coerce,
                'widget': CommaSeparatedInput,
            }
            defaults.update(kwargs)
            return super(ArrayField, self).formfield(**defaults)


class IntegerArrayField(ArrayField):
    default_error_messages = {
        'invalid': _(u'Enter only digits separated by commas.')
    }
    description = _("Array of integers")
    coerce = int

    def db_type(self, connection):
        return 'int[]'

    def to_python(self, value):
        if value == '{}':
            return []

        if isinstance(value, (str, unicode)):
            return map(self.coerce, value[1:-1].split(','))

        return value

    def get_prep_value(self, value):
        return '{%s}' % ','.join(map(str, value))


class BigIntegerArrayField(IntegerArrayField):
    def db_type(self, connection):
        return 'bigint[]'

# Fix unicode arrays for postgresql_psycopg2 backend
try:
    import psycopg2
    psycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)
except ImportError:
    pass

class StringArrayField(ArrayField):
    description = _("Array of strings")
    coerce = unicode

    def __init__(self, verbose_name=None, **kwargs):
        kwargs.setdefault('max_length', 127)
        super(StringArrayField, self).__init__(verbose_name, **kwargs)

    def db_type(self, connection):
        return 'varchar(%s)[]' % self.max_length


# Функции для кодирования/декодирования объектов в json
def default_decode((cls, data)):
    cls = get_module_attr(cls)
    obj = cls.__new__(cls)
    obj.__dict__.update(data['__data__'])
    return obj

def encode_object(obj):
    if hasattr(obj, '__json__'):
        data = obj.__json__()
        if isinstance(data, tuple):
            decode, data = data
        else:
            decode = default_decode
            data = ('%s.%s' % (obj.__class__.__module__, obj.__class__.__name__), data)

        if callable(decode):
            decode = '%s.%s' % (decode.__module__, decode.__name__)

        return {
            '__decode__': decode,
            '__data__': data
        }
    else:
        return dict(__pickled__=pickle.dumps(obj))

def decode_object(d):
    if '__decode__' in d:
        return get_module_attr(d['__decode__'])(d['__data__'])
    elif '__pickled__' in d:
        return pickle.loads(str(d['__pickled__']))
    else:
        return d

class JSONField(models.TextField):
    """JSONField is a generic textfield that neatly serializes/unserializes
    JSON objects seamlessly"""
    __metaclass__ = models.SubfieldBase

    def to_python(self, value):
        """Convert our string value to JSON after we load it from the DB"""
        if value == "":
            return None

        try:
            if isinstance(value, basestring):
                return json.loads(value, object_hook=decode_object)
        except ValueError:
            pass

        return value

    def get_prep_value(self, value):
        """Convert our JSON object to a string before we save"""
        if value == "" or value is None:
            return None

        #if isinstance(value, dict):
        value = json.dumps(value, default=encode_object, ensure_ascii=False, separators=(',',':'))

        return super(JSONField, self).get_prep_value(value)

    def formfield(self, **kwargs):
        defaults = {
            'form_class': forms.Field,
        }
        defaults.update(kwargs)
        defaults['widget'] = JSONTextarea
        return super(JSONField, self).formfield(**defaults)


class JSONTextarea(forms.Textarea):
    def value_from_datadict(self, data, files, name):
        value = data.get(name, '').strip()
        if value in ['', None]:
            return {}
        return json.loads(value)

    def render(self, name, value, attrs=None):
        return super(JSONTextarea, self).render(name, json.dumps(value), attrs=attrs)



class BigIntegerField(models.IntegerField):
    def db_type(self):
        # только для mysql и postgres
        return "bigint"

    def get_internal_type(self):
        return "BigIntegerField"

    def to_python(self, value):
        if value is None:
            return value
        try:
            return long(value)
        except (TypeError, ValueError):
            raise exceptions.ValidationError(
                _("This value must be a long integer."))


# Прописываем правила для South, пустые так как новых, неунаследованных атрибутов у нас нет
try:
    from south.modelsinspector import add_introspection_rules
    rules = [
        ((BigAutoField, ), [], {"external_sequence": ["external_sequence", {"default": False}]}),
        ((StringArrayField, ), [], {"max_length": ["max_length", {}]}),
    ]
    add_introspection_rules(rules, ["^handy\.models\.fields\."])
except ImportError:
    pass

########NEW FILE########
__FILENAME__ = text
# -*- coding: utf-8 -*-
import re, string, random

from django.utils.safestring import mark_safe


def random_str(length=8, letters=string.ascii_letters + string.digits):
    """Generates random string of latin characters and digits"""
    return "".join(random.choice(letters) for x in range(length))


def formatnumber(value, splitter=' '):
    s = unicode(value)
    l = len(s)
    indexes = range(-(l + -l % 3), 0, 3)
    return mark_safe(splitter.join(s[i:i+3 or None] for i in indexes))


def formatnumber_html(value, splitter='<small>&nbsp;</small>'):
    return mark_safe(formatnumber(value, splitter))

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
from datetime import datetime
from functools import wraps
from django.utils.importlib import import_module


from django.db.models.fields.related import ForeignKey
ForeignKey.__dump__ = lambda self: 'ForeignKey(%s.%s -> %s.%s)' % (self.model, self.attname, self.rel.to, self.rel.field_name)

from django.db.models.sql.where import Constraint
Constraint.__dump__ = lambda self: 'Constraint(%s.%s)' % (self.alias, self.col)


def obj_dump(obj, indent=0, seen=None):
    if seen is None:
        seen = set()
    result = []
    if obj is None or isinstance(obj, (str, int, long, float, bool, dict, set, datetime)) or callable(obj):
        result.append(repr(obj))
    elif isinstance(obj, unicode):
        result.append("u'" + obj.encode('utf8') + "'")
    elif isinstance(obj, (list, tuple)) and not obj:
        result.append(repr(obj))
    elif hasattr(obj, '__dump__'):
        result.append(obj.__dump__())
    elif id(obj) in seen:
        result.append('<SEEN_OBJECT>')
    else:
        seen.add(id(obj))
        if isinstance(obj, (list, tuple)):
            result.append('[\n' if isinstance(obj, list) else '(\n')
            for item in obj:
                result.append('%s,' % obj_dump(item, indent=indent+4, seen=seen))
            result.append(']' if isinstance(obj, list) else ')')
        else:
            result.append(repr(obj) + '\n')
            for attr, value in obj.__dict__.iteritems():
                result.append('%s: %s,' % (attr, obj_dump(value, indent=indent+4, seen=seen)))

    result = result[0] + "\n".join(' ' * indent + i for i in result[1:])
    return result


def get_module_attr(path):
    """
    Возвращает атрибут модуля, переданный в виде строки 'module.other.AttrName'.
    Удобно для получения класса по строке импорта.
    При отсутствии атрибута возвращает None.
    """
    i = path.rfind('.')
    module, attr = path[:i], path[i+1:]
    try:
        mod = import_module(module)
        return getattr(mod, attr, None)
    except ImportError, e:
        return None


def cached_property(func):
    @property
    @wraps(func)
    def wrapper(self):
        attname = '_' + func.__name__
        if not hasattr(self, attname):
            setattr(self, attname, func(self))
        return getattr(self, attname)
    return wrapper


def get_or_none(cls, **cond):
    try:
        return cls.objects.get(**cond)
    except cls.DoesNotExist:
        return None

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

sys.path.insert(0, '.')


if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "tests.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = models
from django.db import models
from handy.models import StringArrayField


class Post(models.Model):
    tags = StringArrayField()

########NEW FILE########
__FILENAME__ = settings
INSTALLED_APPS = [
    'tests',
]

# Django replaces this, but it still wants it. *shrugs*
DATABASE_ENGINE = 'django.db.backends.postgresql_psycopg2',
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'handy',
        'USER': 'handy',
        'PASSWORD': '',
        'HOST': '',
        'PORT': '',
        # 'OPTIONS': {"autocommit": True},
    }
}

TIME_ZONE = 'Asia/Krasnoyarsk'

SECRET_KEY = 'abc'

########NEW FILE########
__FILENAME__ = test_db
import pytest

from handy.db import *


def pytestmark(func):
    pytest.mark.django_db(func)
    pytest.mark.usefixtures('test_table')(func)


@pytest.fixture(scope='module')
def test_table():
    # NOTE: We wrap that into transaction because in other case django will gobble it up
    #       into single transaction with first test and then rollback everything happily on
    #       that tests end.
    do_sql('''
        begin;

        create table test (
            id int primary key,
            tag int not null
        );
        insert into test values (1, 10), (2, 20);

        commit;
    ''')


def test_fetch_val():
    assert fetch_val('select min(id) from test') == 1

def test_fetch_col():
    assert fetch_col('select tag from test order by tag') == [10, 20]

def test_fetch_row():
    assert fetch_row('select * from test where id = 2') == (2, 20)

def test_fetch_all():
    assert fetch_all('select * from test order by id') == [(1, 10), (2, 20)]


def test_fetch_non_existent_row():
    assert fetch_row('select * from test where id < 0') is None

def test_fetch_non_existent_val():
    assert fetch_val('select tag from test where id < 0') is None


def test_fetch_named():
    rows = fetch_named('select * from test order by id')
    assert len(rows) == 2
    assert rows[0].id == 1 and rows[0].tag == 10
    assert rows[1].id == 2 and rows[1].tag == 20

def test_fetch_named_row():
    row = fetch_named_row('select * from test where id = 1')
    assert row == (1, 10)
    assert row.id == 1 and row.tag == 10

########NEW FILE########
__FILENAME__ = test_models
# -*- coding: utf-8 -*-
import pytest
pytestmark = pytest.mark.django_db


from .models import Post

def test_stringarray():
    post = Post.objects.create(tags=['django', 'cool'])
    assert Post.objects.get(pk=post.pk).tags == post.tags

def test_stringarray_ru():
    post = Post.objects.create(tags=[u'привет'])
    assert Post.objects.get(pk=post.pk).tags == post.tags

########NEW FILE########
