__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# flask-superadmin documentation build configuration file, created by
# sphinx-quickstart on Tue Nov 01 18:35:30 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'sphinx.ext.ifconfig', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'flask-superadmin'
copyright = u'2012, Syrus Akbary'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.0.1'
# The full version, including alpha/beta/rc tags.
release = '0.0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
sys.path.append(os.path.abspath('_themes'))

html_theme = 'flask'
html_theme_path = ['_themes']

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    'index': ['sidebarintro.html', 'sourcelink.html', 'searchbox.html'],
    '**': ['localtoc.html', 'relations.html',
           'sourcelink.html', 'searchbox.html']
}
# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'flask-superadmin'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'flask-superadmin', u'Flask-SuperAdmin documentation',
   u'Syrus Akbary', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'flask-superadmin', u'Flask-SuperAdmin documentation',
     [u'Syrus Akbary'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'flask-superadmin', u'Flask-SuperAdmin documentation',
   u'Syrus Akbary', 'Flask-SuperAdmin', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

# fall back if theme is not there
try:
    __import__('flask_theme_support')
except ImportError, e:
    print '-' * 74
    print 'Warning: Flask themes unavailable. Building with default theme'
    print 'If you want the Flask themes, run this command and build again:'
    print
    print ' git submodule update --init'
    print '-' * 74

    pygments_style = 'tango'
    html_theme = 'default'
    html_theme_options = {}

########NEW FILE########
__FILENAME__ = flask_theme_support
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        #Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",      # class: 'w'
        Error:                     "#a40000 border:#ef2929", # class: 'err'
        Other:                     "#000000",                # class 'x'

        Comment:                   "italic #8f5902", # class: 'c'
        Comment.Preproc:           "noitalic",       # class: 'cp'

        Keyword:                   "bold #004461",   # class: 'k'
        Keyword.Constant:          "bold #004461",   # class: 'kc'
        Keyword.Declaration:       "bold #004461",   # class: 'kd'
        Keyword.Namespace:         "bold #004461",   # class: 'kn'
        Keyword.Pseudo:            "bold #004461",   # class: 'kp'
        Keyword.Reserved:          "bold #004461",   # class: 'kr'
        Keyword.Type:              "bold #004461",   # class: 'kt'

        Operator:                  "#582800",   # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",        # class: 'n'
        Name.Attribute:            "#c4a000",        # class: 'na' - to be revised
        Name.Builtin:              "#004461",        # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",        # class: 'bp'
        Name.Class:                "#000000",        # class: 'nc' - to be revised
        Name.Constant:             "#000000",        # class: 'no' - to be revised
        Name.Decorator:            "#888",           # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",        # class: 'ni'
        Name.Exception:            "bold #cc0000",   # class: 'ne'
        Name.Function:             "#000000",        # class: 'nf'
        Name.Property:             "#000000",        # class: 'py'
        Name.Label:                "#f57900",        # class: 'nl'
        Name.Namespace:            "#000000",        # class: 'nn' - to be revised
        Name.Other:                "#000000",        # class: 'nx'
        Name.Tag:                  "bold #004461",   # class: 'nt' - like a keyword
        Name.Variable:             "#000000",        # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",        # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",        # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",        # class: 'vi' - to be revised

        Number:                    "#990000",        # class: 'm'

        Literal:                   "#000000",        # class: 'l'
        Literal.Date:              "#000000",        # class: 'ld'

        String:                    "#4e9a06",        # class: 's'
        String.Backtick:           "#4e9a06",        # class: 'sb'
        String.Char:               "#4e9a06",        # class: 'sc'
        String.Doc:                "italic #8f5902", # class: 'sd' - like a comment
        String.Double:             "#4e9a06",        # class: 's2'
        String.Escape:             "#4e9a06",        # class: 'se'
        String.Heredoc:            "#4e9a06",        # class: 'sh'
        String.Interpol:           "#4e9a06",        # class: 'si'
        String.Other:              "#4e9a06",        # class: 'sx'
        String.Regex:              "#4e9a06",        # class: 'sr'
        String.Single:             "#4e9a06",        # class: 's1'
        String.Symbol:             "#4e9a06",        # class: 'ss'

        Generic:                   "#000000",        # class: 'g'
        Generic.Deleted:           "#a40000",        # class: 'gd'
        Generic.Emph:              "italic #000000", # class: 'ge'
        Generic.Error:             "#ef2929",        # class: 'gr'
        Generic.Heading:           "bold #000080",   # class: 'gh'
        Generic.Inserted:          "#00A000",        # class: 'gi'
        Generic.Output:            "#888",           # class: 'go'
        Generic.Prompt:            "#745334",        # class: 'gp'
        Generic.Strong:            "bold #000000",   # class: 'gs'
        Generic.Subheading:        "bold #800080",   # class: 'gu'
        Generic.Traceback:         "bold #a40000",   # class: 'gt'
    }

########NEW FILE########
__FILENAME__ = auth
from flask import Flask, url_for, redirect, render_template, request
from flask.ext.sqlalchemy import SQLAlchemy

from flask.ext import superadmin, login, wtf
from flask.ext.superadmin.contrib import sqlamodel

# Create application
app = Flask(__name__)

# Create dummy secrey key so we can use sessions
app.config['SECRET_KEY'] = '123456790'

# Create in-memory database
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///test.sqlite'
app.config['SQLALCHEMY_ECHO'] = True
db = SQLAlchemy(app)


# Create user model. For simplicity, it will store passwords in plain text.
# Obviously that's not right thing to do in real world application.
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    login = db.Column(db.String(80), unique=True)
    email = db.Column(db.String(120))
    password = db.Column(db.String(64))

    # Flask-Login integration
    def is_authenticated(self):
        return True

    def is_active(self):
        return True

    def is_anonymous(self):
        return False

    def get_id(self):
        return self.id

    # Required for administrative interface
    def __unicode__(self):
        return self.username


# Define login and registration forms (for flask-login)
class LoginForm(wtf.Form):
    login = wtf.TextField(validators=[wtf.required()])
    password = wtf.PasswordField(validators=[wtf.required()])

    def validate_login(self, field):
        user = self.get_user()

        if user is None:
            raise wtf.ValidationError('Invalid user')

        if user.password != self.password.data:
            raise wtf.ValidationError('Invalid password')

    def get_user(self):
        return db.session.query(User).filter_by(login=self.login.data).first()


class RegistrationForm(wtf.Form):
    login = wtf.TextField(validators=[wtf.required()])
    email = wtf.TextField()
    password = wtf.PasswordField(validators=[wtf.required()])

    def validate_login(self, field):
        if db.session.query(User).filter_by(login=self.login.data).count() > 0:
            raise wtf.ValidationError('Duplicate username')


# Initialize flask-login
def init_login():
    login_manager = login.LoginManager()
    login_manager.setup_app(app)

    # Create user loader function
    @login_manager.user_loader
    def load_user(user_id):
        return db.session.query(User).get(user_id)


# Create customized model view class
class MyModelView(sqlamodel.ModelView):
    def is_accessible(self):
        return login.current_user.is_authenticated()


# Create customized index view class
class MyAdminIndexView(superadmin.AdminIndexView):
    def is_accessible(self):
        return login.current_user.is_authenticated()


# Flask views
@app.route('/')
def index():
    return render_template('index.html', user=login.current_user)


@app.route('/login/', methods=('GET', 'POST'))
def login_view():
    form = LoginForm(request.form)
    if form.validate_on_submit():
        user = form.get_user()
        login.login_user(user)
        return redirect(url_for('index'))

    return render_template('form.html', form=form)


@app.route('/register/', methods=('GET', 'POST'))
def register_view():
    form = RegistrationForm(request.form)
    if form.validate_on_submit():
        user = User()

        form.populate_obj(user)

        db.session.add(user)
        db.session.commit()

        login.login_user(user)
        return redirect(url_for('index'))

    return render_template('form.html', form=form)


@app.route('/logout/')
def logout_view():
    login.logout_user()
    return redirect(url_for('index'))

if __name__ == '__main__':
    # Initialize flask-login
    init_login()

    # Create admin
    admin = superadmin.Admin(app, 'Auth', index_view=MyAdminIndexView())

    # Add view
    admin.add_view(MyModelView(User, db.session))

    # Create DB
    db.create_all()

    # Start app
    app.debug = True
    app.run()

########NEW FILE########
__FILENAME__ = mongoauth
from flask import Flask, url_for, redirect, render_template, request
from mongoengine import *

from flask.ext import superadmin, login, wtf
from flask.ext.superadmin.contrib import mongoenginemodel

# Create application
app = Flask(__name__)

# Create dummy secrey key so we can use sessions
app.config['SECRET_KEY'] = '123456790'

# Database name for Mongo
app.config['DATABASE'] = 'dummy_db'


# Create user model. For simplicity, it will store passwords in plain text.
# Obviously that's not right thing to do in real world application.
class User(Document):
    id = StringField(primary_key=True)
    login = StringField(max_length=80, unique=True)
    email = EmailField(max_length=120)
    password = StringField(max_length=64)

    # Flask-Login integration
    def is_authenticated(self):
        return True

    def is_active(self):
        return True

    def is_anonymous(self):
        return False

    def get_id(self):
        return self.id

    # Required for administrative interface
    def __unicode__(self):
        return self.login


# Define login and registration forms (for flask-login)
class LoginForm(wtf.Form):
    login = wtf.TextField(validators=[wtf.required()])
    password = wtf.PasswordField(validators=[wtf.required()])

    def validate_login(self, field):
        user = self.get_user()

        if user is None:
            raise wtf.ValidationError('Invalid user')

        if user.password != self.password.data:
            raise wtf.ValidationError('Invalid password')

    def get_user(self):
        return User.objects.get(self.login)


class RegistrationForm(wtf.Form):
    login = wtf.TextField(validators=[wtf.required()])
    email = wtf.TextField()
    password = wtf.PasswordField(validators=[wtf.required()])

    def validate_login(self, field):
        if len(User.objects(login=self.login.data)) > 0:
            raise wtf.ValidationError('Duplicate username')


# Initialize flask-login
def init_login():
    login_manager = login.LoginManager()
    login_manager.setup_app(app)

    # Create user loader function
    @login_manager.user_loader
    def load_user(user_id):
        return User.objects.get(user_id)


# Create customized model view class
class MyModelView(mongoenginemodel.ModelView):
    def is_accessible(self):
        return login.current_user.is_authenticated()


# Create customized index view class
class MyAdminIndexView(superadmin.AdminIndexView):
    def is_accessible(self):
        return login.current_user.is_authenticated()


# Flask views
@app.route('/')
def index():
    return render_template('index.html', user=login.current_user)


@app.route('/login/', methods=('GET', 'POST'))
def login_view():
    form = LoginForm(request.form)
    if form.validate_on_submit():
        user = form.get_user()
        login.login_user(user)
        return redirect(url_for('index'))

    return render_template('form.html', form=form)


@app.route('/register/', methods=('GET', 'POST'))
def register_view():
    form = RegistrationForm(request.form)
    if form.validate_on_submit():
        user = User()

        form.populate_obj(user)
        user.id = user.login
        user.save()
        login.login_user(user)

        return redirect(url_for('index'))

    return render_template('form.html', form=form)


@app.route('/logout/')
def logout_view():
    login.logout_user()
    return redirect(url_for('index'))

if __name__ == '__main__':
    # Initialize flask-login
    init_login()

    # Mongoengine connection
    connect(app.config['DATABASE'])

    # Create admin
    admin = superadmin.Admin(app, 'Auth', index_view=MyAdminIndexView())

    # Add view
    admin.add_view(MyModelView(User))

    # Start app
    app.debug = True
    app.run()


########NEW FILE########
__FILENAME__ = simple
from flask import Flask, request, session
from flask.ext.sqlalchemy import SQLAlchemy

from flask.ext.superadmin import Admin, model
from flask.ext.babelex import Babel


# Create application
app = Flask(__name__)

# Create dummy secrey key so we can use sessions
app.config['SECRET_KEY'] = '12345678'

# Create in-memory database
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///test.sqlite'
app.config['SQLALCHEMY_ECHO'] = True
db = SQLAlchemy(app)

# Initialize babel
babel = Babel(app)


@babel.localeselector
def get_locale():
    override = request.args.get('lang')

    if override:
        session['lang'] = override

    return session.get('lang', 'en')


# Create models
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True)
    email = db.Column(db.String(120), unique=True)

    # Required for administrative interface
    def __unicode__(self):
        return self.username


class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(120))
    text = db.Column(db.Text, nullable=False)
    date = db.Column(db.DateTime)

    user_id = db.Column(db.Integer(), db.ForeignKey(User.id))
    user = db.relationship(User, backref='posts')

    def __unicode__(self):
        return self.title


# Flask views
@app.route('/')
def index():
    return '<a href="/admin/">Click me to get to Admin!</a>'

if __name__ == '__main__':
    # Create admin
    admin = Admin(app, 'Simple Models')

    admin.locale_selector(get_locale)

    # Add views
    admin.register(User, session=db.session)
    admin.register(Post, session=db.session)

    # Create DB
    db.create_all()

    # Start app
    app.debug = True
    app.run('0.0.0.0', 8000)

########NEW FILE########
__FILENAME__ = simple
from flask import Flask
from flask.ext.superadmin import Admin, model

from utils import install_models


#For using with django
from django.conf import settings

settings.configure(
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': 'mydatabase.sqlite',
        }
    }
)

from django.db import models

# Create application

app = Flask(__name__)

# Create dummy secrey key so we can use sessions
app.config['SECRET_KEY'] = '123456790'


class User(models.Model):
    class Meta:
        app_label = 'users'
    username = models.CharField(max_length=255,unique=True)
    email = models.CharField(max_length=255,unique=True)
    def __unicode__(self):
        return self.username


class Post(models.Model):
    class Meta:
        app_label = 'posts'
    title = models.CharField(max_length=255)
    text = models.TextField()
    date = models.DateField()
    user = models.ForeignKey(User)
    def __unicode__(self):
        return self.title


# Flask views
@app.route('/')
def index():
    return '<a href="/admin/">Click me to get to Admin!</a>'

    # Build the manifest of apps and models that are to be synchronized

if __name__ == '__main__':
    # Create admin
    admin = Admin(app, 'Simple Models')

    # Add views
    admin.register(User)
    admin.register(Post)

    # Create tables in database if not exists
    try:
        install_models(User,Post)
    except:
        pass

    # Start app
    app.debug = True
    app.run('0.0.0.0', 8000)

########NEW FILE########
__FILENAME__ = utils
def install_models(*all_models):
    from django.core.management.color import no_style
    from django.core.management.sql import custom_sql_for_model, emit_post_sync_signal
    from django.db import connections, router, transaction, models, DEFAULT_DB_ALIAS
    db = 'default'
    connection = connections[db]
    cursor = connection.cursor()
    style = no_style()
    # Get a list of already installed *models* so that references work right.
    tables = connection.introspection.table_names()
    seen_models = connection.introspection.installed_models(tables)
    created_models = set()
    pending_references = {}
    def model_installed(model):
        opts = model._meta
        converter = connection.introspection.table_name_converter
        return not ((converter(opts.db_table) in tables) or
            (opts.auto_created and converter(opts.auto_created._meta.db_table) in tables))

    for model in all_models:
        sql, references = connection.creation.sql_create_model(model, style, seen_models)
        seen_models.add(model)
        created_models.add(model)
        for refto, refs in references.items():
            pending_references.setdefault(refto, []).extend(refs)
            if refto in seen_models:
                sql.extend(connection.creation.sql_for_pending_references(refto, style, pending_references))
        sql.extend(connection.creation.sql_for_pending_references(model, style, pending_references))
        for statement in sql:
            cursor.execute(statement)
        tables.append(connection.introspection.table_name_converter(model._meta.db_table))

    transaction.commit_unless_managed(using=db)

########NEW FILE########
__FILENAME__ = file
import os
import os.path as op

from flask import Flask

from flask.ext import superadmin
from flask.ext.superadmin.contrib import fileadmin


# Create flask app
app = Flask(__name__, template_folder='templates', static_folder='files')

# Create dummy secrey key so we can use flash
app.config['SECRET_KEY'] = '123456790'


# Flask views
@app.route('/')
def index():
    return '<a href="/admin/">Click me to get to Admin!</a>'


if __name__ == '__main__':
    # Create directory
    path = op.join(op.dirname(__file__), 'files')
    try:
        os.mkdir(path)
    except OSError:
        pass

    # Create admin interface
    admin = superadmin.Admin(app)
    admin.add_view(fileadmin.FileAdmin(path, '/files/', name='Files'))

    # Start app
    app.debug = True
    app.run()

########NEW FILE########
__FILENAME__ = simple
from flask import Flask
from flask.ext.superadmin import Admin, model

try:
    from mongoengine import *
except ImportError:
    exit('You must have mongoengine installed. Install it with the command:\n\t$> easy_install mongoengine')

# Create application
app = Flask(__name__)

# Create dummy secret key so we can use sessions
app.config['SECRET_KEY'] = '123456790'

mongodb_settings = {
    'db':'test',
    # 'username':None,
    # 'password':None,
    # 'host':None,
    # 'port':None
}

# Connect to mongodb
connect(**mongodb_settings)


# Defining MongoEngine Documents

class User(Document):
    username = StringField(unique=True)
    email = StringField(unique=True)
    def __unicode__(self):
        return self.username

class ComplexEmbedded (EmbeddedDocument):
    complexstring = StringField()
    multiple_users = ListField(ReferenceField('User'))

class Post(Document):
    user = ReferenceField(User)
    tags = ListField(StringField())
    text = StringField()
    date = DateTimeField()
    complex = ListField(EmbeddedDocumentField(ComplexEmbedded))


# Flask views
@app.route('/')
def index():
    return '<a href="/admin/">Click me to get to Admin!</a>'

if __name__ == '__main__':
    
    # Create admin
    admin = Admin(app, 'Simple Models')

    class UserModel(model.ModelAdmin):
        list_display = ('username','email')
        # only = ('username',)

    # Register the models
    admin.register(User, UserModel)
    admin.register(Post)

    # Start app
    app.debug = True
    app.run('0.0.0.0', 8000)

########NEW FILE########
__FILENAME__ = first
from flask import Flask
from flask.ext.superadmin import Admin


app = Flask(__name__)

admin = Admin(app)
app.run()

########NEW FILE########
__FILENAME__ = second
from flask import Flask
from flask.ext.superadmin import Admin, BaseView, expose


class MyView(BaseView):
    @expose('/')
    def index(self):
        return self.render('index.html')

app = Flask(__name__)

admin = Admin(app)
admin.add_view(MyView(name='Hello'))

app.run()

########NEW FILE########
__FILENAME__ = third
from flask import Flask
from flask.ext.superadmin import Admin, BaseView, expose

class MyView(BaseView):
    @expose('/')
    def index(self):
        return self.render('index.html')

app = Flask(__name__)

admin = Admin(app)
admin.add_view(MyView(name='Hello 1', endpoint='test1', category='Test'))
admin.add_view(MyView(name='Hello 2', endpoint='test2', category='Test'))
admin.add_view(MyView(name='Hello 3', endpoint='test3', category='Test'))
app.run()

########NEW FILE########
__FILENAME__ = simple
from flask import Flask, render_template

from flask.ext import superadmin


# Create custom admin view
class MyAdminView(superadmin.BaseView):
    @superadmin.expose('/')
    def index(self):
        return self.render('myadmin.html')


class AnotherAdminView(superadmin.BaseView):
    @superadmin.expose('/')
    def index(self):
        return self.render('anotheradmin.html')

    @superadmin.expose('/test/')
    def test(self):
        return self.render('test.html')


# Create flask app
app = Flask(__name__, template_folder='templates')


# Flask views
@app.route('/')
def index():
    return '<a href="/admin/">Click me to get to Admin!</a>'


if __name__ == '__main__':
    # Create admin interface
    admin = superadmin.Admin()
    admin.add_view(MyAdminView(category='Test'))
    admin.add_view(AnotherAdminView(category='Test'))
    admin.init_app(app)

    # Start app
    app.debug = True
    app.run()

########NEW FILE########
__FILENAME__ = simple
from flask import Flask
from flask.ext.sqlalchemy import SQLAlchemy

from flask.ext import wtf
from flask.ext.superadmin import Admin, model

# Create application
app = Flask(__name__)

# Create dummy secrey key so we can use sessions
app.config['SECRET_KEY'] = '123456790'

# Create in-memory database
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///test.sqlite'
app.config['SQLALCHEMY_ECHO'] = True
db = SQLAlchemy(app)


# Create models
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True)
    email = db.Column(db.String(120), unique=True)

    # Required for administrative interface
    def __unicode__(self):
        return self.username


# Create M2M table
post_tags_table = db.Table('post_tags', db.Model.metadata,
                           db.Column('post_id', db.Integer, db.ForeignKey('post.id')),
                           db.Column('tag_id', db.Integer, db.ForeignKey('tag.id'))
                           )


class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(120))
    text = db.Column(db.Text, nullable=False)
    date = db.Column(db.DateTime)

    user_id = db.Column(db.Integer(), db.ForeignKey(User.id))
    user = db.relationship(User, backref='posts')

    tags = db.relationship('Tag', secondary=post_tags_table)

    def __unicode__(self):
        return self.title


class Tag(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.Unicode(64))

    def __unicode__(self):
        return self.name


# Flask views
@app.route('/')
def index():
    return '<a href="/admin/">Click me to get to Admin!</a>'


if __name__ == '__main__':
    # Create admin
    admin = Admin(app, 'Simple Models')

    # Add views
    admin.register(User, session=db.session)
    admin.register(Tag, session=db.session)
    admin.register(Post, session=db.session)
    # admin.add_view(sqlamodel.ModelView(Post, session=db.session))

    # Create DB
    db.create_all()

    # Start app
    app.debug = True
    app.run('0.0.0.0', 8000)

########NEW FILE########
__FILENAME__ = babel
try:
    try:
        from flask.ext.babelex import Domain
    except:
        from flask.ext.babel import Domain

    from flask.ext.superadmin import translations

    class CustomDomain(Domain):
        def __init__(self):
            super(CustomDomain, self).__init__(translations.__path__[0],
                  domain='admin')

        def get_translations_path(self, ctx):
            print ctx

            dirname = ctx.app.extensions['admin'].translations_path
            if dirname is not None:
                return dirname

            return super(CustomDomain, self).get_translations_path(ctx)

    domain = CustomDomain()

    gettext = domain.gettext
    ngettext = domain.ngettext
    lazy_gettext = domain.lazy_gettext
except ImportError:
    def gettext(string, **variables):
        return string % variables

    def ngettext(singular, plural, num, **variables):
        return (singular if num == 1 else plural) % variables

    def lazy_gettext(string, **variables):
        return gettext(string, **variables)

########NEW FILE########
__FILENAME__ = base
import re

from functools import wraps

from flask import Blueprint, render_template, url_for, abort

from flask_superadmin import babel


def expose(url='/', methods=('GET',)):
    """
        Use this decorator to expose views in your view classes.

        `url`
            Relative URL for the view
        `methods`
            Allowed HTTP methods. By default only GET is allowed.
    """
    def wrap(f):
        if not hasattr(f, '_urls'):
            f._urls = []
        f._urls.append((url, methods))
        return f

    return wrap


# Base views
def _wrap_view(f):
    @wraps(f)
    def inner(self, *args, **kwargs):
        h = self._handle_view(f.__name__, *args, **kwargs)

        if h is not None:
            return h

        return f(self, *args, **kwargs)

    return inner


class AdminViewMeta(type):
    """
        View metaclass.

        Does some precalculations (like getting list of view methods from the class) to avoid
        calculating them for each view class instance.
    """
    def __init__(cls, classname, bases, fields):
        type.__init__(cls, classname, bases, fields)

        # Gather exposed views
        cls._urls = []
        cls._default_view = None

        for p in dir(cls):
            attr = getattr(cls, p)

            if hasattr(attr, '_urls'):
                # Collect methods
                for url, methods in attr._urls:
                    cls._urls.append((url, p, methods))

                    if url == '/':
                        cls._default_view = p

                # Wrap views
                setattr(cls, p, _wrap_view(attr))


class BaseView(object):
    """
        Base administrative view.

        Derive from this class to implement your administrative interface piece. For example::

            class MyView(BaseView):
                @expose('/')
                def index(self):
                    return 'Hello World!'
    """
    __metaclass__ = AdminViewMeta

    def __init__(self, name=None, category=None, endpoint=None, url=None, static_folder=None):
        """
            Constructor.

            `name`
                Name of this view. If not provided, will be defaulted to the class name.
            `category`
                View category. If not provided, will be shown as a top-level menu item. Otherwise, will
                be in a submenu.
            `endpoint`
                Base endpoint name for the view. For example, if there's view method called "index" and
                endpoint was set to "myadmin", you can use `url_for('myadmin.index')` to get URL to the
                view method. By default, equals to the class name in lower case.
            `url`
                Base URL. If provided, affects how URLs are generated. For example, if url parameter
                equals to "test", resulting URL will look like "/admin/test/". If not provided, will
                use endpoint as a base url. However, if URL starts with '/', absolute path is assumed
                and '/admin/' prefix won't be applied.
        """
        self.name = name
        self.category = category
        self.endpoint = endpoint
        self.url = url
        self.static_folder = static_folder

        # Initialized from create_blueprint
        self.admin = None
        self.blueprint = None

        # Default view
        if self._default_view is None:
            raise Exception('Attempted to instantiate admin view %s without default view' % self.__class__.__name__)

    def create_blueprint(self, admin):
        """ Create Flask blueprint. """

        # Store admin instance
        self.admin = admin

        # If endpoint name is not provided, get it from the class name
        if self.endpoint is None:
            self.endpoint = self.__class__.__name__.lower()

        # If url is not provided, generate it from endpoint name
        if self.url is None:
            self.url = '%s/%s' % (self.admin.url, self.endpoint)
        else:
            if not self.url.startswith('/'):
                self.url = '%s/%s' % (self.admin.url, self.url)

        # If name is not povided, use capitalized endpoint name
        if self.name is None:
            self.name = self._prettify_name(self.__class__.__name__)

        # Create blueprint and register rules
        self.blueprint = Blueprint(self.endpoint, __name__,
                                   url_prefix=self.url,
                                   template_folder='templates',
                                   static_folder=self.static_folder)

        for url, name, methods in self._urls:
            self.blueprint.add_url_rule(url,
                                        name,
                                        getattr(self, name),
                                        methods=methods)

        return self.blueprint

    def render(self, template, **kwargs):
        """
            Render template

            `template`
                Template path to render
            `kwargs`
                Template arguments
        """
        # Store self as admin_view
        kwargs['admin_view'] = self

        # Provide i18n support even if flask-babel is not installed
        # or enabled.
        kwargs['_gettext'] = babel.gettext
        kwargs['_ngettext'] = babel.ngettext

        return render_template(template, **kwargs)

    def _prettify_name(self, name):
        """
            Prettify class name by splitting name by capital characters. So, 'MySuperClass' will look like 'My Super Class'

            `name`
                String to prettify
        """
        return re.sub(r'(?<=.)([A-Z])', r' \1', name)

    def is_accessible(self):
        """
            Override this method to add permission checks.

            Flask-SuperAdmin does not make any assumptions about authentication system used in your application, so it is
            up for you to implement it.

            By default, it will allow access for the everyone.
        """
        return True

    def _handle_view(self, name, *args, **kwargs):
        if not self.is_accessible():
            return abort(403)


class AdminIndexView(BaseView):
    """
        Default administrative interface index page when visiting the ``/admin/`` URL.

        It can be overridden by passing your own view class to the ``Admin`` constructor::

            class MyHomeView(AdminIndexView):
                @expose('/')
                def index(self):
                    return render_template('adminhome.html')

            admin = Admin(index_view=MyHomeView)

        Default values for the index page are following:

        * If name is not provided, 'Home' will be used.
        * If endpoint is not provided, will use ``admin``
        * Default URL route is ``/admin``.
        * Automatically associates with static folder.
    """
    def __init__(self, name=None, category=None, endpoint=None, url=None):
        super(AdminIndexView, self).__init__(name or babel.lazy_gettext('Home'),
                                             category,
                                             endpoint or 'admin',
                                             url or '/admin',
                                             'static')

    @expose('/')
    def index(self):
        return self.render('admin/index.html')


class MenuItem(object):
    """ Simple menu tree hierarchy. """

    def __init__(self, name, view=None):
        self.name = name
        self._view = view
        self._children = []
        self._children_urls = set()
        self._cached_url = None

        self.url = None
        if view is not None:
            self.url = view.url

    def add_child(self, view):
        self._children.append(view)
        self._children_urls.add(view.url)

    def get_url(self):
        if self._view is None:
            return None

        if self._cached_url:
            return self._cached_url

        self._cached_url = url_for('%s.%s' % (self._view.endpoint, self._view._default_view))
        return self._cached_url

    def is_active(self, view):
        if view == self._view:
            return True

        return view.url in self._children_urls

    def is_accessible(self):
        if self._view is None:
            return False

        return self._view.is_accessible()

    def is_category(self):
        return self._view is None

    def get_children(self):
        return [c for c in self._children if c.is_accessible()]


class Admin(object):
    """ Collection of the views. Also manages menu structure. """
    app = None

    def __init__(self, app=None, name=None, url=None, index_view=None,
                 translations_path=None):
        """
            Constructor.

            `app`
                Flask application object
            `name`
                Application name. Will be displayed in main menu and as a page title. If not provided, defaulted to "Admin"
            `index_view`
                Home page view to use. If not provided, will use `AdminIndexView`.
            `translations_path`
                Location of the translation message catalogs. By default will use translations
                shipped with the Flask-SuperAdmin.
        """
        self.translations_path = translations_path

        self._views = []
        self._menu = []
        self._menu_categories = dict()
        self._models = []
        self._model_backends = list()

        try:
            from flask_superadmin.model.backends import mongoengine
            self.add_model_backend(mongoengine.ModelAdmin)
        except:
            pass

        try:
            from flask_superadmin.model.backends import sqlalchemy
            self.add_model_backend(sqlalchemy.ModelAdmin)
        except:
            pass

        try:
            from flask_superadmin.model.backends import django
            self.add_model_backend(django.ModelAdmin)
        except:
            pass

        if name is None:
            name = 'Admin'
        self.name = name

        if url is None:
            url = '/admin'
        self.url = url

        # Localizations
        self.locale_selector_func = None

        # Add predefined index view
        self.index_view = index_view or AdminIndexView(url=self.url)
        self.add_view(self.index_view)

        if app is not None:
            self.init_app(app)

    def model_backend(self, model):
        for backend in self._model_backends:
            if backend.model_detect(model):
                return backend
        raise Exception('There is no backend for this model')

    def add_model_backend(self, backend):
        self._model_backends.append(backend)

    def register(self, model, admin_class=None, *args, **kwargs):
        """
            Register model to the collection.

            `model`
                Model to add.
            `admin_class`
                ModelAdmin class corresponding to model.
        """
        from flask_superadmin.model import ModelAdmin

        admin_class = admin_class or ModelAdmin

        backend = self.model_backend(model)
        new_class = type(admin_class.__name__, (admin_class, backend), {})
        model_view = new_class(model, *args, **kwargs)

        self._models.append((model, model_view))
        self.add_view(model_view)

    def add_view(self, view):
        """
            Add view to the collection.

            `view`
                View to add.
        """
        # Add to views
        self._views.append(view)

        # If app was provided in constructor, register view with Flask app
        if self.app is not None:
            self.app.register_blueprint(view.create_blueprint(self))
            self._add_view_to_menu(view)

    def locale_selector(self, f):
        """
            Installs locale selector for current ``Admin`` instance.

            Example::

                def admin_locale_selector():
                    return request.args.get('lang', 'en')

                admin = Admin(app)
                admin.locale_selector(admin_locale_selector)

            It is also possible to use the ``@admin`` decorator::

                admin = Admin(app)

                @admin.locale_selector
                def admin_locale_selector():
                    return request.args.get('lang', 'en')

            Or by subclassing the ``Admin``::

                class MyAdmin(Admin):
                    def locale_selector(self):
                        return request.args.get('lang', 'en')
        """
        if self.locale_selector_func is not None:
            raise Exception('Can not add locale_selector second time.')

        self.locale_selector_func = f

    def _add_view_to_menu(self, view):
        """
            Add view to the menu tree

            `view`
                View to add
        """
        if view.category:
            category = self._menu_categories.get(view.category)

            if category is None:
                category = MenuItem(view.category)
                self._menu_categories[view.category] = category
                self._menu.append(category)

            category.add_child(MenuItem(view.name, view))
        else:
            self._menu.append(MenuItem(view.name, view))

    def init_app(self, app):
        """
            Register all views with Flask application.

            `app`
                Flask application instance
        """
        self.app = app

        app.extensions = getattr(app, 'extensions', {})
        app.extensions['admin'] = self

        for view in self._views:
            app.register_blueprint(view.create_blueprint(self))
            self._add_view_to_menu(view)

    def menu(self):
        """ Return menu hierarchy. """
        return self._menu

########NEW FILE########
__FILENAME__ = djangomodel
from flask_superadmin.contrib import DeprecatedModelView

from flask_superadmin.model.backends.django import ModelAdmin


class ModelView(DeprecatedModelView, ModelAdmin):
    pass

########NEW FILE########
__FILENAME__ = fileadmin
import os
import os.path as op
import platform
import urlparse
import re
import shutil

from operator import itemgetter

from werkzeug import secure_filename

from flask import flash, url_for, redirect, abort, request

from flask_superadmin.base import BaseView, expose
from flask_superadmin.babel import gettext, lazy_gettext
from flask_superadmin import form
from flask_wtf.file import FileField
from wtforms import TextField, ValidationError


class NameForm(form.BaseForm):
    """
        Form with a filename input field.

        Validates if provided name is valid for *nix and Windows systems.
    """
    name = TextField()

    regexp = re.compile(r'^(?!^(PRN|AUX|CLOCK\$|NUL|CON|COM\d|LPT\d|\..*)'
                        r'(\..+)?$)[^\x00-\x1f\\?*:\";|/]+$')

    def validate_name(self, field):
        if not self.regexp.match(field.data):
            raise ValidationError(gettext('Invalid directory name'))


class UploadForm(form.BaseForm):
    """
        File upload form. Works with FileAdmin instance to check if it
        is allowed to upload file with given extension.
    """
    upload = FileField(lazy_gettext('File to upload'))

    def __init__(self, admin):
        self.admin = admin

        super(UploadForm, self).__init__()

    def validate_upload(self, field):
        if not self.upload.has_file():
            raise ValidationError(gettext('File required.'))

        filename = self.upload.data.filename

        if not self.admin.is_file_allowed(filename):
            raise ValidationError(gettext('Invalid file type.'))


class FileAdmin(BaseView):
    """
        Simple file-management interface.

        Requires two parameters:

        `path`
            Path to the directory which will be managed
        `url`
            Base URL for the directory. Will be used to generate
            static links to the files.

        Sample usage::

            admin = Admin()

            path = op.join(op.dirname(__file__), 'static')
            admin.add_view(FileAdmin(path, '/static/', name='Static Files'))
            admin.setup_app(app)
    """

    can_upload = True
    """
        Is file upload allowed.
    """

    can_delete = True
    """
        Is file deletion allowed.
    """

    can_delete_dirs = True
    """
        Is recursive directory deletion is allowed.
    """

    can_mkdir = True
    """
        Is directory creation allowed.
    """

    can_rename = True
    """
        Is file and directory renaming allowed.
    """

    allowed_extensions = None
    """
        List of allowed extensions for uploads, in lower case.

        Example::

            class MyAdmin(FileAdmin):
                allowed_extensions = ('swf', 'jpg', 'gif', 'png')
    """

    list_template = 'admin/file/list.html'
    """
        File list template
    """

    upload_template = 'admin/file/form.html'
    """
        File upload template
    """

    mkdir_template = 'admin/file/form.html'
    """
        Directory creation (mkdir) template
    """

    rename_template = 'admin/file/rename.html'
    """
        Rename template
    """

    def __init__(self, base_path, base_url,
                 name=None, category=None, endpoint=None, url=None):
        """
            Constructor.

            `base_path`
                Base file storage location
            `base_url`
                Base URL for the files
            `name`
                Name of this view. If not provided,
                will be defaulted to the class name.
            `category`
                View category
            `endpoint`
                Endpoint name for the view
            `url`
                URL for view
        """
        self.base_path = base_path
        self.base_url = base_url

        self._on_windows = platform.system() == 'Windows'

        # Convert allowed_extensions to set for quick validation
        if (self.allowed_extensions
                and not isinstance(self.allowed_extensions, set)):
            self.allowed_extensions = set(self.allowed_extensions)

        super(FileAdmin, self).__init__(name, category, endpoint, url)

    def is_accessible_path(self, path):
        """
            Verify if path is accessible for current user.

            Override to customize behavior.

            `path`
                Relative path to the root
        """
        return True

    def get_base_path(self):
        """
            Return base path. Override to customize behavior (per-user
            directories, etc)
        """
        return op.normpath(self.base_path)

    def get_base_url(self):
        """
            Return base URL. Override to customize behavior (per-user
            directories, etc)
        """
        return self.base_url

    def is_file_allowed(self, filename):
        """
            Verify if file can be uploaded.

            Override to customize behavior.

            `filename`
                Source file name
        """
        ext = op.splitext(filename)[1].lower()

        if ext.startswith('.'):
            ext = ext[1:]

        if self.allowed_extensions and ext not in self.allowed_extensions:
            return False

        return True

    def is_in_folder(self, base_path, directory):
        """
            Verify if `directory` is in `base_path` folder
        """
        return op.normpath(directory).startswith(base_path)

    def save_file(self, path, file_data):
        """
            Save uploaded file to the disk

            `path`
                Path to save to
            `file_data`
                Werkzeug `FileStorage` object
        """
        file_data.save(path)

    def _get_dir_url(self, endpoint, path, **kwargs):
        """
            Return prettified URL

            `endpoint`
                Endpoint name
            `path`
                Directory path
            `kwargs`
                Additional arguments
        """
        if not path:
            return url_for(endpoint)
        else:
            if self._on_windows:
                path = path.replace('\\', '/')

            kwargs['path'] = path

            return url_for(endpoint, **kwargs)

    def _get_file_url(self, path):
        """
            Return static file url

            `path`
                Static file path
        """
        base_url = self.get_base_url()
        return urlparse.urljoin(base_url, path)

    def _normalize_path(self, path):
        """
            Verify and normalize path.

            If path is not relative to the base directory,
            will throw 404 exception.

            If path does not exist, will also throw 404 exception.
        """
        base_path = self.get_base_path()

        if path is None:
            directory = base_path
            path = ''
        else:
            path = op.normpath(path)
            directory = op.normpath(op.join(base_path, path))

            if not self.is_in_folder(base_path, directory):
                abort(404)

        if not op.exists(directory):
            abort(404)

        return base_path, directory, path

    def field_name(self, text):
        return text.capitalize()

    def get_readonly_fields(self, instance):
        return {}

    @expose('/')
    @expose('/b/<path:path>')
    def index(self, path=None):
        """
            Index view method

            `path`
                Optional directory path. If not provided,
                will use base directory
        """
        # Get path and verify if it is valid
        base_path, directory, path = self._normalize_path(path)

        # Get directory listing
        items = []

        # Parent directory
        if directory != base_path:
            parent_path = op.normpath(op.join(path, '..'))
            if parent_path == '.':
                parent_path = None

            items.append(('..', parent_path, True, 0))

        for f in os.listdir(directory):
            fp = op.join(directory, f)

            items.append((f, op.join(path, f), op.isdir(fp), op.getsize(fp)))

        # Sort by type
        items.sort(key=itemgetter(2), reverse=True)

        # Generate breadcrumbs
        accumulator = []
        breadcrumbs = []
        for n in path.split(os.sep):
            accumulator.append(n)
            breadcrumbs.append((n, op.join(*accumulator)))

        return self.render(self.list_template,
                           dir_path=path,
                           breadcrumbs=breadcrumbs,
                           get_dir_url=self._get_dir_url,
                           get_file_url=self._get_file_url,
                           items=items,
                           base_path=base_path)

    @expose('/upload/', methods=('GET', 'POST'))
    @expose('/upload/<path:path>', methods=('GET', 'POST'))
    def upload(self, path=None):
        """
            Upload view method

            `path`
                Optional directory path. If not provided,
                will use base directory
        """
        # Get path and verify if it is valid
        base_path, directory, path = self._normalize_path(path)

        if not self.can_upload:
            flash(gettext('File uploading is disabled.'), 'error')
            return redirect(self._get_dir_url('.index', path))

        form = UploadForm(self)
        if form.validate_on_submit():
            filename = op.join(directory,
                               secure_filename(form.upload.data.filename))

            if op.exists(filename):
                flash(gettext('File "%(name)s" already exists.',
                              name=form.upload.data.filename), 'error')
            else:
                try:
                    self.save_file(filename, form.upload.data)
                    return redirect(self._get_dir_url('.index', path))
                except Exception, ex:
                    flash(gettext('Failed to save file: %(error)s', error=ex))

        return self.render(self.upload_template,
                           form=form,
                           base_path=base_path,
                           path=path,
                           msg=gettext(u'Upload a file'))

    @expose('/mkdir/', methods=('GET', 'POST'))
    @expose('/mkdir/<path:path>', methods=('GET', 'POST'))
    def mkdir(self, path=None):
        """
            Directory creation view method

            `path`
                Optional directory path. If not provided,
                will use base directory
        """
        # Get path and verify if it is valid
        base_path, directory, path = self._normalize_path(path)

        dir_url = self._get_dir_url('.index', path)

        if not self.can_mkdir:
            flash(gettext('Directory creation is disabled.'), 'error')
            return redirect(dir_url)

        form = NameForm(request.form)

        if form.validate_on_submit():
            try:
                os.mkdir(op.join(directory, form.name.data))
                return redirect(dir_url)
            except Exception, ex:
                flash(gettext('Failed to create directory: %(error)s', ex),
                      'error')

        return self.render(self.mkdir_template,
                           form=form,
                           dir_url=dir_url,
                           base_path=base_path,
                           path=path,
                           msg=gettext(u'Create a new directory'))

    @expose('/delete/', methods=('POST',))
    def delete(self):
        """
            Delete view method
        """
        path = request.form.get('path')

        if not path:
            return redirect(url_for('.index'))

        # Get path and verify if it is valid
        base_path, full_path, path = self._normalize_path(path)

        return_url = self._get_dir_url('.index', op.dirname(path))

        if not self.can_delete:
            flash(gettext('Deletion is disabled.'))
            return redirect(return_url)

        if op.isdir(full_path):
            if not self.can_delete_dirs:
                flash(gettext('Directory deletion is disabled.'))
                return redirect(return_url)

            try:
                shutil.rmtree(full_path)
                flash(
                    gettext('Directory "%s" was successfully deleted.' % path)
                )
            except Exception, ex:
                flash(
                    gettext('Failed to delete directory: %(error)s', error=ex),
                    'error'
                )
        else:
            try:
                os.remove(full_path)
                flash(gettext('File "%(name)s" was successfully deleted.',
                              name=path))
            except Exception, ex:
                flash(gettext('Failed to delete file: %(name)s',
                              name=ex), 'error')

        return redirect(return_url)

    @expose('/rename/', methods=('GET', 'POST'))
    def rename(self):
        """
            Rename view method
        """
        path = request.args.get('path')

        if not path:
            return redirect(url_for('.index'))

        base_path, full_path, path = self._normalize_path(path)

        return_url = self._get_dir_url('.index', op.dirname(path))

        if not self.can_rename:
            flash(gettext('Renaming is disabled.'))
            return redirect(return_url)

        if not op.exists(full_path):
            flash(gettext('Path does not exist.'))
            return redirect(return_url)

        form = NameForm(request.form, name=op.basename(path))
        if form.validate_on_submit():
            try:
                dir_base = op.dirname(full_path)
                filename = secure_filename(form.name.data)

                os.rename(full_path, op.join(dir_base, filename))
                flash(gettext('Successfully renamed "%(src)s" to "%(dst)s"',
                      src=op.basename(path),
                      dst=filename))
            except Exception, ex:
                flash(gettext('Failed to rename: %(error)s',
                              error=ex), 'error')

            return redirect(return_url)

        return self.render(self.rename_template,
                           form=form,
                           path=op.dirname(path),
                           name=op.basename(path),
                           dir_url=return_url,
                           base_path=base_path)

########NEW FILE########
__FILENAME__ = mongoenginemodel
from flask_superadmin.contrib import DeprecatedModelView

from flask_superadmin.model.backends.mongoengine import ModelAdmin


class ModelView(DeprecatedModelView, ModelAdmin):
    pass

########NEW FILE########
__FILENAME__ = sqlamodel
from flask_superadmin.contrib import DeprecatedModelView

from flask_superadmin.model.backends.sqlalchemy import ModelAdmin


class ModelView(DeprecatedModelView, ModelAdmin):
    pass

########NEW FILE########
__FILENAME__ = form
import time
import datetime

from flask.ext import wtf
from wtforms import fields, widgets

from flask_superadmin.babel import gettext
from flask import request

class BaseForm(wtf.Form):
    """
        Customized form class.
    """
    def __init__(self, formdata=None, obj=None, prefix='', **kwargs):
        if formdata:
            super(BaseForm, self).__init__(formdata, obj, prefix, **kwargs)
        else:
            super(BaseForm, self).__init__(obj=obj, prefix=prefix, **kwargs)

        self._obj = obj

    @property
    def has_file_field(self):
        """
            Return True if form contains at least one FileField.
        """
        # TODO: Optimize me
        for f in self:
            if isinstance(f, fields.FileField):
                return True

        return False


class TimeField(fields.Field):
    """
        A text field which stores a `datetime.time` object.
        Accepts time string in multiple formats: 20:10, 20:10:00, 10:00 am, 9:30pm, etc.
    """
    widget = widgets.TextInput()

    def __init__(self, label=None, validators=None, formats=None, **kwargs):
        """
            Constructor

            `label`
                Label
            `validators`
                Field validators
            `formats`
                Supported time formats, as a enumerable.
            `kwargs`
                Any additional parameters
        """
        super(TimeField, self).__init__(label, validators, **kwargs)

        self.formats = formats or ('%H:%M:%S', '%H:%M',
                                  '%I:%M:%S%p', '%I:%M%p',
                                  '%I:%M:%S %p', '%I:%M %p')

    def _value(self):
        if self.raw_data:
            return u' '.join(self.raw_data)
        else:
            return self.data and self.data.strftime(self.formats[0]) or u''

    def process_formdata(self, valuelist):
        if valuelist:
            date_str = u' '.join(valuelist)

            for format in self.formats:
                try:
                    timetuple = time.strptime(date_str, format)
                    self.data = datetime.time(timetuple.tm_hour,
                                              timetuple.tm_min,
                                              timetuple.tm_sec)
                    return
                except ValueError:
                    pass

            raise ValueError(gettext('Invalid time format'))


class ChosenSelectWidget(widgets.Select):
    """
        `Chosen <http://harvesthq.github.com/chosen/>`_ styled select widget.

        You must include chosen.js and form.js for styling to work.
    """
    def __call__(self, field, **kwargs):
        if getattr(field, 'allow_blank', False) and not self.multiple:
            kwargs['data-role'] = u'chosenblank'
        else:
            kwargs['data-role'] = u'chosen'

        return super(ChosenSelectWidget, self).__call__(field, **kwargs)


class ChosenSelectField(fields.SelectField):
    """
        `Chosen <http://harvesthq.github.com/chosen/>`_ styled select field.

        You must include chosen.js and form.js for styling to work.
    """
    widget = ChosenSelectWidget

class FileFieldWidget(object):
    # widget_file = widgets.FileInput()
    widget_checkbox = widgets.CheckboxInput()
    def __call__(self, field, **kwargs):
        from cgi import escape
        input_file = '<input %s>' % widgets.html_params(name=field.name, type='file')
        return widgets.HTMLString('%s<br />Current: %s<br />%s <label for="%s">Clear file</label>'%(input_file, escape(field._value()), self.widget_checkbox(field._clear), field._clear.id))

class FileField(fields.FileField):
    widget = FileFieldWidget()
    def __init__(self,*args,**kwargs):
        self.clearable = kwargs.pop('clearable', True)
        super(FileField, self).__init__(*args, **kwargs)
        self._prefix = kwargs.get('_prefix', '')
        self.clear_field = fields.BooleanField(default=False)
        if self.clearable:
            self._clear_name = '%s-clear'%self.short_name
            self._clear_id = '%s-clear'%self.id
            self._clear = self.clear_field.bind(form=None, name=self._clear_name, prefix=self._prefix, id=self._clear_id)

    def process(self, formdata, data=fields._unset_value):
        super(FileField, self).process(formdata, data)
        if self.clearable:
            self._clear.process(formdata, data)
            self._clear.checked = False

    @property
    def clear(self):
        return (not self.clearable) or self._clear.data

    @property
    def data(self):
        data = self._data
        if data is not None:
            data.clear = self.clear
        return data

    @data.setter
    def data(self, data):
        self._data = data


class DatePickerWidget(widgets.TextInput):
    """
        Date picker widget.

        You must include bootstrap-datepicker.js and form.js for styling to work.
    """
    def __call__(self, field, **kwargs):
        kwargs['data-role'] = u'datepicker'
        return super(DatePickerWidget, self).__call__(field, **kwargs)


class DateTimePickerWidget(widgets.TextInput):
    """
        Datetime picker widget.

        You must include bootstrap-datepicker.js and form.js for styling to work.
    """
    def __call__(self, field, **kwargs):
        kwargs['data-role'] = u'datetimepicker'
        return super(DateTimePickerWidget, self).__call__(field, **kwargs)

# def format_form(form):
#     for field in form:
#         if isinstance(field,fields.SelectField):
#             field.widget = ChosenSelectWidget(multiple=field.widget.multiple)
#         elif isinstance(field, fields.DateTimeField):
#             field.widget = DatePickerWidget()
#         elif isinstance(field, fields.FormField):
#             format_form(field.form)
#     return form
#         # elif isinstance(field, fields.FieldList):
#         #     for f in field.entries: format_form

########NEW FILE########
__FILENAME__ = fields
# """
# Useful form fields for use with the Django ORM.
# """
# from __future__ import unicode_literals

# import operator

# from wtforms import widgets
# from wtforms.fields import SelectFieldBase
# from wtforms.validators import ValidationError


# __all__ = (
#     'ModelSelectField', 'QuerySetSelectField',
# )


# class QuerySetSelectField(SelectFieldBase):
#     """
#     Given a QuerySet either at initialization or inside a view, will display a
#     select drop-down field of choices. The `data` property actually will
#     store/keep an ORM model instance, not the ID. Submitting a choice which is
#     not in the queryset will result in a validation error.

#     Specify `get_label` to customize the label associated with each option. If
#     a string, this is the name of an attribute on the model object to use as
#     the label text. If a one-argument callable, this callable will be passed
#     model instance and expected to return the label text. Otherwise, the model
#     object's `__str__` or `__unicode__` will be used.

#     If `allow_blank` is set to `True`, then a blank choice will be added to the
#     top of the list. Selecting this choice will result in the `data` property
#     being `None`.  The label for the blank choice can be set by specifying the
#     `blank_text` parameter.
#     """
#     widget = widgets.Select()

#     def __init__(self, label=None, validators=None, queryset=None, get_label=None, allow_blank=False, blank_text='', **kwargs):
#         super(QuerySetSelectField, self).__init__(label, validators, **kwargs)
#         self.allow_blank = allow_blank
#         self.blank_text = blank_text
#         self._set_data(None)
#         if queryset is not None:
#             self.queryset = queryset.all() # Make sure the queryset is fresh

#         if get_label is None:
#             self.get_label = lambda x: x
#         elif isinstance(get_label, (string,basestring)):
#             self.get_label = operator.attrgetter(get_label)
#         else:
#             self.get_label = get_label

#     def _get_data(self):
#         if self._formdata is not None:
#             for obj in self.queryset:
#                 if obj.pk == self._formdata:
#                     self._set_data(obj)
#                     break
#         return self._data

#     def _set_data(self, data):
#         self._data = data
#         self._formdata = None

#     data = property(_get_data, _set_data)

#     def iter_choices(self):
#         if self.allow_blank:
#             yield ('__None', self.blank_text, self.data is None)

#         for obj in self.queryset:
#             yield (obj.pk, self.get_label(obj), obj == self.data)

#     def process_formdata(self, valuelist):
#         if valuelist:
#             if valuelist[0] == '__None':
#                 self.data = None
#             else:
#                 self._formdata = int(valuelist[0])

#     def pre_validate(self, form):
#         if not self.allow_blank or self.data is not None:
#             for obj in self.queryset:
#                 if self.data == obj:
#                     break
#             else:
#                 raise ValidationError(self.gettext('Not a valid choice'))


# class ModelSelectField(QuerySetSelectField):
#     """
#     Like a QuerySetSelectField, except takes a model class instead of a
#     queryset and lists everything in it.
#     """
#     def __init__(self, label=None, validators=None, model=None, **kwargs):
#         super(ModelSelectField, self).__init__(label, validators, queryset=model._default_manager.all(), **kwargs)
########NEW FILE########
__FILENAME__ = orm
"""
Tools for generating forms based on Django Model schemas.
"""

from wtforms import fields as f
from wtforms import Form
from wtforms import validators
from wtforms.ext.django.fields import ModelSelectField

from flask_superadmin import form

__all__ = (
    'AdminModelConverter', 'model_fields', 'model_form'
)


class ModelConverterBase(object):
    def __init__(self, converters):
        self.converters = converters

    def convert(self, model, field, field_args):
        kwargs = {
            'label': field.verbose_name,
            'description': field.help_text,
            'validators': [],
            'filters': [],
            'default': field.default,
        }
        if field_args:
            kwargs.update(field_args)

        if field.blank:
            kwargs['validators'].append(validators.Optional())
        if field.max_length is not None and field.max_length > 0:
            kwargs['validators'].append(validators.Length(max=field.max_length))

        ftype = type(field).__name__
        if field.choices:
            kwargs['choices'] = field.choices
            return f.SelectField(widget=form.ChosenSelectWidget(), **kwargs)
        elif ftype in self.converters:
            return self.converters[ftype](model, field, kwargs)
        else:
            converter = getattr(self, 'conv_%s' % ftype, None)
            if converter is not None:
                return converter(model, field, kwargs)


class AdminModelConverter(ModelConverterBase):
    DEFAULT_SIMPLE_CONVERSIONS = {
        f.IntegerField: ['AutoField', 'IntegerField', 'SmallIntegerField',
                         'PositiveIntegerField', 'PositiveSmallIntegerField'],
        f.DecimalField: ['DecimalField', 'FloatField'],
        f.FileField: ['FileField', 'FilePathField', 'ImageField'],
        f.BooleanField: ['BooleanField'],
        f.TextField: ['CharField', 'PhoneNumberField', 'SlugField'],
        f.TextAreaField: ['TextField', 'XMLField'],
    }

    def __init__(self, extra_converters=None, simple_conversions=None):
        converters = {}
        if simple_conversions is None:
            simple_conversions = self.DEFAULT_SIMPLE_CONVERSIONS
        for field_type, django_fields in simple_conversions.iteritems():
            converter = self.make_simple_converter(field_type)
            for name in django_fields:
                converters[name] = converter

        if extra_converters:
            converters.update(extra_converters)
        super(AdminModelConverter, self).__init__(converters)

    def make_simple_converter(self, field_type):
        def _converter(model, field, kwargs):
            return field_type(**kwargs)
        return _converter

    def conv_ForeignKey(self, model, field, kwargs):
        return ModelSelectField(widget=form.ChosenSelectWidget(),
                                model=field.rel.to, **kwargs)

    def conv_TimeField(self, model, field, kwargs):
        def time_only(obj):
            try:
                return obj.time()
            except AttributeError:
                return obj
        kwargs['filters'].append(time_only)
        return f.DateTimeField(widget=form.DateTimePickerWidget(),
                               format='%H:%M:%S', **kwargs)

    def conv_DateTimeField(self, model, field, kwargs):
        def time_only(obj):
            try:
                return obj.time()
            except AttributeError:
                return obj
        kwargs['filters'].append(time_only)
        return f.DateTimeField(widget=form.DateTimePickerWidget(),
                               format='%H:%M:%S', **kwargs)

    def conv_DateField(self, model, field, kwargs):
        def time_only(obj):
            try:
                return obj.date()
            except AttributeError:
                return obj
        kwargs['filters'].append(time_only)
        return f.DateField(widget=form.DatePickerWidget(), **kwargs)

    def conv_EmailField(self, model, field, kwargs):
        kwargs['validators'].append(validators.email())
        return f.TextField(**kwargs)

    def conv_IPAddressField(self, model, field, kwargs):
        kwargs['validators'].append(validators.ip_address())
        return f.TextField(**kwargs)

    def conv_URLField(self, model, field, kwargs):
        kwargs['validators'].append(validators.url())
        return f.TextField(**kwargs)

    def conv_USStateField(self, model, field, kwargs):
        try:
            from django.contrib.localflavor.us.us_states import STATE_CHOICES
        except ImportError:
            STATE_CHOICES = []

        return f.SelectField(choices=STATE_CHOICES, **kwargs)

    def conv_NullBooleanField(self, model, field, kwargs):
        def coerce_nullbool(value):
            d = {'None': None, None: None, 'True': True, 'False': False}
            if value in d:
                return d[value]
            else:
                return bool(int(value))

        choices = ((None, 'Unknown'), (True, 'Yes'), (False, 'No'))
        return f.SelectField(choices=choices, coerce=coerce_nullbool, **kwargs)


def model_fields(model, fields=None, readonly_fields=None, exclude=None,
                 field_args=None, converter=None):
    """
    Generate a dictionary of fields for a given Django model.

    See `model_form` docstring for description of parameters.
    """
    converter = converter or ModelConverter()
    field_args = field_args or {}

    model_fields = ((f.name, f) for f in model._meta.fields)
    if fields:
        model_fields = (x for x in model_fields if x[0] in fields)
    elif exclude:
        model_fields = (x for x in model_fields if x[0] not in exclude)

    field_dict = {}
    for name, model_field in model_fields:
        field = converter.convert(model, model_field, field_args.get(name))
        if field is not None:
            field_dict[name] = field

    return field_dict


def model_form(model, base_class=Form, fields=None, readonly_fields=None,
               exclude=None, field_args=None, converter=None):
    """
    Create a wtforms Form for a given Django model class::

        from wtforms.ext.django.orm import model_form
        from myproject.myapp.models import User
        UserForm = model_form(User)

    :param model:
        A Django ORM model class
    :param base_class:
        Base form class to extend from. Must be a ``wtforms.Form`` subclass.
    :param fields:
        An optional iterable with the property names that should be included
        in the form. Only these properties will have fields. It also
        determines the order of the fields.
    :param exclude:
        An optional iterable with the property names that should be excluded
        from the form. All other properties will have fields.
    :param field_args:
        An optional dictionary of field names mapping to keyword arguments
        used to construct each field object.
    :param converter:
        A converter to generate the fields based on the model properties. If
        not set, ``ModelConverter`` is used.
    """
    exclude = ([f for f in exclude] if exclude else []) + ['id']
    field_dict = model_fields(model, fields, readonly_fields, exclude,
                              field_args, converter)
    return type(model._meta.object_name + 'Form', (base_class, ), field_dict)


########NEW FILE########
__FILENAME__ = view
from flask_superadmin.model.base import BaseModelAdmin

from orm import model_form, AdminModelConverter
from django.db import models

import operator

class ModelAdmin(BaseModelAdmin):
    @staticmethod
    def model_detect(model):
        return issubclass(model, models.Model)

    def allow_pk(self):
        return False

    def get_model_form(self):
        return model_form

    def get_converter(self):
        return AdminModelConverter

    def get_queryset(self):
        return self.model.objects

    def get_objects(self, *pks):
        return self.get_queryset().filter(pk__in=pks)

    def get_object(self, pk):
        return self.model.objects.get(pk=pk)

    def get_pk(self, instance):
        return str(instance.id)

    def save_model(self, instance, form, adding=False):
        form.populate_obj(instance)
        instance.save()
        return instance

    def delete_models(self, *pks):
        self.get_objects(*pks).delete()
        return True

    def construct_search(self, field_name):
        if field_name.startswith('^'):
            return "%s__istartswith" % field_name[1:]
        elif field_name.startswith('='):
            return "%s__iexact" % field_name[1:]
        else:
            return "%s__icontains" % field_name

    def get_list(self, page=0, sort=None, sort_desc=None, execute=False, search_query=None):
        qs = self.get_queryset()

        # Filter by search query
        if search_query and self.search_fields:
            orm_lookups = [self.construct_search(str(search_field))
                           for search_field in self.search_fields]
            for bit in search_query.split():
                or_queries = [models.Q(**{orm_lookup: bit})
                              for orm_lookup in orm_lookups]
                qs = qs.filter(reduce(operator.or_, or_queries))

        #Calculate number of rows
        count = qs.count()

        #Order queryset
        if sort:
            qs = qs.order_by('%s%s' % ('-' if sort_desc else '', sort))

        # Pagination
        if page is not None:
            qs = qs.all()[page * self.list_per_page:]
        qs = qs[:self.list_per_page]

        if execute:
            qs = list(qs)

        return count, qs

########NEW FILE########
__FILENAME__ = fields
"""
Useful form fields for use with the mongoengine.
"""
import operator

from wtforms import widgets
from wtforms.fields import SelectFieldBase, FieldList
from wtforms.validators import ValidationError
from wtforms.widgets import TextInput

__all__ = (
    'ModelSelectField', 'ModelSelectMultipleField', 'QuerySetSelectField',
    'ListField',
)


class QuerySelectField(SelectFieldBase):
    """
    Will display a select drop-down field to choose between ORM results in a
    sqlalchemy `Query`.  The `data` property actually will store/keep an ORM
    model instance, not the ID. Submitting a choice which is not in the query
    will result in a validation error.

    This field only works for queries on models whose primary key column(s)
    have a consistent string representation. This means it mostly only works
    for those composed of string, unicode, and integer types. For the most
    part, the primary keys will be auto-detected from the model, alternately
    pass a one-argument callable to `get_pk` which can return a unique
    comparable key.

    The `query` property on the field can be set from within a view to assign
    a query per-instance to the field. If the property is not set, the
    `query_factory` callable passed to the field constructor will be called to
    obtain a query.

    Specify `get_label` to customize the label associated with each option. If
    a string, this is the name of an attribute on the model object to use as
    the label text. If a one-argument callable, this callable will be passed
    model instance and expected to return the label text. Otherwise, the model
    object's `__str__` or `__unicode__` will be used.

    If `allow_blank` is set to `True`, then a blank choice will be added to the
    top of the list. Selecting this choice will result in the `data` property
    being `None`. The label for this blank choice can be set by specifying the
    `blank_text` parameter.
    """
    widget = widgets.Select()

    def __init__(self, label=None, validators=None, query_factory=None,
                 get_label=None, allow_blank=False,
                 blank_text='', **kwargs):
        super(QuerySelectField, self).__init__(label, validators, **kwargs)
        self.query_factory = query_factory

        self.get_pk = lambda x: x.id

        if get_label is None:
            self.get_label = lambda x: x
        elif isinstance(get_label, (str, basestring)):
            self.get_label = operator.attrgetter(get_label)
        else:
            self.get_label = get_label

        self.allow_blank = allow_blank
        self.blank_text = blank_text
        self.query = None
        self._object_list = None

    def _get_data(self):
        if self._formdata is not None:
            for pk, obj in self._get_object_list():
                if pk == self._formdata:
                    self._set_data(obj)
                    break
        return self._data

    def _set_data(self, data):
        self._data = data
        self._formdata = None

    data = property(_get_data, _set_data)

    def _get_object_list(self):

        if not self.query_factory:
            return []

        self.query_factory.rewind()
        if self._object_list is None:
            query = self.query_factory
            get_pk = self.get_pk
            self._object_list = list((str(get_pk(obj)), obj) for obj in query)
        return self._object_list

    def iter_choices(self):
        if self.allow_blank:
            yield ('__None', self.blank_text, self.data is None)

        for pk, obj in self._get_object_list():
            yield (pk, self.get_label(obj), obj == self.data)

    def process_formdata(self, valuelist):
        if valuelist:
            if self.allow_blank and valuelist[0] == '__None':
                self.data = None
            else:
                self._data = None
                self._formdata = valuelist[0]

    def pre_validate(self, form):
        if not self.allow_blank or self.data is not None:
            for pk, obj in self._get_object_list():
                if self.data == obj:
                    break
            else:
                raise ValidationError(self.gettext('Not a valid choice'))


class QuerySelectMultipleField(QuerySelectField):
    """
    Very similar to QuerySelectField with the difference that this will
    display a multiple select. The data property will hold a list with ORM
    model instances and will be an empty list when no value is selected.

    If any of the items in the data list or submitted form data cannot be
    found in the query, this will result in a validation error.
    """
    widget = widgets.Select(multiple=True)

    def __init__(self, label=None, validators=None, default=None, **kwargs):
        if default is None:
            default = []
        super(QuerySelectMultipleField, self).__init__(label, validators,
              default=default, **kwargs)
        self._invalid_formdata = False

    def _get_data(self):
        formdata = self._formdata
        if formdata is not None:
            data = []
            for pk, obj in self._get_object_list():
                if not formdata:
                    break
                elif pk in formdata:
                    formdata.remove(pk)
                    data.append(obj)
            if formdata:
                self._invalid_formdata = True
            self._set_data(data)
        return self._data

    def _set_data(self, data):
        self._data = data
        self._formdata = None

    data = property(_get_data, _set_data)

    def iter_choices(self):
        for pk, obj in self._get_object_list():
            yield (pk, self.get_label(obj), obj in self.data)

    def process_formdata(self, valuelist):
        self._formdata = set(valuelist)

    def pre_validate(self, form):
        if self._invalid_formdata:
            raise ValidationError(self.gettext('Not a valid choice'))
        elif self.data:
            obj_list = list(x[1] for x in self._get_object_list())
            for v in self.data:
                if v not in obj_list:
                    raise ValidationError(self.gettext('Not a valid choice'))


def get_pk_from_identity(obj):
    # TODO: WTF
    cls, key = identity_key(instance=obj)
    return ':'.join(str(x) for x in key)


class ModelSelectField(QuerySelectField):
    """
    Like a QuerySetSelectField, except takes a model class instead of a
    queryset and lists everything in it.
    """
    def __init__(self, label=u'', validators=None, model=None, **kwargs):
        super(ModelSelectField, self).__init__(label, validators,
              query_factory=model.objects, **kwargs)


class ModelSelectMultipleField(QuerySelectMultipleField):
    """
    Like a QuerySetSelectField, except takes a model class instead of a
    queryset and lists everything in it.
    """
    def __init__(self, label=u'', validators=None, model=None, **kwargs):
        super(ModelSelectMultipleField, self).__init__(label, validators,
              query_factory=model.objects, **kwargs)


class ListField(FieldList):
    def new_generic(self):
        assert not self.max_entries or len(self.entries) < self.max_entries, \
            'You cannot have more than max_entries entries in this FieldList'
        new_index = '__new__'
        name = '%s-%s' % (self.short_name, new_index)
        id = '%s-%s' % (self.id, new_index)
        field = self.unbound_field.bind(form=None, name=name,
                                        prefix=self._prefix, id=id)
        field.process(None, None)
        return field


class AutocompleteInput(TextInput):
    def __call__(self, field, **kwargs):
        autocomplete_value = kwargs.get('value', field._value())
        kwargs['value'] = ''
        kwargs['data-autocomplete'] = autocomplete_value
        return super(AutocompleteInput, self).__call__(field, **kwargs)

########NEW FILE########
__FILENAME__ = orm
"""
Tools for generating forms based on MongoEngine Document schemas.
"""

import inspect
from werkzeug import secure_filename
from wtforms import Form, validators, fields as f

from fields import ModelSelectField, ModelSelectMultipleField, ListField
from mongoengine.fields import ReferenceField, IntField, FloatField

from flask_superadmin.model import AdminModelConverter as AdminModelConverter_

__all__ = ('model_fields', 'model_form')


def converts(*args):
    """ A convenient decorator for the ModelConverter used to mark which
    method should be used to convert which MongoEngine field.
    """
    def _inner(func):
        func._converter_for = frozenset(args)
        return func
    return _inner


class ModelConverter(object):
    """ Manages the way MongoEngine fields are converted into WTForms fields
    """
    def __init__(self, converters=None):

        if not converters:
            converters = {}

        for name in dir(self):
            obj = getattr(self, name)
            if hasattr(obj, '_converter_for'):
                for classname in obj._converter_for:
                    converters[classname] = obj

        self.converters = converters

    def convert(self, model, field, field_args, multiple=False):
        kwargs = {
            'label': unicode(field.verbose_name or field.name or ''),
            'description': field.help_text or '',
            'validators': [],
            'filters': [],
            'default': field.default,
        }
        if field_args:
            kwargs.update(field_args)

        if field.required:

            # Hacky but necessary, since validators.Required doesn't handle 0 properly
            if isinstance(field, IntField) or isinstance(field, FloatField):
                kwargs['validators'].append(validators.InputRequired())
            else:
                kwargs['validators'].append(validators.Required())
        else:
            kwargs['validators'].append(validators.Optional())

        if field.choices:
            kwargs['choices'] = field.choices
            if isinstance(field, IntField):
                kwargs['coerce'] = int
            if not multiple:
                return f.SelectField(**kwargs)
            else:
                return f.SelectMultipleField(**kwargs)
        ftype = type(field).__name__

        if hasattr(field, 'to_form_field'):
            return field.to_form_field(model, kwargs)

        if ftype in self.converters:
            return self.converters[ftype](model, field, kwargs)

    @classmethod
    def _string_common(cls, model, field, kwargs):
        if field.max_length or field.min_length:
            kwargs['validators'].append(
                validators.Length(max=field.max_length or - 1,
                                  min=field.min_length or - 1))

    @classmethod
    def _number_common(cls, model, field, kwargs):
        if field.max_value or field.min_value:
            kwargs['validators'].append(
                validators.NumberRange(max=field.max_value,
                                       min=field.min_value))

    @converts('StringField')
    def conv_String(self, model, field, kwargs):
        if field.regex:
            kwargs['validators'].append(validators.Regexp(regex=field.regex))
        self._string_common(model, field, kwargs)
        if field.max_length:
            return f.TextField(**kwargs)
        return f.TextAreaField(**kwargs)

    @converts('URLField')
    def conv_URL(self, model, field, kwargs):
        kwargs['validators'].append(validators.URL())
        self._string_common(model, field, kwargs)
        return f.TextField(**kwargs)

    @converts('EmailField')
    def conv_Email(self, model, field, kwargs):
        kwargs['validators'].append(validators.Email())
        self._string_common(model, field, kwargs)
        return f.TextField(**kwargs)

    @converts('IntField')
    def conv_Int(self, model, field, kwargs):
        self._number_common(model, field, kwargs)
        return f.IntegerField(**kwargs)

    @converts('FloatField')
    def conv_Float(self, model, field, kwargs):
        self._number_common(model, field, kwargs)
        return f.FloatField(**kwargs)

    @converts('FileField')
    def conv_File(self, model, field, kwargs):
        return f.FileField(**kwargs)

    @converts('ImageField')
    def conv_Image(self, model, field, kwargs):
        return f.FileField(**kwargs)

    @converts('DecimalField')
    def conv_Decimal(self, model, field, kwargs):
        self._number_common(model, field, kwargs)
        return f.DecimalField(**kwargs)

    @converts('BooleanField')
    def conv_Boolean(self, model, field, kwargs):
        return f.BooleanField(**kwargs)

    @converts('DateTimeField')
    def conv_DateTime(self, model, field, kwargs):
        # kwargs['widget'] = form.DateTimePickerWidget()
        return f.DateTimeField(**kwargs)

    @converts('BinaryField')
    def conv_Binary(self, model, field, kwargs):
        #TODO: may be set file field that will save file`s data to MongoDB
        if field.max_bytes:
            kwargs['validators'].append(validators.Length(max=field.max_bytes))
        return f.TextAreaField(**kwargs)

    @converts('DictField')
    def conv_Dict(self, model, field, kwargs):
        return f.TextAreaField(**kwargs)

    @converts('ListField')
    def conv_List(self, model, field, kwargs):
        kwargs = kwargs or {
            'validators': [],
            'filters': [],
            'label': unicode(field.verbose_name or field.name or ''),
        }
        if field.field.choices:
            return self.convert(model, field.field, None, multiple=True)
        if isinstance(field.field, ReferenceField):
            return ModelSelectMultipleField(model=field.field.document_type, **kwargs)
        unbound_field = self.convert(model, field.field, {})
        return ListField(unbound_field, min_entries=0, **kwargs)

    @converts('SortedListField')
    def conv_SortedList(self, model, field, kwargs):
        #TODO: sort functionality, may be need sortable widget
        return self.conv_List(model, field, kwargs)

    @converts('GeoLocationField')
    def conv_GeoLocation(self, model, field, kwargs):
        #TODO: create geo field and widget (also GoogleMaps)
        return

    @converts('ObjectIdField')
    def conv_ObjectId(self, model, field, kwargs):
        return

    @converts('EmbeddedDocumentField')
    def conv_EmbeddedDocument(self, model, field, kwargs):
        kwargs = {
            'validators': [],
            'filters': [],
        }
        form_class = model_form(field.document_type_obj, field_args={},
                                converter=self)
        return f.FormField(form_class, **kwargs)

    @converts('ReferenceField')
    def conv_Reference(self, model, field, kwargs):
        kwargs['allow_blank'] = not field.required
        return ModelSelectField(model=field.document_type, **kwargs)

    @converts('GenericReferenceField')
    def conv_GenericReference(self, model, field, kwargs):
        return


def model_fields(model, fields=None, readonly_fields=None, exclude=None,
                 field_args=None, converter=None):
    """
    Generate a dictionary of WTForms fields for a given MongoEngine model.

    See `model_form` docstring for description of parameters.
    """
    from mongoengine.base import BaseDocument
    if BaseDocument not in inspect.getmro(model):
        raise TypeError('Model must be a MongoEngine Document schema')

    readonly_fields = readonly_fields or []
    exclude = exclude or []

    converter = converter or ModelConverter()
    field_args = field_args or {}

    field_names = fields if fields else model._fields.keys()
    field_names = (x for x in field_names if x not in exclude)

    field_dict = {}
    for name in field_names:
        if name not in readonly_fields and name not in model._fields:
            raise KeyError('"%s" is not read-only and does not appear to be a field on the document.' % name)

        if name in model._fields and name not in readonly_fields:
            model_field = model._fields[name]
            field = converter.convert(model, model_field, field_args.get(name))
            if field is not None:
                field_dict[name] = field

    return field_dict


import mongoengine.fields as fields

_unset_value = object()
_remove_file_value = object()

def data_to_field(field, data):
    if isinstance(field, fields.EmbeddedDocumentField):
        return data_to_document(field.document_type_obj, data)
    elif isinstance(field, (fields.ListField, fields.SequenceField,
                    fields.SortedListField)):
        l = []
        for d in data:
            l.append(data_to_field(field.field, d))
        return l
    elif isinstance(field, (fields.FileField)):
        if data.filename:
            gfs = field.proxy_class(
                        db_alias=field.db_alias,
                        collection_name=field.collection_name,
                        instance=field.owner_document(),
                        key=field.name)
            gfs.put(data.stream, filename=secure_filename(data.filename), content_type=data.mimetype)
            return gfs
        elif data.clear:
            return _remove_file_value
        return _unset_value
    elif isinstance(field, (fields.ReferenceField, fields.ObjectIdField)) and \
                    isinstance(data, basestring):
        from bson.objectid import ObjectId
        return ObjectId(data)
    else:
        return data


def data_to_document(document, data):
    from inspect import isclass
    new = document() if isclass(document) else document
    for name, value in data.iteritems():
        field = getattr(new.__class__, name)
        field_value = data_to_field(field, value)
        if field_value != _unset_value:
            if field_value == _remove_file_value:
                getattr(new, name).delete()
            else:
                setattr(new, name, field_value)
    return new


def model_form(model, base_class=Form, fields=None, readonly_fields=None,
               exclude=None, field_args=None, converter=None):
    """
    Create a wtforms Form for a given MongoEngine Document schema::

        from flaskext.mongoengine.wtf import model_form
        from myproject.myapp.schemas import Article
        ArticleForm = model_form(Article)

    :param model:
        A MongoEngine Document schema class
    :param base_class:
        Base form class to extend from. Must be a ``wtforms.Form`` subclass.
    :param fields:
        An optional iterable with the property names that should be included
        in the form. Only these properties will have fields. It also
        determines the order of the fields.
    :param exclude:
        An optional iterable with the property names that should be excluded
        from the form. All other properties will have fields.
    :param field_args:
        An optional dictionary of field names mapping to keyword arguments used
        to construct each field object.
    :param converter:
        A converter to generate the fields based on the model properties. If
        not set, ``ModelConverter`` is used.
    """
    field_dict = model_fields(model, fields, readonly_fields, exclude,
                              field_args, converter)
    field_dict['model_class'] = model

    def populate_obj(self, obj):
        return data_to_document(obj, self.data)

    field_dict['populate_obj'] = populate_obj

    return type(model.__name__ + 'Form', (base_class,), field_dict)


class AdminModelConverter(AdminModelConverter_, ModelConverter):
    pass


########NEW FILE########
__FILENAME__ = view
from flask_superadmin.model.base import BaseModelAdmin

from orm import model_form, AdminModelConverter

import operator
import mongoengine

from bson.objectid import ObjectId

SORTABLE_FIELDS = (
    mongoengine.BooleanField,
    mongoengine.DateTimeField,
    #mongoengine.DecimalField,
    mongoengine.FloatField,
    mongoengine.IntField,
    mongoengine.StringField,
    mongoengine.ReferenceField
)


class ModelAdmin(BaseModelAdmin):
    @staticmethod
    def model_detect(model):
        return issubclass(model, mongoengine.Document)

    def allow_pk(self):
        return False

    def is_sortable(self, column):
        field = getattr(self.model, column, None)
        return isinstance(field, SORTABLE_FIELDS)

    def get_model_form(self):
        return model_form

    def get_converter(self):
        return AdminModelConverter

    def get_queryset(self):
        return self.model.objects

    def get_objects(self, *pks):
        return self.get_queryset().filter(pk__in=pks)

    def get_object(self, pk):
        return self.get_queryset().get(pk=pk)

    def get_pk(self, instance):
        return str(instance.id)

    def save_model(self, instance, form, adding=False):
        form.populate_obj(instance)
        instance.save()
        return instance

    def delete_models(self, *pks):
        for obj in self.get_objects(*pks):
            obj.delete()
        return True

    def construct_search(self, field_name):
        if field_name.startswith('^'):
            return "%s__istartswith" % field_name[1:]
        elif field_name.startswith('='):
            return "%s__iexact" % field_name[1:]
        else:
            return "%s__icontains" % field_name

    def get_list(self, page=0, sort=None, sort_desc=None, execute=False, search_query=None):
        qs = self.get_queryset()

        # Filter by search query
        if search_query and self.search_fields:
            orm_lookups = [self.construct_search(str(search_field))
                           for search_field in self.search_fields]
            for bit in search_query.split():
                or_queries = [mongoengine.queryset.Q(**{orm_lookup: bit})
                              for orm_lookup in orm_lookups]
                qs = qs.filter(reduce(operator.or_, or_queries))

        #Calculate number of documents
        count = qs.count()

        #Order queryset
        if sort:
            qs = qs.order_by('%s%s' % ('-' if sort_desc else '', sort))

        # Pagination
        if page is not None:
            qs = qs.skip(page * self.list_per_page)
        qs = qs.limit(self.list_per_page)

        if execute:
            qs = qs.all()

        return count, qs


########NEW FILE########
__FILENAME__ = filters
from flask_superadmin.babel import gettext

from flask_superadmin.model import filters
from flask_superadmin.contrib.sqlamodel import tools


class BaseSQLAFilter(filters.BaseFilter):
    """
        Base SQLAlchemy filter.
    """
    def __init__(self, column, name, options=None, data_type=None):
        """
            Constructor.

            `column`
                Model field
            `name`
                Display name
            `options`
                Fixed set of options
            `data_type`
                Client data type
        """
        super(BaseSQLAFilter, self).__init__(name, options, data_type)

        self.column = column


# Common filters
class FilterEqual(BaseSQLAFilter):
    def apply(self, query, value):
        return query.filter(self.column == value)

    def operation(self):
        return gettext('equals')


class FilterNotEqual(BaseSQLAFilter):
    def apply(self, query, value):
        return query.filter(self.column != value)

    def operation(self):
        return gettext('not equal')


class FilterLike(BaseSQLAFilter):
    def apply(self, query, value):
        stmt = tools.parse_like_term(value)
        return query.filter(self.column.ilike(stmt))

    def operation(self):
        return gettext('contains')


class FilterNotLike(BaseSQLAFilter):
    def apply(self, query, value):
        stmt = tools.parse_like_term(value)
        return query.filter(~self.column.ilike(stmt))

    def operation(self):
        return gettext('not contains')


class FilterGreater(BaseSQLAFilter):
    def apply(self, query, value):
        return query.filter(self.column > value)

    def operation(self):
        return gettext('greater than')


class FilterSmaller(BaseSQLAFilter):
    def apply(self, query, value):
        return query.filter(self.column < value)

    def operation(self):
        return gettext('smaller than')


# Customized type filters
class BooleanEqualFilter(FilterEqual, filters.BaseBooleanFilter):
    pass


class BooleanNotEqualFilter(FilterNotEqual, filters.BaseBooleanFilter):
    pass


# Base SQLA filter field converter
class FilterConverter(filters.BaseFilterConverter):
    strings = (FilterEqual, FilterNotEqual, FilterLike, FilterNotLike)
    numeric = (FilterEqual, FilterNotEqual, FilterGreater, FilterSmaller)

    def convert(self, type_name, column, name):
        if type_name in self.converters:
            return self.converters[type_name](column, name)

        return None

    @filters.convert('String', 'Unicode', 'Text', 'UnicodeText')
    def conv_string(self, column, name):
        return [f(column, name) for f in self.strings]

    @filters.convert('Boolean')
    def conv_bool(self, column, name):
        return [BooleanEqualFilter(column, name),
                BooleanNotEqualFilter(column, name)]

    @filters.convert('Integer', 'SmallInteger', 'Numeric', 'Float')
    def conv_int(self, column, name):
        return [f(column, name) for f in self.numeric]

    @filters.convert('Date')
    def conv_date(self, column, name):
        return [f(column, name, data_type='datepicker') for f in self.numeric]

    @filters.convert('DateTime')
    def conv_datetime(self, column, name):
        return [f(column, name, data_type='datetimepicker') for f in self.numeric]

########NEW FILE########
__FILENAME__ = orm
"""
Tools for generating forms based on SQLAlchemy Model schemas.
"""

from sqlalchemy import Column
from sqlalchemy.orm.exc import NoResultFound

from wtforms import Form, ValidationError, fields, validators
from wtforms.ext.sqlalchemy.orm import converts, ModelConverter, model_form as original_model_form
from wtforms.ext.sqlalchemy.fields import QuerySelectField, QuerySelectMultipleField

from flask.ext.superadmin import form


class Unique(object):
    """Checks field value unicity against specified table field.

    :param get_session:
        A function that return a SQAlchemy Session.
    :param model:
        The model to check unicity against.
    :param column:
        The unique column.
    :param message:
        The error message.
    """
    field_flags = ('unique', )

    def __init__(self, db_session, model, column, message=None):
        self.db_session = db_session
        self.model = model
        self.column = column
        self.message = message

    def __call__(self, form, field):
        try:
            obj = (self.db_session.query(self.model)
                       .filter(self.column == field.data).one())

            if not hasattr(form, '_obj') or not form._obj == obj:
                if self.message is None:
                    self.message = field.gettext(u'Already exists.')
                raise ValidationError(self.message)
        except NoResultFound:
            pass


class AdminModelConverter(ModelConverter):
    """
        SQLAlchemy model to form converter
    """
    def __init__(self, view):
        super(AdminModelConverter, self).__init__()

        self.view = view

    def _get_label(self, name, field_args):
        if 'label' in field_args:
            return field_args['label']

        # if self.view.rename_columns:
        #     return self.view.rename_columns.get(name)

        return None

    def _get_field_override(self, name):
        if self.view.field_overrides:
            return self.view.field_overrides.get(name)

    def convert(self, model, mapper, prop, field_args, *args):
        kwargs = {
            'validators': [],
            'filters': []
        }

        if field_args:
            kwargs.update(field_args)

        if hasattr(prop, 'direction'):
            remote_model = prop.mapper.class_
            local_column = prop.local_remote_pairs[0][0]

            kwargs.update({
                'allow_blank': local_column.nullable,
                'label': self._get_label(prop.key, kwargs),
                'query_factory': lambda: self.view.session.query(remote_model)
            })
            if local_column.nullable:
                kwargs['validators'].append(validators.Optional())
            elif prop.direction.name not in ('MANYTOMANY', 'ONETOMANY'):
                kwargs['validators'].append(validators.Required())

            # Override field type if necessary
            override = self._get_field_override(prop.key)
            if override:
                return override(**kwargs)

            if prop.direction.name == 'MANYTOONE':
                return QuerySelectField(widget=form.ChosenSelectWidget(),
                                        **kwargs)
            elif prop.direction.name == 'ONETOMANY':
                # Skip backrefs
                if not local_column.foreign_keys and self.view.hide_backrefs:
                    return None

                return QuerySelectMultipleField(
                                widget=form.ChosenSelectWidget(multiple=True),
                                **kwargs)
            elif prop.direction.name == 'MANYTOMANY':
                return QuerySelectMultipleField(
                                widget=form.ChosenSelectWidget(multiple=True),
                                **kwargs)
        else:
            # Ignore pk/fk
            if hasattr(prop, 'columns'):
                column = prop.columns[0]

                # Column can be SQL expressions
                # WTForms cannot convert them
                if not isinstance(column, Column):
                    return None

                # Do not display foreign keys - use relations
                if column.foreign_keys:
                    return None

                unique = False

                if column.primary_key:
                    # By default, don't show primary keys either
                    if self.view.fields is None:
                        return None

                    # If PK is not explicitly allowed, ignore it
                    if prop.key not in self.view.fields:
                        return None

                    kwargs['validators'].append(Unique(self.view.session,
                                                       model,
                                                       column))
                    unique = True

                # If field is unique, validate it
                if column.unique and not unique:
                    kwargs['validators'].append(Unique(self.view.session,
                                                       model,
                                                       column))

                if column.nullable:
                    kwargs['validators'].append(validators.Optional())
                else:
                    kwargs['validators'].append(validators.Required())

            # Apply label
            kwargs['label'] = self._get_label(prop.key, kwargs)

            # Override field type if necessary
            override = self._get_field_override(prop.key)
            if override:
                return override(**kwargs)

            return super(AdminModelConverter, self).convert(model, mapper,
                                                            prop, kwargs)

    @converts('Date')
    def convert_date(self, field_args, **extra):
        field_args['widget'] = form.DatePickerWidget()
        return fields.DateField(**field_args)

    @converts('DateTime')
    def convert_datetime(self, field_args, **extra):
        field_args['widget'] = form.DateTimePickerWidget()
        return fields.DateTimeField(**field_args)

    @converts('Time')
    def convert_time(self, field_args, **extra):
        return form.TimeField(**field_args)

    @converts('Text')
    def conv_Text_fix(self, field_args, **extra):
        return self.conv_Text(field_args, **extra)


def model_form(model, base_class=Form, fields=None, readonly_fields=None,
               exclude=None, field_args=None, converter=None):
    only = tuple(set(fields or []) - set(readonly_fields or []))
    return original_model_form(model, base_class=base_class, only=only,
                               exclude=exclude, field_args=field_args,
                               converter=converter)

########NEW FILE########
__FILENAME__ = tools
def parse_like_term(term):
    if term.startswith('^'):
        stmt = '%s%%' % term[1:]
    elif term.startswith('='):
        stmt = term[1:]
    else:
        stmt = '%%%s%%' % term

    return stmt

########NEW FILE########
__FILENAME__ = view
from sqlalchemy.sql.expression import desc, literal_column, or_

from orm import model_form, AdminModelConverter

from flask_superadmin.model.base import BaseModelAdmin
from sqlalchemy import schema


class ModelAdmin(BaseModelAdmin):
    hide_backrefs = False

    def __init__(self, model, session=None,
                 *args, **kwargs):
        super(ModelAdmin, self).__init__(model, *args, **kwargs)
        if session:
            self.session = session
        self._primary_key = self.pk_key

    @staticmethod
    def model_detect(model):
        return isinstance(getattr(model, 'metadata', None), schema.MetaData)

    def _get_model_iterator(self, model=None):
        """
            Return property iterator for the model
        """
        if model is None:
            model = self.model

        return model._sa_class_manager.mapper.iterate_properties

    @property
    def pk_key(self):
        for p in self._get_model_iterator():
            if hasattr(p, 'columns'):
                for c in p.columns:
                    if c.primary_key:
                        return p.key

    def allow_pk(self):
        return False

    def get_model_form(self):
        return model_form

    def get_converter(self):
        return AdminModelConverter(self)

    @property
    def query(self):
        return self.get_queryset()  # TODO remove eventually (kept for backwards compatibility)

    def get_queryset(self):
        return self.session.query(self.model)

    def get_objects(self, *pks):
        id = self.get_pk(self.model)
        return self.get_queryset().filter(id.in_(pks))

    def get_object(self, pk):
        return self.get_queryset().get(pk)

    def get_pk(self, instance):
        return getattr(instance, self._primary_key)

    def save_model(self, instance, form, adding=False):
        form.populate_obj(instance)
        if adding:
            self.session.add(instance)
        self.session.commit()
        return instance

    def delete_models(self, *pks):
        objs = self.get_objects(*pks)
        objs.delete(synchronize_session='fetch')
        self.session.commit()
        return True

    def construct_search(self, field_name, op=None):
        if op == '^':
            return literal_column(field_name).startswith
        elif op == '=':
            return literal_column(field_name).op('=')
        else:
            return literal_column(field_name).contains

    def apply_search(self, qs, search_query):
        or_queries = []
        # treat spaces as if they were OR operators
        for word in search_query.split():
            op = word[:1]
            if op in ['^', '=']:
                word = word[1:]
            orm_lookups = [self.construct_search(str(model_field), op)
                           for model_field in self.search_fields]
            or_queries.extend([orm_lookup(word) for orm_lookup in orm_lookups])
        if or_queries:
            qs = qs.filter(or_(*or_queries))
        return qs

    def get_list(self, page=0, sort=None, sort_desc=None, execute=False, search_query=None):
        qs = self.get_queryset()

        # Filter by search query
        if search_query and self.search_fields:
            qs = self.apply_search(qs, search_query)

        #Calculate number of rows
        count = qs.count()

        #Order queryset
        if sort:
            if sort_desc:
                sort = desc(sort)
            qs = qs.order_by(sort)

        # Pagination
        if page is not None:
            qs = qs.offset(page * self.list_per_page)

        qs = qs.limit(self.list_per_page)

        if execute:
            qs = qs.all()

        return count, qs

########NEW FILE########
__FILENAME__ = base
import math
import re

from wtforms import fields, widgets
from flask import request, url_for, redirect, flash, abort

from flask_superadmin.babel import gettext
from flask_superadmin.base import BaseView, expose
from flask_superadmin.form import (BaseForm, ChosenSelectWidget, FileField,
                                   DatePickerWidget, DateTimePickerWidget)

import traceback


class AdminModelConverter(object):
    def convert(self, *args, **kwargs):
        field = super(AdminModelConverter, self).convert(*args, **kwargs)
        if field:
            widget = field.kwargs.get('widget', field.field_class.widget)
            if isinstance(widget, widgets.Select):
                field.kwargs['widget'] = ChosenSelectWidget(
                    multiple=widget.multiple)
            elif issubclass(field.field_class, fields.DateTimeField):
                field.kwargs['widget'] = DateTimePickerWidget()
            elif issubclass(field.field_class, fields.DateField):
                field.kwargs['widget'] = DatePickerWidget()
            elif issubclass(field.field_class, fields.FileField):
                field.field_class = FileField
        return field


first_cap_re = re.compile('(.)([A-Z][a-z]+)')


def camelcase_to_space(name):
    return first_cap_re.sub(r'\1 \2', name)


def prettify(str):
    return str.replace('_', ' ').title()


class BaseModelAdmin(BaseView):
    """ BaseModelAdmin provides create/edit/delete functionality for an
    abstract Model. The abstraction is further customized by the
    backend-specific model admin (see flask_superadmin/model/backends/) and
    by the user-defined admin classes inheriting from ModelAdmin.
    """

    # Number of objects to display per page in the list view
    list_per_page = 20

    # Columns to display in the list index - can be field names or callables.
    # Admin's methods have higher priority than the fields/methods on
    # the model or document.
    list_display = tuple()

    # Only fields with names specified in `fields` will be displayed in the
    # form (minus the ones mentioned in `exclude`). The order is preserved,
    # too. You can also include methods that are on the model admin, or on the
    # model/document, as long as they are marked as read-only (i.e. included
    # in `readonly_fields`). Priority of fields' lookup: methods on the model
    # admin, methods/fields on the model/document.
    fields = tuple()
    readonly_fields = tuple()
    exclude = tuple()

    # A base class for form rendering. If `None`, `BaseForm` would be used.
    form = None

    can_edit = True
    can_create = True
    can_delete = True

    list_template = 'admin/model/list.html'
    edit_template = 'admin/model/edit.html'
    add_template = 'admin/model/add.html'
    delete_template = 'admin/model/delete.html'

    search_fields = tuple()

    field_overrides = {}

    # A dictionary of field_name: overridden_params_dict, e.g.
    #   { 'name': { 'label': 'Name', 'description': 'This is a name' } }
    # Parameters that can be overridden: label, description, validators,
    # filters, default
    field_args = None

    @staticmethod
    def model_detect(model):
        return False

    def __init__(self, model=None, name=None, category=None, endpoint=None,
                 url=None):
        if name is None:
            name = '%s' % camelcase_to_space(model.__name__)

        if endpoint is None:
            endpoint = ('%s' % model.__name__).lower()

        super(BaseModelAdmin, self).__init__(name, category, endpoint, url)

        if model:
            self.model = model

    def get_display_name(self):
        return self.model.__name__

    def allow_pk(self):
        return not self.model._meta.auto_increment

    def get_column(self, instance, name):
        parts = name.split('.')
        value = instance
        for p in parts:

            # admin's methods have higher priority than the fields/methods on
            # the model or document. If a callable is found on the admin
            # level, it's also passed an instance object
            if hasattr(self, p) and callable(getattr(self, p)):
                value = getattr(self, p)(instance)
            else:
                value = getattr(value, p, None)
                if callable(value):
                    value = value()

            if not value:
                break

        return value

    def get_reference(self, column_value):
        for model, model_view in self.admin._models:
            if type(column_value) == model:
                return '/admin/%s/%s/' % (model_view.endpoint,
                                          model_view.get_pk(column_value))

    def get_readonly_fields(self, instance):
        ret_vals = {}
        for field in self.readonly_fields:
            self_field = getattr(self, field, None)
            if callable(self_field):
                val = self_field(instance)
            else:
                val = getattr(instance, field)
                if callable(val):
                    val = val()
            if not isinstance(val, dict):
                # Check if the value is a reference field to a doc/model
                # registered in the admin. If so, link to it.
                reference = self.get_reference(val)
                val = {
                    'label': prettify(field),
                    'value': val,
                    'url': reference if reference else None
                }
            ret_vals[field] = val
        return ret_vals

    def get_converter(self):
        raise NotImplemented()

    def get_model_form(self):
        """ Returns the model form, should get overridden in backend-specific
        view.
        """
        raise NotImplemented()

    def get_form(self):
        model_form = self.get_model_form()
        converter = self.get_converter()
        if isinstance(converter, type):
            converter = converter()
        base_class = self.form or BaseForm
        form = model_form(self.model, base_class=base_class,
                          fields=self.fields,
                          readonly_fields=self.readonly_fields,
                          exclude=self.exclude, field_args=self.field_args,
                          converter=converter)
        return form

    def get_add_form(self):
        return self.get_form()

    def get_objects(self, *pks):
        raise NotImplemented()

    def get_object(self, pk):
        raise NotImplemented()

    def get_pk(self, instance):
        return

    def save_model(self, instance, form, adding=False):
        raise NotImplemented()

    def delete_models(self, *pks):
        raise NotImplemented()

    def is_sortable(self, column):
        return False

    def field_name(self, field):
        return prettify(field)

    def construct_search(self, field_name):
        raise NotImplemented()

    def get_queryset(self):
        raise NotImplemented()

    def get_list(self):
        raise NotImplemented()

    def get_url_name(self, name):
        URLS = {
            'index': '.list',
            'add': '.add',
            'delete': '.delete',
            'edit': '.edit'
        }
        return URLS[name]

    def dispatch_save_redirect(self, instance):
        if '_edit' in request.form:
            return redirect(
                url_for(self.get_url_name('edit'), pk=self.get_pk(instance))
            )
        elif '_add_another' in request.form:
            return redirect(url_for(self.get_url_name('add')))
        else:
            return redirect(url_for(self.get_url_name('index')))

    @expose('/add/', methods=('GET', 'POST'))
    def add(self):
        if not self.can_create:
            abort(403)

        Form = self.get_add_form()
        if request.method == 'POST':
            form = Form()
            if form.validate_on_submit():
                try:
                    instance = self.save_model(self.model(), form, adding=True)
                    flash(gettext('New %(model)s saved successfully',
                          model=self.get_display_name()), 'success')
                    return self.dispatch_save_redirect(instance)
                except Exception, ex:
                    print traceback.format_exc()
                    if hasattr(self, 'session'):
                        self.session.rollback()
                    flash(gettext('Failed to add model. %(error)s',
                          error=str(ex)), 'error')

        else:
            try:
                form = Form(obj=self.model())
            except TypeError:
                raise Exception('The database model for %r should have an '
                                '__init__ with all arguments set to defaults.'
                                % self.model.__name__)

        return self.render(self.add_template, model=self.model, form=form)

    @property
    def page(self):
        return request.args.get('page', 0, type=int)

    def total_pages(self, count):
        return int(math.ceil(float(count) / self.list_per_page))

    @property
    def sort(self):
        sort = request.args.get('sort', None)
        if sort and sort.startswith('-'):
            desc = True
            sort = sort[1:]
        else:
            desc = False
        return sort, desc

    @property
    def search(self):
        return request.args.get('q', None)

    def page_url(self, page):
        search_query = self.search
        sort, desc = self.sort
        if sort and desc:
            sort = '-' + sort
        if page == 0:
            page = None
        return url_for(self.get_url_name('index'), page=page, sort=sort,
                       q=search_query)

    def sort_url(self, sort, desc=None):
        if sort and desc:
            sort = '-' + sort
        search_query = self.search
        return url_for(self.get_url_name('index'), sort=sort, q=search_query)

    @expose('/', methods=('GET', 'POST',))
    def list(self):
        """
            List view
        """
        # Grab parameters from URL
        if request.method == 'POST':
            id_list = request.form.getlist('_selected_action')
            if id_list and (request.form.get('action-delete') or
                            request.form.get('action', None) == 'delete'):
                return self.delete(*id_list)

        sort, sort_desc = self.sort
        page = self.page
        search_query = self.search
        count, data = self.get_list(page=page, sort=sort, sort_desc=sort_desc,
                                    search_query=search_query)

        return self.render(self.list_template, data=data, page=page,
                           total_pages=self.total_pages(count), sort=sort,
                           sort_desc=sort_desc, count=count, modeladmin=self,
                           search_query=search_query)

    @expose('/<pk>/', methods=('GET', 'POST'))
    def edit(self, pk):
        try:
            instance = self.get_object(pk)
        except self.model.DoesNotExist:
            abort(404)

        Form = self.get_form()

        if request.method == 'POST':
            form = Form(obj=instance)
            if form.validate_on_submit():
                try:
                    self.save_model(instance, form, adding=False)
                    flash(
                        'Changes to %s saved successfully' % self.get_display_name(),
                        'success'
                    )
                    return self.dispatch_save_redirect(instance)
                except Exception, ex:
                    print traceback.format_exc()
                    flash(gettext('Failed to edit model. %(error)s',
                                  error=str(ex)), 'error')
        else:
            form = Form(obj=instance)

        return self.render(self.edit_template, model=self.model, form=form,
                           pk=self.get_pk(instance), instance=instance)

    @expose('/<pk>/delete/', methods=('GET', 'POST'))
    def delete(self, pk=None, *pks):
        if not self.can_delete:
            abort(403)

        if pk:
            pks += pk,

        if request.method == 'POST' and 'confirm_delete' in request.form:
            count = len(pks)
            self.delete_models(*pks)

            flash(
                'Successfully deleted %s %ss' % (count, self.get_display_name()),
                'success'
            )
            return redirect(url_for(self.get_url_name('index')))
        else:
            instances = self.get_objects(*pks)

        return self.render(self.delete_template, instances=instances)


class ModelAdmin(BaseModelAdmin):
    pass

########NEW FILE########
__FILENAME__ = test_base
from nose.tools import ok_, eq_, raises

from flask import Flask
from flask_superadmin import base


class MockView(base.BaseView):
    # Various properties
    allow_call = True
    allow_access = True

    @base.expose('/')
    def index(self):
        return 'Success!'

    @base.expose('/test/')
    def test(self):
        return self.render('mock.html')

    def _handle_view(self, name, **kwargs):
        if self.allow_call:
            return super(MockView, self)._handle_view(name, **kwargs)
        else:
            return 'Failure!'

    def is_accessible(self):
        if self.allow_access:
            return super(MockView, self).is_accessible()
        else:
            return False


def test_baseview_defaults():
    view = MockView()
    eq_(view.name, None)
    eq_(view.category, None)
    eq_(view.endpoint, None)
    eq_(view.url, None)
    eq_(view.static_folder, None)
    eq_(view.admin, None)
    eq_(view.blueprint, None)


def test_base_defaults():
    admin = base.Admin()
    eq_(admin.name, 'Admin')
    eq_(admin.url, '/admin')
    eq_(admin.app, None)
    ok_(admin.index_view is not None)

    # Check if default view was added
    eq_(len(admin._views), 1)
    eq_(admin._views[0], admin.index_view)


def test_base_registration():
    app = Flask(__name__)
    admin = base.Admin(app)

    eq_(admin.app, app)
    ok_(admin.index_view.blueprint is not None)


def test_admin_customizations():
    app = Flask(__name__)
    admin = base.Admin(app, name='Test', url='/foobar')
    eq_(admin.name, 'Test')
    eq_(admin.url, '/foobar')

    client = app.test_client()
    rv = client.get('/foobar/')
    eq_(rv.status_code, 200)


def test_baseview_registration():
    admin = base.Admin()

    view = MockView()
    bp = view.create_blueprint(admin)

    # Base properties
    eq_(view.admin, admin)
    ok_(view.blueprint is not None)

    # Calculated properties
    eq_(view.endpoint, 'mockview')
    eq_(view.url, '/admin/mockview')
    eq_(view.name, 'Mock View')

    # Verify generated blueprint properties
    eq_(bp.name, view.endpoint)
    eq_(bp.url_prefix, view.url)
    eq_(bp.template_folder, 'templates')
    eq_(bp.static_folder, view.static_folder)

    # Verify customizations
    view = MockView(name='Test', endpoint='foobar')
    view.create_blueprint(base.Admin())

    eq_(view.name, 'Test')
    eq_(view.endpoint, 'foobar')
    eq_(view.url, '/admin/foobar')

    view = MockView(url='test')
    view.create_blueprint(base.Admin())
    eq_(view.url, '/admin/test')

    view = MockView(url='/test/test')
    view.create_blueprint(base.Admin())
    eq_(view.url, '/test/test')


def test_baseview_urls():
    app = Flask(__name__)
    admin = base.Admin(app)

    view = MockView()
    admin.add_view(view)

    eq_(len(view._urls), 2)


@raises(Exception)
def test_no_default():
    app = Flask(__name__)
    admin = base.Admin(app)
    admin.add_view(base.BaseView())


def test_call():
    app = Flask(__name__)
    admin = base.Admin(app)
    view = MockView()
    admin.add_view(view)
    client = app.test_client()

    rv = client.get('/admin/')
    eq_(rv.status_code, 200)

    rv = client.get('/admin/mockview/')
    eq_(rv.data, 'Success!')

    rv = client.get('/admin/mockview/test/')
    eq_(rv.data, 'Success!')

    # Check authentication failure
    view.allow_call = False
    rv = client.get('/admin/mockview/')
    eq_(rv.data, 'Failure!')


def test_permissions():
    app = Flask(__name__)
    admin = base.Admin(app)
    view = MockView()
    admin.add_view(view)
    client = app.test_client()

    view.allow_access = False

    rv = client.get('/admin/mockview/')
    eq_(rv.status_code, 403)


def test_submenu():
    app = Flask(__name__)
    admin = base.Admin(app)
    admin.add_view(MockView(name='Test 1', category='Test', endpoint='test1'))

    # Second view is not normally accessible
    view = MockView(name='Test 2', category='Test', endpoint='test2')
    view.allow_access = False
    admin.add_view(view)

    ok_('Test' in admin._menu_categories)
    eq_(len(admin._menu), 2)
    eq_(admin._menu[1].name, 'Test')
    eq_(len(admin._menu[1]._children), 2)

    # Categories don't have URLs and they're not accessible
    eq_(admin._menu[1].get_url(), None)
    eq_(admin._menu[1].is_accessible(), False)

    eq_(len(admin._menu[1].get_children()), 1)


def test_delayed_init():
    app = Flask(__name__)
    admin = base.Admin()
    admin.add_view(MockView())
    admin.init_app(app)

    client = app.test_client()

    rv = client.get('/admin/mockview/')
    eq_(rv.data, 'Success!')


@raises(Exception)
def test_double_init():
    app = Flask(__name__)
    admin = base.Admin(app)
    admin.init_app(app)


########NEW FILE########
__FILENAME__ = test_django
from nose.tools import eq_, ok_, raises

import wtforms

from flask import Flask
from flask_superadmin import Admin


from django.conf import settings


settings.configure(
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': 'mydatabase.sqlite',
        }
    }
)

app = Flask(__name__)
app.config['SECRET_KEY'] = '123456790'
app.config['WTF_CSRF_ENABLED'] = False

admin = Admin(app)

from flask_superadmin.model.backends.django.view import ModelAdmin
from django.db import models, DatabaseError
from examples.django.utils import install_models


class CustomModelView(ModelAdmin):
    def __init__(self, model, name=None, category=None, endpoint=None,
                 url=None, **kwargs):
        for k, v in kwargs.iteritems():
            setattr(self, k, v)

        super(CustomModelView, self).__init__(model, name, category, endpoint,
                                              url)

def test_list():
    class Person(models.Model):
        name = models.CharField(max_length=255)
        age = models.IntegerField()

        def __unicode__(self):
            return self.name

    # Create tables in the database if they don't exists
    try:
        install_models(Person)
    except DatabaseError, e:
        if 'already exists' not in e.message:
            raise

    Person.objects.all().delete()

    view = CustomModelView(Person)
    admin.add_view(view)

    eq_(view.model, Person)
    eq_(view.name, 'Person')
    eq_(view.endpoint, 'person')
    eq_(view.url, '/admin/person')

    # Verify form
    with app.test_request_context():
        Form = view.get_form()
        ok_(isinstance(Form()._fields['name'], wtforms.TextField))
        ok_(isinstance(Form()._fields['age'], wtforms.IntegerField))

    # Make some test clients
    client = app.test_client()

    resp = client.get('/admin/person/')
    eq_(resp.status_code, 200)

    resp = client.get('/admin/person/add/')
    eq_(resp.status_code, 200)

    resp = client.post('/admin/person/add/',
                     data=dict(name='name', age='18'))
    eq_(resp.status_code, 302)

    person = Person.objects.all()[0]
    eq_(person.name, 'name')
    eq_(person.age, 18)

    resp = client.get('/admin/person/')
    eq_(resp.status_code, 200)
    ok_(person.name in resp.data)

    resp = client.get('/admin/person/%s/' % person.pk)
    eq_(resp.status_code, 200)

    resp = client.post('/admin/person/%s/' % person.pk, data=dict(name='changed'))
    eq_(resp.status_code, 302)

    person = Person.objects.all()[0]
    eq_(person.name, 'changed')
    eq_(person.age, 18)

    resp = client.post('/admin/person/%s/delete/' % person.pk)
    eq_(resp.status_code, 200)
    eq_(Person.objects.count(), 1)

    resp = client.post('/admin/person/%s/delete/' % person.pk, data={'confirm_delete': True})
    eq_(resp.status_code, 302)
    eq_(Person.objects.count(), 0)


########NEW FILE########
__FILENAME__ = test_model
from nose.tools import eq_, ok_

import wtforms

from flask import Flask

from flask_superadmin import Admin
from flask_superadmin.model import base

from flask.ext import wtf


class Model(object):
    def __init__(self, id=None, c1=1, c2=2, c3=3):
        self.id = id
        self.col1 = c1
        self.col2 = c2
        self.col3 = c3

    DoesNotExist = 'dummy'


class Form(wtf.Form):
    col1 = wtforms.TextField()
    col2 = wtforms.TextField()
    col3 = wtforms.TextField()


class MockModelView(base.BaseModelAdmin):

    fields = ('col1', 'col2', 'col3')

    def __init__(self, model, name=None, category=None, endpoint=None,
                 url=None, **kwargs):
        # Allow to set any attributes from parameters
        for k, v in kwargs.iteritems():
            setattr(self, k, v)

        super(MockModelView, self).__init__(model, name, category, endpoint, url)

        self.created_models = []
        self.updated_models = []
        self.deleted_models = []

        self.search_arguments = []

        self.all_models = {1: Model(1),
                           2: Model(2)}
        self.last_id = 3

    # Scaffolding
    def get_pk(self, instance):
        return instance.id

    def get_object(self, pk):
        return self.all_models.get(int(pk))

    def get_objects(self, *pks):
        ret = []
        for pk in pks:
            ret.append(self.all_models.get(int(pk)))
        return ret

    def get_model_form(self):
        def fake_model_form(*args, **kwargs):
            return Form
        return fake_model_form

    def get_converter(self):
        pass

    def scaffold_list_columns(self):
        columns = ['col1', 'col2', 'col3']

        if self.excluded_list_columns:
            return filter(lambda x: x not in self.excluded_list_columns, columns)

        return columns

    def init_search(self):
        return bool(self.searchable_columns)

    def scaffold_sortable_columns(self):
        return ['col1', 'col2', 'col3']

    def scaffold_form(self):
        return Form

    # Data

    def get_list(self, page, sort, sort_desc, search_query):
        self.search_arguments.append((page, sort, sort_desc, search_query))
        return len(self.all_models), self.all_models.itervalues()

    def save_model(self, instance, form, adding=False):
        if adding:
            model = Model(self.last_id)
            self.last_id += 1

            form.populate_obj(model)
            self.created_models.append(model)
            self.all_models[model.id] = model
        else:
            form.populate_obj(instance)
            self.updated_models.append(instance)
        return True

    def update_model(self, form, model):
        return True

    def delete_models(self, *pks):
        for pk in pks:
            self.deleted_models.append(self.all_models.get(int(pk)))
        return True


def setup():
    app = Flask(__name__)
    app.config['WTF_CSRF_ENABLED'] = False
    app.secret_key = '1'
    admin = Admin(app)

    return app, admin


def test_mockview():
    app, admin = setup()

    view = MockModelView(Model)
    admin.add_view(view)

    eq_(view.model, Model)

    eq_(view.name, 'Model')
    eq_(view.url, '/admin/model')
    eq_(view.endpoint, 'model')
    ok_(view.blueprint is not None)

    client = app.test_client()

    # Make model view requests
    rv = client.get('/admin/model/')
    eq_(rv.status_code, 200)

    # Test model creation view
    rv = client.get('/admin/model/add/')
    eq_(rv.status_code, 200)

    rv = client.post('/admin/model/add/',
                     data=dict(col1='test1', col2='test2', col3='test3'))
    eq_(rv.status_code, 302)
    eq_(len(view.created_models), 1)

    model = view.created_models.pop()
    eq_(model.id, 3)
    eq_(model.col1, 'test1')
    eq_(model.col2, 'test2')
    eq_(model.col3, 'test3')

    # Try model edit view
    rv = client.get('/admin/model/3/')
    eq_(rv.status_code, 200)
    ok_('test1' in rv.data)

    rv = client.post('/admin/model/3/',
                     data=dict(col1='test!', col2='test@', col3='test#'))
    eq_(rv.status_code, 302)
    eq_(len(view.updated_models), 1)

    model = view.updated_models.pop()
    eq_(model.col1, 'test!')
    eq_(model.col2, 'test@')
    eq_(model.col3, 'test#')

    rv = client.get('/admin/modelview/4/')
    eq_(rv.status_code, 404)

    # Attempt to delete model
    rv = client.post('/admin/model/3/delete/', data=dict(confirm_delete=True))
    eq_(rv.status_code, 302)
    eq_(rv.headers['location'], 'http://localhost/admin/model/')


def test_permissions():
    app, admin = setup()

    view = MockModelView(Model)
    admin.add_view(view)

    client = app.test_client()

    view.can_create = False
    rv = client.get('/admin/model/add/')
    eq_(rv.status_code, 403)

    view.can_edit = False
    rv = client.get('/admin/model/1/')
    # 200 resp, but readonly fields
    eq_(rv.status_code, 200)
    eq_(rv.data.count('<div class="readonly-value">'), 3)

    view.can_delete = False
    rv = client.post('/admin/model/1/delete/')
    eq_(rv.status_code, 403)


def test_permissions_and_add_delete_buttons():
    app, admin = setup()

    view = MockModelView(Model)
    admin.add_view(view)

    client = app.test_client()

    resp = client.get('/admin/model/')
    eq_(resp.status_code, 200)
    ok_('Add Model' in resp.data)

    view.can_create = False
    resp = client.get('/admin/model/')
    eq_(resp.status_code, 200)
    ok_('Add Model' not in resp.data)

    view.can_edit = False
    view.can_delete = False
    resp = client.get('/admin/model/1/')
    eq_(resp.status_code, 200)
    ok_('Submit' not in resp.data)
    ok_('Save and stay on page' not in resp.data)
    ok_('Delete' not in resp.data)

    view.can_edit = False
    view.can_delete = True
    resp = client.get('/admin/model/1/')
    eq_(resp.status_code, 200)
    ok_('Submit' not in resp.data)
    ok_('Save and stay on page' not in resp.data)
    ok_('Delete' in resp.data)

    view.can_edit = True
    view.can_delete = False
    resp = client.get('/admin/model/1/')
    eq_(resp.status_code, 200)
    ok_('Submit' in resp.data)
    ok_('Save and stay on page' in resp.data)
    ok_('Delete' not in resp.data)


def test_templates():
    app, admin = setup()

    view = MockModelView(Model)
    admin.add_view(view)

    client = app.test_client()

    view.list_template = 'mock.html'
    view.add_template = 'mock.html'
    view.edit_template = 'mock.html'

    rv = client.get('/admin/model/')
    eq_(rv.data, 'Success!')

    rv = client.get('/admin/model/add/')
    eq_(rv.data, 'Success!')

    rv = client.get('/admin/model/1/')
    eq_(rv.data, 'Success!')


def test_list_display_header():
    app, admin = setup()

    view = MockModelView(Model, list_display=['test_header'])
    admin.add_view(view)

    eq_(len(view.list_display), 1)

    client = app.test_client()

    rv = client.get('/admin/model/')
    ok_('Test Header' in rv.data)


def test_search_fields():
    app, admin = setup()

    view = MockModelView(Model, search_fields=['col1', 'col2'])
    admin.add_view(view)

    eq_(view.search_fields, ['col1', 'col2'])

    client = app.test_client()

    rv = client.get('/admin/model/')
    ok_('<div class="search">' in rv.data)


########NEW FILE########
__FILENAME__ = test_mongoengine
from nose.tools import eq_, ok_, raises

import wtforms

from flask import Flask
from mongoengine import *

from flask_superadmin import Admin
from flask_superadmin.model.backends.mongoengine.view import ModelAdmin


class CustomModelView(ModelAdmin):
    def __init__(self, model, name=None, category=None, endpoint=None,
                 url=None, **kwargs):
        for k, v in kwargs.iteritems():
            setattr(self, k, v)

        super(CustomModelView, self).__init__(model, name, category, endpoint,
                                              url)


def setup():
    connect('superadmin_test')
    app = Flask(__name__)
    app.config['SECRET_KEY'] = '1'
    app.config['WTF_CSRF_ENABLED'] = False

    admin = Admin(app)

    return app, admin


def test_model():
    app, admin = setup()

    class Person(Document):
        name = StringField()
        age = IntField()

    Person.drop_collection()

    view = CustomModelView(Person)
    admin.add_view(view)

    eq_(view.model, Person)
    eq_(view.name, 'Person')
    eq_(view.endpoint, 'person')
    eq_(view.url, '/admin/person')

    # Verify form
    with app.test_request_context():
        Form = view.get_form()
        ok_(isinstance(Form()._fields['name'], wtforms.TextAreaField))
        ok_(isinstance(Form()._fields['age'], wtforms.IntegerField))

    # Make some test clients
    client = app.test_client()

    resp = client.get('/admin/person/')
    eq_(resp.status_code, 200)

    resp = client.get('/admin/person/add/')
    eq_(resp.status_code, 200)

    resp = client.post('/admin/person/add/',
                     data=dict(name='name', age='18'))
    eq_(resp.status_code, 302)

    person = Person.objects.first()
    eq_(person.name, 'name')
    eq_(person.age, 18)

    resp = client.get('/admin/person/')
    eq_(resp.status_code, 200)
    ok_(str(person.pk) in resp.data)

    resp = client.get('/admin/person/%s/' % person.pk)
    eq_(resp.status_code, 200)

    resp = client.post('/admin/person/%s/' % person.pk, data=dict(name='changed'))
    eq_(resp.status_code, 302)

    person = Person.objects.first()
    eq_(person.name, 'changed')
    eq_(person.age, 18)

    resp = client.post('/admin/person/%s/delete/' % person.pk)
    eq_(resp.status_code, 200)
    eq_(Person.objects.count(), 1)

    resp = client.post('/admin/person/%s/delete/' % person.pk, data={'confirm_delete': True})
    eq_(resp.status_code, 302)
    eq_(Person.objects.count(), 0)


def test_list_display():
    app, admin = setup()

    class Person(Document):
        name = StringField()
        age = IntField()

    Person.drop_collection()

    view = CustomModelView(Person, list_display=('name', 'age'))
    admin.add_view(view)

    eq_(len(view.list_display), 2)

    client = app.test_client()

    resp = client.get('/admin/person/')
    ok_('Name' in resp.data)
    ok_('Age' in resp.data)

    resp = client.post('/admin/person/add/',
                     data=dict(name='Steve', age='18'))
    eq_(resp.status_code, 302)

    resp = client.get('/admin/person/')
    ok_('Steve' in resp.data)
    ok_('18' in resp.data)


def test_exclude():
    app, admin = setup()

    class Person(Document):
        name = StringField()
        age = IntField()

    Person.drop_collection()

    view = CustomModelView(Person, exclude=['name'])
    admin.add_view(view)

    # Verify form
    with app.test_request_context():
        Form = view.get_form()
        eq_(Form()._fields.keys(), ['csrf_token', 'age'])

def test_fields():
    app, admin = setup()

    class Person(Document):
        name = StringField()
        age = IntField()

    Person.drop_collection()

    view = CustomModelView(Person, fields=['name'])
    admin.add_view(view)

    # Verify form
    with app.test_request_context():
        Form = view.get_form()
        eq_(Form()._fields.keys(), ['csrf_token', 'name'])

def test_fields_and_exclude():
    app, admin = setup()

    class Person(Document):
        name = StringField()
        age = IntField()

    Person.drop_collection()

    view = CustomModelView(Person, fields=['name', 'age'], exclude=['name'])
    admin.add_view(view)

    # Verify form
    with app.test_request_context():
        Form = view.get_form()
        eq_(Form()._fields.keys(), ['csrf_token', 'age'])

def test_search_fields():
    app, admin = setup()

    class Person(Document):
        name = StringField()
        age = IntField()

    Person.drop_collection()
    Person.objects.create(name='John', age=18)
    Person.objects.create(name='Michael', age=21)

    view = CustomModelView(Person, list_display=['name'],
                           search_fields=['name'])
    admin.add_view(view)

    eq_(len(view.search_fields), 1)
    client = app.test_client()

    resp = client.get('/admin/person/')
    ok_('name="q" class="search-input"' in resp.data)
    ok_('John' in resp.data)
    ok_('Michael' in resp.data)

    resp = client.get('/admin/person/?q=john')
    ok_('John' in resp.data)
    ok_('Michael' not in resp.data)


def test_pagination():
    app, admin = setup()

    class Person(Document):
        name = StringField()
        age = IntField()

    Person.drop_collection()
    Person.objects.create(name='John', age=18)
    Person.objects.create(name='Michael', age=21)
    Person.objects.create(name='Steve', age=15)
    Person.objects.create(name='Ron', age=59)

    view = CustomModelView(Person, list_per_page=2,
                           list_display=['name', 'age'])
    admin.add_view(view)

    client = app.test_client()

    resp = client.get('/admin/person/')
    ok_('<div class="total-count">Total count: 4</div>' in resp.data)
    ok_('<a href="#">1</a>' in resp.data)  # make sure the first page is active (i.e. has no url)
    ok_('John' in resp.data)
    ok_('Michael' in resp.data)
    ok_('Steve' not in resp.data)
    ok_('Ron' not in resp.data)

    # default page == page 0
    eq_(resp.data, client.get('/admin/person/?page=0').data)

    resp = client.get('/admin/person/?page=1')
    ok_('John' not in resp.data)
    ok_('Michael' not in resp.data)
    ok_('Steve' in resp.data)
    ok_('Ron' in resp.data)

def test_sort():
    app, admin = setup()

    class Person(Document):
        name = StringField()
        age = IntField()

    Person.drop_collection()
    Person.objects.create(name='John', age=18)
    Person.objects.create(name='Michael', age=21)
    Person.objects.create(name='Steve', age=15)
    Person.objects.create(name='Ron', age=59)

    view = CustomModelView(Person, list_per_page=2,
                           list_display=['name', 'age'])
    admin.add_view(view)

    client = app.test_client()

    resp = client.get('/admin/person/?sort=name')
    ok_('John' in resp.data)
    ok_('Michael' in resp.data)
    ok_('Ron' not in resp.data)
    ok_('Steve' not in resp.data)

    resp = client.get('/admin/person/?sort=-name')
    ok_('John' not in resp.data)
    ok_('Michael' not in resp.data)
    ok_('Ron' in resp.data)
    ok_('Steve' in resp.data)

    resp = client.get('/admin/person/?sort=age')
    ok_('John' in resp.data)
    ok_('Michael' not in resp.data)
    ok_('Ron' not in resp.data)
    ok_('Steve' in resp.data)

    resp = client.get('/admin/person/?sort=-age')
    ok_('John' not in resp.data)
    ok_('Michael' in resp.data)
    ok_('Ron' in resp.data)
    ok_('Steve' not in resp.data)

def test_reference_linking():
    app, admin = setup()

    class Dog(Document):
        name = StringField()

        def __unicode__(self):
            return self.name

    class Person(Document):
        name = StringField()
        age = IntField()
        pet = ReferenceField(Dog)

    class DogAdmin(ModelAdmin):
        pass

    class PersonAdmin(ModelAdmin):
        list_display = ('name', 'age', 'pet')
        fields = ('name', 'age', 'pet')
        readonly_fields = ('pet',)

    Dog.drop_collection()
    Person.drop_collection()
    dog = Dog.objects.create(name='Sparky')
    person = Person.objects.create(name='Stan', age=10, pet=dog)

    admin.register(Dog, DogAdmin, name='Dogs')
    admin.register(Person, PersonAdmin, name='People')

    client = app.test_client()

    # test linking on a list page
    resp = client.get('/admin/person/')
    dog_link = '<a href="/admin/dog/%s/">Sparky</a>' % dog.pk
    ok_(dog_link in resp.data)

    # test linking on an edit page
    resp = client.get('/admin/person/%s/' % person.pk)
    ok_('<textarea class="" id="name" name="name">Stan</textarea>' in resp.data)
    ok_('<input class="" id="age" name="age" type="text" value="10">' in resp.data)
    ok_(dog_link in resp.data)

def test_no_csrf_in_form():
    app, admin = setup()

    class Person(Document):
        name = StringField()
        age = IntField()

    Person.drop_collection()
    person = Person.objects.create(name='Eric', age=10)

    client = app.test_client()

    view = CustomModelView(Person)
    admin.add_view(view)

    resp = client.get('/admin/person/%s/' % person.pk)
    ok_('<textarea class="" id="name" name="name">Eric</textarea>' in resp.data)
    ok_('<input class="" id="age" name="age" type="text" value="10">' in resp.data)
    ok_('<label for="csrf_token">Csrf Token</label>' not in resp.data)

def test_requred_int_field():
    app, admin = setup()

    class Person(Document):
        name = StringField()
        age = IntField(required=True)

    Person.drop_collection()

    view = CustomModelView(Person)
    admin.add_view(view)

    client = app.test_client()

    resp = client.post('/admin/person/add/', data=dict(name='name', age='0'))
    eq_(resp.status_code, 302)
    ok_('This field is required.' not in resp.data)
    ok_('error.' not in resp.data)


########NEW FILE########
__FILENAME__ = test_sqlamodel
from nose.tools import eq_, ok_, raises

import wtforms

from flask import Flask

from flask.ext.sqlalchemy import SQLAlchemy
from sqlalchemy.exc import InvalidRequestError
from flask_superadmin import Admin
from flask_superadmin.model.backends.sqlalchemy.view import ModelAdmin


class CustomModelView(ModelAdmin):
    def __init__(self, model, session, name=None, category=None,
                 endpoint=None, url=None, **kwargs):
        for k, v in kwargs.iteritems():
            setattr(self, k, v)

        super(CustomModelView, self).__init__(model, session, name, category,
                                              endpoint, url)


def create_models(db):
    class Model1(db.Model):
        id = db.Column(db.Integer, primary_key=True)
        test1 = db.Column(db.String(20))
        test2 = db.Column(db.Unicode(20))
        test3 = db.Column(db.Text)
        test4 = db.Column(db.UnicodeText)

        def __init__(self, test1=None, test2=None, test3=None, test4=None):
            self.test1 = test1
            self.test2 = test2
            self.test3 = test3
            self.test4 = test4

        def __unicode__(self):
            return self.test1

    class Model2(db.Model):
        id = db.Column(db.Integer, primary_key=True)
        int_field = db.Column(db.Integer)
        bool_field = db.Column(db.Boolean)

    db.create_all()

    return Model1, Model2


def setup():
    app = Flask(__name__)
    app.config['SECRET_KEY'] = '1'
    app.config['WTF_CSRF_ENABLED'] = False
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'

    db = SQLAlchemy(app)
    admin = Admin(app)

    return app, db, admin


def test_model():
    app, db, admin = setup()
    Model1, Model2 = create_models(db)
    db.create_all()

    view = CustomModelView(Model1, db.session)
    admin.add_view(view)

    eq_(view.model, Model1)
    eq_(view.name, 'Model1')
    eq_(view.endpoint, 'model1')

    eq_(view._primary_key, 'id')

    # Verify form
    with app.test_request_context():
        Form = view.get_form()
        ok_(isinstance(Form()._fields['test1'], wtforms.TextField))
        ok_(isinstance(Form()._fields['test2'], wtforms.TextField))
        ok_(isinstance(Form()._fields['test3'], wtforms.TextAreaField))
        ok_(isinstance(Form()._fields['test4'], wtforms.TextAreaField))

    # Make some test clients
    client = app.test_client()

    resp = client.get('/admin/model1/')
    eq_(resp.status_code, 200)

    resp = client.get('/admin/model1/add/')
    eq_(resp.status_code, 200)

    resp = client.post('/admin/model1/add/',
                       data=dict(test1='test1large', test2='test2'))
    eq_(resp.status_code, 302)

    model = db.session.query(Model1).first()
    eq_(model.test1, 'test1large')
    eq_(model.test2, 'test2')
    eq_(model.test3, '')
    eq_(model.test4, '')

    resp = client.get('/admin/model1/')
    eq_(resp.status_code, 200)
    ok_('test1large' in resp.data)

    resp = client.get('/admin/model1/%s/' % model.id)
    eq_(resp.status_code, 200)

    resp = client.post('/admin/model1/%s/' % model.id, data=dict(test1='test1small', test2='test2large'))
    eq_(resp.status_code, 302)

    model = db.session.query(Model1).first()
    eq_(model.test1, 'test1small')
    eq_(model.test2, 'test2large')
    eq_(model.test3, '')
    eq_(model.test4, '')

    resp = client.post('/admin/model1/%s/delete/' % model.id)
    eq_(resp.status_code, 200)
    eq_(db.session.query(Model1).count(), 1)

    resp = client.post('/admin/model1/%s/delete/' % model.id, data={'confirm_delete': True})
    eq_(resp.status_code, 302)
    eq_(db.session.query(Model1).count(), 0)


@raises(InvalidRequestError)
def test_no_pk():
    app, db, admin = setup()

    class Model(db.Model):
        test = db.Column(db.Integer)

    view = CustomModelView(Model, db.session)
    admin.add_view(view)


def test_list_display():
    return
    app, db, admin = setup()

    Model1, Model2 = create_models(db)

    view = CustomModelView(Model1, db.session,
                           list_columns=['test1', 'test3'],
                           rename_columns=dict(test1='Column1'))
    admin.add_view(view)

    eq_(len(view._list_columns), 2)
    eq_(view._list_columns, [('test1', 'Column1'), ('test3', 'Test3')])

    client = app.test_client()

    resp = client.get('/admin/model1view/')
    ok_('Column1' in resp.data)
    ok_('Test2' not in resp.data)


def test_exclude():
    return
    app, db, admin = setup()

    Model1, Model2 = create_models(db)

    view = CustomModelView(Model1, db.session,
                           excluded_list_columns=['test2', 'test4'])
    admin.add_view(view)

    eq_(view._list_columns, [('test1', 'Test1'), ('test3', 'Test3')])

    client = app.test_client()

    resp = client.get('/admin/model1view/')
    ok_('Test1' in resp.data)
    ok_('Test2' not in resp.data)


def test_search_fields():
    return
    app, db, admin = setup()

    Model1, Model2 = create_models(db)

    view = CustomModelView(Model1, db.session,
                           searchable_columns=['test1', 'test2'])
    admin.add_view(view)

    eq_(view._search_supported, True)
    eq_(len(view._search_fields), 2)
    ok_(isinstance(view._search_fields[0], db.Column))
    ok_(isinstance(view._search_fields[1], db.Column))
    eq_(view._search_fields[0].name, 'test1')
    eq_(view._search_fields[1].name, 'test2')

    db.session.add(Model1('model1'))
    db.session.add(Model1('model2'))
    db.session.commit()

    client = app.test_client()

    resp = client.get('/admin/model1view/?search=model1')
    ok_('model1' in resp.data)
    ok_('model2' not in resp.data)


def test_url_args():
    return
    app, db, admin = setup()

    Model1, Model2 = create_models(db)

    view = CustomModelView(Model1, db.session,
                           page_size=2,
                           searchable_columns=['test1'],
                           column_filters=['test1'])
    admin.add_view(view)

    db.session.add(Model1('data1'))
    db.session.add(Model1('data2'))
    db.session.add(Model1('data3'))
    db.session.add(Model1('data4'))
    db.session.commit()

    client = app.test_client()

    resp = client.get('/admin/model1view/')
    ok_('data1' in resp.data)
    ok_('data3' not in resp.data)

    # page
    resp = client.get('/admin/model1view/?page=1')
    ok_('data1' not in resp.data)
    ok_('data3' in resp.data)

    # sort
    resp = client.get('/admin/model1view/?sort=0&desc=1')
    ok_('data1' not in resp.data)
    ok_('data3' in resp.data)
    ok_('data4' in resp.data)

    # search
    resp = client.get('/admin/model1view/?search=data1')
    ok_('data1' in resp.data)
    ok_('data2' not in resp.data)

    resp = client.get('/admin/model1view/?search=^data1')
    ok_('data2' not in resp.data)

    # like
    resp = client.get('/admin/model1view/?flt0=0&flt0v=data1')
    ok_('data1' in resp.data)

    # not like
    resp = client.get('/admin/model1view/?flt0=1&flt0v=data1')
    ok_('data2' in resp.data)


def test_non_int_pk():
    return
    app, db, admin = setup()

    class Model(db.Model):
        id = db.Column(db.String, primary_key=True)
        test = db.Column(db.String)

    db.create_all()

    view = CustomModelView(Model, db.session, form_columns=['id', 'test'])
    admin.add_view(view)

    client = app.test_client()

    resp = client.get('/admin/modelview/')
    eq_(resp.status_code, 200)

    resp = client.post('/admin/modelview/new/',
                     data=dict(id='test1', test='test2'))
    eq_(resp.status_code, 302)

    resp = client.get('/admin/modelview/')
    eq_(resp.status_code, 200)
    ok_('test1' in resp.data)

    resp = client.get('/admin/modelview/edit/?id=test1')
    eq_(resp.status_code, 200)
    ok_('test2' in resp.data)

def test_reference_linking():
    app, db, admin = setup()

    class Person(db.Model):
        id = db.Column(db.Integer, primary_key=True)
        name = db.Column(db.String(20))
        pet = db.relationship("Dog", uselist=False, backref="person")

        def __init__(self, name=None):
            self.name = name

    class Dog(db.Model):
        id = db.Column(db.Integer, primary_key=True)
        name = db.Column(db.String(20))
        person_id = db.Column(db.Integer, db.ForeignKey('person.id'))

        def __init__(self, name=None, person_id=None):
            self.name = name
            self.person_id = person_id

        def __unicode__(self):
            return self.name

    db.create_all()

    class DogAdmin(ModelAdmin):
        session = db.session

    class PersonAdmin(ModelAdmin):
        list_display = ('name', 'pet')
        fields = ('name', 'pet')
        readonly_fields = ('pet',)
        session = db.session

    db.session.add(Person(name='Stan'))
    db.session.commit()
    person = db.session.query(Person).first()

    db.session.add(Dog(name='Sparky', person_id=person.id))
    db.session.commit()
    person = db.session.query(Person).first()
    dog = db.session.query(Dog).first()

    admin.register(Dog, DogAdmin, name='Dogs')
    admin.register(Person, PersonAdmin, name='People')

    client = app.test_client()

    # test linking on a list page
    resp = client.get('/admin/person/')
    dog_link = '<a href="/admin/dog/%s/">Sparky</a>' % dog.id
    ok_(dog_link in resp.data)

    # test linking on an edit page
    resp = client.get('/admin/person/%s/' % person.id)
    ok_('<input class="" id="name" name="name" type="text" value="Stan">' in resp.data)
    ok_(dog_link in resp.data)


########NEW FILE########
