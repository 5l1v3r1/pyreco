__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Python Statsd documentation build configuration file, created by
# sphinx-quickstart on Mon May 23 12:28:27 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys
import datetime

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath(os.path.pardir))

import statsd

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.viewcode',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = statsd.__package_name__.capitalize()
copyright = '%s, %s' % (
    datetime.date.today().year,
    statsd.__author__,
)

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = statsd.__version__
# The full version, including alpha/beta/rc tags.
release = statsd.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'wolph'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_theme']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'PythonStatsddoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'PythonStatsd.tex', u'Python Statsd Documentation',
   statsd.__author__, 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'statsd', u'Python Statsd Documentation',
     [statsd.__author__], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'PythonStatsd', u'Python Statsd Documentation',
   statsd.__author__, 'PythonStatsd', statsd.__description__,
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'Python Statsd'
epub_author = statsd.__author__
epub_publisher = statsd.__author__
epub_copyright = copyright

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = flask_theme_support
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        #Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",      # class: 'w'
        Error:                     "#a40000 border:#ef2929", # class: 'err'
        Other:                     "#000000",                # class 'x'

        Comment:                   "italic #8f5902", # class: 'c'
        Comment.Preproc:           "noitalic",       # class: 'cp'

        Keyword:                   "bold #004461",   # class: 'k'
        Keyword.Constant:          "bold #004461",   # class: 'kc'
        Keyword.Declaration:       "bold #004461",   # class: 'kd'
        Keyword.Namespace:         "bold #004461",   # class: 'kn'
        Keyword.Pseudo:            "bold #004461",   # class: 'kp'
        Keyword.Reserved:          "bold #004461",   # class: 'kr'
        Keyword.Type:              "bold #004461",   # class: 'kt'

        Operator:                  "#582800",   # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",        # class: 'n'
        Name.Attribute:            "#c4a000",        # class: 'na' - to be revised
        Name.Builtin:              "#004461",        # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",        # class: 'bp'
        Name.Class:                "#000000",        # class: 'nc' - to be revised
        Name.Constant:             "#000000",        # class: 'no' - to be revised
        Name.Decorator:            "#888",           # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",        # class: 'ni'
        Name.Exception:            "bold #cc0000",   # class: 'ne'
        Name.Function:             "#000000",        # class: 'nf'
        Name.Property:             "#000000",        # class: 'py'
        Name.Label:                "#f57900",        # class: 'nl'
        Name.Namespace:            "#000000",        # class: 'nn' - to be revised
        Name.Other:                "#000000",        # class: 'nx'
        Name.Tag:                  "bold #004461",   # class: 'nt' - like a keyword
        Name.Variable:             "#000000",        # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",        # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",        # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",        # class: 'vi' - to be revised

        Number:                    "#990000",        # class: 'm'

        Literal:                   "#000000",        # class: 'l'
        Literal.Date:              "#000000",        # class: 'ld'

        String:                    "#4e9a06",        # class: 's'
        String.Backtick:           "#4e9a06",        # class: 'sb'
        String.Char:               "#4e9a06",        # class: 'sc'
        String.Doc:                "italic #8f5902", # class: 'sd' - like a comment
        String.Double:             "#4e9a06",        # class: 's2'
        String.Escape:             "#4e9a06",        # class: 'se'
        String.Heredoc:            "#4e9a06",        # class: 'sh'
        String.Interpol:           "#4e9a06",        # class: 'si'
        String.Other:              "#4e9a06",        # class: 'sx'
        String.Regex:              "#4e9a06",        # class: 'sr'
        String.Single:             "#4e9a06",        # class: 's1'
        String.Symbol:             "#4e9a06",        # class: 'ss'

        Generic:                   "#000000",        # class: 'g'
        Generic.Deleted:           "#a40000",        # class: 'gd'
        Generic.Emph:              "italic #000000", # class: 'ge'
        Generic.Error:             "#ef2929",        # class: 'gr'
        Generic.Heading:           "bold #000080",   # class: 'gh'
        Generic.Inserted:          "#00A000",        # class: 'gi'
        Generic.Output:            "#888",           # class: 'go'
        Generic.Prompt:            "#745334",        # class: 'gp'
        Generic.Strong:            "bold #000000",   # class: 'gs'
        Generic.Subheading:        "bold #800080",   # class: 'gu'
        Generic.Traceback:         "bold #a40000",   # class: 'gt'
    }

########NEW FILE########
__FILENAME__ = average
import statsd


class Average(statsd.Client):
    '''Class to implement a statsd "average" message.
    This value will be averaged against other messages before being
    sent.

    See https://github.com/chuyskywalker/statsd/blob/master/README.md for
    more info.

    >>> average = Average('application_name')
    >>> # do something here
    >>> average.send('subname', 123)
    True
    '''

    def send(self, subname, value):
        '''Send the data to statsd via self.connection

        :keyword subname: The subname to report the data to (appended to the
            client name)
        :keyword value: The raw value to send
        '''
        name = self._get_name(self.name, subname)
        self.logger.info('%s: %d', name, value)
        return statsd.Client._send(self, {name: '%d|a' % value})


########NEW FILE########
__FILENAME__ = client
import logging
import statsd

from . import compat


class Client(object):
    '''Statsd Client Object

    :keyword name: The name for this client
    :type name: str
    :keyword connection: The connection to use, will be automatically created if
        not given
    :type connection: :class:`~statsd.connection.Connection`

    >>> client = Client('test')
    >>> client
    <Client:test@<Connection[localhost:8125] P(1.0)>>
    >>> client.get_client(u'spam')
    <Client:test.spam@<Connection[localhost:8125] P(1.0)>>
    '''

    #: The name of the client, everything sent from this client will be \
    #: prefixed by name
    name = None

    #: The :class:`~statsd.connection.Connection` to use, creates a new
    #: connection if no connection is given
    connection = None

    def __init__(self, name, connection=None):
        self.name = self._get_name(name)
        if not connection:
            connection = statsd.Connection()
        self.connection = connection
        self.logger = logging.getLogger(
            '%s.%s' % (__name__, self.__class__.__name__))

    @classmethod
    def _get_name(cls, *name_parts):
        name_parts = [compat.to_str(x) for x in name_parts if x]
        return '.'.join(name_parts)

    def get_client(self, name=None, class_=None):
        '''Get a (sub-)client with a separate namespace
        This way you can create a global/app based client with subclients
        per class/function

        :keyword name: The name to use, if the name for this client was `spam`
            and the `name` argument is `eggs` than the resulting name will be
            `spam.eggs`
        :type name: str
        :keyword class_: The :class:`~statsd.client.Client` subclass to use
            (e.g. :class:`~statsd.timer.Timer` or
            :class:`~statsd.counter.Counter`)
        :type class_: :class:`~statsd.client.Client`
        '''

        # If the name was given, use it. Otherwise simply clone
        name = self._get_name(self.name, name)

        # Create using the given class, or the current class
        if not class_:
            class_ = self.__class__

        return class_(
            name=name,
            connection=self.connection,
        )

    def __repr__(self):
        return '<%s:%s@%r>' % (
            self.__class__.__name__,
            self.name,
            self.connection,
        )

    def _send(self, data):
        return self.connection.send(data)


########NEW FILE########
__FILENAME__ = compat
"""
Compatability library for python2 and python3 support.
"""
import sys
import decimal

PY3K = sys.version_info >= (3, 0)

def iter_dict(dict_):  # pragma: no cover
    if PY3K:
        return dict_.items()
    else:
        return dict_.iteritems()


def to_str(value):  # pragma: no cover
    if PY3K and isinstance(value, bytes):
        value = value.encode('utf-8', 'replace')
    elif not PY3K and isinstance(value, unicode):
        value = value.encode('utf-8', 'replace')
    return value

if PY3K:  # pragma: no cover
    NUM_TYPES = int, float, decimal.Decimal
else:  # pragma: no cover
    NUM_TYPES = int, long, float, decimal.Decimal

########NEW FILE########
__FILENAME__ = connection
import logging
import socket
import random

from . import compat


class Connection(object):
    '''Statsd Connection

    :keyword host: The statsd host to connect to, defaults to `localhost`
    :type host: str
    :keyword port: The statsd port to connect to, defaults to `8125`
    :type port: int
    :keyword sample_rate: The sample rate, defaults to `1` (meaning always)
    :type sample_rate: int
    :keyword disabled: Turn off sending UDP packets, defaults to ``False``
    :type disabled: bool
    '''

    default_host = 'localhost'
    default_port = 8125
    default_sample_rate = 1
    default_disabled = False

    @classmethod
    def set_defaults(
            cls, host='localhost', port=8125, sample_rate=1, disabled=False):
        cls.default_host = host
        cls.default_port = port
        cls.default_sample_rate = sample_rate
        cls.default_disabled = disabled

    def __init__(self, host=None, port=None, sample_rate=None, disabled=None):
        self._host = host or self.default_host
        self._port = int(port or self.default_port)
        self._sample_rate = sample_rate or self.default_sample_rate
        self._disabled = disabled or self.default_disabled
        self.logger = logging.getLogger(
            '%s.%s' % (__name__, self.__class__.__name__))
        self.udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.udp_sock.connect((self._host, self._port))
        self.logger.debug(
            'Initialized connection to %s:%d with P(%.1f)',
            self._host, self._port, self._sample_rate)

    def send(self, data, sample_rate=None):
        '''Send the data over UDP while taking the sample_rate in account

        The sample rate should be a number between `0` and `1` which indicates
        the probability that a message will be sent. The sample_rate is also
        communicated to `statsd` so it knows what multiplier to use.

        :keyword data: The data to send
        :type data: dict
        :keyword sample_rate: The sample rate, defaults to `1` (meaning always)
        :type sample_rate: int
        '''
        if self._disabled:
            self.logger.debug('Connection disabled, not sending data')
            return False
        if sample_rate is None:
            sample_rate = self._sample_rate

        sampled_data = {}
        if sample_rate < 1:
            if random.random() <= sample_rate:
                # Modify the data so statsd knows our sample_rate
                for stat, value in compat.iter_dict(data):
                    sampled_data[stat] = '%s|@%s' % (data[stat], sample_rate)
        else:
            sampled_data = data

        try:
            for stat, value in compat.iter_dict(sampled_data):
                send_data = ('%s:%s' % (stat, value)).encode("utf-8")
                self.udp_sock.send(send_data)
            return True
        except Exception as e:
            self.logger.exception('unexpected error %r while sending data', e)
            return False

    def __repr__(self):
        return '<%s[%s:%d] P(%.1f)>' % (
            self.__class__.__name__,
            self._host,
            self._port,
            self._sample_rate,
        )


########NEW FILE########
__FILENAME__ = counter
import statsd


class Counter(statsd.Client):
    '''Class to implement a statd counter

    Additional documentation is available at the
    parent class :class:`~statsd.client.Client`

    The values can be incremented/decremented by using either the
    `increment()` and `decrement()` methods or by simply adding/deleting from
    the object.

    >>> counter = Counter('application_name')
    >>> counter += 10

    >>> counter = Counter('application_name')
    >>> counter -= 10
    '''

    def _send(self, subname, delta):
        '''Send the data to statsd via self.connection

        :keyword subname: The subname to report the data to (appended to the
            client name)
        :type subname: str
        :keyword delta: The delta to add to/remove from the counter
        :type delta: int
        '''
        name = self._get_name(self.name, subname)
        self.logger.info('%s: %d', name, delta)
        return statsd.Client._send(self, {name: '%d|c' % delta})

    def increment(self, subname=None, delta=1):
        '''Increment the counter with `delta`

        :keyword subname: The subname to report the data to (appended to the
            client name)
        :type subname: str
        :keyword delta: The delta to add to the counter
        :type delta: int

        >>> counter = Counter('application_name')
        >>> counter.increment('counter_name', 10)
        True
        >>> counter.increment(delta=10)
        True
        >>> counter.increment('counter_name')
        True
        '''
        return self._send(subname, int(delta))

    def decrement(self, subname=None, delta=1):
        '''Decrement the counter with `delta`

        :keyword subname: The subname to report the data to (appended to the
            client name)
        :type subname: str
        :keyword delta: The delta to remove from the counter
        :type delta: int

        >>> counter = Counter('application_name')
        >>> counter.decrement('counter_name', 10)
        True
        >>> counter.decrement(delta=10)
        True
        >>> counter.decrement('counter_name')
        True
        '''
        return self._send(subname, -int(delta))

    def __add__(self, delta):
        '''Increment the counter with `delta`

        :keyword delta: The delta to add to the counter
        :type delta: int
        '''
        self.increment(delta=delta)
        return self

    def __sub__(self, delta):
        '''Decrement the counter with `delta`

        :keyword delta: The delta to remove from the counter
        :type delta: int
        '''
        self.decrement(delta=delta)
        return self


def increment(key, delta=1):
    '''Increment the counter with `delta`

    :keyword key: The key to report the data to
    :type key: str
    :keyword delta: The delta to add to the counter
    :type delta: int
    '''
    return Counter(key).increment(delta=delta)


def decrement(key, delta=1):
    '''Decrement the counter with `delta`

    :keyword key: The key to report the data to
    :type key: str
    :keyword delta: The delta to remove from the counter
    :type delta: int
    '''
    return Counter(key).decrement(delta=delta)


########NEW FILE########
__FILENAME__ = gauge
import statsd

from . import compat


class Gauge(statsd.Client):
    '''Class to implement a statsd gauge

    '''

    def send(self, subname, value):
        '''Send the data to statsd via self.connection

        :keyword subname: The subname to report the data to (appended to the
            client name)
        :type subname: str
        :keyword value: The gauge value to send
        '''
        assert isinstance(value, compat.NUM_TYPES)
        name = self._get_name(self.name, subname)
        self.logger.info('%s: %s', name, value)
        return statsd.Client._send(self, {name: '%s|g' % value})


########NEW FILE########
__FILENAME__ = raw
import statsd
import datetime as dt


class Raw(statsd.Client):
    '''Class to implement a statsd raw message.
    If a service has already summarized its own
    data for e.g. inspection purposes, use this
    summarized data to send to a statsd that has
    the raw patch, and this data will be sent
    to graphite pretty much unchanged.

    See https://github.com/chuyskywalker/statsd/blob/master/README.md for
    more info.

    >>> raw = Raw('test')
    >>> raw.send('name', 12435)
    True
    >>> import time
    >>> raw.send('name', 12435, time.time())
    True
    '''

    def send(self, subname, value, timestamp=None):
        '''Send the data to statsd via self.connection

        :keyword subname: The subname to report the data to (appended to the
            client name)
        :type subname: str
        :keyword value: The raw value to send
        '''
        if timestamp is None:
            ts = int(dt.datetime.now().strftime("%s"))
        else:
            ts = timestamp
        name = self._get_name(self.name, subname)
        self.logger.info('%s: %s %s' % (name, value, ts))
        return statsd.Client._send(self, {name: '%s|r|%s' % (value, ts)})


########NEW FILE########
__FILENAME__ = timer
import contextlib
import time
import statsd


class Timer(statsd.Client):
    '''
    Statsd Timer Object

    Additional documentation is available at the parent class
    :class:`~statsd.client.Client`

    :keyword name: The name for this timer
    :type name: str
    :keyword connection: The connection to use, will be automatically created if
        not given
    :type connection: :class:`~statsd.connection.Connection`
    :keyword min_send_threshold: Timings smaller than this will not be sent so -1
        can be used for all.
    :type min_send_threshold: int

    >>> timer = Timer('application_name')
    >>> timer.start()
    >>>  # do something
    >>> timer.stop('executed_action')
    True
    '''

    def __init__(self, name, connection=None, min_send_threshold=-1):
        super(Timer, self).__init__(name, connection=connection)
        self._start = None
        self._last = None
        self._stop = None
        self.min_send_threshold = min_send_threshold

    def start(self):
        '''Start the timer and store the start time, this can only be executed
        once per instance'''
        assert self._start is None, (
            'Unable to start, the timer is already running')
        self._last = self._start = time.time()

    def send(self, subname, delta):
        '''Send the data to statsd via self.connection

        :keyword subname: The subname to report the data to (appended to the
            client name)
        :type subname: str
        :keyword delta: The time delta (time.time() - time.time()) to report
        :type delta: float
        '''
        ms = delta * 1000
        if ms > self.min_send_threshold:
            name = self._get_name(self.name, subname)
            self.logger.info('%s: %0.08fms', name, ms)
            return statsd.Client._send(self, {name: '%0.08f|ms' % ms})
        else:
            return True

    def intermediate(self, subname):
        '''Send the time that has passed since our last measurement

        :keyword subname: The subname to report the data to (appended to the
            client name)
        :type subname: str
        '''
        t = time.time()
        response = self.send(subname, t - self._last)
        self._last = t
        return response

    def stop(self, subname='total'):
        '''Stop the timer and send the total since `start()` was run

        :keyword subname: The subname to report the data to (appended to the
            client name)
        :type subname: str
        '''
        assert self._stop is None, (
            'Unable to stop, the timer is already stopped')
        self._stop = time.time()
        return self.send(subname, self._stop - self._start)

    def _decorate(self, name, function, class_=None):
        class_ = class_ or Timer

        def _decorator(*args, **kwargs):
            timer = self.get_client(name, class_)
            timer.start()
            try:
                return function(*args, **kwargs)
            finally:
                # Stop the timer, send the message and cleanup
                timer.stop('')
                del timer

        return _decorator

    def decorate(self, function_or_name):
        '''Decorate a function to time the execution

        The method can be called with or without a name. If no name is given
        the function defaults to the name of the function.

        :keyword function_or_name: The name to post to or the function to wrap

        >>> from statsd import Timer
        >>> timer = Timer('application_name')
        >>>
        >>> @timer.decorate
        ... def some_function():
        ...     # resulting timer name: application_name.some_function
        ...     pass
        >>>
        >>> @timer.decorate('my_timer')
        ... def some_other_function():
        ...     # resulting timer name: application_name.my_timer
        ...     pass

        '''
        if callable(function_or_name):
            return self._decorate(function_or_name.__name__, function_or_name)
        else:
            return lambda f: self._decorate(function_or_name, f)

    @contextlib.contextmanager
    def time(self, subname=None, class_=None):
        '''Returns a context manager to time execution of a block of code.

        :keyword subname: The subname to report data to
        :type subname: str
        :keyword class_: The :class:`~statsd.client.Client` subclass to use
            (e.g. :class:`~statsd.timer.Timer` or
            :class:`~statsd.counter.Counter`)
        :type class_: :class:`~statsd.client.Client`

        >>> from statsd import Timer
        >>> timer = Timer('application_name')
        >>>
        >>> with timer.time():
        ...     # resulting timer name: application_name
        ...     pass
        >>>
        >>>
        >>> with timer.time('context_timer'):
        ...     # resulting timer name: application_name.context_timer
        ...     pass

        '''
        if class_ is None:
            class_ = Timer
        timer = self.get_client(subname, class_)
        timer.start()
        yield
        timer.stop('')

########NEW FILE########
__FILENAME__ = test_connection
import mock
import statsd
import unittest

class ConnectionException(Exception):
    pass

class TestConnection(unittest.TestCase):
    def test_set_disabled_to_false_by_default(self):
        result = statsd.connection.Connection()
        assert result._disabled is False

    def test_send_returns_false_if_disabled(self):
        connection = statsd.connection.Connection(disabled=True)
        assert connection.send({'data': True}) is False
        assert connection.send({'data': True}, 1) is False

    @mock.patch('socket.socket')
    def test_send_returns_true_if_enabled(self, mock_class):
        connection = statsd.connection.Connection()
        assert connection.send({'data': True}) is True
        assert connection.send({'test:1|c': True}, 0.99999999)
        assert connection.send({'test:1|c': True}, 0.00000001)
        assert connection.send({'data': True}, 1) is True

    def test_send_exception(self, mock_class=None):
        connection = statsd.connection.Connection()
        socket = mock.MagicMock()
        send = mock.PropertyMock(side_effect=ConnectionException)
        type(socket).send = send
        connection.udp_sock = socket
        assert not connection.send({'data': True})

    def test_connection_set_defaults(self):
        connection = statsd.connection.Connection()
        assert connection._host == 'localhost'
        assert connection._port == 8125
        assert connection._sample_rate == 1
        assert connection._disabled is False

        statsd.connection.Connection.set_defaults('127.0.0.1', 1234, 10, True)
        connection = statsd.connection.Connection()
        assert connection._host == '127.0.0.1'
        assert connection._port == 1234
        assert connection._sample_rate == 10
        assert connection._disabled is True

        statsd.connection.Connection.set_defaults()
        connection = statsd.connection.Connection()
        assert connection._host == 'localhost'
        assert connection._port == 8125
        assert connection._sample_rate == 1
        assert connection._disabled is False

    def test_repr(self):
        connection = statsd.connection.Connection()
        assert '<Connection[localhost:8125] P(1.0)>' == repr(connection)



########NEW FILE########
__FILENAME__ = test_counter
from __future__ import with_statement
from unittest import TestCase
import mock
import statsd


class TestCounter(TestCase):

    def setUp(self):
        self.counter = statsd.Counter('testing')

    def test_increment(self):
        with mock.patch('statsd.Client') as mock_client:
            self.counter.increment('')
            mock_client._send.assert_called_with(mock.ANY, {'testing': '1|c'})

            self.counter.increment('', 2)
            mock_client._send.assert_called_with(mock.ANY, {'testing': '2|c'})

            self.counter += 3
            mock_client._send.assert_called_with(mock.ANY, {'testing': '3|c'})

            statsd.increment('testing', 4)
            mock_client._send.assert_called_with(mock.ANY, {'testing': '4|c'})

            statsd.increment('testing')
            mock_client._send.assert_called_with(mock.ANY, {'testing': '1|c'})

    def test_decrement(self):
        with mock.patch('statsd.Client') as mock_client:
            self.counter.decrement('')
            mock_client._send.assert_called_with(mock.ANY, {'testing': '-1|c'})

            self.counter.decrement('', 2)
            mock_client._send.assert_called_with(mock.ANY, {'testing': '-2|c'})

            self.counter -= 3
            mock_client._send.assert_called_with(mock.ANY, {'testing': '-3|c'})

            statsd.decrement('testing', 4)
            mock_client._send.assert_called_with(mock.ANY, {'testing': '-4|c'})

            statsd.decrement('testing')
            mock_client._send.assert_called_with(mock.ANY, {'testing': '-1|c'})

    def test_decrement_with_an_int(self):
        with mock.patch('statsd.Client') as mock_client:
            self.counter.decrement('', 2)
            mock_client._send.assert_called_with(mock.ANY, {'testing': '-2|c'})

########NEW FILE########
__FILENAME__ = test_gauge
from __future__ import with_statement
from unittest import TestCase
from decimal import Decimal
import mock
import statsd


class TestGauge(TestCase):

    def setUp(self):
        self.gauge = statsd.Gauge('testing')

    def test_send_float(self):
        with mock.patch('statsd.Client') as mock_client:
            self.gauge.send('', 10.5)
            mock_client._send.assert_called_with(mock.ANY, {'testing': '10.5|g'})

    def test_send_decimal(self):
        with mock.patch('statsd.Client') as mock_client:
            self.gauge.send('', Decimal('6.576'))
            mock_client._send.assert_called_with(mock.ANY, {'testing': '6.576|g'})

    def test_send_integer(self):
        with mock.patch('statsd.Client') as mock_client:
            self.gauge.send('', 1)
            mock_client._send.assert_called_with(mock.ANY, {'testing': '1|g'})

########NEW FILE########
__FILENAME__ = test_timer
from __future__ import with_statement
from unittest import TestCase
import mock
import statsd


class TestTimerBase(TestCase):
    def tearDown(self):
        self._time_patch.stop()

    def get_time(self, mock_client, key):
        return float(self.get_arg(mock_client, key).split('|')[0])

    def get_arg(self, mock_client, key):
        return mock_client._send.call_args[0][1][key]


class TestTimerDecorator(TestTimerBase):
    def setUp(self):
        self.timer = statsd.Timer('timer')

        # get time.time() to always return the same value so that this test
        # isn't system load dependant.
        self._time_patch = mock.patch('time.time')
        time_time = self._time_patch.start()

        def generator():
            i = 0.0
            while True:
                i += 0.1234
                yield i
        time_time.side_effect = generator()

    @mock.patch('statsd.Client')
    def test_decorator_a(self, mock_client):
        @self.timer.decorate
        def a():
            pass

        a()

        assert self.get_time(mock_client, 'timer.a') == 123.4, \
            'This test must execute within 2ms'

    @mock.patch('statsd.Client')
    def test_decorator_named_spam(self, mock_client):
        @self.timer.decorate('spam')
        def a():
            pass
        a()

        assert self.get_time(mock_client, 'timer.spam') == 123.4, \
            'This test must execute within 2ms'

    @mock.patch('statsd.Client')
    def test_nested_naming_decorator(self, mock_client):
        timer = self.timer.get_client('eggs0')

        @timer.decorate('d0')
        def a():
            pass
        a()

        assert self.get_time(mock_client, 'timer.eggs0.d0') == 123.4, \
            'This test must execute within 2ms'


class TestTimerContextManager(TestTimerBase):

    def setUp(self):
        self.timer = statsd.Timer('cm')

        # get time.time() to always return the same value so that this test
        # isn't system load dependant.
        self._time_patch = mock.patch('time.time')
        time_time = self._time_patch.start()

        def generator():
            i = 0.0
            while True:
                i += 0.1234
                yield i
        time_time.side_effect = generator()

    @mock.patch('statsd.Client')
    def test_context_manager_default(self, mock_client):
        timer = self.timer.get_client('default')
        with timer.time():
            pass

        assert self.get_time(mock_client, 'cm.default') == 123.4, \
            'This test must execute within 2ms'

    @mock.patch('statsd.Client')
    def test_context_manager_named(self, mock_client):
        timer = self.timer.get_client('named')
        with timer.time('name'):
            pass

        assert self.get_time(mock_client, 'cm.named.name') == 123.4, \
            'This test must execute within 2ms'

    @mock.patch('statsd.Client')
    def test_context_manager_class(self, mock_client):
        timer = self.timer.get_client('named')
        with timer.time(class_=statsd.Timer):
            pass

        assert self.get_time(mock_client, 'cm.named') == 123.4, \
            'This test must execute within 2ms'


class TestTimerAdvancedUsage(TestTimerDecorator):

    @mock.patch('statsd.Client')
    def test_timer_total(self, mock_client):
        timer4 = statsd.Timer('timer4')
        timer4.start()
        timer4.stop()
        assert self.get_time(mock_client, 'timer4.total') == 123.4, \
            'This test must execute within 2ms'

        timer5 = statsd.Timer('timer5')
        timer5.start()
        timer5.stop('test')
        assert self.get_time(mock_client, 'timer5.test') == 123.4, \
            'This test must execute within 2ms'

    @mock.patch('statsd.Client')
    def test_timer_intermediate(self, mock_client):
        timer6 = statsd.Timer('timer6')
        timer6.start()
        timer6.intermediate('extras')
        assert self.get_time(mock_client, 'timer6.extras') == 123.4, \
            'This test must execute within 2ms'
        timer6.stop()
        assert self.get_time(mock_client, 'timer6.total') == 370.2, \
            'This test must execute within 2ms'

        timer7 = statsd.Timer('timer7')
        timer7.start()
        timer7.intermediate('extras')
        assert self.get_time(mock_client, 'timer7.extras') == 123.4, \
            'This test must execute within 2ms'
        timer7.stop('test')
        assert self.get_time(mock_client, 'timer7.test') == 370.2, \
            'This test must execute within 2ms'


class TestTimerZero(TestTimerBase):
    def setUp(self):
        # get time.time() to always return the same value so that this test
        # isn't system load dependant.
        self._time_patch = mock.patch('time.time')
        time_time = self._time_patch.start()

        def generator():
            while True:
                yield 0
        time_time.side_effect = generator()

    def tearDown(self):
        self._time_patch.stop()

    @mock.patch('statsd.Client')
    def test_timer_zero(self, mock_client):
        timer8 = statsd.Timer('timer8', min_send_threshold=0)
        timer8.start()
        timer8.stop()
        assert mock_client._send.call_args is None, \
            '0 timings shouldnt be sent'

        timer9 = statsd.Timer('timer9', min_send_threshold=0)
        timer9.start()
        timer9.stop('test')
        assert mock_client._send.call_args is None, \
            '0 timings shouldnt be sent'


########NEW FILE########
