__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# pyqcy documentation build configuration file, created by
# sphinx-quickstart on Sat May  5 00:30:04 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

import pyqcy

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.coverage']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'pyqcy'
copyright = u'2012, Karol Kuczmarski'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
import re
version = re.search(r"\d+\.\d+", pyqcy.__version__).group()
# The full version, including alpha/beta/rc tags.
release = pyqcy.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'pyqcydoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'pyqcy.tex', u'pyqcy Documentation',
   u'Karol Kuczmarski', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pyqcy', u'pyqcy Documentation',
     [u'Karol Kuczmarski'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'pyqcy', u'pyqcy Documentation',
   u'Karol Kuczmarski', 'pyqcy', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = collections
"""
Generators for arbitrary collections (tuples, lists, dictionaries).
"""
import random
import functools

from pyqcy.arbitraries import arbitrary, is_arbitrary


@arbitrary
def tuple_(*args, **kwargs):
    """Generator for arbitrary tuples.

    The tuples are always of the same length but their values
    may come from different generators. There two ways to specify
    those generators - either enumerate them all::

        tuple_(int_(min=0, max=255), str_(max_length=64))

    or use ``n`` argument with a single generator to get uniform tuples::

        ip_addresses = tuple_(int_(min=0, max=255), n=4)
        ip_addresses = tuple_(of=int_(min=0, max=255), n=4)

    Those two styles are mutually exclusive - only one can be used at a time.

    :param of: Generator used to generate tuple values
    :param n: Tuple length
    """
    n = kwargs.get('n')
    if n is None:
        return tuple(map(next, args))

    of = kwargs.get('of')
    if of:
        if args:
            raise TypeError("ambiguous invocation - "
                            "more than one possible type for tuple elements")
    else:
        if len(args) != 1:
            raise TypeError("no/invalid type of arbitrary tuple elements")
        of = args[0]

    return tuple(next(of) for _ in xrange(n))


#: Generator for arbitrary pairs, combining two values
#: coming from a single generator into tuple of length 2.
two = functools.partial(tuple_, n=2)

#: Generator for arbitrary triples, combining two values
#: coming from a single generator into tuple of length 3.
three = functools.partial(tuple_, n=3)

#: Generator for arbitrary quadruples, combining two values
#: coming from a single generator into tuple of length 4.
four = functools.partial(tuple_, n=4)


@arbitrary
def list_(of, min_length=0, max_length=1024):
    """Generator for arbitrary lists.

    Parameters for this generator allow for adjusting the length
    of resulting list and elements they contain.

    :param of: Generator for list elements
    :param min_length: A minimum length of list to generate
    :param max_length: A maximum length of list to generate

    Example of test property that uses :func:`list_`::

        @qc
        def calculating_average(
            l=list_(of=int_(min=0, max=1024),
                    min_length=16, max_length=2048)
        ):
            average = sum(l) / len(l)
            assert min(l) <= average <= max(l)
    """
    length = random.randint(min_length, max_length)
    if is_arbitrary(of):
        return [next(of) for _ in xrange(length)]
    return [random.choice(of) for _ in xrange(length)]


@arbitrary
def set_(of, min_length=0, max_length=1024):
    """Generator for arbitrary sets.

    Parameters for this generator allow for adjusting the size
    of resulting set and elements they contain.

    :param of: Generator for set elements
    :param min_length: A minimum size of set to generate
    :param max_length: A maximum size of set to generate
    """
    size = random.randint(min_length, max_length)
    if is_arbitrary(of):
        return set(next(of) for _ in xrange(size))
    return set(random.choice(of) for _ in xrange(size))


@arbitrary
def dict_(keys=None, values=None, items=None,
          min_length=0, max_length=1024):
    """Generator for arbitrary dictionaries.

    Dictionaries are specified using generators - either for
    ``keys`` and ``values`` separately::

        dict_(keys=str_(max_length=64), values=str_(max_length=64))

    or already combined into ``items`` (which should yield key-value pairs)::

        dict_(items=two(str_(max_length=64)))

    Those two styles are mutually exclusive - only one can be used at a time.

    :param keys: Generator for dictionary keys
    :param values: Generator for dictionary values
    :param items: Generator for dictionary items (2-element tuples).
    :param min_length: A minimum number of items
                       the resulting dictionary will contain
    :param max_length: A maximum number of items
                       the resulting dictionary will contain
    """
    kv_provided = keys is not None and values is not None
    items_provided = items is not None
    if not (kv_provided or items_provided):
        raise ValueError("no generators for dictionary items provided")
    if kv_provided and items_provided:
        raise ValueError("ambiguous invocation - "
                         "provide either keys and values, or items")

    next_item = ((lambda: next(items)) if items_provided else
                 (lambda: (next(keys), next(values))))
    length = random.randint(min_length, max_length)
    return dict(next_item() for _ in xrange(length))

########NEW FILE########
__FILENAME__ = combinators
"""
Combinators for generators of arbitrary values.
"""
from __future__ import absolute_import

import functools
import inspect
import random

from collections import Iterable, Mapping
try:
    from collections import OrderedDict
except ImportError:
    OrderedDict = dict  # fallback for Python 2.6

from pyqcy.arbitraries import arbitrary, is_arbitrary, to_arbitrary
from pyqcy.utils import recursive


def apply(func, *args, **kwargs):
    """Generator that applies a specific function to objects returned
    by given generator(s).

    Any number of generators can be passed as arguments, and they can
    be both positional (``args``) or keyword arguments (``kwargs``).
    In either case, the same invocation style (i.e. positional or keyword)
    will be used when calling the ``func`` with actual values
    obtained from given generators.

    As an example, the following call::

        apply(json.dumps, dict_(items=two(str)))

    will create a generator that yields results of ``json.dumps(d)``,
    where ``d`` is an arbitrary dictionary that maps strings to strings.

    Similarly, using :func:`apply` as shown below::

        apply(itertools.product, list_(of=int), repeat=4)

    gets us a generator that produces results of
    ``itertools.product(l, repeat=4)``, where ``l`` is an arbitrary
    list of ``int``\ s.
    """
    if not func:
        raise ValueError("no function provided")
    if not callable(func):
        raise TypeError("expected a callable")

    func_args = [next(to_arbitrary(arg)) for arg in args]
    func_kwargs = dict((k, next(to_arbitrary(v)))
                       for (k, v) in kwargs.iteritems())

    @arbitrary
    def generator():
        return func(*func_args, **func_kwargs)
    return generator


def data(schema):
    """Generator that outputs data structures conforming to given schema.

    :param schema: A list or dictionary that contains either
                   immediate values or other generators.

    .. note::

       ``schema`` can be recursive and combine lists with dictionaries
       into complex structures. You can have nested dictionaries,
       lists containing lists, dictionaries with lists as values, and so on.

    A typical example of using :func:`data`:

    .. code-block:: python

        import string

        @qc
        def creating_user_works(
            request=data({
                'login': str_(of=string.ascii_letters | string.digits,
                              min_length=3, max_length=32),
                'password': str_(min_length=8, max_length=128),
            })
        ):
            response = create_user(request['login'], request['password'])
            assert response['status'] == "OK"

    """
    if schema is None:
        raise ValueError("no schema specified")

    is_data_structure = (isinstance(schema, Iterable)
                         and not inspect.isgenerator(schema))
    if not is_data_structure:
        raise TypeError("schema must be a data structure")

    def instance_of(s):
        """Constructs a new data structure instance conforming
        to given schema. This function proceeds recursively.
        """
        if isinstance(s, Mapping):
            res = (OrderedDict()
                   if isinstance(s, OrderedDict)
                   else dict())
            items = s.iteritems()
        else:
            res = [None] * len(s)
            items = enumerate(s)

        for key, value in items:
            if is_arbitrary(value):
                value = to_arbitrary(value)
                res[key] = next(value)
            elif isinstance(value, Iterable):
                res[key] = instance_of(value)
            else:
                res[key] = value

        if isinstance(s, tuple):
            res = tuple(res)
        return res

    @arbitrary
    def generator():
        return instance_of(schema)
    return generator


def combinator(func):
    """Decorator for arbitrary combinator functions which take
    a collection of arguments as either an actual list/sequence,
    or as positional arguments.

    In other words, it makes it possible to use
    the following two forms of invocation::

        func([1, 2, 3])
        func(1, 2, 3)

    In both cases ``func`` receives 1, 2 and 3 as
    positional arguments (``*args``).
    """
    _2arbitrary = recursive(
        lambda obj: to_arbitrary(obj) if is_arbitrary(obj) else obj)

    @arbitrary
    @functools.wraps(func)
    def wrapped(*args, **kwargs):
        if not args:
            return func(**kwargs)

        new_args = []
        for arg in args:
            arg_collection = (isinstance(arg, Iterable)
                              and not is_arbitrary(arg))
            if arg_collection:
                arg = map(_2arbitrary, arg)
                new_args.extend(arg)
            else:
                arg = _2arbitrary(arg)
                new_args.append(arg)
        return func(*new_args, **kwargs)

    return wrapped


@combinator
def elements(*args, **kwargs):
    """Generator that returns random elements from given set.

    Elements can be passed either directly as arguments::

        elements(1, 2, 3)

    or as a list::

        elements([1, 2, 3])

    Every element has equal probability of being chosen.

    :param count: Optional number of elements in every returned subset.
                  If omitted, a single element will be yield every time.
                  If provided, it should always be passed as keyword argument,
                  e.g. ``elements(range(10), count=3)``.

                  This can be also a generator - such as :func:`int_` -
                  if there's a need to randomize the subset size, too.

    .. note::

        There is difference between ``elements(foo)``
        and ``elements(foo, count=1)``. The first form returns
        random element from the set ``foo``, while the second returns random
        *1-element subset* of ``foo`` - ``x`` vs ``[x]``, essentially.
    """
    if not args:
        raise ValueError("cannot pick random elements from empty sequence")

    count = kwargs.get('count', None)
    if count is None:
        return random.choice(args)
    if is_arbitrary(count):
        count = next(to_arbitrary(count))

    count = min(count, len(args))
    return random.sample(args, count)


@combinator
def one_of(*args):
    """Generator that yields values coming from given set of generators.

    Generators can be passed either directly as arguments::

        one_of(int, float)

    or as a list::

        one_of([int, float])

    Every generator has equal probability of being chosen.
    If you need non-uniform probability distribution,
    use the :func:`frequency` function.
    """
    if not args:
        raise ValueError("no generators to choose from")
    return next(random.choice(args))


@combinator
def frequency(*args):
    """Generator that yields coming from given set of generators,
    according to their probability distribution.

    The distribution is just a set of tuples: ``(gen, freq)``
    which can be passed either directly as arguments::

        frequency((int, 1), (float, 2))

    or a a list::

        frequency([(int, 1), (float, 2)])

    The second element of tuple (``freq``) is the relative frequency
    of values from particular generator, compared to those from other
    generators. In both examples above the resulting generator will
    yield ``float``\ s twice as often as ``int``\ s.

    Typically, it's convenient to use floating-point frequencies
    that sum to ``1.0`` or integer frequencies that sum to ``100``.
    """
    if not args:
        raise ValueError("no generators to choose from")

    freq_sum = sum((p for p, _ in args), 0)
    i = int(random.random() * freq_sum)

    s = 0
    for p, gen in args:
        if s <= i < s + p:
            return next(gen)
        s += p

########NEW FILE########
__FILENAME__ = numbers
"""
Arbitrary values generators for Python numeric types.
"""
import sys
import random

from pyqcy.arbitraries import arbitrary


@arbitrary(int)
def int_(min=-sys.maxint - 1, max=sys.maxint):
    """Generator for arbitrary integers.

    By default, it generates values from the whole integer range
    supported by operating system; this can be adjusted using
    parameters.

    :param min: A minimum value of integer to generate
    :param max: A maximum value of integer to generate
    """
    return random.randint(min, max)


@arbitrary(float)
def float_(min=-float(sys.maxint), max=float(sys.maxint)):
    """Generator for arbitrary floats.

    :param min: A minimum value of float to generate
    :param max: A maximum value of float to generate
    """
    return min + random.random() * (max - min)


@arbitrary(complex)
def complex_(min_real=-float(sys.maxint), max_real=float(sys.maxint),
             min_imag=-float(sys.maxint), max_imag=float(sys.maxint)):
    """Generator for arbitrary complex numbers
    of the built-in Python complex type.

    Parameters for this generator allow for adjusting the rectangle
    on the complex plane where the values will come from.

    :param min_real: A minimum value for real part of generated numbers
    :param max_real: A maximum value for real part of generated numbers
    :param min_imag: A minimum value for the imaginary part
                     of generated numbers
    :param max_imag: A maximum value for the imaginary part
                     of generated numbers
    """
    reals = float_(min_real, max_real)
    imags = float_(min_imag, max_imag)
    return complex(next(reals), next(imags))

########NEW FILE########
__FILENAME__ = strings
"""
Generators of arbitrary strings.
"""
import random
import re
import string

from pyqcy.arbitraries import arbitrary, is_arbitrary
from pyqcy.arbitraries.numbers import int_


@arbitrary(str)
def str_(of=int_(min=0, max=255), min_length=1, max_length=64):
    """Generator for arbitrary strings.

    Parameters for this generator allow for adjusting the length
    of resulting strings and the set of characters they are composed of.

    :param of: Characters used to construct the strings.
               This can be either an iterable of characters
               (e.g. a string) or a generator that produces them.
    :param min_length: A minimum length of string to generate
    :param max_length: A maximum length of string to generate
    """
    length = random.randint(min_length, max_length)
    char = lambda ch: ch if isinstance(ch, basestring) else chr(ch)
    if is_arbitrary(of):
        return ''.join(char(next(of)) for _ in xrange(length))
    return ''.join(char(random.choice(of)) for _ in xrange(length))


@arbitrary(unicode)
def unicode_(of=int_(min=0, max=65535), min_length=1, max_length=64):
    """Generator for arbitrary Unicode strings.

    Parameters for this generator allow for adjusting the length
    of resulting strings and the set of characters they are composed of.

    :param of: Characters used to construct the strings.
               This can be either an iterable of characters
               (e.g. a string) or a generator that produces them.
    :param min_length: A minimum length of string to generate
    :param max_length: A maximum length of string to generate
    """
    length = random.randint(min_length, max_length)
    char = lambda ch: ch if isinstance(ch, basestring) else unichr(ch)
    if is_arbitrary(of):
        return u''.join(char(next(of)) for _ in xrange(length))
    return u''.join(char(random.choice(of)) for _ in xrange(length))


# Common patterns

@arbitrary(str)
def email():
    """Generator of arbitrary email addresses."""
    return next(regex(r'[\w\d\.\+]+@[\w\d]+(\.[\w\d]+)+'))


@arbitrary(str)
def ipv4():
    """Generator of arbitrary IPv4 addresses."""
    return '.'.join(str(random.randint(0, 255)) for _ in xrange(4))


@arbitrary(str)
def filepath(style='unix'):
    """Generator of arbitrary filesystem paths.

    :param style: A flavor of the filesystem for the paths
                  to be generated. Currently only 'unix' is supported.

    Note that this generator creates only textual paths,
    without actually touching the filesystem.
    """
    if style == 'unix':
        return next(regex(r'(\/\.?[\-\_\+\w\d]+)+'))


# Regular expressions

@arbitrary(str)
class regex(object):
    """Generator for strings matching a regular expression.

    :param pattern: A regular expression - either a compiled one
                    (through :func:`re.compile`) or a string pattern
    """
    def __init__(self, pattern):
        if not isinstance(pattern, basestring):
            pattern = pattern.pattern   # assuming regex object
        self.regex_ast = re.sre_parse.parse(pattern).data

    def __iter__(self):
        return self

    def next(self):
        return ''.join(self.__reverse_node(node)
                       for node in self.regex_ast)

    def __reverse_node(self, (type_, data)):
        """Generates a string that matches given node
        from the regular expression AST.
        """
        if type_ == 'literal':
            return chr(data)
        if type_ == 'any':
            return next(self.__random_char)

        if type_ == 'in':
            return self.__reverse_in_node(data)
        if type_ in ['min_repeat', 'max_repeat']:
            return self.__reverse_repeat_node(data)
        if type_ == 'subpattern':
            return self.__reverse_subpattern_node(data)

        if type_ == 'at':
            return ''   # match-beginning (^) or match-end ($);
                        # irrelevant for string generation

        # TODO: add support for the rest of regex syntax elements
        raise ValueError("unsupported regular expression element: %s", type_)

    __random_char = str_(min_length=1, max_length=1)

    def __reverse_in_node(self, node_data):
        """Generates a string that matches 'in' node
        from the regular expression AST. Such node is an alternative
        between several variants.
        """
        chosen = random.choice(node_data)
        type_, data = chosen

        if type_ == 'range': # TODO: add support for negation: [^...]
            min_char, max_char = data
            return chr(random.randint(min_char, max_char))
        if type_ == 'category':
            return self.__reverse_category_node(data)

        return self.__reverse_node(chosen)

    def __reverse_category_node(self, node_data):
        """Generates a string that matches 'category' node
        from the regular expression AST. Such node specifies
        a particular kind of characters, like letters or whitespace.
        """
        type_ = node_data[node_data.rfind('_') + 1:]
        negate = '_not_' in node_data

        charsets = {
            'word': string.ascii_letters,
            'digit': string.digits,
            'space': string.whitespace
        }
        charset = (set(string.printable) - set(charsets[type_])
                   if negate else charsets[type_])
        return random.choice(charset)

    def __reverse_repeat_node(self, node_data):
        """Generates a string that matches 'min_repeat' or 'max_repeat' node
        from the regular expression AST. As name implies, such node
        is a repetition of some pattern.
        """
        min_count, max_count, [what] = node_data
        count = random.randint(min_count, min(max_count, 64))
        return ''.join(self.__reverse_node(what)
                       for _ in xrange(count))

    def __reverse_subpattern_node(self, node_data):
        """Generates a string that matches 'subpattern' node
        from the regular expression AST. Subpattern specifies
        a (capture) group defined within the regex.
        """
        # TODO: add support for backreferences to capture groups
        _, inner = node_data    # first element is group index
        return ''.join(self.__reverse_node(node) for node in inner)

########NEW FILE########
__FILENAME__ = integration
"""
Integration between pyqcy and other testing libraries,
especially test runners (such as unittest or nose).
"""
import unittest

from .properties import Property
from .runner import run_tests


__all__ = ['TestCase']


class TestCase(unittest.TestCase):
    """`unittest` test case for pyqcy properties.

    Properties defined here within subclasses of :class:`TestCase`
    will be verified automatically as a part of standard `unittest` run.
    To define them, use the typical syntax with :func:`qc` decorator::

        class Sorting(TestCase):
            '''Properties that must hold for a sorting.'''
            @qc
            def sort_preserves_length(
                l=list_(of=int, max_length=128)
            ):
                assert len(l) == len(list(sorted(l)))
            @qc
            def sort_finds_minimum(
                l=list_(of=int, min_length=1, max_length=128)
            ):
                assert min(l) == list(sorted(l))[0]

    Since :class:`TestCase` itself is a subclass of standard
    :class:`unittest.TestCase`, it will be discovered by :func:`unittest.main`,
    `nosetests` or similar testing utilities.
    """
    class __metaclass__(type):
        def __new__(cls, name, bases, dict_):
            """Create ``TestCase`` class that contains properties to check."""
            properties = [(k, v) for (k, v) in dict_.iteritems()
                          if isinstance(v, Property)]

            for name, prop in properties:
                test = cls._create_test_method(name, prop)
                dict_[test.__name__] = test

            return type.__new__(cls, name, bases, dict_)

        @staticmethod
        def _create_test_method(name, prop):
            """Creates a ``test_X`` method corresponding to
            given :class:`Property`.

            :param name: Name of the property
            :param prop: :class:`Property` object
            :return: Test method
            """
            def test(self):
                run_tests([prop], verbosity=0, propagate_exc=True)

            test.__name__ = "test_%s" % name
            test.__doc__ = "[pyqcy] %s" % name

            return test

########NEW FILE########
__FILENAME__ = properties
"""
Properties to be tested.
Also known as "tests".
"""
import inspect
import functools
import sys

from pyqcy.arbitraries import arbitrary, is_arbitrary, to_arbitrary
from pyqcy.results import TestResult
from pyqcy.statistics import Tag
from pyqcy.utils import optional_args


__all__ = ['qc']


@optional_args
class qc(object):
    """Decorator for Python functions that define properties
    to be tested by pyqcy.

    It is expected that default values for function arguments
    define generators that will be used to generate data
    for test cases. See the section about
    :doc:`using generators <arbitraries>` for more information.

    Example of using ``@qc`` to define a test property::

        @qc
        def len_behaves_correctly(
            l=list_(int, min_length=1, max_length=64)
        ):
            assert len(l) == l.__len__()

    """
    def __init__(self, tests=None):
        self.tests_count = tests

    def __call__(self, func):
        """Applies the @qc decorator to given function,
        turning it into a testable property.
        """
        func_args, _, _, func_defaults = inspect.getargspec(func)
        func_args, func_defaults = func_args or [], func_defaults or []
        free_args_count = len(func_args) - len(func_defaults)
        if free_args_count > 0:
            raise TypeError("property has unbound variables: %s" %
                func_args[:free_args_count])
        return Property(func=func,
                        data=dict(zip(func_args, func_defaults)),
                        tests_count=self.tests_count)


class Property(object):
    """A property that can be QuickChecked."""
    tests_count = 100   # used if not overridden on per-property basis

    def __init__(self, func, data, tests_count=None):
        """Constructor. Callers should specify the function
        which encodes the testing property, and arbitrary values'
        generator for test data (function arguments).
        """
        self.func = self.__coerce_to_generator_func(func)
        self.data = dict((k, to_arbitrary(v) if is_arbitrary(v) else v)
                           for k, v in data.iteritems())
        if tests_count is not None:
            self.tests_count = tests_count

    def __coerce_to_generator_func(self, func):
        """Ensures that given function is a generator function,
        i.e. a function that returns a generator.
        This way all properties can be checked in the same manner,
        regardless of whether they use `yield` internally or not.
        """
        if inspect.isgeneratorfunction(func):
            return func

        @functools.wraps(func)
        def generator_func(*args, **kwargs):
            func(*args, **kwargs)
            yield
        return generator_func

    def check(self, count=None):
        """Executes given number of tests for this property
        and gathers statistics about all test runs.

        :param count: Number of tests to execute.
                      If omitted, the default number of tests
                      for this property is executed.

        Returns a list containing a set of "tags"
        for each test case that was executed.
        """
        if count is None:
            count = self.tests_count
        if not (count > 0):
            raise ValueError("test count must be positive")
        return [self.test_one() for _ in xrange(count)]

    def test(self, count=None):
        """Executes given number of tests for this property
        and checks whether they all pass. This is a simplified
        version of :meth:`check` method which discards
        any statistics generated during test runs.

        :param count: Number of tests to execute.
                      If omitted, the default number of tests
                      for this property is executed.

        Returns True if all tests passed. Otherwise,
        re-raises the exception which caused a test to fail.
        """
        results = self.check(count)
        failure = next((r for r in results if not r.succeeded), None)
        if failure:
            failure.propagate_failure()
        return True

    def test_one(self):
        """Executes a single test for this property."""
        data = self.__generate_data()
        result = TestResult(data)
        try:
            coroutine = self.func(**data)
            result.tags = self.__execute_test(coroutine)
        except:
            result.register_failure()

        return result

    def __generate_data(self):
        """Returns a dictionary of test data
        to be passed as keyword arguments to property function.
        """
        return dict((k, next(v) if is_arbitrary(v) else v)
                    for k, v in self.data.iteritems())

    def __execute_test(self, coroutine):
        """Executes given test coroutine and returns
        a set of "tags" that have been assigned to
        the test case by the property.
        """
        res = []
        try:
            while True:
                obj = next(coroutine)
                if obj is not None:
                    value = obj.value if isinstance(obj, Tag) else obj
                    res.append(value)
        except StopIteration:
            return frozenset(res)

    @property
    def parametrized(self):
        '''Checks whether the property is parametrized, i.e. has
        some arguments which are not generators of arbitrary values.
        '''
        return not all(map(is_arbitrary, self.data.itervalues()))

    def __call__(self, **kwargs):
        """Calling the property object will create new one
        with some of the arguments ("variables") bound to given values.
        In other words, it will perform currying on property's function.
        """
        @functools.wraps(self.func)
        def curried_func(**kwargs_):
            final_kwargs = kwargs.copy()
            final_kwargs.update(kwargs_)
            return self.func(**final_kwargs)

        data = dict((k, v) for (k, v) in self.data.iteritems()
                    if k not in kwargs)
        return Property(curried_func, data, self.tests_count)

########NEW FILE########
__FILENAME__ = results
"""
Code related to results of tests.
"""
import os
import sys


class CheckError(Exception):
    """Exception raised when property test fails.

    It constains the original test data for which
    the test has failed.
    """
    def __init__(self, data, cause=None):
        self.test_data = data
        self.cause = cause

    def __str__(self):
        msg = "test failed"
        if self.cause is not None:
            msg += " due to %s" % type(self.cause).__name__
            cause = str(self.cause)
            if cause:
                msg += ": " + cause

        res = [msg]
        res.append("Failure encountered for data:")
        res.extend(["  %s = %s" % i for i in self.test_data.iteritems()])
        return os.linesep.join(res)


class TestResult(object):
    """An object that holds the results of single test run
    for particular property.

    Results include the original test data,
    all the tags generated by property,
    and the exception that failed the test, if any.
    """
    def __init__(self, data):
        self.data = data
        self.tags = []

    @property
    def succeeded(self):
        return getattr(self, 'exception', None) is None

    def register_failure(self):
        """Saves the current exception info as a reason for test failure,
        so that it can be subsequently inspected or propagated further.
        """
        _, self.exception, self.traceback = sys.exc_info()

    def propagate_failure(self):
        """Re-raises the exception which caused the property test to fail.

        The exception is raised "seemlessly", i.e. with original traceback,
        like it was never really captured to begin with.
        """
        # This form of 'raise' ensures the original traceback is preserved
        exception = CheckError(data=self.data, cause=self.exception)
        raise type(exception), exception, self.traceback

########NEW FILE########
__FILENAME__ = runner
"""
Simple, built-in test runner.
"""
import sys
import traceback

from pyqcy.properties import Property
from pyqcy.utils import partition


__all__ = ['main']


def main(module='__main__', exit=True, verbosity=2, failfast=False):
    """Built-in test runner for properties.

    When called, it will look for all properties (i.e. functions with
    :func:`qc` decorator) and run checks on them.

    Arguments are intended to mimic those from :func:`unittest.main`.
    Return value is the total number of properties checked,
    provided ``exit`` is ``False`` and program doesn't terminate.
    """
    if isinstance(module, basestring):
        module_name = module
        module = __import__(module_name)
        for part in module_name.split('.')[1:]:
            module = getattr(module, part)

    props = [v for v in module.__dict__.itervalues()
             if isinstance(v, Property)]

    success = run_tests(props, verbosity=verbosity, failfast=failfast)
    if exit:
        sys.exit(0 if success else 1)
    return len(props)


def run_tests(props, verbosity=1, failfast=False, propagate_exc=False):
    """Executes tests for given list of properties.
    Returns boolean flag indicating if all the tests succeeded.
    """
    verbosity = verbosity or 0
    success = True

    for p in props:
        results = p.check()
        failed = [r for r in results if not r.succeeded]
        if failed:
            failure = failed[0]

            if verbosity >= 1:
                success_count = p.tests_count - len(failed)
                print "%s: failed (only %s out of %s tests passed)." % (
                    p.func.__name__, success_count, p.tests_count)
                print "Failure encountered for data:"
                for k, arg in failure.data.iteritems():
                    print "  %s = %s" % (k, repr(arg))

                print "Exception:"
                traceback.print_exception(type(failure.exception),
                                          failure.exception, failure.traceback)

            success = False
            if failfast:
                break
            if propagate_exc:
                failure.propagate_failure()
        else:
            if verbosity >= 2:
                tags = (r.tags for r in results)
                print_test_results(p, tags)

    return success


def print_test_results(prop, results):
    """Prints results of testing a single property.

    Results include any statistical information that the property
    has generated though ``yield`` statements.
    """
    print "%s: passed %s test%s." % (prop.func.__name__,
                                     prop.tests_count,
                                     "s" if prop.tests_count != 1 else "")

    # gather and display statistics
    results = list(results)
    with_stats, without_stats = partition(lambda r: len(r) > 0, results)
    if len(with_stats) > 0:
        stats = {}
        for s in with_stats:
            stats[s] = stats.get(s, 0) + 1
        stats = stats.items()
        if len(without_stats) > 0:
            stats.append(("<rest>", len(without_stats)))

        results_count = float(len(results))
        for labels, count in stats:
            percentage = "%.2f%%" % (count * 100 / results_count)
            summary = ", ".join(map(str, labels))
            print "%s: %s" % (percentage.rjust(5), summary)

########NEW FILE########
__FILENAME__ = statistics
"""
Statistics for test cases.
"""
import collections


__all__ = ['collect', 'classify']


class Tag(object):
    """A tag that can be assigned to a test case.

    It can be any hashable value, i.e. a one that
    could be a set element or dictionary key.

    This is mostly a marker class - a wrapper that
    is used to distinguish results of statistic function
    calls from other values that could be yielded
    from property function.
    """
    def __init__(self, value):
        if not isinstance(value, collections.Hashable):
            raise TypeError("tag value must be hashable")
        self.value = value


def collect(value):
    """Collects test cases that share the same value
    (passed as argument) for statistical purposes.

    :param value: Value to collect. This can be any hashable,
                  i.e. a value that could be a set element
                  or dictionary key.

    Typical usage of :func:`collect` is as follows:

    .. code-block:: python

        @qc
        def sort_works(
            l=list_(int, min_length=1, max_length=100)
        ):
            yield collect(len(l))
            assert list(sorted(l))[0] == min(l)

    Checking the above property will produce output similar to this:

    .. code-block:: console

        sort_works: passed 100 tests.
        1.00%: 1
        1.00%: 2
        ...
        1.00%: 100
    """
    return Tag(value)


def classify(condition, label):
    """Classifies test cases depending on whether they satisfy
    given condition.

    If a test case meets the condition, it will be "stamped"
    with given label that will subsequently appear in statistical report
    displayed after a property has been tested.

    :param condition: Condition that the test data should satisfy
                      in order for the test case to be stamped with ``label``.
    :param label: A label to be associated with this test case
                  if ``condition`` turns out to be true

    Typical usage is as follows:

    .. code-block:: python

        @qc
        def sort_preserves_length(
            l=list_(int, min_length=1, max_length=100)
        ):
            yield classify(len(l) == 0, "empty list")
            yield classify(len(l) < 10, "short list")
            assert len(list(sorted(l))) == len(l)

    Checking the above property will produce
    something like the following output:

    .. code-block::  console

        sort_preserves_length: passed 100 tests.
        1.00%: empty list, short list
        9.00%: short list
        90.00%: <rest>
    """
    satisfied = condition() if callable(condition) else bool(condition)
    return Tag(label) if satisfied else None

########NEW FILE########
__FILENAME__ = utils
"""
Utility module.
"""
import itertools
import functools
import inspect
import collections


def partition(pred, iterable):
    """Divides elements of given iterable in two,
    based on whether they satisfy given predicate.
    :return: Tuple (elems_that_satisfy, elems_that_dont_satisfy).
    """
    pred = pred or bool
    true_elems = itertools.ifilter(pred, iterable)
    false_elems = itertools.ifilterfalse(pred, iterable)

    # preserve string-ness, list-ness or tuple-ness of results,
    # in a manner similar to filter() or map()
    res = (true_elems, false_elems)
    for cls in (str, unicode, tuple, list):
        if isinstance(iterable, cls):
            res = map(cls, res)
            break
    return res


# Decorators

def optional_args(decor):
    """Decorator for decorators (sic) that are intended to take
    optional arguments.

    It supports decorators written both as classes or functions,
    as long as they are "doubly-callable".
    For classes, this means implementing ``__call__``, while
    functions must return a function that returns a function
    that accepts a function... which is obvious, of course.
    """
    @functools.wraps(decor)
    def wrapped(*args, **kwargs):
        one_arg = len(args) == 1 and not kwargs
        if one_arg and inspect.isfunction(args[0]):
            decor_instance = decor()
            return decor_instance(args[0])
        else:
            return decor(*args, **kwargs)

    return wrapped


def recursive(func):
    ''' Constructs a function that which recursively applies given callable
    to objects, regardless of whether they are lists (iterables)
    or dictionaries (mapping).

    It can be thought of as recursive, curried ``map`` for lists,
    and/or equivalent for dicts.
    '''
    @functools.wraps(func)
    def recursive_func(obj, *args, **kwargs):
        if isinstance(obj, collections.Mapping):
            return dict((k, recursive_func(v, *args, **kwargs))
                        for (k, v) in obj.iteritems())
        if isinstance(obj, (tuple, list)):
            iter_cls = tuple if isinstance(obj, tuple) else list
            return iter_cls([recursive_func(item, *args, **kwargs)
                             for item in obj])
        return func(obj)

    return recursive_func

########NEW FILE########
__FILENAME__ = test_arbitraries
"""
Unit tests for arbitraries.
"""
import unittest

import random
import json
import string

from pyqcy import *


class General(unittest.TestCase):
    """General test cases for generators of arbitrary values."""

    def test_standard_arbitrary(self):
        @qc
        def addition_doesnt_break(x=int, y=int):
            _ = x + y

        addition_doesnt_break.test()

    def test_generator_arbitrary(self):
        @arbitrary(float)
        def random_floats():
            while True:
                yield random.random()
        @qc
        def multiplication_on_floats(
            a=random_floats, b=random_floats
        ):
            assert a * b <= 1.0

        multiplication_on_floats.test()

    def test_standard_arbitrary_with_args(self):
        @qc
        def addition_works_for_positive_floats(
            x=float_(min=0.0), y=float_(min=0.0)
        ):
            sum = x + y
            assert sum >= x and sum >= y

        addition_works_for_positive_floats.test()

    def test_custom_arbitrary(self):
        @arbitrary(str)
        def str_with_len_lt5():
            length = random.randint(0, 4)
            return ''.join(chr(random.randint(0, 255))
                           for _ in xrange(length))
        @qc
        def case_transform_preserves_length(
            s=str_with_len_lt5
        ):
            assert len(s) == len(s.upper())
            assert len(s) == len(s.lower())

        case_transform_preserves_length.test()

    def test_standard_nested_arbitrary(self):
        @qc
        def sort_finds_minimum(
            l=list_(of=int, min_length=1, max_length=64)
        ):
            assert sorted(l)[0] == min(l)

        sort_finds_minimum.test()


class Strings(unittest.TestCase):
    """Test cases for arbitrary generators producing strings."""

    def test_unicode_arbitrary(self):
        @qc
        def case_transform_on_unicode(
            s=unicode_(min_length=2, max_length=128)
        ):
            assert s.upper() == s.upper().upper()

        case_transform_on_unicode.test()

    def test_regex_arbitrary(self):
        @qc
        def pattern_is_a_pattern(s=regex(r'\d+')):
            assert len(s) > 0
            assert all(c in string.digits for c in s)
        @qc
        def email_is_email(s=email()):
            assert '@' in s
            assert s.rfind('.') > s.find('@')  # at least one dot after @

        pattern_is_a_pattern.test()
        email_is_email.test()

    def test_ipv4(self):
        @qc
        def ipv4_is_within_range(ip=ipv4()):
            assert all(0 <= int(part) <= 255 for part in ip.split('.'))

        ipv4_is_within_range.test()


class Collections(unittest.TestCase):
    """Test cases for generators producing arbitrary collections."""

    def test_tuple_arbitrary(self):
        @qc
        def tuples_survive_listification(t=tuple_(int, n=10)):
            as_list = list(t)
            back_as_tuple = tuple(as_list)
            assert all((old, new) for (old, new) in zip(t, back_as_tuple))

        tuples_survive_listification.test()

    def test_shorthand_tuple_arbitrary(self):
        @qc
        def two_is_two(t=two(int)):
            assert len(t) == 2

        two_is_two.test()

    def test_set_arbitrary(self):
        @qc
        def set_inclusion_works(
            s=set_(of=int, min_length=1, max_length=64)
        ):
            for elem in s:
                assert set([elem]).issubset(s)

        set_inclusion_works.test()

    def test_dict_arbitrary(self):
        @qc
        def dict_update_works(
            d1=dict_(keys=str, values=str, min_length=1, max_length=64),
            d2=dict_(items=tuple_(int, str), min_length=1, max_length=64)
        ):
            d1_len = len(d1)
            d1.update(d2)
            assert len(d1) == d1_len + len(d2)

        dict_update_works.test()


class Combinators(unittest.TestCase):
    """Test cases for arbitrary combinators.."""

    ALPHABET = 'abcdefghijklmnopqrstuvwxyz'
    NUMBERS = range(1, 10)

    def test_apply(self):
        @qc
        def apply_works_with_functions(
            x=apply(json.dumps,
                    list_(of=int, min_length=1, max_length=64))
        ):
            assert isinstance(x, basestring)
            assert all(isinstance(i, int) for i in json.loads(x))

        @qc
        def apply_works_with_types(x=apply(str, int)):
            assert isinstance(x, str)

        apply_works_with_functions.test()
        apply_works_with_types.test()

    def test_data(self):
        @qc
        def data_works_with_lists(
            x=data([int, str])
        ):
            assert isinstance(x, list)
            assert len(x) == 2
            assert isinstance(x[0], int) and isinstance(x[1], str)

        @qc
        def data_works_with_tuples(
            x=data((float, str, int))
        ):
            assert isinstance(x, tuple)
            assert len(x) == 3
            for i, t in enumerate((float, str, int)):
                assert isinstance(x[i], t)

        @qc
        def data_works_with_dictionaries(x=data({
            'login': str_(of=self.ALPHABET,
                          min_length=4, max_length=16),
            'password': str_(min_length=8, max_length=64),
        })):
            assert isinstance(x, dict)
            assert len(x) == 2
            assert 'login' in x and 'password' in x
            assert isinstance(x['login'], str) and isinstance(x['password'], str)

        data_works_with_lists.test()
        data_works_with_tuples.test()
        data_works_with_dictionaries.test()

    def test_elements_arbitrary(self):
        @qc
        def pick_one_element(x=elements(self.NUMBERS)):
            assert isinstance(x, int)
            assert x in self.NUMBERS

        @qc
        def pick_subset_of_count_one(
            x=elements(self.NUMBERS, count=1)
        ):
            assert len(x) == 1
            assert set(x) < set(self.NUMBERS)

        @qc
        def pick_few_from_set(
            x=elements(self.ALPHABET, count=5)
        ):
            assert len(x) == 5
            assert set(x) < set(self.ALPHABET)

        @qc
        def pick_random_number_from_set(
            x=elements(self.ALPHABET,
                       count=int_(min=1, max=len(self.ALPHABET) / 2))
        ):
            assert 1 <= len(x) <= len(self.ALPHABET) / 2
            assert set(x) < set(self.ALPHABET)

        pick_one_element.test()
        pick_subset_of_count_one.test()
        pick_few_from_set.test()
        pick_random_number_from_set.test()

    def test_one_of_arbitrary(self):
        @qc
        def one_of_works(x=one_of(float, int)):
            assert isinstance(x, (float, int))

        one_of_works.test()

    def test_frequency_arbitrary(self):
        @qc
        def frequency_works(x=frequency([(1, float), (2, int)])):
            assert isinstance(x, (float, int))

        frequency_works.test()

########NEW FILE########
__FILENAME__ = test_integration
"""
Unit tests for integration facilities.
"""
import unittest
from pyqcy import *

import os


class Integration(unittest.TestCase):
    """Test cases for the pyqcy test case. (Yes.)"""
    class Sorting(TestCase):
        @qc(tests=1)
        def sort_preserves_length(l=list_(of=int, max_length=128)):
            assert len(l) == len(list(sorted(l)))

        @qc(tests=1)
        def sort_finds_minimum(
            l=list_(of=int, min_length=1, max_length=128)
        ):
            assert min(l) == list(sorted(l))[0]

    def setUp(self):
        loader = unittest.TestLoader()
        self.qc_suite = loader.loadTestsFromTestCase(Integration.Sorting)

    def test_running_testcase(self):
        results = unittest.TextTestRunner(
            stream=open(os.devnull, 'w'),  # we don't want output here
            verbosity=0).run(self.qc_suite)

        assert results.wasSuccessful()

    def test_property_names_in_test_description(self):
        from pyqcy.properties import Property

        test_descriptions = set(tm._testMethodDoc
                                for tm in self.qc_suite._tests)

        assert all("pyqcy" in td for td in test_descriptions)
        assert all(any(k in td for td in test_descriptions)
                   for (k, v) in Integration.Sorting.__dict__.iteritems()
                   if isinstance(v, Property))

########NEW FILE########
__FILENAME__ = test_properties
"""
Unit tests from properties.
"""
import unittest
from pyqcy import *


CUSTOM_TESTS_COUNT = 134


class Properties(unittest.TestCase):
    """Test cases for functionality related to properties."""

    def test_passing_property(self):
        subtraction_doesnt_break.test()

    def test_failing_property(self):
        self.assertRaises(CheckError, failing.test)

    def test_parametrized_property(self):
        adding_to(x=5).test()

    def test_number_of_tests_in_decorator(self):
        results = multiplication_works.check()
        assert len(results) == multiplication_works.tests_count
        assert len(results) == CUSTOM_TESTS_COUNT


# Test properties

@qc
def subtraction_doesnt_break(x=int, y=int):
    _ = x - y


@qc
def failing(a=int, b=int):
    assert False


@qc
def adding_to(x=0, y=int_(min=0, max=10)):
    assert x + y >= x


@qc(tests=CUSTOM_TESTS_COUNT)
def multiplication_works(x=int):
    assert x * 1 == x

########NEW FILE########
__FILENAME__ = test_runner
"""
Unit tests for the pyqcy test runner.
"""
import sys

import unittest
from mocktest import MockTransaction, when, expect

from pyqcy import qc, int_, list_, collect, main


@qc
def addition_success(
    x=int_(min=0), y=int_(min=0)
):
    the_sum = x + y
    assert the_sum >= x and the_sum >= y


@qc
def addition_fail(
    x=int_(min=0), y=int_(min=0)
):
    the_sum = x + y
    assert the_sum >= x and the_sum < y


@qc
def statistics_work(
    l=list_(int, min_length=1, max_length=100)
):
    yield collect(len(l))
    assert list(sorted(l))[0] == min(l)


class Runner(unittest.TestCase):
    """Test cases for the pyqcy test runner (pyqcy.main)."""

    def test_runner(self):
        from pyqcy.properties import Property

        with MockTransaction:
            when(sys).exit.then_return(None)
            assert main(__name__, exit=True) == len([
                obj for obj in globals().itervalues()
                if isinstance(obj, Property)
            ])

            # we have one failing property so expect a failure
            expect(sys).exit.where(lambda code: code != 0).once()

########NEW FILE########
__FILENAME__ = test_statistics
"""
Unit tests for statistics.
"""
import unittest
from pyqcy import *


class Statistics(unittest.TestCase):
    """Test cases for statistics functionality."""

    def test_collect(self):
        results = sorting_short_lists.check()
        assert all(len(r.tags) > 0 for r in results)

    def test_classify(self):
        results = sort_preserves_length.check()
        assert any(len(r.tags) > 0 for r in results)


# Test properties

@qc
def sorting_short_lists(
    l=list_(float, min_length=1, max_length=6)
):
    yield collect(len(l))
    assert list(sorted(l))[-1] == max(l)


@qc
def sort_preserves_length(l=list_(int, max_length=64)):
    yield classify(len(l) == 0, "empty list")
    yield classify(len(l) % 2 == 0, "even list")
    yield classify(len(l) % 2 != 0, "odd list")
    assert len(list(sorted(l))) == len(l)

########NEW FILE########
