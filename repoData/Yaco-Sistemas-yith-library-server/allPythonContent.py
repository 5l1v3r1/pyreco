__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Yith Library Server documentation build configuration file, created by
# sphinx-quickstart on Sat Jul  7 21:15:06 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import datetime
import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('_themes'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Yith Library Server'
year = datetime.datetime.now().year
copyright = u'2012 - %s, Lorenzo Gil Sánchez' % year

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.2'
# The full version, including alpha/beta/rc tags.
release = '0.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'bootstrap'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'YithLibraryServerdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'YithLibraryServer.tex', u'Yith Library Server Documentation',
   u'Lorenzo Gil Sánchez', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'yithlibraryserver', u'Yith Library Server Documentation',
     [u'Lorenzo Gil Sánchez'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'YithLibraryServer', u'Yith Library Server Documentation',
   u'Lorenzo Gil Sánchez', 'YithLibraryServer', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'Yith Library Server'
epub_author = u'Lorenzo Gil Sánchez'
epub_publisher = u'Lorenzo Gil Sánchez'
epub_copyright = u'2012, Lorenzo Gil Sánchez'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

########NEW FILE########
__FILENAME__ = runapp
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import os

from paste.deploy import loadapp
from pyramid.paster import setup_logging
from raven.middleware import Sentry
from waitress import serve

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 5000))
    scheme = os.environ.get("SCHEME", "https")
    setup_logging('yithlibraryserver/config-templates/production.ini')
    app = loadapp('config:production.ini', relative_to='yithlibraryserver/config-templates')

    serve(Sentry(app), host='0.0.0.0', port=port, url_scheme=scheme)

########NEW FILE########
__FILENAME__ = email
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid_mailer.message import Attachment

from yithlibraryserver.backups.utils import get_backup_filename
from yithlibraryserver.backups.utils import get_user_passwords, compress
from yithlibraryserver.email import send_email


def get_day_to_send(user, days_of_month):
    """Sum the ordinal of each character in user._id % days_of_month"""
    return sum([ord(chr) for chr in str(user['_id'])]) % days_of_month


def send_passwords(request, user, preferences_link, backups_link):
    passwords = get_user_passwords(request.db, user)
    if not passwords:
        return False

    context = {
        'user': user,
        'preferences_link': preferences_link,
        'backups_link': backups_link,
    }

    today = request.date_service.today()
    attachment = Attachment(get_backup_filename(today),
                            "application/yith",
                            compress(passwords))

    send_email(
        request,
        'yithlibraryserver.backups:templates/email_passwords',
        context,
        "Your Yith Library's passwords",
        [user['email']],
        attachments=[attachment],
    )

    return True

########NEW FILE########
__FILENAME__ = test_email
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import os
import unittest

import bson

from pyramid import testing
from pyramid.testing import DummyRequest

from pyramid_mailer import get_mailer

from yithlibraryserver.datetimeservice.testing import FakeDateService
from yithlibraryserver.backups.email import get_day_to_send, send_passwords
from yithlibraryserver.testing import TestCase


class GetDayToSendTests(unittest.TestCase):

    def test_get_day_to_send(self):
        user = {}
        user['_id'] = bson.objectid.ObjectId('000000000000000000000001')
        self.assertEqual(5, get_day_to_send(user, 28))
        self.assertEqual(13, get_day_to_send(user, 30))
        self.assertEqual(6, get_day_to_send(user, 31))

        user['_id'] = bson.objectid.ObjectId('100000000000000000000000')
        self.assertEqual(5, get_day_to_send(user, 28))
        self.assertEqual(13, get_day_to_send(user, 30))
        self.assertEqual(6, get_day_to_send(user, 31))

        user['_id'] = bson.objectid.ObjectId('00000000000000000000000a')
        self.assertEqual(25, get_day_to_send(user, 28))
        self.assertEqual(1, get_day_to_send(user, 30))
        self.assertEqual(23, get_day_to_send(user, 31))

    def test_is_uniform_distribution(self):

        def fill_month(days, iterations):
            user = {}
            month = [0] * days
            for i in range(iterations):
                user['_id'] = bson.objectid.ObjectId()
                day = get_day_to_send(user, days)
                month[day] += 1
            return month

        month = fill_month(30, 1000)
        empty_days = [i for i, d in enumerate(month) if d == 0]
        self.assertEqual(empty_days, [])


class SendPasswordsTests(TestCase):

    clean_collections = ('users', 'passwords', )

    def setUp(self):
        self.config = testing.setUp()
        self.config.include('pyramid_mailer.testing')
        super(SendPasswordsTests, self).setUp()

    def test_send_passwords(self):
        preferences_link = 'http://localhost/preferences'
        backups_link = 'http://localhost/backups'
        user_id = self.db.users.insert({
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                }, safe=True)
        user = self.db.users.find_one({'_id': user_id})

        request = DummyRequest()
        request.db = self.db
        mailer = get_mailer(request)

        self.assertFalse(send_passwords(request, user,
                                        preferences_link, backups_link))
        self.assertEqual(len(mailer.outbox), 0)

        # add some passwords
        self.db.passwords.insert({
                'owner': user_id,
                'password': 'secret1',
                })
        self.db.passwords.insert({
                'owner': user_id,
                'password': 'secret2',
                })

        request = DummyRequest()
        request.db = self.db
        request.date_service = FakeDateService(request)
        mailer = get_mailer(request)

        os.environ['YITH_FAKE_DATE'] = '2012-1-10'

        self.assertTrue(send_passwords(request, user,
                                       preferences_link, backups_link))
        self.assertEqual(len(mailer.outbox), 1)
        message = mailer.outbox[0]
        self.assertEqual(message.subject, "Your Yith Library's passwords")
        self.assertEqual(message.recipients, ['john@example.com'])
        self.assertTrue(preferences_link in message.body)
        self.assertTrue(backups_link in message.body)
        self.assertEqual(len(message.attachments), 1)
        attachment = message.attachments[0]
        self.assertEqual(attachment.content_type, 'application/yith')
        self.assertEqual(attachment.filename,
                         'yith-library-backup-2012-01-10.yith')

        del os.environ['YITH_FAKE_DATE']

########NEW FILE########
__FILENAME__ = test_utils
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import datetime

from yithlibraryserver.backups.utils import get_user_passwords
from yithlibraryserver.backups.utils import get_backup_filename
from yithlibraryserver.backups.utils import compress, uncompress
from yithlibraryserver.testing import TestCase


class UtilsTests(TestCase):

    clean_collections = ('users', 'passwords', )

    def test_get_user_passwords(self):
        user_id = self.db.users.insert({
                'first_name': 'John',
                'last_name': 'Doe',
                }, safe=True)
        user = self.db.users.find_one({'_id': user_id})

        self.assertEqual(get_user_passwords(self.db, user), [])

        self.db.passwords.insert({
                'owner': user_id,
                'password': 'secret1',
                })
        self.db.passwords.insert({
                'owner': user_id,
                'password': 'secret2',
                })

        self.assertEqual(get_user_passwords(self.db, user), [{
                    'password': 'secret1',
                    } ,{
                    'password': 'secret2',
                    }])

    def test_get_backup_filename(self):
        self.assertEqual(get_backup_filename(datetime.date(2012, 10, 28)),
                         'yith-library-backup-2012-10-28.yith')
        self.assertEqual(get_backup_filename(datetime.date(2013, 1, 8)),
                         'yith-library-backup-2013-01-08.yith')

    def test_compress_and_uncompress(self):
        passwords = [{'password': 'secret1'}, {'password': 'secret2'}]

        self.assertEqual(uncompress(compress(passwords)), passwords)

########NEW FILE########
__FILENAME__ = test_views
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import gzip
import json
import os

from yithlibraryserver.compat import text_type, BytesIO
from yithlibraryserver.testing import TestCase


def get_gzip_data(text):
    buf = BytesIO()
    gzip_data = gzip.GzipFile(fileobj=buf, mode='wb')
    gzip_data.write(text.encode('utf-8'))
    gzip_data.close()
    return buf.getvalue()


class ViewTests(TestCase):

    clean_collections = ('users', 'passwords', )

    def assertUncompressData(self, body, data):
        buf = BytesIO(body)
        gzip_file = gzip.GzipFile(fileobj=buf, mode='rb')
        self.assertEqual(gzip_file.read().decode('utf-8'), data)

    def test_backups_index(self):
        res = self.testapp.get('/backup')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        date = datetime.datetime(2012, 12, 12, 12, 12)
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': '',
                'email_verified': False,
                'authorized_apps': [],
                'date_joined': date,
                'last_login': date,
                }, safe=True)
        self.set_user_cookie(str(user_id))

        res = self.testapp.get('/backup')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Backup', 'Export passwords', 'Import passwords')

    def test_backups_export(self):
        res = self.testapp.get('/backup/export')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        date = datetime.datetime(2012, 12, 12, 12, 12)
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': '',
                'email_verified': False,
                'authorized_apps': [],
                'date_joined': date,
                'last_login': date,
                }, safe=True)
        self.set_user_cookie(str(user_id))

        os.environ['YITH_FAKE_DATE'] = '2012-1-10'

        res = self.testapp.get('/backup/export')
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.content_type, 'application/yith-library')
        self.assertUncompressData(res.body, '[]')
        self.assertEqual(
            res.content_disposition,
            'attachment; filename=yith-library-backup-2012-01-10.yith',
            )

        self.db.passwords.insert({
                'owner': user_id,
                'password': 'secret1',
                })
        self.db.passwords.insert({
                'owner': user_id,
                'password': 'secret2',
                })

        res = self.testapp.get('/backup/export')
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.content_type, 'application/yith-library')
        self.assertUncompressData(res.body, json.dumps([{
                    'password': 'secret1',
                    }, {
                    'password': 'secret2',
                    }]))
        self.assertEqual(
            res.content_disposition,
            'attachment; filename=yith-library-backup-2012-01-10.yith',
            )
        del os.environ['YITH_FAKE_DATE']

    def test_backups_import(self):
        res = self.testapp.post('/backup/import')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        date = datetime.datetime(2012, 12, 12, 12, 12)
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': '',
                'email_verified': False,
                'authorized_apps': [],
                'date_joined': date,
                'last_login': date,
                }, safe=True)
        self.set_user_cookie(str(user_id))

        # no file to upload
        res = self.testapp.post('/backup/import', status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/backup')

        self.assertEqual(0, self.db.passwords.count())

        # not really a file
        res = self.testapp.post('/backup/import', {
                'passwords-file': '',
                }, status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/backup')

        self.assertEqual(0, self.db.passwords.count())

        # bad file
        content = get_gzip_data(text_type('[{}'))
        res = self.testapp.post(
            '/backup/import', {},
            upload_files=[('passwords-file', 'bad.json', content)],
            status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/backup')

        self.assertEqual(0, self.db.passwords.count())

        # file with good syntax but empty
        content = get_gzip_data(text_type('[]'))
        res = self.testapp.post(
            '/backup/import', {},
            upload_files=[('passwords-file', 'empty.json', content)],
            status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/backup')

        self.assertEqual(0, self.db.passwords.count())

        # file with good syntax but empty
        content = get_gzip_data(text_type('[{}]'))
        res = self.testapp.post(
            '/backup/import', {},
            upload_files=[('passwords-file', 'empty.json', content)],
            status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/backup')

        self.assertEqual(0, self.db.passwords.count())

        # file with good passwords
        content = get_gzip_data(text_type('[{"secret": "password1"}, {"secret": "password2"}]'))
        res = self.testapp.post(
            '/backup/import', {},
            upload_files=[('passwords-file', 'good.json', content)],
            status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/backup')

        self.assertEqual(2, self.db.passwords.count())

########NEW FILE########
__FILENAME__ = utils
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import gzip
import json

from yithlibraryserver.compat import BytesIO
from yithlibraryserver.password.models import PasswordsManager
from yithlibraryserver.utils import remove_attrs


def get_user_passwords(db, user):
    passwords_manager = PasswordsManager(db)
    return [remove_attrs(password, 'owner', '_id')
            for password in passwords_manager.retrieve(user)]


def get_backup_filename(date):
    return 'yith-library-backup-%d-%02d-%02d.yith' % (
        date.year, date.month, date.day)


def compress(passwords):
    buf = BytesIO()
    gzip_data = gzip.GzipFile(fileobj=buf, mode='wb')
    data = json.dumps(passwords)
    gzip_data.write(data.encode('utf-8'))
    gzip_data.close()
    return buf.getvalue()


def uncompress(compressed_data):
    buf = BytesIO(compressed_data)
    gzip_data = gzip.GzipFile(fileobj=buf, mode='rb')
    raw_data = gzip_data.read()
    return json.loads(raw_data.decode('utf-8'))

########NEW FILE########
__FILENAME__ = views
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid.i18n import get_localizer
from pyramid.httpexceptions import HTTPFound
from pyramid.response import Response
from pyramid.view import view_config

from yithlibraryserver.backups.utils import get_backup_filename
from yithlibraryserver.backups.utils import get_user_passwords
from yithlibraryserver.backups.utils import compress, uncompress
from yithlibraryserver.i18n import translation_domain
from yithlibraryserver.i18n import TranslationString as _
from yithlibraryserver.password.models import PasswordsManager


@view_config(route_name='backups_index',
             renderer='templates/backups_index.pt',
             permission='backups')
def backups_index(request):
    return {}


@view_config(route_name='backups_export',
             permission='backups')
def backups_export(request):
    passwords = get_user_passwords(request.db, request.user)
    data = compress(passwords)
    response = Response(body=data, content_type='application/yith-library')
    today = request.date_service.today()
    filename = get_backup_filename(today)
    response.content_disposition = 'attachment; filename=%s' % filename
    return response


@view_config(route_name='backups_import',
             renderer='string',
             permission='backups')
def backups_import(request):
    response = HTTPFound(location=request.route_path('backups_index'))

    if 'passwords-file' in request.POST:
        passwords_field = request.POST['passwords-file']
        if passwords_field != '':
            try:
                json_data = uncompress(passwords_field.file.read())
                passwords_manager = PasswordsManager(request.db)
                passwords_manager.delete(request.user)
                passwords_manager.create(request.user, json_data)
            except (IOError, ValueError):
                request.session.flash(
                    _('There was a problem reading your passwords file'),
                    'error')
                return response

            n_passwords = len(json_data)
            localizer = get_localizer(request)
            msg = localizer.pluralize(
                _('Congratulations, ${n_passwords} password has been imported'),
                _('Congratulations, ${n_passwords} passwords have been imported'),
                n_passwords,
                domain=translation_domain,
                mapping={'n_passwords': n_passwords},
                )
            request.session.flash(msg, 'success')
        else:
            request.session.flash(
                _('The passwords file is required to upload the passwords'),
                'error')
            return response
    else:
        request.session.flash(
            _('The passwords file is required to upload the passwords'),
            'error')
        return response

    return response

########NEW FILE########
__FILENAME__ = compat
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import sys
import types

# True if we are running on Python 3.
PY3 = sys.version_info[0] == 3

if PY3:  # pragma: no cover
    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes
    long = int
else:  # pragma: no cover
    string_types = basestring,
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str
    long = long

if PY3:  # pragma: no cover
    from urllib import parse
    urlparse = parse
    from urllib.parse import quote as url_quote
    from urllib.parse import urlencode as url_encode
else:  # pragma: no cover
    import urlparse
    from urllib import quote as url_quote
    from urllib import urlencode as url_encode

if PY3:  # pragma: no cover
    from base64 import decodebytes, encodebytes
else:  # pragma: no cover
    from base64 import decodestring as decodebytes
    from base64 import encodestring as encodebytes

if PY3:  # pragma: no cover
    def encode_header(obj):  # pragma: no cover
        return obj
else:  # pragma: no cover
    def encode_header(obj):  # pragma: no cover
        return obj.encode('utf-8')

if PY3:  # pragma: no cover
    from io import StringIO, BytesIO
else:  # pragma: no cover
    from StringIO import StringIO
    BytesIO = StringIO

########NEW FILE########
__FILENAME__ = config
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import logging
import os


log = logging.getLogger(__name__)


def read_setting_from_env(settings, key, default=None):
    env_variable = key.upper()
    if env_variable in os.environ:
        log.debug('Setting %s found in the environment: %s' %
                  (key, os.environ[env_variable]))
        return os.environ[env_variable]
    else:
        log.debug('Looking for setting %s in the selected .ini file: %s' %
                  (key, settings.get(key, default)))
        return settings.get(key, default)

########NEW FILE########
__FILENAME__ = email
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from yithlibraryserver.email import send_email, send_email_to_admins


def send_thankyou_email(request, donation):
    return send_email(
        request,
        'yithlibraryserver.contributions:templates/email_thankyou',
        donation,
        'Thanks for your contribution!',
        [donation['email']],
    )


def send_notification_to_admins(request, donation):
    context = {
        'home_link': request.route_url('home'),
    }
    context.update(donation)
    return send_email_to_admins(
        request,
        'yithlibraryserver.contributions:templates/email_admin_notification',
        context,
        'A new donation was received!',
    )

########NEW FILE########
__FILENAME__ = models
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.


def include_sticker(amount):
    return amount > 1


def create_donation(request, data):
    amount = int(data['amount'])
    donation = {
        'amount': amount,
        'firstname': data['firstname'],
        'lastname': data['lastname'],
        'city': data['city'],
        'country': data['country'],
        'state': data['state'],
        'street': data['street'],
        'zip': data['zip'],
        'email': data['email'],
        'creation': request.datetime_service.utcnow(),
    }
    if include_sticker(amount):
        donation['send_sticker'] = not ('no-sticker' in data)
    else:
        donation['send_sticker'] = False

    if request.user is not None:
        donation['user'] = request.user['_id']
    else:
        donation['user'] = None

    _id = request.db.donations.insert(donation, safe=True)
    donation['_id'] = _id
    return donation

########NEW FILE########
__FILENAME__ = paypal
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.


import requests

from yithlibraryserver.compat import urlparse


class PayPalPayload(dict):

    def __init__(self, request, method):
        self['METHOD'] = method
        self['VERSION'] = '72.0'
        self['USER'] = request.registry.settings['paypal_user']
        self['PWD'] = request.registry.settings['paypal_password']
        self['SIGNATURE'] = request.registry.settings['paypal_signature']

    def add_payment_info(self, amount):
        self['PAYMENTREQUEST_0_AMT'] = amount
        self['PAYMENTREQUEST_0_ITEMAMT'] = amount
        self['PAYMENTREQUEST_0_DESC'] = 'Donation'
        self['PAYMENTREQUEST_0_CURRENCYCODE'] = 'USD'
        self['PAYMENTREQUEST_0_PAYMENTACTION'] = 'Sale'
        self['LOCALECODE'] = 'ES'

    def add_callbacks(self, return_url, cancel_url):
        self['RETURNURL'] = return_url
        self['CANCELURL'] = cancel_url

    def add_token(self, token, payerid):
        self['TOKEN'] = token
        self['PAYERID'] = payerid


class PayPalExpressCheckout(object):

    def __init__(self, request):
        self.request = request
        self.nvp_url = request.registry.settings['paypal_nvp_url']
        self.express_checkout_url = request.registry.settings['paypal_express_checkout_url']

    def get_express_checkout_token(self, amount):
        return_url = self.request.route_url('contributions_paypal_success_callback')
        cancel_url = self.request.route_url('contributions_paypal_cancel_callback')
        payload = PayPalPayload(self.request, 'SetExpressCheckout')
        payload.add_payment_info(amount)
        payload.add_callbacks(return_url, cancel_url)

        response = requests.post(self.nvp_url, data=payload)
        if response.ok:
            data = urlparse.parse_qs(response.text)
            ack = data['ACK'][0]
            if ack == 'Success':
                return data['TOKEN'][0]

    def get_express_checkout_url(self, token):
        url = self.express_checkout_url + '?cmd=_express-checkout&token=%s'
        return url % token

    def get_express_checkout_details(self, token, payerid):
        payload = PayPalPayload(self.request, 'GetExpressCheckoutDetails')
        payload.add_token(token, payerid)

        response = requests.post(self.nvp_url, data=payload)

        if response.ok:
            data = urlparse.parse_qs(response.text)
            ack = data['ACK'][0]
            if ack == 'Success':
                amount = data['AMT'][0]
                amount = int(amount.split('.')[0])
                return {
                    'amount': amount,
                    'firstname': data['FIRSTNAME'][0],
                    'lastname': data['LASTNAME'][0],
                    'city': data['SHIPTOCITY'][0],
                    'country': data['SHIPTOCOUNTRYNAME'][0],
                    'state': data['SHIPTOSTATE'][0],
                    'street': data['SHIPTOSTREET'][0],
                    'zip': data['SHIPTOZIP'][0],
                    'email': data['EMAIL'][0],
                }

    def do_express_checkout_payment(self, token, payerid, amount):
        payload = PayPalPayload(self.request, 'DoExpressCheckoutPayment')
        payload.add_payment_info(amount)
        payload.add_token(token, payerid)

        response = requests.post(self.nvp_url, data=payload)

        if response.ok:
            data = urlparse.parse_qs(response.text)
            ack = data['ACK'][0]
            if ack == 'Success':
                return True

        return False

########NEW FILE########
__FILENAME__ = test_email
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import datetime

from pyramid import testing

from pyramid_mailer import get_mailer

from yithlibraryserver.testing import TestCase
from yithlibraryserver.contributions.email import send_thankyou_email
from yithlibraryserver.contributions.email import send_notification_to_admins


class SendEmailTests(TestCase):

    def setUp(self):
        self.admin_emails = ['admin1@example.com', 'admin2@example.com']
        self.config = testing.setUp(settings={
                'admin_emails': self.admin_emails,
                })
        self.config.include('pyramid_mailer.testing')
        self.config.include('yithlibraryserver')
        super(SendEmailTests, self).setUp()

    def test_send_thankyou_email(self):
        request = testing.DummyRequest()
        mailer = get_mailer(request)

        self.assertEqual(len(mailer.outbox), 0)

        donation = {
            'amount': 10,
            'firstname': 'John',
            'lastname': 'Doe',
            'city': 'Springfield',
            'country': 'Exampleland',
            'state': 'Example',
            'street': 'Main Street 10',
            'zip': '12345678',
            'email': 'john@example.com',
            'creation': datetime.datetime.utcnow(),
            'send_sticker': True,
        }
        send_thankyou_email(request, donation)

        self.assertEqual(len(mailer.outbox), 1)
        message = mailer.outbox[0]
        self.assertEqual(message.subject, 'Thanks for your contribution!')
        self.assertEqual(message.recipients, ['john@example.com'])

    def test_send_notification_to_admins(self):
        request = testing.DummyRequest()
        mailer = get_mailer(request)

        self.assertEqual(len(mailer.outbox), 0)

        donation = {
            'amount': 10,
            'firstname': 'John',
            'lastname': 'Doe',
            'city': 'Springfield',
            'country': 'Exampleland',
            'state': 'Example',
            'street': 'Main Street 10',
            'zip': '12345678',
            'email': 'john@example.com',
            'creation': datetime.datetime.utcnow(),
            'send_sticker': True,
            'user': None,
        }
        send_notification_to_admins(request, donation)

        self.assertEqual(len(mailer.outbox), 1)
        message = mailer.outbox[0]
        self.assertEqual(message.subject, 'A new donation was received!')
        self.assertEqual(message.recipients, self.admin_emails)

########NEW FILE########
__FILENAME__ = test_models
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import os
import unittest

from pyramid import testing

from yithlibraryserver.datetimeservice.testing import FakeDatetimeService
from yithlibraryserver.db import MongoDB
from yithlibraryserver.testing import MONGO_URI

from yithlibraryserver.contributions.models import include_sticker
from yithlibraryserver.contributions.models import create_donation


class ModelTests(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp()
        mdb = MongoDB(MONGO_URI)
        self.db = mdb.get_database()
        os.environ['YITH_FAKE_DATETIME'] = '2013-1-2-10-11-02'

        self.request = testing.DummyRequest()
        self.request.datetime_service = FakeDatetimeService(self.request)
        self.request.db = self.db

    def tearDown(self):
        testing.tearDown()
        self.db.drop_collection('donations')
        del os.environ['YITH_FAKE_DATETIME']

    def test_include_sticker(self):
        self.assertFalse(include_sticker(1))
        self.assertTrue(include_sticker(5))
        self.assertTrue(include_sticker(10))

    def test_create_donation_no_sticker(self):
        self.request.user = None

        donation = create_donation(self.request, {
                'amount': 1,
                'firstname': 'John',
                'lastname': 'Doe',
                'city': 'Springfield',
                'country': 'Exampleland',
                'state': 'Example',
                'street': 'Main Street 10',
                'zip': '12345678',
                'email': 'john@example.com',
                })

        self.assertEqual(donation['firstname'], 'John')
        self.assertEqual(donation['lastname'], 'Doe')
        self.assertEqual(donation['city'], 'Springfield')
        self.assertEqual(donation['country'], 'Exampleland')
        self.assertEqual(donation['state'], 'Example')
        self.assertEqual(donation['street'], 'Main Street 10')
        self.assertEqual(donation['zip'], '12345678')
        self.assertEqual(donation['email'], 'john@example.com')
        self.assertEqual(donation['creation'],
                         datetime.datetime(2013, 1, 2, 10, 11, 2))
        self.assertEqual(donation['send_sticker'], False)
        self.assertEqual(donation['user'], None)

    def test_create_donation_with_sticker(self):
        self.request.user = None

        donation = create_donation(self.request, {
                'amount': 5,
                'firstname': 'John',
                'lastname': 'Doe',
                'city': 'Springfield',
                'country': 'Exampleland',
                'state': 'Example',
                'street': 'Main Street 10',
                'zip': '12345678',
                'email': 'john@example.com',
                })

        self.assertEqual(donation['firstname'], 'John')
        self.assertEqual(donation['lastname'], 'Doe')
        self.assertEqual(donation['city'], 'Springfield')
        self.assertEqual(donation['country'], 'Exampleland')
        self.assertEqual(donation['state'], 'Example')
        self.assertEqual(donation['street'], 'Main Street 10')
        self.assertEqual(donation['zip'], '12345678')
        self.assertEqual(donation['email'], 'john@example.com')
        self.assertEqual(donation['creation'],
                         datetime.datetime(2013, 1, 2, 10, 11, 2))
        self.assertEqual(donation['send_sticker'], True)
        self.assertEqual(donation['user'], None)

    def test_create_donation_with_user(self):
        self.request.user = {'_id': 'fake_user_id'}

        donation = create_donation(self.request, {
                'amount': 10,
                'firstname': 'John',
                'lastname': 'Doe',
                'city': 'Springfield',
                'country': 'Exampleland',
                'state': 'Example',
                'street': 'Main Street 10',
                'zip': '12345678',
                'email': 'john@example.com',
                })

        self.assertEqual(donation['firstname'], 'John')
        self.assertEqual(donation['lastname'], 'Doe')
        self.assertEqual(donation['city'], 'Springfield')
        self.assertEqual(donation['country'], 'Exampleland')
        self.assertEqual(donation['state'], 'Example')
        self.assertEqual(donation['street'], 'Main Street 10')
        self.assertEqual(donation['zip'], '12345678')
        self.assertEqual(donation['email'], 'john@example.com')
        self.assertEqual(donation['creation'],
                         datetime.datetime(2013, 1, 2, 10, 11, 2))
        self.assertEqual(donation['send_sticker'], True)
        self.assertEqual(donation['user'], 'fake_user_id')

########NEW FILE########
__FILENAME__ = test_paypal
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from mock import patch

from pyramid import testing

from yithlibraryserver.contributions.paypal import PayPalPayload
from yithlibraryserver.contributions.paypal import PayPalExpressCheckout


class PayPalPayloadTests(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp(settings={
                'paypal_user': 'paypal_user',
                'paypal_password': 'paypal_password',
                'paypal_signature': 'paypal_signature',
                })

    def tearDown(self):
        testing.tearDown()

    def test_basic_payload(self):
        request = testing.DummyRequest()

        payload = PayPalPayload(request, 'method1')
        self.assertEqual(payload, {
                'METHOD': 'method1',
                'VERSION': '72.0',
                'USER': 'paypal_user',
                'PWD': 'paypal_password',
                'SIGNATURE': 'paypal_signature',
                })

    def test_payment_info(self):
        request = testing.DummyRequest()

        payload = PayPalPayload(request, 'method_with_info')
        payload.add_payment_info(10)
        self.assertEqual(payload, {
                'METHOD': 'method_with_info',
                'VERSION': '72.0',
                'USER': 'paypal_user',
                'PWD': 'paypal_password',
                'SIGNATURE': 'paypal_signature',
                'PAYMENTREQUEST_0_AMT': 10,
                'PAYMENTREQUEST_0_ITEMAMT': 10,
                'PAYMENTREQUEST_0_DESC': 'Donation',
                'PAYMENTREQUEST_0_CURRENCYCODE': 'USD',
                'PAYMENTREQUEST_0_PAYMENTACTION': 'Sale',
                'LOCALECODE': 'ES',
                })

    def test_callbacks(self):
        request = testing.DummyRequest()

        payload = PayPalPayload(request, 'method_with_callbacks')
        payload.add_callbacks('http://example.com/success',
                              'http://example.com/cancel')
        self.assertEqual(payload, {
                'METHOD': 'method_with_callbacks',
                'VERSION': '72.0',
                'USER': 'paypal_user',
                'PWD': 'paypal_password',
                'SIGNATURE': 'paypal_signature',
                'RETURNURL': 'http://example.com/success',
                'CANCELURL': 'http://example.com/cancel',
                })

    def test_token(self):
        request = testing.DummyRequest()

        payload = PayPalPayload(request, 'method_with_callbacks')
        payload.add_token('12345', '6789')
        self.assertEqual(payload, {
                'METHOD': 'method_with_callbacks',
                'VERSION': '72.0',
                'USER': 'paypal_user',
                'PWD': 'paypal_password',
                'SIGNATURE': 'paypal_signature',
                'TOKEN': '12345',
                'PAYERID': '6789',
                })


class PayPalExpressCheckoutTests(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp(settings={
                'paypal_user': 'paypal_user',
                'paypal_password': 'paypal_password',
                'paypal_signature': 'paypal_signature',
                'paypal_nvp_url': 'http://paypal.com/nvp',
                'paypal_express_checkout_url': 'http://paypal.com/express_checkout',
                })
        self.config.include('yithlibraryserver')
        self.config.include('yithlibraryserver.contributions')

    def test_express_checkout_token(self):
        request = testing.DummyRequest()
        pec = PayPalExpressCheckout(request)
        self.assertEqual(pec.nvp_url, 'http://paypal.com/nvp')
        self.assertEqual(pec.express_checkout_url,
                         'http://paypal.com/express_checkout')

        with patch('requests.post') as fake:
            fake.return_value.ok = True
            fake.return_value.text = 'ACK=Success&TOKEN=123'
            result = pec.get_express_checkout_token(5)
            fake.assert_called_with('http://paypal.com/nvp', data={
                    'METHOD': 'SetExpressCheckout',
                    'VERSION': '72.0',
                    'USER': 'paypal_user',
                    'PWD': 'paypal_password',
                    'SIGNATURE': 'paypal_signature',
                    'LOCALECODE': 'ES',
                    'PAYMENTREQUEST_0_ITEMAMT': 5,
                    'PAYMENTREQUEST_0_PAYMENTACTION': 'Sale',
                    'PAYMENTREQUEST_0_CURRENCYCODE': 'USD',
                    'PAYMENTREQUEST_0_AMT': 5,
                    'PAYMENTREQUEST_0_DESC': 'Donation',
                    'RETURNURL': 'http://example.com/contribute/paypal-success-callback',
                    'CANCELURL': 'http://example.com/contribute/paypal-cancel-callback',
                    })
            self.assertEqual(result, '123')

        self.assertEqual(
            pec.get_express_checkout_url('123'),
            'http://paypal.com/express_checkout?cmd=_express-checkout&token=123')

    def test_express_checkout_details(self):
        request = testing.DummyRequest()
        pec = PayPalExpressCheckout(request)
        self.assertEqual(pec.nvp_url, 'http://paypal.com/nvp')
        self.assertEqual(pec.express_checkout_url,
                         'http://paypal.com/express_checkout')

        with patch('requests.post') as fake:
            fake.return_value.ok = True
            fake.return_value.text = 'ACK=Success&AMT=5.00&FIRSTNAME=John&LASTNAME=Doe&SHIPTOCITY=ExampleCity&SHIPTOCOUNTRYNAME=ExampleCountry&SHIPTOSTATE=ExampleState&SHIPTOSTREET=ExampleStreet&SHIPTOZIP=123456&EMAIL=john@example.com'
            result = pec.get_express_checkout_details('123', '456')
            fake.assert_called_with('http://paypal.com/nvp', data={
                    'METHOD': 'GetExpressCheckoutDetails',
                    'VERSION': '72.0',
                    'USER': 'paypal_user',
                    'PWD': 'paypal_password',
                    'SIGNATURE': 'paypal_signature',
                    'TOKEN': '123',
                    'PAYERID': '456',
                    })
            self.assertEqual(result, {
                    'amount': 5,
                    'firstname': 'John',
                    'lastname': 'Doe',
                    'city': 'ExampleCity',
                    'country': 'ExampleCountry',
                    'state': 'ExampleState',
                    'street': 'ExampleStreet',
                    'zip': '123456',
                    'email': 'john@example.com',
                    })

    def test_express_checkout_payment(self):
        request = testing.DummyRequest()
        pec = PayPalExpressCheckout(request)
        self.assertEqual(pec.nvp_url, 'http://paypal.com/nvp')
        self.assertEqual(pec.express_checkout_url,
                         'http://paypal.com/express_checkout')

        with patch('requests.post') as fake:
            fake.return_value.ok = True
            fake.return_value.text = 'ACK=Success'
            result = pec.do_express_checkout_payment('123', '456', 5)
            fake.assert_called_with('http://paypal.com/nvp', data={
                    'METHOD': 'DoExpressCheckoutPayment',
                    'VERSION': '72.0',
                    'USER': 'paypal_user',
                    'PWD': 'paypal_password',
                    'SIGNATURE': 'paypal_signature',
                    'TOKEN': '123',
                    'PAYERID': '456',
                    'LOCALECODE': 'ES',
                    'PAYMENTREQUEST_0_ITEMAMT': 5,
                    'PAYMENTREQUEST_0_PAYMENTACTION': 'Sale',
                    'PAYMENTREQUEST_0_CURRENCYCODE': 'USD',
                    'PAYMENTREQUEST_0_AMT': 5,
                    'PAYMENTREQUEST_0_DESC': 'Donation',
                    })
            self.assertTrue(result)

            # Simulate a failure
            fake.return_value.ok = True
            fake.return_value.text = 'ACK=Failure'
            result = pec.do_express_checkout_payment('123', '456', 5)
            self.assertFalse(result)

########NEW FILE########
__FILENAME__ = test_views
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import os

import bson

from mock import patch

from pyramid_mailer import get_mailer

from yithlibraryserver.testing import TestCase


class TestViews(TestCase):

    clean_collections = ('donations', )

    def test_contributions_index(self):
        res = self.testapp.get('/contribute')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('We need your help!', 'Spread the word',
                        'Translate', 'Write some code',
                        'Give us your money')

    def test_contributions_donate_bad_method(self):
        res = self.testapp.get('/contribute/donate', status=400)
        self.assertEqual(res.status, '400 Bad Request')

    def test_contributions_donate_bad_amount(self):
        res = self.testapp.post('/contribute/donate', {
                'amount': 'five',
                'submit': 'submit',
                }, status=400)
        self.assertEqual(res.status, '400 Bad Request')

    def test_contributions_donate(self):
        with patch('requests.post') as fake:
            fake.return_value.ok = True
            fake.return_value.text = 'ACK=Success&TOKEN=123'
            res = self.testapp.post('/contribute/donate', {
                    'amount': '5',
                    'submit': 'submit',
                    }, status=302)

            self.assertEqual(res.status, '302 Found')
            self.assertEqual(res.location, 'https://www.sandbox.paypal.com/webscr?cmd=_express-checkout&token=123')

            # USER, PWD, and SIGNATURE are Paypal testing values
            # They are set in yithlibrary.testing.TestCase.setUp
            fake.assert_called_with('https://api-3t.sandbox.paypal.com/nvp',
                                    data={
                    'METHOD': 'SetExpressCheckout',
                    'VERSION': '72.0',
                    'USER': 'sdk-three_api1.sdk.com',
                    'PWD': 'QFZCWN5HZM8VBG7Q',
                    'SIGNATURE': 'A-IzJhZZjhg29XQ2qnhapuwxIDzyAZQ92FRP5dqBzVesOkzbdUONzmOU',
                    'LOCALECODE': 'ES',
                    'PAYMENTREQUEST_0_ITEMAMT': 5,
                    'PAYMENTREQUEST_0_PAYMENTACTION': 'Sale',
                    'PAYMENTREQUEST_0_CURRENCYCODE': 'USD',
                    'PAYMENTREQUEST_0_AMT': 5,
                    'PAYMENTREQUEST_0_DESC': 'Donation',
                    'RETURNURL': 'http://localhost/contribute/paypal-success-callback',
                    'CANCELURL': 'http://localhost/contribute/paypal-cancel-callback',
                    })

    def test_contributions_confirm_error(self):
        res = self.testapp.get('/contribute/paypal-success-callback',
                               status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/contribute')
        session = self.get_session(res)
        self.assertEqual(session['_f_error'], ['There was a problem in the confirmation process. Please start the checkout again'])

    def test_contributions_confirm_details(self):
        with patch('requests.post') as fake:
            fake.return_value.ok = True
            fake.return_value.text = 'ACK=Success&AMT=5.00&FIRSTNAME=John&LASTNAME=Doe&SHIPTOCITY=ExampleCity&SHIPTOCOUNTRYNAME=ExampleCountry&SHIPTOSTATE=ExampleState&SHIPTOSTREET=ExampleStreet&SHIPTOZIP=123456&EMAIL=john@example.com'
            res = self.testapp.get('/contribute/paypal-success-callback?token=123&PayerID=456')
            self.assertEqual(res.status, '200 OK')
            res.mustcontain('John', 'Doe', 'ExampleCity', 'ExampleCountry',
                            'ExampleState', 'ExampleStreet', '123456')
            fake.assert_called_with('https://api-3t.sandbox.paypal.com/nvp',
                                    data={
                    'METHOD': 'GetExpressCheckoutDetails',
                    'VERSION': '72.0',
                    'USER': 'sdk-three_api1.sdk.com',
                    'PWD': 'QFZCWN5HZM8VBG7Q',
                    'SIGNATURE': 'A-IzJhZZjhg29XQ2qnhapuwxIDzyAZQ92FRP5dqBzVesOkzbdUONzmOU',
                    'TOKEN': '123',
                    'PAYERID': '456',
                    })

    def test_contributions_confirm_bad_action(self):
        res = self.testapp.post('/contribute/paypal-success-callback',
                                status=400)
        self.assertEqual(res.status, '400 Bad Request')

    def test_contributions_confirm_bad_amount(self):
        res = self.testapp.post('/contribute/paypal-success-callback', {
                'submit': 'Submit',
                'token': '123',
                'payerid': '456',
                'amount': 'five',
                }, status=400)
        self.assertEqual(res.status, '400 Bad Request')

    def test_contributions_confirm_cancel(self):
        res = self.testapp.post('/contribute/paypal-success-callback', {
                'cancel': 'Cancel',
                }, status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/contribute/paypal-cancel-callback')

    def test_contributions_confirm_error2(self):
        res = self.testapp.post('/contribute/paypal-success-callback', {
                'submit': 'Submit',
                }, status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/contribute')

        session = self.get_session(res)
        self.assertEqual(session['_f_error'], ['There was a problem in the confirmation process. Please start the checkout again'])

    def test_contributions_confirm_success(self):
        os.environ['YITH_FAKE_DATETIME'] = '2013-1-2-10-11-02'

        with patch('requests.post') as fake:
            fake.return_value.ok = True
            fake.return_value.text = 'ACK=Success'

            self.assertEqual(self.db.donations.count(), 0)

            res = self.testapp.post('/contribute/paypal-success-callback', {
                    'submit': 'Submit',
                    'token': '123',
                    'payerid': '456',
                    'amount': '5',
                    'firstname': 'John',
                    'lastname': 'Doe',
                    'city': 'ExampleCity',
                    'country': 'ExampleCountry',
                    'state': 'ExampleState',
                    'street': 'ExampleStreet',
                    'zip': '123456',
                    'email': 'john@example.com',
                    }, status=302)
            self.assertEqual(res.status, '302 Found')
            self.assertEqual(res.location, 'http://localhost/contribute')

            session = self.get_session(res)
            self.assertEqual(session['_f_success'], ['Thank you very much for your great contribution'])

            fake.assert_called_with('https://api-3t.sandbox.paypal.com/nvp',
                                    data={
                    'METHOD': 'DoExpressCheckoutPayment',
                    'VERSION': '72.0',
                    'USER': 'sdk-three_api1.sdk.com',
                    'PWD': 'QFZCWN5HZM8VBG7Q',
                    'SIGNATURE': 'A-IzJhZZjhg29XQ2qnhapuwxIDzyAZQ92FRP5dqBzVesOkzbdUONzmOU',
                    'TOKEN': '123',
                    'PAYERID': '456',
                    'LOCALECODE': 'ES',
                    'PAYMENTREQUEST_0_ITEMAMT': 5,
                    'PAYMENTREQUEST_0_PAYMENTACTION': 'Sale',
                    'PAYMENTREQUEST_0_CURRENCYCODE': 'USD',
                    'PAYMENTREQUEST_0_AMT': 5,
                    'PAYMENTREQUEST_0_DESC': 'Donation',
                    })

            res.request.registry = self.testapp.app.registry
            mailer = get_mailer(res.request)

            # a couple of emails are sent
            self.assertEqual(len(mailer.outbox), 2)
            self.assertEqual(mailer.outbox[0].subject,
                             'Thanks for your contribution!')
            self.assertEqual(mailer.outbox[0].recipients,
                             ['john@example.com'])
            self.assertEqual(mailer.outbox[1].subject,
                             'A new donation was received!')
            self.assertEqual(mailer.outbox[1].recipients,
                             ['admin1@example.com', 'admin2@example.com'])

            # a new object in the database stores this donation
            self.assertEqual(self.db.donations.count(), 1)
            donation = tuple(self.db.donations.find())[0]
            self.assertEqual(donation['amount'], 5)
            self.assertEqual(donation['firstname'], 'John')
            self.assertEqual(donation['lastname'], 'Doe')
            self.assertEqual(donation['city'], 'ExampleCity')
            self.assertEqual(donation['country'], 'ExampleCountry')
            self.assertEqual(donation['state'], 'ExampleState')
            self.assertEqual(donation['street'], 'ExampleStreet')
            self.assertEqual(donation['zip'], '123456')
            self.assertEqual(donation['email'], 'john@example.com')
            self.assertEqual(donation['creation'],
                             datetime.datetime(2013, 1, 2, 10, 11, 2, tzinfo=bson.tz_util.utc))
            self.assertEqual(donation['send_sticker'], True)
            self.assertEqual(donation['user'], None)

        del os.environ['YITH_FAKE_DATETIME']

    def test_contributions_cancel(self):
        res = self.testapp.get('/contribute/paypal-cancel-callback',
                               status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/contribute')
        session = self.get_session(res)
        self.assertEqual(session['_f_info'], ['Thanks for considering donating to Yith Library. We will be ready if you change your mind'])

########NEW FILE########
__FILENAME__ = views
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import random

from pyramid.httpexceptions import HTTPBadRequest, HTTPFound
from pyramid.i18n import get_locale_name
from pyramid.view import view_config

from yithlibraryserver.contributions.email import send_thankyou_email
from yithlibraryserver.contributions.email import send_notification_to_admins
from yithlibraryserver.contributions.models import create_donation
from yithlibraryserver.contributions.models import include_sticker
from yithlibraryserver.contributions.paypal import PayPalExpressCheckout
from yithlibraryserver.i18n import TranslationString as _


@view_config(route_name='contributions_index',
             renderer='templates/contributions_index.pt')
def contributions_index(request):
    locale_name = get_locale_name(request)
    return {'locale': locale_name, 'random': random}


@view_config(route_name='contributions_donate',
             renderer='string')
def contributions_donate(request):
    if 'submit' in request.POST:
        paypal = PayPalExpressCheckout(request)
        amount = request.POST.get('amount', '1')
        try:
            amount = int(amount)
        except ValueError:
            return HTTPBadRequest('Amount must be an integer')
        token = paypal.get_express_checkout_token(amount)
        return HTTPFound(paypal.get_express_checkout_url(token))

    return HTTPBadRequest('Wrong action or method')


@view_config(route_name='contributions_paypal_success_callback',
             renderer='templates/contributions_confirm.pt')
def contributions_paypal_success(request):
    error_msg = _('There was a problem in the confirmation process. Please start the checkout again')
    if request.method == 'POST':
        if 'submit' in request.POST:
            token = request.POST.get('token', None)
            payerid = request.POST.get('payerid', None)
            amount = request.POST.get('amount', None)

            success = False

            if token and payerid and amount:
                try:
                    amount = int(amount)
                except ValueError:
                    return HTTPBadRequest('Amount must be an integer')

                paypal = PayPalExpressCheckout(request)
                success = paypal.do_express_checkout_payment(token, payerid,
                                                             amount)

            if success:
                donation = create_donation(request, request.POST)
                send_thankyou_email(request, donation)
                send_notification_to_admins(request, donation)
                request.session.flash(
                    _('Thank you very much for your great contribution'),
                    'success',
                )
            else:
                request.session.flash(error_msg, 'error')

            return HTTPFound(location=request.route_path('contributions_index'))

        elif 'cancel' in request.POST:
            return HTTPFound(location=request.route_path('contributions_paypal_cancel_callback'))

        else:
            return HTTPBadRequest('Wrong action')

    else:
        token = request.GET.get('token', None)
        payerid = request.GET.get('PayerID', None)

        if token and payerid:
            paypal = PayPalExpressCheckout(request)
            details = paypal.get_express_checkout_details(token, payerid)
            details.update({
                    'token': token,
                    'payerid': payerid,
                    })
            amount = details['amount']
            details['include_sticker'] = include_sticker(amount)
            return details
        else:
            request.session.flash(error_msg, 'error')
            return HTTPFound(location=request.route_path('contributions_index'))


@view_config(route_name='contributions_paypal_cancel_callback',
             renderer='string')
def contributions_paypal_cancel(request):
    request.session.flash(
        _('Thanks for considering donating to Yith Library. We will be ready if you change your mind'),
        'info',
    )
    return HTTPFound(location=request.route_path('contributions_index'))

########NEW FILE########
__FILENAME__ = cors
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import logging

log = logging.getLogger(__name__)


class CORSManager(object):

    def __init__(self, global_allowed_origins):
        self.global_allowed_origins = global_allowed_origins.split(' ')

    def add_cors_header(self, request, response):
        if 'Origin' in request.headers:
            origin = request.headers['Origin']

            client_id = request.GET.get('client_id')
            if client_id is None:
                allowed_origins = self.global_allowed_origins
            else:
                allowed_origins = self._get_allowed_origins_for_client(
                    request, client_id)

            if origin in allowed_origins:
                log.debug('Origin %s is allowed: %s' %
                          (origin, ' '.join(allowed_origins)))
                response.headers['Access-Control-Allow-Origin'] = origin
            else:
                log.debug('Origin %s is not allowed: %s' %
                          (origin, ' '.join(allowed_origins)))

    def _get_allowed_origins_for_client(self, request, client_id):
        app = request.db.applications.find_one({'client_id': client_id})
        if app is None:
            return []
        else:
            return app['authorized_origins']

########NEW FILE########
__FILENAME__ = testing
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import os


class FakeDateService(object):

    def __init__(self, request):
        self.request = request

    def today(self):
        fake = os.environ['YITH_FAKE_DATE']
        parts = [int(p) for p in fake.split('-')]
        return datetime.date(*parts)


class FakeDatetimeService(object):

    def __init__(self, request):
        self.request = request

    def utcnow(self):
        fake = os.environ['YITH_FAKE_DATETIME']
        parts = [int(p) for p in fake.split('-')]
        return datetime.datetime(*parts)


def get_fake_date(request):
    return FakeDateService(request)


def get_fake_datetime(request):
    return FakeDatetimeService(request)


def includeme(config):
    config.set_request_property(get_fake_date, 'date_service', reify=True)
    config.set_request_property(get_fake_datetime, 'datetime_service', reify=True)

########NEW FILE########
__FILENAME__ = test_service
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import unittest


from yithlibraryserver.datetimeservice import DateService, get_date
from yithlibraryserver.datetimeservice import DatetimeService, get_datetime


class DateServiceTests(unittest.TestCase):

    def assertDateEqual(self, date1, date2):
        delta = date2 - date1
        self.assertEqual(delta.days, 0)

    def test_dateservice(self):
        ds = DateService(None)
        self.assertTrue(isinstance(ds.today(), datetime.date))
        self.assertDateEqual(ds.today(), datetime.date.today())

    def test_get_date(self):
        request = object()
        date = get_date(request)
        self.assertTrue(isinstance(date, DateService))
        self.assertEqual(date.request, request)


class DatetimeServiceTests(unittest.TestCase):

    def assertDatetimeEqual(self, datetime1, datetime2):
        delta = datetime2 - datetime1
        self.assertEqual(delta.days, 0)
        self.assertTrue(delta.seconds < 2)

    def test_datetimeservice(self):
        ds = DatetimeService(None)
        self.assertTrue(isinstance(ds.utcnow(), datetime.datetime))
        self.assertDatetimeEqual(ds.utcnow(), datetime.datetime.utcnow())

    def test_get_datetime(self):
        request = object()
        datetime = get_datetime(request)
        self.assertTrue(isinstance(datetime, DatetimeService))
        self.assertEqual(datetime.request, request)

########NEW FILE########
__FILENAME__ = test_testing
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import os
import datetime
import unittest


from yithlibraryserver.datetimeservice.testing import FakeDateService, get_fake_date
from yithlibraryserver.datetimeservice.testing import FakeDatetimeService, get_fake_datetime


class FakeDateServiceTests(unittest.TestCase):

    def assertDateEqual(self, date1, date2):
        delta = date2 - date1
        self.assertEqual(delta.days, 0)

    def test_dateservice(self):
        ds = FakeDateService(None)
        fake_today = datetime.date(2012, 1, 10)
        os.environ['YITH_FAKE_DATE'] = '2012-1-10'
        self.assertTrue(isinstance(ds.today(), datetime.date))
        self.assertDateEqual(ds.today(), fake_today)
        del os.environ['YITH_FAKE_DATE']

    def test_get_fake_date(self):
        request = object()
        date = get_fake_date(request)
        self.assertTrue(isinstance(date, FakeDateService))
        self.assertEqual(date.request, request)


class FakeDatetimeServiceTests(unittest.TestCase):

    def assertDatetimeEqual(self, datetime1, datetime2):
        delta = datetime2 - datetime1
        self.assertEqual(delta.days, 0)
        self.assertTrue(delta.seconds < 2)

    def test_fakedatetimeservice(self):
        ds = FakeDatetimeService(None)
        os.environ['YITH_FAKE_DATETIME'] = '2012-1-10-14-23-01'
        fake_utcnow = datetime.datetime(2012, 1, 10, 14, 23, 1, 0)
        self.assertTrue(isinstance(ds.utcnow(), datetime.datetime))
        self.assertDatetimeEqual(ds.utcnow(), fake_utcnow)
        del os.environ['YITH_FAKE_DATETIME']

    def test_get_fakedatetime(self):
        request = object()
        datetime = get_fake_datetime(request)
        self.assertTrue(isinstance(datetime, FakeDatetimeService))
        self.assertEqual(datetime.request, request)

########NEW FILE########
__FILENAME__ = db
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import pymongo

from yithlibraryserver.compat import urlparse

DEFAULT_MONGODB_HOST = 'localhost'
DEFAULT_MONGODB_PORT = 27017
DEFAULT_MONGODB_NAME = 'yith-library'
DEFAULT_MONGODB_URI = 'mongodb://%s:%d/%s' % (DEFAULT_MONGODB_HOST,
                                              DEFAULT_MONGODB_PORT,
                                              DEFAULT_MONGODB_NAME)


class MongoDB(object):
    """Simple wrapper to get pymongo real objects from the settings uri"""

    def __init__(self, db_uri=DEFAULT_MONGODB_URI,
                 connection_factory=pymongo.Connection):
        self.db_uri = urlparse.urlparse(db_uri)
        self.connection = connection_factory(
            host=self.db_uri.hostname or DEFAULT_MONGODB_HOST,
            port=self.db_uri.port or DEFAULT_MONGODB_PORT,
            tz_aware=True)

        if self.db_uri.path:
            self.database_name = self.db_uri.path[1:]
        else:
            self.database_name = DEFAULT_MONGODB_NAME

    def get_connection(self):
        return self.connection

    def get_database(self):
        database = self.connection[self.database_name]
        if self.db_uri.username and self.db_uri.password:
            database.authenticate(self.db_uri.username, self.db_uri.password)

        return database


def get_db(request):
    return request.registry.settings['mongodb'].get_database()

########NEW FILE########
__FILENAME__ = email
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid.renderers import render

from pyramid_mailer import get_mailer
from pyramid_mailer.message import Message


def create_message(request, template, context, subject, recipients,
                   attachments=None, extra_headers=None):
    text_body = render(template + '.txt', context, request=request)
    # chamaleon txt templates are rendered as utf-8 bytestrings
    text_body = text_body.decode('utf-8')

    html_body = render(template + '.pt', context, request=request)

    extra_headers = extra_headers or {}

    message = Message(
        subject=subject,
        recipients=recipients,
        body=text_body,
        html=html_body,
        extra_headers=extra_headers,
    )

    if attachments is not None:
        for attachment in attachments:
            message.attach(attachment)

    return message


def send_email(request, template, context, subject, recipients,
               attachments=None, extra_headers=None):
    message = create_message(request, template, context, subject, recipients,
                             attachments, extra_headers)
    return get_mailer(request).send(message)


def send_email_to_admins(request, template, context, subject,
                         attachments=None, extra_headers=None):
    admin_emails = request.registry.settings['admin_emails']
    if admin_emails:
        return send_email(request, template, context, subject, admin_emails,
                          attachments, extra_headers)

########NEW FILE########
__FILENAME__ = errors
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import json

from pyramid.httpexceptions import HTTPBadRequest, HTTPNotFound


def password_not_found(msg='Password not found'):
    return HTTPNotFound(body=json.dumps({'message': msg}),
                        content_type='application/json')


def invalid_password_id(msg='Invalid password id'):
    return HTTPBadRequest(body=json.dumps({'message': msg}),
                          content_type='application/json')

########NEW FILE########
__FILENAME__ = i18n
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid.i18n import get_localizer, TranslationStringFactory
from pyramid.threadlocal import get_current_request

translation_domain = 'yithlibraryserver'
TranslationString = TranslationStringFactory(translation_domain)


def deform_translator(term):
    return get_localizer(get_current_request()).translate(term)


def locale_negotiator(request):
    available_languages = request.registry.settings['available_languages']
    return request.accept_language.best_match(available_languages)

########NEW FILE########
__FILENAME__ = jsonrenderer
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import bson

from pyramid.renderers import JSON

json_renderer = JSON()


def bson_adapter(obj, request):
    return str(obj)
json_renderer.add_adapter(bson.ObjectId, bson_adapter)


def datetime_adapter(obj, request):
    return obj.isoformat()
json_renderer.add_adapter(datetime.datetime, datetime_adapter)

########NEW FILE########
__FILENAME__ = locale
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

try:  # pragma: no cover
    from babel.dates import format_date, format_datetime
    HAS_BABEL = True
except ImportError:  # pragma: no cover
    # Babel does not work in Python 3
    HAS_BABEL = False


class DatesFormatter(object):

    def __init__(self, locale_name):
        self.locale_name = locale_name

    def date(self, date_value):
        if HAS_BABEL:
            return format_date(date_value, locale=self.locale_name)
        else:
            return date_value.strftime('%c')

    def datetime(self, datetime_value):
        if HAS_BABEL:
            return format_datetime(datetime_value, locale=self.locale_name)
        else:
            return datetime_value.strftime('%c')

########NEW FILE########
__FILENAME__ = application
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import uuid


def create_client_id_and_secret(application):
    application['client_id'] = str(uuid.uuid4())
    application['client_secret'] = str(uuid.uuid4())

########NEW FILE########
__FILENAME__ = authentication
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid.httpexceptions import HTTPUnauthorized

from yithlibraryserver.compat import decodebytes, encodebytes, encode_header


def authenticate_client(request):
    """Returns the client application representing this request.

    Uses the Authorization header in Basic format to identify
    the client of this request against the set of registered
    applications on the server.
    """
    authorization = request.headers.get('Authorization')
    if authorization is None:
        raise HTTPUnauthorized()

    method, credentials = request.authorization
    if method.lower() != 'basic':
        raise HTTPUnauthorized()

    credentials = decodebytes(credentials.encode('utf-8'))
    credentials = credentials.decode('utf-8')
    client_id, client_secret = credentials.split(':')

    application = request.db.applications.find_one({
            'client_id': client_id,
            'client_secret': client_secret
            })

    if application is None:
        raise HTTPUnauthorized()

    return application


def auth_basic_encode(user, password):
    value = '%s:%s' % (user, password)
    value = 'Basic ' + encodebytes(value.encode('utf-8')).decode('utf-8')
    return encode_header(value)

########NEW FILE########
__FILENAME__ = authorization
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import uuid


class Codes(object):

    collection_name = ''

    def __init__(self, db):
        self.db = db
        self.collection = self.db[self.collection_name]

    def create(self, user_id, **kwargs):
        code = str(uuid.uuid4())

        new_obj = {
            'code': code,
            'user': user_id,
            }
        new_obj.update(kwargs)

        old_obj = dict(kwargs)  # make a copy
        old_obj['user'] = user_id

        self.collection.remove(old_obj, safe=True)
        self.collection.insert(new_obj, safe=True)

        return code

    def find(self, code):
        return self.collection.find_one({'code': code})

    def remove(self, code_obj):
        self.collection.remove(code_obj, safe=True)


class AuthorizationCodes(Codes):

    collection_name = 'authorization_codes'

    def get_redirect_url(self, code, uri, state=None):
        parameters = ['code=%s' % code]
        if state:
            parameters.append('state=%s' % state)
        return '%s?%s' % (uri, '&'.join(parameters))

    def create(self, user_id, client_id, scope):
        return super(AuthorizationCodes, self).create(user_id,
                                                      scope=scope,
                                                      client_id=client_id)


class AccessCodes(Codes):

    collection_name = 'access_codes'

    def create(self, user_id, grant):
        return super(AccessCodes, self).create(user_id,
                                               scope=grant['scope'],
                                               client_id=grant['client_id'])


class Authorizator(object):

    def __init__(self, db, app):
        self.db = db
        self.app = app
        self.auth_codes = AuthorizationCodes(db)
        self.access_codes = AccessCodes(db)

    def is_app_authorized(self, user):
        return self.app['_id'] in user['authorized_apps']

    def store_user_authorization(self, user):
        self.db.users.update(
            {'_id': user['_id']},
            {'$addToSet': {'authorized_apps': self.app['_id']}},
            safe=True,
            )

    def remove_user_authorization(self, user):
        self.db.users.update(
            {'_id': user['_id']},
            {'$pull': {'authorized_apps': self.app['_id']}},
            safe=True,
            )

########NEW FILE########
__FILENAME__ = client
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import uuid

import requests

from pyramid.httpexceptions import HTTPBadRequest, HTTPFound, HTTPUnauthorized

from yithlibraryserver.compat import urlparse, url_encode


def oauth2_step1(request, auth_uri, client_id, redirect_url, scope):
    state = str(uuid.uuid4())
    request.session['state'] = state

    params = {
        'response_type': 'code',
        'client_id': client_id,
        'redirect_uri': redirect_url,
        'scope': scope,
        'state': state,
        }

    if 'next_url' in request.params:
        request.session['next_url'] = request.params['next_url']

    return HTTPFound(location=auth_uri + '?' + url_encode(params))


def oauth2_step2(request, token_uri, client_id, client_secret, redirect_url,
                 scope):
    try:
        code = request.params['code']
    except KeyError:
        return HTTPBadRequest('Missing required code')

    try:
        state = request.params['state']
    except KeyError:
        return HTTPBadRequest('Missing required state')

    try:
        my_state = request.session['state']
        if state != my_state:
            return HTTPUnauthorized('State parameter does not match internal '
                                    'state. You may be a victim of CSRF')
        else:
            del request.session['state']
    except KeyError:
        return HTTPUnauthorized('Missing internal state. '
                                'You may be a victim of CSRF')

    params = {
        'grant_type': 'authorization_code',
        'client_id': client_id,
        'client_secret': client_secret,
        'code': code,
        'redirect_uri': redirect_url,
        'scope': scope,
        }

    response = requests.post(token_uri, data=params)

    if response.status_code != 200:
        return HTTPUnauthorized(response.text)

    response_json = response.json()
    if response_json is None:
        response_json = dict(urlparse.parse_qsl(response.text))

    return response_json['access_token']


def get_user_info(info_uri, access_token):
    headers = {
        'Authorization': 'Bearer %s' % access_token,
        }

    response = requests.get(info_uri, headers=headers)

    if response.status_code != 200:
        return HTTPUnauthorized(response.text)

    return response.json()

########NEW FILE########
__FILENAME__ = forms
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import colander


class ApplicationSchema(colander.MappingSchema):

    name = colander.SchemaNode(colander.String())
    main_url = colander.SchemaNode(colander.String())
    callback_url = colander.SchemaNode(colander.String())

########NEW FILE########
__FILENAME__ = schemas
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import colander
from deform.widget import TextAreaWidget, TextInputWidget

from yithlibraryserver.compat import string_types
from yithlibraryserver.i18n import TranslationString as _


class AuthorizedOriginsNode(colander.SchemaNode):
    """Converts a node of type string into and from a list of strings"""

    def serialize(self, appstruct=colander.null):
        if not appstruct is colander.null and isinstance(appstruct, list):
            appstruct = '\n'.join(appstruct)
        return super(AuthorizedOriginsNode, self).serialize(appstruct)

    def deserialize(self, cstruct=colander.null):
        result = super(AuthorizedOriginsNode, self).deserialize(cstruct)
        if not result is colander.null and isinstance(result, string_types):
            result = [item.strip() for item in result.split('\n')
                      if item.strip()]

        return result


class ApplicationSchema(colander.MappingSchema):

    name = colander.SchemaNode(colander.String(), title=_('Name'))
    main_url = colander.SchemaNode(
        colander.String(),
        title=_('Main URL'),
        widget=TextInputWidget(css_class='input-xlarge'),
        )
    callback_url = colander.SchemaNode(
        colander.String(),
        title=_('Callback URL'),
        widget=TextInputWidget(css_class='input-xlarge'),
        )
    authorized_origins = AuthorizedOriginsNode(
        colander.String(),
        title=_('Authorized Origins'),
        description=_('One per line. For example https://example.com'),
        missing=[],
        widget=TextAreaWidget(css_class='input-xlarge'),
        )
    production_ready = colander.SchemaNode(
        colander.Boolean(),
        title=_('Production ready'),
        missing=False,
        )
    image_url = colander.SchemaNode(
        colander.String(),
        title=_('Image URL'),
        missing='',
        widget=TextInputWidget(css_class='input-xlarge'),
        )
    description = colander.SchemaNode(
        colander.String(),
        title=_('Description'),
        missing='',
        widget=TextAreaWidget(css_class='input-xlarge'),
        )


class ReadOnlyTextInputWidget(TextInputWidget):

    def serialize(self, field, cstruct, readonly=False):
        return super(ReadOnlyTextInputWidget, self).serialize(field,
                                                              cstruct=cstruct,
                                                              readonly=True)


class FullApplicationSchema(ApplicationSchema):

    client_id = colander.SchemaNode(
        colander.String(),
        title=_('Client Id'),
        widget=ReadOnlyTextInputWidget(css_class='input-xlarge'),
        )
    client_secret = colander.SchemaNode(
        colander.String(),
        title=_('Client secret'),
        widget=ReadOnlyTextInputWidget(css_class='input-xlarge'),
        )

########NEW FILE########
__FILENAME__ = test_authentication
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid.httpexceptions import HTTPUnauthorized

from yithlibraryserver import testing
from yithlibraryserver.oauth2.authentication import authenticate_client
from yithlibraryserver.oauth2.authentication import auth_basic_encode


class AuthenticationTests(testing.TestCase):

    clean_collections = ('applications', )

    def test_authenticate_client(self):
        request = testing.FakeRequest(headers={})
        # The authorization header is required
        self.assertRaises(HTTPUnauthorized, authenticate_client, request)

        request = testing.FakeRequest(
            headers={'Authorization': 'Advanced foobar'})
        # Only the basic method is allowed
        self.assertRaises(HTTPUnauthorized, authenticate_client, request)

        request = testing.FakeRequest(headers={
                'Authorization': auth_basic_encode('foo', 'bar'),
                }, db=self.db)
        # Invalid user:password
        self.assertRaises(HTTPUnauthorized, authenticate_client, request)

        self.db.applications.insert({
                'client_id': '123456',
                'client_secret': 'secret',
                })
        request = testing.FakeRequest(headers={
                'Authorization': auth_basic_encode('123456', 'secret'),
                }, db=self.db)
        res = authenticate_client(request)
        self.assertEqual(res['client_id'], '123456')
        self.assertEqual(res['client_secret'], 'secret')

    def test_auth_basic_encode(self):
        self.assertEqual(auth_basic_encode('foo', 'bar'),
                         'Basic Zm9vOmJhcg==\n')

########NEW FILE########
__FILENAME__ = test_authorization
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from yithlibraryserver import testing
from yithlibraryserver.oauth2.authorization import AuthorizationCodes
from yithlibraryserver.oauth2.authorization import AccessCodes
from yithlibraryserver.oauth2.authorization import Authorizator


class AuthorizationTests(testing.TestCase):

    clean_collections = ('authorization_codes', 'access_codes', 'users')

    def test_authorization_codes(self):
        codes = AuthorizationCodes(self.db)
        url = codes.get_redirect_url('1234', 'http://example.com', 'test')
        self.assertEqual(url, 'http://example.com?code=1234&state=test')
        url = codes.get_redirect_url('1234', 'http://example.com')
        self.assertEqual(url, 'http://example.com?code=1234')

        self.assertEqual(self.db.authorization_codes.count(), 0)
        code1 = codes.create('user1', 'client1', 'passwords')
        self.assertEqual(self.db.authorization_codes.count(), 1)

        # creating a code with same arguments replace the old one
        code2 = codes.create('user1', 'client1', 'passwords')
        self.assertEqual(self.db.authorization_codes.count(), 1)

        self.assertNotEqual(code1, code2)

        self.assertNotEqual(None, codes.find(code2))
        self.assertEqual(None, codes.find(code1))

        codes.remove(codes.find(code1))
        self.assertEqual(self.db.authorization_codes.count(), 0)

    def test_access_codes(self):
        codes = AccessCodes(self.db)
        self.assertEqual(self.db.access_codes.count(), 0)
        grant = {'scope': 'passwords', 'client_id': 'client1'}
        code1 = codes.create('user1', grant)
        self.assertEqual(self.db.access_codes.count(), 1)

        # creating a code with same arguments replace the old one
        code2 = codes.create('user1', grant)
        self.assertEqual(self.db.access_codes.count(), 1)

        self.assertNotEqual(code1, code2)

        self.assertNotEqual(None, codes.find(code2))
        self.assertEqual(None, codes.find(code1))

        codes.remove(codes.find(code1))
        self.assertEqual(self.db.access_codes.count(), 0)

    def test_authorizator(self):
        app = {'_id': 'app1'}
        authorizator = Authorizator(self.db, app)
        self.assertTrue(isinstance(authorizator.auth_codes,
                                   AuthorizationCodes))
        self.assertTrue(isinstance(authorizator.access_codes,
                                   AccessCodes))
        user = {'name': 'John Doe', 'authorized_apps': []}
        self.db.users.insert(user, safe=True)

        self.assertFalse(authorizator.is_app_authorized(user))

        authorizator.store_user_authorization(user)
        user = self.db.users.find_one({'name': 'John Doe'})

        self.assertTrue(authorizator.is_app_authorized(user))
        self.assertEqual(user['authorized_apps'], ['app1'])

        authorizator.remove_user_authorization(user)
        user = self.db.users.find_one({'name': 'John Doe'})

        self.assertFalse(authorizator.is_app_authorized(user))
        self.assertFalse('app1' in user['authorized_apps'])

########NEW FILE########
__FILENAME__ = test_client
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from mock import patch

from pyramid.testing import DummyRequest

from yithlibraryserver.compat import urlparse
from yithlibraryserver.oauth2.client import get_user_info
from yithlibraryserver.oauth2.client import oauth2_step1, oauth2_step2


class Oauth2ClientTests(unittest.TestCase):

    def test_oauth2_step1(self):
        with patch('uuid.uuid4') as fake:
            fake.return_value = 'random-string'

            request = DummyRequest()
            request.params = {'next_url': 'http://localhost/'}
            request.session = {}
            response = oauth2_step1(
                request=request,
                auth_uri='http://example.com/oauth2/auth',
                client_id='1234',
                redirect_url='http://localhost/oauth2/callback',
                scope='scope1 scope2'
                )
            self.assertEqual(response.status, '302 Found')
            url = urlparse.urlparse(response.location)
            self.assertEqual(url.netloc, 'example.com')
            self.assertEqual(url.path, '/oauth2/auth')
            query = urlparse.parse_qs(url.query)
            self.assertEqual(query, {
                    'scope': ['scope1 scope2'],
                    'state': ['random-string'],
                    'redirect_uri': ['http://localhost/oauth2/callback'],
                    'response_type': ['code'],
                    'client_id': ['1234'],
                    })
            self.assertEqual(request.session['next_url'], 'http://localhost/')

    def test_oauth2_step2(self):
        token_uri = 'http://example.com/oauth2/token'
        client_id = '1234'
        client_secret = 'secret'
        redirect_url = 'http://localhost/oauth2/callback'
        scope = 'scope1 scope2'
        request = DummyRequest()
        response = oauth2_step2(request, token_uri, client_id, client_secret,
                                redirect_url, scope)
        self.assertEqual(response.status, '400 Bad Request')
        self.assertEqual(response.message, 'Missing required code')

        request.params = {'code': 'abcdef'}
        response = oauth2_step2(request, token_uri, client_id, client_secret,
                                redirect_url, scope)
        self.assertEqual(response.status, '400 Bad Request')
        self.assertEqual(response.message, 'Missing required state')

        request.params['state'] = 'random-string'
        response = oauth2_step2(request, token_uri, client_id, client_secret,
                                redirect_url, scope)
        self.assertEqual(response.status, '401 Unauthorized')
        self.assertEqual(response.message, 'Missing internal state. You may be a victim of CSRF')

        request.session = {'state': 'other-string'}
        response = oauth2_step2(request, token_uri, client_id, client_secret,
                                redirect_url, scope)
        self.assertEqual(response.status, '401 Unauthorized')
        self.assertEqual(response.message, 'State parameter does not match internal state. You may be a victim of CSRF')

        with patch('requests.post') as fake:
            fake.return_value.status_code = 401
            fake.return_value.text = 'Unauthorized request'
            request.session['state'] = 'random-string'
            response = oauth2_step2(request, token_uri,
                                    client_id, client_secret,
                                    redirect_url, scope)
            self.assertEqual(response.status, '401 Unauthorized')
            self.assertEqual(response.message, 'Unauthorized request')

        with patch('requests.post') as fake:
            fake.return_value.status_code = 200
            fake.return_value.json = lambda: {
                'access_token': 'qwerty'
                }
            request.session['state'] = 'random-string'
            response = oauth2_step2(request, token_uri,
                                    client_id, client_secret,
                                    redirect_url, scope)
            self.assertEqual(response, 'qwerty')

        with patch('requests.post') as fake:
            fake.return_value.status_code = 200
            fake.return_value.json = lambda: None
            fake.return_value.text = 'access_token=qwerty'
            request.session['state'] = 'random-string'
            response = oauth2_step2(request, token_uri,
                                    client_id, client_secret,
                                    redirect_url, scope)
            self.assertEqual(response, 'qwerty')

    def test_get_user_info(self):
        with patch('requests.get') as fake:
            fake.return_value.status_code = 401
            fake.return_value.text = 'Unauthorized request'

            response = get_user_info('http://example.com/info', 'qwerty')
            self.assertEqual(response.status, '401 Unauthorized')
            self.assertEqual(response.message, 'Unauthorized request')

        with patch('requests.get') as fake:
            fake.return_value.status_code = 200
            fake.return_value.json = lambda: {
                'name': 'John',
                'surname': 'Doe',
                }

            response = get_user_info('http://example.com/info', 'qwerty')
            self.assertEqual(response, {
                    'name': 'John',
                    'surname': 'Doe',
                    })

########NEW FILE########
__FILENAME__ = test_views
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import bson

from yithlibraryserver import testing
from yithlibraryserver.oauth2.views import DEFAULT_SCOPE
from yithlibraryserver.oauth2.authentication import auth_basic_encode


class ViewTests(testing.TestCase):

    clean_collections = ('applications', 'users', 'authorization_codes',
                         'access_codes')

    def test_authorization_endpoint(self):
        # this view required authentication
        res = self.testapp.get('/oauth2/endpoints/authorization')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'authorized_apps': [],
                }, safe=True)
        self.set_user_cookie(str(user_id))

        # 1. test incorrect requests
        res = self.testapp.get('/oauth2/endpoints/authorization',
                               status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Missing required response_type')

        res = self.testapp.get('/oauth2/endpoints/authorization', {
                'response_type': 'token',
                }, status=501)

        self.assertEqual(res.status, '501 Not Implemented')
        res.mustcontain('Only code is supported')

        res = self.testapp.get('/oauth2/endpoints/authorization', {
                'response_type': 'code',
                }, status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Missing required client_type')

        res = self.testapp.get('/oauth2/endpoints/authorization', {
                'response_type': 'code',
                'client_id': '1234',
                }, status=404)
        self.assertEqual(res.status, '404 Not Found')

        # create a valid app
        owner_id = self.db.users.insert({
                'twitter_id': 'twitter2',
                'screen_name': 'Administrator',
                'first_name': 'Alice',
                'last_name': 'Doe',
                'email': 'alice@example.com',
                'authorized_apps': [],
                }, safe=True)
        app_id = self.db.applications.insert({
                'owner': owner_id,
                'client_id': '123456',
                'name': 'Example',
                'main_url': 'https://example.com',
                'callback_url': 'https://example.com/callback',
                'image_url': 'https://example.com/logo.png',
                'description': 'Example description',
                }, safe=True)

        res = self.testapp.get('/oauth2/endpoints/authorization', {
                'response_type': 'code',
                'client_id': '123456',
                'redirect_uri': 'https://example.com/bad-callback',
                }, status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Redirect URI does not match registered callback URL')

        # 2. Valid requests
        # simulate a cancel action
        res = self.testapp.get('/oauth2/endpoints/authorization', {
                'response_type': 'code',
                'client_id': '123456',
                'redirect_uri': 'https://example.com/callback',
                })
        self.assertEqual(res.status, '200 OK')

        res = self.testapp.post('/oauth2/endpoints/authorization', {
                'cancel': 'No thanks',
                'response_type': 'code',
                'client_id': '123456',
                'redirect_uri': 'https://example.com/callback',
                })
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'https://example.com')

        # authenticated user who hasn't authorized the app
        res = self.testapp.get('/oauth2/endpoints/authorization', {
                'response_type': 'code',
                'client_id': '123456',
                'redirect_uri': 'https://example.com/callback',
                })
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('is asking your permission for')
        res.mustcontain('Allow access')
        res.mustcontain('No, thanks')

        res = self.testapp.post('/oauth2/endpoints/authorization', {
                'submit': 'Authorize',
                'response_type': 'code',
                'client_id': '123456',
                'redirect_uri': 'https://example.com/callback',
                })
        self.assertEqual(res.status, '302 Found')
        user = self.db.users.find_one({'_id': user_id})
        self.assertEqual(user['authorized_apps'], [app_id])
        grant = self.db.authorization_codes.find_one({
                'scope': DEFAULT_SCOPE,
                'client_id': '123456',
                'user': user_id,
                })
        self.assertNotEqual(grant, None)
        code = grant['code']
        location = 'https://example.com/callback?code=%s' % code
        self.assertEqual(res.location, location)

        # authenticate user who has already authorize the app
        res = self.testapp.get('/oauth2/endpoints/authorization', {
                'response_type': 'code',
                'client_id': '123456',
                'redirect_uri': 'https://example.com/callback',
                })
        self.assertEqual(res.status, '302 Found')
        new_grant = self.db.authorization_codes.find_one({
                'scope': DEFAULT_SCOPE,
                'client_id': '123456',
                'user': user_id,
                })
        self.assertNotEqual(new_grant, None)
        self.assertNotEqual(new_grant['_id'], grant['_id'])
        self.assertNotEqual(new_grant['code'], grant['code'])
        code = new_grant['code']
        location = 'https://example.com/callback?code=%s' % code
        self.assertEqual(res.location, location)

    def test_token_endpoint(self):
        # 1. test incorrect requests
        res = self.testapp.post('/oauth2/endpoints/token', {}, status=401)
        self.assertEqual(res.status, '401 Unauthorized')

        headers = {
            'Authorization': auth_basic_encode('123456', 'secret'),
            }

        res = self.testapp.post('/oauth2/endpoints/token', {}, headers=headers, status=401)
        self.assertEqual(res.status, '401 Unauthorized')

        app_id = self.db.applications.insert({
                'client_id': '123456',
                'client_secret': 'secret',
                'callback_url': 'https://example.com/callback',
                'name': 'Example',
                'main_url': 'https://example.com',
                }, safe=True)

        res = self.testapp.post('/oauth2/endpoints/token', {}, headers=headers, status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Missing required grant_type')

        res = self.testapp.post('/oauth2/endpoints/token', {
                'grant_type': 'password'
                }, headers=headers, status=501)
        self.assertEqual(res.status, '501 Not Implemented')
        res.mustcontain('Only authorization_code is supported')

        res = self.testapp.post('/oauth2/endpoints/token', {
                'grant_type': 'authorization_code',
                }, headers=headers, status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Missing required code')

        res = self.testapp.post('/oauth2/endpoints/token', {
                'grant_type': 'authorization_code',
                'code': 'this-code-does-not-exist',
                }, headers=headers, status=401)
        self.assertEqual(res.status, '401 Unauthorized')

        # 2. Test a valid request

        # first we generate an authorization_code
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'authorized_apps': [app_id],
                }, safe=True)
        self.set_user_cookie(str(user_id))
        res = self.testapp.get('/oauth2/endpoints/authorization', {
                'response_type': 'code',
                'client_id': '123456',
                'redirect_uri': 'https://example.com/callback',
                })
        self.assertEqual(res.status, '302 Found')
        grant = self.db.authorization_codes.find_one({
                'scope': DEFAULT_SCOPE,
                'client_id': '123456',
                'user': user_id,
                })
        self.assertNotEqual(grant, None)
        code = grant['code']

        # now send the token request
        res = self.testapp.post('/oauth2/endpoints/token', {
                'grant_type': 'authorization_code',
                'code': code,
                }, headers=headers)
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.headers['Cache-Control'], 'no-store')
        self.assertEqual(res.headers['Pragma'], 'no-cache')

        # the grant code should be removed
        grant = self.db.authorization_codes.find_one({
                'scope': DEFAULT_SCOPE,
                'client_id': '123456',
                'user': user_id,
                })
        self.assertEqual(grant, None)

        # and an access token should be created
        self.assertEqual(res.json['token_type'], 'bearer')
        self.assertEqual(res.json['expires_in'], 3600)
        self.assertEqual(res.json['scope'], DEFAULT_SCOPE)

        access_code = self.db.access_codes.find_one({
                'code': res.json['access_code'],
                })
        self.assertNotEqual(access_code, None)

    def test_token_endpoint_bad_client_id(self):
        app_id = self.db.applications.insert({
                'client_id': '123456',
                'client_secret': 'secret',
                'callback_url': 'https://example.com/callback',
                'name': 'Example',
                'main_url': 'https://example.com',
                }, safe=True)

        app_id2 = self.db.applications.insert({
                'client_id': '98765',
                'client_secret': 'secret2',
                'callback_url': 'https://example.com/callback2',
                'name': 'Example2',
                'main_url': 'https://example.com',
                }, safe=True)

        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'authorized_apps': [app_id, app_id2],
                }, safe=True)
        self.set_user_cookie(str(user_id))
        self.testapp.get('/oauth2/endpoints/authorization', {
                'response_type': 'code',
                'client_id': '123456',
                })
        grant = self.db.authorization_codes.find_one({
                'scope': DEFAULT_SCOPE,
                'client_id': '123456',
                'user': user_id,
                })
        code = grant['code']

        # Authorize with app2 credentials
        headers = {
            'Authorization': auth_basic_encode('98765', 'secret2'),
            }
        res = self.testapp.post('/oauth2/endpoints/token', {
                'grant_type': 'authorization_code',
                'code': code,
                }, headers=headers, status=401)
        self.assertEqual(res.status, '401 Unauthorized')

    def test_applications(self):
        # this view required authentication
        res = self.testapp.get('/oauth2/applications')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'authorized_apps': [],
                }, safe=True)
        self.set_user_cookie(str(user_id))

        res = self.testapp.get('/oauth2/applications')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('John')
        res.mustcontain('Log out')
        res.mustcontain('Developer Applications')
        res.mustcontain('Register new application')

        # TODO: test creating apps and make sure they appear in the output

    def test_application_new(self):
        # this view required authentication
        res = self.testapp.get('/oauth2/applications/new')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'authorized_apps': [],
                }, safe=True)
        self.set_user_cookie(str(user_id))

        res = self.testapp.get('/oauth2/applications/new')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('New Application')
        res.mustcontain('Name')
        res.mustcontain('Main URL')
        res.mustcontain('Callback URL')
        res.mustcontain('Authorized Origins')
        res.mustcontain('Production ready')
        res.mustcontain('Image URL')
        res.mustcontain('Description')

        res = self.testapp.post('/oauth2/applications/new', {
                'name': 'Test Application',
                'main_url': 'http://example.com',
                'callback_url': 'http://example.com/callback',
                'authorized_origins': '''http://example.com
https://example.com''',
                'submit': 'submit',
                })
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/oauth2/applications')

        app = self.db.applications.find_one({
                'name': 'Test Application',
                'main_url': 'http://example.com',
                'callback_url': 'http://example.com/callback',
                'authorized_origins': ['http://example.com',
                                       'https://example.com'],
                })
        self.assertNotEqual(app, None)
        self.assertTrue('client_id' in app)
        self.assertTrue('client_secret' in app)
        self.assertEqual(app['owner'], user_id)
        self.assertEqual(app['name'], 'Test Application')
        self.assertEqual(app['main_url'], 'http://example.com')
        self.assertEqual(app['callback_url'], 'http://example.com/callback')
        self.assertEqual(app['authorized_origins'],
                         ['http://example.com', 'https://example.com'])
        self.assertEqual(app['production_ready'], False)
        self.assertEqual(app['image_url'], '')
        self.assertEqual(app['description'], '')

        # error if we don't fill all fields
        res = self.testapp.post('/oauth2/applications/new', {
                'name': 'Test Application',
                'callback_url': 'http://example.com/callback',
                'submit': 'submit',
                })
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('There was a problem with your submission')

        # The user hit the cancel button
        res = self.testapp.post('/oauth2/applications/new', {
                'cancel': 'Cancel',
                })
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/oauth2/applications')

    def test_application_delete(self):
        # this view required authentication
        res = self.testapp.get('/oauth2/applications/new')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'authorized_apps': [],
                }, safe=True)
        self.set_user_cookie(str(user_id))

        res = self.testapp.get('/oauth2/applications/xxx/delete',
                               status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Invalid application id')

        res = self.testapp.get('/oauth2/applications/000000000000000000000000/delete',
                               status=404)
        self.assertEqual(res.status, '404 Not Found')

        # create a valid app
        app_id = self.db.applications.insert({
                'owner': bson.ObjectId(),
                'name': 'Test Application',
                'client_id': '123456',
                'callback_url': 'https://example.com/callback',
                'production_ready': False,
                }, safe=True)

        res = self.testapp.get('/oauth2/applications/%s/delete' % str(app_id),
                               status=401)
        self.assertEqual(res.status, '401 Unauthorized')

        self.db.applications.update({'_id': app_id}, {
                '$set': {'owner': user_id},
                }, safe=True)
        res = self.testapp.get('/oauth2/applications/%s/delete' % str(app_id))
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Delete Application <span>Test Application</span>')
        res.mustcontain('Are you sure you want to remove the application')
        res.mustcontain('Yes, I am sure')
        res.mustcontain('No, take me back to the application list')

        # now delete it
        res = self.testapp.post('/oauth2/applications/%s/delete' % str(app_id),
                                {'submit': 'Yes, I am sure'})
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/oauth2/applications')

        app = self.db.applications.find_one(app_id)
        self.assertEqual(app, None)

    def test_application_edit(self):
        # this view required authentication
        res = self.testapp.get('/oauth2/applications/xxx/edit')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'authorized_apps': [],
                }, safe=True)
        self.set_user_cookie(str(user_id))

        res = self.testapp.get('/oauth2/applications/xxx/edit',
                               status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Invalid application id')

        res = self.testapp.get(
            '/oauth2/applications/000000000000000000000000/edit',
            status=404)
        self.assertEqual(res.status, '404 Not Found')

        # create a valid app
        app_id = self.db.applications.insert({
                'owner': bson.ObjectId(),
                'name': 'Test Application',
                'main_url': 'http://example.com',
                'callback_url': 'http://example.com/callback',
                'authorized_origins': ['http://example.com',
                                       'https://example.com'],
                'production_ready': False,
                'image_url': 'http://example.com/image.png',
                'description': 'example description',
                'client_id': '123456',
                'client_secret': 'secret',
                }, safe=True)

        res = self.testapp.get('/oauth2/applications/%s/edit' % str(app_id),
                               status=401)
        self.assertEqual(res.status, '401 Unauthorized')

        self.db.applications.update({'_id': app_id}, {
                '$set': {'owner': user_id},
                }, safe=True)
        res = self.testapp.get('/oauth2/applications/%s/edit' % str(app_id))
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Edit application <span>Test Application</span>')
        res.mustcontain('Name')
        res.mustcontain('Test Application')
        res.mustcontain('Main URL')
        res.mustcontain('http://example.com')
        res.mustcontain('Callback URL')
        res.mustcontain('http://example.com/callback')
        res.mustcontain('Authorized Origins')
        res.mustcontain("""http://example.com
https://example.com""")
        res.mustcontain('Production ready')
        res.mustcontain('Image URL')
        res.mustcontain('http://example.com/image.png')
        res.mustcontain('Description')
        res.mustcontain('example description')
        res.mustcontain('Client Id')
        res.mustcontain('123456')
        res.mustcontain('Client secret')
        res.mustcontain('secret')
        res.mustcontain('Save application')
        res.mustcontain('Delete application')
        res.mustcontain('Cancel')

        # Let's make some changes
        old_count = self.db.applications.count()
        res = self.testapp.post('/oauth2/applications/%s/edit' % str(app_id), {
                'name': 'Test Application 2',
                'main_url': 'http://example.com/new',
                'callback_url': 'http://example.com/new/callback',
                'authorized_origins': 'http://client.example.com',
                'production_ready': 'true',
                'image_url': 'http://example.com/image2.png',
                'description': 'example description 2',
                'client_id': '123456-2',
                'client_secret': 'secret2',
                'submit': 'Save changes',
                })
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/oauth2/applications')
        new_app = self.db.applications.find_one(app_id)
        self.assertEqual(new_app['name'], 'Test Application 2')
        self.assertEqual(new_app['main_url'],
                         'http://example.com/new')
        self.assertEqual(new_app['callback_url'],
                         'http://example.com/new/callback')
        self.assertEqual(new_app['authorized_origins'],
                         ['http://client.example.com'])
        self.assertEqual(new_app['production_ready'], True)
        self.assertEqual(new_app['image_url'], 'http://example.com/image2.png')
        self.assertEqual(new_app['description'], 'example description 2')
        # the Id and Secret shouldn't change
        self.assertEqual(new_app['client_id'], '123456')
        self.assertEqual(new_app['client_secret'], 'secret')
        self.assertEqual(old_count, self.db.applications.count())

        # Try and invalid change
        res = self.testapp.post('/oauth2/applications/%s/edit' % str(app_id), {
                'submit': 'Save changes',
                })
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('There was a problem with your submission')
        res.mustcontain('Required')

        # The user hit the delete button
        res = self.testapp.post('/oauth2/applications/%s/edit' % str(app_id), {
                'delete': 'Delete',
                })
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location,
                         'http://localhost/oauth2/applications/%s/delete'
                         % str(app_id))

        # The user hit the cancel button
        res = self.testapp.post('/oauth2/applications/%s/edit' % str(app_id), {
                'cancel': 'Cancel',
                })
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/oauth2/applications')

    def test_authorized_applications(self):
        # this view required authentication
        res = self.testapp.get('/oauth2/authorized-applications')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'authorized_apps': [],
                }, safe=True)
        self.set_user_cookie(str(user_id))

        res = self.testapp.get('/oauth2/authorized-applications')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Authorized Applications')

    def test_revoke_application(self):
        # this view required authentication
        res = self.testapp.get('/oauth2/applications/xxx/revoke')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'authorized_apps': [],
                }, safe=True)
        self.set_user_cookie(str(user_id))

        res = self.testapp.get('/oauth2/applications/xxx/revoke',
                               status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Invalid application id')

        res = self.testapp.get(
            '/oauth2/applications/000000000000000000000000/revoke',
            status=404)
        self.assertEqual(res.status, '404 Not Found')

        # create a valid app
        app_id = self.db.applications.insert({
                'owner': bson.ObjectId(),
                'name': 'Test Application',
                'main_url': 'http://example.com',
                'callback_url': 'http://example.com/callback',
                'client_id': '123456',
                'client_secret': 'secret',
                }, safe=True)

        res = self.testapp.get('/oauth2/applications/%s/revoke' % str(app_id),
                               status=401)
        self.assertEqual(res.status, '401 Unauthorized')

        self.db.users.update({'_id': user_id}, {
                '$set': {'authorized_apps': [app_id]},
                }, safe=True)

        res = self.testapp.get('/oauth2/applications/%s/revoke' % str(app_id))
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Revoke authorization to application <span>Test Application</span>')

        res = self.testapp.post('/oauth2/applications/%s/revoke' % str(app_id), {
                'submit': 'Yes, I am sure',
                })
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/oauth2/authorized-applications')
        user = self.db.users.find_one(user_id)
        self.assertEqual(user['authorized_apps'], [])

    def test_clients(self):
        res = self.testapp.get('/oauth2/clients')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Available Clients')

        # create a couple of apps
        self.db.applications.insert({
                'client_id': '123456',
                'name': 'Example app 1',
                'main_url': 'https://example.com',
                'callback_url': 'https://example.com/callback',
                'production_ready': True,
                'image_url': 'https://example.com/image.png',
                'description': 'example description',
                }, safe=True)
        self.db.applications.insert({
                'client_id': '654321',
                'name': 'Example app 2',
                'main_url': 'https://2.example.com',
                'callback_url': 'https://2.example.com/callback',
                'production_ready': False,
                }, safe=True)

        res = self.testapp.get('/oauth2/clients')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain(
            'Available Clients', 'Example app 1', 'https://example.com',
            'https://example.com/image.png', 'example description',
            no=('Example app 2', 'https://2.example.com'),
            )


########NEW FILE########
__FILENAME__ = views
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import bson
from deform import Button, Form, ValidationFailure

from pyramid.httpexceptions import HTTPBadRequest, HTTPFound, HTTPNotFound
from pyramid.httpexceptions import HTTPNotImplemented, HTTPUnauthorized
from pyramid.view import view_config

from yithlibraryserver.i18n import TranslationString as _
from yithlibraryserver.oauth2.application import create_client_id_and_secret
from yithlibraryserver.oauth2.authentication import authenticate_client
from yithlibraryserver.oauth2.authorization import Authorizator
from yithlibraryserver.oauth2.schemas import ApplicationSchema
from yithlibraryserver.oauth2.schemas import FullApplicationSchema
from yithlibraryserver.user.security import assert_authenticated_user_is_registered


DEFAULT_SCOPE = 'passwords'

SCOPE_NAMES = {
    'passwords': _('Access your passwords'),
    }


@view_config(route_name='oauth2_developer_applications',
             renderer='templates/developer_applications.pt',
             permission='view-applications')
def developer_applications(request):
    assert_authenticated_user_is_registered(request)
    owned_apps_filter = {'owner': request.user['_id']}
    return {
        'applications': request.db.applications.find(owned_apps_filter)
        }


@view_config(route_name='oauth2_developer_application_new',
             renderer='templates/developer_application_new.pt',
             permission='add-application')
def developer_application_new(request):
    assert_authenticated_user_is_registered(request)
    schema = ApplicationSchema()
    button1 = Button('submit', _('Save application'))
    button1.css_class = 'btn-primary'
    button2 = Button('cancel', _('Cancel'))
    button2.css_class = ''
    form = Form(schema, buttons=(button1, button2))

    if 'submit' in request.POST:
        controls = request.POST.items()
        try:
            appstruct = form.validate(controls)
        except ValidationFailure as e:
            return {'form': e.render()}

        # the data is fine, save into the db
        application = {
            'owner': request.user['_id'],
            'name': appstruct['name'],
            'main_url': appstruct['main_url'],
            'callback_url': appstruct['callback_url'],
            'authorized_origins': appstruct['authorized_origins'],
            'production_ready': appstruct['production_ready'],
            'image_url': appstruct['image_url'],
            'description': appstruct['description'],
            }
        create_client_id_and_secret(application)

        request.session.flash(
            _('The application ${app} was created successfully',
              mapping={'app': appstruct['name']}),
            'success')

        request.db.applications.insert(application, safe=True)
        return HTTPFound(
            location=request.route_path('oauth2_developer_applications'))
    elif 'cancel' in request.POST:
        return HTTPFound(
            location=request.route_path('oauth2_developer_applications'))

    # this is a GET
    return {'form': form.render()}


@view_config(route_name='oauth2_developer_application_edit',
             renderer='templates/developer_application_edit.pt',
             permission='edit-application')
def developer_application_edit(request):
    try:
        app_id = bson.ObjectId(request.matchdict['app'])
    except bson.errors.InvalidId:
        return HTTPBadRequest(body='Invalid application id')

    assert_authenticated_user_is_registered(request)

    app = request.db.applications.find_one(app_id)
    if app is None:
        return HTTPNotFound()

    if app['owner'] != request.user['_id']:
        return HTTPUnauthorized()

    schema = FullApplicationSchema()
    button1 = Button('submit', _('Save application'))
    button1.css_class = 'btn-primary'
    button2 = Button('delete', _('Delete application'))
    button2.css_class = 'btn-danger'
    button3 = Button('cancel', _('Cancel'))
    button3.css_class = ''
    form = Form(schema, buttons=(button1, button2, button3))

    if 'submit' in request.POST:
        controls = request.POST.items()
        try:
            appstruct = form.validate(controls)
        except ValidationFailure as e:
            return {'form': e.render(), 'app': app}

        # the data is fine, save into the db
        application = {
            'owner': request.user['_id'],
            'name': appstruct['name'],
            'main_url': appstruct['main_url'],
            'callback_url': appstruct['callback_url'],
            'authorized_origins': appstruct['authorized_origins'],
            'production_ready': appstruct['production_ready'],
            'image_url': appstruct['image_url'],
            'description': appstruct['description'],
            'client_id': app['client_id'],
            'client_secret': app['client_secret'],
            }

        request.db.applications.update({'_id': app['_id']},
                                       application, safe=True)

        request.session.flash(_('The changes were saved successfully'),
                              'success')

        return HTTPFound(
            location=request.route_path('oauth2_developer_applications'))
    elif 'delete' in request.POST:
        return HTTPFound(
            location=request.route_path('oauth2_developer_application_delete',
                                        app=app['_id']))
    elif 'cancel' in request.POST:
        return HTTPFound(
            location=request.route_path('oauth2_developer_applications'))

    # this is a GET
    return {'form': form.render(app), 'app': app}


@view_config(route_name='oauth2_developer_application_delete',
             renderer='templates/developer_application_delete.pt',
             permission='delete-application')
def developer_application_delete(request):
    try:
        app_id = bson.ObjectId(request.matchdict['app'])
    except bson.errors.InvalidId:
        return HTTPBadRequest(body='Invalid application id')

    app = request.db.applications.find_one(app_id)
    if app is None:
        return HTTPNotFound()

    assert_authenticated_user_is_registered(request)
    if app['owner'] != request.user['_id']:
        return HTTPUnauthorized()

    if 'submit' in request.POST:
        request.db.applications.remove(app_id, safe=True)
        request.session.flash(
            _('The application ${app} was deleted successfully',
              mapping={'app': app['name']}),
            'success',
            )
        return HTTPFound(
            location=request.route_path('oauth2_developer_applications'))

    return {'app': app}


@view_config(route_name='oauth2_authorization_endpoint',
             renderer='templates/application_authorization.pt',
             permission='add-authorized-app')
def authorization_endpoint(request):
    response_type = request.params.get('response_type')
    if response_type is None:
        return HTTPBadRequest('Missing required response_type')

    if response_type != 'code':
        return HTTPNotImplemented('Only code is supported')

    client_id = request.params.get('client_id')
    if client_id is None:
        return HTTPBadRequest('Missing required client_type')

    app = request.db.applications.find_one({'client_id': client_id})
    if app is None:
        return HTTPNotFound()

    redirect_uri = request.params.get('redirect_uri')
    if redirect_uri is None:
        redirect_uri = app['callback_url']
    else:
        if redirect_uri != app['callback_url']:
            return HTTPBadRequest(
                'Redirect URI does not match registered callback URL')

    scope = request.params.get('scope', DEFAULT_SCOPE)

    state = request.params.get('state')

    user = assert_authenticated_user_is_registered(request)

    authorizator = Authorizator(request.db, app)

    if 'submit' in request.POST:
        if not authorizator.is_app_authorized(request.user):
            authorizator.store_user_authorization(request.user)

        code = authorizator.auth_codes.create(
            request.user['_id'], app['client_id'], scope)
        url = authorizator.auth_codes.get_redirect_url(
            code, redirect_uri, state)
        return HTTPFound(location=url)

    elif 'cancel' in request.POST:
        return HTTPFound(app['main_url'])

    else:
        if authorizator.is_app_authorized(user):
            code = authorizator.auth_codes.create(
                user['_id'], app['client_id'], scope)
            url = authorizator.auth_codes.get_redirect_url(
                code, redirect_uri, state)
            return HTTPFound(location=url)

        else:
            authorship_information = ''
            owner_id = app.get('owner', None)
            if owner_id is not None:
                owner = request.db.users.find_one({'_id': owner_id})
                if owner:
                    email = owner.get('email', None)
                    if email:
                        authorship_information = _('By ${owner}',
                                                   mapping={'owner': email})

            scopes = [SCOPE_NAMES.get(scope, scope)
                      for scope in scope.split(' ')]
            return {
                'response_type': response_type,
                'client_id': client_id,
                'redirect_uri': redirect_uri,
                'scope': scope,
                'state': state,
                'app': app,
                'scopes': scopes,
                'authorship_information': authorship_information,
                }


@view_config(route_name='oauth2_token_endpoint',
             renderer='json')
def token_endpoint(request):
    app = authenticate_client(request)

    grant_type = request.POST.get('grant_type')
    if grant_type is None:
        return HTTPBadRequest('Missing required grant_type')

    if grant_type != 'authorization_code':
        return HTTPNotImplemented('Only authorization_code is supported')

    code = request.POST.get('code')
    if code is None:
        return HTTPBadRequest('Missing required code')

    authorizator = Authorizator(request.db, app)

    grant = authorizator.auth_codes.find(code)
    if grant is None:
        return HTTPUnauthorized()

    # TODO: check if the grant is rotten

    if app['client_id'] != grant['client_id']:
        return HTTPUnauthorized()

    authorizator.auth_codes.remove(grant)

    request.response.headers['Cache-Control'] = 'no-store'
    request.response.headers['Pragma'] = 'no-cache'

    access_code = authorizator.access_codes.create(grant['user'], grant)

    return {
        'access_code': access_code,
        'token_type': 'bearer',
        'expires_in': 3600,
        'scope': grant['scope'],
        }


@view_config(route_name='oauth2_authorized_applications',
             renderer='templates/authorized_applications.pt',
             permission='view-applications')
def authorized_applications(request):
    assert_authenticated_user_is_registered(request)
    authorized_apps_filter = {'_id': {'$in': request.user['authorized_apps']}}
    authorized_apps = request.db.applications.find(authorized_apps_filter)
    return {'authorized_apps': authorized_apps}


@view_config(route_name='oauth2_revoke_application',
             renderer='templates/application_revoke_authorization.pt',
             permission='revoke-authorized-app')
def revoke_application(request):
    assert_authenticated_user_is_registered(request)

    try:
        app_id = bson.ObjectId(request.matchdict['app'])
    except bson.errors.InvalidId:
        return HTTPBadRequest(body='Invalid application id')

    app = request.db.applications.find_one(app_id)
    if app is None:
        return HTTPNotFound()

    authorizator = Authorizator(request.db, app)

    if not authorizator.is_app_authorized(request.user):
        return HTTPUnauthorized()

    if 'submit' in request.POST:
        authorizator.remove_user_authorization(request.user)

        request.session.flash(
            _('The access to application ${app} has been revoked',
              mapping={'app': app['name']}),
            'success',
            )
        return HTTPFound(
            location=request.route_path('oauth2_authorized_applications'))

    return {'app': app}


@view_config(route_name='oauth2_clients',
             renderer='templates/clients.pt')
def clients(request):
    return {'apps': request.db.applications.find({'production_ready': True})}

########NEW FILE########
__FILENAME__ = models
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.


class PasswordsManager(object):

    def __init__(self, db):
        self.db = db

    def create(self, user, password):
        """Creates and returns a new password or a set of passwords.

        Stores the password in the database for this specific user
        and returns a new dict with the 'owner' and '_id' fields
        filled.

        If password is a list, do the same with each password in
        this list.
        """
        if isinstance(password, dict):
            if password:
                new_password = dict(password)  # copy since we are changing this object
                new_password['owner'] = user['_id']
                _id = self.db.passwords.insert(new_password, safe=True)
                new_password['_id'] = _id
                return new_password
        else:
            new_passwords = []  # copy since we are changing this object
            for p in password:
                if p:
                    p = dict(p)
                    p['owner'] = user['_id']
                    new_passwords.append(p)

            if new_passwords:

                _ids = self.db.passwords.insert(new_passwords, safe=True)

                for i in range(len(new_passwords)):
                    new_passwords[i]['_id'] = _ids[i]

                return new_passwords

    def retrieve(self, user, _id=None):
        """Return the user's passwords or just one.

        If _id is None return the whole set of passwords for this
        user. Otherwise, it returns the password with that _id.
        """
        if _id is None:
            return self.db.passwords.find({'owner': user['_id']})
        else:
            return self.db.passwords.find_one({
                    '_id': _id,
                    'owner': user['_id'],
                    })

    def update(self, user, _id, password):
        """Update a password in the database.

        Return the updated password on success or None if the original
        password does not exist.
        """
        new_password = dict(password)  # copy since we are changing this object
        new_password['owner'] = user['_id']
        result = self.db.passwords.update({
                '_id': _id,
                'owner': user['_id'],
                }, new_password, safe=True)
        new_password['_id'] = _id

        # result['n'] is the number of documents updated
        # See <http://www.mongodb.org/display/DOCS/getLastError+Command#getLastErrorCommand-ReturnValue
        if result['n'] == 1:
            return new_password
        else:
            return None

    def delete(self, user, _id=None):
        """Deletes a password from the database or the whole set for this user.

        Returns True if the delete is succesfull or False otherwise.
        """
        query = {'owner': user['_id']}
        if _id is not None:
            query['_id'] = _id

        result = self.db.passwords.remove(query, safe=True)
        return result['n'] > 0

########NEW FILE########
__FILENAME__ = test_models
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from pyramid import testing

from yithlibraryserver.db import MongoDB
from yithlibraryserver.password.models import PasswordsManager
from yithlibraryserver.testing import MONGO_URI


class PasswordsManagerTests(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp()
        mdb = MongoDB(MONGO_URI)
        self.db = mdb.get_database()
        self.pm = PasswordsManager(self.db)
        self.user_id = self.db.users.insert({'name': 'John'}, safe=True)
        self.user = self.db.users.find_one({'_id': self.user_id}, safe=True)

    def tearDown(self):
        testing.tearDown()
        self.db.drop_collection('users')
        self.db.drop_collection('passwords')

    def test_create(self):
        n_passwords = self.db.passwords.count()
        result = self.pm.create(self.user, {})
        self.assertEqual(result, None)
        self.assertEqual(n_passwords, self.db.passwords.count())

        password = {'secret': 'secret1'}
        created_password = self.pm.create(self.user, password)
        self.assertEqual(created_password['owner'], self.user_id)
        self.assertTrue('_id' in created_password)
        self.assertEqual(n_passwords + 1, self.db.passwords.count())

        result = self.pm.create(self.user, [])
        self.assertEqual(result, None)
        self.assertEqual(n_passwords + 1, self.db.passwords.count())

        result = self.pm.create(self.user, [{}])
        self.assertEqual(result, None)
        self.assertEqual(n_passwords + 1, self.db.passwords.count())

        passwords = [{
                'secret1': 'abc',
                }, {
                'secret2': 'def',
                }, {
                'secret3': 'ghi',
                }]
        created_passwords = self.pm.create(self.user, passwords)
        self.assertEqual(created_passwords[0]['owner'], self.user_id)
        self.assertEqual(created_passwords[1]['owner'], self.user_id)
        self.assertEqual(created_passwords[2]['owner'], self.user_id)
        self.assertTrue('_id' in created_passwords[0])
        self.assertTrue('_id' in created_passwords[1])
        self.assertTrue('_id' in created_passwords[2])
        self.assertEqual(n_passwords + 4, self.db.passwords.count())

    def test_retrieve(self):
        p1 = self.db.passwords.insert({
                'secret': 'secret1',
                'owner': self.user_id,
                }, safe=True)

        password = self.pm.retrieve(self.user, p1)
        self.assertEqual(password, {
                'secret': 'secret1',
                'owner': self.user_id,
                '_id': p1,
                })

        p2 = self.db.passwords.insert({
                'secret': 'secret2',
                'owner': self.user_id,
                }, safe=True)
        passwords = self.pm.retrieve(self.user)
        self.assertEqual(list(passwords), [{
                    'secret': 'secret1',
                    'owner': self.user_id,
                    '_id': p1,
                    }, {
                    'secret': 'secret2',
                    'owner': self.user_id,
                    '_id': p2,
                    }])

    def test_update(self):
        p1 = self.db.passwords.insert({
                'secret': 'secret1',
                'owner': self.user_id,
                }, safe=True)
        new_password = {'secret': 'new secret'}
        updated_password = self.pm.update(self.user, p1, new_password)
        self.assertEqual(updated_password, {
                '_id': p1,
                'owner': self.user_id,
                'secret': 'new secret',
                })

        fake_user = {'_id': '000000000000000000000000'}
        new_password['secret'] = 'another secret'
        updated_password = self.pm.update(fake_user, p1, new_password)
        self.assertEqual(None, updated_password)

    def test_delete(self):
        p1 = self.db.passwords.insert({
                'secret': 'secret1',
                'owner': self.user_id,
                }, safe=True)
        n_passwords = self.db.passwords.count()

        self.assertTrue(self.pm.delete(self.user, p1))
        self.assertEqual(n_passwords - 1, self.db.passwords.count())
        password = self.db.passwords.find_one({'_id': p1}, safe=True)
        self.assertEqual(None, password)

        p1 = self.db.passwords.insert({
                'secret': 'secret1',
                'owner': self.user_id,
                }, safe=True)
        p2 = self.db.passwords.insert({
                'secret': 'secret2',
                'owner': self.user_id,
                }, safe=True)
        n_passwords = self.db.passwords.count()
        self.assertTrue(self.pm.delete(self.user))
        self.assertEqual(n_passwords - 2, self.db.passwords.count())
        password1 = self.db.passwords.find_one({'_id': p1}, safe=True)
        self.assertEqual(None, password1)
        password2 = self.db.passwords.find_one({'_id': p2}, safe=True)
        self.assertEqual(None, password2)

########NEW FILE########
__FILENAME__ = test_validation
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from yithlibraryserver.password.validation import validate_password


class UtilsTests(unittest.TestCase):

    def test_validate_password(self):
        # empty json
        password, errors = validate_password(b'')
        self.assertEqual(password, {})
        self.assertEqual(errors, ['No JSON object could be decoded'])

        # bad json
        password, errors = validate_password(b'[1')
        self.assertEqual(password, {})
        self.assertEqual(errors, ['No JSON object could be decoded'])

        # id not in the URL
        password, errors = validate_password(b'{}', _id='1')
        self.assertEqual(errors, ['The password id must be in the body',
                                  'Secret is required',
                                  'Service is required'])

        # id doesn't match URL's id
        password, errors = validate_password(b'{"_id": "1"}', _id='2')
        self.assertEqual(errors, ['The password id does not match the URL',
                                  'Secret is required',
                                  'Service is required'])

        # secret is missing
        password, errors = validate_password(b'{"_id": "1"}', _id='1')
        self.assertEqual(errors, ['Secret is required',
                                  'Service is required'])

        # service is missing
        password, errors = validate_password(b'{"_id": "1", "secret": "s3cr3t"}', _id='1')
        self.assertEqual(errors, ['Service is required'])

        # everything is fine
        password, errors = validate_password(b'{"_id": "1", "secret": "s3cr3t", "service": "myservice"}', _id='1')
        self.assertEqual(errors, [])
        self.assertEqual(password, {
                '_id': '1',
                'secret': 's3cr3t',
                'service': 'myservice',
                'account': None,
                'expiration': None,
                'notes': None,
                'tags': None,
                'creation': None,
                'last_modification': None,
                })

########NEW FILE########
__FILENAME__ = test_views
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from yithlibraryserver import testing


class ViewTests(testing.TestCase):

    clean_collections = ('passwords', 'access_codes', 'applications', 'users')

    def setUp(self):
        super(ViewTests, self).setUp()

        self.access_code = '1234'
        self.auth_header = {'Authorization': 'Bearer %s' % self.access_code}
        self.user_id = self.db.users.insert({
                'provider_user_id': 'user1',
                'screen_name': 'User 1',
                'authorized_apps': [],
                }, safe=True)
        self.db.applications.insert({
                'name': 'test-app',
                'client_id': 'client1',
                }, safe=True)
        self.db.access_codes.insert({
                'code': self.access_code,
                'scope': None,
                'user': self.user_id,
                'client_id': 'client1',
                }, safe=True)

    def test_password_collection_options(self):
        res = self.testapp.options('/passwords')
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.body, b'')
        self.assertEqual(res.headers['Access-Control-Allow-Methods'],
                         'GET, POST')
        self.assertEqual(res.headers['Access-Control-Allow-Headers'],
                         'Origin, Content-Type, Accept, Authorization')

    def test_password_collection_get(self):
        res = self.testapp.get('/passwords', headers=self.auth_header)
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.body, b'[]')

    def test_password_collection_post(self):
        res = self.testapp.post('/passwords', '', headers=self.auth_header,
                                status=400)
        self.assertEqual(res.status, '400 Bad Request')
        self.assertEqual(res.body,
                         b'{"message": "No JSON object could be decoded"}')

        res = self.testapp.post('/passwords',
                                '{"secret": "s3cr3t", "service": "myservice"}',
                                headers=self.auth_header)

        self.assertEqual(res.status, '200 OK')

    def test_password_options(self):
        res = self.testapp.options('/passwords/123456')
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.body, b'')
        self.assertEqual(res.headers['Access-Control-Allow-Methods'],
                         'GET, PUT, DELETE')
        self.assertEqual(res.headers['Access-Control-Allow-Headers'],
                         'Origin, Content-Type, Accept, Authorization')

    def test_password_get(self):
        res = self.testapp.get('/passwords/123456', headers=self.auth_header,
                               status=400)
        self.assertEqual(res.status, '400 Bad Request')
        self.assertEqual(res.body,
                         b'{"message": "Invalid password id"}')

        res = self.testapp.get('/passwords/000000000000000000000000',
                               headers=self.auth_header,
                               status=404)
        self.assertEqual(res.status, '404 Not Found')
        self.assertEqual(res.body,
                         b'{"message": "Password not found"}')

        password_id = self.db.passwords.insert({
                'service': 'testing',
                'secret': 's3cr3t',
                'owner': self.user_id,
                }, safe=True)
        res = self.testapp.get('/passwords/%s' % str(password_id),
                               headers=self.auth_header)
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.json, {
                'service': 'testing',
                'secret': 's3cr3t',
                'owner': str(self.user_id),
                '_id': str(password_id),
                })

    def test_password_put(self):
        res = self.testapp.put('/passwords/123456', headers=self.auth_header,
                               status=400)
        self.assertEqual(res.status, '400 Bad Request')
        self.assertEqual(res.body,
                         b'{"message": "Invalid password id"}')

        res = self.testapp.put('/passwords/000000000000000000000000',
                               headers=self.auth_header, status=400)
        self.assertEqual(res.status, '400 Bad Request')
        self.assertEqual(res.body,
                         b'{"message": "No JSON object could be decoded"}')

        password_id = self.db.passwords.insert({
                'service': 'testing',
                'secret': 's3cr3t',
                'owner': self.user_id,
                }, safe=True)
        data = '{"service": "testing2", "secret": "sup3rs3cr3t", "_id": "%s"}' % str(password_id)
        res = self.testapp.put('/passwords/%s' % str(password_id),
                               data, headers=self.auth_header)
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.json, {
                'service': 'testing2',
                'secret': 'sup3rs3cr3t',
                'owner': str(self.user_id),
                'account': None,
                'creation': None,
                'expiration': None,
                'last_modification': None,
                'notes': None,
                'tags': None,
                '_id': str(password_id),
                })
        password = self.db.passwords.find_one(password_id)
        self.assertNotEqual(password, None)
        self.assertEqual(password['service'], 'testing2')
        self.assertEqual(password['secret'], 'sup3rs3cr3t')
        self.assertEqual(password['owner'], self.user_id)

        data = '{"service": "testing2", "secret": "sup3rs3cr3t", "_id": "000000000000000000000000"}'
        res = self.testapp.put('/passwords/000000000000000000000000',
                               data, headers=self.auth_header, status=404)
        self.assertEqual(res.status, '404 Not Found')
        self.assertEqual(res.body, b'{"message": "Password not found"}')

    def test_password_delete(self):
        res = self.testapp.delete('/passwords/123456',
                                  headers=self.auth_header, status=400)
        self.assertEqual(res.status, '400 Bad Request')
        self.assertEqual(res.body,
                         b'{"message": "Invalid password id"}')

        res = self.testapp.delete('/passwords/000000000000000000000000',
                                  headers=self.auth_header, status=404)
        self.assertEqual(res.status, '404 Not Found')
        self.assertEqual(res.body,
                         b'{"message": "Password not found"}')

        password = {
            'secret': 's3cr3t',
            'service': 'myservice',
            'owner': self.user_id,
            }
        _id = self.db.passwords.insert(password, safe=True)
        count = self.db.passwords.count()

        res = self.testapp.delete('/passwords/' + str(_id),
                                  headers=self.auth_header)
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.body, b'""')
        self.assertEqual(self.db.passwords.count(), count - 1)

########NEW FILE########
__FILENAME__ = validation
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import json


def validate_password(rawdata, encoding='utf-8', _id=None):
    errors = []

    try:
        data = json.loads(rawdata.decode(encoding))
    except ValueError:
        errors.append('No JSON object could be decoded')

    # if we have errors here, we can't proceed
    if errors:
        return {}, errors

    password = {}

    # check the password id is the same as in the URL
    if _id is not None:
        if '_id' not in data:
            errors.append('The password id must be in the body')
        else:
            if data['_id'] != str(_id):
                errors.append('The password id does not match the URL')
            else:
                password['_id'] = _id

    # white list submission attributes ignoring anything else
    # first required attributes
    try:
        password['secret'] = data['secret']
    except KeyError:
        errors.append('Secret is required')

    try:
        password['service'] = data['service']
    except KeyError:
        errors.append('Service is required')

    # then optional attributes
    password['account'] = data.get('account')
    password['expiration'] = data.get('expiration')
    password['notes'] = data.get('notes')
    password['tags'] = data.get('tags')
    password['last_modification'] = data.get('last_modification')
    password['creation'] = data.get('creation')

    return password, errors

########NEW FILE########
__FILENAME__ = views
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import json

import bson

from pyramid.httpexceptions import HTTPBadRequest
from pyramid.view import view_config, view_defaults

from yithlibraryserver.errors import password_not_found, invalid_password_id
from yithlibraryserver.security import authorize_user
from yithlibraryserver.password.models import PasswordsManager
from yithlibraryserver.password.validation import validate_password


@view_defaults(route_name='password_collection_view', renderer='json')
class PasswordCollectionRESTView(object):

    def __init__(self, request):
        self.request = request
        self.passwords_manager = PasswordsManager(request.db)

    @view_config(request_method='OPTIONS', renderer='string')
    def options(self):
        headers = self.request.response.headers
        headers['Access-Control-Allow-Methods'] = 'GET, POST'
        headers['Access-Control-Allow-Headers'] = ('Origin, Content-Type, '
                                                   'Accept, Authorization')
        return ''

    @view_config(request_method='GET')
    def get(self):
        user = authorize_user(self.request)
        return list(self.passwords_manager.retrieve(user))

    @view_config(request_method='POST')
    def post(self):
        user = authorize_user(self.request)
        password, errors = validate_password(self.request.body,
                                             self.request.charset)

        if errors:
            result = {'message': ','.join(errors)}
            return HTTPBadRequest(body=json.dumps(result),
                                  content_type='application/json')

        return self.passwords_manager.create(user, password)


@view_defaults(route_name='password_view', renderer='json')
class PasswordRESTView(object):

    def __init__(self, request):
        self.request = request
        self.passwords_manager = PasswordsManager(request.db)
        self.password_id = self.request.matchdict['password']

    @view_config(request_method='OPTIONS', renderer='string')
    def options(self):
        headers = self.request.response.headers
        headers['Access-Control-Allow-Methods'] = 'GET, PUT, DELETE'
        headers['Access-Control-Allow-Headers'] = ('Origin, Content-Type, '
                                                   'Accept, Authorization')
        return ''

    @view_config(request_method='GET')
    def get(self):
        user = authorize_user(self.request)
        try:
            _id = bson.ObjectId(self.password_id)
        except bson.errors.InvalidId:
            return invalid_password_id()

        password = self.passwords_manager.retrieve(user, _id)

        if password is None:
            return password_not_found()
        else:
            return password

    @view_config(request_method='PUT')
    def put(self):
        user = authorize_user(self.request)
        try:
            _id = bson.ObjectId(self.password_id)
        except bson.errors.InvalidId:
            return invalid_password_id()

        password, errors = validate_password(self.request.body,
                                             self.request.charset,
                                             _id)

        if errors:
            result = {'message': ','.join(errors)}
            return HTTPBadRequest(body=json.dumps(result),
                                  content_type='application/json')

        result = self.passwords_manager.update(user, _id, password)
        if result is None:
            return password_not_found()
        else:
            return result

    @view_config(request_method='DELETE')
    def delete(self):
        user = authorize_user(self.request)
        try:
            _id = bson.ObjectId(self.password_id)
        except bson.errors.InvalidId:
            return invalid_password_id()

        if self.passwords_manager.delete(user, _id):
            return ''
        else:
            return password_not_found()

########NEW FILE########
__FILENAME__ = audience
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from yithlibraryserver.compat import urlparse


def get_audience(public_url_root):
    parts = urlparse.urlparse(public_url_root)
    if parts.port is None:
        if parts.scheme == 'http':
            port = 80
        elif parts.scheme == 'https':
            port = 443
        else:
            raise ValueError('Error geting the port from %s' % public_url_root)
    else:
        port = parts.port

    return '%s://%s:%d' % (parts.scheme, parts.hostname, port)

########NEW FILE########
__FILENAME__ = test_audience
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from yithlibraryserver.persona.audience import get_audience


class AudienceTests(unittest.TestCase):

    def test_get_audience(self):
        self.assertEqual(get_audience('http://localhost/'),
                         'http://localhost:80')

        self.assertEqual(get_audience('https://localhost:443/'),
                         'https://localhost:443')

        self.assertEqual(get_audience('https://localhost/foo'),
                         'https://localhost:443')

        self.assertRaises(ValueError, get_audience, 'foo://localhost')

########NEW FILE########
__FILENAME__ = test_views
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from mock import patch

from yithlibraryserver import testing


class ViewTests(testing.TestCase):

    def test_persona_login(self):

        res = self.testapp.get('/persona/login', status=405)
        self.assertEqual(res.status, '405 Method Not Allowed')
        res.mustcontain('Only POST is allowed')

        res = self.testapp.post('/persona/login', status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('The assertion parameter is required')

        with patch('requests.post') as fake_post:
            fake_post.return_value.ok = False
            res = self.testapp.post('/persona/login', {
                    'assertion': 'test-assertion',
                    'next_url': 'http://localhost/oauth2/clients',
                    }, status=500)
            self.assertEqual(res.status, '500 Internal Server Error')
            res.mustcontain('Mozilla Persona verifier is not working properly')

        with patch('requests.post') as fake_post:
            fake_post.return_value.ok = True
            fake_post.return_value.json = lambda: {
                'status': 'failure',
                }
            res = self.testapp.post('/persona/login', {
                    'assertion': 'test-assertion',
                    'next_url': 'http://localhost/oauth2/clients',
                    }, status=403)
            self.assertEqual(res.status, '403 Forbidden')
            res.mustcontain('Mozilla Persona verifier can not verify your identity')

        with patch('requests.post') as fake_post:
            fake_post.return_value.ok = True
            fake_post.return_value.json = lambda: {
                'status': 'okay',
                'email': 'john@example.com',
                }
            res = self.testapp.post('/persona/login', {
                    'assertion': 'test-assertion',
                    'next_url': 'http://localhost/oauth2/clients',
                    })
            self.assertEqual(res.status, '302 Found')
            self.assertEqual(res.location, 'http://localhost/register')

########NEW FILE########
__FILENAME__ = views
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import hashlib

import requests

from pyramid.httpexceptions import HTTPBadRequest, HTTPForbidden
from pyramid.httpexceptions import HTTPMethodNotAllowed, HTTPServerError

from yithlibraryserver.user.utils import register_or_update
from yithlibraryserver.persona.audience import get_audience


def persona_login(request):
    if request.method != 'POST':
        return HTTPMethodNotAllowed('Only POST is allowed')

    assertion = request.POST.get('assertion', None)
    if assertion is None:
        return HTTPBadRequest('The assertion parameter is required')

    if 'next_url' in request.params and request.params['next_url']:
        request.session['next_url'] = request.params['next_url']

    settings = request.registry.settings
    data = {'assertion': assertion,
            'audience': get_audience(settings['public_url_root'])}
    response = requests.post(settings['persona_verifier_url'],
                             data=data, verify=True)

    if response.ok:
        verification_data = response.json()
        if verification_data['status'] == 'okay':
            email = verification_data['email']
            info = {'email': email}
            user_id = hashlib.sha1(email.encode('utf-8')).hexdigest()
            return register_or_update(request, 'persona', user_id,
                                      info, request.route_path('home'))

        else:
            return HTTPForbidden('Mozilla Persona verifier can not verify your identity')
    else:
        return HTTPServerError('Mozilla Persona verifier is not working properly')

########NEW FILE########
__FILENAME__ = schemas
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import colander
from deform.widget import TextAreaWidget

from yithlibraryserver.i18n import TranslationString as _


class ContactSchema(colander.MappingSchema):

    name = colander.SchemaNode(colander.String(), title=_('Name'))
    email = colander.SchemaNode(colander.String(), title=_('Email'))
    message = colander.SchemaNode(
        colander.String(),
        widget=TextAreaWidget(css_class='input-xxlarge', rows=10),
        title=_('Message'),
        )

########NEW FILE########
__FILENAME__ = announce
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import optparse
import textwrap
import sys

import transaction

from pyramid.paster import bootstrap

from pyramid_mailer import get_mailer

from yithlibraryserver.compat import urlparse
from yithlibraryserver.email import create_message
from yithlibraryserver.scripts.reports import get_passwords_map
from yithlibraryserver.scripts.utils import safe_print
from yithlibraryserver.scripts.utils import get_user_display_name


def get_all_users_with_passwords_and_email(db):
    all_passwords = list(db.passwords.find())
    passwords_map = get_passwords_map(all_passwords)
    for user in db.users.find({
            'email_verified': True,
            }):
        if not user['email']:
            continue

        if not user['_id'] in passwords_map:
            continue

        yield user


def send_email(request, email_template, user, preferences_link):
    safe_print('Sending email to %s' % get_user_display_name(user))
    context = {'user': user, 'preferences_link': preferences_link}
    return create_message(
        request,
        'yithlibraryserver.scripts:templates/%s' % email_template,
        context,
        "Yith Library announcement",
        [user['email']],
    )


def announce():
    usage = "migrate: %prog config_uri migration_name"
    description = "Add a 'send_email_periodically' preference to every user."
    parser = optparse.OptionParser(
        usage=usage,
        description=textwrap.dedent(description)
        )
    options, args = parser.parse_args(sys.argv[1:])
    if len(args) != 2:
        safe_print('You must provide two arguments. '
                   'The first one is the config file and the '
                   'second one is the email template.')
        return 2
    config_uri = args[0]
    email_template = args[1]
    env = bootstrap(config_uri)
    settings, closer = env['registry'].settings, env['closer']

    try:

        db = settings['mongodb'].get_database()
        request = env['request']

        public_url_root = settings['public_url_root']
        preferences_link = urlparse.urljoin(
            public_url_root,
            request.route_path('user_preferences'))

        tx = transaction.begin()

        mailer = get_mailer(request)

        for user in get_all_users_with_passwords_and_email(db):
            message = send_email(request, email_template, user,
                                 preferences_link)
            mailer.send(message)

        tx.commit()

    finally:
        closer()


if __name__ == '__main__':  # pragma: no cover
    announce()

########NEW FILE########
__FILENAME__ = backups
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import transaction

from yithlibraryserver.backups.email import send_passwords
from yithlibraryserver.compat import urlparse
from yithlibraryserver.scripts.utils import safe_print, setup_simple_command
from yithlibraryserver.scripts.utils import get_user_display_name


def get_all_users(request):
    day = request.date_service.today().day
    return request.db.users.find({
            'send_passwords_periodically': True,
            'email_verified': True,
            '$where': '''
function () {
    var i, sum;
    sum = 0;
    for (i = 0; i < this._id.str.length; i += 1) {
        sum += this._id.str.charCodeAt(i);
    }
    return sum %% 28 === %d;
}
''' % day
            }).sort('date_joined')


def get_selected_users(request, *emails):
    for email in emails:
        for user in request.db.users.find({
                'email': email,
                }).sort('date_joined'):
            yield user


def send_backups_via_email():
    result = setup_simple_command(
        "send_backups_via_email",
        "Report information about users and their passwords.",
        )
    if isinstance(result, int):
        return result
    else:
        settings, closer, env, args = result

    try:
        request = env['request']

        if len(args) == 0:
            user_iterator = get_all_users(request)
        else:
            user_iterator = get_selected_users(request, *args)

        tx = transaction.begin()

        public_url_root = settings['public_url_root']
        preferences_link = urlparse.urljoin(
            public_url_root,
            request.route_path('user_preferences'))
        backups_link = urlparse.urljoin(
            public_url_root,
            request.route_path('backups_index'))

        for user in user_iterator:
            if user['email']:
                sent = send_passwords(request, user,
                                      preferences_link, backups_link)
                if sent:
                    safe_print('Passwords sent to %s' %
                               get_user_display_name(user))

        tx.commit()

    finally:
        closer()


if __name__ == '__main__':  # pragma: no cover
    send_backups_via_email()

########NEW FILE########
__FILENAME__ = migrations
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import optparse
import textwrap
import sys

from pyramid.paster import bootstrap

from yithlibraryserver.scripts.utils import safe_print
from yithlibraryserver.scripts.utils import get_user_display_name

migration_registry = {}

def migration(fnc):
    migration_registry[fnc.__name__] = fnc
    return fnc


def add_attribute(collection, obj, obj_repr, attribute, value):
    if attribute not in obj:
        safe_print('Adding attribute "%s" to %s' % (attribute, obj_repr))
        collection.update(
            {'_id': obj['_id']},
            {'$set': {attribute: value}},
            safe=True,
            )


@migration
def add_send_email_preference(db):
    for user in db.users.find():
        add_attribute(db.users, user, get_user_display_name(user),
                      'send_passwords_periodically', True)


def migrate():
    usage = "migrate: %prog config_uri migration_name"
    description = "Add a 'send_email_periodically' preference to every user."
    parser = optparse.OptionParser(
        usage=usage,
        description=textwrap.dedent(description)
        )
    options, args = parser.parse_args(sys.argv[1:])
    if len(args) != 2:
        safe_print('You must provide two arguments. '
                   'The first one is the config file and the '
                   'second one is the migration name.')
        return 2
    config_uri = args[0]
    migration_name = args[1]
    env = bootstrap(config_uri)
    settings, closer = env['registry'].settings, env['closer']

    try:
        db = settings['mongodb'].get_database()

        if migration_name in migration_registry:
            migration = migration_registry[migration_name]
            migration(db)
        else:
            safe_print('The migration "%s" does not exist.' % migration_name)
            return 3
    finally:
        closer()


if __name__ == '__main__':  # pragma: no cover
    migrate()

########NEW FILE########
__FILENAME__ = reports
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import operator

from yithlibraryserver.user.accounts import get_available_providers
from yithlibraryserver.user.accounts import get_provider_key, get_n_passwords
from yithlibraryserver.scripts.utils import safe_print, setup_simple_command
from yithlibraryserver.scripts.utils import get_user_display_name


def _get_user_info(db, user):
    return {
        'display_name': get_user_display_name(user),
        'passwords': get_n_passwords(db, user),
        'providers': ', '.join([prov for prov in get_available_providers()
                                if ('%s_id' % prov) in user]),
        'verified': user.get('email_verified', False),
        'date_joined': user.get('date_joined', 'Unknown'),
        'last_login': user.get('last_login', 'Unknown'),
        }


def users():
    result = setup_simple_command(
        "users",
        "Report information about users and their passwords.",
        )
    if isinstance(result, int):
        return result
    else:
        settings, closer, env, args = result

    try:
        db = settings['mongodb'].get_database()
        for user in db.users.find().sort('date_joined'):
            info = _get_user_info(db, user)
            text = ('%s (%s)\n'
                    '\tPasswords: %d\n'
                    '\tProviders: %s\n'
                    '\tVerified: %s\n'
                    '\tDate joined: %s\n'
                    '\tLast login: %s\n' % (
                    info['display_name'], user['_id'],
                    info['passwords'], info['providers'], info['verified'],
                    info['date_joined'], info['last_login'],
                    ))
            safe_print(text)

    finally:
        closer()


def _get_app_info(db, app):
    user = db.users.find_one({'_id': app['owner']})
    if user is None:
        owner = 'Unknown owner (%s)' % app['owner']
    else:
        owner = get_user_display_name(user)

    return {
        'name': app['name'],
        'owner': owner,
        'main_url': app['main_url'],
        'callback_url': app['callback_url'],
        'users': db.users.find({
                'authorized_apps': {'$in': [app['_id']]},
                }).count()
        }


def applications():
    result = setup_simple_command(
        "applications",
        "Report information about oauth2 client applications.",
        )
    if isinstance(result, int):
        return result
    else:
        settings, closer, env, args = result

    try:
        db = settings['mongodb'].get_database()
        for app in db.applications.find():
            info = _get_app_info(db, app)
            text = ('%s\n'
                    '\tOwner: %s\n'
                    '\tMain URL: %s\n'
                    '\tCallback URL: %s\n'
                    '\tUsers: %d\n' % (
                    info['name'], info['owner'],
                    info['main_url'], info['callback_url'],
                    info['users'],
                    ))
            safe_print(text)

    finally:
        closer()


def group_by_identity_provider(users):
    providers = {}
    for user in users:
        for provider in get_available_providers():
            key = get_provider_key(provider)
            if user.get(key, None):
                if provider in providers:
                    providers[provider] += 1
                else:
                    providers[provider] = 1

    return sorted(providers.items(), key=operator.itemgetter(1), reverse=True)


def group_by_email_provider(users, threshold):
    providers = {}
    no_email = 0
    for user in users:
        email = user.get('email', None)
        if not email:
            no_email += 1
            continue

        provider = email.split('@')[1]
        if provider in providers:
            providers[provider] += 1
        else:
            providers[provider] = 1

    providers = [(p, a) for p, a in providers.items() if a > threshold]
    providers.sort(key=operator.itemgetter(1), reverse=True)

    return providers, no_email


def get_passwords_map(passwords):
    # make a password dict keyed by users_id
    passwords_map = {}
    for password in passwords:
        owner = password['owner']
        if owner in passwords_map:
            passwords_map[owner] += 1
        else:
            passwords_map[owner] = 1

    return passwords_map


def users_with_most_passwords(users, passwords, amount):
    passwords_map = get_passwords_map(passwords)
    users_map = dict([(user['_id'], user) for user in users])

    passwords_list = sorted(
        passwords_map.items(),
        key=operator.itemgetter(1),
        reverse=True,
        )[:amount]

    result = []
    for password_owner, amount in passwords_list:
        result.append((users_map[password_owner], amount))

    return result, len(passwords_map)


def statistics():
    result = setup_simple_command(
        "statistics",
        "Report several different statistics.",
        )
    if isinstance(result, int):
        return result
    else:
        settings, closer, env, args = result

    try:
        db = settings['mongodb'].get_database()

        # Get the number of users and passwords
        n_users = db.users.count()
        if n_users == 0:
            return

        n_passwords = db.passwords.count()

        # How many users are verified
        n_verified = db.users.find({'email_verified': True}).count()
        # How many users allow the analytics cookie
        n_allow_cookie = db.users.find({'allow_google_analytics': True}).count()

        all_users = list(db.users.find())

        # Identity providers
        by_identity = group_by_identity_provider(all_users)

        # Email providers
        by_email, without_email = group_by_email_provider(all_users, 1)
        with_email = n_users - without_email

        # Top ten users
        all_passwords = list(db.passwords.find())
        most_active_users, users_with_passwords = users_with_most_passwords(
            all_users, all_passwords, 10)

        # print the statistics
        safe_print('Number of users: %d' % n_users)
        safe_print('Number of passwords: %d' % n_passwords)
        safe_print('Verified users: %.2f%% (%d)' % (
                (100.0 * n_verified) / n_users, n_verified))
        safe_print('Users that allow Google Analytics cookie: %.2f%% (%d)' % (
                (100.0 * n_allow_cookie) / n_users, n_allow_cookie))

        safe_print('Identity providers:')
        for provider, amount in by_identity:
            safe_print('\t%s: %.2f%% (%d)' % (
                    provider, (100.0 * amount) / n_users, amount))

        safe_print('Email providers:')
        others = with_email
        for provider, amount in by_email:
            safe_print('\t%s: %.2f%% (%d)' % (
                    provider, (100.0 * amount) / with_email, amount))
            others -= amount
        safe_print('\tOthers: %.2f%% (%d)' % (
                (100.0 * others) / with_email, others))
        safe_print('Users without email: %.2f%% (%d)' % (
                (100.0 * without_email) / n_users, without_email))

        safe_print('Most active users:')
        for user, n_passwords in most_active_users:
            safe_print('\t%s: %s' % (get_user_display_name(user), n_passwords))

        users_no_passwords = n_users - users_with_passwords
        safe_print('Users without passwords: %.2f%% (%d)' % (
                (100 * users_no_passwords) / n_users, users_no_passwords))

    finally:
        closer()

########NEW FILE########
__FILENAME__ = testing
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import os
import unittest
import tempfile

from yithlibraryserver.db import MongoDB
from yithlibraryserver.testing import MONGO_URI

CONFIG = """[app:main]
use = egg:yith-library-server
mongo_uri = %s
auth_tk_secret = 123456
testing = True
pyramid_mailer.prefix = mail_
mail_default_sender = no-reply@yithlibrary.com
admin_emails = admin1@example.com admin2@example.com

[server:main]
use = egg:waitress#main
host = 0.0.0.0
port = 65432
""" % MONGO_URI


class ScriptTests(unittest.TestCase):

    clean_collections = tuple()

    def setUp(self):
        super(ScriptTests, self).setUp()

        fd, self.conf_file_path = tempfile.mkstemp()
        os.write(fd, CONFIG.encode('ascii'))
        mdb = MongoDB(MONGO_URI)
        self.db = mdb.get_database()

    def tearDown(self):
        super(ScriptTests, self).tearDown()
        os.unlink(self.conf_file_path)
        for col in self.clean_collections:
            self.db.drop_collection(col)

    def add_passwords(self, user, n):
        for i in range(n):
            self.db.passwords.insert({
                    'service': 'service-%d' % (i + 1),
                    'secret': 's3cr3t',
                    'owner': user,
                    })
        return user

########NEW FILE########
__FILENAME__ = test_announce
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import sys

from yithlibraryserver.compat import StringIO
from yithlibraryserver.scripts.announce import announce
from yithlibraryserver.scripts.testing import ScriptTests


class AnnounceTests(ScriptTests):

    clean_collections = ('users', 'passwords')

    def setUp(self):
        super(AnnounceTests, self).setUp()
        # Save sys values
        self.old_args = sys.argv[:]
        self.old_stdout = sys.stdout

    def tearDown(self):
        # Restore sys.values
        sys.argv = self.old_args
        sys.stdout = self.old_stdout
        super(AnnounceTests, self).tearDown()

    def test_no_arguments(self):
        sys.argv = []
        sys.stdout = StringIO()

        result = announce()
        self.assertEqual(result, 2)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, 'You must provide two arguments. The first one is the config file and the second one is the email template.\n')

    def test_empty_database(self):
        sys.argv = ['notused', self.conf_file_path, 'new_feature_send_passwords_via_email']
        sys.stdout = StringIO()
        result = announce()
        self.assertEqual(result, None)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, '')

    def test_announce_send_email(self):
        self.add_passwords(self.db.users.insert({
                    'first_name': 'John0',
                    'last_name': 'Doe',
                    'email': '',
                    'email_verified': False,
                    'send_passwords_periodically': False,
                    }), 10)
        self.add_passwords(self.db.users.insert({
                    'first_name': 'John1',
                    'last_name': 'Doe',
                    'email': '',
                    'email_verified': True,
                    'send_passwords_periodically': False,
                    }), 10)
        self.add_passwords(self.db.users.insert({
                    'first_name': 'John2',
                    'last_name': 'Doe',
                    'email': 'john2@example.com',
                    'email_verified': True,
                    'send_passwords_periodically': False,
                    }), 10)
        self.add_passwords(self.db.users.insert({
                    'first_name': 'John3',
                    'last_name': 'Doe',
                    'email': 'john3@example.com',
                    'email_verified': True,
                    'send_passwords_periodically': True,
                    }), 10)
        self.add_passwords(self.db.users.insert({
                    'first_name': 'John4',
                    'last_name': 'Doe',
                    'email': 'john4@example.com',
                    'email_verified': False,
                    'send_passwords_periodically': True,
                    }), 10)
        self.db.users.insert({
                    'first_name': 'John4',
                    'last_name': 'Doe',
                    'email': 'john4@example.com',
                    'email_verified': True,
                    'send_passwords_periodically': True,
                    })

        sys.argv = ['notused', self.conf_file_path, 'new_feature_send_passwords_via_email']
        sys.stdout = StringIO()
        result = announce()
        self.assertEqual(result, None)
        stdout = sys.stdout.getvalue()
        expected_output = """Sending email to John2 Doe <john2@example.com>
Sending email to John3 Doe <john3@example.com>
"""
        self.assertEqual(stdout, expected_output)

########NEW FILE########
__FILENAME__ = test_backups
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import os
import sys

from yithlibraryserver.backups.email import get_day_to_send
from yithlibraryserver.compat import StringIO
from yithlibraryserver.scripts.backups import send_backups_via_email
from yithlibraryserver.scripts.testing import ScriptTests


class BackupsTests(ScriptTests):

    clean_collections = ('users', 'passwords', )

    def setUp(self):
        super(BackupsTests, self).setUp()

        # Save sys values
        self.old_args = sys.argv[:]
        self.old_stdout = sys.stdout

        os.environ['YITH_FAKE_DATE'] = '2012-1-10'

    def tearDown(self):
        # Restore sys.values
        sys.argv = self.old_args
        sys.stdout = self.old_stdout

        del os.environ['YITH_FAKE_DATE']

        super(BackupsTests, self).tearDown()

    def test_no_arguments(self):
        # Replace sys argv and stdout
        sys.argv = []
        sys.stdout = StringIO()

        # Call send backups with no arguments
        result = send_backups_via_email()
        self.assertEqual(result, 2)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, 'You must provide at least one argument\n')

    def test_empty_database(self):
        # Call send backups with a config file but an empty database
        sys.argv = ['notused', self.conf_file_path]
        sys.stdout = StringIO()
        result = send_backups_via_email()
        self.assertEqual(result, None)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, '')

    def test_send_specific_user(self):
        self.add_passwords(self.db.users.insert({
                    'first_name': 'John1',
                    'last_name': 'Doe',
                    'email': '',
                    'email_verified': False,
                    'send_passwords_periodically': False,
                    }), 10)
        self.add_passwords(self.db.users.insert({
                    'first_name': 'John2',
                    'last_name': 'Doe',
                    'email': 'john2@example.com',
                    'email_verified': True,
                    'send_passwords_periodically': False,
                    }), 10)
        self.add_passwords(self.db.users.insert({
                    'first_name': 'John3',
                    'last_name': 'Doe',
                    'email': 'john3@example.com',
                    'email_verified': True,
                    'send_passwords_periodically': True,
                    }), 10)
        self.add_passwords(self.db.users.insert({
                    'first_name': 'John4',
                    'last_name': 'Doe',
                    'email': 'john4@example.com',
                    'email_verified': True,
                    'send_passwords_periodically': True,
                    }), 10)

        sys.argv = ['notused', self.conf_file_path, 'john3@example.com']
        sys.stdout = StringIO()
        result = send_backups_via_email()
        self.assertEqual(result, None)
        stdout = sys.stdout.getvalue()
        expected_output = """Passwords sent to John3 Doe <john3@example.com>
"""
        self.assertEqual(stdout, expected_output)

    def test_several_users(self):
        date_joined = datetime.datetime(2012, 12, 12, 12, 12)
        # Add some users
        self.add_passwords(self.db.users.insert({
                    'first_name': 'John1',
                    'last_name': 'Doe',
                    'date_joined': date_joined,
                    'email': '',
                    'email_verified': False,
                    'send_passwords_periodically': False,
                    }), 10)

        i = 1
        while True:
            user_id = self.add_passwords(self.db.users.insert({
                        'first_name': 'John%d' % i,
                        'last_name': 'Doe',
                        'date_joined': date_joined,
                        'email': 'john%d@example.com' % i,
                        'email_verified': True,
                        'send_passwords_periodically': True,
                        }), 10)
            day = get_day_to_send({'_id': user_id}, 28)
            if day == 10:
                break

            i += 1

        sys.argv = ['notused', self.conf_file_path]
        sys.stdout = StringIO()
        result = send_backups_via_email()
        self.assertEqual(result, None)
        stdout = sys.stdout.getvalue()
        expected_output = """Passwords sent to John%d Doe <john%d@example.com>
""" % (i, i)
        self.assertEqual(stdout, expected_output)

########NEW FILE########
__FILENAME__ = test_migrations
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import sys

from yithlibraryserver.compat import StringIO
from yithlibraryserver.scripts.migrations import migrate
from yithlibraryserver.scripts.testing import ScriptTests


class MigrationsTests(ScriptTests):

    clean_collections = ('users', 'passwords', 'applications')

    def test_migrate_add_send_email_preference(self):
        # Save sys values
        old_args = sys.argv[:]
        old_stdout = sys.stdout

        # Replace sys argv and stdout
        sys.argv = []
        sys.stdout = StringIO()

        # Call migrate with no arguments
        result = migrate()
        self.assertEqual(result, 2)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, 'You must provide two arguments. The first one is the config file and the second one is the migration name.\n')

        # Call migrate with a config file but no migration name
        sys.argv = ['notused', self.conf_file_path]
        sys.stdout = StringIO()
        result = migrate()
        self.assertEqual(result, 2)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, 'You must provide two arguments. The first one is the config file and the second one is the migration name.\n')

        # Call migrate with a config file and wrong migration name
        sys.argv = ['notused', self.conf_file_path, 'bad_migration']
        sys.stdout = StringIO()
        result = migrate()
        self.assertEqual(result, 3)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, 'The migration "bad_migration" does not exist.\n')

        # Good call
        sys.argv = ['notused', self.conf_file_path, 'add_send_email_preference']
        sys.stdout = StringIO()
        result = migrate()
        self.assertEqual(result, None)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, '')

        # Add some users
        u1_id = self.db.users.insert({
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                })
        self.db.users.insert({
                'first_name': 'John2',
                'last_name': 'Doe2',
                'email': 'john2@example.com',
                'send_passwords_periodically': False,
                })
        sys.argv = ['notused', self.conf_file_path, 'add_send_email_preference']
        sys.stdout = StringIO()
        result = migrate()
        self.assertEqual(result, None)
        stdout = sys.stdout.getvalue()
        expected_output = """Adding attribute "send_passwords_periodically" to John Doe <john@example.com>
"""
        self.assertEqual(stdout, expected_output)

        user1 = self.db.users.find_one({'_id': u1_id})
        self.assertEqual(user1['send_passwords_periodically'], True)

        # Restore sys.values
        sys.argv = old_args
        sys.stdout = old_stdout

########NEW FILE########
__FILENAME__ = test_reports
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.
import datetime
import sys

from yithlibraryserver.compat import StringIO
from yithlibraryserver.scripts.reports import users, applications, statistics
from yithlibraryserver.scripts.testing import ScriptTests


class ReportTests(ScriptTests):

    clean_collections = ('users', 'passwords', 'applications')

    def test_users(self):
        # Save sys values
        old_args = sys.argv[:]
        old_stdout = sys.stdout

        # Replace sys argv and stdout
        sys.argv = []
        sys.stdout = StringIO()

        # Call users with no arguments
        result = users()
        self.assertEqual(result, 2)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, 'You must provide at least one argument\n')

        # Call users with a config file but an empty database
        sys.argv = ['notused', self.conf_file_path]
        sys.stdout = StringIO()
        result = users()
        self.assertEqual(result, None)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, '')

        # Add some data to the database
        u1_id = self.db.users.insert({
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                })
        u2_id = self.db.users.insert({
                'first_name': 'John2',
                'last_name': 'Doe2',
                'email': 'john2@example.com',
                'email_verified': True,
                'twitter_id': '1234',
                })
        self.db.passwords.insert({
                'service': 'service1',
                'secret': 's3cr3t',
                'owner': u2_id,
                })
        u3_id = self.db.users.insert({
                'first_name': 'John3',
                'last_name': 'Doe3',
                'email': 'john3@example.com',
                'email_verified': True,
                'twitter_id': '1234',
                'facebook_id': '5678',
                'google_id': 'abcd',
                'date_joined': datetime.datetime(2012, 12, 12, 12, 12, 12),
                'last_login': datetime.datetime(2012, 12, 12, 12, 12, 12),
                })
        self.db.passwords.insert({
                'service': 'service1',
                'secret': 's3cr3t',
                'owner': u3_id,
                })
        self.db.passwords.insert({
                'service': 'service2',
                'secret': 's3cr3t',
                'owner': u3_id,
                })
        sys.argv = ['notused', self.conf_file_path]
        sys.stdout = StringIO()
        result = users()
        self.assertEqual(result, None)
        stdout = sys.stdout.getvalue()
        expected_output = """John Doe <john@example.com> (%s)
	Passwords: 0
	Providers: 
	Verified: False
	Date joined: Unknown
	Last login: Unknown

John2 Doe2 <john2@example.com> (%s)
	Passwords: 1
	Providers: twitter
	Verified: True
	Date joined: Unknown
	Last login: Unknown

John3 Doe3 <john3@example.com> (%s)
	Passwords: 2
	Providers: facebook, google, twitter
	Verified: True
	Date joined: 2012-12-12 12:12:12+00:00
	Last login: 2012-12-12 12:12:12+00:00

""" % (u1_id, u2_id, u3_id)
        self.assertEqual(stdout, expected_output)

        # Restore sys.values
        sys.argv = old_args
        sys.stdout = old_stdout

    def test_applications(self):
        # Save sys values
        old_args = sys.argv[:]
        old_stdout = sys.stdout

        # Replace sys argv and stdout
        sys.argv = []
        sys.stdout = StringIO()

        # Call applications with no arguments
        result = applications()
        self.assertEqual(result, 2)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, 'You must provide at least one argument\n')

        # Call applications with a config file but an empty database
        sys.argv = ['notused', self.conf_file_path]
        sys.stdout = StringIO()
        result = applications()
        self.assertEqual(result, None)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, '')

        # Add some data to the database
        u1_id = self.db.users.insert({
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                })
        self.db.applications.insert({
                'name': 'Test application 1',
                'owner': u1_id,
                'main_url': 'http://example.com/',
                'callback_url': 'http://example.com/callback',
                })
        self.db.applications.insert({
                'name': 'Test application 2',
                'owner': '000000000000000000000000',
                'main_url': 'http://2.example.com/',
                'callback_url': 'http://2.example.com/callback',
                })
        sys.argv = ['notused', self.conf_file_path]
        sys.stdout = StringIO()
        result = applications()
        self.assertEqual(result, None)
        stdout = sys.stdout.getvalue()
        expected_output = """Test application 1
	Owner: John Doe <john@example.com>
	Main URL: http://example.com/
	Callback URL: http://example.com/callback
	Users: 0

Test application 2
	Owner: Unknown owner (000000000000000000000000)
	Main URL: http://2.example.com/
	Callback URL: http://2.example.com/callback
	Users: 0

"""
        self.assertEqual(stdout, expected_output)

        # Restore sys.values
        sys.argv = old_args
        sys.stdout = old_stdout

    def test_statistics(self):
        # Save sys values
        old_args = sys.argv[:]
        old_stdout = sys.stdout

        # Replace sys argv and stdout
        sys.argv = []
        sys.stdout = StringIO()

        # Call statistics with no arguments
        result = statistics()
        self.assertEqual(result, 2)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, 'You must provide at least one argument\n')

        # Call statistics with a config file but an empty database
        sys.argv = ['notused', self.conf_file_path]
        sys.stdout = StringIO()
        result = statistics()
        self.assertEqual(result, None)
        stdout = sys.stdout.getvalue()
        self.assertEqual(stdout, '')

        # Add some data to the database
        u1_id = self.db.users.insert({
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'email_verified': True,
                'allow_google_analytics': True,
                'google_id': '1',
                })
        self.add_passwords(u1_id, 10)

        u2_id = self.db.users.insert({
                'first_name': 'Peter',
                'last_name': 'Doe',
                'email': 'peter@example.com',
                'email_verified': True,
                'allow_google_analytics': False,
                'twitter_id': '1',
                })
        self.add_passwords(u2_id, 20)

        u3_id = self.db.users.insert({
                'first_name': 'Susan',
                'last_name': 'Doe',
                'email': 'susan@example2.com',
                'email_verified': True,
                'allow_google_analytics': False,
                'facebook_id': '1',
                })
        self.add_passwords(u3_id, 15)

        self.db.users.insert({
                'first_name': 'Alice',
                'last_name': 'Doe',
                'email': '',
                'email_verified': False,
                'allow_google_analytics': False,
                'persona_id': '1',
                })

        self.db.users.insert({
                'first_name': 'Bob',
                'last_name': 'Doe',
                'email': '',
                'email_verified': False,
                'allow_google_analytics': False,
                'google_id': '2',
                })
        self.db.users.insert({
                'first_name': 'Kevin',
                'last_name': 'Doe',
                'email': '',
                'email_verified': False,
                'allow_google_analytics': False,
                'google_id': '3',
                })
        self.db.users.insert({
                'first_name': 'Maria',
                'last_name': 'Doe',
                'email': '',
                'email_verified': False,
                'allow_google_analytics': False,
                'google_id': '4',
                })
        self.db.users.insert({
                'first_name': 'Bran',
                'last_name': 'Doe',
                'email': '',
                'email_verified': False,
                'allow_google_analytics': False,
                'twitter_id': '2',
                })
        self.db.users.insert({
                'first_name': 'George',
                'last_name': 'Doe',
                'email': '',
                'email_verified': False,
                'allow_google_analytics': False,
                'twitter_id': '3',
                })
        self.db.users.insert({
                'first_name': 'Travis',
                'last_name': 'Doe',
                'email': '',
                'email_verified': False,
                'allow_google_analytics': False,
                'persona_id': '2',
                })

        sys.argv = ['notused', self.conf_file_path]
        sys.stdout = StringIO()
        result = statistics()
        self.assertEqual(result, None)
        stdout = sys.stdout.getvalue()

        expected_output = """Number of users: 10
Number of passwords: 45
Verified users: 30.00% (3)
Users that allow Google Analytics cookie: 10.00% (1)
Identity providers:
	google: 40.00% (4)
	twitter: 30.00% (3)
	persona: 20.00% (2)
	facebook: 10.00% (1)
Email providers:
	example.com: 66.67% (2)
	Others: 33.33% (1)
Users without email: 70.00% (7)
Most active users:
	Peter Doe <peter@example.com>: 20
	Susan Doe <susan@example2.com>: 15
	John Doe <john@example.com>: 10
Users without passwords: 70.00% (7)
"""
        self.assertEqual(stdout, expected_output)

        # Restore sys.values
        sys.argv = old_args
        sys.stdout = old_stdout

########NEW FILE########
__FILENAME__ = utils
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import optparse
import textwrap
import sys

from pyramid.paster import bootstrap

from yithlibraryserver.compat import PY3


def safe_print(value):
    if PY3:  # pragma: no cover
        print(value)
    else:  # pragma: no cover
        print(value.encode('utf-8'))


def setup_simple_command(name, description):
    usage = name + ": %prog config_uri"
    parser = optparse.OptionParser(
        usage=usage,
        description=textwrap.dedent(description)
        )
    options, args = parser.parse_args(sys.argv[1:])
    if not len(args) >= 1:
        safe_print('You must provide at least one argument')
        return 2
    config_uri = args[0]
    env = bootstrap(config_uri)
    settings, closer = env['registry'].settings, env['closer']

    return settings, closer, env, args[1:]


def get_user_display_name(user):
    return '%s %s <%s>' % (user.get('first_name', ''),
                           user.get('last_name', ''),
                           user.get('email', ''))

########NEW FILE########
__FILENAME__ = security
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid.httpexceptions import HTTPBadRequest, HTTPUnauthorized
from pyramid.security import Allow, Authenticated


from yithlibraryserver.oauth2.authorization import AccessCodes


class RootFactory(object):

    __acl__ = (
        (Allow, Authenticated, 'user-registration'),
        (Allow, Authenticated, 'view-applications'),
        (Allow, Authenticated, 'edit-application'),
        (Allow, Authenticated, 'add-application'),
        (Allow, Authenticated, 'delete-application'),
        (Allow, Authenticated, 'add-authorized-app'),
        (Allow, Authenticated, 'revoke-authorized-app'),
        (Allow, Authenticated, 'edit-profile'),
        (Allow, Authenticated, 'destroy-account'),
        (Allow, Authenticated, 'backups'),
        )

    def __init__(self, request):
        self.request = request


def authorize_user(request):
    authorization = request.headers.get('Authorization')
    if authorization is None:
        raise HTTPUnauthorized()

    method, credentials = request.authorization
    if method.lower() != 'bearer':
        raise HTTPBadRequest('Authorization method not supported')

    access_code = AccessCodes(request.db).find(credentials)
    if access_code is None:
        raise HTTPUnauthorized()

    user_id = access_code['user']
    user = request.db.users.find_one(user_id)
    if user is None:
        raise HTTPUnauthorized()

    return user

########NEW FILE########
__FILENAME__ = sna_callbacks
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from yithlibraryserver.user.utils import register_or_update


def facebook_callback(request, user_id, info):
    return register_or_update(request, 'facebook', user_id, info,
                              request.route_path('home'))


def google_callback(request, user_id, new_info):
    return register_or_update(request, 'google', user_id, new_info,
                              request.route_path('home'))

########NEW FILE########
__FILENAME__ = subscribers
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid.events import BeforeRender, NewRequest
from pyramid.i18n import get_locale_name
from pyramid.renderers import get_renderer

from yithlibraryserver.db import get_db
from yithlibraryserver.locale import DatesFormatter


def add_cors_headers_response(event):
    cors_manager = event.request.registry.settings['cors_manager']

    def cors_headers_callback(request, response):
        return cors_manager.add_cors_header(request, response)

    event.request.add_response_callback(cors_headers_callback)


def add_compress_response_callback(event):

    def gzip_response(request, response):
        response.encode_content('gzip')
        return response

    accepted = event.request.accept_encoding.best_match(('identity', 'gzip'))
    if 'gzip' == accepted:
        event.request.add_response_callback(gzip_response)


def add_base_templates(event):

    def get_template(name):
        renderer = get_renderer('yithlibraryserver:templates/%s.pt' % name)
        return renderer.implementation()

    event.update({
            'base': get_template('base'),
            'profile': get_template('profile'),
            })


def add_custom_functions(event):

    locale_name = get_locale_name(event['request'])

    event.update({
            'dates_formatter': DatesFormatter(locale_name),
            })


def includeme(config):
    config.set_request_property(get_db, 'db', reify=True)

    config.add_subscriber(add_cors_headers_response, NewRequest)
    config.add_subscriber(add_compress_response_callback, NewRequest)
    config.add_subscriber(add_base_templates, BeforeRender)
    config.add_subscriber(add_custom_functions, BeforeRender)

########NEW FILE########
__FILENAME__ = testing
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from webtest import TestApp, TestRequest

from pyramid.interfaces import ISessionFactory
from pyramid.security import remember
from pyramid.testing import DummyRequest

from yithlibraryserver import main

MONGO_URI = 'mongodb://localhost:27017/test-yith-library'


class FakeRequest(DummyRequest):

    def __init__(self, *args, **kwargs):
        super(FakeRequest, self).__init__(*args, **kwargs)
        self.authorization = self.headers.get('Authorization', '').split(' ')
        if 'db' in kwargs:
            self.db = kwargs['db']


class TestCase(unittest.TestCase):

    clean_collections = tuple()

    def setUp(self):
        settings = {
            'mongo_uri': MONGO_URI,
            'auth_tk_secret': '123456',
            'twitter_consumer_key': 'key',
            'twitter_consumer_secret': 'secret',
            'facebook_app_id': 'id',
            'facebook_app_secret': 'secret',
            'google_client_id': 'id',
            'google_client_secret': 'secret',
            'paypal_user': 'sdk-three_api1.sdk.com',
            'paypal_password': 'QFZCWN5HZM8VBG7Q',
            'paypal_signature': 'A-IzJhZZjhg29XQ2qnhapuwxIDzyAZQ92FRP5dqBzVesOkzbdUONzmOU',
            'testing': 'True',
            'pyramid_mailer.prefix': 'mail_',
            'mail_default_sender': 'no-reply@yithlibrary.com',
            'admin_emails': 'admin1@example.com admin2@example.com',
            'public_url_root': 'http://localhost:6543/',
            }
        app = main({}, **settings)
        self.testapp = TestApp(app)
        self.db = app.registry.settings['db_conn']['test-yith-library']

    def tearDown(self):
        for col in self.clean_collections:
            self.db.drop_collection(col)

        self.testapp.reset()

    def set_user_cookie(self, user_id):
        request = TestRequest.blank('', {})
        request.registry = self.testapp.app.registry
        remember_headers = remember(request, user_id)
        cookie_value = remember_headers[0][1].split('"')[1]
        self.testapp.cookies['auth_tkt'] = cookie_value

    def add_to_session(self, data):
        queryUtility = self.testapp.app.registry.queryUtility
        session_factory = queryUtility(ISessionFactory)
        request = DummyRequest()
        session = session_factory(request)
        for key, value in data.items():
            session[key] = value
        session.persist()
        self.testapp.cookies['beaker.session.id'] = session._sess.id

    def get_session(self, response):
        queryUtility = self.testapp.app.registry.queryUtility
        session_factory = queryUtility(ISessionFactory)
        request = response.request

        if not hasattr(request, 'add_response_callback'):
            request.add_response_callback = lambda r: r

        if 'Set-Cookie' in response.headers:
            request.environ['HTTP_COOKIE'] = response.headers['Set-Cookie']

        return session_factory(request)

########NEW FILE########
__FILENAME__ = test_compression
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from yithlibraryserver import testing


class ContentEncodingTests(testing.TestCase):

    def test_identity_compression(self):
        res = self.testapp.get('/')  # Identity encoding is the default one
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.content_encoding, None)

        res = self.testapp.get('/', headers={'Accept-Encoding': 'identity'})
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.content_encoding, None)

    def test_gzip_compression(self):
        res = self.testapp.get('/', headers={'Accept-Encoding': 'gzip'})
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.content_encoding, 'gzip')

########NEW FILE########
__FILENAME__ = test_config
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import os
import unittest

from pyramid.exceptions import ConfigurationError

from yithlibraryserver import main
from yithlibraryserver.config import read_setting_from_env


class ConfigTests(unittest.TestCase):

    def test_read_setting_from_env(self):
        settings = {
            'foo_bar': '1',
            }

        self.assertEqual('1', read_setting_from_env(settings, 'foo_bar'))

        self.assertEqual('default',
                         read_setting_from_env(settings, 'new_option', 'default'))
        self.assertEqual(None,
                         read_setting_from_env(settings, 'new_option'))

        os.environ['FOO_BAR'] = '2'
        self.assertEqual('2', read_setting_from_env(settings, 'foo_bar'))

    def test_required_settings(self):
        settings = {}
        self.assertRaises(ConfigurationError, main, {}, **settings)

        settings = {
            'auth_tk_secret': '1234',
            }
        self.assertRaises(ConfigurationError, main, {}, **settings)

        settings = {
            'auth_tk_secret': '1234',
            'mongo_uri': 'mongodb://localhost:27017/test',
            }
        app = main({}, **settings)
        self.assertEqual(settings['auth_tk_secret'],
                         app.registry.settings['auth_tk_secret'])
        self.assertEqual(settings['mongo_uri'],
                         app.registry.settings['mongo_uri'])

########NEW FILE########
__FILENAME__ = test_cors
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid.testing import DummyRequest

from yithlibraryserver import testing
from yithlibraryserver.cors import CORSManager


class CORSManagerTests(testing.TestCase):

    clean_collections = ('applications', )

    def test_cors_headers_global_origins_access_denied(self):
        cm = CORSManager('')

        request = DummyRequest(headers={'Origin': 'foo'})
        response = request.response

        cm.add_cors_header(request, response)

        self.assertEqual(response.headers, {
                'Content-Type': 'text/html; charset=UTF-8',
                'Content-Length': '0',
                })

    def test_cors_headers_global_origins(self):
        cm = CORSManager('http://localhost')

        request = DummyRequest(headers={'Origin': 'http://localhost'})
        response = request.response

        cm.add_cors_header(request, response)

        self.assertEqual(response.headers, {
                'Content-Type': 'text/html; charset=UTF-8',
                'Content-Length': '0',
                'Access-Control-Allow-Origin': 'http://localhost',
                })

    def test_cors_headers_app_origins_access_denied(self):
        cm = CORSManager('')

        self.db.applications.insert({
                'name': 'test-app',
                'client_id': 'client1',
                'authorized_origins': ['http://localhost'],
                }, safe=True)

        request = DummyRequest(headers={'Origin': 'http://localhost'},
                               params={'client_id': 'client2'})
        request.db = self.db
        response = request.response

        cm.add_cors_header(request, response)

        self.assertEqual(response.headers, {
                'Content-Type': 'text/html; charset=UTF-8',
                'Content-Length': '0',
                })

    def test_cors_headers_app_origins(self):
        cm = CORSManager('')

        self.db.applications.insert({
                'name': 'test-app',
                'client_id': 'client1',
                'authorized_origins': ['http://localhost'],
                }, safe=True)

        request = DummyRequest(headers={'Origin': 'http://localhost'},
                               params={'client_id': 'client1'})
        request.db = self.db
        response = request.response

        cm.add_cors_header(request, response)

        self.assertEqual(response.headers, {
                'Content-Type': 'text/html; charset=UTF-8',
                'Content-Length': '0',
                'Access-Control-Allow-Origin': 'http://localhost',
                })

########NEW FILE########
__FILENAME__ = test_db
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from yithlibraryserver import db


class FakeDatabase(object):

    def __init__(self, name):
        self.name = name
        self.is_authenticated = False

    def authenticate(self, user, password):
        self.is_authenticated = True


class FakeConnection(object):

    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs

    def __getitem__(self, key):
        return FakeDatabase(key)


class MongoDBTests(unittest.TestCase):

    def test_uri(self):
        mdb = db.MongoDB(connection_factory=FakeConnection)

        self.assertEqual(mdb.db_uri.geturl(), db.DEFAULT_MONGODB_URI)
        self.assertEqual(mdb.database_name, db.DEFAULT_MONGODB_NAME)
        database = mdb.get_database()
        self.assertTrue(isinstance(database, FakeDatabase))
        self.assertEqual(database.name, mdb.database_name)
        self.assertFalse(database.is_authenticated)

        # full specified uri
        uri = 'mongodb://db.example.com:1111/testdb'
        mdb = db.MongoDB(uri, connection_factory=FakeConnection)
        conn = mdb.get_connection()
        database = mdb.get_database()
        self.assertEqual(mdb.db_uri.geturl(), uri)
        self.assertEqual(mdb.db_uri.hostname, 'db.example.com')
        self.assertEqual(conn.kwargs['host'], 'db.example.com')
        self.assertEqual(mdb.db_uri.port, 1111)
        self.assertEqual(conn.kwargs['port'], 1111)
        self.assertEqual(mdb.database_name, 'testdb')
        self.assertFalse(database.is_authenticated)

        # uri without path component
        uri = 'mongodb://db.example.com:1111'
        mdb = db.MongoDB(uri, connection_factory=FakeConnection)
        conn = mdb.get_connection()
        database = mdb.get_database()
        self.assertEqual(mdb.db_uri.geturl(), uri)
        self.assertEqual(mdb.db_uri.hostname, 'db.example.com')
        self.assertEqual(conn.kwargs['host'], 'db.example.com')
        self.assertEqual(mdb.db_uri.port, 1111)
        self.assertEqual(conn.kwargs['port'], 1111)
        self.assertEqual(mdb.database_name, db.DEFAULT_MONGODB_NAME)
        self.assertFalse(database.is_authenticated)

        # uri without port
        uri = 'mongodb://db.example.com'
        mdb = db.MongoDB(uri, connection_factory=FakeConnection)
        conn = mdb.get_connection()
        self.assertEqual(mdb.db_uri.geturl(), uri)
        self.assertEqual(mdb.db_uri.hostname, 'db.example.com')
        self.assertEqual(conn.kwargs['host'], 'db.example.com')
        self.assertEqual(mdb.db_uri.port, None)
        self.assertEqual(conn.kwargs['port'], db.DEFAULT_MONGODB_PORT)
        self.assertEqual(mdb.database_name, db.DEFAULT_MONGODB_NAME)
        self.assertFalse(database.is_authenticated)

        # uri without anything
        uri = 'mongodb://'
        mdb = db.MongoDB(uri, connection_factory=FakeConnection)
        conn = mdb.get_connection()
        database = mdb.get_database()
        self.assertEqual(mdb.db_uri.geturl(), 'mongodb:')
        self.assertEqual(mdb.db_uri.hostname, None)
        self.assertEqual(conn.kwargs['host'], db.DEFAULT_MONGODB_HOST)
        self.assertEqual(mdb.db_uri.port, None)
        self.assertEqual(conn.kwargs['port'], db.DEFAULT_MONGODB_PORT)
        self.assertEqual(mdb.database_name, db.DEFAULT_MONGODB_NAME)
        self.assertFalse(database.is_authenticated)

        # uri with username and password
        uri = 'mongodb://john:secret@db.example.com:1111/testdb'
        mdb = db.MongoDB(uri, connection_factory=FakeConnection)
        conn = mdb.get_connection()
        database = mdb.get_database()
        self.assertEqual(mdb.db_uri.geturl(), uri)
        self.assertEqual(mdb.db_uri.hostname, 'db.example.com')
        self.assertEqual(conn.kwargs['host'], 'db.example.com')
        self.assertEqual(mdb.db_uri.port, 1111)
        self.assertEqual(conn.kwargs['port'], 1111)
        self.assertEqual(mdb.database_name, 'testdb')
        self.assertTrue(database.is_authenticated)

########NEW FILE########
__FILENAME__ = test_email
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from pyramid import testing

from pyramid_mailer import get_mailer
from pyramid_mailer.message import Attachment

from yithlibraryserver.email import create_message, send_email
from yithlibraryserver.email import send_email_to_admins
from yithlibraryserver.testing import TestCase


class CreateMessageTests(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp()

    def test_create_message(self):
        request = testing.DummyRequest()
        message = create_message(
            request,
            'yithlibraryserver.tests:templates/email_test',
            {'name': 'John', 'email': 'john@example.com'},
            'Testing message', ['john@example.com'],
        )
        self.assertEqual(message.subject, 'Testing message')
        self.assertEqual(message.html, '<p>Hello John,</p>\n\n<p>this is your email address: john@example.com</p>')
        self.assertEqual(message.body, 'Hello John,\n\nthis is your email address: john@example.com\n')
        self.assertEqual(message.recipients, ['john@example.com'])
        self.assertEqual(message.attachments, [])
        self.assertEqual(message.extra_headers, {})

    def test_create_message_with_attachments(self):
        request = testing.DummyRequest()

        attachment = Attachment('foo.txt', 'text/plain', 'test')

        message = create_message(
            request,
            'yithlibraryserver.tests:templates/email_test',
            {'name': 'John', 'email': 'john@example.com'},
            'Testing message', ['john@example.com'],
            attachments=[attachment],
        )
        self.assertEqual(message.subject, 'Testing message')
        self.assertEqual(message.html, '<p>Hello John,</p>\n\n<p>this is your email address: john@example.com</p>')
        self.assertEqual(message.body, 'Hello John,\n\nthis is your email address: john@example.com\n')
        self.assertEqual(message.recipients, ['john@example.com'])
        self.assertEqual(message.extra_headers, {})
        self.assertEqual(len(message.attachments), 1)
        a = message.attachments[0]
        self.assertEqual(a.filename, 'foo.txt')
        self.assertEqual(a.content_type, 'text/plain')
        self.assertEqual(a.data, 'test')

    def test_create_message_with_extra_headers(self):
        request = testing.DummyRequest()

        message = create_message(
            request,
            'yithlibraryserver.tests:templates/email_test',
            {'name': 'John', 'email': 'john@example.com'},
            'Testing message', ['john@example.com'],
            extra_headers={'foo': 'bar'},
        )
        self.assertEqual(message.subject, 'Testing message')
        self.assertEqual(message.html, '<p>Hello John,</p>\n\n<p>this is your email address: john@example.com</p>')
        self.assertEqual(message.body, 'Hello John,\n\nthis is your email address: john@example.com\n')
        self.assertEqual(message.recipients, ['john@example.com'])
        self.assertEqual(message.attachments, [])
        self.assertEqual(message.extra_headers, {'foo': 'bar'})


class SendEmailTests(TestCase):

    def setUp(self):
        self.admin_emails = ['admin1@example.com', 'admin2@example.com']
        self.config = testing.setUp(settings={
                'admin_emails': self.admin_emails,
                })
        self.config.include('pyramid_mailer.testing')
        self.config.include('yithlibraryserver')
        super(SendEmailTests, self).setUp()

    def test_send_email(self):
        request = testing.DummyRequest()
        mailer = get_mailer(request)

        send_email(
            request,
            'yithlibraryserver.tests:templates/email_test',
            {'name': 'John', 'email': 'john@example.com'},
            'Testing message', ['john@example.com'],
        )

        self.assertEqual(len(mailer.outbox), 1)
        message = mailer.outbox[0]
        self.assertEqual(message.subject, 'Testing message')
        self.assertEqual(message.html, '<p>Hello John,</p>\n\n<p>this is your email address: john@example.com</p>')
        self.assertEqual(message.body, 'Hello John,\n\nthis is your email address: john@example.com\n')
        self.assertEqual(message.recipients, ['john@example.com'])
        self.assertEqual(message.attachments, [])
        self.assertEqual(message.extra_headers, {})

    def test_send_email_to_admins(self):
        request = testing.DummyRequest()
        mailer = get_mailer(request)

        send_email_to_admins(
            request,
            'yithlibraryserver.tests:templates/email_test',
            {'name': 'John', 'email': 'john@example.com'},
            'Testing message',
        )

        self.assertEqual(len(mailer.outbox), 1)
        message = mailer.outbox[0]
        self.assertEqual(message.subject, 'Testing message')
        self.assertEqual(message.html, '<p>Hello John,</p>\n\n<p>this is your email address: john@example.com</p>')
        self.assertEqual(message.body, 'Hello John,\n\nthis is your email address: john@example.com\n')
        self.assertEqual(message.recipients, self.admin_emails)
        self.assertEqual(message.attachments, [])
        self.assertEqual(message.extra_headers, {})


class SendEmailNoAdminsTests(TestCase):

    def setUp(self):
        self.config = testing.setUp(settings={
                'admin_emails': [],
                })
        self.config.include('pyramid_mailer.testing')
        self.config.include('yithlibraryserver')
        super(SendEmailNoAdminsTests, self).setUp()

    def test_send_email_to_admins(self):
        request = testing.DummyRequest()
        mailer = get_mailer(request)

        send_email_to_admins(
            request,
            'yithlibraryserver.tests:templates/email_test',
            {'name': 'John', 'email': 'john@example.com'},
            'Testing message',
        )

        # no email is actually send since there is no admin
        # emails configured
        self.assertEqual(len(mailer.outbox), 0)

########NEW FILE########
__FILENAME__ = test_errors
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from pyramid.httpexceptions import HTTPBadRequest, HTTPNotFound


from yithlibraryserver.errors import password_not_found, invalid_password_id


class ErrorsTests(unittest.TestCase):

    def test_password_not_found(self):
        result = password_not_found()
        self.assertTrue(isinstance(result, HTTPNotFound))
        self.assertTrue(result.content_type, 'application/json')
        self.assertTrue(result.body, '{"message": "Password not found"}')

        # try a different message
        result = password_not_found('test')
        self.assertTrue(result.body, '{"message": "test"}')


    def test_invalid_password_id(self):
        result = invalid_password_id()
        self.assertTrue(isinstance(result, HTTPBadRequest))
        self.assertTrue(result.content_type, 'application/json')
        self.assertTrue(result.body, '{"message": "Invalid password id"}')

        # try a different message
        result = invalid_password_id('test')
        self.assertTrue(result.body, '{"message": "test"}')

########NEW FILE########
__FILENAME__ = test_i18n
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest
from webtest import TestRequest

from pyramid import testing

from yithlibraryserver.i18n import deform_translator, locale_negotiator
from yithlibraryserver.testing import TestCase


class DeformTranslatorTests(unittest.TestCase):

    def setUp(self):
        request = testing.DummyRequest()
        testing.setUp(request=request)

    def tearDown(self):
        testing.tearDown()

    def test_deform_translator(self):
        self.assertEqual('foo', deform_translator('foo'))


class LocaleNegotiatorTests(TestCase):

    def test_locale_negotiator(self):
        request = TestRequest.blank('', {}, headers={})
        request.registry = self.testapp.app.registry
        self.assertEqual(locale_negotiator(request), 'en')

        request = TestRequest.blank('', {}, headers={
                'Accept-Language': 'es',
                })
        request.registry = self.testapp.app.registry
        self.assertEqual(locale_negotiator(request), 'es')

        request = TestRequest.blank('', {}, headers={
                'Accept-Language': 'de',  # german is not supported
                })
        request.registry = self.testapp.app.registry
        self.assertEqual(locale_negotiator(request), None)

        request = TestRequest.blank('', {}, headers={
                'Accept-Language': 'de, es',
                })
        request.registry = self.testapp.app.registry
        self.assertEqual(locale_negotiator(request), 'es')

########NEW FILE########
__FILENAME__ = test_locale
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import unittest

from yithlibraryserver import locale


class DatesFormatterTests(unittest.TestCase):

    def test_date(self):
        df_en = locale.DatesFormatter('en')
        df_es = locale.DatesFormatter('es')

        date = datetime.date(2012, 12, 12)

        if locale.HAS_BABEL:
            self.assertEqual(df_en.date(date), 'Dec 12, 2012')
            self.assertEqual(df_es.date(date), '12/12/2012')

        locale_changed = False
        if locale.HAS_BABEL:
            locale.HAS_BABEL = False
            locale_changed = True

        self.assertEqual(df_en.date(date), 'Wed Dec 12 00:00:00 2012')
        self.assertEqual(df_es.date(date), 'Wed Dec 12 00:00:00 2012')

        if locale_changed:
            locale.HAS_BABEL = not locale.HAS_BABEL

    def test_datetime(self):
        df_en = locale.DatesFormatter('en')
        df_es = locale.DatesFormatter('es')

        date = datetime.datetime(2012, 12, 12, 12, 12, 12)

        if locale.HAS_BABEL:
            self.assertEqual(df_en.datetime(date), 'Dec 12, 2012 12:12:12 PM')
            self.assertEqual(df_es.datetime(date), '12/12/2012 12:12:12')

        locale_changed = False
        if locale.HAS_BABEL:
            locale.HAS_BABEL = False
            locale_changed = True

        self.assertEqual(df_en.datetime(date), 'Wed Dec 12 12:12:12 2012')
        self.assertEqual(df_es.datetime(date), 'Wed Dec 12 12:12:12 2012')

        if locale_changed:
            locale.HAS_BABEL = not locale.HAS_BABEL

########NEW FILE########
__FILENAME__ = test_security
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid.httpexceptions import HTTPBadRequest, HTTPUnauthorized

from yithlibraryserver import testing
from yithlibraryserver.security import authorize_user


class AuthorizationTests(testing.TestCase):

    clean_collections = ('access_codes', 'users')

    def test_authorize_user(self):

        request = testing.FakeRequest(headers={})

        # The authorization header is required
        self.assertRaises(HTTPUnauthorized, authorize_user, request)

        request = testing.FakeRequest(
            headers={'Authorization': 'Basic foobar'})
        # Only the bearer method is allowed
        self.assertRaises(HTTPBadRequest, authorize_user, request)

        request = testing.FakeRequest(headers={
                'Authorization': 'Bearer 1234',
                }, db=self.db)
        # Invalid code
        self.assertRaises(HTTPUnauthorized, authorize_user, request)

        access_code_id = self.db.access_codes.insert({
                'code': '1234',
                'user': 'user1',
                }, safe=True)
        request = testing.FakeRequest(headers={
                'Authorization': 'Bearer 1234',
                }, db=self.db)
        # Invalid user
        self.assertRaises(HTTPUnauthorized, authorize_user, request)

        user_id = self.db.users.insert({
                'username': 'user1',
                }, safe=True)
        self.db.access_codes.update({'_id': access_code_id}, {
                '$set': {'user': user_id},
                }, safe=True)
        request = testing.FakeRequest(headers={
                'Authorization': 'Bearer 1234',
                }, db=self.db)
        # Invalid user
        authorized_user = authorize_user(request)
        self.assertEqual(authorized_user['username'], 'user1')

########NEW FILE########
__FILENAME__ = test_sna_callbacks
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from pyramid import testing

from yithlibraryserver.db import MongoDB
from yithlibraryserver.sna_callbacks import facebook_callback, google_callback
from yithlibraryserver.testing import MONGO_URI


class SNACallbackTests(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp()
        self.config.include('yithlibraryserver')
        self.config.include('yithlibraryserver.user')
        self.request = testing.DummyRequest()
        self.request.session = {}
        mdb = MongoDB(MONGO_URI)
        self.request.db = mdb.get_database()

    def tearDown(self):
        testing.tearDown()

    def test_facebook_callback(self):
        result = facebook_callback(self.request, '123', {
            'screen_name': 'John Doe',
            'name': 'John Doe',
            'email': 'john@example.com',
            'username': 'john.doe',
            'first_name': 'John',
            'last_name': 'Doe',
        })
        self.assertEqual(result.status, '302 Found')
        self.assertEqual(result.location, '/register')

    def test_google_callback(self):
        result = google_callback(self.request, '123', {
            'screen_name': 'John Doe',
            'email': 'john@example.com',
            'first_name': 'John',
            'last_name': 'Doe',
        })
        self.assertEqual(result.status, '302 Found')
        self.assertEqual(result.location, '/register')


########NEW FILE########
__FILENAME__ = test_utils
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from yithlibraryserver.utils import remove_attrs

class UtilsTests(unittest.TestCase):

    def test_remove_attrs(self):
        self.assertEqual({}, remove_attrs({}))
        self.assertEqual({'a': 1, 'b': 2}, remove_attrs({'a': 1, 'b': 2}))
        self.assertEqual({'a': 1, 'b': 2}, remove_attrs({'a': 1, 'b': 2}, 'c', 'd'))
        self.assertEqual({'a': 1, 'b': 2}, remove_attrs({'a': 1, 'b': 2, 'c': 3}, 'c', 'd'))

########NEW FILE########
__FILENAME__ = test_views
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid_mailer import get_mailer

from yithlibraryserver import testing


class ViewTests(testing.TestCase):

    def test_home(self):
        res = self.testapp.get('/')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Start using it today', no='Get your passwords')

        # Log in
        user_id = self.db.users.insert({
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'email_verified': True,
                }, safe=True)
        self.set_user_cookie(str(user_id))
        res = self.testapp.get('/')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Get your passwords', no='Start using it today')

    def test_contact(self):
        res = self.testapp.get('/contact')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Name')
        res.mustcontain('Email')
        res.mustcontain('Message')

        # The three fields are required
        res = self.testapp.post('/contact', {
                'submit': 'Send message',
                })
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('class="error" id="error-deformField1">Required')
        res.mustcontain('class="error" id="error-deformField2">Required')
        res.mustcontain('class="error" id="error-deformField3">Required')

        res = self.testapp.post('/contact', {
                'name': 'John',
                'email': 'john@example.com',
                'message': 'Testing message',
                'submit': 'Send message',
                })
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/')
        # check that the email was sent
        res.request.registry = self.testapp.app.registry
        mailer = get_mailer(res.request)
        self.assertEqual(len(mailer.outbox), 1)
        self.assertEqual(mailer.outbox[0].subject,
                         "John sent a message from Yith's contact form")
        self.assertEqual(mailer.outbox[0].recipients,
                         ['admin1@example.com', 'admin2@example.com'])
        self.assertEqual(mailer.outbox[0].extra_headers,
                         {'Reply-To': 'john@example.com'})

        # if the user is authenticated, prefill the name and
        # email fields
        # Log in
        user_id = self.db.users.insert({
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'email_verified': True,
                }, safe=True)
        self.set_user_cookie(str(user_id))

        res = self.testapp.get('/contact')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('John')
        res.mustcontain('john@example.com')

        # simulate a cancel
        res = self.testapp.post('/contact', {
                'cancel': 'Cancel',
                }, status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/')

        # remove the admin emails configuration
        self.testapp.app.registry.settings['admin_emails'] = []

        res = self.testapp.post('/contact', {
                'name': 'John',
                'email': 'john@example.com',
                'message': 'Testing message',
                'submit': 'Send message',
                })
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/')
        # check that the email was *not* sent
        res.request.registry = self.testapp.app.registry
        mailer = get_mailer(res.request)
        self.assertEqual(len(mailer.outbox), 1)

    def test_tos(self):
        res = self.testapp.get('/tos')
        self.assertEqual(res.status, '200 OK')

    def test_faq(self):
        res = self.testapp.get('/faq?_LOCALE_=en')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Frequently Asked Questions')

        res = self.testapp.get('/faq', headers={
                'Accept-Language': 'en',
                })
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Frequently Asked Questions')

        res = self.testapp.get('/faq', headers={
                'Accept-Language': 'es',
                })
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Preguntas Frecuentes')

        res = self.testapp.get('/faq', headers={
                'Accept-Language': 'de',  # German is not supported
                })
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Frequently Asked Questions')

########NEW FILE########
__FILENAME__ = authorization
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import binascii
import hashlib
import hmac
import random
import time

from yithlibraryserver.compat import url_quote


def quote(value):
    return url_quote(value, safe='')


def nonce(length=8):
    return ''.join([str(random.randint(0, 9)) for i in range(length)])


def timestamp():
    return int(time.time())


def sign(method, url, original_params, consumer_secret, oauth_token):
    # 1. create the parameter string
    param_string = '&'.join(['%s=%s' % (key, value)
                             for key, value in sorted(original_params)])

    # 2. create signature base string
    signature_base = '%s&%s&%s' % (
        method.upper(), quote(url), quote(param_string),
        )

    # 3. create the signature key
    key = '%s&%s' % (quote(consumer_secret), quote(oauth_token))

    # 4. calculate the signature
    hashed = hmac.new(key.encode('ascii'),
                      signature_base.encode('ascii'),
                      hashlib.sha1)
    return quote(binascii.b2a_base64(hashed.digest())[:-1])


def auth_header(method, url, original_params, settings, oauth_token='',
                nonce_=None, timestamp_=None):
    params = list(original_params) + [
        ('oauth_consumer_key', settings['twitter_consumer_key']),
        ('oauth_nonce', nonce_ or nonce()),
        ('oauth_signature_method', 'HMAC-SHA1'),
        ('oauth_timestamp', str(timestamp_ or timestamp())),
        ('oauth_version', '1.0'),
        ]
    params = [(quote(key), quote(value)) for key, value in params]

    signature = sign(method, url, params,
                     settings['twitter_consumer_secret'], oauth_token)
    params.append(('oauth_signature', signature))

    header = ", ".join(['%s="%s"' % (key, value) for key, value in params])

    return 'OAuth %s' % header

########NEW FILE########
__FILENAME__ = information
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import requests

from pyramid.httpexceptions import HTTPUnauthorized

from yithlibraryserver.compat import url_encode
from yithlibraryserver.twitter.authorization import auth_header


def get_user_info(settings, user_id, oauth_token):
    user_info_url = settings['twitter_user_info_url']

    params = (
        ('oauth_token', oauth_token),
        )

    auth = auth_header('GET', user_info_url, params, settings, oauth_token)

    response = requests.get(
        user_info_url + '?' + url_encode({'user_id': user_id}),
        headers={'Authorization': auth},
        )

    if response.status_code != 200:
        raise HTTPUnauthorized(response.text)

    return response.json()

########NEW FILE########
__FILENAME__ = test_authorization
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import time
import unittest


from yithlibraryserver.twitter.authorization import quote, nonce, timestamp
from yithlibraryserver.twitter.authorization import sign, auth_header

class AuthorizationTests(unittest.TestCase):

    def test_quote(self):
        self.assertEqual(quote('a test'), 'a%20test')
        self.assertEqual(quote('a/test'), 'a%2Ftest')

    def test_nonce(self):
        self.assertEqual(len(nonce()), 8)
        self.assertEqual(len(nonce(10)), 10)
        self.assertNotEqual(nonce(), nonce())

    def test_timestamp(self):
        t1 = timestamp()
        time.sleep(1)
        t2 = timestamp()
        self.assertTrue(t2 > t1)

    def test_sign(self):
        # this example is taken from
        # https://dev.twitter.com/docs/auth/creating-signature
        method = 'post'
        url = 'https://api.twitter.com/1/statuses/update.json'
        params = (
            ('status', quote('Hello Ladies + Gentlemen, a signed OAuth request!')),
            ('include_entities', quote('true')),
            ('oauth_consumer_key', quote('xvz1evFS4wEEPTGEFPHBog')),
            ('oauth_nonce', quote('kYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg')),
            ('oauth_signature_method', quote('HMAC-SHA1')),
            ('oauth_timestamp', quote('1318622958')),
            ('oauth_token', quote('370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb')),
            ('oauth_version', quote('1.0')),
            )
        consumer_secret = 'kAcSOqF21Fu85e7zjz7ZN2U4ZRhfV3WpwPAoE3Z7kBw'
        oauth_token = 'LswwdoUaIvS8ltyTt5jkRh4J50vUPVVHtR2YPi5kE'

        self.assertEqual(sign(method, url, params,
                              consumer_secret, oauth_token),
                         quote('tnnArxj06cWHq44gCs1OSKk/jLY='))

    def test_auth_header(self):
        # this example is taken from
        # https://dev.twitter.com/docs/auth/implementing-sign-twitter
        settings = {
            'twitter_consumer_key': 'cChZNFj6T5R0TigYB9yd1w',
            'twitter_consumer_secret': 'L8qq9PZyRg6ieKGEKhZolGC0vJWLw8iEJ88DRdyOg',
            }
        params = (
            ('oauth_callback', 'http://localhost/sign-in-with-twitter/'),
            )
        token = ''
        nc = 'ea9ec8429b68d6b77cd5600adbbb0456'
        ts = 1318467427
        res = auth_header('post', 'https://api.twitter.com/oauth/request_token',
                          params, settings, token, nc, ts)
        expected = 'OAuth oauth_callback="http%3A%2F%2Flocalhost%2Fsign-in-with-twitter%2F", oauth_consumer_key="cChZNFj6T5R0TigYB9yd1w", oauth_nonce="ea9ec8429b68d6b77cd5600adbbb0456", oauth_signature_method="HMAC-SHA1", oauth_timestamp="1318467427", oauth_version="1.0", oauth_signature="F1Li3tvehgcraF8DMJ7OyxO4w9Y%3D"'
        self.assertEqual(res, expected)



########NEW FILE########
__FILENAME__ = test_information
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest
from mock import patch

from pyramid.httpexceptions import HTTPUnauthorized

from yithlibraryserver.twitter.information import get_user_info


class InformationTests(unittest.TestCase):

    def test_get_user_info(self):
        settings = {
            'twitter_consumer_key': 'key',
            'twitter_consumer_secret': 'secret',
            'twitter_user_info_url': 'https://api.twitter.com/1/users/show.json'
            }

        with patch('requests.get') as fake:
            response = fake.return_value
            response.status_code = 200
            response.json = lambda: {'screen_name': 'John Doe'}

            info = get_user_info(settings, '1234', 'token')
            self.assertEqual(info, {'screen_name': 'John Doe'})

        with patch('requests.get') as fake:
            response = fake.return_value
            response.status_code = 400
            response.json = lambda: {'screen_name': 'John Doe'}

            self.assertRaises(HTTPUnauthorized,
                              get_user_info, settings, '1234', 'token')

########NEW FILE########
__FILENAME__ = test_views
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import os

from mock import patch

from yithlibraryserver import testing


class ViewTests(testing.TestCase):

    clean_collections = ('users', )

    def test_twitter_login(self):
        settings = self.testapp.app.registry.settings
        # these are invalid Twitter tokens taken from the examples
        settings['twitter_request_token_url'] = 'https://api.twitter.com/oauth/request_token'
        settings['twitter_consumer_key'] = 'cChZNFj6T5R0TigYB9yd1w'
        settings['twitter_consumer_secret'] = 'L8qq9PZyRg6ieKGEKhZolGC0vJWLw8iEJ88DRdyOg'
        settings['twitter_authenticate_url'] = 'https://api.twitter.com/oauth/authenticate'
        with patch('requests.post') as fake:
            response = fake.return_value
            response.status_code = 200
            response.text = 'oauth_callback_confirmed=true&oauth_token=123456789'
            res = self.testapp.get('/twitter/login')
            self.assertEqual(res.status, '302 Found')
            loc = 'https://api.twitter.com/oauth/authenticate?oauth_token=123456789'
            self.assertEqual(res.location, loc)

        # simulate an authentication error from Twitter
        with patch('requests.post') as fake:
            response = fake.return_value
            response.status_code = 401
            res = self.testapp.get('/twitter/login', status=401)
            self.assertEqual(res.status, '401 Unauthorized')

        # simulate an oauth_callback_confirmed=false
        with patch('requests.post') as fake:
            response = fake.return_value
            response.status_code = 200
            response.text = 'oauth_callback_confirmed=false'
            res = self.testapp.get('/twitter/login', status=401)
            self.assertEqual(res.status, '401 Unauthorized')
            res.mustcontain('oauth_callback_confirmed is not true')

    def test_twitter_callback(self):
        settings = self.testapp.app.registry.settings
        settings['twitter_request_token_url'] = 'https://api.twitter.com/oauth/request_token'
        settings['twitter_access_token_url'] = 'https://api.twitter.com/oauth/access_token'
        settings['twitter_consumer_key'] = 'cChZNFj6T5R0TigYB9yd1w'
        settings['twitter_consumer_secret'] = 'L8qq9PZyRg6ieKGEKhZolGC0vJWLw8iEJ88DRdyOg'
        settings['twitter_authenticate_url'] = 'https://api.twitter.com/oauth/authenticate'

        os.environ['YITH_FAKE_DATETIME'] = '2012-1-10-15-31-11'

        res = self.testapp.get('/twitter/callback', status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Missing required oauth_token')

        res = self.testapp.get('/twitter/callback?oauth_token=123456789',
                               status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Missing required oauth_verifier')

        good_url = '/twitter/callback?oauth_token=123456789&oauth_verifier=abc'
        res = self.testapp.get(good_url, status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('No oauth_token was found in the session')

        # bad request because oauth tokens are different
        with patch('requests.post') as fake:
            response = fake.return_value
            response.status_code = 200
            response.text = 'oauth_callback_confirmed=true&oauth_token=987654321'
            self.testapp.get('/twitter/login')

            res = self.testapp.get(good_url, status=401)
            self.assertEqual(res.status, '401 Unauthorized')
            res.mustcontain("OAuth tokens don't match")

        # good request, twitter is not happy with us
        with patch('requests.post') as fake:
            response = fake.return_value
            response.status_code = 200
            response.text = 'oauth_callback_confirmed=true&oauth_token=123456789'
            self.testapp.get('/twitter/login')

            response = fake.return_value
            response.status_code = 401
            response.text = 'Invalid token'

            res = self.testapp.get(good_url, status=401)
            self.assertEqual(res.status, '401 Unauthorized')
            res.mustcontain('Invalid token')

        # good request, twitter is happy now. New user
        with patch('requests.post') as fake:
            response = fake.return_value
            response.status_code = 200
            response.text = 'oauth_callback_confirmed=true&oauth_token=123456789'
            self.testapp.get('/twitter/login')

            response = fake.return_value
            response.status_code = 200
            response.text = 'oauth_token=xyz&user_id=user1&screen_name=JohnDoe'

            with patch('requests.get') as fake2:
                response2 = fake2.return_value
                response2.status_code = 200
                response2.json = lambda: {'name': 'John Doe'}

                res = self.testapp.get(good_url, status=302)
                self.assertEqual(res.status, '302 Found')
                self.assertEqual(res.location, 'http://localhost/register')

        # good request, twitter is happy now. Existing user
        user_id = self.db.users.insert({
                'twitter_id': 'user1',
                'screen_name': 'Johnny',
                }, safe=True)
        with patch('requests.post') as fake:
            response = fake.return_value
            response.status_code = 200
            response.text = 'oauth_callback_confirmed=true&oauth_token=123456789'
            self.testapp.get('/twitter/login')

            response = fake.return_value
            response.status_code = 200
            response.text = 'oauth_token=xyz&user_id=user1&screen_name=JohnDoe'

            with patch('requests.get') as fake2:
                response2 = fake2.return_value
                response2.status_code = 200
                response2.json = lambda: {'name': 'John Doe'}

                res = self.testapp.get(good_url, status=302)
                self.assertEqual(res.status, '302 Found')
                self.assertEqual(res.location, 'http://localhost/')
                self.assertTrue('Set-Cookie' in res.headers)

                # even if the response from twitter included a different
                # screen_name, our user will not be updated
                new_user = self.db.users.find_one({'_id': user_id}, safe=True)
                self.assertEqual(new_user['screen_name'], 'Johnny')

        # good request, existing user, remember next_url
        with patch('requests.post') as fake:
            response = fake.return_value
            response.status_code = 200
            response.text = 'oauth_callback_confirmed=true&oauth_token=123456789'
            self.testapp.get('/twitter/login?next_url=http://localhost/foo/bar')

            response = fake.return_value
            response.status_code = 200
            response.text = 'oauth_token=xyz&user_id=user1&screen_name=JohnDoe'

            with patch('requests.get') as fake2:
                response2 = fake2.return_value
                response2.status_code = 200
                response2.json = lambda: {'name': 'John Doe'}

                res = self.testapp.get(good_url, status=302)
                self.assertEqual(res.status, '302 Found')
                self.assertEqual(res.location, 'http://localhost/foo/bar')
                self.assertTrue('Set-Cookie' in res.headers)

        del os.environ['YITH_FAKE_DATETIME']

########NEW FILE########
__FILENAME__ = views
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid.httpexceptions import HTTPBadRequest, HTTPFound, HTTPUnauthorized

import requests

from yithlibraryserver.compat import urlparse
from yithlibraryserver.twitter.authorization import auth_header
from yithlibraryserver.twitter.information import get_user_info
from yithlibraryserver.user.utils import split_name, register_or_update
from yithlibraryserver.user.utils import user_from_provider_id


def twitter_login(request):
    settings = request.registry.settings
    request_token_url = settings['twitter_request_token_url']
    oauth_callback_url = request.route_url('twitter_callback')

    params = (
        ('oauth_callback', oauth_callback_url),
        )

    auth = auth_header('POST', request_token_url, params, settings)

    response = requests.post(request_token_url, data='',
                             headers={'Authorization': auth})

    if response.status_code != 200:
        return HTTPUnauthorized(response.text)

    response_args = dict(urlparse.parse_qsl(response.text))
    if response_args['oauth_callback_confirmed'] != 'true':
        return HTTPUnauthorized('oauth_callback_confirmed is not true')

    #oauth_token_secret = response_args['oauth_token_secret']
    oauth_token = response_args['oauth_token']
    request.session['oauth_token'] = oauth_token
    if 'next_url' in request.params:
        request.session['next_url'] = request.params['next_url']

    authorize_url = '%s?oauth_token=%s' % (
        settings['twitter_authenticate_url'], oauth_token
        )
    return HTTPFound(location=authorize_url)


def twitter_callback(request):
    settings = request.registry.settings

    try:
        oauth_token = request.params['oauth_token']
    except KeyError:
        return HTTPBadRequest('Missing required oauth_token')

    try:
        oauth_verifier = request.params['oauth_verifier']
    except KeyError:
        return HTTPBadRequest('Missing required oauth_verifier')

    try:
        saved_oauth_token = request.session['oauth_token']
    except KeyError:
        return HTTPBadRequest('No oauth_token was found in the session')

    if saved_oauth_token != oauth_token:
        return HTTPUnauthorized("OAuth tokens don't match")
    else:
        del request.session['oauth_token']

    access_token_url = settings['twitter_access_token_url']

    params = (
        ('oauth_token', oauth_token),
        )

    auth = auth_header('POST', access_token_url, params, settings, oauth_token)

    response = requests.post(access_token_url,
                             data='oauth_verifier=%s' % oauth_verifier,
                             headers={'Authorization': auth})

    if response.status_code != 200:
        return HTTPUnauthorized(response.text)

    response_args = dict(urlparse.parse_qsl(response.text))
    #oauth_token_secret = response_args['oauth_token_secret']
    oauth_token = response_args['oauth_token']
    user_id = response_args['user_id']
    screen_name = response_args['screen_name']

    existing_user = user_from_provider_id(request.db, 'twitter', user_id)
    if existing_user is None:
        # fetch Twitter info only if this is the first time for
        # the user sice Twitter has very strong limits for using
        # its APIs
        twitter_info = get_user_info(settings, user_id, oauth_token)
        first_name, last_name = split_name(twitter_info['name'])
        info = {
            'screen_name': screen_name,
            'first_name': first_name,
            'last_name': last_name,
            }
    else:
        info = {}

    return register_or_update(request, 'twitter', user_id, info,
                              request.route_path('home'))

########NEW FILE########
__FILENAME__ = accounts
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import bson

from yithlibraryserver.email import send_email_to_admins


def get_available_providers():
    return ('facebook', 'google', 'twitter', 'persona')


def get_provider_key(provider):
    return '%s_id' % provider


def get_providers(user, current):
    result = []
    for provider in get_available_providers():
        key = provider + '_id'
        if key in user and user[key] is not None:
            result.append({
                    'name': provider,
                    'is_current': current == provider,
                    })
    return result


def get_n_passwords(db, user):
    return db.passwords.find({
            'owner': user.get('_id', None),
            }, safe=True).count()


def get_accounts(db, current_user, current_provider):
    email = current_user.get('email', None)
    results = db.users.find({
            'email': email,
            '_id': {'$ne': current_user.get('_id', None)},
            }, safe=True)

    if current_user:
        results = [current_user] + list(results)

    accounts = []
    for user in results:
        providers = get_providers(user, current_provider)
        is_current = current_provider in [p['name'] for p in providers]
        accounts.append({
            'providers': providers,
            'is_current': is_current,
            'passwords': get_n_passwords(db, user),
            'id': str(user['_id']),
            'is_verified': user.get('email_verified', False),
            })
    return accounts


def merge_accounts(db, master_user, accounts):
    merged = 0

    for account in accounts:
        user_id = bson.ObjectId(account)
        if master_user['_id'] == user_id:
            continue

        current_user = db.users.find_one({'_id': user_id}, safe=True)
        if current_user is None:
            continue

        merge_users(db, master_user, current_user)

        merged += 1

    return merged


def merge_users(db, user1, user2):
    # move all passwords of user2 to user1
    db.passwords.update({'owner': user2['_id']}, {
            '$set': {
                'owner': user1['_id'],
                },
            }, multi=True, safe=True)

    # copy authorized_apps from user2 to user1
    updates = {
        '$addToSet': {
            'authorized_apps': {
                '$each': user2['authorized_apps'],
                },
            },
        }

    # copy the providers
    for provider in get_available_providers():
        key = provider + '_id'
        if key in user2 and key not in user1:
            sets = updates.setdefault('$set', {})
            sets[key] = user2[key]

    db.users.update({'_id': user1['_id']}, updates, safe=True)

    # remove user2
    db.users.remove(user2['_id'])


def notify_admins_of_account_removal(request, user, reason):
    context = {
        'reason': reason or 'no reason was given',
        'user': user,
        'home_link': request.route_url('home'),
    }
    return send_email_to_admins(
        request,
        'yithlibraryserver.user:templates/account_removal_notification',
        context,
        'A user has destroyed his Yith Library account',
    )

########NEW FILE########
__FILENAME__ = analytics
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

USER_ATTR = 'allow_google_analytics'


class GoogleAnalytics(object):

    def __init__(self, request):
        self.request = request

    @property
    def enabled(self):
        code = self.request.registry.settings['google_analytics_code']
        return code is not None

    @property
    def first_time(self):
        if self.request.user is None:
            return USER_ATTR not in self.request.session
        else:
            return USER_ATTR not in self.request.user

    def show_in_session(self):
        return self.request.session.get(USER_ATTR, False)

    def show_in_user(self, user):
        return user.get(USER_ATTR, False)

    def is_in_session(self):
        return USER_ATTR in self.request.session

    def is_stored_in_user(self, user):
        return USER_ATTR in user

    @property
    def show(self):
        user = self.request.user
        if user is None:
            return self.show_in_session()
        else:
            return self.show_in_user(user)

    def clean_session(self):
        if USER_ATTR in self.request.session:
            del self.request.session[USER_ATTR]

    def get_user_attr(self, value):
        return {USER_ATTR: value}


def get_google_analytics(request):
    return GoogleAnalytics(request)

########NEW FILE########
__FILENAME__ = email_verification
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import uuid

from yithlibraryserver.email import send_email


class EmailVerificationCode(object):

    def __init__(self, code=None):
        if code is None:
            self.code = self._generate_code()
        else:
            self.code = code

    def _generate_code(self):
        return str(uuid.uuid4())

    def store(self, db, user):
        result = db.users.update({'_id': user['_id']}, {
                '$set': {'email_verification_code': self.code},
                }, safe=True)
        return result['n'] == 1

    def remove(self, db, email, verified):
        result = db.users.update({
                'email_verification_code': self.code,
                'email': email,
                }, {
                '$unset': {'email_verification_code': 1},
                '$set': {'email_verified': verified},
                }, safe=True)
        return result['n'] == 1

    def verify(self, db, email):
        result = db.users.find_one({
                'email': email,
                'email_verification_code': self.code,
                })
        return result is not None

    def send(self, request, user, url):
        context = {
            'link': '%s?code=%s&email=%s' % (url, self.code, user['email']),
            'user': user,
        }
        return send_email(
            request,
            'yithlibraryserver.user:templates/email_verification_code',
            context,
            'Please verify your email address',
            [user['email']],
        )

########NEW FILE########
__FILENAME__ = gravatar
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import hashlib

from yithlibraryserver.compat import url_encode


class Gravatar(object):

    def __init__(self, request, default_image_url):
        self.request = request
        self.default_image_url = default_image_url

    def get_email_hash(self, email):
        return hashlib.md5(email.lower().encode('utf-8')).hexdigest()

    def get_image_url(self, size=32):
        default_image_url = self.default_image_url

        email = self.get_email()
        if not email:
            return default_image_url

        email_hash = self.get_email_hash(email)
        parameters = {
            'd': default_image_url,
            's': size,
            }
        gravatar_url = 'https://www.gravatar.com/avatar/%s?%s' % (
            email_hash, url_encode(parameters))

        return gravatar_url

    def has_avatar(self):
        return self.get_email() is not None

    def get_email(self):
        user = self.request.user
        if user is None:
            return None

        email = user.get('email', '')
        if not email:
            return None

        return email


def get_gravatar(request):
    default_image_url = request.static_url(
        'yithlibraryserver:static/img/default_gravatar.png')
    return Gravatar(request, default_image_url)


########NEW FILE########
__FILENAME__ = idp
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import logging

from yithlibraryserver.i18n import TranslationString as _

log = logging.getLogger(__name__)


class IdentityProvider(object):

    def __init__(self, name):
        self.name = name

    @property
    def route_path(self):
        return '%s_login' % self.name

    @property
    def image_path(self):
        return 'yithlibraryserver:static/img/%s-logo.png' % self.name

    @property
    def message(self):
        return _('Log in with ${idp}', mapping={'idp': self.name.capitalize()})


def add_identity_provider(config, name):
    log.debug('Registering identity provider "%s"' % name)

    if not hasattr(config.registry, 'identity_providers'):
        config.registry.identity_providers = []

    config.registry.identity_providers.append(IdentityProvider(name))

########NEW FILE########
__FILENAME__ = models
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from yithlibraryserver.compat import text_type


class User(dict):

    def __unicode__(self):
        result = self.get('screen_name', '')
        if result:
            return result

        result = ' '.join([self.get('first_name', ''),
                           self.get('last_name', '')])
        result = result.strip()
        if result:
            return result

        result = self.get('email', '')
        if result:
            return result

        return text_type(self['_id'])

    # py3 compatibility
    def __str__(self):
        return self.__unicode__()

########NEW FILE########
__FILENAME__ = schemas
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import colander
from deform.widget import CheckboxWidget, TextAreaWidget, TextInputWidget

from yithlibraryserver.i18n import TranslationString as _


class EmailWidget(TextInputWidget):

    email_verified_template = 'email_verified'

    def serialize(self, field, cstruct, readonly=False):
        email_output = super(EmailWidget, self).serialize(
            field,
            cstruct.get('email', ''),
            readonly,
            )

        pstruct = field.schema.deserialize(cstruct)
        email_verified_output = field.renderer(
            self.email_verified_template,
            email=pstruct.get('email', ''),
            email_verified=pstruct.get('email_verified', False),
            )

        return email_output + email_verified_output

    def deserialize(self, field, pstruct):
        return {
            'email': super(EmailWidget, self).deserialize(field, pstruct),
            # The email_verified attr is readonly and
            # thus, not used in the view
            'email_verified': None,
            }


class EmailSchema(colander.MappingSchema):

    email = colander.SchemaNode(colander.String(), missing='')
    email_verified = colander.SchemaNode(colander.Boolean())


class BaseUserSchema(colander.MappingSchema):

    first_name = colander.SchemaNode(
        colander.String(),
        title=_('First name'),
        missing='',
        )
    last_name = colander.SchemaNode(
        colander.String(),
        title=_('Last name'),
        missing='',
        )
    screen_name = colander.SchemaNode(
        colander.String(),
        title=_('Screen name'),
        missing='',
        )


class UserSchema(BaseUserSchema):

    email = EmailSchema(
        title=_('Email'),
        widget=EmailWidget(),
        missing={'email': '', 'email_verified': False},
        )


class NewUserSchema(BaseUserSchema):

    email = colander.SchemaNode(
        colander.String(),
        title=_('Email'),
        missing='',
        )


class AccountDestroySchema(colander.MappingSchema):

    reason = colander.SchemaNode(
        colander.String(),
        missing='',
        title=_('Do you mind telling us your reasons? We want to get better!'),
        widget=TextAreaWidget(css_class='input-xlarge'),
        )


class UserPreferencesSchema(colander.MappingSchema):

    allow_google_analytics = colander.SchemaNode(
        colander.Boolean(),
        title=_('Allow statistics cookie'),
        missing=False,
        )

    send_passwords_periodically = colander.SchemaNode(
        colander.Boolean(),
        title=_('Send my passwords to my email monthly'),
        missing=False,
        widget=CheckboxWidget(css_class='send-passwords-periodically'),
        )

########NEW FILE########
__FILENAME__ = security
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import bson

from pyramid.security import authenticated_userid, unauthenticated_userid
from pyramid.httpexceptions import HTTPFound

from yithlibraryserver.user.models import User


def get_user(request):
    user_id = unauthenticated_userid(request)
    if user_id is None:
        return user_id

    try:
        user = request.db.users.find_one(bson.ObjectId(user_id))
    except bson.errors.InvalidId:
        return None

    return User(user)


def assert_authenticated_user_is_registered(request):
    user_id = authenticated_userid(request)
    try:
        user = request.db.users.find_one(bson.ObjectId(user_id))
    except bson.errors.InvalidId:
        raise HTTPFound(location=request.route_path('register_new_user'))
    else:
        return User(user)

########NEW FILE########
__FILENAME__ = test_accounts
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from pyramid import testing
from pyramid.testing import DummyRequest

from pyramid_mailer import get_mailer

from yithlibraryserver.db import MongoDB
from yithlibraryserver.user.accounts import get_available_providers
from yithlibraryserver.user.accounts import get_providers, get_n_passwords
from yithlibraryserver.user.accounts import get_accounts, merge_accounts
from yithlibraryserver.user.accounts import merge_users
from yithlibraryserver.user.accounts import notify_admins_of_account_removal
from yithlibraryserver.testing import MONGO_URI, TestCase


class AccountTests(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp()
        mdb = MongoDB(MONGO_URI)
        self.db = mdb.get_database()

    def tearDown(self):
        testing.tearDown()
        self.db.drop_collection('users')
        self.db.drop_collection('passwords')

    def test_get_available_providers(self):
        self.assertEqual(('facebook', 'google', 'twitter', 'persona'),
                         get_available_providers())

    def test_get_providers(self):
        self.assertEqual([], get_providers({}, ''))
        self.assertEqual([{'name': 'facebook', 'is_current': True}],
                         get_providers({'facebook_id': 1234}, 'facebook'))
        self.assertEqual([{
                    'name': 'facebook',
                    'is_current': True,
                    }, {
                    'name': 'google',
                    'is_current': False,
                    }, {
                    'name': 'twitter',
                    'is_current': False,
                    }],
                          get_providers({'facebook_id': 1234,
                                         'google_id': 4321,
                                         'twitter_id': 6789}, 'facebook'))
        self.assertEqual([], get_providers({'myspace_id': 1234}, ''))

    def test_n_passwords(self):
        self.assertEqual(0, get_n_passwords(self.db, {'_id': 1}))

        self.db.passwords.insert({'password': 'secret', 'owner': 1}, safe=True)
        self.assertEqual(1, get_n_passwords(self.db, {'_id': 1}))

        self.db.passwords.insert({'password2': 'secret2', 'owner': 1}, safe=True)
        self.assertEqual(2, get_n_passwords(self.db, {'_id': 1}))
        self.db.passwords.insert({'password2': 'secret2', 'owner': 2}, safe=True)
        self.assertEqual(2, get_n_passwords(self.db, {'_id': 1}))

    def test_get_accounts(self):
        self.assertEqual([], get_accounts(self.db, {}, ''))
        self.assertEqual([{
                    'providers': [],
                    'is_current': False,
                    'passwords': 0,
                    'id': '',
                    'is_verified': False,
                    }], get_accounts(self.db, {
                    'email': 'john@example.com',
                    '_id': '',
                    }, ''))

        user_id = self.db.users.insert({'email': 'john@example.com'},
                                       safe=True)
        self.assertEqual([{
                    'providers': [],
                    'is_current': False,
                    'passwords': 0,
                    'id': '',
                    'is_verified': False,
                    }, {
                    'providers': [],
                    'is_current': False,
                    'passwords': 0,
                    'id': str(user_id),
                    'is_verified': False,
                    }], get_accounts(self.db, {
                    'email': 'john@example.com',
                    '_id': '',
                    }, ''))

        self.db.users.update({'email': 'john@example.com'}, {
                '$set': {'twitter_id': 1234},
                }, safe=True)
        self.assertEqual([{
                    'providers': [],
                    'is_current': False,
                    'passwords': 0,
                    'id': '',
                    'is_verified': False,
                    }, {
                    'providers': [{
                            'name': 'twitter',
                            'is_current': False,
                            }],
                    'is_current': False,
                    'passwords': 0,
                    'id': str(user_id),
                    'is_verified': False,
                    }], get_accounts(self.db, {
                    'email': 'john@example.com',
                    '_id': '',
                    }, ''))

        self.db.users.update({'email': 'john@example.com'}, {
                '$set': {'email_verified': True},
                }, safe=True)
        self.assertEqual([{
                    'providers': [],
                    'is_current': False,
                    'passwords': 0,
                    'id': '',
                    'is_verified': False,
                    }, {
                    'providers': [{
                            'name': 'twitter',
                            'is_current': True,
                            }],
                    'passwords': 0,
                    'id': str(user_id),
                    'is_current': True,
                    'is_verified': True,
                    }], get_accounts(self.db, {
                    'email': 'john@example.com',
                    '_id': '',
                    }, 'twitter'))

        self.db.passwords.insert({'password': 'secret', 'owner': user_id},
                                 safe=True)
        self.db.users.update({'email': 'john@example.com'}, {
                '$set': {'twitter_id': 1234},
                }, safe=True)
        self.assertEqual([{
                    'providers': [],
                    'is_current': False,
                    'passwords': 0,
                    'id': '',
                    'is_verified': False,
                    }, {
                    'providers': [{
                            'name': 'twitter',
                            'is_current': False,
                            }],
                    'passwords': 1,
                    'id': str(user_id),
                    'is_current': False,
                    'is_verified': True,
                    }], get_accounts(self.db, {
                    'email': 'john@example.com',
                    '_id': '',
                    }, 'google'))

        self.db.users.update({'email': 'john@example.com'}, {
                '$set': {'google_id': 4321},
                }, safe=True)
        self.assertEqual([{
                    'providers': [],
                    'is_current': False,
                    'passwords': 0,
                    'id': '',
                    'is_verified': False,
                    }, {
                    'providers': [{
                            'name': 'google',
                            'is_current': True,
                            }, {
                            'name': 'twitter',
                            'is_current': False,
                            }],
                    'passwords': 1,
                    'id': str(user_id),
                    'is_current': True,
                    'is_verified': True,
                    }], get_accounts(self.db, {
                    'email': 'john@example.com',
                    '_id': '',
                    }, 'google'))

    def test_merge_accounts(self):
        self.assertEqual(0, merge_accounts(self.db, {}, []))

        master_id = self.db.users.insert({
                'email': 'john@example.com',
                'twitter_id': 1234,
                'authorized_apps': ['a', 'b'],
                }, safe=True)
        master_user = self.db.users.find_one({'_id': master_id}, safe=True)

        self.db.passwords.insert({
                'owner': master_id,
                'password1': 'secret1',
                }, safe=True)

        # merging with itself does nothing
        self.assertEqual(1, self.db.users.count())
        self.assertEqual(0, merge_accounts(self.db, master_user,
                                            [str(master_id)]))
        master_user_reloaded = self.db.users.find_one({'_id': master_id},
                                                      safe=True)
        self.assertEqual(master_user, master_user_reloaded)
        self.assertEqual(1, self.db.users.count())

        # merge with invented users does nothing neither
        self.assertEqual(0, merge_accounts(self.db, master_user,
                                           ['000000000000000000000000']))
        master_user_reloaded = self.db.users.find_one({'_id': master_id},
                                                      safe=True)
        self.assertEqual(master_user, master_user_reloaded)
        self.assertEqual(1, self.db.users.count())

        # let's create valid users
        other_id = self.db.users.insert({
                'email': 'john@example.com',
                'google_id': 4321,
                'authorized_apps': ['b', 'c'],
                }, safe=True)
        self.assertEqual(2, self.db.users.count())
        self.db.passwords.insert({
                'owner': other_id,
                'password2': 'secret2',
                }, safe=True)

        self.assertEqual(1, merge_accounts(self.db, master_user,
                                           [str(other_id)]))
        master_user_reloaded = self.db.users.find_one({'_id': master_id},
                                                      safe=True)
        self.assertEqual({
                '_id': master_id,
                'email': 'john@example.com',
                'twitter_id': 1234,
                'google_id': 4321,
                'authorized_apps': ['a', 'b', 'c'],
                }, master_user_reloaded)
        self.assertEqual(1, self.db.users.count())
        self.assertEqual(2,
                         self.db.passwords.find({'owner': master_id}).count())

    def test_merge_users(self):
        user1_id = self.db.users.insert({
                'email': 'john@example.com',
                'twitter_id': 1234,
                'authorized_apps': ['a', 'b'],
                }, safe=True)
        self.db.passwords.insert({
                'owner': user1_id,
                'password': 'secret1',
                }, safe=True)
        self.db.passwords.insert({
                'owner': user1_id,
                'password': 'secret2',
                }, safe=True)
        user1 = self.db.users.find_one({'_id': user1_id}, safe=True)

        user2_id = self.db.users.insert({
                'email': 'john@example.com',
                'google_id': 4321,
                'authorized_apps': ['b', 'c'],
                }, safe=True)
        self.db.passwords.insert({
                'owner': user2_id,
                'password': 'secret3',
                }, safe=True)
        self.db.passwords.insert({
                'owner': user2_id,
                'password': 'secret4',
                }, safe=True)
        user2 = self.db.users.find_one({'_id': user2_id}, safe=True)

        merge_users(self.db, user1, user2)
        self.assertEqual(4, self.db.passwords.find(
                {'owner': user1_id}, safe=True).count())
        self.assertEqual(0, self.db.passwords.find(
                {'owner': user2_id}, safe=True).count())
        self.assertEqual(None, self.db.users.find_one({'_id': user2_id}))
        user1_refreshed = self.db.users.find_one({'_id': user1_id}, safe=True)
        self.assertEqual(user1_refreshed, {
                '_id': user1_id,
                'email': 'john@example.com',
                'twitter_id': 1234,
                'google_id': 4321,
                'authorized_apps': ['a', 'b', 'c'],
                })


class AccountRemovalNotificationTests(TestCase):

    def setUp(self):
        self.admin_emails = ['admin1@example.com', 'admin2@example.com']
        self.config = testing.setUp(settings={
                'admin_emails': self.admin_emails,
                })
        self.config.include('pyramid_mailer.testing')
        self.config.include('yithlibraryserver')
        super(AccountRemovalNotificationTests, self).setUp()

    def test_notify_admins_of_account_removal(self):
        request = DummyRequest()
        mailer = get_mailer(request)
        self.assertEqual(len(mailer.outbox), 0)

        user = {'first_name': 'John', 'last_name': 'Doe',
                'email': 'john@example.com'}
        reason = 'I do not trust free services'
        notify_admins_of_account_removal(request, user, reason)

        self.assertEqual(len(mailer.outbox), 1)
        self.assertEqual(mailer.outbox[0].subject,
                        'A user has destroyed his Yith Library account')
        self.assertEqual(mailer.outbox[0].recipients, self.admin_emails)
        self.assertTrue('John Doe <john@example.com' in mailer.outbox[0].body)
        self.assertTrue('I do not trust free services' in mailer.outbox[0].body)

########NEW FILE########
__FILENAME__ = test_analytics
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from pyramid.testing import DummyRequest

from yithlibraryserver.user.analytics import GoogleAnalytics
from yithlibraryserver.user.analytics import get_google_analytics
from yithlibraryserver.user.analytics import USER_ATTR


class DummyRegistry(object):

    def __init__(self, **kwargs):
        self.settings = kwargs


class GoogleAnalyticsTests(unittest.TestCase):

    def test_enabled(self):
        request = DummyRequest()
        request.session = {}
        request.registry = DummyRegistry(google_analytics_code='1234')
        ga = GoogleAnalytics(request)
        self.assertTrue(ga.enabled)

        request = DummyRequest()
        request.session = {}
        request.registry = DummyRegistry(google_analytics_code=None)
        ga = GoogleAnalytics(request)
        self.assertFalse(ga.enabled)

    def test_first_time(self):
        request = DummyRequest()
        request.session = {}
        request.user = None
        ga = GoogleAnalytics(request)
        self.assertTrue(ga.first_time)

        request = DummyRequest()
        request.session = {USER_ATTR: True}
        request.user = None
        ga = GoogleAnalytics(request)
        self.assertFalse(ga.first_time)

        request = DummyRequest()
        request.session = {USER_ATTR: False}
        request.user = None
        ga = GoogleAnalytics(request)
        self.assertFalse(ga.first_time)

        request = DummyRequest()
        request.session = {}
        request.user = {}
        ga = GoogleAnalytics(request)
        self.assertTrue(ga.first_time)

        request = DummyRequest()
        request.session = {}
        request.user = {USER_ATTR: True}
        ga = GoogleAnalytics(request)
        self.assertFalse(ga.first_time)

        request = DummyRequest()
        request.session = {}
        request.user = {USER_ATTR: False}
        ga = GoogleAnalytics(request)
        self.assertFalse(ga.first_time)

    def test_show_in_session(self):
        request = DummyRequest()
        request.session = {}
        ga = GoogleAnalytics(request)
        self.assertFalse(ga.show_in_session())

        request = DummyRequest()
        request.session = {USER_ATTR: False}
        ga = GoogleAnalytics(request)
        self.assertFalse(ga.show_in_session())

        request = DummyRequest()
        request.session = {USER_ATTR: True}
        ga = GoogleAnalytics(request)
        self.assertTrue(ga.show_in_session())

    def test_show_in_user(self):
        request = DummyRequest()
        ga = GoogleAnalytics(request)
        self.assertFalse(ga.show_in_user({}))

        self.assertFalse(ga.show_in_user({USER_ATTR: False}))

        self.assertTrue(ga.show_in_user({USER_ATTR: True}))

    def test_is_in_session(self):
        request = DummyRequest()
        request.session = {}
        ga = GoogleAnalytics(request)
        self.assertFalse(ga.is_in_session())

        request = DummyRequest()
        request.session = {USER_ATTR: True}
        ga = GoogleAnalytics(request)
        self.assertTrue(ga.is_in_session())

        request = DummyRequest()
        request.session = {USER_ATTR: False}
        ga = GoogleAnalytics(request)
        self.assertTrue(ga.is_in_session())

    def test_is_stored_in_user(self):
        request = DummyRequest()
        ga = GoogleAnalytics(request)
        self.assertFalse(ga.is_stored_in_user({}))

        self.assertTrue(ga.is_stored_in_user({USER_ATTR: True}))

        self.assertTrue(ga.is_stored_in_user({USER_ATTR: False}))

    def test_show(self):
        request = DummyRequest()
        request.session = {}
        request.user = None
        ga = GoogleAnalytics(request)
        self.assertFalse(ga.show)

        request = DummyRequest()
        request.session = {USER_ATTR: True}
        request.user = None
        ga = GoogleAnalytics(request)
        self.assertTrue(ga.show)

        request = DummyRequest()
        request.session = {}
        request.user = {USER_ATTR: True}
        ga = GoogleAnalytics(request)
        self.assertTrue(ga.show)

        request = DummyRequest()
        request.session = {USER_ATTR: True}
        request.user = {USER_ATTR: False}
        ga = GoogleAnalytics(request)
        self.assertFalse(ga.show)

    def test_clean_session(self):
        request = DummyRequest()
        request.session = {}
        request.user = None
        ga = GoogleAnalytics(request)
        ga.clean_session()
        self.assertEqual(request.session, {})

        request = DummyRequest()
        request.session = {USER_ATTR: True}
        request.user = None
        ga = GoogleAnalytics(request)
        ga.clean_session()
        self.assertEqual(request.session, {})

    def test_get_user_attr(self):
        request = DummyRequest()
        request.session = {}
        request.user = None
        ga = GoogleAnalytics(request)
        self.assertEqual(ga.get_user_attr(True), {USER_ATTR: True})
        self.assertEqual(ga.get_user_attr(False), {USER_ATTR: False})

    def test_get_google_analytics(self):
        request = DummyRequest()
        ga = get_google_analytics(request)

        self.assertTrue(isinstance(ga, GoogleAnalytics))
        self.assertEqual(ga.request, request)

########NEW FILE########
__FILENAME__ = test_email_verification
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid import testing
from pyramid.testing import DummyRequest

from pyramid_mailer import get_mailer

from yithlibraryserver.testing import TestCase
from yithlibraryserver.user.email_verification import EmailVerificationCode

class EmailVerificationCodeTests(TestCase):

    clean_collections = ('users', )

    def setUp(self):
        self.config = testing.setUp()
        self.config.include('pyramid_mailer.testing')
        super(EmailVerificationCodeTests, self).setUp()

    def test_email_verification_code(self):
        evc = EmailVerificationCode()

        self.assertNotEqual(evc.code, None)

        user_id = self.db.users.insert({
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                }, safe=True)
        user = self.db.users.find_one({'_id': user_id})
        evc.store(self.db, user)

        user = self.db.users.find_one({'_id': user_id})
        self.assertEqual(user['email_verification_code'], evc.code)

        evc2 = EmailVerificationCode(evc.code)
        result = evc2.verify(self.db, 'john@example.com')
        self.assertTrue(result)

        evc2.remove(self.db, 'john@example.com', True)
        user = self.db.users.find_one({'_id': user_id})
        self.assertFalse('email_verification_code' in user)
        self.assertTrue(user['email_verified'])

        request = DummyRequest()
        mailer = get_mailer(request)
        self.assertEqual(len(mailer.outbox), 0)
        evc2.send(request, user, 'http://example.com/verify')

        self.assertEqual(len(mailer.outbox), 1)
        self.assertEqual(mailer.outbox[0].subject,
                         'Please verify your email address')
        self.assertEqual(mailer.outbox[0].recipients,
                         ['john@example.com'])

########NEW FILE########
__FILENAME__ = test_gravatar
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from pyramid.testing import DummyRequest

from yithlibraryserver.compat import urlparse
from yithlibraryserver.user.gravatar import Gravatar


class GravatarTests(unittest.TestCase):

    def assertURLEqual(self, url1, url2):
        parts1 = urlparse.urlparse(url1)
        parts2 = urlparse.urlparse(url2)
        self.assertEqual(parts1.scheme, parts2.scheme)
        self.assertEqual(parts1.hostname, parts2.hostname)
        self.assertEqual(parts1.netloc, parts2.netloc)
        self.assertEqual(parts1.params, parts2.params)
        self.assertEqual(parts1.path, parts2.path)
        self.assertEqual(parts1.port, parts2.port)
        self.assertEqual(urlparse.parse_qs(parts1.query),
                         urlparse.parse_qs(parts2.query))

    def test_get_email(self):
        request = DummyRequest()
        request.user = None
        gravatar = Gravatar(request, 'http://localhost/default_gravatar.png')
        self.assertEqual(gravatar.get_email(), None)

        request = DummyRequest()
        request.user = {}
        gravatar = Gravatar(request, 'http://localhost/default_gravatar.png')
        self.assertEqual(gravatar.get_email(), None)

        request = DummyRequest()
        request.user = {'email': ''}
        gravatar = Gravatar(request, 'http://localhost/default_gravatar.png')
        self.assertEqual(gravatar.get_email(), None)

        request = DummyRequest()
        request.user = {'email': 'john@example.com'}
        gravatar = Gravatar(request, 'http://localhost/default_gravatar.png')
        self.assertEqual(gravatar.get_email(), 'john@example.com')

    def test_has_avatar(self):
        request = DummyRequest()
        request.user = None
        gravatar = Gravatar(request, 'http://localhost/default_gravatar.png')
        self.assertFalse(gravatar.has_avatar())

        request = DummyRequest()
        request.user = {'email': 'john@example.com'}
        gravatar = Gravatar(request, 'http://localhost/default_gravatar.png')
        self.assertTrue(gravatar.has_avatar())

    def test_email_hash(self):
        request = DummyRequest()
        gravatar = Gravatar(request, 'http://localhost/default_gravatar.png')
        self.assertEqual(gravatar.get_email_hash('john@example.com'),
                         'd4c74594d841139328695756648b6bd6')
        self.assertEqual(gravatar.get_email_hash('JOHN@EXAMPLE.COM'),
                         'd4c74594d841139328695756648b6bd6')

    def test_get_image_url(self):
        request = DummyRequest()
        request.user = None
        gravatar = Gravatar(request, 'http://localhost/default_gravatar.png')
        self.assertEqual(gravatar.get_image_url(),
                         'http://localhost/default_gravatar.png')

        request = DummyRequest()
        request.user = {}
        gravatar = Gravatar(request, 'http://localhost/default_gravatar.png')
        self.assertURLEqual(gravatar.get_image_url(),
                            'http://localhost/default_gravatar.png')

        request = DummyRequest()
        request.user = {'email': ''}
        gravatar = Gravatar(request, 'http://localhost/default_gravatar.png')
        self.assertURLEqual(gravatar.get_image_url(),
                            'http://localhost/default_gravatar.png')

        request = DummyRequest()
        request.user = {'email': 'john@example.com'}
        gravatar = Gravatar(request, 'http://localhost/default_gravatar.png')
        self.assertURLEqual(
            gravatar.get_image_url(),
            'https://www.gravatar.com/avatar/d4c74594d841139328695756648b6bd6?s=32&d=http%3A%2F%2Flocalhost%2Fdefault_gravatar.png')

        gravatar = Gravatar(request, 'http://localhost/default_gravatar.png')
        self.assertURLEqual(
            gravatar.get_image_url(100),
            'https://www.gravatar.com/avatar/d4c74594d841139328695756648b6bd6?s=100&d=http%3A%2F%2Flocalhost%2Fdefault_gravatar.png')

########NEW FILE########
__FILENAME__ = test_idp
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from pyramid import testing

from yithlibraryserver.user.idp import add_identity_provider


class IdentityProviderTests(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp()

    def tearDown(self):
        testing.tearDown()

    def test_add_identity_provider(self):
        self.config.add_directive('add_identity_provider',
                                  add_identity_provider)

        self.config.add_identity_provider('provider1')

        request = testing.DummyRequest()

        self.assertTrue(hasattr(request.registry, 'identity_providers'))
        self.assertEqual(len(request.registry.identity_providers), 1)
        idp1 = request.registry.identity_providers[0]
        self.assertEqual(idp1.route_path, 'provider1_login')
        self.assertEqual(idp1.image_path, 'yithlibraryserver:static/img/provider1-logo.png')
        self.assertEqual(idp1.message, 'Log in with ${idp}')

########NEW FILE########
__FILENAME__ = test_models
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from yithlibraryserver.compat import text_type
from yithlibraryserver.user.models import User


class UserTests(unittest.TestCase):

    def test_unicode(self):
        data = {'_id': '1234'}
        self.assertEqual(text_type(User(data)), '1234')

        data['email'] = 'john@example.com'
        self.assertEqual(text_type(User(data)), 'john@example.com')

        data['last_name'] = 'Doe'
        self.assertEqual(text_type(User(data)), 'Doe')

        data['first_name'] = 'John'
        self.assertEqual(text_type(User(data)), 'John Doe')

        data['screen_name'] = 'Johnny'
        self.assertEqual(text_type(User(data)), 'Johnny')

        u = User(data)
        self.assertEqual(u.__unicode__(), u.__str__())

########NEW FILE########
__FILENAME__ = test_security
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import unittest

from pyramid import testing
from pyramid.httpexceptions import HTTPFound

from yithlibraryserver.db import MongoDB
from yithlibraryserver.testing import MONGO_URI
from yithlibraryserver.user.security import (
    get_user,
    assert_authenticated_user_is_registered,
    )


class SecurityTests(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp()
        self.config.include('yithlibraryserver.user')
        mdb = MongoDB(MONGO_URI)
        self.db = mdb.get_database()

    def tearDown(self):
        testing.tearDown()
        self.db.drop_collection('users')

    def test_get_user(self):
        request = testing.DummyRequest()
        request.db = self.db

        self.assertEqual(None, get_user(request))

        self.config.testing_securitypolicy(userid='john')
        self.assertEqual(None, get_user(request))

        user_id = self.db.users.insert({'screen_name': 'John Doe'}, safe=True)
        self.config.testing_securitypolicy(userid=str(user_id))
        self.assertEqual(get_user(request), {
                '_id': user_id,
                'screen_name': 'John Doe',
                })

    def test_assert_authenticated_user_is_registered(self):
        self.config.testing_securitypolicy(userid='john')

        request = testing.DummyRequest()
        request.db = self.db

        self.assertRaises(HTTPFound, assert_authenticated_user_is_registered, request)
        try:
            assert_authenticated_user_is_registered(request)
        except HTTPFound as exp:
            self.assertEqual(exp.location, '/register')

        user_id = self.db.users.insert({'screen_name': 'John Doe'}, safe=True)

        self.config.testing_securitypolicy(userid=str(user_id))
        res = assert_authenticated_user_is_registered(request)
        self.assertEqual(res['_id'], user_id)
        self.assertEqual(res['screen_name'], 'John Doe')

########NEW FILE########
__FILENAME__ = test_utils
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import os
import unittest

from pyramid import testing

from yithlibraryserver.datetimeservice.testing import FakeDatetimeService
from yithlibraryserver.db import MongoDB
from yithlibraryserver.testing import MONGO_URI

from yithlibraryserver.user.analytics import GoogleAnalytics
from yithlibraryserver.user.analytics import USER_ATTR
from yithlibraryserver.user.utils import split_name, delete_user, update_user
from yithlibraryserver.user.utils import register_or_update


class UtilsTests(unittest.TestCase):

    def setUp(self):
        self.config = testing.setUp()
        self.config.include('yithlibraryserver.user')
        mdb = MongoDB(MONGO_URI)
        self.db = mdb.get_database()

    def tearDown(self):
        testing.tearDown()
        self.db.drop_collection('users')

    def test_split_name(self):
        self.assertEqual(split_name('John Doe'),
                         ('John', 'Doe'))
        self.assertEqual(split_name('John'),
                         ('John', ''))
        self.assertEqual(split_name('John M Doe'),
                         ('John', 'M Doe'))
        self.assertEqual(split_name(''),
                         ('', ''))

    def test_delete_user(self):
        user_id = self.db.users.insert({
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': '',
                }, safe=True)
        user = self.db.users.find_one({'_id': user_id}, safe=True)
        n_users = self.db.users.count()
        self.assertTrue(delete_user(self.db, user))
        refreshed_user = self.db.users.find_one({'_id': user_id}, safe=True)
        self.assertEqual(None, refreshed_user)
        self.assertEqual(n_users - 1, self.db.users.count())

    def test_update_user(self):
        user_id = self.db.users.insert({
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': '',
                }, safe=True)
        user = self.db.users.find_one({'_id': user_id})
        update_user(self.db, user, {}, {})

        updated_user = self.db.users.find_one({'_id': user_id})
        # the user has not changed
        self.assertEqual(updated_user['screen_name'], user['screen_name'])
        self.assertEqual(updated_user['first_name'], user['first_name'])
        self.assertEqual(updated_user['last_name'], user['last_name'])

        # update the last_name
        update_user(self.db, user, {'last_name': 'Doe'}, {})
        updated_user = self.db.users.find_one({'_id': user_id})
        self.assertEqual(updated_user['last_name'], 'Doe')

        # add an email attribute
        update_user(self.db, user, {'email': 'john@example.com'}, {})
        updated_user = self.db.users.find_one({'_id': user_id})
        self.assertEqual(updated_user['email'], 'john@example.com')

        # if an attribute has no value, no update happens
        update_user(self.db, user, {'first_name': ''}, {})
        updated_user = self.db.users.find_one({'_id': user_id})
        self.assertEqual(updated_user['first_name'], 'John')

        # update a non existing attribute
        update_user(self.db, user, {'foo': 'bar'}, {})
        updated_user = self.db.users.find_one({'_id': user_id})
        self.assertFalse('foo' in updated_user)

        # update the same attribute within the last parameter
        update_user(self.db, user, {}, {'foo': 'bar'})
        updated_user = self.db.users.find_one({'_id': user_id})
        self.assertEqual(updated_user['foo'], 'bar')

    def test_register_or_update(self):
        os.environ['YITH_FAKE_DATETIME'] = '2013-1-2-10-11-02'

        request = testing.DummyRequest()
        request.db = self.db
        request.session = {}
        request.google_analytics = GoogleAnalytics(request)
        response = register_or_update(request, 'skynet', 1, {
                'screen_name': 'JohnDoe',
                'first_name': 'John',
                'last_name': 'Doe',
                'invented_attribute': 'foo',  # this will not be in the output
                }, '/next')
        self.assertEqual(response.status, '302 Found')
        self.assertEqual(response.location, '/register')
        self.assertEqual(request.session['next_url'], '/next')
        self.assertEqual(request.session['user_info'], {
                'screen_name': 'JohnDoe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': '',
                'provider': 'skynet',
                'skynet_id': 1,
                })

        # try with an existing user
        user_id = self.db.users.insert({
                'skynet_id': 1,
                'screen_name': 'JohnDoe',
                'first_name': 'John',
                'last_name': '',
                }, safe=True)

        request = testing.DummyRequest()
        request.db = self.db
        request.session = {USER_ATTR: True}
        request.google_analytics = GoogleAnalytics(request)
        request.datetime_service = FakeDatetimeService(request)
        response = register_or_update(request, 'skynet', 1, {
                'screen_name': 'JohnDoe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                }, '/next')
        self.assertEqual(response.status, '302 Found')
        self.assertEqual(response.location, '/next')
        user = self.db.users.find_one({'_id': user_id})
        self.assertEqual(user['email'], 'john@example.com')
        self.assertEqual(user['last_name'], 'Doe')
        self.assertEqual(user[USER_ATTR], True)

        # maybe there is a next_url in the session
        request = testing.DummyRequest()
        request.db = self.db
        request.session = {'next_url': '/foo'}
        request.google_analytics = GoogleAnalytics(request)
        request.datetime_service = FakeDatetimeService(request)
        response = register_or_update(request, 'skynet', 1, {
                'screen_name': 'JohnDoe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                }, '/next')
        self.assertEqual(response.status, '302 Found')
        self.assertEqual(response.location, '/foo')

        del os.environ['YITH_FAKE_DATETIME']

########NEW FILE########
__FILENAME__ = test_views
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import os

from deform import ValidationFailure

from mock import patch

from pyramid_mailer import get_mailer

from yithlibraryserver.backups.email import get_day_to_send
from yithlibraryserver.compat import url_quote
from yithlibraryserver.testing import TestCase
from yithlibraryserver.user.analytics import USER_ATTR


class DummyValidationFailure(ValidationFailure):

    def render(self):
        return 'dummy error'


class BadCollection(object):

    def __init__(self, user=None):
        self.user = user

    def find_one(self, *args, **kwargs):
        return self.user

    def update(self, *args, **kwargs):
        return {'n': 0}


class BadDB(object):

    def __init__(self, user):
        self.users = BadCollection(user)
        self.passwords = BadCollection()


class ViewTests(TestCase):

    clean_collections = ('users', 'passwords', )

    def test_login(self):
        res = self.testapp.get('/login?param1=value1&param2=value2')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in with Twitter')
        res.mustcontain('/twitter/login')
        res.mustcontain(url_quote('param1=value1&param2=value2'))

        res = self.testapp.get('/login')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in with Twitter')
        res.mustcontain('/twitter/login')
        res.mustcontain('next_url=/')

    def test_register_new_user(self):
        os.environ['YITH_FAKE_DATETIME'] = '2013-1-2-10-11-02'

        res = self.testapp.get('/register', status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Missing user info in the session')

        self.add_to_session({
                'next_url': 'http://localhost/foo/bar',
                'user_info': {
                    'provider': 'myprovider',
                    'myprovider_id': '1234',
                    'screen_name': 'John Doe',
                    'first_name': 'John',
                    'last_name': 'Doe',
                    'email': 'john@example.com',
                    },
                })

        res = self.testapp.get('/register')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain("It looks like it's the first time you log into the Yith Library.")
        res.mustcontain("Register into Yith Library")
        res.mustcontain("John")
        res.mustcontain("Doe")
        res.mustcontain("john@example.com")

        self.assertEqual(self.db.users.count(), 0)
        res = self.testapp.post('/register', {
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'submit': 'Register into Yith Library',
                }, status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/foo/bar')
        self.assertEqual(self.db.users.count(), 1)
        user = self.db.users.find_one({'first_name': 'John'})
        self.assertFalse(user is None)
        self.assertEqual(user['first_name'], 'John')
        self.assertEqual(user['last_name'], 'Doe')
        self.assertEqual(user['email'], 'john@example.com')
        self.assertEqual(user['email_verified'], True)
        self.assertEqual(user['authorized_apps'], [])
        self.assertEqual(user['send_passwords_periodically'], False)

        # the next_url and user_info keys are cleared at this point
        self.add_to_session({
                'next_url': 'http://localhost/foo/bar',
                'user_info': {
                    'provider': 'myprovider',
                    'myprovider_id': '1234',
                    'screen_name': 'John Doe',
                    'first_name': 'John',
                    'last_name': 'Doe',
                    'email': 'john@example.com',
                    },
                })

        # if no email is provided at registration, the email is
        # not verified
        res = self.testapp.post('/register', {
                'first_name': 'John2',
                'last_name': 'Doe2',
                'email': '',
                'submit': 'Register into Yith Library',
                }, status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/foo/bar')
        self.assertEqual(self.db.users.count(), 2)
        user = self.db.users.find_one({'first_name': 'John2'})
        self.assertFalse(user is None)
        self.assertEqual(user['first_name'], 'John2')
        self.assertEqual(user['last_name'], 'Doe2')
        self.assertEqual(user['email'], '')
        self.assertEqual(user['email_verified'], False)
        self.assertEqual(user['authorized_apps'], [])
        self.assertEqual(user['send_passwords_periodically'], False)

        # the next_url and user_info keys are cleared at this point
        self.add_to_session({
                'next_url': 'http://localhost/foo/bar',
                'user_info': {
                    'provider': 'myprovider',
                    'myprovider_id': '1234',
                    'screen_name': 'John Doe',
                    'first_name': 'John',
                    'last_name': 'Doe',
                    'email': '',
                    },
                })

        # if an email is provided at registration, but
        # there is no email in the session (the provider
        # did not gave it to us) the email is not verified
        # and a verification email is sent
        res = self.testapp.post('/register', {
                'first_name': 'John2',
                'last_name': 'Doe2',
                'email': 'john@example.com',
                'submit': 'Register into Yith Library',
                }, status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/foo/bar')
        self.assertEqual(self.db.users.count(), 3)
        user = self.db.users.find_one({'first_name': 'John2'})
        self.assertFalse(user is None)
        self.assertEqual(user['first_name'], 'John2')
        self.assertEqual(user['last_name'], 'Doe2')
        self.assertEqual(user['email'], '')
        self.assertEqual(user['email_verified'], False)
        self.assertEqual(user['authorized_apps'], [])
        self.assertEqual(user['send_passwords_periodically'], False)

        # check that the email was sent
        res.request.registry = self.testapp.app.registry
        mailer = get_mailer(res.request)
        self.assertEqual(len(mailer.outbox), 1)
        self.assertEqual(mailer.outbox[0].subject,
                         'Please verify your email address')
        self.assertEqual(mailer.outbox[0].recipients,
                         ['john@example.com'])


        # the next_url and user_info keys are cleared at this point
        self.add_to_session({
                'next_url': 'http://localhost/foo/bar',
                'user_info': {
                    'provider': 'myprovider',
                    'myprovider_id': '1234',
                    'screen_name': 'John Doe',
                    'first_name': 'John',
                    'last_name': 'Doe',
                    'email': '',
                    },
                USER_ATTR: True,
                })

        # The user want the Google Analytics cookie
        res = self.testapp.post('/register', {
                'first_name': 'John3',
                'last_name': 'Doe3',
                'email': 'john3@example.com',
                'submit': 'Register into Yith Library',
                }, status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/foo/bar')
        self.assertEqual(self.db.users.count(), 4)
        user = self.db.users.find_one({'first_name': 'John3'})
        self.assertFalse(user is None)
        self.assertEqual(user['first_name'], 'John3')
        self.assertEqual(user['last_name'], 'Doe3')
        self.assertEqual(user['email'], 'john3@example.com')
        self.assertEqual(user['email_verified'], False)
        self.assertEqual(user['authorized_apps'], [])
        self.assertEqual(user[USER_ATTR], True)
        self.assertEqual(user['send_passwords_periodically'], False)

        # the next_url and user_info keys are cleared at this point
        self.add_to_session({
                'next_url': 'http://localhost/foo/bar',
                'user_info': {
                    'provider': 'myprovider',
                    'myprovider_id': '1234',
                    'screen_name': 'John Doe',
                    'first_name': 'John',
                    'last_name': 'Doe',
                    'email': 'john@example.com',
                    },
                })

        # simulate a cancel
        res = self.testapp.post('/register', {
                'cancel': 'Cancel',
                }, status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/foo/bar')

        # same thing but no next_url in the session
        self.add_to_session({
                'user_info': {
                    'provider': 'myprovider',
                    'myprovider_id': '1234',
                    'screen_name': 'John Doe',
                    'first_name': 'John',
                    'last_name': 'Doe',
                    'email': 'john@example.com',
                    },
                })
        res = self.testapp.post('/register', {
                'cancel': 'Cancel',
                }, status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/oauth2/clients')

        # make the form fail
        self.add_to_session({
                'user_info': {
                    'provider': 'myprovider',
                    'myprovider_id': '1234',
                    'screen_name': 'John Doe',
                    'first_name': 'John',
                    'last_name': 'Doe',
                    'email': 'john@example.com',
                    },
                })

        with patch('deform.Form.validate') as fake:
            fake.side_effect = DummyValidationFailure('f', 'c', 'e')
            res = self.testapp.post('/register', {
                    'submit': 'Register into Yith Library',
                    })
            self.assertEqual(res.status, '200 OK')

        del os.environ['YITH_FAKE_DATETIME']

    def test_logout(self):
        # Log in
        self.set_user_cookie('twitter1')
        self.add_to_session({
                'current_provider': 'twitter',
                })

        res = self.testapp.get('/logout', status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/')
        self.assertTrue('Set-Cookie' in res.headers)
        self.assertTrue('auth_tkt=""' in res.headers['Set-Cookie'])
        self.assertFalse('current_provider' in self.get_session(res))

    def test_user_information(self):
        # this view required authentication
        res = self.testapp.get('/profile')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        date = datetime.datetime(2012, 12, 12, 12, 12)
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': '',
                'email_verified': False,
                'authorized_apps': [],
                'date_joined': date,
                'last_login': date,
                }, safe=True)
        self.set_user_cookie(str(user_id))

        res = self.testapp.get('/profile')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Profile')
        res.mustcontain('John')
        res.mustcontain('Doe')
        res.mustcontain('Save changes')

        res = self.testapp.post('/profile', {
                'submit': 'Save changes',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                })
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/profile')
        # check that the user has changed
        new_user = self.db.users.find_one({'_id': user_id})
        self.assertEqual(new_user['first_name'], 'John')
        self.assertEqual(new_user['last_name'], 'Doe')
        self.assertEqual(new_user['email'], 'john@example.com')

        # make the form fail
        with patch('deform.Form.validate') as fake:
            fake.side_effect = DummyValidationFailure('f', 'c', 'e')
            res = self.testapp.post('/profile', {
                    'submit': 'Save Changes',
                    })
            self.assertEqual(res.status, '200 OK')

        # make the db fail
        with patch('yithlibraryserver.db.MongoDB.get_database') as fake:
            fake.return_value = BadDB(new_user)
            res = self.testapp.post('/profile', {
                    'submit': 'Save changes',
                    'first_name': 'John',
                    'last_name': 'Doe',
                    'email': 'john@example.com',
                    })
            self.assertEqual(res.status, '200 OK')
            res.mustcontain('There were an error while saving your changes')

    def test_user_preferences(self):
        # this view required authentication
        res = self.testapp.get('/preferences')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        date = datetime.datetime(2012, 12, 12, 12, 12)
        while True:
            user_id = self.db.users.insert({
                    'twitter_id': 'twitter1',
                    'screen_name': 'John Doe',
                    'first_name': 'John',
                    'last_name': 'Doe',
                    'email': '',
                    'email_verified': False,
                    'authorized_apps': [],
                    'date_joined': date,
                    'last_login': date,
                    'allow_google_analytics': False,
                    }, safe=True)
            day = get_day_to_send({'_id': user_id}, 28)
            # we want a user with a different day from 1
            # since that's a special case and does not
            # allow us to test a future date to send
            # the passwords
            if day != 1:
                break

            # In most cases day will be != 1 so this line
            # only get executed with very low probability
            self.db.users.remove(user_id, safe=True)  # pragma: no cover

        self.set_user_cookie(str(user_id))

        os.environ['YITH_FAKE_DATE'] = '2012-10-30'
        res = self.testapp.get('/preferences')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Preferences',
                        'Allow statistics cookie',
                        'You will receive your passwords backup on the day %d of next month' % day,
                        'Save changes')

        os.environ['YITH_FAKE_DATE'] = '2012-10-%d' % max(1, day - 1)
        res = self.testapp.get('/preferences')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Preferences',
                        'Allow statistics cookie',
                        'You will receive your passwords backup on the day %d of this month' % day,
                        'Save changes')

        os.environ['YITH_FAKE_DATE'] = '2012-10-%d' % day
        res = self.testapp.get('/preferences')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Preferences',
                        'Allow statistics cookie',
                        'You will receive your passwords backup today',
                        'Save changes')

        res = self.testapp.post('/preferences', {
                'submit': 'Save changes',
                'allow_google_analytics': 'true',
                'send_passwords_periodically': 'false',
                })
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/preferences')
        # check that the user has changed
        new_user = self.db.users.find_one({'_id': user_id})
        self.assertEqual(new_user['allow_google_analytics'], True)
        self.assertEqual(new_user['send_passwords_periodically'], False)

        # make the form fail
        with patch('deform.Form.validate') as fake:
            fake.side_effect = DummyValidationFailure('f', 'c', 'e')
            res = self.testapp.post('/preferences', {
                    'submit': 'Save Changes',
                    })
            self.assertEqual(res.status, '200 OK')

        # make the db fail
        with patch('yithlibraryserver.db.MongoDB.get_database') as fake:
            fake.return_value = BadDB(new_user)
            res = self.testapp.post('/preferences', {
                    'submit': 'Save changes',
                    'allow_google_analytics': 'true',
                    'send_passwords_periodically': 'false',
                    })
            self.assertEqual(res.status, '200 OK')
            res.mustcontain('There were an error while saving your changes')

        del os.environ['YITH_FAKE_DATE']

    def test_destroy(self):
        # this view required authentication
        res = self.testapp.get('/destroy')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': '',
                'authorized_apps': [],
                }, safe=True)
        self.set_user_cookie(str(user_id))

        res = self.testapp.get('/destroy')
        res.mustcontain('Destroy account')
        res.mustcontain('Do you really really really want to destroy your account?')
        res.mustcontain('You will not be able to undo this operation')

        # simulate a cancel
        res = self.testapp.post('/destroy', {
                'cancel': 'Cancel',
                }, status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/profile')

        # make the form fail
        with patch('deform.Form.validate') as fake:
            fake.side_effect = DummyValidationFailure('f', 'c', 'e')
            res = self.testapp.post('/destroy', {
                    'reason': '',
                    'submit': 'Yes, I am sure. Destroy my account',
                    })
            self.assertEqual(res.status, '200 OK')

        # now the real one
        res = self.testapp.post('/destroy', {
                'reason': 'I do not need a password manager',
                'submit': 'Yes, I am sure. Destroy my account',
                }, status=302)
        self.assertEqual(res.location, 'http://localhost/')
        self.assertTrue('Set-Cookie' in res.headers)
        self.assertTrue('auth_tkt=""' in res.headers['Set-Cookie'])

        user = self.db.users.find_one({'_id': user_id})
        self.assertEqual(None, user)

        res.request.registry = self.testapp.app.registry
        mailer = get_mailer(res.request)
        self.assertEqual(len(mailer.outbox), 1)
        self.assertEqual(mailer.outbox[0].subject,
                         'A user has destroyed his Yith Library account')
        self.assertEqual(mailer.outbox[0].recipients,
                         ['admin1@example.com', 'admin2@example.com'])
        self.assertTrue('I do not need a password manager' in mailer.outbox[0].body)


    def test_send_email_verification_code(self):
        # this view required authentication
        res = self.testapp.get('/send-email-verification-code')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': '',
                'authorized_apps': [],
                }, safe=True)
        self.set_user_cookie(str(user_id))

        # the user has no email so an error is expected
        res = self.testapp.get('/send-email-verification-code')
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.json, {
                'status': 'bad',
                'error': 'You have not an email in your profile',
                })

        # let's give the user an email
        self.db.users.update({'_id': user_id},
                             {'$set': {'email': 'john@example.com'}},
                             safe=True)

        # the request must be a post
        res = self.testapp.get('/send-email-verification-code')
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.json, {
                'status': 'bad',
                'error': 'Not a post',
                })


        # now a good request
        res = self.testapp.post('/send-email-verification-code', {
                'submit': 'Send verification code'})
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.json, {
                'status': 'ok',
                'error': None,
                })
        res.request.registry = self.testapp.app.registry
        mailer = get_mailer(res.request)
        self.assertEqual(len(mailer.outbox), 1)
        self.assertEqual(mailer.outbox[0].subject,
                         'Please verify your email address')
        self.assertEqual(mailer.outbox[0].recipients,
                         ['john@example.com'])

        # simulate a db failure
        with patch('yithlibraryserver.user.email_verification.EmailVerificationCode.store') as fake:
            fake.return_value = False
            res = self.testapp.post('/send-email-verification-code', {
                    'submit': 'Send verification code'})
            self.assertEqual(res.status, '200 OK')
            self.assertEqual(res.json, {
                    'status': 'bad',
                    'error': 'There were problems storing the verification code',
                    })

    def test_verify_email(self):
        res = self.testapp.get('/verify-email', status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Missing code parameter')

        res = self.testapp.get('/verify-email?code=1234', status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Missing email parameter')

        res = self.testapp.get('/verify-email?code=1234&email=john@example.com')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Sorry, your verification code is not correct or has expired')

        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'email_verification_code': '1234',
                'authorized_apps': [],
                }, safe=True)

        res = self.testapp.get('/verify-email?code=1234&email=john@example.com')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Congratulations, your email has been successfully verified')

        user = self.db.users.find_one({'_id': user_id})
        self.assertEqual(user['email_verified'], True)
        self.assertFalse('email_verification_code' in user)

    def test_identity_providers(self):
        # this view required authentication
        res = self.testapp.get('/identity-providers')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('Log in')

        # Log in
        user1_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'email_verified': True,
                'authorized_apps': ['app1', 'app2'],
                }, safe=True)
        self.set_user_cookie(str(user1_id))
        self.db.passwords.insert({
                'owner': user1_id,
                'password': 'secret1',
                })

        # one account is not enough for merging
        res = self.testapp.post('/identity-providers', {
                'submit': 'Merge my accounts',
                }, status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('You do not have enough accounts to merge')

        # so let's create another account with the same email
        user2_id = self.db.users.insert({
                'google_id': 'google1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'email_verified': True,
                'authorized_apps': ['app2', 'app3'],
                }, safe=True)
        self.db.passwords.insert({
                'owner': user2_id,
                'password': 'secret2',
                })

        # now the profile view should say I can merge my accounts
        res = self.testapp.get('/identity-providers')
        self.assertEqual(res.status, '200 OK')
        res.mustcontain('You are registered with the following accounts',
                        'Merge my accounts',
                        'If you merge your accounts')

        # if only one account is selected or fake accounts
        # are selected nothing is merged
        res = self.testapp.post('/identity-providers', {
                'account-%s' % str(user1_id): 'on',
                'account-000000000000000000000000': 'on',
                'submit': 'Merge my accounts',
                }, status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/identity-providers')
        self.assertEqual(2, self.db.users.count())
        self.assertEqual(1, self.db.passwords.find(
                {'owner': user1_id}, safe=True).count())
        self.assertEqual(1, self.db.passwords.find(
                {'owner': user2_id}, safe=True).count())

        # let's merge them
        res = self.testapp.post('/identity-providers', {
                'account-%s' % str(user1_id): 'on',
                'account-%s' % str(user2_id): 'on',
                'submit': 'Merge my accounts',
                }, status=302)
        self.assertEqual(res.status, '302 Found')
        self.assertEqual(res.location, 'http://localhost/identity-providers')

        # the accounts have been merged
        self.assertEqual(1, self.db.users.count())
        user1_refreshed = self.db.users.find_one({'_id': user1_id}, safe=True)
        self.assertEqual(user1_refreshed['google_id'], 'google1')
        self.assertEqual(user1_refreshed['authorized_apps'],
                         ['app1', 'app2', 'app3'])

        user2_refreshed = self.db.users.find_one({'_id': user2_id}, safe=True)
        self.assertEqual(user2_refreshed, None)

        self.assertEqual(2, self.db.passwords.find(
                {'owner': user1_id}, safe=True).count())

    def test_google_analytics_preference(self):
        res = self.testapp.post('/google-analytics-preference', status=400)
        self.assertEqual(res.status, '400 Bad Request')
        res.mustcontain('Missing preference parameter')

        # Anonymous users save the preference in the session
        res = self.testapp.post('/google-analytics-preference', {'yes': 'Yes'})
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.json, {'allow': True})
        self.assertEqual(self.get_session(res)[USER_ATTR], True)

        res = self.testapp.post('/google-analytics-preference', {'no': 'No'})
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.json, {'allow': False})
        self.assertEqual(self.get_session(res)[USER_ATTR], False)

        # Authenticated users save the preference in the database
        # Log in
        user_id = self.db.users.insert({
                'twitter_id': 'twitter1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'email_verified': True,
                'authorized_apps': ['app1', 'app2'],
                }, safe=True)
        self.set_user_cookie(str(user_id))

        res = self.testapp.post('/google-analytics-preference', {'yes': 'Yes'})
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.json, {'allow': True})
        user_refreshed = self.db.users.find_one({'_id': user_id}, safe=True)
        self.assertEqual(user_refreshed[USER_ATTR], True)

        res = self.testapp.post('/google-analytics-preference', {'no': 'No'})
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.json, {'allow': False})
        user_refreshed = self.db.users.find_one({'_id': user_id}, safe=True)
        self.assertEqual(user_refreshed[USER_ATTR], False)


class RESTViewTests(TestCase):

    clean_collections = ('users', 'access_codes', 'applications')

    def setUp(self):
        super(RESTViewTests, self).setUp()

        self.access_code = '1234'
        self.auth_header = {'Authorization': 'Bearer %s' % self.access_code}
        date = datetime.datetime(2012, 12, 12, 12, 12)
        self.user_id = self.db.users.insert({
                'provider_user_id': 'user1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'email_verified': True,
                'allow_google_analytics': True,
                'authorized_apps': [],
                'date_joined': date,
                'last_login': date,
                }, safe=True)
        self.db.applications.insert({
                'name': 'test-app',
                'client_id': 'client1',
                }, safe=True)
        self.db.access_codes.insert({
                'code': self.access_code,
                'scope': None,
                'user': self.user_id,
                'client_id': 'client1',
                }, safe=True)

    def test_user_options(self):
        res = self.testapp.options('/user')
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.body, b'')
        self.assertEqual(res.headers['Access-Control-Allow-Methods'],
                         'GET')
        self.assertEqual(res.headers['Access-Control-Allow-Headers'],
                         'Origin, Content-Type, Accept, Authorization')

    def test_user_get(self):
        res = self.testapp.get('/user', headers=self.auth_header)
        self.assertEqual(res.status, '200 OK')
        self.assertEqual(res.json, {
                '_id': str(self.user_id),
                'provider_user_id': 'user1',
                'screen_name': 'John Doe',
                'first_name': 'John',
                'last_name': 'Doe',
                'email': 'john@example.com',
                'email_verified': True,
                'allow_google_analytics': True,
                'authorized_apps': [],
                'date_joined': '2012-12-12T12:12:00+00:00',
                'last_login': '2012-12-12T12:12:00+00:00',
                })

########NEW FILE########
__FILENAME__ = utils
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from pyramid.httpexceptions import HTTPFound
from pyramid.security import remember

from yithlibraryserver.user.accounts import get_provider_key


def split_name(name):
    parts = name.split(' ')
    if len(parts) > 1:
        first_name = parts[0]
        last_name = ' '.join(parts[1:])
    else:
        first_name = parts[0]
        last_name = ''

    return first_name, last_name


def delete_user(db, user):
    result = db.users.remove(user['_id'], safe=True)
    return result['n'] == 1


def update_user(db, user, user_info, other_changes):
    changes = {}
    for attribute in ('screen_name', 'first_name', 'last_name', 'email'):
        if attribute in user_info and user_info[attribute]:
            if attribute in user:
                if user_info[attribute] != user[attribute]:

                    changes[attribute] = user_info[attribute]
            else:
                changes[attribute] = user_info[attribute]

    changes.update(other_changes)

    db.users.update({'_id': user['_id']}, {'$set': changes}, safe=True)


def user_from_provider_id(db, provider, user_id):
    provider_key = get_provider_key(provider)
    return db.users.find_one({provider_key: user_id})


def register_or_update(request, provider, user_id, info, default_url='/'):
    provider_key = get_provider_key(provider)
    user = user_from_provider_id(request.db, provider, user_id)
    if user is None:

        new_info = {'provider': provider, provider_key: user_id}
        for attribute in ('screen_name', 'first_name', 'last_name', 'email'):
            if attribute in info:
                new_info[attribute] = info[attribute]
            else:
                new_info[attribute] = ''

        request.session['user_info'] = new_info
        if 'next_url' not in request.session:
            request.session['next_url'] = default_url
        return HTTPFound(location=request.route_path('register_new_user'))
    else:
        changes = {'last_login': request.datetime_service.utcnow()}

        ga = request.google_analytics
        if ga.is_in_session():
            if not ga.is_stored_in_user(user):
                changes.update(ga.get_user_attr(ga.show_in_session()))
            ga.clean_session()

        update_user(request.db, user, info, changes)

        if 'next_url' in request.session:
            next_url = request.session['next_url']
            del request.session['next_url']
        else:
            next_url = default_url

        request.session['current_provider'] = provider
        remember_headers = remember(request, str(user['_id']))
        return HTTPFound(location=next_url, headers=remember_headers)

########NEW FILE########
__FILENAME__ = views
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

from deform import Button, Form, ValidationFailure

from pyramid.httpexceptions import HTTPBadRequest, HTTPFound
from pyramid.i18n import get_localizer
from pyramid.security import remember, forget
from pyramid.view import view_config, view_defaults, forbidden_view_config

from yithlibraryserver.backups.email import get_day_to_send
from yithlibraryserver.compat import url_quote
from yithlibraryserver.i18n import translation_domain
from yithlibraryserver.i18n import TranslationString as _
from yithlibraryserver.user import analytics
from yithlibraryserver.user.accounts import get_accounts, merge_accounts
from yithlibraryserver.user.accounts import notify_admins_of_account_removal
from yithlibraryserver.user.email_verification import EmailVerificationCode
from yithlibraryserver.user.schemas import UserSchema, NewUserSchema
from yithlibraryserver.user.schemas import AccountDestroySchema
from yithlibraryserver.user.schemas import UserPreferencesSchema
from yithlibraryserver.user.utils import delete_user
from yithlibraryserver.password.models import PasswordsManager
from yithlibraryserver.security import authorize_user


@view_config(route_name='login', renderer='templates/login.pt')
@forbidden_view_config(renderer='templates/login.pt')
def login(request):
    login_url = request.route_path('login')
    referrer = request.path
    if request.query_string:
        referrer += '?' + request.query_string
    if referrer == login_url:
        referrer = request.route_path('oauth2_clients')
    came_from = request.params.get('came_from', referrer)
    return {
        'identity_providers': request.registry.identity_providers,
        'next_url': url_quote(came_from),
        }


@view_config(route_name='register_new_user',
             renderer='templates/register.pt')
def register_new_user(request):
    try:
        user_info = request.session['user_info']
    except KeyError:
        return HTTPBadRequest('Missing user info in the session')

    try:
        next_url = request.session['next_url']
    except KeyError:
        next_url = request.route_url('oauth2_clients')

    schema = NewUserSchema()
    button1 = Button('submit', _('Register into Yith Library'))
    button1.css_class = 'btn-primary'
    button2 = Button('cancel', _('Cancel'))
    button2.css_class = ''

    form = Form(schema, buttons=(button1, button2))

    if 'submit' in request.POST:

        controls = request.POST.items()
        try:
            appstruct = form.validate(controls)
        except ValidationFailure as e:
            return {
                'form': e.render(),
                'provider': user_info.get('provider', ''),
                'email': user_info.get('email', ''),
                'next_url': next_url,
                }

        provider = user_info['provider']
        provider_key = provider + '_id'

        if (appstruct['email'] != ''
            and appstruct['email'] == user_info['email']):
            email_verified = True
        else:
            email_verified = False

        now = request.datetime_service.utcnow()

        user_attrs = {
                provider_key: user_info[provider_key],
                'screen_name': appstruct['screen_name'],
                'first_name': appstruct['first_name'],
                'last_name': appstruct['last_name'],
                'email': appstruct['email'],
                'email_verified': email_verified,
                'authorized_apps': [],
                'date_joined': now,
                'last_login': now,
                'send_passwords_periodically': False,
            }

        if request.google_analytics.is_in_session():
            allow_analytics = request.google_analytics.show_in_session()
            user_attrs[analytics.USER_ATTR] = allow_analytics
            request.google_analytics.clean_session()

        _id = request.db.users.insert(user_attrs, safe=True)

        if not email_verified and appstruct['email'] != '':
            evc = EmailVerificationCode()
            user = request.db.users.find_one({'_id': _id})
            if evc.store(request.db, user):
                link = request.route_url('user_verify_email')
                evc.send(request, user, link)

        del request.session['user_info']
        if 'next_url' in request.session:
            del request.session['next_url']

        request.session['current_provider'] = provider
        return HTTPFound(location=next_url,
                         headers=remember(request, str(_id)))
    elif 'cancel' in request.POST:
        del request.session['user_info']
        if 'next_url' in request.session:
            del request.session['next_url']

        return HTTPFound(location=next_url)

    return {
        'form': form.render({
                'first_name': user_info.get('first_name', ''),
                'last_name': user_info.get('last_name', ''),
                'screen_name': user_info.get('screen_name', ''),
                'email': user_info.get('email', ''),
                }),
        'provider': user_info.get('provider', ''),
        'email': user_info.get('email', ''),
        'next_url': next_url,
        }


@view_config(route_name='logout', renderer='string')
def logout(request):
    if 'current_provider' in request.session:
        del request.session['current_provider']

    return HTTPFound(location=request.route_path('home'),
                     headers=forget(request))


@view_config(route_name='user_destroy',
             renderer='templates/destroy.pt',
             permission='destroy-account')
def destroy(request):
    schema = AccountDestroySchema()
    button1 = Button('submit', _('Yes, I am sure. Destroy my account'))
    button1.css_class = 'btn-danger'
    button2 = Button('cancel', _('Cancel'))
    button2.css_class = ''

    form = Form(schema, buttons=(button1, button2))

    passwords_manager = PasswordsManager(request.db)
    context = {
        'passwords': passwords_manager.retrieve(request.user).count(),
        }

    if 'submit' in request.POST:

        controls = request.POST.items()
        try:
            appstruct = form.validate(controls)
        except ValidationFailure as e:
            context['form'] = e.render()
            return context

        reason = appstruct['reason']
        notify_admins_of_account_removal(request, request.user, reason)

        passwords_manager.delete(request.user)
        # TODO: remove user's applications
        delete_user(request.db, request.user)

        request.session.flash(
            _('Your account has been removed. Have a nice day!'),
            'success',
            )
        return logout(request)

    elif 'cancel' in request.POST:
        request.session.flash(
            _('Thanks for reconsidering removing your account!'),
            'info',
            )
        return HTTPFound(location=request.route_path('user_information'))

    context['form'] = form.render()
    return context


@view_config(route_name='user_information',
             renderer='templates/user_information.pt',
             permission='edit-profile')
def user_information(request):
    schema = UserSchema()
    button1 = Button('submit', _('Save changes'))
    button1.css_class = 'btn-primary'

    form = Form(schema, buttons=(button1, ))

    if 'submit' in request.POST:

        controls = request.POST.items()
        try:
            appstruct = form.validate(controls)
        except ValidationFailure as e:
            return {'form': e.render()}

        changes = {
            'first_name': appstruct['first_name'],
            'last_name': appstruct['last_name'],
            'screen_name': appstruct['screen_name'],
            'email': appstruct['email']['email'],
            }

        if request.user['email'] != appstruct['email']['email']:
            changes['email_verified'] = False

        result = request.db.users.update({'_id': request.user['_id']},
                                         {'$set': changes},
                                         safe=True)

        if result['n'] == 1:
            request.session.flash(
                _('The changes were saved successfully'),
                'success',
                )
            return HTTPFound(location=request.route_path('user_information'))
        else:
            request.session.flash(
                _('There were an error while saving your changes'),
                'error',
                )
            return {'form': appstruct}

    return {
        'form': form.render({
                'first_name': request.user['first_name'],
                'last_name': request.user['last_name'],
                'screen_name': request.user['screen_name'],
                'email': {
                    'email': request.user['email'],
                    'email_verified': request.user['email_verified'],
                    },
                }),
        }


@view_config(route_name='user_preferences',
             renderer='templates/preferences.pt',
             permission='edit-profile')
def preferences(request):
    schema = UserPreferencesSchema()
    button1 = Button('submit', _('Save changes'))
    button1.css_class = 'btn-primary'

    form = Form(schema, buttons=(button1, ))

    today = request.date_service.today()
    # use 28 to get a consistent day_to_send no matter what the
    # current month is. The disadvantage is that there are
    # several days in a regular month that are not used.
    day_to_send = get_day_to_send(request.user, 28)

    if day_to_send > today.day:
        day_to_send_msg = _(
            'You will receive your passwords backup on the day ${day} of this month',
            mapping={'day': day_to_send})
    elif day_to_send < today.day:
        day_to_send_msg = _(
            'You will receive your passwords backup on the day ${day} of next month',
            mapping={'day': day_to_send})
    else:
        day_to_send_msg = _(
            'You will receive your passwords backup today!',
            mapping={'day': day_to_send})

    if 'submit' in request.POST:
        controls = request.POST.items()
        try:
            appstruct = form.validate(controls)
        except ValidationFailure as e:
            return {'form': e.render(), 'day_to_send': day_to_send_msg}

        changes = dict([(pref, appstruct[pref]) for pref in (
                    analytics.USER_ATTR,
                    'send_passwords_periodically',
                    )])

        result = request.db.users.update({'_id': request.user['_id']},
                                         {'$set': changes},
                                         safe=True)

        if result['n'] == 1:
            request.session.flash(
                _('The changes were saved successfully'),
                'success',
                )
            return HTTPFound(location=request.route_path('user_preferences'))
        else:
            request.session.flash(
                _('There were an error while saving your changes'),
                'error',
                )
            return {'form': appstruct, 'day_to_send': day_to_send_msg}

    return {'form': form.render(request.user), 'day_to_send': day_to_send_msg}


@view_config(route_name='user_identity_providers',
             renderer='templates/identity_providers.pt',
             permission='edit-profile')
def identity_providers(request):
    current_provider = request.session.get('current_provider', None)
    accounts = get_accounts(request.db, request.user, current_provider)
    context = {
        'accounts': accounts
    }
    verified = [ac for ac in accounts if ac['is_verified']]
    context['can_merge'] = len(verified) > 1

    if 'submit' in request.POST:
        if not context['can_merge']:
            return HTTPBadRequest('You do not have enough accounts to merge')

        def is_verified(ac):
            for a in accounts:
                if a['id'] == ac:
                    return a['is_verified']
            return False

        accounts_to_merge = [account.replace('account-', '')
                             for account in request.POST.keys()
                             if account != 'submit']
        accounts_to_merge = [account
                             for account in accounts_to_merge
                             if is_verified(account)]

        if len(accounts_to_merge) > 1:
            merged = merge_accounts(request.db, request.user,
                                    accounts_to_merge)
            localizer = get_localizer(request)
            msg = localizer.pluralize(
                _('Congratulations, ${n_merged} of your accounts has been merged into the current one'),
                _('Congratulations, ${n_merged} of your accounts have been merged into the current one'),
                merged,
                domain=translation_domain,
                mapping={'n_merged': merged},
                )
            request.session.flash(msg, 'success')
        else:
            request.session.flash(
                _('Not enough accounts for merging'),
                'error',
                )

        return HTTPFound(
            location=request.route_path('user_identity_providers'))

    return context


@view_config(route_name='user_send_email_verification_code',
             renderer='json',
             permission='edit-profile')
def send_email_verification_code(request):
    if not request.user['email']:
        return {
            'status': 'bad',
            'error': 'You have not an email in your profile',
            }

    if 'submit' in request.POST:
        evc = EmailVerificationCode()
        if evc.store(request.db, request.user):
            link = request.route_url('user_verify_email')
            evc.send(request, request.user, link)
            return {'status': 'ok', 'error': None}
        else:
            return {
                'status': 'bad',
                'error': 'There were problems storing the verification code',
                }
    else:
        return {'status': 'bad', 'error': 'Not a post'}


@view_config(route_name='user_verify_email',
             renderer='templates/verify_email.pt')
def verify_email(request):
    try:
        code = request.params['code']
    except KeyError:
        return HTTPBadRequest('Missing code parameter')

    try:
        email = request.params['email']
    except KeyError:
        return HTTPBadRequest('Missing email parameter')

    evc = EmailVerificationCode(code)
    if evc.verify(request.db, email):
        request.session.flash(
            _('Congratulations, your email has been successfully verified'),
            'success',
            )
        evc.remove(request.db, email, True)
        return {
            'verified': True,
            }
    else:
        request.session.flash(
            _('Sorry, your verification code is not correct or has expired'),
            'error',
            )
        return {
            'verified': False,
            }


@view_config(route_name='user_google_analytics_preference', renderer='json')
def google_analytics_preference(request):
    if 'yes' in request.POST:
        allow = True
    elif 'no' in request.POST:
        allow = False
    else:
        return HTTPBadRequest('Missing preference parameter')

    if request.user is None:
        request.session[analytics.USER_ATTR] = allow
    else:
        changes = request.google_analytics.get_user_attr(allow)
        request.db.users.update({'_id': request.user['_id']},
                                {'$set': changes},
                                safe=True)

    return {'allow': allow}


@view_defaults(route_name='user_view', renderer='json')
class UserRESTView(object):

    def __init__(self, request):
        self.request = request

    @view_config(request_method='OPTIONS', renderer='string')
    def options(self):
        headers = self.request.response.headers
        headers['Access-Control-Allow-Methods'] = 'GET'
        headers['Access-Control-Allow-Headers'] = ('Origin, Content-Type, '
                                                   'Accept, Authorization')
        return ''

    @view_config(request_method='GET')
    def get(self):
        user = authorize_user(self.request)
        return user

########NEW FILE########
__FILENAME__ = utils
# Yith Library Server is a password storage server.
# Copyright (C) 2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.


def remove_attrs(dictionary, *attrs):
    """Returns a copy of dictionary without attrs"""
    result = {}

    for key, value in dictionary.items():
        if key not in attrs:
            result[key] = value

    return result

########NEW FILE########
__FILENAME__ = views
# Yith Library Server is a password storage server.
# Copyright (C) 2012-2013 Yaco Sistemas
# Copyright (C) 2012-2013 Alejandro Blanco Escudero <alejandro.b.e@gmail.com>
# Copyright (C) 2012-2013 Lorenzo Gil Sanchez <lorenzo.gil.sanchez@gmail.com>
#
# This file is part of Yith Library Server.
#
# Yith Library Server is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Yith Library Server is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Yith Library Server.  If not, see <http://www.gnu.org/licenses/>.

import logging

from deform import Button, Form, ValidationFailure

from pyramid.i18n import get_locale_name
from pyramid.httpexceptions import HTTPFound
from pyramid.renderers import render_to_response
from pyramid.view import view_config

from yithlibraryserver.email import send_email_to_admins
from yithlibraryserver.i18n import TranslationString as _
from yithlibraryserver.schemas import ContactSchema

log = logging.getLogger(__name__)


@view_config(route_name='home', renderer='templates/home.pt')
def home(request):
    return {}


@view_config(route_name='contact', renderer='templates/contact.pt')
def contact(request):
    button1 = Button('submit', _('Send message'))
    button1.css_class = 'btn-primary'
    button2 = Button('cancel', _('Cancel'))
    button2.css_class = ''

    form = Form(ContactSchema(), buttons=(button1, button2))

    if 'submit' in request.POST:
        controls = request.POST.items()
        try:
            appstruct = form.validate(controls)
        except ValidationFailure as e:
            return {'form': e.render()}

        context = {'link': request.route_url('contact')}
        context.update(appstruct)
        subject= ("%s sent a message from Yith's contact form"
                  % appstruct['name'])

        result = send_email_to_admins(
            request,
            'yithlibraryserver:templates/email_contact',
            context,
            subject,
            extra_headers={'Reply-To': appstruct['email']},
        )

        if result is None:
            log.error(
                '%s <%s> tried to send a message from the contact form but no '
                'admin emails were configured. Message: %s' % (
                    appstruct['name'],
                    appstruct['email'],
                    appstruct['message'],
                    )
                )

        request.session.flash(
            _('Thank you very much for sharing your opinion'),
            'info',
            )

        return HTTPFound(location=request.route_path('home'))

    elif 'cancel' in request.POST:
        return HTTPFound(location=request.route_path('home'))

    initial = {}
    if request.user is not None:
        initial['name'] = request.user.get('first_name', '')
        if request.user.get('email_verified', False):
            initial['email'] = request.user.get('email', '')

    return {'form': form.render(initial)}


@view_config(route_name='tos', renderer='templates/tos.pt')
def tos(request):
    return {}


@view_config(route_name='faq', renderer='string')
def faq(request):
    # We don't want to mess up the gettext .po file
    # with a lot of strings which don't belong to the
    # application interface.
    #
    # We consider the FAQ as application content
    # so we simple use a different template for each
    # language. When a new locale is added to the
    # application it needs to translate the .po files
    # as well as this template
    locale_name = get_locale_name(request)
    template = 'yithlibraryserver:templates/faq-%s.pt' % locale_name

    return render_to_response(template, {}, request=request)

########NEW FILE########
