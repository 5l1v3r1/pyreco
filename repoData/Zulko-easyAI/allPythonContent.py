__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# easyAI documentation build configuration file, created by
# sphinx-quickstart on Sat Dec 14 13:19:53 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.mathjax', 'sphinx.ext.viewcode', 'numpydoc']
numpydoc_show_class_members = False

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'easyAI'
copyright = u'2014, Zulko'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.0.0.1'
# The full version, including alpha/beta/rc tags.
release = '0.0.0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
sys.path.append(os.path.abspath('_themes'))
sys.path.append("../easyAI")
html_theme_path = ['_themes']
html_theme = 'kr'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'easyAIdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'easyAI.tex', u'easyAI Documentation',
   u'Zulko', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'easyai', u'easyAI Documentation',
     [u'Zulko'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'easyAI', u'easyAI Documentation',
   u'Zulko', 'easyAI', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = flask_theme_support
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        #Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",      # class: 'w'
        Error:                     "#a40000 border:#ef2929", # class: 'err'
        Other:                     "#000000",                # class 'x'

        Comment:                   "italic #8f5902", # class: 'c'
        Comment.Preproc:           "noitalic",       # class: 'cp'

        Keyword:                   "bold #004461",   # class: 'k'
        Keyword.Constant:          "bold #004461",   # class: 'kc'
        Keyword.Declaration:       "bold #004461",   # class: 'kd'
        Keyword.Namespace:         "bold #004461",   # class: 'kn'
        Keyword.Pseudo:            "bold #004461",   # class: 'kp'
        Keyword.Reserved:          "bold #004461",   # class: 'kr'
        Keyword.Type:              "bold #004461",   # class: 'kt'

        Operator:                  "#582800",   # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",        # class: 'n'
        Name.Attribute:            "#c4a000",        # class: 'na' - to be revised
        Name.Builtin:              "#004461",        # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",        # class: 'bp'
        Name.Class:                "#000000",        # class: 'nc' - to be revised
        Name.Constant:             "#000000",        # class: 'no' - to be revised
        Name.Decorator:            "#888",           # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",        # class: 'ni'
        Name.Exception:            "bold #cc0000",   # class: 'ne'
        Name.Function:             "#000000",        # class: 'nf'
        Name.Property:             "#000000",        # class: 'py'
        Name.Label:                "#f57900",        # class: 'nl'
        Name.Namespace:            "#000000",        # class: 'nn' - to be revised
        Name.Other:                "#000000",        # class: 'nx'
        Name.Tag:                  "bold #004461",   # class: 'nt' - like a keyword
        Name.Variable:             "#000000",        # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",        # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",        # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",        # class: 'vi' - to be revised

        Number:                    "#990000",        # class: 'm'

        Literal:                   "#000000",        # class: 'l'
        Literal.Date:              "#000000",        # class: 'ld'

        String:                    "#4e9a06",        # class: 's'
        String.Backtick:           "#4e9a06",        # class: 'sb'
        String.Char:               "#4e9a06",        # class: 'sc'
        String.Doc:                "italic #8f5902", # class: 'sd' - like a comment
        String.Double:             "#4e9a06",        # class: 's2'
        String.Escape:             "#4e9a06",        # class: 'se'
        String.Heredoc:            "#4e9a06",        # class: 'sh'
        String.Interpol:           "#4e9a06",        # class: 'si'
        String.Other:              "#4e9a06",        # class: 'sx'
        String.Regex:              "#4e9a06",        # class: 'sr'
        String.Single:             "#4e9a06",        # class: 's1'
        String.Symbol:             "#4e9a06",        # class: 'ss'

        Generic:                   "#000000",        # class: 'g'
        Generic.Deleted:           "#a40000",        # class: 'gd'
        Generic.Emph:              "italic #000000", # class: 'ge'
        Generic.Error:             "#ef2929",        # class: 'gr'
        Generic.Heading:           "bold #000080",   # class: 'gh'
        Generic.Inserted:          "#00A000",        # class: 'gi'
        Generic.Output:            "#888",           # class: 'go'
        Generic.Prompt:            "#745334",        # class: 'gp'
        Generic.Strong:            "bold #000000",   # class: 'gs'
        Generic.Subheading:        "bold #800080",   # class: 'gu'
        Generic.Traceback:         "bold #a40000",   # class: 'gt'
    }

########NEW FILE########
__FILENAME__ = DictTT
"""
This module implements transposition tables, which store positions
and moves to speed up the AI.
"""

import pickle

class DictTT:
    """
    A tranposition table made out of a Python dictionnary.
    It can only be used on games which have a method
    game.ttentry() -> string, or tuple
    
    Usage:
        
        >>> table = DicTT()  
        >>> ai = Negamax(8, scoring, tt = table) # boosted Negamax !
        >>> ai(some_game) # computes a move, fills the table
        >>> table.to_file('saved_tt.data') # maybe save for later ?
        
        >>> # later...
        >>> table = DictTT.fromfile('saved_tt.data')
        >>> ai = Negamax(8, scoring, tt = table) # boosted Negamax !
    
    Transposition tables can also be used as an AI (``AI_player(tt)``)
    but they must be exhaustive in this case: if they are asked for
    a position that isn't stored in the table, it will lead to an error.
    
    """
    
    def __init__(self):
        self.d = dict()
        
    def lookup(self, game):
        """ Requests the entry in the table. Returns None if the
            entry has not been previously stored in the table. """
        return self.d.get(game.ttentry(), None)
        
    def __call__(self,game):
        """
        This method enables the transposition table to be used
        like an AI algorithm. However it will just break if it falls
        on some game state that is not in the table. Therefore it is a
        better option to use a mixed algorithm like
        
        >>> # negamax boosted with a transposition table !
        >>> Negamax(10, tt= my_dictTT) 
        """
        
        return self.d[game.ttentry()]['move']
        
    def store(self, **data):
        """ Stores an entry into the table """
        entry = data.pop("game").ttentry()
        self.d[entry] = data
        
    def tofile(self, filename):
        """ Saves the transposition table to a file. Warning: the file
            can be big (~100Mo). """
        with open(filename, 'w+') as f:
            pickle.dump(self, f)
    
    @staticmethod
    def fromfile(self, filename):
        """ Loads a transposition table previously saved with
             ``DictTT.tofile`` """
        with open(filename, 'r') as f:
            pickle.load(self, filename)

########NEW FILE########
__FILENAME__ = Negamax
"""
The standard AI algorithm of easyAI is Negamax with alpha-beta pruning
and (optionnally), transposition tables.
"""

import pickle
        
LOWERBOUND, EXACT, UPPERBOUND = -1,0,1
inf = float('infinity')

def negamax(game, depth, origDepth, scoring, alpha=+inf, beta=-inf,
             tt=None):
    """
    This implements Negamax with transposition tables.
    This method is not meant to be used directly. See ``easyAI.Negamax``
    for an example of practical use.
    This function is implemented (almost) acccording to
    http://en.wikipedia.org/wiki/Negamax
    """
    
    alphaOrig = alpha
    
    # Is there a transposition table and is this game in it ?
    lookup = None if (tt is None) else tt.lookup(game)
    
    if lookup != None:
        # The game has been visited in the past
        
        if lookup['depth'] >= depth:
            flag, value = lookup['flag'], lookup['value']
            if flag == EXACT:
                if depth == origDepth:
                    game.ai_move = lookup['move']
                return value
            elif flag == LOWERBOUND:
                alpha = max( alpha, value)
            elif flag == UPPERBOUND:
                beta = min( beta, value)
                
            if alpha >= beta:
                if depth == origDepth:
                    game.ai_move = lookup['move']
                return value
        
        
        
    
    if (depth == 0) or game.is_over():
        score = scoring(game)
        if score == 0:
            return score
        else:
            return  (score - 0.01*depth*abs(score)/score)
    
    
    if lookup != None:
        # Put the supposedly best move first in the list
        possible_moves = game.possible_moves()
        possible_moves.remove(lookup['move'])
        possible_moves = [lookup['move']] + possible_moves
        
    else:
        
        possible_moves = game.possible_moves()
    
    
    
    state = game
    best_move = possible_moves[0]
    if depth == origDepth:
        state.ai_move = possible_moves[0]
        
    bestValue = -inf
    unmake_move = hasattr(state, 'unmake_move')
    
    
    for move in possible_moves:
        
        if not unmake_move:
            game = state.copy() # re-initialize move
        
        game.make_move(move)
        game.switch_player()
        
        move_alpha = - negamax(game, depth-1, origDepth, scoring,
                               -beta, -alpha, tt)
        
        if unmake_move:
            game.switch_player()
            game.unmake_move(move)
        
        bestValue = max( bestValue,  move_alpha )
        if  alpha < move_alpha :
                alpha = move_alpha
                best_move = move
                if depth == origDepth:
                    state.ai_move = move
                if (alpha >= beta):
                    break
        
    if tt != None:
        
        assert best_move in possible_moves
        tt.store(game=state, depth=depth, value = bestValue,
                 move= best_move,
                 flag = UPPERBOUND if (bestValue <= alphaOrig) else (
                        LOWERBOUND if (bestValue >= beta) else EXACT))

    return bestValue

        
class Negamax:
    """
    This implements Negamax on steroids. The following example shows
    how to setup the AI and play a Connect Four game:
    
        >>> from easyAI.games import ConnectFour
        >>> from easyAI import Negamax, Human_Player, AI_Player
        >>> scoring = lambda game: -100 if game.lose() else 0
        >>> ai_algo = Negamax(8, scoring) # AI will think 8 turns in advance
        >>> game = ConnectFour([Human_Player(), AI_Player(ai_algo)])
        >>> game.play()
    
    Parameters
    -----------
    
    depth:
      How many moves in advance should the AI think ?
      (2 moves = 1 complete turn)
    
    scoring:
      A function f(game)-> score. If no scoring is provided
         and the game object has a ``scoring`` method it ill be used.
    
    win_score:
      Score above which the score means a win. This will be
        used to speed up computations if provided, but the AI will not
        differentiate quick defeats from long-fought ones (see next
        section).
        
    tt:
      A transposition table (a table storing game states and moves)
      scoring: can be none if the game that the AI will be given has a
      ``scoring`` method.
      
    Notes
    -----
   
    The score of a given game is given by
    
    >>> scoring(current_game) - 0.01*sign*current_depth
    
    for instance if a lose is -100 points, then losing after 4 moves
    will score -99.96 points but losing after 8 moves will be -99.92
    points. Thus, the AI will chose the move that leads to defeat in
    8 turns, which makes it more difficult for the (human) opponent.
    This will not always work if a ``win_score`` argument is provided.
    
    """
    
    
    def __init__(self, depth, scoring=None, win_score=+inf, tt=None):
        self.scoring = scoring        
        self.depth = depth
        self.tt = tt
        self.win_score= win_score
    
    
    
    def __call__(self,game):
        """
        Returns the AI's best move given the current state of the game.
        """
        
        scoring = self.scoring if self.scoring else (
                       lambda g: g.scoring() ) # horrible hack
                       
        self.alpha = negamax(game, self.depth, self.depth, scoring,
                     -self.win_score, +self.win_score, self.tt)
        return game.ai_move

########NEW FILE########
__FILENAME__ = solving
from easyAI.AI import DictTT, Negamax
from easyAI.Player import AI_Player

def id_solve(game, ai_depths, win_score, scoring=None,
          tt=None, verbose=True):
    """
    Solves a game using iterative deepening, i.e. determines if by playing
    perfectly the first player can force a win, or whether it will always
    lose against a perfect opponent.
    
    
    This algorithm explores the game by using several times the Negamax
    algorithm, always starting at the initial state of the game, but
    taking increasing depth (in the list ai_depths) until the score of
    the initial condition indicates that the first player will certainly
    win or loose, in which case it stops.
    The use of transposition table leads to speed gain as the results
    of shallower searches are used to help exploring the deeper ones.
        
    Parameters
    -----------
    
    ai_depths:
      List of AI depths to try (e.g. [5,6,7,8,9,10])
      
      
    win_score:
      Score above which a score means a win.
    
    scoring:
      Scoring function (see doc of class Negamax)
    
    tt:
      An optional transposition table to speed up computations.
    
    verbose:
      If set to ``True``, will print a summary of the best move
      after each depth tried.
        
    Returns
    --------
    
    (result, depth, move, tt):
      As below
    
    result: 
      Either 1 (certain victory of the first player) or -1
      (certain defeat) or 0 (either draw, or the search was not
      deep enough)
      
    depth:
      The minimal number of moves before victory (or defeat)
    
    move:
      Best move to play for the first player.
    
    tt:
      Will be None if ``use_tt`` was set to false, else will be a
      transposition table containing all the relevant situations to play
      a perfect game and can be used with ``AI_player(tt)``
      
    """
    
    if not hasattr(game, 'players'): # the user provided a Game class
        game = game(players = [AI_Player(None), AI_Player(None)])
    
    for depth in ai_depths:
        ai = Negamax(depth, scoring, tt= tt)
        ai(game)
        alpha = ai.alpha
        if verbose:
             print( "d:%d, a:%d, m:%s"%(depth, alpha, str(game.ai_move)))
        if abs(alpha) >= win_score:
            break
    
    # 1:win, 0:draw, -1:defeat
    result = (+1 if alpha>= win_score else (
             -1 if alpha <= -win_score else 0))
    
    return result, depth, game.ai_move


def df_solve(game, win_score, maxdepth=50, tt=None, depth=0):
    """ 
    Solves a game using a depth-first search: the game is explored until
    endgames are reached.
    
    The endgames are evaluated to see if their are victories or defeats.
    Then, a situation in which every move leads to a defeat is labelled
    as a (certain) defeat, and a situation in which one move leads to a
    (certain) defeat of the opponent is labelled as a (certain) victory.
    Situations are evaluated until the initial condition receives a label
    (victory or defeat). Draws are also possible.
    
    This algorithm can be faster but less informative than ``id_solve``,
    as it does not provide 'optimal' strategies (like shortest path to
    the victory). It returns simply 1, 0, or -1 to indicate certain
    victory, draw, or defeat of the first player.
        
    Parameters
    -----------
    
    game:
      An Game instance, initialized and ready to be played.
      
    win_score:
      Score above which a score means a win.
    
    maxdepth:
      Maximal recursion depth allowed.
    
    tt:
      An optional transposition table to speed up computations.
      
    
    depth:
      Index of the current depth (don't touch that).
      
    Returns
    --------
    
    result
      Either 1 (certain victory of the first player) or -1
      (certain defeat) or 0 (either draw, or the search was not
      deep enough)
    
    """
    
    
    # Is there a transposition table and is this game in it ?
    lookup = None if (tt is None) else tt.lookup(game)
    if lookup != None:
        return lookup['value']
        
    if (depth == maxdepth):
        raise "Max recursion depth reached :("
    
    if game.is_over():
        score = game.scoring()
        value = 1 if (score>=win_score) else (-1 if -score>=win_score else 0)
        tt.store(game=game, value=value, move=None)
        return  value
    
    possible_moves = game.possible_moves()
    
    state = game
    unmake_move = hasattr(state, 'unmake_move')
    
    best_value, best_move = -1, None
    
    for move in possible_moves:
        
        if not unmake_move:
            game = state.copy() # re-initialize move
        
        game.make_move(move)
        game.switch_player()
        
        move_value = - df_solve(game,  win_score,  maxdepth, tt, depth+1)
        
        if unmake_move:
            game.switch_player()
            game.unmake_move(move)
        
        if move_value == 1:
            tt.store(game=state, value=1, move=move)
            return move_value
        
        if move_value == 0 and best_value==-1:
            # Is forcing a draw possible ?
            best_value = 0
            best_move = move
    
    tt.store(game=state, value=best_value, move=best_move)
    
    return best_value

########NEW FILE########
__FILENAME__ = Awele
try:
    import numpy as np
except ImportError:
    print("Sorry, this example requires Numpy installed !")
    raise

from easyAI import TwoPlayersGame


class Awele(TwoPlayersGame):
    """
    Rules are as defined as in http://en.wikipedia.org/wiki/Oware
    with the additional rule that the game ends when then are 6 seeds
    left in the game.
    """

    def __init__(self, players):
        for i, player in enumerate(players):
            player.score = 0
            player.isstarved = False
            player.camp = i
        self.players = players
        
        # Initial configuration of the board.
        # holes are indexed by a,b,c,d...
        self.board = [4, 4, 4, 4, 4, 4,  
                      4, 4, 4, 4, 4, 4]  
                      
        self.nplayer = 1  # player 1 starts.

    def make_move(self, move):
        if move == "None":
            self.player.isstarved = True
            s = 6 * self.opponent.camp
            self.player.score += sum(self.board[s:s + 6])
            return

        move = 'abcdefghijkl'.index(move)

        pos = move
        for i in range(self.board[move]):  #DEAL
            pos = (pos + 1) % 12
            if pos == move:
                pos = (pos + 1) % 12
            self.board[pos] += 1

        self.board[move] = 0

        while ((pos / 6) == self.opponent.camp
               and (self.board[pos] in [2, 3])):  # TAKE
            self.player.score += self.board[pos]
            self.board[pos] = 0
            pos = (pos - 1) % 12

    def possible_moves(self):
        """
        A player must play any hole that contains enough seeds to
        'feed' the opponent. This no hole has this many seeds, any
        non-empty hole can be played.
        """

        if self.nplayer == 1:
            if max(self.board[:6]) == 0: return ['None']
            moves = [i for i in range(6) if (self.board[i] >= 6 - i)]
            if moves == []:
                moves = [i for i in range(6) if self.board[i] != 0]
        else:
            if max(self.board[6:]) == 0: return ['None']
            moves = [i for i in range(6,12) if (self.board[i] >= 12-i)]
            if moves == []:
                moves = [i for i in range(6, 12) if self.board[i] != 0]

        return ['abcdefghijkl'[u] for u in moves]

    def show(self):
        """ Prints the board, with the hole's respective letters """

        print("Score: %d / %d" % tuple(p.score for p in self.players))
        print('  '.join('lkjihg'))
        print(' '.join(["%02d" % i for i in self.board[-1:-7:-1]]))
        print(' '.join(["%02d" % i for i in self.board[:6]]))
        print('  '.join('abcdef'))

    def lose(self):
        return self.opponent.score > 24

    def is_over(self):
        return ( self.lose() or
                  sum(self.board) < 7 or
                  self.opponent.isstarved )


if __name__ == "__main__":
    # In what follows we setup the AI and launch a AI-vs-AI match.

    from easyAI import Human_Player, AI_Player, Negamax

    # this shows that the scoring can be defined in the AI algo, 
    # which enables 2 AIs with different scorings to play a match.
    scoring = lambda game: game.player.score - game.opponent.score
    ai = Negamax(6, scoring)
    game = Awele([AI_Player(ai), AI_Player(ai)])

    game.play()

    if game.player.score > game.opponent.score:
        print("Player %d wins." % game.nplayer)
    elif game.player.score < game.opponent.score:
        print("Player %d wins." % game.nopponent)
    else:
        print("Looks like we have a draw.")

########NEW FILE########
__FILENAME__ = ConnectFour
try:
    import numpy as np
except ImportError:
    print("Sorry, this example requires Numpy installed !")
    raise

from easyAI import TwoPlayersGame


class ConnectFour(TwoPlayersGame):
    """
    The game of Connect Four, as described here:
    http://en.wikipedia.org/wiki/Connect_Four
    """

    def __init__(self, players, board = None):
        self.players = players
        self.board = board if (board != None) else (
            np.array([[0 for i in range(7)] for j in range(6)]))
        self.nplayer = 1 # player 1 starts.

    def possible_moves(self):
        return [i for i in range(7) if (self.board[:, i].min() == 0)]

    def make_move(self, column):
        line = np.argmin(self.board[:, column] != 0)
        self.board[line, column] = self.nplayer

    def show(self):
        print('\n' + '\n'.join(
                        ['0 1 2 3 4 5 6', 13 * '-'] +
                        [' '.join([['.', 'O', 'X'][self.board[5 - j][i]]
                        for i in range(7)]) for j in range(6)]))

    def lose(self):
        return find_four(self.board, self.nopponent)

    def is_over(self):
        return (self.board.min() > 0) or self.lose()

    def scoring(self):
        return -100 if self.lose else 0


def find_four(board, nplayer):
    """
    Returns True iff the player has connected  4 (or more)
    This is much faster if written in C or Cython
    """
    for pos, direction in POS_DIR:
        streak = 0
        while (0 <= pos[0] <= 5) and (0 <= pos[1] <= 6):
            if board[pos[0], pos[1]] == nplayer:
                streak += 1
                if streak == 4:
                    return True
            else:
                streak = 0
            pos = pos + direction
    return False


POS_DIR = np.array([[[i, 0], [0, 1]] for i in range(6)] +
                   [[[0, i], [1, 0]] for i in range(7)] +
                   [[[i, 0], [1, 1]] for i in range(1, 3)] +
                   [[[0, i], [1, 1]] for i in range(4)] +
                   [[[i, 6], [1, -1]] for i in range(1, 3)] +
                   [[[0, i], [1, -1]] for i in range(3, 7)])

if __name__ == '__main__':
    # LET'S PLAY !

    from easyAI import Human_Player, AI_Player, Negamax

    AI = Negamax(7, win_score=80)
    game = ConnectFour([Human_Player(), AI_Player(AI)])
    game.play()
    if game.lose():
        print("Player %d wins." % (game.nopponent))
    else:
        print("Looks like we have a draw.")

########NEW FILE########
__FILENAME__ = Cram
import numpy as np
from easyAI import TwoPlayersGame


# directions in which a knight can move
DIRECTIONS = list(map(np.array, [[1, 2], [-1, 2], [1, -2], [-1, -2],
                                 [2, 1], [2, -1], [-2, 1], [-2, -1]]))


# functions to convert "D8" into (3,7) and back...
pos2string = lambda a: "ABCDEFGH"[a[0]] + str(a[1] + 1)
string2pos = lambda s: ["ABCDEFGH".index(s[0]), int(s[1]) - 1]

mov2string = lambda m: pos2string((m[0], m[1])) + " " + pos2string((m[2], m[3]))


def string2mov(s):
    poss = [string2pos(p) for p in s.split(" ")]
    return poss[0] + poss[1]


class Cram(TwoPlayersGame):
    """
    Players place a domino on the grid (provide x1,y1,x2,y2)
    """

    def __init__(self, players, board_size = (6, 6)):
        self.players = players
        self.board_size = board_size
        self.board = np.zeros(board_size, dtype = int)
        self.nplayer = 1 # player 1 starts.

    def possible_moves(self):
        moves = []
        for i in range(self.board_size[0]):
            for j in range(self.board_size[1]):
                if self.board[i, j] == 0:
                    if (i + 1) < self.board_size[0] and self.board[i + 1, j] == 0:
                        moves.append([i, j, i + 1, j])
                    if (j + 1) < self.board_size[1] and self.board[i, j + 1] == 0:
                        moves.append([i, j, i, j + 1])
        return list(map(mov2string, moves))

    def make_move(self, move):
        move = string2mov(move)
        self.board[move[0], move[1]] = 1
        self.board[move[2], move[3]] = 1

    def unmake_move(self, move):
        move = string2mov(move)
        self.board[move[0], move[1]] = 0
        self.board[move[2], move[3]] = 0

    def show(self):
        print('\n' + '\n'.join(['  1 2 3 4 5 6 7 8'] + ['ABCDEFGH'[k] +
                                                        ' ' + ' '.join(['.*'[self.board[k, i]]
                                                        for i in range(self.board_size[0])])
                                                        for k in range(self.board_size[1])] + ['']))

    def lose(self):
        return self.possible_moves() == []

    def scoring(self):
        return -100 if (self.possible_moves() == []) else 0

    def is_over(self):
        return self.lose()


if __name__ == "__main__":
    from easyAI import AI_Player, Negamax

    ai_algo = Negamax(6)
    game = Cram([AI_Player(ai_algo), AI_Player(ai_algo)], (5, 5))
    game.play()
    print("player {%d} loses".format(game.nplayer))
########NEW FILE########
__FILENAME__ = GameOfBones
""" This is the example featured in section 'A quick example' of the docs """

from easyAI import TwoPlayersGame


class GameOfBones(TwoPlayersGame):
    """ In turn, the players remove one, two or three bones from a
    pile of bones. The player who removes the last bone loses. """

    def __init__(self, players):
        self.players = players
        self.pile = 20 # start with 20 bones in the pile
        self.nplayer = 1 # player 1 starts

    def possible_moves(self): return ['1', '2', '3']

    def make_move(self, move): self.pile -= int(move) # remove bones.

    def win(self): return self.pile <= 0 # opponent took the last bone ?

    def is_over(self): return self.win() # game stops when someone wins.

    def scoring(self): return 100 if self.win() else 0

    def show(self): print("%d bones left in the pile" % (self.pile))


if __name__ == "__main__":
    """
    Start a match (and store the history of moves when it ends)
    ai = Negamax(10) # The AI will think 10 moves in advance 
    game = GameOfBones( [ AI_Player(ai), Human_Player() ] )
    history = game.play()
    """

    # Let's solve the game

    from easyAI import id_solve, DictTT, Human_Player, AI_Player

    tt = DictTT()
    GameOfBones.ttentry = lambda self: self.pile
    r, d, m = id_solve(GameOfBones, range(2, 20), win_score = 100, tt = tt)
    print(r, d, m)  # see the docs.

    # Unbeatable AI !

    game = GameOfBones([AI_Player(tt), Human_Player()])
    game.play() # you will always lose this game :)

########NEW FILE########
__FILENAME__ = Hexapawn
from easyAI import TwoPlayersGame

# Convert D7 to (3,6) and back...
to_string = lambda move: " ".join(["ABCDEFGHIJ"[move[i][0]] + str(move[i][1] + 1)
                                   for i in (0, 1)])
to_tuple = lambda s: ("ABCDEFGHIJ".index(s[0]), int(s[1:]) - 1)


class Hexapawn(TwoPlayersGame):
    """
    A nice game whose rules are explained here:
    http://fr.wikipedia.org/wiki/Hexapawn
    """

    def __init__(self, players, size = (4, 4)):
        self.size = M, N = size
        p = [[(i, j) for j in range(N)] for i in [0, M - 1]]

        for i, d, goal, pawns in [(0, 1, M - 1, p[0]), (1, -1, 0, p[1])]:
            players[i].direction = d
            players[i].goal_line = goal
            players[i].pawns = pawns

        self.players = players
        self.nplayer = 1

    def possible_moves(self):
        moves = []
        opponent_pawns = self.opponent.pawns
        d = self.player.direction
        for i, j in self.player.pawns:
            if (i + d, j) not in opponent_pawns:
                moves.append(((i, j), (i + d, j)))
            if (i + d, j + 1) in opponent_pawns:
                moves.append(((i, j), (i + d, j + 1)))
            if (i + d, j - 1) in opponent_pawns:
                moves.append(((i, j), (i + d, j - 1)))

        return list(map(to_string, [(i, j) for i, j in moves]))

    def make_move(self, move):
        move = list(map(to_tuple, move.split(' ')))
        ind = self.player.pawns.index(move[0])
        self.player.pawns[ind] = move[1]

        if move[1] in self.opponent.pawns:
            self.opponent.pawns.remove(move[1])

    def lose(self):
        return ( any([i == self.opponent.goal_line
                      for i, j in self.opponent.pawns])
                 or (self.possible_moves() == []) )

    def is_over(self):
        return self.lose()

    def show(self):
        f = lambda x: '1' if x in self.players[0].pawns else (
            '2' if x in self.players[1].pawns else '.')
        print("\n".join([" ".join([f((i, j))
                                   for j in range(self.size[1])])
                         for i in range(self.size[0])]))


if __name__ == "__main__":
    from easyAI import AI_Player, Human_Player, Negamax

    scoring = lambda game: -100 if game.lose() else 0
    ai = Negamax(10, scoring)
    game = Hexapawn([AI_Player(ai), AI_Player(ai)])
    game.play()
    print("player %d wins after %d turns " % (game.nopponent, game.nmove))

########NEW FILE########
__FILENAME__ = Knights
import numpy as np
from easyAI import TwoPlayersGame


# directions in which a knight can move
DIRECTIONS = list(map(np.array, [[1, 2], [-1, 2], [1, -2], [-1, -2],
                            [2, 1], [2, -1], [-2, 1], [-2, -1]]))

# functions to convert "D8" into (3,7) and back...
pos2string = lambda ab: "ABCDEFGH"[ab[0]] + str(ab[1] + 1)
string2pos = lambda s: np.array(["ABCDEFGH".index(s[0]), int(s[1])-1])


class Knights(TwoPlayersGame):
    """
    Each player has a chess knight (that moves in "L") on a chessboard.
    Each turn the player moves the knight to any tile that hasn't been
    occupied by a knight before. The first player that cannot move loses.
    """

    def __init__(self, players, board_size = (8, 8)):
        self.players = players
        self.board_size = board_size
        self.board = np.zeros(board_size, dtype = int)
        self.board[0, 0] = 1
        self.board[board_size[0] - 1, board_size[1] - 1] = 2
        players[0].pos = np.array([0, 0])
        players[1].pos = np.array([board_size[0] - 1, board_size[1]-1])
        self.nplayer = 1 # player 1 starts.

    def possible_moves(self):
        endings = [self.player.pos + d for d in DIRECTIONS]
        return [pos2string(e) for e in endings # all positions
                if (e[0] >= 0) and (e[1] >= 0) and
                   (e[0] < self.board_size[0]) and
                   (e[1] < self.board_size[1]) and # inside the board
                   self.board[e[0], e[1]] == 0] # and not blocked

    def make_move(self, pos):
        pi, pj = self.player.pos
        self.board[pi, pj] = 3 # 3 means blocked
        self.player.pos = string2pos(pos)
        pi, pj = self.player.pos
        self.board[pi, pj] = self.nplayer # place player on board

    def show(self):
        print('\n' + '\n'.join(['  1 2 3 4 5 6 7 8'] +
              ['ABCDEFGH'[k] + 
               ' ' + ' '.join([['.', '1', '2', 'X'][self.board[k, i]]
               for i in range(self.board_size[0])])
               for k in range(self.board_size[1])] + ['']))

    def lose(self):
        return self.possible_moves() == []

    def scoring(self):
        return -100 if (self.possible_moves() == []) else 0

    def is_over(self):
        return self.lose()


if __name__ == "__main__":
    from easyAI import AI_Player, Negamax

    ai_algo = Negamax(11)
    game = Knights([AI_Player(ai_algo), AI_Player(ai_algo)], (5, 5))
    game.play()
    print("player %d loses" % (game.nplayer))

########NEW FILE########
__FILENAME__ = Nim
from easyAI import TwoPlayersGame


class Nim(TwoPlayersGame):
    """
    The game starts with 4 piles of 5 pieces. In turn the players
    remove as much pieces as they want, but from one pile only. The
    player that removes the last piece loses.
    
    Arguments:
    
    - players: the players...
    - piles: the piles the game starts with. With piles=[2,3,4,4] the
      game will start with 1 pile of 2 pieces, 1 pile of 3 pieces, and 2
      piles of 4 pieces. If set to None, the default will be [5,5,5,5]
      
    """

    def __init__(self, players, piles = None):
        """ Default for `piles` is 5 piles of 5 pieces. """
        self.players = players
        self.piles = piles if (piles != None) else [5, 5, 5, 5]
        self.nplayer = 1 # player 1 starts.

    def possible_moves(self):
        return ["%d,%d" % (i + 1, j) for i in range(len(self.piles))
                for j in range(1, self.piles[i] + 1)]

    def make_move(self, move):
        move = list(map(int, move.split(',')))
        self.piles[move[0] - 1] -= move[1]

    def unmake_move(self, move): # optional, speeds up the AI
        move = list(map(int, move.split(',')))
        self.piles[move[0] - 1] += move[1]

    def show(self): print(" ".join(map(str, self.piles)))

    def win(self): return max(self.piles) == 0

    def is_over(self): return self.win()

    def scoring(self): return 100 if self.win() else 0

    def ttentry(self): return tuple(self.piles) #optional, speeds up AI


if __name__ == "__main__":
    # IN WHAT FOLLOWS WE SOLVE THE GAME AND START A MATCH AGAINST THE AI

    from easyAI import AI_Player, Human_Player, Negamax, DictTT, id_solve
    # we first solve the game
    w, d, m, tt = id_solve(Nim, range(5, 20), win_score = 80)
    print
    w, d, len(tt.d)
    # the previous line prints -1, 16 which shows that if the
    # computer plays second with an AI depth of 16 (or 15) it will
    # always win in 16 (total) moves or less.

    # Now let's play (and lose !) against the AI
    ai = Negamax(16, tt = DictTT())
    game = Nim([Human_Player(), AI_Player(tt)])
    game.play() # You will always lose this game !
    print("player %d wins" % game.nplayer)

    # Note that with the transposition table tt generated by id_solve
    # we can setup a perfect AI which doesn't have to think:
    # >>> game = Nim( [ Human_Player(), AI_Player( tt )])
    # >>> game.play() # You will always lose this game too!

########NEW FILE########
__FILENAME__ = Reversi
"""
The game of Reversi. Warning: this game is not coded in an optimal
way, the AI will be slow.
"""

import numpy as np
from easyAI import TwoPlayersGame

to_string = lambda a : "ABCDEFGH"[a[0]] + str(a[1]+1)
to_array = lambda s : np.array(["ABCDEFGH".index(s[0]),int(s[1])-1])

class Reversi( TwoPlayersGame ):
    """
    See the rules on http://en.wikipedia.org/wiki/Reversi
    Here for simplicity we suppose that the game ends when a
    player cannot play, but it would take just a few more lines to
    implement the real ending rules, by which the game ends when both
    players can't play.
    
    This implementation will make a slow and dumbe AI and could be sped
    up by adding a way of unmaking moves (method unmake_moves) and
    coding some parts in C (this is left as an exercise :) )
    """

    def __init__(self, players, board = None):
        self.players = players
        self.board = np.zeros((8,8), dtype=int)
        self.board[3,[3,4]] = [1,2]
        self.board[4,[3,4]] = [2,1]
        self.nplayer=1


    def possible_moves(self):
        """ Only moves that lead to flipped pieces are allowed """
        return [to_string((i,j)) for i in range(8) for j in range(8)
            if (self.board[i,j] == 0)
            and (pieces_flipped(self.board, (i,j), self.nplayer) != [])]

    def make_move(self, pos):
        """ Put the piece at position ``pos`` and flip the pieces that
        much be flipped """
        pos= to_array(pos)
        flipped = pieces_flipped(self.board, pos, self.nplayer)
        for i,j in flipped:
            self.board[i,j] = self.nplayer
        self.board[pos[0],pos[1]] = self.nplayer

    def show(self):
        """ Prints the board in a fancy (?) way """
        print('\n'+'\n'.join(['  1 2 3 4 5 6 7 8']+ ['ABCDEFGH'[k] +
                ' '+' '.join([['.','1','2','X'][self.board[k][i]]
                for i in range(8)]) for k in range(8)]+['']))

    def is_over(self):
        """ The game is considered over when someone cannot play. That
        may not be the actual rule but it is simpler to code :). Of
        course it would be possible to implement that a player can pass
        if it cannot play (by adding the move 'pass')"""
        return self.possible_moves() == []

    def scoring(self):
        """
        In the beginning of the game (less than 32 pieces) much
        importance is given to placing pieces on the border. After this
        point, only the number of pieces of each player counts
        """

        if np.sum(self.board==0) > 32: # less than half the board is full
            player = self.board==self.nplayer
            opponent = self.board==self.nopponent
            return ((player-opponent)*BOARD_SCORE).sum()
        else:
            npieces_player = np.sum(self.board==self.nplayer)
            npieces_opponent = np.sum(self.board==self.nopponent)
            return  npieces_player - npieces_opponent

# This board is used by the AI to give more importance to the border
BOARD_SCORE = np.array( [[9,3,3,3,3,3,3,9],
                         [3,1,1,1,1,1,1,3],
                         [3,1,1,1,1,1,1,3],
                         [3,1,1,1,1,1,1,3],
                         [3,1,1,1,1,1,1,3],
                         [3,1,1,1,1,1,1,3],
                         [3,1,1,1,1,1,1,3],
                         [9,3,3,3,3,3,3,9]])

DIRECTIONS = [ np.array([i,j]) for i in [-1,0,1] for j in [-1,0,1]
                               if (i!=0 or j!=0)]

def pieces_flipped(board, pos, nplayer):
    """
    Returns a list of the positions of the pieces to be flipped if
    player `nplayer` places a piece on the `board` at position `pos`.
    This is slow and could be coded in C or Cython.
    """

    flipped = []

    for d in DIRECTIONS:
        ppos = pos + d
        streak = []
        while (0<=ppos[0]<=7) and (0<=ppos[1]<=7):
            if board[ppos[0],ppos[1]] == 3 - nplayer:
                streak.append(+ppos)
            elif board[ppos[0],ppos[1]] == nplayer:
                flipped += streak
                break
            else:
                break
            ppos += d

    return flipped

if __name__ == "__main__":
    from easyAI import Human_Player, AI_Player, Negamax

    # An example: Computer vs Computer:
    game = Reversi([AI_Player(Negamax(4)) for i in (1, 2)])
    game.play()
    if game.score() > 0:
        print("player %d wins." % game.nplayer)
    elif game.score() < 0:
        print("player %d wins." % game.nopponent)
    else:
        print("Draw.")

########NEW FILE########
__FILENAME__ = ThreeMusketeers
import numpy as np
from easyAI import TwoPlayersGame 

MOVES = np.zeros((30,4),dtype=int)

class ThreeMusketeers( TwoPlayersGame ):
    """
    rules: http://en.wikipedia.org/wiki/Three_Musketeers_%28game%29
    """
     
    def __init__(self, players):
        self.players = players
        self.board = np.array([[2,2,2,2,1],
                               [2,2,2,2,2],
                               [2,2,1,2,2],
                               [2,2,2,2,2],
                               [1,2,2,2,2]])
        self.musketeers = [(0,4),(2,2),(4,0)]
        self.nplayer=1
    
    def possible_moves(self):
        moves = []
        if self.nplayer == 2:
            for i in range(5):
                for j in range(5):
                    if self.board[i,j] == 0:
                        moves += [[k,l,i,j]
                                 for k,l in [(i+1,j),(i,j+1),(i-1,j),(i,j-1)]
                                 if 0<=k<5 and 0<=l<5 and self.board[k,l]==2]
        else:
            for i,j in self.musketeers:
                moves += [[i,j,k,l]
                          for k,l in [(i+1,j),(i,j+1),(i-1,j),(i,j-1)]
                          if (0<=k<5) and (0<=l<5) and self.board[k,l]==2]
                
        if moves == []:
            moves = ['None']
            
        return moves
            
    
    def make_move(self, move):
        """ move = [y1, x1, y2, x2] """
        
        if move == 'None':
            return
        
        self.board[move[0],move[1]] = 0
        self.board[move[2],move[3]] = self.nplayer
        if self.nplayer == 1:
            self.musketeers.remove( (move[0],move[1]))
            self.musketeers.append( (move[2],move[3]))
            
    
    def unmake_move(self, move):
        
        if move == 'None':
            return
        
        self.board[move[0],move[1]] = self.nplayer
        self.board[move[2],move[3]] = 0
        if self.nplayer == 1:
            self.board[move[2],move[3]] = 2
            self.musketeers.remove( (move[2],move[3]))
            self.musketeers.append( (move[0],move[1]))
    
    def win(self):
        a,b,c = self.musketeers
        aligned = (a[0]==b[0] and b[0]==c[0]) or (a[1]==b[1] and b[1]==c[1])
        if self.nplayer == 1:
            return not(aligned) and (self.possible_moves() == ['None'])
        else:
            return aligned
    
    def is_over(self):
        self.haswon = self.win() 
        return self.haswon
    
    def scoring(self):
        if self.haswon != None:
            haswon = self.haswon
            self.haswon = None
            return 100 if haswon else 0
        return 100 if self.win() else 0
    
    def show(self):
        print('\n'+'\n'.join(['--1-2-3-4-5']+
            ['ABCDE'[j]+ ' '+ ' '.join(['.12'[self.board[j,i]]
              for i in range(5)]) for j in range(5)]))

    def ttentry(self):
        return "".join(map(str,(self.nplayer,)+ tuple(self.board.flatten())))


if __name__ == "__main__":
    
    # In what follows we setup the AI and launch a AI-vs-AI match.
    
    from easyAI import Human_Player, AI_Player, Negamax, DictTT
    
    tt = DictTT()
    ai = Negamax(5, tt=tt)
    players = [AI_Player(ai) for i in [0,1]]
    game =ThreeMusketeers(players)
    game.play()


########NEW FILE########
__FILENAME__ = TicTacToe
from easyAI import TwoPlayersGame

class TicTacToe( TwoPlayersGame ):
    """ The board positions are numbered as follows:
            7 8 9
            4 5 6
            1 2 3
    """    

    def __init__(self, players):
        self.players = players
        self.board = [0 for i in range(9)]
        self.nplayer = 1 # player 1 starts.
    
    def possible_moves(self):
        return [i+1 for i,e in enumerate(self.board) if e==0]
    
    def make_move(self, move):
        self.board[move-1] = self.nplayer

    def unmake_move(self, move): # optional method (speeds up the AI)
        self.board[move-1] = 0
    
    def lose(self):
        """ Has the opponent "three in line ?" """
        return any( [all([(self.board[c-1]== self.nopponent)
                      for c in line])
                      for line in [[1,2,3],[4,5,6],[7,8,9], # horiz.
                                   [1,4,7],[2,5,8],[3,6,9], # vertical
                                   [1,5,9],[3,5,7]]]) # diagonal
        
    def is_over(self):
        return (self.possible_moves() == []) or self.lose()
        
    def show(self):
        print ('\n'+'\n'.join([
                        ' '.join([['.','O','X'][self.board[3*j+i]]
                        for i in range(3)])
                 for j in range(3)]) )
                 
    def scoring(self):
        return -100 if self.lose() else 0
    

if __name__ == "__main__":
    
    from easyAI import AI_Player, Negamax
    ai_algo = Negamax(6)
    TicTacToe( [AI_Player(ai_algo),AI_Player(ai_algo)]).play()
########NEW FILE########
__FILENAME__ = Player
"""
This module implements the Player (Human or AI), which is basically an
object with an ``ask_move(game)`` method
"""
try:
    input = raw_input
except NameError:
    pass


class Human_Player:
    """
    Class for a human player, which gets asked by text what moves
    she wants to play. She can type ``show moves`` to display a list of
    moves, or ``quit`` to quit the game.
    """

    def __init__(self, name = 'Human'):
        self.name = name

    def ask_move(self, game):
        possible_moves = list(map(str, game.possible_moves()))
        move = -1
        while not move in possible_moves:
            move = input("\nPlayer %s what do you play ? " % (
                game.nplayer))
            if move == 'show moves':
                print(possible_moves)
            elif move.startswith("move #"):
                move = possible_moves[int(move[6:])]
            elif move == 'quit':
                raise KeyboardInterrupt

        return move


class AI_Player:
    """
    Class for an AI player. This class must be initialized with an
    AI algortihm, like ``AI_Player( Negamax(9) )``
    """

    def __init__(self, AI_algo, name = 'AI'):
        self.AI_algo = AI_algo
        self.name = name
        self.move = {}

    def ask_move(self, game):
        return self.AI_algo(game)

########NEW FILE########
__FILENAME__ = TwoPlayersGame
from copy import deepcopy


class TwoPlayersGame:
    """
    Base class for... wait for it... two-players games !
     
    To define a new game, make a subclass of TwoPlayersGame, and define
    the following methods:
    
    - ``__init__(self, players, ...)`` : initialization of the game
    - ``possible_moves(self)`` : returns of all moves allowed
    - ``make_move(self, move)``: transforms the game according to the move
    - ``is_over(self)``: check whether the game has ended
    
    The following methods are optional:
    
    - ``show(self)`` : prints/displays the game
    - ``scoring``: gives a score to the current game (for the AI)
    - ``unmake_move(self, move)``: how to unmake a move (speeds up the AI)
    - ``ttentry(self)``: returns a string/tuple describing the game.
    
    The __init__ method *must* do the following actions:
    
    - Store ``players`` (which must be a list of two Players) into
      self.players
    - Tell which player plays first with ``self.nplayer = 1 # or 2``
    
    When defining ``possible_moves``, you must keep in mind that you
    are in the scope of the *current player*. More precisely, a    
    subclass of TwoPlayersGame has the following attributes that
    indicate whose turn it is. These methods can be used but should not
    be overwritten:
    
    - ``self.player`` : the current player (e.g. ``Human_Player``)
    - ``self.opponent`` : the current Player's opponent (Player). 
    - ``self.nplayer``: the number (1 or 2) of the current player.
    - ``self.nopponent``: the number (1 or 2) of the opponent.
    - ``self.nmove``: How many moves have been played so far ?
    
    For more, see the examples in the dedicated folder.
    
    Examples:
    ----------
    
    ::
    
        from easyAI import TwoPlayersGame, Human_Player
        
        class Sticks( TwoPlayersGame ):
            ''' In turn, the players remove one, two or three sticks from
                a pile. The player who removes the last stick loses '''
                
            def __init__(self, players):
                self.players = players
                self.pile = 20 # start with 20 sticks
                self.nplayer = 1 # player 1 starts
            def possible_moves(self): return ['1','2','3']
            def make_move(self,move): self.pile -= int(move)
            def is_over(self): return self.pile <= 0
            
        
        game = Sticks( [Human_Player(), Human_Player() ] )
        game.play()
        
    
    """
    
    def play(self, nmoves=1000, verbose=True):
        
        history = []
        
        if verbose:
            self.show()
        
        for self.nmove in range(1, nmoves+1):
            
            if self.is_over():
                break
            
            move = self.player.ask_move(self)
            history.append((deepcopy(self), move))
            self.make_move(move)
            
            if verbose:
                print( "\nMove #%d: player %d plays %s :"%(
                             self.nmove, self.nplayer, str(move)) )
                self.show()
                
            self.switch_player()
        
        history.append(deepcopy(self))
        
        return history
    
    @property
    def nopponent(self):
        return 2 if (self.nplayer == 1) else 1
    
    @property
    def player(self):
        return self.players[self.nplayer- 1]
    
    @property
    def opponent(self):
        return self.players[self.nopponent - 1]
    
    def switch_player(self):
        self.nplayer = self.nopponent

    def copy(self):
        return deepcopy(self)

########NEW FILE########
