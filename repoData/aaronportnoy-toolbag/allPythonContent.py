__FILENAME__ = quicktime
'''QuickTime stuff'''

EXPORT = [ 'nameDispatch', 'nameAllDispatches' ]

import idc, comment

import idc,idautils
import function,comment,database
import __quicktime

def nextMnemonic(ea, mnem, maxaddr=0xc0*0x1000000):
    res = idc.GetMnem(ea)
    if res == "": return idc.BADADDR
    if res == mnem: return ea
    return nextMnemonic( idc.NextHead(ea, maxaddr), mnem, maxaddr )

def prevMnemonic(ea, mnem, minaddr=0):
    res = idc.GetMnem(ea)
    #print "%x -> %s"% (ea, res)
    if res == "": return idc.BADADDR
    if res == mnem: return ea
    return prevMnemonic( idc.PrevHead(ea, minaddr), mnem, minaddr )

def getMinorDispatchTableAddress(ea):
    """find address of last lea in function"""
    start = idc.GetFunctionAttr(ea, idc.FUNCATTR_START)
    end = idc.PrevHead( idc.GetFunctionAttr(ea, idc.FUNCATTR_END), start)
    res = prevMnemonic(end, 'lea', start)
    assert res != idc.BADADDR
    return idc.GetOperandValue(res, 1)

def getMajorDispatchTableAddress():
    """find quicktime major dispatch table"""
    res = idc.LocByName('theQuickTimeDispatcher')
    res = nextMnemonic(res, 'lea', idc.GetFunctionAttr(res, idc.FUNCATTR_END))
    assert res != idc.BADADDR
    return idc.GetOperandValue(res, 1)
        
def resolveDispatcher(code):
    major = (code & 0x00ff0000) >> 0x10
    minor = code & 0xff00ffff

    res = getMajorDispatchTableAddress() + major*8
    majorFlag = idc.Dword(res)
    majorAddress = idc.Dword(res+4)
    if majorFlag != 0:
        return majorAddress + (minor*0x10)

    #print "%x"% getMinorDispatchTableAddress(majorAddress)
    #print "resolved by 0x%x(%x)"% (majorAddress, minor)
    return majorAddress

def getDispatchCode(ea):
    # get dispatch code out of an instruction
    first, second = (idc.GetOpnd(ea, 0), idc.GetOperandValue(ea, 1))
    if first == 'eax':
        return second
    raise ValueError("Search resulted in address %08x, but instruction '%s' does fulfill requested constraints"% (ea, idc.GetMnem(ea)))

def FindLastAssignment(ea, register):
    start,end = database.guessrange(ea)
    while ea > start:
        ea = database.prev(ea)
        m = idc.GetMnem(ea)
        r = idc.GetOpnd(ea, 0)

        if m == 'mov' and r == register:
            return ea
        continue
    
    raise ValueError('FindLastAssignment(0x%x, %s) Found no matches'% (ea, register))

def nameDispatch(address):
    '''Name the dispatch function at the specified address in quicktime.qts'''
    try:
        start, end = function.getRange(address)

    except ValueError:
        print '%x making a function'% address
        function.make(address)
        start, end = function.getRange(address)

    try:
        ea = FindLastAssignment(address, 'eax')
        code = getDispatchCode(ea)
    except ValueError:
        print '%08x - Unable to find dispatch code'% address
        return

    function.setName(start, 'dispatch_%08x'% code)
    function.tag(start, 'code', code)
    function.tag(start, 'group', 'dispatch')
    try:
        function.tag(start, 'realname', __quicktime.qt_fv_list[code])
    except KeyError:
        pass

    try:
        function.tag(start, 'address', resolveDispatcher(code), repeatable=True)
    except:
        pass

def nameAllDispatches(ea):
    '''Using the address of {theQuickTimeDispatcher}, name and tag all discovered dispatch calls in quicktime.qts'''
    for address in idautils.DataRefsTo(ea):
        nameDispatch(address)
    return

########NEW FILE########
__FILENAME__ = __quicktime
qt_fv_list={
0x20001: "EnterMovies",
0x20002: "ExitMovies",
0x20003: "GetMoviesError",
0x20004: "GetMoviesStickyError",
0x20005: "MoviesTask",
0x20006: "PrerollMovie",
0x20007: "LoadMovieIntoRam",
0x20008: "LoadMediaIntoRam",
0x20009: "SetMovieActive",
0x2000a: "GetMovieActive",
0x2000b: "StartMovie",
0x2000c: "StopMovie",
0x2000d: "GoToBeginningOfMovie",
0x2000e: "GoToEndOfMovie",
0x2000f: "GetMoviePreviewMode",
0x20010: "SetMoviePreviewMode",
0x20011: "ShowMoviePoster",
0x20012: "GetMovieTimeBase",
0x20015: "GetMovieGWorld",
0x20016: "SetMovieGWorld",
0x2001d: "GetMoviePict",
0x2001e: "GetTrackPict",
0x2001f: "UpdateMovie",
0x20022: "PutMovieIntoHandle",
0x20023: "DisposeMovie",
0x20026: "GetMovieCreationTime",
0x20027: "GetMovieModificationTime",
0x20029: "GetMovieTimeScale",
0x2002a: "SetMovieTimeScale",
0x2002b: "GetMovieDuration",
0x2002c: "GetMovieRate",
0x2002d: "SetMovieRate",
0x2002e: "GetMovieVolume",
0x2002f: "SetMovieVolume",
0x20031: "GetMovieMatrix",
0x20032: "SetMovieMatrix",
0x20033: "GetMoviePreviewTime",
0x20034: "SetMoviePreviewTime",
0x20035: "GetMoviePosterTime",
0x20036: "SetMoviePosterTime",
0x20037: "GetMovieSelection",
0x20038: "SetMovieSelection",
0x20039: "GetMovieTime",
0x2003c: "SetMovieTime",
0x2003d: "SetMovieTimeValue",
0x2003e: "GetMovieUserData",
0x2003f: "GetMovieTrackCount",
0x20040: "GetMovieTrack",
0x20042: "DisposeMovieTrack",
0x20043: "GetTrackCreationTime",
0x20044: "GetTrackModificationTime",
0x20045: "GetTrackEnabled",
0x20046: "SetTrackEnabled",
0x20047: "GetTrackUsage",
0x20048: "SetTrackUsage",
0x2004b: "GetTrackDuration",
0x2004c: "GetTrackOffset",
0x2004d: "SetTrackOffset",
0x20050: "GetTrackLayer",
0x20051: "SetTrackLayer",
0x20052: "GetTrackAlternate",
0x20053: "SetTrackAlternate",
0x20054: "GetTrackVolume",
0x20055: "SetTrackVolume",
0x20056: "GetTrackMatrix",
0x20057: "SetTrackMatrix",
0x2005d: "GetTrackDimensions",
0x2005e: "SetTrackDimensions",
0x2005f: "GetTrackUserData",
0x20061: "DisposeTrackMedia",
0x20062: "GetTrackMedia",
0x20066: "GetMediaCreationTime",
0x20067: "GetMediaModificationTime",
0x20068: "GetMediaTimeScale",
0x20069: "SetMediaTimeScale",
0x2006a: "GetMediaDuration",
0x2006b: "GetMediaLanguage",
0x2006c: "SetMediaLanguage",
0x2006d: "GetMediaQuality",
0x2006e: "SetMediaQuality",
0x2006f: "GetMediaHandlerDescription",
0x20070: "GetMediaUserData",
0x20071: "GetMediaHandler",
0x20072: "BeginMediaEdits",
0x20073: "EndMediaEdits",
0x20074: "AddEmptyTrackToMovie",
0x20077: "GetMediaSampleDescriptionCount",
0x20078: "GetMediaSampleDescription",
0x20079: "GetMediaSampleCount",
0x2007a: "SampleNumToMediaTime",
0x2007b: "MediaTimeToSampleNum",
0x2007c: "AddMediaSample",
0x2007d: "AddMediaSampleReference",
0x2007e: "GetMediaSample",
0x2007f: "GetMediaSampleReference",
0x20084: "CloneRgn",
0x20085: "InsertTrackSegment",
0x20086: "InsertMovieSegment",
0x20087: "InsertEmptyTrackSegment",
0x20088: "InsertEmptyMovieSegment",
0x20089: "DeleteTrackSegment",
0x2008a: "DeleteMovieSegment",
0x2008b: "ScaleTrackSegment",
0x2008c: "ScaleMovieSegment",
0x2008d: "CutMovieSelection",
0x2008e: "CopyMovieSelection",
0x2008f: "PasteMovieSelection",
0x20096: "TrackTimeToMediaTime",
0x20098: "GetMovieDataSize",
0x20099: "GetMediaDataSize",
0x2009a: "PtInMovie",
0x2009b: "PtInTrack",
0x2009c: "SetMovieLanguage",
0x2009d: "SetTrackGWorld",
0x2009e: "GetUserData",
0x2009f: "AddUserData",
0x200a0: "RemoveUserData",
0x200a5: "NewTimeBase",
0x200a6: "GetTimeBaseTime",
0x200a7: "SetTimeBaseTime",
0x200a8: "SetTimeBaseValue",
0x200a9: "GetTimeBaseRate",
0x200aa: "SetTimeBaseRate",
0x200ab: "GetTimeBaseStartTime",
0x200ac: "SetTimeBaseStartTime",
0x200ad: "GetTimeBaseStopTime",
0x200ae: "SetTimeBaseStopTime",
0x200af: "GetTimeBaseMasterTimeBase",
0x200b0: "GetTimeBaseMasterClock",
0x200b1: "GetTimeBaseFlags",
0x200b2: "SetTimeBaseFlags",
0x200b3: "SetTimeBaseMasterClock",
0x200b4: "SetTimeBaseMasterTimeBase",
0x200b5: "ConvertTime",
0x200b6: "DisposeTimeBase",
0x200b7: "ConvertTimeScale",
0x200b8: "CallMeWhen",
0x200b9: "CancelCallBack",
0x200c5: "GetMediaTrack",
0x200cb: "PasteHandleIntoMovie",
0x200cc: "IsScrapMovie",
0x200d0: "GetTrackMovie",
0x200d5: "CloseMovieFile",
0x200d7: "AddMovieResource",
0x200d8: "UpdateMovieResource",
0x200d9: "HasMovieChanged",
0x200dd: "IsMovieDone",
0x200de: "ClearMoviesStickyError",
0x200e1: "ClearMovieSelection",
0x200e2: "GetTrackNextInterestingTime",
0x200eb: "NewCallBack",
0x200ec: "DisposeCallBack",
0x200ed: "GetCallBackType",
0x200ee: "GetCallBackTimeBase",
0x200ef: "SetMoviesErrorProc",
0x200f0: "NewMovieFromFile",
0x200f1: "NewMovieFromHandle",
0x200f2: "PlayMoviePreview",
0x200f3: "GetMoviePreferredRate",
0x200f4: "SetMoviePreferredRate",
0x200f5: "GetMoviePreferredVolume",
0x200f6: "SetMoviePreferredVolume",
0x200f7: "GetMoviePosterPict",
0x200f9: "GetMovieBox",
0x200fa: "SetMovieBox",
0x200fb: "GetMovieDisplayBoundsRgn",
0x200fc: "GetMovieDisplayClipRgn",
0x200fd: "SetMovieDisplayClipRgn",
0x200fe: "GetMovieBoundsRgn",
0x200ff: "GetTrackMovieBoundsRgn",
0x20100: "GetMovieClipRgn",
0x20101: "SetMovieClipRgn",
0x20102: "GetTrackClipRgn",
0x20103: "SetTrackClipRgn",
0x20104: "NewMovieEditState",
0x20105: "UseMovieEditState",
0x20106: "DisposeMovieEditState",
0x20107: "NewTrackEditState",
0x20108: "UseTrackEditState",
0x20109: "DisposeTrackEditState",
0x2010b: "GetTimeBaseStatus",
0x2010c: "AddTime",
0x2010d: "SubtractTime",
0x2010e: "GetMovieNextInterestingTime",
0x20111: "GetTrackBoundsRgn",
0x20112: "GetTrackDisplayBoundsRgn",
0x20113: "ClearMovieChanged",
0x20115: "GetTrackMatte",
0x20116: "SetTrackMatte",
0x20117: "GetMovieIndTrack",
0x20121: "SetMediaShadowSync",
0x20122: "GetMediaShadowSync",
0x20123: "GetTrackEditRate",
0x20124: "GetTimeBaseEffectiveRate",
0x20126: "GetUserDataItem",
0x20127: "GetTrackID",
0x20128: "SetTimeBaseZero",
0x20129: "AddCallBackToTimeBase",
0x2012a: "RemoveCallBackFromTimeBase",
0x2012b: "GetFirstCallBack",
0x2012c: "GetNextCallBack",
0x2012d: "ExecuteCallBack",
0x2012e: "SetUserDataItem",
0x2012f: "NewUserData",
0x20130: "DisposeUserData",
0x20131: "NewUserDataFromHandle",
0x20132: "PutUserDataIntoHandle",
0x20149: "GetTrackDataSize",
0x2014a: "DisposeMatte",
0x2014b: "CountUserDataType",
0x2014c: "AddUserDataText",
0x2014d: "GetUserDataText",
0x2014e: "RemoveUserDataText",
0x20152: "AddMovieSelection",
0x20153: "CopyTrackSettings",
0x20154: "CopyMovieSettings",
0x2015c: "SetMovieActiveSegment",
0x2015d: "GetMovieActiveSegment",
0x2015e: "SetAutoTrackAlternatesEnabled",
0x2015f: "SelectMovieAlternates",
0x20167: "SetMovieMasterTimeBase",
0x20168: "SetMovieMasterClock",
0x2016b: "GetTrackSegmentDisplayBoundsRgn",
0x2016c: "GetMovieSegmentDisplayBoundsRgn",
0x2016d: "GetMediaNextInterestingTime",
0x2016e: "LoadTrackIntoRam",
0x2016f: "GetPosterBox",
0x20170: "SetPosterBox",
0x20172: "GetTrackStatus",
0x20173: "GetMovieStatus",
0x20175: "DeleteMovieFile",
0x20176: "RemoveMovieResource",
0x20179: "SetMovieCoverProcs",
0x20183: "InsertMediaIntoTrack",
0x20187: "NewMovie",
0x20188: "NewMovieTrack",
0x2018a: "NewMovieController",
0x2018b: "DisposeMovieController",
0x2018c: "PutMovieOnScrap",
0x2018d: "NewMovieFromScrap",
0x2018e: "NewTrackMedia",
0x20190: "SetMediaHandler",
0x20191: "CreateMovieFile",
0x20192: "OpenMovieFile",
0x20197: "GetMediaDataRef",
0x20198: "AddMediaDataRef",
0x20199: "GetMediaDataRefCount",
0x2019a: "SetMovieProgressProc",
0x2019b: "FlattenMovie",
0x2019c: "FlattenMovieData",
0x2019e: "GetMediaDataHandlerDescription",
0x2019f: "GetMediaDataHandler",
0x201a0: "SetMediaDataHandler",
0x201a1: "SetMoviePlayHints",
0x201a2: "SetMediaPlayHints",
0x201a5: "GetNextUserDataType",
0x201b3: "NewMovieFromDataFork",
0x201b4: "PutMovieIntoDataFork",
0x201c1: "SetMovieDefaultDataRef",
0x201c9: "SetMediaDataRef",
0x201ca: "SetMediaDataRefAttributes",
0x201cb: "ConvertFileToMovieFile",
0x201cc: "ConvertMovieToFile",
0x201cd: "PutMovieIntoTypedHandle",
0x201d0: "SetMediaSampleDescription",
0x201d2: "GetMovieDefaultDataRef",
0x201dd: "GetMovieCoverProcs",
0x201de: "SetMovieDrawingCompleteProc",
0x201e0: "SetMediaDefaultDataRefIndex",
0x201e3: "SetTrackLoadSettings",
0x201e4: "GetTrackLoadSettings",
0x201ec: "NewMovieFromUserProc",
0x201ed: "GetDataHandler",
0x201f0: "AddTrackReference",
0x201f1: "DeleteTrackReference",
0x201f2: "SetTrackReference",
0x201f3: "GetTrackReference",
0x201f4: "GetNextTrackReferenceType",
0x201f5: "GetTrackReferenceCount",
0x201f7: "AddMediaSampleReferences",
0x201f8: "SetMediaPreferredChunkSize",
0x201f9: "GetMediaPreferredChunkSize",
0x201fa: "GetNextTrackForCompositing",
0x201fb: "GetPrevTrackForCompositing",
0x201ff: "QTSwapAtoms",
0x20200: "QTNextChildAnyType",
0x20201: "QTNewAlias",
0x20205: "SetMovieColorTable",
0x20206: "GetMovieColorTable",
0x20207: "MovieSearchText",
0x20208: "GetMovieIndTrackType",
0x20209: "ShowMovieInformation",
0x2020c: "QTNewAtomContainer",
0x2020d: "QTDisposeAtomContainer",
0x2020e: "QTGetNextChildType",
0x2020f: "QTCountChildrenOfType",
0x20210: "QTFindChildByIndex",
0x20211: "QTSetAtomData",
0x20212: "QTCopyAtomDataToHandle",
0x20213: "QTCopyAtomDataToPtr",
0x20214: "QTCopyAtom",
0x20215: "QTLockContainer",
0x20216: "QTGetAtomDataPtr",
0x20217: "QTUnlockContainer",
0x20218: "QTInsertChild",
0x20219: "QTInsertChildren",
0x2021a: "QTRemoveAtom",
0x2021b: "QTRemoveChildren",
0x2021c: "QTReplaceAtom",
0x2021d: "QTFindChildByID",
0x20220: "NewMovieFromDataRef",
0x2022a: "InvalidateMovieRegion",
0x2022b: "TaskMovie",
0x2022c: "GetMovieNaturalBoundsRect",
0x2022e: "SetMediaPropertyAtom",
0x2022f: "GetMediaPropertyAtom",
0x20231: "QTSetAtomID",
0x20232: "QTGetAtomTypeAndID",
0x20233: "BeginFullScreen",
0x20234: "EndFullScreen",
0x20235: "GetMediaSampleReferences",
0x20239: "NewSpriteWorld",
0x2023a: "DisposeSpriteWorld",
0x2023b: "SetSpriteWorldClip",
0x2023c: "SetSpriteWorldMatrix",
0x2023d: "SpriteWorldIdle",
0x2023e: "InvalidateSpriteWorld",
0x2023f: "DisposeAllSprites",
0x20240: "NewSprite",
0x20241: "DisposeSprite",
0x20242: "InvalidateSprite",
0x20243: "SetSpriteProperty",
0x20244: "GetSpriteProperty",
0x20246: "SpriteWorldHitTest",
0x20247: "SpriteHitTest",
0x20249: "GetMediaInputMap",
0x2024a: "SetMediaInputMap",
0x20263: "GetTrackDisplayMatrix",
0x2027a: "ITextAddString",
0x2027b: "ITextRemoveString",
0x2027c: "ITextGetString",
0x20282: "GetTrackSoundLocalizationSettings",
0x20283: "SetTrackSoundLocalizationSettings",
0x20284: "SetMoviePropertyAtom",
0x20285: "GetMoviePropertyAtom",
0x2029d: "QTNewTween",
0x2029e: "QTDoTween",
0x2029f: "QTDisposeTween",
0x202b2: "GetMediaSyncSampleCount",
0x202b3: "QTGetAccessKeys",
0x202b4: "QTRegisterAccessKey",
0x202b5: "QTUnregisterAccessKey",
0x202be: "MakeTrackTimeTable",
0x202bf: "MakeMediaTimeTable",
0x202c0: "GetMaxLoadedTimeInMovie",
0x202c2: "SetSpriteWorldFlags",
0x202c3: "QTMovieNeedsTimeTable",
0x202c6: "QTGetDataRefMaxFileOffset",
0x202c7: "GetMovieImporterForDataRef",
0x202c9: "QTGetEffectsList",
0x202ca: "QTCreateStandardParameterDialog",
0x202cb: "QTIsStandardParameterDialogEvent",
0x202cc: "QTDismissStandardParameterDialog",
0x202cd: "QTStandardParameterDialogDoAction",
0x202ce: "GetMediaPlayHints",
0x202cf: "AddSoundDescriptionExtension",
0x202d0: "GetSoundDescriptionExtension",
0x202d1: "RemoveSoundDescriptionExtension",
0x202d2: "QTGetEffectSpeed",
0x202d3: "QuickTimeExtensionLoaded",
0x202d4: "GetQuickTimePreference",
0x202d5: "SetQuickTimePreference",
0x202d9: "SetSpriteWorldGraphicsMode",
0x202da: "CheckQuickTimeRegistration",
0x202db: "QTTextToNativeText",
0x202e8: "AddMediaSampleReferences64",
0x202e9: "GetMediaSampleReferences64",
0x202ea: "PutMovieIntoDataFork64",
0x202eb: "GetMovieDataSize64",
0x202ec: "GetTrackDataSize64",
0x202ed: "GetMediaDataSize64",
0x202ee: "NewMovieFromDataFork64",
0x202ef: "QTGetAtomParent",
0x202f1: "QTReportMissingSoftware",
0x202f4: "InstallQuickTimeExtensionRequest",
0x202f5: "QTBandwidthRequest",
0x202f6: "QTBandwidthRelease",
0x202f7: "PrePrerollMovie",
0x202f8: "AbortPrePrerollMovie",
0x202f9: "QTTempNewHandle",
0x202fa: "CreateShortcutMovieFile",
0x202fe: "QTAltGetComputerSpeed",
0x20300: "GetMovieProgressProc",
0x20302: "AddMovieExecuteWiredActionsProc",
0x20303: "RemoveMovieExecuteWiredActionsProc",
0x20304: "MovieExecuteWiredActions",
0x20310: "QTScheduledBandwidthRequest",
0x20311: "QTScheduledBandwidthRelease",
0x20314: "GetMovieLoadState",
0x20315: "SetMovieAnchorDataRef",
0x20316: "GetMovieAnchorDataRef",
0x20318: "QTBandwidthRequestForTimeBase",
0x20319: "QTParseTextHREF",
0x2031b: "QTDoCallBacks",
0x2031c: "OpenADataHandler",
0x2031d: "QTListNew",
0x2031e: "QTListDispose",
0x2031f: "QTListElementRefNew",
0x20320: "QTListElementRefDispose",
0x20321: "QTListElementRefGetList",
0x20322: "QTListElementRefClone",
0x20323: "QTListInsertNewElement",
0x20324: "QTListSetElementDataAs",
0x20325: "QTListSetElementName",
0x20326: "QTListDeleteElement",
0x20327: "QTListCutSublist",
0x20328: "QTListCopySublist",
0x20329: "QTListPasteSublist",
0x2032a: "QTListDeleteSublist",
0x2032b: "QTListSetMatchingElementData",
0x2032c: "QTListCountChildElements",
0x2032d: "QTListFindRootElement",
0x2032e: "QTListFindParentElement",
0x2032f: "QTListFindElementByName",
0x20330: "QTListFindElementByIndex",
0x20331: "QTListFindChildElementByPathName",
0x20332: "QTListGetElementName",
0x20333: "QTListGetElementPathName",
0x20334: "QTListGetElementTypeAndSize",
0x20335: "QTListGetElementIndex",
0x20336: "QTListInsertNewAttribute",
0x20337: "QTListCopyElementDataToPtr",
0x20338: "QTListValidateDataType",
0x20339: "QTListWriteToXML",
0x2033a: "QTListReadFromXML",
0x2033e: "CanQuickTimeOpenFile",
0x2033f: "CanQuickTimeOpenDataRef",
0x20340: "SetMovieVideoOutput",
0x20344: "AddClonedTrackToMovie",
0x20347: "QTGetWallClockTimeBase",
0x2034f: "QTListDeleteAttribute",
0x20350: "QTListCountAttributes",
0x20351: "QTListFindAttributeByIndex",
0x20352: "QTListFindAttributeByName",
0x20353: "QTListFindAttributeParentElement",
0x20354: "QTListSetAttributeDataAs",
0x20355: "QTListSetAttributeName",
0x20356: "QTListGetAttributeName",
0x20357: "QTListAttributeRefNew",
0x20358: "QTListAttributeRefDispose",
0x20359: "QTListAttributeRefClone",
0x2035a: "QTListGetAttributeTypeAndSize",
0x2035b: "QTListGetAttributeIndex",
0x2035c: "QTListCopyAttributeDataToPtr",
0x190002: "NewPalette",
0x190003: "GetNewPalette",
0x190004: "DisposePalette",
0x190005: "ActivatePalette",
0x190006: "SetPalette",
0x190007: "NSetPalette",
0x190008: "GetPalette",
0x190009: "CopyPalette",
0x19000a: "PmForeColor",
0x19000b: "PmBackColor",
0x19000e: "GetEntryColor",
0x19000f: "SetEntryColor",
0x190010: "GetEntryUsage",
0x190011: "SetEntryUsage",
0x190012: "CTab2Palette",
0x190013: "Palette2CTab",
0x190014: "Entry2Index",
0x190016: "MacResizePalette",
0x190017: "SaveFore",
0x190018: "SaveBack",
0x190019: "RestoreFore",
0x19001a: "RestoreBack",
0x19001d: "PMgrVersion",
0x19001e: "SetPaletteUpdates",
0x19001f: "GetPaletteUpdates",
0x190020: "GetGray",
0x1e0002: "OpenPort",
0x1e0003: "InitPort",
0x1e0004: "ClosePort",
0x1e0005: "MacSetPort",
0x1e0006: "GetPort",
0x1e0008: "SetPortBits",
0x1e0009: "PortSize",
0x1e000a: "MovePortTo",
0x1e000b: "SetOrigin",
0x1e000c: "SetClip",
0x1e000d: "GetClip",
0x1e000e: "ClipRect",
0x1e000f: "BackPat",
0x1e0010: "InitCursor",
0x1e0011: "MacSetCursor",
0x1e0012: "HideCursor",
0x1e0013: "MacShowCursor",
0x1e0014: "ObscureCursor",
0x1e0015: "HidePen",
0x1e0016: "ShowPen",
0x1e0017: "GetPen",
0x1e0018: "GetPenState",
0x1e0019: "SetPenState",
0x1e001a: "PenSize",
0x1e001b: "PenMode",
0x1e001c: "PenPat",
0x1e001d: "PenNormal",
0x1e001e: "MoveTo",
0x1e001f: "Move",
0x1e0020: "MacLineTo",
0x1e0021: "Line",
0x1e0022: "ForeColor",
0x1e0023: "BackColor",
0x1e0024: "ColorBit",
0x1e0025: "MacSetRect",
0x1e0026: "MacOffsetRect",
0x1e0027: "MacInsetRect",
0x1e0028: "SectRect",
0x1e0029: "MacUnionRect",
0x1e002a: "MacEqualRect",
0x1e002b: "EmptyRect",
0x1e002c: "MacFrameRect",
0x1e002d: "PaintRect",
0x1e002e: "EraseRect",
0x1e002f: "MacInvertRect",
0x1e0030: "MacFillRect",
0x1e0031: "FrameOval",
0x1e0032: "PaintOval",
0x1e0033: "EraseOval",
0x1e0034: "InvertOval",
0x1e0035: "FillOval",
0x1e0036: "FrameRoundRect",
0x1e0037: "PaintRoundRect",
0x1e0038: "EraseRoundRect",
0x1e0039: "InvertRoundRect",
0x1e003a: "FillRoundRect",
0x1e003b: "FrameArc",
0x1e003c: "PaintArc",
0x1e003d: "EraseArc",
0x1e003e: "InvertArc",
0x1e003f: "FillArc",
0x1e0040: "NewRgn",
0x1e0041: "OpenRgn",
0x1e0042: "CloseRgn",
0x1e0043: "BitMapToRegion",
0x1e0044: "DisposeRgn",
0x1e0045: "MacCopyRgn",
0x1e0046: "SetEmptyRgn",
0x1e0047: "MacSetRectRgn",
0x1e0048: "RectRgn",
0x1e0049: "MacOffsetRgn",
0x1e004a: "InsetRgn",
0x1e004b: "SectRgn",
0x1e004c: "MacUnionRgn",
0x1e004d: "DiffRgn",
0x1e004e: "MacXorRgn",
0x1e004f: "RectInRgn",
0x1e0050: "MacEqualRgn",
0x1e0051: "EmptyRgn",
0x1e0052: "MacFrameRgn",
0x1e0053: "MacPaintRgn",
0x1e0054: "EraseRgn",
0x1e0055: "MacInvertRgn",
0x1e0056: "MacFillRgn",
0x1e0057: "ScrollRect",
0x1e0058: "CopyBits",
0x1e0059: "SeedFill",
0x1e005a: "CalcMask",
0x1e005b: "CopyMask",
0x1e005c: "OpenPicture",
0x1e005d: "PicComment",
0x1e005e: "ClosePicture",
0x1e005f: "DrawPicture",
0x1e0060: "KillPicture",
0x1e0061: "OpenPoly",
0x1e0062: "ClosePoly",
0x1e0063: "KillPoly",
0x1e0064: "OffsetPoly",
0x1e0065: "FramePoly",
0x1e0066: "PaintPoly",
0x1e0067: "ErasePoly",
0x1e0068: "InvertPoly",
0x1e0069: "FillPoly",
0x1e006a: "SetPt",
0x1e006b: "LocalToGlobal",
0x1e006c: "GlobalToLocal",
0x1e006d: "Random",
0x1e006e: "StuffHex",
0x1e006f: "MacGetPixel",
0x1e0070: "ScalePt",
0x1e0071: "MapPt",
0x1e0072: "MapRect",
0x1e0073: "MapRgn",
0x1e0074: "MapPoly",
0x1e0075: "SetStdProcs",
0x1e0076: "StdRect",
0x1e0077: "StdRRect",
0x1e0078: "StdOval",
0x1e0079: "StdArc",
0x1e007a: "StdPoly",
0x1e007b: "StdRgn",
0x1e007c: "StdBits",
0x1e007d: "StdComment",
0x1e007e: "StdGetPic",
0x1e007f: "StdPutPic",
0x1e0080: "AddPt",
0x1e0081: "EqualPt",
0x1e0082: "MacPtInRect",
0x1e0083: "Pt2Rect",
0x1e0084: "PtToAngle",
0x1e0085: "SubPt",
0x1e0086: "PtInRgn",
0x1e0087: "StdLine",
0x1e0088: "OpenCPort",
0x1e0089: "InitCPort",
0x1e008a: "CloseCPort",
0x1e008b: "NewPixMap",
0x1e008c: "DisposePixMap",
0x1e008d: "CopyPixMap",
0x1e008e: "NewPixPat",
0x1e008f: "DisposePixPat",
0x1e0090: "CopyPixPat",
0x1e0091: "PenPixPat",
0x1e0092: "BackPixPat",
0x1e0093: "GetPixPat",
0x1e0094: "MakeRGBPat",
0x1e0095: "FillCRect",
0x1e0096: "FillCOval",
0x1e0097: "FillCRoundRect",
0x1e0098: "FillCArc",
0x1e0099: "FillCRgn",
0x1e009a: "FillCPoly",
0x1e009b: "RGBForeColor",
0x1e009c: "RGBBackColor",
0x1e009d: "SetCPixel",
0x1e009e: "SetPortPix",
0x1e009f: "GetCPixel",
0x1e00a0: "GetForeColor",
0x1e00a1: "GetBackColor",
0x1e00a2: "SeedCFill",
0x1e00a3: "CalcCMask",
0x1e00a4: "OpenCPicture",
0x1e00a5: "OpColor",
0x1e00a6: "HiliteColor",
0x1e00a7: "DisposeCTable",
0x1e00a8: "GetCTable",
0x1e00a9: "GetCCursor",
0x1e00aa: "SetCCursor",
0x1e00ac: "DisposeCCursor",
0x1e00b0: "SetStdCProcs",
0x1e00b1: "GetMaxDevice",
0x1e00b2: "GetCTSeed",
0x1e00b3: "GetDeviceList",
0x1e00b4: "GetMainDevice",
0x1e00b5: "GetNextDevice",
0x1e00b6: "TestDeviceAttribute",
0x1e00b7: "SetDeviceAttribute",
0x1e00b8: "InitGDevice",
0x1e00b9: "NewGDevice",
0x1e00ba: "DisposeGDevice",
0x1e00bb: "SetGDevice",
0x1e00bc: "GetGDevice",
0x1e00bd: "Color2Index",
0x1e00be: "Index2Color",
0x1e00bf: "InvertColor",
0x1e00c0: "RealColor",
0x1e00c1: "GetSubTable",
0x1e00c2: "MakeITable",
0x1e00c3: "AddSearch",
0x1e00c4: "AddComp",
0x1e00c5: "DelSearch",
0x1e00c6: "DelComp",
0x1e00c7: "SetClientID",
0x1e00c8: "ProtectEntry",
0x1e00c9: "ReserveEntry",
0x1e00ca: "SetEntries",
0x1e00cb: "SaveEntries",
0x1e00cc: "RestoreEntries",
0x1e00cd: "QDError",
0x1e00ce: "CopyDeepMask",
0x1e00cf: "DeviceLoop",
0x1e00d3: "MacGetCursor",
0x1e00d4: "GetPicture",
0x1e00d6: "ShieldCursor",
0x1e00d9: "PackBits",
0x1e00da: "UnpackBits",
0x1e00db: "SlopeFromAngle",
0x1e00dc: "AngleFromSlope",
0x1e00dd: "LockPortBits",
0x1e00de: "UnlockPortBits",
0x1e00e1: "UpdatePort",
0x1e00e4: "CopyBitsGDI",
0x30000: "CodecManagerVersion",
0x30001: "GetCodecNameList",
0x30003: "GetCodecInfo",
0x30004: "GetMaxCompressionSize",
0x30005: "GetCompressionTime",
0x30006: "CompressImage",
0x30007: "FCompressImage",
0x30008: "DecompressImage",
0x30009: "FDecompressImage",
0x3000a: "CompressSequenceBegin",
0x3000b: "CompressSequenceFrame",
0x3000c: "StdPix",
0x3000d: "DecompressSequenceBegin",
0x3000e: "DecompressSequenceFrame",
0x3000f: "DisposeCodecNameList",
0x30010: "SetDSequenceMatrix",
0x30011: "SetDSequenceMatte",
0x30012: "SetDSequenceMask",
0x30013: "SetDSequenceTransferMode",
0x30014: "SetDSequenceDataProc",
0x30015: "GetDSequenceImageBuffer",
0x30016: "GetDSequenceScreenBuffer",
0x30017: "SetCSequenceQuality",
0x30018: "SetCSequencePrev",
0x30019: "GetCSequencePrevBuffer",
0x3001a: "CDSequenceBusy",
0x3001b: "CDSequenceEnd",
0x3001c: "GetCompressedImageSize",
0x3001d: "GetSimilarity",
0x3001e: "GetImageDescriptionCTable",
0x3001f: "SetImageDescriptionCTable",
0x30020: "GetImageDescriptionExtension",
0x30021: "AddImageDescriptionExtension",
0x30023: "FindCodec",
0x30024: "CompressPicture",
0x30025: "FCompressPicture",
0x30026: "CompressPictureFile",
0x30027: "FCompressPictureFile",
0x30028: "GetPictureFileHeader",
0x30029: "DrawPictureFile",
0x3002a: "MakeThumbnailFromPicture",
0x3002b: "MakeThumbnailFromPictureFile",
0x3002c: "MakeThumbnailFromPixMap",
0x3002d: "TrimImage",
0x3002e: "DrawTrimmedPicture",
0x3002f: "DrawTrimmedPictureFile",
0x30030: "ConvertImage",
0x30033: "SetCSequenceFlushProc",
0x30034: "SetDSequenceAccuracy",
0x30035: "SetDSequenceSrcRect",
0x30036: "SetCSequenceKeyFrameRate",
0x30037: "GetCompressedPixMapInfo",
0x30038: "SetCompressedPixMapInfo",
0x30039: "TransformRgn",
0x3003a: "RemoveImageDescriptionExtension",
0x3003b: "CountImageDescriptionExtensionType",
0x3003c: "GetNextImageDescriptionExtensionType",
0x30041: "SFGetFilePreview",
0x30042: "SFPGetFilePreview",
0x30043: "StandardGetFilePreview",
0x30044: "CustomGetFilePreview",
0x30045: "MakeFilePreview",
0x30046: "AddFilePreview",
0x30047: "DecompressSequenceFrameS",
0x3004b: "GetCSequenceKeyFrameRate",
0x3004c: "AlignScreenRect",
0x3004d: "AlignWindow",
0x3004e: "DragAlignedWindow",
0x3004f: "DragAlignedGrayRgn",
0x30050: "SetCSequenceDataRateParams",
0x30051: "SetCSequenceFrameNumber",
0x30052: "NewImageGWorld",
0x30053: "GetCSequenceDataRateParams",
0x30054: "GetCSequenceFrameNumber",
0x30055: "GetBestDeviceRect",
0x30056: "SetSequenceProgressProc",
0x30057: "SetDSequenceFlags",
0x3005a: "GDHasScale",
0x3005b: "GDGetScale",
0x3005c: "GDSetScale",
0x3005d: "DecompressSequenceBeginS",
0x3005e: "DecompressSequenceFrameWhen",
0x3005f: "CDSequenceFlush",
0x30061: "QTGetFileNameExtension",
0x30062: "ICMShieldSequenceCursor",
0x30063: "ICMDecompressComplete",
0x30064: "SetDSequenceTimeCode",
0x30065: "CDSequenceEquivalentImageDescription",
0x30066: "CDSequenceNewMemory",
0x30067: "CDSequenceDisposeMemory",
0x30068: "CDSequenceNewDataSource",
0x30069: "CDSequenceDisposeDataSource",
0x3006a: "CDSequenceSetSourceData",
0x3006b: "CDSequenceChangedSourceData",
0x3006c: "PtInDSequenceData",
0x3006d: "ImageFieldSequenceBegin",
0x3006e: "GetGraphicsImporterForFile",
0x3006f: "ImageTranscodeSequenceBegin",
0x30070: "ImageTranscodeSequenceEnd",
0x30071: "ImageTranscodeFrame",
0x30072: "ImageTranscodeDisposeFrameData",
0x30073: "CDSequenceInvalidate",
0x30074: "GetCSequenceMaxCompressionSize",
0x30075: "ImageFieldSequenceExtractCombine",
0x30076: "ImageFieldSequenceEnd",
0x30077: "GetGraphicsImporterForDataRef",
0x30078: "SetCSequencePreferredPacketSize",
0x30079: "CDSequenceSetTimeBase",
0x3007a: "MakeImageDescriptionForPixMap",
0x3007b: "CDSequenceSetSourceDataQueue",
0x3007c: "ICMSequenceLockBits",
0x3007d: "ICMSequenceUnlockBits",
0x3007e: "ICMSequenceGetChainMember",
0x3007f: "CDSequenceGetDataSource",
0x30080: "QTNewGWorld",
0x30081: "QTUpdateGWorld",
0x30082: "ICMDecompressCompleteS",
0x30083: "ICMGetPixelFormatInfo",
0x30084: "GetGraphicsImporterForFileWithFlags",
0x30085: "GetGraphicsImporterForDataRefWithFlags",
0x30086: "QTGetPixelSize",
0x30087: "HitTestDSequenceData",
0x30089: "ICMSequenceGetInfo",
0x3008a: "ICMSetPixelFormatInfo",
0x3008b: "QTNewGWorldFromPtr",
0x3008d: "QTGetPixMapPtrRowBytes",
0x3008e: "QTGetPixMapHandleRowBytes",
0x3008f: "QTSetPixMapHandleRowBytes",
0x30090: "QTSetPixMapPtrRowBytes",
0x30091: "GetDSequenceMatrix",
0x30092: "MakeImageDescriptionForEffect",
0x30093: "QTGetPixMapPtrGammaLevel",
0x30094: "QTSetPixMapPtrGammaLevel",
0x30095: "QuadToQuadMatrix",
0x30096: "QTGetPixMapHandleGammaLevel",
0x30097: "QTSetPixMapHandleGammaLevel",
0x30098: "QTGetPixMapPtrRequestedGammaLevel",
0x30099: "QTSetPixMapPtrRequestedGammaLevel",
0x3009a: "QTGetPixMapHandleRequestedGammaLevel",
0x3009b: "QTSetPixMapHandleRequestedGammaLevel",
0x3009c: "OpenPreviewComponentForFile",
0x3009d: "ICMSequenceSetInfo",
0x3009f: "CDSequenceEquivalentImageDescriptionS",
0x300a0: "ReplaceDSequenceImageDescription",
0x200003: "CloseResFile",
0x200004: "ResError",
0x200005: "CurResFile",
0x200006: "HomeResFile",
0x200009: "UseResFile",
0x20000a: "CountTypes",
0x20000b: "Count1Types",
0x20000c: "GetIndType",
0x20000d: "Get1IndType",
0x20000e: "SetResLoad",
0x20000f: "CountResources",
0x200010: "Count1Resources",
0x200011: "GetIndResource",
0x200012: "Get1IndResource",
0x200013: "GetResource",
0x200014: "Get1Resource",
0x200015: "GetNamedResource",
0x200016: "Get1NamedResource",
0x200017: "MacLoadResource",
0x200018: "ReleaseResource",
0x200019: "DetachResource",
0x20001a: "UniqueID",
0x20001b: "Unique1ID",
0x20001c: "GetResAttrs",
0x20001d: "GetResInfo",
0x20001e: "SetResInfo",
0x20001f: "AddResource",
0x200020: "GetResourceSizeOnDisk",
0x200023: "SetResAttrs",
0x200024: "ChangedResource",
0x200025: "RemoveResource",
0x200026: "UpdateResFile",
0x200027: "WriteResource",
0x200028: "SetResPurge",
0x200029: "GetResFileAttrs",
0x20002a: "SetResFileAttrs",
0x20002f: "FSpOpenResFile",
0x200030: "FSpCreateResFile",
0x200033: "SetResourceSize",
0x200036: "RegisterResourceEndianFilter",
0x200037: "GetIndString",
0x0c0003: "NewDialog",
0x0c0004: "GetNewDialog",
0x0c0006: "CloseDialog",
0x0c0007: "DisposeDialog",
0x0c0008: "ModalDialog",
0x0c0009: "IsDialogEvent",
0x0c000a: "DialogSelect",
0x0c000b: "DrawDialog",
0x0c000c: "UpdateDialog",
0x0c000d: "HideDialogItem",
0x0c000e: "ShowDialogItem",
0x0c000f: "FindDialogItem",
0x0c0014: "Alert",
0x0c0015: "StopAlert",
0x0c0016: "NoteAlert",
0x0c0017: "CautionAlert",
0x0c0018: "GetDialogItem",
0x0c0019: "SetDialogItem",
0x0c001a: "ParamText",
0x0c001b: "SelectDialogItemText",
0x0c001c: "GetDialogItemText",
0x0c001d: "SetDialogItemText",
0x0c0021: "AppendDITL",
0x0c0022: "CountDITL",
0x0c0023: "ShortenDITL",
0x0c0024: "StdFilterProc",
0x0c0025: "GetStdFilterProc",
0x0c0026: "SetDialogDefaultItem",
0x0c0027: "SetDialogCancelItem",
0x0c0028: "SetDialogTracksCursor",
0x0c002d: "NewColorDialog",
0x0c002e: "SetModelessDialogCallbackProc",
0x0c002f: "GetDialogItemAsControl",
0x0c0030: "SetDialogMovableModal",
0x0c0031: "MoveDialogItem",
0x0c0032: "SizeDialogItem",
0x1c0001: "NewGWorld",
0x1c0002: "LockPixels",
0x1c0003: "UnlockPixels",
0x1c0004: "UpdateGWorld",
0x1c0005: "DisposeGWorld",
0x1c0006: "GetGWorld",
0x1c0007: "SetGWorld",
0x1c0008: "CTabChanged",
0x1c0009: "PixPatChanged",
0x1c000a: "PortChanged",
0x1c000b: "GDeviceChanged",
0x1c000c: "AllowPurgePixels",
0x1c000d: "NoPurgePixels",
0x1c000e: "GetPixelsState",
0x1c000f: "SetPixelsState",
0x1c0010: "GetPixBaseAddr",
0x1c0011: "NewScreenBuffer",
0x1c0012: "DisposeScreenBuffer",
0x1c0013: "GetGWorldDevice",
0x1c0014: "QDDone",
0x1c0015: "OffscreenVersion",
0x1c0016: "NewTempScreenBuffer",
0x1c0017: "PixMap32Bit",
0x1c0018: "GetGWorldPixMap",
0x1c0019: "NewGWorldFromPtr",
0x160001: "GetMBarHeight",
0x160002: "NewMenu",
0x160003: "MacGetMenu",
0x160004: "MacAppendMenu",
0x160005: "MacInsertMenu",
0x160006: "MacDeleteMenu",
0x160007: "AppendResMenu",
0x160008: "MacInsertMenuItem",
0x160009: "SetMenuItemText",
0x16000a: "GetMenuItemText",
0x16000b: "SetItemMark",
0x16000c: "GetItemMark",
0x16000d: "SetItemCmd",
0x16000e: "GetItemCmd",
0x16000f: "SetItemIcon",
0x160010: "GetItemIcon",
0x160011: "SetItemStyle",
0x160012: "GetItemStyle",
0x160013: "GetMenuHandle",
0x160014: "CalcMenuSize",
0x160015: "DisableItem",
0x160016: "EnableItem",
0x160017: "FlashMenuBar",
0x160018: "PopUpMenuSelect",
0x16001f: "MacDrawMenuBar",
0x160020: "InvalMenuBar",
0x160021: "InitProcMenu",
0x160022: "GetMenuBar",
0x160023: "SetMenuBar",
0x160024: "SystemEdit",
0x160025: "SystemMenu",
0x160026: "GetNewMBar",
0x160027: "ClearMenuBar",
0x160028: "CheckItem",
0x160029: "CountMItems",
0x16002a: "SetMenuFlash",
0x16002b: "InitMenus",
0x16002c: "MenuKey",
0x16002d: "MenuSelect",
0x16002e: "MenuChoice",
0x16002f: "DisposeMenu",
0x160030: "DeleteMenuItem",
0x160031: "HiliteMenu",
0x160032: "InsertResMenu",
0x160033: "InsertFontResMenu",
0x160034: "InsertIntlResMenu",

0x1d0001: "CreatePortAssociation",
0x1d0002: "DestroyPortAssociation",
0x1d0003: "GetNativeWindowPort",
0x1d0004: "GetPortNativeWindow",
0x1d0008: "QTMLInitInternals",
0x1d0009: "QTMLTermInternals",
0x1d000a: "NativeEventToMacEvent",
0x1d000e: "RegisterAbortAction",
0x1d000f: "UnregisterAbortAction",
0x1d0010: "InitializeQHdr",
0x1d0011: "TerminateQHdr",
0x1d0012: "QTMLYieldCPU",
0x1d0013: "QTMLRegisterInterruptSafeThread",
0x1d0014: "QTMLUnregisterInterruptSafeThread",
0x1d0017: "Endian64_Swap",
0x1d0019: "GetColor",
0x1d001a: "FindFolderEx",
0x1d001d: "ldtox80",
0x1d001e: "x80told",
0x1d0021: "Debugger",
0x1d0022: "DebugStr",
0x1d0024: "QTMLYieldCPUTime",
0x1d0027: "QTMLGetCanonicalPathName",
0x1d0028: "QTMLGetVolumeRootPath",
0x1d0029: "QTMLAcquireWindowList",
0x1d002a: "QTMLReleaseWindowList",
0x1d002b: "NativeRegionToMacRegion",
0x1d002c: "MacRegionToNativeRegion",
0x1d002d: "FSSpecToNativePathName",
0x1d002e: "NativePathNameToFSSpec",

0x1d0033: "QTMLCreateMutex",
0x1d0034: "QTMLDestroyMutex",
0x1d0035: "QTMLGrabMutex",
0x1d0036: "QTMLReturnMutex",

0x1d0037: "QTMLCreateSyncVar",
0x1d0038: "QTMLDestroySyncVar",
0x1d0039: "QTMLTestAndSetSyncVar",
0x1d003a: "QTMLWaitAndSetSyncVar",
0x1d003b: "QTMLResetSyncVar",

0x1d003d: "QTMLTryGrabMutex",

0x1d004e: "QTMLGetDirectXObject",
0x1d004f: "QTMLSetDirectXObject",
0x1d0052: "QTGetAliasInfo",

0x170001: "NewGWorldFromHBITMAP",
0x170003: "QTSetDDPrimarySurface",
0x170004: "QTGetDDObject",
0x170005: "QTMLSetWindowWndProc",
0x170006: "QTMLGetWindowWndProc",
0x170007: "GetPortHDC",
0x170008: "GetPortHBITMAP",
0x170009: "GetPortHPALETTE",
0x17000a: "GetPortHFONT",
0x17000b: "ShowHideTaskBar",
0x17000c: "IsTaskBarVisible",
0x17000e: "QTSetDDObject",
0x17000f: "GetDIBFromPICT",
0x170010: "GetPICTFromDIB",
0x170011: "GetGDeviceSurface",
0x170012: "GetGDeviceAttributes",
0x150002: "SystemZone",
0x150003: "ApplicationZone",
0x150006: "MemError",
0x150007: "GetZone",
0x150008: "NewHandle",
0x150009: "NewHandleSys",
0x15000a: "NewHandleClear",
0x15000b: "NewHandleSysClear",
0x15000c: "HandleZone",
0x15000d: "RecoverHandle",
0x15000f: "NewPtr",
0x150010: "NewPtrSys",
0x150011: "NewPtrClear",
0x150012: "NewPtrSysClear",
0x150013: "PtrZone",
0x150014: "MaxBlock",
0x150015: "MaxBlockSys",
0x150017: "NewEmptyHandle",
0x150018: "NewEmptyHandleSys",
0x150019: "HLock",
0x15001a: "HUnlock",
0x15001b: "HPurge",
0x15001c: "HNoPurge",
0x15001d: "HLockHi",
0x15001e: "TempNewHandle",
0x15001f: "TempMaxMem",
0x150020: "TempFreeMem",
0x150022: "SetZone",
0x150023: "CompactMem",
0x150024: "CompactMemSys",
0x150025: "PurgeMem",
0x150026: "PurgeMemSys",
0x150027: "FreeMem",
0x150028: "FreeMemSys",
0x150029: "ReserveMem",
0x15002a: "ReserveMemSys",
0x15002b: "MaxMem",
0x15002c: "MaxMemSys",
0x15002e: "MoveHHi",
0x15002f: "DisposePtr",
0x150030: "GetPtrSize",
0x150031: "SetPtrSize",
0x150032: "DisposeHandle",
0x150033: "SetHandleSize",
0x150034: "GetHandleSize",
0x150036: "ReallocateHandle",
0x150038: "EmptyHandle",
0x15003b: "HGetState",
0x15003c: "HSetState",
0x15003d: "PurgeSpace",
0x15003e: "BlockMove",
0x15003f: "BlockMoveData",
0x150045: "TempHLock",
0x150046: "TempHUnlock",
0x150047: "TempDisposeHandle",
0x15005b: "HandToHand",
0x15005c: "PtrToXHand",
0x15005d: "PtrToHand",
0x15005e: "HandAndHand",
0x15005f: "PtrAndHand",
0x2a0002: "NewWindow",
0x2a0003: "GetNewWindow",
0x2a0004: "NewCWindow",
0x2a0005: "DisposeWindow",
0x2a0006: "MacCloseWindow",
0x2a0007: "InvalRect",
0x2a0008: "InvalRgn",
0x2a0009: "ValidRect",
0x2a000a: "ValidRgn",
0x2a0015: "GetNewCWindow",
0x2a0016: "SetWTitle",
0x2a0017: "GetWTitle",
0x2a0018: "GetWMgrPort",
0x2a0019: "GetCWMgrPort",
0x2a001a: "SetWRefCon",
0x2a001b: "GetWRefCon",
0x2a001c: "SelectWindow",
0x2a001d: "HideWindow",
0x2a001e: "MacShowWindow",
0x2a001f: "ShowHide",
0x2a0021: "BringToFront",
0x2a0022: "SendBehind",
0x2a0023: "FrontWindow",
0x2a0025: "MacMoveWindow",
0x2a0026: "SizeWindow",
0x2a0027: "ZoomWindow",
0x2a0028: "BeginUpdate",
0x2a0029: "EndUpdate",
0x2a002d: "MacFindWindow",
0x2a002e: "PinRect",
0x2a0034: "GetWVariant",
0x2a0036: "GetGrayRgn",
0x290001: "BitTst",
0x290002: "BitSet",
0x290003: "BitClr",
0x290004: "BitAnd",
0x290005: "BitOr",
0x290006: "BitXor",
0x290007: "BitNot",
0x290008: "BitShift",
0x29000a: "HiWord",
0x29000b: "LoWord",
0x0e0001: "GetMouse",
0x0e0002: "Button",
0x0e0003: "StillDown",
0x0e0005: "TickCount",
0x0e0007: "GetCaretTime",
0x0e0008: "GetEvQHdr",
0x0e0009: "GetDblTime",
0x0e000a: "SetEventMask",
0x0e000b: "PPostEvent",
0x0e000c: "GetNextEvent",
0x0e000d: "WaitNextEvent",
0x0e000e: "EventAvail",
0x0e000f: "PostEvent",
0x0e0010: "OSEventAvail",
0x0e0011: "GetOSEvent",
0x0e0012: "FlushEvents",
0x0e0014: "SystemTask",
0x0e0016: "GetKeys",
0x0e0017: "MacGetDoubleClickTime",
0x10000: "CallComponent",
0x10001: "RegisterComponent",
0x10002: "UnregisterComponent",
0x10003: "CountComponents",
0x10004: "FindNextComponent",
0x10005: "GetComponentInfo",
0x10006: "GetComponentListModSeed",
0x10007: "OpenComponent",
0x10008: "CloseComponent",
0x10009: "DestroyComponent",
0x1000a: "GetComponentInstanceError",
0x1000b: "SetComponentInstanceError",
0x1000c: "GetComponentInstanceStorage",
0x1000d: "SetComponentInstanceStorage",
0x1000e: "GetComponentInstanceA5",
0x1000f: "SetComponentInstanceA5",
0x10010: "GetComponentRefcon",
0x10011: "SetComponentRefcon",
0x10012: "RegisterComponentResource",
0x10013: "CountComponentInstances",
0x10014: "RegisterComponentResourceFile",
0x10015: "OpenComponentResFile",
0x10018: "CloseComponentResFile",
0x1001c: "CaptureComponent",
0x1001d: "UncaptureComponent",
0x1001e: "SetDefaultComponent",
0x10020: "ResolveComponentAlias",
0x10021: "OpenDefaultComponent",
0x10024: "DelegateComponentCall",
0x10029: "GetComponentIconSuite",
0x1002c: "GetComponentTypeModSeed",
0x1002d: "OpenAComponent",
0x1002e: "OpenADefaultComponent",
0x1002f: "OpenAComponentResFile",
0x10035: "GetComponentResource",
0x10036: "GetComponentIndString",
0x10038: "GetComponentPublicResource",
0x10039: "GetComponentPublicResourceList",
0x1003a: "GetComponentPublicIndString",
0x220003: "FontScript",
0x220004: "IntlScript",
0x220006: "IsCmdChar",
0x220007: "FontToScript",
0x220008: "GetScriptManagerVariable",
0x22000a: "GetScriptVariable",
0x22000c: "CharacterByteType",
0x22000d: "CharacterType",
0x220018: "CharByte",
0x220019: "CharType",
0x1f0001: "TextFont",
0x1f0002: "TextFace",
0x1f0003: "TextMode",
0x1f0004: "TextSize",
0x1f0005: "SpaceExtra",
0x1f0006: "DrawChar",
0x1f0007: "DrawString",
0x1f0008: "MacDrawText",
0x1f0009: "CharWidth",
0x1f000a: "StringWidth",
0x1f000b: "TextWidth",
0x1f000c: "MeasureText",
0x1f000d: "GetFontInfo",
0x1f000f: "StdText",
0x1f0010: "StdTxMeas",
0x250003: "SysBeep",
0x250004: "SndDoCommand",
0x250005: "SndDoImmediate",
0x250006: "SndNewChannel",
0x250007: "SndDisposeChannel",
0x250008: "SndPlay",
0x250009: "SndAddModifier",
0x25000a: "SndControl",
0x25000b: "SndSoundManagerVersion",
0x25000f: "SndChannelStatus",
0x250010: "SndManagerStatus",
0x250015: "Comp3to1",
0x250016: "Exp1to3",
0x250017: "Comp6to1",
0x250018: "Exp1to6",
0x25001b: "GetDefaultOutputVolume",
0x25001c: "SetDefaultOutputVolume",
0x25001d: "GetSoundHeaderOffset",
0x25001e: "UnsignedFixedMulDiv",
0x25001f: "GetCompressionInfo",
0x250020: "SetSoundPreference",
0x250021: "GetSoundPreference",
0x250022: "SndGetInfo",
0x250023: "SndSetInfo",
0x250024: "GetSoundOutputInfo",
0x250025: "SetSoundOutputInfo",
0x250026: "GetCompressionName",
0x250027: "SoundConverterOpen",
0x250028: "SoundConverterClose",
0x250029: "SoundConverterGetBufferSizes",
0x25002a: "SoundConverterBeginConversion",
0x25002b: "SoundConverterConvertBuffer",
0x25002c: "SoundConverterEndConversion",
0x25002d: "SoundConverterGetInfo",
0x25002e: "SoundConverterSetInfo",
0x25002f: "OpenMixerSoundComponent",
0x250030: "CloseMixerSoundComponent",
0x25003f: "SoundConverterFillBuffer",
0x250040: "SoundManagerGetInfo",
0x250041: "SoundManagerSetInfo",
0x40001: "CompAdd",
0x40002: "CompSub",
0x40003: "CompNeg",
0x40004: "CompShift",
0x40005: "CompMul",
0x40006: "CompDiv",
0x40007: "CompFixMul",
0x40008: "CompMulDiv",
0x40009: "CompCompare",
0x4000a: "FixMulDiv",
0x4000b: "FracSinCos",
0x4000c: "CompMulDivTrunc",
0x4000d: "UnsignedFixMulDiv",
0x4000e: "FixExp2",
0x4000f: "FixLog2",
0x40010: "FixPow",
0x40011: "CompSquareRoot",
0x40014: "GetMatrixType",
0x40015: "SetIdentityMatrix",
0x40016: "RotateMatrix",
0x40017: "ScaleMatrix",
0x40018: "SkewMatrix",
0x40019: "TranslateMatrix",
0x4001b: "ConcatMatrix",
0x4001c: "InverseMatrix",
0x4001d: "MapMatrix",
0x4001e: "RectMatrix",
0x40020: "CopyMatrix",
0x40021: "EqualMatrix",
0x40022: "TransformFixedPoints",
0x40023: "TransformPoints",
0x40024: "TransformFixedRect",
0x40025: "TransformRect",
0x260001: "SFPutFile",
0x260002: "CustomPutFile",
0x260003: "SFGetFile",
0x260004: "SFPPutFile",
0x260005: "SFPGetFile",
0x260006: "StandardPutFile",
0x260007: "StandardGetFile",
0x260008: "CustomGetFile",
0x180008: "GetDateTime",
0x18000c: "DateToSeconds",
0x18000d: "SecondsToDate",
0x18000e: "DTInstall",
0x180011: "Delay",
0x180013: "Enqueue",
0x180014: "Dequeue",
0x18001f: "ReadLocation",
0x180022: "InsTime",
0x180023: "InsXTime",
0x180024: "Microseconds",
0x180025: "PrimeTime",
0x180026: "RmvTime",
0x180027: "MacGetCurrentProcess",
0x110001: "Gestalt",
0x110004: "NewGestaltValue",
0x110005: "ReplaceGestaltValue",
0x110006: "SetGestaltValue",
0x110007: "DeleteGestaltValue",
0x120001: "GetCIcon",
0x120002: "PlotCIcon",
0x120003: "DisposeCIcon",
0x120004: "GetIcon",
0x120005: "PlotIcon",
0x120006: "PlotIconID",
0x120021: "PlotIconHandle",
0x120022: "PlotSICNHandle",
0x120023: "PlotCIconHandle",
0x0b0001: "NewControl",
0x0b0003: "DisposeControl",
0x0b0004: "KillControls",
0x0b0005: "ShowControl",
0x0b0006: "HideControl",
0x0b0007: "DrawControls",
0x0b0008: "Draw1Control",
0x0b0009: "UpdateControls",
0x0b000a: "HiliteControl",
0x0b000b: "TrackControl",
0x0b000e: "FindControl",
0x0b000f: "MoveControl",
0x0b0010: "SizeControl",
0x0b0011: "SetControlTitle",
0x0b0012: "GetControlTitle",
0x0b0013: "GetControlValue",
0x0b0014: "SetControlValue",
0x0b0015: "GetControlMinimum",
0x0b0016: "SetControlMinimum",
0x0b0017: "GetControlMaximum",
0x0b0018: "SetControlMaximum",
0x0b001a: "SetControlAction",
0x0b001b: "GetControlAction",
0x0b0020: "GetControlComponentInstance",
0x0b0021: "GetDialogControlNotificationProc",
0x0b0022: "GetControlHandleFromCookie",
0x0b0023: "SetControlDefProc",
0x0b0024: "SetControlReference",
0x0b0025: "GetControlReference",
0x280001: "Munger",
0x280002: "NewString",
0x280004: "GetString",
0x280005: "StyledLineBreak",
0x280006: "TruncString",
0x280007: "TruncText",
0x280008: "FindWordBreaks",
0x280017: "c2pstr",
0x280018: "p2cstr",
0x280019: "c2pstrcpy",
0x28001a: "p2cstrcpy",
0x28001c: "IUCompPString",
0x28001d: "IUDateString",
0x28001e: "IUTimeString",
0x28001f: "IUEqualString",
0x280020: "IUMagIDString",
0x280021: "IUMagString",
0x280022: "EqualString",
0x280023: "RelString",
0x280024: "NumToString",
0x280025: "StringToNum",
0x280028: "ExtendedToString",
0x28002a: "IUMagIDPString",
0x230006: "ExitToShell",
0x0f0007: "PBReadSync",
0x0f0008: "PBReadAsync",
0x0f000a: "PBWriteSync",
0x0f000b: "PBWriteAsync",
0x0f000d: "PBGetVInfoSync",
0x0f0021: "PBGetFInfoSync",
0x0f0023: "PBSetFInfoSync",
0x0f002d: "PBGetEOFSync",
0x0f002f: "PBSetEOFSync",
0x0f0035: "PBFlushFileSync",
0x0f003e: "SetVol",
0x0f0041: "FlushVol",
0x0f0046: "FSClose",
0x0f0047: "FSRead",
0x0f0048: "FSWrite",
0x0f004a: "GetFInfo",
0x0f004b: "GetVol",
0x0f004d: "FSDelete",
0x0f004f: "Rename",
0x0f0054: "GetEOF",
0x0f0055: "SetEOF",
0x0f0056: "GetFPos",
0x0f0057: "SetFPos",
0x0f0067: "PBGetFCBInfoSync",
0x0f0069: "PBGetCatInfoSync",
0x0f006d: "PBAllocContigSync",
0x0f0075: "PBHGetVInfoSync",
0x0f0077: "PBHOpenSync",
0x0f0079: "PBHOpenRFSync",
0x0f007b: "PBHOpenDFSync",
0x0f007d: "PBHCreateSync",
0x0f00a2: "PBHGetVolParmsSync",
0x0f00e2: "FSMakeFSSpec",
0x0f00e3: "FSpOpenDF",
0x0f00e4: "FSpOpenRF",
0x0f00e5: "FSpCreate",
0x0f00e7: "FSpDelete",
0x0f00e8: "FSpGetFInfo",
0x0f00ec: "FSpRename",
0x100001: "FixRatio",
0x100002: "FixMul",
0x100003: "FixRound",
0x100004: "Fix2Frac",
0x100005: "Fix2Long",
0x100006: "Long2Fix",
0x100007: "Frac2Fix",
0x100008: "FracMul",
0x100009: "FixDiv",
0x10000a: "FracDiv",
0x10000b: "FracSqrt",
0x10000c: "FracSin",
0x10000d: "FracCos",
0x10000e: "FixATan2",
0x10000f: "RefFrac2X",
0x100010: "RefFix2X",
0x100011: "RefX2Fix",
0x100012: "RefX2Frac",
0x80001: "NewAlias",
0x80002: "NewAliasMinimal",
0x80003: "NewAliasMinimalFromFullPath",
0x80004: "ResolveAlias",
0x80005: "GetAliasInfo",
0x80006: "ResolveAliasFile",
0x80008: "UpdateAlias",
0x80009: "MatchAlias",
0x2b0002: "GetFontName",
0x2b0003: "RealFont",
0x2b0004: "GetFNum",
0x130001: "LNew",
0x130002: "LDispose",
0x130004: "LAddRow",
0x130006: "LDelRow",
0x130007: "LGetSelect",
0x130008: "LLastClick",
0x130009: "LNextCell",
0x13000a: "LSearch",
0x13000c: "LSetDrawingMode",
0x13000d: "LScroll",
0x13000e: "LAutoScroll",
0x13000f: "LUpdate",
0x130010: "LActivate",
0x130012: "LClick",
0x130013: "LAddToCell",
0x130014: "LClrCell",
0x130015: "LGetCell",
0x130016: "LRect",
0x130017: "LSetCell",
0x130018: "LSetSelect",
0x130019: "LDraw",
0x13001a: "LGetCellDataLocation",
0x13001c: "LSetNotificationCallback",
0x13001d: "LSetLDEF",
0x13001e: "GetListVisibleBounds",
0x210001: "InfoScrap",
0x210002: "UnloadScrap",
0x210003: "LoadScrap",
0x210004: "GetScrap",
0x210005: "ZeroScrap",
0x210006: "PutScrap",
0x14000b: "LMGetTheZone",
0x140019: "LMGetTicks",
0x14004b: "LMGetMemErr",
0x14005d: "LMGetSysZone",
0x14006b: "LMGetDoubleTime",
0x14008d: "LMGetScrnBase",
0x14008f: "LMGetMainDevice",
0x140091: "LMGetDeviceList",
0x1400bf: "LMGetWindowList",
0x1400c2: "LMGetPaintWhite",
0x1400c3: "LMSetPaintWhite",
0x1400c6: "LMGetGrayRgn",
0x1400f5: "LMGetResLoad",
0x1400f7: "LMGetResErr",
0x140137: "LMGetTheGDevice",
0x240001: "SPBVersion",
0x240006: "SPBGetIndexedDevice",
0x240007: "SPBOpenDevice",
0x240008: "SPBCloseDevice",
0x240009: "SPBRecord",
0x24000b: "SPBMillisecondsToBytes",
0x24000c: "SPBBytesToMilliseconds",
0x24000d: "SetupSndHeader",
0x24000e: "SetupAIFFHeader",
0x24000f: "ParseAIFFHeader",
0x240010: "ParseSndHeader",
0x240011: "SPBPauseRecording",
0x240012: "SPBStopRecording",
0x240013: "SPBGetDeviceInfo",
0x240014: "SPBSetDeviceInfo",
0x240015: "SPBResumeRecording",
0x240016: "SPBGetRecordingStatus",
0x1b0003: "PrOpen",
0x1b0004: "PrClose",
0x1b0005: "PrintDefault",
0x1b0006: "PrValidate",
0x1b0007: "PrStlDialog",
0x1b0008: "PrJobDialog",
0x1b0009: "PrStlInit",
0x1b000a: "PrJobInit",
0x1b000b: "PrJobMerge",
0x1b000c: "PrDlgMain",
0x1b000d: "PrOpenDoc",
0x1b000e: "PrCloseDoc",
0x1b000f: "PrOpenPage",
0x1b0010: "PrClosePage",
0x1b0011: "PrPicFile",
0x1b0012: "PrError",
0x1b0013: "PrSetError",
0x1b0014: "PrGeneral",
0x270002: "TENew",
0x270003: "TEDispose",
0x270004: "TESetText",
0x270005: "TEGetText",
0x270006: "TEIdle",
0x270007: "TESetSelect",
0x270008: "TEActivate",
0x270009: "TEDeactivate",
0x27000e: "TEDelete",
0x27000f: "TEInsert",
0x270010: "TESetAlignment",
0x270011: "TEUpdate",
0x270012: "TETextBox",
0x270013: "TEScroll",
0x270014: "TESelView",
0x270015: "TEPinScroll",
0x270016: "TEAutoView",
0x270017: "TECalText",
0x270018: "TEGetOffset",
0x270019: "TEGetPoint",
0x27001b: "TEStyleNew",
0x27001c: "TESetStyleHandle",
0x27001d: "TEGetStyleHandle",
0x27001e: "TEGetStyle",
0x27001f: "TEStylePaste",
0x270020: "TESetStyle",
0x270021: "TEReplaceStyle",
0x270022: "TEGetStyleScrapHandle",
0x270023: "TEStyleInsert",
0x270024: "TEGetHeight",
0x270025: "TEContinuousStyle",
0x270026: "TEUseStyleScrap",
0x270028: "TENumStyles",
0x270029: "TEFeatureFlag",
}

########NEW FILE########
__FILENAME__ = comment
# commment.py
#
# for public release, 2012
#

import idc

'''
tagged-comments plugin
[arizvisa@tippingpoint.com]
'''

EXPORT = ['toString', 'toDict']

def tokens(input):
    input = iter(input)

    ### '['
    char = input.next()
    assert char == '[', 'unexpected token %s'% char
    yield char

    ### key
    res = ''
    char = input.next()
    while char != ']':
        res += char
        char = input.next()
    yield res

    ### ']'
    yield char

    ### ' ' '\t'
    while True:
        res = input.next()
        if res in ' \t':
            continue
        break
    
    ### value
    yield res+''.join(list(input))

def getKVFromString(string):
    res = list( tokens(string) )
    l = len(res)
    if l == 3:
        assert (res[0] == '[') and (res[2] == ']')
        return (res[1], '')

    assert (l==4) and (res[0] == '[') and (res[2] == ']')
    return (res[1], res[-1])

def getStringFromKV(key, value):
    return '[%s] %s'% (key, value)

def getIntFromKV(tuple):
    key, value = tuple
    return '[%s] %x'% (key, value)

def IntifyString(value):
    if value[:2] == '0x':
        return int(value[2:], 16) 
    if value[-1:] == 'h':
        return int(value[:-1], 16) 
    if value[-1:] == 'd':
        return int(value[:-1], 10) 
    if value[-1:] == 'b':
        return int(value[:-1], 2) 
    return int(value)

### our stars
def serializeKeyValue(k, v):
    #if k == 'address':
    #    return '%08x'% int(v)
    if type(v) is int:
        if v < 0:
            return '-0x%x'% -int(v)
        return '0x%x'% int(v)
    elif type(v) is dict:
        # due to how bad this code is, i'm not allowing myself to add support for various types
        raise NotImplementedError("Please don't store dicts using this code. Thanks.")
    elif type(v) in (list,set):
        try:
            return '[ %s ]'% ','.join(map(hex,v))
        except:
            pass
        return repr(v)
    return str(v)

def toList(string):
    '''
    converts the following looking string into a list of numbers or strings

    [type] void*
    [value] 0x80ad
    [synopsis] ok....
    '''
    if string is None:      # always return something
        string = ''

    try:
        rows = [n for n in string.split('\n') if n]
        stritems = [getKVFromString(n) for n in rows]

    except AssertionError:
#        stritems = [('untagged-value', string)]
        stritems = [('', string)]

    items = []
    for k,v in stritems:
        try:
            if v.startswith('['):
                v = eval(v)
            else:
                v = IntifyString(v)
        except:
            pass
        items.append( (k,v) )
    return items

def toDict(string):
    items = toList(string)

    # pull out/rename duplicates
    blah = set()
    all = set()
    for k,v in items:
        if k in all:
            blah.add(k)
            continue
        all.add(k)
    
    # fix up duplicates
    res = []
    for i,(k,v) in enumerate(items):
        if k in blah:
            k = '%s_%x'%(k, i)
        res.append((k,v))

    # done
    return dict(res)

def toString(dict):
    '''
    converts a dictionary to it's string representation.

    {'synopsis': 'ok....', 'type': 'void*', 'value': 32941}

    to

    [type] void*
    [value] 0x80ad
    [synopsis] ok....
    '''
    rawitems = dict.items()
    stritems = [(k, serializeKeyValue(k,v)) for k,v in rawitems if v is not None]
    rows = [getStringFromKV(k,v) for k,v in stritems]
    return '\n'.join(rows)

def select_function(list, **where):
    def has(ea):
        d = function.tag(ea)
        for k,v in where.iteritems():
            if k not in d or (v is not None and v != d[k]):
                return False
        return True
    
    for x in list:
        if has(x):
            yield x
        continue
    return

if True:
    def has_and(dictionary, **where):
        for k,v in where.iteritems():
            if k not in dictionary or (v is not None and v != dictionary[k]):
                return False
            continue
        return True

    def has_or(dictionary, **where):
        for k,v in where.iteritems():
            if k in dictionary or (v is None and v == dictionary[k]):
                return True
            continue
        return False

########NEW FILE########
__FILENAME__ = database
# database.py
#
# for public release, 2012
#

import idc,idautils,idaapi as ida
import instruction,function,segment

def isCode(ea):
    '''True if ea marked as code'''
    return idc.isCode( idc.GetFlags(ea) )

def isData(ea):
    '''True if ea marked as data'''
    return idc.isData( idc.GetFlags(ea) )

def isUnknown(ea):
    '''True if ea marked unknown'''
    return idc.isUnknown( idc.GetFlags(ea) )

def isHead(ea):
    return idc.isHead( idc.GetFlags(ea) )

def isTail(ea):
    return idc.isTail( idc.GetFlags(ea) )

def functions():
    '''Returns a list of all the functions in the current database (using idautils)'''
    min,max = idc.MinEA(), idc.MaxEA()
    return list(idautils.Functions(min, max))

def segments():
    '''Returns a list of all segments in the current database'''
    return list(idautils.Segments())

def getblock(start, end):
    '''Return a string of bytes'''
    result = [ idc.Byte(ea) for ea in xrange(start, end) ]
    return ''.join(__builtins__['map'](chr, result))

def prev(ea):
    '''return the previous address (instruction or data)'''
    return idc.PrevHead(ea, idc.MinEA())

def next(ea):
    '''return the next address (instruction or data)'''
    return idc.NextHead(ea, idc.MaxEA())

def walk(ea, next, match):
    if match(ea):
        return ea

    while True:
        ea = next(ea)
        if match(ea):
            return ea
        continue
    assert False is True

def prevdata(ea):
    '''return previous address containing data referencing it'''
    return walk(ea, prev, dxup)

def nextdata(ea):
    '''return next address containing data referencing it'''
    return walk(ea, next, dxup)

def prevcode(ea):
    '''return previous address containing code referencing it'''
    return walk(ea, prev, cxup)

def nextcode(ea):
    '''return next address containing code referencing it'''
    return walk(ea, next, cxup)

def prevref(ea):
    '''return previous address containing any kind of reference to it'''
    return walk(ea, prev, up)

def nextref(ea):
    '''return next address containing any kind of reference to it'''
    return walk(ea, next, up)

def guessrange(ea):
    '''Try really hard to get boundaries of the block at specified address'''
    start,end = function.getRange(ea)
    if function.contains(start, ea) and not (ea >= start and ea < end):
        return (idc.GetFchunkAttr(ea, idc.FUNCATTR_START), idc.GetFchunkAttr(ea, idc.FUNCATTR_END))
    return start,end

def decode(ea):
    return instruction.decode(ea)

# FIXME: there's issues when trying to get xrefs from a structure or array,
#        if it's not the first address of the item, then it will return no
#        xrefs for that particular address. it might be possible to fix this
#        in this module.

#   -- it seems like ida makes structures and stuff into an instruction_t or
#       something
def iterate_refs(address, start, next):
    ea = address
    address = start(ea)
    while address != ida.BADADDR:
        yield address
        address = next(ea, address)
    return

def drefs(ea, descend=False):
    if descend:
        start,next = ida.get_first_dref_from, ida.get_next_dref_from
    else:
        start,next = ida.get_first_dref_to, ida.get_next_dref_to

    for addr in iterate_refs(ea, start, next):
        yield addr
    return

def crefs(ea, descend=False):
    if descend:
        start,next = ida.get_first_cref_from, ida.get_next_cref_from
    else:
        start,next = ida.get_first_cref_to, ida.get_next_cref_to

    for addr in iterate_refs(ea, start, next):
        yield addr
    return

def dxdown(ea):
    return list(drefs(ea, True))

def dxup(ea):
    return list(drefs(ea, False))

def cxdown(ea):
    result = set(crefs(ea, True))
    result.discard(next(ea))
    return list(result)

def cxup(ea):
    result = set(crefs(ea, False))
    result.discard(prev(ea))
    return list(result)

def up(ea):
    '''All locations that reference specified address'''
    return cxup(ea) + dxup(ea)

def down(ea):
    '''All locations that are referenced by the specified address'''
    return cxdown(ea) + dxdown(ea)

def demangle(string):
    return idc.Demangle(string, idc.GetLongPrm(idc.INF_LONG_DN))

def log(string, *argv):
    '''idc.Message(formatstring, ...)'''
    return idc.Message('>' + string% argv + '\n')

def marks():
    '''returns all the known marked positions in an .idb'''
    index = 1
    while True:
        ea = idc.GetMarkedPos(index)
        if ea == 0xffffffff:
            break
        comment = idc.GetMarkComment(index)
        yield ea, comment
        index += 1
    return

def mark(ea, message):
    # TODO: give a warning if we're replacing a mark at the given ea
    nextmark = len(list(marks())) + 1
    idc.MarkPosition(ea, 0, 0, 0, nextmark, message)

def iterate(start, end):
    '''Iterate through instruction/data boundaries within the specified range'''
    while start < end:
        yield start
        start = next(start)
    return

def go(ea):
    '''slightly less typing for idc.Jump'''
    if not contains(ea):
        left,right=range()
        raise ValueError("Unable to goto address %x. (valid range is %x - %x)"% (ea,left,right))
    idc.Jump(ea)
    return ea

def h():
    '''slightly less typing for idc.ScreenEA()'''
    return idc.ScreenEA()

here = h    # alias

def filename():
    return idc.GetInputFile()

def path():
    filepath = idc.GetIdbPath().replace('\\','/')
    return filepath[: filepath.rfind('/')] 

def baseaddress():
    return ida.get_imagebase()
base=baseaddress

def getoffset(ea):
    return ea - baseaddress()

def search(name):
    return idc.LocByName(name)

def searchname(name):
    print 'database.searchname has been deprecated in favor of database.search'
    return search(name)

def name(ea, string=None):
    '''Returns the name at the specified address. (local than global)'''
    if string is not None:
        SN_NOCHECK = 0x00
        SN_NOLIST = 0x80
        SN_LOCAL = 0x200
        SN_PUBLIC = 0x02

        n = name(ea)
        
        flags = SN_NOCHECK
        try:
            function.top(ea)
            flags |= SN_LOCAL
        except ValueError:
            flags |= 0

        idc.MakeNameEx(ea, string, flags)
        #tag(ea, '__name__', string)
        return n

    return None

def blocks(start, end):
    '''Returns each block between the specified range of instructions'''
    block = start
    for ea in iterate(start, end):
        nextea = next(ea)

        if idc.GetMnem(ea).startswith('call'):      # FIXME: heh. ;)
            continue

        if idc.GetMnem(ea).startswith('ret'):       #   whee
            yield block,nextea
            block = ea

        elif cxdown(ea):
            yield block,nextea
            block = nextea

        elif cxup(ea) and block != ea:
            yield block,ea
            block = ea
        continue
    return

def map(l, *args, **kwds):
    '''Execute provided callback on all functions in database. Synonymous to map(l,db.functions())'''
    all = functions()
    result = []
    for i,x in enumerate(all):
        print '%x: processing # %d of %d'%( x, i+1, len(all) )
        result.append( l(x, *args, **kwds) )
    return result

def range():
    '''Return the total address range of the database'''
    left,right = 0xffffffff,0x00000000
    for x in segments():
        l,r = segment.getRange(x)
        if l < left:
            left = l
        if r > right:
            right = r
        continue
    return baseaddress(), right

def contains(ea):
    l,r = range()
    return (ea >= l) and (ea < r)


########NEW FILE########
__FILENAME__ = function
# function.py
#
# for public release, 2012
#

import idc, comment, database, structure, idautils
'''
function-context

generic tools for working in the context of a function.
'''
#EXPORT = ['getComment', 'setComment', 'chunks', 'getName', 'setName', 'getRange', 'make', 'tag', 'contains', 'getBranches']

def getComment(ea, repeatable=1):
    return idc.GetFunctionCmt(int(ea), repeatable)
def setComment(ea, string, repeatable=1):
    return idc.SetFunctionCmt(int(ea), string, repeatable)

def getName(ea):
    '''fetches the function name, returns None on no function'''
    res = idc.GetFunctionName(ea)
    if res:
        return res
    return None

def setName(ea, name):
    '''sets the function name, returns True or False based on success'''
    res = idc.MakeNameEx(ea, name, 2)
    return [False, True][int(res)]

def name(ea, *args):
    '''sets/gets the function name'''
    if args:
        name, = args
        return setName(ea, name)
    return getName(ea)

def chunks(ea):
    '''enumerates all chunks in a function '''
    res = idc.FirstFuncFchunk(ea)
    while res != idc.BADADDR:
        (start, end) = idc.GetFchunkAttr(res, idc.FUNCATTR_START), idc.GetFchunkAttr(res, idc.FUNCATTR_END)
        yield start,end
        res = idc.NextFuncFchunk(ea, res)
    return

def getRange(ea):
    '''tuple containing function start and end'''
    start, end = (idc.GetFunctionAttr(ea, idc.FUNCATTR_START), idc.GetFunctionAttr(ea, idc.FUNCATTR_END))
    if (start == 0xffffffff) and (end == 0xffffffff):
        raise ValueError, 'address %x is not contained in a function'% ea
    return start, end

def make(start, end=idc.BADADDR):
    '''pseudo-safely makes the address at start a function'''
    if database.isCode(start):
        return idc.MakeFunction(start, end)
    raise ValueError, 'address %x does not contain code'% start

def contains(function, address):
    '''Checks if address is contained in function and any of it's chunks'''
    (start,end) = getRange(function)
    if address >= start and address < end:
        return True

    for start,end in chunks(function):
        if address >= start and address < end:
            return True
        continue

    return False

def top(ea):
    '''Jump to the top of the specified function'''
    min,max = getRange(ea)
    return min

def marks(function):
    result = []
    function = top(function)
    for ea,comment in database.marks():
        try:
            if top(ea) == function:
                result.append( (ea,comment) )
        except ValueError:
            pass
        continue
    return result

def __select(function, q):
    for start,end in chunks(function):
        for ea in database.iterate(start, end):
            d = database.tag(ea)        # FIXME: bmn noticed .select yielding empty records
            if d and q.has(d):
                yield ea
            continue
        continue
    return

def select(function, *q, **where):
    if where:
        print "function.select's kwd arguments have been deprecated in favor of query"

    result = list(q)
    for k,v in where.iteritems():
        if v is None:
            result.append( query.hasattr(k) )
            continue
        result.append( query.hasvalue(k,v) )
    return __select(top(function), query._and(*result) )

# function frame attributes
def getFrameId(function):
    '''Returns the structure id of the frame'''
    return idc.GetFunctionAttr(function, idc.FUNCATTR_FRAME)

def getAvarSize(function):
    '''Return the number of bytes occupying argument space'''
    max = structure.size(getFrameId(function))
    total = getLvarSize(function) + getRvarSize(function)
    return max - total

def getLvarSize(function):
    '''Return the number of bytes occupying local variable space'''
    return idc.GetFunctionAttr(function, idc.FUNCATTR_FRSIZE)

def getRvarSize(function):
    '''Return the number of bytes occupying any saved registers'''
    return idc.GetFunctionAttr(function, idc.FUNCATTR_FRREGS) + 4   # +4 for the pc because ida doesn't count it

def getSpDelta(ea):
    '''Gets the stack delta at the specified address'''
    return idc.GetSpd(ea)

def iterate(function):
    '''Iterate through all the instructions in each chunk of the specified function'''
    for start,end in chunks(function):
        for ea in database.iterate(start, end):
            yield ea
        continue
    return

def searchinstruction(function, match=lambda insn: True):
    for ea in iterate(function):
        if match( database.decode(ea) ):
            yield ea
        continue
    return

def blocks(function):
    '''Returns each block in the specified function'''
    for start,end in chunks(function):
        for r in database.blocks(start, end):
            yield r
        continue
    return


########NEW FILE########
__FILENAME__ = instruction
# instruction.py
#
# for public release, 2012
#

import idc
def get(ea, n):
    '''Returns a tuple describing a specific operand of an instruction'''
    return (idc.GetOpType(ea, n), idc.GetOperandValue(ea, n))

def repr(ea, n):
    '''Returns the repr of an operand of an instruction'''
    return idc.GetOpnd(ea, n)

def mnemonic(ea):
    '''Returns the mnemonic of an instruction'''
    return idc.GetMnem(ea)

def decode(ea):
    import ia32
    '''Disassemble instruction at specified address'''
    def bytegenerator(ea):
        while True:
            yield chr(idc.Byte(ea))
            ea += 1
    return ia32.consume(bytegenerator(ea))

########NEW FILE########
__FILENAME__ = segment
# segment.py
#
# for public release, 2012
#

'''
segment-context

generic tools for working with segments
'''
import idc,idautils,database,idaapi

def getName(ea):
    return idc.SegName(ea)

def getRange(ea):
    return idc.GetSegmentAttr(ea, idc.SEGATTR_START), idc.GetSegmentAttr(ea, idc.SEGATTR_END)

def get(name):
    for x in idautils.Segments():
        if getName(x) == name:
            return x
        continue
    raise KeyError(name)

def top(ea):
    return idc.GetSegmentAttr(ea, idc.SEGATTR_START)

def bottom(ea):
    return idc.GetSegmentAttr(ea, idc.SEGATTR_END)


def sameSegment(x, y):
	'''Returns true if x and y are within the same segment'''
	if idc.SegStart(x) == idc.SegStart(y): 
		return True
	else: 
		return False

def getSegsInfo():
	'''
	Returns a list of all segments in the form: (name, segstart, segend) 
	'''

	segments = list(idautils.Segments())

	res = []
	for s in segments:
		res.append((idc.SegName(s), idc.SegStart(s), idc.SegEnd(s)))
	
	return res

def realloc(ea, size, name=".newseg"):
	'''Deletes the segment for which 'ea' is a part of. Re-creates it with the given size and returns its base address'''

	# XXX: so, this is ghetto, but I'm going to leverage segment.alloc to create a 
	# new segment, steal its address, delete it, and move this segment there with a new size
	new_seg = alloc(size, name) 
	idc.SegDelete(new_seg, True)

	# move our existing segment
	idc.MoveSegm(ea, new_seg, True)
		
	# change its bounds
	idc.SetSegBounds(new_seg, new_seg, new_seg+size, True)

	return new_seg


def alloc(size, name):
	'''Allocates a segment of the given size.'''

	# first lets get the last segment in this binary
	last_seg_end = idaapi.get_last_seg().endEA

	# and the first
	first_seg_start = idaapi.get_first_seg().startEA

	# now see how many bytes we have from there to 0xFFFFFFFF
	bytes_high = 0xFFFFFFFF - last_seg_end

	# now see how many bytes we have from 0x0 to the first segments start  
	bytes_low = first_seg_start

	# check where we have more room
	if bytes_high > bytes_low:
		print "[*] segment.py: there is room above current segments"
		new_seg_start = last_seg_end + 0x10000
		new_seg_start = new_seg_start & 0xFFFF0000
	else:
		print "[*] segment.py: there is room below current segments"
		new_seg_start = 0 + 0x1000

	idc.SegCreate(new_seg_start, new_seg_start+size, 0, True, 3, 2)
	idc.SegRename(new_seg_start, name)
	
	return new_seg_start

########NEW FILE########
__FILENAME__ = structure
# structure.py
#
# for public release, 2012
#

import idc, comment, database
'''
structure-context

generic tools for working in the context of a structure.
'''

import idaapi
def get(id):
    return idaapi.get_struc(id)

def name(id, name=None):
    if name is None:
        return idc.GetStrucName(id)
    return idc.SetStrucName(id, name)

def search(name):
    return idc.GetStrucIdByName(name)

def size(id):
    return idc.GetStrucSize(id)

def members(id):
    st = idaapi.get_struc(id)
    if not st:
        # empty structure
        return

    size = idaapi.get_struc_size(st)

    offset = 0
    for i in range(st.memqty):
        m = st.get_member(i)
        ms = idaapi.get_member_size(m)

        left,right = m.soff,m.eoff

        if offset < left:
            yield (offset,left-offset), (None,None)
            offset = left

        yield (offset,ms),(idaapi.get_member_name(m.id), idaapi.get_member_cmt(m.id, 1))
        offset += ms
    return

def fragment(id, offset, size):
    member = members(id)

    # seek
    while True:
        (m_offset,m_size),(m_name,m_cmt) = member.next()
        
        left,right = m_offset, m_offset+m_size
        if (offset >= left) and (offset < right):
            yield (m_offset,m_size),(m_name,m_cmt)
            size -= m_size
            break
        continue
        
    # return
    while size > 0:
        (m_offset,m_size),(m_name,m_cmt) = member.next()
        yield (m_offset,m_size),(m_name,m_cmt)
        size -= m_size

    return

########NEW FILE########
__FILENAME__ = idapythonrc
# __init__.py
#
# for public release, 2012
#
#

import sys,os
import idc,idautils,idaapi

from PySide import QtGui as QtGui

# store the root path
import __root__
root = __root__.__file__[ : __root__.__file__.rfind(os.sep) ]

# add subdirs to the search path
# XXX: we might be able to do this via the ihooka module
for h in ['base','app', 'user', r'toolbag', r'toolbag%sproviders' % os.sep, r'toolbag%sagent%sdbg' % (os.sep, os.sep), r'toolbag%sagent' % os.sep]:
    sys.path.append('%s%c%s'% (root, os.sep, h))

# import the default modules
import comment,database,segment,function
import instruction

# shortcuts
(db,fn) = (database,function)
h,go,top = (db.h, db.go, lambda:fn.top(db.h()))
hex = lambda i: '%x'% i

# try and execute our user's idapythonrc.py
try:
    if (os.getenv('HOME') and os.path.exists('%s%cidapythonrc.py'% (os.getenv('HOME'), os.sep))):
        execfile( '%s%cidapythonrc.py'% (os.getenv('HOME'), os.sep) )
    elif (os.getenv('USERPROFILE') and os.path.exists('%s%cidapythonrc.py'% (os.getenv('USERPROFILE'), os.sep)) ):
        execfile( '%s%cidapythonrc.py'% (os.getenv('USERPROFILE'), os.sep) )
    elif (os.getenv('USERPROFILE') and os.path.exists('%s%c_idapythonrc.py'% (os.getenv('USERPROFILE'), os.sep)) ):
        execfile( '%s%c_idapythonrc.py'% (os.getenv('USERPROFILE'), os.sep) )
    elif (os.getenv('USERNAME') and os.path.exists('%s%suser%s%s.py' % (root, os.sep, os.sep, os.getenv('USERNAME').lower()) ) ):
        execfile( '%s%suser%s%s.py'% (root, os.sep, os.sep, os.getenv('USERNAME').lower()) )
    else:
        print '[!] Unable to load idapythonrc.py from the user\'s home directory'
    pass
except IOError:
    print 'warning: No idapythonrc.py file found in home directory'

except Exception, e:
    print 'warning: Exception %s raised'% repr(e)
    import traceback
#    tb = traceback.format_stack()
#    print ''.join(tb)
    traceback.print_exc()

########NEW FILE########
__FILENAME__ = agent
#!/usr/bin/env python
#
#
import os
import sys
import socket
import struct
import binascii
from multiprocessing import Process
from multiprocessing.managers import BaseManager
sys.path.append("%s%c%s" % (os.getcwd(), os.sep, "dbg"))

class Agent(BaseManager):
    pass
    
allofthethings = dict()

def writeFile(filename, data):
    # 'binary' must be specified for Windows
    "[*] writing %s [%i bytes]" % (filename, len(data))
    fd = open(filename, "wb")
    fd.write(data)
    fd.close()

# return data from file 
def readFile(filename):
    fd = open(filename, "rb")
    data = fd.read()
    fd.close()
    return data

def load(modulename):
    print "[*] loading module %s" % modulename
    module = __import__(modulename)
    allofthethings[modulename]=module

def get(objectname, attrname):
    print "[*] looking for attrname %s" % attrname
    attr = getattr(allofthethings[objectname], attrname)
    print str(type(attr))
    fullname = objectname+"_"+attrname
    print "[*] registering %s" % fullname
    Agent.register(str(fullname), attr)
    allofthethings[fullname]=attr
    return str(type(attr))

def runProcess(targetfunc, arguments, procname):
    runproc = Process(target=targetfunc, args=arguments)
    newproc.start()
    allofthethings[procname]=newproc

def debugPrint(s):
    print "[*] Message from controller: %s" % s

# main function
if __name__ == "__main__":
    argc = len(sys.argv)

    # First get arguments for AgentManager
    ip = sys.argv[1]
    port = sys.argv[2]
    key = sys.argv[3]

    print "[*] setting up agent on %s:%s [%s]" % (ip,port,key)

    print "[*] registering methods"
    Agent.register("get", get)
    Agent.register("load", load)
    Agent.register("readFile", readFile)
    Agent.register("writeFile", writeFile)
    Agent.register("printmsg", debugPrint)
    Agent.register("runProcess", runProcess)

    agent = Agent((ip,int(port)), authkey=key)
    print "[*] starting agent loop"
    server = agent.get_server()
    server.serve_forever()
    
    # exit
    sys.exit(0)

########NEW FILE########
__FILENAME__ = agentmanager
#!/usr/bin/env python
# 
#
from multiprocessing.managers import BaseManager

class Illusion:
    def __init__(self, name, agent):
        self.name = name
        self.agent = agent
        self.localattrs = dict()

    def __getattr__(self, item):
#        print "illusion __getattr__ %s" % item
        thetype = self.agent.get(self.name, item)._getvalue()
#        print "the type: %s" % thetype
        accepted = list()
        accepted.append("<type 'instancemethod'>")
        accepted.append("<type 'classobj'>")
        accepted.append("<type 'function'>")
        fullname=self.name+"_"+item

        if thetype in accepted:
#            print "found accepted type..."
            AgentManager.register(fullname)
            return getattr(self.agent, fullname)

        else:
#            print "returning an illusion"
            return Illusion(fullname, self.agent)
        
# AganetBase: extends BaseManager 
# this is test out using disconnect with the built-in connect
# the idea is to avoid connection timeouts, and instead of 
# changing the default timeout value, to just connect/disconnect
# before/after each use of the networked manager
class AgentManager(BaseManager):
    def __init__(self, address, authkey):
        BaseManager.__init__(self, address, authkey)
        self.srvAddr = address
        self.srvKey = authkey

        AgentManager.register("get")
        AgentManager.register("load")
        AgentManager.register("readFile")
        AgentManager.register("writeFile")
        AgentManager.register("printmsg")

        self.localattrs = dict()

    def loadmodule(self, modulename):
        print "[*] loading module %s" % modulename
        self.load(modulename)
        self.localattrs[modulename] = Illusion(modulename, self)
        
    def __getattr__(self, item):
        if item in self.localattrs.keys():
            return self.localattrs[item]

    # disconnect
    def disconnect(self):
        conn = self._Client(self.srvAddr, self.srvKey)
        conn.close()


########NEW FILE########
__FILENAME__ = cluster

"""
Cobra's built in clustering framework
"""

import gc
import sys
import time
import cobra
import dcode
import Queue
import struct
import socket
import urllib2
import traceback
import threading
import subprocess

cluster_port = 32123
cluster_ip = "224.69.69.69"

sub_cmd = """
import cobra.cluster
cobra.cluster.getAndDoWork("%s", docode=%s)
"""

class InvalidInProgWorkId(Exception):
    def __init__(self, workid):
        Exception.__init__(self, "Work ID %d is not valid" % workid)
        self.workid = workid

class ClusterWork(object):
    """
    Extend this object to create your own work units.  Do it in
    a proper module (and not __main__ to be able to use this
    in conjunction with cobra.dcode).
    """
    def __init__(self, timeout=None):
        object.__init__(self)
        self.id = None # Set by adding to the server
        self.server = None # Set by ClusterClient
        self.starttime = 0
        self.endtime = 0 # Both are set by worker before and after work()
        self.timeout = timeout
        self.touchtime = None
        self.excinfo = None # Will be exception traceback on work unit fail.

    def touch(self): # heh...
        """
        Update the internal "touch time" which is used by the timeout
        subsystem to see if this work unit has gone too long without
        making progress...
        """
        self.touchtime = time.time()

    def isTimedOut(self):
        """
        Check if this work unit is timed out.
        """
        if self.timeout == None:
            return False
        if self.touchtime == None:
            return False
        return (self.touchtime + self.timeout) < time.time()

    def work(self):
        """
        Actually do the work associated with this work object.
        """
        print "OVERRIDE ME"
        for i in range(10):
            self.setCompletion(i*10)
            self.setStatus("Sleeping: %d" % i)
            time.sleep(1)

    def done(self):
        """
        This is called back on the server once a work unit
        is complete and returned.
        """
        print "OVERRIDE DONE"

    def setCompletion(self, percent):
        """
        Work units may call this whenever they like to
        tell the server how far along their work they are.
        """
        self.touch()
        self.server.setWorkCompletion(self.id, percent)

    def setStatus(self, status):
        """
        Work units may call this to inform the server of
        their status.
        """
        self.touch()
        self.server.setWorkStatus(self.id, status)

class ClusterCallback:
    """
    Place one of these in the ClusterServer to get synchronous
    event information about what's going on in the cluster server.
    (mostly for the GUI).
    """

    def workAdded(self, server, work):
        pass
    def workGotten(self, server, work):
        pass
    def workStatus(self, server, workid, status):
        pass
    def workCompletion(self, server, workid, completion):
        pass
    def workDone(self, server, work):
        pass
    def workFailed(self, server, work):
        pass
    def workTimeout(self, server, work):
        pass
    def workCanceled(self, server, work):
        pass

class VerboseCallback(ClusterCallback):
    # This is mostly for testing...
    def workAdded(self, server, work):
        print "WORK ADDED: %d" % work.id
    def workGotten(self, server, work):
        print "WORK GOTTEN: %d" % work.id
    def workStatus(self, server, workid, status):
        print "WORK STATUS: (%d) %s" % (workid, status)
    def workCompletion(self, server, workid, completion):
        print "WORK COMPLETION: (%d) %d%%" % (workid, completion)
    def workDone(self, server, work):
        print "WORK DONE: %d" % work.id
    def workFailed(self, server, work):
        print "WORK FAILED: %d" % work.id
    def workTimeout(self, server, work):
        print "WORK TIMEOUT: %d" % work.id
    def workCanceled(self, server, work):
        print "WORK CANCELED %d" % work.id

import collections

class ClusterServer:
    def __init__(self, name, maxsize=None, docode=False, bindsrc="", cobrad=None):
        """
        The cluster server is the core of the code that manages work units.

        Arguments:
            maxsize - How big should the work queue be before add blocks
            docode  - Should we also be a dcode server?
            bindsrc - Should we bind a src IP for our multicast announcements?
            cobrad  - Should we use an existing cobra daemon to share our objects?
        """
        self.go = True
        self.name = name
        self.nextwid = 0
        self.inprog = {}
        self.maxsize = maxsize
        self.queue = collections.deque()
        self.qcond = threading.Condition()
        self.widiter = iter(xrange(999999999))

        # Initialize a cobra daemon if needed
        if cobrad == None:
            cobrad = cobra.CobraDaemon(host="", port=0)
        self.cobrad = cobrad
        self.cobraname = self.cobrad.shareObject(self)

        # Setup our transmission socket
        self.sendsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sendsock.bind((bindsrc, 0))

        # Set this to a ClusterCallback extension if
        # you want notifications.
        self.callback = None

        if docode:
            self.cobrad.shareObject(dcode.DcodeFinder(), "DcodeServer")

        # Fire the timeout monitor thread...
        thr = threading.Thread(target=self.timerThread)
        thr.setDaemon(True)
        thr.start()

    def __touchWork(self, workid):
        # Used to both validate an inprog workid *and*
        # update it's timestamp for the timeout thread
        work = self.inprog.get(workid, None)
        if work == None:
            raise InvalidInProgWorkId(workid)
        work.touch()

    def __cleanWork(self, workid):
        # Used by done/timeout/etc to clea up an in
        # progress work unit
        return self.inprog.pop(workid, None)

    def timerThread(self):
        # Internal function to monitor work unit time
        while self.go:
            try:
                for id,work in self.inprog.items():
                    if work.isTimedOut():
                        self.timeoutWork(work)

            except Exception, e:
                print "ClusterTimer: %s" % e

            time.sleep(2)

    def shutdownServer(self):
        self.go = False

    def announceWork(self):
        """
        Announce to our multicast cluster peers that we have work
        to do!
        """
        buf = "cobra:%s:%s:%d" % (self.name, self.cobraname, self.cobrad.port)
        self.sendsock.sendto(buf, (cluster_ip, cluster_port))

    def runServer(self, firethread=False):
        if firethread:
            thr = threading.Thread(target=self.runServer)
            thr.setDaemon(True)
            thr.start()
        else:
            self.cobrad.fireThread()
            while self.go:
                if len(self.queue):
                    self.announceWork()

                time.sleep(2)

    def inQueueCount(self):
        """
        How long is the current work unit queue.
        """
        return len(self.queue)

    def inProgressCount(self):
        """
        How many work units are in progress?
        """
        return len(self.inprog)

    def addWork(self, work):
        """
        Add a work object to the ClusterServer.  This 
        """
        if not isinstance(work, ClusterWork):
            raise Exception("%s is not a ClusterWork extension!")

        # If this work has no ID, give it one
        if work.id == None:
            work.id = self.widiter.next()

        self.qcond.acquire()
        if self.maxsize != None:
            while len(self.queue) >= self.maxsize:
                self.qcond.wait()
        self.queue.append(work)
        self.qcond.release()

        if self.callback:
            self.callback.workAdded(self, work)

    def getWork(self):

        self.qcond.acquire()

        try:
            ret = self.queue.popleft()
        except IndexError, e:
            self.qcond.release()
            return None

        self.qcond.notifyAll()
        self.qcond.release()

        self.inprog[ret.id] = ret
        self.__touchWork(ret.id)

        if self.callback:
            self.callback.workGotten(self, ret)

        return ret


    def doneWork(self, work):
        """
        Used by the clients to report work as done.
        """
        self.__cleanWork(work.id)

        work.done()
        if self.callback:
            self.callback.workDone(self, work)

    def timeoutWork(self, work):
        """
        This method may be over-ridden to handle
        work units that time our for whatever reason.
        """
        self.__cleanWork(work.id)
        if self.callback:
            self.callback.workTimeout(self, work)

    def failWork(self, work):
        """
        This is called for a work unit that is in a failed state.  This is most
        commonly that the work() method has raised an exception.
        """
        self.__cleanWork(work.id)
        if self.callback:
            self.callback.workFailed(self, work)

    def cancelAllWork(self, inprog=True):
        """
        Cancel all of the currently pending work units.  You may
        specify inprog=False to cancel all *queued* work units
        but allow inprogress work units to complete.
        """
        self.qcond.acquire()
        qlist = list(self.queue)
        self.queue.clear()

        if inprog:
            p = self.inprog
            self.inprog = {}
            qlist.extend(p.values())

        self.qcond.notifyAll()
        self.qcond.release()

        if self.callback:
            for w in qlist:
                self.callback.workCanceled(self, w)
        
    def cancelWork(self, workid):
        """
        Cancel a work unit by ID.
        """
        cwork = self.__cleanWork(workid)

        # Remove it from the work queue
        # (if we didn't find in inprog)
        if cwork == None:
            self.qcond.acquire()
            qlist = list(self.queue)
            self.queue.clear()
            for work in qlist:
                if work.id != workid:
                    self.queue.append(work)
                else:
                    cwork = work

            self.qcond.notifyAll()
            self.qcond.release()

        if cwork == None:
            return

        if self.callback:
            self.callback.workCanceled(self, cwork)

    def setWorkStatus(self, workid, status):
        """
        Set the humon readable status for the given work unit.
        """
        self.__touchWork(workid)
        if self.callback:
            self.callback.workStatus(self, workid, status)

    def setWorkCompletion(self, workid, percent):
        """
        Set the percentage completion status for this work unit.
        """
        self.__touchWork(workid)
        if self.callback:
            self.callback.workCompletion(self, workid, percent)

class ClusterClient:

    """
    Listen for our name (or any name if name=="*") on the cobra cluster
    multicast address and if we find a server in need, go help.

    maxwidth is the number of work units to do in parallel
    docode will enable code sharing with the server
    """

    def __init__(self, name, maxwidth=4, docode=False):
        self.go = True
        self.name = name
        self.width = 0
        self.maxwidth = maxwidth
        self.verbose = False
        self.docode = docode

        if docode: dcode.enableDcodeClient()

        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock.bind(("",cluster_port))
        mreq = struct.pack("4sL", socket.inet_aton(cluster_ip), socket.INADDR_ANY)
        self.sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)

    def processWork(self):
        """
        Runs handing out work up to maxwidth until self.go == False.
        """
        while self.go:
            
            buf, sockaddr = self.sock.recvfrom(4096)
            if self.width >= self.maxwidth:
                continue

            if not buf.startswith("cobra"):
                continue

            info = buf.split(":")
            if len(info) != 4:
                continue

            server, svrport = sockaddr
            cc,name,cobject,portstr = info
            if (self.name != name) and (self.name != "*"):
                continue

            port = int(portstr)

            uri = "%s://%s:%d/%s" % (cc,server,port,cobject)
            self.fireRunner(uri)

    def fireRunner(self, uri):
        thr = threading.Thread(target=self.threadForker, args=(uri,))
        thr.setDaemon(True)
        thr.start()

    def threadForker(self, uri):
        self.width += 1
        cmd = sub_cmd % (uri, self.docode)
        try:
            sub = subprocess.Popen([sys.executable, '-c', cmd], stdin=subprocess.PIPE)
            sub.wait()
        finally:
            self.width -= 1

def getHostPortFromUri(uri):
    """
    Take the server URI and pull out the
    host and port for use in building the
    dcode uri.
    """
    x = urllib2.Request(uri)
    port = None
    hparts = x.get_host().split(":")
    host = hparts[0]
    if len(hparts):
        port = int(hparts[1])
    return host,port

def workThread(server, work):
    try:
        work.server = server
        work.starttime = time.time()
        work.touch()
        work.work()
        work.endtime = time.time()
        work.server.doneWork(work)

    except InvalidInProgWorkId, e: # the work was canceled
        pass # Nothing to do, the server already knows

    except Exception, e:
        # Tell the server that the work unit failed
        work.excinfo = traceback.format_exc()
        work.server.failWork(work)
        traceback.print_exc()

def runAndWaitWork(server, work):

    thr = threading.Thread(target=workThread, args=(server, work))
    thr.setDaemon(True)
    thr.start()

    # Wait around for done or timeout
    while True:
        if work.isTimedOut():
            break

        # If the thread is done, lets get out.
        if not thr.isAlive():
            break

        # If our parent, or some thread closes stdin,
        # time to pack up and go.
        if sys.stdin.closed:
            break

        time.sleep(2)

def getAndDoWork(uri, docode=False):

    # If we wanna use dcode, set it up
    try:
        if docode:
            dcode.enableDcodeClient()
            host,port = getHostPortFromUri(uri)
            cobra.dcode.addDcodeServer(host, port=port)

        # Use a cobra proxy with timeout/maxretry so we
        # don't hang forever if the server goes away
        proxy = cobra.CobraProxy(uri, timeout=60, retrymax=3)

        work = proxy.getWork()
        # If we got work, do it.
        if work != None:
            runAndWaitWork(proxy, work)

    except Exception, e:
        traceback.print_exc()

    # Any way it goes we wanna exit now.  Work units may have
    # spun up non-daemon threads, so lets GTFO.
    gc.collect() # Try to call destructors
    sys.exit(0)  # GTFO


########NEW FILE########
__FILENAME__ = dcode
"""

Cobra's distributed code module capable of allowing
serialization of code from one system to another.

Particularly useful for clustering and workunit stuff.

"""
import os
import sys
import imp
import cobra

class DcodeFinder(object):
    """
    This is the module finder which is exposed by a dcode
    server to allow clients to attempt to find modules.
    """
    def find_module(self, fullname, uri, path=None):
        # If there are nested module names, they are
        # accounted for in path, so grab just the end
        fullname = fullname.split(".")[-1]
        fobj, filename, typeinfo = imp.find_module(fullname, path)
        if os.path.isdir(filename):
            filename = os.path.join(filename, "__init__.py")

        if not os.path.exists(filename):
            return None

        path = "%s|%s" % (uri,os.path.dirname(filename))
        fbytes = file(filename, "rU").read()
        return DcodeLoader(fbytes, filename, path)

class DcodeLoader(object):

    """
    This object gets pickled by the DcodeFinder and returned
    to the client who calls load_module.
    """

    def __init__(self, fbytes, filename, path):
        object.__init__(self)
        self.fbytes = fbytes
        self.filename = filename
        self.path = path

    def get_source(self, name):
        return self.fbytes

    def load_module(self, fullname):
        mod = sys.modules.get(fullname)
        if mod == None:
            mod = imp.new_module(fullname)
            sys.modules[fullname] = mod
            mod.__file__ = self.filename
            mod.__loader__ = self
            if self.path != None:
                mod.__path__ = [self.path]

            exec self.fbytes in mod.__dict__

        return mod

class DcodeImporter(object):
    """
    This object goes into the client side import path_hooks
    to allow cobra:// uri's to be added to the import path.
    """
    def __init__(self, uri, retrymax=3, timeout=10):
        object.__init__(self)

        if not cobra.isCobraUri(uri):
            raise ImportError

        path = None
        if uri.find("|") != -1:
            uri,path = uri.split("|")
            path = [path,]

        self.uri = uri
        self.path = path

        try:
            self.cobra = cobra.CobraProxy(uri, retrymax=retrymax, timeout=timeout)
        except Exception, e:
            raise ImportError

    def find_module(self, fullname, path=None):
        if path == None:
            path = self.path
        return self.cobra.find_module(fullname, self.uri, path)

def enableDcodeClient():
    """
    Once having called this, a client will be able to add cobra URIs
    to sys.path (one will be added automatically for the optional
    server parameter) and code will be imported via the distributed method.
    """
    if DcodeImporter not in sys.path_hooks:
        sys.path_hooks.append(DcodeImporter)

def addDcodeServer(server, port=None, override=False, ssl=False):
    scheme = "cobra"
    if ssl:
        scheme = "cobrassl"

    if port == None:
        port = cobra.COBRA_PORT

    uri = "%s://%s:%d/DcodeServer" % (scheme, server, port)
    if uri not in sys.path:
        if override:
            sys.path.insert(0, uri)
        else:
            sys.path.append(uri)

def enableDcodeServer():
    cobra.shareObject(DcodeFinder(), "DcodeServer")


########NEW FILE########
__FILENAME__ = elf_lookup
## EM enumeration definitions
EM_NONE = 0
EM_M32 = 1
EM_SPARC = 2
EM_386 = 3
EM_68K = 4
EM_88K = 5
EM_860 = 7
EM_MIPS = 8
EM_S370 = 9
EM_MIPS_RS3_LE = 10
EM_PARISC = 15
EM_VPP500 = 17
EM_SPARC32PLUS = 18
EM_960 = 19
EM_PPC = 20
EM_PPC64 = 21
EM_S390 = 22
EM_V800 = 36
EM_FR20 = 37
EM_RH32 = 38
EM_RCE = 39
EM_ARM = 40
EM_FAKE_ALPHA = 41
EM_SH = 42
EM_SPARCV9 = 43
EM_TRICORE = 44
EM_ARC = 45
EM_H8_300 = 46
EM_H8_300H = 47
EM_H8S = 48
EM_H8_500 = 49
EM_IA_64 = 50
EM_MIPS_X = 51
EM_COLDFIRE = 52
EM_68HC12 = 53
EM_MMA = 54
EM_PCP = 55
EM_NCPU = 56
EM_NDR1 = 57
EM_STARCORE = 58
EM_ME16 = 59
EM_ST100 = 60
EM_TINYJ = 61
EM_X86_64 = 62
EM_PDSP = 63
EM_FX66 = 66
EM_ST9PLUS = 67
EM_ST7 = 68
EM_68HC16 = 69
EM_68HC11 = 70
EM_68HC08 = 71
EM_68HC05 = 72
EM_SVX = 73
EM_ST19 = 74
EM_VAX = 75
EM_CRIS = 76
EM_JAVELIN = 77
EM_FIREPATH = 78
EM_ZSP = 79
EM_MMIX = 80
EM_HUANY = 81
EM_PRISM = 82
EM_AVR = 83
EM_FR30 = 84
EM_D10V = 85
EM_D30V = 86
EM_V850 = 87
EM_M32R = 88
EM_MN10300 = 89
EM_MN10200 = 90
EM_PJ = 91
EM_OPENRISC = 92
EM_ARC_A5 = 93
EM_XTENSA = 94
EM_NUM = 95
EM_ALPHA = 0x9026

# There are plenty more of these to
# fill in, but...  this is all I need
# for now...
e_machine_32 =  (
                EM_386,
                EM_PPC,
                EM_ARM,
                )
e_machine_64 =  (
                EM_PPC64,
                EM_SPARCV9,
                EM_X86_64
                )

e_machine_types = {
EM_NONE:"No machine",
EM_M32:"AT&T WE 32100",
EM_SPARC:"SUN SPARC",
EM_386:"Intel 80386",
EM_68K:"Motorola m68k family",
EM_88K:"Motorola m88k family",
EM_860:"Intel 80860",
EM_MIPS:"MIPS R3000 big-endian",
EM_S370:"IBM System/370",
EM_MIPS_RS3_LE:"MIPS R3000 little-endian",
EM_PARISC:"HPPA",
EM_VPP500:"Fujitsu VPP500",
EM_SPARC32PLUS:"Suns v8plus",
EM_960:"Intel 80960",
EM_PPC:"PowerPC",
EM_PPC64:"PowerPC 64-bit",
EM_S390:"IBM S390",
EM_V800:"NEC V800 series",
EM_FR20:"Fujitsu FR20",
EM_RH32:"TRW RH-32",
EM_RCE:"Motorola RCE",
EM_ARM:"ARM",
EM_FAKE_ALPHA:"Digital Alpha",
EM_SH:"Hitachi SH",
EM_SPARCV9:"SPARC v9 64-bit",
EM_TRICORE:"Siemens Tricore",
EM_ARC:"Argonaut RISC Core",
EM_H8_300:"Hitachi H8/300",
EM_H8_300H:"Hitachi H8/300H",
EM_H8S:"Hitachi H8S",
EM_H8_500:"Hitachi H8/500",
EM_IA_64:"Intel Merced",
EM_MIPS_X:"Stanford MIPS-X",
EM_COLDFIRE:"Motorola Coldfire",
EM_68HC12:"Motorola M68HC12",
EM_MMA:"Fujitsu MMA Multimedia",
EM_PCP:"Siemens PCP",
EM_NCPU:"Sony nCPU embeeded RISC",
EM_NDR1:"Denso NDR1 microprocessor",
EM_STARCORE:"Motorola Start*Core processor",
EM_ME16:"Toyota ME16 processor",
EM_ST100:"STMicroelectronic ST100 processor",
EM_TINYJ:"Advanced Logic Corp. Tinyj",
EM_X86_64:"AMD x86-64 architecture",
EM_PDSP:"Sony DSP Processor",
EM_FX66:"Siemens FX66 microcontroller",
EM_ST9PLUS:"STMicroelectronics ST9+ 8/16 mc",
EM_ST7:"STmicroelectronics ST7 8 bit mc",
EM_68HC16:"Motorola MC68HC16 microcontroller",
EM_68HC11:"Motorola MC68HC11 microcontroller",
EM_68HC08:"Motorola MC68HC08 microcontroller",
EM_68HC05:"Motorola MC68HC05 microcontroller",
EM_SVX:"Silicon Graphics SVx",
EM_ST19:"STMicroelectronics ST19 8 bit mc",
EM_VAX:"Digital VAX",
EM_CRIS:"Axis Communications 32-bit embedded processor",
EM_JAVELIN:"Infineon Technologies 32-bit embedded processor",
EM_FIREPATH:"Element 14 64-bit DSP Processor",
EM_ZSP:"LSI Logic 16-bit DSP Processor",
EM_MMIX:"Donald Knuths educational 64-bit processor",
EM_HUANY:"Harvard University machine-independent object files",
EM_PRISM:"SiTera Prism",
EM_AVR:"Atmel AVR 8-bit microcontroller",
EM_FR30:"Fujitsu FR30",
EM_D10V:"Mitsubishi D10V",
EM_D30V:"Mitsubishi D30V",
EM_V850:"NEC v850",
EM_M32R:"Mitsubishi M32R",
EM_MN10300:"Matsushita MN10300",
EM_MN10200:"Matsushita MN10200",
EM_PJ:"picoJava",
EM_OPENRISC:"OpenRISC 32-bit embedded processor",
EM_ARC_A5:"ARC Cores Tangent-A5",
EM_XTENSA:"Tensilica Xtensa Architecture",
EM_NUM:"",
EM_ALPHA:"",
}

ET_NONE = 0
ET_REL = 1
ET_EXEC = 2
ET_DYN = 3
ET_CORE = 4
ET_NUM = 5
ET_LOOS = 0xfe00
ET_HIOS = 0xfeff
ET_LOPROC = 0xff00
ET_HIPROC = 0xffff

e_types = {
ET_NONE:"No file type",
ET_REL:"Relocatable file",
ET_EXEC:"Executable file",
ET_DYN:"Shared object file",
ET_CORE:"Core file",
ET_NUM:"Number of defined types",
ET_LOOS:"OS-specific range start",
ET_HIOS:"OS-specific range end",
ET_LOPROC:"Processor-specific range start",
ET_HIPROC:"Processor-specific range end",
}

EV_NONE = 0
EV_CURRENT = 1
EV_NUM = 2

e_versions = {
EV_NONE:"Invalid ELF version",
EV_CURRENT:"Current version",
EV_NUM:"",
}
R_68K_NONE = 0
R_68K_32 = 1
R_68K_16 = 2
R_68K_8 = 3
R_68K_PC32 = 4
R_68K_PC16 = 5
R_68K_PC8 = 6
R_68K_GOT32 = 7
R_68K_GOT16 = 8
R_68K_GOT8 = 9
R_68K_GOT32O = 10
R_68K_GOT16O = 11
R_68K_GOT8O = 12
R_68K_PLT32 = 13
R_68K_PLT16 = 14
R_68K_PLT8 = 15
R_68K_PLT32O = 16
R_68K_PLT16O = 17
R_68K_PLT8O = 18
R_68K_COPY = 19
R_68K_GLOB_DAT = 20
R_68K_JMP_SLOT = 21
R_68K_RELATIVE = 22

e_flags_68k = {
R_68K_NONE:"No reloc",
R_68K_32:"Direct 32 bit",
R_68K_16:"Direct 16 bit",
R_68K_8:"Direct 8 bit",
R_68K_PC32:"PC relative 32 bit",
R_68K_PC16:"PC relative 16 bit",
R_68K_PC8:"PC relative 8 bit",
R_68K_GOT32:"32 bit PC relative GOT entry",
R_68K_GOT16:"16 bit PC relative GOT entry",
R_68K_GOT8:"8 bit PC relative GOT entry",
R_68K_GOT32O:"32 bit GOT offset",
R_68K_GOT16O:"16 bit GOT offset",
R_68K_GOT8O:"8 bit GOT offset",
R_68K_PLT32:"32 bit PC relative PLT address",
R_68K_PLT16:"16 bit PC relative PLT address",
R_68K_PLT8:"8 bit PC relative PLT address",
R_68K_PLT32O:"32 bit PLT offset",
R_68K_PLT16O:"16 bit PLT offset",
R_68K_PLT8O:"8 bit PLT offset",
R_68K_COPY:"Copy symbol at runtime",
R_68K_GLOB_DAT:"Create GOT entry",
R_68K_JMP_SLOT:"Create PLT entry",
R_68K_RELATIVE:"Adjust by program base",
}

R_386_NONE = 0
R_386_32 = 1
R_386_PC32 = 2
R_386_GOT32 = 3
R_386_PLT32 = 4
R_386_COPY = 5
R_386_GLOB_DAT = 6
R_386_JMP_SLOT = 7
R_386_RELATIVE = 8
R_386_GOTOFF = 9
R_386_GOTPC = 10
R_386_32PLT = 11
R_386_TLS_TPOFF = 14
R_386_TLS_IE = 15
R_386_TLS_GOTIE = 16
R_386_TLS_LE = 17
R_386_TLS_GD = 18
R_386_TLS_LDM = 19
R_386_16 = 20
R_386_PC16 = 21
R_386_8 = 22
R_386_PC8 = 23
R_386_TLS_GD_32 = 24
R_386_TLS_GD_PUSH = 25
R_386_TLS_GD_CALL = 26
R_386_TLS_GD_POP = 27
R_386_TLS_LDM_32 = 28
R_386_TLS_LDM_PUSH = 29
R_386_TLS_LDM_CALL = 30
R_386_TLS_LDM_POP = 31
R_386_TLS_LDO_32 = 32
R_386_TLS_IE_32 = 33
R_386_TLS_LE_32 = 34
R_386_TLS_DTPMOD32 = 35
R_386_TLS_DTPOFF32 = 36
R_386_TLS_TPOFF32 = 37

r_types_386 = {
R_386_NONE:"No reloc",
R_386_32:"Direct 32 bit",
R_386_PC32:"PC relative 32 bit",
R_386_GOT32:"32 bit GOT entry",
R_386_PLT32:"32 bit PLT address",
R_386_COPY:"Copy symbol at runtime",
R_386_GLOB_DAT:"Create GOT entry",
R_386_JMP_SLOT:"Create PLT entry",
R_386_RELATIVE:"Adjust by program base",
R_386_GOTOFF:"32 bit offset to GOT",
R_386_GOTPC:"32 bit PC relative offset to GOT",
R_386_32PLT:"",
R_386_TLS_TPOFF:"Offset in static TLS block",
R_386_TLS_IE:"Address of GOT entry for static",
R_386_TLS_GOTIE:"GOT entry for static TLS",
R_386_TLS_LE:"Offset relative to static",
R_386_TLS_GD:"Direct 32 bit for GNU version",
R_386_TLS_LDM:"Direct 32 bit for GNU version",
R_386_16:"",
R_386_PC16:"",
R_386_8:"",
R_386_PC8:"",
R_386_TLS_GD_32:"Direct 32 bit for general",
R_386_TLS_GD_PUSH:"Tag for pushl in GD TLS code",
R_386_TLS_GD_CALL:"Relocation for call",
R_386_TLS_GD_POP:"Tag for popl in GD TLS code",
R_386_TLS_LDM_32:"Direct 32 bit for local",
R_386_TLS_LDM_PUSH:"Tag for pushl in LDM TLS code",
R_386_TLS_LDM_CALL:"Relocation for call",
R_386_TLS_LDM_POP:"Tag for popl in LDM TLS code",
R_386_TLS_LDO_32:"Offset relative to TLS block",
R_386_TLS_IE_32:"GOT entry for negated static",
R_386_TLS_LE_32:"Negated offset relative to",
R_386_TLS_DTPMOD32:"ID of module containing symbol",
R_386_TLS_DTPOFF32:"Offset in TLS block",
R_386_TLS_TPOFF32:"Negated offset in static TLS block",
}

R_X86_64_NONE        = 0
R_X86_64_64          = 1
R_X86_64_PC32        = 2
R_X86_64_GOT32       = 3
R_X86_64_PLT32       = 4
R_X86_64_COPY        = 5
R_X86_64_GLOB_DAT    = 6
R_X86_64_JUMP_SLOT   = 7
R_X86_64_RELATIVE    = 8
R_X86_64_GOTPCREL    = 9
R_X86_64_32          = 10
R_X86_64_32S         = 11
R_X86_64_16          = 12
R_X86_64_PC16        = 13
R_X86_64_8           = 14
R_X86_64_PC8         = 15
R_X86_64_DTPMOD64    = 16
R_X86_64_DTPOFF64    = 17
R_X86_64_TPOFF64     = 18
R_X86_64_TLSGD       = 19
R_X86_64_TLSLD       = 20
R_X86_64_DTPOFF32    = 21
R_X86_64_GOTTPOFF    = 22
R_X86_64_TPOFF32     = 23
R_X86_64_NUM         = 24

r_types_amd64 = {
R_X86_64_NONE       :'No reloc',
R_X86_64_64         :'Direct 64 bit ',
R_X86_64_PC32       :'PC relative 32 bit signed',
R_X86_64_GOT32      :'32 bit GOT entry',
R_X86_64_PLT32      :'32 bit PLT address',
R_X86_64_COPY       :'Copy symbol at runtime',
R_X86_64_GLOB_DAT   :'Create GOT entry',
R_X86_64_JUMP_SLOT  :'Create PLT entry',
R_X86_64_RELATIVE   :'Adjust by program base',
R_X86_64_GOTPCREL   :'32 bit signed PC relative offset to GOT',
R_X86_64_32         :'Direct 32 bit zero extended',
R_X86_64_32S        :'Direct 32 bit sign extended',
R_X86_64_16         :'Direct 16 bit zero extended',
R_X86_64_PC16       :'16 bit sign extended pc relative',
R_X86_64_8          :'Direct 8 bit sign extended ',
R_X86_64_PC8        :'8 bit sign extended pc relative',
R_X86_64_DTPMOD64   :'ID of module containing symbol',
R_X86_64_DTPOFF64   :'Offset in modules TLS block',
R_X86_64_TPOFF64    :'Offset in initial TLS block',
R_X86_64_TLSGD      :'32 bit signed PC relative offset to two GOT entries for GD symbol',
R_X86_64_TLSLD      :'32 bit signed PC relative offset to two GOT entries for LD symbol',
R_X86_64_DTPOFF32   :'Offset in TLS block',
R_X86_64_GOTTPOFF   :'32 bit signed PC relative offset to GOT entry for IE symbol',
R_X86_64_TPOFF32    :'Offset in initial TLS block',
}

## Define e_flags to 386
SHT_NULL = 0
SHT_PROGBITS = 1
SHT_SYMTAB = 2
SHT_STRTAB = 3
SHT_RELA = 4
SHT_HASH = 5
SHT_DYNAMIC = 6
SHT_NOTE = 7
SHT_NOBITS = 8
SHT_REL = 9
SHT_SHLIB = 10
SHT_DYNSYM = 11
SHT_INIT_ARRAY = 14
SHT_FINI_ARRAY = 15
SHT_PREINIT_ARRAY = 16
SHT_GROUP = 17
SHT_SYMTAB_SHNDX = 18
SHT_LOOS = 0x60000000
SHT_GNU_LIBLIST = 0x6ffffff7
SHT_CHECKSUM = 0x6ffffff8
SHT_LOSUNW = 0x6ffffffa
SHT_GNU_verdef = 0x6ffffffd
SHT_GNU_verneed = 0x6ffffffe
SHT_GNU_versym = 0x6fffffff
SHT_HISUNW = 0x6fffffff
SHT_HIOS = 0x6fffffff
SHT_LOPROC = 0x70000000
SHT_HIPROC = 0x7fffffff
SHT_LOUSER = 0x80000000
SHT_HIUSER = 0x8fffffff

sh_type = {
SHT_NULL:"Section header table entry unused",
SHT_PROGBITS:"Program data",
SHT_SYMTAB:"Symbol table",
SHT_STRTAB:"String table",
SHT_RELA:"Relocation entries with addends",
SHT_HASH:"Symbol hash table",
SHT_DYNAMIC:"Dynamic linking information",
SHT_NOTE:"Notes",
SHT_NOBITS:"Program space with no data (bss)",
SHT_REL:"Relocation entries, no addends",
SHT_SHLIB:"Reserved",
SHT_DYNSYM:"Dynamic linker symbol table",
SHT_INIT_ARRAY:"Array of constructors",
SHT_FINI_ARRAY:"Array of destructors",
SHT_PREINIT_ARRAY:"Array of pre-constructors",
SHT_GROUP:"Section group",
SHT_SYMTAB_SHNDX:"Extended section indeces",
SHT_LOOS:"Start OS-specific",
SHT_GNU_LIBLIST:"Prelink library list",
SHT_CHECKSUM:"Checksum for DSO content.",
SHT_LOSUNW:"Sun-specific low bound.",
SHT_GNU_verdef:"Version definition section.",
SHT_GNU_verneed:"Version needs section.",
SHT_GNU_versym:"Version symbol table.",
SHT_HISUNW:"Sun-specific high bound.",
SHT_HIOS:"End OS-specific type",
SHT_LOPROC:"Start of processor-specific",
SHT_HIPROC:"End of processor-specific",
SHT_LOUSER:"Start of application-specific",
SHT_HIUSER:"End of application-specific",
}

SHF_WRITE = 1
SHF_ALLOC = 2
SHF_EXECINSTR = 4
SHF_MERGE = 16
SHF_STRINGS = 32
SHF_INFO_LINK = 64
SHF_LINK_ORDER = 128
SHF_OS_NONCONFORMING = 256
SHF_GROUP = 512
SHF_TLS = 1024
SHF_ORDERED = 1073741824
SHF_EXCLUDE = 2147483648

sh_flags = {
SHF_WRITE:"Writable",
SHF_ALLOC:"Occupies memory during execution",
SHF_EXECINSTR:"Executable",
SHF_MERGE:"Might be merged",
SHF_STRINGS:"Contains nul-terminated strings",
SHF_INFO_LINK:"`sh_info' contains SHT index",
SHF_LINK_ORDER:"Preserve order after combining",
SHF_OS_NONCONFORMING:"Non-standard OS specific",
SHF_GROUP:"Section is member of a group.",
SHF_TLS:"Section hold thread-local data.",
SHF_ORDERED:"Special ordering",
SHF_EXCLUDE:"Section is excluded",
}

STB_LOCAL = 0
STB_GLOBAL = 1
STB_WEAK = 2
STB_LOOS = 10
STB_HIOS = 12
STB_LOPROC = 13
STB_HIPROC = 15

st_info_bind = {
STB_LOCAL:"Local symbol",
STB_GLOBAL:"Global symbol",
STB_WEAK:"Weak symbol",
STB_LOOS:"Start of OS-specific",
STB_HIOS:"End of OS-specific",
STB_LOPROC:"Start of processor-specific",
STB_HIPROC:"End of processor-specific",
}

STT_NOTYPE = 0
STT_OBJECT = 1
STT_FUNC = 2
STT_SECTION = 3
STT_FILE = 4
STT_COMMON = 5
STT_TLS = 6
STT_LOOS = 10
STT_HIOS = 12
STT_LOPROC = 13
STT_HIPROC = 15

st_info_type = {
STT_NOTYPE:"Symbol type is unspecified",
STT_OBJECT:"Symbol is a data object",
STT_FUNC:"Symbol is a code object",
STT_SECTION:"Symbol associated with a section",
STT_FILE:"Symbol's name is file name",
STT_COMMON:"Symbol is a common data object",
STT_TLS:"Symbol is thread-local data",
STT_LOOS:"Start of OS-specific",
STT_HIOS:"End of OS-specific",
STT_LOPROC:"Start of processor-specific",
STT_HIPROC:"End of processor-specific",
}

DT_NULL     = 0
DT_NEEDED   = 1
DT_PLTRELSZ = 2
DT_PLTGOT   = 3
DT_HASH     = 4
DT_STRTAB   = 5
DT_SYMTAB   = 6
DT_RELA     = 7
DT_RELASZ   = 8
DT_RELAENT  = 9
DT_STRSZ    = 10
DT_SYMENT   = 11
DT_INIT     = 12
DT_FINI     = 13
DT_SONAME   = 14
DT_RPATH    = 15
DT_SYMBOLIC = 16
DT_REL      = 17
DT_RELSZ    = 18
DT_RELENT   = 19
DT_PLTREL   = 20
DT_DEBUG    = 21
DT_TEXTREL  = 22
DT_JMPREL   = 23
DT_BIND_NOW = 24
DT_INIT_ARRAY   = 25
DT_FINI_ARRAY   = 26
DT_INIT_ARRAYSZ = 27
DT_FINI_ARRAYSZ = 28
DT_RUNPATH  = 29
DT_FLAGS    = 30
DT_ENCODING = 32
DT_PREINIT_ARRAY = 32
DT_PREINIT_ARRAYSZ = 33
DT_NUM      = 34
DT_GNU_PRELINKED    = 0x6ffffdf5 
DT_GNU_CONFLICTSZ   = 0x6ffffdf6 
DT_GNU_LIBLISTSZ    = 0x6ffffdf7 
DT_CHECKSUM         = 0x6ffffdf8 
DT_PLTPADSZ         = 0x6ffffdf9 
DT_MOVEENT          = 0x6ffffdfa 
DT_MOVESZ           = 0x6ffffdfb 
DT_FEATURE_1        = 0x6ffffdfc 
DT_POSFLAG_1        = 0x6ffffdfd 
DT_SYMINSZ          = 0x6ffffdfe 
DT_SYMINENT         = 0x6ffffdff 
DT_GNU_HASH         = 0x6ffffef5 
DT_TLSDESC_PLT      = 0x6ffffef6 
DT_TLSDESC_GOT      = 0x6ffffef7 
DT_GNU_CONFLICT     = 0x6ffffef8 
DT_GNU_LIBLIST      = 0x6ffffef9 
DT_CONFIG           = 0x6ffffefa 
DT_DEPAUDIT         = 0x6ffffefb 
DT_AUDIT            = 0x6ffffefc 
DT_PLTPAD           = 0x6ffffefd 
DT_MOVETAB          = 0x6ffffefe 
DT_SYMINFO          = 0x6ffffeff 
DT_VERSYM           = 0x6ffffff0 
DT_RELACOUNT        = 0x6ffffff9 
DT_RELCOUNT         = 0x6ffffffa 
DT_FLAGS_1          = 0x6ffffffb 
DT_VERDEF           = 0x6ffffffc 
DT_VERDEFNUM        = 0x6ffffffd 
DT_VERNEED          = 0x6ffffffe 
DT_VERNEEDNUM       = 0x6fffffff 
DT_AUXILIARY        = 0x7ffffffd 
DT_FILTER           = 0x7fffffff 
DT_LOOS             = 0x6000000d
DT_HIOS             = 0x6ffff000
DT_LOPROC           = 0x70000000
DT_HIPROC           = 0x7fffffff
#DT_PROCNUM  = DT_MIPS_NUM

dt_types = {
DT_NULL     : "Marks end of dynamic section ",
DT_NEEDED   : "Name of needed library ",
DT_PLTRELSZ : "Size in bytes of PLT relocs ",
DT_PLTGOT   : "Processor defined value ",
DT_HASH     : "Address of symbol hash table ",
DT_STRTAB   : "Address of string table ",
DT_SYMTAB   : "Address of symbol table ",
DT_RELA     : "Address of Rela relocs ",
DT_RELASZ   : "Total size of Rela relocs ",
DT_RELAENT  : "Size of one Rela reloc ",
DT_STRSZ    : "Size of string table ",
DT_SYMENT   : "Size of one symbol table entry ",
DT_INIT     : "Address of init function ",
DT_FINI     : "Address of termination function ",
DT_SONAME   : "Name of shared object ",
DT_RPATH    : "Library search path (deprecated) ",
DT_SYMBOLIC : "Start symbol search here ",
DT_REL      : "Address of Rel relocs ",
DT_RELSZ    : "Total size of Rel relocs ",
DT_RELENT   : "Size of one Rel reloc ",
DT_PLTREL   : "Type of reloc in PLT ",
DT_DEBUG    : "For debugging; unspecified ",
DT_TEXTREL  : "Reloc might modify .text ",
DT_JMPREL   : "Address of PLT relocs ",
DT_BIND_NOW : "Process relocations of object ",
DT_INIT_ARRAY   : "Array with addresses of init fct ",
DT_FINI_ARRAY   : "Array with addresses of fini fct ",
DT_INIT_ARRAYSZ : "Size in bytes of DT_INIT_ARRAY ",
DT_FINI_ARRAYSZ : "Size in bytes of DT_FINI_ARRAY ",
DT_RUNPATH  : "Library search path ",
DT_FLAGS    : "Flags for the object being loaded ",
DT_ENCODING : "Start of encoded range ",
DT_PREINIT_ARRAY : "Array with addresses of preinit fct",
DT_PREINIT_ARRAYSZ : "size in bytes of DT_PREINIT_ARRAY ",
DT_NUM      : "Number used ",
DT_LOOS     : "Start of OS-specific ",
DT_HIOS     : "End of OS-specific ",
DT_LOPROC   : "Start of processor-specific ",
DT_HIPROC   : "End of processor-specific ",
#DT_PROCNUM  : "Most used by any processor ",
}


PT_NULL     = 0
PT_LOAD     = 1
PT_DYNAMIC  = 2
PT_INTERP   = 3
PT_NOTE     = 4
PT_SHLIB    = 5
PT_PHDR     = 6
PT_TLS      = 7
PT_NUM      = 8
PT_LOOS     = 0x60000000
PT_GNU_EH_FRAME  = 0x6474e550
PT_GNU_STACK  = 0x6474e551
PT_GNU_RELRO  = 0x6474e552
PT_LOSUNW   = 0x6ffffffa
PT_SUNWBSS  = 0x6ffffffa
PT_SUNWSTACK = 0x6ffffffb
PT_HISUNW =  0x6fffffff
PT_HIOS   =  0x6fffffff
PT_LOPROC =  0x70000000
PT_HIPROC =  0x7fffffff

ph_types = {
PT_NULL:"Program header table entry unused",
PT_LOAD:"Loadable program segment",
PT_DYNAMIC:"Dynamic linking information",
PT_INTERP:"Program interpreter",
PT_NOTE:"Auxiliary information",
PT_SHLIB:"Reserved",
PT_PHDR:"Entry for header table itself",
PT_TLS:"Thread-local storage segment",
PT_NUM:"Number of defined types",
PT_LOOS:"Start of OS-specific",
PT_GNU_EH_FRAME:"GCC .eh_frame_hdr segment",
PT_GNU_STACK:"Indicates stack executability",
PT_GNU_RELRO:"Read-only after relocation",
PT_SUNWBSS:"Sun Specific segment",
PT_SUNWSTACK:"Stack segment",
PT_HIOS:"End of OS-specific",
PT_LOPROC:"Start of processor-specific",
PT_HIPROC:"End of processor-specific"}

########NEW FILE########
__FILENAME__ = disasm
import envi
import envi.bits as e_bits
import envi.archs.i386 as e_i386
import envi.archs.i386.opcode86 as opcode86

from envi.archs.amd64.regs import *

# Pre generate these for fast lookup. Because our REX prefixes have the same relative
# bit relationship to eachother, we can cheat a little...
amd64_prefixes = list(e_i386.i386_prefixes)
amd64_prefixes[0x40] = (0x10 << 16)
amd64_prefixes[0x41] = (0x11 << 16)
amd64_prefixes[0x42] = (0x12 << 16)
amd64_prefixes[0x43] = (0x13 << 16)
amd64_prefixes[0x44] = (0x14 << 16)
amd64_prefixes[0x45] = (0x15 << 16)
amd64_prefixes[0x46] = (0x16 << 16)
amd64_prefixes[0x47] = (0x17 << 16)
amd64_prefixes[0x48] = (0x18 << 16)
amd64_prefixes[0x49] = (0x19 << 16)
amd64_prefixes[0x4a] = (0x1a << 16)
amd64_prefixes[0x4b] = (0x1b << 16)
amd64_prefixes[0x4c] = (0x1c << 16)
amd64_prefixes[0x4d] = (0x1d << 16)
amd64_prefixes[0x4e] = (0x1e << 16)
amd64_prefixes[0x4f] = (0x1f << 16)

# NOTE: some notes from the intel manual...
# REX.W overrides 66, but alternate registers (via REX.B etc..) can have 66 to be 16 bit..
# REX.R only modifies reg for GPR/SSE(SIMD)/ctrl/debug addressing modes.
# REX.X only modifies the SIB index value
# REX.B modifies modrm r/m field, or SIB base (if SIB present), or opcode reg.
# We inherit all the regular intel prefixes...
PREFIX_REX   = 0x100000 # Shows that the rex prefix is present
PREFIX_REX_B = 0x010000 # Bit 0 in REX prefix (0x41) means ModR/M r/m field, SIB base, or opcode reg
PREFIX_REX_X = 0x020000 # Bit 1 in REX prefix (0x42) means SIB index extension
PREFIX_REX_R = 0x040000 # Bit 2 in REX prefix (0x44) means ModR/M reg extention
PREFIX_REX_W = 0x080000 # Bit 3 in REX prefix (0x48) means 64 bit operand

REX_BUMP = 8
MODE_16 = 0
MODE_32 = 1
MODE_64 = 2

class Amd64RipRelOper(envi.DerefOper):
    def __init__(self, imm, tsize):
        self.imm = imm
        self.tsize = tsize
        self._is_deref = True

    def getOperValue(self, op, emu=None):
        if self._is_deref == False: # Special lea behavior
            return self.getOperAddr(op)
        if emu == None: return None
        return emu.readMemValue(self.getOperAddr(op, emu), self.tsize)

    def setOperValue(self, op, emu, val):
        emu.writeMemValue(self.getOperAddr(op, emu), val, self.tsize)

    def getOperAddr(self, op, emu=None):
        return op.va + op.size + self.imm

    def isDeref(self):
        # The disassembler may reach in and set this (if lea...)
        return self._is_deref

    def render(self, mcanv, op, idx):
        destva = op.va + op.size + self.imm
        sym = mcanv.syms.getSymByAddr(destva)

        mcanv.addNameText(e_i386.sizenames[self.tsize])
        mcanv.addText(" [")
        mcanv.addNameText("rip", typename="registers")

        if self.imm > 0:
            mcanv.addText(" + ")
            if sym != None:
                mcanv.addVaText("$%s" % repr(sym), destva)
            else:
                mcanv.addNameText(str(self.imm))
        elif self.imm < 0:
            mcanv.addText(" - ")
            if sym != None:
                mcanv.addVaText("$%s" % repr(sym), destva)
            else:
                mcanv.addNameText(str(abs(self.imm)))
        mcanv.addText("]")

    def repr(self, op):
        return "[rip + %d]" % self.imm

class Amd64Disasm(e_i386.i386Disasm):

    def __init__(self):
        e_i386.i386Disasm.__init__(self)
        self._dis_prefixes = amd64_prefixes
        self._dis_regctx = Amd64RegisterContext()

        # Over-ride these which are in use by the i386 version of the ASM
        self.ROFFSET_MMX   = e_i386.getRegOffset(amd64regs, "mm0")
        self.ROFFSET_SIMD  = e_i386.getRegOffset(amd64regs, "xmm0")
        self.ROFFSET_DEBUG = e_i386.getRegOffset(amd64regs, "debug0")
        self.ROFFSET_CTRL  = e_i386.getRegOffset(amd64regs, "ctrl0")
        self.ROFFSET_TEST  = e_i386.getRegOffset(amd64regs, "test0")
        self.ROFFSET_SEG   = e_i386.getRegOffset(amd64regs, "es")
        self.ROFFSET_FPU   = e_i386.getRegOffset(amd64regs, "st0")

    # NOTE: Technically, the REX must be the *last* prefix specified

    def _dis_calc_tsize(self, opertype, prefixes):
        """
        Use the oper type and prefixes to decide on the tsize for
        the operand.
        """

        mode = MODE_32

        sizelist = opcode86.OPERSIZE.get(opertype, None)
        if sizelist == None:
            raise "OPERSIZE FAIL"

        # NOTE: REX takes precedence over 66
        # (see section 2.2.1.2 in Intel 2a)
        if prefixes & PREFIX_REX_W:

            mode = MODE_64

        elif prefixes & e_i386.PREFIX_OP_SIZE:

            mode = MODE_16

        return sizelist[mode]

    def byteRegOffset(self, val):
        # NOTE: Override this because there is no AH etc in 64 bit mode
        return val + e_i386.RMETA_LOW8

    def extended_parse_modrm(self, bytes, offset, opersize, regbase=0):
        """
        Return a tuple of (size, Operand)
        """
        size = 1
        # FIXME this would be best to not parse_modrm twice.  tweak it.
        mod,reg,rm = self.parse_modrm(ord(bytes[offset]))
        if mod == 0 and rm == 5:
            imm = e_bits.parsebytes(bytes, offset + size, 4, sign=True)
            size += 4
            return(size, Amd64RipRelOper(imm, 4))

        return e_i386.i386Disasm.extended_parse_modrm(self, bytes, offset, opersize, regbase)

    # NOTE: Override a bunch of the address modes to account for REX
    def ameth_0(self, operflags, operval, tsize, prefixes):
        o = e_i386.i386Disasm.ameth_0(self, operflags, operval, tsize, prefixes)
        # If it has a builtin register, we need to check for bump prefix
        if prefixes & PREFIX_REX_B and isinstance(o, e_i386.i386RegOper):
            o.reg += REX_BUMP
        return o

    def ameth_g(self, bytes, offset, tsize, prefixes):
        osize, oper = e_i386.i386Disasm.ameth_g(self, bytes, offset, tsize, prefixes)
        if oper.tsize == 4 and oper.reg != REG_RIP:
            oper.reg += RMETA_LOW32
        if prefixes & PREFIX_REX_R:
            oper.reg += REX_BUMP
        return osize, oper

    def ameth_c(self, bytes, offset, tsize, prefixes):
        osize, oper = e_i386.i386Disasm.ameth_c(self, bytes, offset, tsize, prefixes)
        if prefixes & PREFIX_REX_R:
            oper.reg += REX_BUMP
        return osize,oper

    def ameth_d(self, bytes, offset, tsize, prefixes):
        osize, oper = e_i386.i386Disasm.ameth_d(self, bytes, offset, tsize, prefixes)
        if prefixes & PREFIX_REX_R:
            oper.reg += REX_BUMP
        return osize,oper

    def ameth_v(self, bytes, offset, tsize, prefixes):
        osize, oper = e_i386.i386Disasm.ameth_v(self, bytes, offset, tsize, prefixes)
        if prefixes & PREFIX_REX_R:
            oper.reg += REX_BUMP
        return osize,oper

    # NOTE: The ones below are the only ones to which REX.X or REX.B can apply (besides ameth_0)
    def _dis_rex_exmodrm(self, oper, prefixes):
        # REMEMBER: all extended mod RM reg fields come from the r/m part.  If it
        #           were actually just the reg part, it'd be in one of the above
        #           addressing modes...
        if getattr(oper, "index", None) != None:
            if oper.tsize == 4:
                oper.index += RMETA_LOW32
            if prefixes & PREFIX_REX_X:
                oper.index += REX_BUMP
            # Adjust the size if needed

        # oper.reg will be r/m or SIB base
        if getattr(oper, "reg", None) != None:
            # Adjust the size if needed
            if oper.tsize == 4:
                oper.reg += RMETA_LOW32

            if prefixes & PREFIX_REX_B:
                oper.reg += REX_BUMP

    def ameth_e(self, bytes, offset, tsize, prefixes):
        osize, oper = e_i386.i386Disasm.ameth_e(self, bytes, offset, tsize, prefixes)
        self._dis_rex_exmodrm(oper, prefixes)
        return osize, oper

    def ameth_w(self, bytes, offset, tsize, prefixes):
        osize, oper = e_i386.i386Disasm.ameth_w(self, bytes, offset, tsize, prefixes)
        self._dis_rex_exmodrm(oper, prefixes)
        return osize,oper



if __name__ == '__main__':
    import sys
    d = Amd64Disasm()
    b = file(sys.argv[1], 'rb').read()
    offset = 0
    va = 0x41414141
    while offset < len(b):
        op = d.disasm(b, offset, va+offset)
        print '0x%.8x %s %s' % (va+offset, b[offset:offset+len(op)].encode('hex').ljust(16), repr(op))
        offset += len(op)


########NEW FILE########
__FILENAME__ = regs
import envi.registers as e_reg
import envi.archs.i386 as e_i386

# NOTE: all REX_R registers must *directly* follow their 3 bit variants
#       in the table below
amd64regs = [
    ("rax",64),("rcx",64),("rdx",64),("rbx",64),("rsp",64),("rbp",64),("rsi",64),("rdi",64),
    # The amd64 extended GP regs
    ("r8",64),("r9",64),("r10",64),("r11",64),("r12",64),("r13",64),("r14",64),("r15",64),

    ("mm0",64),("mm1",64), ("mm2",64), ("mm3",64), ("mm4",64), ("mm5",64), ("mm6",64), ("mm7",64),

    # SIMD registers
    ("xmm0",128),("xmm1",128),("xmm2",128),("xmm3",128),("xmm4",128),("xmm5",128),("xmm6",128),("xmm7",128),
    # The amd64 extended SIMD regs...
    ("xmm8",128),("xmm9",128),("xmm10",128),("xmm11",128),("xmm12",128),("xmm13",128),("xmm14",128),("xmm15",128),

    # Debug registers
    ("debug0",64),("debug1",64),("debug2",64),("debug3",64),("debug4",64),("debug5",64),("debug6",64),("debug7",64),
    # Extended Debug registers (REX.R)
    ("debug8",64),("debug9",64),("debug10",64),("debug11",64),("debug12",64),("debug13",64),("debug14",64),("debug15",64),

    # Control registers
    ("ctrl0",64),("ctrl1",64),("ctrl2",64),("ctrl3",64),("ctrl4",64),("ctrl5",64),("ctrl6",64),("ctrl7",64),
    # Extended Control registers (REX.R)
    ("ctrl8",64),("ctrl9",64),("ctrl10",64),("ctrl11",64),("ctrl12",64),("ctrl13",64),("ctrl14",64),("ctrl15",64),

    # Test registers
    ("test0", 32),("test1", 32),("test2", 32),("test3", 32),("test4", 32),("test5", 32),("test6", 32),("test7", 32),
    # Segment registers
    ("es", 16),("cs",16),("ss",16),("ds",16),("fs",16),("gs",16),
    # FPU Registers
    ("st0", 128),("st1", 128),("st2", 128),("st3", 128),("st4", 128),("st5", 128),("st6", 128),("st7", 128),
    # Leftovers ;)
    ("eflags", 32), ("rip", 64),
]

# Build up a set of accessable constants
l = locals()
e_reg.addLocalEnums(l, amd64regs)

amd64meta = e_i386.i386meta + [
    ("eax", REG_RAX, 0, 32),
    ("ecx", REG_RCX, 0, 32),
    ("edx", REG_RDX, 0, 32),
    ("ebx", REG_RBX, 0, 32),
    ("esp", REG_RSP, 0, 32),
    ("ebp", REG_RBP, 0, 32),
    ("esi", REG_RSI, 0, 32),
    ("edi", REG_RDI, 0, 32),

    ("ax", REG_RAX, 0, 16),
    ("cx", REG_RCX, 0, 16),
    ("dx", REG_RDX, 0, 16),
    ("bx", REG_RBX, 0, 16),
    ("sp", REG_RSP, 0, 16),
    ("bp", REG_RBP, 0, 16),
    ("si", REG_RSI, 0, 16),
    ("di", REG_RDI, 0, 16),

    ("al", REG_RAX, 0, 8),
    ("cl", REG_RCX, 0, 8),
    ("dl", REG_RDX, 0, 8),
    ("bl", REG_RBX, 0, 8),

    ("ah", REG_RAX, 8, 8),
    ("ch", REG_RCX, 8, 8),
    ("dh", REG_RDX, 8, 8),
    ("bh", REG_RBX, 8, 8),

    # NOTE: with a REX prefix, all ah/ch regs get
    # mapped back to being sil/dil etc...
    ("spl", REG_RSP, 8, 8),
    ("bpl", REG_RBP, 8, 8),
    ("sil", REG_RSI, 8, 8),
    ("dil", REG_RDI, 8, 8),

    # The new GP regs are accessible in all modes.
    ("r8d",  REG_R8,  0, 32),
    ("r9d",  REG_R9,  0, 32),
    ("r10d", REG_R10, 0, 32),
    ("r11d", REG_R11, 0, 32),
    ("r12d", REG_R12, 0, 32),
    ("r13d", REG_R13, 0, 32),
    ("r14d", REG_R14, 0, 32),
    ("r15d", REG_R15, 0, 32),

    ("r8w",  REG_R8,  0, 16),
    ("r9w",  REG_R9,  0, 16),
    ("r10w", REG_R10, 0, 16),
    ("r11w", REG_R11, 0, 16),
    ("r12w", REG_R12, 0, 16),
    ("r13w", REG_R13, 0, 16),
    ("r14w", REG_R14, 0, 16),
    ("r15w", REG_R15, 0, 16),

    ("r8l",  REG_R8,  0, 8),
    ("r9l",  REG_R9,  0, 8),
    ("r10l", REG_R10, 0, 8),
    ("r11l", REG_R11, 0, 8),
    ("r12l", REG_R12, 0, 8),
    ("r13l", REG_R13, 0, 8),
    ("r14l", REG_R14, 0, 8),
    ("r15l", REG_R15, 0, 8),

    # Flags
    ("TF", REG_EFLAGS, 8, 1),
]

# Add the meta's indexes
e_reg.addLocalMetas(l, amd64meta)

RMETA_LOW32 = 0x00200000

class Amd64RegisterContext(e_reg.RegisterContext):
    def __init__(self):
        self.loadRegDef(amd64regs)
        self.loadRegMetas(amd64meta)
        self.setRegisterIndexes(REG_RIP, REG_RSP)

    def setRegister(self, index, value):
        # NOTE: A special override is needed here because setting "eax" automagicall
        # zero extends into RAX...
        if (index & 0xffff0000) == RMETA_LOW32:
            index = index & 0xffff
        e_reg.RegisterContext.setRegister(self, index, value)


########NEW FILE########
__FILENAME__ = armdisasm
import sys
import struct
import traceback

import envi
import envi.bits as e_bits
from envi.bits import binary

from envi.archs.arm.const import *
from envi.archs.arm.regs import *

# Universal opcode things:
# len
# mode

#FIXME: TODO
#   * Thumb Extension Parser
#   * Jazelle Extension Parser
#   * Emulators

####################################################################
# Parsers for the multiply family of instruction encodings

def chopmul(opcode):
    op1 = (opcode >> 20) & 0xff
    a = (opcode >> 16) & 0xf
    b = (opcode >> 12) & 0xf
    c = (opcode >> 8)  & 0xf
    d = (opcode >> 4)  & 0xf
    e = opcode & 0xf
    return (op1<<4)+d,(a,b,c,d,e)

# FIXME this seems to be universal...
def addrToName(mcanv, va):
    sym = mcanv.syms.getSymByAddr(va)
    if sym != None:
        return repr(sym)
    return "0x%.8x" % va

# The keys in this table are made of the
# concat of bits 27-21 and 7-4 (only when
# ienc == mul!
iencmul_codes = {
    # Basic multiplication opcodes
    binary("000000001001"): ("mul",(0,4,2), 0),
    binary("000000011001"): ("mul",(0,4,2), IF_PSR_S),
    binary("000000101001"): ("mla",(0,4,2,1), 0),
    binary("000000111001"): ("mla",(0,4,2,1), IF_PSR_S),
    binary("000001001001"): ("umaal",(1,0,4,2), 0),
    binary("000010001001"): ("umull",(1,0,4,2), 0),
    binary("000010011001"): ("umull",(1,0,4,2), IF_PSR_S),
    binary("000010101001"): ("umlal",(1,0,4,2), 0),
    binary("000010111001"): ("umlal",(1,0,4,2), IF_PSR_S),
    binary("000011001001"): ("smull",(1,0,4,2), 0),
    binary("000011011001"): ("smull",(1,0,4,2), IF_PSR_S),
    binary("000011101001"): ("smlal",(1,0,4,2), 0),
    binary("000011111001"): ("smlal",(1,0,4,2), IF_PSR_S),

    # multiplys with <x><y>
    # "B"
    binary("000100001000"): ("smlabb", (0,4,2,1), 0),
    binary("000100001010"): ("smlatb", (0,4,2,1), 0),
    binary("000100001100"): ("smlabt", (0,4,2,1), 0),
    binary("000100001110"): ("smlatt", (0,4,2,1), 0),
    binary("000100101010"): ("smulwb", (0,4,2), 0),
    binary("000100101110"): ("smulwt", (0,4,2), 0),
    binary("000100101000"): ("smlawb", (0,4,2), 0),
    binary("000100101100"): ("smlawt", (0,4,2), 0),
    binary("000101001000"): ("smlalbb", (1,0,4,2), 0),
    binary("000101001010"): ("smlaltb", (1,0,4,2), 0),
    binary("000101001100"): ("smlalbt", (1,0,4,2), 0),
    binary("000101001110"): ("smlaltt", (1,0,4,2), 0),
    binary("000101101000"): ("smulbb", (0,4,2), 0),
    binary("000101101010"): ("smultb", (0,4,2), 0),
    binary("000101101100"): ("smulbt", (0,4,2), 0),
    binary("000101101110"): ("smultt", (0,4,2), 0),

    # type 2 multiplys

    binary("011100000001"): ("smuad", (0,4,2), 0),
    binary("011100000011"): ("smuadx", (0,4,2), 0),
    binary("011100000101"): ("smusd", (0,4,2), 0),
    binary("011100000111"): ("smusdx", (0,4,2), 0),
    binary("011100000001"): ("smlad", (0,4,2), 0),
    binary("011100000011"): ("smladx", (0,4,2), 0),
    binary("011100000101"): ("smlsd", (0,4,2), 0),
    binary("011100000111"): ("smlsdx", (0,4,2), 0),
    binary("011101000001"): ("smlald", (0,4,2), 0),
    binary("011101000011"): ("smlaldx", (0,4,2), 0),
    binary("011101000101"): ("smlsld", (0,4,2), 0),
    binary("011101000111"): ("smlsldx", (0,4,2), 0),
    binary("011101010001"): ("smmla", (0,4,2,1), 0),
    binary("011101010011"): ("smmlar", (0,4,2,1), 0),
    binary("011101011101"): ("smmls", (0,4,2,1), 0),
    binary("011101011111"): ("smmlsr", (0,4,2,1), 0),
    binary("011101010001"): ("smmul", (0,4,2), 0),
    binary("011101010011"): ("smmulr", (0,4,2), 0),
}

def sh_lsl(num,shval):
    return (num&0xffffffff) << shval
def sh_lsr(num,shval):
    return (num&0xffffffff) >> shval
def sh_asr(num,shval):
    return num >> shval
def sh_ror(num,shval):
    return (((num&0xffffffff) >> shval) | (num<< (32-shval))) & 0xffffffff
def sh_rrx(num,shval, emu=None):
    half1 = (num&0xffffffff) >> shval
    half2 = num<<(33-shval)
    newC = (num>>(shval-1)) & 1
    if emu != None:
        flags = emu.getFlags()
        oldC = (flags>>PSR_C) & 1
        emu.setFlags(flags & PSR_C_mask | newC)     #part of the change
    else:
        oldC = 0        # FIXME: 
    retval = (half1 | half2 | (oldC << (32-shval))) & 0xffffffff
    return retval

shifters = (
    sh_lsl,
    sh_lsr,
    sh_asr,
    sh_ror,
    sh_rrx,
    )


####################################################################
# Mnemonic tables for opcode based mnemonic lookup

# Dataprocessing mnemonics
dp_mnem = ("and","eor","sub","rsb","add","adc","sbc","rsc","tst","teq","cmp","cmn","orr","mov","bic","mvn",)

# FIXME: THIS IS FUGLY
dp_noRn = (13,15)
dp_noRd = (8,9,10,11)

# FIXME: !!! Don't make SBZ and SBO's part of the list of opers !!!
#  first parm SBZ:   mov,mvn
#  second parm SBZ:  tst,teq,cmp,cmn,
def dpbase(opval):
    """
    Parse and return opcode,sflag,Rn,Rd for a standard
    dataprocessing instruction.
    """
    ocode = (opval >> 21) & 0xf
    sflag = (opval >> 20) & 0x1
    Rn = (opval >> 16) & 0xf
    Rd = (opval >> 12) & 0xf
    #print "DPBASE:",ocode,sflag,Rn,Rd
    return ocode,sflag,Rn,Rd

####################################################################
# Parser functions for each of the instruction encodings

def p_dp_imm_shift(opval, va):
    ocode,sflag,Rn,Rd = dpbase(opval)
    Rm = opval & 0xf
    shtype = (opval >> 5) & 0x3
    shval = (opval >> 7) & 0x1f     #CHECKME: is this correctly done?

    if ocode in dp_noRn:# FIXME: FUGLY (and slow...)
        olist = (
            ArmRegOper(Rd),
            ArmRegShiftImmOper(Rm, shtype, shval),
        )
    elif ocode in dp_noRd:
        olist = (
            ArmRegOper(Rn),
            ArmRegShiftImmOper(Rm, shtype, shval),
        )
    else:
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rn),
            ArmRegShiftImmOper(Rm, shtype, shval),
        )

    opcode = (IENC_DP_IMM_SHIFT << 16) + ocode
    if sflag > 0:
        iflags = IF_PSR_S
    else:
        iflags = 0
    return (opcode, dp_mnem[ocode], olist, iflags)

# specialized mnemonics for p_misc
qop_mnem = ('qadd','qsub','qdadd','qdsub')
smla_mnem = ('smlabb','smlabt','smlatb','smlatt',)
smlal_mnem = ('smlalbb','smlalbt','smlaltb','smlaltt',)
smul_mnem = ('smulbb','smulbt','smultb','smultt',)
smlaw_mnem = ('smlawb','smlawt',)
smlaw_mnem = ('smulwb','smulwt',)

def p_misc(opval, va):  
    # 0x0f900000 = 0x01000000 or 0x01000010 (misc and misc1 are both parsed at the same time.  see the footnote [2] on dp instructions in the Atmel AT91SAM7 docs
    if   opval & 0x0fc00000 == 0x01000000:
        opcode = (IENC_MISC << 16) + 1
        mnem = 'mrs'
        r = (opval>>22) & 1
        Rd = (opval>>12) & 0xf
        olist = (
            ArmRegOper(Rd),
            ArmPgmStatRegOper(r),
        )
    elif opval & 0x0fc000f0 == 0x01200000:
        opcode = (IENC_MISC << 16) + 2
        mnem = 'msr'
        r = (opval>>22) & 1
        Rd = (opval>>12) & 0xf
        olist = (
            ArmPgmStatRegOper(r),
            ArmRegOper(Rd),
        )
    elif opval & 0x0ff000f0 == 0x01200020:
        opcode = (IENC_MISC << 16) + 5
        mnem = 'bxj'
        Rm = opval & 0xf
        olist = ( ArmRegOper(Rm), )
        
    elif opval & 0x0ff00090 == 0x01000080:
        opcode = (IENC_MISC << 16) + 9
        xy = (opval>>5)&3
        mnem = smla_mnem[xy]
        Rd = (opval>>16) & 0xf
        Rn = (opval>>12) & 0xf 
        Rs = (opval>>8) & 0xf
        Rm = opval & 0xf
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rm),
            ArmRegOper(Rs),
            ArmRegOper(Rn),
        )
    elif opval & 0x0ff000b0 == 0x01200080:
        opcode = (IENC_MISC << 16) + 10
        y = (opval>>6)&1
        mnem = smlaw_mnem[y]
        Rd = (opval>>16) & 0xf
        Rn = (opval>>12) & 0xf 
        Rs = (opval>>8) & 0xf
        Rm = opval & 0xf
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rm),
            ArmRegOper(Rs),
            ArmRegOper(Rn),
        )
    elif opval & 0x0ff000b0 == 0x012000a0:
        opcode = (IENC_MISC << 16) + 11
        y = (opval>>6)&1
        mnem = smulw_mnem[y]
        Rd = (opval>>16) & 0xf
        Rs = (opval>>8) & 0xf
        Rm = opval & 0xf
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rm),
            ArmRegOper(Rs),
        )
    elif opval & 0x0ff00090 == 0x01400080:
        opcode = (IENC_MISC << 16) + 12
        xy = (opval>>5)&3
        mnem = smlal_mnem[xy]
        Rdhi = (opval>>16) & 0xf
        Rdlo = (opval>>12) & 0xf 
        Rs = (opval>>8) & 0xf
        Rm = opval & 0xf
        olist = (
            ArmRegOper(Rdlo),
            ArmRegOper(Rdhi),
            ArmRegOper(Rs),
            ArmRegOper(Rn),
        )
    elif opval & 0x0ff00090 == 0x01600080:
        opcode = (IENC_MISC << 16) + 13
        xy = (opval>>5)&3
        mnem = smulxy_mnem[xy]
        Rd = (opval>>16) & 0xf
        Rs = (opval>>8) & 0xf
        Rm = opval & 0xf
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rm),
            ArmRegOper(Rs),
        )
        mnem = 'smul'   #xy
    #elif opval & 0x0fc00000 == 0x03200000:
        #mnem = 'msr'
    else:
        raise Exception("p_misc: invalid instruction: %.8x:\t%.8x"%(va,opval))
        opcode = IENC_UNDEF
        mnem = "undefined instruction"
        olist = ()
        
    return (opcode, mnem, olist, 0)


#### these actually belong to the media section, and already exist there. FIXME: DELETE
#misc1_mnem = ("pkhbt", "pkhtb", "rev", "rev16", "revsh", "sel", "ssat", "ssat16", "usat", "usat16", )

def p_misc1(opval, va): # 
    #R = (opval>>22) & 1
    #Rn = (opval>>16) & 0xf
    #Rd = (opval>>12) & 0xf
    #rot_imm = (opval>>8) & 0xf
    #imm = opval & 0xff
    #Rm = opval & 0xf
    if opval & 0x0ff000f0 == 0x01200010:
        opcode = INS_BX
        mnem = 'bx'
        Rm = opval & 0xf
        olist = ( ArmRegOper(Rm), )
        
    elif opval & 0x0ff000f0 == 0x01600010:  
        opcode = (IENC_MISC << 16) + 4
        mnem = 'clz'
        Rd = (opval>>12) & 0xf
        Rm = opval & 0xf
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rm),
        )
    elif opval & 0x0ff000f0 == 0x01200030:
        #opcode = (IENC_MISC << 16) + 6
        opcode = INS_BLX
        mnem = 'blx'
        Rm = opval & 0xf
        olist = ( ArmRegOper(Rm), )
        
    elif opval & 0x0f9000f0 == 0x01000050:  #all qadd/qsub's
        opcode = (IENC_MISC << 16) + 7
        qop = (opval>>21)&3
        mnem = qop_mnem[qop]
        Rn = (opval>>16) & 0xf
        Rd = (opval>>12) & 0xf
        Rm = opval & 0xf
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rm),
            ArmRegOper(Rn),
        )
        
    elif opval & 0x0ff000f0 == 0x01200070:
        opcode = (IENC_MISC << 16) + 8
        mnem = 'bkpt'
        immed = ((opval>>4)&0xfff0) + (opval&0xf)
        olist = ( ArmImmOper(immed), )

    else:
        raise Exception("p_misc1: invalid instruction: %.8x:\t%.8x"%(va,opval))
        
    return (opcode, mnem, olist, 0)



swap_mnem = ("swp","swpb",)
strex_mnem = ("strex","ldrex",)  # actual full instructions
#strh_mnem = ("strh","ldrh",)
#ldrs_mnem = ("ldrsh","ldrsb",)
#ldrd_mnem = ("ldrd","strd",)
strh_mnem = (("str",IF_H),("ldr",IF_H),)          # IF_H
ldrs_mnem = (("ldr",IF_S|IF_H),("ldr",IF_S|IF_B),)      # IF_SH, IF_SB
ldrd_mnem = (("ldr",IF_D),("str",IF_D),)        # IF_D
def p_extra_load_store(opval, va):
    pubwl = (opval>>20) & 0x1f
    Rn = (opval>>16) & 0xf
    Rd = (opval>>12) & 0xf
    Rs = (opval>>8) & 0xf
    op1 = (opval>>5) & 0x3
    Rm = opval & 0xf
    iflags = 0

    if opval&0x0fb000f0==0x01000090:# swp/swpb
        idx = (pubwl>>2)&1
        opcode = (IENC_EXTRA_LOAD << 16) + idx
        mnem = swap_mnem[idx]
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rm),
            ArmImmOffsetOper(Rn, 0, va),
        )
    elif opval&0x0fe000f0==0x01800090:# strex/ldrex
        idx = pubwl&1
        opcode = (IENC_EXTRA_LOAD << 16) + 2 + idx
        mnem = strex_mnem[idx]
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rm),
            ArmRegOper(Rn),
        )
    elif opval&0x0e4000f0==0x000000b0:# strh/ldrh regoffset
        idx = pubwl&1
        opcode = (IENC_EXTRA_LOAD << 16) + 4 + idx
        mnem,iflags = strh_mnem[idx]
        olist = (
            ArmRegOper(Rd),
            ArmRegOffsetOper(Rn, Rm, va, pubwl),
        )
    elif opval&0x0e4000f0==0x004000b0:# strh/ldrh immoffset
        idx = pubwl&1
        opcode = (IENC_EXTRA_LOAD << 16) + 6 + idx
        mnem,iflags = strh_mnem[idx]
        olist = (
            ArmRegOper(Rd),
            ArmImmOffsetOper(Rn,(Rs<<4)+Rm, va),
        )
    elif opval&0x0e4000d0==0x004000d0:# ldrsh/b immoffset
        idx = (opval>>5)&1
        opcode = (IENC_EXTRA_LOAD << 16) + 8 + idx
        mnem,iflags = ldrs_mnem[idx]
        olist = (
            ArmRegOper(Rd),
            ArmImmOffsetOper(Rn, (Rs<<4)+Rm, va, pubwl),
        )
    elif opval&0x0e4000d0==0x000000d0:# ldrsh/b regoffset
        idx = (opval>>5)&1
        opcode = (IENC_EXTRA_LOAD << 16) + 10 + idx
        mnem,iflags = ldrs_mnem[idx]
        olist = (
            ArmRegOper(Rd),
            ArmRegOffsetOper(Rn, Rm, va, pubwl),
        )
    elif opval&0x0e5000d0==0x000000d0:# ldrd/strd regoffset
        idx = (opval>>5)&1
        opcode = (IENC_EXTRA_LOAD << 16) + 12 + idx
        mnem,iflags = ldrd_mnem[idx]
        olist = (
            ArmRegOper(Rd),
            ArmRegOffsetOper(Rn, Rm, va, pubwl),
        )
    elif opval&0x0e5000d0==0x004000d0:# ldrd/strd immoffset
        idx = (opval>>5)&1
        opcode = (IENC_EXTRA_LOAD << 16) + 14 + idx
        mnem,iflags = ldrd_mnem[idx]
        olist = (
            ArmRegOper(Rd),
            ArmImmOffsetOper(Rn, (Rs<<4)+Rm),
        )
    else:
        raise Exception("extra_load_store: invalid instruction: %.8x:\t%.8x"%(va,opval))

    return (opcode, mnem, olist, iflags)


def p_dp_reg_shift(opval, va):
    ocode,sflag,Rn,Rd = dpbase(opval)
    Rm = opval & 0xf
    shtype = (opval >> 5) & 0x3
    Rs = (opval >> 8) & 0xf

    if ocode in dp_noRn:# FIXME: FUGLY
        olist = (
            ArmRegOper(Rd),
            ArmRegShiftRegOper(Rm, shtype, Rs),
        )
    elif ocode in dp_noRd:
        olist = (
            ArmRegOper(Rn),
            ArmRegShiftRegOper(Rm, shtype, Rs),
        )
    else:
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rn),
            ArmRegShiftRegOper(Rm, shtype, Rs),
        )

    opcode = (IENC_DP_REG_SHIFT << 16) + ocode
    if sflag > 0:
        iflags = IF_PSR_S
    else:
        iflags = 0
    return (opcode, dp_mnem[ocode], olist, iflags)

multfail = (None, None, None,)
def p_mult(opval, va):
    ocode, vals = chopmul(opval)
                             
    mnem, opindexes, flags = iencmul_codes.get(ocode, multfail)
    if mnem == None:
        raise Exception("p_mult: invalid instruction: %.8x:\t%.8x"%(va,opval))

    olist = []
    for i in opindexes:
        olist.append(ArmRegOper(vals[i]))

    opcode = (IENC_MULT << 16) + ocode
    return (opcode, mnem, olist, flags)

def p_dp_imm(opval, va):
    ocode,sflag,Rn,Rd = dpbase(opval)
    imm = opval & 0xff
    rot = (opval >> 7) & 0x1e   # effectively, rot*2
    

    if ocode in dp_noRn:# FIXME: FUGLY
        olist = (
            ArmRegOper(Rd),
            ArmImmOper(imm, rot, S_ROR),
        )
    elif ocode in dp_noRd:
        olist = (
            ArmRegOper(Rn),
            ArmImmOper(imm, rot, S_ROR),
        )
    else:
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rn),
            ArmImmOper(imm, rot, S_ROR),
        )

    opcode = (IENC_DP_IMM << 16) + ocode
    if sflag > 0:
        iflags = IF_PSR_S
    else:
        iflags = 0
    return (opcode, dp_mnem[ocode], olist, iflags)

def p_undef(opval, va):
    raise Exception("p_undef: invalid instruction (by definition in ARM spec): %.8x:\t%.8x"%(va,opval))
    opcode = IENC_UNDEF
    mnem = "undefined instruction"
    olist = (
        ArmImmOper(opval),
    )
        
    return (opcode, mnem, olist, 0)

def p_mov_imm_stat(opval, va):      # only one instruction: "msr"
    imm = opval & 0xff
    rot = (opval>>8) & 0xf
    r = (opval>>22) & 1
    mask = (opval>>16) & 0xf
    
    immed = ((imm>>rot) + (imm<<(32-rot))) & 0xffffffff
    
    olist = (
        ArmPgmStatRegOper(mask),
        ArmImmOper(immed),
    )
    
    opcode = (IENC_MOV_IMM_STAT << 16)
    return (opcode, "msr", olist, 0)
    
ldr_mnem = ("str", "ldr")
tsizes = (4, 1,)
def p_load_imm_off(opval, va):
    pubwl = (opval>>20) & 0x1f
    Rn = (opval>>16) & 0xf
    Rd = (opval>>12) & 0xf
    imm = opval & 0xfff

    if pubwl & 4:   # B   
        iflags = IF_B
        if (pubwl & 0x12) == 2:
            iflags |= IF_T
    else:
        iflags = 0

    olist = (
        ArmRegOper(Rd),
        ArmImmOffsetOper(Rn, imm, va, pubwl=pubwl)    # u=-/+, b=word/byte
    )
    
    opcode = (IENC_LOAD_IMM_OFF << 16)
    return (opcode, ldr_mnem[pubwl&1], olist, iflags)

def p_load_reg_off(opval, va):
    pubwl = (opval>>20) & 0x1f
    Rd = (opval>>12) & 0xf
    Rn = (opval>>16) & 0xf
    Rm = opval & 0xf
    shtype = (opval>>5) & 0x3
    shval = (opval>>7) & 0x1f

    if pubwl & 4:   # B   
        iflags = IF_B
        if (pubwl & 0x12) == 2:
            iflags |= IF_T
    else:
        iflags = 0

    olist = (
        ArmRegOper(Rd),
        ArmScaledOffsetOper(Rn, Rm, shtype, shval, va, pubwl),  # u=-/+, b=word/byte
    )
    
    opcode = (IENC_LOAD_REG_OFF << 16) 
    return (opcode, ldr_mnem[pubwl&1], olist, iflags)

    
def p_media(opval, va):
    """
    27:20, 7:4
    """
    # media is a parent for the following:
    #  parallel add/sub                         01100
    #  pkh, ssat, ssat16, usat, usat16, sel     01101
    #  rev, rev16, revsh                        01101
    #  smlad, smlsd, smlald, smusd              01110
    #  usad8, usada8                            01111
    definer = (opval>>23) & 0x1f
    if   definer == 0xc:
        return p_media_parallel(opval, va)
    elif definer == 0xd:
        return p_media_pack_sat_rev_extend(opval, va)
    elif definer == 0xe:
        return p_mult(opval, va)
        return p_media_smul(opval, va)
    else:
        return p_media_usada(opval, va)

#generate mnemonics for parallel instructions (could do manually like last time...)
parallel_mnem = []
par_suffixes = ("add16", "addsubx", "subaddx", "sub16", "add8", "sub8", "", "")
par_prefixes = ("","s","q","sh","","u","uq","uh")
for pre in par_prefixes:
    for suf in par_suffixes:
        parallel_mnem.append(pre+suf)

parallel_mnem = tuple(parallel_mnem)

def p_media_parallel(opval, va):
    
    opc1 = (opval>>17) & 0x38
    Rn = (opval>>16) & 0xf
    Rd = (opval>>12) & 0xf
    opc1 += (opval>>5) & 7
    Rm = opval & 0xf
    mnem = parallel_mnem[opc1]
    
    olist = (
        ArmRegOper(Rd),
        ArmRegOper(Rn),
        ArmRegOper(Rm),
    )
    opcode = IENC_MEDIA_PARALLEL + opc1
    return (opcode, mnem, olist, 0)


xtnd_mnem = []
xtnd_suffixes = ("xtab16","xtab","xtah","xtb16","xtb","xth",)
xtnd_prefixes = ("s","u")
for pre in xtnd_prefixes:
    for suf in xtnd_suffixes:
        xtnd_mnem.append(pre+suf)
        
xtnd_mnem = tuple(xtnd_mnem)

pkh_mnem = ('pkhbt', 'pkhtb',)
sat_mnem = ('ssat','usat')
sat16_mnem = ('ssat16','usat16')    
rev_mnem = ('rev','rev16',None,'revsh',)

def p_media_pack_sat_rev_extend(opval, va):
    ## part of p_media
    # assume bit 23 == 1
    opc1 = (opval>>20) & 7
    opc2 = (opval>>4) & 0xf
    opc25 = opc2 & 3
    opcode = 0
    
    if opc1 == 0 and opc25 == 1:   #pkh
        mnem = pkh_mnem[(opval>>6)&1]
        Rn = (opval>>16) & 0xf
        Rd = (opval>>12) & 0xf
        shift_imm = (opval>>7) & 0x1f
        Rm = opval & 0xf

        # 'FIXME WHAT WAS OPCODE SUPPOSED TO BE HERE @las?'
        # 'dear visi, read the code ;)  move the "mnem =" line if you prefer'
        
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rn),
            ArmRegShiftImmOper(Rm, S_LSL, shift_imm),
        )

    elif (opc1 & 2) and opc25 == 1: #word sat
        opidx = (opval>>22)&1
        sat_imm = 1 + (opval>>16) & 0xf
        Rd = (opval>>12) & 0xf
        Rm = opval & 0xf
        if opc1 & 0x10: # ?sat16
            mnem = sat16_mnem[opidx]
            olist = (
                ArmRegOper(Rd),
                ArmImmOper(sat_imm),
                ArmRegOper(Rm),
            )
            opcode = IENC_MEDIA_SAT + opidx
        else:
            mnem = sat_mnem[opidx]
            shift_imm = (opval>>7) & 0x1f
            sh = (opval>>5) & 2
            olist = (
                ArmRegOper(Rd),
                ArmImmOper(sat_imm),
                ArmRegShiftImmOper(Rm, sh, shift_imm),
            )
            opcode = IENC_MEDIA_SAT + 2 + opidx
            
    elif (opc1 & 3) == 2 and opc2 == 3:     #parallel half-word sat
        raise Exception("WTF! Parallel Half-Word Saturate...  what is that instruction?")
    
    elif (opc1 > 0) and (opc2 & 7) == 3:           # byte rev word
        opidx = ((opval>>21) & 2) + ((opval>>7) & 1)
        mnem = rev_mnem[opidx]
        if mnem == None:
            raise Exception("p_media_pack_sat_rev_extend: invalid instruction: %.8x:\t%.8x"%(va,opval))
 
        Rd = (opval>>12) & 0xf
        Rm = opval & 0xf
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rm),
        )
        opcode = IENC_MEDIA_REV + opidx
    #elif opc1 == 3 and opc2 == 0xb:         # byte rev pkt halfword
    #elif opc1 == 7 and opc2 == 0xb:         # byte rev signed halfword
    elif opc1 == 0 and opc2 == 0xb:         # select bytes
        mnem = "sel"
        Rn = (opval>>16) & 0xf
        Rd = (opval>>12) & 0xf
        Rm = opval & 0xf
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rn),
            ArmRegOper(Rm),
        )
        opcode = IENC_MEDIA_SEL
    elif opc2 == 7:                         # sign extend
        mnem = xtnd_mnem[opc1]
        Rn = (opval>>16) & 0xf
        Rd = (opval>>12) & 0xf
        rot = (opval>>10) & 3
        Rm = opval & 0xf
        
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rn),
            ArmRegShiftImmOper(Rm, S_ROR, rot),
        )
        opcode = IENC_MEDIA_EXTEND + opc1
    else:
        raise Exception("p_media_extend: invalid instruction: %.8x:\t%.8x"%(va,opval))

    return (opcode, mnem, olist, 0)

#smult3_mnem = ('smlad','smlsd',,,'smlald')
def p_media_smul(opval, va):
    raise Exception("Should not reach here.  If we reach here, we'll have to implement MEDIA_SMUL extended multiplication (type 3)")
    # hmmm, is this already handled?
    
def p_media_usada(opval, va):
    Rd = (opval>>16) & 0xf
    Rn = (opval>>12) & 0xf
    Rs = (opval>>8) & 0xf
    Rm = opval & 0xf
    
    if Rn == 0xf:
        mnem = "usad8"
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rm),
            ArmRegOper(Rs),
        )
        opcode = IENC_MEDIA_USAD8
    else:
        mnem = "usada8"
        olist = (
            ArmRegOper(Rd),
            ArmRegOper(Rm),
            ArmRegOper(Rs),
            ArmRegOper(Rn),
        )
        opcode = IENC_MEDIA_USADA8

    return (opcode, mnem, olist, 0)

def p_arch_undef(opval, va):
    raise Exception("p_arch_undef: invalid instruction (by definition in ARM spec): %.8x:\t%.8x"%(va,opval))
    #print >>sys.stderr,("implementme: p_arch_undef")
    return (IENC_ARCH_UNDEF, 'arch undefined', (ArmImmOper(opval),), 0)

ldm_mnem = ("stm", "ldm")

def p_load_mult(opval, va):
    puswl = (opval>>20) & 0x1f
    mnem = ldm_mnem[(puswl&1)]
    #flags = ((puswl<<10) & 0x3000) + IF_DA   # ???? WTF?
    flags = ((puswl&0x18)<<21) + IF_DA     # store bits for decoding whether to dec/inc before/after between ldr/str.  IF_DA tells the repr to print the the DAIB extension after the conditional
    Rn = (opval>>16) & 0xf
    reg_list = opval & 0xffff
    
    olist = (
        ArmRegOper(Rn),
        ArmRegListOper(reg_list, puswl),
    )
    if puswl & 2:       # W (mnemonic: "!")
        flags |= IF_W
        olist[0].oflags |= OF_W
    if puswl & 4:       # UM - usermode, or mov current SPSR -> CPSR if r15 included
        flags |= IF_UM
        olist[1].oflags |= OF_UM

    
    opcode = (IENC_LOAD_MULT << 16)
    return (opcode, mnem, olist, flags)

def instrenc(encoding, index):
    return (encoding << 16) + index

INS_B       = instrenc(IENC_BRANCH, 0)
INS_BL      = instrenc(IENC_BRANCH, 1)
INS_BX      = instrenc(IENC_MISC, 3)
INS_BXJ     = instrenc(IENC_MISC, 5)
INS_BLX     = IENC_UNCOND_BLX

b_mnem = ("b", "bl",)
def p_branch(opval, va):        # primary branch encoding.  others were added later in the media section
    off = e_bits.signed(opval, 3)
    off <<= 2
    link = (opval>>24) & 1

    #FIXME this assumes A1 branch encoding.
    
    olist = ( ArmOffsetOper(off, va),)
    if link:
        flags = envi.IF_CALL
    else:
        flags = envi.IF_BRANCH
    
    opcode = (IENC_BRANCH << 16) + link
    return (opcode, b_mnem[link], olist, flags)

ldc_mnem = ("stc", "ldc",)
def p_coproc_load(opval, va):       #FIXME: MRRC,  MCRR encoded here.
    punwl = (opval>>20) & 0x1f
    Rn = (opval>>16) & 0xf
    CRd = (opval>>12) & 0xf
    cp_num = (opval>>8) & 0xf
    offset = opval & 0xff

    if punwl & 4:   # L
        iflags = IF_L
    else:
        iflags = 0

    olist = (
        ArmCoprocOper(cp_num),
        ArmCoprocRegOper(CRd),
        ArmImmOffsetOper(Rn, offset*4, va, pubwl=punwl),
    )
    
    opcode = (IENC_COPROC_LOAD << 16)
    return (opcode, ldc_mnem[punwl&1], olist, iflags)

mcrr_mnem = ("mcrr", "mrrc")
def p_coproc_dbl_reg_xfer(opval, va):
    Rn = (opval>>16) & 0xf
    Rd = (opval>>12) & 0xf
    cp_num = (opval>>8) & 0xf
    opcode = (opval>>4) & 0xf
    CRm = opval & 0xf
    mnem = mcrr_mnem[(opval>>20) & 1]
    
    olist = (
        ArmCoprocOper(cp_num),
        ArmCoprocOpcodeOper(opcode),
        ArmRegOper(Rd),
        ArmRegOper(Rn),
        ArmCoprocRegOper(CRm),
    )
    opcode = IENC_COPROC_RREG_XFER<<16
    return (opcode, mnem, olist, 0)
    
cdp_mnem = ["cdp" for x in range(15)]
cdp_mnem.append("cdp2")

def p_coproc_dp(opval, va):
    opcode1 = (opval>>20) & 0xf
    CRn = (opval>>16) & 0xf
    CRd = (opval>>12) & 0xf
    cp_num = (opval>>8) & 0xf
    opcode2 = (opval>>5) & 0x7
    CRm = opval & 0xf
    mnem = cdp_mnem[opval>>28]

    olist = (
        ArmCoprocOper(cp_num),
        ArmCoprocOpcodeOper(opcode1),
        ArmCoprocRegOper(CRd),
        ArmCoprocRegOper(CRn),
        ArmCoprocRegOper(CRm),
        ArmCoprocOpcodeOper(opcode2),
    )
    
    opcode = (IENC_COPROC_DP << 16)
    return (opcode, mnem, olist, 0)       #FIXME: CDP2 (cond = 0b1111) also needs handling.

mcr_mnem = ("mcr", "mrc")
def p_coproc_reg_xfer(opval, va):
    opcode1 = (opval>>21) & 0x7
    load = (opval>>20) & 1
    CRn = (opval>>16) & 0xf
    Rd = (opval>>12) & 0xf
    cp_num = (opval>>8) & 0xf
    opcode2 = (opval>>5) & 0x7
    CRm = opval & 0xf

    olist = (
        ArmCoprocOper(cp_num),
        ArmCoprocOpcodeOper(opcode1),
        ArmRegOper(Rd),
        ArmCoprocRegOper(CRn),
        ArmCoprocRegOper(CRm),
        ArmCoprocOpcodeOper(opcode2),
    )
    
    opcode = (IENC_COPROC_REG_XFER << 16)
    return (opcode, mcr_mnem[load], olist, 0)

def p_swint(opval, va):
    swint = opval & 0xffffff
    
    olist = ( ArmImmOper(swint), )
    opcode = IENC_SWINT << 16 + 1
    return (opcode, "swi", olist, 0)

cps_mnem = ("cps","cps FAIL-bad encoding","cpsie","cpsid")
mcrr2_mnem = ("mcrr2", "mrrc2")
ldc2_mnem = ("stc2", "ldc2",)
mcr2_mnem = ("mcr2", "mrc2")
def p_uncond(opval, va):

    if opval & 0x0f000000 == 0x0f000000:
        # FIXME THIS IS HORKED
        opcode = IENC_SWINT << 16 + 2
        immval = opval & 0x00ffffff
        return (opcode, 'swi', (ArmImmOper(immval),), 0)

    optop = ( opval >> 26 ) & 0x3
    if optop == 0:
        if opval & 0xfff10020 == 0xf1000000:
            #cps
            imod = (opval>>18)&3
            mmod = (opval>>17)&1
            aif = (opval>>5)&7
            mode = opval&0x1f
            mnem = cps_mnem[imod]
            
            if imod & 2:
                olist = [
                    ArmCPSFlagsOper(aif)    # if mode is set...
                ]
            else:
                olist = []
            if mmod:
                olist.append(ArmImmOper(mode))
            
            opcode = IENC_UNCOND_CPS + imod
            return (opcode, mnem, olist, 0)
        elif (opval & 0xffff00f0) == 0xf1010000:
            #setend
            e = (opval>>9) & 1
            mnem = "setend"
            olist = ( ArmEndianOper(e), )
            opcode = IENC_UNCOND_SETEND
            return (opcode, mnem, olist, 0)
        else:
            raise Exception("p_uncond (ontop=0): invalid instruction: %.8x:\t%.8x"%(va,opval))
    elif optop == 1:
        if (opval & 0xf570f000) == 0xf550f000:
            #cache preload  -  also known as a nop on most platforms... does nothing except prefetch instructions from cache.
            # i'm tempted to cut the parsing of it and just return a canned something.
            mnem = "pld"
            I = (opval>>25) & 1     # what the freak am i supposed to do with "i"???
            Rn = (opval>>16) & 0xf
            U = (opval>>23) & 1
            opcode = IENC_UNCOND_PLD
            if I:
                immoffset = opval & 0xfff
                olist = (ArmImmOffsetOper(Rn, immoffset, va, U<<3),)
            else:
                Rm = opval & 0xf
                shtype = (opval>>5) & 3
                shval = (opval>>7) & 0x1f
                olist = (ArmScaledOffsetOper(Rn, Rm, shtype, shval, va, pubwl), )
            return (opcode, mnem, olist, 0)
        else:
            raise Exception("p_uncond (ontop=1): invalid instruction: %.8x:\t%.8x"%(va,opval))
    elif optop == 2:
        if (opval & 0xfe5f0f00) == 0xf84d0500:
            #save return state
            pu_w = (opval>>21) & 0xf
            mnem = "srs"
            flags = ((pu_w<<10) & 0x3000) + IF_DA
            mode = opval & 0xf
            
            olist = (
                ArmModeOper(mode, pu_w&1),
            )
            opcode = IENC_UNCOND_SRS
            return (opcode, mnem, olist, flags)
        elif (opval & 0xfe500f00) == 0xf8100a00:
            #rfe
            pu = (opval>>23) & 3
            mnem = "rfe"
            flags = (pu<<12)  + IF_DA
            Rn = (opval>>16) & 0xf
            
            olist = (
                ArmRegOper(Rn),
            )
            opcode = IENC_UNCOND_RFE
            return (opcode, mnem, olist, flags)

        elif (opval & 0xfe000000) == 0xfa000000:
            #blx
            mnem = "blx"
            h = (opval>>23) & 2
            imm_offset = e_bits.signed(opval, 3) + h
            
            olist = (
                ArmOffsetOper(imm_offset, va),
            )
            
            opcode = INS_BLX           #should this be IENC_UNCOND_BLX?
            return (opcode, mnem, olist, 0)
        else:
            raise Exception("p_uncond (ontop=2): invalid instruction: %.8x:\t%.8x"%(va,opval))
    else:
        if (opval & 0xffe00000) == 0xfc400000:
            #MRCC2/MRRC2
            Rn = (opval>>16) & 0xf
            Rd = (opval>>12) & 0xf
            cp_num = (opval>>8) & 0xf
            opcode = (opval>>4) & 0xf
            CRm = opval & 0xf
            mnem = mcrr2_mnem[(opval>>20) & 1]
                
            olist = (
                ArmCoprocOper(cp_num),
                ArmCoprocOpcodeOper(opcode),
                ArmRegOper(Rd),
                ArmRegOper(Rn),
                ArmCoprocRegOper(CRm),
            )
            opcode = IENC_COPROC_RREG_XFER<<16
            return (opcode, mnem, olist, 0)
            
        elif (opval & 0xfe000000) == 0xfc000000:
            #stc2/ldc2
            punwl = (opval>>20) & 0x1f
            Rn = (opval>>16) & 0xf
            CRd = (opval>>12) & 0xf
            cp_num = (opval>>8) & 0xf
            offset = opval & 0xff

            if punwl & 4:   # L
                iflags = IF_L
            else:
                iflags = 0

            olist = (
                ArmCoprocOper(cp_num),
                ArmCoprocRegOper(CRd),
                ArmImmOffsetOper(Rn, offset*4, va, pubwl=punwl),
            )
            
            opcode = (IENC_COPROC_LOAD << 16)
            return (opcode, ldc2_mnem[punwl&1], olist, iflags)

        elif (opval & 0xff000010) == 0xfe000000:
            #coproc dp (cdp2)
            return p_coproc_dp(opval)
        elif (opval & 0xff000010) == 0xfe000010:
            #mcr2/mrc2
            opcode1 = (opval>>21) & 0x7
            load = (opval>>20) & 1
            CRn = (opval>>16) & 0xf
            Rd = (opval>>12) & 0xf
            cp_num = (opval>>8) & 0xf
            opcode2 = (opval>>5) & 0x7
            CRm = opval & 0xf

            olist = (
                ArmCoprocOper(cp_num),
                ArmCoprocOpcodeOper(opcode1),
                ArmRegOper(Rd),
                ArmCoprocRegOper(CRn),
                ArmCoprocRegOper(CRm),
                ArmCoprocOpcodeOper(opcode2),
            )
            
            opcode = (IENC_COPROC_REG_XFER << 16)
            return (opcode, mcr2_mnem[load], olist, 0)
        else:
            raise Exception("p_uncond (ontop=3): invalid instruction: %.8x:\t%.8x"%(va,opval))
    
####################################################################
# Table of the parser functions
ienc_parsers_tmp = [None for x in range(21)]

ienc_parsers_tmp[IENC_DP_IMM_SHIFT] =  p_dp_imm_shift
ienc_parsers_tmp[IENC_MISC] =   p_misc
ienc_parsers_tmp[IENC_MISC1] =   p_misc1
ienc_parsers_tmp[IENC_EXTRA_LOAD] =   p_extra_load_store
ienc_parsers_tmp[IENC_DP_REG_SHIFT] =   p_dp_reg_shift
ienc_parsers_tmp[IENC_MULT] =   p_mult
ienc_parsers_tmp[IENC_UNDEF] =   p_undef
ienc_parsers_tmp[IENC_MOV_IMM_STAT] =   p_mov_imm_stat
ienc_parsers_tmp[IENC_DP_IMM] =   p_dp_imm
ienc_parsers_tmp[IENC_LOAD_IMM_OFF] =   p_load_imm_off
ienc_parsers_tmp[IENC_LOAD_REG_OFF] =   p_load_reg_off
ienc_parsers_tmp[IENC_ARCH_UNDEF] =   p_arch_undef
ienc_parsers_tmp[IENC_MEDIA] =   p_media
ienc_parsers_tmp[IENC_LOAD_MULT] =   p_load_mult
ienc_parsers_tmp[IENC_BRANCH] =   p_branch
ienc_parsers_tmp[IENC_COPROC_RREG_XFER] = p_coproc_dbl_reg_xfer
ienc_parsers_tmp[IENC_COPROC_LOAD] =   p_coproc_load
ienc_parsers_tmp[IENC_COPROC_DP] =   p_coproc_dp
ienc_parsers_tmp[IENC_COPROC_REG_XFER] =   p_coproc_reg_xfer
ienc_parsers_tmp[IENC_SWINT] =    p_swint
ienc_parsers_tmp[IENC_UNCOND] = p_uncond

ienc_parsers = tuple(ienc_parsers_tmp)

####################################################################

# the primary table is index'd by the 3 bits following the
# conditional and are structured as follows:
# ( ENC, nexttable )
# If ENC != None, those 3 bits were enough for us to know the
# encoding type, otherwise move on to the second table.

# The secondary tables have the format:
# (mask, value, ENC).  If the opcode is masked with "mask"
# resulting in "value" we have found the instruction encoding.
# NOTE: All entries in these tables *must* be from most specific
# to least!

# Table for initial 3 bit == 0
s_0_table = (
    # Order is critical here...
    (binary("00000000000000000000000000010000"), binary("00000000000000000000000000000000"), IENC_DP_IMM_SHIFT),
    (binary("00000001100100000000000000010000"), binary("00000001000000000000000000000000"), IENC_MISC),
    (binary("00000001100100000000000010010000"), binary("00000001000000000000000000010000"), IENC_MISC1),
    (binary("00000001000000000000000011110000"), binary("00000000000000000000000010010000"), IENC_MULT),
    (binary("00000001001000000000000010010000"), binary("00000001001000000000000010010000"), IENC_EXTRA_LOAD),
    (binary("00000000000000000000000010010000"), binary("00000000000000000000000010010000"), IENC_EXTRA_LOAD),
    (binary("00000000000000000000000010010000"), binary("00000000000000000000000000010000"), IENC_DP_REG_SHIFT),
    (0,0, IENC_UNDEF),   #catch-all
)

s_1_table = (
    (binary("00000001100110000000000000000000"), binary("00000001000000000000000000000000"), IENC_UNDEF),
    (binary("00000001100110000000000000000000"), binary("00000001001000000000000000000000"), IENC_MOV_IMM_STAT),
    (0,0, IENC_DP_IMM),
)

s_3_table = (
    (binary("00000001111100000000000011110000"),binary("00000001111100000000000011110000"), IENC_ARCH_UNDEF),
    (binary("00000000000000000000000000010000"),binary("00000000000000000000000000010000"), IENC_MEDIA),
    (0,0, IENC_LOAD_REG_OFF),
)

s_6_table = (
    (binary("00001111111000000000000000000000"),binary("00001100010000000000000000000000"), IENC_COPROC_RREG_XFER),
    (binary("00001110000000000000000000000000"),binary("00001100000000000000000000000000"), IENC_COPROC_LOAD),
)

s_7_table = (
    (binary("00000001000000000000000000000000"),binary("00000001000000000000000000000000"), IENC_SWINT),
    (binary("00000001000000000000000000010000"),binary("00000000000000000000000000010000"), IENC_COPROC_REG_XFER),
    (0, 0, IENC_COPROC_DP),
)

# Initial 3 (non conditional) primary table
inittable = [
    (None, s_0_table),
    (None, s_1_table),
    (IENC_LOAD_IMM_OFF, None), # Load or store an immediate
    (None, s_3_table),
    (IENC_LOAD_MULT, None),
    (IENC_BRANCH, None),
    (None, s_6_table),
    (None, s_7_table),
    (IENC_UNCOND, None),
]

# FIXME for emulation...
#def s_lsl(val, shval):
    #pass

#def s_lsr(val, shval):
    #pass

# These are indexed by the 2 bit "shift" value in some DP encodings
#shift_handlers = (
    #s_lsl,
    #s_lsr,
    #s_asr,
    #s_ror,
#)

endian_names = ("le","be")

#FIXME IF_NOFALL (and other envi flags)

class ArmOpcode(envi.Opcode):

    def __hash__(self):
        return int(hash(self.mnem) ^ (self.size << 4))

    def __len__(self):
        return int(self.size)

    def getBranches(self, emu=None):
        """
        Return a list of tuples.  Each tuple contains the target VA of the
        branch, and a possible set of flags showing what type of branch it is.

        See the BR_FOO types for all the supported envi branch flags....
        Example: for bva,bflags in op.getBranches():
        """
        ret = []

        if not self.iflags & envi.IF_NOFALL:
            ret.append((self.va + self.size, envi.BR_FALL))

        # FIXME if this is a move to PC god help us...
        flags = 0
        if self.prefixes != COND_AL:
            flags |= envi.BR_COND
        if self.opcode == INS_B:
            oper = self.opers[0]
            ret.append((oper.getOperValue(self), flags))
        elif self.opcode == INS_BL:
            oper = self.opers[0]
            ret.append((oper.getOperValue(self), flags | envi.BR_PROC))
        return ret

    def render(self, mcanv):
        """
        Render this opcode to the specified memory canvas
        """
        mnem = self.mnem + cond_codes.get(self.prefixes)
        mcanv.addNameText(mnem, typename="mnemonic")
        mcanv.addText(" ")

        # Allow each of our operands to render
        imax = len(self.opers)
        lasti = imax - 1
        for i in xrange(imax):
            oper = self.opers[i]
            oper.render(mcanv, self, i)
            if i != lasti:
                mcanv.addText(",")
        #mcanv.addText('; %s' % repr(self))

    def __repr__(self):
        mnem = self.mnem + cond_codes.get(self.prefixes)
        # FIXME put in S flag! -- scratch that... optimize and preload a list of these combos!

        # FIXME actually all these are broke... (iflags)
        # FIXME handle these in parsing too!
        daib_flags = self.iflags & IF_DAIB_MASK
        if self.iflags & IF_L:
            mnem += 'l'
        elif self.iflags & IF_PSR_S:
            mnem += 's'
        elif daib_flags > 0:
            idx = ((daib_flags)>>24) 
            mnem += daib[idx]
        else:
            if self.iflags & IF_S:
                mnem += 's'
            if self.iflags & IF_B:
                mnem += 'b'
            if self.iflags & IF_H:
                mnem += 'h'
            elif self.iflags & IF_T:
                mnem += 't'
        
        x = []
        
        for o in self.opers:
            x.append(o.repr(self))
        return mnem + " " + ", ".join(x)

class ArmRegOper(envi.Operand):
    def __init__(self, reg, oflags=0):
        self.reg = reg
        self.oflags = oflags

    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.reg != oper.reg:
            return False
        if self.oflags != oper.oflags:
            return False
        return True
    
    def involvesPC(self):
        return self.reg == 15

    def getOperValue(self, op, emu=None):
        if emu == None:
            return None
        return emu.getRegister(self.reg)

    def setOperValue(self, op, emu=None, val=None):
        if emu == None:
            return None
        emu.setRegister(self.reg, val)

    def render(self, mcanv, op, idx):
        rname = arm_regs[self.reg][0]
        if self.oflags & OF_W:
            rname += "!"
        mcanv.addNameText(rname, typename='registers')


    def repr(self, op):
        rname = arm_regs[self.reg][0]
        if self.oflags & OF_W:
            rname += "!"
        return rname

class ArmRegShiftRegOper(envi.Operand):

    def __init__(self, reg, shtype, shreg):
        self.reg = reg
        self.shtype = shtype
        self.shreg = shreg

    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.reg != oper.reg:
            return False
        if self.shtype != oper.shtype:
            return False
        if self.shreg != oper.shreg:
            return False
        return True

    def involvesPC(self):
        return self.reg == 15

    def getOperValue(self, op, emu=None):
        if emu == None:
            return None
        return shifters[self.shtype](emu.getRegister(self.reg), emu.getRegister(shreg))

    def render(self, mcanv, op, idx):
        rname = arm_regs[self.reg][0]
        mcanv.addNameText(rname, typename='registers')
        mcanv.addText(', ')
        mcanv.addNameText(shift_names[self.shtype])
        mcanv.addText(' ')
        mcanv.addNameText(arm_regs[self.shreg][0], typename='registers')

    def repr(self, op):
        rname = arm_regs[self.reg][0]+","
        return " ".join([rname, shift_names[self.shtype], arm_regs[self.shreg][0]])

class ArmRegShiftImmOper(envi.Operand):

    def __init__(self, reg, shtype, shimm):
        if shimm == 0:
            if shtype == S_ROR:
                shtype = S_RRX
            elif shtype == S_LSR or shtype == S_ASR:
                shimm = 32
        self.reg = reg
        self.shtype = shtype
        self.shimm = shimm

    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.reg != oper.reg:
            return False
        if self.shtype != oper.shtype:
            return False
        if self.shimm != oper.shimm:
            return False
        return True

    def involvesPC(self):
        return self.reg == 15

    def getOperValue(self, op, emu=None):
        if emu == None:
            return None
        return shifters[self.shtype](emu.getRegister(self.reg), self.shimm)

    def render(self, mcanv, op, idx):
        rname = arm_regs[self.reg][0]
        mcanv.addNameText(rname, typename='registers')
        if self.shimm != 0:
            mcanv.addText(', ')
            mcanv.addNameText(shift_names[self.shtype])
            mcanv.addText(' ')
            mcanv.addNameText('#%d' % self.shimm)
        elif self.shtype == S_RRX:
            mcanv.addText(', ')
            mcanv.addNameText(shift_names[self.shtype])

    def repr(self, op):
        rname = arm_regs[self.reg][0]
        retval = [ rname ]
        if self.shimm != 0:
            retval.append(", "+shift_names[self.shtype])
            retval.append("#%d"%self.shimm)
        elif self.shtype == S_RRX:
            retval.append(shift_names[self.shtype])
        return " ".join(retval)

class ArmImmOper(envi.Operand):

    def __init__(self, val, shval=0, shtype=S_ROR):
        self.val = val
        self.shval = shval
        self.shtype = shtype

    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.getOperValue(None) != oper.getOperValue(None):
            return False
        return True

    def involvesPC(self):
        return False

    def getOperValue(self, op, emu=None):
        return shifters[self.shtype](self.val, self.shval)

    def render(self, mcanv, op, idx):
        if self.shval != 0:
            mcanv.addNameText('#0x%.2x,%d' % (self.val, self.shval))
        else:
            mcanv.addNameText('#0x%.2x' % (self.val))

    def repr(self, op):
        if self.shval != 0:
            return '#0x%.2x,%d' % (self.val, self.shval)
        else:
            return '#0x%.2x' % (self.val)

class ArmScaledOffsetOper(envi.Operand):
    def __init__(self, base_reg, offset_reg, shtype, shval, va, pubwl=0):
        if shval == 0:
            if shtype == S_ROR:
                shtype = S_RRX
            elif shtype == S_LSR or shtype == S_ASR:
                shval = 32
        self.base_reg = base_reg
        self.offset_reg = offset_reg
        self.shtype = shtype
        self.shval = shval
        self.pubwl = pubwl

    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.base_reg != oper.base_reg:
            return False
        if self.offset_reg != oper.offset_reg:
            return False
        if self.shtype != oper.shtype:
            return False
        if self.shval != oper.shval:
            return False
        if self.pubwl != oper.pubwl:
            return False
        return True

    def involvesPC(self):
        return self.base_reg == 15

    def getOperValue(self, op, emu=None):
        if emu == None:
            return None
        raise Exception("FIXME: Implement ArmScaledOffsetOper.getOperValue()")
        return None # FIXME

    def render(self, mcanv, op, idx):
        pom = ('-','')[(self.pubwl>>4)&1]
        idxing = self.pubwl & 0x12
        basereg = arm_regs[self.base_reg][0]
        offreg = arm_regs[self.offset_reg][0]
        shname = shift_names[self.shtype]

        mcanv.addText('[')
        mcanv.addNameText(basereg, typename='registers')
        if (idxing&0x10) == 0:
            mcanv.addText('], ')
        else:
            mcanv.addText(', ')
        mcanv.addText(pom)
        mcanv.addNameText(offreg, typename='registers')
        mcanv.addText(' ')
        if self.shval != 0:
            mcanv.addNameText(shname)
            mcanv.addText(' ')
            mcanv.addNameText('#%d' % self.shval)
        if idxing == 0x10:
            mcanv.addText(']')
        elif idxing != 0:
            mcanv.addText(']!')

    def repr(self, op):
        pom = ('-','')[(self.pubwl>>4)&1]
        idxing = self.pubwl & 0x12
        basereg = arm_regs[self.base_reg][0]
        offreg = arm_regs[self.offset_reg][0]
        shname = shift_names[self.shtype]
        if self.shval != 0:
            shval = "%s #%d"%(shname,self.shval)
        elif self.shtype == S_RRX:
            shval = shname
        else:
            shval = ""
        if (idxing&0x10) == 0:         # post-indexed
            tname = '[%s], %s%s %s' % (basereg, pom, offreg, shval)
        elif idxing == 0x10:
            tname = '[%s, %s%s %s]' % (basereg, pom, offreg, shval)
        else:               # pre-indexed
            tname = '[%s, %s%s %s]!' % (basereg, pom, offreg, shval)
        return tname

class ArmRegOffsetOper(envi.Operand):
    def __init__(self, base_reg, offset_reg, va, pubwl=0):
        self.base_reg = base_reg
        self.offset_reg = offset_reg
        self.pubwl = pubwl

    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.base_reg != oper.base_reg:
            return False
        if self.offset_reg != oper.offset_reg:
            return False
        if self.pubwl != oper.pubwl:
            return False
        return True

    def involvesPC(self):
        return self.base_reg == 15

    def getOperValue(self, op, emu=None):
        if emu == None:
            return None
        raise Exception("FIXME: Implement ArmRegOffsetOper.getOperValue()")

    def render(self, mcanv, op, idx):
        pom = ('-','')[(self.pubwl>>4)&1]
        idxing = self.pubwl & 0x12
        basereg = arm_regs[self.base_reg][0]
        offreg = arm_regs[self.offset_reg][0]

        mcanv.addText('[')
        mcanv.addNameText(basereg, typename='registers')
        if (idxing&0x10) == 0:
            mcanv.addText('] ')
        else:
            mcanv.addText(', ')
        mcanv.addText(pom)
        mcanv.addNameText(offreg, typename='registers')
        if idxing == 0x10:
            mcanv.addText(']')
        elif idxing != 0:
            mcanv.addText(']!')

    def repr(self, op):
        pom = ('-','')[(self.pubwl>>4)&1]
        idxing = self.pubwl & 0x12
        basereg = arm_regs[self.base_reg][0]
        offreg = arm_regs[self.offset_reg][0]
        if (idxing&0x10) == 0:         # post-indexed
            tname = '[%s], %s%s' % (basereg, pom, offreg)
        elif idxing == 0x10:  # offset addressing, not updated
            tname = '[%s, %s%s]' % (basereg, pom, offreg)
        else:               # pre-indexed
            tname = '[%s, %s%s]!' % (basereg, pom, offreg)
        return tname

class ArmImmOffsetOper(envi.Operand):
    def __init__(self, base_reg, offset, va, pubwl=8):
        self.base_reg = base_reg
        self.offset = offset
        self.pubwl = pubwl

    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.base_reg != oper.base_reg:
            return False
        if self.offset != oper.offset:
            return False
        if self.pubwl != oper.pubwl:
            return False
        return True

    def involvesPC(self):
        return self.base_reg == 15

    def getOperValue(self, op, emu=None):
        if emu == None:
            return None

        pubwl = self.pubwl >> 1
        w = pubwl & 1
        pubwl >>=1
        b = pubwl & 1
        pubwl >>=1
        u = pubwl & 1
        pubwl >>=1
        p = pubwl 

        addr = emu.getRegister(self.basereg)
        if u:
            addr += self.offset
        else:
            addr -= self.offset

        fmt = ("B", "<L")[b]
        ret = emu.readMemoryFormat(addr, fmt)
        return ret

    def render(self, mcanv, op, idx):
        pom = ('-','')[(self.pubwl>>4)&1]
        idxing = self.pubwl & 0x12
        basereg = arm_regs[self.base_reg][0]
        mcanv.addText('[')
        mcanv.addNameText(basereg, typename='registers')
        if self.offset == 0:
            mcanv.addText(']')
        else:
            if (idxing&0x10) == 0:
                mcanv.addText('] ')
            else:
                mcanv.addText(', ')

            mcanv.addNameText('#%s0x%x' % (pom,self.offset))

            if idxing == 0x10:
                mcanv.addText(']')
            elif idxing != 0:
                mcanv.addText(']!')

    def repr(self, op):
        pom = ('-','')[(self.pubwl>>4)&1]
        idxing = (self.pubwl) & 0x12
        basereg = arm_regs[self.base_reg][0]
        if self.offset != 0:
            offset = ", #%s0x%x"%(pom,self.offset)
        else:
            offset = ""
            
        if (idxing&0x10) == 0:         # post-indexed
            tname = '[%s]%s' % (basereg, offset)
        else:
            if idxing == 0x10:  # offset addressing, not updated
                tname = '[%s%s]' % (basereg,offset)
            else:               # pre-indexed
                tname = '[%s%s]!' % (basereg,offset)
        return tname

class ArmOffsetOper(envi.Operand):        # ArmImmOper but for Branches
    def __init__(self, val, va):
        self.val = val # depending on mode, this is reg/imm
        self.va = va

    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.val != oper.val:
            return False
        if self.va != oper.va:
            return False
        return True

    def involvesPC(self):
        return True

    def getOperValue(self, op, emu=None):
        return self.va + self.val + op.size + 4 # FIXME WTF?

    def render(self, mcanv, op, idx):
        value = self.getOperValue(op)
        if mcanv.mem.isValidPointer(value):
            name = addrToName(mcanv, value)
            mcanv.addVaText(name, value)
        else:
            mcanv.addVaText('0x%.8x' % value, value)

    def repr(self, op):
        targ = self.getOperValue(op)
        tname = "#0x%.8x" % targ
        return tname

psrs = ("CPSR", "SPSR")
class ArmPgmStatRegOper(envi.Operand):
    def __init__(self, val):
        self.val = val

    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.val != oper.val:
            return False
        return True

    def involvesPC(self):
        return False

    def getOperValue(self, op, emu=None):
        if emu == None:
            return None
        raise Exception("FIXME: Implement ArmPgmStatRegOper.getOperValue()")
        return None # FIXME

    def repr(self, op):
        return psrs[self.val]
    
class ArmPgmStatFlagsOper(envi.Operand):
    # FIXED: visi: sorry, i accidentally overrode the previous class to have two meanings
    def __init__(self, val):
        self.val = val

    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.val != oper.val:
            return False
        return True

    def involvesPC(self):
        return False

    def getOperValue(self, op, emu=None):
        if emu == None:
            return None
        raise Exception("FIXME: Implement ArmPgmStatRegOper.getOperValue()")
        return None # FIXME

    def repr(self, op):
        s = ["PSR_",psr_fields[self.val]]
        return "".join(s)
    
class ArmEndianOper(ArmImmOper):
    def repr(self, op):
        return endian_names[self.val]

    def involvesPC(self):
        return False

    def getOperValue(self, op, emu=None):
        return self.val

class ArmRegListOper(envi.Operand):
    def __init__(self, val, oflags=0):
        self.val = val
        self.oflags = oflags

    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.val != oper.val:
            return False
        if self.oflags != oper.oflags:
            return False
        return True

    def involvesPC(self):
        return self.val & 0x80 == 0x80

    def render(self, mcanv, op, idx):
        mcanv.addText('{')
        for l in xrange(16):
            if self.val & 1<<l:
                mcanv.addNameText(arm_regs[l][0], typename='registers')
                mcanv.addText(', ')
        mcanv.addText('}')
        if self.oflags & OF_UM:
            mcanv.addText('^')

    def getOperValue(self, op, emu=None):
        if emu == None:
            return None
        reglist = []
        for regidx in xrange(16):
            #FIXME: check processor mode (abort, system, user, etc... use banked registers?)
            if self.val & (1<<regidx):
                reg = emu.getRegister(regidx)
                reglist.append(reg)
        return reglist

    def repr(self, op):
            s = [ "{" ]
            for l in xrange(16):
                if (self.val & (1<<l)):
                    s.append(arm_regs[l][0])
            s.append('}')
            if self.oflags & OF_UM:
                s.append('^')
            return " ".join(s)
    
aif_flags = (None, 'f','i','if','a','af','ai','aif')
class ArmPSRFlagsOper(envi.Operand):
    def __init__(self, flags):
        self.flags = flags

    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.flags != oper.flags:
            return False
        return True

    def involvesPC(self):
        return False

    def getOperValue(self, op, emu=None):
        if emu == None:
            return None
        raise Exception("FIXME: Implement ArmPSRFlagsOper.getOperValue() (does it want to be a bitmask? or the actual value according to the PSR?)")
        return None # FIXME

    def repr(self, op):
        return aif_flags[self.flags]

class ArmCoprocOpcodeOper(envi.Operand):
    def __init__(self, val):
        self.val = val
        
    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.val != oper.val:
            return False
        return True

    def involvesPC(self):
        return False

    def getOperValue(self, op, emu=None):
        return self.val

    def repr(self, op):
        return "%d"%self.val

class ArmCoprocOper(envi.Operand):
    def __init__(self, val):
        self.val = val
        
    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.val != oper.val:
            return False
        return True

    def involvesPC(self):
        return False

    def getOperValue(self, op, emu=None):
        return self.val

    def repr(self, op):
        return "p%d"%self.val

class ArmCoprocRegOper(envi.Operand):
    def __init__(self, val, shtype=None, shval=None):
        self.val = val # depending on mode, this is reg/imm
        self.shval = shval
        self.shtype = shtype

    def __eq__(self, oper):
        if not isinstance(oper, self.__class__):
            return False
        if self.val != oper.val:
            return False
        if self.shval != oper.shval:
            return False
        if self.shtype != oper.shtype:
            return False
        return True

    def involvesPC(self):
        return False

    def getOperValue(self, op, emu=None):
        if emu == None:
            return None
        raise Exception("FIXME: Implement ArmCoprocRegOper.getOperValue()")
        return None # FIXME

    def repr(self, op):
        return "c%d"%self.val



class ArmStdDisasm:

    def disasm(self, bytes, offset, va, trackMode=False):
        """
        Parse a sequence of bytes out into an envi.Opcode instance.
        """
        opbytes = bytes[offset:offset+4]
        opval, = struct.unpack("<L", opbytes)
        
        cond = opval >> 28

        # Begin the table lookup sequence with the first 3 non-cond bits
        encfam = (opval >> 25) & 0x7
        if cond == COND_EXTENDED:
            enc = IENC_UNCOND

        else:

            enc,nexttab = inittable[encfam]
            if nexttab != None: # we have to sub-parse...
                for mask,val,penc in nexttab:
                    if (opval & mask) == val:
                        enc = penc
                        break

        # If we don't know the encoding by here, we never will ;)
        if enc == None:
            raise InvalidInstruction(bytes[:4])

        opcode, mnem, olist, flags = ienc_parsers[enc](opval, va)
        # Ok...  if we're a non-conditional branch, *or* we manipulate PC unconditionally,
        # lets call ourself envi.IF_NOFALL
        if cond == COND_AL:
            if opcode in (INS_B, INS_BX):
                flags |= envi.IF_NOFALL

            elif (  len(olist) and 
                    isinstance(olist[0], ArmRegOper) and
                    olist[0].involvesPC() ):
                
                showop = True
                flags |= envi.IF_NOFALL


        # FIXME conditionals are currently plumbed as "prefixes".  Perhaps normalize to that...
        op = ArmOpcode(va, opcode, mnem, cond, 4, olist, flags)
        op.encoder = enc    #FIXME: DEBUG CODE

        return op
 
    def checkSetMode(self, op):     # FIXME: i'm forked.  bx references a register...  emulation required unless we want to trust it to always mean a jump to thumb...
        # CHANGE TO THUMB MODE FROM ARM
        #   if bx or blx and target is odd
        #   if dst is r15 and target is odd
        #   if set T bit in SPSR then reload CPSR from SPSR (sh*t, emulation here we come)
        olist = op.opers
        if op.opcode == INS_BX:
            self.parent.setMode( olist[0]&1 )   # fornicated because we don't know what the register value is
            self.parent.setMode( 1 )            # FIXME: HACK!  assumes always a call to bx 
        elif ( len(olist) > 1 and 
                isinstance(olist[0], ArmRegOper) and
                olist[0].reg == REG_PC ):
            mode = olist[1].getOperValue(op)
            if mode != None:
                self.parent.setMode( mode&1 )

        # CHANGE TO JAZELLE MODE
        #   if bxj is called and jazelle is available and enabled....  sheesh this is gonna get complex
        elif op.opcode == INS_BXJ:
            if self.parent.jzl_enabled:
                self.parent.setMode( 2 )
            else: 
                pass # how do we change PC from here?  bxj changes to jazelle mode, 
                     # but if it's unavailable, the operand is the Arm/Thumb "handler"



########NEW FILE########
__FILENAME__ = const
MODE_ARM        = 0
MODE_THUMB      = 1
MODE_JAZELLE    = 2

#IFLAGS - keep bottom 8-bits for cross-platform flags like envi.IF_NOFALL and envi.IF_BRFALL
IF_PSR_S     = 1<<8     # This DP instruciton can update CPSR
IF_B         = 1<<9     # Byte
IF_H         = 1<<11    # HalfWord
IF_S         = 1<<12    # Signed
IF_D         = 1<<13    # Signed
IF_L         = 1<<14    # Long-store (eg. Dblword Precision) for STC
IF_T         = 1<<15    # Translate for strCCbt
IF_W         = 1<<16    # Write Back for STM/LDM (!)
IF_UM        = 1<<17    # User Mode Registers for STM/LDM (^) (obviously no R15)
IF_DAIB_MASK = 0x3800000
IF_DAIB_SHFT = 23
IF_DA        = 0x0800000  # Decrement After
IF_IA        = 0x1800000  # Increment After
IF_DB        = 0x2800000  # Decrement Before
IF_IB        = 0x3800000  # Increment Before
IF_DAIB_B    = 0x2800000  # Before mask 
IF_DAIB_I    = 0x1800000  # Before mask 


OF_W         = 1<<8     # Write back to 
OF_UM        = 1<<9     # Usermode, or if r15 included set current SPSR -> CPSR


OSZFMT_BYTE = "B"
OSZFMT_HWORD = "<H"  # Introduced in ARMv4
OSZFMT_WORD = "<L"
OSZ_BYTE = 1
OSZ_HWORD = 2
OSZ_WORD = 4

fmts = [None, OSZ_BYTE, OSZ_HWORD, None, OSZ_WORD]

COND_EQ     = 0x0        # z==1  (equal)
COND_NE     = 0x1        # z==0  (not equal)
COND_CS     = 0x2        # c==1  (carry set/unsigned higher or same)
COND_CC     = 0x3        # c==0  (carry clear/unsigned lower)
COND_MI     = 0x4        # n==1  (minus/negative)
COND_PL     = 0x5        # n==0  (plus/positive or zero)
COND_VS     = 0x6        # v==1  (overflow)
COND_VC     = 0x7        # v==0  (no overflow)
COND_HI     = 0x8        # c==1 and z==0  (unsigned higher)
COND_LO     = 0x9        # c==0  or z==1  (unsigned lower or same)
COND_GE     = 0xA        # n==v  (signed greater than or equal)  (n==1 and v==1) or (n==0 and v==0)
COND_LT     = 0xB        # n!=v  (signed less than)  (n==1 and v==0) or (n==0 and v==1)
COND_GT     = 0xC        # z==0 and n==v (signed greater than)
COND_LE     = 0xD        # z==1 and n!=v (signed less than or equal)
COND_AL     = 0xE        # always
COND_EXTENDED = 0xF        # special case - see conditional 0b1111

cond_codes = {
COND_EQ:"eq", # Equal Z set 
COND_NE:"ne", # Not equal Z clear 
COND_CS:"cs", #/HS Carry set/unsigned higher or same C set 
COND_CC:"cc", #/LO Carry clear/unsigned lower C clear 
COND_MI:"mi", # Minus/negative N set 
COND_PL:"pl", # Plus/positive or zero N clear 
COND_VS:"vs", # Overflow V set 
COND_VC:"vc", # No overflow V clear 
COND_HI:"hi", # Unsigned higher C set and Z clear 
COND_LO:"lo", # Unsigned lower or same C clear or Z set 
COND_GE:"ge", # Signed greater than or equal N set and V set, or N clear and V clear (N == V) 
COND_LT:"lt", # Signed less than N set and V clear, or N clear and V set (N!= V) 
COND_GT:"gt", # Signed greater than Z clear, and either N set and V set, or N clear and V clear (Z == 0,N == V) 
COND_LE:"le", # Signed less than or equal Z set, or N set and V clear, or N clear and V set (Z == 1 or N!= V) 
COND_AL:"", # Always (unconditional) - could be "al" but "" seems better...
COND_EXTENDED:"2", # See extended opcode table
}

PM_usr = 0b10000
PM_fiq = 0b10001
PM_irq = 0b10010
PM_svc = 0b10011
PM_abt = 0b10111
PM_und = 0b11011
PM_sys = 0b11111

# reg stuff stolen from regs.py to support proc_modes
REG_OFFSET_USR = 17 * (PM_usr&0xf)
REG_OFFSET_FIQ = 17 * (PM_fiq&0xf)
REG_OFFSET_IRQ = 17 * (PM_irq&0xf)
REG_OFFSET_SVC = 17 * (PM_svc&0xf)
REG_OFFSET_ABT = 17 * (PM_abt&0xf)
REG_OFFSET_UND = 17 * (PM_und&0xf)
REG_OFFSET_SYS = 17 * (PM_sys&0xf)
#REG_OFFSET_CPSR = 17 * 16
REG_OFFSET_CPSR = 16                    # CPSR is available in every mode, and PM_usr and PM_sys don't have an SPSR.

REG_SPSR_usr = REG_OFFSET_USR + 16
REG_SPSR_fiq = REG_OFFSET_FIQ + 16
REG_SPSR_irq = REG_OFFSET_IRQ + 16
REG_SPSR_svc = REG_OFFSET_SVC + 16
REG_SPSR_abt = REG_OFFSET_ABT + 16
REG_SPSR_und = REG_OFFSET_UND + 16
REG_SPSR_sys = REG_OFFSET_SYS + 16

REG_PC = 0xf
REG_SP = 0xd
REG_BP = None
REG_CPSR = REG_OFFSET_CPSR
REG_FLAGS = REG_OFFSET_CPSR    #same location, backward-compat name

proc_modes = { # mode_name, short_name, description, offset, mode_reg_count, PSR_offset
    PM_usr: ("User Processor Mode", "usr", "Normal program execution mode", REG_OFFSET_USR, 15, REG_SPSR_usr),
    PM_fiq: ("FIQ Processor Mode", "fiq", "Supports a high-speed data transfer or channel process", REG_OFFSET_FIQ, 8, REG_SPSR_fiq),
    PM_irq: ("IRQ Processor Mode", "irq", "Used for general-purpose interrupt handling", REG_OFFSET_IRQ, 13, REG_SPSR_irq),
    PM_svc: ("Supervisor Processor Mode", "svc", "A protected mode for the operating system", REG_OFFSET_SVC, 13, REG_SPSR_svc),
    PM_abt: ("Abort Processor Mode", "abt", "Implements virtual memory and/or memory protection", REG_OFFSET_ABT, 13, REG_SPSR_abt),
    PM_und: ("Undefined Processor Mode", "und", "Supports software emulation of hardware coprocessor", REG_OFFSET_UND, 13, REG_SPSR_und),
    PM_sys: ("System Processor Mode", "sys", "Runs privileged operating system tasks (ARMv4 and above)", REG_OFFSET_SYS, 15, REG_SPSR_sys),
}

INST_ENC_DP_IMM = 0 # Data Processing Immediate Shift
INST_ENC_MISC   = 1 # Misc Instructions

# Instruction encodings in arm v5
IENC_DP_IMM_SHIFT = 0 # Data processing immediate shift
IENC_MISC         = 1 # Miscellaneous instructions
IENC_MISC1        = 2 # Miscellaneous instructions again
IENC_DP_REG_SHIFT = 3 # Data processing register shift
IENC_MULT         = 4 # Multiplies & Extra load/stores
IENC_UNDEF        = 5 # Undefined instruction
IENC_MOV_IMM_STAT = 6 # Move immediate to status register
IENC_DP_IMM       = 7 # Data processing immediate
IENC_LOAD_IMM_OFF = 8 # Load/Store immediate offset
IENC_LOAD_REG_OFF = 9 # Load/Store register offset
IENC_ARCH_UNDEF   = 10 # Architecturally undefined
IENC_MEDIA        = 11 # Media instructions
IENC_LOAD_MULT    = 12 # Load/Store Multiple
IENC_BRANCH       = 13 # Branch
IENC_COPROC_RREG_XFER = 14  # mrrc/mcrr
IENC_COPROC_LOAD  = 15 # Coprocessor load/store and double reg xfers
IENC_COPROC_DP    = 16 # Coprocessor data processing
IENC_COPROC_REG_XFER = 17 # Coprocessor register transfers
IENC_SWINT        = 18 # Sofware interrupts
IENC_UNCOND       = 19 # unconditional wacko instructions
IENC_EXTRA_LOAD   = 20 # extra load/store (swp)

# offchutes
IENC_MEDIA_PARALLEL = ((IENC_MEDIA << 8) + 1) << 8
IENC_MEDIA_SAT      = ((IENC_MEDIA << 8) + 2) << 8
IENC_MEDIA_REV      = ((IENC_MEDIA << 8) + 3) << 8
IENC_MEDIA_SEL      = ((IENC_MEDIA << 8) + 4) << 8
IENC_MEDIA_USAD8    = ((IENC_MEDIA << 8) + 5) << 8
IENC_MEDIA_USADA8   = ((IENC_MEDIA << 8) + 6) << 8
IENC_MEDIA_EXTEND   = ((IENC_MEDIA << 8) + 7) << 8
IENC_UNCOND_CPS     = ((IENC_UNCOND << 8) + 1) << 8
IENC_UNCOND_SETEND  = ((IENC_UNCOND << 8) + 2) << 8
IENC_UNCOND_PLD     = ((IENC_UNCOND << 8) + 3) << 8
IENC_UNCOND_BLX     = ((IENC_UNCOND << 8) + 4) << 8


# The supported types of operand shifts (by the 2 bit field)
S_LSL = 0
S_LSR = 1
S_ASR = 2
S_ROR = 3
S_RRX = 4 # FIXME HACK XXX add this

shift_names = ("lsl", "lsr", "asr", "ror", "rrx")

SOT_REG = 0
SOT_IMM = 1

daib = ("da","ia","db","ib")


########NEW FILE########
__FILENAME__ = disasm
#import sys
#import struct
#import traceback

import envi
#import envi.bits as e_bits
#from envi.bits import binary

from envi.archs.arm.const import *
from envi.archs.arm.armdisasm import ArmStdDisasm
from envi.archs.arm.thumbdisasm import ArmThumbDisasm
from envi.archs.arm.regs import *

# Universal opcode things:
# len
# mode

#FIXME: TODO
# FIXME ldm sp, { pc } seems to not get marked NOFALL
# FIXME ldm sp, { pc } should probably be marked IF_RET too...
# FIXME b lr / bx lr should be marked IF_RET as well!
# FIXME encoding for swi instruction ( <4 cond> 1111 <24 bytes immediate> ) is totally horked (it's in p_uncond)
# FIXME some arm opcode values are ENC << and some are ENC and some are etc..
#       (make all be ENC_FOO << 16 + <their index>

# FIXME the following things dont decode correctly
# 5346544e    cmppl   r6, #1308622848

#
# Possible future extensions: 
#   * VectorPointFloat subsystem (coproc 10+11)
#   * Debug subsystem (coproc 14)
#   * other 'default' coprocs we can handle and add value?


####################################################################
# Parsers for the multiply family of instruction encodings



class ArmDisasm:

    def __init__(self):
        self.jzl_enabled = False
        self._dis_regctx = ArmRegisterContext()
        self._disasm = None
        self._disasms = (
            ArmStdDisasm(),
            ArmThumbDisasm(),
            ArmJazDisasm(),
        )
        self.loclookup = {}
        
        self.setMode(MODE_ARM)
        
    def setMode(self, mode_num):
        self._disasm = self._disasms[mode_num]
    
    def disasm(self, bytes, offset, va, trackMode=True, mode=None):

        # hack to make sure parsing odd addresses kicks to thumb
        if va & 1 == 1:
            self.setMode( MODE_THUMB )
        else:
            self.setMode( MODE_ARM )

        op = self._disasm.disasm(bytes, offset, va, trackMode)
        return op
        
class ArmJazDisasm:
    def disasm(self, bytes, offset, va, trackMode=True):
        raise Exception('Jaz Not Supported Yet!')
    

########NEW FILE########
__FILENAME__ = emu

"""
The initial arm module.
"""

import struct

import envi
from envi.archs.arm import ArmModule
from envi.archs.arm.regs import *
from envi.archs.arm.thumbdisasm import *    #this gets both arm and thumb



# CPU state (memory, regs inc SPSRs and banked registers)
# CPU mode  (User, FIQ, IRQ, supervisor, Abort, Undefined, System)
# 
# instruction code
# exception handler code
# FIXME: SPSR handling is not certain.  

# calling conventions
class ArmArchitectureProcedureCall(envi.CallingConvention):
    """
    Implement calling conventions for your arch.
    """
    def setReturnValue(self, emu, value, ccinfo=None):
        esp = emu.getRegister(REG_ESP)
        eip = struct.unpack("<L", emu.readMemory(esp, 4))[0]
        esp += 4 # For the saved eip
        esp += (4 * argc) # Cleanup saved args

        emu.setRegister(REG_ESP, esp)
        emu.setRegister(REG_EAX, value)
        emu.setProgramCounter(eip)


    def getCallArgs(self, emu, count):
        return emu.getRegisters(0xf)  # r0-r3 are used to hand in parameters.  additional parms are stored and pointed to by r0

aapcs = ArmArchitectureProcedureCall()

class CoProcEmulator:       # useful for prototyping, but should be subclassed
    def __init__(self):
        pass

    def stc(self, parms):
        print >>sys.stderr,"CoProcEmu: stc(%s)"%repr(parms)
    def ldc(self, parms):
        print >>sys.stderr,"CoProcEmu: ldc(%s)"%repr(parms)
    def cdp(self, parms):
        print >>sys.stderr,"CoProcEmu: cdp(%s)"%repr(parms)
    def mcr(self, parms):
        print >>sys.stderr,"CoProcEmu: mcr(%s)"%repr(parms)
    def mcrr(self, parms):
        print >>sys.stderr,"CoProcEmu: mcrr(%s)"%repr(parms)
    def mrc(self, parms):
        print >>sys.stderr,"CoProcEmu: mrc(%s)"%repr(parms)
    def mrrc(self, parms):
        print >>sys.stderr,"CoProcEmu: mrrc(%s)"%repr(parms)



class ArmEmulator(ArmModule, ArmRegisterContext, envi.Emulator):

    def __init__(self):
        ArmModule.__init__(self)

        self.coprocs = [CoProcEmulator() for x in xrange(16)]       # FIXME: this should be None's, and added in for each real coproc... but this will work for now.

        seglist = [ (0,0xffffffff) for x in xrange(6) ]
        envi.Emulator.__init__(self, segs=seglist)

        ArmRegisterContext.__init__(self)

        self.addCallingConvention("Arm Arch Procedure Call", aapcs)

    def undefFlags(self):
        """
        Used in PDE.
        A flag setting operation has resulted in un-defined value.  Set
        the flags to un-defined as well.
        """
        self.setRegister(REG_EFLAGS, None)

    def setFlag(self, which, state, mode=PM_usr):   # FIXME: CPSR?
        flags = self.getSPSR(mode)
        if state:
            flags |= which
        else:
            flags &= ~which
        self.setSPSR(mode, flags)

    def getFlag(self, which, mode=PM_usr):          # FIXME: CPSR?
        #if (flags_reg == None):
        #    flags_reg = proc_modes[self.getProcMode()][5]
        #flags = self.getRegister(flags_reg)
        flags = self.getSPSR(mode)
        if flags == None:
            raise envi.PDEUndefinedFlag(self)
        return bool(flags & which)

    def readMemValue(self, addr, size):
        bytes = self.readMemory(addr, size)
        if bytes == None:
            return None
        #FIXME change this (and all uses of it) to passing in format...
        #FIXME: Remove byte check and possibly half-word check.  (possibly all but word?)
        if len(bytes) != size:
            raise Exception("Read Gave Wrong Length At 0x%.8x (va: 0x%.8x wanted %d got %d)" % (self.getProgramCounter(),addr, size, len(bytes)))
        if size == 1:
            return struct.unpack("B", bytes)[0]
        elif size == 2:
            return struct.unpack("<H", bytes)[0]
        elif size == 4:
            return struct.unpack("<L", bytes)[0]
        elif size == 8:
            return struct.unpack("<Q", bytes)[0]

    def writeMemValue(self, addr, value, size):
        #FIXME change this (and all uses of it) to passing in format...
        #FIXME: Remove byte check and possibly half-word check.  (possibly all but word?)
        if size == 1:
            bytes = struct.pack("B",value & 0xff)
        elif size == 2:
            bytes = struct.pack("<H",value & 0xffff)
        elif size == 4:
            bytes = struct.pack("<L", value & 0xffffffff)
        elif size == 8:
            bytes = struct.pack("<Q", value & 0xffffffffffffffff)
        self.writeMemory(addr, bytes)

    def readMemSignedValue(self, addr, size):
        #FIXME: Remove byte check and possibly half-word check.  (possibly all but word?)
        bytes = self.readMemory(addr, size)
        if bytes == None:
            return None
        if size == 1:
            return struct.unpack("b", bytes)[0]
        elif size == 2:
            return struct.unpack("<h", bytes)[0]
        elif size == 4:
            return struct.unpack("<l", bytes)[0]

    def executeOpcode(self, op):
        # NOTE: If an opcode method returns
        #       other than None, that is the new eip
        x = None
        if op.prefixes >= 0xe or op.prefixes == (self.getRegister(REG_FLAGS)>>28):         #nearly every opcode is optional
            meth = self.op_methods.get(op.mnem, None)
            if meth == None:
                raise envi.UnsupportedInstruction(self, op)
            x = meth(op)
            print >>sys.stderr,"executed instruction, returned: %s"%x

        if x == None:
            pc = self.getProgramCounter()
            x = pc+op.size

        self.setProgramCounter(x)

    def doPush(self, val):
        esp = self.getRegister(REG_ESP)
        esp -= 4
        self.writeMemValue(esp, val, 4)
        self.setRegister(REG_ESP, esp)

    def doPop(self):
        esp = self.getRegister(REG_ESP)
        val = self.readMemValue(esp, 4)
        self.setRegister(REG_ESP, esp+4)
        return val

    def getProcMode(self):
        return self._rctx_vals[REG_CPSR] & 0x1f     # obfuscated for speed.  could call getCPSR but it's not as fast

    def getCPSR(self):
        return self._rctx_vals[REG_CPSR]

    def setCPSR(self, psr):
        self._rctx_vals[REG_CPSR] = psr

    def getSPSR(self, mode):
        return self._rctx_vals[((mode&0xf)*17)+16]

    def setSPSR(self, mode, psr):
        self._rctx_vals[((mode&0xf)*17)+16] = psr

    def setProcMode(self, mode):
        # write current psr to the saved psr register for current mode
        curSPSRidx = proc_modes[self.getProcMode()][5]
        self._rctx_vals[curSPSRidx] = self._rctx_vals[REG_CPSR]

        # do we restore saved spsr?
        cpsr = self._rctx_vals[REG_CPSR] & 0xffffffe0
        self._rctx_vals[REG_CPSR] = cpsr | mode

    def getRegister(self, index, mode=None):
        """
        Return the current value of the specified register index.
        """
        if mode == None:
            mode = self.getProcMode() & 0xf
        else:
            mode &= 0xf
        idx = (index & 0xffff)
        ridx = idx + (mode*17)                # account for different banks of registers
        ridx = reg_table[ridx][2]         # magic pointers allowing overlapping banks of registers
        if idx == index:
            return self._rctx_vals[ridx]

        offset = (index >> 24) & 0xff
        width  = (index >> 16) & 0xff

        mask = (2**width)-1
        return (self._rctx_vals[ridx] >> offset) & mask

    def setRegister(self, index, value, mode=None):
        """
        Set a register value by index.
        """
        if mode == None:
            mode = self.getProcMode() & 0xf
        else:
            mode &= 0xf

        self._rctx_dirty = True

        idx = (index & 0xffff)
        ridx = idx + (mode*17)            # account for different banks of registers
        ridx = reg_table[ridx][2]         # magic pointers allowing overlapping banks of registers
        if idx == index:
            self._rctx_vals[ridx] = (value & self._rctx_masks[ridx])      # FIXME: hack.  should look up index in proc_modes dict?
            return

        # If we get here, it's a meta register index.
        # NOTE: offset/width are in bits...
        offset = (index >> 24) & 0xff
        width  = (index >> 16) & 0xff

        #FIXME is it faster to generate or look thses up?
        mask = (2**width)-1
        mask = mask << offset

        # NOTE: basewidth is in *bits*
        basewidth = self._rctx_widths[ridx]
        basemask  = (2**basewidth)-1

        # cut a whole in basemask at the size/offset of mask
        finalmask = basemask ^ mask

        curval = self._rctx_vals[ridx]

        self._rctx_vals[ridx] = (curval & finalmask) | (value << offset)

    def integerSubtraction(self, op):
        """
        Do the core of integer subtraction but only *return* the
        resulting value rather than assigning it.
        (allows cmp and sub to use the same code)
        """
        # Src op gets sign extended to dst
        #FIXME account for same operand with zero result for PDE
        src1 = self.getOperValue(op, 1)
        src2 = self.getOperValue(op, 2)
        Sflag = op.iflags & IF_PSR_S

        if src1 == None or src2 == None:
            self.undefFlags()
            return None

        return self.intSubBase(src1, src2, Sflag)

    def intSubBase(self, src1, src2, Sflag=0, rd=0):
        # So we can either do a BUNCH of crazyness with xor and shifting to
        # get the necissary flags here, *or* we can just do both a signed and
        # unsigned sub and use the results.


        usrc = e_bits.unsigned(src1, 4)
        udst = e_bits.unsigned(src2, 4)

        ssrc = e_bits.signed(src1, 4)
        sdst = e_bits.signed(src2, 4)

        ures = udst - usrc
        sres = sdst - ssrc

        if Sflag:
            curmode = self.getProcMode() 
            if rd == 15:
                if(curmode != PM_sys and curmode != PM_usr):
                    self.setCPSR(self.getSPSR(curmode))
                else:
                    raise Exception("Messed up opcode...  adding to r15 from PM_usr or PM_sys")
            self.setFlag(PSR_C, e_bits.is_unsigned_carry(ures, 4))
            self.setFlag(PSR_Z, not ures)
            self.setFlag(PSR_N, e_bits.is_signed(ures, 4))
            self.setFlag(PSR_V, e_bits.is_signed_overflow(sres, 4))

        #print "s2size/s1size: %d %d" % (s2size, s1size)
        #print "unsigned: %d %d %d" % (usrc, udst, ures)
        #print "signed: %d %d %d" % (ssrc, sdst, sres)
        
        #if Sflag:
        #    self.setFlag(PSR_N, sres>>32)
        #    self.setFlag(PSR_Z, sres==0)
        #    self.setFlag(PSR_C, e_bits.is_unsigned_carry(ures, s2size))
        #    self.setFlag(PSR_V, e_bits.is_signed_overflow(sres, s2size))

        return ures


    def logicalAnd(self, op):
        src1 = self.getOperValue(op, 1)
        src2 = self.getOperValue(op, 2)

        # PDE
        if src1 == None or src2 == None:
            self.undefFlags()
            self.setOperValue(op, 0, None)
            return

        res = src1 & src2

        self.setFlag(PSR_N, 0)
        self.setFlag(PSR_V, 0)
        self.setFlag(PSR_C, 0)
        self.setFlag(PSR_Z, not res)
        return res

    def i_and(self, op):
        res = self.logicalAnd(op)
        self.setOperValue(op, 0, res)
        
    def i_stm(self, op):
        srcreg = self.getOperValue(op,0)
        regmask = self.getOperValue(op,1)
        pc = self.getRegister(REG_PC)       # store for later check

        start_address = self.getRegister(srcreg)
        addr = start_address
        for reg in xrange(16):
            if reg in regmask:
                val = self.getRegister(reg)
                if op.iflags & IF_DAIB_B:
                    if op.iflags & IF_DAIB_I:
                        addr += 4
                    else:
                        addr -= 4
                    self.writeMemValue(addr, val, 4)
                else:
                    self.writeMemValue(addr, val, 4)
                    if op.iflags & IF_DAIB_I:
                        addr += 4
                    else:
                        addr -= 4
                if op.opers[0].oflags & OF_W:
                    self.setRegister(srcreg,addr)
        #FIXME: add "shared memory" functionality?  prolly just in strex which will be handled in i_strex
        # is the following necessary?  
        newpc = self.getRegister(REG_PC)    # check whether pc has changed
        if pc != newpc:
            return newpc

    i_stmia = i_stm


    def i_ldm(self, op):
        srcreg = self.getOperValue(op,0)
        regmask = self.getOperValue(op,1)
        pc = self.getRegister(REG_PC)       # store for later check

        start_address = self.getRegister(srcreg)
        addr = start_address
        for reg in xrange(16):
            if reg in regmask:
                if op.iflags & IF_DAIB_B:
                    if op.iflags & IF_DAIB_I:
                        addr += 4
                    else:
                        addr -= 4
                    regval = self.readMemValue(addr, 4)
                    self.setRegister(reg, regval)
                else:
                    regval = self.readMemValue(addr, 4)
                    self.setRegister(reg, regval)
                    if op.iflags & IF_DAIB_I:
                        addr += 4
                    else:
                        addr -= 4
                if op.opers[0].oflags & OF_W:
                    self.setRegister(srcreg,addr)
        #FIXME: add "shared memory" functionality?  prolly just in ldrex which will be handled in i_ldrex
        # is the following necessary?  
        newpc = self.getRegister(REG_PC)    # check whether pc has changed
        if pc != newpc:
            return newpc

    i_ldmia = i_ldm

    def i_ldr(self, op):
        # hint: covers ldr, ldrb, ldrbt, ldrd, ldrh, ldrsh, ldrsb, ldrt   (any instr where the syntax is ldr{condition}stuff)
        val = self.getOperValue(op, 1)
        self.setOperValue(op, 0, val)
        if op.opers[0].reg == REG_PC:
            return val





    def i_add(self, op):
        src1 = self.getOperValue(op, 1)
        src2 = self.getOperValue(op, 2)
        
        #FIXME PDE and flags
        if src1 == None or src2 == None:
            self.undefFlags()
            self.setOperValue(op, 0, None)
            return

        dsize = op.opers[0].tsize
        ssize = op.opers[1].tsize
        s2size = op.opers[2].tsize

        usrc1 = e_bits.unsigned(src1, 4)
        usrc2 = e_bits.unsigned(src2, 4)
        ssrc1 = e_bits.signed(src1, 4)
        ssrc2 = e_bits.signed(src2, 4)

        ures = usrc1 + usrc2
        sres = ssrc1 + ssrc2


        self.setOperValue(op, 0, ures)

        curmode = self.getProcMode() 
        if op.flags & IF_S:
            if op.opers[0].reg == 15 and (curmode != PM_sys and curmode != PM_usr):
                self.setCPSR(self.getSPSR(curmode))
            else:
                raise Exception("Messed up opcode...  adding to r15 from PM_usr or PM_sys")
            self.setFlag(PSR_C, e_bits.is_unsigned_carry(ures, dsize))
            self.setFlag(PSR_Z, not ures)
            self.setFlag(PSR_N, e_bits.is_signed(ures, dsize))
            self.setFlag(PSR_V, e_bits.is_signed_overflow(sres, dsize))

    def i_b(self, op):
        return self.getOperValue(op, 0)

    def i_bl(self, op):
        self.setRegister(REG_LR, self.getRegister(REG_PC))
        return self.getOperValue(op, 0)

    def i_tst(self, op):
        src1 = self.getOperValue(op, 0)
        src2 = self.getOperValue(op, 1)

        dsize = op.opers[0].tsize
        ures = src1 & src2

        self.setFlag(PSR_N, e_bits.is_signed(ures, dsize))
        self.setFlag(PSR_Z, (0,1)[ures==0])
        self.setFlag(PSR_C, e_bits.is_unsigned_carry(ures, dsize))
        #self.setFlag(PSR_V, e_bits.is_signed_overflow(sres, dsize))
        
    def i_rsb(self, op):
        src1 = self.getOperValue(op, 1)
        src2 = self.getOperValue(op, 2)
        
        #FIXME PDE and flags
        if src1 == None or src2 == None:
            self.undefFlags()
            self.setOperValue(op, 0, None)
            return

        dsize = op.opers[0].tsize
        ssize = op.opers[1].tsize
        s2size = op.opers[2].tsize

        usrc1 = e_bits.unsigned(src1, 4)
        usrc2 = e_bits.unsigned(src2, 4)
        ssrc1 = e_bits.signed(src1, 4)
        ssrc2 = e_bits.signed(src2, 4)

        ures = usrc2 - usrc1
        sres = ssrc2 - ssrc1


        self.setOperValue(op, 0, ures)

        curmode = self.getProcMode() 
        if op.flags & IF_S:
            if op.opers[0].reg == 15:
                if (curmode != PM_sys and curmode != PM_usr):
                    self.setCPSR(self.getSPSR(curmode))
                else:
                    raise Exception("Messed up opcode...  adding to r15 from PM_usr or PM_sys")
            self.setFlag(PSR_C, e_bits.is_unsigned_carry(ures, dsize))
            self.setFlag(PSR_Z, not ures)
            self.setFlag(PSR_N, e_bits.is_signed(ures, dsize))
            self.setFlag(PSR_V, e_bits.is_signed_overflow(sres, dsize))

    def i_rsb(self, op):
        # Src op gets sign extended to dst
        #FIXME account for same operand with zero result for PDE
        src1 = self.getOperValue(op, 1)
        src2 = self.getOperValue(op, 2)
        Sflag = op.iflags & IF_PSR_S

        if src1 == None or src2 == None:
            self.undefFlags()
            return None

        res = self.intSubBase(src2, src1, Sflag, op.opers[0].reg)
        self.setOperValue(op, 0, res)

    def i_sub(self, op):
        # Src op gets sign extended to dst
        #FIXME account for same operand with zero result for PDE
        src1 = self.getOperValue(op, 1)
        src2 = self.getOperValue(op, 2)
        Sflag = op.iflags & IF_PSR_S

        if src1 == None or src2 == None:
            self.undefFlags()
            return None

        res = self.intSubBase(src1, src2, Sflag, op.opers[0].reg)
        self.setOperValue(op, 0, res)

    def i_eor(self, op):
        src1 = self.getOperValue(op, 1)
        src2 = self.getOperValue(op, 2)
        
        #FIXME PDE and flags
        if src1 == None or src2 == None:
            self.undefFlags()
            self.setOperValue(op, 0, None)
            return

        usrc1 = e_bits.unsigned(src1, 4)
        usrc2 = e_bits.unsigned(src2, 4)

        ures = usrc1 ^ usrc2

        self.setOperValue(op, 0, ures)

        curmode = self.getProcMode() 
        if op.iflags & IF_S:
            if op.opers[0].reg == 15:
                if (curmode != PM_sys and curmode != PM_usr):
                    self.setCPSR(self.getSPSR(curmode))
                else:
                    raise Exception("Messed up opcode...  adding to r15 from PM_usr or PM_sys")
            self.setFlag(PSR_C, e_bits.is_unsigned_carry(ures, 4))
            self.setFlag(PSR_Z, not ures)
            self.setFlag(PSR_N, e_bits.is_signed(ures, 4))
            self.setFlag(PSR_V, e_bits.is_signed_overflow(sres, 4))




    # Coprocessor Instructions
    def i_stc(self, op):
        cpnum = op.opers[0]
        coproc = self._getCoProc(cpnum)
        coproc.stc(op.opers)

    def i_ldc(self, op):
        cpnum = op.opers[0]
        coproc = self._getCoProc(cpnum)
        coproc.ldc(op.opers)

    def i_cdp(self, op):
        cpnum = op.opers[0]
        coproc = self._getCoProc(cpnum)
        coproc.cdp(op.opers)

    def i_mrc(self, op):
        cpnum = op.opers[0]
        coproc = self._getCoProc(cpnum)
        coproc.mrc(op.opers)

    def i_mrrc(self, op):
        cpnum = op.opers[0]
        coproc = self._getCoProc(cpnum)
        coproc.mrrc(op.opers)

    def i_mcr(self, op):
        cpnum = op.opers[0]
        coproc = self._getCoProc(cpnum)
        coproc.mrrc(op.opers)

    def i_mcrr(self, op):
        cpnum = op.opers[0]
        coproc = self._getCoProc(cpnum)
        coproc.mcrr(op.opers)




opcode_dist = \
[('and', 4083),#
 ('stm', 1120),#
 ('ldr', 1064),#
 ('add', 917),#
 ('stc', 859),#
 ('str', 770),#
 ('bl', 725),#
 ('ldm', 641),#
 ('b', 472),#
 ('ldc', 469),#
 ('tst', 419),#
 ('rsb', 196),#
 ('eor', 180),#
 ('mul', 159),
 ('swi', 128),
 ('sub', 110),#
 ('adc', 96),
 ('cdp', 74),#
 ('orr', 66),
 ('cmn', 59),
 ('mcr', 55),#
 ('stc2', 54),
 ('ldc2', 52),
 ('mrc', 49),#
 ('mvn', 47),
 ('rsc', 46),
 ('teq', 45),
 ('cmp', 41),
 ('sbc', 40),
 ('mov', 35),
 ('bic', 34),
 ('mcr2', 29),#
 ('mrc2', 28),#
 ('swp', 28),
 ('mcrr', 21),#
 ('mrrc', 20),#
 ('usada8', 20),
 ('qadd', 13),
 ('mrrc2', 10),#
 ('add16', 9),
 ('mla', 9),
 ('mcrr2', 7),#
 ('uqsub16', 6),
 ('uqadd16', 5),
 ('sub16', 5),
 ('umull', 4),
 ('uq', 3),
 ('smlsdx', 3),
 ('uhsub16', 3),
 ('uqsubaddx', 3),
 ('qdsub', 2),
 ('subaddx', 2),
 ('uqadd8', 2),
 ('ssat', 2),
 ('uqaddsubx', 2),
 ('smull', 2),
 ('blx', 2),
 ('smlal', 2),
 ('shsub16', 1),
 ('', 1),
 ('smlsd', 1),
 ('pkhbt', 1),
 ('revsh', 1),
 ('qadd16', 1),
 ('uqsub8', 1),
 ('ssub16', 1),
 ('usad8', 1),
 ('uadd16', 1),
 ('smladx', 1),
 ('swpb', 1),
 ('smlaldx', 1),
 ('usat', 1),
 ('umlal', 1),
 ('rev16', 1),
 ('sadd16', 1),
 ('sel', 1),
 ('sub8', 1),
 ('pkhtb', 1),
 ('umaal', 1),
 ('addsubx', 1),
 ('add8', 1),
 ('smlad', 1),
 ('sxtb', 1),
 ('sadd8', 1)]


########NEW FILE########
__FILENAME__ = regs
from envi.archs.arm.const import *
import envi.registers as e_reg

arm_regs = (
    ('r0', 32),
    ('r1', 32),
    ('r2', 32),
    ('r3', 32),
    ('r4', 32),
    ('r5', 32),
    ('r6', 32),
    ('r7', 32),
    ('r8', 32),
    ('r9', 32),
    ('sl', 32),
    ('fp', 32),
    ('ip', 32),
    ('sp', 32),
    ('lr', 32),
    ('pc', 32),
    ('cpsr', 32),
    # FIXME shadow regs go here (but are not encoded in
    # instructions... they are used by context only)
)

l = locals()
e_reg.addLocalEnums(l, arm_regs)

PSR_N = 31  # negative
PSR_Z = 30  # zero
PSR_C = 29  # carry
PSR_V = 28  # oVerflow
PSR_Q = 27
PSR_J = 24
PSR_GE = 16
PSR_E = 9
PSR_A = 8
PSR_I = 7
PSR_F = 6
PSR_T = 5
PSR_M = 0

PSR_C_bit  = 1 << PSR_C
PSR_C_mask = 0xffffffff ^ PSR_C_bit

psr_fields = [None for x in xrange(32)]
psr_fields[PSR_M] = "M"
psr_fields[PSR_T] = "T"
psr_fields[PSR_F] = "F"
psr_fields[PSR_I] = "I"
psr_fields[PSR_A] = "A"
psr_fields[PSR_E] = "E"
psr_fields[PSR_GE] = "GE"
psr_fields[PSR_GE+1] = "GE+1"
psr_fields[PSR_GE+2] = "GE+2"
psr_fields[PSR_GE+3] = "GE+3"
psr_fields[PSR_J] = "J"
psr_fields[PSR_Q] = "Q"
psr_fields[PSR_V] = "V"
psr_fields[PSR_C] = "C"
psr_fields[PSR_Z] = "Z"
psr_fields[PSR_N] = "N"

# FIXME this is....  hmm....
ArmMeta =tuple([("N", REG_FLAGS, PSR_N, 1),
                ("Z", REG_FLAGS, PSR_Z, 1),
                ("C", REG_FLAGS, PSR_C, 1),
                ("V", REG_FLAGS, PSR_V, 1),
                ("Q", REG_FLAGS, PSR_Q, 1),
                ("J", REG_FLAGS, PSR_J, 1),
                ("GE",REG_FLAGS, PSR_GE, 4),
                ("E", REG_FLAGS, PSR_E, 1),
                ("A", REG_FLAGS, PSR_A, 1),
                ("I", REG_FLAGS, PSR_I, 1),
                ("F", REG_FLAGS, PSR_F, 1),
                ("T", REG_FLAGS, PSR_T, 1),
                ("M", REG_FLAGS, PSR_M, 5),
                ])


class ArmRegisterContext(e_reg.RegisterContext):
    def __init__(self):
        e_reg.RegisterContext.__init__(self)
        self.loadRegDef(arm_regs)
        #self.loadRegMetas(ArmMeta)
        self.setRegisterIndexes(REG_PC, REG_SP)


########NEW FILE########
__FILENAME__ = thumb

import envi.bits as e_bits
from envi.bits import binary
import envi.bintree as e_btree

import envi.archs.arm.disasm as arm_dis
import envi.archs.arm.regs as arm_reg

thumb_32 = [
        binary('11101'),
        binary('11110'),
        binary('11111'),
]

O_REG = 0
O_IMM = 1

def shmaskval(value, shval, mask):  #FIXME: unnecessary to make this another fn call.  will be called a bajillion times.
    return (value >> shval) & mask

class simpleops:
    def __init__(self, *operdef):
        self.operdef = operdef

    def __call__(self, va, value):
        ret = []
        for otype, shval, mask in self.operdef:
            oval = shmaskval(value, shval, mask)

            ret.append( (value >> shval) )

imm5_rm_rd  = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7), (O_IMM, 6, 0x1f))
rm_rn_rd    = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7), (O_REG, 6, 0x7))
imm3_rn_rd  = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7), (O_IMM, 6, 0x7))
imm8_rd     = simpleops((O_REG, 8, 0x7), (O_IMM, 0, 0xff))
rm_rd       = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7))
rn_rdm      = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7))
rm_rdn      = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7))
rm_rd_imm0  = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7), (O_IMM, 0, 0))
rm4_shift3  = simpleops((O_REG, 3, 0xf))
rm_rn_rt    = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7), (O_REG, 6, 0x7))
imm8        = simpleops((O_IMM, 8, 0xff))
imm11       = simpleops((O_IMM, 11, 0x7ff))

sh4_imm1    = simpleops((O_IMM, 3, 0x1))

def d1_rm4_rd3(va, value):
    # 0 1 0 0 0 1 0 0 DN(1) Rm(4) Rdn(3)
    rdbit = shmaskval(value, 4, 0x8)
    rd = shmaskval(value, 0, 0x7) + rdbit
    rm = shmaskval(value, 3, 0xf)
    return ArmRegOper(rd),ArmRegOper(rn)

def rm_rn_rt(va, value):
    rt = shmask(value, 0, 0x7) # target
    rn = shmask(value, 3, 0x7) # base
    rm = shmask(value, 6, 0x7) # offset
    oper0 = arm_dis.ArmRegOper(rt)
    oper1 = arm_dis.ArmRegOffsetOper(rn, rm, va)
    return oper0,oper1

def imm5_rn_rt(va, value):
    imm = shmask(value, 6, 0x1f)
    rn = shmask(value, 3, 0x7)
    rt = shmask(value, 0, 0x7)
    oper0 = arm_dis.ArmRegOper(rt)
    oper1 = arm_dis.ArmImmOffsetOper(rn, imm, va)
    return oper0,oper1

def rd_sp_imm8(va, value):
    rd = shmask(value, 8, 0x7)
    imm = shmask(value, 0, 0xff)
    oper0 = arm_dis.ArmRegOper(rd)
    # pre-compute PC relative addr
    oper1 = arm_dis.ArmImmOffsetOper(REG_SP, imm)
    return oper0,oper1

def rd_pc_imm8(va, value):
    rd = shmask(value, 8, 0x7)
    imm = shmask(value, 0, 0xff)
    oper0 = arm_dis.ArmRegOper(rd)
    # pre-compute PC relative addr
    oper1 = arm_dis.ArmImmOper(va+imm)
    return oper0,oper1

def rt_pc_imm8(va, value):
    rt = shmask(value, 8, 0x7)
    imm = shmask(value, 0, 0xff)
    oper0 = arm_dis.ArmRegOper(rt)
    oper1 = arm_dis.ArmImmOffsetOper() # FIXME offset from PC
    return oper0,oper1

def ldmia(va, value): 
    rd = shmask(value, 8, 0x7)
    reg_list = value & 0xff
    oper0 = arm_dis.ArmRegOper(rd)
    oper1 = arm_dis.ArmRegListOper(reg_list)
    flags = 1<<11   # W flag indicating that write back should occur (marked by "!")
    return oper0,oper1

def sp_sp_imm7(va, value):
    imm = shmask(value, 0, 0x7f)
    o0 = arm_dis.ArmRegOper(arm_reg.REG_SP)
    o1 = arm_dis.ArmRegOper(arm_reg.REG_SP)
    o2 = arm_dis.ArmImmOper(imm*4)
    return o0,o1,o2

def rm_reglist(va, value):
    rm = shmask(value, 8, 0x7)
    reglist = value & 0xff
    oper0 = arm_dis.ArmRegOper(rm)
    oper1 = arm_dis.ArmReglistOper(reglist)
    return oper0,oper1


# opinfo is:
# ( <mnem>, <operdef>, <flags> )
# operdef is:
# ( (otype, oshift, omask), ...)
thumb_table = [
    ('00000',       ('lsl',     imm5_rm_rd, 0)), # LSL<c> <Rd>,<Rm>,#<imm5>
    ('00001',       ('lsr',     imm5_rm_rd, 0)), # LSR<c> <Rd>,<Rm>,#<imm>
    ('00010',       ('asr',     imm5_rm_rd, 0)), # ASR<c> <Rd>,<Rm>,#<imm>
    ('0001100',     ('add',     rm_rn_rd,   0)), # ADD<c> <Rd>,<Rn>,<Rm>
    ('0001101',     ('sub',     rm_rn_rd,   0)), # SUB<c> <Rd>,<Rn>,<Rm>
    ('0001110',     ('add',     imm3_rn_rd, 0)), # ADD<c> <Rd>,<Rn>,#<imm3>
    ('0001111',     ('sub',     imm3_rn_rd, 0)), # SUB<c> <Rd>,<Rn>,#<imm3>
    ('00100',       ('mov',     imm8_rd,    0)), # MOV<c> <Rd>,#<imm8>
    ('00101',       ('cmp',     imm8_rd,    0)), # CMP<c> <Rn>,#<imm8>
    ('00110',       ('add',     imm8_rd,    0)), # ADD<c> <Rdn>,#<imm8>
    ('00111',       ('sub',     imm8_rd,    0)), # SUB<c> <Rdn>,#<imm8>
    # Data processing instructions
    ('0100000000',  ('and',     rm_rdn,     0)), # AND<c> <Rdn>,<Rm>
    ('0100000001',  ('eor',     rm_rdn,     0)), # EOR<c> <Rdn>,<Rm>
    ('0100000010',  ('lsl',     rm_rdn,     0)), # LSL<c> <Rdn>,<Rm>
    ('0100000011',  ('lsr',     rm_rdn,     0)), # LSR<c> <Rdn>,<Rm>
    ('0100000100',  ('asr',     rm_rdn,     0)), # ASR<c> <Rdn>,<Rm>
    ('0100000101',  ('adc',     rm_rdn,     0)), # ADC<c> <Rdn>,<Rm>
    ('0100000110',  ('sbc',     rm_rdn,     0)), # SBC<c> <Rdn>,<Rm>
    ('0100000111',  ('ror',     rm_rdn,     0)), # ROR<c> <Rdn>,<Rm>
    ('0100001000',  ('tst',     rm_rd,      0)), # TST<c> <Rn>,<Rm>
    ('0100001001',  ('rsb',     rm_rd_imm0, 0)), # RSB<c> <Rd>,<Rn>,#0
    ('0100001010',  ('cmp',     rm_rd,      0)), # CMP<c> <Rn>,<Rm>
    ('0100001011',  ('cmn',     rm_rd,      0)), # CMN<c> <Rn>,<Rm>
    ('0100001100',  ('orr',     rm_rdn,     0)), # ORR<c> <Rdn>,<Rm>
    ('0100001101',  ('mul',     rn_rdm,     0)), # MUL<c> <Rdm>,<Rn>,<Rdm>
    ('0100001110',  ('bic',     rm_rdn,     0)), # BIC<c> <Rdn>,<Rm>
    ('0100001111',  ('mvn',     rm_rd,      0)), # MVN<c> <Rd>,<Rm>
    # Special data instructions and branch and exchange
    ('0100010000',  ('add',     d1_rm4_rd3, 0)), # ADD<c> <Rdn>,<Rm>
    ('0100010001',  ('add',     d1_rm4_rd3, 0)), # ADD<c> <Rdn>,<Rm>
    ('010001001',   ('add',     d1_rm4_rd3, 0)), # ADD<c> <Rdn>,<Rm>
    ('0100010101',  ('cmp',     d1_rm4_rd3, 0)), # CMP<c> <Rn>,<Rm>
    ('010001011',   ('cmp',     d1_rm4_rd3, 0)), # CMP<c> <Rn>,<Rm>
    ('0100011000',  ('mov',     d1_rm4_rd3, 0)), # MOV<c> <Rd>,<Rm>
    ('0100011001',  ('mov',     d1_rm4_rd3, 0)), # MOV<c> <Rd>,<Rm>
    ('0100011010',  ('mov',     d1_rm4_rd3, 0)), # MOV<c> <Rd>,<Rm>
    ('010001110',   ('bx',      rm4_shift3, 0)), # BX<c> <Rm>
    ('010001111',   ('blx',     rm4_shift3, 0)), # BLX<c> <Rm>
    # Load from Literal Pool
    ('01001',       ('ldr',     rt_pc_imm8, 0)), # LDR<c> <Rt>,<label>
    # Load/Stor single data item
    ('0101000',     ('str',     rm_rn_rt,   0)), # STR<c> <Rt>,[<Rn>,<Rm>]
    ('0101001',     ('strh',    rm_rn_rt,   0)), # STRH<c> <Rt>,[<Rn>,<Rm>]
    ('0101010',     ('strb',    rm_rn_rt,   0)), # STRB<c> <Rt>,[<Rn>,<Rm>]
    ('0101011',     ('ldrsb',   rm_rn_rt,   0)), # LDRSB<c> <Rt>,[<Rn>,<Rm>]
    ('0101100',     ('ldr',     rm_rn_rt,   0)), # LDR<c> <Rt>,[<Rn>,<Rm>]
    ('0101101',     ('ldrh',    rm_rn_rt,   0)), # LDRH<c> <Rt>,[<Rn>,<Rm>]
    ('0101110',     ('ldrb',    rm_rn_rt,   0)), # LDRB<c> <Rt>,[<Rn>,<Rm>]
    ('0101111',     ('ldrsh',   rm_rn_rt,   0)), # LDRSH<c> <Rt>,[<Rn>,<Rm>]
    ('01100',       ('str',     imm5_rn_rt, 0)), # STR<c> <Rt>, [<Rn>{,#<imm5>}]
    ('01101',       ('ldr',     imm5_rn_rt, 0)), # LDR<c> <Rt>, [<Rn>{,#<imm5>}]
    ('01110',       ('strb',    imm5_rn_rt, 0)), # STRB<c> <Rt>,[<Rn>,#<imm5>]
    ('01111',       ('ldrb',    imm5_rn_rt, 0)), # LDRB<c> <Rt>,[<Rn>{,#<imm5>}]
    ('10000',       ('strh',    imm5_rn_rt, 0)), # STRH<c> <Rt>,[<Rn>{,#<imm>}]
    ('10001',       ('ldrh',    imm5_rn_rt, 0)), # LDRH<c> <Rt>,[<Rn>{,#<imm>}]
    ('10010',       ('str',     imm5_rn_rt, 0)), # STR<c> <Rt>, [<Rn>{,#<imm>}]
    ('10011',       ('ldr',     imm5_rn_rt, 0)), # LDR<c> <Rt>, [<Rn>{,#<imm>}]
    # Generate PC relative address
    ('10100',       ('add',     rd_pc_imm8, 0)), # ADD<c> <Rd>,<label>
    # Generate SP relative address
    ('10101',       ('add',     rd_sp_imm8, 0)), # ADD<c> <Rd>,SP,#<imm>
    # Miscellaneous instructions
    ('10110110010', ('setend',  sh4_imm1,   0)), # SETEND <endian_specifier>
    ('10110110011', ('cps',     simpleops(),0)), # CPS<effect> <iflags> FIXME
    ('1011101000',  ('rev',     rn_rdm,     0)), # REV Rd, Rn
    ('1011101001',  ('rev16',   rn_rdm,     0)), # REV16 Rd, Rn
    ('1011101011',  ('revsh',   rn_rdm,     0)), # REVSH Rd, Rn
    ('101100000',   ('add',     sp_sp_imm7, 0)), # ADD<c> SP,SP,#<imm>
    ('101100001',   ('sub',     sp_sp_imm7, 0)), # SUB<c> SP,SP,#<imm>
    ('10111110',    ('bkpt',    imm8,       0)), # BKPT <blahblah>
    # Load / Store Multiple
    ('11000',       ('stmia',   rm_reglist, 0x800)), # LDMIA Rd!, reg_list
    ('11001',       ('ldmia',   rm_reglist, 0x800)), # STMIA Rd!, reg_list
    # Conditional Branches
    ('11010000',    ('b',       imm8,       0)),
    ('11010001',    ('bn',      imm8,       0)),
    ('11010010',    ('bz',      imm8,       0)),
    ('11010011',    ('bnz',     imm8,       0)),
    ('11010100',    ('bc',      imm8,       0)),
    ('11010101',    ('bnc',     imm8,       0)),
    ('11010100',    ('bzc',     imm8,       0)),
    ('11010111',    ('bnzc',    imm8,       0)),
    ('11011000',    ('bv',      imm8,       0)),
    ('11011001',    ('bnv',     imm8,       0)),
    ('11011010',    ('bzv',     imm8,       0)),
    ('11011011',    ('bnzv',    imm8,       0)),
    ('11011100',    ('bcv',     imm8,       0)),
    ('11011101',    ('bncv',    imm8,       0)),
    ('11011110',    ('bzcv',    imm8,       0)),
    ('11011111',    ('bnzcv',   imm8,       0)),
    # Software Interrupt
    ('11011111',    ('swi',     imm8,       0)), # SWI <blahblah>
    ('11100',       ('b',       imm11,      0)), # B <addr11> 
    ('11101',       ('blx',     imm11,      0)), # BLX suffix <addr11>  -- SEE p542 of 14218.pdf manual for how this if gonna fuck with emulation. 
    ('11110',       ('bl',      imm11,      0)), # BL/BLX prefix <addr11> -- SEE p542 of 14218.pdf manual for how this if gonna fuck with emulation. 
    ('11111',       ('blx',     imm11,      0)), # BL suffix <addr11>   -- SEE p542 of 14218.pdf manual for how this if gonna fuck with emulation.
]

ttree = e_btree.BinaryTree()
for binstr, opinfo in thumb_table:
    ttree.addBinstr(binstr, opinfo)

thumb32mask = binary('11111')
thumb32min  = binary('11100')

def is_thumb32(val):
    '''
    Take a 16 bit integer (opcode) value and determine
    if it is really the first 16 bits of a 32 bit
    instruction.
    '''
    bval = val >> 11
    return (bval & thumb32mask) > thumb32min


class ThumbOpcode(arm_dis.ArmOpcode):
    pass

class ArmThumbDisasm(arm_dis.ArmDisasmChild):
    def disasm(self, bytes, offset, va, trackMode=True):
        val = struct.unpack("<L", bytes[offset:offset+2])
        mnem, opermkr, flags = ttree.getInstr(val)
        olist = opermkr(va, val)

        op = ThumbOpcode(va, opcode, mnem, 0xe, 2, olist, flags)
        return op
        raise Exception("ummm. you could try Implementing disasm first... duh.")

########NEW FILE########
__FILENAME__ = thumbdisasm

import envi.bits as e_bits
import envi.bintree as e_btree

from envi.bits import binary

from envi.archs.arm.armdisasm import *

thumb_32 = [
        binary('11101'),
        binary('11110'),
        binary('11111'),
]


O_REG = 0
O_IMM = 1

OperType = (
    ArmRegOper,
    ArmImmOper,
    )
def shmaskval(value, shval, mask):  #FIXME: unnecessary to make this another fn call.  will be called a bajillion times.
    return (value >> shval) & mask

class simpleops:
    def __init__(self, *operdef):
        self.operdef = operdef

    def __call__(self, va, value):
        ret = []
        for otype, shval, mask in self.operdef:
            oval = shmaskval(value, shval, mask)
            oper = OperType[otype]((value >> shval) & mask)
            ret.append( oper )
        return ret

imm5_rm_rd  = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7), (O_IMM, 6, 0x1f))
rm_rn_rd    = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7), (O_REG, 6, 0x7))
imm3_rn_rd  = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7), (O_IMM, 6, 0x7))
imm8_rd     = simpleops((O_REG, 8, 0x7), (O_IMM, 0, 0xff))
rm_rd       = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7))
rn_rdm      = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7))
rm_rdn      = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7))
rm_rd_imm0  = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7), (O_IMM, 0, 0))
rm4_shift3  = simpleops((O_REG, 3, 0xf))
rm_rn_rt    = simpleops((O_REG, 0, 0x7), (O_REG, 3, 0x7), (O_REG, 6, 0x7))
imm8        = simpleops((O_IMM, 8, 0xff))
imm11       = simpleops((O_IMM, 11, 0x7ff))

sh4_imm1    = simpleops((O_IMM, 3, 0x1))

def d1_rm4_rd3(va, value):
    # 0 1 0 0 0 1 0 0 DN(1) Rm(4) Rdn(3)
    rdbit = shmaskval(value, 4, 0x8)
    rd = shmaskval(value, 0, 0x7) + rdbit
    rm = shmaskval(value, 3, 0xf)
    return ArmRegOper(rd),ArmRegOper(rm)

def rm_rn_rt(va, value):
    rt = shmaskval(value, 0, 0x7) # target
    rn = shmaskval(value, 3, 0x7) # base
    rm = shmaskval(value, 6, 0x7) # offset
    oper0 = ArmRegOper(rt)
    oper1 = ArmRegOffsetOper(rn, rm, va)
    return oper0,oper1

def imm5_rn_rt(va, value):
    imm = shmaskval(value, 6, 0x1f)
    rn = shmaskval(value, 3, 0x7)
    rt = shmaskval(value, 0, 0x7)
    oper0 = ArmRegOper(rt)
    oper1 = ArmImmOffsetOper(rn, imm, va)
    return oper0,oper1

def rd_sp_imm8(va, value):
    rd = shmaskval(value, 8, 0x7)
    imm = shmaskval(value, 0, 0xff) * 4
    oper0 = ArmRegOper(rd)
    # pre-compute PC relative addr
    oper1 = ArmImmOffsetOper(REG_SP, imm, va)
    return oper0,oper1

def rd_pc_imm8(va, value):
    rd = shmaskval(value, 8, 0x7)
    imm = shmaskval(value, 0, 0xff) * 4
    oper0 = ArmRegOper(rd)
    # pre-compute PC relative addr
    oper1 = ArmImmOper(va+imm)
    return oper0,oper1

def rt_pc_imm8(va, value):
    rt = shmaskval(value, 8, 0x7)
    imm = shmaskval(value, 0, 0xff) * 4
    oper0 = ArmRegOper(rt)
    oper1 = ArmImmOffsetOper(rt, imm, va) # FIXME offset from PC
    return oper0,oper1

def ldmia(va, value): 
    rd = shmaskval(value, 8, 0x7)
    reg_list = value & 0xff
    oper0 = ArmRegOper(rd)
    oper1 = ArmRegListOper(reg_list)
    flags = 1<<11   # W flag indicating that write back should occur (marked by "!")
    return oper0,oper1

def sp_sp_imm7(va, value):
    imm = shmaskval(value, 0, 0x7f)
    o0 = ArmRegOper(REG_SP)
    o1 = ArmRegOper(REG_SP)
    o2 = ArmImmOper(imm*4)
    return o0,o1,o2

def rm_reglist(va, value):
    rm = shmaskval(value, 8, 0x7)
    reglist = value & 0xff
    oper0 = ArmRegOper(rm)
    oper1 = ArmRegListOper(reglist)
    return oper0,oper1


# opinfo is:
# ( <mnem>, <operdef>, <flags> )
# operdef is:
# ( (otype, oshift, omask), ...)
thumb_table = [
    ('00000',       ( 0,'lsl',     imm5_rm_rd, 0)), # LSL<c> <Rd>,<Rm>,#<imm5>
    ('00001',       ( 1,'lsr',     imm5_rm_rd, 0)), # LSR<c> <Rd>,<Rm>,#<imm>
    ('00010',       ( 2,'asr',     imm5_rm_rd, 0)), # ASR<c> <Rd>,<Rm>,#<imm>
    ('0001100',     ( 3,'add',     rm_rn_rd,   0)), # ADD<c> <Rd>,<Rn>,<Rm>
    ('0001101',     ( 4,'sub',     rm_rn_rd,   0)), # SUB<c> <Rd>,<Rn>,<Rm>
    ('0001110',     ( 5,'add',     imm3_rn_rd, 0)), # ADD<c> <Rd>,<Rn>,#<imm3>
    ('0001111',     ( 6,'sub',     imm3_rn_rd, 0)), # SUB<c> <Rd>,<Rn>,#<imm3>
    ('00100',       ( 7,'mov',     imm8_rd,    0)), # MOV<c> <Rd>,#<imm8>
    ('00101',       ( 8,'cmp',     imm8_rd,    0)), # CMP<c> <Rn>,#<imm8>
    ('00110',       ( 9,'add',     imm8_rd,    0)), # ADD<c> <Rdn>,#<imm8>
    ('00111',       (10,'sub',     imm8_rd,    0)), # SUB<c> <Rdn>,#<imm8>
    # Data processing instructions
    ('0100000000',  (11,'and',     rm_rdn,     0)), # AND<c> <Rdn>,<Rm>
    ('0100000001',  (12,'eor',     rm_rdn,     0)), # EOR<c> <Rdn>,<Rm>
    ('0100000010',  (13,'lsl',     rm_rdn,     0)), # LSL<c> <Rdn>,<Rm>
    ('0100000011',  (14,'lsr',     rm_rdn,     0)), # LSR<c> <Rdn>,<Rm>
    ('0100000100',  (15,'asr',     rm_rdn,     0)), # ASR<c> <Rdn>,<Rm>
    ('0100000101',  (16,'adc',     rm_rdn,     0)), # ADC<c> <Rdn>,<Rm>
    ('0100000110',  (17,'sbc',     rm_rdn,     0)), # SBC<c> <Rdn>,<Rm>
    ('0100000111',  (18,'ror',     rm_rdn,     0)), # ROR<c> <Rdn>,<Rm>
    ('0100001000',  (19,'tst',     rm_rd,      0)), # TST<c> <Rn>,<Rm>
    ('0100001001',  (20,'rsb',     rm_rd_imm0, 0)), # RSB<c> <Rd>,<Rn>,#0
    ('0100001010',  (21,'cmp',     rm_rd,      0)), # CMP<c> <Rn>,<Rm>
    ('0100001011',  (22,'cmn',     rm_rd,      0)), # CMN<c> <Rn>,<Rm>
    ('0100001100',  (23,'orr',     rm_rdn,     0)), # ORR<c> <Rdn>,<Rm>
    ('0100001101',  (24,'mul',     rn_rdm,     0)), # MUL<c> <Rdm>,<Rn>,<Rdm>
    ('0100001110',  (25,'bic',     rm_rdn,     0)), # BIC<c> <Rdn>,<Rm>
    ('0100001111',  (26,'mvn',     rm_rd,      0)), # MVN<c> <Rd>,<Rm>
    # Special data in2tructions and branch and exchange
    ('0100010000',  (27,'add',     d1_rm4_rd3, 0)), # ADD<c> <Rdn>,<Rm>
    ('0100010001',  (28,'add',     d1_rm4_rd3, 0)), # ADD<c> <Rdn>,<Rm>
    ('010001001',   (29,'add',     d1_rm4_rd3, 0)), # ADD<c> <Rdn>,<Rm>
    ('0100010101',  (30,'cmp',     d1_rm4_rd3, 0)), # CMP<c> <Rn>,<Rm>
    ('010001011',   (31,'cmp',     d1_rm4_rd3, 0)), # CMP<c> <Rn>,<Rm>
    ('0100011000',  (32,'mov',     d1_rm4_rd3, 0)), # MOV<c> <Rd>,<Rm>
    ('0100011001',  (33,'mov',     d1_rm4_rd3, 0)), # MOV<c> <Rd>,<Rm>
    ('0100011010',  (34,'mov',     d1_rm4_rd3, 0)), # MOV<c> <Rd>,<Rm>
    ('010001110',   (35,'bx',      rm4_shift3, 0)), # BX<c> <Rm>
    ('010001111',   (36,'blx',     rm4_shift3, 0)), # BLX<c> <Rm>
    # Load from Litera7 Pool
    ('01001',       (37,'ldr',     rt_pc_imm8, 0)), # LDR<c> <Rt>,<label>
    # Load/Stor single data item
    ('0101000',     (38,'str',     rm_rn_rt,   0)), # STR<c> <Rt>,[<Rn>,<Rm>]
    ('0101001',     (39,'strh',    rm_rn_rt,   0)), # STRH<c> <Rt>,[<Rn>,<Rm>]
    ('0101010',     (40,'strb',    rm_rn_rt,   0)), # STRB<c> <Rt>,[<Rn>,<Rm>]
    ('0101011',     (41,'ldrsb',   rm_rn_rt,   0)), # LDRSB<c> <Rt>,[<Rn>,<Rm>]
    ('0101100',     (42,'ldr',     rm_rn_rt,   0)), # LDR<c> <Rt>,[<Rn>,<Rm>]
    ('0101101',     (43,'ldrh',    rm_rn_rt,   0)), # LDRH<c> <Rt>,[<Rn>,<Rm>]
    ('0101110',     (44,'ldrb',    rm_rn_rt,   0)), # LDRB<c> <Rt>,[<Rn>,<Rm>]
    ('0101111',     (45,'ldrsh',   rm_rn_rt,   0)), # LDRSH<c> <Rt>,[<Rn>,<Rm>]
    ('01100',       (46,'str',     imm5_rn_rt, 0)), # STR<c> <Rt>, [<Rn>{,#<imm5>}]
    ('01101',       (47,'ldr',     imm5_rn_rt, 0)), # LDR<c> <Rt>, [<Rn>{,#<imm5>}]
    ('01110',       (48,'strb',    imm5_rn_rt, 0)), # STRB<c> <Rt>,[<Rn>,#<imm5>]
    ('01111',       (49,'ldrb',    imm5_rn_rt, 0)), # LDRB<c> <Rt>,[<Rn>{,#<imm5>}]
    ('10000',       (50,'strh',    imm5_rn_rt, 0)), # STRH<c> <Rt>,[<Rn>{,#<imm>}]
    ('10001',       (51,'ldrh',    imm5_rn_rt, 0)), # LDRH<c> <Rt>,[<Rn>{,#<imm>}]
    ('10010',       (52,'str',     imm5_rn_rt, 0)), # STR<c> <Rt>, [<Rn>{,#<imm>}]
    ('10011',       (53,'ldr',     imm5_rn_rt, 0)), # LDR<c> <Rt>, [<Rn>{,#<imm>}]
    # Generate PC rel54ive address
    ('10100',       (54,'add',     rd_pc_imm8, 0)), # ADD<c> <Rd>,<label>
    # Generate SP rel5tive address
    ('10101',       (55,'add',     rd_sp_imm8, 0)), # ADD<c> <Rd>,SP,#<imm>
    # Miscellaneous in6tructions
    ('10110110010', (56,'setend',  sh4_imm1,   0)), # SETEND <endian_specifier>
    ('10110110011', (57,'cps',     simpleops(),0)), # CPS<effect> <iflags> FIXME
    ('1011101000',  (58,'rev',     rn_rdm,     0)), # REV Rd, Rn
    ('1011101001',  (59,'rev16',   rn_rdm,     0)), # REV16 Rd, Rn
    ('1011101011',  (60,'revsh',   rn_rdm,     0)), # REVSH Rd, Rn
    ('101100000',   (61,'add',     sp_sp_imm7, 0)), # ADD<c> SP,SP,#<imm>
    ('101100001',   (62,'sub',     sp_sp_imm7, 0)), # SUB<c> SP,SP,#<imm>
    ('10111110',    (63,'bkpt',    imm8,       0)), # BKPT <blahblah>
    # Load / Store Mu64iple
    ('11000',       (64,'stmia',   rm_reglist, 0x800)), # LDMIA Rd!, reg_list
    ('11001',       (65,'ldmia',   rm_reglist, 0x800)), # STMIA Rd!, reg_list
    # Conditional Bran6hes
    ('11010000',    (66,'b',       imm8,       0)),
    ('11010001',    (67,'bn',      imm8,       0)),
    ('11010010',    (68,'bz',      imm8,       0)),
    ('11010011',    (69,'bnz',     imm8,       0)),
    ('11010100',    (70,'bc',      imm8,       0)),
    ('11010101',    (71,'bnc',     imm8,       0)),
    ('11010100',    (72,'bzc',     imm8,       0)),
    ('11010111',    (73,'bnzc',    imm8,       0)),
    ('11011000',    (74,'bv',      imm8,       0)),
    ('11011001',    (75,'bnv',     imm8,       0)),
    ('11011010',    (76,'bzv',     imm8,       0)),
    ('11011011',    (77,'bnzv',    imm8,       0)),
    ('11011100',    (78,'bcv',     imm8,       0)),
    ('11011101',    (79,'bncv',    imm8,       0)),
    ('11011110',    (80,'bzcv',    imm8,       0)),
    ('11011111',    (81,'bnzcv',   imm8,       0)),
    # Software Interru2t
    ('11011111',    (82,'swi',     imm8,       0)), # SWI <blahblah>
    ('11100',       (83,'b',       imm11,      0)), # B <addr11> 
    ('11101',       (84,'blx',     imm11,      0)), # BLX suffix <addr11>  -- SEE p542 of 14218.pdf manual for how this if gonna fuck with emulation. 
    ('11110',       (85,'bl',      imm11,      0)), # BL/BLX prefix <addr11> -- SEE p542 of 14218.pdf manual for how this if gonna fuck with emulation. 
    ('11111',       (86,'blx',     imm11,      0)), # BL suffix <addr11>   -- SEE p542 of 14218.pdf manual for how this if gonna fuck with emulation.
]

ttree = e_btree.BinaryTree()
for binstr, opinfo in thumb_table:
    ttree.addBinstr(binstr, opinfo)

thumb32mask = binary('11111')
thumb32min  = binary('11100')

def is_thumb32(val):
    '''
    Take a 16 bit integer (opcode) value and determine
    if it is really the first 16 bits of a 32 bit
    instruction.
    '''
    bval = val >> 11
    return (bval & thumb32mask) > thumb32min


class ThumbOpcode(ArmOpcode):
    pass

class ArmThumbDisasm:

    def disasm(self, bytes, offset, va, trackMode=True):
        val, = struct.unpack("H", bytes[offset:offset+2])
        opcode, mnem, opermkr, flags = ttree.getInstr(val)
        olist = opermkr(va, val)
        op = ThumbOpcode(va, opcode, mnem, 0xe, 2, olist, flags)
        return op


########NEW FILE########
__FILENAME__ = disasm

"""
The guts for the i386 envi opcode disassembler.
"""

import struct

import envi
import envi.bits as e_bits

import opcode86
all_tables = opcode86.tables86

# Grab our register enums etc...
from envi.archs.i386.regs import *

# Our instruction prefix masks
# NOTE: table 3-4 (section 3.6) of intel 1 shows how REX/OP_SIZE
# interact...
INSTR_PREFIX=      0x0001
PREFIX_LOCK =      0x0002
PREFIX_REPNZ=      0x0004
PREFIX_REPZ =      0x0008
PREFIX_REP  =      0x0010
PREFIX_REP_SIMD=   0x0020
PREFIX_OP_SIZE=    0x0040
PREFIX_ADDR_SIZE=  0x0080
PREFIX_SIMD=       0x0100
PREFIX_CS  =       0x0200
PREFIX_SS  =       0x0400
PREFIX_DS  =       0x0800
PREFIX_ES  =       0x1000
PREFIX_FS  =       0x2000
PREFIX_GS  =       0x4000
PREFIX_REG_MASK=   0x8000

# envi.registers meta offsets
RMETA_LOW8  = 0x00080000
RMETA_HIGH8 = 0x08080000
RMETA_LOW16 = 0x00100000

# Use a list here instead of a dict for speed (max 255 anyway)
i386_prefixes = [ None for i in range(256) ]
i386_prefixes[0xF0] = PREFIX_LOCK
i386_prefixes[0xF2] = PREFIX_REPNZ
i386_prefixes[0xF3] = PREFIX_REP
i386_prefixes[0x2E] = PREFIX_CS
i386_prefixes[0x36] = PREFIX_SS
i386_prefixes[0x3E] = PREFIX_DS
i386_prefixes[0x26] = PREFIX_ES
i386_prefixes[0x64] = PREFIX_FS
i386_prefixes[0x65] = PREFIX_GS
i386_prefixes[0x66] = PREFIX_OP_SIZE
i386_prefixes[0x67] = PREFIX_ADDR_SIZE

# The scale byte index into this for multiplier imm
scale_lookup = (1, 2, 4, 8)

# A set of instructions that are considered privileged (mark with IF_PRIV)
# FIXME this should be part of the opcdode tables!
priv_lookup = {
    "int":True,
    "in":True,
    "out":True,
    "insb":True,
    "outsb":True,
    "insd":True,
    "outsd":True,
    "vmcall":True,
    "vmlaunch":True,
    "vmresume":True,
    "vmxoff":True,
    "vmread":True,
    "vmwrite":True,
    "rsm":True,
    "lar":True,
    "lsl":True,
    "clts":True,
    "invd":True,
    "wbinvd":True,
    "wrmsr":True,
    "rdmsr":True,
    "sysexit":True,
    "lgdt":True,
    "lidt":True,
    "lmsw":True,
    "monitor":True,
    "mwait":True,
    "vmclear":True,
    "vmptrld":True,
    "vmptrst":True,
    "vmxon":True,
}

# Map of codes to their respective envi flags
iflag_lookup = {
    opcode86.INS_RET: envi.IF_NOFALL|envi.IF_RET,
    opcode86.INS_CALL: envi.IF_CALL,
    opcode86.INS_HALT: envi.IF_NOFALL,
    opcode86.INS_CALLCC: envi.IF_CALL,
    opcode86.INS_BRANCH: envi.IF_NOFALL | envi.IF_BRANCH,
    opcode86.INS_BRANCHCC: envi.IF_BRANCH,
}

sizenames = ["" for x in range(17)]
sizenames[1] = "byte"
sizenames[2] = "word"
sizenames[4] = "dword"
sizenames[8] = "qword"
sizenames[16] = "oword"

def addrToName(mcanv, va):
    sym = mcanv.syms.getSymByAddr(va)
    if sym != None:
        return repr(sym)
    return "0x%.8x" % va

###########################################################################
#
# Operand objects for the i386 architecture
#


class i386RegOper(envi.RegisterOper):

    def __init__(self, reg, tsize):
        self.reg = reg
        self.tsize = tsize

    def repr(self, op):
        return self._dis_regctx.getRegisterName(self.reg)

    def getOperValue(self, op, emu=None):
        if emu == None: return None # This operand type requires an emulator
        return emu.getRegister(self.reg)

    def setOperValue(self, op, emu, value):
        emu.setRegister(self.reg, value)

    def render(self, mcanv, op, idx):
        hint = mcanv.syms.getSymHint(op.va, idx)
        if hint != None:
            mcanv.addNameText(name, typename="registers")
        else:
            name = self._dis_regctx.getRegisterName(self.reg)
            mcanv.addNameText(name, typename="registers")

    def __eq__(self, other):
        if not isinstance(other, i386RegOper):
            return False
        if other.reg != self.reg:
            return False
        if other.tsize != self.tsize:
            return False
        return True

class i386ImmOper(envi.ImmedOper):
    """
    An operand representing an immediate.
    """
    def __init__(self, imm, tsize):
        self.imm = imm
        self.tsize = tsize

    def repr(self, op):
        ival = self.imm
        if ival > 4096:
            return "0x%.8x" % ival
        return str(ival)

    def getOperValue(self, op, emu=None):
        return self.imm

    def render(self, mcanv, op, idx):
        value = self.imm
        hint = mcanv.syms.getSymHint(op.va, idx)
        if hint != None:
            if mcanv.mem.isValidPointer(value):
                mcanv.addVaText(hint, value)
            else:
                mcanv.addNameText(hint)
        elif mcanv.mem.isValidPointer(value):
            name = addrToName(mcanv, value)
            mcanv.addVaText(name, value)
        else:
            if self.imm >= 4096:
                mcanv.addNameText('0x%.8x' % value)
            else:
                mcanv.addNameText(str(value))

    def __eq__(self, other):
        if not isinstance(other, i386ImmOper):
            return False
        if other.imm != self.imm:
            return False
        if other.tsize != self.tsize:
            return False
        return True

class i386PcRelOper(envi.Operand):
    """
    This is the operand used for EIP relative offsets
    for operands on instructions like jmp/call
    """
    def __init__(self, imm, tsize):
        self.imm = imm
        self.tsize = tsize

    def repr(self, op):
        return "0x%.8x" % (op.va + op.size + self.imm)

    def isImmed(self):
        return True # FIXME trying this out....

    def getOperValue(self, op, emu=None):
        return op.va + op.size + self.imm

    def render(self, mcanv, op, idx):
        hint = mcanv.syms.getSymHint(op.va, idx)
        if hint != None:
            mcanv.addVaText(hint, value)
        else:
            value = op.va + op.size + self.imm
            name = addrToName(mcanv, value)
            mcanv.addVaText(name, value)

    def __eq__(self, other):
        if not isinstance(other, i386PcRelOper):
            return False
        if other.imm != self.imm:
            return False
        if other.tsize != self.tsize:
            return False
        return True

class i386RegMemOper(envi.DerefOper):
    """
    An operand which represents the result of reading/writting memory from the
    dereference (with possible displacement) from a given register.
    """
    def __init__(self, reg, tsize, disp=0):
        self.reg = reg
        self.tsize = tsize
        self.disp = disp
        self._is_deref = True

    def repr(self, op):
        r = self._dis_regctx.getRegisterName(self.reg)
        if self.disp > 0:
            return "%s [%s + %d]" % (sizenames[self.tsize],r,self.disp)
        elif self.disp < 0:
            return "%s [%s - %d]" % (sizenames[self.tsize],r,abs(self.disp))
        return "%s [%s]" % (sizenames[self.tsize],r)

    def getOperValue(self, op, emu=None):
        if emu == None: return None # This operand type requires an emulator
        return emu.readMemValue(self.getOperAddr(op, emu), self.tsize)

    def setOperValue(self, op, emu, val):
        emu.writeMemValue(self.getOperAddr(op, emu), val, self.tsize)

    def getOperAddr(self, op, emu):
        if emu == None: return None # This operand type requires an emulator
        base, size = emu.getSegmentInfo(op)
        rval = emu.getRegister(self.reg)
        return base + rval + self.disp

    def isDeref(self):
        # The disassembler may reach in and set this (if lea...)
        return self._is_deref

    def render(self, mcanv, op, idx):
        mcanv.addNameText(sizenames[self.tsize])
        mcanv.addText(" [")
        mcanv.addNameText(self._dis_regctx.getRegisterName(self.reg), typename="registers")
        hint = mcanv.syms.getSymHint(op.va, idx)
        if hint != None:
            mcanv.addText(" + ")
            mcanv.addNameText(hint)

        else:
            if self.disp > 0:
                mcanv.addText(" + ")
                mcanv.addNameText(str(self.disp))
            elif self.disp < 0:
                mcanv.addText(" - ")
                mcanv.addNameText(str(abs(self.disp)))
        mcanv.addText("]")

    def __eq__(self, other):
        if not isinstance(other, i386RegMemOper):
            return False
        if other.reg != self.reg:
            return False
        if other.disp != self.disp:
            return False
        if other.tsize != self.tsize:
            return False
        return True

class i386ImmMemOper(envi.DerefOper):
    """
    An operand which represents the dereference (memory read/write) of
    a memory location associated with an immediate.
    """
    def __init__(self, imm, tsize):
        self.imm = imm
        self.tsize = tsize

    def repr(self, op):
        return "%s [0x%.8x]" % (sizenames[self.tsize], self.imm)

    def getOperValue(self, op, emu=None):
        if emu == None: return None # This operand type requires an emulator
        return emu.readMemValue(self.getOperAddr(op, emu), self.tsize)

    def setOperValue(self, op, emu, val):
        emu.writeMemValue(self.getOperAddr(op, emu), val, self.tsize)

    def getOperAddr(self, op, emu=None):
        ret = self.imm
        if emu != None:
            base, size = emu.getSegmentInfo(op)
            ret += base
        return ret

    def render(self, mcanv, op, idx):
        mcanv.addNameText(sizenames[self.tsize])
        mcanv.addText(" [")
        value = self.imm

        hint = mcanv.syms.getSymHint(op.va, idx)
        if hint != None:
            mcanv.addVaText(hint, value)
        else:
            name = addrToName(mcanv, value)
            mcanv.addVaText(name, value)

        mcanv.addText("]")

    def __eq__(self, other):
        if not isinstance(other, i386ImmMemOper):
            return False
        if other.imm != self.imm:
            return False
        if other.tsize != self.tsize:
            return False
        return True

class i386SibOper(envi.DerefOper):
    """
    An operand which represents the result of reading/writting memory from the
    dereference (with possible displacement) from a given register.
    """
    def __init__(self, tsize, reg=None, imm=None, index=None, scale=1, disp=0):
        self.reg = reg
        self.imm = imm
        self.index = index
        self.scale = scale
        self.tsize = tsize
        self.disp = disp
        self._is_deref = True

    def __eq__(self, other):
        if not isinstance(other, i386SibOper):
            return False
        if other.imm != self.imm:
            return False
        if other.reg != self.reg:
            return False
        if other.index != self.index:
            return False
        if other.scale != self.scale:
            return False
        if other.disp != self.disp:
            return False
        if other.tsize != self.tsize:
            return False
        return True

    def isDeref(self):
        return self._is_deref

    def repr(self, op):

        r = "%s [" % sizenames[self.tsize]

        if self.reg != None:
            r += self._dis_regctx.getRegisterName(self.reg)

        if self.imm != None:
            r += "0x%.8x" % self.imm

        if self.index != None:
            r += " + %s" % self._dis_regctx.getRegisterName(self.index)
            if self.scale != 1:
                r += " * %d" % self.scale

        if self.disp > 0:
            r += " + %d" % self.disp
        elif self.disp < 0:
            r += " - %d" % abs(self.disp)

        r += "]"

        return r

    def getOperValue(self, op, emu=None):
        if emu == None: return None # This operand type requires an emulator
        return emu.readMemValue(self.getOperAddr(op, emu), self.tsize)

    def setOperValue(self, op, emu, val):
        emu.writeMemValue(self.getOperAddr(op, emu), val, self.tsize)

    def getOperAddr(self, op, emu=None):
        if emu == None: return None # This operand type requires an emulator

        ret = 0

        if self.imm != None:
            ret += self.imm

        if self.reg != None:
            ret += emu.getRegister(self.reg)

        if self.index != None:
            ret += (emu.getRegister(self.index) * self.scale)

        # Handle x86 segmentation
        base, size = emu.getSegmentInfo(op)
        ret += base

        return ret + self.disp

    def _getOperBase(self, emu=None):
        # Special SIB only method for getting the SIB base value
        if self.imm:
            return self.imm
        if emu:
            return emu.getRegister(self.reg)
        return None

    def render(self, mcanv, op, idx):

        mcanv.addNameText(sizenames[self.tsize])
        mcanv.addText(" [")
        if self.imm != None:
            name = addrToName(mcanv, self.imm)
            mcanv.addVaText(name, self.imm)

        if self.reg != None:
            name = self._dis_regctx.getRegisterName(self.reg)
            mcanv.addNameText(name, typename="registers")

        # Does our SIB have a scale
        if self.index != None:
            mcanv.addText(" + ")
            name = self._dis_regctx.getRegisterName(self.index)
            mcanv.addNameText(name, typename="registers")
            if self.scale != 1:
                mcanv.addText(" * ")
                mcanv.addNameText(str(self.scale))

        hint = mcanv.syms.getSymHint(op.va, idx)
        if hint != None:
            mcanv.addText(" + ")
            mcanv.addNameText(hint)

        else:
            # If we have a displacement, add it.
            if self.disp != 0:
                mcanv.addText(" + ")
                mcanv.addNameText(str(self.disp))

        mcanv.addText("]")

class i386Opcode(envi.Opcode):

    # Printable prefix names
    prefix_names = [
        (PREFIX_LOCK, "lock"),
        (PREFIX_REPNZ, "repnz"),
        (PREFIX_REP, "rep"),
        (PREFIX_CS, "cs"),
        (PREFIX_SS, "ss"),
        (PREFIX_DS, "ds"),
        (PREFIX_ES, "es"),
        (PREFIX_FS, "fs"),
        (PREFIX_GS, "gs"),
    ]


    def getBranches(self, emu=None):
        ret = []

        # To start with we have no flags.
        flags = 0
        addb = False

        # If we are a conditional branch, even our fallthrough
        # case is conditional...
        if self.opcode == opcode86.INS_BRANCHCC:
            flags |= envi.BR_COND
            addb = True

        # If we can fall through, reflect that...
        if not self.iflags & envi.IF_NOFALL:
            ret.append((self.va + self.size, flags|envi.BR_FALL))

        # In intel, if we have no operands, it has no
        # further branches...
        if len(self.opers) == 0:
            return ret

        # Check for a call...
        if self.opcode == opcode86.INS_CALL:
            flags |= envi.BR_PROC
            addb = True

        # A conditional call?  really?  what compiler did you use? ;)
        elif self.opcode == opcode86.INS_CALLCC:
            flags |= (envi.BR_PROC | envi.BR_COND)
            addb = True

        elif self.opcode == opcode86.INS_BRANCH:
            oper0 = self.opers[0]
            if isinstance(oper0, i386SibOper) and oper0.scale == 4:
                # In the case with no emulator, note that our deref is
                # from the base of a table. If we have one, parse out all the
                # valid pointers from our base
                base = oper0._getOperBase(emu)
                if emu == None:
                    ret.append((base, flags | envi.BR_DEREF | envi.BR_TABLE))

                else:
                    # Since we're parsing this out, lets just resolve the derefs
                    # for our caller...
                    dest = emu.readMemValue(base, oper0.tsize)
                    while emu.isValidPointer(dest):
                        ret.append((dest, envi.BR_COND))
                        base += oper0.tsize
                        dest = emu.readMemValue(base, oper0.tsize)
            else:
                addb = True

        if addb:
            oper0 = self.opers[0]
            if oper0.isDeref():
                flags |= envi.BR_DEREF
                tova = oper0.getOperAddr(self, emu=emu)
            else:
                tova = oper0.getOperValue(self, emu=emu)

            ret.append((tova, flags))

        return ret

    def render(self, mcanv):
        """
        Render this opcode to the specified memory canvas
        """
        if self.prefixes:
            pfx = self.getPrefixName()
            if pfx:
                mcanv.addNameText("%s: " % pfx, pfx)

        mcanv.addNameText(self.mnem, typename="mnemonic")
        mcanv.addText(" ")

        # Allow each of our operands to render
        imax = len(self.opers)
        lasti = imax - 1
        for i in xrange(imax):
            oper = self.opers[i]
            oper.render(mcanv, self, i)
            if i != lasti:
                mcanv.addText(",")

operand_range = (2,3,4)

MODE_16 = 0
MODE_32 = 1
MODE_64 = 2

class i386Disasm:

    def __init__(self, mode=MODE_32):
        self._dis_mode = MODE_32
        self._dis_prefixes = i386_prefixes
        self._dis_regctx = i386RegisterContext()

        # This will make function lookups nice and quick
        self._dis_amethods = [ None for x in range(22) ]
        self._dis_amethods[opcode86.ADDRMETH_A>>16] = self.ameth_a
        self._dis_amethods[opcode86.ADDRMETH_C>>16] = self.ameth_c
        self._dis_amethods[opcode86.ADDRMETH_D>>16] = self.ameth_d
        self._dis_amethods[opcode86.ADDRMETH_E>>16] = self.ameth_e
        self._dis_amethods[opcode86.ADDRMETH_M>>16] = self.ameth_e
        self._dis_amethods[opcode86.ADDRMETH_N>>16] = self.ameth_n
        self._dis_amethods[opcode86.ADDRMETH_Q>>16] = self.ameth_q
        self._dis_amethods[opcode86.ADDRMETH_R>>16] = self.ameth_e
        self._dis_amethods[opcode86.ADDRMETH_W>>16] = self.ameth_w
        self._dis_amethods[opcode86.ADDRMETH_I>>16] = self.ameth_i
        self._dis_amethods[opcode86.ADDRMETH_J>>16] = self.ameth_j
        self._dis_amethods[opcode86.ADDRMETH_O>>16] = self.ameth_o
        self._dis_amethods[opcode86.ADDRMETH_G>>16] = self.ameth_g
        self._dis_amethods[opcode86.ADDRMETH_P>>16] = self.ameth_p
        self._dis_amethods[opcode86.ADDRMETH_S>>16] = self.ameth_s
        self._dis_amethods[opcode86.ADDRMETH_U>>16] = self.ameth_u
        self._dis_amethods[opcode86.ADDRMETH_V>>16] = self.ameth_v
        self._dis_amethods[opcode86.ADDRMETH_X>>16] = self.ameth_x
        self._dis_amethods[opcode86.ADDRMETH_Y>>16] = self.ameth_y

        # Offsets used to add in addressing method parsers
        self.ROFFSETMMX   = getRegOffset(i386regs, "mm0")
        self.ROFFSETSIMD  = getRegOffset(i386regs, "xmm0")
        self.ROFFSETDEBUG = getRegOffset(i386regs, "debug0")
        self.ROFFSETCTRL  = getRegOffset(i386regs, "ctrl0")
        self.ROFFSETTEST  = getRegOffset(i386regs, "test0")
        self.ROFFSETSEG   = getRegOffset(i386regs, "es")
        self.ROFFSETFPU   = getRegOffset(i386regs, "st0")

    def parse_modrm(self, byte):
        # Pass in a string with an offset for speed rather than a new string
        mod = (byte >> 6) & 0x3
        reg = (byte >> 3) & 0x7
        rm = byte & 0x7
        #print "MOD/RM",hex(byte),mod,reg,rm
        return (mod,reg,rm)

    def byteRegOffset(self, val):
        # NOTE: This is used for high byte metas in 32 bit mode only
        if val < 4:
            return val + RMETA_LOW8
        return (val-4) + RMETA_HIGH8

    # Parse modrm as though addr mode might not be just a reg
    def extended_parse_modrm(self, bytes, offset, opersize, regbase=0):
        """
        Return a tuple of (size, Operand)
        """

        mod,reg,rm = self.parse_modrm(ord(bytes[offset]))

        size = 1

        #print "EXTENDED MOD REG RM",mod,reg,rm

        if mod == 3: # Easy one, just a reg
            # FIXME only use self.byteRegOffset in 32 bit mode, NOT 64 bit...
            if opersize == 1: rm = self.byteRegOffset(rm)
            elif opersize == 2: rm += RMETA_LOW16
            #print "OPERSIZE",opersize,rm
            return (size, i386RegOper(rm+regbase, opersize))

        elif mod == 0:
            # means we are [reg] unless rm == 4 (SIB) or rm == 5 ([imm32])
            if rm == 5:
                imm = e_bits.parsebytes(bytes, offset + size, 4)
                size += 4
                # NOTE: in 64 bit mode, *this* is where we differ, (This case is RIP relative)
                return(size, i386ImmMemOper(imm, opersize))

            elif rm == 4:
                sibsize, scale, index, base, imm = self.parse_sib(bytes, offset+size, mod)
                size += sibsize
                if base != None: base += regbase    # Adjust for different register addressing modes
                if index != None: index += regbase    # Adjust for different register addressing modes
                oper = i386SibOper(opersize, reg=base, imm=imm, index=index, scale=scale_lookup[scale])
                return (size, oper)

            else:
                return(size, i386RegMemOper(regbase+rm, opersize))

        elif mod == 1:
            # mod 1 means we are [ reg + disp8 ] (unless rm == 4 which means sib + disp8)
            if rm == 4:
                sibsize, scale, index, base, imm = self.parse_sib(bytes, offset+size, mod)
                size += sibsize
                disp = e_bits.parsebytes(bytes, offset+size, 1, sign=True)
                size += 1
                if base != None: base += regbase    # Adjust for different register addressing modes
                if index != None: index += regbase    # Adjust for different register addressing modes
                oper = i386SibOper(opersize, reg=base, index=index, scale=scale_lookup[scale], disp=disp)
                return (size,oper)
            else:
                x = e_bits.signed(ord(bytes[offset+size]), 1)
                size += 1
                return(size, i386RegMemOper(regbase+rm, opersize, disp=x))

        elif mod == 2:
            # Means we are [ reg + disp32 ] (unless rm == 4  which means SIB + disp32)
            if rm == 4:
                sibsize, scale, index, base, imm = self.parse_sib(bytes,offset+size,mod)
                size += sibsize
                disp = e_bits.parsebytes(bytes, offset + size, 4, sign=True)
                size += 4
                if base != None: base += regbase    # Adjust for different register addressing modes
                if index != None: index += regbase    # Adjust for different register addressing modes
                oper = i386SibOper(opersize, reg=base, imm=imm, index=index, scale=scale_lookup[scale], disp=disp)
                return (size, oper)

            else:
                # NOTE: Immediate displacements in SIB are still 4 bytes in 64 bit mode
                disp = e_bits.parsebytes(bytes, offset+size, 4, sign=True)
                size += 4
                return(size, i386RegMemOper(regbase+rm, opersize, disp=disp))

        else:
            raise Exception("How does mod == %d" % mod)

    def parse_sib(self, bytes, offset, mod):
        """
        Return a tuple of (size, scale, index, base, imm)
        """
        byte = ord(bytes[offset])
        scale = (byte >> 6) & 0x3
        index = (byte >> 3) & 0x7
        base  = byte & 0x7
        imm = None

        size = 1

        # Special SIB case with no index reg
        if index == 4:
            index = None

        # Special SIB case with possible immediate
        if base == 5:
            if mod == 0: # [ imm32 + index * scale ]
                base = None
                imm = e_bits.parsebytes(bytes, offset+size, 4, sign=False)
                size += 4
            # FIXME is there special stuff needed here?
            elif mod == 1:
                pass
                #raise "OMG MOD 1"
            elif mod == 2:
                pass
                #raise "OMG MOD 2"

        return (size, scale, index, base, imm)


    def _dis_calc_tsize(self, opertype, prefixes):
        """
        Use the oper type and prefixes to decide on the tsize for
        the operand.
        """
        mode = MODE_32

        #print "OPERTYPE",hex(opertype)
        sizelist = opcode86.OPERSIZE.get(opertype, None)
        if sizelist == None:
            raise "OPERSIZE FAIL: %.8x" % opertype

        if prefixes & PREFIX_OP_SIZE:

            mode = MODE_16

        #print "OPERTYPE",hex(opertype)
        #print "SIZELIST",repr(sizelist)
        return sizelist[mode]

    def disasm(self, bytes, offset, va):

        # Stuff for opcode parsing
        tabdesc = all_tables[0] # A tuple (optable, shiftbits, mask byte, sub, max)
        startoff = offset # Use startoff as a size knob if needed

        # Stuff we'll be putting in the opcode object
        optype = None # This gets set if we successfully decode below
        mnem = None 
        operands = []

        prefixes = 0

        while True:

            obyte = ord(bytes[offset])

            # This line changes in 64 bit mode
            p = self._dis_prefixes[obyte]
            if p == None:
                break
            if obyte == 0x66 and ord(bytes[offset+1]) == 0x0f:
                break
            prefixes |= p
            offset += 1
            continue

        #pdone = False
        while True:

            obyte = ord(bytes[offset])

            #print "OBYTE",hex(obyte)
            if (obyte > tabdesc[4]):
                #print "Jumping To Overflow Table:", tabdesc[5]
                tabdesc = all_tables[tabdesc[5]]

            tabidx = ((obyte - tabdesc[3]) >> tabdesc[1]) & tabdesc[2]
            #print "TABIDX: %d" % tabidx
            opdesc = tabdesc[0][tabidx]
            #print 'OPDESC: %s' % repr(opdesc)

            # Hunt down multi-byte opcodes
            nexttable = opdesc[0]
            #print "NEXT",nexttable,hex(obyte)
            if nexttable != 0: # If we have a sub-table specified, use it.
                #print "Multi-Byte Next Hop For",hex(obyte),opdesc[0]
                tabdesc = all_tables[nexttable]

                # In the case of 66 0f, the next table is *already* assuming we ate
                # the 66 *and* the 0f...  oblidge them.
                if obyte == 0x66 and ord(bytes[offset+1]) == 0x0f:
                    offset += 1

                # Account for the table jump we made
                offset += 1

                continue

            # We are now on the final table...
            #print repr(opdesc)
            mnem = opdesc[6]
            optype = opdesc[1]
            if tabdesc[2] == 0xff:
                offset += 1 # For our final opcode byte
            break

        if optype == 0:
            #print tabidx
            #print opdesc
            #print "OPTTYPE 0"
            raise envi.InvalidInstruction(bytes=bytes[startoff:startoff+16])

        operoffset = 0
        # Begin parsing operands based off address method
        for i in operand_range:

            oper = None # Set this if we end up with an operand
            osize = 0

            # Pull out the operand description from the table
            operflags = opdesc[i]
            opertype = operflags & opcode86.OPTYPE_MASK
            addrmeth = operflags & opcode86.ADDRMETH_MASK

            # If there are no more operands, break out of the loop!
            if operflags == 0:
                break

            #print "ADDRTYPE: %.8x OPERTYPE: %.8x" % (addrmeth, opertype)

            tsize = self._dis_calc_tsize(opertype, prefixes)

            #print hex(opertype),hex(addrmeth)


            # If addrmeth is zero, we have operands embedded in the opcode
            if addrmeth == 0:
                osize = 0
                oper = self.ameth_0(operflags, opdesc[5+i], tsize, prefixes)

            else:
                #print "ADDRTYPE",hex(addrmeth)
                ameth = self._dis_amethods[addrmeth >> 16]
                #print "AMETH",ameth
                if ameth == None:
                    raise Exception("Implement Addressing Method 0x%.8x" % addrmeth)

                # NOTE: Depending on your addrmethod you may get beginning of operands, or offset
                try:
                    if addrmeth == opcode86.ADDRMETH_I or addrmeth == opcode86.ADDRMETH_J:
                        osize, oper = ameth(bytes, offset+operoffset, tsize, prefixes)

                        # If we are a sign extended immediate and not the same as the other operand,
                        # do the sign extension during disassembly so nothing else has to worry about it..
                        if operflags & opcode86.OP_SIGNED and len(operands) and tsize != operands[-1].tsize:
                            otsize = operands[-1].tsize
                            oper.imm = e_bits.sign_extend(oper.imm, oper.tsize, otsize)
                            oper.tsize = otsize

                    else:
                        osize, oper = ameth(bytes, offset, tsize, prefixes)

                except struct.error, e:
                    # Catch struct unpack errors due to insufficient data length
                    raise envi.InvalidInstruction(bytes=bytes[startoff:startoff+16])

            if oper != None:
                # This is a filty hack for now...
                oper._dis_regctx = self._dis_regctx
                operands.append(oper)
            operoffset += osize

        # Pull in the envi generic instruction flags
        iflags = iflag_lookup.get(optype, 0)

        if priv_lookup.get(mnem, False):
            iflags |= envi.IF_PRIV

        # Lea will have a reg-mem/sib operand with _is_deref True, but should be false
        if optype == opcode86.INS_LEA:
            operands[1]._is_deref = False

        ret = i386Opcode(va, optype, mnem, prefixes, (offset-startoff)+operoffset, operands, iflags)

        return ret

    # Declare all the address method parsers here!

    def ameth_0(self, operflags, operval, tsize, prefixes):
        # Special address method for opcodes with embedded operands
        if operflags & opcode86.OP_REG:
            return i386RegOper(operval, tsize)
        elif operflags & opcode86.OP_IMM:
            return i386ImmOper(operval, tsize)
        raise Exception("Unknown ameth_0! operflags: 0x%.8x" % operflags)

    def ameth_a(self, bytes, offset, tsize, prefixes):
        imm = e_bits.parsebytes(bytes, offset, tsize)
        seg = e_bits.parsebytes(bytes, offset+tsize, 2)
        # THIS BEING GHETTORIGGED ONLY EFFECTS callf jmpf
        #print "FIXME: envi.intel.ameth_a skipping seg prefix %d" % seg
        return (tsize+2, i386ImmOper(imm, tsize))

    def ameth_e(self, bytes, offset, tsize, prefixes):
        return self.extended_parse_modrm(bytes, offset, tsize)

    def ameth_n(self, bytes, offset, tsize, prefixes):
        mod,reg,rm = self.parse_modrm(ord(bytes[offset]))
        return (1, i386RegOper(rm + self.ROFFSETMMX, tsize))

    def ameth_q(self, bytes, offset, tsize, prefixes):
        mod,reg,rm = self.parse_modrm(ord(bytes[offset]))
        if mod == 3:
            return (1, i386RegOper(rm + self.ROFFSETMMX, tsize))
        return self.extended_parse_modrm(bytes, offset, tsize)

    def ameth_w(self, bytes, offset, tsize, prefixes):
        mod,reg,rm = self.parse_modrm(ord(bytes[offset]))
        if mod == 3:
            return (1, i386RegOper(rm + self.ROFFSETSIMD, tsize))
        return self.extended_parse_modrm(bytes, offset, tsize)

    def ameth_i(self, bytes, offset, tsize, prefixes):
        # FIXME sign extend here if opflags has OP_SIGNED
        imm = e_bits.parsebytes(bytes, offset, tsize)
        return (tsize, i386ImmOper(imm, tsize))

    def ameth_j(self, bytes, offset, tsize, prefixes):
        imm = e_bits.parsebytes(bytes, offset, tsize, sign=True)
        return (tsize, i386PcRelOper(imm, tsize))

    def ameth_o(self, bytes, offset, tsize, prefixes):
        # NOTE: displacement *stays* 32 bit even with REX
        # (but 16 bit should probably be supported)
        imm = e_bits.parsebytes(bytes, offset, 4, sign=False)
        return (4, i386ImmMemOper(imm, tsize))

    def ameth_g(self, bytes, offset, tsize, prefixes):
        mod,reg,rm = self.parse_modrm(ord(bytes[offset]))
        if tsize == 1: reg = self.byteRegOffset(reg)
        elif tsize == 2: reg += RMETA_LOW16
        return (0, i386RegOper(reg, tsize))

    def ameth_c(self, bytes, offset, tsize, prefixes):
        mod,reg,rm = self.parse_modrm(ord(bytes[offset]))
        return (0, i386RegOper(reg+self.ROFFSETCTRL, tsize))

    def ameth_d(self, bytes, offset, tsize, prefixes):
        mod,reg,rm = self.parse_modrm(ord(bytes[offset]))
        return (0, i386RegOper(reg+self.ROFFSETDEBUG, tsize))

    def ameth_p(self, bytes, offset, tsize, prefixes):
        mod,reg,rm = self.parse_modrm(ord(bytes[offset]))
        return (0, i386RegOper(reg+self.ROFFSETMMX, tsize))

    def ameth_s(self, bytes, offset, tsize, prefixes):
        mod,reg,rm = self.parse_modrm(ord(bytes[offset]))
        return (0, i386RegOper(reg+self.ROFFSETSEG, tsize))

    def ameth_u(self, bytes, offset, tsize, prefixes):
        mod,reg,rm = self.parse_modrm(ord(bytes[offset]))
        return (0, i386RegOper(reg+self.ROFFSETTEST, tsize))

    def ameth_v(self, bytes, offset, tsize, prefixes):
        mod,reg,rm = self.parse_modrm(ord(bytes[offset]))
        return (0, i386RegOper(reg+self.ROFFSETSIMD, tsize))

    def ameth_x(self, bytes, offset, tsize, prefixes):
        #FIXME this needs the DS over-ride, but is only for outsb which we don't support
        return (0, i386RegMemOper(REG_ESI, tsize))

    def ameth_y(self, bytes, offset, tsize, prefixes):
        #FIXME this needs the ES over-ride, but is only for insb which we don't support
        return (0, i386RegMemOper(REG_ESI, tsize))


if __name__ == '__main__':

    # A little helper to make testing easier

    import sys
    d = i386Disasm()
    b = file(sys.argv[1], 'rb').read()
    offset = 0
    va = 0x41414141
    while offset < len(b):
        op = d.disasm(b, offset, va+offset)
        print '0x%.8x %s %s' % (va+offset, b[offset:offset+len(op)].encode('hex').ljust(16), repr(op))
        offset += len(op)


########NEW FILE########
__FILENAME__ = emu
"""
Home for the i386 emulation code.
"""
import envi
import envi.bits as e_bits
import envi.memory as e_mem

from envi.archs.i386.regs import *
from envi.archs.i386.disasm import *
from envi.archs.i386 import i386Module

def shiftMask(val, size):
    if size == 1:
        return (val & 0x1f) % 9
    elif size == 2:
        return (val & 0x1f) % 17
    elif size == 4:
        return val & 0x1f
    elif size == 8:
        return val & 0x3f
    else:
        raise Exception("shiftMask is broke in envi/intel.py")

# The indexes for the list of segments in the emulator
SEG_CS = 0
SEG_DS = 1
SEG_ES = 2
SEG_FS = 3
SEG_GS = 4
SEG_SS = 5

# The general purpose register indexes
# (for use in _emu_setGpReg / _emu_getGpReg)
# NOTE: These *must* stay in sync with i386regs first row.
GPR_A  = 0
GPR_C  = 1
GPR_D  = 2
GPR_B  = 3
GPR_SP = 4
GPR_BP = 5
GPR_SI = 6
GPR_DI = 7

class IntelEmulator(i386Module, i386RegisterContext, envi.Emulator):

    def __init__(self):
        # Set ourself up as an arch module *and* register context
        i386Module.__init__(self)

        seglist = [ (0,0xffffffff) for i in range(6) ]
        envi.Emulator.__init__(self, segs=seglist)

        i386RegisterContext.__init__(self)

    def getSegmentIndex(self, op):
        # FIXME this needs to account for push/pop/etc
        if op.prefixes == 0:
            return SEG_DS
        if op.prefixes & PREFIX_ES:
            return SEG_ES
        elif op.prefixes & PREFIX_CS:
            return SEG_CS
        elif op.prefixes & PREFIX_SS:
            return SEG_SS
        elif op.prefixes & PREFIX_DS:
            return SEG_DS
        elif op.prefixes & PREFIX_FS:
            return SEG_FS
        elif op.prefixes & PREFIX_GS:
            return SEG_GS
        return SEG_DS

    def undefFlags(self):
        """
        Used in PDE.
        A flag setting operation has resulted in un-defined value.  Set
        the flags to un-defined as well.
        """
        self.setRegister(REG_EFLAGS, None)

    def setFlag(self, which, state):
        flags = self.getRegister(REG_EFLAGS)
        if state:
            flags |= which
        else:
            flags &= ~which
        self.setRegister(REG_EFLAGS, flags)

    def getFlag(self, which):
        flags = self.getRegister(REG_EFLAGS)
        if flags == None:
            raise envi.PDEUndefinedFlag(self)
        return bool(flags & which)

    def readMemValue(self, addr, size):
        bytes = self.readMemory(addr, size)
        if bytes == None:
            return None
        #FIXME change this (and all uses of it) to passing in format...
        if len(bytes) != size:
            raise Exception("Read Gave Wrong Length At 0x%.8x (va: 0x%.8x wanted %d got %d)" % (self.getProgramCounter(),addr, size, len(bytes)))
        if size == 1:
            return struct.unpack("B", bytes)[0]
        elif size == 2:
            return struct.unpack("<H", bytes)[0]
        elif size == 4:
            return struct.unpack("<L", bytes)[0]
        elif size == 8:
            return struct.unpack("<Q", bytes)[0]

    def writeMemValue(self, addr, value, size):
        #FIXME change this (and all uses of it) to passing in format...
        if size == 1:
            bytes = struct.pack("B",value & 0xff)
        elif size == 2:
            bytes = struct.pack("<H",value & 0xffff)
        elif size == 4:
            bytes = struct.pack("<L", value & 0xffffffff)
        elif size == 8:
            bytes = struct.pack("<Q", value & 0xffffffffffffffff)
        self.writeMemory(addr, bytes)

    def readMemSignedValue(self, addr, size):
        bytes = self.readMemory(addr, size)
        if bytes == None:
            return None
        if size == 1:
            return struct.unpack("b", bytes)[0]
        elif size == 2:
            return struct.unpack("<h", bytes)[0]
        elif size == 4:
            return struct.unpack("<l", bytes)[0]

    def executeOpcode(self, op):
        # NOTE: If an opcode method returns
        #       other than None, that is the new eip
        meth = self.op_methods.get(op.mnem, None)
        if meth == None:
            raise envi.UnsupportedInstruction(self, op)
        if op.prefixes & PREFIX_REP:
            x = self.doRepPrefix(meth, op)
        else:
            x = meth(op)
        if x == None:
            pc = self.getProgramCounter()
            x = pc+op.size

        self.setProgramCounter(x)

    ###### Conditional Callbacks #####

    # NOTE: for ease of validation, these are in the same order as the Jcc
    # page in the intel manual.  However, duplicate conditions (be/na) are
    # reduced to their earliest (in the manual) form.

    def cond_a(self):
        return self.getFlag(EFLAGS_CF) == 0 and self.getFlag(EFLAGS_ZF) == 0

    def cond_ae(self):
        return self.getFlag(EFLAGS_CF) == 0

    def cond_b(self):
        return self.getFlag(EFLAGS_CF) == 1

    def cond_be(self):
        return self.getFlag(EFLAGS_CF) == 1 or self.getFlag(EFLAGS_ZF) == 1

    def cond_c(self):
        return self.getFlag(EFLAGS_CF) == 1

    def cond_ecxz(self):
        return self.getRegister(REG_ECX) == 0

    def cond_e(self):
        return self.getFlag(EFLAGS_ZF) == 1

    def cond_g(self):
        return self.getFlag(EFLAGS_ZF) == 0 and (self.getFlag(EFLAGS_SF) == self.getFlag(EFLAGS_OF))

    def cond_ge(self):
        return self.getFlag(EFLAGS_SF) == self.getFlag(EFLAGS_OF)

    def cond_l(self):
        return self.getFlag(EFLAGS_SF) != self.getFlag(EFLAGS_OF)

    def cond_le(self):
        return (self.getFlag(EFLAGS_SF) != self.getFlag(EFLAGS_OF) or
                (self.getFlag(EFLAGS_ZF) == 1))

    # Some duplicates
    cond_na = cond_be
    cond_nae = cond_b
    cond_nb = cond_ae
    cond_nbe = cond_a
    cond_nc = cond_ae

    def cond_ne(self):
        return self.getFlag(EFLAGS_ZF) == 0

    # A few more
    cond_ng = cond_le
    cond_nge = cond_l
    cond_nl = cond_ge
    cond_nle = cond_g

    def cond_no(self):
        return self.getFlag(EFLAGS_OF) == 0

    def cond_np(self):
        return self.getFlag(EFLAGS_PF) == 0

    def cond_ns(self):
        return self.getFlag(EFLAGS_SF) == 0

    cond_nz = cond_ne

    def cond_o(self):
        return self.getFlag(EFLAGS_OF) == 1

    def cond_p(self):
        return self.getFlag(EFLAGS_PF) == 1

    cond_pe = cond_p
    cond_po = cond_np

    def cond_s(self):
        return self.getFlag(EFLAGS_SF) == 1

    cond_z = cond_e

    # FROM OTHER INSTRUCTIONS
    cond_nc = cond_ae
    cond_nl = cond_ge

    ###### End Conditional Callbacks #####

    def doPush(self, val):
        esp = self.getRegister(REG_ESP)
        esp -= 4
        self.writeMemValue(esp, val, 4)
        self.setRegister(REG_ESP, esp)

    def doPop(self):
        esp = self.getRegister(REG_ESP)
        val = self.readMemValue(esp, 4)
        self.setRegister(REG_ESP, esp+4)
        return val

    def integerSubtraction(self, op):
        """
        Do the core of integer subtraction but only *return* the
        resulting value rather than assigning it.
        (allows cmp and sub to use the same code)
        """
        # Src op gets sign extended to dst
        #FIXME account for same operand with zero result for PDE
        dst = self.getOperValue(op, 0)
        src = self.getOperValue(op, 1)

        if src == None or dst == None:
            self.undefFlags()
            return None

        # So we can either do a BUNCH of crazyness with xor and shifting to
        # get the necissary flags here, *or* we can just do both a signed and
        # unsigned sub and use the results.
        dsize = op.opers[0].tsize
        ssize = op.opers[1].tsize
        # Sign extend immediates where the sizes don't match
        if dsize != ssize:
            src = e_bits.sign_extend(src, ssize, dsize)
            ssize = dsize
        return self.intSubBase(src, dst, ssize, dsize)

    def intSubBase(self, src, dst, ssize, dsize):

        usrc = e_bits.unsigned(src, ssize)
        udst = e_bits.unsigned(dst, dsize)

        ssrc = e_bits.signed(src, ssize)
        sdst = e_bits.signed(dst, dsize)

        ures = udst - usrc
        sres = sdst - ssrc

        #print "dsize/ssize: %d %d" % (dsize, ssize)
        #print "unsigned: %d %d %d" % (usrc, udst, ures)
        #print "signed: %d %d %d" % (ssrc, sdst, sres)

        self.setFlag(EFLAGS_OF, e_bits.is_signed_overflow(sres, dsize))
        self.setFlag(EFLAGS_AF, e_bits.is_aux_carry(usrc, udst))
        self.setFlag(EFLAGS_CF, e_bits.is_unsigned_carry(ures, dsize))
        self.setFlag(EFLAGS_SF, e_bits.is_signed(ures, dsize))
        self.setFlag(EFLAGS_ZF, not sres)
        self.setFlag(EFLAGS_PF, e_bits.is_parity_byte(ures))

        return ures

    def logicalAnd(self, op):
        dst = self.getOperValue(op, 0)
        src = self.getOperValue(op, 1)

        # PDE
        if dst == None or src == None:
            self.undefFlags()
            self.setOperValue(op, 0, None)
            return

        dsize = op.opers[0].tsize
        ssize = op.opers[1].tsize

        # sign-extend an immediate if needed
        if dsize != ssize:
            src = e_bits.sign_extend(src, ssize, dsize)
            ssize = dsize

        # Make sure everybody's on the same bit page.
        dst = e_bits.unsigned(dst, dsize)
        src = e_bits.unsigned(src, ssize)

        res = src & dst

        self.setFlag(EFLAGS_AF, 0) # AF is undefined, but it seems like it is zeroed
        self.setFlag(EFLAGS_OF, 0)
        self.setFlag(EFLAGS_CF, 0)
        self.setFlag(EFLAGS_SF, e_bits.is_signed(res, dsize))
        self.setFlag(EFLAGS_ZF, not res)
        self.setFlag(EFLAGS_PF, e_bits.is_parity_byte(res))
        return res

    def doRepPrefix(self, meth, op):
        #FIXME check for opcode family valid to rep
        ret = None
        ecx = self.getRegister(REG_ECX)
        while ecx != 0:
            ret = meth(op)
            ecx -= 1
        self.setRegister(REG_ECX, 0)
        return ret

    def doRepzPrefix(self, meth, op):
        pass

    # Beginning of Instruction methods

    def i_adc(self, op):
        dst = self.getOperValue(op, 0)
        src = self.getOperValue(op, 1)
        # PDE
        if dst == None or src == None:
            self.undefFlags()
            self.setOperValue(op, 0, None)
            return

        cf = 0
        if self.getFlag(EFLAGS_CF):
            cf = 1

        dstsize = op.opers[0].tsize
        srcsize = op.opers[1].tsize

        if (isinstance(op.opers[1], i386ImmOper) and
            srcsize < dstsize):
            src = e_bits.sign_extend(src, srcsize, dstsize)
            srcsize = dstsize

        #FIXME perhaps unify the add/adc flags/arith code
        res = dst + src + cf

        tsize = op.opers[0].tsize

        self.setFlag(EFLAGS_CF, e_bits.is_unsigned_carry(res, tsize))
        self.setFlag(EFLAGS_PF, e_bits.is_parity_byte(res))
        self.setFlag(EFLAGS_AF, e_bits.is_aux_carry(src, dst))
        self.setFlag(EFLAGS_ZF, not res)
        self.setFlag(EFLAGS_SF, e_bits.is_signed(res, tsize))
        self.setFlag(EFLAGS_OF, e_bits.is_signed_overflow(res, tsize))

        self.setOperValue(op, 0, res)

    def i_add(self, op):
        dst = self.getOperValue(op, 0)
        src = self.getOperValue(op, 1)

        dsize = op.opers[0].tsize
        ssize = op.opers[1].tsize

        #FIXME PDE and flags
        if dst == None or src == None:
            self.undefFlags()
            self.setOperValue(op, 0, None)
            return

        if dsize > ssize:
            src = e_bits.sign_extend(src, ssize, dsize)
            ssize = dsize

        udst = e_bits.unsigned(dst, dsize)
        usrc = e_bits.unsigned(src, ssize)
        sdst = e_bits.signed(dst, dsize)
        ssrc = e_bits.signed(src, ssize)

        ures = udst + usrc
        sres = sdst + ssrc

        self.setFlag(EFLAGS_CF, e_bits.is_unsigned_carry(ures, dsize))
        self.setFlag(EFLAGS_PF, e_bits.is_parity_byte(ures))
        self.setFlag(EFLAGS_AF, e_bits.is_aux_carry(src, dst))
        self.setFlag(EFLAGS_ZF, not ures)
        self.setFlag(EFLAGS_SF, e_bits.is_signed(ures, dsize))
        self.setFlag(EFLAGS_OF, e_bits.is_signed_overflow(sres, dsize))

        self.setOperValue(op, 0, ures)

    def i_and(self, op):
        #FIXME 24 and 25 opcodes should *not* get sign-extended.
        res = self.logicalAnd(op)
        self.setOperValue(op, 0, res)

    def i_arpl(self, op):
        v1 = self.getOperValue(op, 0)
        v2 = self.getOperValue(op, 1)

        # Mask off the rpl
        r1 = v1 & 3
        r2 = v2 & 3

        if r1 < r2: # If dest rpl < src rpl
            self.setFlag(EFLAGS_ZF, True)
            # Bump 2 bits off the bottom and add r2
            self.setOperValue(op, 0, ((v1 >> 2) << 2) | r2)
        else:
            self.setFlag(EFLAGS_ZF, False)

    def i_bswap(self, op):
        val = self.getOperValue(op, 0)
        tsize = op.opers[0].tsize
        self.setOperValue(op, 0, e_bits.byteswap(val, tsize))

    def i_bsr(self, op):
        val = self.getOperValue(op, 0)

        if val == 0:
            # If the src is 0, set ZF and get out
            self.setFlag(EFLAGS_ZF, True)
            return

        self.setFlag(EFLAGS_ZF, False)

        tsize = op.opers[0].tsize
        rmax = (tsize*8) - 1
        while rmax >= 0:
            if val & (1<<rmax):
                self.setOperValue(op, 1, rmax)
                return
            rmax -= 1

    def doBitTest(self, op):
        val = self.getOperValue(op, 0)
        shift = self.getOperValue(op, 1)
        mask = 1 << shift
        self.setFlag(EFLAGS_CF, val & mask)
        # Return the source and mask for btc/btr
        return val,mask

    def i_bt(self, op):
        self.doBitTest(op)

    def i_btc(self, op):
        # bit test and toggle bit in source
        val, mask = self.doBitTest(op)
        self.setOperValue(op, 0, val ^ mask)

    def i_btr(self, op):
        # bit test (and clear in the source)
        val, mask = self.doBitTest(op)
        mask = e_bits.unsigned(~val, op.opers[0].tsize)
        self.setOperValue(op, 0, val & mask)

    def i_bts(self, op):
        # bit test (and set in the source)
        val, mask = self.doBitTest(op)
        self.setOperValue(op, 0, val | mask)

    def i_call(self, op):
        eip = self.getProgramCounter()
        saved = eip + op.size
        self.doPush(saved)

        val = self.getOperValue(op, 0)
        if val == None:
            raise envi.PDEException(self, "Unknown Call Target")
        return val

    def i_clc(self, op):
        self.setFlag(EFLAGS_CF, False)

    def i_cld(self, op):
        self.setFlag(EFLAGS_DF, False)

    def i_cli(self, op):
        self.setFlag(EFLAGS_IF, False)

    # We include all the possible CMOVcc names just in case somebody
    # gets hinkey with the disassembler.
    def i_cmova(self, op):
        if self.cond_a():    return self.i_mov(op)
    def i_cmovae(self, op):
        if self.cond_ae():   return self.i_mov(op)
    def i_cmovb(self, op):
        if self.cond_b():    return self.i_mov(op)
    def i_cmovbe(self, op):
        if self.cond_be():   return self.i_mov(op)
    def i_cmovc(self, op):
        if self.cond_c():    return self.i_mov(op)
    def i_cmovecxz(self, op):
        if self.cond_ecxz(): return self.i_mov(op)
    def i_cmove(self, op):
        if self.cond_e():    return self.i_mov(op)
    def i_cmovg(self, op):
        if self.cond_g():    return self.i_mov(op)
    def i_cmovge(self, op):
        if self.cond_ge():   return self.i_mov(op)
    def i_cmovl(self, op):
        if self.cond_l():    return self.i_mov(op)
    def i_cmovle(self, op):
        if self.cond_le():   return self.i_mov(op)
    i_cmovna = i_cmovbe
    i_cmovnae = i_cmovb
    i_cmovnb = i_cmovae
    i_cmovnbe = i_cmova
    i_cmovnc = i_cmovae
    def i_cmovne(self, op):
        if self.cond_ne():   return self.i_mov(op)
    i_cmovng = i_cmovle
    i_cmovnge = i_cmovl
    i_cmovnl = i_cmovge
    i_cmovnle = i_cmovg
    def i_cmovno(self, op):
        if self.cond_no():   return self.i_mov(op)
    def i_cmovnp(self, op):
        if self.cond_np():   return self.i_mov(op)
    def i_cmovns(self, op):
        if self.cond_ns():   return self.i_mov(op)
    i_cmovnz = i_cmovne
    def i_cmovo(self, op):
        if self.cond_o():    return self.i_mov(op)
    def i_cmovp(self, op):
        if self.cond_p():    return self.i_mov(op)
    i_cmovpe = i_cmovp
    i_cmovpo = i_cmovnp
    def i_cmovs(self, op):
        if self.cond_s():    return self.i_mov(op)
    i_cmovz = i_cmove

    def i_cmp(self, op):
        self.integerSubtraction(op)

    def doCmps(self, width):
        esi = self.getRegister(REG_ESI)
        edi = self.getRegister(REG_EDI)


        # FIXME che
        sval = self.readMemValue(esi, width)
        dval = self.readMemValue(edi, width)

        self.intSubBase(sval, dval, width, width)

        if self.getFlag(EFLAGS_ZF):
            if self.getFlag(EFLAGS_DF): # decrement
                esi -= width
                edi -= width
            else:
                esi += width
                edi += width
            self.setRegister(REG_ESI, esi)
            self.setRegister(REG_EDI, edi)

    def i_cmpsb(self, op):
        self.doCmps(1)

    def i_cmpsd(self, op):
        """
        Compare the dword pointed at by ds:esi to ds:edi.
        (if equal, update esi/edi by one acording to DF)
        """
        width = 4
        if op.prefixes & PREFIX_OP_SIZE:
            width = 2

        self.doCmps(width)

    def i_cmpxchg(self, op):
        tsize = op.opers[0].tsize
        if tsize == 4:
            areg = REG_EAX
        elif tsize == 1:
            areg = REG_AL
        else:
            areg = REG_AX

        aval = self.getRegister(areg)
        tval = self.getOperValue(op, 0)
        vval = self.getOperValue(op, 1)

        #FIXME eflags... is this supposed to be a real cmp?
        if aval == tval:
            self.setFlag(EFLAGS_ZF, True)
            self.setOperValue(op, 0, vval)
        else:
            self.setFlag(EFLAGS_ZF, False)
            self.setRegister(areg, tval)

    def twoRegCompound(self, topreg, botreg, size):
        """
        Build a compound value where the value of the top reg is shifted and
        or'd with the value of the bot reg ( assuming they are size
        bytes in length).  The return is size * 2 wide (and unsigned).
        """
        top = e_bits.unsigned(self.getRegister(topreg), size)
        bot = e_bits.unsigned(self.getRegister(botreg), size)

        return ((top << (size *8)) | bot)

    def regsFromCompound(self, val, size):
        top = e_bits.unsigned(val >> (size * 8), size)
        bot = e_bits.unsigned(val, size)
        return (top, bot)

    def i_cmpxch8b(self, op):
        size = 4
        dsize = 8
        if op.prefixes & PREFIX_OP_SIZE:
            size = 2
            dsize = 4

        bignum = self.twoRegCompound(REG_EDX, REG_EAX, size)
        testnum = self.getOperValue(op, 0)
        if bignum == testnum:
            self.setFlag(EFLAGS_ZF, 1)
            resval = self.twoRegCompound(REG_ECX, REG_EBX, size)
            self.setOperValue(op, 0, resval)
        else:
            self.setFlag(EFLAGS_ZF, 0)
            edx,eax = self.regsFromCompound(testnum, dsize)
            self.setRegister(REG_EDX, edx)
            self.setRegister(REG_EAX, eax)

    def i_cdq(self, op):
        return self.i_cwd(op)

    def i_cpuid(self, op):
        eax = self.getRegister(REG_EAX)
        print "FIXME: cpuid() returns NONSENSE (eax:0x%.8x)" % eax
        self.setRegister(REG_EAX, 0)
        self.setRegister(REG_EBX, 0)
        self.setRegister(REG_ECX, 0)
        self.setRegister(REG_EDX, 0)

    def i_cwd(self, op):
        #FIXME handle 16 bit variant
        eax = self.getRegister(REG_EAX)
        #PDE
        if eax == None:
            self.setRegister(REG_EDX, None)
            return

        if e_bits.is_signed(eax, 4):
            self.setRegister(REG_EDX, 0xffffffff)
        else:
            self.setRegister(REG_EDX, 0)

    def i_dec(self, op):
        val = self.getOperValue(op, 0)
        if val == None:
            self.undefFlags()
            return
        val -= 1
        self.setOperValue(op, 0, val)
        #FIXME change over to integer subtraction

        self.setFlag(EFLAGS_OF, 0) #FIXME OF
        self.setFlag(EFLAGS_SF, e_bits.is_signed(val, op.opers[0].tsize))
        self.setFlag(EFLAGS_ZF, not val)
        self.setFlag(EFLAGS_AF, 0) #FIXME AF...
        self.setFlag(EFLAGS_PF, e_bits.is_parity_byte(val))

    def i_div(self, op):
        #FIXME this is probably broke
        oper = op.opers[0]
        val = self.getOperValue(op, 0)
        if val == 0: raise envi.DivideByZero(self)
        if oper.tsize == 1:
            ax = self.getRegister(REG_AX)
            quot = ax / val
            rem  = ax % val
            if quot > 255:
                #FIXME stuff
                print "FIXME: division exception"
            self.setRegister(REG_EAX, (quot << 8) + rem)

        elif oper.tsize == 4:
            #FIXME 16 bit over-ride
            eax = self.getRegister(REG_EAX)
            edx = self.getRegister(REG_EDX)
            tot = (edx << 32) + eax
            quot = tot / val
            rem = tot % val

            if quot > 0xffffffff:
                print "FIXME: division exception"

            self.setRegister(REG_EAX, quot)
            self.setRegister(REG_EDX, rem)

        else:
            raise envi.UnsupportedInstruction(self, op)

    def i_enter(self, op):
        locsize = self.getOperValue(op, 0)
        depth = self.getOperValue(op, 1)
        if depth != 0:
            raise envi.UnsupportedInstruction(self, op)

        esp = self.getRegister(REG_ESP)
        ebp = self.getRegister(REG_EBP)

        esp -= 4 # Room for the base pointer

        self.writeMemValue(esp, ebp, 4)
        self.setRegister(REG_EBP, esp)
        esp -= locsize
        self.setRegister(REG_ESP, esp)

    # FIXME a whole bunch of float instructions whose
    # processing is essentially ignored:
    def i_fldz(self, op):
        pass

    def i_fild(self, op):
        pass

    def i_fstp(self, op):
        pass

    def i_idiv(self, op):
        #FIXME this needs emulation testing!
        tsize = op.opers[0].tsize
        if tsize == 1:
            ax = self.getRegister(REG_AX)
            ax = e_bits.signed(ax, 2)
            d = self.getOperValue(op, 0)
            d = e_bits.signed(d, 1)
            if d == 0: raise envi.DivideByZero(self)
            q = ax / d
            r = ax % d
            res = ((r & 0xff) << 8) | (q & 0xff)
            self.setRegister(REG_AX, res)

        elif tsize == 2:
            val = self.twoRegCompound(REG_DX, REG_AX, 2)
            val = e_bits.signed(val, 4)
            d = self.getOperValue(op, 0)
            d = e_bits.signed(d, 2)
            if d == 0: raise envi.DivideByZero(self)
            q = val / d
            r = val % d

            self.setRegister(REG_AX, q)
            self.setRegister(REG_DX, r)

        elif tsize == 4:
            val = self.twoRegCompound(REG_EDX, REG_EAX, 4)
            val = e_bits.signed(val, 8)
            d = self.getOperValue(op, 0)
            d = e_bits.signed(d, 4)
            if d == 0: raise envi.DivideByZero(self)
            q = val / d
            r = val % d

            self.setRegister(REG_EAX, q)
            self.setRegister(REG_EDX, r)

        else:
            raise envi.UnsupportedInstruction(self, op)

    def i_imul(self, op):
        #FIXME eflags
        # FIXME imul bugs
        ocount = len(op.opers)
        if ocount == 2:
            dst = self.getOperValue(op, 0)
            src = self.getOperValue(op, 1)
            dsize = op.opers[0].tsize
            ssize = op.opers[1].tsize

            # FIXME all these are taken care of in disasm now...
            if dsize > ssize:
                src = e_bits.sign_extend(src, ssize, dsize)
                ssize = dsize

            res = dst * src

            sof = e_bits.is_unsigned_carry(res, dsize)
            self.setFlag(EFLAGS_CF, sof)
            self.setFlag(EFLAGS_OF, sof)

            self.setOperValue(op, 0, res)

        elif ocount == 3:
            dst = self.getOperValue(op, 0)
            src1 = self.getOperValue(op, 1)
            src2 = self.getOperValue(op, 2)

            dsize = op.opers[0].tsize
            ssize1 = op.opers[1].tsize
            ssize2 = op.opers[2].tsize

            if dsize > ssize2: # Only the last operand may be shorter imm
                src2 = e_bits.sign_extend(src2, ssize2, dsize)
                ssize2 = dsize

            res = src1 * src2

            sof = e_bits.is_unsigned_carry(res, dsize)
            self.setFlag(EFLAGS_CF, sof)
            self.setFlag(EFLAGS_OF, sof)

            self.setOperValue(op, 0, res)

        else:
            raise envi.UnsupportedInstruction(self, op)

    def i_in(self, op):
        raise envi.UnsupportedInstruction(self, op)

    def i_inc(self, op):
        size = op.opers[0].tsize
        val = self.getOperValue(op, 0)

        sval = e_bits.signed(val, size)
        sval += 1

        self.setOperValue(op, 0, sval)

        # Another arithmetic op where doing signed and unsigned is easier ;)

        self.setFlag(EFLAGS_OF, e_bits.is_signed_overflow(sval, size))
        self.setFlag(EFLAGS_SF, e_bits.is_signed(sval, size))
        self.setFlag(EFLAGS_ZF, not sval)
        self.setFlag(EFLAGS_AF, (sval & 0xf == 0))
        self.setFlag(EFLAGS_PF, e_bits.is_parity_byte(sval))

    def i_int(self, op):
        raise envi.UnsupportedInstruction(self, op)

    def i_int3(self, op):
        raise envi.BreakpointHit(self)

    def i_lea(self, op):
        base = self.getOperAddr(op, 1)
        self.setOperValue(op, 0, base)

    def decCounter(self):
        """
        A helper to decrement and return the counter
        """
        ecx = self.getRegister(REG_ECX)
        ecx -= 1
        self.setRegister(REG_ECX, ecx)
        return ecx

    def i_lodsb(self, op):
        esi = self.getRegister(REG_ESI)
        newal = self.readMemoryFormat(esi, "<B")[0]
        self.setRegister(REG_AL, newal)
        if not self.getFlag(EFLAGS_DF):
            esi += 1
        else:
            esi -= 1
        self.setRegister(REG_ESI, esi)
        
    def i_lodsd(self, op):
        esi = self.getRegister(REG_ESI)
        neweax = self.readMemoryFormat(esi, "<L")[0]
        #FIXME figgure out ADDR_SIZE vs OP_SIZE and which is which
        self.setRegister(REG_EAX, neweax)
        if not self.getFlag(EFLAGS_DF):
            esi += 4
        else:
            esi -= 4
        self.setRegister(REG_ESI, esi)

    def i_loop(self, op):
        if self.decCounter() != 0:
            return self.getOperValue(op, 0)

    def i_loopz(self, op):
        if self.decCounter() != 0 and self.cond_e():
            return self.getOperValue(op, 0)

    def i_loopnz(self, op):
        if self.decCounter() != 0 and self.cond_ne():
            return self.getOperValue(op, 0)

    i_loope = i_loopz
    i_loopne = i_loopnz

    def i_leave(self, op):
        ebp = self.getRegister(REG_EBP)
        self.setRegister(REG_ESP, ebp)
        self.setRegister(REG_EBP, self.doPop())

    def i_mov(self, op):
        val = self.getOperValue(op, 1)
        self.setOperValue(op, 0, val)

    def i_movq(self, op):
        val = self.getOperValue(op, 1)
        self.setOperValue(op, 0, val)

    def i_movsb(self, op):
        esi = self.getRegister(REG_ESI)
        edi = self.getRegister(REG_EDI)
        bytes = self.readMemory(esi, 1)
        self.writeMemory(edi, bytes)
        if self.getFlag(EFLAGS_DF):
            self.setRegister(REG_ESI, esi-1)
            self.setRegister(REG_EDI, edi-1)
        else:
            self.setRegister(REG_ESI, esi+1)
            self.setRegister(REG_EDI, edi+1)

    def i_movsd(self, op):
        esi = self.getRegister(REG_ESI)
        edi = self.getRegister(REG_EDI)
        bytes = self.readMemory(esi, 4)
        self.writeMemory(edi, bytes)
        if self.getFlag(EFLAGS_DF):
            self.setRegister(REG_ESI, esi-4)
            self.setRegister(REG_EDI, edi-4)
        else:
            self.setRegister(REG_ESI, esi+4)
            self.setRegister(REG_EDI, edi+4)

    def i_movsx(self, op):
        osize = op.opers[1].tsize
        nsize = op.opers[0].tsize
        val = self.getOperValue(op, 1)
        val = e_bits.sign_extend(val, osize, nsize)
        self.setOperValue(op, 0, val)

    def i_movzx(self, op):
        val = self.getOperValue(op, 1)
        self.setOperValue(op, 0, val)

    def i_mul(self, op):
        #FIXME make sure these work right
        tsize = op.opers[0].tsize

        val = self.getOperValue(op, 0)

        # Return al/ax/eax as needed...
        a = self._emu_getGpReg(GPR_A, tsize)

        res = a * val

        if tsize == 1:
            self.setRegister(REG_AX, res)

        elif tsize == 2:
            d,a = self.regsFromCompound(res, tsize)
            self._emu_setGpReg(GPR_A, a, tsize)
            self._emu_setGpReg(GPR_D, d, tsize)

        # If the high order stuff was used, set CF/OF
        if res >> (tsize * 8):
            self.setFlag(EFLAGS_CF, True)
            self.setFlag(EFLAGS_OF, True)
        else:
            self.setFlag(EFLAGS_CF, False)
            self.setFlag(EFLAGS_OF, False)

    def _emu_setGpReg(self, reg, val, tsize):
        """
        Automagically map all general purpose register accesses
        to their tsize equiv.  Helps clean up a lot of code
        (and makes a nice place for AMD64 to hook ;) )
        """
        if tsize == 1:
            reg += 0x00080000
        elif tsize == 2:
            reg += 0x00100000
        self.setRegister(reg, value)

    def _emu_getGpReg(self, reg, tsize):
        """
        Automagically map all general purpose register accesses
        to their tsize equiv.  Helps clean up a lot of code
        (and makes a nice place for AMD64 to hook ;) )
        """
        if tsize == 1:
            reg += 0x00080000
        elif tsize == 2:
            reg += 0x00100000
        return self.getRegister(reg)

    def i_neg(self, op):
        tsize = op.opers[0].tsize
        val = self.getOperValue(op, 0)
        res = 0 - val
        self.setOperValue(op, 0, res)

        self.setFlag(EFLAGS_CF, val != 0)
        self.setFlag(EFLAGS_ZF, not res)
        self.setFlag(EFLAGS_SF, e_bits.is_signed(res, tsize))
        #FIXME how does neg cause/not cause a carry?
        self.setFlag(EFLAGS_AF, 0) # FIXME EFLAGS_AF

    def i_nop(self, op):
        pass

    def i_not(self, op):
        val = self.getOperValue(op, 0)
        val ^= e_bits.u_maxes[op.opers[0].tsize]
        self.setOperValue(op, 0, val)

    def i_or(self, op):
        dst = self.getOperValue(op, 0)
        dsize = op.opers[0].tsize
        src = self.getOperValue(op, 1)
        ssize = op.opers[1].tsize

        if dsize != ssize:
            src = e_bits.sign_extend(src, ssize, dsize)
            ssize = dsize

        res = dst | src

        self.setOperValue(op, 0, res)

        self.setFlag(EFLAGS_OF, 0)
        self.setFlag(EFLAGS_CF, 0)
        self.setFlag(EFLAGS_SF, e_bits.is_signed(res, dsize))
        self.setFlag(EFLAGS_ZF, not res)
        self.setFlag(EFLAGS_PF, e_bits.is_parity_byte(res))

    def i_pop(self, op):
        val = self.doPop()
        self.setOperValue(op, 0, val)

    def i_popad(self, op):
        #FIXME 16 bit?
        self.setRegister(REG_EDI, self.doPop())
        self.setRegister(REG_ESI, self.doPop())
        self.setRegister(REG_EBP, self.doPop())
        self.doPop() # skip one
        self.setRegister(REG_EBX, self.doPop())
        self.setRegister(REG_EDX, self.doPop())
        self.setRegister(REG_ECX, self.doPop())
        self.setRegister(REG_EAX, self.doPop())

    def i_popfd(self, op):
        eflags = self.doPop()
        self.setRegister(REG_EFLAGS, eflags)

    def i_push(self, op):
        val = self.getOperValue(op, 0)
        if isinstance(op.opers[0], i386ImmOper):
            val = e_bits.sign_extend(val, op.opers[0].tsize, 4) #FIXME 64bit
        self.doPush(val)

    def i_pushad(self, op):
        tmp = self.getRegister(REG_ESP)
        self.doPush(self.getRegister(REG_EAX))
        self.doPush(self.getRegister(REG_ECX))
        self.doPush(self.getRegister(REG_EDX))
        self.doPush(self.getRegister(REG_EBX))
        self.doPush(tmp)
        self.doPush(self.getRegister(REG_EBP))
        self.doPush(self.getRegister(REG_ESI))
        self.doPush(self.getRegister(REG_EDI))

    def i_pushfd(self, op):
        eflags = self.getRegister(REG_EFLAGS)
        self.doPush(eflags)

    def i_jmp(self, op):
        return self.getOperValue(op, 0)

    # We include all the possible Jcc names just in case somebody
    # gets hinkey with the disassembler.
    def i_ja(self, op):
        if self.cond_a():    return self.getOperValue(op, 0)
    def i_jae(self, op):
        if self.cond_ae():   return self.getOperValue(op, 0)
    def i_jb(self, op):
        if self.cond_b():    return self.getOperValue(op, 0)
    def i_jbe(self, op):
        if self.cond_be():   return self.getOperValue(op, 0)
    def i_jc(self, op):
        if self.cond_c():    return self.getOperValue(op, 0)
    def i_jecxz(self, op):
        if self.cond_ecxz(): return self.getOperValue(op, 0)
    def i_je(self, op):
        if self.cond_e():    return self.getOperValue(op, 0)
    def i_jg(self, op):
        if self.cond_g():    return self.getOperValue(op, 0)
    def i_jge(self, op):
        if self.cond_ge():   return self.getOperValue(op, 0)
    def i_jl(self, op):
        if self.cond_l():    return self.getOperValue(op, 0)
    def i_jle(self, op):
        if self.cond_le():   return self.getOperValue(op, 0)
    i_jna = i_jbe
    i_jnae = i_jb
    i_jnb = i_jae
    i_jnbe = i_ja
    i_jnc = i_jae
    def i_jne(self, op):
        if self.cond_ne():   return self.getOperValue(op, 0)
    i_jng = i_jle
    i_jnge = i_jl
    i_jnl = i_jge
    i_jnle = i_jg
    def i_jno(self, op):
        if self.cond_no():   return self.getOperValue(op, 0)
    def i_jnp(self, op):
        if self.cond_np():   return self.getOperValue(op, 0)
    def i_jns(self, op):
        if self.cond_ns():   return self.getOperValue(op, 0)
    i_jnz = i_jne
    def i_jo(self, op):
        if self.cond_o():    return self.getOperValue(op, 0)
    def i_jp(self, op):
        if self.cond_p():    return self.getOperValue(op, 0)
    i_jpe = i_jp
    i_jpo = i_jnp
    def i_js(self, op):
        if self.cond_s():    return self.getOperValue(op, 0)
    i_jz = i_je

    def i_rcl(self, op):
        dsize = op.opers[0].tsize
        dst = self.getOperValue(op, 0)
        src = self.getOperValue(op, 1)

        src = src & 0x1f

        # Put that carry bit up there.
        if self.getFlag(EFLAGS_CF):
            dst = dst | (1 << (8 * dsize))

        # Add one to account for carry
        x = ((8*dsize) - src) + 1
        #FIXME is this the one that can end up negative?

        res = (dst << src) | (dst >> x)
        cf = (res >> (8*dsize)) & 1
        res = e_bits.unsigned(res, dsize)

        self.setFlag(EFLAGS_CF, cf)
        if src == 1:
            m1 = e_bits.msb(res, dsize)
            m2 = e_bits.msb(res << 1, dsize)
            self.setFlag(EFLAGS_OF, m1 ^ m2)

        self.setOperValue(op, 0, res)

    def i_rcr(self, op):
        dsize = op.opers[0].tsize
        dst = self.getOperValue(op, 0)
        src = self.getOperValue(op, 1)

        src = src & 0x1f
        # Put that carry bit up there.
        if self.getFlag(EFLAGS_CF):
            dst = dst | (1 << (8 * dsize))

        # Add one to account for carry
        x = ((8*dsize) - src) + 1

        res = (dst >> src) | (dst << x)
        cf = (res >> (8*dsize)) & 1
        res = e_bits.unsigned(res, dsize)

        self.setFlag(EFLAGS_CF, cf)
        if src == 1:
            m1 = e_bits.msb(res, dsize)
            m2 = e_bits.msb(res << 1, dsize)
            self.setFlag(EFLAGS_OF, m1 ^ m2)

        self.setOperValue(op, 0, res)

    def i_rdtsc(self, op):
        """
        Read the clock cycle counter into edx:eax
        """
        self.setRegister(REG_EDX, 0)
        self.setRegister(REG_EAX, 0x414141)

    def i_rol(self, op):
        dstSize = op.opers[0].tsize
        count = self.getOperValue(op, 1)
        tempCount = shiftMask(count, dstSize)

        if tempCount > 0: # Yeah, i know...weird. See the intel manual
            while tempCount:
                val = self.getOperValue(op, 0)
                tempCf = e_bits.msb(val, dstSize)
                self.setOperValue(op, 0, (val * 2) + tempCf)
                tempCount -= 1
            val = self.getOperValue(op, 0)
            self.setFlag(EFLAGS_CF, e_bits.lsb(val))
            if count == 1:
                val = self.getOperValue(op, 0)
                cf = self.getFlag(EFLAGS_CF)
                self.setFlag(EFLAGS_OF, e_bits.msb(val, dstSize) ^ cf)
            else:
                self.setFlag(EFLAGS_OF, False)
        
    def i_ror(self, op):
        dstSize = op.opers[0].tsize
        count = self.getOperValue(op, 1)
        tempCount = shiftMask(count, dstSize)

        if tempCount > 0: # Yeah, i know...weird. See the intel manual
            while tempCount:
                val = self.getOperValue(op, 0)
                tempCf = e_bits.lsb(val)
                self.setOperValue(op, 0, (val / 2) + (tempCf * (2 ** dstSize)))
                tempCount -= 1
            val = self.getOperValue(op, 0)
            self.setFlag(EFLAGS_CF, e_bits.msb(val, dstSize))
            if count == 1:
                val = self.getOperValue(op, 0)
                cf = self.getFlag(EFLAGS_CF)
                # FIXME: This may be broke...the manual is kinda flaky here
                self.setFlag(EFLAGS_OF, e_bits.msb(val, dstSize) ^ (e_bits.msb(val, dstSize) - 1))
            else:
                self.setFlag(EFLAGS_OF, False)

    def i_ret(self, op):
        ret = self.doPop()
        if len(op.opers):
            esp = self.getRegister(REG_ESP)
            ival = self.getOperValue(op, 0)
            self.setRegister(REG_ESP, esp+ival)
        return ret

    def i_sal(self, op):
        dsize = op.opers[0].tsize
        dst = self.getOperValue(op, 0)
        src = self.getOperValue(op, 1)

        src = src & 0x1f

        # According to intel manual, if src == 0 eflags are not changed
        if src == 0:
            return

        res = dst << src
        cf = (res >> 8*dsize) & 1

        res = e_bits.unsigned(res, dsize)

        self.setFlag(EFLAGS_CF, cf)
        self.setFlag(EFLAGS_SF, e_bits.is_signed(res, dsize))
        self.setFlag(EFLAGS_ZF, not res)
        self.setFlag(EFLAGS_PF, e_bits.is_parity_byte(res))
        if src == 1:
            self.setFlag(EFLAGS_OF, not e_bits.msb(res, dsize) == cf)
        else:
            self.setFlag(EFLAGS_OF, 0) # Undefined, but zero'd on core2 duo

        self.setOperValue(op, 0, res)

    def i_sar(self, op):
        dsize = op.opers[0].tsize
        dst = self.getOperValue(op, 0)
        src = self.getOperValue(op, 1)

        src = src & 0x1f

        # According to intel manual, if src == 0 eflags are not changed
        if src == 0:
            return

        signed = e_bits.msb(dst, dsize)

        res = dst >> src
        cf = (dst >> (src-1)) & 1

        # If it was signed, we need to fill in all those bits we
        # shifted off with ones.
        if signed:
            x = (8*dsize) - src
            umax = e_bits.u_maxes[dsize]
            res |= (umax >> x) << x

        res = e_bits.unsigned(res, dsize)

        self.setFlag(EFLAGS_CF, cf)
        self.setFlag(EFLAGS_SF, e_bits.is_signed(res, dsize))
        self.setFlag(EFLAGS_ZF, not res)
        self.setFlag(EFLAGS_PF, e_bits.is_parity_byte(res))
        if src == 1:
            self.setFlag(EFLAGS_OF, False)
        else:
            self.setFlag(EFLAGS_OF, 0) # Undefined, but zero'd on core2 duo

        self.setOperValue(op, 0, res)

    def i_shl(self, op):
        return self.i_sal(op)

    def i_shr(self, op):
        dsize = op.opers[0].tsize
        dst = self.getOperValue(op, 0)
        src = self.getOperValue(op, 1)

        src = src & 0x1f

        # According to intel manual, if src == 0 eflags are not changed
        if src == 0:
            return

        res = dst >> src
        cf = (dst >> (src-1)) & 1

        res = e_bits.unsigned(res, dsize)

        self.setFlag(EFLAGS_CF, cf)
        self.setFlag(EFLAGS_SF, e_bits.is_signed(res, dsize))
        self.setFlag(EFLAGS_ZF, not res)
        self.setFlag(EFLAGS_PF, e_bits.is_parity_byte(res))
        if src == 1:
            self.setFlag(EFLAGS_OF, False)
        else:
            self.setFlag(EFLAGS_OF, 0) # Undefined, but zero'd on core2 duo

        self.setOperValue(op, 0, res)

    def i_shrd(self, op):
        dsize = op.opers[0].tsize
        bsize = dsize * 8
        dst = self.getOperValue(op, 0)
        src = self.getOperValue(op, 1)
        cnt = self.getOperValue(op, 2)

        cnt &= 0x1f # Reg gets masked down

        if cnt == 0:
            return

        if cnt > bsize:
            # result is "undfined"
            return

        res = dst >> cnt
        res |= src << (bsize - cnt)

        # We now have the bits masked into res, but it has become
        # wider than the original operand.

        # Ret is masked down to size
        ret = e_bits.unsigned(res, dsize)

        if cnt == 1: # Set OF on sign change
            dsign = e_bits.is_signed(dst, dsize)
            rsign = e_bits.is_signed(ret, dsize)
            self.setFlag(EFLAGS_OF, dsign != rsign)

        # set carry to last shifted bit
        self.setFlag(EFLAGS_CF, (res << bsize) & 1)
        self.setFlag(EFLAGS_SF, e_bits.is_signed(ret, dsize))
        self.setFlag(EFLAGS_ZF, not ret)
        self.setFlag(EFLAGS_PF, e_bits.is_parity_byte(ret))

        self.setOperValue(op, 0, ret)

    def i_shld(self, op):
        dsize = op.opers[0].tsize
        bsize = dsize * 8
        dst = self.getOperValue(op, 0)
        src = self.getOperValue(op, 1)
        cnt = self.getOperValue(op, 2)

        cnt &= 0x1f # Reg gets masked down

        if cnt == 0:
            return

        if cnt > bsize:
            return

        res = dst << cnt
        res |= src >> (bsize - cnt)
        ret = e_bits.unsigned(res, dsize)

        if cnt == 1: # Set OF on sign change
            dsign = e_bits.is_signed(dst, dsize)
            rsign = e_bits.is_signed(ret, dsize)
            self.setFlag(EFLAGS_OF, dsign != rsign)

        # set carry to last shifted bit
        self.setFlag(EFLAGS_CF, (dst << (cnt-1)) & 1)
        self.setFlag(EFLAGS_SF, e_bits.is_signed(ret, dsize))
        self.setFlag(EFLAGS_ZF, not ret)
        self.setFlag(EFLAGS_PF, e_bits.is_parity_byte(ret))

        self.setOperValue(op, 0, ret)

    def i_scasb(self, op):
        al = self.getRegister(REG_AL)
        edi = self.getRegister(REG_EDI)
        base,size = self.segments[SEG_ES]
        memval = ord(self.readMemory(base+edi, 1))
        self.intSubBase(al, memval, 1, 1)
        if self.getFlag(EFLAGS_DF):
            edi -= 1
        else:
            edi += 1
        self.setRegister(REG_EDI, edi)

    def i_scasd(self, op):
        #FIXME probably need to handle oper prefix by hand here...
        eax = self.getRegister(REG_EAX)
        edi = self.getRegister(REG_EDI)
        base,size = self.segments[SEG_ES]
        memval = struct.unpack("<L",self.readMemory(base+edi, 4))[0]
        self.intSubBase(eax, memval, 4, 4)
        if self.getFlag(EFLAGS_DF):
            edi -= 4
        else:
            edi += 4
        self.setRegister(REG_EDI, edi)

    def i_stosb(self, op):
        al = self.getRegister(REG_AL)
        edi = self.getRegister(REG_EDI)
        base,size = self.segments[SEG_ES]
        self.writeMemory(base+edi, chr(al))
        if self.getFlag(EFLAGS_DF):
            edi -= 1
        else:
            edi += 1
        self.setRegister(REG_EDI, edi)

    def i_stosd(self, op):
        eax = self.getRegister(REG_EAX)
        edi = self.getRegister(REG_EDI)
        base,size = self.segments[SEG_ES]
        self.writeMemory(base+edi, struct.pack("<L", eax))
        if self.getFlag(EFLAGS_DF):
            edi -= 4
        else:
            edi += 4
        self.setRegister(REG_EDI, edi)

    # We include all the possible SETcc names just in case somebody
    # gets hinkey with the disassembler.
    def i_seta(self, op):     self.setOperValue(op, 0, int(self.cond_a()))
    def i_setae(self, op):    self.setOperValue(op, 0, int(self.cond_ae()))
    def i_setb(self, op):     self.setOperValue(op, 0, int(self.cond_b()))
    def i_setbe(self, op):    self.setOperValue(op, 0, int(self.cond_be()))
    def i_setc(self, op):     self.setOperValue(op, 0, int(self.cond_c()))
    def i_setecxz(self, op):  self.setOperValue(op, 0, int(self.cond_ecxz()))
    def i_sete(self, op):     self.setOperValue(op, 0, int(self.cond_e()))
    def i_setg(self, op):     self.setOperValue(op, 0, int(self.cond_g()))
    def i_setge(self, op):    self.setOperValue(op, 0, int(self.cond_ge()))
    def i_setl(self, op):     self.setOperValue(op, 0, int(self.cond_l()))
    def i_setle(self, op):    self.setOperValue(op, 0, int(self.cond_le()))
    i_setna = i_setbe
    i_setnae = i_setb
    i_setnb = i_setae
    i_setnbe = i_seta
    i_setnc = i_setae
    def i_setne(self, op):    self.setOperValue(op, 0, int(self.cond_ne()))
    i_setng = i_setle
    i_setnge = i_setl
    i_setnl = i_setge
    i_setnle = i_setg
    def i_setno(self, op):    self.setOperValue(op, 0, int(self.cond_no()))
    def i_setnp(self, op):    self.setOperValue(op, 0, int(self.cond_np()))
    def i_setns(self, op):    self.setOperValue(op, 0, int(self.cond_ns()))
    i_setnz = i_setne
    def i_seto(self, op):     self.setOperValue(op, 0, int(self.cond_o()))
    def i_setp(self, op):     self.setOperValue(op, 0, int(self.cond_p()))
    i_setpe = i_setp
    i_setpo = i_setnp
    def i_sets(self, op):     self.setOperValue(op, 0, int(self.cond_s()))
    i_setz = i_sete

    def i_sbb(self, op):
        dst = self.getOperValue(op, 0)
        src = self.getOperValue(op, 1)

        # Much like "integer subtraction" but we need
        # too add in the carry flag
        if src == None or dst == None:
            self.undefFlags()
            return None

        dsize = op.opers[0].tsize
        ssize = op.opers[1].tsize
        # Sign extend immediates where the sizes don't match
        if dsize != ssize:
            src = e_bits.sign_extend(src, ssize, dsize)
            ssize = dsize
        src += self.getFlag(EFLAGS_CF)
        res = self.intSubBase(src, dst, ssize, dsize)
        self.setOperValue(op, 0, res)

    # FIXME scas stuff goes here
    # FIXME conditional byte set goes here
    def i_stc(self, op):
        self.setFlag(EFLAGS_CF, True)

    def i_std(self, op):
        self.setFlag(EFLAGS_DF, True)

    def i_sti(self, op):
        self.setFlag(EFLAGS_IF, True)

    # FIXME stos variants go here
    def i_stosd(self, op):
        eax = self.getRegister(REG_EAX)
        edi = self.getRegister(REG_EDI)
        # FIXME shouldn't have to do this directly
        # FIXME this needs a 32/16 bit mode check
        base,size = self.segments[SEG_ES]
        self.writeMemValue(base+edi, eax, 4)
        # FIXME edi inc must be by oper len
        self.setRegister(REG_EDI, edi+4)

    def i_sub(self, op):
        x = self.integerSubtraction(op)
        if x != None:
            self.setOperValue(op, 0, x)

    def i_test(self, op):
        self.logicalAnd(op)

    def i_wait(self, op):
        print "i_wait() is a stub..."

    def i_xadd(self, op):
        val1 = self.getOperValue(op, 0)
        val2 = self.getOperValue(op, 1)
        temp = val1 + val2
        self.setOperValue(op, 1, val1)
        self.setOperValue(op, 0, temp)

    def i_xchg(self, op):
        temp = self.getOperValue(op, 0)
        self.setOperValue(op, 0, self.getOperValue(op, 1))
        self.setOperValue(op, 1, temp)

    def i_xor(self, op):
        dsize = op.opers[0].tsize
        ssize = op.opers[1].tsize
        dst = self.getOperValue(op, 0)
        src = self.getOperValue(op, 1)

        ret = src ^ dst

        self.setOperValue(op, 0, ret)

        self.setFlag(EFLAGS_CF, 0)
        self.setFlag(EFLAGS_OF, 0)
        self.setFlag(EFLAGS_SF, e_bits.is_signed(ret, dsize))
        self.setFlag(EFLAGS_ZF, not ret)
        self.setFlag(EFLAGS_PF, e_bits.is_parity_byte(ret))
        self.setFlag(EFLAGS_AF, False) # Undefined but actually cleared on amd64 X2

    def i_pxor(self, op):
        return self.i_xor(op)


########NEW FILE########
__FILENAME__ = opcode86

# The opcode tables were taken from Mammon_'s Guide to Writing Disassemblers in Perl, You Morons!"
# and the bastard project. http://www.eccentrix.com/members/mammon/

INSTR_PREFIX=      0xF0000000L
PREFIX_LOCK =      0x00100000
PREFIX_REPNZ=      0x00200000
PREFIX_REPZ =      0x00400000
PREFIX_REP  =      0x00800000
PREFIX_REP_SIMD=   0x01000000
PREFIX_OP_SIZE=    0x02000000
PREFIX_ADDR_SIZE=  0x04000000
PREFIX_SIMD=       0x08000000
PREFIX_CS  =       0x10000000
PREFIX_SS  =       0x20000000
PREFIX_DS  =       0x30000000
PREFIX_ES  =       0x40000000
PREFIX_FS  =       0x50000000
PREFIX_GS  =       0x60000000
PREFIX_REG_MASK=   0xF0000000L

ADDRMETH_MASK =     0x00FF0000L
ADDRMETH_A=   0x00010000    #   Direct address with segment prefix
ADDRMETH_C=   0x00020000    #   MODRM reg field defines control register
ADDRMETH_D=   0x00030000    #   MODRM reg field defines debug register
ADDRMETH_E=   0x00040000    #   MODRM byte defines reg/memory address
ADDRMETH_F=   0x00050000    #   EFLAGS/RFLAGS register
ADDRMETH_G=   0x00060000    #   MODRM byte defines general-purpose reg
ADDRMETH_I=   0x00070000    #   Immediate data follows
ADDRMETH_J=   0x00080000    #   Immediate value is relative to EIP
ADDRMETH_M=   0x00090000    #   MODRM mod field can refer only to memory
ADDRMETH_N=   0x000A0000    #   R/M field of MODRM selects a packed-quadword, MMX register
ADDRMETH_O=   0x000B0000    #   Displacement follows (without modrm/sib)
ADDRMETH_P=   0x000C0000    #   MODRM reg field defines MMX register
ADDRMETH_Q=   0x000D0000    #   MODRM defines MMX register or memory
ADDRMETH_R=   0x000E0000    #   MODRM mod field can only refer to register
ADDRMETH_S=   0x000F0000    #   MODRM reg field defines segment register
ADDRMETH_U=   0x00100000    #   MODRM reg field defines test register
ADDRMETH_V=   0x00110000    #   MODRM reg field defines XMM register
ADDRMETH_W=   0x00120000    #   MODRM defines XMM register or memory
ADDRMETH_X=   0x00130000    #   Memory addressed by DS:rSI
ADDRMETH_Y=   0x00140000    #   Memory addressd by ES:rDI

OPTYPE_a   = 0x01000000     # 2/4   two one-word operands in memory or two double-word operands in memory (operand-size attribute)   
OPTYPE_b   = 0x02000000     # 1     always 1 byte
OPTYPE_c   = 0x03000000     # 1/2   byte or word, depending on operand
OPTYPE_d   = 0x04000000     # 4     double-word
OPTYPE_dq  = 0x05000000     # 16    double quad-word
OPTYPE_p   = 0x06000000     # 4/6   32-bit or 48-bit pointer
OPTYPE_pi  = 0x07000000     # 8     quadword MMX register
OPTYPE_ps  = 0x08000000     # 16    128-bit single-precision float
OPTYPE_pd  = 0x08000000     # ??    should be a double-precision float?
OPTYPE_q   = 0x09000000     # 8     quad-word
OPTYPE_s   = 0x0A000000     # 6     6-byte pseudo descriptor
OPTYPE_ss  = 0x0B000000     # ??    Scalar of 128-bit single-precision float
OPTYPE_si  = 0x0C000000     # 4     Doubleword integer register
OPTYPE_sd  = 0x0C000000     #   ???  
OPTYPE_v   = 0x0D000000     # 2/4   word or double-word, depending on operand
OPTYPE_w   = 0x0E000000     # 2     always word
OPTYPE_z   = 0x0F000000     # 2/4   is this OPTYPE_z?  word for 16-bit operand size or doubleword for 32 or 64-bit operand-size

OPTYPE_fs= 0x10000000L      #   
OPTYPE_fd= 0x20000000L      #   
OPTYPE_fe= 0x30000000L      #   
OPTYPE_fb= 0x40000000L      #   
OPTYPE_fv= 0x50000000L      #   

# FIXME this should probably be a list rather than a dictionary

OPERSIZE = {
             0        : (2,4,8),           # We will only end up here on regs embedded in opcodes
             OPTYPE_a : (2,4,4),
             OPTYPE_b : (1,1,1),
             OPTYPE_c : (1,2,2),           # 1/2   byte or word, depending on operand
             OPTYPE_d : (4,4,4),           # 4     double-word
             OPTYPE_dq: (16,16,16),        # 16    double quad-word
             OPTYPE_p : (4,6,6),           # 4/6   32-bit or 48-bit pointer
             OPTYPE_pi: (8,8,8),           # 8     quadword MMX register
             OPTYPE_ps: (16,16,16),        # 16    128-bit single-precision float
             OPTYPE_pd: (16,16,16),        # ??    should be a double-precision float?
             OPTYPE_q : (8,8,8),           # 8     quad-word
             OPTYPE_s : (6,10,10),         # 6     6-byte pseudo descriptor
             OPTYPE_ss: (0,0,0),           # ??    Scalar of 128-bit single-precision float
             OPTYPE_si: (4,4,4),           # 4     Doubleword integer register
             OPTYPE_sd: (4,4,4),           #   ???
             OPTYPE_v : (2,4,8),           # 2/4   word or double-word, depending on operand
             OPTYPE_w : (2,2,2),           # 2     always word
             OPTYPE_z : (2,4,4),           #  word for 16-bit operand size or doubleword for 32 or 64-bit operand-size
             # Floating point crazyness FIXME these are mostly wrong
             OPTYPE_fs: (4,4,4),
             OPTYPE_fd: (8,8,8),
             OPTYPE_fe: (10,10,10),
             OPTYPE_fb: (10,10,10),
             OPTYPE_fv: (14,14,28),
}


INS_EXEC =               0x1000
INS_ARITH=               0x2000
INS_LOGIC=               0x3000
INS_STACK=               0x4000
INS_COND =               0x5000
INS_LOAD =               0x6000
INS_ARRAY=               0x7000
INS_BIT  =       	 0x8000
INS_FLAG =               0x9000
INS_FPU  =      	 0xA000
INS_TRAPS=               0xD000
INS_SYSTEM = 	     	 0xE000
INS_OTHER=               0xF000

INS_BRANCH  =    INS_EXEC | 0x01 
INS_BRANCHCC=    INS_EXEC | 0x02 
INS_CALL    =    INS_EXEC | 0x03
INS_CALLCC  =    INS_EXEC | 0x04 
INS_RET     =    INS_EXEC | 0x05 
INS_LOOP    =    INS_EXEC | 0x06 
                                                                                
INS_ADD=         INS_ARITH | 0x01
INS_SUB=         INS_ARITH | 0x02
INS_MUL=         INS_ARITH | 0x03
INS_DIV=         INS_ARITH | 0x04
INS_INC=         INS_ARITH | 0x05        
INS_DEC=         INS_ARITH | 0x06 
INS_SHL=         INS_ARITH | 0x07 
INS_SHR=         INS_ARITH | 0x08
INS_ROL=         INS_ARITH | 0x09
INS_ROR=         INS_ARITH | 0x0A

INS_AND=         INS_LOGIC | 0x01
INS_OR =         INS_LOGIC | 0x02
INS_XOR=         INS_LOGIC | 0x03
INS_NOT=         INS_LOGIC | 0x04
INS_NEG=         INS_LOGIC | 0x05
                                                                                
INS_PUSH=                INS_STACK | 0x01
INS_POP =        INS_STACK | 0x02
INS_PUSHREGS=    INS_STACK | 0x03 
INS_POPREGS=     INS_STACK | 0x04  
INS_PUSHFLAGS=   INS_STACK | 0x05 
INS_POPFLAGS=    INS_STACK | 0x06 
INS_ENTER=               INS_STACK | 0x07   
INS_LEAVE =              INS_STACK | 0x08

INS_TEST  =              INS_COND | 0x01
INS_CMP   =      INS_COND | 0x02
                                                                                
INS_MOV    =     INS_LOAD | 0x01
INS_MOVCC  =             INS_LOAD | 0x02
INS_XCHG   =             INS_LOAD | 0x03
INS_XCHGCC =     INS_LOAD | 0x04
INS_LEA    =     INS_LOAD | 0x05
                                                                                
INS_STRCMP  =    INS_ARRAY | 0x01
INS_STRLOAD =    INS_ARRAY | 0x02
INS_STRMOV  =    INS_ARRAY | 0x03
INS_STRSTOR =    INS_ARRAY | 0x04
INS_XLAT    =            INS_ARRAY | 0x05
                                                                                
INS_BITTEST =    INS_BIT | 0x01
INS_BITSET  =    INS_BIT | 0x02
INS_BITCLR  =    INS_BIT | 0x03

INS_CLEARCF  =   INS_FLAG | 0x01
INS_CLEARZF  =   INS_FLAG | 0x02 
INS_CLEAROF  =   INS_FLAG | 0x03
INS_CLEARDF  =   INS_FLAG | 0x04
INS_CLEARSF  =   INS_FLAG | 0x05 
INS_CLEARPF  =   INS_FLAG | 0x06 
INS_SETCF    =           INS_FLAG | 0x07
INS_SETZF    =           INS_FLAG | 0x08
INS_SETOF    =           INS_FLAG | 0x09
INS_SETDF    =           INS_FLAG | 0x0A
INS_SETSF    =           INS_FLAG | 0x0B
INS_SETPF    =           INS_FLAG | 0x0C
INS_TOGCF    =           INS_FLAG | 0x10 #/* toggle */
INS_TOGZF    =           INS_FLAG | 0x20
INS_TOGOF    =           INS_FLAG | 0x30
INS_TOGDF    =           INS_FLAG | 0x40
INS_TOGSF    =           INS_FLAG | 0x50
INS_TOGPF    =           INS_FLAG | 0x60

INS_TRAP  =              INS_TRAPS | 0x01  #/* generate trap */
INS_TRAPCC=      INS_TRAPS | 0x02          #/* conditional trap gen */
INS_TRET  =              INS_TRAPS | 0x03  #/* return from trap */
INS_BOUNDS=      INS_TRAPS | 0x04          #/* gen bounds trap */
INS_DEBUG =              INS_TRAPS | 0x05  #/* gen breakpoint trap */
INS_TRACE  =             INS_TRAPS | 0x06  #/* gen single step trap */
INS_INVALIDOP=   INS_TRAPS | 0x07          #     /* gen invalid instruction */
INS_OFLOW    =           INS_TRAPS | 0x08  #      /* gen overflow trap */
                                                                                
#/* INS_SYSTEM */
INS_HALT    =            INS_SYSTEM | 0x01 #               /* halt machine */
INS_IN      =    INS_SYSTEM | 0x02         #      /* input form port */
INS_OUT     =    INS_SYSTEM | 0x03         #      /* output to port */
INS_CPUID   =            INS_SYSTEM | 0x04 #              /* iden

INS_NOP     =    INS_OTHER | 0x01
INS_BCDCONV =    INS_OTHER | 0x02        #/* convert to/from BCD */
INS_SZCONV  =    INS_OTHER | 0x03        #/* convert size of operand */


OP_R=         0x001    
OP_W=         0x002 
OP_X=         0x004  
OP_UNK=       0x000  
OP_REG=       0x100   
OP_IMM=       0x200  
OP_REL=       0x300   
OP_ADDR=      0x400 
OP_EXPR=      0x500   
OP_PTR =      0x600 
OP_OFF =      0x700   

OP_SIGNED=    0x001000  
OP_STRING=    0x002000  
OP_CONST =    0x004000

# NOTE: These are junk and can't be used because
#       they overlap with the addressing modes.
OP_EXTRASEG=  0x010000 
OP_CODESEG =  0x020000
OP_STACKSEG=  0x030000
OP_DATASEG =  0x040000
OP_DATA1SEG=  0x050000
OP_DATA2SEG=  0x060000

ARG_NONE = 0
cpu_8086 =        0x00001000
cpu_80286=        0x00002000
cpu_80386=        0x00003000
cpu_80387=        0x00004000
cpu_80486=        0x00005000
cpu_PENTIUM=      0x00006000
cpu_PENTPRO=      0x00007000
cpu_PENTMMX=      0x00008000
cpu_PENTIUM2=     0x00009000
cpu_AMD64=        0x0000a000

x86_MAIN =0
x86_0F   =1
x86_80   =2

#import envi.archs.i386.regs as e_i386_regs
# Relative import priority...
import regs as e_i386_regs
                                                                                
"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodenane", op0Register, op1Register, op2Register)
"""
tbl32_Main = [
( 0, INS_ADD, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "add", 0, 0, 0),
( 0, INS_ADD, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "add", 0, 0, 0),
( 0, INS_ADD, ADDRMETH_G | OPTYPE_b | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "add", 0, 0, 0),
( 0, INS_ADD, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "add", 0, 0, 0),
( 0, INS_ADD, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "add", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_ADD, OP_REG | OP_W, ADDRMETH_I | OPTYPE_z | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "add", e_i386_regs.REG_EAX, 0, 0),  
(0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_ES, 0, 0),  
(0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_ES, 0, 0),  
( 0, INS_OR, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "or", 0, 0, 0),  
( 0, INS_OR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "or", 0, 0, 0),  
( 0, INS_OR, ADDRMETH_G | OPTYPE_b | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "or", 0, 0, 0),  
( 0, INS_OR, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "or", 0, 0, 0),  
( 0, INS_OR, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "or", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_OR, OP_REG | OP_W, ADDRMETH_I | OPTYPE_z | OP_R, ARG_NONE, cpu_80386, "or", e_i386_regs.REG_EAX, 0, 0),  
(0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_CS, 0, 0),  
(1, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  # 0x0f
# 0x10
( 0, INS_ADD, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "adc", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "adc", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_G | OPTYPE_b | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "adc", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "adc", 0, 0, 0),  
( 0, INS_ADD, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "adc", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_ADD, OP_REG | OP_W, ADDRMETH_I | OPTYPE_z | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "adc", e_i386_regs.REG_EAX, 0, 0),  
(0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_SS, 0, 0),  
(0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_SS, 0, 0),  
( 0, INS_SUB, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "sbb", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "sbb", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_G | OPTYPE_b | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "sbb", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "sbb", 0, 0, 0),  
( 0, INS_SUB, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "sbb", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_SUB, OP_REG | OP_W, ADDRMETH_I | OPTYPE_z | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "sbb", e_i386_regs.REG_EAX, 0, 0),  
(0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_DS, 0, 0),  
(0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_DS, 0, 0),  
# 0x20
( 0, INS_AND, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "and", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "and", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_G | OPTYPE_b | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "and", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "and", 0, 0, 0),  
( 0, INS_AND, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "and", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_AND, OP_REG | OP_W, ADDRMETH_I | OPTYPE_z | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "and", e_i386_regs.REG_EAX, 0, 0),  
( 0, INSTR_PREFIX, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(0, INS_BCDCONV, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "daa", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "sub", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "sub", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_G | OPTYPE_b | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "sub", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "sub", 0, 0, 0),  
( 0, INS_SUB, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "sub", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_SUB, OP_REG | OP_W, ADDRMETH_I | OPTYPE_z | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "sub", e_i386_regs.REG_EAX, 0, 0),  
( 0, INSTR_PREFIX, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(0, INS_BCDCONV, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "das", 0, 0, 0),  
# 0x30
( 0, INS_XOR, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "xor", 0, 0, 0),  
( 0, INS_XOR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "xor", 0, 0, 0),  
( 0, INS_XOR, ADDRMETH_G | OPTYPE_b | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "xor", 0, 0, 0),  
( 0, INS_XOR, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "xor", 0, 0, 0),  
( 0, INS_XOR, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "xor", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_XOR, OP_REG | OP_W, ADDRMETH_I | OPTYPE_z | OP_R, ARG_NONE, cpu_80386, "xor", e_i386_regs.REG_EAX, 0, 0),  
( 0, INSTR_PREFIX, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(0, INS_BCDCONV, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "aaa", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_E | OPTYPE_b | OP_R, ADDRMETH_G | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "cmp", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "cmp", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_G | OPTYPE_b | OP_R, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "cmp", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "cmp", 0, 0, 0),  
( 0, INS_CMP, OP_REG | OP_R, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "cmp", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_CMP, OP_REG | OP_R, ADDRMETH_I | OPTYPE_z | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "cmp", e_i386_regs.REG_EAX, 0, 0),  
( 0, INSTR_PREFIX, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(0, INS_BCDCONV, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "aas", 0, 0, 0),  
# 0x40
( 0, INS_INC, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "inc", e_i386_regs.REG_EAX, 0, 0),  
( 0, INS_INC, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "inc", e_i386_regs.REG_ECX, 0, 0),  
( 0, INS_INC, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "inc", e_i386_regs.REG_EDX, 0, 0),  
( 0, INS_INC, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "inc", e_i386_regs.REG_EBX, 0, 0),  
( 0, INS_INC, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "inc", e_i386_regs.REG_ESP, 0, 0),  
( 0, INS_INC, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "inc", e_i386_regs.REG_EBP, 0, 0),  
( 0, INS_INC, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "inc", e_i386_regs.REG_ESI, 0, 0),  
( 0, INS_INC, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "inc", e_i386_regs.REG_EDI, 0, 0),  

( 0, INS_DEC, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "dec", e_i386_regs.REG_EAX, 0, 0),  
( 0, INS_DEC, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "dec", e_i386_regs.REG_ECX, 0, 0),  
( 0, INS_DEC, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "dec", e_i386_regs.REG_EDX, 0, 0),  
( 0, INS_DEC, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "dec", e_i386_regs.REG_EBX, 0, 0),  
( 0, INS_DEC, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "dec", e_i386_regs.REG_ESP, 0, 0),  
( 0, INS_DEC, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "dec", e_i386_regs.REG_EBP, 0, 0),  
( 0, INS_DEC, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "dec", e_i386_regs.REG_ESI, 0, 0),  
( 0, INS_DEC, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "dec", e_i386_regs.REG_EDI, 0, 0),  
# 0x50
( 0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_EAX, 0, 0),  
( 0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_ECX, 0, 0),  
( 0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_EDX, 0, 0),  
( 0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_EBX, 0, 0),  
( 0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_ESP, 0, 0),  
( 0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_EBP, 0, 0),  
( 0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_ESI, 0, 0),  
( 0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_EDI, 0, 0),  

( 0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_EAX, 0, 0),
( 0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_ECX, 0, 0),
( 0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_EDX, 0, 0),
( 0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_EBX, 0, 0),
( 0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_ESP, 0, 0),
( 0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_EBP, 0, 0),
( 0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_ESI, 0, 0),
( 0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_EDI, 0, 0),
# 0x60
( 0, INS_PUSHREGS, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "pushad", 0, 0, 0),  
( 0, INS_POPREGS, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "popad", 0, 0, 0),  
( 0, INS_BOUNDS, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_M | OPTYPE_a | OP_R, ARG_NONE, cpu_80386, "bound", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_R, ADDRMETH_G | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "arpl", 0, 0, 0),  
( 0, INSTR_PREFIX, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
( 0, INSTR_PREFIX, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(44, INSTR_PREFIX, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  # 0x66
( 0, INSTR_PREFIX, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
( 0, INS_PUSH, ADDRMETH_I | OPTYPE_v | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_I | OP_SIGNED |OPTYPE_z | OP_R, cpu_80386, "imul", 0, 0, 0),  
(0, INS_PUSH, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_I |  OP_SIGNED | OP_R | OPTYPE_b, cpu_80386, "imul", 0, 0, 0),  
(0, INS_IN,  ADDRMETH_Y | OPTYPE_b | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "insb", 0, e_i386_regs.REG_EDX, 0),  
(0, INS_IN,  ADDRMETH_Y | OPTYPE_z | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "insd", 0, e_i386_regs.REG_EDX, 0),  
(0, INS_OUT,  OP_REG | OP_W, ADDRMETH_X | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "outsb", e_i386_regs.REG_EDX, 0, 0),  
(0, INS_OUT,  OP_REG | OP_W, ADDRMETH_X | OPTYPE_z | OP_R, ARG_NONE, cpu_80386, "outsd", e_i386_regs.REG_EDX, 0, 0),  
# 0x70
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jo", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jno", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jc", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jnc", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jz", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jnz", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jbe", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "ja", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "js", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jns", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jpe", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jpo", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jl", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jge", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jle", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jg", 0, 0, 0),  
# 0x80
(2, 0, ADDRMETH_E | OPTYPE_b, ADDRMETH_I | OPTYPE_b, ARG_NONE,cpu_80386, 0, 0, 0, 0),  
(3, 0, ADDRMETH_E | OPTYPE_v, ADDRMETH_I | OPTYPE_v, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(4, 0, ADDRMETH_E | OPTYPE_v, ADDRMETH_I | OPTYPE_b, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(5, 0,  ADDRMETH_E | OPTYPE_v, ADDRMETH_I | OPTYPE_b, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
( 0, INS_TEST, ADDRMETH_E | OPTYPE_b | OP_R, ADDRMETH_G | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "test", 0, 0, 0),  
( 0, INS_TEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "test", 0, 0, 0),  
( 0, INS_XCHG, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_W, ARG_NONE, cpu_80386, "xchg", 0, 0, 0),  
( 0, INS_XCHG, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_W, ARG_NONE, cpu_80386, "xchg", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_b | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_E | OPTYPE_w | OP_W, ADDRMETH_S | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_LEA, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "lea", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_S | OPTYPE_w | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_POP, ADDRMETH_E | OPTYPE_v | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", 0, 0, 0),  
# 0x90
(0, INS_NOP, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "nop", 0, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, OP_REG | OP_W, ARG_NONE, cpu_80386, "xchg", e_i386_regs.REG_EAX, e_i386_regs.REG_ECX, 0),  
( 0, INS_XCHG, OP_REG | OP_W, OP_REG | OP_W, ARG_NONE, cpu_80386, "xchg", e_i386_regs.REG_EAX, e_i386_regs.REG_EDX, 0),  
( 0, INS_XCHG, OP_REG | OP_W, OP_REG | OP_W, ARG_NONE, cpu_80386, "xchg", e_i386_regs.REG_EAX, e_i386_regs.REG_EBX, 0),  
( 0, INS_XCHG, OP_REG | OP_W, OP_REG | OP_W, ARG_NONE, cpu_80386, "xchg", e_i386_regs.REG_EAX, e_i386_regs.REG_ESP, 0),  
( 0, INS_XCHG, OP_REG | OP_W, OP_REG | OP_W, ARG_NONE, cpu_80386, "xchg", e_i386_regs.REG_EAX, e_i386_regs.REG_EBP, 0),  
( 0, INS_XCHG, OP_REG | OP_W, OP_REG | OP_W, ARG_NONE, cpu_80386, "xchg", e_i386_regs.REG_EAX, e_i386_regs.REG_ESI, 0),  
( 0, INS_XCHG, OP_REG | OP_W, OP_REG | OP_W, ARG_NONE, cpu_80386, "xchg", e_i386_regs.REG_EAX, e_i386_regs.REG_EDI, 0),  
( 0, INS_SZCONV, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "cwde", 0, 0, 0),  
( 0, INS_SZCONV, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "cdq", 0, 0, 0),  
( 0, INS_CALL, ADDRMETH_A | OPTYPE_p | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "callf", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "wait", 0, 0, 0),  
( 0, INS_PUSHFLAGS, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "pushfd", 0, 0, 0),  
( 0, INS_POPFLAGS, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "popfd", 0, 0, 0),  
(0, INS_MOV, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "sahf", 0, 0, 0),  
(0, INS_MOV, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "lahf", 0, 0, 0),  
# 0xa0
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_O | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_O | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_EAX, 0, 0),  
( 0, INS_MOV, ADDRMETH_O | OPTYPE_b | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "mov", 0, e_i386_regs.REG_AL, 0),  
( 0, INS_MOV, ADDRMETH_O | OPTYPE_v | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "mov", 0, e_i386_regs.REG_EAX, 0),  
(0, INS_STRMOV, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "movsb", 0, 0, 0),  
( 0, INS_STRMOV, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "movsd", 0, 0, 0),  
(0, INS_STRCMP, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "cmpsb", 0, 0, 0),  
( 0, INS_STRCMP, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "cmpsd", 0, 0, 0),  
( 0, INS_TEST, OP_REG | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "test", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_TEST, OP_REG | OP_R, ADDRMETH_I | OPTYPE_z | OP_R, ARG_NONE, cpu_80386, "test", e_i386_regs.REG_EAX, 0, 0),  
(0, INS_STRSTOR, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "stosb", 0, 0, 0),  
( 0, INS_STRSTOR, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "stosd", 0, 0, 0),  
(0, INS_STRLOAD, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "lodsb", 0, 0, 0),  
( 0, INS_STRLOAD, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "lodsd", 0, 0, 0),  
(0, INS_STRCMP, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "scasb", 0, 0, 0),  
( 0, INS_STRCMP, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "scasd", 0, 0, 0),  
# 0xb0
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_CL, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_DL, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_BL, 0, 0),  
# FIXME 64
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_AH, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_CH, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_DH, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_BH, 0, 0),  

( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_EAX, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_ECX, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_EDX, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_EBX, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_ESP, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_EBP, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_ESI, 0, 0),  
( 0, INS_MOV, OP_REG | OP_W, ADDRMETH_I | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "mov", e_i386_regs.REG_EDI, 0, 0),  
# 0xc0
(6, 0,  ADDRMETH_E | OPTYPE_b, ADDRMETH_I | OPTYPE_b, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(7, 0,  ADDRMETH_E | OPTYPE_v, ADDRMETH_I | OPTYPE_b, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
( 0, INS_RET, ADDRMETH_I | OPTYPE_w | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "ret", 0, 0, 0),  
( 0, INS_RET, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "ret", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p | OP_R, ARG_NONE, cpu_80386, "les", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p | OP_R, ARG_NONE, cpu_80386, "lds", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_z | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_ENTER, ADDRMETH_I | OPTYPE_w | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "enter", 0, 0, 0),  
(0, INS_LEAVE, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "leave", 0, 0, 0),  
( 0, INS_RET, ADDRMETH_I | OPTYPE_w | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "retf", 0, 0, 0),  
( 0, INS_RET, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "retf", 0, 0, 0),  
(0, INS_DEBUG, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "int3", 0, 0, 0),  
( 0, INS_TRAP, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "int", 0, 0, 0),  
(0, INS_OFLOW, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "into", 0, 0, 0),  
( 0, INS_TRET, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "iret", 0, 0, 0),  
# 0xd0
(8, 0,  ADDRMETH_E | OPTYPE_b, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 1, 0),  
(9, 0, ADDRMETH_E | OPTYPE_v, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 1, 0),  
(10, 0, ADDRMETH_E | OPTYPE_b, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, e_i386_regs.REG_CL, 0),  
(11, 0, ADDRMETH_E | OPTYPE_v, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, e_i386_regs.REG_CL, 0),  
( 0, INS_BCDCONV, ADDRMETH_I | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "aam", 0, 0, 0),  
( 0, INS_BCDCONV, ADDRMETH_I | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "aad", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(0, INS_XLAT, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "xlat", 0, 0, 0),  
(26, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(28, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(30, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(32, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(34, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(36, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(38, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(40, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
# 0xf0
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "loopnz", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "loopz", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "loop", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jecxz", 0, 0, 0),  
( 0, INS_IN, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "in", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_IN, OP_REG | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "in", e_i386_regs.REG_EAX, 0, 0),  
( 0, INS_OUT, ADDRMETH_I | OPTYPE_b | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "out", 0, e_i386_regs.REG_AL, 0),  
( 0, INS_OUT, ADDRMETH_I | OPTYPE_b | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "out", 0, e_i386_regs.REG_EAX, 0),  
( 0, INS_CALL, ADDRMETH_J | OPTYPE_v | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "call", 0, 0, 0),  
( 0, INS_BRANCH, ADDRMETH_J | OPTYPE_v | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jmp", 0, 0, 0),  
( 0, INS_BRANCH, ADDRMETH_A | OPTYPE_p | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jmp", 0, 0, 0),  
( 0, INS_BRANCH, ADDRMETH_J | OPTYPE_b | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jmp", 0, 0, 0),  
(0, INS_IN, OP_REG | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "in", e_i386_regs.REG_AL, e_i386_regs.REG_DX, 0),  
( 0, INS_IN, OP_REG | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "in", e_i386_regs.REG_EAX, e_i386_regs.REG_DX, 0),  
(0, INS_OUT, OP_REG | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "out", e_i386_regs.REG_DX, e_i386_regs.REG_AL, 0),  
( 0, INS_OUT, OP_REG | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "out", e_i386_regs.REG_DX, e_i386_regs.REG_EAX, 0),  
( 0, INSTR_PREFIX, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "lock:", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
( 45, INSTR_PREFIX, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "repne:", 0, 0, 0),  
( 46, INSTR_PREFIX, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "rep:", 0, 0, 0),  
(0, INS_HALT, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "hlt", 0, 0, 0),  
(0, INS_TOGCF, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "cmc", 0, 0, 0),  
(12, 0,  ADDRMETH_E | OPTYPE_b, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(13, 0, ADDRMETH_E | OPTYPE_v, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(0, INS_CLEARCF, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "clc", 0, 0, 0),  
(0, INS_SETCF, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "stc", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "cli", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "sti", 0, 0, 0),  
(0, INS_CLEARDF, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "cld", 0, 0, 0),  
(0, INS_SETDF, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "std", 0, 0, 0),  
(14, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(15, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0   )
]



"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_0F = [
# 0f00
(16, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(17, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "lar", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "lsl", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_AMD64, "syscall", 0, 0, 0),
( 0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "clts", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_AMD64, "sysret", 0, 0, 0),
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80486, "invd", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80486, "wbinvd", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "ud2", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_E | OPTYPE_v, ARG_NONE, ARG_NONE, cpu_80386, "NOP", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
# 0f10
( 0, INS_MOV, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movups", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_W | OPTYPE_ps | OP_W, ADDRMETH_V | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movups", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_V | OPTYPE_q | OP_W, ADDRMETH_M | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movlps", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_M | OPTYPE_q | OP_W, ADDRMETH_V | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movlps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "unpcklps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "unpckhps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_q | OP_W, ADDRMETH_M | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movhps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_M | OPTYPE_q | OP_W, ADDRMETH_V | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movhps", 0, 0, 0),  
(18, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_E | OPTYPE_v, ARG_NONE, ARG_NONE, cpu_80386, "NOP", 0, 0, 0),  
# 0f20
( 0, INS_MOV, ADDRMETH_R | OPTYPE_d | OP_W, ADDRMETH_C | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_R | OPTYPE_d | OP_W, ADDRMETH_D | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_C | OPTYPE_d | OP_W, ADDRMETH_R | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_D | OPTYPE_d | OP_W, ADDRMETH_R | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movaps", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_W | OPTYPE_ps | OP_W, ADDRMETH_V | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movaps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_R, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "cvtpi2ps", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_M | OPTYPE_ps | OP_W, ADDRMETH_V | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movntps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_Q | OPTYPE_q | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "cvttps2pi", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_Q | OPTYPE_q | OP_R, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "cvtps2pi", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ss | OP_W, ADDRMETH_W | OPTYPE_ss | OP_R, ARG_NONE, cpu_PENTIUM2, "ucomiss", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_W, ARG_NONE, cpu_PENTIUM2, "comiss", 0, 0, 0),  
# 0f30
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM, "wrmsr", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM, "rdtsc", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM, "rdmsr", 0, 0, 0),  
(0, INS_OTHER, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTPRO, "rdpmc", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "sysenter", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "sysexit", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  # 3-byte escape 28
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  # 3-byte escape 2a
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
# 0f40
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovo", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovno", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovc", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovnc", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovz", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovnz", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovbe", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmova", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovs", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovns", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovpe", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovpo", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovl", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovge", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovle", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovg", 0, 0, 0),  
# 0f50
( 0, INS_MOV, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_U | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movmskps", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "sqrtps", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "rsqrtps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "rcpps", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "andps", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "andnps", 0, 0, 0),  
( 0, INS_OR, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "orps", 0, 0, 0),  
( 0, INS_XOR, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "xorps", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "addps", 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_V | OPTYPE_ps | OP_R, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "mulps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "cvtps2pd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_dq |OP_R, ARG_NONE, cpu_PENTIUM2, "cvtdq2ps", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "subps", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "minps", 0, 0, 0),  
( 0, INS_DIV, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "divps", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "maxps", 0, 0, 0),  
# 0f60
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpcklbw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpcklwd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpckldq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "packsswb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpgtb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpgtw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpgtd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "packuswb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpckhbw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpckhwd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpckhdq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "packssdw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_P | OPTYPE_d | OP_W, ADDRMETH_E | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "movd", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "movq", 0, 0, 0),  
# 0f70
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ADDRMETH_I |  OPTYPE_b | OP_R, cpu_PENTIUM2, "pshufw", 0, 0, 0),  
(19, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  
(20, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  
(21, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpeqb", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpeqw", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpeqd", 0, 0, 0),  
(0, INS_OTHER, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, "emms", 0, 0, 0),  
(0, INS_SYSTEM, ADDRMETH_E | OPTYPE_d | OP_W, ADDRMETH_G | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTIUM2, "vmread", 0, 0, 0),  
(0, INS_SYSTEM, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_E | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTIUM2, "vmwrite", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_E | OPTYPE_d | OP_W, ADDRMETH_P | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "movd", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_Q | OPTYPE_q | OP_W, ADDRMETH_P | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "movq", 0, 0, 0),  
# 0f80
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jo", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jno", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jc", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jnc", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jz", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jnz", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jbe", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "ja", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "js", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jns", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jpe", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jpo", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jl", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jge", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jle", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jg", 0, 0, 0),  
# 0f90
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "seto", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setno", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setc", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setnc", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setz", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setnz", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setbe", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "seta", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "sets", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setns", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setpe", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setpo", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setl", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setge", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setle", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setg", 0, 0, 0),  
# 0fa0
(0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_FS, 0, 0),  
(0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_FS, 0, 0),  
(0, INS_CPUID, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80486, "cpuid", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bt", 0, 0, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_80386, "shld", 0, 0, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, OP_R | OP_REG, cpu_80386, "shld", 0, 0, e_i386_regs.REG_CL), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_GS, 0, 0),  
(0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_GS, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "rsm", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bts", 0, 0, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_80386, "shrd", 0, 0, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, OP_R | OP_REG, cpu_80386, "shrd", 0, 0, e_i386_regs.REG_CL), 
(22, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, 0, 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "imul", 0, 0, 0),  
# 0fb0
( 0, INS_XCHGCC, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_W, ARG_NONE, cpu_80486, "cmpxchg", 0, 0, 0),  
( 0, INS_XCHGCC, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_W, ARG_NONE, cpu_80486, "cmpxchg", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p | OP_R, ARG_NONE, cpu_80386, "lss", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "btr", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p| OP_R, ARG_NONE, cpu_80386, "lfs", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p | OP_R, ARG_NONE, cpu_80386, "lgs", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "movzx", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "movzx", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "ud1", 0, 0, 0),  #### GROUP 10?
(23, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "btc", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_G | OPTYPE_v | OP_R | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bsf", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_G | OPTYPE_v | OP_R | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bsr", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "movsx", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "movsx", 0, 0, 0),  
# 0fc0
( 0, INS_ADD, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_W, ARG_NONE, cpu_80486, "xadd", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v, ARG_NONE, cpu_80486, "xadd", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_V | OPTYPE_ps| OP_W, ADDRMETH_W | OPTYPE_ps| OP_W, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "cmpps", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_M | OPTYPE_q | OP_W, ADDRMETH_G | OPTYPE_q |OP_R, ARG_NONE, cpu_PENTIUM2, "movnti", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "pinsrw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_N | OPTYPE_q | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "pextrw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "shufps", 0, 0, 0),  
(24, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  # group 9
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EAX, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_ECX, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EDX, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EBX, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_ESP, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EBP, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_ESI, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EDI, 0, 0),  
# 0fd0
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psrlw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psrld", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psrlq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pmullw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_N | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pmovmskb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubusb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubusw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pminub", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pand", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddusb", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddusw", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pmaxub", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pandn", 0, 0, 0),  
# 0ff0
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pavgb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psraw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psrad", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pavgw", 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pmulhuw", 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pmulhw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_M | OPTYPE_dq | OP_W, ADDRMETH_V | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "movntq", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubsb", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubsw", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pminsw", 0, 0, 0),  
( 0, INS_OR, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "por", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddsb", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddsw", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pmaxsw", 0, 0, 0),  
( 0, INS_XOR, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pxor", 0, 0, 0),  
    (0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psllw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pslld", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psllq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pmuludq", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pmaddwd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "psadbw", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_N | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "maskmovq", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubb", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubw", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubd", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubq", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddb", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddw", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddd", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ) 
]

"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_660F = [
(16, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),
(17, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),
( 0, INS_SYSTEM, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "lar", 0, 0, 0),
( 0, INS_SYSTEM, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "lsl", 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
( 0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "clts", 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80486, "invd", 0, 0, 0),
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80486, "wbinvd", 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "ud2", 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
( 0, INS_OTHER, ADDRMETH_E | OPTYPE_v, ARG_NONE, ARG_NONE, cpu_80386, "NOP", 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
    ( 0, INS_MOV, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "movupd", 0, 0, 0),  #
( 0, INS_MOV, ADDRMETH_W | OPTYPE_pd | OP_W, ADDRMETH_V | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "movupd", 0, 0, 0),  #
( 0, INS_MOV, ADDRMETH_V | OPTYPE_q | OP_W, ADDRMETH_M | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movlpd", 0, 0, 0),  #
( 0, INS_MOV, ADDRMETH_M | OPTYPE_q | OP_W, ADDRMETH_V | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movlpd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "unpcklpd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "unpckhpd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_q | OP_W, ADDRMETH_M | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movhpd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_M | OPTYPE_q | OP_W, ADDRMETH_V | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movhpd", 0, 0, 0),  #
(18, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_E | OPTYPE_v, ARG_NONE, ARG_NONE, cpu_80386, "NOP", 0, 0, 0),
    ( 0, INS_MOV, ADDRMETH_R | OPTYPE_d | OP_W, ADDRMETH_C | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),
( 0, INS_MOV, ADDRMETH_R | OPTYPE_d | OP_W, ADDRMETH_D | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),
( 0, INS_MOV, ADDRMETH_C | OPTYPE_d | OP_W, ADDRMETH_R | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),
( 0, INS_MOV, ADDRMETH_D | OPTYPE_d | OP_W, ADDRMETH_R | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "movapd", 0, 0, 0),  #
( 0, INS_MOV, ADDRMETH_W | OPTYPE_pd | OP_W, ADDRMETH_V | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "movapd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_pd | OP_R, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "cvtpi2pd", 0, 0, 0),  #
( 0, INS_MOV, ADDRMETH_M | OPTYPE_pd | OP_W, ADDRMETH_V | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "movntpd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_Q | OPTYPE_dq | OP_R, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "cvttpd2pi", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_Q | OPTYPE_dq | OP_R, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "cvtpd2pi", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_sd | OP_W, ADDRMETH_W | OPTYPE_sd | OP_R, ARG_NONE, cpu_PENTIUM2, "ucomisd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_sd | OP_W, ARG_NONE, cpu_PENTIUM2, "comisd", 0, 0, 0),  #
    (0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM, "wrmsr", 0, 0, 0),
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM, "rdtsc", 0, 0, 0),
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM, "rdmsr", 0, 0, 0),
(0, INS_OTHER, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTPRO, "rdpmc", 0, 0, 0),
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "sysenter", 0, 0, 0),
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "sysexit", 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  # 3-byte escape 28
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  # 3-byte escape 2a
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
    ( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovo", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovno", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovc", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovnc", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovz", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovnz", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovbe", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmova", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovs", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovns", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovpe", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovpo", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovl", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovge", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovle", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovg", 0, 0, 0),
    ( 0, INS_MOV, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_U | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "movmskpd", 0, 0, 0),  #
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "sqrtpd", 0, 0, 0),  #
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "rsqrtpd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "rcppd", 0, 0, 0),  #
( 0, INS_AND, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "andpd", 0, 0, 0),  #
( 0, INS_AND, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "andnpd", 0, 0, 0),  #
( 0, INS_OR, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "orpd", 0, 0, 0),  #
( 0, INS_XOR, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "xorpd", 0, 0, 0),  #
( 0, INS_ADD, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "addpd", 0, 0, 0),  #
( 0, INS_MUL, ADDRMETH_V | OPTYPE_pd | OP_R, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "mulpd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_pd | OP_R, ADDRMETH_Q | OPTYPE_q, ARG_NONE, 0, "cvtpd2pd", 0, 0, 0),  #
( 0, INS_MOV, ADDRMETH_M | OPTYPE_pd, ADDRMETH_V | OPTYPE_pd, ARG_NONE, 0, "movntpd", 0, 0, 0),  #
( 0, INS_SUB, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "subpd", 0, 0, 0),  #
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "minpd", 0, 0, 0),  #
( 0, INS_DIV, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "divpd", 0, 0, 0),  #
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTIUM2, "maxpd", 0, 0, 0),  #
    ( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "punpcklbw", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_Q | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "punpcklwd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_Q | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "punpckldq", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_Q | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "packsswb", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_Q | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpgtb", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_Q | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpgtw", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_Q | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpgtd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_Q | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "packuswb", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_dq | OP_W, ADDRMETH_Q | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "punpckhbw", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_dq | OP_W, ADDRMETH_Q | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "punpckhwd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_dq | OP_W, ADDRMETH_Q | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "punpckhdq", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_dq | OP_W, ADDRMETH_Q | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "packssdw", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "punpcklqdq", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "punpckhqdq", 0, 0, 0),  #
#VISI
( 0, INS_MOV, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_E | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "movd", 0, 0, 0),  #
( 0, INS_MOV, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_E | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "movq", 0, 0, 0),  # FIXME HORKED
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ADDRMETH_I |  OPTYPE_b | OP_R, cpu_PENTIUM2, "pshufd", 0, 0, 0),  #
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  
(54, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  # 66 0f 73
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpeqb", 0, 0, 0),  #
( 0, INS_CMP, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpeqw", 0, 0, 0),  #
( 0, INS_CMP, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpeqd", 0, 0, 0),  #
(0, INS_OTHER, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, "emms", 0, 0, 0),
(0, INS_SYSTEM, ADDRMETH_E | OPTYPE_d | OP_W, ADDRMETH_G | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTIUM2, "vmread", 0, 0, 0),
(0, INS_SYSTEM, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_E | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTIUM2, "vmwrite", 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTMMX, "haddpd", 0, 0, 0),  #
( 0, INS_MOV, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTMMX, "hsubpd", 0, 0, 0),  #
( 0, INS_MOV, ADDRMETH_E | OPTYPE_d | OP_W, ADDRMETH_V | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "movd", 0, 0, 0),  #
( 0, INS_MOV, ADDRMETH_Q | OPTYPE_q | OP_W, ADDRMETH_P | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "movq", 0, 0, 0),

( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jo", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jno", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jc", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jnc", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jz", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jnz", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jbe", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "ja", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "js", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jns", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jpe", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jpo", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jl", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jge", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jle", 0, 0, 0),
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jg", 0, 0, 0),
    ( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "seto", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setno", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setc", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setnc", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setz", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setnz", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setbe", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "seta", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "sets", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setns", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setpe", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setpo", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setl", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setge", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setle", 0, 0, 0),
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setg", 0, 0, 0),
    (0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_FS, 0, 0),
(0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_FS, 0, 0),
(0, INS_CPUID, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80486, "cpuid", 0, 0, 0),
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bt", 0, 0, 0),
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_80386, "shld", 0, 0, 0),
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, OP_R | OP_REG, cpu_80386, "shld", 0, 0, e_i386_regs.REG_CL),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_GS, 0, 0),
(0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_GS, 0, 0),
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "rsm", 0, 0, 0),
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bts", 0, 0, 0),
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_80386, "shrd", 0, 0, 0),
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, OP_R | OP_REG, cpu_80386, "shrd", 0, 0, e_i386_regs.REG_CL),
(22, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, 0, 0, 0, 0),
( 0, INS_MUL, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "imul", 0, 0, 0),
    ( 0, INS_XCHGCC, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_W, ARG_NONE, cpu_80486, "cmpxchg", 0, 0, 0),
( 0, INS_XCHGCC, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_W, ARG_NONE, cpu_80486, "cmpxchg", 0, 0, 0),
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p | OP_R, ARG_NONE, cpu_80386, "lss", 0, 0, 0),
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "btr", 0, 0, 0),
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p| OP_R, ARG_NONE, cpu_80386, "lfs", 0, 0, 0),
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p | OP_R, ARG_NONE, cpu_80386, "lgs", 0, 0, 0),
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "movzx", 0, 0, 0),
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "movzx", 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "ud1", 0, 0, 0),  #### GROUP 10?
(23, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "btc", 0, 0, 0),
( 0, INS_BITTEST, ADDRMETH_G | OPTYPE_v | OP_R | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bsf", 0, 0, 0),
( 0, INS_BITTEST, ADDRMETH_G | OPTYPE_v | OP_R | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bsr", 0, 0, 0),
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "movsx", 0, 0, 0),
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "movsx", 0, 0, 0),
    ( 0, INS_ADD, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_W, ARG_NONE, cpu_80486, "xadd", 0, 0, 0),
( 0, INS_ADD, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v, ARG_NONE, cpu_80486, "xadd", 0, 0, 0),
( 0, INS_CMP, ADDRMETH_V | OPTYPE_pd| OP_W, ADDRMETH_W | OPTYPE_pd| OP_W, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "cmppd", 0, 0, 0),  #
( 0, INS_MOV, ADDRMETH_M | OPTYPE_q | OP_W, ADDRMETH_G | OPTYPE_q |OP_R, ARG_NONE, cpu_PENTIUM2, "movnti", 0, 0, 0),
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "pinsrw", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_U | OPTYPE_dq | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "pextrw", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "shufps", 0, 0, 0),  #
(47, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  # 660FC7 table #
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EAX, 0, 0),
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_ECX, 0, 0),
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EDX, 0, 0),
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EBX, 0, 0),
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_ESP, 0, 0),
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EBP, 0, 0),
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_ESI, 0, 0),
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EDI, 0, 0),
    ( 0, INS_ADD, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTMMX, "addsubpd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psrlw", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psrld", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psrlq", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "paddq", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pmullw", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_W | OPTYPE_q | OP_W, ADDRMETH_V | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "movq", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_U | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "pmovmskb", 0, 0, 0), #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psubusb", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psubusw", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "pminub", 0, 0, 0),  #
( 0, INS_AND, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pand", 0, 0, 0),  #
( 0, INS_ADD, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "paddusb", 0, 0, 0),  #
( 0, INS_ADD, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "paddusw", 0, 0, 0),  #
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "pmaxub", 0, 0, 0),  #
( 0, INS_AND, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pandn", 0, 0, 0),  #
    ( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "pavgb", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psraw", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psrad", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "pavgw", 0, 0, 0),  #
( 0, INS_MUL, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "pmulhuw", 0, 0, 0),  #
( 0, INS_MUL, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pmulhw", 0, 0, 0),  #
( 0, INS_MUL, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_pd | OP_R, ARG_NONE, cpu_PENTMMX, "cvttpd2dq", 0, 0, 0),  #
( 0, INS_MOV, ADDRMETH_M | OPTYPE_dq | OP_W, ADDRMETH_V | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "movntdq", 0, 0, 0),  #
( 0, INS_SUB, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psubsb", 0, 0, 0),  #
( 0, INS_SUB, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psubsw", 0, 0, 0),  #
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "pminsw", 0, 0, 0),  #
( 0, INS_OR, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "por", 0, 0, 0),  #
( 0, INS_ADD, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "paddsb", 0, 0, 0),  #
( 0, INS_ADD, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "paddsw", 0, 0, 0),  #
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "pmaxsw", 0, 0, 0),  #
( 0, INS_XOR, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pxor", 0, 0, 0),  #
    (0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psllw", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pslld", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psllq", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pmuludq", 0, 0, 0),  #
( 0, INS_ADD, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "pmaddwd", 0, 0, 0),  #
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "psadbw", 0, 0, 0),  #
( 0, INS_MOV, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_U | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "maskmovq", 0, 0, 0),  #
( 0, INS_SUB, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psubb", 0, 0, 0),  #
( 0, INS_SUB, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psubw", 0, 0, 0),  #
( 0, INS_SUB, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psubd", 0, 0, 0),  #
( 0, INS_SUB, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "psubq", 0, 0, 0),  #
( 0, INS_ADD, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "paddb", 0, 0, 0),  #
( 0, INS_ADD, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "paddw", 0, 0, 0),  #
( 0, INS_ADD, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_W | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTMMX, "paddd", 0, 0, 0),  #
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ) 
]

"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_F20F = [
(16, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(17, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "lar", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "lsl", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "clts", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80486, "invd", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80486, "wbinvd", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "ud2", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_E | OPTYPE_v, ARG_NONE, ARG_NONE, cpu_80386, "NOP", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
    ( 0, INS_MOV, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movups", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_W | OPTYPE_ps | OP_W, ADDRMETH_V | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movups", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_V | OPTYPE_q | OP_W, ADDRMETH_M | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movlps", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_M | OPTYPE_q | OP_W, ADDRMETH_V | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movlps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "unpcklps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "unpckhps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_q | OP_W, ADDRMETH_M | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movhps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_M | OPTYPE_q | OP_W, ADDRMETH_V | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movhps", 0, 0, 0),  
(18, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_E | OPTYPE_v, ARG_NONE, ARG_NONE, cpu_80386, "NOP", 0, 0, 0),  
    ( 0, INS_MOV, ADDRMETH_R | OPTYPE_d | OP_W, ADDRMETH_C | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_R | OPTYPE_d | OP_W, ADDRMETH_D | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_C | OPTYPE_d | OP_W, ADDRMETH_R | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_D | OPTYPE_d | OP_W, ADDRMETH_R | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movaps", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_W | OPTYPE_ps | OP_W, ADDRMETH_V | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movaps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_R, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "cvtpi2ps", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_M | OPTYPE_ps | OP_W, ADDRMETH_V | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movntps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_Q | OPTYPE_q | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "cvttps2pi", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_Q | OPTYPE_q | OP_R, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "cvtps2pi", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ss | OP_W, ADDRMETH_W | OPTYPE_ss | OP_R, ARG_NONE, cpu_PENTIUM2, "ucomiss", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_W, ARG_NONE, cpu_PENTIUM2, "comiss", 0, 0, 0),  
    (0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM, "wrmsr", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM, "rdtsc", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM, "rdmsr", 0, 0, 0),  
(0, INS_OTHER, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTPRO, "rdpmc", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "sysenter", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "sysexit", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  # 3-byte escape 28
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  # 3-byte escape 2a
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
    ( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovo", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovno", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovc", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovnc", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovz", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovnz", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovbe", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmova", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovs", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovns", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovpe", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovpo", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovl", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovge", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovle", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovg", 0, 0, 0),  
    ( 0, INS_MOV, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_U | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movmskps", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "sqrtps", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "rsqrtps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "rcpps", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "andps", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "andnps", 0, 0, 0),  
( 0, INS_OR, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "orps", 0, 0, 0),  
( 0, INS_XOR, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "xorps", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "addps", 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_V | OPTYPE_ps | OP_R, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "mulps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "cvtps2pd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_dq |OP_R, ARG_NONE, cpu_PENTIUM2, "cvtdq2ps", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "subps", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "minps", 0, 0, 0),  
( 0, INS_DIV, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "divps", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "maxps", 0, 0, 0),  
    ( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpcklbw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpcklwd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpckldq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "packsswb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpgtb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpgtw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpgtd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "packuswb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpckhbw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpckhwd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpckhdq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "packssdw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_P | OPTYPE_d | OP_W, ADDRMETH_E | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "movd", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "movq", 0, 0, 0),  
    ( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ADDRMETH_I |  OPTYPE_b | OP_R, cpu_PENTIUM2, "pshufw", 0, 0, 0),  
(19, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  
(20, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  
(21, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpeqb", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpeqw", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpeqd", 0, 0, 0),  
(0, INS_OTHER, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, "emms", 0, 0, 0),  
(0, INS_SYSTEM, ADDRMETH_E | OPTYPE_d | OP_W, ADDRMETH_G | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTIUM2, "vmread", 0, 0, 0),  
(0, INS_SYSTEM, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_E | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTIUM2, "vmwrite", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_E | OPTYPE_d | OP_W, ADDRMETH_P | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "movd", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_Q | OPTYPE_q | OP_W, ADDRMETH_P | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "movq", 0, 0, 0),  
    ( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jo", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jno", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jc", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jnc", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jz", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jnz", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jbe", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "ja", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "js", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jns", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jpe", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jpo", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jl", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jge", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jle", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jg", 0, 0, 0),  
    ( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "seto", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setno", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setc", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setnc", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setz", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setnz", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setbe", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "seta", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "sets", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setns", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setpe", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setpo", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setl", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setge", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setle", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setg", 0, 0, 0),  
    (0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_FS, 0, 0),  
(0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_FS, 0, 0),  
(0, INS_CPUID, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80486, "cpuid", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bt", 0, 0, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_80386, "shld", 0, 0, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, OP_R | OP_REG, cpu_80386, "shld", 0, 0, e_i386_regs.REG_CL), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_GS, 0, 0),  
(0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_GS, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "rsm", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bts", 0, 0, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_80386, "shrd", 0, 0, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, OP_R | OP_REG, cpu_80386, "shrd", 0, 0, e_i386_regs.REG_CL), 
(22, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, 0, 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "imul", 0, 0, 0),  
    ( 0, INS_XCHGCC, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_W, ARG_NONE, cpu_80486, "cmpxchg", 0, 0, 0),  
( 0, INS_XCHGCC, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_W, ARG_NONE, cpu_80486, "cmpxchg", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p | OP_R, ARG_NONE, cpu_80386, "lss", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "btr", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p| OP_R, ARG_NONE, cpu_80386, "lfs", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p | OP_R, ARG_NONE, cpu_80386, "lgs", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "movzx", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "movzx", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "ud1", 0, 0, 0),  #### GROUP 10?
(23, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "btc", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_G | OPTYPE_v | OP_R | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bsf", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_G | OPTYPE_v | OP_R | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bsr", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "movsx", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "movsx", 0, 0, 0),  
    ( 0, INS_ADD, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_W, ARG_NONE, cpu_80486, "xadd", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v, ARG_NONE, cpu_80486, "xadd", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_V | OPTYPE_ps| OP_W, ADDRMETH_W | OPTYPE_ps| OP_W, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "cmpps", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_M | OPTYPE_q | OP_W, ADDRMETH_G | OPTYPE_q |OP_R, ARG_NONE, cpu_PENTIUM2, "movnti", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "pinsrw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_N | OPTYPE_q | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "pextrw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "shufps", 0, 0, 0),  
(25, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  # group 9
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EAX, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_ECX, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EDX, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EBX, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_ESP, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EBP, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_ESI, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EDI, 0, 0),  
    (0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psrlw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psrld", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psrlq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pmullw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_N | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pmovmskb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubusb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubusw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pminub", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pand", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddusb", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddusw", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pmaxub", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pandn", 0, 0, 0),  
    ( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pavgb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psraw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psrad", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pavgw", 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pmulhuw", 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pmulhw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_M | OPTYPE_dq | OP_W, ADDRMETH_V | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "movntq", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubsb", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubsw", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pminsw", 0, 0, 0),  
( 0, INS_OR, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "por", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddsb", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddsw", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pmaxsw", 0, 0, 0),  
( 0, INS_XOR, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pxor", 0, 0, 0),  
    (0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psllw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pslld", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psllq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pmuludq", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pmaddwd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "psadbw", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_N | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "maskmovq", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubb", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubw", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubd", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubq", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddb", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddw", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddd", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_F30F = [
(16, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0), 
(17, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "lar", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "lsl", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "clts", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80486, "invd", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80486, "wbinvd", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "ud2", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_E | OPTYPE_v, ARG_NONE, ARG_NONE, cpu_80386, "NOP", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
    ( 0, INS_MOV, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movups", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_W | OPTYPE_ps | OP_W, ADDRMETH_V | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movups", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_V | OPTYPE_q | OP_W, ADDRMETH_M | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movlps", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_M | OPTYPE_q | OP_W, ADDRMETH_V | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movlps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "unpcklps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "unpckhps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_q | OP_W, ADDRMETH_M | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movhps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_M | OPTYPE_q | OP_W, ADDRMETH_V | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "movhps", 0, 0, 0),  
(18, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_E | OPTYPE_v, ARG_NONE, ARG_NONE, cpu_80386, "NOP", 0, 0, 0),  
    ( 0, INS_MOV, ADDRMETH_R | OPTYPE_d | OP_W, ADDRMETH_C | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_R | OPTYPE_d | OP_W, ADDRMETH_D | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_C | OPTYPE_d | OP_W, ADDRMETH_R | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_D | OPTYPE_d | OP_W, ADDRMETH_R | OPTYPE_d | OP_R, ARG_NONE, cpu_80386, "mov", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movaps", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_W | OPTYPE_ps | OP_W, ADDRMETH_V | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movaps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_R, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "cvtpi2ps", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_M | OPTYPE_ps | OP_W, ADDRMETH_V | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movntps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_Q | OPTYPE_q | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "cvttps2pi", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_Q | OPTYPE_q | OP_R, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "cvtps2pi", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ss | OP_W, ADDRMETH_W | OPTYPE_ss | OP_R, ARG_NONE, cpu_PENTIUM2, "ucomiss", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_W, ARG_NONE, cpu_PENTIUM2, "comiss", 0, 0, 0),  
    (0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM, "wrmsr", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM, "rdtsc", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM, "rdmsr", 0, 0, 0),  
(0, INS_OTHER, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTPRO, "rdpmc", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "sysenter", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "sysexit", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  # 3-byte escape 28
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  # 3-byte escape 2a
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
    ( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovo", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovno", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovc", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovnc", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovz", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovnz", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovbe", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmova", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovs", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovns", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovpe", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovpo", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovl", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovge", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovle", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_PENTPRO, "cmovg", 0, 0, 0),  
    ( 0, INS_MOV, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_U | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "movmskps", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "sqrtps", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "rsqrtps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "rcpps", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "andps", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "andnps", 0, 0, 0),  
( 0, INS_OR, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "orps", 0, 0, 0),  
( 0, INS_XOR, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "xorps", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "addps", 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_V | OPTYPE_ps | OP_R, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "mulps", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_pd | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "cvtps2pd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_dq |OP_R, ARG_NONE, cpu_PENTIUM2, "cvtdq2ps", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "subps", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "minps", 0, 0, 0),  
( 0, INS_DIV, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "divps", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ARG_NONE, cpu_PENTIUM2, "maxps", 0, 0, 0),  
    ( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpcklbw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpcklwd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpckldq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "packsswb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpgtb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpgtw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpgtd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "packuswb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpckhbw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpckhwd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "punpckhdq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "packssdw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_P | OPTYPE_d | OP_W, ADDRMETH_E | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "movd", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "movq", 0, 0, 0),  
    ( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ADDRMETH_I |  OPTYPE_b | OP_R, cpu_PENTIUM2, "pshufw", 0, 0, 0),  
(19, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  
(20, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  
(21, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpeqb", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpeqw", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pcmpeqd", 0, 0, 0),  
(0, INS_OTHER, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, "emms", 0, 0, 0),  
(0, INS_SYSTEM, ADDRMETH_E | OPTYPE_d | OP_W, ADDRMETH_G | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTIUM2, "vmread", 0, 0, 0),  
(0, INS_SYSTEM, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_E | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTIUM2, "vmwrite", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_E | OPTYPE_d | OP_W, ADDRMETH_P | OPTYPE_d | OP_R, ARG_NONE, cpu_PENTMMX, "movd", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_Q | OPTYPE_q | OP_W, ADDRMETH_P | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "movq", 0, 0, 0),  
    ( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jo", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jno", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jc", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jnc", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jz", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jnz", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jbe", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "ja", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "js", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jns", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jpe", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jpo", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jl", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jge", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jle", 0, 0, 0),  
( 0, INS_BRANCHCC, ADDRMETH_J | OPTYPE_z | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jg", 0, 0, 0),  
    ( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "seto", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setno", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setc", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setnc", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setz", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setnz", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setbe", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "seta", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "sets", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setns", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setpe", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setpo", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setl", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setge", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setle", 0, 0, 0),  
( 0, INS_MOVCC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "setg", 0, 0, 0),  
    (0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_FS, 0, 0),  
(0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_FS, 0, 0),  
(0, INS_CPUID, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80486, "cpuid", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bt", 0, 0, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_80386, "shld", 0, 0, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, OP_R | OP_REG, cpu_80386, "shld", 0, 0, e_i386_regs.REG_CL), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, INS_PUSH, OP_REG | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", e_i386_regs.REG_GS, 0, 0),  
(0, INS_POP, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "pop", e_i386_regs.REG_GS, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "rsm", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bts", 0, 0, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_80386, "shrd", 0, 0, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_R, OP_R | OP_REG, cpu_80386, "shrd", 0, 0, e_i386_regs.REG_CL), 
(22, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, 0, 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_G | OPTYPE_v | OP_R, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "imul", 0, 0, 0),  
    ( 0, INS_XCHGCC, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_W, ARG_NONE, cpu_80486, "cmpxchg", 0, 0, 0),  
( 0, INS_XCHGCC, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v | OP_W, ARG_NONE, cpu_80486, "cmpxchg", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p | OP_R, ARG_NONE, cpu_80386, "lss", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "btr", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p| OP_R, ARG_NONE, cpu_80386, "lfs", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_M | OPTYPE_p | OP_R, ARG_NONE, cpu_80386, "lgs", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "movzx", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "movzx", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, "ud1", 0, 0, 0),  #### GROUP 10?
(23, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_80386, 0, 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_G | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "btc", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_G | OPTYPE_v | OP_R | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bsf", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_G | OPTYPE_v | OP_R | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "bsr", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "movsx", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_G | OPTYPE_v | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, cpu_80386, "movsx", 0, 0, 0),  
    ( 0, INS_ADD, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_G | OPTYPE_b | OP_W, ARG_NONE, cpu_80486, "xadd", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_G | OPTYPE_v, ARG_NONE, cpu_80486, "xadd", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_V | OPTYPE_ps| OP_W, ADDRMETH_W | OPTYPE_ps| OP_W, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "cmpps", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_M | OPTYPE_q | OP_W, ADDRMETH_G | OPTYPE_q |OP_R, ARG_NONE, cpu_PENTIUM2, "movnti", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_E | OPTYPE_w | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "pinsrw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_N | OPTYPE_q | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "pextrw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_ps | OP_W, ADDRMETH_W | OPTYPE_ps | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, cpu_PENTIUM2, "shufps", 0, 0, 0),  
(25, 0, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTMMX, 0, 0, 0, 0),  # group 9
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EAX, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_ECX, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EDX, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EBX, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_ESP, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EBP, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_ESI, 0, 0),  
( 0, INS_XCHG, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_80486, "bswap", e_i386_regs.REG_EDI, 0, 0),  
    (0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psrlw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psrld", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psrlq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pmullw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_G | OPTYPE_d | OP_W, ADDRMETH_N | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pmovmskb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubusb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubusw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pminub", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pand", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddusb", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddusw", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pmaxub", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pandn", 0, 0, 0),  
    ( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pavgb", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psraw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psrad", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pavgw", 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pmulhuw", 0, 0, 0),  
( 0, INS_MUL, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pmulhw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_M | OPTYPE_dq | OP_W, ADDRMETH_V | OPTYPE_dq | OP_R, ARG_NONE, cpu_PENTIUM2, "movntq", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubsb", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubsw", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pminsw", 0, 0, 0),  
( 0, INS_OR, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "por", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddsb", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddsw", 0, 0, 0),  
( 0, INS_ARITH, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "pmaxsw", 0, 0, 0),  
( 0, INS_XOR, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pxor", 0, 0, 0),  
    (0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psllw", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pslld", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psllq", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pmuludq", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "pmaddwd", 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "psadbw", 0, 0, 0),  
( 0, INS_MOV, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_N | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTIUM2, "maskmovq", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubb", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubw", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubd", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "psubq", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddb", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddw", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_P | OPTYPE_q | OP_W, ADDRMETH_Q | OPTYPE_q | OP_R, ARG_NONE, cpu_PENTMMX, "paddd", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""

tbl32_0F00 = [
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "sldt", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "str", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "lldt", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "ltr", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "verr", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "verw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""

tbl32_0F01_00BF = [
( 0, INS_SYSTEM, ADDRMETH_M | OPTYPE_s | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "sgdt", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_M | OPTYPE_s | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "sidt", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_M | OPTYPE_s | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "lgdt", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_M | OPTYPE_s | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "lidt", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "smsw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "lmsw", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_M | OPTYPE_b | OP_R, ARG_NONE, ARG_NONE, cpu_80486, "invlpg", 0, 0, 0   )
]

tbl32_0F01_rest = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "vmcall", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "vmlaunch", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "vmresume", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "vmxoff", 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "smsw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "lmsw", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "monitor", 0, 0, 0),  
(0, INS_SYSTEM, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "mwait", 0, 0, 0),    
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
 (0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "smsw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "lmsw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
 (0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "smsw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "lmsw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
 (0, INS_OTHER, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "swapgs", 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "smsw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_SYSTEM, ADDRMETH_E | OPTYPE_w | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "lmsw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_0F18 = [
( 0, INS_SYSTEM,  OP_W | ADDRMETH_M, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "prefetch", 0, 0, 0),  
( 0, INS_SYSTEM, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "prefetch", e_i386_regs.REG_TEST0, 0, 0),
( 0, INS_SYSTEM, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "prefetch", e_i386_regs.REG_TEST1, 0, 0),
( 0, INS_SYSTEM, OP_REG | OP_W, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "prefetch", e_i386_regs.REG_TEST2, 0, 0),
#( 0, INS_SYSTEM, OP_REG | OP_W | ADDRMETH_M, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "prefetch", 0 + REG_TEST_OFFSET, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_0F71 = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_N | OPTYPE_q | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_PENTMMX, "psrlw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_N | OPTYPE_q | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_PENTMMX, "psraw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_N | OPTYPE_q | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_PENTMMX, "psllw", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_0F72 = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_N | OPTYPE_q | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_PENTMMX, "psrld", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_N | OPTYPE_q | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_PENTMMX, "psrad", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_OTHER, ADDRMETH_N | OPTYPE_q | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_PENTMMX, "pslld", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_0F73 = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
( 0, INS_OTHER, ADDRMETH_N | OPTYPE_q | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_PENTMMX, "psrlq", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
( 0, INS_OTHER, ADDRMETH_N | OPTYPE_q | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_PENTMMX, "psllq", 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ) 
]

"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
#FIXME there are more...  like 660F72 and all the VM ones...
tbl32_660F73 = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
#( 0, INS_OTHER, ADDRMETH_V | OPTYPE_q | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_PENTMMX, "psrlq", 0, 0, 0),
( 0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_PENTMMX, "psrlq", 0, 0, 0),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
#(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
#(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ) 
(0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_PENTMMX, "psllq", 0, 0, 0),
(0, INS_OTHER, ADDRMETH_V | OPTYPE_dq | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_PENTMMX, "psldq", 0, 0, 0),
]

"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_0FAE_00BF = [	# IA32 manuals don't list an actual address method... guessing by trial/error
( 0, INS_FPU, ADDRMETH_E | OPTYPE_v | OP_W, ARG_NONE, ARG_NONE, cpu_PENTMMX, "fxsave", 0, 0, 0),  
( 0, INS_FPU, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, ARG_NONE, cpu_PENTMMX, "fxrstor", 0, 0, 0),  
( 0, INS_FPU, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "ldmxcsr", 0, 0, 0),  
( 0, INS_FPU, ADDRMETH_E | OPTYPE_v | OP_W, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "stmxcsr", 0, 0, 0),  
( 0, INS_FPU, ADDRMETH_E | OPTYPE_v | OP_W, ARG_NONE, ARG_NONE, cpu_PENTIUM2, 'xsave', 0, 0, 0  ), 
( 0, INS_FPU, ADDRMETH_E | OPTYPE_v | OP_W, ARG_NONE, ARG_NONE, cpu_PENTIUM2, 'xrstor', 0, 0, 0  ), 
#( 0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
#( 0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
( 0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
( 0, INS_FPU, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "clflush", 0, 0, 0  )
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_0FAE_rest = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
( 0, INS_FPU, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "lfence", 0, 0, 0  ),
( 0, INS_FPU, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "mfence", 0, 0, 0  ),
( 0, INS_FPU, ARG_NONE, ARG_NONE, ARG_NONE, cpu_PENTIUM2, "sfence", 0, 0, 0  )
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_0FBA = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0  ), 
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "bt", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "bts", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "btr", 0, 0, 0),  
( 0, INS_BITTEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "btc", 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_0FC2 = [
( 0, INS_XCHGCC, ADDRMETH_M | OPTYPE_q | OP_W, ARG_NONE, ARG_NONE, cpu_PENTIUM, "cmpxch8b", 0, 0, 0   ),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, INS_SYSTEM, ADDRMETH_M | OPTYPE_q | OP_W, ARG_NONE, ARG_NONE, 0, "vmptrld", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_0FC7_00BF = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
( 0, INS_XCHGCC, ADDRMETH_M | OPTYPE_q | OP_W, ARG_NONE, ARG_NONE, cpu_PENTIUM, "cmpxch8b", 0, 0, 0   ),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, INS_SYSTEM, ADDRMETH_M | OPTYPE_q | OP_W, ARG_NONE, ARG_NONE, 0, "vmptrld", 0, 0, 0),  
(0, INS_SYSTEM, ADDRMETH_M | OPTYPE_q | OP_W, ARG_NONE, ARG_NONE, 0, "vmptrst", 0, 0, 0)  
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_0FC7_rest = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_660FC7_00BF = [
( 0, INS_XCHGCC, ADDRMETH_M | OPTYPE_q | OP_W, ARG_NONE, ARG_NONE, cpu_PENTIUM, "cmpxch8b", 0, 0, 0   ),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, INS_SYSTEM, ADDRMETH_M | OPTYPE_q | OP_W, ARG_NONE, ARG_NONE, 0, "vmclear", 0, 0, 0),  
(0, INS_SYSTEM, ADDRMETH_M | OPTYPE_q | OP_W, ARG_NONE, ARG_NONE, 0, "vmptrst", 0, 0, 0)  
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_660FC7_rest = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_F20FC7_00BF = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_F20FC7_rest = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_F30FC7_00BF = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, INS_SYSTEM, ADDRMETH_M | OPTYPE_q | OP_W, ARG_NONE, ARG_NONE, 0, "vmclear", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_F30FC7_rest = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_F30FC7_00BF = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, INS_SYSTEM, ADDRMETH_M | OPTYPE_q | OP_W, ARG_NONE, ARG_NONE, 0, "vmxon", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_F30FC7_rest = [
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_80 = [
( 0, INS_ADD, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "add", 0, 0, 0),  
( 0, INS_OR,  ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "or", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "adc", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "sbb", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "and", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "sub", 0, 0, 0),  
( 0, INS_XOR, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "xor", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_E | OPTYPE_b | OP_R, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "cmp", 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_81 = [
( 0, INS_ADD, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_z | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "add", 0, 0, 0),  
( 0, INS_OR,  ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_z | OP_R, ARG_NONE, cpu_80386, "or", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_z | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "adc", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_z | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "sbb", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_z | OP_R, ARG_NONE, cpu_80386, "and", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_z | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "sub", 0, 0, 0),  
( 0, INS_XOR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_z | OP_R, ARG_NONE, cpu_80386, "xor", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_z | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "cmp", 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_82 = [
( 0, INS_ADD, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "add", 0, 0, 0),  
( 0, INS_OR,  ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "or", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "adc", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "sbb", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "and", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "sub", 0, 0, 0),  
( 0, INS_XOR, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "xor", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_E | OPTYPE_b | OP_R, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "cmp", 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_83 = [
( 0, INS_ADD, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "add", 0, 0, 0),  
( 0, INS_OR,  ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "or", 0, 0, 0),  
( 0, INS_ADD, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "adc", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "sbb", 0, 0, 0),  
( 0, INS_AND, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "and", 0, 0, 0),  
( 0, INS_SUB, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "sub", 0, 0, 0),  
( 0, INS_XOR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "xor", 0, 0, 0),  
( 0, INS_CMP, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "cmp", 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_C0 = [
( 0, INS_ROL, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "rol", 0, 0, 0),  
( 0, INS_ROR, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "ror", 0, 0, 0),  
( 0, INS_ROL, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "rcl", 0, 0, 0),  
( 0, INS_ROR, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "rcr", 0, 0, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "shl", 0, 0, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "shr", 0, 0, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "sal", 0, 0, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_b | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "sar", 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_C1 = [
( 0, INS_ROL, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "rol", 0, 0, 0),  
( 0, INS_ROR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "ror", 0, 0, 0),  
( 0, INS_ROL, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "rcl", 0, 0, 0),  
( 0, INS_ROR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "rcr", 0, 0, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "shl", 0, 0, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "shr", 0, 0, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "sal", 0, 0, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "sar", 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_D0 = [
( 0, INS_ROL, ADDRMETH_E | OPTYPE_b | OP_W, OP_IMM  | OP_R, ARG_NONE, cpu_80386, "rol", 0, 1, 0),  
( 0, INS_ROR, ADDRMETH_E | OPTYPE_b | OP_W, OP_IMM  | OP_R, ARG_NONE, cpu_80386, "ror", 0, 1, 0),  
( 0, INS_ROL, ADDRMETH_E | OPTYPE_b | OP_W, OP_IMM  | OP_R, ARG_NONE, cpu_80386, "rcl", 0, 1, 0),  
( 0, INS_ROR, ADDRMETH_E | OPTYPE_b | OP_W, OP_IMM  | OP_R, ARG_NONE, cpu_80386, "rcr", 0, 1, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_b | OP_W, OP_IMM  | OP_R, ARG_NONE, cpu_80386, "shl", 0, 1, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_b | OP_W, OP_IMM  | OP_R, ARG_NONE, cpu_80386, "shr", 0, 1, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_b | OP_W, OP_IMM  | OP_R, ARG_NONE, cpu_80386, "sal", 0, 1, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_b | OP_W, OP_IMM  | OP_R, ARG_NONE, cpu_80386, "sar", 0, 1, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_D1 = [
( 0, INS_ROL, ADDRMETH_E | OPTYPE_v | OP_W, OP_IMM | OP_R, ARG_NONE, cpu_80386, "rol", 0, 1, 0),  
( 0, INS_ROR, ADDRMETH_E | OPTYPE_v | OP_W, OP_IMM | OP_R, ARG_NONE, cpu_80386, "ror", 0, 1, 0),  
( 0, INS_ROL, ADDRMETH_E | OPTYPE_v | OP_W, OP_IMM | OP_R, ARG_NONE, cpu_80386, "rcl", 0, 1, 0),  
( 0, INS_ROR, ADDRMETH_E | OPTYPE_v | OP_W, OP_IMM | OP_R, ARG_NONE, cpu_80386, "rcr", 0, 1, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, OP_IMM | OP_R, ARG_NONE, cpu_80386, "shl", 0, 1, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, OP_IMM | OP_R, ARG_NONE, cpu_80386, "shr", 0, 1, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, OP_IMM | OP_R, ARG_NONE, cpu_80386, "sal", 0, 1, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, OP_IMM | OP_R, ARG_NONE, cpu_80386, "sar", 0, 1, 0   ) 
]
#( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, ADDRMETH_I | OP_IMM | OP_R, ARG_NONE, cpu_80386, "sar", 0, 1, 0   ) 


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_D2 = [
( 0, INS_ROL, ADDRMETH_E | OPTYPE_b | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "rol", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_ROR, ADDRMETH_E | OPTYPE_b | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "ror", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_ROL, ADDRMETH_E | OPTYPE_b | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "rcl", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_ROR, ADDRMETH_E | OPTYPE_b | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "rcr", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_b | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "shl", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_b | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "shr", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_b | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "sal", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_b | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "sar", 0, e_i386_regs.REG_CL, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_D3 = [
( 0, INS_ROL, ADDRMETH_E | OPTYPE_v | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "rol", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_ROR, ADDRMETH_E | OPTYPE_v | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "ror", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_ROL, ADDRMETH_E | OPTYPE_v | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "rcl", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_ROR, ADDRMETH_E | OPTYPE_v | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "rcr", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "shl", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "shr", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_SHL, ADDRMETH_E | OPTYPE_v | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "sal", 0, e_i386_regs.REG_CL, 0),  
( 0, INS_SHR, ADDRMETH_E | OPTYPE_v | OP_W, OP_REG | OP_R, ARG_NONE, cpu_80386, "sar", 0, e_i386_regs.REG_CL, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_F6 = [
( 0, INS_TEST, ADDRMETH_E | OPTYPE_b | OP_R, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "test", 0, 0, 0),  
( 0, INS_TEST, ADDRMETH_E | OPTYPE_b | OP_R, ADDRMETH_I | OPTYPE_b | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "test", 0, 0, 0),  
( 0, INS_NOT, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "not", 0, 0, 0),  
( 0, INS_NEG, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "neg", 0, 0, 0),  
( 0, INS_MUL, OP_REG | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "mul", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_MUL, OP_REG | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "imul", e_i386_regs.REG_AL, 0, 0),  
( 0, INS_DIV, OP_REG | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "div", e_i386_regs.REG_AL, 0, 0),  
#( 0, INS_DIV, OP_REG | OP_W, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, cpu_80386, "idiv", e_i386_regs.REG_AL, 0, 0   ) 
( 0, INS_DIV, ADDRMETH_E | OPTYPE_b | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "idiv", e_i386_regs.REG_AL, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_F7 = [
( 0, INS_TEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_z | OP_R, ARG_NONE, cpu_80386, "test", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ),
#( 0, INS_TEST, ADDRMETH_E | OPTYPE_v | OP_R, ADDRMETH_I | OPTYPE_z | OP_SIGNED | OP_R, ARG_NONE, cpu_80386, "test", 0, 0, 0),  
( 0, INS_NOT, ADDRMETH_E | OPTYPE_v | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "not", 0, 0, 0),  
( 0, INS_NEG, ADDRMETH_E | OPTYPE_v | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "neg", 0, 0, 0),  
( 0, INS_MUL, OP_REG | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "mul", e_i386_regs.REG_EAX, 0, 0),  
( 0, INS_MUL, OP_REG | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "imul", e_i386_regs.REG_EAX, 0, 0),  
( 0, INS_DIV, OP_REG | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "div", e_i386_regs.REG_EAX, 0, 0),  
#( 0, INS_DIV, OP_REG | OP_W, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, cpu_80386, "idiv", e_i386_regs.REG_EAX, 0, 0) 
( 0, INS_DIV, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "idiv", e_i386_regs.REG_EAX, 0, 0) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_FE = [
( 0, INS_INC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "inc", 0, 0, 0),  
( 0, INS_DEC, ADDRMETH_E | OPTYPE_b | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "dec", 0, 0, 0), 
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ),
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_FF = [
( 0, INS_INC, ADDRMETH_E | OPTYPE_v | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "inc", 0, 0, 0),  
( 0, INS_DEC, ADDRMETH_E | OPTYPE_v | OP_W, ARG_NONE, ARG_NONE, cpu_80386, "dec", 0, 0, 0),  
( 0, INS_CALL, ADDRMETH_E | OPTYPE_v | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "call", 0, 0, 0),  
( 0, INS_CALL, ADDRMETH_E | OPTYPE_p | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "call", 0, 0, 0),  
( 0, INS_BRANCH, ADDRMETH_E | OPTYPE_v | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jmp", 0, 0, 0),  
( 0, INS_BRANCH, ADDRMETH_E | OPTYPE_p | OP_X, ARG_NONE, ARG_NONE, cpu_80386, "jmp", 0, 0, 0),  
( 0, INS_PUSH, ADDRMETH_E | OPTYPE_v | OP_R, ARG_NONE, ARG_NONE, cpu_80386, "push", 0, 0, 0),  
(0, 0, ARG_NONE, ARG_NONE, ARG_NONE, 0, 0, 0, 0, 0   ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuD8_00BF = [
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fs|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fadd",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fs|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fmul",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fs|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fcom",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fs|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fcomp",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fs|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fsub",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fs|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fsubr",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fs|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fdiv",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fs|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fdivr",0,0,0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuD8_rest = [
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcom",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcom",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcom",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcom",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcom",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcom",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcom",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcom",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 )
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuD9_00BF = [
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fs|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fld",0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fs|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fst",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fs|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstp",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fv|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fldenv",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fldcw",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fv|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstenv",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstcw",0,0,0 )
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuD9_rest = [
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fld",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fld",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fld",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fld",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fld",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fld",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fld",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fld",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  

( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fxch",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fxch",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fxch",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fxch",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fxch",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fxch",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fxch",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fxch",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fnop",0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fchs",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fabs",0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"ftst",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fxam",0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fld1",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fldl2t",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fldl2e",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fldpi",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fldlg2",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fldln2",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fldz",0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"f2xm1",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fyl2x",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fptan",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fpatan",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fxtract",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fprem1",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fdecstp",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fincstp",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fprem",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fyl2xp1",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fsqrt",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fsincos",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"frndint",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fscale",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fsin",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fcos",0,0,0 )
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuDA_00BF = [
( 0,INS_FPU,ADDRMETH_M|OPTYPE_d|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fiadd",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_d|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fimul",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_d|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"ficom",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_d|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"ficomp",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_d|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fisub",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_d|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fisubr",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_d|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fidiv",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_d|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fidivr",0,0,0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuDA_rest = [
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmove",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmove",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmove",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmove",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmove",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmove",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmove",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmove",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fucompp",0,0,0 ), 
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 )
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuDB_00BF = [
( 0,INS_FPU,ADDRMETH_M|OPTYPE_d|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fild",0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_d|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fist",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_d|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fistp",0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fe|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fld",0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fe|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstp",0,0,0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuDB_rest = [
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnb",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovne",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovne",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovne",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovne",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovne",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovne",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovne",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovne",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnbe",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcmovnu",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fclex",0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"finit",0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomi",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 )
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuDC_00BF = [
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fd|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fadd",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fd|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fmul",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fd|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fcom",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fd|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fcomp",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fd|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fsub",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fd|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fsubr",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fd|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fdiv",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fd|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fdivr",0,0,0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuDC_rest = [
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST1,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST2,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST3,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST4,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST5,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST6,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fadd",e_i386_regs.REG_ST7,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST1,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST2,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST3,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST4,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST5,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST6,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmul",e_i386_regs.REG_ST7,e_i386_regs.REG_ST0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST1,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST2,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST3,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST4,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST5,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST6,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubr",e_i386_regs.REG_ST7,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST1,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST2,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST3,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST4,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST5,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST6,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsub",e_i386_regs.REG_ST7,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST1,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST2,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST3,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST4,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST5,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST6,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivr",e_i386_regs.REG_ST7,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST1,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST2,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST3,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST4,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST5,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST6,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdiv",e_i386_regs.REG_ST7,e_i386_regs.REG_ST0,0 )
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuDD_00BF = [
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fd|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fld",0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fd|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fst",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fd|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstp",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fv|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"frstor",0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fv|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fsave",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstsw",0,0,0 )
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuDD_rest = [
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"ffree",e_i386_regs.REG_ST0,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"ffree",e_i386_regs.REG_ST1,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"ffree",e_i386_regs.REG_ST2,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"ffree",e_i386_regs.REG_ST3,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"ffree",e_i386_regs.REG_ST4,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"ffree",e_i386_regs.REG_ST5,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"ffree",e_i386_regs.REG_ST6,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"ffree",e_i386_regs.REG_ST7,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fst",e_i386_regs.REG_ST0,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fst",e_i386_regs.REG_ST1,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fst",e_i386_regs.REG_ST2,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fst",e_i386_regs.REG_ST3,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fst",e_i386_regs.REG_ST4,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fst",e_i386_regs.REG_ST5,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fst",e_i386_regs.REG_ST6,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fst",e_i386_regs.REG_ST7,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstp",e_i386_regs.REG_ST0,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstp",e_i386_regs.REG_ST1,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstp",e_i386_regs.REG_ST2,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstp",e_i386_regs.REG_ST3,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstp",e_i386_regs.REG_ST4,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstp",e_i386_regs.REG_ST5,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstp",e_i386_regs.REG_ST6,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fstp",e_i386_regs.REG_ST7,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucom",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucom",e_i386_regs.REG_ST1,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucom",e_i386_regs.REG_ST2,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucom",e_i386_regs.REG_ST3,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucom",e_i386_regs.REG_ST4,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucom",e_i386_regs.REG_ST5,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucom",e_i386_regs.REG_ST6,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucom",e_i386_regs.REG_ST7,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fucomp",e_i386_regs.REG_ST0,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fucomp",e_i386_regs.REG_ST1,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fucomp",e_i386_regs.REG_ST2,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fucomp",e_i386_regs.REG_ST3,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fucomp",e_i386_regs.REG_ST4,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fucomp",e_i386_regs.REG_ST5,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fucomp",e_i386_regs.REG_ST6,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fucomp",e_i386_regs.REG_ST7,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 )
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuDE_00BF = [
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fiadd",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fimul",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"ficom",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"ficomp",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fisub",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fisubr",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fidiv",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fidivr",0,0,0)
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuDE_rest = [
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"faddp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"faddp",e_i386_regs.REG_ST1,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"faddp",e_i386_regs.REG_ST2,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"faddp",e_i386_regs.REG_ST3,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"faddp",e_i386_regs.REG_ST4,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"faddp",e_i386_regs.REG_ST5,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"faddp",e_i386_regs.REG_ST6,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"faddp",e_i386_regs.REG_ST7,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmulp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmulp",e_i386_regs.REG_ST1,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmulp",e_i386_regs.REG_ST2,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmulp",e_i386_regs.REG_ST3,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmulp",e_i386_regs.REG_ST4,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmulp",e_i386_regs.REG_ST5,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmulp",e_i386_regs.REG_ST6,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fmulp",e_i386_regs.REG_ST7,e_i386_regs.REG_ST0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,"fcompp",0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubrp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubrp",e_i386_regs.REG_ST1,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubrp",e_i386_regs.REG_ST2,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubrp",e_i386_regs.REG_ST3,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubrp",e_i386_regs.REG_ST4,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubrp",e_i386_regs.REG_ST5,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubrp",e_i386_regs.REG_ST6,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubrp",e_i386_regs.REG_ST7,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubp",e_i386_regs.REG_ST1,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubp",e_i386_regs.REG_ST2,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubp",e_i386_regs.REG_ST3,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubp",e_i386_regs.REG_ST4,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubp",e_i386_regs.REG_ST5,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubp",e_i386_regs.REG_ST6,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fsubp",e_i386_regs.REG_ST7,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivrp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivrp",e_i386_regs.REG_ST1,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivrp",e_i386_regs.REG_ST2,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivrp",e_i386_regs.REG_ST3,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivrp",e_i386_regs.REG_ST4,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivrp",e_i386_regs.REG_ST5,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivrp",e_i386_regs.REG_ST6,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivrp",e_i386_regs.REG_ST7,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivp",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivp",e_i386_regs.REG_ST1,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivp",e_i386_regs.REG_ST2,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivp",e_i386_regs.REG_ST3,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivp",e_i386_regs.REG_ST4,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivp",e_i386_regs.REG_ST5,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivp",e_i386_regs.REG_ST6,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fdivp",e_i386_regs.REG_ST7,e_i386_regs.REG_ST0,0 )
]



"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuDF_00BF = [ 
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fild",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fisttp",0,0,0),
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fist",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_w|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fistp",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fb|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fbld",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_q|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fild",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_fb|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fbstp",0,0,0 ),  
( 0,INS_FPU,ADDRMETH_M|OPTYPE_q|OP_W,ARG_NONE,ARG_NONE,cpu_80387,"fistp",0,0,0 ) 
]


"""
(optable, optype, operand 0, operand 1, operand 2, CPU required, "opcodename", op0Register, op1Register, op2Register)
"""
tbl32_fpuDF_rest = [ 
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,OP_REG,ARG_NONE,ARG_NONE,cpu_80387,"fstsw",e_i386_regs.REG_AX,0,0 ),
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fucomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST0,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST1,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST2,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST3,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST4,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST5,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST6,0 ),  
( 0,INS_FPU,OP_REG | OP_W,OP_REG | OP_R,ARG_NONE,cpu_80387,"fcomip",e_i386_regs.REG_ST0,e_i386_regs.REG_ST7,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 ),  
( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,cpu_80387,0,0,0,0 )]


tbl_INVALID = [ ( 0,0,ARG_NONE,ARG_NONE,ARG_NONE,0,0,0,0,0 ) ]

"""
        ### These values allow an opcode to be sliced and diced to make it fit correctly into the current lookup table.
        #
        #   (tbl32_0F, 0, 0xff, 0, 0xff),
        #   (tbl32_80, 3, 0x07, 0, 0xff, 4),
        #
        #           Table pointer
        #           shift bits right        (eg.  >> 4 makes each line in the table valid for 16 numbers... ie 0xc0-0xcf are all one entry in the table)
        #           mask part of the byte   (eg.  & 0x7 only makes use of the 00000111 bits...)
        #           simple subtraction
        #           highest acceptable value
        #           tables86 entry to handle the falloff (from the previous check)
"""
tables86=[
(tbl32_Main,0,0xff,0,0xff),              #0
(tbl32_0F,0,0xff,0,0xff),                #1
(tbl32_80,3,0x07,0,0xff),                #2
(tbl32_81,3,0x07,0,0xff),                #3
(tbl32_82,3,0x07,0,0xff),                #4
(tbl32_83,3,0x07,0,0xff),                #5
(tbl32_C0,3,0x07,0,0xff),                #6
(tbl32_C1,3,0x07,0,0xff),                #7
(tbl32_D0,3,0x07,0,0xff),                #8
(tbl32_D1,3,0x07,0,0xff),                #9
(tbl32_D2,3,0x07,0,0xff),                #10
(tbl32_D3,3,0x07,0,0xff),                #11
(tbl32_F6,3,0x07,0,0xff),                #12
(tbl32_F7,3,0x07,0,0xff),                #13
(tbl32_FE,3,0x07,0,0xff),                #14
(tbl32_FF,3,0x07,0,0xff),                #15
(tbl32_0F00,3,0x07,0,0xff),              #16
(tbl32_0F01_00BF,3,0x07,0,0xbf,42),      #17
(tbl32_0F18,3,0x07,0,0xff),              #18
(tbl32_0F71,3,0x07,0,0xff),              #19
(tbl32_0F72,3,0x07,0,0xff),              #20
(tbl32_0F73,3,0x07,0,0xff),              #21
(tbl32_0FAE_00BF,3,0x07,0,0xbf, 53),     #22
(tbl32_0FBA,3,0x07,0,0xff),              #23
(tbl32_0FC7_00BF,3,0x07,0,0xbf, 25),     #24
(tbl32_0FC7_rest,0,0x07,0xc0,0xff),      #25
(tbl32_fpuD8_00BF,3,0x07,0,0xbf, 27),    #26
(tbl32_fpuD8_rest,0,0xff,0xc0,0xff),     #27
(tbl32_fpuD9_00BF,3,0x07,0,0xbf, 29),    #28
(tbl32_fpuD9_rest,0,0xff,0xc0,0xff),     #29
(tbl32_fpuDA_00BF,3,0x07,0,0xbf, 31),    #30
(tbl32_fpuDA_rest,0,0xff,0xc0,0xff),     #31
(tbl32_fpuDB_00BF,3,0x07,0,0xbf, 33),    #32
(tbl32_fpuDB_rest,0,0xff,0xc0,0xff),     #33
(tbl32_fpuDC_00BF,3,0x07,0,0xbf, 35),    #34
(tbl32_fpuDC_rest,0,0xff,0xc0,0xff),     #35
(tbl32_fpuDD_00BF,3,0x07,0,0xbf, 37),    #36
(tbl32_fpuDD_rest,0,0xff,0xc0,0xff),     #37
(tbl32_fpuDE_00BF,3,0x07,0,0xbf, 39),    #38
(tbl32_fpuDE_rest,0,0xff,0xc0,0xff),     #39
(tbl32_fpuDF_00BF,3,0x07,0,0xbf, 41),    #40
(tbl32_fpuDF_rest,0,0xff,0xc0,0xff),     #41
(tbl32_0F01_rest,0,0x0f,0xc0,0xff),      #42
(tbl_INVALID, 0,0x00, 0, 0xff),          #43
(tbl32_660F,0,0xff,0,0xff),              #44
(tbl32_F20F,0,0xff,0,0xff),              #45
(tbl32_F30F,0,0xff,0,0xff),              #46
(tbl32_660FC7_00BF,3,0x07,0,0xff, 48),   #47
(tbl32_660FC7_rest,3,0x07,0xc0,0xff),    #48
(tbl32_F20FC7_00BF,3,0x07,0,0xff, 50),   #49
(tbl32_F20FC7_rest,3,0x07,0xc0,0xff),    #50
(tbl32_F30FC7_00BF,3,0x07,0,0xff, 50),   #51
(tbl32_F30FC7_rest,3,0x07,0xc0,0xff),    #52
(tbl32_0FAE_rest,3,0x07,0xc0,0xff),      #53
(tbl32_660F73,3,0x7,0,0xff)              #54
]

regs=[
        ("eax", "REG_GENERAL,REG_RET", 4),
        ("ecx", "REG_GENERAL,REG_COUNT", 4),
        ("edx", "REG_GENERAL", 4),
        ("ebx", "REG_GENERAL", 4),
        ("esp", "REG_SP", 4),
        ("ebp", "REG_GENERAL,REG_FP", 4),
        ("esi", "REG_GENERAL,REG_SRC", 4),
        ("edi", "REG_GENERAL,REG_DEST", 4),
        ("ax", "REG_GENERAL,REG_RET", 2),
        ("cx", "REG_GENERAL,REG_COUNT", 2),
        ("dx", "REG_GENERAL", 2),
        ("bx", "REG_GENERAL", 2),
        ("sp", "REG_SP", 2),
        ("bp", "REG_GENERAL,REG_FP", 2),
        ("si", "REG_GENERAL,REG_SRC", 2),
        ("di", "REG_GENERAL,REG_DEST", 2),
        ("al", "REG_GENERAL", 1),
        ("cl", "REG_GENERAL", 1),
        ("dl", "REG_GENERAL", 1),
        ("bl", "REG_GENERAL", 1),
        ("ah", "REG_GENERAL", 1),
        ("ch", "REG_GENERAL", 1),
        ("dh", "REG_GENERAL", 1),
        ("bh", "REG_GENERAL", 1),
        ("mm0", "REG_SIMD", 4),
        ("mm1", "REG_SIMD", 4),
        ("mm2", "REG_SIMD", 4),
        ("mm3", "REG_SIMD", 4),
        ("mm4", "REG_SIMD", 4),
        ("mm5", "REG_SIMD", 4),
        ("mm6", "REG_SIMD", 4),
        ("mm7", "REG_SIMD", 4),
        ("xmm0", "REG_SIMD", 4),
        ("xmm1", "REG_SIMD", 4),
        ("xmm2", "REG_SIMD", 4),
        ("xmm3", "REG_SIMD", 4),
        ("xmm4", "REG_SIMD", 4),
        ("xmm5", "REG_SIMD", 4),
        ("xmm6", "REG_SIMD", 4),
        ("xmm7", "REG_SIMD", 4),
        ("dr0", "REG_DEBUG", 4),
        ("dr1", "REG_DEBUG", 4),
        ("dr2", "REG_DEBUG", 4),
        ("dr3", "REG_DEBUG", 4),
        ("dr4", "REG_DEBUG", 4),
        ("dr5", "REG_DEBUG", 4),
        ("dr6", "REG_DEBUG,REG_SYS", 4),
        ("dr7", "REG_DEBUG,REG_SYS", 4),
        ("cr0", "REG_SYS", 4),
        ("cr1", "REG_SYS", 4),
        ("cr2", "REG_SYS", 4),
        ("cr3", "REG_SYS", 4),
        ("cr4", "REG_SYS", 4),
        ("cr5", "REG_SYS", 4),
        ("cr6", "REG_SYS", 4),
        ("cr7", "REG_SYS", 4),
        ("tr0", "REG_SYS", 4),
        ("tr1", "REG_SYS", 4),
        ("tr2", "REG_SYS", 4),
        ("tr3", "REG_SYS", 4),
        ("tr4", "REG_SYS", 4),
        ("tr5", "REG_SYS", 4),
        ("tr6", "REG_SYS", 4),
        ("tr7", "REG_SYS", 4),
        ("es", "REG_DATASEG", 2),
        ("cs", "REG_CODESEG", 2),
        ("ss", "REG_STACKSEG", 2),
        ("ds", "REG_DATASEG", 2),
        ("fs", "REG_DATASEG", 2),
        ("gs", "REG_DATASEG", 2),
        (" ", "REG_INVALID", 0),
        (" ", "REG_INVALID", 0),
        ("st(0)", "REG_FPU", "OPSIZE_FPREG"),
        ("st(1)", "REG_FPU", "OPSIZE_FPREG"),
        ("st(2)", "REG_FPU", "OPSIZE_FPREG"),
        ("st(3)", "REG_FPU", "OPSIZE_FPREG"),
        ("st(4)", "REG_FPU", "OPSIZE_FPREG"),
        ("st(5)", "REG_FPU", "OPSIZE_FPREG"),
        ("st(6)", "REG_FPU", "OPSIZE_FPREG"),
        ("st(7)", "REG_FPU", "OPSIZE_FPREG"),
        ("eflags", "REG_CC", "OPSIZE_FPREG"),
        ("fpctrl", "REG_FPU,REG_SYS", 2),
        ("fpstat", "REG_FPU,REG_SYS", 2),
        ("fptag", "REG_FPU,REG_SYS", 2),
        ("eip", "REG_PC", 4),
        ("ip", "REG_PC", 2) ]


prefix_table = {
    0xF0 : PREFIX_LOCK ,
    0xF2: PREFIX_REPNZ,
    0xF3: PREFIX_REP,
    0x2E: PREFIX_CS,
    0x36: PREFIX_SS,
    0x3E: PREFIX_DS,
    0x26: PREFIX_ES,
    0x64: PREFIX_FS,
    0x65: PREFIX_GS,
    0x66: PREFIX_OP_SIZE,
    0x67: PREFIX_ADDR_SIZE,
    0:    0
}

#eventually, change this for your own codes
#ADDEXP_SCALE_OFFSET= 0 
#ADDEXP_INDEX_OFFSET= 8
#ADDEXP_BASE_OFFSET = 16
#ADDEXP_DISP_OFFSET = 24
#MODRM_EA =  1
#MODRM_reg=  0
ADDRMETH_MASK =     0x00FF0000
OPTYPE_MASK   =     0xFF000000L
OPFLAGS_MASK  =     0x0000FFFF


########NEW FILE########
__FILENAME__ = regs
"""
Home of the i386 module's register specs/code.
"""
import envi.registers as e_reg

## Definitions for some of the i386 MSRs from intel...
MSR_DEBUGCTL             = 0x01d9 # Intel p4 and forward, debug behavior control
MSR_DEBUGCTL_LBR         = 0x0001 # last branch recording (in msr's)
MSR_DEBUGCTL_BTF         = 0x0002 # single-step on branches (break on branch)
MSR_DEBUGCTL_TR          = 0x0004 # enable sending "branch trace messages" !!
MSR_DEBUGCTL_BTS         = 0x0008 # enable logging BTMs to circular buffer
MSR_DEBUGCTL_BTINT       = 0x0010 # Branch-trace-interrupt (gen interrupt on BTS full)
MSR_DEBUGCTL_BTS_OFF_OS  = 0x0020 # disable ring0 branch trace store
MSR_DEBUGCTL_BTS_OFF_USR = 0x0040 # disable non-ring0 branch trace store

MSR_SYSENTER_EIP         = 0x0176 # Where is EIP at sysenter?

IA32_DS_AREA_MSR         = 0x0600 # pointer to the configured debug storage area

# Eflags bit masks
EFLAGS_CF = 1 << 0
EFLAGS_PF = 1 << 2
EFLAGS_AF = 1 << 4
EFLAGS_ZF = 1 << 6
EFLAGS_SF = 1 << 7
EFLAGS_TF = 1 << 8
EFLAGS_IF = 1 << 9
EFLAGS_DF = 1 << 10
EFLAGS_OF = 1 << 11

i386regs = [
    ("eax",32),("ecx",32),("edx",32),("ebx",32),("esp",32),("ebp",32),("esi",32),("edi",32),
    #FIXME are these 64?
    ("mm0",64),("mm1",64), ("mm2",64), ("mm3",64), ("mm4",64), ("mm5",64), ("mm6",64), ("mm7",64),
    # SIMD registers
    ("xmm0",128),("xmm1",128),("xmm2",128),("xmm3",128),("xmm4",128),("xmm5",128),("xmm6",128),("xmm7",128),
    # Debug registers
    ("debug0",32),("debug1",32),("debug2",32),("debug3",32),("debug4",32),("debug5",32),("debug6",32),("debug7",32),
    # Control registers
    ("ctrl0",32),("ctrl1",32),("ctrl2",32),("ctrl3",32),("ctrl4",32),("ctrl5",32),("ctrl6",32),("ctrl7",32),
    # Test registers
    ("test0", 32),("test1", 32),("test2", 32),("test3", 32),("test4", 32),("test5", 32),("test6", 32),("test7", 32),
    # Segment registers
    ("es", 16),("cs",16),("ss",16),("ds",16),("fs",16),("gs",16),
    # FPU Registers
    ("st0", 128),("st1", 128),("st2", 128),("st3", 128),("st4", 128),("st5", 128),("st6", 128),("st7", 128),
    # Leftovers ;)
    ("eflags", 32), ("eip", 32),
]

def getRegOffset(regs, regname):
    # NOTE: dynamically calculate this on import so we are less
    # likely to fuck it up...
    for i,(name,width) in enumerate(regs):
        if name == regname:
            return i
    raise Exception("getRegOffset doesn't know about: %s" % regname)

# Setup REG_EAX and the like in our module
l = locals()
e_reg.addLocalEnums(l, i386regs)

i386meta = [
    ("ax", REG_EAX, 0, 16),
    ("cx", REG_ECX, 0, 16),
    ("dx", REG_EDX, 0, 16),
    ("bx", REG_EBX, 0, 16),
    ("sp", REG_ESP, 0, 16),
    ("bp", REG_EBP, 0, 16),
    ("si", REG_ESI, 0, 16),
    ("di", REG_EDI, 0, 16),

    ("al", REG_EAX, 0, 8),
    ("cl", REG_ECX, 0, 8),
    ("dl", REG_EDX, 0, 8),
    ("bl", REG_EBX, 0, 8),

    ("ah", REG_EAX, 8, 8),
    ("ch", REG_ECX, 8, 8),
    ("dh", REG_EDX, 8, 8),
    ("bh", REG_EBX, 8, 8),

    # FIXME more flags... (here and amd64)
    ("TF", REG_EFLAGS, 8, 1),
]

e_reg.addLocalMetas(l, i386meta)


class i386RegisterContext(e_reg.RegisterContext):
    def __init__(self):
        e_reg.RegisterContext.__init__(self)
        self.loadRegDef(i386regs)
        self.loadRegMetas(i386meta)
        self.setRegisterIndexes(REG_EIP, REG_ESP)


########NEW FILE########
__FILENAME__ = const

OPTYPE_Reg      =   1
OPTYPE_RegMem   =   2
OPTYPE_const    =   3
OPTYPE_imm8     =   4
OPTYPE_imm16    =   5
OPTYPE_RegAlt   =   6
OPTYPE_Ind      =   7
OPTYPE_Cond     =   8
OPTYPE_immmem16 =   9
OPTYPE_immmem8  =   10
OPTYPE_RegMemDisp = 11


COND_NZ         =   1
COND_Z          =   2
COND_NC         =   3
COND_PO         =   4
COND_PE         =   5
COND_P          =   6
COND_M          =   7

########NEW FILE########
__FILENAME__ = disasm

import envi
import envi.bits as e_bits
import envi.bytesig as e_bsig

from envi.archs.z80.regs import *
from envi.archs.z80.const import *

import envi.archs.z80.z80opcode as z80_opcode

sigtree = e_bsig.SignatureTree()

for row in z80_opcode.z80table:
    sighex, maskhex = row[0]

    sig = sighex.decode('hex')
    mask = maskhex.decode('hex')

    sigtree.addSignature(sig, masks=mask, val=row)


class z80RegOper(envi.RegisterOper):
    def __init__(self, reg):
        self.reg = reg

class z80ImmOper(envi.ImmedOper):
    def __init__(self, imm):
        self.imm = imm

    def repr(self, op):
        return '%.4xH' % self.imm

class z80ConstOper(z80ImmOper):
    pass

class z80RegMem(envi.DerefOper):
    def __init__(self, reg, disp = 0):
        self.reg = reg
        self.disp = disp

    def repr(self, op):
        rname = regctx.getRegisterName(self.reg)
        if self.disp > 0:
            return '(%s + %d)' % (rname, self.disp)
        if self.disp < 0:
            return '(%s - %d)' % (rname, abs(self.disp))
        return '(%s)' % rname

class z80Opcode(envi.Opcode):
    pass

class z80Disasm:

    def __init__(self):
        # NOTE: For eventual things like "modes" etc...
        pass

    def disasm(self, bytes, offset, va):
        row = sigtree.getSignature(bytes, offset)
        if row == None:
            raise envi.InvalidInstruction(bytes=bytes[offset:offset+8])
        sigmask, mnem, o1type, o1info, o2type, o2info, oplen, immoff, iflags = row
        #ret = i386Opcode(va, optype, mnem, prefixes, (offset-startoff)+operoffset, operands, iflags)
        opers = []
        if o1type != None:
            opers.append(self._buildOper(bytes, offset, immoff, o1type, o1info))
        if o2type != None:
            opers.append(self._buildOper(bytes, offset, immoff, o2type, o2info))
        return z80Opcode(va, 0, mnem, 0, oplen, opers, iflags)

    def _buildOper(self, bytes, offset, immoff, otype, oinfo):

        if otype == OPTYPE_Reg:
            return z80RegOper(oinfo)

        elif otype == OPTYPE_RegMem:
            return z80RegMem(oinfo)

        elif otype == OPTYPE_const:
            return z80ConstOper(oinfo)

        elif otype == OPTYPE_imm8:
            imm = e_bits.parsebytes(bytes, offset+immoff, 1)
            return z80ImmOper(imm)

        elif otype == OPTYPE_imm16:
            imm = e_bits.parsebytes(bytes, offset+immoff, 2)
            return z80ImmOper(imm)

        elif otype == OPTYPE_RegAlt:
            print 'REG ALT!'
            return z80RegOper(oinfo)

        elif otype == OPTYPE_Ind:

        elif otype == OPTYPE_RegMemDisp:
            disp = e_bits.parsebytes(bytes, offset+immoff, 1, sign=True)
            return z80RegMem(oinfo, disp)

        else:
            raise Exception('Unknown z80 operand type: %d' % otype)

if __name__ == '__main__':
    print sigtree.getSignature('\x00')
    print sigtree.getSignature('fdcb0006'.decode('hex'))

    d = z80Disasm()

    print repr(d.disasm('\xfd\xcb\x30\x06', 0, 20))



########NEW FILE########
__FILENAME__ = regs
'''
Register definition for the z80 architecture
'''

import envi.registers as e_reg

z80regs = [
    ('AF', 16),
    ('BC', 16),
    ('DE', 16),
    ('HL', 16),

    ('IX', 16),
    ('IY', 16),

    ('PC', 16),
    ('SP', 16),

    ('I', 8),
    ('R', 8),
]

l = locals()
e_reg.addLocalEnums(l, z80regs)

z80meta = [
    ('A', REG_AF, 8, 8),
    ('B', REG_BC, 8, 8),
    ('C', REG_BC, 0, 8),
    ('D', REG_DE, 8, 8),
    ('E', REG_DE, 0, 8),
    ('F', REG_AF, 0, 8),
    ('H', REG_HL, 8, 8),
    ('L', REG_HL, 0, 8),
]

e_reg.addLocalMetas(l, z80meta)

class z80RegisterContext(e_reg.RegisterContext):
    def __init__(self):
        e_reg.RegisterContext.__init__(self)
        self.loadRegDef(z80regs)
        self.loadRegMetas(z80meta)
        self.setRegisterIndexes(REG_PC, REG_SP)

regctx = z80RegisterContext()


########NEW FILE########
__FILENAME__ = z80opcode
from envi.archs.z80.regs import *
from envi.archs.z80.const import *
# (patrn,mask), mnem, o1type, o1info, o2type, o2info, oplen, immoff, iflags
z80table = [
(('00', 'ff'), 'nop', None, None, None, None, 1, 0, 0),
(('010000', 'ff0000'), 'ld', OPTYPE_Reg, REG_BC, OPTYPE_imm16, None, 3, 1, 0),
(('02', 'ff'), 'ld', OPTYPE_RegMem, REG_BC, OPTYPE_Reg, REG_A, 1, 0, 0),
(('03', 'ff'), 'inc', OPTYPE_Reg, REG_BC, None, None, 1, 0, 0),
(('04', 'ff'), 'inc', OPTYPE_Reg, REG_B, None, None, 1, 0, 0),
(('05', 'ff'), 'dec', OPTYPE_Reg, REG_B, None, None, 1, 0, 0),
(('0600', 'ff00'), 'ld', OPTYPE_Reg, REG_B, OPTYPE_imm8, None, 2, 1, 0),
(('07', 'ff'), 'rlca', None, None, None, None, 1, 0, 0),
(('08', 'ff'), 'ex', OPTYPE_Reg, REG_AF, OPTYPE_RegAlt, REG_AF, 1, 0, 0),
(('09', 'ff'), 'add', OPTYPE_Reg, REG_HL, OPTYPE_Reg, REG_BC, 1, 0, 0),
(('0a', 'ff'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_RegMem, REG_BC, 1, 0, 0),
(('0b', 'ff'), 'dec', OPTYPE_Reg, REG_BC, None, None, 1, 0, 0),
(('0c', 'ff'), 'inc', OPTYPE_Reg, REG_C, None, None, 1, 0, 0),
(('0d', 'ff'), 'dec', OPTYPE_Reg, REG_C, None, None, 1, 0, 0),
(('0e00', 'ff00'), 'ld', OPTYPE_Reg, REG_C, OPTYPE_imm8, None, 2, 1, 0),
(('0f', 'ff'), 'rrca', None, None, None, None, 1, 0, 0),
(('1000', 'ff00'), 'djnz', OPTYPE_Ind, None, None, None, 2, 1, 0),
(('110000', 'ff0000'), 'ld', OPTYPE_Reg, REG_DE, OPTYPE_imm16, None, 3, 1, 0),
(('12', 'ff'), 'ld', OPTYPE_RegMem, REG_DE, OPTYPE_Reg, REG_A, 1, 0, 0),
(('13', 'ff'), 'inc', OPTYPE_Reg, REG_DE, None, None, 1, 0, 0),
(('14', 'ff'), 'inc', OPTYPE_Reg, REG_D, None, None, 1, 0, 0),
(('15', 'ff'), 'dec', OPTYPE_Reg, REG_D, None, None, 1, 0, 0),
(('1600', 'ff00'), 'ld', OPTYPE_Reg, REG_D, OPTYPE_imm8, None, 2, 1, 0),
(('17', 'ff'), 'rla', None, None, None, None, 1, 0, 0),
(('1800', 'ff00'), 'jr', OPTYPE_Ind, None, None, None, 2, 1, 0),
(('19', 'ff'), 'add', OPTYPE_Reg, REG_HL, OPTYPE_Reg, REG_DE, 1, 0, 0),
(('1a', 'ff'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_RegMem, REG_DE, 1, 0, 0),
(('1b', 'ff'), 'dec', OPTYPE_Reg, REG_DE, None, None, 1, 0, 0),
(('1c', 'ff'), 'inc', OPTYPE_Reg, REG_E, None, None, 1, 0, 0),
(('1d', 'ff'), 'dec', OPTYPE_Reg, REG_E, None, None, 1, 0, 0),
(('1e00', 'ff00'), 'ld', OPTYPE_Reg, REG_E, OPTYPE_imm8, None, 2, 1, 0),
(('1f', 'ff'), 'rra', None, None, None, None, 1, 0, 0),
(('2000', 'ff00'), 'jr', OPTYPE_Cond, COND_NZ, OPTYPE_Ind, None, 2, 1, 0),
(('210000', 'ff0000'), 'ld', OPTYPE_Reg, REG_HL, OPTYPE_imm16, None, 3, 1, 0),
(('220000', 'ff0000'), 'ld', OPTYPE_immmem16, None, OPTYPE_Reg, REG_HL, 3, 1, 0),
(('23', 'ff'), 'inc', OPTYPE_Reg, REG_HL, None, None, 1, 0, 0),
(('24', 'ff'), 'inc', OPTYPE_Reg, REG_H, None, None, 1, 0, 0),
(('25', 'ff'), 'dec', OPTYPE_Reg, REG_H, None, None, 1, 0, 0),
(('2600', 'ff00'), 'ld', OPTYPE_Reg, REG_H, OPTYPE_imm8, None, 2, 1, 0),
(('27', 'ff'), 'daa', None, None, None, None, 1, 0, 0),
(('2800', 'ff00'), 'jr', OPTYPE_Cond, COND_Z, OPTYPE_Ind, None, 2, 1, 0),
(('29', 'ff'), 'add', OPTYPE_Reg, REG_HL, OPTYPE_Reg, REG_HL, 1, 0, 0),
(('2a0000', 'ff0000'), 'ld', OPTYPE_Reg, REG_HL, OPTYPE_immmem16, None, 3, 1, 0),
(('2b', 'ff'), 'dec', OPTYPE_Reg, REG_HL, None, None, 1, 0, 0),
(('2c', 'ff'), 'inc', OPTYPE_Reg, REG_L, None, None, 1, 0, 0),
(('2d', 'ff'), 'dec', OPTYPE_Reg, REG_L, None, None, 1, 0, 0),
(('2e00', 'ff00'), 'ld', OPTYPE_Reg, REG_L, OPTYPE_imm8, None, 2, 1, 0),
(('2f', 'ff'), 'cpl', None, None, None, None, 1, 0, 0),
(('3000', 'ff00'), 'jr', OPTYPE_Cond, COND_NC, OPTYPE_Ind, None, 2, 1, 0),
(('310000', 'ff0000'), 'ld', OPTYPE_Reg, REG_SP, OPTYPE_imm16, None, 3, 1, 0),
(('320000', 'ff0000'), 'ld', OPTYPE_immmem16, None, OPTYPE_Reg, REG_A, 3, 1, 0),
(('33', 'ff'), 'inc', OPTYPE_Reg, REG_SP, None, None, 1, 0, 0),
(('34', 'ff'), 'inc', OPTYPE_RegMem, REG_HL, None, None, 1, 0, 0),
(('35', 'ff'), 'dec', OPTYPE_RegMem, REG_HL, None, None, 1, 0, 0),
(('3600', 'ff00'), 'ld', OPTYPE_RegMem, REG_HL, OPTYPE_imm8, None, 2, 1, 0),
(('37', 'ff'), 'scf', None, None, None, None, 1, 0, 0),
(('3800', 'ff00'), 'jr', OPTYPE_Cond, COND_C, OPTYPE_Ind, None, 2, 1, 0),
(('39', 'ff'), 'add', OPTYPE_Reg, REG_HL, OPTYPE_Reg, REG_SP, 1, 0, 0),
(('3a0000', 'ff0000'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_immmem16, None, 3, 1, 0),
(('3b', 'ff'), 'dec', OPTYPE_Reg, REG_SP, None, None, 1, 0, 0),
(('3c', 'ff'), 'inc', OPTYPE_Reg, REG_A, None, None, 1, 0, 0),
(('3d', 'ff'), 'dec', OPTYPE_Reg, REG_A, None, None, 1, 0, 0),
(('3e00', 'ff00'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_imm8, None, 2, 1, 0),
(('3f', 'ff'), 'ccf', None, None, None, None, 1, 0, 0),
(('40', 'ff'), 'ld', OPTYPE_Reg, REG_B, OPTYPE_Reg, REG_B, 1, 0, 0),
(('41', 'ff'), 'ld', OPTYPE_Reg, REG_B, OPTYPE_Reg, REG_C, 1, 0, 0),
(('42', 'ff'), 'ld', OPTYPE_Reg, REG_B, OPTYPE_Reg, REG_D, 1, 0, 0),
(('43', 'ff'), 'ld', OPTYPE_Reg, REG_B, OPTYPE_Reg, REG_E, 1, 0, 0),
(('44', 'ff'), 'ld', OPTYPE_Reg, REG_B, OPTYPE_Reg, REG_H, 1, 0, 0),
(('45', 'ff'), 'ld', OPTYPE_Reg, REG_B, OPTYPE_Reg, REG_L, 1, 0, 0),
(('46', 'ff'), 'ld', OPTYPE_Reg, REG_B, OPTYPE_RegMem, REG_HL, 1, 0, 0),
(('47', 'ff'), 'ld', OPTYPE_Reg, REG_B, OPTYPE_Reg, REG_A, 1, 0, 0),
(('48', 'ff'), 'ld', OPTYPE_Reg, REG_C, OPTYPE_Reg, REG_B, 1, 0, 0),
(('49', 'ff'), 'ld', OPTYPE_Reg, REG_C, OPTYPE_Reg, REG_C, 1, 0, 0),
(('4a', 'ff'), 'ld', OPTYPE_Reg, REG_C, OPTYPE_Reg, REG_D, 1, 0, 0),
(('4b', 'ff'), 'ld', OPTYPE_Reg, REG_C, OPTYPE_Reg, REG_E, 1, 0, 0),
(('4c', 'ff'), 'ld', OPTYPE_Reg, REG_C, OPTYPE_Reg, REG_H, 1, 0, 0),
(('4d', 'ff'), 'ld', OPTYPE_Reg, REG_C, OPTYPE_Reg, REG_L, 1, 0, 0),
(('4e', 'ff'), 'ld', OPTYPE_Reg, REG_C, OPTYPE_RegMem, REG_HL, 1, 0, 0),
(('4f', 'ff'), 'ld', OPTYPE_Reg, REG_C, OPTYPE_Reg, REG_A, 1, 0, 0),
(('50', 'ff'), 'ld', OPTYPE_Reg, REG_D, OPTYPE_Reg, REG_B, 1, 0, 0),
(('51', 'ff'), 'ld', OPTYPE_Reg, REG_D, OPTYPE_Reg, REG_C, 1, 0, 0),
(('52', 'ff'), 'ld', OPTYPE_Reg, REG_D, OPTYPE_Reg, REG_D, 1, 0, 0),
(('53', 'ff'), 'ld', OPTYPE_Reg, REG_D, OPTYPE_Reg, REG_E, 1, 0, 0),
(('54', 'ff'), 'ld', OPTYPE_Reg, REG_D, OPTYPE_Reg, REG_H, 1, 0, 0),
(('55', 'ff'), 'ld', OPTYPE_Reg, REG_D, OPTYPE_Reg, REG_L, 1, 0, 0),
(('56', 'ff'), 'ld', OPTYPE_Reg, REG_D, OPTYPE_RegMem, REG_HL, 1, 0, 0),
(('57', 'ff'), 'ld', OPTYPE_Reg, REG_D, OPTYPE_Reg, REG_A, 1, 0, 0),
(('58', 'ff'), 'ld', OPTYPE_Reg, REG_E, OPTYPE_Reg, REG_B, 1, 0, 0),
(('59', 'ff'), 'ld', OPTYPE_Reg, REG_E, OPTYPE_Reg, REG_C, 1, 0, 0),
(('5a', 'ff'), 'ld', OPTYPE_Reg, REG_E, OPTYPE_Reg, REG_D, 1, 0, 0),
(('5b', 'ff'), 'ld', OPTYPE_Reg, REG_E, OPTYPE_Reg, REG_E, 1, 0, 0),
(('5c', 'ff'), 'ld', OPTYPE_Reg, REG_E, OPTYPE_Reg, REG_H, 1, 0, 0),
(('5d', 'ff'), 'ld', OPTYPE_Reg, REG_E, OPTYPE_Reg, REG_L, 1, 0, 0),
(('5e', 'ff'), 'ld', OPTYPE_Reg, REG_E, OPTYPE_RegMem, REG_HL, 1, 0, 0),
(('5f', 'ff'), 'ld', OPTYPE_Reg, REG_E, OPTYPE_Reg, REG_A, 1, 0, 0),
(('60', 'ff'), 'ld', OPTYPE_Reg, REG_H, OPTYPE_Reg, REG_B, 1, 0, 0),
(('61', 'ff'), 'ld', OPTYPE_Reg, REG_H, OPTYPE_Reg, REG_C, 1, 0, 0),
(('62', 'ff'), 'ld', OPTYPE_Reg, REG_H, OPTYPE_Reg, REG_D, 1, 0, 0),
(('63', 'ff'), 'ld', OPTYPE_Reg, REG_H, OPTYPE_Reg, REG_E, 1, 0, 0),
(('64', 'ff'), 'ld', OPTYPE_Reg, REG_H, OPTYPE_Reg, REG_H, 1, 0, 0),
(('65', 'ff'), 'ld', OPTYPE_Reg, REG_H, OPTYPE_Reg, REG_L, 1, 0, 0),
(('66', 'ff'), 'ld', OPTYPE_Reg, REG_H, OPTYPE_RegMem, REG_HL, 1, 0, 0),
(('67', 'ff'), 'ld', OPTYPE_Reg, REG_H, OPTYPE_Reg, REG_A, 1, 0, 0),
(('68', 'ff'), 'ld', OPTYPE_Reg, REG_L, OPTYPE_Reg, REG_B, 1, 0, 0),
(('69', 'ff'), 'ld', OPTYPE_Reg, REG_L, OPTYPE_Reg, REG_C, 1, 0, 0),
(('6a', 'ff'), 'ld', OPTYPE_Reg, REG_L, OPTYPE_Reg, REG_D, 1, 0, 0),
(('6b', 'ff'), 'ld', OPTYPE_Reg, REG_L, OPTYPE_Reg, REG_E, 1, 0, 0),
(('6c', 'ff'), 'ld', OPTYPE_Reg, REG_L, OPTYPE_Reg, REG_H, 1, 0, 0),
(('6d', 'ff'), 'ld', OPTYPE_Reg, REG_L, OPTYPE_Reg, REG_L, 1, 0, 0),
(('6e', 'ff'), 'ld', OPTYPE_Reg, REG_L, OPTYPE_RegMem, REG_HL, 1, 0, 0),
(('6f', 'ff'), 'ld', OPTYPE_Reg, REG_L, OPTYPE_Reg, REG_A, 1, 0, 0),
(('70', 'ff'), 'ld', OPTYPE_RegMem, REG_HL, OPTYPE_Reg, REG_B, 1, 0, 0),
(('71', 'ff'), 'ld', OPTYPE_RegMem, REG_HL, OPTYPE_Reg, REG_C, 1, 0, 0),
(('72', 'ff'), 'ld', OPTYPE_RegMem, REG_HL, OPTYPE_Reg, REG_D, 1, 0, 0),
(('73', 'ff'), 'ld', OPTYPE_RegMem, REG_HL, OPTYPE_Reg, REG_E, 1, 0, 0),
(('74', 'ff'), 'ld', OPTYPE_RegMem, REG_HL, OPTYPE_Reg, REG_H, 1, 0, 0),
(('75', 'ff'), 'ld', OPTYPE_RegMem, REG_HL, OPTYPE_Reg, REG_L, 1, 0, 0),
(('76', 'ff'), 'halt', None, None, None, None, 1, 0, 0),
(('77', 'ff'), 'ld', OPTYPE_RegMem, REG_HL, OPTYPE_Reg, REG_A, 1, 0, 0),
(('78', 'ff'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_B, 1, 0, 0),
(('79', 'ff'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_C, 1, 0, 0),
(('7a', 'ff'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_D, 1, 0, 0),
(('7b', 'ff'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_E, 1, 0, 0),
(('7c', 'ff'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_H, 1, 0, 0),
(('7d', 'ff'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_L, 1, 0, 0),
(('7e', 'ff'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_RegMem, REG_HL, 1, 0, 0),
(('7f', 'ff'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_A, 1, 0, 0),
(('80', 'ff'), 'add', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_B, 1, 0, 0),
(('81', 'ff'), 'add', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_C, 1, 0, 0),
(('82', 'ff'), 'add', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_D, 1, 0, 0),
(('83', 'ff'), 'add', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_E, 1, 0, 0),
(('84', 'ff'), 'add', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_H, 1, 0, 0),
(('85', 'ff'), 'add', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_L, 1, 0, 0),
(('86', 'ff'), 'add', OPTYPE_Reg, REG_A, OPTYPE_RegMem, REG_HL, 1, 0, 0),
(('87', 'ff'), 'add', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_A, 1, 0, 0),
(('88', 'ff'), 'adc', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_B, 1, 0, 0),
(('89', 'ff'), 'adc', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_C, 1, 0, 0),
(('8a', 'ff'), 'adc', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_D, 1, 0, 0),
(('8b', 'ff'), 'adc', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_E, 1, 0, 0),
(('8c', 'ff'), 'adc', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_H, 1, 0, 0),
(('8d', 'ff'), 'adc', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_L, 1, 0, 0),
(('8e', 'ff'), 'adc', OPTYPE_Reg, REG_A, OPTYPE_RegMem, REG_HL, 1, 0, 0),
(('8f', 'ff'), 'adc', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_A, 1, 0, 0),
(('90', 'ff'), 'sub', OPTYPE_Reg, REG_B, None, None, 1, 0, 0),
(('91', 'ff'), 'sub', OPTYPE_Reg, REG_C, None, None, 1, 0, 0),
(('92', 'ff'), 'sub', OPTYPE_Reg, REG_D, None, None, 1, 0, 0),
(('93', 'ff'), 'sub', OPTYPE_Reg, REG_E, None, None, 1, 0, 0),
(('94', 'ff'), 'sub', OPTYPE_Reg, REG_H, None, None, 1, 0, 0),
(('95', 'ff'), 'sub', OPTYPE_Reg, REG_L, None, None, 1, 0, 0),
(('96', 'ff'), 'sub', OPTYPE_RegMem, REG_HL, None, None, 1, 0, 0),
(('97', 'ff'), 'sub', OPTYPE_Reg, REG_A, None, None, 1, 0, 0),
(('98', 'ff'), 'sbc', OPTYPE_Reg, REG_B, None, None, 1, 0, 0),
(('99', 'ff'), 'sbc', OPTYPE_Reg, REG_C, None, None, 1, 0, 0),
(('9a', 'ff'), 'sbc', OPTYPE_Reg, REG_D, None, None, 1, 0, 0),
(('9b', 'ff'), 'sbc', OPTYPE_Reg, REG_E, None, None, 1, 0, 0),
(('9c', 'ff'), 'sbc', OPTYPE_Reg, REG_H, None, None, 1, 0, 0),
(('9d', 'ff'), 'sbc', OPTYPE_Reg, REG_L, None, None, 1, 0, 0),
(('9e', 'ff'), 'sbc', OPTYPE_RegMem, REG_HL, None, None, 1, 0, 0),
(('9f', 'ff'), 'sbc', OPTYPE_Reg, REG_A, None, None, 1, 0, 0),
(('a0', 'ff'), 'and', OPTYPE_Reg, REG_B, None, None, 1, 0, 0),
(('a1', 'ff'), 'and', OPTYPE_Reg, REG_C, None, None, 1, 0, 0),
(('a2', 'ff'), 'and', OPTYPE_Reg, REG_D, None, None, 1, 0, 0),
(('a3', 'ff'), 'and', OPTYPE_Reg, REG_E, None, None, 1, 0, 0),
(('a4', 'ff'), 'and', OPTYPE_Reg, REG_H, None, None, 1, 0, 0),
(('a5', 'ff'), 'and', OPTYPE_Reg, REG_L, None, None, 1, 0, 0),
(('a6', 'ff'), 'and', OPTYPE_RegMem, REG_HL, None, None, 1, 0, 0),
(('a7', 'ff'), 'and', OPTYPE_Reg, REG_A, None, None, 1, 0, 0),
(('a8', 'ff'), 'xor', OPTYPE_Reg, REG_B, None, None, 1, 0, 0),
(('a9', 'ff'), 'xor', OPTYPE_Reg, REG_C, None, None, 1, 0, 0),
(('aa', 'ff'), 'xor', OPTYPE_Reg, REG_D, None, None, 1, 0, 0),
(('ab', 'ff'), 'xor', OPTYPE_Reg, REG_E, None, None, 1, 0, 0),
(('ac', 'ff'), 'xor', OPTYPE_Reg, REG_H, None, None, 1, 0, 0),
(('ad', 'ff'), 'xor', OPTYPE_Reg, REG_L, None, None, 1, 0, 0),
(('ae', 'ff'), 'xor', OPTYPE_RegMem, REG_HL, None, None, 1, 0, 0),
(('af', 'ff'), 'xor', OPTYPE_Reg, REG_A, None, None, 1, 0, 0),
(('b0', 'ff'), 'or', OPTYPE_Reg, REG_B, None, None, 1, 0, 0),
(('b1', 'ff'), 'or', OPTYPE_Reg, REG_C, None, None, 1, 0, 0),
(('b2', 'ff'), 'or', OPTYPE_Reg, REG_D, None, None, 1, 0, 0),
(('b3', 'ff'), 'or', OPTYPE_Reg, REG_E, None, None, 1, 0, 0),
(('b4', 'ff'), 'or', OPTYPE_Reg, REG_H, None, None, 1, 0, 0),
(('b5', 'ff'), 'or', OPTYPE_Reg, REG_L, None, None, 1, 0, 0),
(('b6', 'ff'), 'or', OPTYPE_RegMem, REG_HL, None, None, 1, 0, 0),
(('b7', 'ff'), 'or', OPTYPE_Reg, REG_A, None, None, 1, 0, 0),
(('b8', 'ff'), 'cp', OPTYPE_Reg, REG_B, None, None, 1, 0, 0),
(('b9', 'ff'), 'cp', OPTYPE_Reg, REG_C, None, None, 1, 0, 0),
(('ba', 'ff'), 'cp', OPTYPE_Reg, REG_D, None, None, 1, 0, 0),
(('bb', 'ff'), 'cp', OPTYPE_Reg, REG_E, None, None, 1, 0, 0),
(('bc', 'ff'), 'cp', OPTYPE_Reg, REG_H, None, None, 1, 0, 0),
(('bd', 'ff'), 'cp', OPTYPE_Reg, REG_L, None, None, 1, 0, 0),
(('be', 'ff'), 'cp', OPTYPE_RegMem, REG_HL, None, None, 1, 0, 0),
(('bf', 'ff'), 'cp', OPTYPE_Reg, REG_A, None, None, 1, 0, 0),
(('c0', 'ff'), 'ret', OPTYPE_Cond, COND_NZ, None, None, 1, 0, 0),
(('c1', 'ff'), 'pop', OPTYPE_Reg, REG_BC, None, None, 1, 0, 0),
(('c2', 'ff'), 'jp', OPTYPE_Cond, COND_NZ, OPTYPE_Ind, None, 1, 0, 0),
(('c3', 'ff'), 'jp', OPTYPE_imm16, None, None, None, 3, 1, 0),
(('c40000', 'ff0000'), 'call', OPTYPE_Cond, COND_NZ, OPTYPE_imm16, None, 3, 1, 0),
(('c5', 'ff'), 'push', OPTYPE_Reg, REG_BC, None, None, 1, 0, 0),
(('c600', 'ff00'), 'add', OPTYPE_Reg, REG_A, OPTYPE_imm8, None, 2, 1, 0),
(('c7', 'ff'), 'rst', OPTYPE_const, 0, None, None, 1, 0, 0),
(('c8', 'ff'), 'ret', OPTYPE_Cond, COND_Z, None, None, 1, 0, 0),
(('c9', 'ff'), 'ret', None, None, None, None, 1, 0, 0),
(('ca', 'ff'), 'jp', OPTYPE_Cond, COND_Z, OPTYPE_Ind, None, 1, 0, 0),
(('cb00', 'ffff'), 'rlc', OPTYPE_Reg, REG_B, None, None, 2, 0, 0),
(('cb01', 'ffff'), 'rlc', OPTYPE_Reg, REG_C, None, None, 2, 0, 0),
(('cb02', 'ffff'), 'rlc', OPTYPE_Reg, REG_D, None, None, 2, 0, 0),
(('cb03', 'ffff'), 'rlc', OPTYPE_Reg, REG_E, None, None, 2, 0, 0),
(('cb04', 'ffff'), 'rlc', OPTYPE_Reg, REG_H, None, None, 2, 0, 0),
(('cb05', 'ffff'), 'rlc', OPTYPE_Reg, REG_L, None, None, 2, 0, 0),
(('cb06', 'ffff'), 'rlc', OPTYPE_RegMem, REG_HL, None, None, 2, 0, 0),
(('cb07', 'ffff'), 'rlc', OPTYPE_Reg, REG_A, None, None, 2, 0, 0),
(('cb08', 'ffff'), 'rrc', OPTYPE_Reg, REG_B, None, None, 2, 0, 0),
(('cb09', 'ffff'), 'rrc', OPTYPE_Reg, REG_C, None, None, 2, 0, 0),
(('cb0a', 'ffff'), 'rrc', OPTYPE_Reg, REG_D, None, None, 2, 0, 0),
(('cb0b', 'ffff'), 'rrc', OPTYPE_Reg, REG_E, None, None, 2, 0, 0),
(('cb0c', 'ffff'), 'rrc', OPTYPE_Reg, REG_H, None, None, 2, 0, 0),
(('cb0d', 'ffff'), 'rrc', OPTYPE_Reg, REG_L, None, None, 2, 0, 0),
(('cb0e', 'ffff'), 'rrc', OPTYPE_RegMem, REG_HL, None, None, 2, 0, 0),
(('cb0f', 'ffff'), 'rrc', OPTYPE_Reg, REG_A, None, None, 2, 0, 0),
(('cb10', 'ffff'), 'rl', OPTYPE_Reg, REG_B, None, None, 2, 0, 0),
(('cb11', 'ffff'), 'rl', OPTYPE_Reg, REG_C, None, None, 2, 0, 0),
(('cb12', 'ffff'), 'rl', OPTYPE_Reg, REG_D, None, None, 2, 0, 0),
(('cb13', 'ffff'), 'rl', OPTYPE_Reg, REG_E, None, None, 2, 0, 0),
(('cb14', 'ffff'), 'rl', OPTYPE_Reg, REG_H, None, None, 2, 0, 0),
(('cb15', 'ffff'), 'rl', OPTYPE_Reg, REG_L, None, None, 2, 0, 0),
(('cb16', 'ffff'), 'rl', OPTYPE_RegMem, REG_HL, None, None, 2, 0, 0),
(('cb17', 'ffff'), 'rl', OPTYPE_Reg, REG_A, None, None, 2, 0, 0),
(('cb18', 'ffff'), 'rr', OPTYPE_Reg, REG_B, None, None, 2, 0, 0),
(('cb19', 'ffff'), 'rr', OPTYPE_Reg, REG_C, None, None, 2, 0, 0),
(('cb1a', 'ffff'), 'rr', OPTYPE_Reg, REG_D, None, None, 2, 0, 0),
(('cb1b', 'ffff'), 'rr', OPTYPE_Reg, REG_E, None, None, 2, 0, 0),
(('cb1c', 'ffff'), 'rr', OPTYPE_Reg, REG_H, None, None, 2, 0, 0),
(('cb1d', 'ffff'), 'rr', OPTYPE_Reg, REG_L, None, None, 2, 0, 0),
(('cb1e', 'ffff'), 'rr', OPTYPE_RegMem, REG_HL, None, None, 2, 0, 0),
(('cb1f', 'ffff'), 'rr', OPTYPE_Reg, REG_A, None, None, 2, 0, 0),
(('cb20', 'ffff'), 'sla', OPTYPE_Reg, REG_B, None, None, 2, 0, 0),
(('cb21', 'ffff'), 'sla', OPTYPE_Reg, REG_C, None, None, 2, 0, 0),
(('cb22', 'ffff'), 'sla', OPTYPE_Reg, REG_D, None, None, 2, 0, 0),
(('cb23', 'ffff'), 'sla', OPTYPE_Reg, REG_E, None, None, 2, 0, 0),
(('cb24', 'ffff'), 'sla', OPTYPE_Reg, REG_H, None, None, 2, 0, 0),
(('cb25', 'ffff'), 'sla', OPTYPE_Reg, REG_L, None, None, 2, 0, 0),
(('cb26', 'ffff'), 'sla', OPTYPE_RegMem, REG_HL, None, None, 2, 0, 0),
(('cb27', 'ffff'), 'sla', OPTYPE_Reg, REG_A, None, None, 2, 0, 0),
(('cb28', 'ffff'), 'sra', OPTYPE_Reg, REG_B, None, None, 2, 0, 0),
(('cb29', 'ffff'), 'sra', OPTYPE_Reg, REG_C, None, None, 2, 0, 0),
(('cb2a', 'ffff'), 'sra', OPTYPE_Reg, REG_D, None, None, 2, 0, 0),
(('cb2b', 'ffff'), 'sra', OPTYPE_Reg, REG_E, None, None, 2, 0, 0),
(('cb2c', 'ffff'), 'sra', OPTYPE_Reg, REG_H, None, None, 2, 0, 0),
(('cb2d', 'ffff'), 'sra', OPTYPE_Reg, REG_L, None, None, 2, 0, 0),
(('cb2e', 'ffff'), 'sra', OPTYPE_RegMem, REG_HL, None, None, 2, 0, 0),
(('cb2f', 'ffff'), 'sra', OPTYPE_Reg, REG_A, None, None, 2, 0, 0),
(('cb38', 'ffff'), 'srl', OPTYPE_Reg, REG_B, None, None, 2, 0, 0),
(('cb39', 'ffff'), 'srl', OPTYPE_Reg, REG_C, None, None, 2, 0, 0),
(('cb3a', 'ffff'), 'srl', OPTYPE_Reg, REG_D, None, None, 2, 0, 0),
(('cb3b', 'ffff'), 'srl', OPTYPE_Reg, REG_E, None, None, 2, 0, 0),
(('cb3c', 'ffff'), 'srl', OPTYPE_Reg, REG_H, None, None, 2, 0, 0),
(('cb3d', 'ffff'), 'srl', OPTYPE_Reg, REG_L, None, None, 2, 0, 0),
(('cb3e', 'ffff'), 'srl', OPTYPE_RegMem, REG_HL, None, None, 2, 0, 0),
(('cb3f', 'ffff'), 'srl', OPTYPE_Reg, REG_A, None, None, 2, 0, 0),
(('cb40', 'ffff'), 'bit', OPTYPE_const, 0, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cb41', 'ffff'), 'bit', OPTYPE_const, 0, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cb42', 'ffff'), 'bit', OPTYPE_const, 0, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cb43', 'ffff'), 'bit', OPTYPE_const, 0, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cb44', 'ffff'), 'bit', OPTYPE_const, 0, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cb45', 'ffff'), 'bit', OPTYPE_const, 0, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cb46', 'ffff'), 'bit', OPTYPE_const, 0, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cb47', 'ffff'), 'bit', OPTYPE_const, 0, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cb48', 'ffff'), 'bit', OPTYPE_const, 1, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cb49', 'ffff'), 'bit', OPTYPE_const, 1, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cb4a', 'ffff'), 'bit', OPTYPE_const, 1, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cb4b', 'ffff'), 'bit', OPTYPE_const, 1, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cb4c', 'ffff'), 'bit', OPTYPE_const, 1, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cb4d', 'ffff'), 'bit', OPTYPE_const, 1, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cb4e', 'ffff'), 'bit', OPTYPE_const, 1, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cb4f', 'ffff'), 'bit', OPTYPE_const, 1, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cb50', 'ffff'), 'bit', OPTYPE_const, 2, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cb51', 'ffff'), 'bit', OPTYPE_const, 2, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cb52', 'ffff'), 'bit', OPTYPE_const, 2, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cb53', 'ffff'), 'bit', OPTYPE_const, 2, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cb54', 'ffff'), 'bit', OPTYPE_const, 2, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cb55', 'ffff'), 'bit', OPTYPE_const, 2, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cb56', 'ffff'), 'bit', OPTYPE_const, 2, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cb57', 'ffff'), 'bit', OPTYPE_const, 2, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cb58', 'ffff'), 'bit', OPTYPE_const, 3, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cb59', 'ffff'), 'bit', OPTYPE_const, 3, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cb5a', 'ffff'), 'bit', OPTYPE_const, 3, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cb5b', 'ffff'), 'bit', OPTYPE_const, 3, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cb5c', 'ffff'), 'bit', OPTYPE_const, 3, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cb5d', 'ffff'), 'bit', OPTYPE_const, 3, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cb5e', 'ffff'), 'bit', OPTYPE_const, 3, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cb5f', 'ffff'), 'bit', OPTYPE_const, 3, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cb60', 'ffff'), 'bit', OPTYPE_const, 4, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cb61', 'ffff'), 'bit', OPTYPE_const, 4, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cb62', 'ffff'), 'bit', OPTYPE_const, 4, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cb63', 'ffff'), 'bit', OPTYPE_const, 4, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cb64', 'ffff'), 'bit', OPTYPE_const, 4, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cb65', 'ffff'), 'bit', OPTYPE_const, 4, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cb66', 'ffff'), 'bit', OPTYPE_const, 4, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cb67', 'ffff'), 'bit', OPTYPE_const, 4, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cb68', 'ffff'), 'bit', OPTYPE_const, 5, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cb69', 'ffff'), 'bit', OPTYPE_const, 5, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cb6a', 'ffff'), 'bit', OPTYPE_const, 5, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cb6b', 'ffff'), 'bit', OPTYPE_const, 5, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cb6c', 'ffff'), 'bit', OPTYPE_const, 5, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cb6d', 'ffff'), 'bit', OPTYPE_const, 5, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cb6e', 'ffff'), 'bit', OPTYPE_const, 5, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cb6f', 'ffff'), 'bit', OPTYPE_const, 5, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cb70', 'ffff'), 'bit', OPTYPE_const, 6, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cb71', 'ffff'), 'bit', OPTYPE_const, 6, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cb72', 'ffff'), 'bit', OPTYPE_const, 6, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cb73', 'ffff'), 'bit', OPTYPE_const, 6, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cb74', 'ffff'), 'bit', OPTYPE_const, 6, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cb75', 'ffff'), 'bit', OPTYPE_const, 6, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cb76', 'ffff'), 'bit', OPTYPE_const, 6, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cb77', 'ffff'), 'bit', OPTYPE_const, 6, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cb78', 'ffff'), 'bit', OPTYPE_const, 7, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cb79', 'ffff'), 'bit', OPTYPE_const, 7, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cb7a', 'ffff'), 'bit', OPTYPE_const, 7, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cb7b', 'ffff'), 'bit', OPTYPE_const, 7, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cb7c', 'ffff'), 'bit', OPTYPE_const, 7, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cb7d', 'ffff'), 'bit', OPTYPE_const, 7, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cb7e', 'ffff'), 'bit', OPTYPE_const, 7, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cb7f', 'ffff'), 'bit', OPTYPE_const, 7, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cb80', 'ffff'), 'res', OPTYPE_const, 0, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cb81', 'ffff'), 'res', OPTYPE_const, 0, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cb82', 'ffff'), 'res', OPTYPE_const, 0, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cb83', 'ffff'), 'res', OPTYPE_const, 0, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cb84', 'ffff'), 'res', OPTYPE_const, 0, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cb85', 'ffff'), 'res', OPTYPE_const, 0, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cb86', 'ffff'), 'res', OPTYPE_const, 0, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cb87', 'ffff'), 'res', OPTYPE_const, 0, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cb88', 'ffff'), 'res', OPTYPE_const, 1, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cb89', 'ffff'), 'res', OPTYPE_const, 1, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cb8a', 'ffff'), 'res', OPTYPE_const, 1, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cb8b', 'ffff'), 'res', OPTYPE_const, 1, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cb8c', 'ffff'), 'res', OPTYPE_const, 1, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cb8d', 'ffff'), 'res', OPTYPE_const, 1, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cb8e', 'ffff'), 'res', OPTYPE_const, 1, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cb8f', 'ffff'), 'res', OPTYPE_const, 1, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cb90', 'ffff'), 'res', OPTYPE_const, 2, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cb91', 'ffff'), 'res', OPTYPE_const, 2, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cb92', 'ffff'), 'res', OPTYPE_const, 2, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cb93', 'ffff'), 'res', OPTYPE_const, 2, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cb94', 'ffff'), 'res', OPTYPE_const, 2, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cb95', 'ffff'), 'res', OPTYPE_const, 2, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cb96', 'ffff'), 'res', OPTYPE_const, 2, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cb97', 'ffff'), 'res', OPTYPE_const, 2, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cb98', 'ffff'), 'res', OPTYPE_const, 3, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cb99', 'ffff'), 'res', OPTYPE_const, 3, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cb9a', 'ffff'), 'res', OPTYPE_const, 3, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cb9b', 'ffff'), 'res', OPTYPE_const, 3, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cb9c', 'ffff'), 'res', OPTYPE_const, 3, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cb9d', 'ffff'), 'res', OPTYPE_const, 3, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cb9e', 'ffff'), 'res', OPTYPE_const, 3, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cb9f', 'ffff'), 'res', OPTYPE_const, 3, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cba0', 'ffff'), 'res', OPTYPE_const, 4, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cba1', 'ffff'), 'res', OPTYPE_const, 4, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cba2', 'ffff'), 'res', OPTYPE_const, 4, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cba3', 'ffff'), 'res', OPTYPE_const, 4, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cba4', 'ffff'), 'res', OPTYPE_const, 4, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cba5', 'ffff'), 'res', OPTYPE_const, 4, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cba6', 'ffff'), 'res', OPTYPE_const, 4, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cba7', 'ffff'), 'res', OPTYPE_const, 4, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cba8', 'ffff'), 'res', OPTYPE_const, 5, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cba9', 'ffff'), 'res', OPTYPE_const, 5, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cbaa', 'ffff'), 'res', OPTYPE_const, 5, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cbab', 'ffff'), 'res', OPTYPE_const, 5, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cbac', 'ffff'), 'res', OPTYPE_const, 5, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cbad', 'ffff'), 'res', OPTYPE_const, 5, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cbae', 'ffff'), 'res', OPTYPE_const, 5, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cbaf', 'ffff'), 'res', OPTYPE_const, 5, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cbb0', 'ffff'), 'res', OPTYPE_const, 6, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cbb1', 'ffff'), 'res', OPTYPE_const, 6, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cbb2', 'ffff'), 'res', OPTYPE_const, 6, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cbb3', 'ffff'), 'res', OPTYPE_const, 6, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cbb4', 'ffff'), 'res', OPTYPE_const, 6, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cbb5', 'ffff'), 'res', OPTYPE_const, 6, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cbb6', 'ffff'), 'res', OPTYPE_const, 6, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cbb7', 'ffff'), 'res', OPTYPE_const, 6, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cbb8', 'ffff'), 'res', OPTYPE_const, 7, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cbb9', 'ffff'), 'res', OPTYPE_const, 7, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cbba', 'ffff'), 'res', OPTYPE_const, 7, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cbbb', 'ffff'), 'res', OPTYPE_const, 7, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cbbc', 'ffff'), 'res', OPTYPE_const, 7, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cbbd', 'ffff'), 'res', OPTYPE_const, 7, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cbbe', 'ffff'), 'res', OPTYPE_const, 7, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cbbf', 'ffff'), 'res', OPTYPE_const, 7, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cbc0', 'ffff'), 'set', OPTYPE_const, 0, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cbc1', 'ffff'), 'set', OPTYPE_const, 0, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cbc2', 'ffff'), 'set', OPTYPE_const, 0, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cbc3', 'ffff'), 'set', OPTYPE_const, 0, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cbc4', 'ffff'), 'set', OPTYPE_const, 0, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cbc5', 'ffff'), 'set', OPTYPE_const, 0, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cbc6', 'ffff'), 'set', OPTYPE_const, 0, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cbc7', 'ffff'), 'set', OPTYPE_const, 0, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cbc8', 'ffff'), 'set', OPTYPE_const, 1, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cbc9', 'ffff'), 'set', OPTYPE_const, 1, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cbca', 'ffff'), 'set', OPTYPE_const, 1, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cbcb', 'ffff'), 'set', OPTYPE_const, 1, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cbcc', 'ffff'), 'set', OPTYPE_const, 1, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cbcd', 'ffff'), 'set', OPTYPE_const, 1, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cbce', 'ffff'), 'set', OPTYPE_const, 1, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cbcf', 'ffff'), 'set', OPTYPE_const, 1, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cbd0', 'ffff'), 'set', OPTYPE_const, 2, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cbd1', 'ffff'), 'set', OPTYPE_const, 2, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cbd2', 'ffff'), 'set', OPTYPE_const, 2, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cbd3', 'ffff'), 'set', OPTYPE_const, 2, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cbd4', 'ffff'), 'set', OPTYPE_const, 2, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cbd5', 'ffff'), 'set', OPTYPE_const, 2, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cbd6', 'ffff'), 'set', OPTYPE_const, 2, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cbd7', 'ffff'), 'set', OPTYPE_const, 2, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cbd8', 'ffff'), 'set', OPTYPE_const, 3, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cbd9', 'ffff'), 'set', OPTYPE_const, 3, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cbda', 'ffff'), 'set', OPTYPE_const, 3, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cbdb', 'ffff'), 'set', OPTYPE_const, 3, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cbdc', 'ffff'), 'set', OPTYPE_const, 3, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cbdd', 'ffff'), 'set', OPTYPE_const, 3, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cbde', 'ffff'), 'set', OPTYPE_const, 3, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cbdf', 'ffff'), 'set', OPTYPE_const, 3, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cbe0', 'ffff'), 'set', OPTYPE_const, 4, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cbe1', 'ffff'), 'set', OPTYPE_const, 4, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cbe2', 'ffff'), 'set', OPTYPE_const, 4, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cbe3', 'ffff'), 'set', OPTYPE_const, 4, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cbe4', 'ffff'), 'set', OPTYPE_const, 4, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cbe5', 'ffff'), 'set', OPTYPE_const, 4, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cbe6', 'ffff'), 'set', OPTYPE_const, 4, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cbe7', 'ffff'), 'set', OPTYPE_const, 4, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cbe8', 'ffff'), 'set', OPTYPE_const, 5, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cbe9', 'ffff'), 'set', OPTYPE_const, 5, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cbea', 'ffff'), 'set', OPTYPE_const, 5, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cbeb', 'ffff'), 'set', OPTYPE_const, 5, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cbec', 'ffff'), 'set', OPTYPE_const, 5, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cbed', 'ffff'), 'set', OPTYPE_const, 5, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cbee', 'ffff'), 'set', OPTYPE_const, 5, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cbef', 'ffff'), 'set', OPTYPE_const, 5, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cbf0', 'ffff'), 'set', OPTYPE_const, 6, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cbf1', 'ffff'), 'set', OPTYPE_const, 6, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cbf2', 'ffff'), 'set', OPTYPE_const, 6, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cbf3', 'ffff'), 'set', OPTYPE_const, 6, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cbf4', 'ffff'), 'set', OPTYPE_const, 6, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cbf5', 'ffff'), 'set', OPTYPE_const, 6, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cbf6', 'ffff'), 'set', OPTYPE_const, 6, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cbf7', 'ffff'), 'set', OPTYPE_const, 6, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cbf8', 'ffff'), 'set', OPTYPE_const, 7, OPTYPE_Reg, REG_B, 2, 0, 0),
(('cbf9', 'ffff'), 'set', OPTYPE_const, 7, OPTYPE_Reg, REG_C, 2, 0, 0),
(('cbfa', 'ffff'), 'set', OPTYPE_const, 7, OPTYPE_Reg, REG_D, 2, 0, 0),
(('cbfb', 'ffff'), 'set', OPTYPE_const, 7, OPTYPE_Reg, REG_E, 2, 0, 0),
(('cbfc', 'ffff'), 'set', OPTYPE_const, 7, OPTYPE_Reg, REG_H, 2, 0, 0),
(('cbfd', 'ffff'), 'set', OPTYPE_const, 7, OPTYPE_Reg, REG_L, 2, 0, 0),
(('cbfe', 'ffff'), 'set', OPTYPE_const, 7, OPTYPE_RegMem, REG_HL, 2, 0, 0),
(('cbff', 'ffff'), 'set', OPTYPE_const, 7, OPTYPE_Reg, REG_A, 2, 0, 0),
(('cc0000', 'ff0000'), 'call', OPTYPE_Cond, COND_Z, OPTYPE_imm16, None, 3, 1, 0),
(('cd0000', 'ff0000'), 'call', OPTYPE_imm16, None, None, None, 3, 1, 0),
(('ce00', 'ff00'), 'adc', OPTYPE_Reg, REG_A, OPTYPE_imm8, None, 2, 1, 0),
(('cf', 'ff'), 'rst', OPTYPE_const, 8, None, None, 1, 0, 0),
(('d0', 'ff'), 'ret', OPTYPE_Cond, COND_NC, None, None, 1, 0, 0),
(('d1', 'ff'), 'pop', OPTYPE_Reg, REG_DE, None, None, 1, 0, 0),
(('d2', 'ff'), 'jp', OPTYPE_Cond, COND_NC, OPTYPE_Ind, None, 1, 0, 0),
(('d300', 'ff00'), 'out', OPTYPE_immmem8, None, OPTYPE_Reg, REG_A, 2, 1, 0),
(('d40000', 'ff0000'), 'call', OPTYPE_Cond, COND_NC, OPTYPE_imm16, None, 3, 1, 0),
(('d40000', 'ff0000'), 'call', OPTYPE_Cond, COND_NC, OPTYPE_imm16, None, 3, 1, 0),
(('d5', 'ff'), 'push', OPTYPE_Reg, REG_DE, None, None, 1, 0, 0),
(('d600', 'ff00'), 'sub', OPTYPE_imm8, None, None, None, 2, 1, 0),
(('d7', 'ff'), 'rst', OPTYPE_const, 16, None, None, 1, 0, 0),
(('d8', 'ff'), 'ret', OPTYPE_Reg, REG_C, None, None, 1, 0, 0),
(('d9', 'ff'), 'exx', None, None, None, None, 1, 0, 0),
(('da', 'ff'), 'jp', OPTYPE_Reg, REG_C, OPTYPE_Ind, None, 1, 0, 0),
(('db00', 'ff00'), 'in', OPTYPE_Reg, REG_A, OPTYPE_immmem8, None, 2, 1, 0),
(('dc0000', 'ff0000'), 'call', OPTYPE_Reg, REG_C, OPTYPE_imm16, None, 3, 1, 0),
(('dd09', 'ffff'), 'add', OPTYPE_Reg, REG_IX, OPTYPE_Reg, REG_BC, 2, 0, 0),
(('dd19', 'ffff'), 'add', OPTYPE_Reg, REG_IX, OPTYPE_Reg, REG_DE, 2, 0, 0),
(('dd210000', 'ffff0000'), 'ld', OPTYPE_Reg, REG_IX, OPTYPE_imm16, None, 4, 2, 0),
(('dd220000', 'ffff0000'), 'ld', OPTYPE_immmem16, None, OPTYPE_Reg, REG_IX, 4, 2, 0),
(('dd23', 'ffff'), 'inc', OPTYPE_Reg, REG_IX, None, None, 2, 0, 0),
(('dd29', 'ffff'), 'add', OPTYPE_Reg, REG_IX, OPTYPE_Reg, REG_IX, 2, 0, 0),
(('dd2a0000', 'ffff0000'), 'ld', OPTYPE_Reg, REG_IX, OPTYPE_immmem16, None, 4, 2, 0),
(('dd2b', 'ffff'), 'dec', OPTYPE_Reg, REG_IX, None, None, 2, 0, 0),
(('dd3400', 'ffff00'), 'inc', OPTYPE_RegMemDisp, REG_IX, None, None, 3, 2, 0),
(('dd3500', 'ffff00'), 'dec', OPTYPE_RegMemDisp, REG_IX, None, None, 3, 2, 0),
(('dd360000', 'ffff0000'), 'ld', OPTYPE_RegMemDisp, REG_IX, OPTYPE_imm8, None, 4, 2, 0),
(('dd39', 'ffff'), 'add', OPTYPE_Reg, REG_IX, OPTYPE_Reg, REG_SP, 2, 0, 0),
(('dd4600', 'ffff00'), 'ld', OPTYPE_Reg, REG_B, OPTYPE_RegMemDisp, REG_IX, 3, 2, 0),
(('dd4e00', 'ffff00'), 'ld', OPTYPE_Reg, REG_C, OPTYPE_RegMemDisp, REG_IX, 3, 2, 0),
(('dd5600', 'ffff00'), 'ld', OPTYPE_Reg, REG_D, OPTYPE_RegMemDisp, REG_IX, 3, 2, 0),
(('dd5e00', 'ffff00'), 'ld', OPTYPE_Reg, REG_E, OPTYPE_RegMemDisp, REG_IX, 3, 2, 0),
(('dd6600', 'ffff00'), 'ld', OPTYPE_Reg, REG_H, OPTYPE_RegMemDisp, REG_IX, 3, 2, 0),
(('dd6e00', 'ffff00'), 'ld', OPTYPE_Reg, REG_L, OPTYPE_RegMemDisp, REG_IX, 3, 2, 0),
(('dd7000', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IX, OPTYPE_Reg, REG_B, 3, 2, 0),
(('dd7100', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IX, OPTYPE_Reg, REG_C, 3, 2, 0),
(('dd7200', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IX, OPTYPE_Reg, REG_D, 3, 2, 0),
(('dd7300', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IX, OPTYPE_Reg, REG_E, 3, 2, 0),
(('dd7400', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IX, OPTYPE_Reg, REG_H, 3, 2, 0),
(('dd7500', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IX, OPTYPE_Reg, REG_L, 3, 2, 0),
(('dd7700', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IX, OPTYPE_Reg, REG_A, 3, 2, 0),
(('dd7e00', 'ffff00'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_RegMemDisp, REG_IX, 3, 2, 0),
(('dd8600', 'ffff00'), 'add', OPTYPE_Reg, REG_A, OPTYPE_RegMemDisp, REG_IX, 3, 2, 0),
(('dd8e00', 'ffff00'), 'adc', OPTYPE_Reg, REG_A, OPTYPE_RegMemDisp, REG_IX, 3, 2, 0),
(('dd9600', 'ffff00'), 'sub', OPTYPE_RegMemDisp, REG_IX, None, None, 3, 2, 0),
(('dd9e00', 'ffff00'), 'sbc', OPTYPE_Reg, REG_A, OPTYPE_RegMemDisp, REG_IX, 3, 2, 0),
(('dda600', 'ffff00'), 'and', OPTYPE_RegMemDisp, REG_IX, None, None, 3, 2, 0),
(('ddae00', 'ffff00'), 'xor', OPTYPE_RegMemDisp, REG_IX, None, None, 3, 2, 0),
(('ddb600', 'ffff00'), 'or', OPTYPE_RegMemDisp, REG_IX, None, None, 3, 2, 0),
(('ddbe00', 'ffff00'), 'cp', OPTYPE_RegMemDisp, REG_IX, None, None, 3, 2, 0),
(('ddcb0006', 'ffff00ff'), 'rlc', OPTYPE_RegMemDisp, REG_IX, None, None, 4, 2, 0),
(('ddcb000e', 'ffff00ff'), 'rrc', OPTYPE_RegMemDisp, REG_IX, None, None, 4, 2, 0),
(('ddcb0016', 'ffff00ff'), 'rl', OPTYPE_RegMemDisp, REG_IX, None, None, 4, 2, 0),
(('ddcb001e', 'ffff00ff'), 'rr', OPTYPE_RegMemDisp, REG_IX, None, None, 4, 2, 0),
(('ddcb0026', 'ffff00ff'), 'sla', OPTYPE_RegMemDisp, REG_IX, None, None, 4, 2, 0),
(('ddcb002e', 'ffff00ff'), 'sra', OPTYPE_RegMemDisp, REG_IX, None, None, 4, 2, 0),
(('ddcb0046', 'ffff00ff'), 'bit', OPTYPE_const, 0, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb004e', 'ffff00ff'), 'bit', OPTYPE_const, 1, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb0056', 'ffff00ff'), 'bit', OPTYPE_const, 2, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb005e', 'ffff00ff'), 'bit', OPTYPE_const, 3, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb0066', 'ffff00ff'), 'bit', OPTYPE_const, 4, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb006e', 'ffff00ff'), 'bit', OPTYPE_const, 5, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb0076', 'ffff00ff'), 'bit', OPTYPE_const, 6, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb007e', 'ffff00ff'), 'bit', OPTYPE_const, 7, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb0086', 'ffff00ff'), 'res', OPTYPE_const, 0, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb008e', 'ffff00ff'), 'res', OPTYPE_const, 1, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb0096', 'ffff00ff'), 'res', OPTYPE_const, 2, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb009e', 'ffff00ff'), 'res', OPTYPE_const, 3, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb00a6', 'ffff00ff'), 'res', OPTYPE_const, 4, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb00ae', 'ffff00ff'), 'res', OPTYPE_const, 5, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb00b6', 'ffff00ff'), 'res', OPTYPE_const, 6, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb00be', 'ffff00ff'), 'res', OPTYPE_const, 7, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb00c6', 'ffff00ff'), 'set', OPTYPE_const, 0, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb00ce', 'ffff00ff'), 'set', OPTYPE_const, 1, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb00d6', 'ffff00ff'), 'set', OPTYPE_const, 2, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb00de', 'ffff00ff'), 'set', OPTYPE_const, 3, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb00e6', 'ffff00ff'), 'set', OPTYPE_const, 4, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb00ee', 'ffff00ff'), 'set', OPTYPE_const, 5, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb00f6', 'ffff00ff'), 'set', OPTYPE_const, 6, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('ddcb00fe', 'ffff00ff'), 'set', OPTYPE_const, 7, OPTYPE_RegMemDisp, REG_IX, 4, 2, 0),
(('dde1', 'ffff'), 'pop', OPTYPE_Reg, REG_IX, None, None, 2, 0, 0),
(('dde3', 'ffff'), 'ex', OPTYPE_RegMem, REG_SP, OPTYPE_Reg, REG_IX, 2, 0, 0),
(('dde5', 'ffff'), 'push', OPTYPE_Reg, REG_IX, None, None, 2, 0, 0),
(('dde9', 'ffff'), 'jp', OPTYPE_RegMem, REG_IX, None, None, 2, 0, 0),
(('ddf9', 'ffff'), 'ld', OPTYPE_Reg, REG_SP, OPTYPE_Reg, REG_IX, 2, 0, 0),
(('de00', 'ff00'), 'sbc', OPTYPE_Reg, REG_A, OPTYPE_imm8, None, 2, 1, 0),
(('df', 'ff'), 'rst', OPTYPE_const, 24, None, None, 1, 0, 0),
(('e0', 'ff'), 'ret', OPTYPE_Cond, COND_PO, None, None, 1, 0, 0),
(('e1', 'ff'), 'pop', OPTYPE_Reg, REG_HL, None, None, 1, 0, 0),
(('e2', 'ff'), 'jp', OPTYPE_Cond, COND_PO, OPTYPE_Ind, None, 1, 0, 0),
(('e3', 'ff'), 'ex', OPTYPE_RegMem, REG_SP, OPTYPE_Reg, REG_HL, 1, 0, 0),
(('e40000', 'ff0000'), 'call', OPTYPE_Cond, COND_PO, OPTYPE_imm16, None, 3, 1, 0),
(('e5', 'ff'), 'push', OPTYPE_Reg, REG_HL, None, None, 1, 0, 0),
(('e600', 'ff00'), 'and', OPTYPE_imm8, None, None, None, 2, 1, 0),
(('e7', 'ff'), 'rst', OPTYPE_const, 32, None, None, 1, 0, 0),
(('e8', 'ff'), 'ret', OPTYPE_Cond, COND_PE, None, None, 1, 0, 0),
(('e9', 'ff'), 'jp', OPTYPE_RegMem, REG_HL, None, None, 1, 0, 0),
(('ea', 'ff'), 'jp', OPTYPE_Cond, COND_PE, OPTYPE_Ind, None, 1, 0, 0),
(('eb', 'ff'), 'ex', OPTYPE_Reg, REG_DE, OPTYPE_Reg, REG_HL, 1, 0, 0),
(('ec0000', 'ff0000'), 'call', OPTYPE_Cond, COND_PE, OPTYPE_imm16, None, 3, 1, 0),
(('ed40', 'ffff'), 'in', OPTYPE_Reg, REG_B, OPTYPE_RegMem, REG_C, 2, 0, 0),
(('ed41', 'ffff'), 'out', OPTYPE_RegMem, REG_C, OPTYPE_Reg, REG_B, 2, 0, 0),
(('ed42', 'ffff'), 'sbc', OPTYPE_Reg, REG_HL, OPTYPE_Reg, REG_BC, 2, 0, 0),
(('ed430000', 'ffff0000'), 'ld', OPTYPE_immmem16, None, OPTYPE_Reg, REG_BC, 4, 2, 0),
(('ed44', 'ffff'), 'neg', None, None, None, None, 2, 0, 0),
(('ed45', 'ffff'), 'retn', None, None, None, None, 2, 0, 0),
(('ed46', 'ffff'), 'im', OPTYPE_const, 0, None, None, 2, 0, 0),
(('ed47', 'ffff'), 'ld', OPTYPE_Reg, REG_I, OPTYPE_Reg, REG_A, 2, 0, 0),
(('ed48', 'ffff'), 'in', OPTYPE_Reg, REG_C, OPTYPE_RegMem, REG_C, 2, 0, 0),
(('ed49', 'ffff'), 'out', OPTYPE_RegMem, REG_C, OPTYPE_Reg, REG_C, 2, 0, 0),
(('ed4a', 'ffff'), 'adc', OPTYPE_Reg, REG_HL, OPTYPE_Reg, REG_BC, 2, 0, 0),
(('ed4b0000', 'ffff0000'), 'ld', OPTYPE_Reg, REG_BC, OPTYPE_immmem16, None, 4, 2, 0),
(('ed4d', 'ffff'), 'reti', None, None, None, None, 2, 0, 0),
(('ed50', 'ffff'), 'in', OPTYPE_Reg, REG_D, OPTYPE_RegMem, REG_C, 2, 0, 0),
(('ed51', 'ffff'), 'out', OPTYPE_RegMem, REG_C, OPTYPE_Reg, REG_D, 2, 0, 0),
(('ed52', 'ffff'), 'sbc', OPTYPE_Reg, REG_HL, OPTYPE_Reg, REG_DE, 2, 0, 0),
(('ed530000', 'ffff0000'), 'ld', OPTYPE_immmem16, None, OPTYPE_Reg, REG_DE, 4, 2, 0),
(('ed56', 'ffff'), 'im', OPTYPE_const, 1, None, None, 2, 0, 0),
(('ed57', 'ffff'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_Reg, REG_I, 2, 0, 0),
(('ed58', 'ffff'), 'in', OPTYPE_Reg, REG_E, OPTYPE_RegMem, REG_C, 2, 0, 0),
(('ed59', 'ffff'), 'out', OPTYPE_RegMem, REG_C, OPTYPE_Reg, REG_E, 2, 0, 0),
(('ed5a', 'ffff'), 'adc', OPTYPE_Reg, REG_HL, OPTYPE_Reg, REG_DE, 2, 0, 0),
(('ed5b0000', 'ffff0000'), 'ld', OPTYPE_Reg, REG_DE, OPTYPE_immmem16, None, 4, 2, 0),
(('ed5e', 'ffff'), 'im', OPTYPE_const, 2, None, None, 2, 0, 0),
(('ed60', 'ffff'), 'in', OPTYPE_Reg, REG_H, OPTYPE_RegMem, REG_C, 2, 0, 0),
(('ed61', 'ffff'), 'out', OPTYPE_RegMem, REG_C, OPTYPE_Reg, REG_H, 2, 0, 0),
(('ed62', 'ffff'), 'sbc', OPTYPE_Reg, REG_HL, OPTYPE_Reg, REG_HL, 2, 0, 0),
(('ed67', 'ffff'), 'rrd', None, None, None, None, 2, 0, 0),
(('ed68', 'ffff'), 'in', OPTYPE_Reg, REG_L, OPTYPE_RegMem, REG_C, 2, 0, 0),
(('ed69', 'ffff'), 'out', OPTYPE_RegMem, REG_C, OPTYPE_Reg, REG_L, 2, 0, 0),
(('ed6a', 'ffff'), 'adc', OPTYPE_Reg, REG_HL, OPTYPE_Reg, REG_HL, 2, 0, 0),
(('ed6f', 'ffff'), 'rld', None, None, None, None, 2, 0, 0),
(('ed72', 'ffff'), 'sbc', OPTYPE_Reg, REG_HL, OPTYPE_Reg, REG_SP, 2, 0, 0),
(('ed730000', 'ffff0000'), 'ld', OPTYPE_immmem16, None, OPTYPE_Reg, REG_SP, 4, 2, 0),
(('ed78', 'ffff'), 'in', OPTYPE_Reg, REG_A, OPTYPE_RegMem, REG_C, 2, 0, 0),
(('ed79', 'ffff'), 'out', OPTYPE_RegMem, REG_C, OPTYPE_Reg, REG_A, 2, 0, 0),
(('ed7a', 'ffff'), 'adc', OPTYPE_Reg, REG_HL, OPTYPE_Reg, REG_SP, 2, 0, 0),
(('ed7b0000', 'ffff0000'), 'ld', OPTYPE_Reg, REG_SP, OPTYPE_immmem16, None, 4, 2, 0),
(('eda0', 'ffff'), 'ldi', None, None, None, None, 2, 0, 0),
(('eda1', 'ffff'), 'cpi', None, None, None, None, 2, 0, 0),
(('eda2', 'ffff'), 'ini', None, None, None, None, 2, 0, 0),
(('eda3', 'ffff'), 'outi', None, None, None, None, 2, 0, 0),
(('eda8', 'ffff'), 'ldd', None, None, None, None, 2, 0, 0),
(('eda9', 'ffff'), 'cpd', None, None, None, None, 2, 0, 0),
(('edaa', 'ffff'), 'ind', None, None, None, None, 2, 0, 0),
(('edab', 'ffff'), 'outd', None, None, None, None, 2, 0, 0),
(('edb0', 'ffff'), 'ldir', None, None, None, None, 2, 0, 0),
(('edb1', 'ffff'), 'cpir', None, None, None, None, 2, 0, 0),
(('edb2', 'ffff'), 'inir', None, None, None, None, 2, 0, 0),
(('edb3', 'ffff'), 'otir', None, None, None, None, 2, 0, 0),
(('edb8', 'ffff'), 'lddr', None, None, None, None, 2, 0, 0),
(('edb9', 'ffff'), 'cpdr', None, None, None, None, 2, 0, 0),
(('edba', 'ffff'), 'indr', None, None, None, None, 2, 0, 0),
(('edbb', 'ffff'), 'otdr', None, None, None, None, 2, 0, 0),
(('ee00', 'ff00'), 'xor', OPTYPE_imm8, None, None, None, 2, 1, 0),
(('ef', 'ff'), 'rst', OPTYPE_const, 40, None, None, 1, 0, 0),
(('f0', 'ff'), 'ret', OPTYPE_Cond, COND_P, None, None, 1, 0, 0),
(('f1', 'ff'), 'pop', OPTYPE_Reg, REG_AF, None, None, 1, 0, 0),
(('f2', 'ff'), 'jp', OPTYPE_Cond, COND_P, OPTYPE_Ind, None, 1, 0, 0),
(('f3', 'ff'), 'di', None, None, None, None, 1, 0, 0),
(('f40000', 'ff0000'), 'call', OPTYPE_Cond, COND_P, OPTYPE_imm16, None, 3, 1, 0),
(('f5', 'ff'), 'push', OPTYPE_Reg, REG_AF, None, None, 1, 0, 0),
(('f600', 'ff00'), 'or', OPTYPE_imm8, None, None, None, 2, 1, 0),
(('f7', 'ff'), 'rst', OPTYPE_const, 48, None, None, 1, 0, 0),
(('f8', 'ff'), 'ret', OPTYPE_Cond, COND_M, None, None, 1, 0, 0),
(('f9', 'ff'), 'ld', OPTYPE_Reg, REG_SP, OPTYPE_Reg, REG_HL, 1, 0, 0),
(('fa', 'ff'), 'jp', OPTYPE_Cond, COND_M, OPTYPE_Ind, None, 1, 0, 0),
(('fb', 'ff'), 'ei', None, None, None, None, 1, 0, 0),
(('fc0000', 'ff0000'), 'call', OPTYPE_Cond, COND_M, OPTYPE_imm16, None, 3, 1, 0),
(('fd09', 'ffff'), 'add', OPTYPE_Reg, REG_IY, OPTYPE_Reg, REG_BC, 2, 0, 0),
(('fd19', 'ffff'), 'add', OPTYPE_Reg, REG_IY, OPTYPE_Reg, REG_DE, 2, 0, 0),
(('fd210000', 'ffff0000'), 'ld', OPTYPE_Reg, REG_IY, OPTYPE_imm16, None, 4, 2, 0),
(('fd220000', 'ffff0000'), 'ld', OPTYPE_immmem16, None, OPTYPE_Reg, REG_IY, 4, 2, 0),
(('fd23', 'ffff'), 'inc', OPTYPE_Reg, REG_IY, None, None, 2, 0, 0),
(('fd29', 'ffff'), 'add', OPTYPE_Reg, REG_IY, OPTYPE_Reg, REG_IY, 2, 0, 0),
(('fd2a0000', 'ffff0000'), 'ld', OPTYPE_Reg, REG_IY, OPTYPE_immmem16, None, 4, 2, 0),
(('fd2b', 'ffff'), 'dec', OPTYPE_Reg, REG_IY, None, None, 2, 0, 0),
(('fd3400', 'ffff00'), 'inc', OPTYPE_RegMemDisp, REG_IY, None, None, 3, 2, 0),
(('fd3500', 'ffff00'), 'dec', OPTYPE_RegMemDisp, REG_IY, None, None, 3, 2, 0),
(('fd360000', 'ffff0000'), 'ld', OPTYPE_RegMemDisp, REG_IY, OPTYPE_imm8, None, 4, 2, 0),
(('fd39', 'ffff'), 'add', OPTYPE_Reg, REG_IY, OPTYPE_Reg, REG_SP, 2, 0, 0),
(('fd4600', 'ffff00'), 'ld', OPTYPE_Reg, REG_B, OPTYPE_RegMemDisp, REG_IY, 3, 2, 0),
(('fd4e00', 'ffff00'), 'ld', OPTYPE_Reg, REG_C, OPTYPE_RegMemDisp, REG_IY, 3, 2, 0),
(('fd5600', 'ffff00'), 'ld', OPTYPE_Reg, REG_D, OPTYPE_RegMemDisp, REG_IY, 3, 2, 0),
(('fd5e00', 'ffff00'), 'ld', OPTYPE_Reg, REG_E, OPTYPE_RegMemDisp, REG_IY, 3, 2, 0),
(('fd6600', 'ffff00'), 'ld', OPTYPE_Reg, REG_H, OPTYPE_RegMemDisp, REG_IY, 3, 2, 0),
(('fd6e00', 'ffff00'), 'ld', OPTYPE_Reg, REG_L, OPTYPE_RegMemDisp, REG_IY, 3, 2, 0),
(('fd7000', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IY, OPTYPE_Reg, REG_B, 3, 2, 0),
(('fd7100', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IY, OPTYPE_Reg, REG_C, 3, 2, 0),
(('fd7200', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IY, OPTYPE_Reg, REG_D, 3, 2, 0),
(('fd7300', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IY, OPTYPE_Reg, REG_E, 3, 2, 0),
(('fd7400', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IY, OPTYPE_Reg, REG_H, 3, 2, 0),
(('fd7500', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IY, OPTYPE_Reg, REG_L, 3, 2, 0),
(('fd7700', 'ffff00'), 'ld', OPTYPE_RegMemDisp, REG_IY, OPTYPE_Reg, REG_A, 3, 2, 0),
(('fd7e00', 'ffff00'), 'ld', OPTYPE_Reg, REG_A, OPTYPE_RegMemDisp, REG_IY, 3, 2, 0),
(('fd8600', 'ffff00'), 'add', OPTYPE_Reg, REG_A, OPTYPE_RegMemDisp, REG_IY, 3, 2, 0),
(('fd8e00', 'ffff00'), 'adc', OPTYPE_Reg, REG_A, OPTYPE_RegMemDisp, REG_IY, 3, 2, 0),
(('fd9600', 'ffff00'), 'sub', OPTYPE_RegMemDisp, REG_IY, None, None, 3, 2, 0),
(('fd9e00', 'ffff00'), 'sbc', OPTYPE_Reg, REG_A, OPTYPE_RegMemDisp, REG_IY, 3, 2, 0),
(('fda600', 'ffff00'), 'and', OPTYPE_RegMemDisp, REG_IY, None, None, 3, 2, 0),
(('fdae00', 'ffff00'), 'xor', OPTYPE_RegMemDisp, REG_IY, None, None, 3, 2, 0),
(('fdb600', 'ffff00'), 'or', OPTYPE_RegMemDisp, REG_IY, None, None, 3, 2, 0),
(('fdbe00', 'ffff00'), 'cp', OPTYPE_RegMemDisp, REG_IY, None, None, 3, 2, 0),
(('fdcb0006', 'ffff00ff'), 'rlc', OPTYPE_RegMemDisp, REG_IY, None, None, 4, 2, 0),
(('fdcb000e', 'ffff00ff'), 'rrc', OPTYPE_RegMemDisp, REG_IY, None, None, 4, 2, 0),
(('fdcb0016', 'ffff00ff'), 'rl', OPTYPE_RegMemDisp, REG_IY, None, None, 4, 2, 0),
(('fdcb001e', 'ffff00ff'), 'rr', OPTYPE_RegMemDisp, REG_IY, None, None, 4, 2, 0),
(('fdcb0026', 'ffff00ff'), 'sla', OPTYPE_RegMemDisp, REG_IY, None, None, 4, 2, 0),
(('fdcb002e', 'ffff00ff'), 'sra', OPTYPE_RegMemDisp, REG_IY, None, None, 4, 2, 0),
(('fdcb0046', 'ffff00ff'), 'bit', OPTYPE_const, 0, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb004e', 'ffff00ff'), 'bit', OPTYPE_const, 1, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb0056', 'ffff00ff'), 'bit', OPTYPE_const, 2, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb005e', 'ffff00ff'), 'bit', OPTYPE_const, 3, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb0066', 'ffff00ff'), 'bit', OPTYPE_const, 4, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb006e', 'ffff00ff'), 'bit', OPTYPE_const, 5, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb0076', 'ffff00ff'), 'bit', OPTYPE_const, 6, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb007e', 'ffff00ff'), 'bit', OPTYPE_const, 7, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb0086', 'ffff00ff'), 'res', OPTYPE_const, 0, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb008e', 'ffff00ff'), 'res', OPTYPE_const, 1, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb0096', 'ffff00ff'), 'res', OPTYPE_const, 2, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb009e', 'ffff00ff'), 'res', OPTYPE_const, 3, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb00a6', 'ffff00ff'), 'res', OPTYPE_const, 4, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb00ae', 'ffff00ff'), 'res', OPTYPE_const, 5, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb00b6', 'ffff00ff'), 'res', OPTYPE_const, 6, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb00be', 'ffff00ff'), 'res', OPTYPE_const, 7, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb00c6', 'ffff00ff'), 'set', OPTYPE_const, 0, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb00ce', 'ffff00ff'), 'set', OPTYPE_const, 1, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb00d6', 'ffff00ff'), 'set', OPTYPE_const, 2, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb00de', 'ffff00ff'), 'set', OPTYPE_const, 3, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb00e6', 'ffff00ff'), 'set', OPTYPE_const, 4, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb00ee', 'ffff00ff'), 'set', OPTYPE_const, 5, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb00f6', 'ffff00ff'), 'set', OPTYPE_const, 6, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fdcb00fe', 'ffff00ff'), 'set', OPTYPE_const, 7, OPTYPE_RegMemDisp, REG_IY, 4, 2, 0),
(('fde1', 'ffff'), 'pop', OPTYPE_Reg, REG_IY, None, None, 2, 0, 0),
(('fde3', 'ffff'), 'ex', OPTYPE_RegMem, REG_SP, OPTYPE_Reg, REG_IY, 2, 0, 0),
(('fde5', 'ffff'), 'push', OPTYPE_Reg, REG_IY, None, None, 2, 0, 0),
(('fde9', 'ffff'), 'jp', OPTYPE_RegMem, REG_IY, None, None, 2, 0, 0),
(('fdf9', 'ffff'), 'ld', OPTYPE_Reg, REG_SP, OPTYPE_Reg, REG_IY, 2, 0, 0),
(('fe00', 'ff00'), 'cp', OPTYPE_imm8, None, None, None, 2, 1, 0),
(('ff', 'ff'), 'rst', OPTYPE_const, 56, None, None, 1, 0, 0),
]

from envi.bits import binbytes as bb

nbits = '00000000'
nnbits = '0000000000000000'

newtab = (

  # 8bit ld variants...
  (bb('01000000'), bb('11000000'), 'ld', OPTYPE_Reg, (2, 3), OPTYPE_Reg, (5, 3)),
  (bb('00000110'), bb('11000111'), 'ld', OPTYPE_Reg, (2, 3), OPTYPE_Imm, (8, 8)),
  (bb('01000110'), bb('11000111'), 'ld', OPTYPE_Reg, (2, 3), OPTYPE_OpReg, REG_HL),
  (bb('110111010100011000000000'), bb('111111111100011100000000'), 'ld', OPTYPE_Reg, (10, 3), OPTYPE_RegMemDisp, (REG_IX, 16, 8)),
  (bb('111111010100011000000000'), bb('111111111100011100000000'), 'ld', OPTYPE_Reg, (10, 3), OPTYPE_RegMemDisp, (REG_IY, 16, 8)),
  (bb('01110000'), bb('11111000'), 'ld', OPTYPE_RegMem, (REG_HL, None, None), OPTYPE_Reg, (5, 3)),
  (bb('110111010111000000000000'), bb('111111111111100000000000'), 'ld', OPTYPE_RegMemDisp, (REG_IX, 16, 8), OPTYPE_Reg, (13, 3)),
  (bb('111111010111000000000000'), bb('111111111111100000000000'), 'ld', OPTYPE_RegMemDisp, (REG_IY, 16, 8), OPTYPE_Reg, (13, 3)),
  (bb('0011011000000000'), bb('1111111100000000'), 'ld', OPTYPE_RegMem, (REG_HL, None, None), OPTYPE_Imm, (8, 8)),
  (bb('11011101001101100000000000000000'), bb('11111111111111110000000000000000'), 'ld', OPTYPE_RegMemDisp, (REG_IX, 16, 8), OPTYPE_Imm, (24, 8)),
  (bb('11111101001101100000000000000000'), bb('11111111111111110000000000000000'), 'ld', OPTYPE_RegMemDisp, (REG_IY, 16, 8), OPTYPE_Imm, (24, 8)),
  (bb('00001010'), bb('11111111'), 'ld', OPTYPE_OpReg, REG_A, OPTYPE_RegMem, (REG_BC, None, None)),
  (bb('00011010'), bb('11111111'), 'ld', OPTYPE_OpReg, REG_A, OPTYPE_RegMem, (REG_DE, None, None)),
  (bb('001110100000000000000000'), bb('111111110000000000000000'), 'ld', OPTYPE_OpReg, REG_A, OPTYPE_ImmMem, (8, 16)),
  (bb('00000010'), bb('11111111'), 'ld', OPTYPE_RegMem, (REG_BC, None, None), OPTYPE_OpReg, REG_A),
  (bb('00010010'), bb('11111111'), 'ld', OPTYPE_RegMem, (REG_DE, None, None), OPTYPE_OpReg, REG_A),
  (bb('001100100000000000000000'), bb('111111110000000000000000'), 'ld', OPTYPE_ImmMem, (8, 16), OPTYPE_OpReg, REG_A),
  (bb('1110110101010111'), bb('1111111111111111'), 'ld', OPTYPE_OpReg, REG_A, OPTYPE_OpReg, REG_I),
  (bb('1110110101011111'), bb('1111111111111111'), 'ld', OPTYPE_OpReg, REG_A, OPTYPE_OpReg, REG_R),
  (bb('1110110101000111'), bb('1111111111111111'), 'ld', OPTYPE_OpReg, REG_I, OPTYPE_OpReg, REG_A),
  (bb('111011010100f111'), bb('1111111111111111'), 'ld', OPTYPE_OpReg, REG_R, OPTYPE_OpReg, REG_A),

  # 16 bit ld variants
  (bb('000000010000000000000000'), bb('110011110000000000000000'), 'ld', OPTYPE_RegPair, (2, 2), OPTYPE_Imm, (8, 16)),
  (bb('11011101001000010000000000000000'), bb('11111111111111110000000000000000'), 'ld', OPTYPE_OpReg, REG_IX, OPTYPE_Imm, (16, 16)),
  (bb('11111101001000010000000000000000'), bb('11111111111111110000000000000000'), 'ld', OPTYPE_OpReg, REG_IY, OPTYPE_Imm, (16, 16)),
  (bb('001010100000000000000000'), bb('111111110000000000000000'), 'ld', OPTYPE_OpReg, REG_HL, OPTYPE_ImmMem, (8,16)),
  (bb('11101101010010110000000000000000'), bb('11111111110011110000000000000000'), 'ld', OPTYPE_RegPair, (10, 2), OPTYPE_ImmMem, (16, 16)),
  (bb('11011101001010100000000000000000'), bb('11111111111111110000000000000000'), 'ld', OPTYPE_OpReg, REG_IX, OPTYPE_ImmMem, (16, 16)),
  (bb('11111101001010100000000000000000'), bb('11111111111111110000000000000000'), 'ld', OPTYPE_OpReg, REG_IY, OPTYPE_ImmMem, (16, 16)),
  (bb('001000100000000000000000'), bb('111111110000000000000000'), 'ld', OPTYPE_ImmMem, (8, 16), OPTYPE_OpReg, REG_HL),
)


########NEW FILE########
__FILENAME__ = arm

"""
The initial arm module.
"""

import struct

import envi

# FIXME put this in envi bits.
def binary(s):
    x = 0
    for c in s:
        x = (x << 1) + int(c)
    return x

# Universal opcode things:
# len
# mode

IF_PSR_S = 0x100

COND_EQ     = 0x0        # z==1  (equal)
COND_NE     = 0x1        # z==0  (not equal)
COND_CS     = 0x2        # c==1  (carry set/unsigned higher or same)
COND_CC     = 0x3        # c==0  (carry clear/unsigned lower)
COND_MI     = 0x4        # n==1  (minus/negative)
COND_PL     = 0x5        # n==0  (plus/positive or zero)
COND_VS     = 0x6        # v==1  (overflow)
COND_VC     = 0x7        # v==0  (no overflow)
COND_HI     = 0x8        # c==1 and z==0  (unsigned higher)
COND_LO     = 0x9        # c==0  or z==1  (unsigned lower or same)
COND_GE     = 0xA        # n==v  (signed greater than or equal)  (n==1 and v==1) or (n==0 and v==0)
COND_LT     = 0xB        # n!=v  (signed less than)  (n==1 and v==0) or (n==0 and v==1)
COND_GT     = 0xC        # z==0 and n==v (signed greater than)
COND_LE     = 0xD        # z==1 and n!=v (signed less than or equal)
COND_AL     = 0xE        # always
COND_EXTENDED = 0xF        # special case - see conditional 0b1111

COND_EQ = 0
COND_NE = 1
COND_CS = 2
COND_CC = 3
COND_MI = 4
COND_PL = 5
COND_VS = 6
COND_VC = 7
COND_HI = 8
COND_LS = 9
COND_GE = 10
COND_LT = 11
COND_GT = 12
COND_LE = 13
COND_AL = 14
COND_EXTENDED = 15

cond_codes = {
COND_EQ:"EQ", # Equal Z set 
COND_NE:"NE", # Not equal Z clear 
COND_CS:"CS", #/HS Carry set/unsigned higher or same C set 
COND_CC:"CC", #/LO Carry clear/unsigned lower C clear 
COND_MI:"MI", # Minus/negative N set 
COND_PL:"PL", # Plus/positive or zero N clear 
COND_VS:"VS", # Overflow V set 
COND_VC:"VC", # No overflow V clear 
COND_HI:"HI", # Unsigned higher C set and Z clear 
COND_LS:"LS", # Unsigned lower or same C clear or Z set 
COND_GE:"GE", # Signed greater than or equal N set and V set, or N clear and V clear (N == V) 
COND_LT:"LT", # Signed less than N set and V clear, or N clear and V set (N!= V) 
COND_GT:"GT", # Signed greater than Z clear, and either N set and V set, or N clear and V clear (Z == 0,N == V) 
COND_LE:"LE", # Signed less than or equal Z set, or N set and V clear, or N clear and V set (Z == 1 or N!= V) 
COND_AL:"AL", # Always (unconditional) - 
COND_EXTENDED:"EXTENDED", # See extended opcode table
}

INST_ENC_DP_IMM = 0 # Data Processing Immediate Shift
INST_ENC_MISC   = 1 # Misc Instructions

# Instruction encodings in arm v5
IENC_DP_IMM_SHIFT = 0 # Data processing immediate shift
IENC_MISC         = 1 # Miscellaneous instructions
IENC_DP_REG_SHIFT = 2 # Data processing register shift
IENC_MISC1        = 3 # Miscellaneous instructions again
IENC_MULT         = 4 # Multiplies & Extra load/stores
IENC_DP_IMM       = 5 # Data processing immediate
IENC_UNDEF        = 6 # Undefined instruction
IENC_MOV_IMM_STAT = 7 # Move immediate to status register
IENC_LOAD_IMM_OFF = 8 # Load/Store immediate offset
IENC_LOAD_REG_OFF = 9 # Load/Store register offset
IENC_MEDIA        = 10 # Media instructions
IENC_ARCH_UNDEF   = 11 # Architecturally undefined
IENC_LOAD_MULT    = 12 # Load/Store Multiple
IENC_BRANCH       = 13 # Branch
IENC_COPROC_LOAD  = 14 # Coprocessor load/store and double reg xfers
IENC_COPROC_DP    = 15 # Coprocessor data processing
IENC_COPROC_REG_XFER = 16 # Coprocessor register transfers
IENC_SWINT        = 17 # Sofware interrupts

####################################################################
# Parsers for the multiply family of instruction encodings

def chopmul(opcode):
    op1 = (opcode >> 20) & 0xff
    a = (opcode >> 16) & 0xf
    b = (opcode >> 12) & 0xf
    c = (opcode >> 8)  & 0xf
    d = (opcode >> 4)  & 0xf
    e = opcode & 0xf
    return (op1<<4)+d,(a,b,c,d,e)

# The keys in this table are made of the
# concat of bits 27-21 and 7-4 (only when
# ienc == mul!
iencmul_codes = {
    # Basic multiplication opcodes
    binary("000000001001"): ("mul",(0,4,2), 0),
    binary("000000011001"): ("mul",(0,4,2), IF_PSR_S),
    binary("000000101001"): ("mla",(0,4,2,1), 0),
    binary("000000111001"): ("mla",(0,4,2,1), IF_PSR_S),
    binary("000001001001"): ("umaal",(1,0,4,2), 0),
    binary("000010001001"): ("umull",(1,0,4,2), 0),
    binary("000010011001"): ("umull",(1,0,4,2), IF_PSR_S),
    binary("000010101001"): ("umlal",(1,0,4,2), 0),
    binary("000010111001"): ("umlal",(1,0,4,2), IF_PSR_S),
    binary("000011001001"): ("smull",(1,0,4,2), 0),
    binary("000011011001"): ("smull",(1,0,4,2), IF_PSR_S),
    binary("000011101001"): ("smlal",(1,0,4,2), 0),
    binary("000011111001"): ("smlal",(1,0,4,2), IF_PSR_S),

    # multiplys with <x><y>
    # "B"
    binary("000100001000"): ("smlabb", (0,4,2,1), 0),
    binary("000100001010"): ("smlatb", (0,4,2,1), 0),
    binary("000100001100"): ("smlabt", (0,4,2,1), 0),
    binary("000100001110"): ("smlatt", (0,4,2,1), 0),
    binary("000100101010"): ("smulwb", (0,4,2), 0),
    binary("000100101110"): ("smulwt", (0,4,2), 0),
    binary("000100101000"): ("smlawb", (0,4,2), 0),
    binary("000100101100"): ("smlawt", (0,4,2), 0),
    binary("000101001000"): ("smlalbb", (1,0,4,2), 0),
    binary("000101001010"): ("smlaltb", (1,0,4,2), 0),
    binary("000101001100"): ("smlalbt", (1,0,4,2), 0),
    binary("000101001110"): ("smlaltt", (1,0,4,2), 0),
    binary("000101101000"): ("smulbb", (0,4,2), 0),
    binary("000101101010"): ("smultb", (0,4,2), 0),
    binary("000101101100"): ("smulbt", (0,4,2), 0),
    binary("000101101110"): ("smultt", (0,4,2), 0),

    # type 2 multiplys

    binary("011100000001"): ("smuad", (0,4,2), 0),
    binary("011100000011"): ("smuadx", (0,4,2), 0),
    binary("011100000101"): ("smusd", (0,4,2), 0),
    binary("011100000111"): ("smusdx", (0,4,2), 0),
    binary("011100000001"): ("smlad", (0,4,2), 0),
    binary("011100000011"): ("smladx", (0,4,2), 0),
    binary("011100000101"): ("smlsd", (0,4,2), 0),
    binary("011100000111"): ("smlsdx", (0,4,2), 0),
    binary("011101000001"): ("smlald", (0,4,2), 0),
    binary("011101000011"): ("smlaldx", (0,4,2), 0),
    binary("011101000101"): ("smlsld", (0,4,2), 0),
    binary("011101000111"): ("smlsldx", (0,4,2), 0),
    binary("011101010001"): ("smmla", (0,4,2,1), 0),
    binary("011101010011"): ("smmlar", (0,4,2,1), 0),
    binary("011101011101"): ("smmls", (0,4,2,1), 0),
    binary("011101011111"): ("smmlsr", (0,4,2,1), 0),
    binary("011101010001"): ("smmul", (0,4,2), 0),
    binary("011101010011"): ("smmulr", (0,4,2), 0),
}

####################################################################
# Mnemonic tables for opcode based mnemonic lookup

# Dataprocessing mnemonics
dp_mnem = ("and","eor","sub","rsb","add","adc","sbc","rsc","tst","teq","cmp","cmn","orr","mov","bic","mvn"),
misc_mnem = ("mrs","msr","bxj")

def dpbase(opval):
    """
    Parse and return opcode,sflag,Rn,Rd for a standard
    dataprocessing instruction.
    """
    ocode = (opval >> 21) & 0xf
    sflag = (opval >> 20) & 0x1
    Rn = (opval >> 16) & 0xf
    Rd = (opval >> 12) & 0xf
    #print "DPBASE:",ocode,sflag,Rn,Rd
    return ocode,sflag,Rn,Rd

####################################################################
# Parser functions for each of the instruction encodings

def p_dp_imm_shift(opval):
    ocode,sflag,Rn,Rd = dpbase(opval)
    Rm = opval & 0xf
    shtype = (opval >> 5) & 0x3
    shval = (opval >> 7) & 0x1f

    olist = [
        ArmOperand(OM_REG, Rn),
        ArmOperand(OM_REG, Rd),
        ArmOperand(OM_REG, Rm, shtype=shtype, shval=shval),
    ]

    opcode = (IENC_DP_IMM_SHIFT << 16) + ocode
    return ArmOpcode(opcode, dp_mnem[ocode], olist)

def p_misc(opval):
    pass

def p_dp_reg_shift(opval):
    ocode,sflag,Rn,Rd = dpbase(opval)
    Rm = opval & 0xf
    shtype = (opval >> 5) & 0x3
    Rs = (opval >> 8) & 0xf

    olist = [
        ArmOperand(OM_REG, Rn),
        ArmOperand(OM_REG, Rd),
        ArmOperand(OM_REG, Rm, oflags=OFLAG_SHIFT_REG, shtype=shtype, shval=shval),
    ]

    opcode = (IENC_DP_IMM_SHIFT << 16) + ocode
    return ArmOpcode(opcode, dp_mnem[ocode], olist)

def p_misc1(opval):
    pass

def p_mult(opval):
    ocode, vals = chopmul(opval)
                             
    mnem, opindexes, flags = iencmul_codes.get(ocode)

    olist = []
    for i in opindexes:
        olist.append(ArmOperand(OM_REG, vals[i]))

    opcode = (IENC_MULT << 16) + ocode
    return ArmOpcode(opcode, mnem, olist, iflags=flags)

def p_dp_imm(opval):
    ocode,sflag,Rn,Rd = dpbase(opval)
    imm = opval & 0xff
    rot = (opval >> 8) & 0xf

def p_undef(opval):
    pass

def p_mov_imm_stat(opval):
    pass

def p_load_imm_off(opval):
    pass

def p_load_reg_off(opval):
    pass

def p_media(opval):
    pass

def p_arch_undef(opval):
    pass

def p_load_mult(opval):
    pass

def p_branch(opval):
    pass

def p_coproc_load(opval):
    pass

def p_coproc_dp(opval):
    pass

def p_coproc_reg_xfer(opval):
    pass

def p_swint(opval):
    pass

####################################################################
# Table of the parser functions

ienc_parsers = (
    p_dp_imm_shift,
    p_misc,
    p_dp_reg_shift,
    p_misc1,
    p_mult,
    p_dp_imm,
    p_undef,
    p_mov_imm_stat,
    p_load_imm_off,
    p_load_reg_off,
    p_media,
    p_arch_undef,
    p_load_mult,
    p_branch,
    p_coproc_load,
    p_coproc_dp,
    p_coproc_reg_xfer,
    p_swint,
)

####################################################################

# the primary table is index'd by the 3 bits following the
# conditional and are structured as follows:
# ( ENC, nexttable )
# If ENC != None, those 3 bits were enough for us to know the
# encoding type, otherwise move on to the second table.

# The secondary tables have the format:
# (mask, value, ENC).  If the opcode is masked with "mask"
# resulting in "value" we have found the instruction encoding.
# NOTE: All entries in these tables *must* be from most specific
# to least!

# Table for initial 3 bit == 0
s_0_table = (
    # Order is critical here...
    (binary("00000001100100000000000000010000"), binary("00000001000000000000000000000000"), IENC_MISC),
    (binary("00000000000000000000000000010000"), binary("00000000000000000000000000000000"), IENC_DP_IMM_SHIFT),
    (binary("00000000000000000000000010010000"), binary("00000000000000000000000010010000"), IENC_MULT),
    (binary("00000001100000000000000010010000"), binary("00000001000000000000000000010000"), IENC_MISC1),
    (binary("00000000000000000000000010010000"), binary("00000000000000000000000000010000"), IENC_DP_REG_SHIFT),
)

s_1_table = (
    (binary("00000001100110000000000000000000"), binary("00000001000000000000000000000000"), IENC_UNDEF),
    (binary("00000001100110000000000000000000"), binary("00000001001000000000000000000000"), IENC_MOV_IMM_STAT),
    (0,0, IENC_DP_IMM),
)

s_3_table = (
    (binary("00000001111100000000000011110000"),binary("00000001111100000000000011110000"), IENC_ARCH_UNDEF),
    (binary("00000000000000000000000000010000"),binary("00000000000000000000000000010000"), IENC_MEDIA),
    (0,0, IENC_LOAD_REG_OFF),
)

s_7_table = (
    (binary("00000001000000000000000000000000"),binary("00000001000000000000000000000000"), IENC_SWINT),
    (binary("00000001000000000000000000010000"),binary("00000000000000000000000000010000"), IENC_COPROC_REG_XFER),
    (0, 0, IENC_COPROC_DP),
)

# Initial 3 (non conditional) primary table
inittable = [
    (None, s_0_table),
    (None, s_1_table),
    (IENC_LOAD_IMM_OFF, None), # Load or store an immediate
    (None, s_3_table),
    (IENC_LOAD_MULT, None),
    (IENC_BRANCH, None),
    (IENC_COPROC_LOAD, None),
    (None, s_7_table),
]

OFLAG_SHIFT_REG = 1 # Is the shval a register?

# The supported types of operand shifts (by the 2 bit field)
S_LSL = 0
S_LSR = 1
S_ASR = 2
S_ROR = 3
S_RRX = 4 # FIXME HACK XXX add this

shift_names = ["lsl", "lsr", "asr", "ror", "rrx"]

# FIXME for emulation...
#def s_lsl(val, shval):
    #pass

#def s_lsr(val, shval):
    #pass

# These are indexed by the 2 bit "shift" value in some DP encodings
#shift_handlers = (
    #s_lsl,
    #s_lsr,
    #s_asr,
    #s_ror,
#)

endian_names = ("LE","BE")

class ArmOpcode(envi.Opcode):

    def __init__(self, opcode, mnem, opers, cond=COND_AL, iflags=0):
        envi.Opcode.__init__(self, opcode, mnem, 0, 4, opers, iflags)
        self.cond = cond

    def __repr__(self):
        x = [self.mnem, cond_codes.get(self.cond)]
        # FIXME put in S flag!
        for o in self.opers:
            x.append(repr(o))
        return " ".join(x)

# Arm specific opcode flags
IF_PSR_S = 0x100    # Instruction updates S field in PSR (for some opcodes it's optional)

OM_IMM = 0          # imm (with possible shift and offset)
OM_REG = 1          # reg (with possible shift and offset)
OM_REG_MULT = 2     # reg is regmask of effected registers
OM_PSR = 3          # Process state register (like intel elfags)
OM_ENDIAN = 4       # boolean operand used in one instruction... *sigh*...
OM_COPROC_OP = 5    # The subsequent opcode for a coprocessing instruction

class ArmOperand(envi.Operand):
    def __init__(self, mode, val, oflags=0, shtype=None, shval=None):
        envi.Operand.__init__(self, mode)
        self.val = val # depending on mode, this is reg/imm
        self.oflags = oflags
        self.shval = shval
        self.shtype = shtype

    def __eq__(self, oper):
        if not envi.Operand.__eq__(self, oper):
            return False
        if self.val != oper.val:
            return False
        if self.oflags != oper.oflags:
            return False
        if self.shval != oper.shval:
            return False
        if self.shtype != oper.shtype:
            return False
        return True

    def __repr__(self):
        if self.mode == OM_IMM:
            return "#%d" % self.val

        if self.mode == OM_REG:
            base = "r%d" % self.val
            if self.shtype != None:
                if self.oflags & OFLAG_SHIFT_REG:
                    base = "%s %s %s" % (base, shift_names[self.shtype], "r%d" % self.shval) # FIXME regnames
                else:
                    base = "%s %s %s" % (base, shift_names[self.shtype], "#%d" % self.shval) # FIXME regnames
            return base

        if self.mode == OM_PSR:
            return "FIXME DO PSR"

        if self.mode == OM_ENDIAN:
            return endian_names[self.val]

        if self.mode == OM_REG_MULT:
            return "FIXME REG MULT"

class ArmModule(envi.ArchitectureModule):

    def __init__(self):
        envi.ArchitectureModule.__init__(self, "armv5", maxinst=4)

    def makeOpcode(self, bytes, offset):
        opval = struct.unpack("<L", bytes[offset:offset+4])[0]

        cond = opval >> 28

        if cond == COND_EXTENDED:
            return "FIXME - make extended opcode parser"

        # Begin the table lookup sequence with the first 3 non-cond bits
        encfam = (opval >> 25) & 0x7
        enc,nexttab = inittable[encfam]
        if nexttab != None: # we have to sub-parse...
            for mask,val,penc in nexttab:
                if (opval & mask) == val:
                    enc = penc
                    break

        # If we don't know the encoding by here, we never will ;)
        if enc == None:
            raise InvalidInstruction("omg")

        #print "ENCFAM",encfam
        #print "COND",cond
        #print "ENCODING",enc

        op = ienc_parsers[enc](opval)
        op.cond = cond

        return op

a = ArmModule()
#a.makeOpcode("\x0d\xc0\xa0\xe1", 0)
#e2833004 add r3, r3, #4
print repr(a.makeOpcode("\x92\x10\x93\x00", 0))
print repr(a.makeOpcode("\x04\x30\x83\xe2", 0))


########NEW FILE########
__FILENAME__ = bintree
import envi.bits as e_bits

class BinaryTree:
    '''
    A simple binary search tree capable of using integers
    or string representations of binary integers as inputs.

    NOTE: the lookup routines assume once a node is found which
    has nodeinfo, we have matched.  It does *not* need to walk
    the rest of the values...
    '''
    def __init__(self):
        self.basenode = [None, None, None]

    def addInt(self, intval, width, nodeinfo):
        node = self.basenode
        for sh in xrange(width-1, -1, -1):
            choice = (intval >> sh) & 1
            if node[choice] == None:
                node[choice] = [None, None, None]
            node = node[choice]
        node[2] = nodeinfo

    def addBinstr(self, binstr, nodeinfo):
        bval = e_bits.binary(binstr)
        return self.addInt(bval, len(binstr), nodeinfo)

    #def addString(self, charstr, nodeinfo):
    # e_bits the whole string to a huge int?

    def getInt(self, intval, width):
        '''
        Get an element back out of the tree.

        width is in bits...
        '''
        node = self.basenode
        for sh in xrange(width-1, -1, -1):
            choice = (intval >> sh) & 1
            node = node[choice]
            ninfo = node[2]
            if ninfo != None:
                return ninfo
        return node[2]

    def getBinstr(self, binstr):
        bval = e_bits.binary(binstr)
        return self.getInt(bval, len(bstr))


########NEW FILE########
__FILENAME__ = bits
"""
A file full of bit twidling helpers
"""

import struct

MAX_WORD = 8 # Dont have any more than 64 bit archs

# Masks to use for unsigned anding to size
u_maxes = [ (2 ** (8*i)) - 1 for i in range(MAX_WORD+1) ]
u_maxes[0] = 0 # powers of 0 are 1, but we need 0

# Masks of just the sign bit for different sizes
sign_bits = [ (2 ** (8*i)) >> 1 for i in range(MAX_WORD+1) ]
sign_bits[0] = 0 # powers of 0 are 1, but we need 0

# Max *signed* masks (all but top bit )
s_maxes = [ u_maxes[i] ^ sign_bits[i] for i in range(len(u_maxes))]
s_maxes[0] = 0

# bit width masks 
b_masks = [ (2**i)-1 for i in range(MAX_WORD*8) ]
b_masks[0] = 0

def unsigned(value, size):
    """
    Make a value unsigned based on it's size.
    """
    # In python "&" will do abs value
    return value & u_maxes[size]

def signed(value, size):
    """
    Make a value signed based on it's size.
    """
    x = unsigned(value, size)
    if x & sign_bits[size]:
        x = (x - u_maxes[size]) - 1
    return x

def is_signed(value, size):
    x = unsigned(value, size)
    return bool(x & sign_bits[size])

def sign_extend(value, cursize, newsize):
    """
    Take a value and extend it's size filling
    in the space with the value of the high 
    order bit.
    """
    x = unsigned(value, cursize)
    if cursize != newsize:
        # Test for signed w/o the call
        if x & sign_bits[cursize]:
            delta = newsize - cursize
            highbits = u_maxes[delta]
            x |= highbits << (8*cursize)
    return x

def is_parity(val):
    s = 0
    while val:
        s ^= val & 1
        val = val >> 1
    return (not s)

parity_table = []
for i in range(256):
    parity_table.append(is_parity(i))

def is_parity_byte(bval):
    """
    An "optimized" parity checker that looks up the index.
    """
    return parity_table[bval & 0xff]

def lsb(value):
    return value & 0x1

def msb(value, size):
    if value & sign_bits[size]:
        return 1
    return 0

def is_signed_overflow(value, size):
    max = s_maxes[size]
    if value > max:
        return True
    if value < -max:
        return True
    return False

def is_unsigned_carry(value, size):
    umax = u_maxes[size]
    if value > umax:
        return True
    elif value < 0:
        return True
    return False

def is_aux_carry(src, dst):
    # FIXME this is only how to do it for add...
    dst = dst & 0xf
    src = src & 0xf
    if (dst + src) > 15:
        return True
    return False

le_fmt_chars = (None,"B","<H",None,"<L",None,None,None,"<Q")
be_fmt_chars = (None,"B",">H",None,">L",None,None,None,">Q")
def parsebytes(bytes, offset, size, sign=False, bigend=False):
    """
    Mostly for pulling immediates out of strings...
    """
    if size > 8:
        return slowparsebytes(bytes, offset, size, sign=sign, bigend=bigend)
    if bigend:
        f = be_fmt_chars[size]
    else:
        f = le_fmt_chars[size]
    if f == None:
        return slowparsebytes(bytes, offset, size, sign=sign, bigend=bigend)
    d = bytes[offset:offset+size]
    x = struct.unpack(f, d)[0]
    if sign:
        x = signed(x, size)
    return x

def slowparsebytes(bytes, offset, size, sign=False, bigend=False):
    if bigend:
        begin = offset
        inc = 1
    else:
        begin = offset + (size-1)
        inc = -1

    ret = 0
    ioff = 0
    for x in range(size):
        ret = ret << 8
        ret |= ord(bytes[begin+ioff])
        ioff += inc
    if sign:
        ret = signed(ret, size)
    return ret

def buildbytes(value, size, bigend=False):
    if bigend:
        f = be_fmt_chars[size]
    else:
        f = le_fmt_chars[size]
    if f == None:
        raise Exception("envi.bits.buildbytes needs slowbuildbytes")
    return struct.pack(f, value)

def byteswap(value, size):
    ret = 0
    for i in range(size):
        ret |= (value >> (8*i)) & 0xff
        ret = ret << 8
    return ret

hex_fmt = {
    1:"0x%.2x",
    2:"0x%.4x",
    4:"0x%.8x",
    8:"0x%.16x",
}

def intwidth(val):
    if val < 0:
        val = abs(val)
    ret = 0
    while val:
        ret += 1
        val = val >> 8
    return ret

def hex(value, size=None):
    if size == None:
        size = intwidth(value)

    fmt = hex_fmt.get(size)
    if fmt != None:
        return fmt % value

    x = []
    while value:
        x.append('%.2x' % (value & 0xff))
        value = value >> 8
    x.reverse()
    return '0x%.s' % ''.join(x)


    return hex_fmt.get(size) % value

def binrepr(intval, bitwidth=None):
    '''
    Return a string of one's and zero's for the given value.
    '''
    ret = []
    while intval:
        ret.append(str(intval & 0x1))
        intval >>= 1
    ret.reverse()
    binstr = ''.join(ret)
    if bitwidth != None:
        binstr = binstr.rjust(bitwidth, '0')
    return binstr

def binary(binstr):
    '''
    Decode a binary string of 1/0's into a python number
    '''
    x = 0
    for c in binstr:
        x = (x << 1) + int(c)
    return x

def binbytes(binstr):
    '''
    Decode a binary string of 1/0's into a python binary
    string.
    '''
    if len(binstr) % 8 != 0:
        raise Exception('Byte padded binary strings only for now!')
    bytes = ''
    while binstr:
        bytes += chr( binary(binstr[:8]) )
        binstr = binstr[8:]
    return bytes

def parsebits(bytes, offset, bitoff, bitsize):
    '''
    Parse bitsize bits from the bit offset bitoff beginning
    at offset bytes.

    Example: 
    '''
    val = 0
    cnt = 0
    while cnt < bitsize:

        addbit = bitoff + cnt
        addoff = offset + (addbit / 8)

        modoff = addbit % 8

        o = ord(bytes[addoff])
        val = (val << 1) + ((o >> (7 - modoff)) & 1)

        cnt += 1

    return val

#if __name__ == '__main__':
    #print hex(parsebits('\x0f\x00', 0, 4, 8))
    #print hex(parsebits('\x0f\x0f', 0, 4, 12))
    #print hex(parsebits('\x0f\x0f\xf0', 1, 4, 4))


########NEW FILE########
__FILENAME__ = bytesig

"""
A byte and mask based decision engine for creating byte
sequences (and potential comparison masks) for general purpose
signature matching.

Currently used by vivisect function entry sig db and others.
"""

class SignatureTree:
    """
    A byte based decision tree which uses all the RAMs but is
    really fast....

    Signatures consist of a byte sequence and an optional mask
    sequence.  If present each mask byte is used to logical and
    the byte being compared before comparison.  This allows the
    creation of signatures which have parts of the sig generalized.

    FIXME allow sigs to have a reliability rating
    FIXME allow sig nodes to store depth and truncate the tree early (and then mask the rest)
    """

    def __init__(self):
        self.basenode = (0, [], [None] * 256)
        self.sigs = {} # track duplicates

    def _addChoice(self, siginfo, node):

        todo = [(node, siginfo),]

        # Recursion is for the weak minded.
        while len(todo):

            node, siginfo = todo.pop()
            depth, sigs, choices = node
            bytes, masks, o = siginfo
            siglen = len(sigs)

            sigs.append(siginfo)
            if siglen == 0:
                pass # we just don't want the "else" here, if we're the only
                # one on this node, just let it ride.

            elif siglen == 1:
                # If it has one already, we *both* need to add another level
                # (because if it is the only one, it thought it was last choice)
                for s in sigs:
                    chval = s[0][depth] # get the choice byte from siginfo
                    nnode = self._getNode(depth, choices, chval)
                    todo.append((nnode, s))

            else: # This is already a choice node, keep on choosing...
                chval = bytes[depth]
                nnode = self._getNode(depth, choices, chval)
                todo.append((nnode, siginfo))

    def _getNode(self, depth, choices, choice):
        # Chose, (and or initialize) a sub node
        nnode = choices[choice]
        if nnode == None:
            nnode = (depth+1, [], [None] * 256)
            choices[choice] = nnode
        return nnode

    def addSignature(self, bytes, masks=None, val=None):
        """
        Add a signature to the search tree.  If masks goes unspecified, it will be
        assumed to be all ones (\\xff * len(bytes)).

        Additionally, you may specify "val" as the object to get back with
        getSignature().
        """
        # FIXME perhaps make masks None on all ff's
        if masks == None:
            masks = "\xff" * len(bytes)

        if val == None:
            val = True

        # Detect and skip duplicate additions...
        bytekey = bytes + masks
        if self.sigs.get(bytekey) != None:
            return

        self.sigs[bytekey] = True

        byteord = [ord(c) for c in bytes]
        maskord = [ord(c) for c in masks]

        siginfo = (byteord, maskord, val)
        self._addChoice(siginfo, self.basenode)

    def isSignature(self, bytes, offset=0):
        return self.getSignature(bytes, offset=offset) != None

    def getSignature(self, bytes, offset=0):

        node = self.basenode
        while True:
            depth, sigs, choices = node
            # Once we get down to one sig, there are no more branches,
            # just check the byte sequence.
            if len(sigs) == 1:
                sbytes, smasks, sobj = sigs[0]
                for i in xrange(depth, len(sbytes)):
                    realoff = offset + i
                    masked = ord(bytes[realoff]) & smasks[i]
                    if masked != sbytes[i]:
                        return None
                return sobj

            # There are still more choices, keep branching.
            node = None # Lets go find a new one
            for sig in sigs:
                sbytes, smasks, sobj = sig
                masked = ord(bytes[offset+depth]) & smasks[depth]
                if sbytes[depth] == masked: # We have a winner!
                    # FIXME find the *best* winner! (because of masking)
                    node = choices[masked]
                    break

            # We failed to make our next choice
            if node == None:
                return None

########NEW FILE########
__FILENAME__ = cli
"""
Unified CLI code for things like vivisect and vdb.
"""

import code
import traceback
import threading

import envi.bits as e_bits
import envi.memory as e_mem
import envi.config as e_config
import envi.resolver as e_resolv
import envi.memcanvas as e_canvas
import envi.expression as e_expr

from cmd import Cmd
from getopt import getopt

import re                                                                                                          

def splitargs(cmdline):
    cmdline = cmdline.replace('\\\\"', '"').replace('\\"', '')
    patt = re.compile('\".+?\"|\S+')
    for item in cmdline.split('\n'):
        return [s.strip('"') for s in patt.findall(item)]

def columnstr(slist):
    msize = 0
    for s in slist:
        if len(s) > msize:
            msize = len(s)
    return [x.ljust(msize) for x in slist]


class CliExtMeth:
    """
    This is used to work around the difference
    between functions and bound methods for extended
    command modules
    """
    def __init__(self, cli, func):
        self.cli = cli
        self.func = func
        self.__doc__ = func.__doc__

    def __call__(self, line):
        return self.func(self.cli, line)

cfgdefs = """

[Aliases]

"""

class EnviCli(Cmd):

    def __init__(self, memobj, config=None, symobj=None):

        self.extcmds = {}

        Cmd.__init__(self, stdout=self)

        self.shutdown = threading.Event()

        # If they didn't give us a resolver, make one.
        if symobj == None:
            symobj = e_resolv.SymbolResolver()

        if config == None:
            config = e_config.EnviConfig(defaults=cfgdefs)

        self.config = config
        self.memobj = memobj
        self.symobj = symobj
        self.canvas = e_canvas.MemoryCanvas(memobj, syms=symobj)

    def setCanvas(self, canvas):
        """
        Set a new canvas for the CLI and add all the current renderers
        to the new one.
        """
        for name in self.canvas.getRendererNames():
            canvas.addRenderer(name, self.canvas.getRenderer(name))
        self.canvas = canvas

    def write(self, data):
        # For stdout/stderr
        self.canvas.write(data)

    def get_names(self):
        ret = []
        ret.extend(Cmd.get_names(self))
        ret.extend(self.extcmds.keys())
        return ret

    def getExpressionLocals(self):
        """
        Over-ride this to have things like the eval command
        and the python command use more locals than the sybolic
        defaults.
        """
        return e_expr.MemoryExpressionLocals(self.memobj, symobj=self.symobj)

    def registerCmdExtension(self, func):
        self.extcmds["do_%s" % func.__name__] = CliExtMeth(self, func)

    def vprint(self, msg, addnl=True):
        if addnl:
            msg = msg+"\n"
        self.canvas.write(msg)

    def __getattr__(self, name):
        func = self.extcmds.get(name, None)
        if func == None:
            raise AttributeError(name)
        return func

    def doAlias(self, line):
        for opt in self.config.options("Aliases"):
            if line.startswith(opt):
                line = line.replace(opt, self.config.get("Aliases", opt), 1)
        return line

    def cmdloop(self, intro=None):
        if intro != None:
            self.vprint(intro)

        while not self.shutdown.isSet():
            try:
                Cmd.cmdloop(self, intro=intro)
            except:
                traceback.print_exc()

    def onecmd(self, line):
        lines = line.split("&&")
        try:
            for line in lines:
                line = self.doAlias(line)
                Cmd.onecmd(self, line)
        except SystemExit:
            raise
        except Exception, msg:
            #self.vprint(traceback.format_exc())
            self.vprint("\nERROR: (%s) %s" % (msg.__class__.__name__,msg))

        if self.shutdown.isSet():
            return True

    def do_EOF(self, line):
        self.vprint("Use quit")

    def do_quit(self, line):
        """
        Quit

        Usage: quit
        """
        self.shutdown.set()

    def do_config(self, line):
        """
        Show or edit a config option from the command line

        Usage: config [-S section] [option=value]
        """
        argv = splitargs(line)
        secname = None
        try:
            opts,args = getopt(argv, "S:")
            for opt,optarg in opts:
                if opt == "-S":
                    secname = optarg

        except Exception, e:
            print e
            return self.do_help("config")

        if len(args) > 1:
            return self.do_help("config")

        if len(args) == 0:
            if secname != None:
                secs = [secname,]
            else:
                secs = self.config.sections()

            for secname in secs:
                self.vprint("")
                self.vprint("[%s]" % secname)
                for oname in self.config.options(secname):
                    val = self.config.get(secname, oname)
                    self.vprint("%s=%s" % (oname, val))

        else:
            if secname == None:
                secname = ""
            key,val = args[0].split("=",1)
            self.config.set(secname, key, val)
            self.vprint("[%s] %s = %s" % (secname,key,val))

    def do_alias(self, line):
        """
        Add an alias to the command line interpreter's aliases dictionary

        Usage: alias <alias_word> rest of the alias command
        To delete an alias:
        Usage: alias <alias_word>
        """
        if len(line):
            row = line.split(None, 1)
            if len(row) == 1:
                self.config.remove_option("Aliases",row[0])
            else:
                self.config.set("Aliases",row[0],row[1])

        self.vprint("Current Aliases:\n")

        opts = self.config.options("Aliases")
        opts.sort()

        for opt in opts:
            val = self.config.get("Aliases", opt)
            self.vprint("%s -> %s" % (opt,val))
        self.vprint("")
        return

    def do_python(self, line):
        """
        Start an interactive python interpreter. The namespace of the
        interpreter is updated with expression nicities.  You may also
        specify a line of python code as an argument to be exec'd without
        beginning an interactive python interpreter on the controlling
        terminal.

        Usage: python [pycode]
        """
        locals = self.getExpressionLocals()
        if len(line) != 0:
            cobj = compile(line, 'cli_input', 'exec')
            exec(cobj, locals)
        else:
            code.interact(local=locals)

    def parseExpression(self, expr):
        l = self.getExpressionLocals()
        return long(e_expr.evaluate(expr, l))

    def do_binstr(self, line):
        '''
        Display a binary representation of the given value expression
        (padded to optional width in bits)
        
        Usage: binstr <val_expr> [<bitwidth_expr>]
        '''
        argv = splitargs(line)
        if len(argv) == 0:
            return self.do_help('binstr')
        bitwidth = None
        value = self.parseExpression(argv[0])
        if len(argv) > 1:
            bitwidth = self.parseExpression(argv[1])
        binstr = e_bits.binrepr(value, bitwidth=bitwidth)
        self.canvas.addText("0x%.8x (%d) %s\n" % (value, value, binstr))

    def do_eval(self, line):
        """
        Evaluate an expression on the CLI to show it's value.

        Usage: eval (ecx+edx)/2
        """
        if not line:
            return self.do_help("eval")
        value = self.parseExpression(line)

        self.canvas.addText("%s = " % line)
        if self.memobj.isValidPointer(value):
            self.canvas.addVaText("0x%.8x" % value, value)
            sym = self.symobj.getSymByAddr(value, exact=False)
            if sym != None:
                self.canvas.addText(" ")
                self.canvas.addVaText("%s + %d" % (repr(sym),value-long(sym)), value)
        else:
            self.canvas.addText("0x%.8x (%d)" % (value, value))

        self.canvas.addText("\n")

    def do_script(self, line):
        """
        Execute a python file.

        The script file is arbitrary python code which is run with the
        full compliment of expression extensions mapped in as locals.

        NOTE: additional command line arguments may be passed in and will
              appear as the list "argv" in the script namespace!  (They will
              all be strings)

        Usage: script <scriptfile> [<argv[0]>, ...]
        """
        if len(line) == 0:
            return self.do_help("script")

        argv = splitargs(line)
        locals = self.getExpressionLocals()
        locals['argv'] = argv
        script = file(argv[0]).read()
        cobj = compile(script, argv[0], "exec")
        exec(cobj, locals)

    def do_maps(self, line):
        """
        Display either a list of all the memory maps or the memory map
        details for the given address expression.

        Usage: maps [addr_expression]
        """
        argv = splitargs(line)
        if len(argv):
            expr = " ".join(argv)
            va = self.parseExpression(expr)
            map = self.memobj.getMemoryMap(va)
            if map == None:
                self.vprint("Memory Map Not Found For: 0x%.8x"%va)

            else:
                addr,size,perm,fname = map
                pname = e_mem.reprPerms(perm)
                self.canvas.addText("Memory Map For: ")
                self.canvas.addVaText("0x%.8x" % va, va)
                self.canvas.addText("\n")
                self.canvas.addVaText("0x%.8x" % addr, addr)
                self.canvas.addText("\t%d\t%s\t%s\n" % (size,pname,fname))
        else:
            totsize = 0
            self.vprint("[ address ] [ size ] [ perms ] [ File ]")
            for addr,size,perm,fname in self.memobj.getMemoryMaps():
                pname = e_mem.reprPerms(perm)
                totsize += size
                self.canvas.addVaText("0x%.8x" % addr, addr)
                sizestr = ("%dK" % (size/1024,)).rjust(8)
                self.canvas.addText("%s\t%s\t%s\n" % (sizestr,pname,fname))
            self.vprint("Total Virtual Memory: %s MB" % ((totsize/1024)/1024))

    def do_search(self, line):
        """
        Search memory for patterns.

        Usage: search [options] <pattern>
        -e Encode the pattern with a codec (ie utf-16le, hex, etc)
        -E The specified pattern is an expression (search for numeric values)
        -r The specified pattern is a regular expression
        -R <baseexpr:sizeexpr> Search a specific range only.
        -X The specified pattern is in hex (ie.  414141424242 is AAABBB)
        """
        if len(line) == 0:
            return self.do_help("search")

        range = None
        dohex = False
        doexpr = False
        regex = False
        encode = None

        argv = splitargs(line)
        try:
            opts,args = getopt(argv, "e:ER:rX")
        except:
            return self.do_help("search")

        for opt,optarg in opts:
            if opt == '-E':
                doexpr = True
            elif opt == '-e':
                encode = optarg
            elif opt == '-R':
                range = optarg
            elif opt == '-r':
                regex = True
            elif opt == '-X':
                dohex = True

        pattern = " ".join(args)
        if doexpr:
            import struct #FIXME see below
            sval = self.parseExpression(pattern)
            pattern = struct.pack("<L", sval) # FIXME 64bit (and alt arch)
        if dohex: pattern = pattern.decode('hex')
        if encode: pattern = pattern.encode(encode)
        if range:
            try:
                addrexpr, sizeexpr = range.split(":")
            except Exception, e:
                return self.do_help("search")
            addr = self.parseExpression(addrexpr)
            size = self.parseExpression(sizeexpr)
            self.canvas.addText("Searching from ")
            self.canvas.addVaText("0x%.8x", addr)
            self.canvas.addText(" for %d bytes\n" % size)
            res = self.memobj.searchMemoryRange(pattern, addr, size, regex=regex)
        else:
            self.vprint("Searching all memory...")
            res = self.memobj.searchMemory(pattern, regex=regex)

        if len(res) == 0:
            self.vprint('Pattern Not Found: %s' % pattern.encode('hex'))
            return

        self.vprint('Matches for: %s' % pattern.encode('hex'))
        for r in res:
            self.canvas.addVaText("0x%.8x" % r, r)
            self.canvas.addText(": ")

            mbase,msize,mperm,mfile = self.memobj.getMemoryMap(r)
            pname = e_mem.reprPerms(mperm)

            self.canvas.addText("%s " % pname)

            sname = self.reprPointer(r)

            self.canvas.addText(sname)
            self.canvas.addText("\n")

    def reprPointer(self, va):
        """
        Do your best to create a humon readable name for the
        value of this pointer.
        """
        if va == 0:
            return "NULL"

        mbase,msize,mperm,mfile = self.memobj.getMemoryMap(va)
        ret = mfile
        sym = self.symobj.getSymByAddr(va, exact=False)
        if sym != None:
            ret = "%s + %d" % (repr(sym),va-long(sym))
        return ret

    def do_memdump(self, line):
        """
        Dump memory out to a file.

        Usage: memdump <addr_expression> <size_expression> <filename>
        """
        if len(line) == 0:
            return self.do_help("memdump")

        argv = splitargs(line)
        if len(argv) != 3:
            return self.do_help("memdump")

        addr = self.parseExpression(argv[0])
        size = self.parseExpression(argv[1])

        mem = self.memobj.readMemory(addr, size)
        file(argv[2], "wb").write(mem)
        self.vprint("Wrote %d bytes!" % len(mem))

    def do_memcmp(self, line):
        '''
        Compare memory at the given locations.  Outputs a set of
        differences showing bytes at their given offsets....

        Usage: memcmp <addr_expr1> <addr_expr2> <size_expr>
        '''
        if len(line) == 0:
            return self.do_help('memcmp')

        argv = splitargs(line)
        if len(argv) != 3:
            return self.do_help('memcmp')

        addr1 = self.parseExpression(argv[0])
        addr2 = self.parseExpression(argv[1])
        size  = self.parseExpression(argv[2])

        bytes1 = self.memobj.readMemory(addr1, size)
        bytes2 = self.memobj.readMemory(addr2, size)

        res = e_mem.memdiff(bytes1, bytes2)
        if len(res) == 0:
            self.vprint('No Differences!')
            return

        for offset, offsize in res:
            diff1 = addr1+offset
            diff2 = addr2+offset
            self.canvas.addText('==== %d byte difference at offset %d\n' % (offsize,offset))
            self.canvas.addVaText("0x%.8x" % diff1, diff1)
            self.canvas.addText(":")
            self.canvas.addText(bytes1[offset:offset+offsize].encode('hex'))
            self.canvas.addText('\n')
            self.canvas.addVaText("0x%.8x" % diff2, diff2)
            self.canvas.addText(":")
            self.canvas.addText(bytes2[offset:offset+offsize].encode('hex'))
            self.canvas.addText('\n')

    def do_mem(self, line):
        """
        Show some memory (with optional formatting and size)

        Usage: mem [-F <format>] <addr expression> [size]

        NOTE: use -F ? for a list of the formats
        """
        fmtname = "bytes"

        if len(line) == 0:
            return self.do_help("mem")

        argv = splitargs(line)
        try:
            opts,args = getopt(argv, "F:")
        except:
            return self.do_help("mem")

        for opt,optarg in opts:
            if opt == "-F":
                fmtname = optarg
                fnames = self.canvas.getRendererNames()

                if fmtname == "?":
                    self.vprint("Registered renderers:")
                    for name in fnames:
                        self.vprint(name)
                    return

                if fmtname not in fnames:
                    self.vprint("Unknown renderer: %s" % fmtname)
                    return

        if len(args) == 0:
            return self.do_help("mem")

        size = 256
        addr = self.parseExpression(args[0])
        if len(args) == 2:
            size = self.parseExpression(args[1])

        self.canvas.setRenderer(fmtname)
        self.canvas.render(addr, size)

class EnviMutableCli(EnviCli):
    """
    Cli extensions which require a mutable memory object
    (emulator/trace) rather than a static one (viv workspace)
    """

    def do_memcpy(self, line):
        '''
        Copy memory from one location to another...

        Usage: memcpy <dest_expr> <src_expr> <size_expr>
        '''
        argv = splitargs(line)
        if len(argv) != 3:
            return self.do_help('memcpy')


        dst = self.parseExpression(argv[0])
        src = self.parseExpression(argv[1])
        siz = self.parseExpression(argv[2])

        mem = self.memobj.readMemory(src, siz)
        self.memobj.writeMemory(dst, mem)

    def do_memprotect(self, line):
        """
        Change the memory permissions of a given page/map.

        Usage: memprotect [options] <addr_expr> <perms>
        -S <size> Specify the size of the region to change (default == whole memory map)
        <perms> = "rwx" string "rw", "rx" "rwx" etc...
        """
        if len(line) == 0:
            return self.do_help("memprotect")

        size = None
        argv = splitargs(line)
        try:
            opts, args = getopt(argv, "S:")
        except Exception, e:
            return self.do_help("memprotect")

        for opt,optarg in opts:
            if opt == "-S":
                size = self.parseExpression(optarg)

        if len(args) != 2:
            return self.do_help("memprotect")


        addr = self.parseExpression(args[0])
        perm = e_mem.parsePerms(args[1])

        if size == None:
            map = self.memobj.getMemoryMap(addr)
            if map == None:
                raise Exception("Unknown memory map for 0x%.8x" % addr)
            size = map[1]

        self.memobj.protectMemory(addr, size, perm)

    def do_writemem(self, args):
        """
        Over-write some memory in the target address space.
        Usage: writemem [options] <addr expression> <string>
        -X    The specified string is in hex (ie 414141 = AAA)
        -U    The specified string needs to be unicode in mem (AAA -> 410041004100)
        """
        dohex = False
        douni = False

        try:
            argv = splitargs(args)
            opts,args = getopt(argv, "XU")
        except:
            return self.do_help("writemem")

        if len(args) != 2:
            return self.do_help("writemem")

        for opt,optarg in opts:
            if opt == "-X":
                dohex = True
            elif opt == "-U":
                douni = True

        exprstr, memstr = args
        if dohex: memstr = memstr.decode('hex')
        if douni: memstr = ("\x00".join(memstr)) + "\x00"

        addr = self.parseExpression(exprstr)
        self.memobj.writeMemory(addr, memstr)


########NEW FILE########
__FILENAME__ = codeflow
'''
A module to contain code flow analysis for envi opcode objects...
'''
import copy

import envi
import envi.memory as e_mem

class CodeFlowContext(object):

    '''
    A CodeFlowContext is used for code-flow (not linear) based disassembly
    for an envi MemoryObject (which is responsible for knowing the implementation
    of parseOpcode().  The CodeFlowContext will optionally notify several callback
    handlers for different events which occur during disassembly:

    self._cb_opcode(va, op, branches) - called for every newly parsed opcode
        NOTE: _cb_opcode must return the desired branches for continued flow

    self._cb_function(fva, metadict) - called once for every function

    self._cb_branchtable(tabva, destva) - called for switch tables

    '''
    def __init__(self, mem):

        self._funcs = {}
        self._entries = {}
        self._mem = mem
        self._opdone = {}

    def _cb_opcode(self, va, op, branches):
        '''
        Extend CodeFlowContext and implement this method to recieve
        a callback for every newly discovered opcode.
        '''
        return branches

    def _cb_function(self, fva, fmeta):
        '''
        Extend CodeFlowContext and implement this method to recieve
        a callback for every newly discovered function.  Additionally,
        metadata about the function may be stored in the fmeta dict.
        '''
        pass

    def _cb_branchtable(self, tabva, destva):
        pass

    def getCallsFrom(self, fva):
        return self._funcs.get(fva)

    def addFunctionDef(self, fva, calls_from):
        '''
        Add a priori knowledge of a function to the code flow
        stuff...
        '''

        if self._funcs.get(fva) != None:
            return

        self._funcs[fva] = calls_from

    def addCodeFlow(self, va, persist=False, exptable=True):
        '''
        Do code flow disassembly from the specified address.  Returnes a list
        of the procedural branch targets discovered during code flow...

        Set persist=True to store 'opdone' and never disassemble the same thing twice
        Set exptable=True to expand branch tables in this phase
        '''

        opdone = self._opdone
        if not persist:
            opdone = {}
        calls_from = {}
        optodo = [va, ]

        while len(optodo):

            va = optodo.pop()

            if opdone.get(va):
                continue

            opdone[va] = True

            try:
                op = self._mem.parseOpcode(va)
            except Exception, e:
                print 'parseOpcodeError at 0x%.8x: %s' % (va,e)
                # FIXME code block breakage...
                continue

            branches = op.getBranches()
            # The opcode callback may filter branches...
            branches = self._cb_opcode(va, op, branches)

            while len(branches):

                bva, bflags = branches.pop()

                # Don't worry about unresolved branches now...
                if bva == None:
                    continue

                # Handle a table branch by adding more branches...
                if bflags & envi.BR_TABLE:
                    if exptable:
                        ptrbase = bva
                        bdest = self._mem.readMemoryFormat(ptrbase, '<P')[0]
                        tabdone = {}
                        while self._mem.isValidPointer(bdest):

                            self._cb_branchtable(ptrbase, bdest)

                            if not tabdone.get(bdest):
                                tabdone[bdest] = True
                                branches.append((bdest, envi.BR_COND))

                            ptrbase += self._mem.psize
                            bdest = self._mem.readMemoryFormat(ptrbase, '<P')[0]

                    continue

                # FIXME handle conditionals here for block boundary detection!

                if bflags & envi.BR_DEREF:

                    if not self._mem.probeMemory(bva, 1, e_mem.MM_READ):
                        continue

                    bva = self._mem.readMemoryFormat(bva, '<P')[0]

                if not self._mem.probeMemory(bva, 1, e_mem.MM_EXEC):
                    continue

                if bflags & envi.BR_PROC:

                    # Record that the current code flow has a call from it
                    # to the branch target...
                    # FIXME intel hack, call 0, pop reg for geteip...
                    if bva != va + len(op):
                        calls_from[bva] = True

                else:
                    if not opdone.get(bva):
                        optodo.append(bva)

        return calls_from.keys()

    def _handleFunc(self, va, pth):

        path = []

        # Check if this is already a known function.
        if self._funcs.get(va) != None:
            return

        self._funcs[va] = True

        # Check if we have disassembled a loop
        if va in pth:
            return

        pth.append(va)

        calls_from = self.addCodeFlow(va)

        for callto in calls_from:
            self._handleFunc(callto, pth=pth)

        pth.pop()

        # Finally, notify the callback of a new function
        self._cb_function(va, {'CallsFrom':calls_from})

    def addEntryPoint(self, va):
        '''
        Analyze the given procedure entry point and flow downward
        to find all subsequent code blocks and procedure edges.
        '''
        self._entries[va] = True
        return self._handleFunc(va, [])


########NEW FILE########
__FILENAME__ = config
"""
Unified config object for all vtoys.
"""

import os
import sys

from ConfigParser import ConfigParser
from cStringIO import StringIO

def gethomedir(*paths):
    path = None
    if sys.platform == "win32":
        homepath = os.getenv("HOMEPATH")
        homedrive = os.getenv("HOMEDRIVE")
        if homedrive != None and homepath != None:
            path = os.path.join(homedrive, homepath, *paths)
    else:
        home = os.getenv("HOME")
        if home != None:
            path = os.path.join(home, *paths)

    if path != None and not os.path.exists(path):
        os.makedirs(path)

    return path

def getusername():
    u = os.getenv('USERNAME')
    if u != None:
        return u
    u = os.getenv('USER')
    if u != None:
        return u
    return 'UnknownUser'

class EnviConfig(ConfigParser):

    def __init__(self, filename=None, defaults=None):
        ConfigParser.__init__(self)
        if defaults != None:
            self.readstr(defaults)
            
        self.filename = filename
        if filename != None:
            self.read(filename)

    def readstr(self, s):
        self.readfp(StringIO(s))

    def syncFile(self):
        if self.filename != None:
            f = file(self.filename, "wb")
            self.write(f)
            f.close()

    def set(self, sec, opt, val):
        ConfigParser.set(self, sec, opt, val)
        self.syncFile()

    def remove_option(self, sec, opt):
        ConfigParser.remove_option(self, sec, opt)
        self.syncFile()

    #def __getattr__(self, name):

    #def __setattr__(self, name, value):


########NEW FILE########
__FILENAME__ = expression
"""
Unified expression helpers.
"""

def evaluate(pycode, locals):
    return eval(pycode, {}, locals)

class ExpressionLocals(dict):
    """
    An object to act as the locals dictionary for the evaluation
    of envi expressions.  You may pass in an envi.resolver.SymbolResolver
    object to automagically use symbols in your expressions.
    """
    def __init__(self, symobj=None):
        dict.__init__(self)
        self.symobj = symobj

    def __getitem__(self, name):
        if self.symobj != None:
            ret = self.symobj.getSymByName(name)
            if ret != None: return ret
        return dict.__getitem__(self, name)

class MemoryExpressionLocals(ExpressionLocals):

    def __init__(self, memobj, symobj=None):
        ExpressionLocals.__init__(self, symobj=symobj)
        self.memobj = memobj
        self.update({
            'mapbase':self.mapbase,
            'maplen':self.maplen,
            'ispoi':self.ispoi,
            'mem':self.mem,
            'poi':self.poi,
            'sym':self.sym,
        })

    def sym(self, symstr):
        '''
        An easy to use utility for symbols which have un-pythonic names.

        Example x = sym('kernel32.??2@$$FYAPAXI@Z')
        '''
        return long(evaluate(symstr, self))

    def mapbase(self, address):
        """
        The expression mapbase(address) returns the base address of the
        memory mapped area containing "address"
        """
        map = self.memobj.getMemoryMap(address)
        if not map:
            raise Exception("ERROR - un-mapped address in mapbase()")
        return map[0]

    def maplen(self, address):
        """
        The expression maplen(address) returns the length of the
        memory mapped area containing "address".
        """
        map = self.memobj.getMemoryMap(address)
        if not map:
            raise Exception("ERROR - un-mapped address in maplen()")
        return map[1]

    def ispoi(self, addr):
        """
        The expression ispoi(value) returns True if the specified value
        is a valid pointer.  Otherwise, False.
        """
        return self.memobj.isValidPointer(addr)

    def mem(self, addr, size):
        """
        Read and return memory.

        Example: mem(ecx, 20)
        """
        return self.memobj.readMemory(addr, size)

    def poi(self, address):
        """
        When expression contains "poi(addr)" this will return
        the address pointed to by addr.
        """
        return self.memobj.readMemoryFormat(address, "P")[0]


########NEW FILE########
__FILENAME__ = memory
import re

import struct
import envi

"""
A module containing memory utilities and the definition of the
memory access API used by all vtoys trace/emulators/workspaces.
"""

# Memory Map Permission Flags
MM_NONE = 0x0
MM_READ = 0x4
MM_WRITE = 0x2
MM_EXEC = 0x1
MM_SHARED = 0x08

MM_READ_WRITE = MM_READ | MM_WRITE
MM_READ_EXEC  =  MM_READ | MM_EXEC
MM_RWX = MM_READ | MM_WRITE | MM_EXEC

pnames = ['No Access', 'Execute', 'Write', None, 'Read']
def getPermName(perm):
    '''
    Return the human readable name for a *single* memory
    perm enumeration value.
    '''
    return pnames[perm]

def reprPerms(mask):
    plist = ['-','-','-','-']
    if mask & MM_SHARED:
        plist[0] = 's'
    if mask & MM_READ:
        plist[1] = 'r'
    if mask & MM_WRITE:
        plist[2] = 'w'
    if mask & MM_EXEC:
        plist[3] = 'x'

    return "".join(plist)

def parsePerms(pstr):
    ret = 0
    if pstr.find('s') != -1: ret |= MM_SHARED
    if pstr.find('r') != -1: ret |= MM_READ
    if pstr.find('w') != -1: ret |= MM_WRITE
    if pstr.find('x') != -1: ret |= MM_EXEC
    return ret

class IMemory:
    """
    This is the interface spec (and a few helper utils)
    for the unified memory object interface.

    NOTE: If your actual underlying memory format is such
    that over-riding anything (like isValidPointer!) can
    be faster than the default implementation, DO IT!
    """

    def __init__(self, archmod=None):
        self.imem_psize = struct.calcsize("P")
        self.imem_arch = archmod
        # If the specified an arch module, use that!
        if archmod != None:
            self.imem_psize = archmod.getPointerSize()

    def readMemory(self, va, size):
        """
        Read memory from the specified virtual address for size bytes
        and return it as a python string.

        Example: mem.readMemory(0x41414141, 20) -> "A..."
        """
        raise Exception("must implement readMemory!")

    def writeMemory(self, va, bytes):
        """
        Write the given bytes to the specified virtual address.

        Example: mem.writeMemory(0x41414141, "VISI")
        """
        raise Exception("must implement writeMemory!")

    def protectMemory(self, va, size, perms):
        """
        Change the protections for the given memory map. On most platforms
        the va/size *must* exactly match an existing memory map.
        """
        raise Exception("must implement protectMemory!")

    def probeMemory(self, va, size, perm):
        """
        Check to be sure that the given virtual address and size
        is contained within one memory map, and check that the
        perms are contained within the permission bits
        for the memory map. (MM_READ | MM_WRITE | MM_EXEC | ...)

        Example probeMemory(0x41414141, 20, envi.memory.MM_WRITE)
        (check if the memory for 20 bytes at 0x41414141 is writable)
        """
        map = self.getMemoryMap(va)
        if map == None:
            return False
        mapva, mapsize, mapperm, mapfile = map
        mapend = mapva+mapsize
        if va+size >= mapend:
            return False
        if mapperm & perm != perm:
            return False
        return True

    def allocateMemory(self, size, perms=MM_RWX, suggestaddr=0):
        raise Exception("must implement allocateMemory!")

    def addMemoryMap(self, mapva, perms, fname, bytes):
        raise Exception("must implement addMemoryMap!")

    def getMemoryMaps(self):
        raise Exception("must implement getMemoryMaps!")

    # Mostly helpers from here down...
    def readMemoryFormat(self, va, fmt):
        # Somehow, pointers are "signed" when they
        # get chopped up by python's struct package
        if self.imem_psize == 4:
            fmt = fmt.replace("P","I")
        elif self.imem_psize == 8:
            fmt = fmt.replace("P","Q")

        size = struct.calcsize(fmt)
        bytes = self.readMemory(va, size)
        return struct.unpack(fmt, bytes)

    def getSegmentInfo(self, id):
        return (0,0xffffffff)

    def readMemValue(self, addr, size):
        bytes = self.readMemory(addr, size)
        if bytes == None:
            return None
        #FIXME change this (and all uses of it) to passing in format...
        if len(bytes) != size:
            raise Exception("Read Gave Wrong Length At 0x%.8x (va: 0x%.8x wanted %d got %d)" % (self.getProgramCounter(),addr, size, len(bytes)))
        if size == 1:
            return struct.unpack("B", bytes)[0]
        elif size == 2:
            return struct.unpack("<H", bytes)[0]
        elif size == 4:
            return struct.unpack("<I", bytes)[0]
        elif size == 8:
            return struct.unpack("<Q", bytes)[0]


    def writeMemoryFormat(self, va, fmt, *args):
        '''
        Write a python format sequence of variables out to memory after
        serializing using struct pack...

        Example:
            trace.writeMemoryFormat(va, '<PBB', 10, 30, 99)
        '''
        if self.imem_psize == 4:
            fmt = fmt.replace("P","I")
        elif self.imem_psize == 8:
            fmt = fmt.replace("P","Q")
        mbytes = struct.pack(fmt, *args)
        self.writeMemory(va, mbytes)

    def getMemoryMap(self, va):
        """
        Return a tuple of mapva,size,perms,filename for the memory
        map which contains the specified address (or None).
        """
        for mapva,size,perms,mname in self.getMemoryMaps():
            if va >= mapva and va < (mapva+size):
                return (mapva,size,perms,mname)
        return None

    def isValidPointer(self, va):
        return self.getMemoryMap(va) != None

    def isReadable(self, va):
        maptup = self.getMemoryMap(va)
        if maptup == None:
            return False
        return bool(maptup[2] & MM_READ)

    def isWriteable(self, va):
        maptup = self.getMemoryMap(va)
        if maptup == None:
            return False
        return bool(maptup[2] & MM_WRITE)

    def isExecutable(self, va):
        maptup = self.getMemoryMap(va)
        if maptup == None:
            return False
        return bool(maptup[2] & MM_EXEC)

    def isShared(self, va):
        maptup = self.getMemoryMap(va)
        if maptup == None:
            return False
        return bool(maptup[2] & MM_SHAR)


    def searchMemory(self, needle, regex=False):
        """
        A quick cheater way to searchMemoryRange() for each
        of the current memory maps.
        """
        results = []
        for va,size,perm,fname in self.getMemoryMaps():
            try:
                results.extend(self.searchMemoryRange(needle, va, size, regex=regex))
            except:
                pass # Some platforms dont let debuggers read non-readable mem

        return results

    def searchMemoryRange(self, needle, address, size, regex=False):
        """
        Search the specified memory range (address -> size)
        for the string needle.   Return a list of addresses
        where the match occurs.
        """
        results = []
        memory = self.readMemory(address, size)
        if regex:
            for match in re.finditer(needle, memory):
                off = match.start()
                results.append(address+off)
        else:
            offset = 0
            while offset < size:
                loc = memory.find(needle, offset)
                if loc == -1: # No more to be found ;)
                    break
                results.append(address+loc)
                offset = loc+len(needle) # Skip one past our matcher

        return results

    def parseOpcode(self, va):
        '''
        Parse an opcode from the specified virtual address.

        Example: op = m.parseOpcode(0x7c773803)
        '''
        if self.imem_arch == None:
            raise Exception('IMemory got no architecture module (%s)' % (self.__class__.__name__))
        b = self.readMemory(va, 16)
        return self.imem_arch.makeOpcode(b, 0, va)

class MemoryObject(IMemory):

    def __init__(self, maps=()):
        """
        Take a set of memory maps (va, perms, fname, bytes) and put them in
        a sparse space finder. You may specify your own page-size to optimize
        the search for an architecture.
        """
        IMemory.__init__(self)
        self._map_defs = []
        for va,perms,fname,bytes in maps:
            self.addMemoryMap(va, perms, fname, bytes)

    #FIXME MemoryObject: def allocateMemory(self, size, perms=MM_RWX, suggestaddr=0):

    def addMemoryMap(self, va, perms, fname, bytes):
        '''
        Add a memory map to this object...
        '''
        msize = len(bytes)
        map = (va, msize, perms, fname)
        hlpr = [va, va+msize, map, bytes]
        self._map_defs.append(hlpr)
        return

    def getMemorySnap(self):
        '''
        Take a memory snapshot which may be restored later.

        Example: snap = mem.getMemorySnap()
        '''
        return [ list(mdef) for mdef in self._map_defs ]

    def setMemorySnap(self, snap):
        '''
        Restore a previously saved memory snapshot.

        Example: mem.setMemorySnap(snap)
        '''
        self._map_defs = [list(md) for md in snap]

    def getMemoryMap(self, va):
        """
        Get the va,size,perms,fname tuple for this memory map
        """
        for mva, mmaxva, mmap, mbytes in self._map_defs:
            if va >= mva and va < mmaxva:
                return mmap
        return None

    def getMemoryMaps(self):
        return [ mmap for mva, mmaxva, mmap, mbytes in self._map_defs ]

    def readMemory(self, va, size):

        for mva, mmaxva, mmap, mbytes in self._map_defs:
            if va >= mva and va < mmaxva:
                mva, msize, mperms, mfname = mmap
                if not mperms & MM_READ:
                    raise envi.SegmentationViolation(va)
                offset = va - mva
                return mbytes[offset:offset+size]
        raise envi.SegmentationViolation(va)

    def writeMemory(self, va, bytes):
        for mapdef in self._map_defs:
            mva, mmaxva, mmap, mbytes = mapdef
            if va >= mva and va < mmaxva:
                mva, msize, mperms, mfname = mmap
                if not mperms & MM_WRITE:
                    raise envi.SegmentationViolation(va)
                offset = va - mva
                mapdef[3] = mbytes[:offset] + bytes + mbytes[offset+len(bytes):]
                return

        raise envi.SegmentationViolation(va)

    def getByteDef(self, va):
        """
        An optimized routine which returns the existing
        segment bytes sequence without creating a new
        string object *AND* an offset of va into the 
        buffer.  Used internally for optimized memory
        handling.  Returns (offset, bytes)
        """
        for mapdef in self._map_defs:
            mva, mmaxva, mmap, mbytes = mapdef
            if va >= mva and va < mmaxva:
                offset = va - mva
                return (offset, mbytes)
        raise envi.SegmentationViolation(va)

class MemoryFile:
    '''
    A file like object to wrap around a memory object.
    '''
    def __init__(self, memobj, baseaddr):
        self.baseaddr = baseaddr
        self.offset = baseaddr
        self.memobj = memobj

    def seek(self, offset):
        self.offset = self.baseaddr + offset

    def read(self, size):
        ret = self.memobj.readMemory(self.offset, size)
        self.offset += size
        return ret
        
    def write(self, bytes):
        self.memobj.writeMemory(self.offset, bytes)
        self.offset += len(bytes)


def memdiff(bytes1, bytes2):
    '''
    Return a list of (offset, size) tuples showing any memory
    differences between the given bytes.
    '''
    
    size = len(bytes1)
    if size != len(bytes2):
        raise Exception('memdiff *requires* same size bytes')
    ret = []
    offset = 0
    while offset < size:
        if bytes1[offset] != bytes2[offset]:
            beginoff = offset
            # Gather up all the difference bytes.
            while ( offset < size and
                    bytes1[offset] != bytes2[offset]):
                offset += 1
            ret.append((beginoff, offset-beginoff))
        offset += 1
    return ret


########NEW FILE########
__FILENAME__ = pagelookup
'''
A home for the page lookup construct.  Basically it is a
python object which implements a similar lookup mechanism
to the i386 page table lookups...
'''

# FIXME move functions in here too so there is procedural "speed" way
# and objecty pythonic way...

class PageLookup:
    '''
    An object capable of rapid lookups across a sparse address
    space which will also NOT eat *all* the RAMS like a straight
    dictionary full of millions of entries would.
    '''

    def __init__(self):
        self._page_dict = {}

    def getPageLookup(self, va):
        base = va >> 16
        offs = va & 0xffff
        page = self._page_dict.get(base)
        if page == None:
            return None
        return page[offs]

    def setPageLookup(self, va, size, obj):
        vamax = va+size
        while va < vamax:
            base = va >> 16
            offs = va & 0xffff
            page = self._page_dict.get(base)
            if page == None:
                page = [None] * 0xffff
                self._page_dict[base] = page
            page[offs] = obj
            va += 1

    # __getitem__
    # __getslice__
    # __setslice__

class MapLookup:

    '''
    A specialized lookup object for large densely populated ranges
    which are layed out in a sparse field space themselves...
    '''

    def __init__(self):
        self._maps_list = []

    def initMapLookup(self, va, size, obj=None):
        marray = [obj] * size
        # FIXME optimize by size!
        self._maps_list.append((va, va+size, marray))

    def setMapLookup(self, va, size, obj):
        for mva, mvamax, marray in self._maps_list:
            if va >= mva and va < mvamax:
                off = va - mva
                s = [obj] * size
                marray[off:off+size] = s
                return
        raise Exception('Address (0x%.8x) not in maps!' % va)

    def getMapLookup(self, va):
        for mva, mvamax, marray in self._maps_list:
            if va >= mva and va < mvamax:
                off = va - mva
                return marray[off]
        return None

    def __getslice__(self, start, end):
        print 'GET SLICE'


########NEW FILE########
__FILENAME__ = registers
"""
Similar to the memory subsystem, this is a unified way to
access information about objects which contain registers
"""

import envi.bits as e_bits

class InvalidRegisterName(Exception):
    pass

class RegisterContext:

    def __init__(self, regdef=(), metas=(), pcindex=None, spindex=None):
        """
        Hand in a register definition which consists of
        a list of (<name>, <width>) tuples.
        """
        self.loadRegDef(regdef)
        self.loadRegMetas(metas)
        self.setRegisterIndexes(pcindex, spindex)

        self._rctx_dirty = False

    def getRegisterSnap(self):
        """
        Use this to bulk save off the register state.
        """
        return list(self._rctx_vals)

    def setRegisterSnap(self, snap):
        """
        Use this to bulk restore the register state.

        NOTE: This may only be used under the assumption that the
              RegisterContext has been initialized the same way
              (like context switches in tracers, or emulaction snaps)
        """
        self._rctx_vals = list(snap)

    def isDirty(self):
        """
        Returns true if registers in this context have been modififed
        since their import.
        """
        return self._rctx_dirty

    def setIsDirty(self, bool):
        self._rctx_dirty = bool

    def setRegisterIndexes(self, pcindex, spindex):
        self._rctx_pcindex = pcindex
        self._rctx_spindex = spindex

    def loadRegDef(self, regdef, defval=0):
        """
        Load a register definition.  A register definition consists
        of a list of tuples with the following format:
        (regname, regwidth)

        NOTE: All widths in envi RegisterContexts are in bits.
        """
        self._rctx_regdef = regdef # Save this for snaps etc..
        self._rctx_names = {}
        self._rctx_ids = {}
        self._rctx_widths = []
        self._rctx_vals  = []
        self._rctx_masks = []

        for i,(name,width) in enumerate(regdef):
            self._rctx_names[name] = i
            self._rctx_ids[i] = name
            self._rctx_widths.append(width)
            self._rctx_masks.append((2**width)-1)
            self._rctx_vals.append(defval)

    def getRegDef(self):
        return self._rctx_regdef

    def loadRegMetas(self, metas):
        """
        Load a set of defined "meta" registers for this architecture.  Meta
        registers are defined as registers who exist as a subset of the bits
        in some other "real" register. The argument metas is a list of tuples
        with the following format:
        (regname, reg_shift_offset, reg_width)
        The given example is for the AX register in the i386 subsystem
        regname: "ax"
        reg_shift_offset: 0
        reg_width: 16
        """
        self._rctx_regmetas = metas
        for name,idx,offset,width in metas:
            self.addMetaRegister(name,idx, offset, width)

    def addMetaRegister(self, name, idx, offset, width):
        """
        Meta registers are registers which are really just directly
        addressable parts of already existing registers (eax -> al).

        To add a meta register, you give the name, the idx of the *real*
        register, the width of the meta reg, and it's left shifted (in bits)
        offset into the real register value.  The RegisterContext will take
        care of accesses after that.
        """
        newidx = (offset << 24) + (width << 16) + idx
        self._rctx_names[name] = newidx
        self._rctx_ids[newidx] = name

    def isMetaRegister(self, index):
        return (index & 0xffff) == index

    def _rctx_Import(self, sobj):
        """
        Given an object with attributes with the same names as
        registers in our context, populate our values from it.

        NOTE: This also clears the dirty flag
        """
        # On import from a structure, we are clean again.
        self._rctx_dirty = False
        for name,idx in self._rctx_names.items():
            # Skip meta registers
            if (idx & 0xffff) != idx:
                continue
            x = getattr(sobj, name, None)
            if x != None:
                self._rctx_vals[idx] = x

    def _rctx_Export(self, sobj):
        """
        Given an object with attributes with the same names as
        registers in our context, set the ones he has to match
        our values.
        """
        for name,idx in self._rctx_names.items():
            # Skip meta registers
            if (idx & 0xffff) != idx:
                continue
            if hasattr(sobj, name):
                setattr(sobj, name, self._rctx_vals[idx])

    def reprRegister(self, idx):
        """
        This may be used to allow a register context to provide
        extended repr (flags breakouts, etc) info about a register.
        """
        width = self._rctx_widths.get(idx)
        reg = self.getRegisger(idx)
        return e_bits.hex(reg, width/8)

    def getRegisterInfo(self, meta=False):
        """
        Return an object which can be stored off, and restored
        to re-initialize a register context.  (much like snapshot
        but it takes the definitions with it)
        """
        regdef = self._rctx_regdef
        regmeta = self._rctx_regmetas
        pcindex = self._rctx_pcindex
        spindex = self._rctx_spindex
        snap = self.getRegisterSnap()

        return (regdef, regmeta, pcindex, spindex, snap)

    def setRegisterInfo(self, info):
        """
        Import the exported data from 
        """
        regdef, regmeta, pcindex, spindex, snap = info
        self.loadRegDef(regdef)
        self.loadRegMetas(regmeta)
        self.setRegisterIndexes(pcindex, spindex)
        self.setRegisterSnap(snap)

    def getRegisterName(self, index):
        return self._rctx_ids.get(index,"REG%.8x" % index)

    def getProgramCounter(self):
        """
        Get the value of the program counter for this register
        context.
        """
        return self.getRegister(self._rctx_pcindex)

    def setProgramCounter(self, value):
        """
        Set the value of the program counter for this register
        contex.
        """
        self.setRegister(self._rctx_pcindex, value)

    def getStackCounter(self):
        return self.getRegister(self._rctx_spindex)

    def setStackCounter(self, value):
        self.setRegister(self._rctx_spindex, value)

    def getRegisterByName(self, name):
        idx = self._rctx_names.get(name)
        if idx == None:
            raise InvalidRegisterName("Unknown Register: %s" % name)
        return self.getRegister(idx)

    def setRegisterByName(self, name, value):
        idx = self._rctx_names.get(name)
        if idx == None:
            raise InvalidRegisterName("Unknown Register: %s" % name)
        self.setRegister(idx, value)

    def getRegisterNames(self):
        """
        """
        return self._rctx_names.keys()

    def getRegisterNameIndexes(self):
        '''
        Return a list of all the "real" (non meta) registers and their indexes.

        Example: for regname, regidx in x.getRegisterNameIndexes():
        '''
        return self._rctx_names.items()

    def getRegisters(self):
        """
        Get all the *real* registers from this context as a dictionary of name
        value pairs.
        """
        ret = {}
        for name,idx in self._rctx_names.items():
            if (idx & 0xffff) != idx:
                continue
            ret[name] = self.getRegister(idx)
        return ret

    def setRegisters(self, regdict):
        """
        For any name value pairs in the specified dictionary, set the current
        register values in this context.
        """
        for name,value in regdict.items():
            self.setRegisterByName(name, value)

    def getRegisterIndex(self, name):
        """
        Get a register index by name.
        (faster to use the index multiple times)
        """
        return self._rctx_names.get(name)

    def getRegisterWidth(self, index):
        """
        Return the width of the register which lives at the specified
        index (width is always in bits).
        """
        ridx = index & 0xffff
        if ridx == index:
            return self._rctx_widths[index]
        width  = (index >> 16) & 0xff
        return width

    def getRegister(self, index):
        """
        Return the current value of the specified register index.
        """
        ridx = index & 0xffff
        value = self._rctx_vals[ridx]
        if ridx != index:
            value = self._xlateToMetaReg(index, value)
        return value

    def getMetaRegInfo(self, index):
        '''
        Return the appropriate realreg, shift, mask info
        for the specified metareg idx (or None if it's not
        meta).

        Example:
            real_reg, lshift, mask = r.getMetaRegInfo(x)
        '''
        ridx = index & 0xffff
        if ridx == index:
            return None

        offset = (index >> 24) & 0xff
        width  = (index >> 16) & 0xff

        mask = (2**width)-1
        return ridx, offset, mask

    def _xlateToMetaReg(self, index, value):
        '''
        Translate a register value to the meta register value
        (used when getting a meta register)
        '''
        ridx = index & 0xffff
        offset = (index >> 24) & 0xff
        width  = (index >> 16) & 0xff

        mask = (2**width)-1

        if offset != 0:
            value >>= offset

        return value & mask


    def _xlateToNativeReg(self, index, value):
        '''
        Translate a register value to the native register value
        (used when setting a meta register)
        '''
        ridx = index & 0xffff
        offset = (index >> 24) & 0xff
        width  = (index >> 16) & 0xff

        #FIXME is it faster to generate or look thses up?
        mask = (2**width)-1
        mask = mask << offset

        # NOTE: basewidth is in *bits*
        basewidth = self._rctx_widths[ridx]
        basemask  = (2**basewidth)-1

        # cut a whole in basemask at the size/offset of mask
        finalmask = basemask ^ mask

        curval = self._rctx_vals[ridx]

        if offset:
            value <<= offset

        #NOTE value is first for object stuff in symboliks
        return value | (curval & finalmask)

    def setRegister(self, index, value):
        """
        Set a register value by index.
        """
        self._rctx_dirty = True

        ridx = index & 0xffff

        # If it's a meta register index, lets mask it into
        # the real thing...
        if ridx != index:
            value = self._xlateToNativeReg(index, value)

        self._rctx_vals[ridx] = (value & self._rctx_masks[ridx])

def addLocalEnums(l, regdef):
    """
    Update a dictionary (or module locals) with REG_FOO index
    values for all the base registers defined in regdef.
    """
    for i,(rname,width) in enumerate(regdef):
        l["REG_%s" % rname.upper()] = i

def addLocalMetas(l, metas):
    """
    Update a dictionary (or module locals) with REG_FOO index
    values for all meta registers defined in metas.
    """
    for name,idx,offset,width in metas:
        l["REG_%s" % name.upper()] = (offset << 24) | (width << 16) | idx


########NEW FILE########
__FILENAME__ = resolver
"""
The API describing what it means to be an envi compliant
symbol resolver.
"""

import types

class Symbol:

    def __init__(self, name, value, size=0, fname=None):
        self.name = name
        self.value = value
        self.size = size
        self.fname = fname

    def __eq__(self, other):
        if not isinstance(other, Symbol):
            return False
        return long(self) == long(other)

    def __coerce__(self, value):
        t = type(value)
        if t == types.NoneType:
            return (True, False)
        return (value, t(self.value))

    def __long__(self):
        return long(self.value)

    def __int__(self):
        return int(self.value)

    def __len__(self):
        return self.size

    def __str__(self):
        if self.fname != None:
            return "%s.%s" % (self.fname, self.name)
        return self.name

    def __repr__(self):
        return str(self)

class SymbolResolver:

    """
    NOTE: Nothing should reach directly into a SymbolResolver!
    """

    def __init__(self, width=4, casesens=True):
        self.width = width
        self.widthmask = (2**(width*8))-1
        self.casesens = casesens
        # Lets use 4096 byte buckes for now
        self.bucketsize = 4096
        self.bucketmask = self.widthmask ^ (self.bucketsize-1)
        self.buckets = {}
        self.symnames = {}
        self.symaddrs = {}

    def delSymbol(self, sym):
        """
        Delete a symbol from the resolver's namespace
        """
        symval = long(sym)
        self.symaddrs.pop(symval, None)

        bbase = symval & self.bucketmask
        while bbase < symval:
            bucket = self.buckets.get(bbase)
            bucket.remove(sym)
            bbase += self.bucketsize

        subres = None
        if sym.fname != None:
            subres = self.symnames.get(sym.fname)

        # Potentially del it from the sub resolver's namespace
        if subres != None:
            subres.delSymbol(sym)

        # Otherwise del it from our namespace
        else:
            symname = sym.name
            if not self.casesens:
                symname = symname.lower()
            self.symnames.pop(symname, None)

    def addSymbol(self, sym):
        """
        Add a symbol to the resolver.
        """
        # If the symbol has an fname, add it to the namespace
        # for the FileSymbol inside us rather than our namespace.

        symval = long(sym)
        self.symaddrs[symval] = sym

        bbase = symval & self.bucketmask
        while bbase < symval:
            bucket = self.buckets.get(bbase)
            if bucket == None:
                bucket = []
                self.buckets[bbase] = bucket
            bucket.append(sym)
            bbase += self.bucketsize

        subres = None
        if sym.fname != None:
            subres = self.symnames.get(sym.fname)

        # Potentially add it to the sub resolver's namespace
        if subres != None:
            subres.addSymbol(sym)

        # Otherwise add it to our namespace
        else:
            symname = sym.name
            if not self.casesens:
                symname = symname.lower()
            self.symnames[symname] = sym

    def getSymByName(self, name):
        if not self.casesens:
            name = name.lower()
        return self.symnames.get(name)

    def getSymByAddr(self, va, exact=True):
        """
        Return a symbol object for the given virtual address.
        """
        va = va & self.widthmask
        sym = self.symaddrs.get(va)

        if sym != None:
            return sym

        if not exact:
            b = va & self.bucketmask
            best = 999999999
            while sym == None:
                bucket = self.buckets.get(b)
                if bucket != None:
                    for s in bucket:
                        sva = long(s)
                        if sva > va:
                            continue
                        offset = va - sva
                        if offset < best:
                            best = offset
                            sym = s
                # If we get more than 8k away, just get out...
                if va - b > 8192:
                    break
                # Move back to the previous bucket.
                b -= self.bucketsize

        # If we resolve a sub-resolver, see if he
        # has finer resolution than we do...
        if isinstance(sym, SymbolResolver):
            ssym = sym.getSymByAddr(va, exact=exact)
            if ssym != None:
                return ssym

        return sym

    def getSymList(self):
        """
        Return a list of the symbols which are contained in this resolver.
        """
        return self.symaddrs.values()

    def getSymHint(self, va, hidx):
        """
        May be used by symbol resolvers who know what type they are
        resolving to store and retrieve "hints" with indexes.

        Used specifically by opcode render methods to resolve
        any memory dereference info for a given operand.

        NOTE: These are mostly symbolic references to FRAME LOCAL
              names....
        """
        return None

# Some extension types

class FunctionSymbol(Symbol):
    """
    Used to represent functions.
    """
    def __repr__(self):
        return "%s.%s()" % (self.fname, self.name)

class SectionSymbol(Symbol):
    """
    Used for file sections/segments.
    """
    def __repr__(self):
        return "%s[%s]" % (self.fname,self.name)

class FileSymbol(Symbol,SymbolResolver):
    """
    A file symbol is both a symbol resolver of it's own, and
    a symbol.

    File symbols are used to do heirarchal symbol lookups and don't
    actually add anything but the name to their lookup (it is assumed
    that the parent Resolver of the FileSymbol takes care of addr lookups.
    """
    def __init__(self, fname, base, size, width=4):
        SymbolResolver.__init__(self, width=width)
        Symbol.__init__(self, fname, base, size)

    def __getattr__(self, name):
        """
        File symbols may be dereferenced like python objects to resolve
        symbols within them.
        """
        ret = self.getSymByName(name)
        if ret == None:
            raise AttributeError("%s has no symbol %s" % (self.name,name))
        return ret

    def __getitem__(self, name):
        """
        Allow dictionary style access for mangled incompatible names...
        """
        ret = self.getSymByName(name)
        if ret == None:
            raise KeyError("%s has no symbol %s" % (self.name,name))
        return ret


########NEW FILE########
__FILENAME__ = threads
'''
A couple useful thread related toys...
'''

import threading

def firethread(func):
    '''
    A decorator which fires a thread to do the given call.

    NOTE: This means these methods may not return anything
    and callers may not expect sync behavior!
    '''
    def dothread(*args, **kwargs):
        thr = threading.Thread(target=func, args=args, kwargs=kwargs)
        thr.setDaemon(True)
        thr.start()
    return dothread


########NEW FILE########
__FILENAME__ = util

class CopyOnWrite:
    """
    A memory object wrapper you can use to do copy-on-write memory
    use and be able to simply reset it.
    """

    def __init__(self, memobj):
        self.writes = []
        self.memobj = memobj

    def reset(self):
        """
        Throw away the current writes and be fresh...
        """
        self.writes = []

    def writeMemory(self, va, bytes):
        # FIXME for now, allow any writes, but soon, do more
        self.writes.append((va,va+len(bytes),bytes))

    def readMemory(self, va, size):
        for memva,nextva,bytes in self.writes:
            if memva <= va and va+size <= nextva:
                offset = va-memva
                return bytes[offset:offset+size]
        return self.memobj.readMemory(va, size)


########NEW FILE########
__FILENAME__ = printord
import sys

'''
Quick utility to generate ord lookups from DLL exports.
'''

import PE

p = PE.PE(file(sys.argv[1], 'rb'))

base = long(p.IMAGE_EXPORT_DIRECTORY.Base)

ords = {}
for fva, ord, name in p.getExports():
    ords[ord+base] = name

keys = ords.keys()
keys.sort()
for k in keys:
    print '''    %d:'%s',''' % (k,ords.get(k))


########NEW FILE########
__FILENAME__ = ws2_32

ord_names = {
    1:'accept',
    2:'bind',
    3:'closesocket',
    4:'connect',
    5:'getpeername',
    6:'getsockname',
    7:'getsockopt',
    8:'htonl',
    9:'htons',
    10:'ioctlsocket',
    11:'inet_addr',
    12:'inet_ntoa',
    13:'listen',
    14:'ntohl',
    15:'ntohs',
    16:'recv',
    17:'recvfrom',
    18:'select',
    19:'send',
    20:'sendto',
    21:'setsockopt',
    22:'shutdown',
    23:'socket',
    24:'GetAddrInfoW',
    25:'GetNameInfoW',
    26:'WSApSetPostRoutine',
    27:'FreeAddrInfoW',
    28:'WPUCompleteOverlappedRequest',
    29:'WSAAccept',
    30:'WSAAddressToStringA',
    31:'WSAAddressToStringW',
    32:'WSACloseEvent',
    33:'WSAConnect',
    34:'WSACreateEvent',
    35:'WSADuplicateSocketA',
    36:'WSADuplicateSocketW',
    37:'WSAEnumNameSpaceProvidersA',
    38:'WSAEnumNameSpaceProvidersW',
    39:'WSAEnumNetworkEvents',
    40:'WSAEnumProtocolsA',
    41:'WSAEnumProtocolsW',
    42:'WSAEventSelect',
    43:'WSAGetOverlappedResult',
    44:'WSAGetQOSByName',
    45:'WSAGetServiceClassInfoA',
    46:'WSAGetServiceClassInfoW',
    47:'WSAGetServiceClassNameByClassIdA',
    48:'WSAGetServiceClassNameByClassIdW',
    49:'WSAHtonl',
    50:'WSAHtons',
    51:'gethostbyaddr',
    52:'gethostbyname',
    53:'getprotobyname',
    54:'getprotobynumber',
    55:'getservbyname',
    56:'getservbyport',
    57:'gethostname',
    58:'WSAInstallServiceClassA',
    59:'WSAInstallServiceClassW',
    60:'WSAIoctl',
    61:'WSAJoinLeaf',
    62:'WSALookupServiceBeginA',
    63:'WSALookupServiceBeginW',
    64:'WSALookupServiceEnd',
    65:'WSALookupServiceNextA',
    66:'WSALookupServiceNextW',
    67:'WSANSPIoctl',
    68:'WSANtohl',
    69:'WSANtohs',
    70:'WSAProviderConfigChange',
    71:'WSARecv',
    72:'WSARecvDisconnect',
    73:'WSARecvFrom',
    74:'WSARemoveServiceClass',
    75:'WSAResetEvent',
    76:'WSASend',
    77:'WSASendDisconnect',
    78:'WSASendTo',
    79:'WSASetEvent',
    80:'WSASetServiceA',
    81:'WSASetServiceW',
    82:'WSASocketA',
    83:'WSASocketW',
    84:'WSAStringToAddressA',
    85:'WSAStringToAddressW',
    86:'WSAWaitForMultipleEvents',
    87:'WSCDeinstallProvider',
    88:'WSCEnableNSProvider',
    89:'WSCEnumProtocols',
    90:'WSCGetProviderPath',
    91:'WSCInstallNameSpace',
    92:'WSCInstallProvider',
    93:'WSCUnInstallNameSpace',
    94:'WSCUpdateProvider',
    95:'WSCWriteNameSpaceOrder',
    96:'WSCWriteProviderOrder',
    97:'freeaddrinfo',
    98:'getaddrinfo',
    99:'getnameinfo',
    101:'WSAAsyncSelect',
    102:'WSAAsyncGetHostByAddr',
    103:'WSAAsyncGetHostByName',
    104:'WSAAsyncGetProtoByNumber',
    105:'WSAAsyncGetProtoByName',
    106:'WSAAsyncGetServByPort',
    107:'WSAAsyncGetServByName',
    108:'WSACancelAsyncRequest',
    109:'WSASetBlockingHook',
    110:'WSAUnhookBlockingHook',
    111:'WSAGetLastError',
    112:'WSASetLastError',
    113:'WSACancelBlockingCall',
    114:'WSAIsBlocking',
    115:'WSAStartup',
    116:'WSACleanup',
    151:'__WSAFDIsSet',
    500:'WEP',
}

########NEW FILE########
__FILENAME__ = petool

import os
import sys

import PE

'''
For now, all this does is rename files to their exportname and version info.
(more to come is likely)
'''

if __name__ == "__main__":

    for fname in sys.argv[1:]:

        print 'Parsing: %s' % fname

        vsver = None
        expname = None

        pe = PE.peFromFileName(fname)

        expname = pe.getExportName()

        dirname = os.path.dirname(fname)

        vs = pe.getVS_VERSIONINFO()
        if vs == None:
            print 'No VS_VERSIONINFO found!'

        else:
            keys = vs.getVersionKeys()
            keys.sort()
            for k in keys:
                val = vs.getVersionValue(k).encode('ascii','ignore')
                print '%s: %s' % (k, val)

        #if vs != None:
            #vsver = vs.getVersionValue('FileVersion')
            #newpath = os.path.join(dirname, '

        #if vsver != None and expname != None:
            #expname = expname.split('.')[0].lower()
            #vsver = vsver.split()[0]
            #destpath = os.path.join(dirname, '%s_%s.dll' % (expname, vsver))
            #print 'Renaming to %s' % destpath
            #os.rename(sys.argv[1], destpath)


########NEW FILE########
__FILENAME__ = amd64

def vdbExtension(vdb, trace):
    vdb.config.set('Aliases','db','mem -F bytes')
    vdb.config.set('Aliases','dw','mem -F u_int_16')
    vdb.config.set('Aliases','dd','mem -F u_int_32')
    vdb.config.set('Aliases','dq','mem -F u_int_64')
    vdb.config.set('Aliases','dr','mem -F "Deref View"')
    vdb.config.set('Aliases','ds','mem -F "Symbols View"')

########NEW FILE########
__FILENAME__ = arm

import envi.cli as e_cli
import envi.archs.arm.thumb as e_thumb

def thumb(db, line):
    '''
    Disassemble thumb instructions from the given address.

    Usage: thumb <addr_exp>
    '''
    t = db.getTrace()

    d = e_thumb.ArmThumbDisasm()

    argv = e_cli.splitargs(line)
    size = 20
    argc = len(argv)
    if argc == 0:
        addr = t.getProgramCounter()
    else:
        addr = t.parseExpression(argv[0])

    if argc > 1:
        size = t.parseExpression(argv[1])

    bytes = t.readMemory(addr, size)
    offset = 0

    db.vprint("Dissassembly:")
    while offset < size:
        va = addr + offset
        op = d.disasm(bytes, offset, va)
        obytes = bytes[offset:offset+len(op)]


        db.canvas.addVaText('0x%.8x' % va, va=va)
        db.canvas.addText(": %s " % obytes.encode('hex').ljust(17))
        op.render(db.canvas)
        db.canvas.addText("\n")

        offset += len(op)

def vdbExtension(db, trace):
    vdb.config.set('Aliases','db','mem -F bytes')
    vdb.config.set('Aliases','dw','mem -F u_int_16')
    vdb.config.set('Aliases','dd','mem -F u_int_32')
    vdb.config.set('Aliases','dq','mem -F u_int_64')
    vdb.config.set('Aliases','dr','mem -F "Deref View"')
    vdb.config.set('Aliases','ds','mem -F "Symbols View"')
    db.registerCmdExtension(thumb)


########NEW FILE########
__FILENAME__ = darwin

def einfo(db, line):
    db.vprint('EINFO')

def vdbExtension(vdb, trace):
    vdb.registerCmdExtension(einfo)
    

########NEW FILE########
__FILENAME__ = gdbstub

import vtrace
import vdb.extensions.windows as vdb_windows

def ethread(db, line):
    '''
    Display information about the currently stopped ethread.

    Usage: ethread
    #FIXME support listing them
    #FIXME support ethread interp arbitrary address
    '''
    t = db.getTrace()
    t.requireNotRunning()
    fsbase = t._getVmwareReg('fs')
    kpcr = t.getStruct('nt.KPCR', fsbase)
    ethraddr = kpcr.PrcbData.CurrentThread
    ethr = t.getStruct('nt.ETHREAD', ethraddr)
    db.vprint(ethr.tree(va=ethraddr))

def eprocess(db, line):
    '''
    Display information about the currently stopped eprocess.

    Usage: eprocess
    #FIXME support listing
    #FIXME support eprocess interp address
    '''
    t = db.getTrace()
    t.requireNotRunning()
    fsbase = t._getVmwareReg('fs')
    kpcr = t.getStruct('nt.KPCR', fsbase)
    ethraddr = kpcr.PrcbData.CurrentThread
    ethr = t.getStruct('nt.ETHREAD', ethraddr)
    eprocaddr = ethr.Tcb.ApcState.Process
    eproc = t.getStruct('nt.EPROCESS', eprocaddr)
    db.vprint(eproc.tree(va=eprocaddr))

def kpcr(db, line):
    '''
    Show the kpcr structure for the currently stopped kernel.

    Usage: kpcr
    '''
    t = db.getTrace()
    t.requireNotRunning()
    fsbase = t._getVmwareReg('fs')
    kpcr = t.getStruct('nt.KPCR', fsbase)
    db.vprint(kpcr.tree(va=fsbase))

# FIXME do we need to make gdbstub a package so it can have subs?

def armcore(db, line):
    '''
    Show / set the 'mode' of the arm core between arm and thumb.

    Usage: armcore [arm|thumb]
    '''
    t = db.getTrace()
    t.requireNotRunning()

    if line:
        if line not in ('arm','thumb'):
            return db.do_help('armcore')
        cmdstr = t._monitorCommand('arm core_state %s' % line)
    else:
        cmdstr = t._monitorCommand('arm core_state')

    mode = cmdstr.split(':')[1].strip()
    db.vprint('Arm Core Mode: %s' % mode)

class GdbStubNotifier(vtrace.Notifier):

    def __init__(self, db):
        vtrace.Notifier.__init__(self)
        self._db = db

    def notify(self, event, trace):
        if event != vtrace.NOTIFY_ATTACH:
            return

        targarch = trace.getMeta('Architecture')
        gdbplatform = trace.getMeta('GdbPlatform')
        targplatform = trace.getMeta('GdbTargetPlatform')

        #print 'Target Architecture: %s' % targarch
        #print 'Gdb Platform: %s' % gdbplatform
        #print 'Target Platform: %s' % targplatform

        if gdbplatform == 'VMware32':

            if targplatform == 'Windows':
                self._db.registerCmdExtension(vdb_windows.aslr)
                self._db.registerCmdExtension(vdb_windows.pe)
                self._db.registerCmdExtension(ethread)
                self._db.registerCmdExtension(eprocess)

        elif gdbplatform == 'OpenOCD':

            # If we are openocd, lets add some commands for jtag etc..
            if targarch == 'arm':
                #import vdb.extensions.arm as vdb_arm
                self._db.registerCmdExtension(armcore)
                #self._db.registerCmdExtension(vdb_arm.thumb)

def gdbmon(db, line):
    '''
    Issue a gdb "monitor" command which allows access to the extensions
    inside the gdb stub.

    Example: gdbmon r fs

    (try: "gdbmon help" for info on supported commands in the target stub)
    '''
    if len(line) == 0:
        return db.do_help('gdbmon')
    t = db.getTrace()
    t.requireNotRunning()
    resp = t._monitorCommand(line)
    db.vprint('gdb> %s' % line)
    db.vprint(resp)

def vdbExtension(db, trace):
    notif = GdbStubNotifier(db)
    db.registerCmdExtension(gdbmon)
    db.registerNotifier(vtrace.NOTIFY_ATTACH, notif)


########NEW FILE########
__FILENAME__ = i386

import envi.archs.i386 as e_i386

def eflags(vdb, line):
    """
    Show the status of the eflags register bits.

    Usage: eflags
    """
    t = vdb.getTrace()
    ef = t.getRegisterByName("eflags")
    vdb.vprint("%16s: %s" % ("Carry", bool(ef & e_i386.EFLAGS_CF)))
    vdb.vprint("%16s: %s" % ("Parity", bool(ef & e_i386.EFLAGS_PF)))
    vdb.vprint("%16s: %s" % ("Adjust", bool(ef & e_i386.EFLAGS_AF)))
    vdb.vprint("%16s: %s" % ("Zero", bool(ef & e_i386.EFLAGS_ZF)))
    vdb.vprint("%16s: %s" % ("Sign", bool(ef & e_i386.EFLAGS_SF)))
    vdb.vprint("%16s: %s" % ("Trap", bool(ef & e_i386.EFLAGS_TF)))
    vdb.vprint("%16s: %s" % ("Interrupt", bool(ef & e_i386.EFLAGS_IF)))
    vdb.vprint("%16s: %s" % ("Direction", bool(ef & e_i386.EFLAGS_DF)))
    vdb.vprint("%16s: %s" % ("Overflow", bool(ef & e_i386.EFLAGS_OF)))

def vdbExtension(vdb, trace):
    vdb.config.set('Aliases','db','mem -F bytes')
    vdb.config.set('Aliases','dw','mem -F u_int_16')
    vdb.config.set('Aliases','dd','mem -F u_int_32')
    vdb.config.set('Aliases','dq','mem -F u_int_64')
    vdb.config.set('Aliases','dr','mem -F "Deref View"')
    vdb.config.set('Aliases','ds','mem -F "Symbols View"')
    vdb.registerCmdExtension(eflags)


########NEW FILE########
__FILENAME__ = i486

from vdb.extensions.i386 import *


########NEW FILE########
__FILENAME__ = i586

from vdb.extensions.i386 import *


########NEW FILE########
__FILENAME__ = i686

from vdb.extensions.i386 import *


########NEW FILE########
__FILENAME__ = windows
import os
import sys
import getopt

import vtrace
import vtrace.tools.win32heap as win32heap
import vtrace.tools.win32aslr as win32_aslr
import vtrace.tools.iathook as vt_iathook
import vtrace.tools.win32stealth as win32_stealth
import vtrace.util as v_util

import envi.memory as e_mem
import envi.cli as e_cli
import envi.bits as e_bits

import PE
import vstruct.defs.pe as vs_pe

def teb(vdb, line):
    """
    Print out the TEB for the current or specified thread.

    Usage: teb [threadid]
    """
    t = vdb.getTrace()
    threads = t.getThreads()
    tid = t.getMeta("ThreadId")
    if len(line):
        tid = t.parseExpression(line)
    taddr = threads.get(tid)
    if taddr == None:
        vdb.vprint("Invalid Thread ID: %d" % tid)
        return
    teb = t.getStruct("ntdll.TEB", taddr)
    vdb.vprint(teb.tree(va=taddr, reprmax=32))

def peb(vdb, line):
    """
    Print the PEB

    Usage: peb
    """
    t = vdb.getTrace()
    t.requireAttached()
    pebaddr = t.getMeta("PEB")
    peb = t.getStruct("ntdll.PEB", pebaddr)
    vdb.vprint(peb.tree(pebaddr, reprmax=32))

def regkeys(vdb, line):
    """
    Show all the registry keys the target process currently has open.

    Usage: regkeys
    """
    t = vdb.getTrace()
    t.requireAttached()
    vdb.vprint("\nOpen Registry Keys:\n")
    for fd,ftype,fname in t.getFds():
        if ftype == vtrace.FD_REGKEY:
            vdb.vprint("\t%s" % fname)
    vdb.vprint("")

def einfo(vdb, line):
    """
    Show all the current exception information.

    -P    Toggle the "PendingSignal" meta key which controls
          delivery (or handling) of the current exception.

    Usage: einfo [options]
    """
    argv = e_cli.splitargs(line)
    t = vdb.getTrace()

    try:
        opts,args = getopt.getopt(argv, 'P')
    except Exception, e:
        return vdb.do_help('einfo')

    for opt,optarg in opts:
        if opt == '-P':
            p = t.getMeta('PendingSignal')
            if p != None:
                t.setMeta('OrigSignal', p)
                t.setMeta('PendingSignal', None)
            else:
                newp = t.getMeta('OrigSignal', None)
                t.setMeta('PendingSignal', newp)

    exc = t.getMeta("Win32Event", None)
    if exc == None:
        vdb.vprint("No Exception Information Found")
    ecode = exc.get("ExceptionCode", 0)
    eaddr = exc.get("ExceptionAddress",0)
    chance = 2
    if exc.get("FirstChance", False):
        chance = 1

    einfo = exc.get("ExceptionInformation", [])
    #FIXME get extended infoz
    #FIXME unify with cli thing
    vdb.vprint("Win32 Exception 0x%.8x at 0x%.8x (%d chance)" % (ecode, eaddr, chance))
    vdb.vprint("Exception Information: %s" % " ".join([hex(i) for i in einfo]))
    dbool = True
    if t.getCurrentSignal() == None:
        dbool = False
    vdb.vprint('Deliver Exception: %s' % dbool)

def seh(vdb, line):
    """
    Walk and print the SEH chain for the current (or specified) thread.

    Usage: seh [threadid]
    """
    t = vdb.getTrace()
    if len(line) == 0:
        tid = t.getMeta("ThreadId")
    else:
        tid = int(line)
    tinfo = t.getThreads().get(tid, None)
    if tinfo == None:
        vdb.vprint("Unknown Thread Id: %d" % tid)
        return
    teb = t.getStruct("ntdll.TEB", tinfo)
    addr = long(teb.NtTib.ExceptionList)
    vdb.vprint("REG        HANDLER")
    while addr != 0xffffffff:
        #FIXME print out which frame these are in
        er = t.getStruct("ntdll.EXCEPTION_REGISTRATION_RECORD", addr)
        vdb.vprint("0x%.8x 0x%.8x" % (addr, er.Handler))
        addr = long(er.Next)

def safeseh(vdb, line):
    """
    Show the SafeSEH status of all the loaded DLLs or list the
    handlers for a particular dll by normalized name.

    Usage: safeseh [libname]
    """
    t = vdb.getTrace()
    libs = t.getMeta("LibraryBases")
    if len(line):
        base = libs.get(line)
        if base == None:
            vdb.vprint("Unknown library: %s" % line)
            return

        vdb.vprint("%s:" % line)

        try:
            p = PE.peFromMemoryObject(t, base)
        except Exception, e:
            vdb.vprint('Error: %s (0x%.8x) %s' % (line, base, e))
            return

        if p.IMAGE_LOAD_CONFIG != None:
            va = int(p.IMAGE_LOAD_CONFIG.SEHandlerTable)
            if va != 0:
                count = int(p.IMAGE_LOAD_CONFIG.SEHandlerCount)
                for h in t.readMemoryFormat(va, "<%dL" % count):
                    vdb.vprint("\t0x%.8x %s" % (base+h, vdb.reprPointer(base+h)))
                return
        vdb.vprint("None...")
            
    else:
        lnames = libs.keys()
        lnames.sort()
        for name in lnames:
            base = libs.get(name)
            try:
                p = PE.peFromMemoryObject(t, base)
            except Exception, e:
                vdb.vprint('Error: %s (0x%.8x) %s' % (name, base, e))
                continue

            enabled = False
            if p.IMAGE_LOAD_CONFIG != None:
                va = int(p.IMAGE_LOAD_CONFIG.SEHandlerTable)
                if va != 0:
                    enabled = True
                #print name
                #print p.IMAGE_LOAD_CONFIG
            vdb.vprint("%16s\t%s" % (name, enabled))

def validate_heaps(db):
    """
    A simple routine that works like the built in windows
    heap checkers to show where blocks and/or freelist
    is potentially dorked.
    """
    trace = db.getTrace()
    db.vprint("Validating:")
    for heap in win32heap.getHeaps(trace):
        db.vprint("%s: 0x%.8x" % ("heap".rjust(9), heap.address))

        try:
            f = heap.getFreeLists()
        except Exception, e:
            #import traceback
            #traceback.print_exc()
            db.vprint("%s: %s" % (e.__class__.__name__,e))

        for seg in heap.getSegments():
            db.vprint("%s: 0x%.8x" % ("segment".rjust(9),seg.address))
            try:
                blist = seg.getChunks()
                for i,chunk in enumerate(blist):
                    if i == 0:
                        continue
                    if heap._win7_heap:
                        continue
                    pchunk = blist[i-1]
                    if chunk.chunk.PreviousSize != pchunk.chunk.Size:
                        db.vprint('Corruption! (block at 0x%.8x (size: %d) block at 0x%.8x (prevsize: %d)' % 
                                  (pchunk.address, pchunk.chunk.Size, chunk.address, chunk.chunk.PreviousSize))
                        break

            except Exception, e:
                db.vprint("%s: %s" % (e.__class__.__name__,e))

def heaps(vdb, line):
    """
    Show Win32 Heap Information.

    Usage: heaps [-F <heapaddr>] [-C <address>] [-L <segmentaddr>]
    -F <heapaddr> print the freelist for the heap
    -C <address>  Find and print the heap chunk containing <address>
    -S <segmentaddr> Print the chunks for the given heap segment
    -L <heapaddr> Print the look aside list for the given heap
    -V Validate the heaps (check next/prev sizes and free list)
    -l <heapaddr> Leak detection (list probable leaked chunks)
    -U <heapaddr> Show un-commited ranges for the specified heap
    (no options lists heaps and segments)
    """
    t = vdb.getTrace()
    t.requireAttached()

    if t.getMeta('Architecture') == 'amd64':
        vdb.vprint("WARNING: not all 64bit heap stuff works quite right yet!")

    argv = e_cli.splitargs(line)
    freelist_heap = None
    chunkfind_addr = None
    chunklist_seg = None
    lookaside_heap = None
    leakfind_heap = None
    uncommit_heap = None
    try:
        opts,args = getopt.getopt(argv, "F:C:S:L:l:U:V")
    except Exception, e:
        return vdb.do_help('heaps')

    for opt,optarg in opts:
        if opt == "-F":
            freelist_heap = t.parseExpression(optarg)
        elif opt == "-C":
            chunkfind_addr = t.parseExpression(optarg)
        elif opt == "-L":
            lookaside_heap = t.parseExpression(optarg)
        elif opt == "-S":
            chunklist_seg = t.parseExpression(optarg)
        elif opt == "-V":
            return validate_heaps(vdb)
        elif opt == "-l":
            leakfind_heap = t.parseExpression(optarg)
        elif opt == '-U':
            uncommit_heap = t.parseExpression(optarg)

    if lookaside_heap != None:
        haddrs = [h.address for h in win32heap.getHeaps(t)]
        if lookaside_heap not in haddrs:
            vdb.vprint("0x%.8x is NOT a valid heap!" % lookaside_heap)
            return

        heap = win32heap.Win32Heap(t, lookaside_heap)
        vdb.vprint('[Index] [Chunks]')
        for i,l in enumerate(heap.getLookAsideLists()):
            vdb.vprint("[%d]" % i)
            for c in l:
                vdb.vprint("    %s" % (repr(c)))

    elif uncommit_heap != None:

        haddrs = [h.address for h in win32heap.getHeaps(t)]
        if uncommit_heap not in haddrs:
            vdb.vprint("0x%.8x is NOT a valid heap!" % uncommit_heap)
            return

        heap = win32heap.Win32Heap(t, uncommit_heap)
        ucrdict = heap.getUCRDict()
        addrs = ucrdict.keys()
        addrs.sort()
        if len(addrs) == 0:
            vdb.vprint('Heap 0x%.8x has 0 uncommited-ranges!' % uncommit_heap)
            return

        vdb.vprint('Uncommited ranges for heap: 0x%.8x' % uncommit_heap)
        for ucraddr in addrs:
            size = ucrdict.get(ucraddr)
            vdb.vprint('0x%.8x (%d)' % (ucraddr, size))

        return

    elif freelist_heap != None:
        haddrs = [h.address for h in win32heap.getHeaps(t)]
        if freelist_heap not in haddrs:
            vdb.vprint("0x%.8x is NOT a valid heap!" % freelist_heap)
            return

        heap = win32heap.Win32Heap(t, freelist_heap)
        for i,l in enumerate(heap.getFreeLists()):
            if len(l):
                vdb.vprint("Freelist Index: %d" % i)
                for c in l:
                    vdb.vprint("   %s" % repr(c))

    elif chunkfind_addr != None:
        heap,seg,chunk = win32heap.getHeapSegChunk(t, chunkfind_addr)
        vdb.vprint("Address  0x%.8x found in:" % (chunkfind_addr,))
        vdb.vprint("Heap:    0x%.8x" % (heap.address))
        vdb.vprint("Segment: 0x%.8x" % (seg.address))
        vdb.vprint("Chunk:   0x%.8x (%d) FLAGS: %s" % (chunk.address, len(chunk),chunk.reprFlags()))

    elif chunklist_seg != None:

        for heap in win32heap.getHeaps(t):
            for seg in heap.getSegments():
                if chunklist_seg == seg.address:
                    vdb.vprint("Chunks for segment at 0x%.8x (X == in use)" % chunklist_seg)
                    for chunk in seg.getChunks():
                        c = " "
                        if chunk.isBusy():
                            c = "X"
                        vdb.vprint("0x%.8x %s (%d)" % (chunk.address,c,len(chunk)))
                    return

        vdb.vprint("Segment 0x%.8x not found!" % chunklist_seg)

    elif leakfind_heap != None:
        # FIXME do this the slow way for now...
        haddrs = [h.address for h in win32heap.getHeaps(t)]
        if leakfind_heap not in haddrs:
            vdb.vprint("0x%.8x is NOT a valid heap!" % leakfind_heap)
            return

        h = win32heap.Win32Heap(t, leakfind_heap)
        for seg in h.getSegments():
            for chunk in seg.getChunks():
                if chunk.address == seg.address:
                    continue
                # Obviously, only check for leaks if they are in use...
                # FIXME we will need to check the lookaside also...
                if not chunk.isBusy():
                    continue
                addr = chunk.getDataAddress()
                # FIXME get size and endian from trace
                pat = e_bits.buildbytes(addr, 4)
                l = t.searchMemory(pat)
                if len(l) == 0:
                    vdb.vprint("0x%.8x may be leaked!" % addr)

    else:
        vdb.vprint("Heap\t\tSegment")
        for heap in win32heap.getHeaps(t):
            flags = " ".join(heap.getFlagNames())
            for s in heap.getSegments():
                vdb.vprint("0x%.8x\t0x%.8x\t%s" % (heap.address, s.address, flags))

IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 0x0040

def showaslr(vdb, base, libname):
    t = vdb.getTrace()
    try:
        p = PE.peFromMemoryObject(t, base)
    except Exception, e:
        vdb.vprint('Error: %s (0x%.8x) %s' % (name, base, e))
        return
    enabled = False
    c = p.IMAGE_NT_HEADERS.OptionalHeader.DllCharacteristics
    if c & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE:
        enabled = True
    vdb.vprint("%16s\t%s" % (libname, enabled))

def aslr(vdb, line):
    """
    Determine which PE's in the current process address space
    support Vista's ASLR implementation by the presence of the
    IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE (0x0040) bit in the 
    DllCharacteristics field of the PE header.

    Usage: aslr [libname]
    """
    t = vdb.getTrace()
    libs = t.getMeta("LibraryBases")
    if line:
        base = libs.get(line)
        if base == None:
            vdb.vprint("Unknown library: %s" % line)
            return
        showaslr(vdb, base, line)
    else:
        lnames = libs.keys()
        lnames.sort()
        for name in lnames:
            base = libs.get(name)
            showaslr(vdb, base, name)

def _printPageHits(vdb, hits, unique=False):
    vdb.vprint('[  eip  ]  [ mem addr ] [ access ]')
    if unique:
        newhits = []
        [newhits.append(h) for h in hits if not newhits.count(h)]
        hits = newhits

    for eip,addr,perm in hits:
        vdb.vprint("0x%.8x 0x%.8x   %s" % (eip,addr,e_mem.getPermName(perm)))

def pagewatch(vdb, line):
    """
    Enable write access watching on a given memory page.  This works
    by setting the page to read-only and then specially handling the
    access violations as though they were hardware Watchpoints.

    Usage: pagewatch [options] [<addr_expression>]
    -C - Clear the current pagewatch log
    -F - Toggle auto-continue behavior (run and record vs. stop on hit)
    -L - List the current hits from the pagewatch log
    -M - Add page watches to the entire memory map from addr_expression
    -R - Use to enable *read* watching while adding a page watch
    -S <addr> - Show touches to the specified address
    -P <addr> - Show memory touched by specifed program counter (eip)
    -u - When listing, show only *unique* entries
    """
    argv = e_cli.splitargs(line)
    try:
        opts,args = getopt.getopt(argv, "CFLMP:RS:u")
    except Exception, e:
        return vdb.do_help('pagewatch')

    if vdb.trace.getMeta('pagewatch') == None:
        vdb.trace.setMeta('pagewatch', [])

    if vdb.trace.getMeta('pagerun') == None:
        vdb.trace.setMeta('pagerun', False)

    domap = False
    unique = False
    watchread = False
    for opt,optarg in opts:

        if opt == "-C":
            vdb.trace.setMeta("pagewatch", [])
            vdb.vprint("Pagewatch log cleared")
            return

        elif opt == '-F':
            pr = vdb.trace.getMeta('pagerun', False)
            pr = not pr
            vdb.trace.setMeta('pagerun', pr)
            vdb.vprint('Pagewatch Auto Continue: %s' % pr)
            return

        elif opt == "-L":
            hits = vdb.trace.getMeta('pagewatch', [])
            _printPageHits(vdb, hits, unique=unique)
            return

        elif opt == "-M":
            domap = True

        elif opt == '-R':
            watchread = True

        elif opt == "-S":
            saddr = vdb.trace.parseExpression(optarg)
            hits = vdb.trace.getMeta("pagewatch")
            if hits == None:
                vdb.vprint("No pagewatch log!")
                return
            hits = [ h for h in hits if h[1] == saddr ]
            _printPageHits(vdb, hits, unique=unique)
            return

        elif opt == "-P":
            saddr = vdb.trace.parseExpression(optarg)
            hits = vdb.trace.getMeta("pagewatch")
            if hits == None:
                vdb.vprint("No pagewatch log!")
                return

            hits = [ h for h in hits if h[0] == saddr ]
            _printPageHits(vdb, hits, unique=unique)
            return

        elif opt == '-u':
            unique = True

    if len(args) == 0:
        return vdb.do_help('pagewatch')

    baseaddr = vdb.trace.parseExpression(args[0])
    # Page align
    baseaddr = baseaddr & 0xfffff000
    maxaddr = baseaddr + 4096

    map = vdb.trace.getMemoryMap(baseaddr)
    if map == None:
        raise Exception("Invalid memory map address 0x%.8x" % baseaddr)

    if domap:
        baseaddr = map[0]
        maxaddr  = baseaddr + map[1]

    bpset = vdb.trace.breakpoints
    while baseaddr < maxaddr:
        # Skip ones that are already there!
        if not bpset.get(baseaddr):
            wp = vtrace.PageWatchpoint(baseaddr, size=4096, watchread=watchread)
            wpid = vdb.trace.addBreakpoint(wp)
        baseaddr += 4096

def stealth(vdb, line):
    """
    Enable basic debugger stealth.  This has the following effects:

    Change PEB to show BeingDebugged == 0
    Special breakpoint on CheckRemoteDebuggerPresent

    WARNING:
    break/sendBreak() behave VERY strange with this because the
    kernel aparently doesn't think he needs to post the exception
    to the debugger?
    """
    if vdb.trace.getMeta("Win32Stealth") != None:
        win32_stealth.unstealthify(vdb.trace)
        vdb.vprint("Stealth disabled")
    else:
        win32_stealth.stealthify(vdb.trace)
        vdb.vprint("Stealth enabled")


gflag_stuff = [
    ('loader_snaps', 'ntdll.ShowSnaps', '<B', 0, 1),
    ('loader_debug', 'ntdll.LdrpDebugFlags', '<I', 0, 0xffffffff),
]

def gflags(vdb, line):
    '''
    Support a subset of gflags like behavior on windows.  This enables
    features *exclusively* by direct process manipulation and does NOT
    set any registry settings or persist across processes...

    Usage: gflags [toggle_type]

    NOTE: Most of these options require symbols!
    '''
    argv = e_cli.splitargs(line)

    optnames = [ x[0] for x in gflag_stuff ]

    for opt in argv:

        if opt not in optnames:
            vdb.vprint('Unknown/Unsupported Option: %s' % opt)
            continue

        for hname, symname, fmt, offval, onval in gflag_stuff:
            if opt == hname:
                try:
                    addr = vdb.trace.parseExpression(symname)
                    cur = vdb.trace.readMemoryFormat(addr, fmt)[0]
                    if cur == offval:
                        newval = onval
                    else:
                        newval = offval
                    vdb.trace.writeMemoryFormat(addr, fmt, newval)
                except Exception, e:
                    vdb.vprint('Symbol Failure: %s' % symname)
                break

    for hname, symname, fmt, offval, onval in gflag_stuff:
        status = 'Unknown'
        try:
            addr = vdb.trace.parseExpression(symname)
            val = vdb.trace.readMemoryFormat(addr, fmt)[0]
            if val == offval:
                status = 'Off'
            elif val == onval:
                status = 'On'
        except Exception, e:
            pass
        vdb.vprint('%s : %s' % (hname.rjust(20), status))


def pe(vdb, line):
    """
    Show extended info about loaded PE binaries.

    Usage: pe [opts] [<libname>...]
    -I      Show PE import files.
    -m      Toggle inmem/ondisk behavior (directly mapped DLLs)
    -N      Show full NT header
    -t      Show PE timestamp information
    -E      Show PE exports
    -S      Show PE sections
    -v      Show FileVersion from VS_VERSIONINFO
    -V      Show all keys from VS_VERSIONINFO

    NOTE: "libname" may be a vtrace expression:

    Examples:

        # Show the imports from a PE loaded at 0x777c0000
        pe -I 0x777c0000

        # Show the exports from advapi32.dll
        pe -E advapi32

        # Show the build timestamp of the PE pointed to by a register
        pe -t esi+10

    """
    #-v      Show PE version information
    argv = e_cli.splitargs(line)
    try:
        opts,args = getopt.getopt(argv, "EImNStvV")
    except Exception, e:
        return vdb.do_help('pe')

    inmem = True

    showsecs = False
    showvers = False
    showtime = False
    showimps = False
    shownthd = False
    showexps = False
    showvsin = False
    for opt,optarg in opts:
        if opt == '-I':
            showimps = True
        elif opt == '-t':
            showtime = True
        elif opt == '-v':
            showvers = True
        elif opt == '-V':
            showvsin = True
        elif opt == '-N':
            shownthd = True
        elif opt == '-m':
            inmem = False
        elif opt == '-S':
            showsecs = True
        elif opt == '-E':
            showexps = True

    t = vdb.trace
    bases = t.getMeta("LibraryBases")
    paths = t.getMeta("LibraryPaths")

    names = args
    if len(names) == 0:
        names = t.getNormalizedLibNames()

    names.sort()
    names = e_cli.columnstr(names)
    for libname in names:
        base = bases.get(libname.strip(), None)
        if base == None:
            base = vdb.trace.parseExpression(libname)
        path = paths.get(base, "unknown")

        try:
            pobj = PE.peFromMemoryObject(t, base)
        except Exception, e:
            vdb.vprint('Error: %s (0x%.8x) %s' % (libname, base, e))
            continue

        if showimps:
            ldeps = {}
            try:
                for rva,lname,fname in pobj.getImports():
                    ldeps[lname.lower()] = True
                lnames = ldeps.keys()
                lnames.sort()
                vdb.vprint('0x%.8x - %.30s %s' % (base, libname, ' '.join(lnames)))
            except Exception, e:
                vdb.vprint('Import Parser Error On %s: %s' % (libname, e))

        elif showvers:
            version = 'Unknown!'
            vs = pobj.getVS_VERSIONINFO()
            if vs != None:
                version = vs.getVersionValue('FileVersion')
            vdb.vprint('%s: %s' % (libname.rjust(30),version))

        elif showvsin:
            vs = pobj.getVS_VERSIONINFO()
            vdb.vprint('==== %s' % libname)
            if vs == None:
                vdb.vprint('no VS_VERSIONINFO...')
            else:
                vskeys = vs.getVersionKeys()
                vskeys.sort()
                for vskey in vskeys:
                    vsval = vs.getVersionValue(vskey)
                    vdb.vprint('%s: %s' % (vskey.rjust(20), vsval[:50]))

        elif showtime:
            tstamp = pobj.IMAGE_NT_HEADERS.FileHeader.TimeDateStamp
            vdb.vprint('0x%.8x - %.30s 0x%.8x' % (base, libname, tstamp))

        elif shownthd:
            t = pobj.IMAGE_NT_HEADERS.tree(reprmax=32)
            vdb.vprint(t)

        elif showsecs:
            for sec in pobj.getSections():
                vdb.vprint(sec.tree(reprmax=32))

        elif showexps:
            vdb.vprint('[Ord] [Address] [Name]')
            for fva, ord, name in pobj.getExports():
                vdb.vprint('%.4d 0x%.8x %s' % (ord, fva, name))
        else:
            vdb.vprint('0x%.8x - %.30s %s' % (base, libname, path))

def bindiff(mem1, mem2):
    ret = []
    i = 0
    imax = len(mem1)
    while i < imax:
        r = i
        while mem1[r] != mem2[r] and r < imax:
            r += 1
        # We found a discrepency
        if r != i:
            size = (r-i)
            ret.append((i,size))
            i+=r
        i+=1
    return ret

def deaslr(vdb, line):
    '''
    Rebase the specified address expression as though the origin
    library had gotten it's suggested base address rather than
    being ASLR'd.

    Usage: deaslr <addr_expr>
    '''
    if len(line) == 0:
        return vdb.do_help('deaslr')

    addr = vdb.trace.parseExpression(line)
    newaddr = win32_aslr.deAslr(vdb.trace, addr)

    vdb.vprint('aslr: 0x%.8x deaslr: 0x%.8x' % (addr, newaddr))

def sympath(vdb, line):
    '''
    Set the symbol path for the tracer.  This will currently only
    effect *subsequent* library loads!

    Usage: sympath <new_path>
    '''
    if len(line):
        vdb.trace.setMeta('NtSymbolPath', line)
    sympath = vdb.trace.getMeta('NtSymbolPath')
    if sympath == None:
        sympath = os.getenv('_NT_SYMBOL_PATH')
    vdb.vprint('Current Symbol Path: %s' % sympath)

def stepb(vdb, line):
    '''
    Use the extended intel hardware support to step to the next branch
    target.

    Usage: stepb
    
    NOTE: This will *not* work inside VMware / VirtualBox.  Other hypervisors
          may vary... (it will simply single step)
    '''
    if len(line):
        vdb.do_help('stepb')

    orig = vdb.trace.getMode('BranchStep')
    vdb.trace.setMode('BranchStep', True)
    # For now, lets cheat so we get FastStep behavior for free...
    vdb.do_stepi('')
    vdb.trace.setMode('BranchStep', orig)

def hooks(vdb, line):
    '''
    Check the executable regions of the target process for any
    hooks by comparing against the PE on disk.  This will
    account for relocations and import entries.
    '''
    t = vdb.getTrace()
    bases = t.getMeta("LibraryBases")
    paths = t.getMeta("LibraryPaths")
    found = False
    for bname in bases.keys():
        base = bases.get(bname)
        fpath = paths.get(base)
        pobj = PE.PE(file(fpath,'rb'))
        filebase = pobj.IMAGE_NT_HEADERS.OptionalHeader.ImageBase

        skips = {}
        # Get relocations for skipping
        r = (0,1,2,3)
        for relrva, reltype in pobj.getRelocations():
            for i in r:
                skips[base+relrva+i] = True
        # Add the import entries to skip
        for iva,libname,name in pobj.getImports():
            for i in r:
                skips[base+iva+i] = True

        for sec in pobj.getSections():
            if sec.Characteristics & PE.IMAGE_SCN_MEM_EXECUTE:
                size = sec.VirtualSize
                va = base + sec.VirtualAddress
                fileva = filebase + sec.VirtualAddress
                filebytes = pobj.readAtRva(sec.VirtualAddress, sec.VirtualSize)
                procbytes = t.readMemory(va, size)
                for off,size in bindiff(filebytes, procbytes):
                    difva = va + off
                    fdifva = fileva + off
                    # Check for a relocation covering this...
                    if skips.get(difva):
                        continue
                    found = True
                    dmem = procbytes[off:off+size].encode('hex')[:10]
                    dfil = filebytes[off:off+size].encode('hex')[:10]

                    vdb.canvas.addVaText('0x%.8x' % difva, difva)
                    vdb.canvas.addText(' (0x%.8x) (%d)' % (fdifva,size))
                    vdb.canvas.addText(' mem: %s file: %s ' % (dmem, dfil))

                    sym = vdb.symobj.getSymByAddr(difva, exact=False)
                    if sym != None:
                        vdb.canvas.addText(' ')
                        vdb.canvas.addVaText('%s + %d' % (repr(sym),difva-long(sym)), difva)
                    vdb.canvas.addText('\n')

    if not found: vdb.canvas.addText('No Hooks Found!\n')

def jit(vdb, line):
    '''
    Enable/Disable the current VDB location as the current Just-In-Time
    debugger for windows applications.

    Usage: jitenable [-D]
    -E  Enable VDB JIT debugging
    -D  Disable JIT debugging
    '''
    argv = e_cli.splitargs(line)
    try:
        opts,args = getopt.getopt(argv, "ED")
    except Exception, e:
        return vdb.do_help('jit')

    try:
        import _winreg
    except Exception, e:
        vdb.vprint('Error Importing _winreg: %s' % e)
        return

    HKLM = _winreg.HKEY_LOCAL_MACHINE
    HKCU = _winreg.HKEY_CURRENT_USER
    REG_SZ = _winreg.REG_SZ

    regpath = r'SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug'
    #wow64path = r'SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug'

    #regkey = _winreg.CreateKey(HKLM, regpath)
    regkey = _winreg.CreateKey(HKLM, regpath)

    vdb.vprint('JIT Currently: %s' % _winreg.QueryValueEx(regkey, 'Debugger')[0])

    setval = None
    for opt,optarg in opts:

        if opt == '-D':
            setval = ''

        elif opt == '-E':
            vdbpath = os.path.abspath(sys.argv[0])
            setval = '%s %s -r -p %%ld -e %%Id' % (sys.executable, vdbpath)
            #_winreg.SetValue(HKLM

    if setval != None:
        vdb.vprint('Setting JIT: %s' % (setval,))
        _winreg.SetValueEx(regkey, 'Debugger', None, REG_SZ, setval)

def svclist(vdb, line):
    '''
    List the running service names and pids.

    Usage: svclist
    '''
    cols = []
    pids = []
    names = []
    descrs = []
    for pid, name, descr in vdb.trace._getSvcList():
        pids.append('%d' %  pid)
        names.append(name)
        descrs.append(descr)

    names = e_cli.columnstr(names)

    for i in xrange(len(pids)):
        vdb.vprint('%8s %s %s' % (pids[i], names[i], descrs[i]))

def injectso(vdb, line):
    '''
    Inject a shared object (DLL) into the target process.

    Usage: injectso <dllname>
    '''
    if not line:
        return vdb.do_help('injectso')
    t = vdb.trace
    t.injectso(line)

token_elevation_types = {
    0: 'UAC Not Present',
    1: 'Default Elevation',
    2: 'Elevated',
    3: 'Low',
}
def uac(db, line):
    '''
    Display the current UAC status of the target process.
    (User Account Control)

    Usage: uac
    '''
    t = db.trace
    u = t._getUacStatus()
    db.vprint('UAC Status: %s' % token_elevation_types.get(u))

def hookiat(db, line):
    '''
    Hook the specified IAT entries by munging a pointer and emulating
    "breakpoint" like behavior on the resultant memory access errors.  Basically,
    break on import call...

    Usage: hookiat <libname> [ <implibname> [ <impfuncname> ] ]

    Example:
        hookiat calc
        hookiat calc kernel32
        hookiat calc kernel32 LoadLibraryA

    NOTE: Once added, you may use "bp" and commands like "bpedit" to modify,
    remove, or add code to "iat hooks"
    '''
    argv = e_cli.splitargs(line)
    arglen = len(argv)
    if arglen < 1:
        return db.do_help('hookiat')
    if arglen > 3:
        return db.do_help('hookiat')

    db.vprint('Adding IAT Hooks (use bp/bpedit cmds to review/modify...)')
    hooks = vt_iathook.hookIat(db.trace, *argv)
    if len(hooks):
        db.vprint('[ bpid ] [ IAT Name ]')
    for iatname, bpid in hooks:
        db.vprint('[%6d] %s' % (bpid, iatname))
    db.vprint('Added %d hooks.' % len(hooks))

# The necissary module extension function
def vdbExtension(db, trace):
    db.registerCmdExtension(hookiat)
    db.registerCmdExtension(pe)
    db.registerCmdExtension(peb)
    db.registerCmdExtension(einfo)
    db.registerCmdExtension(heaps)
    db.registerCmdExtension(regkeys)
    db.registerCmdExtension(seh)
    db.registerCmdExtension(safeseh)
    db.registerCmdExtension(teb)
    db.registerCmdExtension(pagewatch)
    db.registerCmdExtension(stealth)
    db.registerCmdExtension(aslr)
    db.registerCmdExtension(hooks)
    db.registerCmdExtension(gflags)
    #db.registerCmdExtension(deaslr)
    db.registerCmdExtension(sympath)
    db.registerCmdExtension(jit)
    db.registerCmdExtension(svclist)
    #db.registerCmdExtension(stepb)
    db.registerCmdExtension(injectso)
    db.registerCmdExtension(uac)

########NEW FILE########
__FILENAME__ = windows

import os
import vwidget
import vwidget.windows as vw_windows
import vwidget.util as vw_util
import vtrace.tools.win32heap as win32heap

import vdb
import vdb.gui

import envi.memcanvas as e_canvas
import vwidget.memview as vw_memview

import gtk
import pango

busy_color = (0xff, 0, 0)
def_color  = (0, 0xff, 0)

class VdbHeapRenderer(e_canvas.MemoryRenderer):
    """
    A renderer which knows how to show heap chunks
    (only to be used on aligned addresses, our parent window
    takes care of that)
    """
    def __init__(self, trace):
        self.trace = trace

    def getPad(self, buf, size):
        return " " * (size-len(buf))

    def isAscii(self, buf):
        for b in buf:
            v = ord(b)
            if v == 0:
                continue
            if v < 0x20 or v >= 0x7f:
                return False
        return True

    def render(self, canvas, va):
        chunk = win32heap.Win32Chunk(self.trace, va)
        size = len(chunk)
        canvas.addVaText("0x%.8x" % va, va=va)
        canvas.addText(": ")
        sizestr = str(len(chunk))
        sizepad = self.getPad(sizestr, 7)
        canvas.addText("CHUNK:%s" % sizepad)
        canvas.addNameText(sizestr, name="chunk:%d" % size)
        canvas.addText(" %s" % chunk.reprFlags())
        canvas.addText("\n")

        dva = chunk.getDataAddress()
        dsize = chunk.getDataSize()
        #r = min(32, dsize)
        canvas.addVaText("0x%.8x" % dva, va=dva)
        dsizestr = str(dsize)
        dsizepad = self.getPad(dsizestr, 7)
        canvas.addText(": %s" % dsizepad)
        canvas.addNameText(dsizestr, name="data:%d" % dsize)
        canvas.addText(": ")

        bytes = self.trace.readMemory(dva, dsize)

        if not chunk.isBusy():
            flink, blink = self.trace.readMemoryFormat(dva, "PP")
            canvas.addText("FLINK: ")
            canvas.addVaText("0x%.8x" % flink, va=flink)
            canvas.addText(" BLINK: ")
            canvas.addVaText("0x%.8x" % blink, va=blink)
            canvas.addText(" leftovers: %s" % bytes[8:8+32].encode('hex'))

        else:
            if self.isAscii(bytes):
                canvas.addText(bytes[:128].replace("\x00",""))
            else:
                canvas.addText("%s" % bytes[:32].encode('hex'))

        canvas.addText("\n")

        return size

class VdbHeapView(vw_memview.MemoryView):

    def render(self, va, size, rend=None):
        trace = self.mem
        heap, seg, chunk = win32heap.getHeapSegChunk(trace, va)
        va = seg.address

        # FIXME if is valid
        last = seg.getLastChunk()
        size = (last.address+len(last))-va

        vw_memview.MemoryView.render(self, va, size, rend=rend)


class VdbHeapWindow(vw_memview.MemoryWindow):
    def __init__(self, db, gui):
        self.db = db
        self.gui = gui
        self.trace = vdb.VdbTrace(db)

        canvas = VdbHeapView(self.trace, syms=self.trace)
        canvas.addRenderer("Windows Heap", VdbHeapRenderer(self.trace))
        vw_memview.MemoryWindow.__init__(self, canvas)

    # These are straight stolen from vdb gui
    def setTraceWindowActive(self, active=True):
        if active:
            self.vbox.set_sensitive(True)
            self.updateMemoryView()
        else:
            self.vbox.set_sensitive(False)

    def updateMemoryView(self, *args):

        trace = self.db.getTrace()
        if (not trace.isAttached()) or trace.isRunning():
            return

        return vw_memview.MemoryWindow.updateMemoryView(self, *args)

class Win32HeapWindow(vw_windows.VWindow):
    def __init__(self, db):
        vw_windows.VWindow.__init__(self, os.path.join(vdb.basepath,"glade","Win32Heap.glade"), None)
        self.vdb = db
        self.font = pango.FontDescription("Monospace 10")
        self.setupHeapTree()
        self.setupChunkList()
        self.spaceview = vwidget.SpaceView([], dwidth=40)
        hb = self.getWidget("hbox1")
        hb.pack_start(self.spaceview, expand=False)
        self.spaceview.show()
        hb.resize_children()

    def chunkListActivated(self, tree, path, column):
        model = tree.get_model()
        iter = model.get_iter(path)
        chunk = model.get_value(iter, 0)
        vdb.gui.MemoryWindow(self.vdb, "0x%.8x" % chunk.address, len_expr=str(len(chunk)))

    def heapTreeActivated(self, tree, path, column):
        model = tree.get_model()
        iter = model.get_iter(path)
        o = model.get_value(iter, 0)
        if isinstance(o, win32heap.Win32Heap):
            if tree.row_expanded(path):
                tree.collapse_row(path)
            else:
                tree.expand_row(path, False)
        elif isinstance(o, win32heap.Win32Segment):
            self.updateChunkList(o)

    def updateWindow(self, trace):
        self.updateHeapTree()

    def setupChunkList(self):
        tree = self.getWidget("Win32ChunkList")
        tree.modify_font(self.font)
        col1 = vw_util.makeColumn("Chunkaddr", 1)
        col2 = vw_util.makeColumn("Size", 2)
        col3 = vw_util.makeColumn("Busy", 3) # FIXME make a picture?
        col4 = vw_util.makeColumn("Bytes", 4)
        tree.append_column(col1)
        tree.append_column(col2)
        tree.append_column(col3)
        tree.append_column(col4)
        store =  gtk.ListStore(object,str,str,str,str)
        tree.set_model(store)

    def updateChunkList(self, seg):
        """
        Because this is already parsing chunks, we'll have this update
        the segment view as well.
        """
        tree = self.getWidget("Win32ChunkList")
        model = tree.get_model()
        model.clear()

        spaces = []
        for c in seg.getChunks():

            if c.isBusy():
                color = busy_color
                bstr = "X"
            else:
                color = def_color
                bstr = ""

            bytes = c.getDataBytes(maxsize=10)
            r = ""
            for b in bytes:
                ob = ord(b)
                if ob >= 0x20 and ob < 0x7f:
                    r += b
                else:
                    r += "."

            spaces.append((c.address, len(c), color, r))
            model.append((c, "0x%.8x" % c.address, len(c), bstr, r))

        self.spaceview.updateSpaces(spaces)

    def setupHeapTree(self):
        tree = self.getWidget("Win32HeapTree")
        tree.modify_font(self.font)
        col1 = vw_util.makeColumn("Heap", 1)
        col2 = vw_util.makeColumn("Segment", 2)
        tree.append_column(col1)
        tree.append_column(col2)
        store =  gtk.TreeStore(object,str,str)
        tree.set_model(store)
        self.updateHeapTree(tree)

    def updateHeapTree(self, tree=None):
        if tree == None:
            tree = self.getWidget("Win32HeapTree")
        t = self.vdb.getTrace()
        model = tree.get_model()
        model.clear()
        if not t.isAttached():
            return

        # Populate the heap list
        for h in win32heap.getHeaps(t):
            #i = model.append(None, (h,"0x%.8x" % h.address,"0x%.8x" % int(h.heap.Flags),""))
            for s in h.getSegments():
                i = model.append(None, (s, "0x%.8x" % h.address,"0x%.8x" % s.address))
                model.append(i, (None, repr(h.heap), repr(s.seg)))

def heapview(db, line):
    """
    Open a Win32 Heap View window.

    Usage: heapview
    """
    Win32HeapWindow(db)

def vdbGuiExtension(db, gui):
    db.registerCmdExtension(heapview)
    gui.addExtensionWindow("Windows Heap", VdbHeapWindow)


########NEW FILE########
__FILENAME__ = dopestack
'''
A quick set of tools for doing stack doping.
'''
import vtrace

def dopeThreadStack(trace, threadid):
    curthread = trace.getCurrentThread()
    try:
        trace.selectThread(threadid)
        sp = trace.getStackCounter()
        map = trace.getMemoryMap(sp)
        if map == None:
            raise Exception('Thread %d has invalid stack pointer 0x%.8x' % (threadid, sp))

        mapva, mapsize, mperms, mfname = map

        dopesize = sp - mapva
        trace.writeMemory(mapva, 'V' * dopesize)

    except Exception, e:
        print 'dopeThreadStack Failed On %d' % threadid
        trace.selectThread(curthread)

def dopeAllThreadStacks(trace):
    '''
    Apply stack doping to all thread stacks.
    '''
    for threadid in trace.getThreads().keys():
        dopeThreadStack(trace, threadid)

class ThreadDopeNotifier(vtrace.Notifier):

    def notify(self, event, trace):
        dopeAllThreadStacks(trace)

dopenotif = ThreadDopeNotifier()

def enableEventDoping(trace):
    trace.registerNotifier(vtrace.NOTIFY_CONTINUE, dopenotif)

def disableEventDoping(trace):
    trace.deregisterNotifier(vtrace.NOTIFY_CONTINUE, dopenotif)


########NEW FILE########
__FILENAME__ = sniper
'''
Specialized breakpoints which identify dangerous calling
mechanisms and tag them.
'''
import envi.memory as e_mem
import vtrace.breakpoints as vt_breakpoints

def getStackArg(trace, argidx):
    '''
    Assuming we are at the instruction after
    a call, grab the stack argument at the specified
    index (skipping the saved instruction pointer).
    '''
    stack = trace.getStackCounter()
    fmt = '<P' + ('P' * (argidx+1))
    args = trace.readMemoryFormat(stack, fmt)
    return args[-1]

class SniperDynArgBreak(vt_breakpoints.Breakpoint):
    '''
    A breakpoint for use in determining if an API was called
    with a dynamic pointer.
    '''

    def __init__(self, symname, argidx):
        vt_breakpoints.Breakpoint.__init__(self, None, expression=symname)
        self.fastbreak = True
        self._argidx = argidx
        self._symname = symname

    def getName(self):
        return '%s argidx: %d' % (self._symname, self._argidx)

    def notify(self, event, trace):
        arg = getStackArg(trace, self._argidx)
        self.fastbreak = True
        if trace.probeMemory(arg, 1, e_mem.MM_WRITE):
            print 'SNIPER: %s TOOK DYNAMIC ARG IDX %d (0x%.8x)' % (self._symname, self._argidx, arg)
            self.fastbreak = False

class SniperArgValueBreak(vt_breakpoints.Breakpoint):
    '''
    A breakpoint for monitoring an API for being called with a particular
    value.
    '''
    def __init__(self, symname, argidx, argval):
        pass

def snipeDynArg(trace, symname, argidx):
    '''
    Construct a SnyperDynArgBreak and snap it in.
    '''
    bp = SniperDynArgBreak(symname, argidx)
    bpid = trace.addBreakpoint(bp)
    return bpid


########NEW FILE########
__FILENAME__ = renderers
"""
A home for the vdb specific memory renderers.
"""

import envi
import envi.bits as e_bits
import envi.memory as e_mem
import envi.memcanvas as e_canvas

class OpcodeRenderer(e_canvas.MemoryRenderer):

    def __init__(self, trace):
        a = trace.getMeta("Architecture")
        self.arch = envi.getArchModule(a)
        self.pwidth = self.arch.getPointerSize()

    def render(self, mcanv, va):
        vastr = self.arch.pointerString(va)
        # NOTE: we assume the memobj is a trace
        trace = mcanv.mem
        sym = trace.getSymByAddr(va)
        if sym != None:
            mcanv.addVaText(str(sym), va=va)
            mcanv.addText(":\n")
        p = trace.readMemory(va, 16)
        op = self.arch.makeOpcode(p, va=va)
        obytes = p[:min(op.size, 8)]

        mcanv.addVaText(vastr, va=va)
        mcanv.addText(": %s " % obytes.encode('hex').ljust(17))
        op.render(mcanv)
        mcanv.addText("\n")
        return len(op)

class SymbolRenderer(e_canvas.MemoryRenderer):
    def __init__(self, trace):
        a = trace.getMeta("Architecture")
        self.arch = envi.getArchModule(a)
        self.pwidth = self.arch.getPointerSize()

    def render(self, mcanv, va):
        # This is only used with tracer based stuff...
        trace = mcanv.mem
        vastr = self.arch.pointerString(va)
        # NOTE: we assume the memobj is a trace
        trace = mcanv.mem
        p = trace.readMemoryFormat(va, 'P')[0]

        isptr = trace.isValidPointer(p)

        pstr = self.arch.pointerString(p)

        mcanv.addVaText(vastr, va=va)
        mcanv.addText(": ")
        if isptr:
            mcanv.addVaText(pstr, p)
        else:
            mcanv.addText(pstr)

        if isptr:
            sym = trace.getSymByAddr(p, exact=False)
            if sym != None:
                mcanv.addText(' %s + %d' % (repr(sym), p-long(sym)))
        mcanv.addText('\n')

        return self.pwidth

class DerefRenderer(e_canvas.MemoryRenderer):
    def __init__(self, trace):
        a = trace.getMeta("Architecture")
        self.arch = envi.getArchModule(a)
        self.pwidth = self.arch.getPointerSize()

    def render(self, mcanv, va):
        vastr = self.arch.pointerString(va)
        # NOTE: we assume the memobj is a trace
        trace = mcanv.mem
        p = trace.readMemoryFormat(va, 'P')[0]

        isptr = trace.isValidPointer(p)

        pstr = self.arch.pointerString(p)

        vareg = ""
        preg = ""

        regs = trace.getRegisters()
        for name,val in regs.items():
            if val == 0:
                continue
            if val == va:
                vareg = "(%s)" % name
            if val == p:
                preg = "(%s)" % name

        bt = trace.getStackTrace()
        if len(bt) > 1:
            for i in range(1, len(bt)):
                spc, sfc = bt[i]
                if sfc == 0:
                    break
                if spc == 0:
                    break
                if va == spc:
                    vareg = "(savepc)"
                if va == sfc:
                    vareg = "(frame%d)" % i
                if p == spc:
                    preg = "(savepc)"
                if p == sfc:
                    preg = "(frame%d)" % i

        vareg = vareg.ljust(8)
        preg = preg.ljust(8)

        #sym = trace.getSymByAddr(va)
        #if sym != None:
            #pstr = repr(sym)

        mcanv.addVaText(vastr, va=va)
        mcanv.addText(" %s: " % vareg)
        if isptr:
            mcanv.addVaText(pstr, p)
        else:
            mcanv.addText(pstr)
        mcanv.addText(preg)
        if isptr:
            try:
                addr,size,perm,fname = trace.getMemoryMap(p)
                pname = e_mem.reprPerms(perm)
                mcanv.addText(" ")
                mcanv.addNameText(pname)
                mcanv.addText(" ")

                bytes = trace.readMemory(p, 32)
                if self.isAscii(bytes):
                    mcanv.addText("'%s'" % bytes.split("\x00")[0])

                elif self.isBasicUnicode(bytes):
                    s = bytes.split("\x00\x00")[0].replace("\x00","")
                    mcanv.addText("u'%s'" % s)

                else:
                    mcanv.addText(bytes.encode('hex'))

            except Exception, e:
                mcanv.addText("ERROR: %s" % e)
        else:
            try:
                for fd,ftype,fname in trace.getFds():
                    if fd == p:
                        mcanv.addText('HANDLE/FD?: %s' % fname)
            except Exception, e:
                pass
        mcanv.addText("\n")

        return self.arch.getPointerSize()

    def isAscii(self, bytes):
        bytes = bytes.split("\x00")[0]
        if len(bytes) < 4:
            return False
        for i in range(len(bytes)):
            o = ord(bytes[i])
            if o < 0x20 or o > 0x7e:
                return False
        return True

    def isBasicUnicode(self, bytes):
        bytes = bytes.split("\x00\x00")[0]
        if len(bytes) < 8:
            return False
        nonull = bytes.replace("\x00", "")
        if (len(bytes) / 2) != len(nonull):
            return False
        return self.isAscii(nonull)

########NEW FILE########
__FILENAME__ = basictest
import sys
import time
import ctypes
import threading

def dostuff():
    print '++ Hi! Im the new thread! (sleeping for 3)\n'
    time.sleep(3)
    print '++ Now Im going to memory fault (reading 0x41414141)\n'
    try:
        x = ctypes.string_at(0x41414141, 20)
    except Exception, e:
        print e
    print '++ Sorry... my bad... ;)'
    print '++ Now Im going to exit... (value 30)\n'
    return 30


if __name__ == '__main__':


    print '== You should see a thread create\n'
    t = threading.Thread(target=dostuff)
    t.setDaemon(True)
    t.start()

    print '== He should exit in a couple seconds (sleeping for 5)\n'
    time.sleep(5)

    print '== I will exit now...\n'



########NEW FILE########
__FILENAME__ = builder
'''

VStruct builder!  Used to serialize structure definitions etc...

'''

import copy
import types
import inspect
import vstruct
import vstruct.primitives as vs_prim

prim_types = [ None, 
               vs_prim.v_uint8,
               vs_prim.v_uint16,
               None,
               vs_prim.v_uint32,
               None, None, None,
               vs_prim.v_uint64
             ]

# VStruct Field Flags
VSFF_POINTER = 1

class VStructConstructor:
    def __init__(self, builder, vsname):
        self.builder = builder
        self.vsname = vsname

    def __call__(self, *args, **kwargs):
        return self.builder.buildVStruct(self.vsname)

class VStructBuilder:

    def __init__(self, defs=(), enums=()):
        self._vs_defs = {}
        self._vs_enums = {}
        self._vs_namespaces = {}
        for vsdef in defs:
            self.addVStructDef(vsdef)
        for enum in enums:
            self.addVStructEnumeration(enum)

    def __getattr__(self, name):
        ns = self._vs_namespaces.get(name)
        if ns != None:
            return ns

        vsdef = self._vs_defs.get(name)
        if vsdef != None:
            return VStructConstructor(self, name)

        raise AttributeError, name

    def addVStructEnumeration(self, enum):
        self._vs_enums[enum[0]] = enum

    def addVStructNamespace(self, name, builder):
        self._vs_namespaces[name] = builder

    def getVStructNamespaces(self):
        return self._vs_namespaces.items()

    def getVStructNamespaceNames(self):
        return self._vs_namespaces.keys()

    def hasVStructNamespace(self, namespace):
        return self._vs_namespaces.get(namespace, None) != None

    def getVStructNames(self, namespace=None):
        if namespace == None:
            return self._vs_defs.keys()
        nsmod = self._vs_namespaces.get(namespace)
        ret = []
        for name in dir(nsmod):
            nobj = getattr(nsmod, name)
            if not inspect.isclass(nobj):
                continue
            if issubclass(nobj, vstruct.VStruct):
                ret.append(name)
        return ret

    def addVStructDef(self, vsdef):
        vsname = vsdef[0]
        self._vs_defs[vsname] = vsdef

    def _buildVsType(self, tname, tsize, tflags):

        if tflags & VSFF_POINTER:
            if tsize == 4:
                return vs_prim.v_ptr32()

            elif tsize == 8:
                return vs_prim.v_ptr64()

            else:
                raise Exception('Invalid Pointer Width: %d' % tsize)

        if tname != None:
            return self.buildVStruct(tname)

        if tsize not in [1,2,4,8]:
            return v_bytes(size=tsize)

        return prim_types[tsize]()

    def buildVStruct(self, vsname):
        # Check for a namespace
        parts = vsname.split('.', 1)
        if len(parts) == 2:
            ns = self._vs_namespaces.get(parts[0])
            if ns == None:
                raise Exception('Namespace %s is not present! (need symbols?)' % parts[0])

            # If a module gets added as a namespace, assume it has a class def...
            if isinstance(ns, types.ModuleType):
                cls = getattr(ns, parts[1])
                if cls == None:
                    raise Exception('Unknown VStruct Definition: %s' % vsname)
                return cls()

            return ns.buildVStruct(parts[1])

        vsdef = self._vs_defs.get(vsname)
        if vsdef == None:
            raise Exception('Unknown VStruct Definition: %s' % vsname)

        vsname, vssize, vskids = vsdef

        vs = vstruct.VStruct()
        vs._vs_name = vsname
    

        for fname, foffset, fsize, ftypename, fflags, fcount in vskids:

            fieldval = self._buildVsType(ftypename, fsize, fflags)

            if fcount != None:
                afields = [copy.deepcopy(fieldval) for i in xrange(fcount) ]
                fieldval = vstruct.VArray(afields)

            cursize = len(vs)
            if foffset < cursize:
                continue

            if foffset > cursize:
                setattr(vs, '_pad%.4x' % foffset, vs_prim.v_bytes(size=(foffset-cursize)))

            setattr(vs, fname, fieldval)

        final_len = len(vs)
        if final_len < vssize:
            setattr(vs, '_pad%.4x' % vssize, vs_prim.v_bytes(size=(vssize-final_len)))

        return vs

    def _genTypeConstructor(self, tname, tsize, tflags):
        if tflags & VSFF_POINTER:
            if tsize == 4:
                return 'v_ptr32()'
            elif tsize == 8:
                return 'v_ptr64()'
            else:
                return 'v_bytes(size=%d)' % tsize

        if tname != None:
            return '%s()' % tname

        # It's a base numeric type!
        if tsize == 1:
            return 'v_uint8()'
        elif tsize == 2:
            return 'v_uint16()'
        elif tsize == 4:
            return 'v_uint32()'
        elif tsize == 8:
            return 'v_uint64()'
        else:
            return 'v_bytes(size=%d)' % tsize

    def genVStructPyCode(self):
        ret = 'import vstruct\n'
        ret += 'from vstruct.primitives import *'
        ret += '\n\n'

        for ename, esize, ekids in self._vs_enums.values():
            ret += '%s = v_enum()\n' % ename
            for kname, kval in ekids:
                ret += '%s.%s = %d\n' % (ename,kname,kval)
            ret += '\n\n'


        for vsname, vsize, vskids in self._vs_defs.values():
            ret += 'class %s(vstruct.VStruct):\n' % vsname
            ret += '    def __init__(self):\n'
            ret += '        vstruct.VStruct.__init__(self)\n'
            offset = 0
            for fname, foffset, fsize, ftypename, fflags, fcount in vskids:

                # Skip overlapped fields
                if foffset < offset:
                    continue

                # Add pad if needed to reach next offset
                if foffset > offset:
                    ret += '        self._pad%.4x = v_bytes(size=%d)\n' % (foffset, foffset-offset)
                    offset += (foffset - offset)

                fconst = self._genTypeConstructor(ftypename, fsize, fflags)

                # If fcount != None, we're an array!
                if fcount != None:
                    fconst = 'vstruct.VArray([ %s for i in xrange(%d) ])' % (fconst, fcount)
                    fsize *= fcount

                ret += '        self.%s = %s\n' % (fname, fconst)
                offset += fsize
            # Check if we need to do final pading
            if offset < vsize:
                psize = vsize - offset
                ret += '        self._pad%.4x = v_bytes(size=%d)\n' % (vsize, psize)
            ret += '\n\n'

        return ret

if __name__ == '__main__':
    # Parse windows structures from dll symbols...
    import os
    import sys
    import platform

    from pprint import pprint

    import PE
    import vtrace.platforms.win32 as vt_win32

    p = PE.PE(file(sys.argv[1], 'rb'))
    baseaddr = p.IMAGE_NT_HEADERS.OptionalHeader.ImageBase
    osmajor = p.IMAGE_NT_HEADERS.OptionalHeader.MajorOperatingSystemVersion
    osminor = p.IMAGE_NT_HEADERS.OptionalHeader.MinorOperatingSystemVersion
    machine = p.IMAGE_NT_HEADERS.FileHeader.Machine

    vsver = p.getVS_VERSIONINFO()

    archname = PE.machine_names.get(machine)

    parser = vt_win32.Win32SymbolParser(0xffffffff, sys.argv[1], baseaddr)
    parser.parse()

    t = parser._sym_types.values()
    e = parser._sym_enums.values()
    builder = VStructBuilder(defs=t, enums=e)

    print '# Version: %d.%d' % (osmajor, osminor)
    print '# Architecture: %s' % archname
    if vsver != None:
        keys = vsver.getVersionKeys()
        keys.sort()
        for k in keys:
            val = vsver.getVersionValue(k).encode('ascii','ignore')
            print '# %s: %s' % (k,val)
    print builder.genVStructPyCode()


########NEW FILE########
__FILENAME__ = ntstatus
STATUS_SEVERITY_SUCCESS = 0x00000000
STATUS_SEVERITY_INFORMATIONAL = 0x00000001
STATUS_SEVERITY_WARNING = 0x00000002
STATUS_SEVERITY_ERROR = 0x00000003
STATUS_WAIT_0 = 0x00000000
STATUS_WAIT_1 = 0x00000001
STATUS_WAIT_2 = 0x00000002
STATUS_WAIT_3 = 0x00000003
STATUS_WAIT_63 = 0x0000003f
STATUS_ABANDONED = 0x00000080
STATUS_ABANDONED_WAIT_0 = 0x00000080
STATUS_ABANDONED_WAIT_63 = 0x000000bf
STATUS_USER_APC = 0x000000c0
STATUS_KERNEL_APC = 0x00000100
STATUS_ALERTED = 0x00000101
STATUS_TIMEOUT = 0x00000102
STATUS_PENDING = 0x00000103
STATUS_REPARSE = 0x00000104
STATUS_MORE_ENTRIES = 0x00000105
STATUS_NOT_ALL_ASSIGNED = 0x00000106
STATUS_SOME_NOT_MAPPED = 0x00000107
STATUS_OPLOCK_BREAK_IN_PROGRESS = 0x00000108
STATUS_VOLUME_MOUNTED = 0x00000109
STATUS_RXACT_COMMITTED = 0x0000010a
STATUS_NOTIFY_CLEANUP = 0x0000010b
STATUS_NOTIFY_ENUM_DIR = 0x0000010c
STATUS_NO_QUOTAS_FOR_ACCOUNT = 0x0000010d
STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED = 0x0000010e
STATUS_PAGE_FAULT_TRANSITION = 0x00000110
STATUS_PAGE_FAULT_DEMAND_ZERO = 0x00000111
STATUS_PAGE_FAULT_COPY_ON_WRITE = 0x00000112
STATUS_PAGE_FAULT_GUARD_PAGE = 0x00000113
STATUS_PAGE_FAULT_PAGING_FILE = 0x00000114
STATUS_CACHE_PAGE_LOCKED = 0x00000115
STATUS_CRASH_DUMP = 0x00000116
STATUS_BUFFER_ALL_ZEROS = 0x00000117
STATUS_REPARSE_OBJECT = 0x00000118
STATUS_RESOURCE_REQUIREMENTS_CHANGED = 0x00000119
STATUS_TRANSLATION_COMPLETE = 0x00000120
STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY = 0x00000121
STATUS_NOTHING_TO_TERMINATE = 0x00000122
STATUS_PROCESS_NOT_IN_JOB = 0x00000123
STATUS_PROCESS_IN_JOB = 0x00000124
STATUS_VOLSNAP_HIBERNATE_READY = 0x00000125
STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY = 0x00000126
STATUS_OBJECT_NAME_EXISTS = 0x40000000
STATUS_THREAD_WAS_SUSPENDED = 0x40000001
STATUS_WORKING_SET_LIMIT_RANGE = 0x40000002
STATUS_IMAGE_NOT_AT_BASE = 0x40000003
STATUS_RXACT_STATE_CREATED = 0x40000004
STATUS_SEGMENT_NOTIFICATION = 0x40000005
STATUS_LOCAL_USER_SESSION_KEY = 0x40000006
STATUS_BAD_CURRENT_DIRECTORY = 0x40000007
STATUS_SERIAL_MORE_WRITES = 0x40000008
STATUS_REGISTRY_RECOVERED = 0x40000009
STATUS_FT_READ_RECOVERY_FROM_BACKUP = 0x4000000a
STATUS_FT_WRITE_RECOVERY = 0x4000000b
STATUS_SERIAL_COUNTER_TIMEOUT = 0x4000000c
STATUS_NULL_LM_PASSWORD = 0x4000000d
STATUS_IMAGE_MACHINE_TYPE_MISMATCH = 0x4000000e
STATUS_RECEIVE_PARTIAL = 0x4000000f
STATUS_RECEIVE_EXPEDITED = 0x40000010
STATUS_RECEIVE_PARTIAL_EXPEDITED = 0x40000011
STATUS_EVENT_DONE = 0x40000012
STATUS_EVENT_PENDING = 0x40000013
STATUS_CHECKING_FILE_SYSTEM = 0x40000014
STATUS_FATAL_APP_EXIT = 0x40000015
STATUS_PREDEFINED_HANDLE = 0x40000016
STATUS_WAS_UNLOCKED = 0x40000017
STATUS_SERVICE_NOTIFICATION = 0x40000018
STATUS_WAS_LOCKED = 0x40000019
STATUS_LOG_HARD_ERROR = 0x4000001a
STATUS_ALREADY_WIN32 = 0x4000001b
STATUS_WX86_UNSIMULATE = 0x4000001c
STATUS_WX86_CONTINUE = 0x4000001d
STATUS_WX86_SINGLE_STEP = 0x4000001e
STATUS_WX86_BREAKPOINT = 0x4000001f
STATUS_WX86_EXCEPTION_CONTINUE = 0x40000020
STATUS_WX86_EXCEPTION_LASTCHANCE = 0x40000021
STATUS_WX86_EXCEPTION_CHAIN = 0x40000022
STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE = 0x40000023
STATUS_NO_YIELD_PERFORMED = 0x40000024
STATUS_TIMER_RESUME_IGNORED = 0x40000025
STATUS_ARBITRATION_UNHANDLED = 0x40000026
STATUS_CARDBUS_NOT_SUPPORTED = 0x40000027
STATUS_WX86_CREATEWX86TIB = 0x40000028
STATUS_MP_PROCESSOR_MISMATCH = 0x40000029
STATUS_HIBERNATED = 0x4000002a
STATUS_RESUME_HIBERNATION = 0x4000002b
STATUS_FIRMWARE_UPDATED = 0x4000002c
STATUS_WAKE_SYSTEM = 0x40000294
STATUS_DS_SHUTTING_DOWN = 0x40000370
RPC_NT_UUID_LOCAL_ONLY = 0x40020056
RPC_NT_SEND_INCOMPLETE = 0x400200af
STATUS_CTX_CDM_CONNECT = 0x400a0004
STATUS_CTX_CDM_DISCONNECT = 0x400a0005
STATUS_SXS_RELEASE_ACTIVATION_CONTEXT = 0x4015000d
STATUS_GUARD_PAGE_VIOLATION = 0x80000001
STATUS_DATATYPE_MISALIGNMENT = 0x80000002
STATUS_BREAKPOINT = 0x80000003
STATUS_SINGLE_STEP = 0x80000004
STATUS_BUFFER_OVERFLOW = 0x80000005
STATUS_NO_MORE_FILES = 0x80000006
STATUS_WAKE_SYSTEM_DEBUGGER = 0x80000007
STATUS_HANDLES_CLOSED = 0x8000000a
STATUS_NO_INHERITANCE = 0x8000000b
STATUS_GUID_SUBSTITUTION_MADE = 0x8000000c
STATUS_PARTIAL_COPY = 0x8000000d
STATUS_DEVICE_PAPER_EMPTY = 0x8000000e
STATUS_DEVICE_POWERED_OFF = 0x8000000f
STATUS_DEVICE_OFF_LINE = 0x80000010
STATUS_DEVICE_BUSY = 0x80000011
STATUS_NO_MORE_EAS = 0x80000012
STATUS_INVALID_EA_NAME = 0x80000013
STATUS_EA_LIST_INCONSISTENT = 0x80000014
STATUS_INVALID_EA_FLAG = 0x80000015
STATUS_VERIFY_REQUIRED = 0x80000016
STATUS_EXTRANEOUS_INFORMATION = 0x80000017
STATUS_RXACT_COMMIT_NECESSARY = 0x80000018
STATUS_NO_MORE_ENTRIES = 0x8000001a
STATUS_FILEMARK_DETECTED = 0x8000001b
STATUS_MEDIA_CHANGED = 0x8000001c
STATUS_BUS_RESET = 0x8000001d
STATUS_END_OF_MEDIA = 0x8000001e
STATUS_BEGINNING_OF_MEDIA = 0x8000001f
STATUS_MEDIA_CHECK = 0x80000020
STATUS_SETMARK_DETECTED = 0x80000021
STATUS_NO_DATA_DETECTED = 0x80000022
STATUS_REDIRECTOR_HAS_OPEN_HANDLES = 0x80000023
STATUS_SERVER_HAS_OPEN_HANDLES = 0x80000024
STATUS_ALREADY_DISCONNECTED = 0x80000025
STATUS_LONGJUMP = 0x80000026
STATUS_CLEANER_CARTRIDGE_INSTALLED = 0x80000027
STATUS_PLUGPLAY_QUERY_VETOED = 0x80000028
STATUS_UNWIND_CONSOLIDATE = 0x80000029
STATUS_REGISTRY_HIVE_RECOVERED = 0x8000002a
STATUS_DLL_MIGHT_BE_INSECURE = 0x8000002b
STATUS_DLL_MIGHT_BE_INCOMPATIBLE = 0x8000002c
STATUS_DEVICE_REQUIRES_CLEANING = 0x80000288
STATUS_DEVICE_DOOR_OPEN = 0x80000289
STATUS_CLUSTER_NODE_ALREADY_UP = 0x80130001
STATUS_CLUSTER_NODE_ALREADY_DOWN = 0x80130002
STATUS_CLUSTER_NETWORK_ALREADY_ONLINE = 0x80130003
STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE = 0x80130004
STATUS_CLUSTER_NODE_ALREADY_MEMBER = 0x80130005
STATUS_UNSUCCESSFUL = 0xc0000001
STATUS_NOT_IMPLEMENTED = 0xc0000002
STATUS_INVALID_INFO_CLASS = 0xc0000003
STATUS_INFO_LENGTH_MISMATCH = 0xc0000004
STATUS_ACCESS_VIOLATION = 0xc0000005
STATUS_IN_PAGE_ERROR = 0xc0000006
STATUS_PAGEFILE_QUOTA = 0xc0000007
STATUS_INVALID_HANDLE = 0xc0000008
STATUS_BAD_INITIAL_STACK = 0xc0000009
STATUS_BAD_INITIAL_PC = 0xc000000a
STATUS_INVALID_CID = 0xc000000b
STATUS_TIMER_NOT_CANCELED = 0xc000000c
STATUS_INVALID_PARAMETER = 0xc000000d
STATUS_NO_SUCH_DEVICE = 0xc000000e
STATUS_NO_SUCH_FILE = 0xc000000f
STATUS_INVALID_DEVICE_REQUEST = 0xc0000010
STATUS_END_OF_FILE = 0xc0000011
STATUS_WRONG_VOLUME = 0xc0000012
STATUS_NO_MEDIA_IN_DEVICE = 0xc0000013
STATUS_UNRECOGNIZED_MEDIA = 0xc0000014
STATUS_NONEXISTENT_SECTOR = 0xc0000015
STATUS_MORE_PROCESSING_REQUIRED = 0xc0000016
STATUS_NO_MEMORY = 0xc0000017
STATUS_CONFLICTING_ADDRESSES = 0xc0000018
STATUS_NOT_MAPPED_VIEW = 0xc0000019
STATUS_UNABLE_TO_FREE_VM = 0xc000001a
STATUS_UNABLE_TO_DELETE_SECTION = 0xc000001b
STATUS_INVALID_SYSTEM_SERVICE = 0xc000001c
STATUS_ILLEGAL_INSTRUCTION = 0xc000001d
STATUS_INVALID_LOCK_SEQUENCE = 0xc000001e
STATUS_INVALID_VIEW_SIZE = 0xc000001f
STATUS_INVALID_FILE_FOR_SECTION = 0xc0000020
STATUS_ALREADY_COMMITTED = 0xc0000021
STATUS_ACCESS_DENIED = 0xc0000022
STATUS_BUFFER_TOO_SMALL = 0xc0000023
STATUS_OBJECT_TYPE_MISMATCH = 0xc0000024
STATUS_NONCONTINUABLE_EXCEPTION = 0xc0000025
STATUS_INVALID_DISPOSITION = 0xc0000026
STATUS_UNWIND = 0xc0000027
STATUS_BAD_STACK = 0xc0000028
STATUS_INVALID_UNWIND_TARGET = 0xc0000029
STATUS_NOT_LOCKED = 0xc000002a
STATUS_PARITY_ERROR = 0xc000002b
STATUS_UNABLE_TO_DECOMMIT_VM = 0xc000002c
STATUS_NOT_COMMITTED = 0xc000002d
STATUS_INVALID_PORT_ATTRIBUTES = 0xc000002e
STATUS_PORT_MESSAGE_TOO_LONG = 0xc000002f
STATUS_INVALID_PARAMETER_MIX = 0xc0000030
STATUS_INVALID_QUOTA_LOWER = 0xc0000031
STATUS_DISK_CORRUPT_ERROR = 0xc0000032
STATUS_OBJECT_NAME_INVALID = 0xc0000033
STATUS_OBJECT_NAME_NOT_FOUND = 0xc0000034
STATUS_OBJECT_NAME_COLLISION = 0xc0000035
STATUS_PORT_DISCONNECTED = 0xc0000037
STATUS_DEVICE_ALREADY_ATTACHED = 0xc0000038
STATUS_OBJECT_PATH_INVALID = 0xc0000039
STATUS_OBJECT_PATH_NOT_FOUND = 0xc000003a
STATUS_OBJECT_PATH_SYNTAX_BAD = 0xc000003b
STATUS_DATA_OVERRUN = 0xc000003c
STATUS_DATA_LATE_ERROR = 0xc000003d
STATUS_DATA_ERROR = 0xc000003e
STATUS_CRC_ERROR = 0xc000003f
STATUS_SECTION_TOO_BIG = 0xc0000040
STATUS_PORT_CONNECTION_REFUSED = 0xc0000041
STATUS_INVALID_PORT_HANDLE = 0xc0000042
STATUS_SHARING_VIOLATION = 0xc0000043
STATUS_QUOTA_EXCEEDED = 0xc0000044
STATUS_INVALID_PAGE_PROTECTION = 0xc0000045
STATUS_MUTANT_NOT_OWNED = 0xc0000046
STATUS_SEMAPHORE_LIMIT_EXCEEDED = 0xc0000047
STATUS_PORT_ALREADY_SET = 0xc0000048
STATUS_SECTION_NOT_IMAGE = 0xc0000049
STATUS_SUSPEND_COUNT_EXCEEDED = 0xc000004a
STATUS_THREAD_IS_TERMINATING = 0xc000004b
STATUS_BAD_WORKING_SET_LIMIT = 0xc000004c
STATUS_INCOMPATIBLE_FILE_MAP = 0xc000004d
STATUS_SECTION_PROTECTION = 0xc000004e
STATUS_EAS_NOT_SUPPORTED = 0xc000004f
STATUS_EA_TOO_LARGE = 0xc0000050
STATUS_NONEXISTENT_EA_ENTRY = 0xc0000051
STATUS_NO_EAS_ON_FILE = 0xc0000052
STATUS_EA_CORRUPT_ERROR = 0xc0000053
STATUS_FILE_LOCK_CONFLICT = 0xc0000054
STATUS_LOCK_NOT_GRANTED = 0xc0000055
STATUS_DELETE_PENDING = 0xc0000056
STATUS_CTL_FILE_NOT_SUPPORTED = 0xc0000057
STATUS_UNKNOWN_REVISION = 0xc0000058
STATUS_REVISION_MISMATCH = 0xc0000059
STATUS_INVALID_OWNER = 0xc000005a
STATUS_INVALID_PRIMARY_GROUP = 0xc000005b
STATUS_NO_IMPERSONATION_TOKEN = 0xc000005c
STATUS_CANT_DISABLE_MANDATORY = 0xc000005d
STATUS_NO_LOGON_SERVERS = 0xc000005e
STATUS_NO_SUCH_LOGON_SESSION = 0xc000005f
STATUS_NO_SUCH_PRIVILEGE = 0xc0000060
STATUS_PRIVILEGE_NOT_HELD = 0xc0000061
STATUS_INVALID_ACCOUNT_NAME = 0xc0000062
STATUS_USER_EXISTS = 0xc0000063
STATUS_NO_SUCH_USER = 0xc0000064
STATUS_GROUP_EXISTS = 0xc0000065
STATUS_NO_SUCH_GROUP = 0xc0000066
STATUS_MEMBER_IN_GROUP = 0xc0000067
STATUS_MEMBER_NOT_IN_GROUP = 0xc0000068
STATUS_LAST_ADMIN = 0xc0000069
STATUS_WRONG_PASSWORD = 0xc000006a
STATUS_ILL_FORMED_PASSWORD = 0xc000006b
STATUS_PASSWORD_RESTRICTION = 0xc000006c
STATUS_LOGON_FAILURE = 0xc000006d
STATUS_ACCOUNT_RESTRICTION = 0xc000006e
STATUS_INVALID_LOGON_HOURS = 0xc000006f
STATUS_INVALID_WORKSTATION = 0xc0000070
STATUS_PASSWORD_EXPIRED = 0xc0000071
STATUS_ACCOUNT_DISABLED = 0xc0000072
STATUS_NONE_MAPPED = 0xc0000073
STATUS_TOO_MANY_LUIDS_REQUESTED = 0xc0000074
STATUS_LUIDS_EXHAUSTED = 0xc0000075
STATUS_INVALID_SUB_AUTHORITY = 0xc0000076
STATUS_INVALID_ACL = 0xc0000077
STATUS_INVALID_SID = 0xc0000078
STATUS_INVALID_SECURITY_DESCR = 0xc0000079
STATUS_PROCEDURE_NOT_FOUND = 0xc000007a
STATUS_INVALID_IMAGE_FORMAT = 0xc000007b
STATUS_NO_TOKEN = 0xc000007c
STATUS_BAD_INHERITANCE_ACL = 0xc000007d
STATUS_RANGE_NOT_LOCKED = 0xc000007e
STATUS_DISK_FULL = 0xc000007f
STATUS_SERVER_DISABLED = 0xc0000080
STATUS_SERVER_NOT_DISABLED = 0xc0000081
STATUS_TOO_MANY_GUIDS_REQUESTED = 0xc0000082
STATUS_GUIDS_EXHAUSTED = 0xc0000083
STATUS_INVALID_ID_AUTHORITY = 0xc0000084
STATUS_AGENTS_EXHAUSTED = 0xc0000085
STATUS_INVALID_VOLUME_LABEL = 0xc0000086
STATUS_SECTION_NOT_EXTENDED = 0xc0000087
STATUS_NOT_MAPPED_DATA = 0xc0000088
STATUS_RESOURCE_DATA_NOT_FOUND = 0xc0000089
STATUS_RESOURCE_TYPE_NOT_FOUND = 0xc000008a
STATUS_RESOURCE_NAME_NOT_FOUND = 0xc000008b
STATUS_ARRAY_BOUNDS_EXCEEDED = 0xc000008c
STATUS_FLOAT_DENORMAL_OPERAND = 0xc000008d
STATUS_FLOAT_DIVIDE_BY_ZERO = 0xc000008e
STATUS_FLOAT_INEXACT_RESULT = 0xc000008f
STATUS_FLOAT_INVALID_OPERATION = 0xc0000090
STATUS_FLOAT_OVERFLOW = 0xc0000091
STATUS_FLOAT_STACK_CHECK = 0xc0000092
STATUS_FLOAT_UNDERFLOW = 0xc0000093
STATUS_INTEGER_DIVIDE_BY_ZERO = 0xc0000094
STATUS_INTEGER_OVERFLOW = 0xc0000095
STATUS_PRIVILEGED_INSTRUCTION = 0xc0000096
STATUS_TOO_MANY_PAGING_FILES = 0xc0000097
STATUS_FILE_INVALID = 0xc0000098
STATUS_ALLOTTED_SPACE_EXCEEDED = 0xc0000099
STATUS_INSUFFICIENT_RESOURCES = 0xc000009a
STATUS_DFS_EXIT_PATH_FOUND = 0xc000009b
STATUS_DEVICE_DATA_ERROR = 0xc000009c
STATUS_DEVICE_NOT_CONNECTED = 0xc000009d
STATUS_DEVICE_POWER_FAILURE = 0xc000009e
STATUS_FREE_VM_NOT_AT_BASE = 0xc000009f
STATUS_MEMORY_NOT_ALLOCATED = 0xc00000a0
STATUS_WORKING_SET_QUOTA = 0xc00000a1
STATUS_MEDIA_WRITE_PROTECTED = 0xc00000a2
STATUS_DEVICE_NOT_READY = 0xc00000a3
STATUS_INVALID_GROUP_ATTRIBUTES = 0xc00000a4
STATUS_BAD_IMPERSONATION_LEVEL = 0xc00000a5
STATUS_CANT_OPEN_ANONYMOUS = 0xc00000a6
STATUS_BAD_VALIDATION_CLASS = 0xc00000a7
STATUS_BAD_TOKEN_TYPE = 0xc00000a8
STATUS_BAD_MASTER_BOOT_RECORD = 0xc00000a9
STATUS_INSTRUCTION_MISALIGNMENT = 0xc00000aa
STATUS_INSTANCE_NOT_AVAILABLE = 0xc00000ab
STATUS_PIPE_NOT_AVAILABLE = 0xc00000ac
STATUS_INVALID_PIPE_STATE = 0xc00000ad
STATUS_PIPE_BUSY = 0xc00000ae
STATUS_ILLEGAL_FUNCTION = 0xc00000af
STATUS_PIPE_DISCONNECTED = 0xc00000b0
STATUS_PIPE_CLOSING = 0xc00000b1
STATUS_PIPE_CONNECTED = 0xc00000b2
STATUS_PIPE_LISTENING = 0xc00000b3
STATUS_INVALID_READ_MODE = 0xc00000b4
STATUS_IO_TIMEOUT = 0xc00000b5
STATUS_FILE_FORCED_CLOSED = 0xc00000b6
STATUS_PROFILING_NOT_STARTED = 0xc00000b7
STATUS_PROFILING_NOT_STOPPED = 0xc00000b8
STATUS_COULD_NOT_INTERPRET = 0xc00000b9
STATUS_FILE_IS_A_DIRECTORY = 0xc00000ba
STATUS_NOT_SUPPORTED = 0xc00000bb
STATUS_REMOTE_NOT_LISTENING = 0xc00000bc
STATUS_DUPLICATE_NAME = 0xc00000bd
STATUS_BAD_NETWORK_PATH = 0xc00000be
STATUS_NETWORK_BUSY = 0xc00000bf
STATUS_DEVICE_DOES_NOT_EXIST = 0xc00000c0
STATUS_TOO_MANY_COMMANDS = 0xc00000c1
STATUS_ADAPTER_HARDWARE_ERROR = 0xc00000c2
STATUS_INVALID_NETWORK_RESPONSE = 0xc00000c3
STATUS_UNEXPECTED_NETWORK_ERROR = 0xc00000c4
STATUS_BAD_REMOTE_ADAPTER = 0xc00000c5
STATUS_PRINT_QUEUE_FULL = 0xc00000c6
STATUS_NO_SPOOL_SPACE = 0xc00000c7
STATUS_PRINT_CANCELLED = 0xc00000c8
STATUS_NETWORK_NAME_DELETED = 0xc00000c9
STATUS_NETWORK_ACCESS_DENIED = 0xc00000ca
STATUS_BAD_DEVICE_TYPE = 0xc00000cb
STATUS_BAD_NETWORK_NAME = 0xc00000cc
STATUS_TOO_MANY_NAMES = 0xc00000cd
STATUS_TOO_MANY_SESSIONS = 0xc00000ce
STATUS_SHARING_PAUSED = 0xc00000cf
STATUS_REQUEST_NOT_ACCEPTED = 0xc00000d0
STATUS_REDIRECTOR_PAUSED = 0xc00000d1
STATUS_NET_WRITE_FAULT = 0xc00000d2
STATUS_PROFILING_AT_LIMIT = 0xc00000d3
STATUS_NOT_SAME_DEVICE = 0xc00000d4
STATUS_FILE_RENAMED = 0xc00000d5
STATUS_VIRTUAL_CIRCUIT_CLOSED = 0xc00000d6
STATUS_NO_SECURITY_ON_OBJECT = 0xc00000d7
STATUS_CANT_WAIT = 0xc00000d8
STATUS_PIPE_EMPTY = 0xc00000d9
STATUS_CANT_ACCESS_DOMAIN_INFO = 0xc00000da
STATUS_CANT_TERMINATE_SELF = 0xc00000db
STATUS_INVALID_SERVER_STATE = 0xc00000dc
STATUS_INVALID_DOMAIN_STATE = 0xc00000dd
STATUS_INVALID_DOMAIN_ROLE = 0xc00000de
STATUS_NO_SUCH_DOMAIN = 0xc00000df
STATUS_DOMAIN_EXISTS = 0xc00000e0
STATUS_DOMAIN_LIMIT_EXCEEDED = 0xc00000e1
STATUS_OPLOCK_NOT_GRANTED = 0xc00000e2
STATUS_INVALID_OPLOCK_PROTOCOL = 0xc00000e3
STATUS_INTERNAL_DB_CORRUPTION = 0xc00000e4
STATUS_INTERNAL_ERROR = 0xc00000e5
STATUS_GENERIC_NOT_MAPPED = 0xc00000e6
STATUS_BAD_DESCRIPTOR_FORMAT = 0xc00000e7
STATUS_INVALID_USER_BUFFER = 0xc00000e8
STATUS_UNEXPECTED_IO_ERROR = 0xc00000e9
STATUS_UNEXPECTED_MM_CREATE_ERR = 0xc00000ea
STATUS_UNEXPECTED_MM_MAP_ERROR = 0xc00000eb
STATUS_UNEXPECTED_MM_EXTEND_ERR = 0xc00000ec
STATUS_NOT_LOGON_PROCESS = 0xc00000ed
STATUS_LOGON_SESSION_EXISTS = 0xc00000ee
STATUS_INVALID_PARAMETER_1 = 0xc00000ef
STATUS_INVALID_PARAMETER_2 = 0xc00000f0
STATUS_INVALID_PARAMETER_3 = 0xc00000f1
STATUS_INVALID_PARAMETER_4 = 0xc00000f2
STATUS_INVALID_PARAMETER_5 = 0xc00000f3
STATUS_INVALID_PARAMETER_6 = 0xc00000f4
STATUS_INVALID_PARAMETER_7 = 0xc00000f5
STATUS_INVALID_PARAMETER_8 = 0xc00000f6
STATUS_INVALID_PARAMETER_9 = 0xc00000f7
STATUS_INVALID_PARAMETER_10 = 0xc00000f8
STATUS_INVALID_PARAMETER_11 = 0xc00000f9
STATUS_INVALID_PARAMETER_12 = 0xc00000fa
STATUS_REDIRECTOR_NOT_STARTED = 0xc00000fb
STATUS_REDIRECTOR_STARTED = 0xc00000fc
STATUS_STACK_OVERFLOW = 0xc00000fd
STATUS_NO_SUCH_PACKAGE = 0xc00000fe
STATUS_BAD_FUNCTION_TABLE = 0xc00000ff
STATUS_VARIABLE_NOT_FOUND = 0xc0000100
STATUS_DIRECTORY_NOT_EMPTY = 0xc0000101
STATUS_FILE_CORRUPT_ERROR = 0xc0000102
STATUS_NOT_A_DIRECTORY = 0xc0000103
STATUS_BAD_LOGON_SESSION_STATE = 0xc0000104
STATUS_LOGON_SESSION_COLLISION = 0xc0000105
STATUS_NAME_TOO_LONG = 0xc0000106
STATUS_FILES_OPEN = 0xc0000107
STATUS_CONNECTION_IN_USE = 0xc0000108
STATUS_MESSAGE_NOT_FOUND = 0xc0000109
STATUS_PROCESS_IS_TERMINATING = 0xc000010a
STATUS_INVALID_LOGON_TYPE = 0xc000010b
STATUS_NO_GUID_TRANSLATION = 0xc000010c
STATUS_CANNOT_IMPERSONATE = 0xc000010d
STATUS_IMAGE_ALREADY_LOADED = 0xc000010e
STATUS_ABIOS_NOT_PRESENT = 0xc000010f
STATUS_ABIOS_LID_NOT_EXIST = 0xc0000110
STATUS_ABIOS_LID_ALREADY_OWNED = 0xc0000111
STATUS_ABIOS_NOT_LID_OWNER = 0xc0000112
STATUS_ABIOS_INVALID_COMMAND = 0xc0000113
STATUS_ABIOS_INVALID_LID = 0xc0000114
STATUS_ABIOS_SELECTOR_NOT_AVAILABLE = 0xc0000115
STATUS_ABIOS_INVALID_SELECTOR = 0xc0000116
STATUS_NO_LDT = 0xc0000117
STATUS_INVALID_LDT_SIZE = 0xc0000118
STATUS_INVALID_LDT_OFFSET = 0xc0000119
STATUS_INVALID_LDT_DESCRIPTOR = 0xc000011a
STATUS_INVALID_IMAGE_NE_FORMAT = 0xc000011b
STATUS_RXACT_INVALID_STATE = 0xc000011c
STATUS_RXACT_COMMIT_FAILURE = 0xc000011d
STATUS_MAPPED_FILE_SIZE_ZERO = 0xc000011e
STATUS_TOO_MANY_OPENED_FILES = 0xc000011f
STATUS_CANCELLED = 0xc0000120
STATUS_CANNOT_DELETE = 0xc0000121
STATUS_INVALID_COMPUTER_NAME = 0xc0000122
STATUS_FILE_DELETED = 0xc0000123
STATUS_SPECIAL_ACCOUNT = 0xc0000124
STATUS_SPECIAL_GROUP = 0xc0000125
STATUS_SPECIAL_USER = 0xc0000126
STATUS_MEMBERS_PRIMARY_GROUP = 0xc0000127
STATUS_FILE_CLOSED = 0xc0000128
STATUS_TOO_MANY_THREADS = 0xc0000129
STATUS_THREAD_NOT_IN_PROCESS = 0xc000012a
STATUS_TOKEN_ALREADY_IN_USE = 0xc000012b
STATUS_PAGEFILE_QUOTA_EXCEEDED = 0xc000012c
STATUS_COMMITMENT_LIMIT = 0xc000012d
STATUS_INVALID_IMAGE_LE_FORMAT = 0xc000012e
STATUS_INVALID_IMAGE_NOT_MZ = 0xc000012f
STATUS_INVALID_IMAGE_PROTECT = 0xc0000130
STATUS_INVALID_IMAGE_WIN_16 = 0xc0000131
STATUS_LOGON_SERVER_CONFLICT = 0xc0000132
STATUS_TIME_DIFFERENCE_AT_DC = 0xc0000133
STATUS_SYNCHRONIZATION_REQUIRED = 0xc0000134
STATUS_DLL_NOT_FOUND = 0xc0000135
STATUS_OPEN_FAILED = 0xc0000136
STATUS_IO_PRIVILEGE_FAILED = 0xc0000137
STATUS_ORDINAL_NOT_FOUND = 0xc0000138
STATUS_ENTRYPOINT_NOT_FOUND = 0xc0000139
STATUS_CONTROL_C_EXIT = 0xc000013a
STATUS_LOCAL_DISCONNECT = 0xc000013b
STATUS_REMOTE_DISCONNECT = 0xc000013c
STATUS_REMOTE_RESOURCES = 0xc000013d
STATUS_LINK_FAILED = 0xc000013e
STATUS_LINK_TIMEOUT = 0xc000013f
STATUS_INVALID_CONNECTION = 0xc0000140
STATUS_INVALID_ADDRESS = 0xc0000141
STATUS_DLL_INIT_FAILED = 0xc0000142
STATUS_MISSING_SYSTEMFILE = 0xc0000143
STATUS_UNHANDLED_EXCEPTION = 0xc0000144
STATUS_APP_INIT_FAILURE = 0xc0000145
STATUS_PAGEFILE_CREATE_FAILED = 0xc0000146
STATUS_NO_PAGEFILE = 0xc0000147
STATUS_INVALID_LEVEL = 0xc0000148
STATUS_WRONG_PASSWORD_CORE = 0xc0000149
STATUS_ILLEGAL_FLOAT_CONTEXT = 0xc000014a
STATUS_PIPE_BROKEN = 0xc000014b
STATUS_REGISTRY_CORRUPT = 0xc000014c
STATUS_REGISTRY_IO_FAILED = 0xc000014d
STATUS_NO_EVENT_PAIR = 0xc000014e
STATUS_UNRECOGNIZED_VOLUME = 0xc000014f
STATUS_SERIAL_NO_DEVICE_INITED = 0xc0000150
STATUS_NO_SUCH_ALIAS = 0xc0000151
STATUS_MEMBER_NOT_IN_ALIAS = 0xc0000152
STATUS_MEMBER_IN_ALIAS = 0xc0000153
STATUS_ALIAS_EXISTS = 0xc0000154
STATUS_LOGON_NOT_GRANTED = 0xc0000155
STATUS_TOO_MANY_SECRETS = 0xc0000156
STATUS_SECRET_TOO_LONG = 0xc0000157
STATUS_INTERNAL_DB_ERROR = 0xc0000158
STATUS_FULLSCREEN_MODE = 0xc0000159
STATUS_TOO_MANY_CONTEXT_IDS = 0xc000015a
STATUS_LOGON_TYPE_NOT_GRANTED = 0xc000015b
STATUS_NOT_REGISTRY_FILE = 0xc000015c
STATUS_NT_CROSS_ENCRYPTION_REQUIRED = 0xc000015d
STATUS_DOMAIN_CTRLR_CONFIG_ERROR = 0xc000015e
STATUS_FT_MISSING_MEMBER = 0xc000015f
STATUS_ILL_FORMED_SERVICE_ENTRY = 0xc0000160
STATUS_ILLEGAL_CHARACTER = 0xc0000161
STATUS_UNMAPPABLE_CHARACTER = 0xc0000162
STATUS_UNDEFINED_CHARACTER = 0xc0000163
STATUS_FLOPPY_VOLUME = 0xc0000164
STATUS_FLOPPY_ID_MARK_NOT_FOUND = 0xc0000165
STATUS_FLOPPY_WRONG_CYLINDER = 0xc0000166
STATUS_FLOPPY_UNKNOWN_ERROR = 0xc0000167
STATUS_FLOPPY_BAD_REGISTERS = 0xc0000168
STATUS_DISK_RECALIBRATE_FAILED = 0xc0000169
STATUS_DISK_OPERATION_FAILED = 0xc000016a
STATUS_DISK_RESET_FAILED = 0xc000016b
STATUS_SHARED_IRQ_BUSY = 0xc000016c
STATUS_FT_ORPHANING = 0xc000016d
STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT = 0xc000016e
STATUS_PARTITION_FAILURE = 0xc0000172
STATUS_INVALID_BLOCK_LENGTH = 0xc0000173
STATUS_DEVICE_NOT_PARTITIONED = 0xc0000174
STATUS_UNABLE_TO_LOCK_MEDIA = 0xc0000175
STATUS_UNABLE_TO_UNLOAD_MEDIA = 0xc0000176
STATUS_EOM_OVERFLOW = 0xc0000177
STATUS_NO_MEDIA = 0xc0000178
STATUS_NO_SUCH_MEMBER = 0xc000017a
STATUS_INVALID_MEMBER = 0xc000017b
STATUS_KEY_DELETED = 0xc000017c
STATUS_NO_LOG_SPACE = 0xc000017d
STATUS_TOO_MANY_SIDS = 0xc000017e
STATUS_LM_CROSS_ENCRYPTION_REQUIRED = 0xc000017f
STATUS_KEY_HAS_CHILDREN = 0xc0000180
STATUS_CHILD_MUST_BE_VOLATILE = 0xc0000181
STATUS_DEVICE_CONFIGURATION_ERROR = 0xc0000182
STATUS_DRIVER_INTERNAL_ERROR = 0xc0000183
STATUS_INVALID_DEVICE_STATE = 0xc0000184
STATUS_IO_DEVICE_ERROR = 0xc0000185
STATUS_DEVICE_PROTOCOL_ERROR = 0xc0000186
STATUS_BACKUP_CONTROLLER = 0xc0000187
STATUS_LOG_FILE_FULL = 0xc0000188
STATUS_TOO_LATE = 0xc0000189
STATUS_NO_TRUST_LSA_SECRET = 0xc000018a
STATUS_NO_TRUST_SAM_ACCOUNT = 0xc000018b
STATUS_TRUSTED_DOMAIN_FAILURE = 0xc000018c
STATUS_TRUSTED_RELATIONSHIP_FAILURE = 0xc000018d
STATUS_EVENTLOG_FILE_CORRUPT = 0xc000018e
STATUS_EVENTLOG_CANT_START = 0xc000018f
STATUS_TRUST_FAILURE = 0xc0000190
STATUS_MUTANT_LIMIT_EXCEEDED = 0xc0000191
STATUS_NETLOGON_NOT_STARTED = 0xc0000192
STATUS_ACCOUNT_EXPIRED = 0xc0000193
STATUS_POSSIBLE_DEADLOCK = 0xc0000194
STATUS_NETWORK_CREDENTIAL_CONFLICT = 0xc0000195
STATUS_REMOTE_SESSION_LIMIT = 0xc0000196
STATUS_EVENTLOG_FILE_CHANGED = 0xc0000197
STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = 0xc0000198
STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT = 0xc0000199
STATUS_NOLOGON_SERVER_TRUST_ACCOUNT = 0xc000019a
STATUS_DOMAIN_TRUST_INCONSISTENT = 0xc000019b
STATUS_FS_DRIVER_REQUIRED = 0xc000019c
STATUS_NO_USER_SESSION_KEY = 0xc0000202
STATUS_USER_SESSION_DELETED = 0xc0000203
STATUS_RESOURCE_LANG_NOT_FOUND = 0xc0000204
STATUS_INSUFF_SERVER_RESOURCES = 0xc0000205
STATUS_INVALID_BUFFER_SIZE = 0xc0000206
STATUS_INVALID_ADDRESS_COMPONENT = 0xc0000207
STATUS_INVALID_ADDRESS_WILDCARD = 0xc0000208
STATUS_TOO_MANY_ADDRESSES = 0xc0000209
STATUS_ADDRESS_ALREADY_EXISTS = 0xc000020a
STATUS_ADDRESS_CLOSED = 0xc000020b
STATUS_CONNECTION_DISCONNECTED = 0xc000020c
STATUS_CONNECTION_RESET = 0xc000020d
STATUS_TOO_MANY_NODES = 0xc000020e
STATUS_TRANSACTION_ABORTED = 0xc000020f
STATUS_TRANSACTION_TIMED_OUT = 0xc0000210
STATUS_TRANSACTION_NO_RELEASE = 0xc0000211
STATUS_TRANSACTION_NO_MATCH = 0xc0000212
STATUS_TRANSACTION_RESPONDED = 0xc0000213
STATUS_TRANSACTION_INVALID_ID = 0xc0000214
STATUS_TRANSACTION_INVALID_TYPE = 0xc0000215
STATUS_NOT_SERVER_SESSION = 0xc0000216
STATUS_NOT_CLIENT_SESSION = 0xc0000217
STATUS_CANNOT_LOAD_REGISTRY_FILE = 0xc0000218
STATUS_DEBUG_ATTACH_FAILED = 0xc0000219
STATUS_SYSTEM_PROCESS_TERMINATED = 0xc000021a
STATUS_DATA_NOT_ACCEPTED = 0xc000021b
STATUS_NO_BROWSER_SERVERS_FOUND = 0xc000021c
STATUS_VDM_HARD_ERROR = 0xc000021d
STATUS_DRIVER_CANCEL_TIMEOUT = 0xc000021e
STATUS_REPLY_MESSAGE_MISMATCH = 0xc000021f
STATUS_MAPPED_ALIGNMENT = 0xc0000220
STATUS_IMAGE_CHECKSUM_MISMATCH = 0xc0000221
STATUS_LOST_WRITEBEHIND_DATA = 0xc0000222
STATUS_CLIENT_SERVER_PARAMETERS_INVALID = 0xc0000223
STATUS_PASSWORD_MUST_CHANGE = 0xc0000224
STATUS_NOT_FOUND = 0xc0000225
STATUS_NOT_TINY_STREAM = 0xc0000226
STATUS_RECOVERY_FAILURE = 0xc0000227
STATUS_STACK_OVERFLOW_READ = 0xc0000228
STATUS_FAIL_CHECK = 0xc0000229
STATUS_DUPLICATE_OBJECTID = 0xc000022a
STATUS_OBJECTID_EXISTS = 0xc000022b
STATUS_CONVERT_TO_LARGE = 0xc000022c
STATUS_RETRY = 0xc000022d
STATUS_FOUND_OUT_OF_SCOPE = 0xc000022e
STATUS_ALLOCATE_BUCKET = 0xc000022f
STATUS_PROPSET_NOT_FOUND = 0xc0000230
STATUS_MARSHALL_OVERFLOW = 0xc0000231
STATUS_INVALID_VARIANT = 0xc0000232
STATUS_DOMAIN_CONTROLLER_NOT_FOUND = 0xc0000233
STATUS_ACCOUNT_LOCKED_OUT = 0xc0000234
STATUS_HANDLE_NOT_CLOSABLE = 0xc0000235
STATUS_CONNECTION_REFUSED = 0xc0000236
STATUS_GRACEFUL_DISCONNECT = 0xc0000237
STATUS_ADDRESS_ALREADY_ASSOCIATED = 0xc0000238
STATUS_ADDRESS_NOT_ASSOCIATED = 0xc0000239
STATUS_CONNECTION_INVALID = 0xc000023a
STATUS_CONNECTION_ACTIVE = 0xc000023b
STATUS_NETWORK_UNREACHABLE = 0xc000023c
STATUS_HOST_UNREACHABLE = 0xc000023d
STATUS_PROTOCOL_UNREACHABLE = 0xc000023e
STATUS_PORT_UNREACHABLE = 0xc000023f
STATUS_REQUEST_ABORTED = 0xc0000240
STATUS_CONNECTION_ABORTED = 0xc0000241
STATUS_BAD_COMPRESSION_BUFFER = 0xc0000242
STATUS_USER_MAPPED_FILE = 0xc0000243
STATUS_AUDIT_FAILED = 0xc0000244
STATUS_TIMER_RESOLUTION_NOT_SET = 0xc0000245
STATUS_CONNECTION_COUNT_LIMIT = 0xc0000246
STATUS_LOGIN_TIME_RESTRICTION = 0xc0000247
STATUS_LOGIN_WKSTA_RESTRICTION = 0xc0000248
STATUS_IMAGE_MP_UP_MISMATCH = 0xc0000249
STATUS_INSUFFICIENT_LOGON_INFO = 0xc0000250
STATUS_BAD_DLL_ENTRYPOINT = 0xc0000251
STATUS_BAD_SERVICE_ENTRYPOINT = 0xc0000252
STATUS_LPC_REPLY_LOST = 0xc0000253
STATUS_IP_ADDRESS_CONFLICT1 = 0xc0000254
STATUS_IP_ADDRESS_CONFLICT2 = 0xc0000255
STATUS_REGISTRY_QUOTA_LIMIT = 0xc0000256
STATUS_PATH_NOT_COVERED = 0xc0000257
STATUS_NO_CALLBACK_ACTIVE = 0xc0000258
STATUS_LICENSE_QUOTA_EXCEEDED = 0xc0000259
STATUS_PWD_TOO_SHORT = 0xc000025a
STATUS_PWD_TOO_RECENT = 0xc000025b
STATUS_PWD_HISTORY_CONFLICT = 0xc000025c
STATUS_PLUGPLAY_NO_DEVICE = 0xc000025e
STATUS_UNSUPPORTED_COMPRESSION = 0xc000025f
STATUS_INVALID_HW_PROFILE = 0xc0000260
STATUS_INVALID_PLUGPLAY_DEVICE_PATH = 0xc0000261
STATUS_DRIVER_ORDINAL_NOT_FOUND = 0xc0000262
STATUS_DRIVER_ENTRYPOINT_NOT_FOUND = 0xc0000263
STATUS_RESOURCE_NOT_OWNED = 0xc0000264
STATUS_TOO_MANY_LINKS = 0xc0000265
STATUS_QUOTA_LIST_INCONSISTENT = 0xc0000266
STATUS_FILE_IS_OFFLINE = 0xc0000267
STATUS_EVALUATION_EXPIRATION = 0xc0000268
STATUS_ILLEGAL_DLL_RELOCATION = 0xc0000269
STATUS_LICENSE_VIOLATION = 0xc000026a
STATUS_DLL_INIT_FAILED_LOGOFF = 0xc000026b
STATUS_DRIVER_UNABLE_TO_LOAD = 0xc000026c
STATUS_DFS_UNAVAILABLE = 0xc000026d
STATUS_VOLUME_DISMOUNTED = 0xc000026e
STATUS_WX86_INTERNAL_ERROR = 0xc000026f
STATUS_WX86_FLOAT_STACK_CHECK = 0xc0000270
STATUS_VALIDATE_CONTINUE = 0xc0000271
STATUS_NO_MATCH = 0xc0000272
STATUS_NO_MORE_MATCHES = 0xc0000273
STATUS_NOT_A_REPARSE_POINT = 0xc0000275
STATUS_IO_REPARSE_TAG_INVALID = 0xc0000276
STATUS_IO_REPARSE_TAG_MISMATCH = 0xc0000277
STATUS_IO_REPARSE_DATA_INVALID = 0xc0000278
STATUS_IO_REPARSE_TAG_NOT_HANDLED = 0xc0000279
STATUS_REPARSE_POINT_NOT_RESOLVED = 0xc0000280
STATUS_DIRECTORY_IS_A_REPARSE_POINT = 0xc0000281
STATUS_RANGE_LIST_CONFLICT = 0xc0000282
STATUS_SOURCE_ELEMENT_EMPTY = 0xc0000283
STATUS_DESTINATION_ELEMENT_FULL = 0xc0000284
STATUS_ILLEGAL_ELEMENT_ADDRESS = 0xc0000285
STATUS_MAGAZINE_NOT_PRESENT = 0xc0000286
STATUS_REINITIALIZATION_NEEDED = 0xc0000287
STATUS_ENCRYPTION_FAILED = 0xc000028a
STATUS_DECRYPTION_FAILED = 0xc000028b
STATUS_RANGE_NOT_FOUND = 0xc000028c
STATUS_NO_RECOVERY_POLICY = 0xc000028d
STATUS_NO_EFS = 0xc000028e
STATUS_WRONG_EFS = 0xc000028f
STATUS_NO_USER_KEYS = 0xc0000290
STATUS_FILE_NOT_ENCRYPTED = 0xc0000291
STATUS_NOT_EXPORT_FORMAT = 0xc0000292
STATUS_FILE_ENCRYPTED = 0xc0000293
STATUS_WMI_GUID_NOT_FOUND = 0xc0000295
STATUS_WMI_INSTANCE_NOT_FOUND = 0xc0000296
STATUS_WMI_ITEMID_NOT_FOUND = 0xc0000297
STATUS_WMI_TRY_AGAIN = 0xc0000298
STATUS_SHARED_POLICY = 0xc0000299
STATUS_POLICY_OBJECT_NOT_FOUND = 0xc000029a
STATUS_POLICY_ONLY_IN_DS = 0xc000029b
STATUS_VOLUME_NOT_UPGRADED = 0xc000029c
STATUS_REMOTE_STORAGE_NOT_ACTIVE = 0xc000029d
STATUS_REMOTE_STORAGE_MEDIA_ERROR = 0xc000029e
STATUS_NO_TRACKING_SERVICE = 0xc000029f
STATUS_SERVER_SID_MISMATCH = 0xc00002a0
STATUS_DS_NO_ATTRIBUTE_OR_VALUE = 0xc00002a1
STATUS_DS_INVALID_ATTRIBUTE_SYNTAX = 0xc00002a2
STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED = 0xc00002a3
STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS = 0xc00002a4
STATUS_DS_BUSY = 0xc00002a5
STATUS_DS_UNAVAILABLE = 0xc00002a6
STATUS_DS_NO_RIDS_ALLOCATED = 0xc00002a7
STATUS_DS_NO_MORE_RIDS = 0xc00002a8
STATUS_DS_INCORRECT_ROLE_OWNER = 0xc00002a9
STATUS_DS_RIDMGR_INIT_ERROR = 0xc00002aa
STATUS_DS_OBJ_CLASS_VIOLATION = 0xc00002ab
STATUS_DS_CANT_ON_NON_LEAF = 0xc00002ac
STATUS_DS_CANT_ON_RDN = 0xc00002ad
STATUS_DS_CANT_MOD_OBJ_CLASS = 0xc00002ae
STATUS_DS_CROSS_DOM_MOVE_FAILED = 0xc00002af
STATUS_DS_GC_NOT_AVAILABLE = 0xc00002b0
STATUS_DIRECTORY_SERVICE_REQUIRED = 0xc00002b1
STATUS_REPARSE_ATTRIBUTE_CONFLICT = 0xc00002b2
STATUS_CANT_ENABLE_DENY_ONLY = 0xc00002b3
STATUS_FLOAT_MULTIPLE_FAULTS = 0xc00002b4
STATUS_FLOAT_MULTIPLE_TRAPS = 0xc00002b5
STATUS_DEVICE_REMOVED = 0xc00002b6
STATUS_JOURNAL_DELETE_IN_PROGRESS = 0xc00002b7
STATUS_JOURNAL_NOT_ACTIVE = 0xc00002b8
STATUS_NOINTERFACE = 0xc00002b9
STATUS_DS_ADMIN_LIMIT_EXCEEDED = 0xc00002c1
STATUS_DRIVER_FAILED_SLEEP = 0xc00002c2
STATUS_MUTUAL_AUTHENTICATION_FAILED = 0xc00002c3
STATUS_CORRUPT_SYSTEM_FILE = 0xc00002c4
STATUS_DATATYPE_MISALIGNMENT_ERROR = 0xc00002c5
STATUS_WMI_READ_ONLY = 0xc00002c6
STATUS_WMI_SET_FAILURE = 0xc00002c7
STATUS_COMMITMENT_MINIMUM = 0xc00002c8
STATUS_REG_NAT_CONSUMPTION = 0xc00002c9
STATUS_TRANSPORT_FULL = 0xc00002ca
STATUS_DS_SAM_INIT_FAILURE = 0xc00002cb
STATUS_ONLY_IF_CONNECTED = 0xc00002cc
STATUS_DS_SENSITIVE_GROUP_VIOLATION = 0xc00002cd
STATUS_PNP_RESTART_ENUMERATION = 0xc00002ce
STATUS_JOURNAL_ENTRY_DELETED = 0xc00002cf
STATUS_DS_CANT_MOD_PRIMARYGROUPID = 0xc00002d0
STATUS_SYSTEM_IMAGE_BAD_SIGNATURE = 0xc00002d1
STATUS_PNP_REBOOT_REQUIRED = 0xc00002d2
STATUS_POWER_STATE_INVALID = 0xc00002d3
STATUS_DS_INVALID_GROUP_TYPE = 0xc00002d4
STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = 0xc00002d5
STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = 0xc00002d6
STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = 0xc00002d7
STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = 0xc00002d8
STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = 0xc00002d9
STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = 0xc00002da
STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = 0xc00002db
STATUS_DS_HAVE_PRIMARY_MEMBERS = 0xc00002dc
STATUS_WMI_NOT_SUPPORTED = 0xc00002dd
STATUS_INSUFFICIENT_POWER = 0xc00002de
STATUS_SAM_NEED_BOOTKEY_PASSWORD = 0xc00002df
STATUS_SAM_NEED_BOOTKEY_FLOPPY = 0xc00002e0
STATUS_DS_CANT_START = 0xc00002e1
STATUS_DS_INIT_FAILURE = 0xc00002e2
STATUS_SAM_INIT_FAILURE = 0xc00002e3
STATUS_DS_GC_REQUIRED = 0xc00002e4
STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = 0xc00002e5
STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS = 0xc00002e6
STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = 0xc00002e7
STATUS_MULTIPLE_FAULT_VIOLATION = 0xc00002e8
STATUS_CURRENT_DOMAIN_NOT_ALLOWED = 0xc00002e9
STATUS_CANNOT_MAKE = 0xc00002ea
STATUS_SYSTEM_SHUTDOWN = 0xc00002eb
STATUS_DS_INIT_FAILURE_CONSOLE = 0xc00002ec
STATUS_DS_SAM_INIT_FAILURE_CONSOLE = 0xc00002ed
STATUS_UNFINISHED_CONTEXT_DELETED = 0xc00002ee
STATUS_NO_TGT_REPLY = 0xc00002ef
STATUS_OBJECTID_NOT_FOUND = 0xc00002f0
STATUS_NO_IP_ADDRESSES = 0xc00002f1
STATUS_WRONG_CREDENTIAL_HANDLE = 0xc00002f2
STATUS_CRYPTO_SYSTEM_INVALID = 0xc00002f3
STATUS_MAX_REFERRALS_EXCEEDED = 0xc00002f4
STATUS_MUST_BE_KDC = 0xc00002f5
STATUS_STRONG_CRYPTO_NOT_SUPPORTED = 0xc00002f6
STATUS_TOO_MANY_PRINCIPALS = 0xc00002f7
STATUS_NO_PA_DATA = 0xc00002f8
STATUS_PKINIT_NAME_MISMATCH = 0xc00002f9
STATUS_SMARTCARD_LOGON_REQUIRED = 0xc00002fa
STATUS_KDC_INVALID_REQUEST = 0xc00002fb
STATUS_KDC_UNABLE_TO_REFER = 0xc00002fc
STATUS_KDC_UNKNOWN_ETYPE = 0xc00002fd
STATUS_SHUTDOWN_IN_PROGRESS = 0xc00002fe
STATUS_SERVER_SHUTDOWN_IN_PROGRESS = 0xc00002ff
STATUS_NOT_SUPPORTED_ON_SBS = 0xc0000300
STATUS_WMI_GUID_DISCONNECTED = 0xc0000301
STATUS_WMI_ALREADY_DISABLED = 0xc0000302
STATUS_WMI_ALREADY_ENABLED = 0xc0000303
STATUS_MFT_TOO_FRAGMENTED = 0xc0000304
STATUS_COPY_PROTECTION_FAILURE = 0xc0000305
STATUS_CSS_AUTHENTICATION_FAILURE = 0xc0000306
STATUS_CSS_KEY_NOT_PRESENT = 0xc0000307
STATUS_CSS_KEY_NOT_ESTABLISHED = 0xc0000308
STATUS_CSS_SCRAMBLED_SECTOR = 0xc0000309
STATUS_CSS_REGION_MISMATCH = 0xc000030a
STATUS_CSS_RESETS_EXHAUSTED = 0xc000030b
STATUS_PKINIT_FAILURE = 0xc0000320
STATUS_SMARTCARD_SUBSYSTEM_FAILURE = 0xc0000321
STATUS_NO_KERB_KEY = 0xc0000322
STATUS_HOST_DOWN = 0xc0000350
STATUS_UNSUPPORTED_PREAUTH = 0xc0000351
STATUS_EFS_ALG_BLOB_TOO_BIG = 0xc0000352
STATUS_PORT_NOT_SET = 0xc0000353
STATUS_DEBUGGER_INACTIVE = 0xc0000354
STATUS_DS_VERSION_CHECK_FAILURE = 0xc0000355
STATUS_AUDITING_DISABLED = 0xc0000356
STATUS_PRENT4_MACHINE_ACCOUNT = 0xc0000357
STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = 0xc0000358
STATUS_INVALID_IMAGE_WIN_32 = 0xc0000359
STATUS_INVALID_IMAGE_WIN_64 = 0xc000035a
STATUS_BAD_BINDINGS = 0xc000035b
STATUS_NETWORK_SESSION_EXPIRED = 0xc000035c
STATUS_APPHELP_BLOCK = 0xc000035d
STATUS_ALL_SIDS_FILTERED = 0xc000035e
STATUS_NOT_SAFE_MODE_DRIVER = 0xc000035f
STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT = 0xc0000361
STATUS_ACCESS_DISABLED_BY_POLICY_PATH = 0xc0000362
STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER = 0xc0000363
STATUS_ACCESS_DISABLED_BY_POLICY_OTHER = 0xc0000364
STATUS_FAILED_DRIVER_ENTRY = 0xc0000365
STATUS_DEVICE_ENUMERATION_ERROR = 0xc0000366
STATUS_WAIT_FOR_OPLOCK = 0x00000367
STATUS_MOUNT_POINT_NOT_RESOLVED = 0xc0000368
STATUS_INVALID_DEVICE_OBJECT_PARAMETER = 0xc0000369
STATUS_MCA_OCCURED = 0xc000036a
STATUS_DRIVER_BLOCKED_CRITICAL = 0xc000036b
STATUS_DRIVER_BLOCKED = 0xc000036c
STATUS_DRIVER_DATABASE_ERROR = 0xc000036d
STATUS_SYSTEM_HIVE_TOO_LARGE = 0xc000036e
STATUS_INVALID_IMPORT_OF_NON_DLL = 0xc000036f
STATUS_SMARTCARD_WRONG_PIN = 0xc0000380
STATUS_SMARTCARD_CARD_BLOCKED = 0xc0000381
STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED = 0xc0000382
STATUS_SMARTCARD_NO_CARD = 0xc0000383
STATUS_SMARTCARD_NO_KEY_CONTAINER = 0xc0000384
STATUS_SMARTCARD_NO_CERTIFICATE = 0xc0000385
STATUS_SMARTCARD_NO_KEYSET = 0xc0000386
STATUS_SMARTCARD_IO_ERROR = 0xc0000387
STATUS_DOWNGRADE_DETECTED = 0xc0000388
STATUS_SMARTCARD_CERT_REVOKED = 0xc0000389
STATUS_ISSUING_CA_UNTRUSTED = 0xc000038a
STATUS_REVOCATION_OFFLINE_C = 0xc000038b
STATUS_PKINIT_CLIENT_FAILURE = 0xc000038c
STATUS_SMARTCARD_CERT_EXPIRED = 0xc000038d
STATUS_DRIVER_FAILED_PRIOR_UNLOAD = 0xc000038e
STATUS_SMARTCARD_SILENT_CONTEXT = 0xc000038f
STATUS_PER_USER_TRUST_QUOTA_EXCEEDED = 0xc0000401
STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED = 0xc0000402
STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED = 0xc0000403
STATUS_DS_NAME_NOT_UNIQUE = 0xc0000404
STATUS_DS_DUPLICATE_ID_FOUND = 0xc0000405
STATUS_DS_GROUP_CONVERSION_ERROR = 0xc0000406
STATUS_VOLSNAP_PREPARE_HIBERNATE = 0xc0000407
STATUS_USER2USER_REQUIRED = 0xc0000408
STATUS_STACK_BUFFER_OVERRUN = 0xc0000409
STATUS_NO_S4U_PROT_SUPPORT = 0xc000040a
STATUS_CROSSREALM_DELEGATION_FAILURE = 0xc000040b
STATUS_REVOCATION_OFFLINE_KDC = 0xc000040c
STATUS_ISSUING_CA_UNTRUSTED_KDC = 0xc000040d
STATUS_KDC_CERT_EXPIRED = 0xc000040e
STATUS_KDC_CERT_REVOKED = 0xc000040f
STATUS_PARAMETER_QUOTA_EXCEEDED = 0xc0000410
STATUS_HIBERNATION_FAILURE = 0xc0000411
STATUS_DELAY_LOAD_FAILED = 0xc0000412
STATUS_AUTHENTICATION_FIREWALL_FAILED = 0xc0000413
STATUS_VDM_DISALLOWED = 0xc0000414
STATUS_HUNG_DISPLAY_DRIVER_THREAD = 0xc0000415
STATUS_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = 0xc0000416
STATUS_INVALID_CRUNTIME_PARAMETER = 0xc0000417
STATUS_NTLM_BLOCKED = 0xc0000418
STATUS_ASSERTION_FAILURE = 0xc0000420
STATUS_VERIFIER_STOP = 0xc0000421
STATUS_CALLBACK_POP_STACK = 0xc0000423
STATUS_INCOMPATIBLE_DRIVER_BLOCKED = 0xc0000424
STATUS_HIVE_UNLOADED = 0xc0000425
STATUS_COMPRESSION_DISABLED = 0xc0000426
STATUS_FILE_SYSTEM_LIMITATION = 0xc0000427
STATUS_INVALID_IMAGE_HASH = 0xc0000428
STATUS_NOT_CAPABLE = 0xc0000429
STATUS_REQUEST_OUT_OF_SEQUENCE = 0xc000042a
STATUS_IMPLEMENTATION_LIMIT = 0xc000042b
STATUS_ELEVATION_REQUIRED = 0xc000042c
STATUS_BEYOND_VDL = 0xc0000432
STATUS_ENCOUNTERED_WRITE_IN_PROGRESS = 0xc0000433
STATUS_PTE_CHANGED = 0xc0000434
STATUS_PURGE_FAILED = 0xc0000435
STATUS_CRED_REQUIRES_CONFIRMATION = 0xc0000440
STATUS_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = 0xc0000441
STATUS_CS_ENCRYPTION_UNSUPPORTED_SERVER = 0xc0000442
STATUS_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = 0xc0000443
STATUS_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = 0xc0000444
STATUS_CS_ENCRYPTION_FILE_NOT_CSE = 0xc0000445
STATUS_INVALID_LABEL = 0xc0000446
STATUS_DRIVER_PROCESS_TERMINATED = 0xc0000450
STATUS_AMBIGUOUS_SYSTEM_DEVICE = 0xc0000451
STATUS_SYSTEM_DEVICE_NOT_FOUND = 0xc0000452
STATUS_RESTART_BOOT_APPLICATION = 0xc0000453
STATUS_INVALID_TASK_NAME = 0xc0000500
STATUS_INVALID_TASK_INDEX = 0xc0000501
STATUS_THREAD_ALREADY_IN_TASK = 0xc0000502
STATUS_CALLBACK_BYPASS = 0xc0000503
STATUS_PORT_CLOSED = 0xc0000700
STATUS_MESSAGE_LOST = 0xc0000701
STATUS_INVALID_MESSAGE = 0xc0000702
STATUS_REQUEST_CANCELED = 0xc0000703
STATUS_RECURSIVE_DISPATCH = 0xc0000704
STATUS_LPC_RECEIVE_BUFFER_EXPECTED = 0xc0000705
STATUS_LPC_INVALID_CONNECTION_USAGE = 0xc0000706
STATUS_LPC_REQUESTS_NOT_ALLOWED = 0xc0000707
STATUS_RESOURCE_IN_USE = 0xc0000708
STATUS_HARDWARE_MEMORY_ERROR = 0xc0000709
STATUS_THREADPOOL_HANDLE_EXCEPTION = 0xc000070a
STATUS_THREADPOOL_SET_EVENT_ON_COMPLETION_FAILED = 0xc000070b
STATUS_THREADPOOL_RELEASE_SEMAPHORE_ON_COMPLETION_FAILED = 0xc000070c
STATUS_THREADPOOL_RELEASE_MUTEX_ON_COMPLETION_FAILED = 0xc000070d
STATUS_THREADPOOL_FREE_LIBRARY_ON_COMPLETION_FAILED = 0xc000070e
STATUS_THREADPOOL_RELEASED_DURING_OPERATION = 0xc000070f
STATUS_CALLBACK_RETURNED_WHILE_IMPERSONATING = 0xc0000710
STATUS_APC_RETURNED_WHILE_IMPERSONATING = 0xc0000711
STATUS_PROCESS_IS_PROTECTED = 0xc0000712
STATUS_MCA_EXCEPTION = 0xc0000713
STATUS_CERTIFICATE_MAPPING_NOT_UNIQUE = 0xc0000714
STATUS_SYMLINK_CLASS_DISABLED = 0xc0000715
STATUS_INVALID_IDN_NORMALIZATION = 0xc0000716
STATUS_NO_UNICODE_TRANSLATION = 0xc0000717
STATUS_ALREADY_REGISTERED = 0xc0000718
STATUS_CONTEXT_MISMATCH = 0xc0000719
STATUS_PORT_ALREADY_HAS_COMPLETION_LIST = 0xc000071a
STATUS_CALLBACK_RETURNED_THREAD_PRIORITY = 0xc000071b
STATUS_INVALID_THREAD = 0xc000071c
STATUS_CALLBACK_RETURNED_TRANSACTION = 0xc000071d
STATUS_CALLBACK_RETURNED_LDR_LOCK = 0xc000071e
STATUS_CALLBACK_RETURNED_LANG = 0xc000071f
STATUS_CALLBACK_RETURNED_PRI_BACK = 0xc0000720
STATUS_CALLBACK_RETURNED_THREAD_AFFINITY = 0xc0000721
STATUS_DISK_REPAIR_DISABLED = 0xc0000800
STATUS_DS_DOMAIN_RENAME_IN_PROGRESS = 0xc0000801
STATUS_DISK_QUOTA_EXCEEDED = 0xc0000802
STATUS_CONTENT_BLOCKED = 0xc0000804
STATUS_BAD_CLUSTERS = 0xc0000805
STATUS_VOLUME_DIRTY = 0xc0000806
STATUS_FILE_CHECKED_OUT = 0xc0000901
STATUS_CHECKOUT_REQUIRED = 0xc0000902
STATUS_BAD_FILE_TYPE = 0xc0000903
STATUS_FILE_TOO_LARGE = 0xc0000904
STATUS_FORMS_AUTH_REQUIRED = 0xc0000905
STATUS_VIRUS_INFECTED = 0xc0000906
STATUS_VIRUS_DELETED = 0xc0000907
STATUS_BAD_MCFG_TABLE = 0xc0000908
STATUS_WOW_ASSERTION = 0xc0009898
RPC_NT_INVALID_STRING_BINDING = 0xc0020001
RPC_NT_WRONG_KIND_OF_BINDING = 0xc0020002
RPC_NT_INVALID_BINDING = 0xc0020003
RPC_NT_PROTSEQ_NOT_SUPPORTED = 0xc0020004
RPC_NT_INVALID_RPC_PROTSEQ = 0xc0020005
RPC_NT_INVALID_STRING_UUID = 0xc0020006
RPC_NT_INVALID_ENDPOINT_FORMAT = 0xc0020007
RPC_NT_INVALID_NET_ADDR = 0xc0020008
RPC_NT_NO_ENDPOINT_FOUND = 0xc0020009
RPC_NT_INVALID_TIMEOUT = 0xc002000a
RPC_NT_OBJECT_NOT_FOUND = 0xc002000b
RPC_NT_ALREADY_REGISTERED = 0xc002000c
RPC_NT_TYPE_ALREADY_REGISTERED = 0xc002000d
RPC_NT_ALREADY_LISTENING = 0xc002000e
RPC_NT_NO_PROTSEQS_REGISTERED = 0xc002000f
RPC_NT_NOT_LISTENING = 0xc0020010
RPC_NT_UNKNOWN_MGR_TYPE = 0xc0020011
RPC_NT_UNKNOWN_IF = 0xc0020012
RPC_NT_NO_BINDINGS = 0xc0020013
RPC_NT_NO_PROTSEQS = 0xc0020014
RPC_NT_CANT_CREATE_ENDPOINT = 0xc0020015
RPC_NT_OUT_OF_RESOURCES = 0xc0020016
RPC_NT_SERVER_UNAVAILABLE = 0xc0020017
RPC_NT_SERVER_TOO_BUSY = 0xc0020018
RPC_NT_INVALID_NETWORK_OPTIONS = 0xc0020019
RPC_NT_NO_CALL_ACTIVE = 0xc002001a
RPC_NT_CALL_FAILED = 0xc002001b
RPC_NT_CALL_FAILED_DNE = 0xc002001c
RPC_NT_PROTOCOL_ERROR = 0xc002001d
RPC_NT_UNSUPPORTED_TRANS_SYN = 0xc002001f
RPC_NT_UNSUPPORTED_TYPE = 0xc0020021
RPC_NT_INVALID_TAG = 0xc0020022
RPC_NT_INVALID_BOUND = 0xc0020023
RPC_NT_NO_ENTRY_NAME = 0xc0020024
RPC_NT_INVALID_NAME_SYNTAX = 0xc0020025
RPC_NT_UNSUPPORTED_NAME_SYNTAX = 0xc0020026
RPC_NT_UUID_NO_ADDRESS = 0xc0020028
RPC_NT_DUPLICATE_ENDPOINT = 0xc0020029
RPC_NT_UNKNOWN_AUTHN_TYPE = 0xc002002a
RPC_NT_MAX_CALLS_TOO_SMALL = 0xc002002b
RPC_NT_STRING_TOO_LONG = 0xc002002c
RPC_NT_PROTSEQ_NOT_FOUND = 0xc002002d
RPC_NT_PROCNUM_OUT_OF_RANGE = 0xc002002e
RPC_NT_BINDING_HAS_NO_AUTH = 0xc002002f
RPC_NT_UNKNOWN_AUTHN_SERVICE = 0xc0020030
RPC_NT_UNKNOWN_AUTHN_LEVEL = 0xc0020031
RPC_NT_INVALID_AUTH_IDENTITY = 0xc0020032
RPC_NT_UNKNOWN_AUTHZ_SERVICE = 0xc0020033
EPT_NT_INVALID_ENTRY = 0xc0020034
EPT_NT_CANT_PERFORM_OP = 0xc0020035
EPT_NT_NOT_REGISTERED = 0xc0020036
RPC_NT_NOTHING_TO_EXPORT = 0xc0020037
RPC_NT_INCOMPLETE_NAME = 0xc0020038
RPC_NT_INVALID_VERS_OPTION = 0xc0020039
RPC_NT_NO_MORE_MEMBERS = 0xc002003a
RPC_NT_NOT_ALL_OBJS_UNEXPORTED = 0xc002003b
RPC_NT_INTERFACE_NOT_FOUND = 0xc002003c
RPC_NT_ENTRY_ALREADY_EXISTS = 0xc002003d
RPC_NT_ENTRY_NOT_FOUND = 0xc002003e
RPC_NT_NAME_SERVICE_UNAVAILABLE = 0xc002003f
RPC_NT_INVALID_NAF_ID = 0xc0020040
RPC_NT_CANNOT_SUPPORT = 0xc0020041
RPC_NT_NO_CONTEXT_AVAILABLE = 0xc0020042
RPC_NT_INTERNAL_ERROR = 0xc0020043
RPC_NT_ZERO_DIVIDE = 0xc0020044
RPC_NT_ADDRESS_ERROR = 0xc0020045
RPC_NT_FP_DIV_ZERO = 0xc0020046
RPC_NT_FP_UNDERFLOW = 0xc0020047
RPC_NT_FP_OVERFLOW = 0xc0020048
RPC_NT_CALL_IN_PROGRESS = 0xc0020049
RPC_NT_NO_MORE_BINDINGS = 0xc002004a
RPC_NT_GROUP_MEMBER_NOT_FOUND = 0xc002004b
EPT_NT_CANT_CREATE = 0xc002004c
RPC_NT_INVALID_OBJECT = 0xc002004d
RPC_NT_NO_INTERFACES = 0xc002004f
RPC_NT_CALL_CANCELLED = 0xc0020050
RPC_NT_BINDING_INCOMPLETE = 0xc0020051
RPC_NT_COMM_FAILURE = 0xc0020052
RPC_NT_UNSUPPORTED_AUTHN_LEVEL = 0xc0020053
RPC_NT_NO_PRINC_NAME = 0xc0020054
RPC_NT_NOT_RPC_ERROR = 0xc0020055
RPC_NT_SEC_PKG_ERROR = 0xc0020057
RPC_NT_NOT_CANCELLED = 0xc0020058
RPC_NT_INVALID_ASYNC_HANDLE = 0xc0020062
RPC_NT_INVALID_ASYNC_CALL = 0xc0020063
RPC_NT_NO_MORE_ENTRIES = 0xc0030001
RPC_NT_SS_CHAR_TRANS_OPEN_FAIL = 0xc0030002
RPC_NT_SS_CHAR_TRANS_SHORT_FILE = 0xc0030003
RPC_NT_SS_IN_NULL_CONTEXT = 0xc0030004
RPC_NT_SS_CONTEXT_MISMATCH = 0xc0030005
RPC_NT_SS_CONTEXT_DAMAGED = 0xc0030006
RPC_NT_SS_HANDLES_MISMATCH = 0xc0030007
RPC_NT_SS_CANNOT_GET_CALL_HANDLE = 0xc0030008
RPC_NT_NULL_REF_POINTER = 0xc0030009
RPC_NT_ENUM_VALUE_OUT_OF_RANGE = 0xc003000a
RPC_NT_BYTE_COUNT_TOO_SMALL = 0xc003000b
RPC_NT_BAD_STUB_DATA = 0xc003000c
RPC_NT_INVALID_ES_ACTION = 0xc0030059
RPC_NT_WRONG_ES_VERSION = 0xc003005a
RPC_NT_WRONG_STUB_VERSION = 0xc003005b
RPC_NT_INVALID_PIPE_OBJECT = 0xc003005c
RPC_NT_INVALID_PIPE_OPERATION = 0xc003005d
RPC_NT_WRONG_PIPE_VERSION = 0xc003005e
RPC_NT_PIPE_CLOSED = 0xc003005f
RPC_NT_PIPE_DISCIPLINE_ERROR = 0xc0030060
RPC_NT_PIPE_EMPTY = 0xc0030061
STATUS_PNP_BAD_MPS_TABLE = 0xc0040035
STATUS_PNP_TRANSLATION_FAILED = 0xc0040036
STATUS_PNP_IRQ_TRANSLATION_FAILED = 0xc0040037
STATUS_PNP_INVALID_ID = 0xc0040038
STATUS_CTX_WINSTATION_NAME_INVALID = 0xc00a0001
STATUS_CTX_INVALID_PD = 0xc00a0002
STATUS_CTX_PD_NOT_FOUND = 0xc00a0003
STATUS_CTX_CLOSE_PENDING = 0xc00a0006
STATUS_CTX_NO_OUTBUF = 0xc00a0007
STATUS_CTX_MODEM_INF_NOT_FOUND = 0xc00a0008
STATUS_CTX_INVALID_MODEMNAME = 0xc00a0009
STATUS_CTX_RESPONSE_ERROR = 0xc00a000a
STATUS_CTX_MODEM_RESPONSE_TIMEOUT = 0xc00a000b
STATUS_CTX_MODEM_RESPONSE_NO_CARRIER = 0xc00a000c
STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE = 0xc00a000d
STATUS_CTX_MODEM_RESPONSE_BUSY = 0xc00a000e
STATUS_CTX_MODEM_RESPONSE_VOICE = 0xc00a000f
STATUS_CTX_TD_ERROR = 0xc00a0010
STATUS_CTX_LICENSE_CLIENT_INVALID = 0xc00a0012
STATUS_CTX_LICENSE_NOT_AVAILABLE = 0xc00a0013
STATUS_CTX_LICENSE_EXPIRED = 0xc00a0014
STATUS_CTX_WINSTATION_NOT_FOUND = 0xc00a0015
STATUS_CTX_WINSTATION_NAME_COLLISION = 0xc00a0016
STATUS_CTX_WINSTATION_BUSY = 0xc00a0017
STATUS_CTX_BAD_VIDEO_MODE = 0xc00a0018
STATUS_CTX_GRAPHICS_INVALID = 0xc00a0022
STATUS_CTX_NOT_CONSOLE = 0xc00a0024
STATUS_CTX_CLIENT_QUERY_TIMEOUT = 0xc00a0026
STATUS_CTX_CONSOLE_DISCONNECT = 0xc00a0027
STATUS_CTX_CONSOLE_CONNECT = 0xc00a0028
STATUS_CTX_SHADOW_DENIED = 0xc00a002a
STATUS_CTX_WINSTATION_ACCESS_DENIED = 0xc00a002b
STATUS_CTX_INVALID_WD = 0xc00a002e
STATUS_CTX_WD_NOT_FOUND = 0xc00a002f
STATUS_CTX_SHADOW_INVALID = 0xc00a0030
STATUS_CTX_SHADOW_DISABLED = 0xc00a0031
STATUS_RDP_PROTOCOL_ERROR = 0xc00a0032
STATUS_CTX_CLIENT_LICENSE_NOT_SET = 0xc00a0033
STATUS_CTX_CLIENT_LICENSE_IN_USE = 0xc00a0034
STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE = 0xc00a0035
STATUS_CTX_SHADOW_NOT_RUNNING = 0xc00a0036
STATUS_CTX_LOGON_DISABLED = 0xc00a0037
STATUS_CTX_SECURITY_LAYER_ERROR = 0xc00a0038
STATUS_CLUSTER_INVALID_NODE = 0xc0130001
STATUS_CLUSTER_NODE_EXISTS = 0xc0130002
STATUS_CLUSTER_JOIN_IN_PROGRESS = 0xc0130003
STATUS_CLUSTER_NODE_NOT_FOUND = 0xc0130004
STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND = 0xc0130005
STATUS_CLUSTER_NETWORK_EXISTS = 0xc0130006
STATUS_CLUSTER_NETWORK_NOT_FOUND = 0xc0130007
STATUS_CLUSTER_NETINTERFACE_EXISTS = 0xc0130008
STATUS_CLUSTER_NETINTERFACE_NOT_FOUND = 0xc0130009
STATUS_CLUSTER_INVALID_REQUEST = 0xc013000a
STATUS_CLUSTER_INVALID_NETWORK_PROVIDER = 0xc013000b
STATUS_CLUSTER_NODE_DOWN = 0xc013000c
STATUS_CLUSTER_NODE_UNREACHABLE = 0xc013000d
STATUS_CLUSTER_NODE_NOT_MEMBER = 0xc013000e
STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS = 0xc013000f
STATUS_CLUSTER_INVALID_NETWORK = 0xc0130010
STATUS_CLUSTER_NO_NET_ADAPTERS = 0xc0130011
STATUS_CLUSTER_NODE_UP = 0xc0130012
STATUS_CLUSTER_NODE_PAUSED = 0xc0130013
STATUS_CLUSTER_NODE_NOT_PAUSED = 0xc0130014
STATUS_CLUSTER_NO_SECURITY_CONTEXT = 0xc0130015
STATUS_CLUSTER_NETWORK_NOT_INTERNAL = 0xc0130016
STATUS_CLUSTER_POISONED = 0xc0130017
STATUS_SXS_SECTION_NOT_FOUND = 0xc0150001
STATUS_SXS_CANT_GEN_ACTCTX = 0xc0150002
STATUS_SXS_INVALID_ACTCTXDATA_FORMAT = 0xc0150003
STATUS_SXS_ASSEMBLY_NOT_FOUND = 0xc0150004
STATUS_SXS_MANIFEST_FORMAT_ERROR = 0xc0150005
STATUS_SXS_MANIFEST_PARSE_ERROR = 0xc0150006
STATUS_SXS_ACTIVATION_CONTEXT_DISABLED = 0xc0150007
STATUS_SXS_KEY_NOT_FOUND = 0xc0150008
STATUS_SXS_VERSION_CONFLICT = 0xc0150009
STATUS_SXS_WRONG_SECTION_TYPE = 0xc015000a
STATUS_SXS_THREAD_QUERIES_DISABLED = 0xc015000b
STATUS_SXS_ASSEMBLY_MISSING = 0xc015000c
STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET = 0xc015000e
STATUS_SXS_EARLY_DEACTIVATION = 0xc015000f
STATUS_SXS_INVALID_DEACTIVATION = 0xc0150010
STATUS_SXS_MULTIPLE_DEACTIVATION = 0xc0150011
STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = 0xc0150012
STATUS_SXS_PROCESS_TERMINATION_REQUESTED = 0xc0150013
STATUS_SXS_CORRUPT_ACTIVATION_STACK = 0xc0150014
STATUS_SXS_CORRUPTION = 0xc0150015
STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = 0xc0150016
STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = 0xc0150017
STATUS_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = 0xc0150018
STATUS_SXS_IDENTITY_PARSE_ERROR = 0xc0150019
STATUS_SXS_COMPONENT_STORE_CORRUPT = 0xc015001a
STATUS_SXS_FILE_HASH_MISMATCH = 0xc015001b
STATUS_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = 0xc015001c
STATUS_SXS_IDENTITIES_DIFFERENT = 0xc015001d
STATUS_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = 0xc015001e
STATUS_SXS_FILE_NOT_PART_OF_ASSEMBLY = 0xc015001f
STATUS_ADVANCED_INSTALLER_FAILED = 0xc0150020
STATUS_XML_ENCODING_MISMATCH = 0xc0150021
STATUS_SXS_MANIFEST_TOO_BIG = 0xc0150022
STATUS_SXS_SETTING_NOT_REGISTERED = 0xc0150023
STATUS_SXS_TRANSACTION_CLOSURE_INCOMPLETE = 0xc0150024
STATUS_SXS_PRIMITIVE_INSTALLER_FAILED = 0xc0150025
STATUS_GENERIC_COMMAND_FAILED = 0xc0150026
STATUS_SXS_FILE_HASH_MISSING = 0xc0150027
DBG_EXCEPTION_HANDLED = 0x00010001
DBG_CONTINUE = 0x00010002
DBG_TERMINATE_THREAD = 0x40010003
DBG_TERMINATE_PROCESS = 0x40010004
DBG_CONTROL_C = 0x40010005
DBG_CONTROL_BREAK = 0x40010008
DBG_COMMAND_EXCEPTION = 0x40010009
DBG_EXCEPTION_NOT_HANDLED = 0x80010001
STATUS_SUCCESS = 0x00000000

########NEW FILE########
__FILENAME__ = dns

import vstruct
from vstruct.primitives import *

DNS_FLAG_RESPONSE       = 0x8000
DNS_FLAG_AUTHORITATIVE  = 0x0400

DNS_TYPE_A     = 1
DNS_TYPE_CNAME = 5

DNS_CLASS_IN   = 1

class DnsNamePart(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.length = v_uint8()
        self.namepart = v_str()

    def pcb_length(self):
        size = self.length
        if size == 0xc0: size = 1 # FIXME offsets for name...
        self.vsGetField('namepart').vsSetLength(size)

    def isNameTerm(self):
        if self.length == 0:
            return True
        if self.length == 0xc0:
            return True
        return False

class DnsName(vstruct.VArray):

    def __init__(self):
        vstruct.VStruct.__init__(self)

    def getFullName(self, dnspkt):
        r = []
        for fname,fobj in self.vsGetFields():
            if fobj.length == 0xc0:
                newn = DnsName()
                # FIXME redundant parsing...
                newn.vsParse(dnspkt, ord(fobj.namepart))
                r.append( newn.getFullName(dnspkt) )
            else:
                r.append(fobj.namepart)
        return '.'.join(r)

    def vsParse(self, bytes, offset=0):
        self.vsClearFields()
        while offset < len(bytes):
            np = DnsNamePart()
            offset = np.vsParse(bytes, offset=offset)
            self.vsAddElement(np)
            if np.isNameTerm():
                break
        return offset

class DnsQuery(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.qname  = DnsName()
        self.qtype  = v_uint16(bigend=True)
        self.qclass = v_uint16(bigend=True)

class DnsQueryArray(vstruct.VArray):

    def __init__(self, reccnt):
        vstruct.VArray.__init__(self)
        for i in xrange(reccnt):
            self.vsAddElement( DnsQuery() )

class DnsAnswer(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.qname      = DnsName()
        self.qtype      = v_uint16(bigend=True)
        self.qclass     = v_uint16(bigend=True)
        self.qttl       = v_uint32(bigend=True)
        self.dlength    = v_uint16(bigend=True)
        self.qdata      = v_bytes()

    def pcb_dlength(self):
        size = self.dlength
        self.vsGetField('qdata').vsSetLength(size)

class DnsAnswerArray(vstruct.VArray):

    def __init__(self, reccnt):
        vstruct.VArray.__init__(self)
        for i in xrange(reccnt):
            self.vsAddElement( DnsAnswer() )

class DnsPacket(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        #self.length   = v_uint16(bigend=True)
        self.transid  = v_uint16(bigend=True)
        self.flags    = v_uint16(bigend=True)
        self.ques_cnt = v_uint16(bigend=True)
        self.answ_cnt = v_uint16(bigend=True)
        self.auth_cnt = v_uint16(bigend=True)
        self.addt_cnt = v_uint16(bigend=True)
        self.records  = vstruct.VStruct()
        self.records.queries = DnsQueryArray(0)
        self.records.answers = DnsAnswerArray(0)
        self.records.authns  = DnsAnswerArray(0)
        self.records.addtl   = DnsAnswerArray(0)

    def pcb_ques_cnt(self):
        self.records.queries = DnsQueryArray( self.ques_cnt )

    def pcb_answ_cnt(self):
        self.records.answers = DnsAnswerArray( self.answ_cnt )

    def pcb_auth_cnt(self):
        self.records.authns = DnsAnswerArray( self.auth_cnt )

    def pcb_addt_cnt(self):
        self.records.addtl = DnsAnswerArray( self.addt_cnt )


########NEW FILE########
__FILENAME__ = elf
import vstruct
from vstruct.primitives import *

EI_NIDENT = 4
EI_PADLEN = 7

class Elf32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e_ident       = v_bytes(EI_NIDENT)
        self.e_class       = v_uint8()
        self.e_data        = v_uint8()
        self.e_fileversion = v_uint8()
        self.e_osabi       = v_uint8()
        self.e_abiversio   = v_uint8()
        self.e_pad         = v_bytes(EI_PADLEN)
        self.e_type        = v_uint16()
        self.e_machine     = v_uint16()
        self.e_version     = v_uint32()
        self.e_entry       = v_uint32()
        self.e_phoff       = v_uint32()
        self.e_shoff       = v_uint32()
        self.e_flags       = v_uint32()
        self.e_ehsize      = v_uint16()
        self.e_phentsize   = v_uint16()
        self.e_phnum       = v_uint16()
        self.e_shentsize   = v_uint16()
        self.e_shnum       = v_uint16()
        self.e_shstrndx    = v_uint16()

class Elf32Section(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.sh_name      = v_uint32()
        self.sh_type      = v_uint32()
        self.sh_flags     = v_uint32()
        self.sh_addr      = v_uint32()
        self.sh_offset    = v_uint32()
        self.sh_size      = v_uint32()
        self.sh_link      = v_uint32()
        self.sh_info      = v_uint32()
        self.sh_addralign = v_uint32()
        self.sh_entsize = v_uint32()

class Elf32Pheader(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.p_type   = v_uint32()
        self.p_offset = v_uint32()
        self.p_vaddr  = v_uint32()
        self.p_paddr  = v_uint32()
        self.p_filesz = v_uint32()
        self.p_memsz  = v_uint32()
        self.p_flags  = v_uint32()
        self.p_align  = v_uint32()

class Elf32Reloc(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.r_offset = v_ptr32()
        self.r_info   = v_uint32()

class Elf32Reloca(Elf32Reloc):
    def __init__(self):
        Elf32Reloc.__init__(self)
        self.r_addend = v_uint32()

class Elf32Symbol(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.st_name  = v_uint32()
        self.st_value = v_uint32()
        self.st_size  = v_uint32()
        self.st_info  = v_uint8()
        self.st_other = v_uint8()
        self.st_shndx = v_uint16()

class Elf32Dynamic(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.d_tag   = v_uint32()
        self.d_value = v_uint32()


class Elf64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e_ident       = v_bytes(EI_NIDENT)
        self.e_class       = v_uint8()
        self.e_data        = v_uint8()
        self.e_fileversion = v_uint8()
        self.e_osabi       = v_uint8()
        self.e_abiversio   = v_uint8()
        self.e_pad         = v_bytes(EI_PADLEN)
        self.e_type        = v_uint16()
        self.e_machine     = v_uint16()
        self.e_version     = v_uint32()
        self.e_entry       = v_uint64()
        self.e_phoff       = v_uint64()
        self.e_shoff       = v_uint64()
        self.e_flags       = v_uint32()
        self.e_ehsize      = v_uint16()
        self.e_phentsize   = v_uint16()
        self.e_phnum       = v_uint16()
        self.e_shentsize   = v_uint16()
        self.e_shnum       = v_uint16()
        self.e_shstrndx    = v_uint16()

class Elf64Section(Elf32Section):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.sh_name      = v_uint32()
        self.sh_type      = v_uint32()
        self.sh_flags     = v_uint64()
        self.sh_addr      = v_uint64()
        self.sh_offset    = v_uint64()
        self.sh_size      = v_uint64()
        self.sh_link      = v_uint32()
        self.sh_info      = v_uint32()
        self.sh_addralign = v_uint64()
        self.sh_entsize   = v_uint64()

class Elf64Pheader(Elf32Pheader):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.p_type   = v_uint32()
        self.p_flags  = v_uint32()
        self.p_offset = v_uint64()
        self.p_vaddr  = v_uint64()
        self.p_paddr  = v_uint64()
        self.p_filesz = v_uint64()
        self.p_memsz  = v_uint64()
        self.p_align  = v_uint64()


class Elf64Reloc(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.r_offset = v_ptr64()
        self.r_info   = v_uint64()

class Elf64Reloca(Elf64Reloc):
    def __init__(self):
        #Elf64Reloc.__init__(self)
        vstruct.VStruct.__init__(self)
        self.r_offset = v_uint64()
        self.r_info   = v_uint64()
        self.r_addend = v_uint64()

class Elf64Symbol(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.st_name  = v_uint32()
        self.st_info  = v_uint8()
        self.st_other = v_uint8()
        self.st_shndx = v_uint16()
        self.st_value = v_uint64()
        self.st_size  = v_uint64()

class Elf64Dynamic(Elf32Dynamic):
    pass


########NEW FILE########
__FILENAME__ = gif

import vstruct
from vstruct.primitives import *

GIF_F_HAS_CMAP  = 0x80
GIF_F_BPP_MASK  = 0x07

GIF_IMG_SEP     = ','

class GIF_FILE_HEADER(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.magic      = v_bytes(size=6)
        self.width      = v_uint16()
        self.height     = v_uint16()
        self.flags      = v_uint8()
        self.bgcolor    = v_uint8()
        self.zero       = v_uint8()

class RGB(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.red    = v_uint8()
        self.green  = v_uint8()
        self.blue   = v_uint8()

class GIF_IMAGE_DESCRIPTOR(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.sep        = v_uint8()
        self.img_left   = v_uint16()
        self.img_top    = v_uint16()
        self.img_width  = v_uint16()
        self.img_height = v_uint16()
        self.flags      = v_uing8()

class GIF8XA(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)

    def isValidGif(self):
        if self.header.magic not in ('GIF87a', 'GIF89a'):
            return False
        if self.header.zero != 0:
            return False

    def vsParse(self, bytes, offset):


        # FIXME this is not functional yet...

        self.vsClearFields()
        self.header = GIF_FILE_HEADER()
        offset = self.header.vsParse(bytes, offset)

        # Do we have a global color table?
        if self.header.flags & GIF_F_HAS_CMAP:
            bits_per_pixel = (self.header.flags & GIF_F_BPP_MASK) + 1
            self.gct = vstruct.VStruct()
            for i in xrange(2**bits_per_pixel):
                self.gct.vsAddField('color%d' % i, RGB())

            offset = self.gct.vsParse(bytes, offset)

        self.images = vstruct.VStruct()

        imgidx = 0
        while bytes[offset] == GIF_IMG_SEP:
            img = vstruct.VStruct()

            img.descriptor = GIF_IMAGE_DESCRIPTOR()
            offset = img.descriptor.vsParse(bytes, offset)

            if img.descriptor.flags & GIF_F_HAS_CMAP:
                bits_per_pixel = (img.descriptor.flags & GIF_F_BPP_MASK) + 1
                img.cmap = vstruct.VStruct()

                for i in xrange(2**bits_per_pixel):
                    img.cmap.vsAddField('color%d' % i, RGB())

                offset = img.cmap.vsParse(bytes, offset)


########NEW FILE########
__FILENAME__ = inet
'''
Datalink / Network / Transport layer headers
'''
import socket
import struct

import vstruct
from vstruct.primitives import *

ETH_P_IP    = 0x0800

IPPROTO_ICMP    = 1
IPPROTO_TCP     = 6
IPPROTO_UDP     = 17
IPPROTO_IPV6    = 41

TCP_F_FIN  = 0x01
TCP_F_SYN  = 0x02
TCP_F_RST  = 0x04
TCP_F_PUSH = 0x08
TCP_F_ACK  = 0x10
TCP_F_URG  = 0x20
TCP_F_ECE  = 0x40
TCP_F_CWR  = 0x80

# Useful combinations...
TCP_F_SYNACK = (TCP_F_SYN | TCP_F_ACK)

def reprIPv4Addr(addr):
    bytes = struct.pack('>I', addr)
    return socket.inet_ntoa(bytes)

def decIPv4Addr(addrstr):
    bytes = socket.inet_aton(addrstr)
    return struct.unpack('>I', bytes)[0]

class IPv4Address(v_uint32):

    def __init__(self, value=0):
        v_uint32.__init__(self, value=value, bigend=True)

    def __repr__(self):
        bytes = struct.pack('>I', self._vs_value)
        return socket.inet_ntop(socket.AF_INET, bytes)

class ETHERII(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.destmac    = v_bytes(size=6)
        self.srcmac     = v_bytes(size=6)
        self.etype      = v_uint16(bigend=True)

class IPv4(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.veriphl    = v_uint8()
        self.tos        = v_uint8()
        self.totlen     = v_uint16(bigend=True)
        self.ipid       = v_uint16(bigend=True)
        self.flagfrag   = v_uint16(bigend=True)
        self.ttl        = v_uint8()
        self.proto      = v_uint8()
        self.cksum      = v_uint16(bigend=True)
        self.srcaddr    = IPv4Address()
        self.dstaddr    = IPv4Address()

    # Make our len over-ride
    def __len__(self):
        return (self.veriphl & 0x0f) * 4


class TCP(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.srcport    = v_uint16(bigend=True)
        self.dstport    = v_uint16(bigend=True)
        self.sequence   = v_uint32(bigend=True)
        self.ackseq     = v_uint32(bigend=True)
        self.doff       = v_uint8()
        self.flags      = v_uint8()
        self.window     = v_uint16(bigend=True)
        self.checksum   = v_uint16(bigend=True)
        self.urgent     = v_uint16(bigend=True)

    def __len__(self):
        return self.doff >> 2

class UDP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.srcport    = v_uint16(bigend=True)
        self.dstport    = v_uint16(bigend=True)
        self.udplen     = v_uint16(bigend=True)
        self.checksum   = v_uint16(bigend=True)


########NEW FILE########
__FILENAME__ = kdcom
"""
Initial module with supporting structures for windows
kernel serial debugging.
"""

import vstruct
from vstruct.primitives import *

# Main packet magic bytes and such
BREAKIN_PACKET                      = 0x62626262
BREAKIN_PACKET_BYTE                 = 0x62
PACKET_LEADER                       = 0x30303030
PACKET_LEADER_BYTE                  = 0x30
CONTROL_PACKET_LEADER               = 0x69696969
CONTROL_PACKET_LEADER_BYTE          = 0x69
PACKET_TRAILING_BYTE                = 0xAA

pkt_magic_names = {
    BREAKIN_PACKET:"Break Packet",
    PACKET_LEADER:"Packet",
    CONTROL_PACKET_LEADER:"Control Packet",
} 

# Primary "packet types"
PACKET_TYPE_UNUSED                  = 0
PACKET_TYPE_KD_STATE_CHANGE32       = 1
PACKET_TYPE_KD_STATE_MANIPULATE     = 2
PACKET_TYPE_KD_DEBUG_IO             = 3
PACKET_TYPE_KD_ACKNOWLEDGE          = 4
PACKET_TYPE_KD_RESEND               = 5
PACKET_TYPE_KD_RESET                = 6
PACKET_TYPE_KD_STATE_CHANGE64       = 7
PACKET_TYPE_KD_POLL_BREAKIN         = 8
PACKET_TYPE_KD_TRACE_IO             = 9
PACKET_TYPE_KD_CONTROL_REQUEST      = 10
PACKET_TYPE_KD_FILE_IO              = 11
PACKET_TYPE_MAX                     = 12

pkt_type_names = {
    PACKET_TYPE_UNUSED:"Unused",
    PACKET_TYPE_KD_STATE_CHANGE32:"State Change32",
    PACKET_TYPE_KD_STATE_MANIPULATE:"Manipulate",
    PACKET_TYPE_KD_DEBUG_IO:"Debug IO",
    PACKET_TYPE_KD_ACKNOWLEDGE:"Ack",
    PACKET_TYPE_KD_RESEND:"Resend",
    PACKET_TYPE_KD_RESET:"Reset",
    PACKET_TYPE_KD_STATE_CHANGE64:"State Change64",
    PACKET_TYPE_KD_POLL_BREAKIN:"Breakin",
    PACKET_TYPE_KD_TRACE_IO:"Trace IO",
    PACKET_TYPE_KD_CONTROL_REQUEST:"Control Request",
    PACKET_TYPE_KD_FILE_IO:"File IO",
    PACKET_TYPE_MAX:"Max",
}

# Wait State Change Types
DbgKdMinimumStateChange             = 0x00003030
DbgKdExceptionStateChange           = 0x00003030
DbgKdLoadSymbolsStateChange         = 0x00003031
DbgKdCommandStringStateChange       = 0x00003032
DbgKdMaximumStateChange             = 0x00003033

pkt_sub_wait_state_change = {
    DbgKdMinimumStateChange:"DbgKdMinimumStateChange",
    DbgKdExceptionStateChange:"DbgKdExceptionStateChange",
    DbgKdLoadSymbolsStateChange:"DbgKdLoadSymbolsStateChange",
    DbgKdCommandStringStateChange:"DbgKdCommandStringStateChange",
    DbgKdMaximumStateChange:"DbgKdMaximumStateChange",
}

# Manipulate Types
DbgKdMinimumManipulate              = 0x00003130
DbgKdReadVirtualMemoryApi           = 0x00003130
DbgKdWriteVirtualMemoryApi          = 0x00003131
DbgKdGetContextApi                  = 0x00003132
DbgKdSetContextApi                  = 0x00003133
DbgKdWriteBreakPointApi             = 0x00003134
DbgKdRestoreBreakPointApi           = 0x00003135
DbgKdContinueApi                    = 0x00003136
DbgKdReadControlSpaceApi            = 0x00003137
DbgKdWriteControlSpaceApi           = 0x00003138
DbgKdReadIoSpaceApi                 = 0x00003139
DbgKdWriteIoSpaceApi                = 0x0000313A
DbgKdRebootApi                      = 0x0000313B
DbgKdContinueApi2                   = 0x0000313C
DbgKdReadPhysicalMemoryApi          = 0x0000313D
DbgKdWritePhysicalMemoryApi         = 0x0000313E
DbgKdQuerySpecialCallsApi           = 0x0000313F
DbgKdSetSpecialCallApi              = 0x00003140
DbgKdClearSpecialCallsApi           = 0x00003141
DbgKdSetInternalBreakPointApi       = 0x00003142
DbgKdGetInternalBreakPointApi       = 0x00003143
DbgKdReadIoSpaceExtendedApi         = 0x00003144
DbgKdWriteIoSpaceExtendedApi        = 0x00003145
DbgKdGetVersionApi                  = 0x00003146
DbgKdWriteBreakPointExApi           = 0x00003147
DbgKdRestoreBreakPointExApi         = 0x00003148
DbgKdCauseBugCheckApi               = 0x00003149
DbgKdSwitchProcessor                = 0x00003150
DbgKdPageInApi                      = 0x00003151
DbgKdReadMachineSpecificRegister    = 0x00003152
DbgKdWriteMachineSpecificRegister   = 0x00003153
OldVlm1                             = 0x00003154
OldVlm2                             = 0x00003155
DbgKdSearchMemoryApi                = 0x00003156
DbgKdGetBusDataApi                  = 0x00003157
DbgKdSetBusDataApi                  = 0x00003158
DbgKdCheckLowMemoryApi              = 0x00003159
DbgKdClearAllInternalBreakpointsApi = 0x0000315A
DbgKdFillMemoryApi                  = 0x0000315B
DbgKdQueryMemoryApi                 = 0x0000315C
DbgKdSwitchPartition                = 0x0000315D
DbgKdMaximumManipulate              = 0x0000315E

pkt_sub_manipulate = {
    DbgKdMinimumManipulate:"DbgKdMinimumManipulate",
    DbgKdReadVirtualMemoryApi:"DbgKdReadVirtualMemoryApi",
    DbgKdWriteVirtualMemoryApi:"DbgKdWriteVirtualMemoryApi",
    DbgKdGetContextApi:"DbgKdGetContextApi",
    DbgKdSetContextApi:"DbgKdSetContextApi",
    DbgKdWriteBreakPointApi:"DbgKdWriteBreakPointApi",
    DbgKdRestoreBreakPointApi:"DbgKdRestoreBreakPointApi",
    DbgKdContinueApi:"DbgKdContinueApi",
    DbgKdReadControlSpaceApi:"DbgKdReadControlSpaceApi",
    DbgKdWriteControlSpaceApi:"DbgKdWriteControlSpaceApi",
    DbgKdReadIoSpaceApi:"DbgKdReadIoSpaceApi",
    DbgKdWriteIoSpaceApi:"DbgKdWriteIoSpaceApi",
    DbgKdRebootApi:"DbgKdRebootApi",
    DbgKdContinueApi2:"DbgKdContinueApi2",
    DbgKdReadPhysicalMemoryApi:"DbgKdReadPhysicalMemoryApi",
    DbgKdWritePhysicalMemoryApi:"DbgKdWritePhysicalMemoryApi",
    DbgKdQuerySpecialCallsApi:"DbgKdQuerySpecialCallsApi",
    DbgKdSetSpecialCallApi:"DbgKdSetSpecialCallApi",
    DbgKdClearSpecialCallsApi:"DbgKdClearSpecialCallsApi",
    DbgKdSetInternalBreakPointApi:"DbgKdSetInternalBreakPointApi",
    DbgKdGetInternalBreakPointApi:"DbgKdGetInternalBreakPointApi",
    DbgKdReadIoSpaceExtendedApi:"DbgKdReadIoSpaceExtendedApi",
    DbgKdWriteIoSpaceExtendedApi:"DbgKdWriteIoSpaceExtendedApi",
    DbgKdGetVersionApi:"DbgKdGetVersionApi",
    DbgKdWriteBreakPointExApi:"DbgKdWriteBreakPointExApi",
    DbgKdRestoreBreakPointExApi:"DbgKdRestoreBreakPointExApi",
    DbgKdCauseBugCheckApi:"DbgKdCauseBugCheckApi",
    DbgKdSwitchProcessor:"DbgKdSwitchProcessor",
    DbgKdPageInApi:"DbgKdPageInApi",
    DbgKdReadMachineSpecificRegister:"DbgKdReadMachineSpecificRegister",
    DbgKdWriteMachineSpecificRegister:"DbgKdWriteMachineSpecificRegister",
    OldVlm1:"OldVlm1",
    OldVlm2:"OldVlm2",
    DbgKdSearchMemoryApi:"DbgKdSearchMemoryApi",
    DbgKdGetBusDataApi:"DbgKdGetBusDataApi",
    DbgKdSetBusDataApi:"DbgKdSetBusDataApi",
    DbgKdCheckLowMemoryApi:"DbgKdCheckLowMemoryApi",
    DbgKdClearAllInternalBreakpointsApi:"DbgKdClearAllInternalBreakpointsApi",
    DbgKdFillMemoryApi:"DbgKdFillMemoryApi",
    DbgKdQueryMemoryApi:"DbgKdQueryMemoryApi",
    DbgKdSwitchPartition:"DbgKdSwitchPartition",
    DbgKdMaximumManipulate:"DbgKdMaximumManipulate",
}

# Debug I/O Types
DbgKdPrintStringApi                 = 0x00003230
DbgKdGetStringApi                   = 0x00003231

# Control Report Flags
REPORT_INCLUDES_SEGS                = 0x0001
REPORT_INCLUDES_CS                  = 0x0002

# Protocol Versions
DBGKD_64BIT_PROTOCOL_VERSION1       = 5
DBGKD_64BIT_PROTOCOL_VERSION2       = 6

# Query Memory Address Spaces
DBGKD_QUERY_MEMORY_VIRTUAL          = 0
DBGKD_QUERY_MEMORY_PROCESS          = 0
DBGKD_QUERY_MEMORY_SESSION          = 1
DBGKD_QUERY_MEMORY_KERNEL           = 2

# Query Memory Flags
DBGKD_QUERY_MEMORY_READ             = 0x01
DBGKD_QUERY_MEMORY_WRITE            = 0x02
DBGKD_QUERY_MEMORY_EXECUTE          = 0x04
DBGKD_QUERY_MEMORY_FIXED            = 0x08

ULONG = v_uint32
ULONG64 = v_uint64
BOOLEAN = v_uint32

class DBGKD_LOAD_SYMBOLS64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self._vs_field_align = True
        self.PathNameLength = v_uint32()
        self.BaseOfDll = v_uint64()
        self.ProcessId = v_uint64()
        self.CheckSum = v_uint32()
        self.SizeOfImage = v_uint32()
        #self.UnloadSymbols = v_uint8()
        self.UnloadSymbols = v_uint32() # HACK must be 32 bit aligned

class DBGKD_WAIT_STATE_CHANGE64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self._vs_field_align = True
        self.NewState = v_uint32()
        self.ProcessorLevel = v_uint16()
        self.Processor = v_uint16()
        self.NumberProcessors = v_uint32()
        self.Thread = v_uint64()
        self.ProgramCounter = v_uint64()


########NEW FILE########
__FILENAME__ = const

# Fat Defines...
FAT_MAGIC = 0xcafebabe
FAT_CIGAM = 0xbebafeca   #NXSwapLong(FAT_MAGIC)

MH_MAGIC                  = 0xfeedface #  the mach magic number 
MH_CIGAM                  = 0xcefaedfe #  NXSwapInt(MH_MAGIC) 
MH_MAGIC_64               = 0xfeedfacf #  the 64-bit mach magic number 
MH_CIGAM_64               = 0xcffaedfe #  NXSwapInt(MH_MAGIC_64) 
MH_OBJECT                 = 0x1 #  relocatable object file 
MH_EXECUTE                = 0x2 #  demand paged executable file 
MH_FVMLIB                 = 0x3 #  fixed VM shared library file 
MH_CORE                   = 0x4 #  core file 
MH_PRELOAD                = 0x5 #  preloaded executable file 
MH_DYLIB                  = 0x6 #  dynamically bound shared library 
MH_DYLINKER               = 0x7 #  dynamic link editor 
MH_BUNDLE                 = 0x8 #  dynamically bound bundle file 
MH_DYLIB_STUB             = 0x9 #  shared library stub for static 
MH_DSYM                   = 0xa #  companion file with only debug 
MH_NOUNDEFS               = 0x1 #  the object file has no undefinedreferences 
MH_INCRLINK               = 0x2 #  the object file is the output of anincremental link against a base fileand can't be link edited again 
MH_DYLDLINK               = 0x4 #  the object file is input for thedynamic linker and can't be staticlylink edited again 
MH_BINDATLOAD             = 0x8 #  the object file's undefinedreferences are bound by the dynamiclinker when loaded. 
MH_PREBOUND               = 0x10 #  the file has its dynamic undefinedreferences prebound. 
MH_SPLIT_SEGS             = 0x20 #  the file has its read-only andread-write segments split 
MH_LAZY_INIT              = 0x40 #  the shared library init routine isto be run lazily via catching memoryfaults to its writeable segments(obsolete) 
MH_TWOLEVEL               = 0x80 #  the image is using two-level namespace bindings 
MH_FORCE_FLAT             = 0x100 #  the executable is forcing all imagesto use flat name space bindings 
MH_NOMULTIDEFS            = 0x200 #  this umbrella guarantees no multipledefintions of symbols in itssub-images so the two-level namespacehints can always be used. 
MH_NOFIXPREBINDING        = 0x400 #  do not have dyld notify theprebinding agent about thisexecutable 
MH_PREBINDABLE            = 0x800 #  the binary is not prebound but canhave its prebinding redone. only usedwhen MH_PREBOUND is not set. 
MH_ALLMODSBOUND           = 0x1000 #  this binary binds toall two-level namespace modules ofits dependent libraries. only usedwhen MH_PREBINDABLE and MH_TWOLEVELare both set. 
MH_CANONICAL              = 0x4000 #  the binary has been canonicalizedvia the unprebind operation 
MH_WEAK_DEFINES           = 0x8000 #  the final linked image containsexternal weak symbols 
MH_BINDS_TO_WEAK          = 0x10000 #  the final linked image usesweak symbols 
MH_ROOT_SAFE              = 0x40000 #  When this bit is set, the binarydeclares it is safe for use inprocesses with uid zero 
MH_SETUID_SAFE            = 0x80000 #  When this bit is set, the binarydeclares it is safe for use inprocesses when issetugid() is true 
MH_NO_REEXPORTED_DYLIBS   = 0x100000 #  When this bit is set on a dylib,the static linker does not need toexamine dependent dylibs to seeif any are re-exported 
MH_PIE                    = 0x200000 #  When this bit is set, the OS willload the main executable at arandom address. Only used inMH_EXECUTE filetypes. 

# Constants for the cmd field of all load commands, the type
LC_REQ_DYLD               = 0x80000000 #  When this bit is set, the OS willload the main executable at arandom address. Only used inMH_EXECUTE filetypes. 
LC_SEGMENT                = 0x1 #  segment of this file to be mapped 
LC_SYMTAB                 = 0x2 #  link-edit stab symbol table info 
LC_SYMSEG                 = 0x3 #  link-edit gdb symbol table info (obsolete) 
LC_THREAD                 = 0x4 #  thread 
LC_UNIXTHREAD             = 0x5 #  unix thread (includes a stack) 
LC_LOADFVMLIB             = 0x6 #  load a specified fixed VM shared library 
LC_IDFVMLIB               = 0x7 #  fixed VM shared library identification 
LC_IDENT                  = 0x8 #  object identification info (obsolete) 
LC_FVMFILE                = 0x9 #  fixed VM file inclusion (internal use) 
LC_PREPAGE                = 0xa #  prepage command (internal use) 
LC_DYSYMTAB               = 0xb #  dynamic link-edit symbol table info 
LC_LOAD_DYLIB             = 0xc #  load a dynamically linked shared library 
LC_ID_DYLIB               = 0xd #  dynamically linked shared lib ident 
LC_LOAD_DYLINKER          = 0xe #  load a dynamic linker 
LC_ID_DYLINKER            = 0xf #  dynamic linker identification 
LC_PREBOUND_DYLIB         = 0x10 #  modules prebound for a dynamically 
LC_ROUTINES               = 0x11 #  image routines 
LC_SUB_FRAMEWORK          = 0x12 #  sub framework 
LC_SUB_UMBRELLA           = 0x13 #  sub umbrella 
LC_SUB_CLIENT             = 0x14 #  sub client 
LC_SUB_LIBRARY            = 0x15 #  sub library 
LC_TWOLEVEL_HINTS         = 0x16 #  two-level namespace lookup hints 
LC_PREBIND_CKSUM          = 0x17 #  prebind checksum 
LC_SEGMENT_64             = 0x19 #  64-bit segment of this file to bemapped 
LC_ROUTINES_64            = 0x1a #  64-bit image routines 
LC_UUID                   = 0x1b #  the uuid 
LC_CODE_SIGNATURE         = 0x1d #  local of code signature 
LC_SEGMENT_SPLIT_INFO     = 0x1e #  local of info to split segments 
LC_LAZY_LOAD_DYLIB        = 0x20 #  delay load of dylib until first use 
LC_ENCRYPTION_INFO        = 0x21 #  encrypted segment information 
LC_DYLD_INFO              = 0x22 #  compressed dyld information

SG_HIGHVM                 = 0x1 #  the file contents for this segment is forthe high part of the VM space, the low partis zero filled (for stacks in core files) 
SG_FVMLIB                 = 0x2 #  this segment is the VM that is allocated bya fixed VM library, for overlap checking inthe link editor 
SG_NORELOC                = 0x4 #  this segment has nothing that was relocatedin it and nothing relocated to it, that isit maybe safely replaced without relocation
SG_PROTECTED_VERSION_1    = 0x8 #  This segment is protected. If thesegment starts at file offset 0, thefirst page of the segment is notprotected. All other pages of thesegment are protected. 


SECTION_TYPE              = 0x000000ff #  256 section types 
SECTION_ATTRIBUTES        = 0xffffff00 #  24 section attributes 
S_REGULAR                 = 0x0 #  regular section 
S_ZEROFILL                = 0x1 #  zero fill on demand section 
S_CSTRING_LITERALS        = 0x2 #  section with only literal C strings
S_4BYTE_LITERALS          = 0x3 #  section with only 4 byte literals 
S_8BYTE_LITERALS          = 0x4 #  section with only 8 byte literals 
S_LITERAL_POINTERS        = 0x5 #  section with only pointers to 
S_NON_LAZY_SYMBOL_POINTERS = 0x6 #  section with only non-lazysymbol pointers 
S_LAZY_SYMBOL_POINTERS    = 0x7 #  section with only lazy symbolpointers 
S_SYMBOL_STUBS            = 0x8 #  section with only symbolstubs, byte size of stub inthe reserved2 field 
S_MOD_INIT_FUNC_POINTERS  = 0x9 #  section with only functionpointers for initialization
S_MOD_TERM_FUNC_POINTERS  = 0xa #  section with only functionpointers for termination 
S_COALESCED               = 0xb #  section contains symbols thatare to be coalesced 
S_GB_ZEROFILL             = 0xc #  zero fill on demand section(that can be larger than 4gigabytes) 
S_INTERPOSING             = 0xd #  section with only pairs offunction pointers forinterposing 
S_16BYTE_LITERALS         = 0xe #  section with only 16 byteliterals 
S_DTRACE_DOF              = 0xf #  section containsDTrace Object Format 
S_LAZY_DYLIB_SYMBOL_POINTERS = 0x10 #  section with only lazysymbol pointers to lazyloaded dylibs 
SECTION_ATTRIBUTES_USR    = 0xff000000 #  User setable attributes 
S_ATTR_PURE_INSTRUCTIONS  = 0x80000000 #  section contains only truemachine instructions 
S_ATTR_NO_TOC             = 0x40000000 #  section contains coalescedsymbols that are not to bein a ranlib table ofcontents 
S_ATTR_STRIP_STATIC_SYMS  = 0x20000000 #  ok to strip static symbolsin this section in fileswith the MH_DYLDLINK flag 
S_ATTR_NO_DEAD_STRIP      = 0x10000000 #  no dead stripping 
S_ATTR_LIVE_SUPPORT       = 0x08000000 #  blocks are live if theyreference live blocks 
S_ATTR_SELF_MODIFYING_CODE = 0x04000000 #  Used with i386 code stubswritten on by dyld 
S_ATTR_DEBUG              = 0x02000000 #  a debug section 
SECTION_ATTRIBUTES_SYS    = 0x00ffff00 #  system setable attributes 
S_ATTR_SOME_INSTRUCTIONS  = 0x00000400 #  section contains somemachine instructions 
S_ATTR_EXT_RELOC          = 0x00000200 #  section has externalrelocation entries 
S_ATTR_LOC_RELOC          = 0x00000100 #  section has localrelocation entries 
INDIRECT_SYMBOL_LOCAL     = 0x80000000 #  section has localrelocation entries 
INDIRECT_SYMBOL_ABS       = 0x40000000 #  section has localrelocation entries 

CPU_TYPE_ANY        = -1
CPU_TYPE_VAX        = 1
CPU_TYPE_MC680      = 6
CPU_TYPE_X86        = 7
CPU_TYPE_X86_64     = 0x01000007
CPU_TYPE_MIPS       = 8
CPU_TYPE_MC98000    = 10
CPU_TYPE_HPPA       = 11
CPU_TYPE_ARM        = 12
CPU_TYPE_MC88000    = 13
CPU_TYPE_SPARC      = 14
CPU_TYPE_I860       = 15
CPU_TYPE_ALPHA      = 16
CPU_TYPE_POWERPC    = 18
#CPU_TYPE_POWERPC64  (CPU_TYPE_POWERPC | CPU_ARCH_ABI64)

mach_cpu_names = {
    CPU_TYPE_VAX        : 'vax',
    CPU_TYPE_MC680      : 'mc680',
    CPU_TYPE_X86        : 'i386',
    CPU_TYPE_X86_64     : 'amd64',
    CPU_TYPE_MIPS       : 'mips',
    CPU_TYPE_MC98000    : 'mc98000',
    CPU_TYPE_HPPA       : 'hppa',
    CPU_TYPE_ARM        : 'arm',
    CPU_TYPE_MC88000    : 'mc88000',
    CPU_TYPE_SPARC      : 'sparc',
    CPU_TYPE_I860       : 'i860',
    CPU_TYPE_ALPHA      : 'alpha',
    CPU_TYPE_POWERPC    : 'powerpc',
}

# Symbol types
N_GSYM      = 0x20      # global symbol:                name,,NO_SECT,type,0
N_FNAME     = 0x22      # procedure name (f77 kludge):  name,,NO_SECT,0,0
N_FUN       = 0x24      # procedure:                    name,,n_sect,linenumber,address
N_STSYM     = 0x26      # static symbol:                name,,n_sect,type,address
N_LCSYM     = 0x28      # .lcomm symbol:                name,,n_sect,type,address
N_BNSYM     = 0x2e      # begin nsect sym:              0,,n_sect,0,address
N_PC        = 0x30      # global pascal symbol:         name,,NO_SECT,subtype,line
N_OPT       = 0x3c      # emitted with gcc2_compile and in gcc source
N_RSYM      = 0x40      # register sym:                 name,,NO_SECT,type,register
N_SLINE     = 0x44      # src line:                     0,,n_sect,linenumber,address
N_ENSYM     = 0x4e      # end nsect sym:                0,,n_sect,0,address
N_SSYM      = 0x60      # struct elt:                   name,,NO_SECT,type,struct_offset
N_SO        = 0x64      # source file name:             name,,n_sect,0,address
N_LSYM      = 0x80      # local sym:                    name,,NO_SECT,type,offset
N_BINCL     = 0x82      # include file beginning:       name,,NO_SECT,0,sum
N_SOL       = 0x84      # #included file name:          name,,n_sect,0,address
N_PARAMS    = 0x86      # compiler parameters:          name,,NO_SECT,0,0
N_VERSION   = 0x88      # compiler version:             name,,NO_SECT,0,0
N_OLEVEL    = 0x8A      # compiler -O level:            name,,NO_SECT,0,0
N_PSYM      = 0xA0      # parameter:                    name,,NO_SECT,type,offset
N_EINCL     = 0xA2      # include file end:             name,,NO_SECT,0,0
N_ENTRY     = 0xA4      # alternate entry:              name,,n_sect,linenumber,address
N_LBRAC     = 0xC0      # left bracket:                 0,,NO_SECT,nesting level,address
N_EXCL      = 0xC2      # deleted include file:         name,,NO_SECT,0,sum
N_RBRAC     = 0xE0      # right bracket:                0,,NO_SECT,nesting level,address
N_BCOMM     = 0xE2      # begin common:                 name,,NO_SECT,0,0
N_ECOMM     = 0xE4      # end common:                   name,,n_sect,0,0
N_ECOML     = 0xE8      # end common (local name):      0,,n_sect,0,address
N_LENG      = 0xFE      # second stab entry with length information

# The n_type field really contains four fields:
#	unsigned char N_STAB:3,
#		      N_PEXT:1,
#		      N_TYPE:3,
#		      N_EXT:1;

N_STAB  = 0xe0  # if any of these bits set, a symbolic debugging entry
N_PEXT  = 0x10  # private external symbol bit
N_TYPE  = 0x0e  # mask for the type bits
N_EXT   = 0x01  # external symbol bit, set for external symbols

# Values for N_TYPE bits of the n_type field.
N_UNDF   = 0x0 # undefined, n_sect == NO_SECT
N_ABS    = 0x2 # absolute, n_sect == NO_SECT
N_SECT   = 0xe # defined in section number n_sect
N_PBUD   = 0xc # prebound undefined (defined in a dylib)
N_INDR   = 0xa # indirect


########NEW FILE########
__FILENAME__ = fat

import vstruct
from vstruct.primitives import *
import vstruct.primitives as vs_prim

class fat_header(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.magic = v_uint32(bigend=True)
        self.nfat_arch = v_uint32(bigend=True)

class fat_arch(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cputype    = v_uint32(bigend=True)  # cpu specifier (int) */
        self.cpusubtype = v_uint32(bigend=True)  # machine specifier (int) */
        self.offset     = v_uint32(bigend=True)  # file offset to this object file */
        self.size       = v_uint32(bigend=True)  # size of this object file */
        self.align      = v_uint32(bigend=True)  # alignment as a power of 2 */


########NEW FILE########
__FILENAME__ = loader
import vstruct

from vstruct.primitives import *
from vstruct.defs.macho.const import *

vm_prot_t = v_uint32
cpu_type_t = v_uint32
cpu_subtype_t = v_uint32
lc_str = v_uint32

class mach_header(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.magic      = v_uint32() # mach magic number identifier
        self.cputype    = cpu_type_t() # cpu specifier
        self.cpusubtype = cpu_subtype_t() # machine specifier
        self.filetype   = v_uint32() # type of file
        self.ncmds      = v_uint32() # number of load commands
        self.sizeofcmds = v_uint32() # the size of all the load commands
        self.flags      = v_uint32() # flags

    def vsParse(self, bytes, offset=0):
        # Over-ride this so we can do the parse, and make sure we
        # had the right endianness.
        ret = vstruct.VStruct.vsParse(self, bytes, offset=offset)
        if self.magic == MH_CIGAM:
            self._vs_fmtbase = '>'
            ret = vstruct.VStruct.vsParse(self, bytes, offset=offset)
        return ret

class mach_header_64(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.magic      = v_uint32() # mach magic number identifier
        self.cputype    = cpu_type_t() # cpu specifier
        self.cpusubtype = cpu_subtype_t() # machine specifier
        self.filetype   = v_uint32() # type of file
        self.ncmds      = v_uint32() # number of load commands
        self.sizeofcmds = v_uint32() # the size of all the load commands
        self.flags      = v_uint32() # flags
        self.reserved   = v_uint32() # reserved


# FIXME all commands should subclass this one!
class load_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd     = v_uint32() # type of load command
        self.cmdsize = v_uint32() # total size of command in bytes

class segment_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd         = v_uint32() # LC_SEGMENT
        self.cmdsize     = v_uint32() # includes sizeof section structs
        self.segname     = v_str(size=16) # segment name
        self.vmaddr      = v_uint32() # memory address of this segment
        self.vmsize      = v_uint32() # memory size of this segment
        self.fileoff     = v_uint32() # file offset of this segment
        self.filesize    = v_uint32() # amount to map from the file
        self.maxprot     = vm_prot_t() # maximum VM protection
        self.initprot    = vm_prot_t() # initial VM protection
        self.nsects      = v_uint32() # number of sections in segment
        self.flags       = v_uint32() # flags

class segment_command_64(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd         = v_uint32() # LC_SEGMENT_64
        self.cmdsize     = v_uint32() # includes sizeof section_64 structs
        self.segname[16] = v_uint8() # segment name
        self.vmaddr      = v_uint64() # memory address of this segment
        self.vmsize      = v_uint64() # memory size of this segment
        self.fileoff     = v_uint64() # file offset of this segment
        self.filesize    = v_uint64() # amount to map from the file
        self.maxprot     = vm_prot_t() # maximum VM protection
        self.initprot    = vm_prot_t() # initial VM protection
        self.nsects      = v_uint32() # number of sections in segment
        self.flags       = v_uint32() # flags


class section(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.sectname     = v_str(size=16) # name of this section
        self.segname      = v_str(size=16) # segment this section goes in
        self.addr         = v_uint32() # memory address of this section
        self.size         = v_uint32() # size in bytes of this section
        self.offset       = v_uint32() # file offset of this section
        self.align        = v_uint32() # section alignment (power of 2)
        self.reloff       = v_uint32() # file offset of relocation entries
        self.nreloc       = v_uint32() # number of relocation entries
        self.flags        = v_uint32() # flags (section type and attributes)
        self.reserved1    = v_uint32() # reserved (for offset or index)
        self.reserved2    = v_uint32() # reserved (for count or sizeof)


class section_64(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.sectname     = v_str(size=16) # name of this section
        self.segname      = v_str(size=16) # segment this section goes in
        self.addr         = v_uint64() # memory address of this section
        self.size         = v_uint64() # size in bytes of this section
        self.offset       = v_uint32() # file offset of this section
        self.align        = v_uint32() # section alignment (power of 2)
        self.reloff       = v_uint32() # file offset of relocation entries
        self.nreloc       = v_uint32() # number of relocation entries
        self.flags        = v_uint32() # flags (section type and attributes)
        self.reserved1    = v_uint32() # reserved (for offset or index)
        self.reserved2    = v_uint32() # reserved (for count or sizeof)
        self.reserved3    = v_uint32() # reserved

class fvmlib_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd     = v_uint32() # LC_IDFVMLIB or LC_LOADFVMLIB
        self.cmdsize = v_uint32() # includes pathname string
        self.name          = lc_str() # library's target pathname
        self.minor_version = v_uint32() # library's minor version number
        self.header_addr   = v_uint32() # library's header address

class dylib_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd     = v_uint32() # LC_ID_DYLIB, LC_LOAD_{,WEAK_}DYLIB, LC_REEXPORT_DYLIB
        self.cmdsize = v_uint32() # includes pathname string
        self.name                  = lc_str() # library's path name
        self.timestamp             = v_uint32() # library's build time stamp
        self.current_version       = v_uint32() # library's current version number
        self.compatibility_version = v_uint32() # library's compatibility vers number
        self.namedata              = v_bytes(size=0)

    def vsParse(self, bytes, offset=0):
        # So we can grab the name data
        retoff = vstruct.VStruct.vsParse(self, bytes, offset=offset)
        # Grab the name from the inline data...
        name = bytes[ offset + self.name : offset + self.cmdsize ]
        self.namedata = name.split('\x00', 1)[0]
        return retoff

class sub_framework_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd      = v_uint32() # LC_SUB_FRAMEWORK
        self.cmdsize  = v_uint32() # includes umbrella string
        self.umbrella = lc_str() # the umbrella framework name


class sub_client_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd     = v_uint32() # LC_SUB_CLIENT
        self.cmdsize = v_uint32() # includes client string
        self.client  = lc_str() # the client name


class sub_umbrella_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd          = v_uint32() # LC_SUB_UMBRELLA
        self.cmdsize      = v_uint32() # includes sub_umbrella string
        self.sub_umbrella = lc_str() # the sub_umbrella framework name


class sub_library_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd         = v_uint32() # LC_SUB_LIBRARY
        self.cmdsize     = v_uint32() # includes sub_library string
        self.sub_library = lc_str() # the sub_library name


class prebound_dylib_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd            = v_uint32() # LC_PREBOUND_DYLIB
        self.cmdsize        = v_uint32() # includes strings
        self.name           = lc_str() # library's path name
        self.nmodules       = v_uint32() # number of modules in library
        self.linked_modules = lc_str() # bit vector of linked modules


class dylinker_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd     = v_uint32() # LC_ID_DYLINKER or LC_LOAD_DYLINKER
        self.cmdsize = v_uint32() # includes pathname string
        self.name    = lc_str() # dynamic linker's path name


class thread_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd     = v_uint32() # LC_THREAD or LC_UNIXTHREAD
        self.cmdsize = v_uint32() # total size of this command


class routines_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd          = v_uint32() # LC_ROUTINES
        self.cmdsize      = v_uint32() # total size of this command
        self.init_address = v_uint32() # address of initialization routine
        self.init_module  = v_uint32() # index into the module table that
        self.reserved1    = v_uint32()
        self.reserved2    = v_uint32()
        self.reserved3    = v_uint32()
        self.reserved4    = v_uint32()
        self.reserved5    = v_uint32()
        self.reserved6    = v_uint32()


class routines_command_64(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd          = v_uint32() # LC_ROUTINES_64
        self.cmdsize      = v_uint32() # total size of this command
        self.init_address = v_uint64() # address of initialization routine
        self.init_module  = v_uint64() # index into the module table that
        self.reserved1    = v_uint64()
        self.reserved2    = v_uint64()
        self.reserved3    = v_uint64()
        self.reserved4    = v_uint64()
        self.reserved5    = v_uint64()
        self.reserved6    = v_uint64()


class symtab_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd     = v_uint32() # LC_SYMTAB
        self.cmdsize = v_uint32() # sizeof(struct symtab_command)
        self.symoff  = v_uint32() # symbol table offset
        self.nsyms   = v_uint32() # number of symbol table entries
        self.stroff  = v_uint32() # string table offset
        self.strsize = v_uint32() # string table size in bytes

class dysymtab_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd            = v_uint32() # LC_DYSYMTAB
        self.cmdsize        = v_uint32() # sizeof(struct dysymtab_command)
        self.ilocalsym      = v_uint32() # index to local symbols
        self.nlocalsym      = v_uint32() # number of local symbols
        self.iextdefsym     = v_uint32() # index to externally defined symbols
        self.nextdefsym     = v_uint32() # number of externally defined symbols
        self.iundefsym      = v_uint32() # index to undefined symbols
        self.nundefsym      = v_uint32() # number of undefined symbols
        self.tocoff         = v_uint32() # file offset to table of contents
        self.ntoc           = v_uint32() # number of entries in table of contents
        self.modtaboff      = v_uint32() # file offset to module table
        self.nmodtab        = v_uint32() # number of module table entries
        self.extrefsymoff   = v_uint32() # offset to referenced symbol table
        self.nextrefsyms    = v_uint32() # number of referenced symbol table entries
        self.indirectsymoff = v_uint32() # file offset to the indirect symbol table
        self.nindirectsyms  = v_uint32() # number of indirect symbol table entries
        self.extreloff      = v_uint32() # offset to external relocation entries
        self.nextrel        = v_uint32() # number of external relocation entries
        self.locreloff      = v_uint32() # offset to local relocation entries
        self.nlocrel        = v_uint32() # number of local relocation entries


class dylib_table_of_contents(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.symbol_index = v_uint32() # the defined external symbol (index into the symbol table)
        self.module_index = v_uint32() # index into the module table this symbol is defined in


class dylib_module(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.module_name           = v_uint32() # the module name (index into string table)
        self.iextdefsym            = v_uint32() # index into externally defined symbols
        self.nextdefsym            = v_uint32() # number of externally defined symbols
        self.irefsym               = v_uint32() # index into reference symbol table
        self.nrefsym               = v_uint32() # number of reference symbol table entries
        self.ilocalsym             = v_uint32() # index into symbols for local symbols
        self.nlocalsym             = v_uint32() # number of local symbols
        self.iextrel               = v_uint32() # index into external relocation entries
        self.nextrel               = v_uint32() # number of external relocation entries
        self.iinit_iterm           = v_uint32() # low 16 bits are the index into the init section, high 16 bits are the index into the term section
        self.ninit_nterm           = v_uint32() # low 16 bits are the number of init section entries, high 16 bits are the number of term section entries
        self.objc_module_info_addr = v_uint32() # the (__OBJC,__module_info) section
        self.objc_module_info_size = v_uint32() # the (__OBJC,__module_info) section


class dylib_module_64(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.module_name           = v_uint32() # the module name (index into string table)
        self.iextdefsym            = v_uint32() # index into externally defined symbols
        self.nextdefsym            = v_uint32() # number of externally defined symbols
        self.irefsym               = v_uint32() # index into reference symbol table
        self.nrefsym               = v_uint32() # number of reference symbol table entries
        self.ilocalsym             = v_uint32() # index into symbols for local symbols
        self.nlocalsym             = v_uint32() # number of local symbols
        self.iextrel               = v_uint32() # index into external relocation entries
        self.nextrel               = v_uint32() # number of external relocation entries
        self.iinit_iterm           = v_uint32() # low 16 bits are the index into the init section, high 16 bits are the index into the term section
        self.ninit_nterm           = v_uint32() # low 16 bits are the number of init section entries, high 16 bits are the number of term section entries
        self.objc_module_info_size = v_uint32() # the (__OBJC,__module_info) section
        self.objc_module_info_addr = v_uint64() # the (__OBJC,__module_info) section


class dylib_reference(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.flags = v_uint32() # flags to indicate the type of reference


class twolevel_hints_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd     = v_uint32() # LC_TWOLEVEL_HINTS
        self.cmdsize = v_uint32() # sizeof(struct twolevel_hints_command)
        self.offset  = v_uint32() # offset to the hint table
        self.nhints  = v_uint32() # number of hints in the hint table


class twolevel_hint(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.itoc = v_uint32() # index into the table of contents

class prebind_cksum_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd     = v_uint32() # LC_PREBIND_CKSUM
        self.cmdsize = v_uint32() # sizeof(struct prebind_cksum_command)
        self.cksum   = v_uint32() # the check sum or zero


class uuid_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd      = v_uint32() # LC_UUID
        self.cmdsize  = v_uint32() # sizeof(struct uuid_command)
        self.uuid[16] = v_uint8() # the 128-bit uuid


class rpath_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd     = v_uint32() # LC_RPATH
        self.cmdsize = v_uint32() # includes string
        self.path    = lc_str() # path to add to run path


class linkedit_data_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd      = v_uint32() # LC_CODE_SIGNATURE or LC_SEGMENT_SPLIT_INFO
        self.cmdsize  = v_uint32() # sizeof(struct linkedit_data_command)
        self.dataoff  = v_uint32() # file offset of data in __LINKEDIT segment
        self.datasize = v_uint32() # file size of data in __LINKEDIT segment


class encryption_info_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd       = v_uint32() # LC_ENCRYPTION_INFO
        self.cmdsize   = v_uint32() # sizeof(struct encryption_info_command)
        self.cryptoff  = v_uint32() # file offset of encrypted range
        self.cryptsize = v_uint32() # file size of encrypted range
        self.cryptid   = v_uint32() # which enryption system, 0 means not-encrypted yet


class symseg_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd     = v_uint32() # LC_SYMSEG
        self.cmdsize = v_uint32() # sizeof(struct symseg_command)
        self.offset  = v_uint32() # symbol segment offset
        self.size    = v_uint32() # symbol segment size in bytes


class ident_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd     = v_uint32() # LC_IDENT
        self.cmdsize = v_uint32() # strings that follow this command

class fvmfile_command(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cmd         = v_uint32() # LC_FVMFILE
        self.cmdsize     = v_uint32() # includes pathname string
        self.name        = lc_str() # files pathname
        self.header_addr = v_uint32() # files virtual address

command_classes = {
    LC_SEGMENT:     segment_command,
    LC_SYMTAB:      symtab_command,
    LC_LOAD_DYLIB:  dylib_command,
}

def getCommandClass(cmdtype):
    cls = command_classes.get(cmdtype)
    if cls != None:
        return cls
    return load_command


########NEW FILE########
__FILENAME__ = stabs
import vstruct

from vstruct.primitives import *
from vstruct.defs.macho.const import *

class nlist(vstruct.VStruct):
    '''
    A symbol table entry in a Mach-O binary is called an nlist.
    '''
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.n_strx     = v_uint32()    # index into the string table
        self.n_type     = v_uint8()     # type flag (see const...)
        self.n_sect     = v_uint8()     # section number or NO_SECT (index from 1...)
        self.n_desc     = v_uint16()    # desription (see const...)
        self.n_value    = v_uint32()    # value of this symbol (or stab offset)

class nlist64(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.n_strx     = v_uint32()
        self.n_type     = v_uint8()
        self.n_sect     = v_uint8()
        self.n_desc     = v_uint16()
        self.n_value    = v_uint64()


########NEW FILE########
__FILENAME__ = pcap

import vstruct
import vstruct.defs.inet as vs_inet

from vstruct.primitives import *

PCAP_LINKTYPE_ETHER     = 1
PCAP_LINKTYPE_RAW       = 101

class PCAP_FILE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.magic      = v_uint32()
        self.vers_maj   = v_uint16()
        self.vers_min   = v_uint16()
        self.thiszone   = v_uint32()
        self.sigfigs    = v_uint32()
        self.snaplen    = v_uint32()
        self.linktype   = v_uint32()

class PCAP_PACKET_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.tvsec      = v_uint32()
        self.tvusec     = v_uint32()
        self.caplen     = v_uint32()
        self.len        = v_uint32()

def iterPcapFileName(filename, reuse=False):
    fd = file(filename, 'rb')
    for x in iterPcapFile(fd, reuse=reuse):
        yield x
    
def iterPcapFile(fd, reuse=False):

    h = PCAP_FILE_HEADER()
    b = fd.read(len(h))
    h.vsParse(b)

    linktype = h.linktype

    if linktype not in (PCAP_LINKTYPE_ETHER, PCAP_LINKTYPE_RAW):
        raise Exeption('PCAP Link Type %d Not Supported Yet!' % linktype)

    pkt = PCAP_PACKET_HEADER()
    eII = vs_inet.ETHERII()

    eIIsize = len(eII)

    ipv4 = vs_inet.IPv4()
    tcp_hdr = vs_inet.TCP()
    udp_hdr = vs_inet.UDP()

    go = True
    while go:

        hdr = fd.read(len(pkt))
        if hdr == '':
            break

        pkt.vsParse(hdr)

        b = fd.read(pkt.caplen)

        offset = 0

        if linktype == PCAP_LINKTYPE_ETHER:

            if len(b) < eIIsize:
                continue

            eII.vsParse(b, 0)

            # No support for non-ip protocol yet...
            if eII.etype != vs_inet.ETH_P_IP:
                continue

            offset += len(eII)

        elif linktype == PCAP_LINKTYPE_RAW:
            pass

        #print eII.tree()
        if not reuse:
            ipv4 = vs_inet.IPv4()

        ipv4.vsParse(b, offset)

        # Make b *only* the IP datagram bytes...
        b = b[offset:offset+ipv4.totlen]

        offset = 0
        offset += len(ipv4)
        tsize = len(b) - offset

        if ipv4.proto == vs_inet.IPPROTO_TCP:

            if tsize < 20:
                continue

            if not reuse:
                tcp_hdr = vs_inet.TCP()

            tcp_hdr.vsParse(b, offset)
            offset += len(tcp_hdr)
            pdata = b[offset:]

            yield pkt,ipv4,tcp_hdr,pdata

        elif ipv4.proto == vs_inet.IPPROTO_UDP:

            if tsize < 8:
                continue

            if not reuse:
                udp_hdr = vs_inet.UDP()

            udp_hdr.vsParse(b, offset)
            offset += len(udp_hdr)
            pdata = b[offset:]

            yield pkt,ipv4,udp_hdr,pdata

        else:
            pass
            #print 'UNHANDLED IP PROTOCOL: %d' % ipv4.proto


########NEW FILE########
__FILENAME__ = pe

import vstruct
from vstruct.primitives import *

class IMAGE_BASE_RELOCATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_uint32()
        self.SizeOfBlock    = v_uint32()

class IMAGE_DATA_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_uint32()
        self.Size           = v_uint32()

class IMAGE_DOS_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e_magic    = v_uint16()
        self.e_cblp     = v_uint16()
        self.e_cp       = v_uint16()
        self.e_crlc     = v_uint16()
        self.e_cparhdr  = v_uint16()
        self.e_minalloc = v_uint16()
        self.e_maxalloc = v_uint16()
        self.e_ss       = v_uint16()
        self.e_sp       = v_uint16()
        self.e_csum     = v_uint16()
        self.e_ip       = v_uint16()
        self.e_cs       = v_uint16()
        self.e_lfarlc   = v_uint16()
        self.e_ovno     = v_uint16()
        self.e_res      = vstruct.VArray([v_uint16() for i in range(4)])
        self.e_oemid    = v_uint16()
        self.e_oeminfo  = v_uint16()
        self.e_res2     = vstruct.VArray([v_uint16() for i in range(10)])
        self.e_lfanew   = v_uint32()

class IMAGE_EXPORT_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Characteristics    = v_uint32()
        self.TimeDateStamp      = v_uint32()
        self.MajorVersion       = v_uint16()
        self.MinorVersion       = v_uint16()
        self.Name               = v_uint32()
        self.Base               = v_uint32()
        self.NumberOfFunctions  = v_uint32()
        self.NumberOfNames      = v_uint32()
        self.AddressOfFunctions = v_uint32()
        self.AddressOfNames     = v_uint32()
        self.AddressOfOrdinals  = v_uint32()

class IMAGE_FILE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Machine              = v_uint16()
        self.NumberOfSections     = v_uint16()
        self.TimeDateStamp        = v_uint32()
        self.PointerToSymbolTable = v_uint32()
        self.NumberOfSymbols      = v_uint32()
        self.SizeOfOptionalHeader = v_uint16()
        self.Ccharacteristics     = v_uint16()

class IMAGE_IMPORT_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OriginalFirstThunk = v_uint32()
        self.TimeDateStamp      = v_uint32()
        self.ForwarderChain     = v_uint32()
        self.Name               = v_uint32()
        self.FirstThunk         = v_uint32()

class IMAGE_IMPORT_BY_NAME(vstruct.VStruct):
    def __init__(self, namelen=128):
        vstruct.VStruct.__init__(self)
        self.Hint   = v_uint16()
        self.Name   = v_str(size=namelen)

class IMAGE_LOAD_CONFIG_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size                          = v_uint32()
        self.TimeDateStamp                 = v_uint32()
        self.MajorVersion                  = v_uint16()
        self.MinorVersion                  = v_uint16()
        self.GlobalFlagsClear              = v_uint32()
        self.GlobalFlagsSet                = v_uint32()
        self.CriticalSectionDefaultTimeout = v_uint32()
        self.DeCommitFreeBlockThreshold    = v_uint32()
        self.DeCommitTotalFreeThreshold    = v_uint32()
        self.LockPrefixTable               = v_uint32()
        self.MaximumAllocationSize         = v_uint32()
        self.VirtualMemoryThreshold        = v_uint32()
        self.ProcessHeapFlags              = v_uint32()
        self.ProcessAffinityMask           = v_uint32()
        self.CSDVersion                    = v_uint16()
        self.Reserved1                     = v_uint16()
        self.EditList                      = v_uint32()
        self.SecurityCookie                = v_uint32()
        self.SEHandlerTable                = v_uint32()
        self.SEHandlerCount                = v_uint32()

class IMAGE_NT_HEADERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature      = v_bytes(4)
        self.FileHeader     = IMAGE_FILE_HEADER()
        self.OptionalHeader = IMAGE_OPTIONAL_HEADER()

class IMAGE_NT_HEADERS64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature      = v_bytes(4)
        self.FileHeader     = IMAGE_FILE_HEADER()
        self.OptionalHeader = IMAGE_OPTIONAL_HEADER64()

class IMAGE_OPTIONAL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic                       = v_bytes(2)
        self.MajorLinkerVersion          = v_uint8()
        self.MinorLinkerVersion          = v_uint8()
        self.SizeOfCode                  = v_uint32()
        self.SizeOfInitializedData       = v_uint32()
        self.SizeOfUninitializedData     = v_uint32()
        self.AddressOfEntryPoint         = v_uint32()
        self.BaseOfCode                  = v_uint32()
        self.BaseOfData                  = v_uint32()
        self.ImageBase                   = v_uint32()
        self.SectionAlignment            = v_uint32()
        self.FileAlignment               = v_uint32()
        self.MajorOperatingSystemVersion = v_uint16()
        self.MinorOperatingSystemVersion = v_uint16()
        self.MajorImageVersion           = v_uint16()
        self.MinorImageVersion           = v_uint16()
        self.MajorSubsystemVersion       = v_uint16()
        self.MinorSubsystemVersion       = v_uint16()
        self.Win32VersionValue           = v_uint32()
        self.SizeOfImage                 = v_uint32()
        self.SizeOfHeaders               = v_uint32()
        self.CheckSum                    = v_uint32()
        self.Subsystem                   = v_uint16()
        self.DllCharacteristics          = v_uint16()
        self.SizeOfStackReserve          = v_uint32()
        self.SizeOfStackCommit           = v_uint32()
        self.SizeOfHeapReserve           = v_uint32()
        self.SizeOfHeapCommit            = v_uint32()
        self.LoaderFlags                 = v_uint32()
        self.NumberOfRvaAndSizes         = v_uint32()
        self.DataDirectory               = vstruct.VArray([IMAGE_DATA_DIRECTORY() for i in range(16)])

class IMAGE_OPTIONAL_HEADER64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic                       = v_bytes(2)
        self.MajorLinkerVersion          = v_uint8()
        self.MinorLinkerVersion          = v_uint8()
        self.SizeOfCode                  = v_uint32()
        self.SizeOfInitializedData       = v_uint32()
        self.SizeOfUninitializedData     = v_uint32()
        self.AddressOfEntryPoint         = v_uint32()
        self.BaseOfCode                  = v_uint32()
        self.ImageBase                   = v_uint64()
        self.SectionAlignment            = v_uint32()
        self.FileAlignment               = v_uint32()
        self.MajorOperatingSystemVersion = v_uint16()
        self.MinorOperatingSystemVersion = v_uint16()
        self.MajorImageVersion           = v_uint16()
        self.MinorImageVersion           = v_uint16()
        self.MajorSubsystemVersion       = v_uint16()
        self.MinorSubsystemVersion       = v_uint16()
        self.Win32VersionValue           = v_uint32()
        self.SizeOfImage                 = v_uint32()
        self.SizeOfHeaders               = v_uint32()
        self.CheckSum                    = v_uint32()
        self.Subsystem                   = v_uint16()
        self.DllCharacteristics          = v_uint16()
        self.SizeOfStackReserve          = v_uint64()
        self.SizeOfStackCommit           = v_uint64()
        self.SizeOfHeapReserve           = v_uint64()
        self.SizeOfHeapCommit            = v_uint64()
        self.LoaderFlags                 = v_uint32()
        self.NumberOfRvaAndSizes         = v_uint32()
        self.DataDirectory               = vstruct.VArray([IMAGE_DATA_DIRECTORY() for i in range(16)])

class IMAGE_RESOURCE_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Characteristics      = v_uint32()
        self.TimeDateStamp        = v_uint32()
        self.MajorVersion         = v_uint16()
        self.MinorVersion         = v_uint16()
        self.NumberOfNamedEntries = v_uint16()
        self.NumberOfIdEntries    = v_uint16()

class IMAGE_RESOURCE_DIRECTORY_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name           = v_uint32()
        self.OffsetToData   = v_uint32()

class IMAGE_RESOURCE_DATA_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OffsetToData   = v_uint32()
        self.Size           = v_uint32()
        self.CodePage       = v_uint32()
        self.Reserved       = v_uint32()

class VS_FIXEDFILEINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature          = v_uint32()
        self.StrucVersion       = v_uint32()
        self.FileVersionMS      = v_uint32()
        self.FileVersionLS      = v_uint32()
        self.ProductVersionMS   = v_uint32()
        self.ProductVersionLS   = v_uint32()
        self.FileFlagsMask      = v_uint32()
        self.FileFlags          = v_uint32()
        self.FileOS             = v_uint32()
        self.FileType           = v_uint32()
        self.FileSubtype        = v_uint32()
        self.FileDateMS         = v_uint32()
        self.FileDateLS         = v_uint32()

class IMAGE_SECTION_HEADER(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name                 = v_str(8)
        self.VirtualSize          = v_uint32()
        self.VirtualAddress       = v_uint32()
        self.SizeOfRawData        = v_uint32()
        self.PointerToRawData     = v_uint32()
        self.PointerToRelocations = v_uint32()
        self.PointerToLineNumbers = v_uint32()
        self.NumberOfRelocations  = v_uint16()
        self.NumberOfLineNumbers  = v_uint16()
        self.Characteristics      = v_uint32()


class IMAGE_RUNTIME_FUNCTION_ENTRY(vstruct.VStruct):
    """
    Used in the .pdata section of a PE32+ for all non
    leaf functions.
    """
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BeginAddress = v_uint32()
        self.EndAddress = v_uint32()
        self.UnwindInfoAddress = v_uint32()


########NEW FILE########
__FILENAME__ = rar
import vstruct
from vstruct.primitives import *

HEAD_TYPE_MARKER        = 0x72          #marker block
HEAD_TYPE_ARCHIVE       = 0x73          #archive header
HEAD_TYPE_FILE_HDR      = 0x74          #file header
HEAD_TYPE_OLD_COMMENT   = 0x75          #old style comment header
HEAD_TYPE_OLD_AUTH      = 0x76          #old style authenticity information
HEAD_TYPE_OLD_SUBBLOCK  = 0x77          #old style subblock
HEAD_TYPE_OLD_RECOVERY  = 0x78          #old style recovery record
HEAD_TYPE_OLD_AUTH2     = 0x79          #old style authenticity information
HEAD_TYPE_SUBBLOCK      = 0x7a          #subblock

class RarChunkUnkn(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CHUNK_BYTES = v_bytes()

class RarBlock(vstruct.VStruct):

    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HEAD_CRC       = v_uint16()
        self.HEAD_TYPE      = v_uint8()
        self.HEAD_FLAGS     = v_uint16()
        self.HEAD_SIZE      = v_uint16()
        self.ADD_SIZE       = v_uint32()
        self.BLOCK_DATA     = vstruct.VStruct()

    def pcb_HEAD_FLAGS(self):
        # a proto callback for the header
        if self.HEAD_FLAGS & 0x8000:
            self.ADD_SIZE = v_uint32()
        else:
            self.ADD_SIZE = vstruct.VStruct()

    def pcb_ADD_SIZE(self):
        hsize = 7
        totsize = self.HEAD_SIZE
        if not isinstance(self.ADD_SIZE, vstruct.VStruct):
            hsize += 4
            totsize += self.ADD_SIZE

        # We will *now* use TYPE to find out our chunk guts
        self.BLOCK_DATA = v_bytes(totsize - hsize)
        

if __name__ == '__main__':
    import sys

    offset = 0
    b = file(sys.argv[1], 'rb').read()

    while offset < len(b):
        r = RarBlock()
        offset = r.vsParse( b, offset=offset)
        print r.tree()
        

########NEW FILE########
__FILENAME__ = win32

# FIXME this is named wrong!

import vstruct
from vstruct.primitives import *

class CLIENT_ID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_ptr32()
        self.UniqueThread = v_ptr32()

class EXCEPTION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_ptr32()
        self.ExceptionAddress = v_ptr32()
        self.NumberParameters = v_uint32()

class EXCEPTION_REGISTRATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.prev = v_ptr32()
        self.handler = v_ptr32()

class HEAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.Signature = v_uint32()
        self.Flags = v_uint32()
        self.ForceFlags = v_uint32()
        self.VirtualMemoryThreshold = v_uint32()
        self.SegmentReserve = v_uint32()
        self.SegmentCommit = v_uint32()
        self.DeCommitFreeBlockThreshold = v_uint32()
        self.DeCommitTotalFreeThreshold = v_uint32()
        self.TotalFreeSize = v_uint32()
        self.MaximumAllocationSize = v_uint32()
        self.ProcessHeapsListIndex = v_uint16()
        self.HeaderValidateLength = v_uint16()
        self.HeaderValidateCopy = v_ptr32()
        self.NextAvailableTagIndex = v_uint16()
        self.MaximumTagIndex = v_uint16()
        self.TagEntries = v_ptr32()
        self.UCRSegments = v_ptr32()
        self.UnusedUnCommittedRanges = v_ptr32()
        self.AlignRound = v_uint32()
        self.AlignMask = v_uint32()
        self.VirtualAllocBlocks = ListEntry()
        self.Segments = vstruct.VArray([v_uint32() for i in range(64)])
        self.u = vstruct.VArray([v_uint8() for i in range(16)])
        self.u2 = vstruct.VArray([v_uint8() for i in range(2)])
        self.AllocatorBackTraceIndex = v_uint16()
        self.NonDedicatedListLength = v_uint32()
        self.LargeBlocksIndex = v_ptr32()
        self.PseudoTagEntries = v_ptr32()
        self.FreeLists = vstruct.VArray([ListEntry() for i in range(128)])
        self.LockVariable = v_uint32()
        self.CommitRoutine = v_ptr32()
        self.FrontEndHeap = v_ptr32()
        self.FrontEndHeapLockCount = v_uint16()
        self.FrontEndHeapType = v_uint8()
        self.LastSegmentIndex = v_uint8()

class HEAP_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.SegmentSignature = v_uint32()
        self.SegmentFlags = v_uint32()
        self.Heap = v_ptr32()
        self.LargestUncommitedRange = v_uint32()
        self.BaseAddress = v_ptr32()
        self.NumberOfPages = v_uint32()
        self.FirstEntry = v_ptr32()
        self.LastValidEntry = v_ptr32()
        self.NumberOfUnCommittedPages = v_uint32()
        self.NumberOfUnCommittedRanges = v_uint32()
        self.UncommittedRanges = v_ptr32()
        self.SegmentAllocatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self.LastEntryInSegment = v_ptr32()

class HEAP_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.PrevSize = v_uint16()
        self.SegmentIndex = v_uint8()
        self.Flags = v_uint8()
        self.Unused = v_uint8()
        self.TagIndex = v_uint8()

class ListEntry(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_ptr32()
        self.Blink = v_ptr32()

class NT_TIB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_ptr32()
        self.StackBase = v_ptr32()
        self.StackLimit = v_ptr32()
        self.SubSystemTib = v_ptr32()
        self.FiberData = v_ptr32()
        #x.Version = v_ptr32() # This is a union field
        self.ArbitraryUserPtr = v_ptr32()
        self.Self = v_ptr32()

class PEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InheritedAddressSpace = v_uint8()
        self.ReadImageFileExecOptions = v_uint8()
        self.BeingDebugged = v_uint8()
        self.SpareBool = v_uint8()
        self.Mutant = v_ptr32()
        self.ImageBaseAddress = v_ptr32()
        self.Ldr = v_ptr32()
        self.ProcessParameters = v_ptr32()
        self.SubSystemData = v_ptr32()
        self.ProcessHeap = v_ptr32()
        self.FastPebLock = v_ptr32()
        self.FastPebLockRoutine = v_ptr32()
        self.FastPebUnlockRoutine = v_ptr32()
        self.EnvironmentUpdateCount = v_uint32()
        self.KernelCallbackTable = v_ptr32()
        self.SystemReserved = v_uint32()
        self.AtlThunkSListPtr32 = v_ptr32()
        self.FreeList = v_ptr32()
        self.TlsExpansionCounter = v_uint32()
        self.TlsBitmap = v_ptr32()
        self.TlsBitmapBits = vstruct.VArray([v_uint32() for i in range(2)])
        self.ReadOnlySharedMemoryBase = v_ptr32()
        self.ReadOnlySharedMemoryHeap = v_ptr32()
        self.ReadOnlyStaticServerData = v_ptr32()
        self.AnsiCodePageData = v_ptr32()
        self.OemCodePageData = v_ptr32()
        self.UnicodeCaseTableData = v_ptr32()
        self.NumberOfProcessors = v_uint32()
        self.NtGlobalFlag = v_uint64()
        self.CriticalSectionTimeout = v_uint64()
        self.HeapSegmentReserve = v_uint32()
        self.HeapSegmentCommit = v_uint32()
        self.HeapDeCommitTotalFreeThreshold = v_uint32()
        self.HeapDeCommitFreeBlockThreshold = v_uint32()
        self.NumberOfHeaps = v_uint32()
        self.MaximumNumberOfHeaps = v_uint32()
        self.ProcessHeaps = v_ptr32()
        self.GdiSharedHandleTable = v_ptr32()
        self.ProcessStarterHelper = v_ptr32()
        self.GdiDCAttributeList = v_uint32()
        self.LoaderLock = v_ptr32()
        self.OSMajorVersion = v_uint32()
        self.OSMinorVersion = v_uint32()
        self.OSBuildNumber = v_uint16()
        self.OSCSDVersion = v_uint16()
        self.OSPlatformId = v_uint32()
        self.ImageSubsystem = v_uint32()
        self.ImageSubsystemMajorVersion = v_uint32()
        self.ImageSubsystemMinorVersion = v_uint32()
        self.ImageProcessAffinityMask = v_uint32()
        self.GdiHandleBuffer = vstruct.VArray([v_ptr32() for i in range(34)])
        self.PostProcessInitRoutine = v_ptr32()
        self.TlsExpansionBitmap = v_ptr32()
        self.TlsExpansionBitmapBits = vstruct.VArray([v_uint32() for i in range(32)])
        self.SessionId = v_uint32()
        self.AppCompatFlags = v_uint64()
        self.AppCompatFlagsUser = v_uint64()
        self.pShimData = v_ptr32()
        self.AppCompatInfo = v_ptr32()
        self.CSDVersion = v_ptr32()
        self.UNKNOWN = v_uint32()
        self.ActivationContextData = v_ptr32()
        self.ProcessAssemblyStorageMap = v_ptr32()
        self.SystemDefaultActivationContextData = v_ptr32()
        self.SystemAssemblyStorageMap = v_ptr32()
        self.MinimumStackCommit = v_uint32()

class SEH3_SCOPETABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnclosingLevel = v_int32()
        self.FilterFunction = v_ptr32()
        self.HandlerFunction = v_ptr32()

class SEH4_SCOPETABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GSCookieOffset = v_int32()
        self.GSCookieXOROffset = v_int32()
        self.EHCookieOffset = v_int32()
        self.EHCookieXOROffset = v_int32()
        self.EnclosingLevel = v_int32()
        self.FilterFunction = v_ptr32()
        self.HandlerFunction = v_ptr32()

class TEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TIB = NT_TIB()
        self.EnvironmentPointer = v_ptr32()
        self.ClientId = CLIENT_ID()
        self.ActiveRpcHandle = v_ptr32()
        self.ThreadLocalStorage = v_ptr32()
        self.ProcessEnvironmentBlock = v_ptr32()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_ptr32()
        self.Win32ThreadInfo = v_ptr32()
        self.User32Reserved = vstruct.VArray([v_uint32() for i in range(26)])
        self.UserReserved = vstruct.VArray([v_uint32() for i in range(5)])
        self.WOW32Reserved = v_ptr32()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()

class CLSID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.uuid = GUID()

class IID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.uuid = GUID()


########NEW FILE########
__FILENAME__ = ntdll
# Version: 5.1
# Architecture: i386
import vstruct
from vstruct.primitives import *

DEVICE_RELATION_TYPE = v_enum()
DEVICE_RELATION_TYPE.BusRelations = 0
DEVICE_RELATION_TYPE.EjectionRelations = 1
DEVICE_RELATION_TYPE.PowerRelations = 2
DEVICE_RELATION_TYPE.RemovalRelations = 3
DEVICE_RELATION_TYPE.TargetDeviceRelation = 4
DEVICE_RELATION_TYPE.SingleBusRelations = 5


IO_ALLOCATION_ACTION = v_enum()
IO_ALLOCATION_ACTION.KeepObject = 1
IO_ALLOCATION_ACTION.DeallocateObject = 2
IO_ALLOCATION_ACTION.DeallocateObjectKeepRegisters = 3


BUS_QUERY_ID_TYPE = v_enum()
BUS_QUERY_ID_TYPE.BusQueryDeviceID = 0
BUS_QUERY_ID_TYPE.BusQueryHardwareIDs = 1
BUS_QUERY_ID_TYPE.BusQueryCompatibleIDs = 2
BUS_QUERY_ID_TYPE.BusQueryInstanceID = 3
BUS_QUERY_ID_TYPE.BusQueryDeviceSerialNumber = 4


NT_PRODUCT_TYPE = v_enum()
NT_PRODUCT_TYPE.NtProductWinNt = 1
NT_PRODUCT_TYPE.NtProductLanManNt = 2
NT_PRODUCT_TYPE.NtProductServer = 3


DEVICE_POWER_STATE = v_enum()
DEVICE_POWER_STATE.PowerDeviceUnspecified = 0
DEVICE_POWER_STATE.PowerDeviceD0 = 1
DEVICE_POWER_STATE.PowerDeviceD1 = 2
DEVICE_POWER_STATE.PowerDeviceD2 = 3
DEVICE_POWER_STATE.PowerDeviceD3 = 4
DEVICE_POWER_STATE.PowerDeviceMaximum = 5


KSPIN_LOCK_QUEUE_NUMBER = v_enum()
KSPIN_LOCK_QUEUE_NUMBER.LockQueueDispatcherLock = 0
KSPIN_LOCK_QUEUE_NUMBER.LockQueueContextSwapLock = 1
KSPIN_LOCK_QUEUE_NUMBER.LockQueuePfnLock = 2
KSPIN_LOCK_QUEUE_NUMBER.LockQueueSystemSpaceLock = 3
KSPIN_LOCK_QUEUE_NUMBER.LockQueueVacbLock = 4
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMasterLock = 5
KSPIN_LOCK_QUEUE_NUMBER.LockQueueNonPagedPoolLock = 6
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoCancelLock = 7
KSPIN_LOCK_QUEUE_NUMBER.LockQueueWorkQueueLock = 8
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoVpbLock = 9
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoDatabaseLock = 10
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoCompletionLock = 11
KSPIN_LOCK_QUEUE_NUMBER.LockQueueNtfsStructLock = 12
KSPIN_LOCK_QUEUE_NUMBER.LockQueueAfdWorkQueueLock = 13
KSPIN_LOCK_QUEUE_NUMBER.LockQueueBcbLock = 14
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMaximumLock = 15


FSINFOCLASS = v_enum()
FSINFOCLASS.FileFsVolumeInformation = 1
FSINFOCLASS.FileFsLabelInformation = 2
FSINFOCLASS.FileFsSizeInformation = 3
FSINFOCLASS.FileFsDeviceInformation = 4
FSINFOCLASS.FileFsAttributeInformation = 5
FSINFOCLASS.FileFsControlInformation = 6
FSINFOCLASS.FileFsFullSizeInformation = 7
FSINFOCLASS.FileFsObjectIdInformation = 8
FSINFOCLASS.FileFsDriverPathInformation = 9
FSINFOCLASS.FileFsMaximumInformation = 10


POOL_TYPE = v_enum()
POOL_TYPE.NonPagedPool = 0
POOL_TYPE.PagedPool = 1
POOL_TYPE.NonPagedPoolMustSucceed = 2
POOL_TYPE.DontUseThisType = 3
POOL_TYPE.NonPagedPoolCacheAligned = 4
POOL_TYPE.PagedPoolCacheAligned = 5
POOL_TYPE.NonPagedPoolCacheAlignedMustS = 6
POOL_TYPE.MaxPoolType = 7
POOL_TYPE.NonPagedPoolSession = 32
POOL_TYPE.PagedPoolSession = 33
POOL_TYPE.NonPagedPoolMustSucceedSession = 34
POOL_TYPE.DontUseThisTypeSession = 35
POOL_TYPE.NonPagedPoolCacheAlignedSession = 36
POOL_TYPE.PagedPoolCacheAlignedSession = 37
POOL_TYPE.NonPagedPoolCacheAlignedMustSSession = 38


MODE = v_enum()
MODE.KernelMode = 0
MODE.UserMode = 1
MODE.MaximumMode = 2


FS_FILTER_SECTION_SYNC_TYPE = v_enum()
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeOther = 0
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeCreateSection = 1


OB_OPEN_REASON = v_enum()
OB_OPEN_REASON.ObCreateHandle = 0
OB_OPEN_REASON.ObOpenHandle = 1
OB_OPEN_REASON.ObDuplicateHandle = 2
OB_OPEN_REASON.ObInheritHandle = 3
OB_OPEN_REASON.ObMaxOpenReason = 4


DEVICE_TEXT_TYPE = v_enum()
DEVICE_TEXT_TYPE.DeviceTextDescription = 0
DEVICE_TEXT_TYPE.DeviceTextLocationInformation = 1


POWER_STATE_TYPE = v_enum()
POWER_STATE_TYPE.SystemPowerState = 0
POWER_STATE_TYPE.DevicePowerState = 1


FILE_INFORMATION_CLASS = v_enum()
FILE_INFORMATION_CLASS.FileDirectoryInformation = 1
FILE_INFORMATION_CLASS.FileFullDirectoryInformation = 2
FILE_INFORMATION_CLASS.FileBothDirectoryInformation = 3
FILE_INFORMATION_CLASS.FileBasicInformation = 4
FILE_INFORMATION_CLASS.FileStandardInformation = 5
FILE_INFORMATION_CLASS.FileInternalInformation = 6
FILE_INFORMATION_CLASS.FileEaInformation = 7
FILE_INFORMATION_CLASS.FileAccessInformation = 8
FILE_INFORMATION_CLASS.FileNameInformation = 9
FILE_INFORMATION_CLASS.FileRenameInformation = 10
FILE_INFORMATION_CLASS.FileLinkInformation = 11
FILE_INFORMATION_CLASS.FileNamesInformation = 12
FILE_INFORMATION_CLASS.FileDispositionInformation = 13
FILE_INFORMATION_CLASS.FilePositionInformation = 14
FILE_INFORMATION_CLASS.FileFullEaInformation = 15
FILE_INFORMATION_CLASS.FileModeInformation = 16
FILE_INFORMATION_CLASS.FileAlignmentInformation = 17
FILE_INFORMATION_CLASS.FileAllInformation = 18
FILE_INFORMATION_CLASS.FileAllocationInformation = 19
FILE_INFORMATION_CLASS.FileEndOfFileInformation = 20
FILE_INFORMATION_CLASS.FileAlternateNameInformation = 21
FILE_INFORMATION_CLASS.FileStreamInformation = 22
FILE_INFORMATION_CLASS.FilePipeInformation = 23
FILE_INFORMATION_CLASS.FilePipeLocalInformation = 24
FILE_INFORMATION_CLASS.FilePipeRemoteInformation = 25
FILE_INFORMATION_CLASS.FileMailslotQueryInformation = 26
FILE_INFORMATION_CLASS.FileMailslotSetInformation = 27
FILE_INFORMATION_CLASS.FileCompressionInformation = 28
FILE_INFORMATION_CLASS.FileObjectIdInformation = 29
FILE_INFORMATION_CLASS.FileCompletionInformation = 30
FILE_INFORMATION_CLASS.FileMoveClusterInformation = 31
FILE_INFORMATION_CLASS.FileQuotaInformation = 32
FILE_INFORMATION_CLASS.FileReparsePointInformation = 33
FILE_INFORMATION_CLASS.FileNetworkOpenInformation = 34
FILE_INFORMATION_CLASS.FileAttributeTagInformation = 35
FILE_INFORMATION_CLASS.FileTrackingInformation = 36
FILE_INFORMATION_CLASS.FileIdBothDirectoryInformation = 37
FILE_INFORMATION_CLASS.FileIdFullDirectoryInformation = 38
FILE_INFORMATION_CLASS.FileValidDataLengthInformation = 39
FILE_INFORMATION_CLASS.FileShortNameInformation = 40
FILE_INFORMATION_CLASS.FileMaximumInformation = 41


EXCEPTION_DISPOSITION = v_enum()
EXCEPTION_DISPOSITION.ExceptionContinueExecution = 0
EXCEPTION_DISPOSITION.ExceptionContinueSearch = 1
EXCEPTION_DISPOSITION.ExceptionNestedException = 2
EXCEPTION_DISPOSITION.ExceptionCollidedUnwind = 3


PF_SCENARIO_TYPE = v_enum()
PF_SCENARIO_TYPE.PfApplicationLaunchScenarioType = 0
PF_SCENARIO_TYPE.PfSystemBootScenarioType = 1
PF_SCENARIO_TYPE.PfMaxScenarioType = 2


SECURITY_OPERATION_CODE = v_enum()
SECURITY_OPERATION_CODE.SetSecurityDescriptor = 0
SECURITY_OPERATION_CODE.QuerySecurityDescriptor = 1
SECURITY_OPERATION_CODE.DeleteSecurityDescriptor = 2
SECURITY_OPERATION_CODE.AssignSecurityDescriptor = 3


PP_NPAGED_LOOKASIDE_NUMBER = v_enum()
PP_NPAGED_LOOKASIDE_NUMBER.LookasideSmallIrpList = 0
PP_NPAGED_LOOKASIDE_NUMBER.LookasideLargeIrpList = 1
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMdlList = 2
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCreateInfoList = 3
PP_NPAGED_LOOKASIDE_NUMBER.LookasideNameBufferList = 4
PP_NPAGED_LOOKASIDE_NUMBER.LookasideTwilightList = 5
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCompletionList = 6
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMaximumList = 7


SECURITY_IMPERSONATION_LEVEL = v_enum()
SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous = 0
SECURITY_IMPERSONATION_LEVEL.SecurityIdentification = 1
SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation = 2
SECURITY_IMPERSONATION_LEVEL.SecurityDelegation = 3


DEVICE_USAGE_NOTIFICATION_TYPE = v_enum()
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeUndefined = 0
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypePaging = 1
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeHibernation = 2
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeDumpFile = 3


INTERFACE_TYPE = v_enum()
INTERFACE_TYPE.InterfaceTypeUndefined = -1
INTERFACE_TYPE.Internal = 0
INTERFACE_TYPE.Isa = 1
INTERFACE_TYPE.Eisa = 2
INTERFACE_TYPE.MicroChannel = 3
INTERFACE_TYPE.TurboChannel = 4
INTERFACE_TYPE.PCIBus = 5
INTERFACE_TYPE.VMEBus = 6
INTERFACE_TYPE.NuBus = 7
INTERFACE_TYPE.PCMCIABus = 8
INTERFACE_TYPE.CBus = 9
INTERFACE_TYPE.MPIBus = 10
INTERFACE_TYPE.MPSABus = 11
INTERFACE_TYPE.ProcessorInternal = 12
INTERFACE_TYPE.InternalPowerBus = 13
INTERFACE_TYPE.PNPISABus = 14
INTERFACE_TYPE.PNPBus = 15
INTERFACE_TYPE.MaximumInterfaceType = 16


KWAIT_REASON = v_enum()
KWAIT_REASON.Executive = 0
KWAIT_REASON.FreePage = 1
KWAIT_REASON.PageIn = 2
KWAIT_REASON.PoolAllocation = 3
KWAIT_REASON.DelayExecution = 4
KWAIT_REASON.Suspended = 5
KWAIT_REASON.UserRequest = 6
KWAIT_REASON.WrExecutive = 7
KWAIT_REASON.WrFreePage = 8
KWAIT_REASON.WrPageIn = 9
KWAIT_REASON.WrPoolAllocation = 10
KWAIT_REASON.WrDelayExecution = 11
KWAIT_REASON.WrSuspended = 12
KWAIT_REASON.WrUserRequest = 13
KWAIT_REASON.WrEventPair = 14
KWAIT_REASON.WrQueue = 15
KWAIT_REASON.WrLpcReceive = 16
KWAIT_REASON.WrLpcReply = 17
KWAIT_REASON.WrVirtualMemory = 18
KWAIT_REASON.WrPageOut = 19
KWAIT_REASON.WrRendezvous = 20
KWAIT_REASON.Spare2 = 21
KWAIT_REASON.Spare3 = 22
KWAIT_REASON.Spare4 = 23
KWAIT_REASON.Spare5 = 24
KWAIT_REASON.Spare6 = 25
KWAIT_REASON.WrKernel = 26
KWAIT_REASON.MaximumWaitReason = 27


ALTERNATIVE_ARCHITECTURE_TYPE = v_enum()
ALTERNATIVE_ARCHITECTURE_TYPE.StandardDesign = 0
ALTERNATIVE_ARCHITECTURE_TYPE.NEC98x86 = 1
ALTERNATIVE_ARCHITECTURE_TYPE.EndAlternatives = 2


MEMORY_TYPE = v_enum()
MEMORY_TYPE.MemoryExceptionBlock = 0
MEMORY_TYPE.MemorySystemBlock = 1
MEMORY_TYPE.MemoryFree = 2
MEMORY_TYPE.MemoryBad = 3
MEMORY_TYPE.MemoryLoadedProgram = 4
MEMORY_TYPE.MemoryFirmwareTemporary = 5
MEMORY_TYPE.MemoryFirmwarePermanent = 6
MEMORY_TYPE.MemoryFreeContiguous = 7
MEMORY_TYPE.MemorySpecialMemory = 8
MEMORY_TYPE.MemoryMaximum = 9


PS_QUOTA_TYPE = v_enum()
PS_QUOTA_TYPE.PsNonPagedPool = 0
PS_QUOTA_TYPE.PsPagedPool = 1
PS_QUOTA_TYPE.PsPageFile = 2
PS_QUOTA_TYPE.PsQuotaTypes = 3


ReplacesCorHdrNumericDefines = v_enum()
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY = 1
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED = 2
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY = 4
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED = 8
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2 = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MINOR = 0
ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB = 1
ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA = 1
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA = 2
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT = 1
ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT = 2
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED = 4
ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED = 16
ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE = 32
ReplacesCorHdrNumericDefines.MAX_CLASS_NAME = 1024
ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME = 1024


SYSTEM_POWER_STATE = v_enum()
SYSTEM_POWER_STATE.PowerSystemUnspecified = 0
SYSTEM_POWER_STATE.PowerSystemWorking = 1
SYSTEM_POWER_STATE.PowerSystemSleeping1 = 2
SYSTEM_POWER_STATE.PowerSystemSleeping2 = 3
SYSTEM_POWER_STATE.PowerSystemSleeping3 = 4
SYSTEM_POWER_STATE.PowerSystemHibernate = 5
SYSTEM_POWER_STATE.PowerSystemShutdown = 6
SYSTEM_POWER_STATE.PowerSystemMaximum = 7


MEMORY_CACHING_TYPE_ORIG = v_enum()
MEMORY_CACHING_TYPE_ORIG.MmFrameBufferCached = 2


POWER_ACTION = v_enum()
POWER_ACTION.PowerActionNone = 0
POWER_ACTION.PowerActionReserved = 1
POWER_ACTION.PowerActionSleep = 2
POWER_ACTION.PowerActionHibernate = 3
POWER_ACTION.PowerActionShutdown = 4
POWER_ACTION.PowerActionShutdownReset = 5
POWER_ACTION.PowerActionShutdownOff = 6
POWER_ACTION.PowerActionWarmEject = 7


class _unnamed_5821(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumChannel = v_uint32()
        self.MaximumChannel = v_uint32()


class KEXECUTE_OPTIONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteDisable = v_uint8()


class _unnamed_5824(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(3) ])


class _unnamed_5826(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.MinBusNumber = v_uint32()
        self.MaxBusNumber = v_uint32()
        self.Reserved = v_uint32()


class KPRCB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinorVersion = v_uint16()
        self.MajorVersion = v_uint16()
        self.CurrentThread = v_ptr32()
        self.NextThread = v_ptr32()
        self.IdleThread = v_ptr32()
        self.Number = v_uint8()
        self.Reserved = v_uint8()
        self.BuildType = v_uint16()
        self.SetMember = v_uint32()
        self.CpuType = v_uint8()
        self.CpuID = v_uint8()
        self.CpuStep = v_uint16()
        self.ProcessorState = KPROCESSOR_STATE()
        self.KernelReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.HalReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.PrcbPad0 = vstruct.VArray([ v_uint8() for i in xrange(92) ])
        self.LockQueue = vstruct.VArray([ KSPIN_LOCK_QUEUE() for i in xrange(16) ])
        self.PrcbPad1 = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.NpxThread = v_ptr32()
        self.InterruptCount = v_uint32()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.DpcTime = v_uint32()
        self.DebugDpcTime = v_uint32()
        self.InterruptTime = v_uint32()
        self.AdjustDpcThreshold = v_uint32()
        self.PageColor = v_uint32()
        self.SkipTick = v_uint32()
        self.MultiThreadSetBusy = v_uint8()
        self.Spare2 = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.ParentNode = v_ptr32()
        self.MultiThreadProcessorSet = v_uint32()
        self.MultiThreadSetMaster = v_ptr32()
        self.ThreadStartCount = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.CcFastReadNoWait = v_uint32()
        self.CcFastReadWait = v_uint32()
        self.CcFastReadNotPossible = v_uint32()
        self.CcCopyReadNoWait = v_uint32()
        self.CcCopyReadWait = v_uint32()
        self.CcCopyReadNoWaitMiss = v_uint32()
        self.KeAlignmentFixupCount = v_uint32()
        self.KeContextSwitches = v_uint32()
        self.KeDcacheFlushCount = v_uint32()
        self.KeExceptionDispatchCount = v_uint32()
        self.KeFirstLevelTbFills = v_uint32()
        self.KeFloatingEmulationCount = v_uint32()
        self.KeIcacheFlushCount = v_uint32()
        self.KeSecondLevelTbFills = v_uint32()
        self.KeSystemCalls = v_uint32()
        self.SpareCounter0 = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.PPLookasideList = vstruct.VArray([ PP_LOOKASIDE_LIST() for i in xrange(16) ])
        self.PPNPagedLookasideList = vstruct.VArray([ PP_LOOKASIDE_LIST() for i in xrange(32) ])
        self.PPPagedLookasideList = vstruct.VArray([ PP_LOOKASIDE_LIST() for i in xrange(32) ])
        self.PacketBarrier = v_uint32()
        self.ReverseStall = v_uint32()
        self.IpiFrame = v_ptr32()
        self.PrcbPad2 = vstruct.VArray([ v_uint8() for i in xrange(52) ])
        self.CurrentPacket = vstruct.VArray([ v_ptr32() for i in xrange(3) ])
        self.TargetSet = v_uint32()
        self.WorkerRoutine = v_ptr32()
        self.IpiFrozen = v_uint32()
        self.PrcbPad3 = vstruct.VArray([ v_uint8() for i in xrange(40) ])
        self.RequestSummary = v_uint32()
        self.SignalDone = v_ptr32()
        self.PrcbPad4 = vstruct.VArray([ v_uint8() for i in xrange(56) ])
        self.DpcListHead = LIST_ENTRY()
        self.DpcStack = v_ptr32()
        self.DpcCount = v_uint32()
        self.DpcQueueDepth = v_uint32()
        self.DpcRoutineActive = v_uint32()
        self.DpcInterruptRequested = v_uint32()
        self.DpcLastCount = v_uint32()
        self.DpcRequestRate = v_uint32()
        self.MaximumDpcQueueDepth = v_uint32()
        self.MinimumDpcRate = v_uint32()
        self.QuantumEnd = v_uint32()
        self.PrcbPad5 = vstruct.VArray([ v_uint8() for i in xrange(16) ])
        self.DpcLock = v_uint32()
        self.PrcbPad6 = vstruct.VArray([ v_uint8() for i in xrange(28) ])
        self.CallDpc = KDPC()
        self.ChainedInterruptList = v_ptr32()
        self.LookasideIrpFloat = v_uint32()
        self.SpareFields0 = vstruct.VArray([ v_uint32() for i in xrange(6) ])
        self.VendorString = vstruct.VArray([ v_uint8() for i in xrange(13) ])
        self.InitialApicId = v_uint8()
        self.LogicalProcessorsPerPhysicalProcessor = v_uint8()
        self._pad0910 = v_bytes(size=1)
        self.MHz = v_uint32()
        self.FeatureBits = v_uint32()
        self.UpdateSignature = LARGE_INTEGER()
        self.NpxSaveArea = FX_SAVE_AREA()
        self.PowerState = PROCESSOR_POWER_STATE()


class _unnamed_5494(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()


class OBJECT_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.RootDirectory = v_ptr32()
        self.ObjectName = v_ptr32()
        self.Attributes = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.SecurityQualityOfService = v_ptr32()


class IO_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReadOperationCount = v_uint64()
        self.WriteOperationCount = v_uint64()
        self.OtherOperationCount = v_uint64()
        self.ReadTransferCount = v_uint64()
        self.WriteTransferCount = v_uint64()
        self.OtherTransferCount = v_uint64()


class KSYSTEM_TIME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.High1Time = v_uint32()
        self.High2Time = v_uint32()


class CM_FULL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.PartialResourceList = CM_PARTIAL_RESOURCE_LIST()


class EXCEPTION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_ptr32()
        self.ExceptionAddress = v_ptr32()
        self.NumberParameters = v_uint32()
        self.ExceptionInformation = vstruct.VArray([ v_uint32() for i in xrange(15) ])


class SID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.SubAuthorityCount = v_uint8()
        self.IdentifierAuthority = SID_IDENTIFIER_AUTHORITY()
        self.SubAuthority = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class PS_JOB_TOKEN_FILTER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CapturedSidCount = v_uint32()
        self.CapturedSids = v_ptr32()
        self.CapturedSidsLength = v_uint32()
        self.CapturedGroupCount = v_uint32()
        self.CapturedGroups = v_ptr32()
        self.CapturedGroupsLength = v_uint32()
        self.CapturedPrivilegeCount = v_uint32()
        self.CapturedPrivileges = v_ptr32()
        self.CapturedPrivilegesLength = v_uint32()


class KSPIN_LOCK_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Lock = v_ptr32()


class FAST_IO_DISPATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFastIoDispatch = v_uint32()
        self.FastIoCheckIfPossible = v_ptr32()
        self.FastIoRead = v_ptr32()
        self.FastIoWrite = v_ptr32()
        self.FastIoQueryBasicInfo = v_ptr32()
        self.FastIoQueryStandardInfo = v_ptr32()
        self.FastIoLock = v_ptr32()
        self.FastIoUnlockSingle = v_ptr32()
        self.FastIoUnlockAll = v_ptr32()
        self.FastIoUnlockAllByKey = v_ptr32()
        self.FastIoDeviceControl = v_ptr32()
        self.AcquireFileForNtCreateSection = v_ptr32()
        self.ReleaseFileForNtCreateSection = v_ptr32()
        self.FastIoDetachDevice = v_ptr32()
        self.FastIoQueryNetworkOpenInfo = v_ptr32()
        self.AcquireForModWrite = v_ptr32()
        self.MdlRead = v_ptr32()
        self.MdlReadComplete = v_ptr32()
        self.PrepareMdlWrite = v_ptr32()
        self.MdlWriteComplete = v_ptr32()
        self.FastIoReadCompressed = v_ptr32()
        self.FastIoWriteCompressed = v_ptr32()
        self.MdlReadCompleteCompressed = v_ptr32()
        self.MdlWriteCompleteCompressed = v_ptr32()
        self.FastIoQueryOpen = v_ptr32()
        self.ReleaseForModWrite = v_ptr32()
        self.AcquireForCcFlush = v_ptr32()
        self.ReleaseForCcFlush = v_ptr32()


class _unnamed_5463(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self.Length = v_uint32()


class FS_FILTER_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbacks = v_uint32()
        self.Reserved = v_uint32()
        self.PreAcquireForSectionSynchronization = v_ptr32()
        self.PostAcquireForSectionSynchronization = v_ptr32()
        self.PreReleaseForSectionSynchronization = v_ptr32()
        self.PostReleaseForSectionSynchronization = v_ptr32()
        self.PreAcquireForCcFlush = v_ptr32()
        self.PostAcquireForCcFlush = v_ptr32()
        self.PreReleaseForCcFlush = v_ptr32()
        self.PostReleaseForCcFlush = v_ptr32()
        self.PreAcquireForModifiedPageWriter = v_ptr32()
        self.PostAcquireForModifiedPageWriter = v_ptr32()
        self.PreReleaseForModifiedPageWriter = v_ptr32()
        self.PostReleaseForModifiedPageWriter = v_ptr32()


class _unnamed_5754(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ResourceToRelease = v_ptr32()


class _unnamed_5466(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self.SecurityDescriptor = v_ptr32()


class IMAGE_FILE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Machine = v_uint16()
        self.NumberOfSections = v_uint16()
        self.TimeDateStamp = v_uint32()
        self.PointerToSymbolTable = v_uint32()
        self.NumberOfSymbols = v_uint32()
        self.SizeOfOptionalHeader = v_uint16()
        self.Characteristics = v_uint16()


class IO_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Option = v_uint8()
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Spare1 = v_uint8()
        self.Flags = v_uint16()
        self.Spare2 = v_uint16()
        self.u = _unnamed_5804()


class EX_PUSH_LOCK_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locks = vstruct.VArray([ v_ptr32() for i in xrange(32) ])


class MMWSL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_4716(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserApcRoutine = v_ptr32()
        self.UserApcContext = v_ptr32()


class CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DosPath = UNICODE_STRING()
        self.Handle = v_ptr32()


class RTL_TRACE_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint32()
        self.Count = v_uint32()
        self.Size = v_uint32()
        self.UserCount = v_uint32()
        self.UserSize = v_uint32()
        self.UserContext = v_ptr32()
        self.Next = v_ptr32()
        self.Trace = v_ptr32()


class IMAGE_OPTIONAL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint16()
        self.MajorLinkerVersion = v_uint8()
        self.MinorLinkerVersion = v_uint8()
        self.SizeOfCode = v_uint32()
        self.SizeOfInitializedData = v_uint32()
        self.SizeOfUninitializedData = v_uint32()
        self.AddressOfEntryPoint = v_uint32()
        self.BaseOfCode = v_uint32()
        self.BaseOfData = v_uint32()
        self.ImageBase = v_uint32()
        self.SectionAlignment = v_uint32()
        self.FileAlignment = v_uint32()
        self.MajorOperatingSystemVersion = v_uint16()
        self.MinorOperatingSystemVersion = v_uint16()
        self.MajorImageVersion = v_uint16()
        self.MinorImageVersion = v_uint16()
        self.MajorSubsystemVersion = v_uint16()
        self.MinorSubsystemVersion = v_uint16()
        self.Win32VersionValue = v_uint32()
        self.SizeOfImage = v_uint32()
        self.SizeOfHeaders = v_uint32()
        self.CheckSum = v_uint32()
        self.Subsystem = v_uint16()
        self.DllCharacteristics = v_uint16()
        self.SizeOfStackReserve = v_uint32()
        self.SizeOfStackCommit = v_uint32()
        self.SizeOfHeapReserve = v_uint32()
        self.SizeOfHeapCommit = v_uint32()
        self.LoaderFlags = v_uint32()
        self.NumberOfRvaAndSizes = v_uint32()
        self.DataDirectory = vstruct.VArray([ IMAGE_DATA_DIRECTORY() for i in xrange(16) ])


class SCSI_REQUEST_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class IMAGE_NT_HEADERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.FileHeader = IMAGE_FILE_HEADER()
        self.OptionalHeader = IMAGE_OPTIONAL_HEADER()


class ETHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Tcb = KTHREAD()
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self.ExitStatus = v_uint32()
        self.PostBlockList = LIST_ENTRY()
        self.TerminationPort = v_ptr32()
        self.ActiveTimerListLock = v_uint32()
        self.ActiveTimerListHead = LIST_ENTRY()
        self.Cid = CLIENT_ID()
        self.LpcReplySemaphore = KSEMAPHORE()
        self.LpcReplyMessage = v_ptr32()
        self.ImpersonationInfo = v_ptr32()
        self.IrpList = LIST_ENTRY()
        self.TopLevelIrp = v_uint32()
        self.DeviceToVerify = v_ptr32()
        self.ThreadsProcess = v_ptr32()
        self.StartAddress = v_ptr32()
        self.Win32StartAddress = v_ptr32()
        self.ThreadListEntry = LIST_ENTRY()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.ThreadLock = EX_PUSH_LOCK()
        self.LpcReplyMessageId = v_uint32()
        self.ReadClusterSize = v_uint32()
        self.GrantedAccess = v_uint32()
        self.CrossThreadFlags = v_uint32()
        self.SameThreadPassiveFlags = v_uint32()
        self.SameThreadApcFlags = v_uint32()
        self.ForwardClusterOnly = v_uint8()
        self.DisablePageFaultClustering = v_uint8()
        self._pad0258 = v_bytes(size=2)


class PEB_LDR_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Initialized = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.SsHandle = v_ptr32()
        self.InLoadOrderModuleList = LIST_ENTRY()
        self.InMemoryOrderModuleList = LIST_ENTRY()
        self.InInitializationOrderModuleList = LIST_ENTRY()
        self.EntryInProgress = v_ptr32()


class _unnamed_5458(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self.InputBufferLength = v_uint32()
        self.IoControlCode = v_uint32()
        self.Type3InputBuffer = v_ptr32()


class EPROCESS_QUOTA_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Usage = v_uint32()
        self.Limit = v_uint32()
        self.Peak = v_uint32()
        self.Return = v_uint32()


class VPB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.Flags = v_uint16()
        self.VolumeLabelLength = v_uint16()
        self.DeviceObject = v_ptr32()
        self.RealDevice = v_ptr32()
        self.SerialNumber = v_uint32()
        self.ReferenceCount = v_uint32()
        self.VolumeLabel = vstruct.VArray([ v_uint16() for i in xrange(32) ])


class HEAP_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.PreviousSize = v_uint16()
        self.SmallTagIndex = v_uint8()
        self.Flags = v_uint8()
        self.UnusedBytes = v_uint8()
        self.SegmentIndex = v_uint8()


class _unnamed_5481(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.StartSid = v_ptr32()
        self.SidList = v_ptr32()
        self.SidListLength = v_uint32()


class RTL_CRITICAL_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DebugInfo = v_ptr32()
        self.LockCount = v_uint32()
        self.RecursionCount = v_uint32()
        self.OwningThread = v_ptr32()
        self.LockSemaphore = v_ptr32()
        self.SpinCount = v_uint32()


class HANDLE_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TableCode = v_uint32()
        self.QuotaProcess = v_ptr32()
        self.UniqueProcessId = v_ptr32()
        self.HandleTableLock = vstruct.VArray([ EX_PUSH_LOCK() for i in xrange(4) ])
        self.HandleTableList = LIST_ENTRY()
        self.HandleContentionEvent = EX_PUSH_LOCK()
        self.DebugInfo = v_ptr32()
        self.ExtraInfoPages = v_uint32()
        self.FirstFree = v_uint32()
        self.LastFree = v_uint32()
        self.NextHandleNeedingPool = v_uint32()
        self.HandleCount = v_uint32()
        self.Flags = v_uint32()


class SECURITY_SUBJECT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientToken = v_ptr32()
        self.ImpersonationLevel = v_uint32()
        self.PrimaryToken = v_ptr32()
        self.ProcessAuditId = v_ptr32()


class KDEVICE_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceListHead = LIST_ENTRY()
        self.Lock = v_uint32()
        self.Busy = v_uint8()
        self._pad0014 = v_bytes(size=3)


class PROCESSOR_POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleFunction = v_ptr32()
        self.Idle0KernelTimeLimit = v_uint32()
        self.Idle0LastTime = v_uint32()
        self.IdleHandlers = v_ptr32()
        self.IdleState = v_ptr32()
        self.IdleHandlersCount = v_uint32()
        self.LastCheck = v_uint64()
        self.IdleTimes = PROCESSOR_IDLE_TIMES()
        self.IdleTime1 = v_uint32()
        self.PromotionCheck = v_uint32()
        self.IdleTime2 = v_uint32()
        self.CurrentThrottle = v_uint8()
        self.ThermalThrottleLimit = v_uint8()
        self.CurrentThrottleIndex = v_uint8()
        self.ThermalThrottleIndex = v_uint8()
        self.LastKernelUserTime = v_uint32()
        self.LastIdleThreadKernelTime = v_uint32()
        self.PackageIdleStartTime = v_uint32()
        self.PackageIdleTime = v_uint32()
        self.DebugCount = v_uint32()
        self.LastSysTime = v_uint32()
        self.TotalIdleStateTime = vstruct.VArray([ v_uint64() for i in xrange(3) ])
        self.TotalIdleTransitions = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self._pad0090 = v_bytes(size=4)
        self.PreviousC3StateTime = v_uint64()
        self.KneeThrottleIndex = v_uint8()
        self.ThrottleLimitIndex = v_uint8()
        self.PerfStatesCount = v_uint8()
        self.ProcessorMinThrottle = v_uint8()
        self.ProcessorMaxThrottle = v_uint8()
        self.EnableIdleAccounting = v_uint8()
        self.LastC3Percentage = v_uint8()
        self.LastAdjustedBusyPercentage = v_uint8()
        self.PromotionCount = v_uint32()
        self.DemotionCount = v_uint32()
        self.ErrorCount = v_uint32()
        self.RetryCount = v_uint32()
        self.Flags = v_uint32()
        self._pad00b8 = v_bytes(size=4)
        self.PerfCounterFrequency = LARGE_INTEGER()
        self.PerfTickCount = v_uint32()
        self._pad00c8 = v_bytes(size=4)
        self.PerfTimer = KTIMER()
        self.PerfDpc = KDPC()
        self.PerfStates = v_ptr32()
        self.PerfSetThrottle = v_ptr32()
        self.LastC3KernelUserTime = v_uint32()
        self.LastPackageIdleTime = v_uint32()


class FLOATING_SAVE_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint32()
        self.StatusWord = v_uint32()
        self.TagWord = v_uint32()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint32()
        self.RegisterArea = vstruct.VArray([ v_uint8() for i in xrange(80) ])
        self.Cr0NpxState = v_uint32()


class DPH_HEAP_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pNextAlloc = v_ptr32()
        self.pVirtualBlock = v_ptr32()
        self.nVirtualBlockSize = v_uint32()
        self.nVirtualAccessSize = v_uint32()
        self.pUserAllocation = v_ptr32()
        self.nUserRequestedSize = v_uint32()
        self.nUserActualSize = v_uint32()
        self.UserValue = v_ptr32()
        self.UserFlags = v_uint32()
        self.StackTrace = v_ptr32()


class KQUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.EntryListHead = LIST_ENTRY()
        self.CurrentCount = v_uint32()
        self.MaximumCount = v_uint32()
        self.ThreadListHead = LIST_ENTRY()


class RTL_TRACE_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint32()
        self.Database = v_ptr32()
        self.NextSegment = v_ptr32()
        self.TotalSize = v_uint32()
        self.SegmentStart = v_ptr32()
        self.SegmentEnd = v_ptr32()
        self.SegmentFree = v_ptr32()


class _unnamed_4337(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CriticalSection = RTL_CRITICAL_SECTION()
        self._pad0038 = v_bytes(size=32)


class IO_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityQos = v_ptr32()
        self.AccessState = v_ptr32()
        self.DesiredAccess = v_uint32()
        self.FullCreateOptions = v_uint32()


class LUID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Luid = LUID()
        self.Attributes = v_uint32()


class TERMINATION_PORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Port = v_ptr32()


class CM_PARTIAL_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.PartialDescriptors = vstruct.VArray([ CM_PARTIAL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class _unnamed_5416(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileInformationClass = v_uint32()


class DEVICE_CAPABILITIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.DeviceD1 = v_uint32()
        self.Address = v_uint32()
        self.UINumber = v_uint32()
        self.DeviceState = vstruct.VArray([ DEVICE_POWER_STATE() for i in xrange(7) ])
        self.SystemWake = v_uint32()
        self.DeviceWake = v_uint32()
        self.D1Latency = v_uint32()
        self.D2Latency = v_uint32()
        self.D3Latency = v_uint32()


class _unnamed_5413(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.CompletionFilter = v_uint32()


class INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Context = v_ptr32()
        self.InterfaceReference = v_ptr32()
        self.InterfaceDereference = v_ptr32()


class SLIST_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Alignment = v_uint64()


class _unnamed_5419(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileInformationClass = v_uint32()
        self.FileObject = v_ptr32()
        self.ReplaceIfExists = v_uint8()
        self.AdvanceOnly = v_uint8()
        self._pad0010 = v_bytes(size=2)


class HEAP_UNCOMMMTTED_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Address = v_uint32()
        self.Size = v_uint32()
        self.filler = v_uint32()


class KTHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.MutantListHead = LIST_ENTRY()
        self.InitialStack = v_ptr32()
        self.StackLimit = v_ptr32()
        self.Teb = v_ptr32()
        self.TlsArray = v_ptr32()
        self.KernelStack = v_ptr32()
        self.DebugActive = v_uint8()
        self.State = v_uint8()
        self.Alerted = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.Iopl = v_uint8()
        self.NpxState = v_uint8()
        self.Saturation = v_uint8()
        self.Priority = v_uint8()
        self.ApcState = KAPC_STATE()
        self.ContextSwitches = v_uint32()
        self.IdleSwapBlock = v_uint8()
        self.Spare0 = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.WaitStatus = v_uint32()
        self.WaitIrql = v_uint8()
        self.WaitMode = v_uint8()
        self.WaitNext = v_uint8()
        self.WaitReason = v_uint8()
        self.WaitBlockList = v_ptr32()
        self.WaitListEntry = LIST_ENTRY()
        self.WaitTime = v_uint32()
        self.BasePriority = v_uint8()
        self.DecrementCount = v_uint8()
        self.PriorityDecrement = v_uint8()
        self.Quantum = v_uint8()
        self.WaitBlock = vstruct.VArray([ KWAIT_BLOCK() for i in xrange(4) ])
        self.LegoData = v_ptr32()
        self.KernelApcDisable = v_uint32()
        self.UserAffinity = v_uint32()
        self.SystemAffinityActive = v_uint8()
        self.PowerState = v_uint8()
        self.NpxIrql = v_uint8()
        self.InitialNode = v_uint8()
        self.ServiceTable = v_ptr32()
        self.Queue = v_ptr32()
        self.ApcQueueLock = v_uint32()
        self._pad00f0 = v_bytes(size=4)
        self.Timer = KTIMER()
        self.QueueListEntry = LIST_ENTRY()
        self.SoftAffinity = v_uint32()
        self.Affinity = v_uint32()
        self.Preempted = v_uint8()
        self.ProcessReadyQueue = v_uint8()
        self.KernelStackResident = v_uint8()
        self.NextProcessor = v_uint8()
        self.CallbackStack = v_ptr32()
        self.Win32Thread = v_ptr32()
        self.TrapFrame = v_ptr32()
        self.ApcStatePointer = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self.PreviousMode = v_uint8()
        self.EnableStackSwap = v_uint8()
        self.LargeStack = v_uint8()
        self.ResourceIndex = v_uint8()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.SavedApcState = KAPC_STATE()
        self.Alertable = v_uint8()
        self.ApcStateIndex = v_uint8()
        self.ApcQueueable = v_uint8()
        self.AutoAlignment = v_uint8()
        self.StackBase = v_ptr32()
        self.SuspendApc = KAPC()
        self.SuspendSemaphore = KSEMAPHORE()
        self.ThreadListEntry = LIST_ENTRY()
        self.FreezeCount = v_uint8()
        self.SuspendCount = v_uint8()
        self.IdealProcessor = v_uint8()
        self.DisableBoost = v_uint8()
        self._pad01c0 = v_bytes(size=4)


class PP_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P = v_ptr32()
        self.L = v_ptr32()


class _unnamed_5638(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedResources = v_ptr32()
        self.AllocatedResourcesTranslated = v_ptr32()


class IMAGE_DATA_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_uint32()
        self.Size = v_uint32()


class KAPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.Spare0 = v_uint32()
        self.Thread = v_ptr32()
        self.ApcListEntry = LIST_ENTRY()
        self.KernelRoutine = v_ptr32()
        self.RundownRoutine = v_ptr32()
        self.NormalRoutine = v_ptr32()
        self.NormalContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.ApcStateIndex = v_uint8()
        self.ApcMode = v_uint8()
        self.Inserted = v_uint8()
        self._pad0030 = v_bytes(size=1)


class PROCESSOR_IDLE_TIMES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartTime = v_uint64()
        self.EndTime = v_uint64()
        self.IdleHandlerReserved = vstruct.VArray([ v_uint32() for i in xrange(4) ])


class KWAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitListEntry = LIST_ENTRY()
        self.Thread = v_ptr32()
        self.Object = v_ptr32()
        self.NextWaitBlock = v_ptr32()
        self.WaitKey = v_uint16()
        self.WaitType = v_uint16()


class KPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.ProfileListHead = LIST_ENTRY()
        self.DirectoryTableBase = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.LdtDescriptor = KGDTENTRY()
        self.Int21Descriptor = KIDTENTRY()
        self.IopmOffset = v_uint16()
        self.Iopl = v_uint8()
        self.Unused = v_uint8()
        self.ActiveProcessors = v_uint32()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.ReadyListHead = LIST_ENTRY()
        self.SwapListEntry = SINGLE_LIST_ENTRY()
        self.VdmTrapcHandler = v_ptr32()
        self.ThreadListHead = LIST_ENTRY()
        self.ProcessLock = v_uint32()
        self.Affinity = v_uint32()
        self.StackCount = v_uint16()
        self.BasePriority = v_uint8()
        self.ThreadQuantum = v_uint8()
        self.AutoAlignment = v_uint8()
        self.State = v_uint8()
        self.ThreadSeed = v_uint8()
        self.DisableBoost = v_uint8()
        self.PowerState = v_uint8()
        self.DisableQuantum = v_uint8()
        self.IdealNode = v_uint8()
        self.Flags = KEXECUTE_OPTIONS()


class DEVICE_OBJECT_POWER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFlags = v_uint32()
        self.Dr0 = v_uint32()
        self.Dr1 = v_uint32()
        self.Dr2 = v_uint32()
        self.Dr3 = v_uint32()
        self.Dr6 = v_uint32()
        self.Dr7 = v_uint32()
        self.FloatSave = FLOATING_SAVE_AREA()
        self.SegGs = v_uint32()
        self.SegFs = v_uint32()
        self.SegEs = v_uint32()
        self.SegDs = v_uint32()
        self.Edi = v_uint32()
        self.Esi = v_uint32()
        self.Ebx = v_uint32()
        self.Edx = v_uint32()
        self.Ecx = v_uint32()
        self.Eax = v_uint32()
        self.Ebp = v_uint32()
        self.Eip = v_uint32()
        self.SegCs = v_uint32()
        self.EFlags = v_uint32()
        self.Esp = v_uint32()
        self.SegSs = v_uint32()
        self.ExtendedRegisters = vstruct.VArray([ v_uint8() for i in xrange(512) ])


class EX_FAST_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr32()


class HEAP_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint32()
        self.TagIndex = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self.TagName = vstruct.VArray([ v_uint16() for i in xrange(24) ])


class _unnamed_5326(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.FileAttributes = v_uint16()
        self.ShareAccess = v_uint16()
        self.EaLength = v_uint32()


class _unnamed_4280(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FreeListsInUseTerminate = v_uint16()


class KNODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProcessorMask = v_uint32()
        self.Color = v_uint32()
        self.MmShiftedColor = v_uint32()
        self.FreeCount = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self._pad0018 = v_bytes(size=4)
        self.DeadStackList = SLIST_HEADER()
        self.PfnDereferenceSListHead = SLIST_HEADER()
        self.PfnDeferredList = v_ptr32()
        self.Seed = v_uint8()
        self.Flags = flags()
        self._pad0030 = v_bytes(size=2)


class FILE_NETWORK_OPEN_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0038 = v_bytes(size=4)


class DPH_HEAP_ROOT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.HeapFlags = v_uint32()
        self.HeapCritSect = v_ptr32()
        self.nRemoteLockAcquired = v_uint32()
        self.pVirtualStorageListHead = v_ptr32()
        self.pVirtualStorageListTail = v_ptr32()
        self.nVirtualStorageRanges = v_uint32()
        self.nVirtualStorageBytes = v_uint32()
        self.pBusyAllocationListHead = v_ptr32()
        self.pBusyAllocationListTail = v_ptr32()
        self.nBusyAllocations = v_uint32()
        self.nBusyAllocationBytesCommitted = v_uint32()
        self.pFreeAllocationListHead = v_ptr32()
        self.pFreeAllocationListTail = v_ptr32()
        self.nFreeAllocations = v_uint32()
        self.nFreeAllocationBytesCommitted = v_uint32()
        self.pAvailableAllocationListHead = v_ptr32()
        self.pAvailableAllocationListTail = v_ptr32()
        self.nAvailableAllocations = v_uint32()
        self.nAvailableAllocationBytesCommitted = v_uint32()
        self.pUnusedNodeListHead = v_ptr32()
        self.pUnusedNodeListTail = v_ptr32()
        self.nUnusedNodes = v_uint32()
        self.nBusyAllocationBytesAccessible = v_uint32()
        self.pNodePoolListHead = v_ptr32()
        self.pNodePoolListTail = v_ptr32()
        self.nNodePools = v_uint32()
        self.nNodePoolBytes = v_uint32()
        self.pNextHeapRoot = v_ptr32()
        self.pPrevHeapRoot = v_ptr32()
        self.nUnProtectionReferenceCount = v_uint32()
        self.InsideAllocateNode = v_uint32()
        self.ExtraFlags = v_uint32()
        self.Seed = v_uint32()
        self.NormalHeap = v_ptr32()
        self.CreateStackTrace = v_ptr32()
        self.FirstThread = v_ptr32()


class _unnamed_2986(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class HEAP_PSEUDO_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint32()


class _unnamed_4733(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Create = _unnamed_5326()


class _unnamed_5407(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileName = v_ptr32()
        self.FileInformationClass = v_uint32()
        self.FileIndex = v_uint32()


class IO_CLIENT_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextExtension = v_ptr32()
        self.ClientIdentificationAddress = v_ptr32()


class OBJECT_HANDLE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleAttributes = v_uint32()
        self.GrantedAccess = v_uint32()


class RTL_DRIVE_LETTER_CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint16()
        self.Length = v_uint16()
        self.TimeStamp = v_uint32()
        self.DosPath = STRING()


class INITIAL_PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(3) ])


class _unnamed_5642(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProviderId = v_uint32()
        self.DataPath = v_ptr32()
        self.BufferSize = v_uint32()
        self.Buffer = v_ptr32()


class _unnamed_5647(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr32()
        self.Argument2 = v_ptr32()
        self.Argument3 = v_ptr32()
        self.Argument4 = v_ptr32()


class GENERAL_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.Allocate = v_ptr32()
        self.Free = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self._pad0080 = v_bytes(size=56)


class _unnamed_5628(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemContext = v_uint32()
        self.Type = v_uint32()
        self.State = POWER_STATE()
        self.ShutdownType = v_uint32()


class TEB_ACTIVE_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.Previous = v_ptr32()
        self.Context = v_ptr32()


class RTL_TRACE_DATABASE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint32()
        self.Flags = v_uint32()
        self.Tag = v_uint32()
        self.SegmentList = v_ptr32()
        self.MaximumSize = v_uint32()
        self.CurrentSize = v_uint32()
        self.Owner = v_ptr32()
        self.Lock = RTL_CRITICAL_SECTION()
        self.NoOfBuckets = v_uint32()
        self.Buckets = v_ptr32()
        self.HashFunction = v_ptr32()
        self.NoOfTraces = v_uint32()
        self.NoOfHits = v_uint32()
        self.HashCounter = vstruct.VArray([ v_uint32() for i in xrange(16) ])


class ULARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class EX_PUSH_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Waiting = v_uint32()


class _unnamed_5584(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceTextType = v_uint32()
        self.LocaleId = v_uint32()


class LDR_DATA_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InLoadOrderLinks = LIST_ENTRY()
        self.InMemoryOrderLinks = LIST_ENTRY()
        self.InInitializationOrderLinks = LIST_ENTRY()
        self.DllBase = v_ptr32()
        self.EntryPoint = v_ptr32()
        self.SizeOfImage = v_uint32()
        self.FullDllName = UNICODE_STRING()
        self.BaseDllName = UNICODE_STRING()
        self.Flags = v_uint32()
        self.LoadCount = v_uint16()
        self.TlsIndex = v_uint16()
        self.HashLinks = LIST_ENTRY()
        self.TimeDateStamp = v_uint32()
        self.EntryPointActivationContext = v_ptr32()
        self.PatchInformation = v_ptr32()


class HEAP_FREE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.PreviousSize = v_uint16()
        self.SmallTagIndex = v_uint8()
        self.Flags = v_uint8()
        self.UnusedBytes = v_uint8()
        self.SegmentIndex = v_uint8()
        self.FreeList = LIST_ENTRY()


class FXSAVE_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint16()
        self.StatusWord = v_uint16()
        self.TagWord = v_uint16()
        self.ErrorOpcode = v_uint16()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint32()
        self.MXCsr = v_uint32()
        self.MXCsrMask = v_uint32()
        self.RegisterArea = vstruct.VArray([ v_uint8() for i in xrange(128) ])
        self.Reserved3 = vstruct.VArray([ v_uint8() for i in xrange(128) ])
        self.Reserved4 = vstruct.VArray([ v_uint8() for i in xrange(224) ])
        self.Align16Byte = vstruct.VArray([ v_uint8() for i in xrange(8) ])


class OWNER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerThread = v_uint32()
        self.OwnerCount = v_uint32()


class DPH_BLOCK_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartStamp = v_uint32()
        self.Heap = v_ptr32()
        self.RequestedSize = v_uint32()
        self.ActualSize = v_uint32()
        self.FreeQueue = LIST_ENTRY()
        self.StackTrace = v_ptr32()
        self.EndStamp = v_uint32()


class DEVOBJ_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.PowerFlags = v_uint32()
        self.Dope = v_ptr32()
        self.ExtensionFlags = v_uint32()
        self.DeviceNode = v_ptr32()
        self.AttachedTo = v_ptr32()
        self.StartIoCount = v_uint32()
        self.StartIoKey = v_uint32()
        self.StartIoFlags = v_uint32()
        self.Vpb = v_ptr32()


class _unnamed_4279(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FreeListsInUseUlong = vstruct.VArray([ v_uint32() for i in xrange(4) ])


class PROCESSOR_PERF_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PercentFrequency = v_uint8()
        self.MinCapacity = v_uint8()
        self.Power = v_uint16()
        self.IncreaseLevel = v_uint8()
        self.DecreaseLevel = v_uint8()
        self.Flags = v_uint16()
        self.IncreaseTime = v_uint32()
        self.DecreaseTime = v_uint32()
        self.IncreaseCount = v_uint32()
        self.DecreaseCount = v_uint32()
        self.PerformanceTime = v_uint64()


class MDL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Size = v_uint16()
        self.MdlFlags = v_uint16()
        self.Process = v_ptr32()
        self.MappedSystemVa = v_ptr32()
        self.StartVa = v_ptr32()
        self.ByteCount = v_uint32()
        self.ByteOffset = v_uint32()


class KGDTENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LimitLow = v_uint16()
        self.BaseLow = v_uint16()
        self.HighWord = _unnamed_4641()


class NAMED_PIPE_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NamedPipeType = v_uint32()
        self.ReadMode = v_uint32()
        self.CompletionMode = v_uint32()
        self.MaximumInstances = v_uint32()
        self.InboundQuota = v_uint32()
        self.OutboundQuota = v_uint32()
        self.DefaultTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0028 = v_bytes(size=7)


class NT_TIB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_ptr32()
        self.StackBase = v_ptr32()
        self.StackLimit = v_ptr32()
        self.SubSystemTib = v_ptr32()
        self.FiberData = v_ptr32()
        self.ArbitraryUserPointer = v_ptr32()
        self.Self = v_ptr32()


class HEAP_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.Signature = v_uint32()
        self.Flags = v_uint32()
        self.Heap = v_ptr32()
        self.LargestUnCommittedRange = v_uint32()
        self.BaseAddress = v_ptr32()
        self.NumberOfPages = v_uint32()
        self.FirstEntry = v_ptr32()
        self.LastValidEntry = v_ptr32()
        self.NumberOfUnCommittedPages = v_uint32()
        self.NumberOfUnCommittedRanges = v_uint32()
        self.UnCommittedRanges = v_ptr32()
        self.AllocatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self.LastEntryInSegment = v_ptr32()


class _unnamed_5432(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()


class _unnamed_3555(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self._pad0028 = v_bytes(size=32)


class POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemState = v_uint32()


class _unnamed_5469(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vpb = v_ptr32()
        self.DeviceObject = v_ptr32()


class UNICODE_STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class TEB_ACTIVE_FRAME_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.FrameName = v_ptr32()


class DRIVER_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Flags = v_uint32()
        self.DriverStart = v_ptr32()
        self.DriverSize = v_uint32()
        self.DriverSection = v_ptr32()
        self.DriverExtension = v_ptr32()
        self.DriverName = UNICODE_STRING()
        self.HardwareDatabase = v_ptr32()
        self.FastIoDispatch = v_ptr32()
        self.DriverInit = v_ptr32()
        self.DriverStartIo = v_ptr32()
        self.DriverUnload = v_ptr32()
        self.MajorFunction = vstruct.VArray([ v_ptr32() for i in xrange(28) ])


class _unnamed_4504(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MasterIrp = v_ptr32()


class _unnamed_5753(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EndingOffset = v_ptr32()
        self.ResourceToRelease = v_ptr32()


class _unnamed_4507(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsynchronousParameters = _unnamed_4716()


class ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OperationID = LUID()
        self.SecurityEvaluated = v_uint8()
        self.GenerateAudit = v_uint8()
        self.GenerateOnClose = v_uint8()
        self.PrivilegesAllocated = v_uint8()
        self.Flags = v_uint32()
        self.RemainingDesiredAccess = v_uint32()
        self.PreviouslyGrantedAccess = v_uint32()
        self.OriginalDesiredAccess = v_uint32()
        self.SubjectSecurityContext = SECURITY_SUBJECT_CONTEXT()
        self.SecurityDescriptor = v_ptr32()
        self.AuxData = v_ptr32()
        self.Privileges = _unnamed_4415()
        self.AuditPrivileges = v_uint8()
        self._pad0064 = v_bytes(size=3)
        self.ObjectName = UNICODE_STRING()
        self.ObjectTypeName = UNICODE_STRING()


class EJOB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Event = KEVENT()
        self.JobLinks = LIST_ENTRY()
        self.ProcessListHead = LIST_ENTRY()
        self.JobLock = ERESOURCE()
        self.TotalUserTime = LARGE_INTEGER()
        self.TotalKernelTime = LARGE_INTEGER()
        self.ThisPeriodTotalUserTime = LARGE_INTEGER()
        self.ThisPeriodTotalKernelTime = LARGE_INTEGER()
        self.TotalPageFaultCount = v_uint32()
        self.TotalProcesses = v_uint32()
        self.ActiveProcesses = v_uint32()
        self.TotalTerminatedProcesses = v_uint32()
        self.PerProcessUserTimeLimit = LARGE_INTEGER()
        self.PerJobUserTimeLimit = LARGE_INTEGER()
        self.LimitFlags = v_uint32()
        self.MinimumWorkingSetSize = v_uint32()
        self.MaximumWorkingSetSize = v_uint32()
        self.ActiveProcessLimit = v_uint32()
        self.Affinity = v_uint32()
        self.PriorityClass = v_uint8()
        self._pad00b0 = v_bytes(size=3)
        self.UIRestrictionsClass = v_uint32()
        self.SecurityLimitFlags = v_uint32()
        self.Token = v_ptr32()
        self.Filter = v_ptr32()
        self.EndOfJobTimeAction = v_uint32()
        self.CompletionPort = v_ptr32()
        self.CompletionKey = v_ptr32()
        self.SessionId = v_uint32()
        self.SchedulingClass = v_uint32()
        self._pad00d8 = v_bytes(size=4)
        self.ReadOperationCount = v_uint64()
        self.WriteOperationCount = v_uint64()
        self.OtherOperationCount = v_uint64()
        self.ReadTransferCount = v_uint64()
        self.WriteTransferCount = v_uint64()
        self.OtherTransferCount = v_uint64()
        self.IoInfo = IO_COUNTERS()
        self.ProcessMemoryLimit = v_uint32()
        self.JobMemoryLimit = v_uint32()
        self.PeakProcessMemoryUsed = v_uint32()
        self.PeakJobMemoryUsed = v_uint32()
        self.CurrentJobMemoryUsed = v_uint32()
        self.MemoryLimitsLock = FAST_MUTEX()
        self.JobSetLinks = LIST_ENTRY()
        self.MemberLevel = v_uint32()
        self.JobFlags = v_uint32()
        self._pad0180 = v_bytes(size=4)


class _unnamed_5755(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SyncType = v_uint32()
        self.PageProtection = v_uint32()


class FILE_STANDARD_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.NumberOfLinks = v_uint32()
        self.DeletePending = v_uint8()
        self.Directory = v_uint8()
        self._pad0018 = v_bytes(size=2)


class _unnamed_5610(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerSequence = v_ptr32()


class _unnamed_4508(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Overlay = _unnamed_4769()
        self._pad0030 = v_bytes(size=8)


class IMAGE_SECTION_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.Misc = _unnamed_4575()
        self.VirtualAddress = v_uint32()
        self.SizeOfRawData = v_uint32()
        self.PointerToRawData = v_uint32()
        self.PointerToRelocations = v_uint32()
        self.PointerToLinenumbers = v_uint32()
        self.NumberOfRelocations = v_uint16()
        self.NumberOfLinenumbers = v_uint16()
        self.Characteristics = v_uint32()


class EPROCESS_QUOTA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.QuotaEntry = vstruct.VArray([ EPROCESS_QUOTA_ENTRY() for i in xrange(3) ])
        self.QuotaList = LIST_ENTRY()
        self.ReferenceCount = v_uint32()
        self.ProcessCount = v_uint32()


class HANDLE_TRACE_DEBUG_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CurrentStackIndex = v_uint32()
        self.TraceDb = vstruct.VArray([ HANDLE_TRACE_DB_ENTRY() for i in xrange(4096) ])


class GDI_TEB_BATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.HDC = v_uint32()
        self.Buffer = vstruct.VArray([ v_uint32() for i in xrange(310) ])


class KPROCESSOR_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFrame = CONTEXT()
        self.SpecialRegisters = KSPECIAL_REGISTERS()


class LIST_ENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint64()
        self.Blink = v_uint64()


class KTRAP_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DbgEbp = v_uint32()
        self.DbgEip = v_uint32()
        self.DbgArgMark = v_uint32()
        self.DbgArgPointer = v_uint32()
        self.TempSegCs = v_uint32()
        self.TempEsp = v_uint32()
        self.Dr0 = v_uint32()
        self.Dr1 = v_uint32()
        self.Dr2 = v_uint32()
        self.Dr3 = v_uint32()
        self.Dr6 = v_uint32()
        self.Dr7 = v_uint32()
        self.SegGs = v_uint32()
        self.SegEs = v_uint32()
        self.SegDs = v_uint32()
        self.Edx = v_uint32()
        self.Ecx = v_uint32()
        self.Eax = v_uint32()
        self.PreviousPreviousMode = v_uint32()
        self.ExceptionList = v_ptr32()
        self.SegFs = v_uint32()
        self.Edi = v_uint32()
        self.Esi = v_uint32()
        self.Ebx = v_uint32()
        self.Ebp = v_uint32()
        self.ErrCode = v_uint32()
        self.Eip = v_uint32()
        self.SegCs = v_uint32()
        self.EFlags = v_uint32()
        self.HardwareEsp = v_uint32()
        self.HardwareSegSs = v_uint32()
        self.V86Es = v_uint32()
        self.V86Ds = v_uint32()
        self.V86Fs = v_uint32()
        self.V86Gs = v_uint32()


class WAIT_CONTEXT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.DeviceRoutine = v_ptr32()
        self.DeviceContext = v_ptr32()
        self.NumberOfMapRegisters = v_uint32()
        self.DeviceObject = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.BufferChainingDpc = v_ptr32()


class PEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InheritedAddressSpace = v_uint8()
        self.ReadImageFileExecOptions = v_uint8()
        self.BeingDebugged = v_uint8()
        self.SpareBool = v_uint8()
        self.Mutant = v_ptr32()
        self.ImageBaseAddress = v_ptr32()
        self.Ldr = v_ptr32()
        self.ProcessParameters = v_ptr32()
        self.SubSystemData = v_ptr32()
        self.ProcessHeap = v_ptr32()
        self.FastPebLock = v_ptr32()
        self.FastPebLockRoutine = v_ptr32()
        self.FastPebUnlockRoutine = v_ptr32()
        self.EnvironmentUpdateCount = v_uint32()
        self.KernelCallbackTable = v_ptr32()
        self.SystemReserved = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.AtlThunkSListPtr32 = v_uint32()
        self.FreeList = v_ptr32()
        self.TlsExpansionCounter = v_uint32()
        self.TlsBitmap = v_ptr32()
        self.TlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ReadOnlySharedMemoryBase = v_ptr32()
        self.ReadOnlySharedMemoryHeap = v_ptr32()
        self.ReadOnlyStaticServerData = v_ptr32()
        self.AnsiCodePageData = v_ptr32()
        self.OemCodePageData = v_ptr32()
        self.UnicodeCaseTableData = v_ptr32()
        self.NumberOfProcessors = v_uint32()
        self.NtGlobalFlag = v_uint32()
        self._pad0070 = v_bytes(size=4)
        self.CriticalSectionTimeout = LARGE_INTEGER()
        self.HeapSegmentReserve = v_uint32()
        self.HeapSegmentCommit = v_uint32()
        self.HeapDeCommitTotalFreeThreshold = v_uint32()
        self.HeapDeCommitFreeBlockThreshold = v_uint32()
        self.NumberOfHeaps = v_uint32()
        self.MaximumNumberOfHeaps = v_uint32()
        self.ProcessHeaps = v_ptr32()
        self.GdiSharedHandleTable = v_ptr32()
        self.ProcessStarterHelper = v_ptr32()
        self.GdiDCAttributeList = v_uint32()
        self.LoaderLock = v_ptr32()
        self.OSMajorVersion = v_uint32()
        self.OSMinorVersion = v_uint32()
        self.OSBuildNumber = v_uint16()
        self.OSCSDVersion = v_uint16()
        self.OSPlatformId = v_uint32()
        self.ImageSubsystem = v_uint32()
        self.ImageSubsystemMajorVersion = v_uint32()
        self.ImageSubsystemMinorVersion = v_uint32()
        self.ImageProcessAffinityMask = v_uint32()
        self.GdiHandleBuffer = vstruct.VArray([ v_uint32() for i in xrange(34) ])
        self.PostProcessInitRoutine = v_ptr32()
        self.TlsExpansionBitmap = v_ptr32()
        self.TlsExpansionBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(32) ])
        self.SessionId = v_uint32()
        self.AppCompatFlags = ULARGE_INTEGER()
        self.AppCompatFlagsUser = ULARGE_INTEGER()
        self.pShimData = v_ptr32()
        self.AppCompatInfo = v_ptr32()
        self.CSDVersion = UNICODE_STRING()
        self.ActivationContextData = v_ptr32()
        self.ProcessAssemblyStorageMap = v_ptr32()
        self.SystemDefaultActivationContextData = v_ptr32()
        self.SystemAssemblyStorageMap = v_ptr32()
        self.MinimumStackCommit = v_uint32()
        self._pad0210 = v_bytes(size=4)


class SE_AUDIT_PROCESS_CREATION_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImageFileName = v_ptr32()


class ACTIVATION_CONTEXT_STACK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.NextCookieSequenceNumber = v_uint32()
        self.ActiveFrame = v_ptr32()
        self.FrameListCache = LIST_ENTRY()


class PROCESS_WS_WATCH_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FaultingPc = v_ptr32()
        self.FaultingVa = v_ptr32()


class SID_IDENTIFIER_AUTHORITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Value = vstruct.VArray([ v_uint8() for i in xrange(6) ])


class SECTION_OBJECT_POINTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSectionObject = v_ptr32()
        self.SharedCacheMap = v_ptr32()
        self.ImageSectionObject = v_ptr32()


class STACK_TRACE_DATABASE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = _unnamed_4337()
        self.AcquireLockRoutine = v_ptr32()
        self.ReleaseLockRoutine = v_ptr32()
        self.OkayToLockRoutine = v_ptr32()
        self.PreCommitted = v_uint8()
        self.DumpInProgress = v_uint8()
        self._pad0048 = v_bytes(size=2)
        self.CommitBase = v_ptr32()
        self.CurrentLowerCommitLimit = v_ptr32()
        self.CurrentUpperCommitLimit = v_ptr32()
        self.NextFreeLowerMemory = v_ptr32()
        self.NextFreeUpperMemory = v_ptr32()
        self.NumberOfEntriesLookedUp = v_uint32()
        self.NumberOfEntriesAdded = v_uint32()
        self.EntryIndexArray = v_ptr32()
        self.NumberOfBuckets = v_uint32()
        self.Buckets = vstruct.VArray([ v_ptr32() for i in xrange(1) ])


class HEAP_UCR_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.ReservedSize = v_uint32()
        self.CommittedSize = v_uint32()
        self.filler = v_uint32()


class TEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.EnvironmentPointer = v_ptr32()
        self.ClientId = CLIENT_ID()
        self.ActiveRpcHandle = v_ptr32()
        self.ThreadLocalStoragePointer = v_ptr32()
        self.ProcessEnvironmentBlock = v_ptr32()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_ptr32()
        self.Win32ThreadInfo = v_ptr32()
        self.User32Reserved = vstruct.VArray([ v_uint32() for i in xrange(26) ])
        self.UserReserved = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self.WOW32Reserved = v_ptr32()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()
        self.SystemReserved1 = vstruct.VArray([ v_ptr32() for i in xrange(54) ])
        self.ExceptionCode = v_uint32()
        self.ActivationContextStack = ACTIVATION_CONTEXT_STACK()
        self.SpareBytes1 = vstruct.VArray([ v_uint8() for i in xrange(24) ])
        self.GdiTebBatch = GDI_TEB_BATCH()
        self.RealClientId = CLIENT_ID()
        self.GdiCachedProcessHandle = v_ptr32()
        self.GdiClientPID = v_uint32()
        self.GdiClientTID = v_uint32()
        self.GdiThreadLocalInfo = v_ptr32()
        self.Win32ClientInfo = vstruct.VArray([ v_uint32() for i in xrange(62) ])
        self.glDispatchTable = vstruct.VArray([ v_ptr32() for i in xrange(233) ])
        self.glReserved1 = vstruct.VArray([ v_uint32() for i in xrange(29) ])
        self.glReserved2 = v_ptr32()
        self.glSectionInfo = v_ptr32()
        self.glSection = v_ptr32()
        self.glTable = v_ptr32()
        self.glCurrentRC = v_ptr32()
        self.glContext = v_ptr32()
        self.LastStatusValue = v_uint32()
        self.StaticUnicodeString = UNICODE_STRING()
        self.StaticUnicodeBuffer = vstruct.VArray([ v_uint16() for i in xrange(261) ])
        self._pad0e0c = v_bytes(size=2)
        self.DeallocationStack = v_ptr32()
        self.TlsSlots = vstruct.VArray([ v_ptr32() for i in xrange(64) ])
        self.TlsLinks = LIST_ENTRY()
        self.Vdm = v_ptr32()
        self.ReservedForNtRpc = v_ptr32()
        self.DbgSsReserved = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self.HardErrorsAreDisabled = v_uint32()
        self.Instrumentation = vstruct.VArray([ v_ptr32() for i in xrange(16) ])
        self.WinSockData = v_ptr32()
        self.GdiBatchCount = v_uint32()
        self.InDbgPrint = v_uint8()
        self.FreeStackOnTermination = v_uint8()
        self.HasFiberData = v_uint8()
        self.IdealProcessor = v_uint8()
        self.Spare3 = v_uint32()
        self.ReservedForPerf = v_ptr32()
        self.ReservedForOle = v_ptr32()
        self.WaitingOnLoaderLock = v_uint32()
        self.Wx86Thread = Wx86ThreadState()
        self.TlsExpansionSlots = v_ptr32()
        self.ImpersonationLocale = v_uint32()
        self.IsImpersonating = v_uint32()
        self.NlsCache = v_ptr32()
        self.pShimData = v_ptr32()
        self.HeapVirtualAffinity = v_uint32()
        self.CurrentTransactionHandle = v_ptr32()
        self.ActiveFrame = v_ptr32()
        self.SafeThunkCall = v_uint8()
        self.BooleanSpare = vstruct.VArray([ v_uint8() for i in xrange(3) ])


class _unnamed_5427(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.EaList = v_ptr32()
        self.EaListLength = v_uint32()
        self.EaIndex = v_uint32()


class EX_RUNDOWN_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()


class RTL_USER_PROCESS_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MaximumLength = v_uint32()
        self.Length = v_uint32()
        self.Flags = v_uint32()
        self.DebugFlags = v_uint32()
        self.ConsoleHandle = v_ptr32()
        self.ConsoleFlags = v_uint32()
        self.StandardInput = v_ptr32()
        self.StandardOutput = v_ptr32()
        self.StandardError = v_ptr32()
        self.CurrentDirectory = CURDIR()
        self.DllPath = UNICODE_STRING()
        self.ImagePathName = UNICODE_STRING()
        self.CommandLine = UNICODE_STRING()
        self.Environment = v_ptr32()
        self.StartingX = v_uint32()
        self.StartingY = v_uint32()
        self.CountX = v_uint32()
        self.CountY = v_uint32()
        self.CountCharsX = v_uint32()
        self.CountCharsY = v_uint32()
        self.FillAttribute = v_uint32()
        self.WindowFlags = v_uint32()
        self.ShowWindowFlags = v_uint32()
        self.WindowTitle = UNICODE_STRING()
        self.DesktopInfo = UNICODE_STRING()
        self.ShellInfo = UNICODE_STRING()
        self.RuntimeData = UNICODE_STRING()
        self.CurrentDirectores = vstruct.VArray([ RTL_DRIVE_LETTER_CURDIR() for i in xrange(32) ])


class _unnamed_5342(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self.Parameters = v_ptr32()


class KDPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Number = v_uint8()
        self.Importance = v_uint8()
        self.DpcListEntry = LIST_ENTRY()
        self.DeferredRoutine = v_ptr32()
        self.DeferredContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.Lock = v_ptr32()


class Wx86ThreadState(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CallBx86Eip = v_ptr32()
        self.DeallocationCpu = v_ptr32()
        self.UseKnownWx86Dll = v_uint8()
        self.OleStubInvoked = v_uint8()
        self._pad000c = v_bytes(size=2)


class KEVENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class _unnamed_5604(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerState = v_uint32()


class _unnamed_5818(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumVector = v_uint32()
        self.MaximumVector = v_uint32()


class FILE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Vpb = v_ptr32()
        self.FsContext = v_ptr32()
        self.FsContext2 = v_ptr32()
        self.SectionObjectPointer = v_ptr32()
        self.PrivateCacheMap = v_ptr32()
        self.FinalStatus = v_uint32()
        self.RelatedFileObject = v_ptr32()
        self.LockOperation = v_uint8()
        self.DeletePending = v_uint8()
        self.ReadAccess = v_uint8()
        self.WriteAccess = v_uint8()
        self.DeleteAccess = v_uint8()
        self.SharedRead = v_uint8()
        self.SharedWrite = v_uint8()
        self.SharedDelete = v_uint8()
        self.Flags = v_uint32()
        self.FileName = UNICODE_STRING()
        self.CurrentByteOffset = LARGE_INTEGER()
        self.Waiters = v_uint32()
        self.Busy = v_uint32()
        self.LastLock = v_ptr32()
        self.Lock = KEVENT()
        self.Event = KEVENT()
        self.CompletionContext = v_ptr32()


class _unnamed_4575(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PhysicalAddress = v_uint32()


class _unnamed_4678(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMid = v_uint32()


class RTL_CRITICAL_SECTION_DEBUG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self.CriticalSection = v_ptr32()
        self.ProcessLocksList = LIST_ENTRY()
        self.EntryCount = v_uint32()
        self.ContentionCount = v_uint32()
        self.Spare = vstruct.VArray([ v_uint32() for i in xrange(2) ])


class PAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = FAST_MUTEX()
        self._pad0100 = v_bytes(size=96)


class _unnamed_5813(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Alignment = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class OBJECT_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mutex = ERESOURCE()
        self.TypeList = LIST_ENTRY()
        self.Name = UNICODE_STRING()
        self.DefaultObject = v_ptr32()
        self.Index = v_uint32()
        self.TotalNumberOfObjects = v_uint32()
        self.TotalNumberOfHandles = v_uint32()
        self.HighWaterNumberOfObjects = v_uint32()
        self.HighWaterNumberOfHandles = v_uint32()
        self.TypeInfo = OBJECT_TYPE_INITIALIZER()
        self.Key = v_uint32()
        self.ObjectLocks = vstruct.VArray([ ERESOURCE() for i in xrange(4) ])


class SID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Sid = v_ptr32()
        self.Attributes = v_uint32()


class _unnamed_4673(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMid = v_uint8()
        self.Flags1 = v_uint8()
        self.Flags2 = v_uint8()
        self.BaseHi = v_uint8()


class _unnamed_5563(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoResourceRequirementList = v_ptr32()


class _unnamed_2976(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class DISPATCHER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.Absolute = v_uint8()
        self.Size = v_uint8()
        self.Inserted = v_uint8()
        self.SignalState = v_uint32()
        self.WaitListHead = LIST_ENTRY()


class LUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class IO_TIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.TimerFlag = v_uint16()
        self.TimerList = LIST_ENTRY()
        self.TimerRoutine = v_ptr32()
        self.Context = v_ptr32()
        self.DeviceObject = v_ptr32()


class _unnamed_5890(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Channel = v_uint32()
        self.Port = v_uint32()
        self.Reserved1 = v_uint32()


class _unnamed_5592(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InPath = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.Type = v_uint32()


class MMSUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LastTrimTime = LARGE_INTEGER()
        self.Flags = MMSUPPORT_FLAGS()
        self.PageFaultCount = v_uint32()
        self.PeakWorkingSetSize = v_uint32()
        self.WorkingSetSize = v_uint32()
        self.MinimumWorkingSetSize = v_uint32()
        self.MaximumWorkingSetSize = v_uint32()
        self.VmWorkingSetList = v_ptr32()
        self.WorkingSetExpansionLinks = LIST_ENTRY()
        self.Claim = v_uint32()
        self.NextEstimationSlot = v_uint32()
        self.NextAgingSlot = v_uint32()
        self.EstimatedAvailable = v_uint32()
        self.GrowthSinceLastEstimate = v_uint32()


class _unnamed_5894(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint32()
        self.Length = v_uint32()
        self.Reserved = v_uint32()


class OBJECT_TYPE_INITIALIZER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.UseDefaultObject = v_uint8()
        self.CaseInsensitive = v_uint8()
        self.InvalidAttributes = v_uint32()
        self.GenericMapping = GENERIC_MAPPING()
        self.ValidAccessMask = v_uint32()
        self.SecurityRequired = v_uint8()
        self.MaintainHandleCount = v_uint8()
        self.MaintainTypeList = v_uint8()
        self._pad0020 = v_bytes(size=1)
        self.PoolType = v_uint32()
        self.DefaultPagedPoolCharge = v_uint32()
        self.DefaultNonPagedPoolCharge = v_uint32()
        self.DumpProcedure = v_ptr32()
        self.OpenProcedure = v_ptr32()
        self.CloseProcedure = v_ptr32()
        self.DeleteProcedure = v_ptr32()
        self.ParseProcedure = v_ptr32()
        self.SecurityProcedure = v_ptr32()
        self.QueryNameProcedure = v_ptr32()
        self.OkayToCloseProcedure = v_ptr32()


class _unnamed_5898(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class _unnamed_5453(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_ptr32()
        self.Key = v_uint32()
        self.ByteOffset = LARGE_INTEGER()


class DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pad = v_uint16()
        self.Limit = v_uint16()
        self.Base = v_uint32()


class _unnamed_5354(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self.Parameters = v_ptr32()


class MMSUPPORT_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SessionSpace = v_uint32()


class HEAP_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = _unnamed_4337()


class EXCEPTION_REGISTRATION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Handler = v_ptr32()


class _unnamed_5579(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdType = v_uint32()


class FILE_BASIC_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0028 = v_bytes(size=4)


class DEVICE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.ReferenceCount = v_uint32()
        self.DriverObject = v_ptr32()
        self.NextDevice = v_ptr32()
        self.AttachedDevice = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.Timer = v_ptr32()
        self.Flags = v_uint32()
        self.Characteristics = v_uint32()
        self.Vpb = v_ptr32()
        self.DeviceExtension = v_ptr32()
        self.DeviceType = v_uint32()
        self.StackSize = v_uint8()
        self._pad0034 = v_bytes(size=3)
        self.Queue = _unnamed_3555()
        self.AlignmentRequirement = v_uint32()
        self.DeviceQueue = KDEVICE_QUEUE()
        self.Dpc = KDPC()
        self.ActiveThreadCount = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.DeviceLock = KEVENT()
        self.SectorSize = v_uint16()
        self.Spare1 = v_uint16()
        self.DeviceObjectExtension = v_ptr32()
        self.Reserved = v_ptr32()


class LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_ptr32()
        self.Blink = v_ptr32()


class SECURITY_QUALITY_OF_SERVICE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.ImpersonationLevel = v_uint32()
        self.ContextTrackingMode = v_uint8()
        self.EffectiveOnly = v_uint8()
        self._pad000c = v_bytes(size=2)


class COMPRESSED_DATA_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CompressionFormatAndEngine = v_uint16()
        self.CompressionUnitShift = v_uint8()
        self.ChunkShift = v_uint8()
        self.ClusterShift = v_uint8()
        self.Reserved = v_uint8()
        self.NumberOfChunks = v_uint16()
        self.CompressedChunkSizes = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class PEB_FREE_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Size = v_uint32()


class _unnamed_5508(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_ptr32()
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Interface = v_ptr32()
        self.InterfaceSpecificData = v_ptr32()


class KSEMAPHORE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.Limit = v_uint32()


class KTIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.DueTime = ULARGE_INTEGER()
        self.TimerListEntry = LIST_ENTRY()
        self.Dpc = v_ptr32()
        self.Period = v_uint32()


class _unnamed_4641(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Bytes = _unnamed_4673()


class _unnamed_3291(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FnArea = FNSAVE_FORMAT()
        self._pad0208 = v_bytes(size=412)


class EX_PUSH_LOCK_WAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WakeEvent = KEVENT()
        self.Next = v_ptr32()
        self.ShareCount = v_uint32()
        self.Exclusive = v_uint8()
        self._pad001c = v_bytes(size=3)


class _unnamed_5804(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = _unnamed_5813()


class _unnamed_5571(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint8()


class LARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class CLIENT_ID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_ptr32()
        self.UniqueThread = v_ptr32()


class NPAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = v_uint32()
        self._pad0100 = v_bytes(size=124)


class RTL_STACK_TRACE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashChain = v_ptr32()
        self.TraceCount = v_uint32()
        self.Index = v_uint16()
        self.Depth = v_uint16()
        self.BackTrace = vstruct.VArray([ v_ptr32() for i in xrange(32) ])


class OBJECT_DUMP_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Stream = v_ptr32()
        self.Detail = v_uint32()


class _unnamed_5883(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length = v_uint32()


class _unnamed_5448(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self.InputBufferLength = v_uint32()
        self.FsControlCode = v_uint32()
        self.Type3InputBuffer = v_ptr32()


class GUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data1 = v_uint32()
        self.Data2 = v_uint16()
        self.Data3 = v_uint16()
        self.Data4 = vstruct.VArray([ v_uint8() for i in xrange(8) ])


class _unnamed_5886(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint32()
        self.Vector = v_uint32()
        self.Affinity = v_uint32()


class HANDLE_TRACE_DB_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientId = CLIENT_ID()
        self.Handle = v_ptr32()
        self.Type = v_uint32()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(16) ])


class _unnamed_5756(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr32()
        self.Argument2 = v_ptr32()
        self.Argument3 = v_ptr32()
        self.Argument4 = v_ptr32()
        self.Argument5 = v_ptr32()


class KAPC_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ApcListHead = vstruct.VArray([ LIST_ENTRY() for i in xrange(2) ])
        self.Process = v_ptr32()
        self.KernelApcInProgress = v_uint8()
        self.KernelApcPending = v_uint8()
        self.UserApcPending = v_uint8()
        self._pad0018 = v_bytes(size=1)


class PS_IMPERSONATION_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Token = v_ptr32()
        self.CopyOnOpen = v_uint8()
        self.EffectiveOnly = v_uint8()
        self._pad0008 = v_bytes(size=2)
        self.ImpersonationLevel = v_uint32()


class _unnamed_5445(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FsInformationClass = v_uint32()


class FAST_MUTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Owner = v_ptr32()
        self.Contention = v_uint32()
        self.Event = KEVENT()
        self.OldIrql = v_uint32()


class _unnamed_5361(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Key = v_uint32()
        self.ByteOffset = LARGE_INTEGER()


class _unnamed_4769(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.Thread = v_ptr32()
        self.AuxiliaryBuffer = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.CurrentStackLocation = v_ptr32()
        self.OriginalFileObject = v_ptr32()


class KIDTENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint16()
        self.Selector = v_uint16()
        self.Access = v_uint16()
        self.ExtendedOffset = v_uint16()


class HARDWARE_PTE_X86(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class IO_STACK_LOCATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorFunction = v_uint8()
        self.MinorFunction = v_uint8()
        self.Flags = v_uint8()
        self.Control = v_uint8()
        self.Parameters = _unnamed_4733()
        self.DeviceObject = v_ptr32()
        self.FileObject = v_ptr32()
        self.CompletionRoutine = v_ptr32()
        self.Context = v_ptr32()


class ERESOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemResourcesList = LIST_ENTRY()
        self.OwnerTable = v_ptr32()
        self.ActiveCount = v_uint16()
        self.Flag = v_uint16()
        self.SharedWaiters = v_ptr32()
        self.ExclusiveWaiters = v_ptr32()
        self.OwnerThreads = vstruct.VArray([ OWNER_ENTRY() for i in xrange(2) ])
        self.ContentionCount = v_uint32()
        self.NumberOfSharedWaiters = v_uint16()
        self.NumberOfExclusiveWaiters = v_uint16()
        self.Address = v_ptr32()
        self.SpinLock = v_uint32()


class _unnamed_5549(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Capabilities = v_ptr32()


class _unnamed_5566(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WhichSpace = v_uint32()
        self.Buffer = v_ptr32()
        self.Offset = v_uint32()
        self.Length = v_uint32()


class STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class _unnamed_5831(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Priority = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class GENERIC_MAPPING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GenericRead = v_uint32()
        self.GenericWrite = v_uint32()
        self.GenericExecute = v_uint32()
        self.GenericAll = v_uint32()


class IRP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.MdlAddress = v_ptr32()
        self.Flags = v_uint32()
        self.AssociatedIrp = _unnamed_4504()
        self.ThreadListEntry = LIST_ENTRY()
        self.IoStatus = IO_STATUS_BLOCK()
        self.RequestorMode = v_uint8()
        self.PendingReturned = v_uint8()
        self.StackCount = v_uint8()
        self.CurrentLocation = v_uint8()
        self.Cancel = v_uint8()
        self.CancelIrql = v_uint8()
        self.ApcEnvironment = v_uint8()
        self.AllocationFlags = v_uint8()
        self.UserIosb = v_ptr32()
        self.UserEvent = v_ptr32()
        self.Overlay = _unnamed_4507()
        self.CancelRoutine = v_ptr32()
        self.UserBuffer = v_ptr32()
        self.Tail = _unnamed_4508()


class OBJECT_NAME_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = UNICODE_STRING()


class IO_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.Descriptors = vstruct.VArray([ IO_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class _unnamed_4415(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InitialPrivilegeSet = INITIAL_PRIVILEGE_SET()


class KUSER_SHARED_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TickCountLow = v_uint32()
        self.TickCountMultiplier = v_uint32()
        self.InterruptTime = KSYSTEM_TIME()
        self.SystemTime = KSYSTEM_TIME()
        self.TimeZoneBias = KSYSTEM_TIME()
        self.ImageNumberLow = v_uint16()
        self.ImageNumberHigh = v_uint16()
        self.NtSystemRoot = vstruct.VArray([ v_uint16() for i in xrange(260) ])
        self.MaxStackTraceDepth = v_uint32()
        self.CryptoExponent = v_uint32()
        self.TimeZoneId = v_uint32()
        self.Reserved2 = vstruct.VArray([ v_uint32() for i in xrange(8) ])
        self.NtProductType = v_uint32()
        self.ProductTypeIsValid = v_uint8()
        self._pad026c = v_bytes(size=3)
        self.NtMajorVersion = v_uint32()
        self.NtMinorVersion = v_uint32()
        self.ProcessorFeatures = vstruct.VArray([ v_uint8() for i in xrange(64) ])
        self.Reserved1 = v_uint32()
        self.Reserved3 = v_uint32()
        self.TimeSlip = v_uint32()
        self.AlternativeArchitecture = v_uint32()
        self._pad02c8 = v_bytes(size=4)
        self.SystemExpirationDate = LARGE_INTEGER()
        self.SuiteMask = v_uint32()
        self.KdDebuggerEnabled = v_uint8()
        self.NXSupportPolicy = v_uint8()
        self._pad02d8 = v_bytes(size=2)
        self.ActiveConsoleId = v_uint32()
        self.DismountCount = v_uint32()
        self.ComPlusPackage = v_uint32()
        self.LastSystemRITEventTickCount = v_uint32()
        self.NumberOfPhysicalPages = v_uint32()
        self.SafeBootMode = v_uint8()
        self._pad02f0 = v_bytes(size=3)
        self.TraceLogging = v_uint32()
        self._pad02f8 = v_bytes(size=4)
        self.TestRetInstruction = v_uint64()
        self.SystemCall = v_uint32()
        self.SystemCallReturn = v_uint32()
        self.SystemCallPad = vstruct.VArray([ v_uint64() for i in xrange(3) ])
        self.TickCount = KSYSTEM_TIME()
        self._pad0330 = v_bytes(size=4)
        self.Cookie = v_uint32()
        self._pad0338 = v_bytes(size=4)


class FNSAVE_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint32()
        self.StatusWord = v_uint32()
        self.TagWord = v_uint32()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint32()
        self.RegisterArea = vstruct.VArray([ v_uint8() for i in xrange(80) ])


class KSPECIAL_REGISTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cr0 = v_uint32()
        self.Cr2 = v_uint32()
        self.Cr3 = v_uint32()
        self.Cr4 = v_uint32()
        self.KernelDr0 = v_uint32()
        self.KernelDr1 = v_uint32()
        self.KernelDr2 = v_uint32()
        self.KernelDr3 = v_uint32()
        self.KernelDr6 = v_uint32()
        self.KernelDr7 = v_uint32()
        self.Gdtr = DESCRIPTOR()
        self.Idtr = DESCRIPTOR()
        self.Tr = v_uint16()
        self.Ldtr = v_uint16()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(6) ])


class IO_RESOURCE_REQUIREMENTS_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.SlotNumber = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.AlternativeLists = v_uint32()
        self.List = vstruct.VArray([ IO_RESOURCE_LIST() for i in xrange(1) ])


class _unnamed_5881(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Generic = _unnamed_5883()


class FS_FILTER_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AcquireForModifiedPageWriter = _unnamed_5753()
        self._pad0014 = v_bytes(size=12)


class HEAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.Signature = v_uint32()
        self.Flags = v_uint32()
        self.ForceFlags = v_uint32()
        self.VirtualMemoryThreshold = v_uint32()
        self.SegmentReserve = v_uint32()
        self.SegmentCommit = v_uint32()
        self.DeCommitFreeBlockThreshold = v_uint32()
        self.DeCommitTotalFreeThreshold = v_uint32()
        self.TotalFreeSize = v_uint32()
        self.MaximumAllocationSize = v_uint32()
        self.ProcessHeapsListIndex = v_uint16()
        self.HeaderValidateLength = v_uint16()
        self.HeaderValidateCopy = v_ptr32()
        self.NextAvailableTagIndex = v_uint16()
        self.MaximumTagIndex = v_uint16()
        self.TagEntries = v_ptr32()
        self.UCRSegments = v_ptr32()
        self.UnusedUnCommittedRanges = v_ptr32()
        self.AlignRound = v_uint32()
        self.AlignMask = v_uint32()
        self.VirtualAllocdBlocks = LIST_ENTRY()
        self.Segments = vstruct.VArray([ v_ptr32() for i in xrange(64) ])
        self.u = _unnamed_4279()
        self.u2 = _unnamed_4280()
        self.AllocatorBackTraceIndex = v_uint16()
        self.NonDedicatedListLength = v_uint32()
        self.LargeBlocksIndex = v_ptr32()
        self.PseudoTagEntries = v_ptr32()
        self.FreeLists = vstruct.VArray([ LIST_ENTRY() for i in xrange(128) ])
        self.LockVariable = v_ptr32()
        self.CommitRoutine = v_ptr32()
        self.FrontEndHeap = v_ptr32()
        self.FrontHeapLockCount = v_uint16()
        self.FrontEndHeapType = v_uint8()
        self.LastSegmentIndex = v_uint8()


class MAILSLOT_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MailslotQuota = v_uint32()
        self.MaximumMessageSize = v_uint32()
        self.ReadTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0018 = v_bytes(size=7)


class IO_STATUS_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.Information = v_uint32()


class PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(1) ])


class CM_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.List = vstruct.VArray([ CM_FULL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class EPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pcb = KPROCESS()
        self.ProcessLock = EX_PUSH_LOCK()
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.UniqueProcessId = v_ptr32()
        self.ActiveProcessLinks = LIST_ENTRY()
        self.QuotaUsage = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.QuotaPeak = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.CommitCharge = v_uint32()
        self.PeakVirtualSize = v_uint32()
        self.VirtualSize = v_uint32()
        self.SessionProcessLinks = LIST_ENTRY()
        self.DebugPort = v_ptr32()
        self.ExceptionPort = v_ptr32()
        self.ObjectTable = v_ptr32()
        self.Token = EX_FAST_REF()
        self.WorkingSetLock = FAST_MUTEX()
        self.WorkingSetPage = v_uint32()
        self.AddressCreationLock = FAST_MUTEX()
        self.HyperSpaceLock = v_uint32()
        self.ForkInProgress = v_ptr32()
        self.HardwareTrigger = v_uint32()
        self.VadRoot = v_ptr32()
        self.VadHint = v_ptr32()
        self.CloneRoot = v_ptr32()
        self.NumberOfPrivatePages = v_uint32()
        self.NumberOfLockedPages = v_uint32()
        self.Win32Process = v_ptr32()
        self.Job = v_ptr32()
        self.SectionObject = v_ptr32()
        self.SectionBaseAddress = v_ptr32()
        self.QuotaBlock = v_ptr32()
        self.WorkingSetWatch = v_ptr32()
        self.Win32WindowStation = v_ptr32()
        self.InheritedFromUniqueProcessId = v_ptr32()
        self.LdtInformation = v_ptr32()
        self.VadFreeHint = v_ptr32()
        self.VdmObjects = v_ptr32()
        self.DeviceMap = v_ptr32()
        self.PhysicalVadList = LIST_ENTRY()
        self.PageDirectoryPte = HARDWARE_PTE_X86()
        self._pad0170 = v_bytes(size=4)
        self.Session = v_ptr32()
        self.ImageFileName = vstruct.VArray([ v_uint8() for i in xrange(16) ])
        self.JobLinks = LIST_ENTRY()
        self.LockedPagesList = v_ptr32()
        self.ThreadListHead = LIST_ENTRY()
        self.SecurityPort = v_ptr32()
        self.PaeTop = v_ptr32()
        self.ActiveThreads = v_uint32()
        self.GrantedAccess = v_uint32()
        self.DefaultHardErrorProcessing = v_uint32()
        self.LastThreadExitStatus = v_uint32()
        self.Peb = v_ptr32()
        self.PrefetchTrace = EX_FAST_REF()
        self.ReadOperationCount = LARGE_INTEGER()
        self.WriteOperationCount = LARGE_INTEGER()
        self.OtherOperationCount = LARGE_INTEGER()
        self.ReadTransferCount = LARGE_INTEGER()
        self.WriteTransferCount = LARGE_INTEGER()
        self.OtherTransferCount = LARGE_INTEGER()
        self.CommitChargeLimit = v_uint32()
        self.CommitChargePeak = v_uint32()
        self.AweInfo = v_ptr32()
        self.SeAuditProcessCreationInfo = SE_AUDIT_PROCESS_CREATION_INFO()
        self.Vm = MMSUPPORT()
        self.LastFaultCount = v_uint32()
        self.ModifiedPageCount = v_uint32()
        self.NumberOfVads = v_uint32()
        self.JobStatus = v_uint32()
        self.Flags = v_uint32()
        self.ExitStatus = v_uint32()
        self.NextPageColor = v_uint16()
        self.SubSystemMinorVersion = v_uint8()
        self.SubSystemMajorVersion = v_uint8()
        self.PriorityClass = v_uint8()
        self.WorkingSetAcquiredUnsafe = v_uint8()
        self._pad0258 = v_bytes(size=2)
        self.Cookie = v_uint32()
        self._pad0260 = v_bytes(size=4)


class LIST_ENTRY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint32()
        self.Blink = v_uint32()


class FILE_GET_QUOTA_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextEntryOffset = v_uint32()
        self.SidLength = v_uint32()
        self.Sid = SID()


class SINGLE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()


class _unnamed_5473(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Srb = v_ptr32()


class FX_SAVE_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.U = _unnamed_3291()
        self.NpxSavedCpu = v_uint32()
        self.Cr0NpxState = v_uint32()


class POWER_SEQUENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SequenceD1 = v_uint32()
        self.SequenceD2 = v_uint32()
        self.SequenceD3 = v_uint32()


class IO_COMPLETION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = v_ptr32()
        self.Key = v_ptr32()


class FS_FILTER_CALLBACK_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbackData = v_uint32()
        self.Operation = v_uint8()
        self.Reserved = v_uint8()
        self._pad0008 = v_bytes(size=2)
        self.DeviceObject = v_ptr32()
        self.FileObject = v_ptr32()
        self.Parameters = FS_FILTER_PARAMETERS()


class DRIVER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DriverObject = v_ptr32()
        self.AddDevice = v_ptr32()
        self.Count = v_uint32()
        self.ServiceKeyName = UNICODE_STRING()
        self.ClientDriverExtension = v_ptr32()
        self.FsFilterCallbacks = v_ptr32()


class KDEVICE_QUEUE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceListEntry = LIST_ENTRY()
        self.SortKey = v_uint32()
        self.Inserted = v_uint8()
        self._pad0010 = v_bytes(size=3)


class flags(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Removable = v_uint8()


class PAGEFAULT_HISTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CurrentIndex = v_uint32()
        self.MaxIndex = v_uint32()
        self.SpinLock = v_uint32()
        self.Reserved = v_ptr32()
        self.WatchInfo = vstruct.VArray([ PROCESS_WS_WATCH_INFORMATION() for i in xrange(1) ])


class CM_PARTIAL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Flags = v_uint16()
        self.u = _unnamed_5881()




########NEW FILE########
__FILENAME__ = ntoskrnl
# Version: 5.1
# Architecture: i386
import vstruct
from vstruct.primitives import *

POLICY_AUDIT_EVENT_TYPE = v_enum()
POLICY_AUDIT_EVENT_TYPE.AuditCategorySystem = 0
POLICY_AUDIT_EVENT_TYPE.AuditCategoryLogon = 1
POLICY_AUDIT_EVENT_TYPE.AuditCategoryObjectAccess = 2
POLICY_AUDIT_EVENT_TYPE.AuditCategoryPrivilegeUse = 3
POLICY_AUDIT_EVENT_TYPE.AuditCategoryDetailedTracking = 4
POLICY_AUDIT_EVENT_TYPE.AuditCategoryPolicyChange = 5
POLICY_AUDIT_EVENT_TYPE.AuditCategoryAccountManagement = 6
POLICY_AUDIT_EVENT_TYPE.AuditCategoryDirectoryServiceAccess = 7
POLICY_AUDIT_EVENT_TYPE.AuditCategoryAccountLogon = 8


KINTERRUPT_MODE = v_enum()
KINTERRUPT_MODE.LevelSensitive = 0
KINTERRUPT_MODE.Latched = 1


ARBITER_REQUEST_SOURCE = v_enum()
ARBITER_REQUEST_SOURCE.ArbiterRequestUndefined = -1
ARBITER_REQUEST_SOURCE.ArbiterRequestLegacyReported = 0
ARBITER_REQUEST_SOURCE.ArbiterRequestHalReported = 1
ARBITER_REQUEST_SOURCE.ArbiterRequestLegacyAssigned = 2
ARBITER_REQUEST_SOURCE.ArbiterRequestPnpDetected = 3
ARBITER_REQUEST_SOURCE.ArbiterRequestPnpEnumerated = 4


DEVICE_RELATION_TYPE = v_enum()
DEVICE_RELATION_TYPE.BusRelations = 0
DEVICE_RELATION_TYPE.EjectionRelations = 1
DEVICE_RELATION_TYPE.PowerRelations = 2
DEVICE_RELATION_TYPE.RemovalRelations = 3
DEVICE_RELATION_TYPE.TargetDeviceRelation = 4
DEVICE_RELATION_TYPE.SingleBusRelations = 5


IO_ALLOCATION_ACTION = v_enum()
IO_ALLOCATION_ACTION.KeepObject = 1
IO_ALLOCATION_ACTION.DeallocateObject = 2
IO_ALLOCATION_ACTION.DeallocateObjectKeepRegisters = 3


BUS_QUERY_ID_TYPE = v_enum()
BUS_QUERY_ID_TYPE.BusQueryDeviceID = 0
BUS_QUERY_ID_TYPE.BusQueryHardwareIDs = 1
BUS_QUERY_ID_TYPE.BusQueryCompatibleIDs = 2
BUS_QUERY_ID_TYPE.BusQueryInstanceID = 3
BUS_QUERY_ID_TYPE.BusQueryDeviceSerialNumber = 4


MMSYSTEM_PTE_POOL_TYPE = v_enum()
MMSYSTEM_PTE_POOL_TYPE.SystemPteSpace = 0
MMSYSTEM_PTE_POOL_TYPE.NonPagedPoolExpansion = 1
MMSYSTEM_PTE_POOL_TYPE.MaximumPtePoolTypes = 2


POP_POLICY_DEVICE_TYPE = v_enum()
POP_POLICY_DEVICE_TYPE.PolicyDeviceSystemButton = 0
POP_POLICY_DEVICE_TYPE.PolicyDeviceThermalZone = 1
POP_POLICY_DEVICE_TYPE.PolicyDeviceBattery = 2
POP_POLICY_DEVICE_TYPE.PolicyInitiatePowerActionAPI = 3
POP_POLICY_DEVICE_TYPE.PolicySetPowerStateAPI = 4
POP_POLICY_DEVICE_TYPE.PolicyImmediateDozeS4 = 5
POP_POLICY_DEVICE_TYPE.PolicySystemIdle = 6


MEMORY_CACHING_TYPE = v_enum()
MEMORY_CACHING_TYPE.MmNonCached = 0
MEMORY_CACHING_TYPE.MmCached = 1
MEMORY_CACHING_TYPE.MmWriteCombined = 2
MEMORY_CACHING_TYPE.MmHardwareCoherentCached = 3
MEMORY_CACHING_TYPE.MmNonCachedUnordered = 4
MEMORY_CACHING_TYPE.MmUSWCCached = 5
MEMORY_CACHING_TYPE.MmMaximumCacheType = 6


NT_PRODUCT_TYPE = v_enum()
NT_PRODUCT_TYPE.NtProductWinNt = 1
NT_PRODUCT_TYPE.NtProductLanManNt = 2
NT_PRODUCT_TYPE.NtProductServer = 3


DEVICE_POWER_STATE = v_enum()
DEVICE_POWER_STATE.PowerDeviceUnspecified = 0
DEVICE_POWER_STATE.PowerDeviceD0 = 1
DEVICE_POWER_STATE.PowerDeviceD1 = 2
DEVICE_POWER_STATE.PowerDeviceD2 = 3
DEVICE_POWER_STATE.PowerDeviceD3 = 4
DEVICE_POWER_STATE.PowerDeviceMaximum = 5


PF_SCENARIO_TYPE = v_enum()
PF_SCENARIO_TYPE.PfApplicationLaunchScenarioType = 0
PF_SCENARIO_TYPE.PfSystemBootScenarioType = 1
PF_SCENARIO_TYPE.PfMaxScenarioType = 2


TOKEN_TYPE = v_enum()
TOKEN_TYPE.TokenPrimary = 1
TOKEN_TYPE.TokenImpersonation = 2


VI_DEADLOCK_RESOURCE_TYPE = v_enum()
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockUnknown = 0
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockMutex = 1
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockFastMutex = 2
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockFastMutexUnsafe = 3
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockSpinLock = 4
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockQueuedSpinLock = 5
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockTypeMaximum = 6


FSINFOCLASS = v_enum()
FSINFOCLASS.FileFsVolumeInformation = 1
FSINFOCLASS.FileFsLabelInformation = 2
FSINFOCLASS.FileFsSizeInformation = 3
FSINFOCLASS.FileFsDeviceInformation = 4
FSINFOCLASS.FileFsAttributeInformation = 5
FSINFOCLASS.FileFsControlInformation = 6
FSINFOCLASS.FileFsFullSizeInformation = 7
FSINFOCLASS.FileFsObjectIdInformation = 8
FSINFOCLASS.FileFsDriverPathInformation = 9
FSINFOCLASS.FileFsMaximumInformation = 10


ARBITER_ACTION = v_enum()
ARBITER_ACTION.ArbiterActionTestAllocation = 0
ARBITER_ACTION.ArbiterActionRetestAllocation = 1
ARBITER_ACTION.ArbiterActionCommitAllocation = 2
ARBITER_ACTION.ArbiterActionRollbackAllocation = 3
ARBITER_ACTION.ArbiterActionQueryAllocatedResources = 4
ARBITER_ACTION.ArbiterActionWriteReservedResources = 5
ARBITER_ACTION.ArbiterActionQueryConflict = 6
ARBITER_ACTION.ArbiterActionQueryArbitrate = 7
ARBITER_ACTION.ArbiterActionAddReserved = 8
ARBITER_ACTION.ArbiterActionBootAllocation = 9


POOL_TYPE = v_enum()
POOL_TYPE.NonPagedPool = 0
POOL_TYPE.PagedPool = 1
POOL_TYPE.NonPagedPoolMustSucceed = 2
POOL_TYPE.DontUseThisType = 3
POOL_TYPE.NonPagedPoolCacheAligned = 4
POOL_TYPE.PagedPoolCacheAligned = 5
POOL_TYPE.NonPagedPoolCacheAlignedMustS = 6
POOL_TYPE.MaxPoolType = 7
POOL_TYPE.NonPagedPoolSession = 32
POOL_TYPE.PagedPoolSession = 33
POOL_TYPE.NonPagedPoolMustSucceedSession = 34
POOL_TYPE.DontUseThisTypeSession = 35
POOL_TYPE.NonPagedPoolCacheAlignedSession = 36
POOL_TYPE.PagedPoolCacheAlignedSession = 37
POOL_TYPE.NonPagedPoolCacheAlignedMustSSession = 38


PCI_DISPATCH_STYLE = v_enum()
PCI_DISPATCH_STYLE.IRP_COMPLETE = 0
PCI_DISPATCH_STYLE.IRP_DOWNWARD = 1
PCI_DISPATCH_STYLE.IRP_UPWARD = 2
PCI_DISPATCH_STYLE.IRP_DISPATCH = 3


MODE = v_enum()
MODE.KernelMode = 0
MODE.UserMode = 1
MODE.MaximumMode = 2


FS_FILTER_SECTION_SYNC_TYPE = v_enum()
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeOther = 0
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeCreateSection = 1


OB_OPEN_REASON = v_enum()
OB_OPEN_REASON.ObCreateHandle = 0
OB_OPEN_REASON.ObOpenHandle = 1
OB_OPEN_REASON.ObDuplicateHandle = 2
OB_OPEN_REASON.ObInheritHandle = 3
OB_OPEN_REASON.ObMaxOpenReason = 4


CPU_VENDORS = v_enum()
CPU_VENDORS.CPU_NONE = 0
CPU_VENDORS.CPU_INTEL = 1
CPU_VENDORS.CPU_AMD = 2
CPU_VENDORS.CPU_CYRIX = 3
CPU_VENDORS.CPU_TRANSMETA = 4
CPU_VENDORS.CPU_CENTAUR = 5
CPU_VENDORS.CPU_RISE = 6
CPU_VENDORS.CPU_UNKNOWN = 7


DEVICE_TEXT_TYPE = v_enum()
DEVICE_TEXT_TYPE.DeviceTextDescription = 0
DEVICE_TEXT_TYPE.DeviceTextLocationInformation = 1


POWER_STATE_TYPE = v_enum()
POWER_STATE_TYPE.SystemPowerState = 0
POWER_STATE_TYPE.DevicePowerState = 1


BUS_DATA_TYPE = v_enum()
BUS_DATA_TYPE.ConfigurationSpaceUndefined = -1
BUS_DATA_TYPE.Cmos = 0
BUS_DATA_TYPE.EisaConfiguration = 1
BUS_DATA_TYPE.Pos = 2
BUS_DATA_TYPE.CbusConfiguration = 3
BUS_DATA_TYPE.PCIConfiguration = 4
BUS_DATA_TYPE.VMEConfiguration = 5
BUS_DATA_TYPE.NuBusConfiguration = 6
BUS_DATA_TYPE.PCMCIAConfiguration = 7
BUS_DATA_TYPE.MPIConfiguration = 8
BUS_DATA_TYPE.MPSAConfiguration = 9
BUS_DATA_TYPE.PNPISAConfiguration = 10
BUS_DATA_TYPE.SgiInternalConfiguration = 11
BUS_DATA_TYPE.MaximumBusDataType = 12


LSA_FOREST_TRUST_RECORD_TYPE = v_enum()
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName = 0
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx = 1
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo = 2
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustRecordTypeLast = 2


FILE_INFORMATION_CLASS = v_enum()
FILE_INFORMATION_CLASS.FileDirectoryInformation = 1
FILE_INFORMATION_CLASS.FileFullDirectoryInformation = 2
FILE_INFORMATION_CLASS.FileBothDirectoryInformation = 3
FILE_INFORMATION_CLASS.FileBasicInformation = 4
FILE_INFORMATION_CLASS.FileStandardInformation = 5
FILE_INFORMATION_CLASS.FileInternalInformation = 6
FILE_INFORMATION_CLASS.FileEaInformation = 7
FILE_INFORMATION_CLASS.FileAccessInformation = 8
FILE_INFORMATION_CLASS.FileNameInformation = 9
FILE_INFORMATION_CLASS.FileRenameInformation = 10
FILE_INFORMATION_CLASS.FileLinkInformation = 11
FILE_INFORMATION_CLASS.FileNamesInformation = 12
FILE_INFORMATION_CLASS.FileDispositionInformation = 13
FILE_INFORMATION_CLASS.FilePositionInformation = 14
FILE_INFORMATION_CLASS.FileFullEaInformation = 15
FILE_INFORMATION_CLASS.FileModeInformation = 16
FILE_INFORMATION_CLASS.FileAlignmentInformation = 17
FILE_INFORMATION_CLASS.FileAllInformation = 18
FILE_INFORMATION_CLASS.FileAllocationInformation = 19
FILE_INFORMATION_CLASS.FileEndOfFileInformation = 20
FILE_INFORMATION_CLASS.FileAlternateNameInformation = 21
FILE_INFORMATION_CLASS.FileStreamInformation = 22
FILE_INFORMATION_CLASS.FilePipeInformation = 23
FILE_INFORMATION_CLASS.FilePipeLocalInformation = 24
FILE_INFORMATION_CLASS.FilePipeRemoteInformation = 25
FILE_INFORMATION_CLASS.FileMailslotQueryInformation = 26
FILE_INFORMATION_CLASS.FileMailslotSetInformation = 27
FILE_INFORMATION_CLASS.FileCompressionInformation = 28
FILE_INFORMATION_CLASS.FileObjectIdInformation = 29
FILE_INFORMATION_CLASS.FileCompletionInformation = 30
FILE_INFORMATION_CLASS.FileMoveClusterInformation = 31
FILE_INFORMATION_CLASS.FileQuotaInformation = 32
FILE_INFORMATION_CLASS.FileReparsePointInformation = 33
FILE_INFORMATION_CLASS.FileNetworkOpenInformation = 34
FILE_INFORMATION_CLASS.FileAttributeTagInformation = 35
FILE_INFORMATION_CLASS.FileTrackingInformation = 36
FILE_INFORMATION_CLASS.FileIdBothDirectoryInformation = 37
FILE_INFORMATION_CLASS.FileIdFullDirectoryInformation = 38
FILE_INFORMATION_CLASS.FileValidDataLengthInformation = 39
FILE_INFORMATION_CLASS.FileShortNameInformation = 40
FILE_INFORMATION_CLASS.FileMaximumInformation = 41


EXCEPTION_DISPOSITION = v_enum()
EXCEPTION_DISPOSITION.ExceptionContinueExecution = 0
EXCEPTION_DISPOSITION.ExceptionContinueSearch = 1
EXCEPTION_DISPOSITION.ExceptionNestedException = 2
EXCEPTION_DISPOSITION.ExceptionCollidedUnwind = 3


PNP_VETO_TYPE = v_enum()
PNP_VETO_TYPE.PNP_VetoTypeUnknown = 0
PNP_VETO_TYPE.PNP_VetoLegacyDevice = 1
PNP_VETO_TYPE.PNP_VetoPendingClose = 2
PNP_VETO_TYPE.PNP_VetoWindowsApp = 3
PNP_VETO_TYPE.PNP_VetoWindowsService = 4
PNP_VETO_TYPE.PNP_VetoOutstandingOpen = 5
PNP_VETO_TYPE.PNP_VetoDevice = 6
PNP_VETO_TYPE.PNP_VetoDriver = 7
PNP_VETO_TYPE.PNP_VetoIllegalDeviceRequest = 8
PNP_VETO_TYPE.PNP_VetoInsufficientPower = 9
PNP_VETO_TYPE.PNP_VetoNonDisableable = 10
PNP_VETO_TYPE.PNP_VetoLegacyDriver = 11
PNP_VETO_TYPE.PNP_VetoInsufficientRights = 12


PCI_SIGNATURE = v_enum()
PCI_SIGNATURE.PciPdoExtensionType = 1768116272
PCI_SIGNATURE.PciFdoExtensionType = 1768116273
PCI_SIGNATURE.PciArb_Io = 1768116274
PCI_SIGNATURE.PciArb_Memory = 1768116275
PCI_SIGNATURE.PciArb_Interrupt = 1768116276
PCI_SIGNATURE.PciArb_BusNumber = 1768116277
PCI_SIGNATURE.PciTrans_Interrupt = 1768116278
PCI_SIGNATURE.PciInterface_BusHandler = 1768116279
PCI_SIGNATURE.PciInterface_IntRouteHandler = 1768116280
PCI_SIGNATURE.PciInterface_PciCb = 1768116281
PCI_SIGNATURE.PciInterface_LegacyDeviceDetection = 1768116282
PCI_SIGNATURE.PciInterface_PmeHandler = 1768116283
PCI_SIGNATURE.PciInterface_DevicePresent = 1768116284
PCI_SIGNATURE.PciInterface_NativeIde = 1768116285
PCI_SIGNATURE.PciInterface_AgpTarget = 1768116286


SECURITY_OPERATION_CODE = v_enum()
SECURITY_OPERATION_CODE.SetSecurityDescriptor = 0
SECURITY_OPERATION_CODE.QuerySecurityDescriptor = 1
SECURITY_OPERATION_CODE.DeleteSecurityDescriptor = 2
SECURITY_OPERATION_CODE.AssignSecurityDescriptor = 3


PP_NPAGED_LOOKASIDE_NUMBER = v_enum()
PP_NPAGED_LOOKASIDE_NUMBER.LookasideSmallIrpList = 0
PP_NPAGED_LOOKASIDE_NUMBER.LookasideLargeIrpList = 1
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMdlList = 2
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCreateInfoList = 3
PP_NPAGED_LOOKASIDE_NUMBER.LookasideNameBufferList = 4
PP_NPAGED_LOOKASIDE_NUMBER.LookasideTwilightList = 5
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCompletionList = 6
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMaximumList = 7


SECURITY_IMPERSONATION_LEVEL = v_enum()
SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous = 0
SECURITY_IMPERSONATION_LEVEL.SecurityIdentification = 1
SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation = 2
SECURITY_IMPERSONATION_LEVEL.SecurityDelegation = 3


DEVICE_USAGE_NOTIFICATION_TYPE = v_enum()
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeUndefined = 0
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypePaging = 1
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeHibernation = 2
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeDumpFile = 3


PROXY_CLASS = v_enum()
PROXY_CLASS.ProxyFull = 0
PROXY_CLASS.ProxyService = 1
PROXY_CLASS.ProxyTree = 2
PROXY_CLASS.ProxyDirectory = 3


PLUGPLAY_EVENT_CATEGORY = v_enum()
PLUGPLAY_EVENT_CATEGORY.HardwareProfileChangeEvent = 0
PLUGPLAY_EVENT_CATEGORY.TargetDeviceChangeEvent = 1
PLUGPLAY_EVENT_CATEGORY.DeviceClassChangeEvent = 2
PLUGPLAY_EVENT_CATEGORY.CustomDeviceEvent = 3
PLUGPLAY_EVENT_CATEGORY.DeviceInstallEvent = 4
PLUGPLAY_EVENT_CATEGORY.DeviceArrivalEvent = 5
PLUGPLAY_EVENT_CATEGORY.PowerEvent = 6
PLUGPLAY_EVENT_CATEGORY.VetoEvent = 7
PLUGPLAY_EVENT_CATEGORY.BlockedDriverEvent = 8
PLUGPLAY_EVENT_CATEGORY.MaxPlugEventCategory = 9


INTERFACE_TYPE = v_enum()
INTERFACE_TYPE.InterfaceTypeUndefined = -1
INTERFACE_TYPE.Internal = 0
INTERFACE_TYPE.Isa = 1
INTERFACE_TYPE.Eisa = 2
INTERFACE_TYPE.MicroChannel = 3
INTERFACE_TYPE.TurboChannel = 4
INTERFACE_TYPE.PCIBus = 5
INTERFACE_TYPE.VMEBus = 6
INTERFACE_TYPE.NuBus = 7
INTERFACE_TYPE.PCMCIABus = 8
INTERFACE_TYPE.CBus = 9
INTERFACE_TYPE.MPIBus = 10
INTERFACE_TYPE.MPSABus = 11
INTERFACE_TYPE.ProcessorInternal = 12
INTERFACE_TYPE.InternalPowerBus = 13
INTERFACE_TYPE.PNPISABus = 14
INTERFACE_TYPE.PNPBus = 15
INTERFACE_TYPE.MaximumInterfaceType = 16


KWAIT_REASON = v_enum()
KWAIT_REASON.Executive = 0
KWAIT_REASON.FreePage = 1
KWAIT_REASON.PageIn = 2
KWAIT_REASON.PoolAllocation = 3
KWAIT_REASON.DelayExecution = 4
KWAIT_REASON.Suspended = 5
KWAIT_REASON.UserRequest = 6
KWAIT_REASON.WrExecutive = 7
KWAIT_REASON.WrFreePage = 8
KWAIT_REASON.WrPageIn = 9
KWAIT_REASON.WrPoolAllocation = 10
KWAIT_REASON.WrDelayExecution = 11
KWAIT_REASON.WrSuspended = 12
KWAIT_REASON.WrUserRequest = 13
KWAIT_REASON.WrEventPair = 14
KWAIT_REASON.WrQueue = 15
KWAIT_REASON.WrLpcReceive = 16
KWAIT_REASON.WrLpcReply = 17
KWAIT_REASON.WrVirtualMemory = 18
KWAIT_REASON.WrPageOut = 19
KWAIT_REASON.WrRendezvous = 20
KWAIT_REASON.Spare2 = 21
KWAIT_REASON.Spare3 = 22
KWAIT_REASON.Spare4 = 23
KWAIT_REASON.Spare5 = 24
KWAIT_REASON.Spare6 = 25
KWAIT_REASON.WrKernel = 26
KWAIT_REASON.MaximumWaitReason = 27


ALTERNATIVE_ARCHITECTURE_TYPE = v_enum()
ALTERNATIVE_ARCHITECTURE_TYPE.StandardDesign = 0
ALTERNATIVE_ARCHITECTURE_TYPE.NEC98x86 = 1
ALTERNATIVE_ARCHITECTURE_TYPE.EndAlternatives = 2


MMLISTS = v_enum()
MMLISTS.ZeroedPageList = 0
MMLISTS.FreePageList = 1
MMLISTS.StandbyPageList = 2
MMLISTS.ModifiedPageList = 3
MMLISTS.ModifiedNoWritePageList = 4
MMLISTS.BadPageList = 5
MMLISTS.ActiveAndValid = 6
MMLISTS.TransitionPage = 7


MEMORY_TYPE = v_enum()
MEMORY_TYPE.MemoryExceptionBlock = 0
MEMORY_TYPE.MemorySystemBlock = 1
MEMORY_TYPE.MemoryFree = 2
MEMORY_TYPE.MemoryBad = 3
MEMORY_TYPE.MemoryLoadedProgram = 4
MEMORY_TYPE.MemoryFirmwareTemporary = 5
MEMORY_TYPE.MemoryFirmwarePermanent = 6
MEMORY_TYPE.MemoryFreeContiguous = 7
MEMORY_TYPE.MemorySpecialMemory = 8
MEMORY_TYPE.MemoryMaximum = 9


PS_QUOTA_TYPE = v_enum()
PS_QUOTA_TYPE.PsNonPagedPool = 0
PS_QUOTA_TYPE.PsPagedPool = 1
PS_QUOTA_TYPE.PsPageFile = 2
PS_QUOTA_TYPE.PsQuotaTypes = 3


ReplacesCorHdrNumericDefines = v_enum()
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY = 1
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED = 2
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY = 4
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED = 8
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2 = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MINOR = 0
ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB = 1
ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA = 1
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA = 2
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT = 1
ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT = 2
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED = 4
ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED = 16
ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE = 32
ReplacesCorHdrNumericDefines.MAX_CLASS_NAME = 1024
ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME = 1024


ARBITER_RESULT = v_enum()
ARBITER_RESULT.ArbiterResultUndefined = -1
ARBITER_RESULT.ArbiterResultSuccess = 0
ARBITER_RESULT.ArbiterResultExternalConflict = 1
ARBITER_RESULT.ArbiterResultNullRequest = 2


SYSTEM_POWER_STATE = v_enum()
SYSTEM_POWER_STATE.PowerSystemUnspecified = 0
SYSTEM_POWER_STATE.PowerSystemWorking = 1
SYSTEM_POWER_STATE.PowerSystemSleeping1 = 2
SYSTEM_POWER_STATE.PowerSystemSleeping2 = 3
SYSTEM_POWER_STATE.PowerSystemSleeping3 = 4
SYSTEM_POWER_STATE.PowerSystemHibernate = 5
SYSTEM_POWER_STATE.PowerSystemShutdown = 6
SYSTEM_POWER_STATE.PowerSystemMaximum = 7


MEMORY_CACHING_TYPE_ORIG = v_enum()
MEMORY_CACHING_TYPE_ORIG.MmFrameBufferCached = 2


POWER_ACTION = v_enum()
POWER_ACTION.PowerActionNone = 0
POWER_ACTION.PowerActionReserved = 1
POWER_ACTION.PowerActionSleep = 2
POWER_ACTION.PowerActionHibernate = 3
POWER_ACTION.PowerActionShutdown = 4
POWER_ACTION.PowerActionShutdownReset = 5
POWER_ACTION.PowerActionShutdownOff = 6
POWER_ACTION.PowerActionWarmEject = 7


PNP_DEVNODE_STATE = v_enum()
PNP_DEVNODE_STATE.DeviceNodeUnspecified = 768
PNP_DEVNODE_STATE.DeviceNodeUninitialized = 769
PNP_DEVNODE_STATE.DeviceNodeInitialized = 770
PNP_DEVNODE_STATE.DeviceNodeDriversAdded = 771
PNP_DEVNODE_STATE.DeviceNodeResourcesAssigned = 772
PNP_DEVNODE_STATE.DeviceNodeStartPending = 773
PNP_DEVNODE_STATE.DeviceNodeStartCompletion = 774
PNP_DEVNODE_STATE.DeviceNodeStartPostWork = 775
PNP_DEVNODE_STATE.DeviceNodeStarted = 776
PNP_DEVNODE_STATE.DeviceNodeQueryStopped = 777
PNP_DEVNODE_STATE.DeviceNodeStopped = 778
PNP_DEVNODE_STATE.DeviceNodeRestartCompletion = 779
PNP_DEVNODE_STATE.DeviceNodeEnumeratePending = 780
PNP_DEVNODE_STATE.DeviceNodeEnumerateCompletion = 781
PNP_DEVNODE_STATE.DeviceNodeAwaitingQueuedDeletion = 782
PNP_DEVNODE_STATE.DeviceNodeAwaitingQueuedRemoval = 783
PNP_DEVNODE_STATE.DeviceNodeQueryRemoved = 784
PNP_DEVNODE_STATE.DeviceNodeRemovePendingCloses = 785
PNP_DEVNODE_STATE.DeviceNodeRemoved = 786
PNP_DEVNODE_STATE.DeviceNodeDeletePendingCloses = 787
PNP_DEVNODE_STATE.DeviceNodeDeleted = 788


PROFILE_STATUS = v_enum()
PROFILE_STATUS.DOCK_NOTDOCKDEVICE = 0
PROFILE_STATUS.DOCK_QUIESCENT = 1
PROFILE_STATUS.DOCK_ARRIVING = 2
PROFILE_STATUS.DOCK_DEPARTING = 3
PROFILE_STATUS.DOCK_EJECTIRP_COMPLETED = 4


MI_PFN_CACHE_ATTRIBUTE = v_enum()
MI_PFN_CACHE_ATTRIBUTE.MiNonCached = 0
MI_PFN_CACHE_ATTRIBUTE.MiCached = 1
MI_PFN_CACHE_ATTRIBUTE.MiWriteCombined = 2
MI_PFN_CACHE_ATTRIBUTE.MiNotMapped = 3


class KEXECUTE_OPTIONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteDisable = v_uint8()


class PCI_PMC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint8()
        self.Support = PM_SUPPORT()


class _unnamed_14487(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = LIST_ENTRY()


class _unnamed_14486(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserData = v_ptr32()
        self.Owner = v_ptr32()


class _unnamed_16779(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EndingOffset = v_ptr32()
        self.ResourceToRelease = v_ptr32()


class SEGMENT_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseAddress = v_ptr32()
        self.TotalNumberOfPtes = v_uint32()
        self.SizeOfSegment = LARGE_INTEGER()
        self.NonExtendedPtes = v_uint32()
        self.ImageCommitment = v_uint32()
        self.ControlArea = v_ptr32()
        self.Subsection = v_ptr32()
        self.LargeControlArea = v_ptr32()
        self.MmSectionFlags = v_ptr32()
        self.MmSubSectionFlags = v_ptr32()
        self._pad0030 = v_bytes(size=4)


class DUAL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Map = v_ptr32()
        self.SmallDir = v_ptr32()
        self.Guard = v_uint32()
        self.FreeDisplay = vstruct.VArray([ RTL_BITMAP() for i in xrange(24) ])
        self.FreeSummary = v_uint32()
        self.FreeBins = LIST_ENTRY()


class SID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.SubAuthorityCount = v_uint8()
        self.IdentifierAuthority = SID_IDENTIFIER_AUTHORITY()
        self.SubAuthority = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class MMPTE_HARDWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class PCI_FUNCTION_RESOURCES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Limit = vstruct.VArray([ IO_RESOURCE_DESCRIPTOR() for i in xrange(7) ])
        self.Current = vstruct.VArray([ CM_PARTIAL_RESOURCE_DESCRIPTOR() for i in xrange(7) ])


class _unnamed_13153(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EntireFrame = v_uint32()


class DBGKD_SET_SPECIAL_CALL64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SpecialCall = v_uint64()


class _unnamed_13092(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Bytes = _unnamed_14544()


class KTSS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Backlink = v_uint16()
        self.Reserved0 = v_uint16()
        self.Esp0 = v_uint32()
        self.Ss0 = v_uint16()
        self.Reserved1 = v_uint16()
        self.NotUsed1 = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.CR3 = v_uint32()
        self.Eip = v_uint32()
        self.EFlags = v_uint32()
        self.Eax = v_uint32()
        self.Ecx = v_uint32()
        self.Edx = v_uint32()
        self.Ebx = v_uint32()
        self.Esp = v_uint32()
        self.Ebp = v_uint32()
        self.Esi = v_uint32()
        self.Edi = v_uint32()
        self.Es = v_uint16()
        self.Reserved2 = v_uint16()
        self.Cs = v_uint16()
        self.Reserved3 = v_uint16()
        self.Ss = v_uint16()
        self.Reserved4 = v_uint16()
        self.Ds = v_uint16()
        self.Reserved5 = v_uint16()
        self.Fs = v_uint16()
        self.Reserved6 = v_uint16()
        self.Gs = v_uint16()
        self.Reserved7 = v_uint16()
        self.LDT = v_uint16()
        self.Reserved8 = v_uint16()
        self.Flags = v_uint16()
        self.IoMapBase = v_uint16()
        self.IoMaps = vstruct.VArray([ KiIoAccessMap() for i in xrange(1) ])
        self.IntDirectionMap = vstruct.VArray([ v_uint8() for i in xrange(32) ])


class CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DosPath = UNICODE_STRING()
        self.Handle = v_ptr32()


class DBGKD_GET_INTERNAL_BREAKPOINT32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakpointAddress = v_uint32()
        self.Flags = v_uint32()
        self.Calls = v_uint32()
        self.MaxCallsPerPeriod = v_uint32()
        self.MinInstructions = v_uint32()
        self.MaxInstructions = v_uint32()
        self.TotalInstructions = v_uint32()


class DBGKD_MANIPULATE_STATE32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ApiNumber = v_uint32()
        self.ProcessorLevel = v_uint16()
        self.Processor = v_uint16()
        self.ReturnStatus = v_uint32()
        self.u = _unnamed_11882()


class _unnamed_11075(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self._pad0028 = v_bytes(size=32)


class PROCESSOR_POWER_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint32()
        self.DynamicThrottle = v_uint8()
        self.Spare = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.DisableCStates = v_uint32()
        self.PolicyCount = v_uint32()
        self.Policy = vstruct.VArray([ PROCESSOR_POWER_POLICY_INFO() for i in xrange(3) ])


class _unnamed_11597(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Long = v_uint32()


class _unnamed_12520(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags = v_uint32()


class BITMAP_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Links = LIST_ENTRY()
        self.BasePage = v_uint64()
        self.FirstDirtyPage = v_uint32()
        self.LastDirtyPage = v_uint32()
        self.DirtyPages = v_uint32()
        self.Bitmap = v_ptr32()


class HARDWARE_PTE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class HANDLE_TABLE_ENTRY_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AuditMask = v_uint32()


class DBGKD_WRITE_MEMORY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TargetBaseAddress = v_uint32()
        self.TransferCount = v_uint32()
        self.ActualBytesWritten = v_uint32()


class _unnamed_13252(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_ptr32()


class PCI_INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_ptr32()
        self.MinSize = v_uint16()
        self.MinVersion = v_uint16()
        self.MaxVersion = v_uint16()
        self.Flags = v_uint16()
        self.ReferenceCount = v_uint32()
        self.Signature = v_uint32()
        self.Constructor = v_ptr32()
        self.Initializer = v_ptr32()


class _unnamed_16629(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceId = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class MMWSLENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class _unnamed_12976(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsynchronousParameters = _unnamed_14745()


class CM_PARTIAL_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.PartialDescriptors = vstruct.VArray([ CM_PARTIAL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class DBGKD_RESTORE_BREAKPOINT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakPointHandle = v_uint32()


class DEVICE_CAPABILITIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.DeviceD1 = v_uint32()
        self.Address = v_uint32()
        self.UINumber = v_uint32()
        self.DeviceState = vstruct.VArray([ DEVICE_POWER_STATE() for i in xrange(7) ])
        self.SystemWake = v_uint32()
        self.DeviceWake = v_uint32()
        self.D1Latency = v_uint32()
        self.D2Latency = v_uint32()
        self.D3Latency = v_uint32()


class _unnamed_12973(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MasterIrp = v_ptr32()


class _unnamed_16624(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClassGuid = GUID()
        self.SymbolicLinkName = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0014 = v_bytes(size=2)


class _unnamed_16310(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.MinBusNumber = v_uint32()
        self.MaxBusNumber = v_uint32()
        self.Reserved = v_uint32()


class _unnamed_16315(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Priority = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class EXCEPTION_RECORD64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_uint64()
        self.ExceptionAddress = v_uint64()
        self.NumberParameters = v_uint32()
        self.unusedAlignment = v_uint32()
        self.ExceptionInformation = vstruct.VArray([ v_uint64() for i in xrange(15) ])


class _unnamed_16250(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProviderId = v_uint32()
        self.DataPath = v_ptr32()
        self.BufferSize = v_uint32()
        self.Buffer = v_ptr32()


class KPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.ProfileListHead = LIST_ENTRY()
        self.DirectoryTableBase = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.LdtDescriptor = KGDTENTRY()
        self.Int21Descriptor = KIDTENTRY()
        self.IopmOffset = v_uint16()
        self.Iopl = v_uint8()
        self.Unused = v_uint8()
        self.ActiveProcessors = v_uint32()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.ReadyListHead = LIST_ENTRY()
        self.SwapListEntry = SINGLE_LIST_ENTRY()
        self.VdmTrapcHandler = v_ptr32()
        self.ThreadListHead = LIST_ENTRY()
        self.ProcessLock = v_uint32()
        self.Affinity = v_uint32()
        self.StackCount = v_uint16()
        self.BasePriority = v_uint8()
        self.ThreadQuantum = v_uint8()
        self.AutoAlignment = v_uint8()
        self.State = v_uint8()
        self.ThreadSeed = v_uint8()
        self.DisableBoost = v_uint8()
        self.PowerState = v_uint8()
        self.DisableQuantum = v_uint8()
        self.IdealNode = v_uint8()
        self.Flags = KEXECUTE_OPTIONS()


class DEVICE_OBJECT_POWER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleCount = v_uint32()
        self.ConservationIdleTime = v_uint32()
        self.PerformanceIdleTime = v_uint32()
        self.DeviceObject = v_ptr32()
        self.IdleList = LIST_ENTRY()
        self.DeviceType = v_uint8()
        self._pad001c = v_bytes(size=3)
        self.State = v_uint32()
        self.NotifySourceList = LIST_ENTRY()
        self.NotifyTargetList = LIST_ENTRY()
        self.PowerChannelSummary = POWER_CHANNEL_SUMMARY()
        self.Volume = LIST_ENTRY()


class MMPTE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class HEAP_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint32()
        self.TagIndex = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self.TagName = vstruct.VArray([ v_uint16() for i in xrange(24) ])


class VI_POOL_ENTRY_INUSE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_ptr32()
        self.CallingAddress = v_ptr32()
        self.NumberOfBytes = v_uint32()
        self.Tag = v_uint32()


class HEAP_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Counters = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self._pad0030 = v_bytes(size=4)


class MMPTE_TRANSITION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class _unnamed_16247(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedResources = v_ptr32()
        self.AllocatedResourcesTranslated = v_ptr32()


class OBJECT_HANDLE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleAttributes = v_uint32()
        self.GrantedAccess = v_uint32()


class OWNER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerThread = v_uint32()
        self.OwnerCount = v_uint32()


class DEVOBJ_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.PowerFlags = v_uint32()
        self.Dope = v_ptr32()
        self.ExtensionFlags = v_uint32()
        self.DeviceNode = v_ptr32()
        self.AttachedTo = v_ptr32()
        self.StartIoCount = v_uint32()
        self.StartIoKey = v_uint32()
        self.StartIoFlags = v_uint32()
        self.Vpb = v_ptr32()


class _unnamed_14357(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.bits = _unnamed_16509()


class ARBITER_ALLOCATION_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint64()
        self.End = v_uint64()
        self.CurrentMinimum = v_uint64()
        self.CurrentMaximum = v_uint64()
        self.Entry = v_ptr32()
        self.CurrentAlternative = v_ptr32()
        self.AlternativeCount = v_uint32()
        self.Alternatives = v_ptr32()
        self.Flags = v_uint16()
        self.RangeAttributes = v_uint8()
        self.RangeAvailableAttributes = v_uint8()
        self.WorkSpace = v_uint32()


class DBGKD_SET_INTERNAL_BREAKPOINT64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakpointAddress = v_uint64()
        self.Flags = v_uint32()
        self._pad0010 = v_bytes(size=4)


class _unnamed_16089(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.EaList = v_ptr32()
        self.EaListLength = v_uint32()
        self.EaIndex = v_uint32()


class MM_DRIVER_VERIFIER_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint32()
        self.RaiseIrqls = v_uint32()
        self.AcquireSpinLocks = v_uint32()
        self.SynchronizeExecutions = v_uint32()
        self.AllocationsAttempted = v_uint32()
        self.AllocationsSucceeded = v_uint32()
        self.AllocationsSucceededSpecialPool = v_uint32()
        self.AllocationsWithNoTag = v_uint32()
        self.TrimRequests = v_uint32()
        self.Trims = v_uint32()
        self.AllocationsFailed = v_uint32()
        self.AllocationsFailedDeliberately = v_uint32()
        self.Loads = v_uint32()
        self.Unloads = v_uint32()
        self.UnTrackedPool = v_uint32()
        self.UserTrims = v_uint32()
        self.CurrentPagedPoolAllocations = v_uint32()
        self.CurrentNonPagedPoolAllocations = v_uint32()
        self.PeakPagedPoolAllocations = v_uint32()
        self.PeakNonPagedPoolAllocations = v_uint32()
        self.PagedBytes = v_uint32()
        self.NonPagedBytes = v_uint32()
        self.PeakPagedBytes = v_uint32()
        self.PeakNonPagedBytes = v_uint32()
        self.BurstAllocationsFailedDeliberately = v_uint32()
        self.SessionTrims = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(2) ])


class PI_BUS_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.NumberCSNs = v_uint32()
        self.ReadDataPort = v_ptr32()
        self.DataPortMapped = v_uint8()
        self._pad0010 = v_bytes(size=3)
        self.AddressPort = v_ptr32()
        self.AddrPortMapped = v_uint8()
        self._pad0018 = v_bytes(size=3)
        self.CommandPort = v_ptr32()
        self.CmdPortMapped = v_uint8()
        self._pad0020 = v_bytes(size=3)
        self.NextSlotNumber = v_uint32()
        self.DeviceList = SINGLE_LIST_ENTRY()
        self.CardList = SINGLE_LIST_ENTRY()
        self.PhysicalBusDevice = v_ptr32()
        self.FunctionalBusDevice = v_ptr32()
        self.AttachedDevice = v_ptr32()
        self.BusNumber = v_uint32()
        self.SystemPowerState = v_uint32()
        self.DevicePowerState = v_uint32()


class MAILSLOT_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MailslotQuota = v_uint32()
        self.MaximumMessageSize = v_uint32()
        self.ReadTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0018 = v_bytes(size=7)


class FS_FILTER_CALLBACK_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbackData = v_uint32()
        self.Operation = v_uint8()
        self.Reserved = v_uint8()
        self._pad0008 = v_bytes(size=2)
        self.DeviceObject = v_ptr32()
        self.FileObject = v_ptr32()
        self.Parameters = FS_FILTER_PARAMETERS()


class ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OperationID = LUID()
        self.SecurityEvaluated = v_uint8()
        self.GenerateAudit = v_uint8()
        self.GenerateOnClose = v_uint8()
        self.PrivilegesAllocated = v_uint8()
        self.Flags = v_uint32()
        self.RemainingDesiredAccess = v_uint32()
        self.PreviouslyGrantedAccess = v_uint32()
        self.OriginalDesiredAccess = v_uint32()
        self.SubjectSecurityContext = SECURITY_SUBJECT_CONTEXT()
        self.SecurityDescriptor = v_ptr32()
        self.AuxData = v_ptr32()
        self.Privileges = _unnamed_14065()
        self.AuditPrivileges = v_uint8()
        self._pad0064 = v_bytes(size=3)
        self.ObjectName = UNICODE_STRING()
        self.ObjectTypeName = UNICODE_STRING()


class FILE_STANDARD_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.NumberOfLinks = v_uint32()
        self.DeletePending = v_uint8()
        self.Directory = v_uint8()
        self._pad0018 = v_bytes(size=2)


class EX_PUSH_LOCK_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locks = vstruct.VArray([ v_ptr32() for i in xrange(1) ])


class POOL_BLOCK_HEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = POOL_HEADER()
        self.List = LIST_ENTRY()


class DBGKD_SET_SPECIAL_CALL32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SpecialCall = v_uint32()


class SYSTEM_POWER_LEVEL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Enable = v_uint8()
        self.Spare = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.BatteryLevel = v_uint32()
        self.PowerPolicy = POWER_ACTION_POLICY()
        self.MinSystemState = v_uint32()


class DBGKD_LOAD_SYMBOLS32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PathNameLength = v_uint32()
        self.BaseOfDll = v_uint32()
        self.ProcessId = v_uint32()
        self.CheckSum = v_uint32()
        self.SizeOfImage = v_uint32()
        self.UnloadSymbols = v_uint8()
        self._pad0018 = v_bytes(size=3)


class DBGKM_EXCEPTION32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionRecord = EXCEPTION_RECORD32()
        self.FirstChance = v_uint32()


class PAGEFAULT_HISTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CurrentIndex = v_uint32()
        self.MaxIndex = v_uint32()
        self.SpinLock = v_uint32()
        self.Reserved = v_ptr32()
        self.WatchInfo = vstruct.VArray([ PROCESS_WS_WATCH_INFORMATION() for i in xrange(1) ])


class _unnamed_16107(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FsInformationClass = v_uint32()


class WNODE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BufferSize = v_uint32()
        self.ProviderId = v_uint32()
        self.HistoricalContext = v_uint64()
        self.CountLost = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Guid = GUID()
        self.ClientContext = v_uint32()
        self.Flags = v_uint32()


class PROCESS_WS_WATCH_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FaultingPc = v_ptr32()
        self.FaultingVa = v_ptr32()


class SECTION_OBJECT_POINTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSectionObject = v_ptr32()
        self.SharedCacheMap = v_ptr32()
        self.ImageSectionObject = v_ptr32()


class MDL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Size = v_uint16()
        self.MdlFlags = v_uint16()
        self.Process = v_ptr32()
        self.MappedSystemVa = v_ptr32()
        self.StartVa = v_ptr32()
        self.ByteCount = v_uint32()
        self.ByteOffset = v_uint32()


class KTRAP_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DbgEbp = v_uint32()
        self.DbgEip = v_uint32()
        self.DbgArgMark = v_uint32()
        self.DbgArgPointer = v_uint32()
        self.TempSegCs = v_uint32()
        self.TempEsp = v_uint32()
        self.Dr0 = v_uint32()
        self.Dr1 = v_uint32()
        self.Dr2 = v_uint32()
        self.Dr3 = v_uint32()
        self.Dr6 = v_uint32()
        self.Dr7 = v_uint32()
        self.SegGs = v_uint32()
        self.SegEs = v_uint32()
        self.SegDs = v_uint32()
        self.Edx = v_uint32()
        self.Ecx = v_uint32()
        self.Eax = v_uint32()
        self.PreviousPreviousMode = v_uint32()
        self.ExceptionList = v_ptr32()
        self.SegFs = v_uint32()
        self.Edi = v_uint32()
        self.Esi = v_uint32()
        self.Ebx = v_uint32()
        self.Ebp = v_uint32()
        self.ErrCode = v_uint32()
        self.Eip = v_uint32()
        self.SegCs = v_uint32()
        self.EFlags = v_uint32()
        self.HardwareEsp = v_uint32()
        self.HardwareSegSs = v_uint32()
        self.V86Es = v_uint32()
        self.V86Ds = v_uint32()
        self.V86Fs = v_uint32()
        self.V86Gs = v_uint32()


class CM_INDEX_HINT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.HashKey = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class SEP_AUDIT_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PolicyElements = SEP_AUDIT_POLICY_CATEGORIES()


class MMPTE_SOFTWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class IO_TIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.TimerFlag = v_uint16()
        self.TimerList = LIST_ENTRY()
        self.TimerRoutine = v_ptr32()
        self.Context = v_ptr32()
        self.DeviceObject = v_ptr32()


class Wx86ThreadState(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CallBx86Eip = v_ptr32()
        self.DeallocationCpu = v_ptr32()
        self.UseKnownWx86Dll = v_uint8()
        self.OleStubInvoked = v_uint8()
        self._pad000c = v_bytes(size=2)


class _unnamed_12112(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FreeListsInUseTerminate = v_uint16()


class _unnamed_12111(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FreeListsInUseUlong = vstruct.VArray([ v_uint32() for i in xrange(4) ])


class _unnamed_16218(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceTextType = v_uint32()
        self.LocaleId = v_uint32()


class MM_SESSION_SPACE_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Initialized = v_uint32()


class _unnamed_14629(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.type0 = PCI_HEADER_TYPE_0()


class EVENT_COUNTER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = SINGLE_LIST_ENTRY()
        self.RefCount = v_uint32()
        self.Event = KEVENT()


class SECURITY_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.Sbz1 = v_uint8()
        self.Control = v_uint16()
        self.Owner = v_ptr32()
        self.Group = v_ptr32()
        self.Sacl = v_ptr32()
        self.Dacl = v_ptr32()


class SECURITY_TOKEN_AUDIT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.GrantMask = v_uint32()
        self.DenyMask = v_uint32()


class EX_WORK_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkerQueue = KQUEUE()
        self.DynamicThreadCount = v_uint32()
        self.WorkItemsProcessed = v_uint32()
        self.WorkItemsProcessedLastPass = v_uint32()
        self.QueueDepthLastPass = v_uint32()
        self.Info = EX_QUEUE_WORKER_INFO()


class OBJECT_TYPE_INITIALIZER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.UseDefaultObject = v_uint8()
        self.CaseInsensitive = v_uint8()
        self.InvalidAttributes = v_uint32()
        self.GenericMapping = GENERIC_MAPPING()
        self.ValidAccessMask = v_uint32()
        self.SecurityRequired = v_uint8()
        self.MaintainHandleCount = v_uint8()
        self.MaintainTypeList = v_uint8()
        self._pad0020 = v_bytes(size=1)
        self.PoolType = v_uint32()
        self.DefaultPagedPoolCharge = v_uint32()
        self.DefaultNonPagedPoolCharge = v_uint32()
        self.DumpProcedure = v_ptr32()
        self.OpenProcedure = v_ptr32()
        self.CloseProcedure = v_ptr32()
        self.DeleteProcedure = v_ptr32()
        self.ParseProcedure = v_ptr32()
        self.SecurityProcedure = v_ptr32()
        self.QueryNameProcedure = v_ptr32()
        self.OkayToCloseProcedure = v_ptr32()


class VACB_LEVEL_REFERENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reference = v_uint32()
        self.SpecialReference = v_uint32()


class _unnamed_16627(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceIds = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class HEAP_ENTRY_EXTRA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatorBackTraceIndex = v_uint16()
        self.TagIndex = v_uint16()
        self.Settable = v_uint32()


class POP_DEVICE_SYS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IrpMinor = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.SystemState = v_uint32()
        self.Event = KEVENT()
        self.SpinLock = v_uint32()
        self.Thread = v_ptr32()
        self.GetNewDeviceList = v_uint8()
        self._pad0024 = v_bytes(size=3)
        self.Order = PO_DEVICE_NOTIFY_ORDER()
        self.Status = v_uint32()
        self.FailedDevice = v_ptr32()
        self.Waking = v_uint8()
        self.Cancelled = v_uint8()
        self.IgnoreErrors = v_uint8()
        self.IgnoreNotImplemented = v_uint8()
        self.WaitAny = v_uint8()
        self.WaitAll = v_uint8()
        self._pad027c = v_bytes(size=2)
        self.PresentIrpQueue = LIST_ENTRY()
        self.Head = POP_DEVICE_POWER_IRP()
        self.PowerIrpState = vstruct.VArray([ POP_DEVICE_POWER_IRP() for i in xrange(20) ])


class VI_DEADLOCK_RESOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.NodeCount = v_uint32()
        self.ResourceAddress = v_ptr32()
        self.ThreadOwner = v_ptr32()
        self.ResourceList = LIST_ENTRY()
        self.HashChainList = LIST_ENTRY()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(8) ])
        self.LastAcquireTrace = vstruct.VArray([ v_ptr32() for i in xrange(8) ])
        self.LastReleaseTrace = vstruct.VArray([ v_ptr32() for i in xrange(8) ])


class HEAP_PSEUDO_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint32()


class _unnamed_13834(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Generic = _unnamed_14637()


class CM_KEY_REFERENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.KeyCell = v_uint32()
        self.KeyHive = v_ptr32()


class MMSECTION_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BeingDeleted = v_uint32()


class IA64_DBGKD_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Continue = v_uint32()
        self.CurrentSymbolStart = v_uint64()
        self.CurrentSymbolEnd = v_uint64()


class DBGKD_GET_INTERNAL_BREAKPOINT64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakpointAddress = v_uint64()
        self.Flags = v_uint32()
        self.Calls = v_uint32()
        self.MaxCallsPerPeriod = v_uint32()
        self.MinInstructions = v_uint32()
        self.MaxInstructions = v_uint32()
        self.TotalInstructions = v_uint32()


class PROCESSOR_POWER_POLICY_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TimeCheck = v_uint32()
        self.DemoteLimit = v_uint32()
        self.PromoteLimit = v_uint32()
        self.DemotePercent = v_uint8()
        self.PromotePercent = v_uint8()
        self.Spare = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.AllowDemotion = v_uint32()


class _unnamed_16213(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdType = v_uint32()


class POP_POWER_ACTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Updates = v_uint8()
        self.State = v_uint8()
        self.Shutdown = v_uint8()
        self._pad0004 = v_bytes(size=1)
        self.Action = v_uint32()
        self.LightestState = v_uint32()
        self.Flags = v_uint32()
        self.Status = v_uint32()
        self.IrpMinor = v_uint8()
        self._pad0018 = v_bytes(size=3)
        self.SystemState = v_uint32()
        self.NextSystemState = v_uint32()
        self.ShutdownBugCode = v_ptr32()
        self.DevState = v_ptr32()
        self.HiberContext = v_ptr32()
        self.LastWakeState = v_uint32()
        self.WakeTime = v_uint64()
        self.SleepTime = v_uint64()


class OBJECT_CREATE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Attributes = v_uint32()
        self.RootDirectory = v_ptr32()
        self.ParseContext = v_ptr32()
        self.ProbeMode = v_uint8()
        self._pad0010 = v_bytes(size=3)
        self.PagedPoolCharge = v_uint32()
        self.NonPagedPoolCharge = v_uint32()
        self.SecurityDescriptorCharge = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.SecurityQos = v_ptr32()
        self.SecurityQualityOfService = SECURITY_QUALITY_OF_SERVICE()


class OBJECT_HEADER_CREATOR_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TypeList = LIST_ENTRY()
        self.CreatorUniqueProcess = v_ptr32()
        self.CreatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()


class PAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = FAST_MUTEX()
        self._pad0100 = v_bytes(size=96)


class HEAP_STOP_ON_TAG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HeapAndTagIndex = v_uint32()


class PO_NOTIFY_ORDER_LEVEL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LevelReady = KEVENT()
        self.DeviceCount = v_uint32()
        self.ActiveCount = v_uint32()
        self.WaitSleep = LIST_ENTRY()
        self.ReadySleep = LIST_ENTRY()
        self.Pending = LIST_ENTRY()
        self.Complete = LIST_ENTRY()
        self.ReadyS0 = LIST_ENTRY()
        self.WaitS0 = LIST_ENTRY()


class RTL_BITMAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfBitMap = v_uint32()
        self.Buffer = v_ptr32()


class LARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class _unnamed_12162(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CriticalSection = RTL_CRITICAL_SECTION()
        self._pad0038 = v_bytes(size=32)


class NPAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = v_uint32()
        self._pad0100 = v_bytes(size=124)


class _unnamed_11794(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReadMemory = DBGKD_READ_MEMORY64()
        self._pad0028 = v_bytes(size=24)


class KLOCK_QUEUE_HANDLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LockQueue = KSPIN_LOCK_QUEUE()
        self.OldIrql = v_uint8()
        self._pad000c = v_bytes(size=3)


class VPB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.Flags = v_uint16()
        self.VolumeLabelLength = v_uint16()
        self.DeviceObject = v_ptr32()
        self.RealDevice = v_ptr32()
        self.SerialNumber = v_uint32()
        self.ReferenceCount = v_uint32()
        self.VolumeLabel = vstruct.VArray([ v_uint16() for i in xrange(32) ])


class SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlArea = v_ptr32()
        self.TotalNumberOfPtes = v_uint32()
        self.NonExtendedPtes = v_uint32()
        self.WritableUserReferences = v_uint32()
        self.SizeOfSegment = v_uint64()
        self.SegmentPteTemplate = MMPTE()
        self.NumberOfCommittedPages = v_uint32()
        self.ExtendInfo = v_ptr32()
        self.SystemImageBase = v_ptr32()
        self.BasedAddress = v_ptr32()
        self.u1 = _unnamed_12605()
        self.u2 = _unnamed_12606()
        self.PrototypePte = v_ptr32()
        self.ThePtes = vstruct.VArray([ MMPTE() for i in xrange(1) ])
        self._pad0040 = v_bytes(size=4)


class _unnamed_15247(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TestAllocation = _unnamed_16554()
        self._pad0010 = v_bytes(size=4)


class PP_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P = v_ptr32()
        self.L = v_ptr32()


class OBJECT_NAME_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = UNICODE_STRING()


class IO_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.Descriptors = vstruct.VArray([ IO_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class _unnamed_16445(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PageNo = v_uint32()
        self.StartPage = v_uint32()
        self.EndPage = v_uint32()
        self.CheckSum = v_uint32()


class _unnamed_16446(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.NextTable = v_uint32()
        self.CheckSum = v_uint32()
        self.EntryCount = v_uint32()


class PRIVATE_CACHE_MAP_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DontUse = v_uint32()


class FS_FILTER_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AcquireForModifiedPageWriter = _unnamed_16779()
        self._pad0014 = v_bytes(size=12)


class HEAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.Signature = v_uint32()
        self.Flags = v_uint32()
        self.ForceFlags = v_uint32()
        self.VirtualMemoryThreshold = v_uint32()
        self.SegmentReserve = v_uint32()
        self.SegmentCommit = v_uint32()
        self.DeCommitFreeBlockThreshold = v_uint32()
        self.DeCommitTotalFreeThreshold = v_uint32()
        self.TotalFreeSize = v_uint32()
        self.MaximumAllocationSize = v_uint32()
        self.ProcessHeapsListIndex = v_uint16()
        self.HeaderValidateLength = v_uint16()
        self.HeaderValidateCopy = v_ptr32()
        self.NextAvailableTagIndex = v_uint16()
        self.MaximumTagIndex = v_uint16()
        self.TagEntries = v_ptr32()
        self.UCRSegments = v_ptr32()
        self.UnusedUnCommittedRanges = v_ptr32()
        self.AlignRound = v_uint32()
        self.AlignMask = v_uint32()
        self.VirtualAllocdBlocks = LIST_ENTRY()
        self.Segments = vstruct.VArray([ v_ptr32() for i in xrange(64) ])
        self.u = _unnamed_12111()
        self.u2 = _unnamed_12112()
        self.AllocatorBackTraceIndex = v_uint16()
        self.NonDedicatedListLength = v_uint32()
        self.LargeBlocksIndex = v_ptr32()
        self.PseudoTagEntries = v_ptr32()
        self.FreeLists = vstruct.VArray([ LIST_ENTRY() for i in xrange(128) ])
        self.LockVariable = v_ptr32()
        self.CommitRoutine = v_ptr32()
        self.FrontEndHeap = v_ptr32()
        self.FrontHeapLockCount = v_uint16()
        self.FrontEndHeapType = v_uint8()
        self.LastSegmentIndex = v_uint8()


class HANDLE_TRACE_DEBUG_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CurrentStackIndex = v_uint32()
        self.TraceDb = vstruct.VArray([ HANDLE_TRACE_DB_ENTRY() for i in xrange(4096) ])


class PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(1) ])


class CM_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.List = vstruct.VArray([ CM_FULL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class EPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pcb = KPROCESS()
        self.ProcessLock = EX_PUSH_LOCK()
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.UniqueProcessId = v_ptr32()
        self.ActiveProcessLinks = LIST_ENTRY()
        self.QuotaUsage = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.QuotaPeak = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.CommitCharge = v_uint32()
        self.PeakVirtualSize = v_uint32()
        self.VirtualSize = v_uint32()
        self.SessionProcessLinks = LIST_ENTRY()
        self.DebugPort = v_ptr32()
        self.ExceptionPort = v_ptr32()
        self.ObjectTable = v_ptr32()
        self.Token = EX_FAST_REF()
        self.WorkingSetLock = FAST_MUTEX()
        self.WorkingSetPage = v_uint32()
        self.AddressCreationLock = FAST_MUTEX()
        self.HyperSpaceLock = v_uint32()
        self.ForkInProgress = v_ptr32()
        self.HardwareTrigger = v_uint32()
        self.VadRoot = v_ptr32()
        self.VadHint = v_ptr32()
        self.CloneRoot = v_ptr32()
        self.NumberOfPrivatePages = v_uint32()
        self.NumberOfLockedPages = v_uint32()
        self.Win32Process = v_ptr32()
        self.Job = v_ptr32()
        self.SectionObject = v_ptr32()
        self.SectionBaseAddress = v_ptr32()
        self.QuotaBlock = v_ptr32()
        self.WorkingSetWatch = v_ptr32()
        self.Win32WindowStation = v_ptr32()
        self.InheritedFromUniqueProcessId = v_ptr32()
        self.LdtInformation = v_ptr32()
        self.VadFreeHint = v_ptr32()
        self.VdmObjects = v_ptr32()
        self.DeviceMap = v_ptr32()
        self.PhysicalVadList = LIST_ENTRY()
        self.PageDirectoryPte = HARDWARE_PTE()
        self._pad0170 = v_bytes(size=4)
        self.Session = v_ptr32()
        self.ImageFileName = vstruct.VArray([ v_uint8() for i in xrange(16) ])
        self.JobLinks = LIST_ENTRY()
        self.LockedPagesList = v_ptr32()
        self.ThreadListHead = LIST_ENTRY()
        self.SecurityPort = v_ptr32()
        self.PaeTop = v_ptr32()
        self.ActiveThreads = v_uint32()
        self.GrantedAccess = v_uint32()
        self.DefaultHardErrorProcessing = v_uint32()
        self.LastThreadExitStatus = v_uint32()
        self.Peb = v_ptr32()
        self.PrefetchTrace = EX_FAST_REF()
        self.ReadOperationCount = LARGE_INTEGER()
        self.WriteOperationCount = LARGE_INTEGER()
        self.OtherOperationCount = LARGE_INTEGER()
        self.ReadTransferCount = LARGE_INTEGER()
        self.WriteTransferCount = LARGE_INTEGER()
        self.OtherTransferCount = LARGE_INTEGER()
        self.CommitChargeLimit = v_uint32()
        self.CommitChargePeak = v_uint32()
        self.AweInfo = v_ptr32()
        self.SeAuditProcessCreationInfo = SE_AUDIT_PROCESS_CREATION_INFO()
        self.Vm = MMSUPPORT()
        self.LastFaultCount = v_uint32()
        self.ModifiedPageCount = v_uint32()
        self.NumberOfVads = v_uint32()
        self.JobStatus = v_uint32()
        self.Flags = v_uint32()
        self.ExitStatus = v_uint32()
        self.NextPageColor = v_uint16()
        self.SubSystemMinorVersion = v_uint8()
        self.SubSystemMajorVersion = v_uint8()
        self.PriorityClass = v_uint8()
        self.WorkingSetAcquiredUnsafe = v_uint8()
        self._pad0258 = v_bytes(size=2)
        self.Cookie = v_uint32()
        self._pad0260 = v_bytes(size=4)


class PHYSICAL_MEMORY_RUN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BasePage = v_uint32()
        self.PageCount = v_uint32()


class CM_KEY_BODY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.KeyControlBlock = v_ptr32()
        self.NotifyBlock = v_ptr32()
        self.ProcessID = v_ptr32()
        self.Callers = v_uint32()
        self.CallerAddress = vstruct.VArray([ v_ptr32() for i in xrange(10) ])
        self.KeyBodyList = LIST_ENTRY()


class KMUTANT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.MutantListEntry = LIST_ENTRY()
        self.OwnerThread = v_ptr32()
        self.Abandoned = v_uint8()
        self.ApcDisable = v_uint8()
        self._pad0020 = v_bytes(size=2)


class FX_SAVE_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.U = _unnamed_10880()
        self.NpxSavedCpu = v_uint32()
        self.Cr0NpxState = v_uint32()


class POWER_SEQUENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SequenceD1 = v_uint32()
        self.SequenceD2 = v_uint32()
        self.SequenceD3 = v_uint32()


class KTIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.DueTime = ULARGE_INTEGER()
        self.TimerListEntry = LIST_ENTRY()
        self.Dpc = v_ptr32()
        self.Period = v_uint32()


class MM_PAGED_POOL_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PagedPoolAllocationMap = v_ptr32()
        self.EndOfPagedPoolBitmap = v_ptr32()
        self.PagedPoolLargeSessionAllocationMap = v_ptr32()
        self.FirstPteForPagedPool = v_ptr32()
        self.LastPteForPagedPool = v_ptr32()
        self.NextPdeForPagedPoolExpansion = v_ptr32()
        self.PagedPoolHint = v_uint32()
        self.PagedPoolCommit = v_uint32()
        self.AllocatedPagedPool = v_uint32()


class HIVE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = v_ptr32()
        self.BaseName = v_ptr32()
        self.CmHive = v_ptr32()
        self.Flags = v_uint32()
        self.CmHive2 = v_ptr32()
        self.ThreadFinished = v_uint8()
        self.ThreadStarted = v_uint8()
        self.Allocate = v_uint8()
        self._pad0018 = v_bytes(size=1)


class CM_PARTIAL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Flags = v_uint16()
        self.u = _unnamed_13834()


class RTLP_RANGE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint64()
        self.End = v_uint64()
        self.Allocated = _unnamed_14486()
        self.Attributes = v_uint8()
        self.PublicFlags = v_uint8()
        self.PrivateFlags = v_uint16()
        self.ListEntry = LIST_ENTRY()
        self._pad0028 = v_bytes(size=4)


class _unnamed_14765(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.Thread = v_ptr32()
        self.AuxiliaryBuffer = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.CurrentStackLocation = v_ptr32()
        self.OriginalFileObject = v_ptr32()


class _unnamed_14762(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Create = _unnamed_15988()


class _unnamed_13383(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CellData = CELL_DATA()


class MMVAD_LONG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartingVpn = v_uint32()
        self.EndingVpn = v_uint32()
        self.Parent = v_ptr32()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.u = _unnamed_14102()
        self.ControlArea = v_ptr32()
        self.FirstPrototypePte = v_ptr32()
        self.LastContiguousPte = v_ptr32()
        self.u2 = _unnamed_14103()
        self.u3 = _unnamed_14104()
        self.u4 = _unnamed_14105()


class CM_VIEW_OF_FILE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LRUViewList = LIST_ENTRY()
        self.PinViewList = LIST_ENTRY()
        self.FileOffset = v_uint32()
        self.Size = v_uint32()
        self.ViewAddress = v_ptr32()
        self.Bcb = v_ptr32()
        self.UseCount = v_uint32()


class _unnamed_16143(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.StartSid = v_ptr32()
        self.SidList = v_ptr32()
        self.SidListLength = v_uint32()


class CM_FULL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.PartialResourceList = CM_PARTIAL_RESOURCE_LIST()


class DBGKD_WRITE_MEMORY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TargetBaseAddress = v_uint64()
        self.TransferCount = v_uint32()
        self.ActualBytesWritten = v_uint32()


class DBGKD_GET_VERSION64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.ProtocolVersion = v_uint16()
        self.Flags = v_uint16()
        self.MachineType = v_uint16()
        self.MaxPacketType = v_uint8()
        self.MaxStateChange = v_uint8()
        self.MaxManipulate = v_uint8()
        self.Simulation = v_uint8()
        self.Unused = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self.KernBase = v_uint64()
        self.PsLoadedModuleList = v_uint64()
        self.DebuggerDataList = v_uint64()


class _unnamed_16069(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileName = v_ptr32()
        self.FileInformationClass = v_uint32()
        self.FileIndex = v_uint32()


class FAST_IO_DISPATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFastIoDispatch = v_uint32()
        self.FastIoCheckIfPossible = v_ptr32()
        self.FastIoRead = v_ptr32()
        self.FastIoWrite = v_ptr32()
        self.FastIoQueryBasicInfo = v_ptr32()
        self.FastIoQueryStandardInfo = v_ptr32()
        self.FastIoLock = v_ptr32()
        self.FastIoUnlockSingle = v_ptr32()
        self.FastIoUnlockAll = v_ptr32()
        self.FastIoUnlockAllByKey = v_ptr32()
        self.FastIoDeviceControl = v_ptr32()
        self.AcquireFileForNtCreateSection = v_ptr32()
        self.ReleaseFileForNtCreateSection = v_ptr32()
        self.FastIoDetachDevice = v_ptr32()
        self.FastIoQueryNetworkOpenInfo = v_ptr32()
        self.AcquireForModWrite = v_ptr32()
        self.MdlRead = v_ptr32()
        self.MdlReadComplete = v_ptr32()
        self.PrepareMdlWrite = v_ptr32()
        self.MdlWriteComplete = v_ptr32()
        self.FastIoReadCompressed = v_ptr32()
        self.FastIoWriteCompressed = v_ptr32()
        self.MdlReadCompleteCompressed = v_ptr32()
        self.MdlWriteCompleteCompressed = v_ptr32()
        self.FastIoQueryOpen = v_ptr32()
        self.ReleaseForModWrite = v_ptr32()
        self.AcquireForCcFlush = v_ptr32()
        self.ReleaseForCcFlush = v_ptr32()


class CM_KEY_CONTROL_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RefCount = v_uint32()
        self.ExtFlags = v_uint32()
        self.KeyHash = CM_KEY_HASH()
        self.ParentKcb = v_ptr32()
        self.NameBlock = v_ptr32()
        self.CachedSecurity = v_ptr32()
        self.ValueCache = CACHED_CHILD_LIST()
        self.IndexHint = v_ptr32()
        self.KeyBodyListHead = LIST_ENTRY()
        self.KcbLastWriteTime = LARGE_INTEGER()
        self.KcbMaxNameLen = v_uint16()
        self.KcbMaxValueNameLen = v_uint16()
        self.KcbMaxValueDataLen = v_uint32()
        self.KcbUserFlags = v_uint32()
        self._pad0050 = v_bytes(size=4)


class MMVAD_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CommitCharge = v_uint32()


class MMWSL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Quota = v_uint32()
        self.FirstFree = v_uint32()
        self.FirstDynamic = v_uint32()
        self.LastEntry = v_uint32()
        self.NextSlot = v_uint32()
        self.Wsle = v_ptr32()
        self.LastInitializedWsle = v_uint32()
        self.NonDirectCount = v_uint32()
        self.HashTable = v_ptr32()
        self.HashTableSize = v_uint32()
        self.NumberOfCommittedPageTables = v_uint32()
        self.HashTableStart = v_ptr32()
        self.HighestPermittedHashAddress = v_ptr32()
        self.NumberOfImageWaiters = v_uint32()
        self.VadBitMapHint = v_uint32()
        self.UsedPageTableEntries = vstruct.VArray([ v_uint16() for i in xrange(768) ])
        self.CommittedPageTables = vstruct.VArray([ v_uint32() for i in xrange(24) ])


class DBGKD_CONTINUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContinueStatus = v_uint32()


class _unnamed_14102(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags = v_uint32()


class _unnamed_14103(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags2 = v_uint32()


class SUPPORTED_RANGES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Sorted = v_uint8()
        self.Reserved = v_uint8()
        self.NoIO = v_uint32()
        self.IO = SUPPORTED_RANGE()
        self.NoMemory = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.Memory = SUPPORTED_RANGE()
        self.NoPrefetchMemory = v_uint32()
        self._pad0058 = v_bytes(size=4)
        self.PrefetchMemory = SUPPORTED_RANGE()
        self.NoDma = v_uint32()
        self._pad0080 = v_bytes(size=4)
        self.Dma = SUPPORTED_RANGE()


class WORK_QUEUE_ITEM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.List = LIST_ENTRY()
        self.WorkerRoutine = v_ptr32()
        self.Parameter = v_ptr32()


class _unnamed_14104(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.List = LIST_ENTRY()


class _unnamed_14105(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Banked = v_ptr32()


class EPROCESS_QUOTA_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Usage = v_uint32()
        self.Limit = v_uint32()
        self.Peak = v_uint32()
        self.Return = v_uint32()


class KSPECIAL_REGISTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cr0 = v_uint32()
        self.Cr2 = v_uint32()
        self.Cr3 = v_uint32()
        self.Cr4 = v_uint32()
        self.KernelDr0 = v_uint32()
        self.KernelDr1 = v_uint32()
        self.KernelDr2 = v_uint32()
        self.KernelDr3 = v_uint32()
        self.KernelDr6 = v_uint32()
        self.KernelDr7 = v_uint32()
        self.Gdtr = DESCRIPTOR()
        self.Idtr = DESCRIPTOR()
        self.Tr = v_uint16()
        self.Ldtr = v_uint16()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(6) ])


class KINTERRUPT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.InterruptListEntry = LIST_ENTRY()
        self.ServiceRoutine = v_ptr32()
        self.ServiceContext = v_ptr32()
        self.SpinLock = v_uint32()
        self.TickCount = v_uint32()
        self.ActualLock = v_ptr32()
        self.DispatchAddress = v_ptr32()
        self.Vector = v_uint32()
        self.Irql = v_uint8()
        self.SynchronizeIrql = v_uint8()
        self.FloatingSave = v_uint8()
        self.Connected = v_uint8()
        self.Number = v_uint8()
        self.ShareVector = v_uint8()
        self._pad0030 = v_bytes(size=2)
        self.Mode = v_uint32()
        self.ServiceCount = v_uint32()
        self.DispatchCount = v_uint32()
        self.DispatchCode = vstruct.VArray([ v_uint32() for i in xrange(106) ])


class RTL_CRITICAL_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DebugInfo = v_ptr32()
        self.LockCount = v_uint32()
        self.RecursionCount = v_uint32()
        self.OwningThread = v_ptr32()
        self.LockSemaphore = v_ptr32()
        self.SpinCount = v_uint32()


class _unnamed_16782(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr32()
        self.Argument2 = v_ptr32()
        self.Argument3 = v_ptr32()
        self.Argument4 = v_ptr32()
        self.Argument5 = v_ptr32()


class _unnamed_16780(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ResourceToRelease = v_ptr32()


class _unnamed_16781(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SyncType = v_uint32()
        self.PageProtection = v_uint32()


class KSYSTEM_TIME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.High1Time = v_uint32()
        self.High2Time = v_uint32()


class PO_DEVICE_NOTIFY_ORDER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DevNodeSequence = v_uint32()
        self.WarmEjectPdoPointer = v_ptr32()
        self.OrderLevel = vstruct.VArray([ PO_NOTIFY_ORDER_LEVEL() for i in xrange(8) ])


class _unnamed_11882(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReadMemory = DBGKD_READ_MEMORY32()
        self._pad0028 = v_bytes(size=28)


class FLOATING_SAVE_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint32()
        self.StatusWord = v_uint32()
        self.TagWord = v_uint32()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint32()
        self.RegisterArea = vstruct.VArray([ v_uint8() for i in xrange(80) ])
        self.Cr0NpxState = v_uint32()


class WMI_LOGGER_MODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SequentialFile = v_uint32()


class KQUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.EntryListHead = LIST_ENTRY()
        self.CurrentCount = v_uint32()
        self.MaximumCount = v_uint32()
        self.ThreadListHead = LIST_ENTRY()


class POOL_TRACKER_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Key = v_uint32()
        self.NonPagedAllocs = v_uint32()
        self.NonPagedFrees = v_uint32()
        self.NonPagedBytes = v_uint32()
        self.PagedAllocs = v_uint32()
        self.PagedFrees = v_uint32()
        self.PagedBytes = v_uint32()


class _unnamed_16666(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DiskId = GUID()


class WMI_BUFFER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Free = v_uint32()


class LUID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Luid = LUID()
        self.Attributes = v_uint32()


class _unnamed_15560(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Base = v_uint32()
        self.Limit = v_uint32()


class MMMOD_WRITER_MDL_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Links = LIST_ENTRY()
        self.WriteOffset = LARGE_INTEGER()
        self.u = _unnamed_15130()
        self.Irp = v_ptr32()
        self.LastPageToWrite = v_uint32()
        self.PagingListHead = v_ptr32()
        self.CurrentList = v_ptr32()
        self.PagingFile = v_ptr32()
        self.File = v_ptr32()
        self.ControlArea = v_ptr32()
        self.FileResource = v_ptr32()
        self.Mdl = MDL()
        self.Page = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class CACHED_CHILD_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.ValueList = v_uint32()


class KTHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.MutantListHead = LIST_ENTRY()
        self.InitialStack = v_ptr32()
        self.StackLimit = v_ptr32()
        self.Teb = v_ptr32()
        self.TlsArray = v_ptr32()
        self.KernelStack = v_ptr32()
        self.DebugActive = v_uint8()
        self.State = v_uint8()
        self.Alerted = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.Iopl = v_uint8()
        self.NpxState = v_uint8()
        self.Saturation = v_uint8()
        self.Priority = v_uint8()
        self.ApcState = KAPC_STATE()
        self.ContextSwitches = v_uint32()
        self.IdleSwapBlock = v_uint8()
        self.Spare0 = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.WaitStatus = v_uint32()
        self.WaitIrql = v_uint8()
        self.WaitMode = v_uint8()
        self.WaitNext = v_uint8()
        self.WaitReason = v_uint8()
        self.WaitBlockList = v_ptr32()
        self.WaitListEntry = LIST_ENTRY()
        self.WaitTime = v_uint32()
        self.BasePriority = v_uint8()
        self.DecrementCount = v_uint8()
        self.PriorityDecrement = v_uint8()
        self.Quantum = v_uint8()
        self.WaitBlock = vstruct.VArray([ KWAIT_BLOCK() for i in xrange(4) ])
        self.LegoData = v_ptr32()
        self.KernelApcDisable = v_uint32()
        self.UserAffinity = v_uint32()
        self.SystemAffinityActive = v_uint8()
        self.PowerState = v_uint8()
        self.NpxIrql = v_uint8()
        self.InitialNode = v_uint8()
        self.ServiceTable = v_ptr32()
        self.Queue = v_ptr32()
        self.ApcQueueLock = v_uint32()
        self._pad00f0 = v_bytes(size=4)
        self.Timer = KTIMER()
        self.QueueListEntry = LIST_ENTRY()
        self.SoftAffinity = v_uint32()
        self.Affinity = v_uint32()
        self.Preempted = v_uint8()
        self.ProcessReadyQueue = v_uint8()
        self.KernelStackResident = v_uint8()
        self.NextProcessor = v_uint8()
        self.CallbackStack = v_ptr32()
        self.Win32Thread = v_ptr32()
        self.TrapFrame = v_ptr32()
        self.ApcStatePointer = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self.PreviousMode = v_uint8()
        self.EnableStackSwap = v_uint8()
        self.LargeStack = v_uint8()
        self.ResourceIndex = v_uint8()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.SavedApcState = KAPC_STATE()
        self.Alertable = v_uint8()
        self.ApcStateIndex = v_uint8()
        self.ApcQueueable = v_uint8()
        self.AutoAlignment = v_uint8()
        self.StackBase = v_ptr32()
        self.SuspendApc = KAPC()
        self.SuspendSemaphore = KSEMAPHORE()
        self.ThreadListEntry = LIST_ENTRY()
        self.FreezeCount = v_uint8()
        self.SuspendCount = v_uint8()
        self.IdealProcessor = v_uint8()
        self.DisableBoost = v_uint8()
        self._pad01c0 = v_bytes(size=4)


class _unnamed_12531(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags = v_uint32()


class ADAPTER_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_10508(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFlags = v_uint32()
        self.Dr0 = v_uint32()
        self.Dr1 = v_uint32()
        self.Dr2 = v_uint32()
        self.Dr3 = v_uint32()
        self.Dr6 = v_uint32()
        self.Dr7 = v_uint32()
        self.FloatSave = FLOATING_SAVE_AREA()
        self.SegGs = v_uint32()
        self.SegFs = v_uint32()
        self.SegEs = v_uint32()
        self.SegDs = v_uint32()
        self.Edi = v_uint32()
        self.Esi = v_uint32()
        self.Ebx = v_uint32()
        self.Edx = v_uint32()
        self.Ecx = v_uint32()
        self.Eax = v_uint32()
        self.Ebp = v_uint32()
        self.Eip = v_uint32()
        self.SegCs = v_uint32()
        self.EFlags = v_uint32()
        self.Esp = v_uint32()
        self.SegSs = v_uint32()
        self.ExtendedRegisters = vstruct.VArray([ v_uint8() for i in xrange(512) ])


class DBGKD_GET_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Unused = v_uint32()


class GENERIC_MAPPING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GenericRead = v_uint32()
        self.GenericWrite = v_uint32()
        self.GenericExecute = v_uint32()
        self.GenericAll = v_uint32()


class DEVICE_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Sibling = v_ptr32()
        self.Child = v_ptr32()
        self.Parent = v_ptr32()
        self.LastChild = v_ptr32()
        self.Level = v_uint32()
        self.Notify = v_ptr32()
        self.State = v_uint32()
        self.PreviousState = v_uint32()
        self.StateHistory = vstruct.VArray([ PNP_DEVNODE_STATE() for i in xrange(20) ])
        self.StateHistoryEntry = v_uint32()
        self.CompletionStatus = v_uint32()
        self.PendingIrp = v_ptr32()
        self.Flags = v_uint32()
        self.UserFlags = v_uint32()
        self.Problem = v_uint32()
        self.PhysicalDeviceObject = v_ptr32()
        self.ResourceList = v_ptr32()
        self.ResourceListTranslated = v_ptr32()
        self.InstancePath = UNICODE_STRING()
        self.ServiceName = UNICODE_STRING()
        self.DuplicatePDO = v_ptr32()
        self.ResourceRequirements = v_ptr32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.ChildInterfaceType = v_uint32()
        self.ChildBusNumber = v_uint32()
        self.ChildBusTypeIndex = v_uint16()
        self.RemovalPolicy = v_uint8()
        self.HardwareRemovalPolicy = v_uint8()
        self.TargetDeviceNotify = LIST_ENTRY()
        self.DeviceArbiterList = LIST_ENTRY()
        self.DeviceTranslatorList = LIST_ENTRY()
        self.NoTranslatorMask = v_uint16()
        self.QueryTranslatorMask = v_uint16()
        self.NoArbiterMask = v_uint16()
        self.QueryArbiterMask = v_uint16()
        self.OverUsed1 = _unnamed_12916()
        self.OverUsed2 = _unnamed_12917()
        self.BootResources = v_ptr32()
        self.CapabilityFlags = v_uint32()
        self.DockInfo = _unnamed_12918()
        self.DisableableDepends = v_uint32()
        self.PendedSetInterfaceState = LIST_ENTRY()
        self.LegacyBusListEntry = LIST_ENTRY()
        self.DriverUnloadRetryCount = v_uint32()


class RTL_ATOM_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.CriticalSection = RTL_CRITICAL_SECTION()
        self.RtlHandleTable = RTL_HANDLE_TABLE()
        self.NumberOfBuckets = v_uint32()
        self.Buckets = vstruct.VArray([ v_ptr32() for i in xrange(1) ])


class _unnamed_15130(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoStatus = IO_STATUS_BLOCK()


class KUSER_SHARED_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TickCountLow = v_uint32()
        self.TickCountMultiplier = v_uint32()
        self.InterruptTime = KSYSTEM_TIME()
        self.SystemTime = KSYSTEM_TIME()
        self.TimeZoneBias = KSYSTEM_TIME()
        self.ImageNumberLow = v_uint16()
        self.ImageNumberHigh = v_uint16()
        self.NtSystemRoot = vstruct.VArray([ v_uint16() for i in xrange(260) ])
        self.MaxStackTraceDepth = v_uint32()
        self.CryptoExponent = v_uint32()
        self.TimeZoneId = v_uint32()
        self.Reserved2 = vstruct.VArray([ v_uint32() for i in xrange(8) ])
        self.NtProductType = v_uint32()
        self.ProductTypeIsValid = v_uint8()
        self._pad026c = v_bytes(size=3)
        self.NtMajorVersion = v_uint32()
        self.NtMinorVersion = v_uint32()
        self.ProcessorFeatures = vstruct.VArray([ v_uint8() for i in xrange(64) ])
        self.Reserved1 = v_uint32()
        self.Reserved3 = v_uint32()
        self.TimeSlip = v_uint32()
        self.AlternativeArchitecture = v_uint32()
        self._pad02c8 = v_bytes(size=4)
        self.SystemExpirationDate = LARGE_INTEGER()
        self.SuiteMask = v_uint32()
        self.KdDebuggerEnabled = v_uint8()
        self.NXSupportPolicy = v_uint8()
        self._pad02d8 = v_bytes(size=2)
        self.ActiveConsoleId = v_uint32()
        self.DismountCount = v_uint32()
        self.ComPlusPackage = v_uint32()
        self.LastSystemRITEventTickCount = v_uint32()
        self.NumberOfPhysicalPages = v_uint32()
        self.SafeBootMode = v_uint8()
        self._pad02f0 = v_bytes(size=3)
        self.TraceLogging = v_uint32()
        self._pad02f8 = v_bytes(size=4)
        self.TestRetInstruction = v_uint64()
        self.SystemCall = v_uint32()
        self.SystemCallReturn = v_uint32()
        self.SystemCallPad = vstruct.VArray([ v_uint64() for i in xrange(3) ])
        self.TickCount = KSYSTEM_TIME()
        self._pad0330 = v_bytes(size=4)
        self.Cookie = v_uint32()
        self._pad0338 = v_bytes(size=4)


class IMAGE_ROM_OPTIONAL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint16()
        self.MajorLinkerVersion = v_uint8()
        self.MinorLinkerVersion = v_uint8()
        self.SizeOfCode = v_uint32()
        self.SizeOfInitializedData = v_uint32()
        self.SizeOfUninitializedData = v_uint32()
        self.AddressOfEntryPoint = v_uint32()
        self.BaseOfCode = v_uint32()
        self.BaseOfData = v_uint32()
        self.BaseOfBss = v_uint32()
        self.GprMask = v_uint32()
        self.CprMask = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.GpValue = v_uint32()


class _unnamed_16242(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemContext = v_uint32()
        self.Type = v_uint32()
        self.State = POWER_STATE()
        self.ShutdownType = v_uint32()


class HEAP_FREE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.PreviousSize = v_uint16()
        self.SmallTagIndex = v_uint8()
        self.Flags = v_uint8()
        self.UnusedBytes = v_uint8()
        self.SegmentIndex = v_uint8()
        self.FreeList = LIST_ENTRY()


class LDR_DATA_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InLoadOrderLinks = LIST_ENTRY()
        self.InMemoryOrderLinks = LIST_ENTRY()
        self.InInitializationOrderLinks = LIST_ENTRY()
        self.DllBase = v_ptr32()
        self.EntryPoint = v_ptr32()
        self.SizeOfImage = v_uint32()
        self.FullDllName = UNICODE_STRING()
        self.BaseDllName = UNICODE_STRING()
        self.Flags = v_uint32()
        self.LoadCount = v_uint16()
        self.TlsIndex = v_uint16()
        self.HashLinks = LIST_ENTRY()
        self.TimeDateStamp = v_uint32()
        self.EntryPointActivationContext = v_ptr32()
        self.PatchInformation = v_ptr32()


class MMADDRESS_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartVpn = v_uint32()
        self.EndVpn = v_uint32()


class _unnamed_15988(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.FileAttributes = v_uint16()
        self.ShareAccess = v_uint16()
        self.EaLength = v_uint32()


class DBGKD_READ_MEMORY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TargetBaseAddress = v_uint64()
        self.TransferCount = v_uint32()
        self.ActualBytesRead = v_uint32()


class PO_MEMORY_IMAGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Version = v_uint32()
        self.CheckSum = v_uint32()
        self.LengthSelf = v_uint32()
        self.PageSelf = v_uint32()
        self.PageSize = v_uint32()
        self.ImageType = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.SystemTime = LARGE_INTEGER()
        self.InterruptTime = v_uint64()
        self.FeatureFlags = v_uint32()
        self.HiberFlags = v_uint8()
        self.spare = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.NoHiberPtes = v_uint32()
        self.HiberVa = v_uint32()
        self.HiberPte = LARGE_INTEGER()
        self.NoFreePages = v_uint32()
        self.FreeMapCheck = v_uint32()
        self.WakeCheck = v_uint32()
        self.TotalPages = v_uint32()
        self.FirstTablePage = v_uint32()
        self.LastFilePage = v_uint32()
        self.PerfInfo = PO_HIBER_PERF()


class HEAP_UCR_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.ReservedSize = v_uint32()
        self.CommittedSize = v_uint32()
        self.filler = v_uint32()


class HHIVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.GetCellRoutine = v_ptr32()
        self.ReleaseCellRoutine = v_ptr32()
        self.Allocate = v_ptr32()
        self.Free = v_ptr32()
        self.FileSetSize = v_ptr32()
        self.FileWrite = v_ptr32()
        self.FileRead = v_ptr32()
        self.FileFlush = v_ptr32()
        self.BaseBlock = v_ptr32()
        self.DirtyVector = RTL_BITMAP()
        self.DirtyCount = v_uint32()
        self.DirtyAlloc = v_uint32()
        self.RealWrites = v_uint8()
        self._pad003c = v_bytes(size=3)
        self.Cluster = v_uint32()
        self.Flat = v_uint8()
        self.ReadOnly = v_uint8()
        self.Log = v_uint8()
        self._pad0044 = v_bytes(size=1)
        self.HiveFlags = v_uint32()
        self.LogSize = v_uint32()
        self.RefreshCount = v_uint32()
        self.StorageTypeCount = v_uint32()
        self.Version = v_uint32()
        self.Storage = vstruct.VArray([ DUAL() for i in xrange(2) ])


class TEB_ACTIVE_FRAME_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.FrameName = v_ptr32()


class TEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.EnvironmentPointer = v_ptr32()
        self.ClientId = CLIENT_ID()
        self.ActiveRpcHandle = v_ptr32()
        self.ThreadLocalStoragePointer = v_ptr32()
        self.ProcessEnvironmentBlock = v_ptr32()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_ptr32()
        self.Win32ThreadInfo = v_ptr32()
        self.User32Reserved = vstruct.VArray([ v_uint32() for i in xrange(26) ])
        self.UserReserved = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self.WOW32Reserved = v_ptr32()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()
        self.SystemReserved1 = vstruct.VArray([ v_ptr32() for i in xrange(54) ])
        self.ExceptionCode = v_uint32()
        self.ActivationContextStack = ACTIVATION_CONTEXT_STACK()
        self.SpareBytes1 = vstruct.VArray([ v_uint8() for i in xrange(24) ])
        self.GdiTebBatch = GDI_TEB_BATCH()
        self.RealClientId = CLIENT_ID()
        self.GdiCachedProcessHandle = v_ptr32()
        self.GdiClientPID = v_uint32()
        self.GdiClientTID = v_uint32()
        self.GdiThreadLocalInfo = v_ptr32()
        self.Win32ClientInfo = vstruct.VArray([ v_uint32() for i in xrange(62) ])
        self.glDispatchTable = vstruct.VArray([ v_ptr32() for i in xrange(233) ])
        self.glReserved1 = vstruct.VArray([ v_uint32() for i in xrange(29) ])
        self.glReserved2 = v_ptr32()
        self.glSectionInfo = v_ptr32()
        self.glSection = v_ptr32()
        self.glTable = v_ptr32()
        self.glCurrentRC = v_ptr32()
        self.glContext = v_ptr32()
        self.LastStatusValue = v_uint32()
        self.StaticUnicodeString = UNICODE_STRING()
        self.StaticUnicodeBuffer = vstruct.VArray([ v_uint16() for i in xrange(261) ])
        self._pad0e0c = v_bytes(size=2)
        self.DeallocationStack = v_ptr32()
        self.TlsSlots = vstruct.VArray([ v_ptr32() for i in xrange(64) ])
        self.TlsLinks = LIST_ENTRY()
        self.Vdm = v_ptr32()
        self.ReservedForNtRpc = v_ptr32()
        self.DbgSsReserved = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self.HardErrorsAreDisabled = v_uint32()
        self.Instrumentation = vstruct.VArray([ v_ptr32() for i in xrange(16) ])
        self.WinSockData = v_ptr32()
        self.GdiBatchCount = v_uint32()
        self.InDbgPrint = v_uint8()
        self.FreeStackOnTermination = v_uint8()
        self.HasFiberData = v_uint8()
        self.IdealProcessor = v_uint8()
        self.Spare3 = v_uint32()
        self.ReservedForPerf = v_ptr32()
        self.ReservedForOle = v_ptr32()
        self.WaitingOnLoaderLock = v_uint32()
        self.Wx86Thread = Wx86ThreadState()
        self.TlsExpansionSlots = v_ptr32()
        self.ImpersonationLocale = v_uint32()
        self.IsImpersonating = v_uint32()
        self.NlsCache = v_ptr32()
        self.pShimData = v_ptr32()
        self.HeapVirtualAffinity = v_uint32()
        self.CurrentTransactionHandle = v_ptr32()
        self.ActiveFrame = v_ptr32()
        self.SafeThunkCall = v_uint8()
        self.BooleanSpare = vstruct.VArray([ v_uint8() for i in xrange(3) ])


class DRIVER_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Flags = v_uint32()
        self.DriverStart = v_ptr32()
        self.DriverSize = v_uint32()
        self.DriverSection = v_ptr32()
        self.DriverExtension = v_ptr32()
        self.DriverName = UNICODE_STRING()
        self.HardwareDatabase = v_ptr32()
        self.FastIoDispatch = v_ptr32()
        self.DriverInit = v_ptr32()
        self.DriverStartIo = v_ptr32()
        self.DriverUnload = v_ptr32()
        self.MajorFunction = vstruct.VArray([ v_ptr32() for i in xrange(28) ])


class OBJECT_SYMBOLIC_LINK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LinkTarget = UNICODE_STRING()
        self.LinkTargetRemaining = UNICODE_STRING()
        self.LinkTargetObject = v_ptr32()
        self.DosDeviceDriveIndex = v_uint32()


class EJOB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Event = KEVENT()
        self.JobLinks = LIST_ENTRY()
        self.ProcessListHead = LIST_ENTRY()
        self.JobLock = ERESOURCE()
        self.TotalUserTime = LARGE_INTEGER()
        self.TotalKernelTime = LARGE_INTEGER()
        self.ThisPeriodTotalUserTime = LARGE_INTEGER()
        self.ThisPeriodTotalKernelTime = LARGE_INTEGER()
        self.TotalPageFaultCount = v_uint32()
        self.TotalProcesses = v_uint32()
        self.ActiveProcesses = v_uint32()
        self.TotalTerminatedProcesses = v_uint32()
        self.PerProcessUserTimeLimit = LARGE_INTEGER()
        self.PerJobUserTimeLimit = LARGE_INTEGER()
        self.LimitFlags = v_uint32()
        self.MinimumWorkingSetSize = v_uint32()
        self.MaximumWorkingSetSize = v_uint32()
        self.ActiveProcessLimit = v_uint32()
        self.Affinity = v_uint32()
        self.PriorityClass = v_uint8()
        self._pad00b0 = v_bytes(size=3)
        self.UIRestrictionsClass = v_uint32()
        self.SecurityLimitFlags = v_uint32()
        self.Token = v_ptr32()
        self.Filter = v_ptr32()
        self.EndOfJobTimeAction = v_uint32()
        self.CompletionPort = v_ptr32()
        self.CompletionKey = v_ptr32()
        self.SessionId = v_uint32()
        self.SchedulingClass = v_uint32()
        self._pad00d8 = v_bytes(size=4)
        self.ReadOperationCount = v_uint64()
        self.WriteOperationCount = v_uint64()
        self.OtherOperationCount = v_uint64()
        self.ReadTransferCount = v_uint64()
        self.WriteTransferCount = v_uint64()
        self.OtherTransferCount = v_uint64()
        self.IoInfo = IO_COUNTERS()
        self.ProcessMemoryLimit = v_uint32()
        self.JobMemoryLimit = v_uint32()
        self.PeakProcessMemoryUsed = v_uint32()
        self.PeakJobMemoryUsed = v_uint32()
        self.CurrentJobMemoryUsed = v_uint32()
        self.MemoryLimitsLock = FAST_MUTEX()
        self.JobSetLinks = LIST_ENTRY()
        self.MemberLevel = v_uint32()
        self.JobFlags = v_uint32()
        self._pad0180 = v_bytes(size=4)


class _unnamed_16023(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Key = v_uint32()
        self.ByteOffset = LARGE_INTEGER()


class DBGKD_READ_WRITE_IO_EXTENDED64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.AddressSpace = v_uint32()
        self.IoAddress = v_uint64()
        self.DataValue = v_uint32()
        self._pad0020 = v_bytes(size=4)


class IO_STATUS_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.Information = v_uint32()


class KPROCESSOR_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFrame = CONTEXT()
        self.SpecialRegisters = KSPECIAL_REGISTERS()


class KiIoAccessMap(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DirectionMap = vstruct.VArray([ v_uint8() for i in xrange(32) ])
        self.IoMap = vstruct.VArray([ v_uint8() for i in xrange(8196) ])


class KAPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.Spare0 = v_uint32()
        self.Thread = v_ptr32()
        self.ApcListEntry = LIST_ENTRY()
        self.KernelRoutine = v_ptr32()
        self.RundownRoutine = v_ptr32()
        self.NormalRoutine = v_ptr32()
        self.NormalContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.ApcStateIndex = v_uint8()
        self.ApcMode = v_uint8()
        self.Inserted = v_uint8()
        self._pad0030 = v_bytes(size=1)


class POOL_TRACKER_BIG_PAGES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Va = v_ptr32()
        self.Key = v_uint32()
        self.NumberOfPages = v_uint32()


class SID_IDENTIFIER_AUTHORITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Value = vstruct.VArray([ v_uint8() for i in xrange(6) ])


class RTL_RANGE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = LIST_ENTRY()
        self.Flags = v_uint32()
        self.Count = v_uint32()
        self.Stamp = v_uint32()


class LARGE_CONTROL_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Segment = v_ptr32()
        self.DereferenceList = LIST_ENTRY()
        self.NumberOfSectionReferences = v_uint32()
        self.NumberOfPfnReferences = v_uint32()
        self.NumberOfMappedViews = v_uint32()
        self.NumberOfSubsections = v_uint16()
        self.FlushInProgressCount = v_uint16()
        self.NumberOfUserReferences = v_uint32()
        self.u = _unnamed_12520()
        self.FilePointer = v_ptr32()
        self.WaitingForDeletion = v_ptr32()
        self.ModifiedWriteCount = v_uint16()
        self.NumberOfSystemCacheViews = v_uint16()
        self.StartingFrame = v_uint32()
        self.UserGlobalList = LIST_ENTRY()
        self.SessionId = v_uint32()


class VI_POOL_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InUse = VI_POOL_ENTRY_INUSE()


class POOL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousSize = v_uint16()
        self.BlockSize = v_uint16()
        self.ProcessBilled = v_ptr32()


class SHARED_CACHE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self.NodeByteSize = v_uint16()
        self.OpenCount = v_uint32()
        self.FileSize = LARGE_INTEGER()
        self.BcbList = LIST_ENTRY()
        self.SectionSize = LARGE_INTEGER()
        self.ValidDataLength = LARGE_INTEGER()
        self.ValidDataGoal = LARGE_INTEGER()
        self.InitialVacbs = vstruct.VArray([ v_ptr32() for i in xrange(4) ])
        self.Vacbs = v_ptr32()
        self.FileObject = v_ptr32()
        self.ActiveVacb = v_ptr32()
        self.NeedToZero = v_ptr32()
        self.ActivePage = v_uint32()
        self.NeedToZeroPage = v_uint32()
        self.ActiveVacbSpinLock = v_uint32()
        self.VacbActiveCount = v_uint32()
        self.DirtyPages = v_uint32()
        self.SharedCacheMapLinks = LIST_ENTRY()
        self.Flags = v_uint32()
        self.Status = v_uint32()
        self.Mbcb = v_ptr32()
        self.Section = v_ptr32()
        self.CreateEvent = v_ptr32()
        self.WaitOnActiveCount = v_ptr32()
        self.PagesToWrite = v_uint32()
        self.BeyondLastFlush = v_uint64()
        self.Callbacks = v_ptr32()
        self.LazyWriteContext = v_ptr32()
        self.PrivateList = LIST_ENTRY()
        self.LogHandle = v_ptr32()
        self.FlushToLsnRoutine = v_ptr32()
        self.DirtyPageThreshold = v_uint32()
        self.LazyWritePassCount = v_uint32()
        self.UninitializeEvent = v_ptr32()
        self.NeedToZeroVacb = v_ptr32()
        self.BcbSpinLock = v_uint32()
        self.Reserved = v_ptr32()
        self.Event = KEVENT()
        self.VacbPushLock = EX_PUSH_LOCK()
        self._pad00d8 = v_bytes(size=4)
        self.PrivateCacheMap = PRIVATE_CACHE_MAP()


class TRACE_ENABLE_FLAG_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint16()
        self.Length = v_uint8()
        self.Flag = v_uint8()


class MI_VERIFIER_POOL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListIndex = v_uint32()
        self.Verifier = v_ptr32()


class MMBANKED_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BasePhysicalPage = v_uint32()
        self.BasedPte = v_ptr32()
        self.BankSize = v_uint32()
        self.BankShift = v_uint32()
        self.BankedRoutine = v_ptr32()
        self.Context = v_ptr32()
        self.CurrentMappedPte = v_ptr32()
        self.BankTemplate = vstruct.VArray([ MMPTE() for i in xrange(1) ])


class PCI_POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CurrentSystemState = v_uint32()
        self.CurrentDeviceState = v_uint32()
        self.SystemWakeLevel = v_uint32()
        self.DeviceWakeLevel = v_uint32()
        self.SystemStateMapping = vstruct.VArray([ DEVICE_POWER_STATE() for i in xrange(7) ])
        self.WaitWakeIrp = v_ptr32()
        self.SavedCancelRoutine = v_ptr32()
        self.Paging = v_uint32()
        self.Hibernate = v_uint32()
        self.CrashDump = v_uint32()


class RTL_CRITICAL_SECTION_DEBUG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self.CriticalSection = v_ptr32()
        self.ProcessLocksList = LIST_ENTRY()
        self.EntryCount = v_uint32()
        self.ContentionCount = v_uint32()
        self.Spare = vstruct.VArray([ v_uint32() for i in xrange(2) ])


class PNP_DEVICE_EVENT_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.Argument = v_uint32()
        self.CallerEvent = v_ptr32()
        self.Callback = v_ptr32()
        self.Context = v_ptr32()
        self.VetoType = v_ptr32()
        self.VetoName = v_ptr32()
        self.Data = PLUGPLAY_EVENT_BLOCK()


class ARBITER_CONFLICT_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwningObject = v_ptr32()
        self._pad0008 = v_bytes(size=4)
        self.Start = v_uint64()
        self.End = v_uint64()


class SID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Sid = v_ptr32()
        self.Attributes = v_uint32()


class VI_DEADLOCK_GLOBALS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Nodes = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.Resources = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.Threads = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.TimeAcquire = v_uint64()
        self.TimeRelease = v_uint64()
        self.BytesAllocated = v_uint32()
        self.ResourceDatabase = v_ptr32()
        self.ThreadDatabase = v_ptr32()
        self.AllocationFailures = v_uint32()
        self.NodesTrimmedBasedOnAge = v_uint32()
        self.NodesTrimmedBasedOnCount = v_uint32()
        self.NodesSearched = v_uint32()
        self.MaxNodesSearched = v_uint32()
        self.SequenceNumber = v_uint32()
        self.RecursionDepthLimit = v_uint32()
        self.SearchedNodesLimit = v_uint32()
        self.DepthLimitHits = v_uint32()
        self.SearchLimitHits = v_uint32()
        self.ABC_ACB_Skipped = v_uint32()
        self.FreeResourceList = LIST_ENTRY()
        self.FreeThreadList = LIST_ENTRY()
        self.FreeNodeList = LIST_ENTRY()
        self.FreeResourceCount = v_uint32()
        self.FreeThreadCount = v_uint32()
        self.FreeNodeCount = v_uint32()
        self.Instigator = v_ptr32()
        self.NumberOfParticipants = v_uint32()
        self.Participant = vstruct.VArray([ v_ptr32() for i in xrange(32) ])
        self.CacheReductionInProgress = v_uint32()


class TOKEN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TokenSource = TOKEN_SOURCE()
        self.TokenId = LUID()
        self.AuthenticationId = LUID()
        self.ParentTokenId = LUID()
        self.ExpirationTime = LARGE_INTEGER()
        self.TokenLock = v_ptr32()
        self._pad0038 = v_bytes(size=4)
        self.AuditPolicy = SEP_AUDIT_POLICY()
        self.ModifiedId = LUID()
        self.SessionId = v_uint32()
        self.UserAndGroupCount = v_uint32()
        self.RestrictedSidCount = v_uint32()
        self.PrivilegeCount = v_uint32()
        self.VariableLength = v_uint32()
        self.DynamicCharged = v_uint32()
        self.DynamicAvailable = v_uint32()
        self.DefaultOwnerIndex = v_uint32()
        self.UserAndGroups = v_ptr32()
        self.RestrictedSids = v_ptr32()
        self.PrimaryGroup = v_ptr32()
        self.Privileges = v_ptr32()
        self.DynamicPart = v_ptr32()
        self.DefaultDacl = v_ptr32()
        self.TokenType = v_uint32()
        self.ImpersonationLevel = v_uint32()
        self.TokenFlags = v_uint32()
        self.TokenInUse = v_uint8()
        self._pad0090 = v_bytes(size=3)
        self.ProxyData = v_ptr32()
        self.AuditData = v_ptr32()
        self.OriginatingLogonSession = LUID()
        self.VariablePart = v_uint32()
        self._pad00a8 = v_bytes(size=4)


class MMCOLOR_TABLES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint32()
        self.Blink = v_ptr32()
        self.Count = v_uint32()


class DISPATCHER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.Absolute = v_uint8()
        self.Size = v_uint8()
        self.Inserted = v_uint8()
        self.SignalState = v_uint32()
        self.WaitListHead = LIST_ENTRY()


class _unnamed_16509(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceNumber = v_uint32()


class _unnamed_16110(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self.InputBufferLength = v_uint32()
        self.FsControlCode = v_uint32()
        self.Type3InputBuffer = v_ptr32()


class _unnamed_16505(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mbr = _unnamed_16663()
        self._pad0010 = v_bytes(size=8)


class DBGKD_READ_WRITE_IO64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoAddress = v_uint64()
        self.DataSize = v_uint32()
        self.DataValue = v_uint32()


class PROCESSOR_POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleFunction = v_ptr32()
        self.Idle0KernelTimeLimit = v_uint32()
        self.Idle0LastTime = v_uint32()
        self.IdleHandlers = v_ptr32()
        self.IdleState = v_ptr32()
        self.IdleHandlersCount = v_uint32()
        self.LastCheck = v_uint64()
        self.IdleTimes = PROCESSOR_IDLE_TIMES()
        self.IdleTime1 = v_uint32()
        self.PromotionCheck = v_uint32()
        self.IdleTime2 = v_uint32()
        self.CurrentThrottle = v_uint8()
        self.ThermalThrottleLimit = v_uint8()
        self.CurrentThrottleIndex = v_uint8()
        self.ThermalThrottleIndex = v_uint8()
        self.LastKernelUserTime = v_uint32()
        self.LastIdleThreadKernelTime = v_uint32()
        self.PackageIdleStartTime = v_uint32()
        self.PackageIdleTime = v_uint32()
        self.DebugCount = v_uint32()
        self.LastSysTime = v_uint32()
        self.TotalIdleStateTime = vstruct.VArray([ v_uint64() for i in xrange(3) ])
        self.TotalIdleTransitions = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self._pad0090 = v_bytes(size=4)
        self.PreviousC3StateTime = v_uint64()
        self.KneeThrottleIndex = v_uint8()
        self.ThrottleLimitIndex = v_uint8()
        self.PerfStatesCount = v_uint8()
        self.ProcessorMinThrottle = v_uint8()
        self.ProcessorMaxThrottle = v_uint8()
        self.EnableIdleAccounting = v_uint8()
        self.LastC3Percentage = v_uint8()
        self.LastAdjustedBusyPercentage = v_uint8()
        self.PromotionCount = v_uint32()
        self.DemotionCount = v_uint32()
        self.ErrorCount = v_uint32()
        self.RetryCount = v_uint32()
        self.Flags = v_uint32()
        self._pad00b8 = v_bytes(size=4)
        self.PerfCounterFrequency = LARGE_INTEGER()
        self.PerfTickCount = v_uint32()
        self._pad00c8 = v_bytes(size=4)
        self.PerfTimer = KTIMER()
        self.PerfDpc = KDPC()
        self.PerfStates = v_ptr32()
        self.PerfSetThrottle = v_ptr32()
        self.LastC3KernelUserTime = v_uint32()
        self.LastPackageIdleTime = v_uint32()


class SECURITY_CLIENT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityQos = SECURITY_QUALITY_OF_SERVICE()
        self.ClientToken = v_ptr32()
        self.DirectlyAccessClientToken = v_uint8()
        self.DirectAccessEffectiveOnly = v_uint8()
        self.ServerIsRemote = v_uint8()
        self._pad0014 = v_bytes(size=1)
        self.ClientTokenControl = TOKEN_CONTROL()


class DBGKD_SEARCH_MEMORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SearchAddress = v_uint64()
        self.SearchLength = v_uint64()
        self.PatternLength = v_uint32()
        self._pad0018 = v_bytes(size=4)


class DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pad = v_uint16()
        self.Limit = v_uint16()
        self.Base = v_uint32()


class DBGKD_MANIPULATE_STATE64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ApiNumber = v_uint32()
        self.ProcessorLevel = v_uint16()
        self.Processor = v_uint16()
        self.ReturnStatus = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.u = _unnamed_11794()


class LPCP_PORT_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NonPagedPortQueue = v_ptr32()
        self.Semaphore = v_ptr32()
        self.ReceiveHead = LIST_ENTRY()


class DBGKD_LOAD_SYMBOLS64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PathNameLength = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.BaseOfDll = v_uint64()
        self.ProcessId = v_uint64()
        self.CheckSum = v_uint32()
        self.SizeOfImage = v_uint32()
        self.UnloadSymbols = v_uint8()
        self._pad0028 = v_bytes(size=7)


class CACHE_UNINITIALIZE_EVENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Event = KEVENT()


class SECURITY_QUALITY_OF_SERVICE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.ImpersonationLevel = v_uint32()
        self.ContextTrackingMode = v_uint8()
        self.EffectiveOnly = v_uint8()
        self._pad000c = v_bytes(size=2)


class COMPRESSED_DATA_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CompressionFormatAndEngine = v_uint16()
        self.CompressionUnitShift = v_uint8()
        self.ChunkShift = v_uint8()
        self.ClusterShift = v_uint8()
        self.Reserved = v_uint8()
        self.NumberOfChunks = v_uint16()
        self.CompressedChunkSizes = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class _unnamed_14650(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint32()
        self.Length = v_uint32()
        self.Reserved = v_uint32()


class RTL_HANDLE_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MaximumNumberOfHandles = v_uint32()
        self.SizeOfHandleTableEntry = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.FreeHandles = v_ptr32()
        self.CommittedHandles = v_ptr32()
        self.UnCommittedHandles = v_ptr32()
        self.MaxReservedHandles = v_ptr32()


class _unnamed_14654(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class CMHIVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Hive = HHIVE()
        self.FileHandles = vstruct.VArray([ v_ptr32() for i in xrange(3) ])
        self.NotifyList = LIST_ENTRY()
        self.HiveList = LIST_ENTRY()
        self.HiveLock = v_ptr32()
        self.ViewLock = v_ptr32()
        self.LRUViewListHead = LIST_ENTRY()
        self.PinViewListHead = LIST_ENTRY()
        self.FileObject = v_ptr32()
        self.FileFullPath = UNICODE_STRING()
        self.FileUserName = UNICODE_STRING()
        self.MappedViews = v_uint16()
        self.PinnedViews = v_uint16()
        self.UseCount = v_uint32()
        self.SecurityCount = v_uint32()
        self.SecurityCacheSize = v_uint32()
        self.SecurityHitHint = v_uint32()
        self.SecurityCache = v_ptr32()
        self.SecurityHash = vstruct.VArray([ LIST_ENTRY() for i in xrange(64) ])
        self.UnloadEvent = v_ptr32()
        self.RootKcb = v_ptr32()
        self.Frozen = v_uint8()
        self._pad047c = v_bytes(size=3)
        self.UnloadWorkItem = v_ptr32()
        self.GrowOnlyMode = v_uint8()
        self._pad0484 = v_bytes(size=3)
        self.GrowOffset = v_uint32()
        self.KcbConvertListHead = LIST_ENTRY()
        self.KnodeConvertListHead = LIST_ENTRY()
        self.CellRemapArray = v_ptr32()


class POP_SHUTDOWN_BUG_CHECK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Code = v_uint32()
        self.Parameter1 = v_uint32()
        self.Parameter2 = v_uint32()
        self.Parameter3 = v_uint32()
        self.Parameter4 = v_uint32()


class SECTION_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartingVa = v_ptr32()
        self.EndingVa = v_ptr32()
        self.Parent = v_ptr32()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.Segment = v_ptr32()


class LUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class OBJECT_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PointerCount = v_uint32()
        self.HandleCount = v_uint32()
        self.Type = v_ptr32()
        self.NameInfoOffset = v_uint8()
        self.HandleInfoOffset = v_uint8()
        self.QuotaInfoOffset = v_uint8()
        self.Flags = v_uint8()
        self.ObjectCreateInfo = v_ptr32()
        self.SecurityDescriptor = v_ptr32()
        self.Body = QUAD()


class PCI_MN_DISPATCH_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DispatchStyle = v_uint32()
        self.DispatchFunction = v_ptr32()


class PCI_HEADER_TYPE_2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SocketRegistersBaseAddress = v_uint32()
        self.CapabilitiesPtr = v_uint8()
        self.Reserved = v_uint8()
        self.SecondaryStatus = v_uint16()
        self.PrimaryBus = v_uint8()
        self.SecondaryBus = v_uint8()
        self.SubordinateBus = v_uint8()
        self.SecondaryLatency = v_uint8()
        self.Range = vstruct.VArray([ _unnamed_15560() for i in xrange(4) ])
        self.InterruptLine = v_uint8()
        self.InterruptPin = v_uint8()
        self.BridgeControl = v_uint16()


class PCI_HEADER_TYPE_1(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseAddresses = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.PrimaryBus = v_uint8()
        self.SecondaryBus = v_uint8()
        self.SubordinateBus = v_uint8()
        self.SecondaryLatency = v_uint8()
        self.IOBase = v_uint8()
        self.IOLimit = v_uint8()
        self.SecondaryStatus = v_uint16()
        self.MemoryBase = v_uint16()
        self.MemoryLimit = v_uint16()
        self.PrefetchBase = v_uint16()
        self.PrefetchLimit = v_uint16()
        self.PrefetchBaseUpper32 = v_uint32()
        self.PrefetchLimitUpper32 = v_uint32()
        self.IOBaseUpper16 = v_uint16()
        self.IOLimitUpper16 = v_uint16()
        self.CapabilitiesPtr = v_uint8()
        self.Reserved1 = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.ROMBaseAddress = v_uint32()
        self.InterruptLine = v_uint8()
        self.InterruptPin = v_uint8()
        self.BridgeControl = v_uint16()


class PCI_HEADER_TYPE_0(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseAddresses = vstruct.VArray([ v_uint32() for i in xrange(6) ])
        self.CIS = v_uint32()
        self.SubVendorID = v_uint16()
        self.SubSystemID = v_uint16()
        self.ROMBaseAddress = v_uint32()
        self.CapabilitiesPtr = v_uint8()
        self.Reserved1 = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.Reserved2 = v_uint32()
        self.InterruptLine = v_uint8()
        self.InterruptPin = v_uint8()
        self.MinimumGrant = v_uint8()
        self.MaximumLatency = v_uint8()


class MMPFN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_13150()
        self.PteAddress = v_ptr32()
        self.u2 = _unnamed_13151()
        self.u3 = _unnamed_13152()
        self.OriginalPte = MMPTE()
        self.u4 = _unnamed_13153()


class OBJECT_DUMP_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Stream = v_ptr32()
        self.Detail = v_uint32()


class CACHE_MANAGER_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AcquireForLazyWrite = v_ptr32()
        self.ReleaseFromLazyWrite = v_ptr32()
        self.AcquireForReadAhead = v_ptr32()
        self.ReleaseFromReadAhead = v_ptr32()


class DBGKD_CONTINUE2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContinueStatus = v_uint32()
        self.ControlSet = X86_DBGKD_CONTROL_SET()
        self._pad0020 = v_bytes(size=12)


class HANDLE_TRACE_DB_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientId = CLIENT_ID()
        self.Handle = v_ptr32()
        self.Type = v_uint32()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(16) ])


class LPCP_NONPAGED_PORT_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Semaphore = KSEMAPHORE()
        self.BackPointer = v_ptr32()


class DEVICE_RELATIONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Objects = vstruct.VArray([ v_ptr32() for i in xrange(1) ])


class _unnamed_14532(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = _unnamed_16299()


class BATTERY_REPORTING_SCALE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Granularity = v_uint32()
        self.Capacity = v_uint32()


class MMPAGING_FILE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.MaximumSize = v_uint32()
        self.MinimumSize = v_uint32()
        self.FreeSpace = v_uint32()
        self.CurrentUsage = v_uint32()
        self.PeakUsage = v_uint32()
        self.Hint = v_uint32()
        self.HighestPage = v_uint32()
        self.Entry = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self.Bitmap = v_ptr32()
        self.File = v_ptr32()
        self.PageFileName = UNICODE_STRING()
        self.PageFileNumber = v_uint32()
        self.Extended = v_uint8()
        self.HintSetToZero = v_uint8()
        self.BootPartition = v_uint8()
        self._pad0040 = v_bytes(size=1)
        self.FileHandle = v_ptr32()


class _unnamed_16200(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WhichSpace = v_uint32()
        self.Buffer = v_ptr32()
        self.Offset = v_uint32()
        self.Length = v_uint32()


class STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class _unnamed_16205(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint8()


class FNSAVE_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint32()
        self.StatusWord = v_uint32()
        self.TagWord = v_uint32()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint32()
        self.RegisterArea = vstruct.VArray([ v_uint8() for i in xrange(80) ])


class CMP_OFFSET_ARRAY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileOffset = v_uint32()
        self.DataBuffer = v_ptr32()
        self.DataLength = v_uint32()


class CM_KEY_VALUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.NameLength = v_uint16()
        self.DataLength = v_uint32()
        self.Data = v_uint32()
        self.Type = v_uint32()
        self.Flags = v_uint16()
        self.Spare = v_uint16()
        self.Name = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0018 = v_bytes(size=2)


class MMVAD_FLAGS2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileOffset = v_uint32()


class LIST_ENTRY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint32()
        self.Blink = v_uint32()


class MMWSLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_13252()


class DBGKD_BREAKPOINTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakPointCount = v_uint32()
        self.ContinueStatus = v_uint32()


class FILE_NETWORK_OPEN_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0038 = v_bytes(size=4)


class PCI_SECONDARY_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.List = SINGLE_LIST_ENTRY()
        self.ExtensionType = v_uint32()
        self.Destructor = v_ptr32()


class DBGKD_QUERY_MEMORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_uint64()
        self.Reserved = v_uint64()
        self.AddressSpace = v_uint32()
        self.Flags = v_uint32()


class PCI_SLOT_NUMBER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u = _unnamed_14357()


class _unnamed_16115(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_ptr32()
        self.Key = v_uint32()
        self.ByteOffset = LARGE_INTEGER()


class KDEVICE_QUEUE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceListEntry = LIST_ENTRY()
        self.SortKey = v_uint32()
        self.Inserted = v_uint8()
        self._pad0010 = v_bytes(size=3)


class LIST_ENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint64()
        self.Blink = v_uint64()


class MMPTE_SUBSECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class PO_DEVICE_NOTIFY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = LIST_ENTRY()
        self.TargetDevice = v_ptr32()
        self.WakeNeeded = v_uint8()
        self.OrderLevel = v_uint8()
        self._pad0010 = v_bytes(size=2)
        self.DeviceObject = v_ptr32()
        self.Node = v_ptr32()
        self.DeviceName = v_ptr32()
        self.DriverName = v_ptr32()
        self.ChildCount = v_uint32()
        self.ActiveChild = v_uint32()


class HMAP_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Directory = vstruct.VArray([ v_ptr32() for i in xrange(1024) ])


class _unnamed_13150(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint32()


class _unnamed_13151(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Blink = v_uint32()


class _unnamed_13152(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e1 = MMPFNENTRY()


class HEAP_STOP_ON_VALUES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocAddress = v_uint32()
        self.AllocTag = HEAP_STOP_ON_TAG()
        self.ReAllocAddress = v_uint32()
        self.ReAllocTag = HEAP_STOP_ON_TAG()
        self.FreeAddress = v_uint32()
        self.FreeTag = HEAP_STOP_ON_TAG()


class WMI_BUFFER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Wnode = WNODE_HEADER()
        self.Offset = v_uint32()
        self.EventsLost = v_uint32()
        self.InstanceGuid = GUID()


class RTL_HANDLE_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()


class ARBITER_ALTERNATIVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Minimum = v_uint64()
        self.Maximum = v_uint64()
        self.Length = v_uint32()
        self.Alignment = v_uint32()
        self.Priority = v_uint32()
        self.Flags = v_uint32()
        self.Descriptor = v_ptr32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])


class EX_FAST_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr32()


class INTERLOCK_SEQ(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint16()
        self.FreeEntryOffset = v_uint16()
        self.Sequence = v_uint32()


class HMAP_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Table = vstruct.VArray([ HMAP_ENTRY() for i in xrange(512) ])


class KSPIN_LOCK_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Lock = v_ptr32()


class _unnamed_12918(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DockStatus = v_uint32()
        self.ListEntry = LIST_ENTRY()
        self.SerialNumber = v_ptr32()


class FS_FILTER_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbacks = v_uint32()
        self.Reserved = v_uint32()
        self.PreAcquireForSectionSynchronization = v_ptr32()
        self.PostAcquireForSectionSynchronization = v_ptr32()
        self.PreReleaseForSectionSynchronization = v_ptr32()
        self.PostReleaseForSectionSynchronization = v_ptr32()
        self.PreAcquireForCcFlush = v_ptr32()
        self.PostAcquireForCcFlush = v_ptr32()
        self.PreReleaseForCcFlush = v_ptr32()
        self.PostReleaseForCcFlush = v_ptr32()
        self.PreAcquireForModifiedPageWriter = v_ptr32()
        self.PostAcquireForModifiedPageWriter = v_ptr32()
        self.PreReleaseForModifiedPageWriter = v_ptr32()
        self.PostReleaseForModifiedPageWriter = v_ptr32()


class HANDLE_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr32()
        self.GrantedAccess = v_uint32()


class IO_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Option = v_uint8()
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Spare1 = v_uint8()
        self.Flags = v_uint16()
        self.Spare2 = v_uint16()
        self.u = _unnamed_14532()


class _unnamed_12917(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextResourceDeviceNode = v_ptr32()


class _unnamed_12916(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LegacyDeviceNode = v_ptr32()


class THERMAL_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ThermalStamp = v_uint32()
        self.ThermalConstant1 = v_uint32()
        self.ThermalConstant2 = v_uint32()
        self.Processors = v_uint32()
        self.SamplingPeriod = v_uint32()
        self.CurrentTemperature = v_uint32()
        self.PassiveTripPoint = v_uint32()
        self.CriticalTripPoint = v_uint32()
        self.ActiveTripPointCount = v_uint8()
        self._pad0024 = v_bytes(size=3)
        self.ActiveTripPoint = vstruct.VArray([ v_uint32() for i in xrange(10) ])


class IMAGE_OPTIONAL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint16()
        self.MajorLinkerVersion = v_uint8()
        self.MinorLinkerVersion = v_uint8()
        self.SizeOfCode = v_uint32()
        self.SizeOfInitializedData = v_uint32()
        self.SizeOfUninitializedData = v_uint32()
        self.AddressOfEntryPoint = v_uint32()
        self.BaseOfCode = v_uint32()
        self.BaseOfData = v_uint32()
        self.ImageBase = v_uint32()
        self.SectionAlignment = v_uint32()
        self.FileAlignment = v_uint32()
        self.MajorOperatingSystemVersion = v_uint16()
        self.MinorOperatingSystemVersion = v_uint16()
        self.MajorImageVersion = v_uint16()
        self.MinorImageVersion = v_uint16()
        self.MajorSubsystemVersion = v_uint16()
        self.MinorSubsystemVersion = v_uint16()
        self.Win32VersionValue = v_uint32()
        self.SizeOfImage = v_uint32()
        self.SizeOfHeaders = v_uint32()
        self.CheckSum = v_uint32()
        self.Subsystem = v_uint16()
        self.DllCharacteristics = v_uint16()
        self.SizeOfStackReserve = v_uint32()
        self.SizeOfStackCommit = v_uint32()
        self.SizeOfHeapReserve = v_uint32()
        self.SizeOfHeapCommit = v_uint32()
        self.LoaderFlags = v_uint32()
        self.NumberOfRvaAndSizes = v_uint32()
        self.DataDirectory = vstruct.VArray([ IMAGE_DATA_DIRECTORY() for i in xrange(16) ])


class SCSI_REQUEST_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class OBJECT_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.RootDirectory = v_ptr32()
        self.ObjectName = v_ptr32()
        self.Attributes = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.SecurityQualityOfService = v_ptr32()


class SUBSECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlArea = v_ptr32()
        self.u = _unnamed_12531()
        self.StartingSector = v_uint32()
        self.NumberOfFullSectors = v_uint32()
        self.SubsectionBase = v_ptr32()
        self.UnusedPtes = v_uint32()
        self.PtesInSubsection = v_uint32()
        self.NextSubsection = v_ptr32()


class ETHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Tcb = KTHREAD()
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self.ExitStatus = v_uint32()
        self.PostBlockList = LIST_ENTRY()
        self.TerminationPort = v_ptr32()
        self.ActiveTimerListLock = v_uint32()
        self.ActiveTimerListHead = LIST_ENTRY()
        self.Cid = CLIENT_ID()
        self.LpcReplySemaphore = KSEMAPHORE()
        self.LpcReplyMessage = v_ptr32()
        self.ImpersonationInfo = v_ptr32()
        self.IrpList = LIST_ENTRY()
        self.TopLevelIrp = v_uint32()
        self.DeviceToVerify = v_ptr32()
        self.ThreadsProcess = v_ptr32()
        self.StartAddress = v_ptr32()
        self.Win32StartAddress = v_ptr32()
        self.ThreadListEntry = LIST_ENTRY()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.ThreadLock = EX_PUSH_LOCK()
        self.LpcReplyMessageId = v_uint32()
        self.ReadClusterSize = v_uint32()
        self.GrantedAccess = v_uint32()
        self.CrossThreadFlags = v_uint32()
        self.SameThreadPassiveFlags = v_uint32()
        self.SameThreadApcFlags = v_uint32()
        self.ForwardClusterOnly = v_uint8()
        self.DisablePageFaultClustering = v_uint8()
        self._pad0258 = v_bytes(size=2)


class _unnamed_16158(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_ptr32()
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Interface = v_ptr32()
        self.InterfaceSpecificData = v_ptr32()


class FAST_MUTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Owner = v_ptr32()
        self.Contention = v_uint32()
        self.Event = KEVENT()
        self.OldIrql = v_uint32()


class _unnamed_16156(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()


class MM_SESSION_SPACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReferenceCount = v_uint32()
        self.u = _unnamed_13227()
        self.SessionId = v_uint32()
        self.SessionPageDirectoryIndex = v_uint32()
        self.GlobalVirtualAddress = v_ptr32()
        self.ProcessList = LIST_ENTRY()
        self.NonPagedPoolBytes = v_uint32()
        self.PagedPoolBytes = v_uint32()
        self.NonPagedPoolAllocations = v_uint32()
        self.PagedPoolAllocations = v_uint32()
        self.NonPagablePages = v_uint32()
        self.CommittedPages = v_uint32()
        self._pad0038 = v_bytes(size=4)
        self.LastProcessSwappedOutTime = LARGE_INTEGER()
        self.PageTables = v_ptr32()
        self.PagedPoolMutex = FAST_MUTEX()
        self.PagedPoolStart = v_ptr32()
        self.PagedPoolEnd = v_ptr32()
        self.PagedPoolBasePde = v_ptr32()
        self.PagedPoolInfo = MM_PAGED_POOL_INFO()
        self.Color = v_uint32()
        self.ProcessOutSwapCount = v_uint32()
        self.ImageList = LIST_ENTRY()
        self.GlobalPteEntry = v_ptr32()
        self.CopyOnWriteCount = v_uint32()
        self.SessionPoolAllocationFailures = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.AttachCount = v_uint32()
        self.AttachEvent = KEVENT()
        self.LastProcess = v_ptr32()
        self._pad00d8 = v_bytes(size=4)
        self.Vm = MMSUPPORT()
        self.Wsle = v_ptr32()
        self.WsLock = ERESOURCE()
        self.WsListEntry = LIST_ENTRY()
        self.Session = MMSESSION()
        self.Win32KDriverObject = DRIVER_OBJECT()
        self.WorkingSetLockOwner = v_ptr32()
        self.PagedPool = POOL_DESCRIPTOR()
        self.ProcessReferenceToSession = v_uint32()
        self.LocaleId = v_uint32()
        self._pad1278 = v_bytes(size=4)


class CM_NAME_CONTROL_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Compressed = v_uint8()
        self._pad0002 = v_bytes(size=1)
        self.RefCount = v_uint16()
        self.NameHash = CM_NAME_HASH()


class _unnamed_16016(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self.Parameters = v_ptr32()


class _unnamed_13534(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint32()


class KDEVICE_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceListHead = LIST_ENTRY()
        self.Lock = v_uint32()
        self.Busy = v_uint8()
        self._pad0014 = v_bytes(size=3)


class IO_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReadOperationCount = v_uint64()
        self.WriteOperationCount = v_uint64()
        self.OtherOperationCount = v_uint64()
        self.ReadTransferCount = v_uint64()
        self.WriteTransferCount = v_uint64()
        self.OtherTransferCount = v_uint64()


class _unnamed_16380(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataLength = v_uint16()
        self.TotalLength = v_uint16()


class PCI_BUS_INTERFACE_STANDARD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Context = v_ptr32()
        self.InterfaceReference = v_ptr32()
        self.InterfaceDereference = v_ptr32()
        self.ReadConfig = v_ptr32()
        self.WriteConfig = v_ptr32()
        self.PinToLine = v_ptr32()
        self.LineToPin = v_ptr32()


class PORT_MESSAGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_15734()
        self.u2 = _unnamed_15735()
        self.ClientId = CLIENT_ID()
        self.MessageId = v_uint32()
        self.ClientViewSize = v_uint32()


class _unnamed_16385(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.DataInfoOffset = v_uint16()


class PCI_COMMON_CONFIG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VendorID = v_uint16()
        self.DeviceID = v_uint16()
        self.Command = v_uint16()
        self.Status = v_uint16()
        self.RevisionID = v_uint8()
        self.ProgIf = v_uint8()
        self.SubClass = v_uint8()
        self.BaseClass = v_uint8()
        self.CacheLineSize = v_uint8()
        self.LatencyTimer = v_uint8()
        self.HeaderType = v_uint8()
        self.BIST = v_uint8()
        self.u = _unnamed_14629()
        self.DeviceSpecific = vstruct.VArray([ v_uint8() for i in xrange(192) ])


class IO_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityQos = v_ptr32()
        self.AccessState = v_ptr32()
        self.DesiredAccess = v_uint32()
        self.FullCreateOptions = v_uint32()


class TERMINATION_PORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Port = v_ptr32()


class IO_CLIENT_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextExtension = v_ptr32()
        self.ClientIdentificationAddress = v_ptr32()


class INITIAL_PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(3) ])


class PCI_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Atom = v_uint32()
        self.OldIrql = v_uint8()
        self._pad0008 = v_bytes(size=3)


class POOL_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PoolType = v_uint32()
        self.PoolIndex = v_uint32()
        self.RunningAllocs = v_uint32()
        self.RunningDeAllocs = v_uint32()
        self.TotalPages = v_uint32()
        self.TotalBigPages = v_uint32()
        self.Threshold = v_uint32()
        self.LockAddress = v_ptr32()
        self.PendingFrees = v_ptr32()
        self.PendingFreeDepth = v_uint32()
        self.ListHeads = vstruct.VArray([ LIST_ENTRY() for i in xrange(512) ])


class DBGKD_QUERY_SPECIAL_CALLS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumberOfSpecialCalls = v_uint32()


class HEAP_UNCOMMMTTED_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Address = v_uint32()
        self.Size = v_uint32()
        self.filler = v_uint32()


class HMAP_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BlockAddress = v_uint32()
        self.BinAddress = v_uint32()
        self.CmView = v_ptr32()
        self.MemAlloc = v_uint32()


class DUMP_STACK_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Init = DUMP_INITIALIZATION_CONTEXT()
        self.PartitionOffset = LARGE_INTEGER()
        self.DumpPointers = v_ptr32()
        self.PointersLength = v_uint32()
        self.ModulePrefix = v_ptr32()
        self.DriverList = LIST_ENTRY()
        self.InitMsg = STRING()
        self.ProgMsg = STRING()
        self.DoneMsg = STRING()
        self.FileObject = v_ptr32()
        self.UsageType = v_uint32()
        self._pad00b0 = v_bytes(size=4)


class PNP_DEVICE_EVENT_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.EventQueueMutex = KMUTANT()
        self.Lock = FAST_MUTEX()
        self.List = LIST_ENTRY()


class PROCESSOR_IDLE_TIMES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartTime = v_uint64()
        self.EndTime = v_uint64()
        self.IdleHandlerReserved = vstruct.VArray([ v_uint32() for i in xrange(4) ])


class KWAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitListEntry = LIST_ENTRY()
        self.Thread = v_ptr32()
        self.Object = v_ptr32()
        self.NextWaitBlock = v_ptr32()
        self.WaitKey = v_uint16()
        self.WaitType = v_uint16()


class DBGKD_READ_WRITE_IO32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.IoAddress = v_uint32()
        self.DataValue = v_uint32()


class POP_HIBER_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WriteToFile = v_uint8()
        self.ReserveLoaderMemory = v_uint8()
        self.ReserveFreeMemory = v_uint8()
        self.VerifyOnWake = v_uint8()
        self.Reset = v_uint8()
        self.HiberFlags = v_uint8()
        self.LinkFile = v_uint8()
        self._pad0008 = v_bytes(size=1)
        self.LinkFileHandle = v_ptr32()
        self.Lock = v_uint32()
        self.MapFrozen = v_uint8()
        self._pad0014 = v_bytes(size=3)
        self.MemoryMap = RTL_BITMAP()
        self.ClonedRanges = LIST_ENTRY()
        self.ClonedRangeCount = v_uint32()
        self.NextCloneRange = v_ptr32()
        self.NextPreserve = v_uint32()
        self.LoaderMdl = v_ptr32()
        self.Clones = v_ptr32()
        self.NextClone = v_ptr32()
        self.NoClones = v_uint32()
        self.Spares = v_ptr32()
        self._pad0048 = v_bytes(size=4)
        self.PagesOut = v_uint64()
        self.IoPage = v_ptr32()
        self.CurrentMcb = v_ptr32()
        self.DumpStack = v_ptr32()
        self.WakeState = v_ptr32()
        self.NoRanges = v_uint32()
        self.HiberVa = v_uint32()
        self.HiberPte = LARGE_INTEGER()
        self.Status = v_uint32()
        self.MemoryImage = v_ptr32()
        self.TableHead = v_ptr32()
        self.CompressionWorkspace = v_ptr32()
        self.CompressedWriteBuffer = v_ptr32()
        self.PerformanceStats = v_ptr32()
        self.CompressionBlock = v_ptr32()
        self.DmaIO = v_ptr32()
        self.TemporaryHeap = v_ptr32()
        self._pad0098 = v_bytes(size=4)
        self.PerfInfo = PO_HIBER_PERF()


class _unnamed_16128(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self.SecurityDescriptor = v_ptr32()


class PS_JOB_TOKEN_FILTER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CapturedSidCount = v_uint32()
        self.CapturedSids = v_ptr32()
        self.CapturedSidsLength = v_uint32()
        self.CapturedGroupCount = v_uint32()
        self.CapturedGroups = v_ptr32()
        self.CapturedGroupsLength = v_uint32()
        self.CapturedPrivilegeCount = v_uint32()
        self.CapturedPrivileges = v_ptr32()
        self.CapturedPrivilegesLength = v_uint32()


class CALL_HASH_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.CallersAddress = v_ptr32()
        self.CallersCaller = v_ptr32()
        self.CallCount = v_uint32()


class _unnamed_16125(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self.Length = v_uint32()


class TOKEN_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TokenId = LUID()
        self.AuthenticationId = LUID()
        self.ModifiedId = LUID()
        self.TokenSource = TOKEN_SOURCE()


class _unnamed_16120(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self.InputBufferLength = v_uint32()
        self.IoControlCode = v_uint32()
        self.Type3InputBuffer = v_ptr32()


class _unnamed_16554(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ArbitrationList = v_ptr32()
        self.AllocateFromCount = v_uint32()
        self.AllocateFrom = v_ptr32()


class PCI_COMMON_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.ExtensionType = v_uint32()
        self.IrpDispatchTable = v_ptr32()
        self.DeviceState = v_uint8()
        self.TentativeNextState = v_uint8()
        self._pad0010 = v_bytes(size=2)
        self.SecondaryExtLock = KEVENT()


class HEAP_USERDATA_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SFreeListEntry = SINGLE_LIST_ENTRY()
        self.HeapHandle = v_ptr32()
        self.SizeIndex = v_uint32()
        self.Signature = v_uint32()


class _unnamed_16559(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ArbitrationList = v_ptr32()


class RTL_DRIVE_LETTER_CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint16()
        self.Length = v_uint16()
        self.TimeStamp = v_uint32()
        self.DosPath = STRING()


class ULARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class _unnamed_15734(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_16380()


class _unnamed_15735(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s2 = _unnamed_16385()


class TEB_ACTIVE_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.Previous = v_ptr32()
        self.Context = v_ptr32()


class ETIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.KeTimer = KTIMER()
        self.TimerApc = KAPC()
        self.TimerDpc = KDPC()
        self.ActiveTimerListEntry = LIST_ENTRY()
        self.Lock = v_uint32()
        self.Period = v_uint32()
        self.ApcAssociated = v_uint8()
        self.WakeTimer = v_uint8()
        self._pad008c = v_bytes(size=2)
        self.WakeTimerListEntry = LIST_ENTRY()
        self._pad0098 = v_bytes(size=4)


class GENERAL_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.Allocate = v_ptr32()
        self.Free = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self._pad0080 = v_bytes(size=56)


class PHYSICAL_MEMORY_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumberOfRuns = v_uint32()
        self.NumberOfPages = v_uint32()
        self.Run = vstruct.VArray([ PHYSICAL_MEMORY_RUN() for i in xrange(1) ])


class ARBITER_ORDERING_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint16()
        self.Maximum = v_uint16()
        self.Orderings = v_ptr32()


class OBJECT_DIRECTORY_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ChainLink = v_ptr32()
        self.Object = v_ptr32()


class CM_KEY_HASH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ConvKey = v_uint32()
        self.NextHash = v_ptr32()
        self.KeyHive = v_ptr32()
        self.KeyCell = v_uint32()


class ARBITER_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.AlternativeCount = v_uint32()
        self.Alternatives = v_ptr32()
        self.PhysicalDeviceObject = v_ptr32()
        self.RequestSource = v_uint32()
        self.Flags = v_uint32()
        self.WorkSpace = v_uint32()
        self.InterfaceType = v_uint32()
        self.SlotNumber = v_uint32()
        self.BusNumber = v_uint32()
        self.Assignment = v_ptr32()
        self.SelectedAlternative = v_ptr32()
        self.Result = v_uint32()


class PROCESSOR_PERF_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PercentFrequency = v_uint8()
        self.MinCapacity = v_uint8()
        self.Power = v_uint16()
        self.IncreaseLevel = v_uint8()
        self.DecreaseLevel = v_uint8()
        self.Flags = v_uint16()
        self.IncreaseTime = v_uint32()
        self.DecreaseTime = v_uint32()
        self.IncreaseCount = v_uint32()
        self.DecreaseCount = v_uint32()
        self.PerformanceTime = v_uint64()


class KGDTENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LimitLow = v_uint16()
        self.BaseLow = v_uint16()
        self.HighWord = _unnamed_13092()


class MMPFNENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Modified = v_uint32()


class NT_TIB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_ptr32()
        self.StackBase = v_ptr32()
        self.StackLimit = v_ptr32()
        self.SubSystemTib = v_ptr32()
        self.FiberData = v_ptr32()
        self.ArbitraryUserPointer = v_ptr32()
        self.Self = v_ptr32()


class POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemState = v_uint32()


class UNICODE_STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class CELL_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u = u()


class MMSESSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemSpaceViewLock = FAST_MUTEX()
        self.SystemSpaceViewLockPointer = v_ptr32()
        self.SystemSpaceViewStart = v_ptr32()
        self.SystemSpaceViewTable = v_ptr32()
        self.SystemSpaceHashSize = v_uint32()
        self.SystemSpaceHashEntries = v_uint32()
        self.SystemSpaceHashKey = v_uint32()
        self.SystemSpaceBitMap = v_ptr32()


class _unnamed_16230(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerState = v_uint32()


class _unnamed_16236(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerSequence = v_ptr32()


class PEB_FREE_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Size = v_uint32()


class MMFREE_POOL_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.List = LIST_ENTRY()
        self.Size = v_uint32()
        self.Signature = v_uint32()
        self.Owner = v_ptr32()


class EPROCESS_QUOTA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.QuotaEntry = vstruct.VArray([ EPROCESS_QUOTA_ENTRY() for i in xrange(3) ])
        self.QuotaList = LIST_ENTRY()
        self.ReferenceCount = v_uint32()
        self.ProcessCount = v_uint32()


class FXSAVE_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint16()
        self.StatusWord = v_uint16()
        self.TagWord = v_uint16()
        self.ErrorOpcode = v_uint16()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint32()
        self.MXCsr = v_uint32()
        self.MXCsrMask = v_uint32()
        self.RegisterArea = vstruct.VArray([ v_uint8() for i in xrange(128) ])
        self.Reserved3 = vstruct.VArray([ v_uint8() for i in xrange(128) ])
        self.Reserved4 = vstruct.VArray([ v_uint8() for i in xrange(224) ])
        self.Align16Byte = vstruct.VArray([ v_uint8() for i in xrange(8) ])


class BUS_HANDLER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint32()
        self.InterfaceType = v_uint32()
        self.ConfigurationType = v_uint32()
        self.BusNumber = v_uint32()
        self.DeviceObject = v_ptr32()
        self.ParentHandler = v_ptr32()
        self.BusData = v_ptr32()
        self.DeviceControlExtensionSize = v_uint32()
        self.BusAddresses = v_ptr32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.GetBusData = v_ptr32()
        self.SetBusData = v_ptr32()
        self.AdjustResourceList = v_ptr32()
        self.AssignSlotResources = v_ptr32()
        self.GetInterruptVector = v_ptr32()
        self.TranslateBusAddress = v_ptr32()
        self.Spare1 = v_ptr32()
        self.Spare2 = v_ptr32()
        self.Spare3 = v_ptr32()
        self.Spare4 = v_ptr32()
        self.Spare5 = v_ptr32()
        self.Spare6 = v_ptr32()
        self.Spare7 = v_ptr32()
        self.Spare8 = v_ptr32()


class OBJECT_HEADER_NAME_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Directory = v_ptr32()
        self.Name = UNICODE_STRING()
        self.QueryReferences = v_uint32()


class PEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InheritedAddressSpace = v_uint8()
        self.ReadImageFileExecOptions = v_uint8()
        self.BeingDebugged = v_uint8()
        self.SpareBool = v_uint8()
        self.Mutant = v_ptr32()
        self.ImageBaseAddress = v_ptr32()
        self.Ldr = v_ptr32()
        self.ProcessParameters = v_ptr32()
        self.SubSystemData = v_ptr32()
        self.ProcessHeap = v_ptr32()
        self.FastPebLock = v_ptr32()
        self.FastPebLockRoutine = v_ptr32()
        self.FastPebUnlockRoutine = v_ptr32()
        self.EnvironmentUpdateCount = v_uint32()
        self.KernelCallbackTable = v_ptr32()
        self.SystemReserved = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.AtlThunkSListPtr32 = v_uint32()
        self.FreeList = v_ptr32()
        self.TlsExpansionCounter = v_uint32()
        self.TlsBitmap = v_ptr32()
        self.TlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ReadOnlySharedMemoryBase = v_ptr32()
        self.ReadOnlySharedMemoryHeap = v_ptr32()
        self.ReadOnlyStaticServerData = v_ptr32()
        self.AnsiCodePageData = v_ptr32()
        self.OemCodePageData = v_ptr32()
        self.UnicodeCaseTableData = v_ptr32()
        self.NumberOfProcessors = v_uint32()
        self.NtGlobalFlag = v_uint32()
        self._pad0070 = v_bytes(size=4)
        self.CriticalSectionTimeout = LARGE_INTEGER()
        self.HeapSegmentReserve = v_uint32()
        self.HeapSegmentCommit = v_uint32()
        self.HeapDeCommitTotalFreeThreshold = v_uint32()
        self.HeapDeCommitFreeBlockThreshold = v_uint32()
        self.NumberOfHeaps = v_uint32()
        self.MaximumNumberOfHeaps = v_uint32()
        self.ProcessHeaps = v_ptr32()
        self.GdiSharedHandleTable = v_ptr32()
        self.ProcessStarterHelper = v_ptr32()
        self.GdiDCAttributeList = v_uint32()
        self.LoaderLock = v_ptr32()
        self.OSMajorVersion = v_uint32()
        self.OSMinorVersion = v_uint32()
        self.OSBuildNumber = v_uint16()
        self.OSCSDVersion = v_uint16()
        self.OSPlatformId = v_uint32()
        self.ImageSubsystem = v_uint32()
        self.ImageSubsystemMajorVersion = v_uint32()
        self.ImageSubsystemMinorVersion = v_uint32()
        self.ImageProcessAffinityMask = v_uint32()
        self.GdiHandleBuffer = vstruct.VArray([ v_uint32() for i in xrange(34) ])
        self.PostProcessInitRoutine = v_ptr32()
        self.TlsExpansionBitmap = v_ptr32()
        self.TlsExpansionBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(32) ])
        self.SessionId = v_uint32()
        self.AppCompatFlags = ULARGE_INTEGER()
        self.AppCompatFlagsUser = ULARGE_INTEGER()
        self.pShimData = v_ptr32()
        self.AppCompatInfo = v_ptr32()
        self.CSDVersion = UNICODE_STRING()
        self.ActivationContextData = v_ptr32()
        self.ProcessAssemblyStorageMap = v_ptr32()
        self.SystemDefaultActivationContextData = v_ptr32()
        self.SystemAssemblyStorageMap = v_ptr32()
        self.MinimumStackCommit = v_uint32()
        self._pad0210 = v_bytes(size=4)


class DBGKD_ANY_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.X86ControlSet = X86_DBGKD_CONTROL_SET()
        self._pad001c = v_bytes(size=12)


class MMSUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LastTrimTime = LARGE_INTEGER()
        self.Flags = MMSUPPORT_FLAGS()
        self.PageFaultCount = v_uint32()
        self.PeakWorkingSetSize = v_uint32()
        self.WorkingSetSize = v_uint32()
        self.MinimumWorkingSetSize = v_uint32()
        self.MaximumWorkingSetSize = v_uint32()
        self.VmWorkingSetList = v_ptr32()
        self.WorkingSetExpansionLinks = LIST_ENTRY()
        self.Claim = v_uint32()
        self.NextEstimationSlot = v_uint32()
        self.NextAgingSlot = v_uint32()
        self.EstimatedAvailable = v_uint32()
        self.GrowthSinceLastEstimate = v_uint32()


class HBASE_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Sequence1 = v_uint32()
        self.Sequence2 = v_uint32()
        self.TimeStamp = LARGE_INTEGER()
        self.Major = v_uint32()
        self.Minor = v_uint32()
        self.Type = v_uint32()
        self.Format = v_uint32()
        self.RootCell = v_uint32()
        self.Length = v_uint32()
        self.Cluster = v_uint32()
        self.FileName = vstruct.VArray([ v_uint8() for i in xrange(64) ])
        self.Reserved1 = vstruct.VArray([ v_uint32() for i in xrange(99) ])
        self.CheckSum = v_uint32()
        self.Reserved2 = vstruct.VArray([ v_uint32() for i in xrange(894) ])
        self.BootType = v_uint32()
        self.BootRecover = v_uint32()


class BUS_EXTENSION_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.BusExtension = v_ptr32()


class DBGKD_GET_SET_BUS_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BusDataType = v_uint32()
        self.BusNumber = v_uint32()
        self.SlotNumber = v_uint32()
        self.Offset = v_uint32()
        self.Length = v_uint32()


class KDPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Number = v_uint8()
        self.Importance = v_uint8()
        self.DpcListEntry = LIST_ENTRY()
        self.DeferredRoutine = v_ptr32()
        self.DeferredContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.Lock = v_ptr32()


class KEVENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class KSEMAPHORE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.Limit = v_uint32()


class PCI_ARBITER_INSTANCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = PCI_SECONDARY_EXTENSION()
        self.Interface = v_ptr32()
        self.BusFdoExtension = v_ptr32()
        self.InstanceName = vstruct.VArray([ v_uint16() for i in xrange(24) ])
        self.CommonInstance = ARBITER_INSTANCE()


class PI_RESOURCE_ARBITER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceArbiterList = LIST_ENTRY()
        self.ResourceType = v_uint8()
        self._pad000c = v_bytes(size=3)
        self.ArbiterInterface = v_ptr32()
        self.Level = v_uint32()
        self.ResourceList = LIST_ENTRY()
        self.BestResourceList = LIST_ENTRY()
        self.BestConfig = LIST_ENTRY()
        self.ActiveArbiterList = LIST_ENTRY()
        self.State = v_uint8()
        self.ResourcesChanged = v_uint8()
        self._pad0038 = v_bytes(size=2)


class OBJECT_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mutex = ERESOURCE()
        self.TypeList = LIST_ENTRY()
        self.Name = UNICODE_STRING()
        self.DefaultObject = v_ptr32()
        self.Index = v_uint32()
        self.TotalNumberOfObjects = v_uint32()
        self.TotalNumberOfHandles = v_uint32()
        self.HighWaterNumberOfObjects = v_uint32()
        self.HighWaterNumberOfHandles = v_uint32()
        self.TypeInfo = OBJECT_TYPE_INITIALIZER()
        self.Key = v_uint32()
        self.ObjectLocks = vstruct.VArray([ ERESOURCE() for i in xrange(4) ])


class DBGKD_SET_INTERNAL_BREAKPOINT32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakpointAddress = v_uint32()
        self.Flags = v_uint32()


class POP_THERMAL_ZONE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = LIST_ENTRY()
        self.State = v_uint8()
        self.Flags = v_uint8()
        self.Mode = v_uint8()
        self.PendingMode = v_uint8()
        self.ActivePoint = v_uint8()
        self.PendingActivePoint = v_uint8()
        self._pad0010 = v_bytes(size=2)
        self.Throttle = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.LastTime = v_uint64()
        self.SampleRate = v_uint32()
        self.LastTemp = v_uint32()
        self.PassiveTimer = KTIMER()
        self.PassiveDpc = KDPC()
        self.OverThrottled = POP_ACTION_TRIGGER()
        self.Irp = v_ptr32()
        self.Info = THERMAL_INFORMATION()
        self._pad00d0 = v_bytes(size=4)


class POOL_HACKER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = POOL_HEADER()
        self.Contents = vstruct.VArray([ v_uint32() for i in xrange(8) ])


class HANDLE_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TableCode = v_uint32()
        self.QuotaProcess = v_ptr32()
        self.UniqueProcessId = v_ptr32()
        self.HandleTableLock = vstruct.VArray([ EX_PUSH_LOCK() for i in xrange(4) ])
        self.HandleTableList = LIST_ENTRY()
        self.HandleContentionEvent = EX_PUSH_LOCK()
        self.DebugInfo = v_ptr32()
        self.ExtraInfoPages = v_uint32()
        self.FirstFree = v_uint32()
        self.LastFree = v_uint32()
        self.NextHandleNeedingPool = v_uint32()
        self.HandleCount = v_uint32()
        self.Flags = v_uint32()


class PO_HIBER_PERF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoTicks = v_uint64()
        self.InitTicks = v_uint64()
        self.CopyTicks = v_uint64()
        self.StartCount = v_uint64()
        self.ElapsedTime = v_uint32()
        self.IoTime = v_uint32()
        self.CopyTime = v_uint32()
        self.InitTime = v_uint32()
        self.PagesWritten = v_uint32()
        self.PagesProcessed = v_uint32()
        self.BytesCopied = v_uint32()
        self.DumpCount = v_uint32()
        self.FileRuns = v_uint32()
        self._pad0048 = v_bytes(size=4)


class DEFERRED_WRITE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self.NodeByteSize = v_uint16()
        self.FileObject = v_ptr32()
        self.BytesToWrite = v_uint32()
        self.DeferredWriteLinks = LIST_ENTRY()
        self.Event = v_ptr32()
        self.PostRoutine = v_ptr32()
        self.Context1 = v_ptr32()
        self.Context2 = v_ptr32()
        self.LimitModifiedPages = v_uint8()
        self._pad0028 = v_bytes(size=3)


class ARBITER_INSTANCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.MutexEvent = v_ptr32()
        self.Name = v_ptr32()
        self.ResourceType = v_uint32()
        self.Allocation = v_ptr32()
        self.PossibleAllocation = v_ptr32()
        self.OrderingList = ARBITER_ORDERING_LIST()
        self.ReservedList = ARBITER_ORDERING_LIST()
        self.ReferenceCount = v_uint32()
        self.Interface = v_ptr32()
        self.AllocationStackMaxSize = v_uint32()
        self.AllocationStack = v_ptr32()
        self.UnpackRequirement = v_ptr32()
        self.PackResource = v_ptr32()
        self.UnpackResource = v_ptr32()
        self.ScoreRequirement = v_ptr32()
        self.TestAllocation = v_ptr32()
        self.RetestAllocation = v_ptr32()
        self.CommitAllocation = v_ptr32()
        self.RollbackAllocation = v_ptr32()
        self.BootAllocation = v_ptr32()
        self.QueryArbitrate = v_ptr32()
        self.QueryConflict = v_ptr32()
        self.AddReserved = v_ptr32()
        self.StartArbiter = v_ptr32()
        self.PreprocessEntry = v_ptr32()
        self.AllocateEntry = v_ptr32()
        self.GetNextAllocationRange = v_ptr32()
        self.FindSuitableRange = v_ptr32()
        self.AddAllocation = v_ptr32()
        self.BacktrackAllocation = v_ptr32()
        self.OverrideConflict = v_ptr32()
        self.TransactionInProgress = v_uint8()
        self._pad008c = v_bytes(size=3)
        self.Extension = v_ptr32()
        self.BusDeviceObject = v_ptr32()
        self.ConflictCallbackContext = v_ptr32()
        self.ConflictCallback = v_ptr32()


class MMMOD_WRITER_LISTHEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = LIST_ENTRY()
        self.Event = KEVENT()


class NAMED_PIPE_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NamedPipeType = v_uint32()
        self.ReadMode = v_uint32()
        self.CompletionMode = v_uint32()
        self.MaximumInstances = v_uint32()
        self.InboundQuota = v_uint32()
        self.OutboundQuota = v_uint32()
        self.DefaultTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0028 = v_bytes(size=7)


class POP_IDLE_HANDLER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Latency = v_uint32()
        self.TimeCheck = v_uint32()
        self.DemoteLimit = v_uint32()
        self.PromoteLimit = v_uint32()
        self.PromoteCount = v_uint32()
        self.Demote = v_uint8()
        self.Promote = v_uint8()
        self.PromotePercent = v_uint8()
        self.DemotePercent = v_uint8()
        self.State = v_uint8()
        self.Spare = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.IdleFunction = v_ptr32()


class MMSUPPORT_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SessionSpace = v_uint32()


class HEAP_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = _unnamed_12162()


class EXCEPTION_REGISTRATION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Handler = v_ptr32()


class FILE_BASIC_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0028 = v_bytes(size=4)


class PLUGPLAY_EVENT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EventGuid = GUID()
        self.EventCategory = v_uint32()
        self.Result = v_ptr32()
        self.Flags = v_uint32()
        self.TotalSize = v_uint32()
        self.DeviceObject = v_ptr32()
        self.u = _unnamed_15795()


class LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_ptr32()
        self.Blink = v_ptr32()


class CM_KEY_SECURITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.Reserved = v_uint16()
        self.Flink = v_uint32()
        self.Blink = v_uint32()
        self.ReferenceCount = v_uint32()
        self.DescriptorLength = v_uint32()
        self.Descriptor = SECURITY_DESCRIPTOR_RELATIVE()


class _unnamed_14637(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length = v_uint32()


class _unnamed_14395(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Acquired = v_uint8()
        self.CacheLineSize = v_uint8()
        self.LatencyTimer = v_uint8()
        self.EnablePERR = v_uint8()
        self.EnableSERR = v_uint8()


class CLIENT_ID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_ptr32()
        self.UniqueThread = v_ptr32()


class POP_ACTION_TRIGGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.Flags = v_uint8()
        self.Spare = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.Battery = _unnamed_13534()


class CM_CACHED_VALUE_INDEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CellIndex = v_uint32()
        self.Data = _unnamed_13383()


class DEVICE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DosDevicesDirectory = v_ptr32()
        self.GlobalDosDevicesDirectory = v_ptr32()
        self.ReferenceCount = v_uint32()
        self.DriveMap = v_uint32()
        self.DriveType = vstruct.VArray([ v_uint8() for i in xrange(32) ])


class CONTROL_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Segment = v_ptr32()
        self.DereferenceList = LIST_ENTRY()
        self.NumberOfSectionReferences = v_uint32()
        self.NumberOfPfnReferences = v_uint32()
        self.NumberOfMappedViews = v_uint32()
        self.NumberOfSubsections = v_uint16()
        self.FlushInProgressCount = v_uint16()
        self.NumberOfUserReferences = v_uint32()
        self.u = _unnamed_12520()
        self.FilePointer = v_ptr32()
        self.WaitingForDeletion = v_ptr32()
        self.ModifiedWriteCount = v_uint16()
        self.NumberOfSystemCacheViews = v_uint16()


class GUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data1 = v_uint32()
        self.Data2 = v_uint16()
        self.Data3 = v_uint16()
        self.Data4 = vstruct.VArray([ v_uint8() for i in xrange(8) ])


class KAPC_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ApcListHead = vstruct.VArray([ LIST_ENTRY() for i in xrange(2) ])
        self.Process = v_ptr32()
        self.KernelApcInProgress = v_uint8()
        self.KernelApcPending = v_uint8()
        self.UserApcPending = v_uint8()
        self._pad0018 = v_bytes(size=1)


class MMVAD_SHORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartingVpn = v_uint32()
        self.EndingVpn = v_uint32()
        self.Parent = v_ptr32()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.u = _unnamed_14102()


class DBGKD_GET_VERSION32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.ProtocolVersion = v_uint16()
        self.Flags = v_uint16()
        self.KernBase = v_uint32()
        self.PsLoadedModuleList = v_uint32()
        self.MachineType = v_uint16()
        self.ThCallbackStack = v_uint16()
        self.NextCallback = v_uint16()
        self.FramePointer = v_uint16()
        self.KiCallUserMode = v_uint32()
        self.KeUserCallbackDispatcher = v_uint32()
        self.BreakpointWithStatus = v_uint32()
        self.DebuggerDataList = v_uint32()


class CM_CELL_REMAP_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OldCell = v_uint32()
        self.NewCell = v_uint32()


class _unnamed_14065(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InitialPrivilegeSet = INITIAL_PRIVILEGE_SET()


class KIDTENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint16()
        self.Selector = v_uint16()
        self.Access = v_uint16()
        self.ExtendedOffset = v_uint16()


class _unnamed_16198(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoResourceRequirementList = v_ptr32()


class _unnamed_16195(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Capabilities = v_ptr32()


class _unnamed_14640(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint32()
        self.Vector = v_uint32()
        self.Affinity = v_uint32()


class PO_MEMORY_RANGE_ARRAY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Range = _unnamed_16445()


class _unnamed_14644(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Channel = v_uint32()
        self.Port = v_uint32()
        self.Reserved1 = v_uint32()


class SYSTEM_POWER_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint32()
        self.PowerButton = POWER_ACTION_POLICY()
        self.SleepButton = POWER_ACTION_POLICY()
        self.LidClose = POWER_ACTION_POLICY()
        self.LidOpenWake = v_uint32()
        self.Reserved = v_uint32()
        self.Idle = POWER_ACTION_POLICY()
        self.IdleTimeout = v_uint32()
        self.IdleSensitivity = v_uint8()
        self.DynamicThrottle = v_uint8()
        self.Spare2 = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.MinSleep = v_uint32()
        self.MaxSleep = v_uint32()
        self.ReducedLatencySleep = v_uint32()
        self.WinLogonFlags = v_uint32()
        self.Spare3 = v_uint32()
        self.DozeS4Timeout = v_uint32()
        self.BroadcastCapacityResolution = v_uint32()
        self.DischargePolicy = vstruct.VArray([ SYSTEM_POWER_LEVEL() for i in xrange(4) ])
        self.VideoTimeout = v_uint32()
        self.VideoDimDisplay = v_uint8()
        self._pad00c8 = v_bytes(size=3)
        self.VideoReserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.SpindownTimeout = v_uint32()
        self.OptimizeForPower = v_uint8()
        self.FanThrottleTolerance = v_uint8()
        self.ForcedThrottle = v_uint8()
        self.MinThrottle = v_uint8()
        self.OverThrottled = POWER_ACTION_POLICY()


class IRP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.MdlAddress = v_ptr32()
        self.Flags = v_uint32()
        self.AssociatedIrp = _unnamed_12973()
        self.ThreadListEntry = LIST_ENTRY()
        self.IoStatus = IO_STATUS_BLOCK()
        self.RequestorMode = v_uint8()
        self.PendingReturned = v_uint8()
        self.StackCount = v_uint8()
        self.CurrentLocation = v_uint8()
        self.Cancel = v_uint8()
        self.CancelIrql = v_uint8()
        self.ApcEnvironment = v_uint8()
        self.AllocationFlags = v_uint8()
        self.UserIosb = v_ptr32()
        self.UserEvent = v_ptr32()
        self.Overlay = _unnamed_12976()
        self.CancelRoutine = v_ptr32()
        self.UserBuffer = v_ptr32()
        self.Tail = _unnamed_12979()


class _unnamed_14648(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(3) ])


class _unnamed_16307(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumChannel = v_uint32()
        self.MaximumChannel = v_uint32()


class _unnamed_16081(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileInformationClass = v_uint32()
        self.FileObject = v_ptr32()
        self.ReplaceIfExists = v_uint8()
        self.AdvanceOnly = v_uint8()
        self._pad0010 = v_bytes(size=2)


class POWER_ACTION_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Action = v_uint32()
        self.Flags = v_uint32()
        self.EventCode = v_uint32()


class SECURITY_DESCRIPTOR_RELATIVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.Sbz1 = v_uint8()
        self.Control = v_uint16()
        self.Owner = v_uint32()
        self.Group = v_uint32()
        self.Sacl = v_uint32()
        self.Dacl = v_uint32()


class DUMP_INITIALIZATION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Reserved = v_uint32()
        self.MemoryBlock = v_ptr32()
        self.CommonBuffer = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self._pad0018 = v_bytes(size=4)
        self.PhysicalAddress = vstruct.VArray([ LARGE_INTEGER() for i in xrange(2) ])
        self.StallRoutine = v_ptr32()
        self.OpenRoutine = v_ptr32()
        self.WriteRoutine = v_ptr32()
        self.FinishRoutine = v_ptr32()
        self.AdapterObject = v_ptr32()
        self.MappedRegisterBase = v_ptr32()
        self.PortConfiguration = v_ptr32()
        self.CrashDump = v_uint8()
        self._pad0048 = v_bytes(size=3)
        self.MaximumTransferSize = v_uint32()
        self.CommonBufferSize = v_uint32()
        self.TargetAddress = v_ptr32()
        self.WritePendingRoutine = v_ptr32()
        self.PartitionStyle = v_uint32()
        self.DiskInfo = _unnamed_16505()
        self._pad0070 = v_bytes(size=4)


class FILE_GET_QUOTA_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextEntryOffset = v_uint32()
        self.SidLength = v_uint32()
        self.Sid = SID()


class IO_COMPLETION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = v_ptr32()
        self.Key = v_ptr32()


class _unnamed_16565(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PhysicalDeviceObject = v_ptr32()
        self.ConflictingResource = v_ptr32()
        self.ConflictCount = v_ptr32()
        self.Conflicts = v_ptr32()


class DRIVER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DriverObject = v_ptr32()
        self.AddDevice = v_ptr32()
        self.Count = v_uint32()
        self.ServiceKeyName = UNICODE_STRING()
        self.ClientDriverExtension = v_ptr32()
        self.FsFilterCallbacks = v_ptr32()


class TOKEN_SOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SourceName = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.SourceIdentifier = LUID()


class _unnamed_16561(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedResources = v_ptr32()


class _unnamed_14549(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMid = v_uint32()


class flags(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Removable = v_uint8()


class DBGKM_EXCEPTION64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionRecord = EXCEPTION_RECORD64()
        self.FirstChance = v_uint32()
        self._pad00a0 = v_bytes(size=4)


class _unnamed_14544(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMid = v_uint8()
        self.Flags1 = v_uint8()
        self.Flags2 = v_uint8()
        self.BaseHi = v_uint8()


class PM_SUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Rsvd2 = v_uint8()


class KPRCB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinorVersion = v_uint16()
        self.MajorVersion = v_uint16()
        self.CurrentThread = v_ptr32()
        self.NextThread = v_ptr32()
        self.IdleThread = v_ptr32()
        self.Number = v_uint8()
        self.Reserved = v_uint8()
        self.BuildType = v_uint16()
        self.SetMember = v_uint32()
        self.CpuType = v_uint8()
        self.CpuID = v_uint8()
        self.CpuStep = v_uint16()
        self.ProcessorState = KPROCESSOR_STATE()
        self.KernelReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.HalReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.PrcbPad0 = vstruct.VArray([ v_uint8() for i in xrange(92) ])
        self.LockQueue = vstruct.VArray([ KSPIN_LOCK_QUEUE() for i in xrange(16) ])
        self.PrcbPad1 = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.NpxThread = v_ptr32()
        self.InterruptCount = v_uint32()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.DpcTime = v_uint32()
        self.DebugDpcTime = v_uint32()
        self.InterruptTime = v_uint32()
        self.AdjustDpcThreshold = v_uint32()
        self.PageColor = v_uint32()
        self.SkipTick = v_uint32()
        self.MultiThreadSetBusy = v_uint8()
        self.Spare2 = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.ParentNode = v_ptr32()
        self.MultiThreadProcessorSet = v_uint32()
        self.MultiThreadSetMaster = v_ptr32()
        self.ThreadStartCount = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.CcFastReadNoWait = v_uint32()
        self.CcFastReadWait = v_uint32()
        self.CcFastReadNotPossible = v_uint32()
        self.CcCopyReadNoWait = v_uint32()
        self.CcCopyReadWait = v_uint32()
        self.CcCopyReadNoWaitMiss = v_uint32()
        self.KeAlignmentFixupCount = v_uint32()
        self.KeContextSwitches = v_uint32()
        self.KeDcacheFlushCount = v_uint32()
        self.KeExceptionDispatchCount = v_uint32()
        self.KeFirstLevelTbFills = v_uint32()
        self.KeFloatingEmulationCount = v_uint32()
        self.KeIcacheFlushCount = v_uint32()
        self.KeSecondLevelTbFills = v_uint32()
        self.KeSystemCalls = v_uint32()
        self.SpareCounter0 = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.PPLookasideList = vstruct.VArray([ PP_LOOKASIDE_LIST() for i in xrange(16) ])
        self.PPNPagedLookasideList = vstruct.VArray([ PP_LOOKASIDE_LIST() for i in xrange(32) ])
        self.PPPagedLookasideList = vstruct.VArray([ PP_LOOKASIDE_LIST() for i in xrange(32) ])
        self.PacketBarrier = v_uint32()
        self.ReverseStall = v_uint32()
        self.IpiFrame = v_ptr32()
        self.PrcbPad2 = vstruct.VArray([ v_uint8() for i in xrange(52) ])
        self.CurrentPacket = vstruct.VArray([ v_ptr32() for i in xrange(3) ])
        self.TargetSet = v_uint32()
        self.WorkerRoutine = v_ptr32()
        self.IpiFrozen = v_uint32()
        self.PrcbPad3 = vstruct.VArray([ v_uint8() for i in xrange(40) ])
        self.RequestSummary = v_uint32()
        self.SignalDone = v_ptr32()
        self.PrcbPad4 = vstruct.VArray([ v_uint8() for i in xrange(56) ])
        self.DpcListHead = LIST_ENTRY()
        self.DpcStack = v_ptr32()
        self.DpcCount = v_uint32()
        self.DpcQueueDepth = v_uint32()
        self.DpcRoutineActive = v_uint32()
        self.DpcInterruptRequested = v_uint32()
        self.DpcLastCount = v_uint32()
        self.DpcRequestRate = v_uint32()
        self.MaximumDpcQueueDepth = v_uint32()
        self.MinimumDpcRate = v_uint32()
        self.QuantumEnd = v_uint32()
        self.PrcbPad5 = vstruct.VArray([ v_uint8() for i in xrange(16) ])
        self.DpcLock = v_uint32()
        self.PrcbPad6 = vstruct.VArray([ v_uint8() for i in xrange(28) ])
        self.CallDpc = KDPC()
        self.ChainedInterruptList = v_ptr32()
        self.LookasideIrpFloat = v_uint32()
        self.SpareFields0 = vstruct.VArray([ v_uint32() for i in xrange(6) ])
        self.VendorString = vstruct.VArray([ v_uint8() for i in xrange(13) ])
        self.InitialApicId = v_uint8()
        self.LogicalProcessorsPerPhysicalProcessor = v_uint8()
        self._pad0910 = v_bytes(size=1)
        self.MHz = v_uint32()
        self.FeatureBits = v_uint32()
        self.UpdateSignature = LARGE_INTEGER()
        self.NpxSaveArea = FX_SAVE_AREA()
        self.PowerState = PROCESSOR_POWER_STATE()


class HEAP_VIRTUAL_ALLOC_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = LIST_ENTRY()
        self.ExtraStuff = HEAP_ENTRY_EXTRA()
        self.CommitSize = v_uint32()
        self.ReserveSize = v_uint32()
        self.BusyBlock = HEAP_ENTRY()


class VI_DEADLOCK_THREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Thread = v_ptr32()
        self.CurrentSpinNode = v_ptr32()
        self.CurrentOtherNode = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.NodeCount = v_uint32()
        self.PagingCount = v_uint32()


class SUPPORTED_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.SystemAddressSpace = v_uint32()
        self.SystemBase = v_uint64()
        self.Base = v_uint64()
        self.Limit = v_uint64()


class ARBITER_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parameters = _unnamed_15247()


class EXCEPTION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_ptr32()
        self.ExceptionAddress = v_ptr32()
        self.NumberParameters = v_uint32()
        self.ExceptionInformation = vstruct.VArray([ v_uint32() for i in xrange(15) ])


class MMPTE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u = _unnamed_11597()


class VI_DEADLOCK_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parent = v_ptr32()
        self.ChildrenList = LIST_ENTRY()
        self.SiblingsList = LIST_ENTRY()
        self.ResourceList = LIST_ENTRY()
        self.Root = v_ptr32()
        self.ThreadEntry = v_ptr32()
        self.Active = v_uint32()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(8) ])
        self.ParentStackTrace = vstruct.VArray([ v_ptr32() for i in xrange(8) ])


class KPCR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.SelfPcr = v_ptr32()
        self.Prcb = v_ptr32()
        self.Irql = v_uint8()
        self._pad0028 = v_bytes(size=3)
        self.IRR = v_uint32()
        self.IrrActive = v_uint32()
        self.IDR = v_uint32()
        self.KdVersionBlock = v_ptr32()
        self.IDT = v_ptr32()
        self.GDT = v_ptr32()
        self.TSS = v_ptr32()
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.SetMember = v_uint32()
        self.StallScaleFactor = v_uint32()
        self.DebugActive = v_uint8()
        self.Number = v_uint8()
        self.Spare0 = v_uint8()
        self.SecondLevelCacheAssociativity = v_uint8()
        self.VdmAlert = v_uint32()
        self.KernelReserved = vstruct.VArray([ v_uint32() for i in xrange(14) ])
        self.SecondLevelCacheSize = v_uint32()
        self.HalReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.InterruptMode = v_uint32()
        self.Spare1 = v_uint8()
        self._pad00dc = v_bytes(size=3)
        self.KernelReserved2 = vstruct.VArray([ v_uint32() for i in xrange(17) ])
        self.PrcbData = KPRCB()


class IMAGE_FILE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Machine = v_uint16()
        self.NumberOfSections = v_uint16()
        self.TimeDateStamp = v_uint32()
        self.PointerToSymbolTable = v_uint32()
        self.NumberOfSymbols = v_uint32()
        self.SizeOfOptionalHeader = v_uint16()
        self.Characteristics = v_uint16()


class CM_KEY_INDEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.Count = v_uint16()
        self.List = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class IMAGE_DEBUG_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Characteristics = v_uint32()
        self.TimeDateStamp = v_uint32()
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.Type = v_uint32()
        self.SizeOfData = v_uint32()
        self.AddressOfRawData = v_uint32()
        self.PointerToRawData = v_uint32()


class AMD64_DBGKD_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TraceFlag = v_uint32()
        self.Dr7 = v_uint64()
        self.CurrentSymbolStart = v_uint64()
        self.CurrentSymbolEnd = v_uint64()


class SYSPTES_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = LIST_ENTRY()
        self.Count = v_uint32()


class DBGKD_READ_WRITE_IO_EXTENDED32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.AddressSpace = v_uint32()
        self.IoAddress = v_uint32()
        self.DataValue = v_uint32()


class PEB_LDR_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Initialized = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.SsHandle = v_ptr32()
        self.InLoadOrderModuleList = LIST_ENTRY()
        self.InMemoryOrderModuleList = LIST_ENTRY()
        self.InInitializationOrderModuleList = LIST_ENTRY()
        self.EntryInProgress = v_ptr32()


class DBGKD_WRITE_BREAKPOINT64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakPointAddress = v_uint64()
        self.BreakPointHandle = v_uint32()
        self._pad0010 = v_bytes(size=4)


class IMAGE_NT_HEADERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.FileHeader = IMAGE_FILE_HEADER()
        self.OptionalHeader = IMAGE_OPTIONAL_HEADER()


class HEAP_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.PreviousSize = v_uint16()
        self.SmallTagIndex = v_uint8()
        self.Flags = v_uint8()
        self.UnusedBytes = v_uint8()
        self.SegmentIndex = v_uint8()


class _unnamed_16304(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumVector = v_uint32()
        self.MaximumVector = v_uint32()


class SECURITY_SUBJECT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientToken = v_ptr32()
        self.ImpersonationLevel = v_uint32()
        self.PrimaryToken = v_ptr32()
        self.ProcessAuditId = v_ptr32()


class X86_DBGKD_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TraceFlag = v_uint32()
        self.Dr7 = v_uint32()
        self.CurrentSymbolStart = v_uint32()
        self.CurrentSymbolEnd = v_uint32()


class SEP_AUDIT_POLICY_OVERLAY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PolicyBits = v_uint64()


class MI_VERIFIER_DRIVER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Links = LIST_ENTRY()
        self.Loads = v_uint32()
        self.Unloads = v_uint32()
        self.BaseName = UNICODE_STRING()
        self.StartAddress = v_ptr32()
        self.EndAddress = v_ptr32()
        self.Flags = v_uint32()
        self.Signature = v_uint32()
        self.Reserved = v_uint32()
        self.VerifierPoolLock = v_uint32()
        self.PoolHash = v_ptr32()
        self.PoolHashSize = v_uint32()
        self.PoolHashFree = v_uint32()
        self.PoolHashReserved = v_uint32()
        self.CurrentPagedPoolAllocations = v_uint32()
        self.CurrentNonPagedPoolAllocations = v_uint32()
        self.PeakPagedPoolAllocations = v_uint32()
        self.PeakNonPagedPoolAllocations = v_uint32()
        self.PagedBytes = v_uint32()
        self.NonPagedBytes = v_uint32()
        self.PeakPagedBytes = v_uint32()
        self.PeakNonPagedBytes = v_uint32()


class GDI_TEB_BATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.HDC = v_uint32()
        self.Buffer = vstruct.VArray([ v_uint32() for i in xrange(310) ])


class WMI_CLIENT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProcessorNumber = v_uint8()
        self.Alignment = v_uint8()
        self.LoggerId = v_uint16()


class MMSUBSECTION_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReadOnly = v_uint32()


class INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Context = v_ptr32()
        self.InterfaceReference = v_ptr32()
        self.InterfaceDereference = v_ptr32()


class OBJECT_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashBuckets = vstruct.VArray([ v_ptr32() for i in xrange(37) ])
        self.Lock = EX_PUSH_LOCK()
        self.DeviceMap = v_ptr32()
        self.SessionId = v_uint32()
        self.Reserved = v_uint16()
        self.SymbolicLinkUsageCount = v_uint16()


class WMI_LOGGER_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BufferSpinLock = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.StartTime = LARGE_INTEGER()
        self.LogFileHandle = v_ptr32()
        self.LoggerSemaphore = KSEMAPHORE()
        self.LoggerThread = v_ptr32()
        self.LoggerEvent = KEVENT()
        self.FlushEvent = KEVENT()
        self.LoggerStatus = v_uint32()
        self.LoggerId = v_uint32()
        self.BuffersAvailable = v_uint32()
        self.UsePerfClock = v_uint32()
        self.WriteFailureLimit = v_uint32()
        self.BuffersDirty = v_uint32()
        self.BuffersInUse = v_uint32()
        self.SwitchingInProgress = v_uint32()
        self._pad0070 = v_bytes(size=4)
        self.FreeList = SLIST_HEADER()
        self.FlushList = SLIST_HEADER()
        self.GlobalList = SLIST_HEADER()
        self.ProcessorBuffers = v_ptr32()
        self.LoggerName = UNICODE_STRING()
        self.LogFileName = UNICODE_STRING()
        self.LogFilePattern = UNICODE_STRING()
        self.NewLogFileName = UNICODE_STRING()
        self.EndPageMarker = v_ptr32()
        self.CollectionOn = v_uint32()
        self.KernelTraceOn = v_uint32()
        self.PerfLogInTransition = v_uint32()
        self.RequestFlag = v_uint32()
        self.EnableFlags = v_uint32()
        self.MaximumFileSize = v_uint32()
        self.LoggerMode = v_uint32()
        self.LastFlushedBuffer = v_uint32()
        self.RefCount = v_uint32()
        self.FlushTimer = v_uint32()
        self.FirstBufferOffset = LARGE_INTEGER()
        self.ByteOffset = LARGE_INTEGER()
        self.BufferAgeLimit = LARGE_INTEGER()
        self.MaximumBuffers = v_uint32()
        self.MinimumBuffers = v_uint32()
        self.EventsLost = v_uint32()
        self.BuffersWritten = v_uint32()
        self.LogBuffersLost = v_uint32()
        self.RealTimeBuffersLost = v_uint32()
        self.BufferSize = v_uint32()
        self.NumberOfBuffers = v_uint32()
        self.SequencePtr = v_ptr32()
        self.InstanceGuid = GUID()
        self.LoggerHeader = v_ptr32()
        self.GetCpuClock = v_ptr32()
        self.ClientSecurityContext = SECURITY_CLIENT_CONTEXT()
        self.LoggerExtension = v_ptr32()
        self.ReleaseQueue = v_uint32()
        self.EnableFlagExtension = TRACE_ENABLE_FLAG_EXTENSION()
        self.LocalSequence = v_uint32()
        self.MaximumIrql = v_uint32()
        self.EnableFlagArray = v_ptr32()
        self.LoggerMutex = KMUTANT()
        self.MutexCount = v_uint32()
        self.FileCounter = v_uint32()
        self.BufferCallback = v_ptr32()
        self.CallbackContext = v_ptr32()
        self.PoolType = v_uint32()
        self._pad01b8 = v_bytes(size=4)
        self.ReferenceSystemTime = LARGE_INTEGER()
        self.ReferenceTimeStamp = LARGE_INTEGER()


class IO_STACK_LOCATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorFunction = v_uint8()
        self.MinorFunction = v_uint8()
        self.Flags = v_uint8()
        self.Control = v_uint8()
        self.Parameters = _unnamed_14762()
        self.DeviceObject = v_ptr32()
        self.FileObject = v_ptr32()
        self.CompletionRoutine = v_ptr32()
        self.Context = v_ptr32()


class DBGKD_READ_WRITE_MSR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Msr = v_uint32()
        self.DataValueLow = v_uint32()
        self.DataValueHigh = v_uint32()


class _unnamed_14745(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserApcRoutine = v_ptr32()
        self.UserApcContext = v_ptr32()


class PCI_PDO_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.ExtensionType = v_uint32()
        self.IrpDispatchTable = v_ptr32()
        self.DeviceState = v_uint8()
        self.TentativeNextState = v_uint8()
        self._pad0010 = v_bytes(size=2)
        self.SecondaryExtLock = KEVENT()
        self.Slot = PCI_SLOT_NUMBER()
        self.PhysicalDeviceObject = v_ptr32()
        self.ParentFdoExtension = v_ptr32()
        self.SecondaryExtension = SINGLE_LIST_ENTRY()
        self.BusInterfaceReferenceCount = v_uint32()
        self.AgpInterfaceReferenceCount = v_uint32()
        self.VendorId = v_uint16()
        self.DeviceId = v_uint16()
        self.SubsystemVendorId = v_uint16()
        self.SubsystemId = v_uint16()
        self.RevisionId = v_uint8()
        self.ProgIf = v_uint8()
        self.SubClass = v_uint8()
        self.BaseClass = v_uint8()
        self.AdditionalResourceCount = v_uint8()
        self.AdjustedInterruptLine = v_uint8()
        self.InterruptPin = v_uint8()
        self.RawInterruptLine = v_uint8()
        self.CapabilitiesPtr = v_uint8()
        self.SavedLatencyTimer = v_uint8()
        self.SavedCacheLineSize = v_uint8()
        self.HeaderType = v_uint8()
        self.NotPresent = v_uint8()
        self.ReportedMissing = v_uint8()
        self.ExpectedWritebackFailure = v_uint8()
        self.NoTouchPmeEnable = v_uint8()
        self.LegacyDriver = v_uint8()
        self.UpdateHardware = v_uint8()
        self.MovedDevice = v_uint8()
        self.DisablePowerDown = v_uint8()
        self.NeedsHotPlugConfiguration = v_uint8()
        self.SwitchedIDEToNativeMode = v_uint8()
        self.BIOSAllowsIDESwitchToNativeMode = v_uint8()
        self.IoSpaceUnderNativeIdeControl = v_uint8()
        self.OnDebugPath = v_uint8()
        self._pad005c = v_bytes(size=3)
        self.PowerState = PCI_POWER_STATE()
        self.Dependent = PCI_HEADER_TYPE_DEPENDENT()
        self.HackFlags = v_uint64()
        self.Resources = v_ptr32()
        self.BridgeFdoExtension = v_ptr32()
        self.NextBridge = v_ptr32()
        self.NextHashEntry = v_ptr32()
        self.Lock = PCI_LOCK()
        self.PowerCapabilities = PCI_PMC()
        self.TargetAgpCapabilityId = v_uint8()
        self._pad00c4 = v_bytes(size=1)
        self.CommandEnables = v_uint16()
        self.InitialCommand = v_uint16()


class IMAGE_DATA_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_uint32()
        self.Size = v_uint32()


class FILE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Vpb = v_ptr32()
        self.FsContext = v_ptr32()
        self.FsContext2 = v_ptr32()
        self.SectionObjectPointer = v_ptr32()
        self.PrivateCacheMap = v_ptr32()
        self.FinalStatus = v_uint32()
        self.RelatedFileObject = v_ptr32()
        self.LockOperation = v_uint8()
        self.DeletePending = v_uint8()
        self.ReadAccess = v_uint8()
        self.WriteAccess = v_uint8()
        self.DeleteAccess = v_uint8()
        self.SharedRead = v_uint8()
        self.SharedWrite = v_uint8()
        self.SharedDelete = v_uint8()
        self.Flags = v_uint32()
        self.FileName = UNICODE_STRING()
        self.CurrentByteOffset = LARGE_INTEGER()
        self.Waiters = v_uint32()
        self.Busy = v_uint32()
        self.LastLock = v_ptr32()
        self.Lock = KEVENT()
        self.Event = KEVENT()
        self.CompletionContext = v_ptr32()


class MMWSLE_HASH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Key = v_ptr32()
        self.Index = v_uint32()


class _unnamed_16004(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self.Parameters = v_ptr32()


class SECTION_IMAGE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TransferAddress = v_ptr32()
        self.ZeroBits = v_uint32()
        self.MaximumStackSize = v_uint32()
        self.CommittedStackSize = v_uint32()
        self.SubSystemType = v_uint32()
        self.SubSystemMinorVersion = v_uint16()
        self.SubSystemMajorVersion = v_uint16()
        self.GpValue = v_uint32()
        self.ImageCharacteristics = v_uint16()
        self.DllCharacteristics = v_uint16()
        self.Machine = v_uint16()
        self.ImageContainsCode = v_uint8()
        self.Spare1 = v_uint8()
        self.LoaderFlags = v_uint32()
        self.ImageFileSize = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class HEAP_SUBSEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Bucket = v_ptr32()
        self.UserBlocks = v_ptr32()
        self.AggregateExchg = INTERLOCK_SEQ()
        self.BlockSize = v_uint16()
        self.FreeThreshold = v_uint16()
        self.BlockCount = v_uint16()
        self.SizeIndex = v_uint8()
        self.AffinityIndex = v_uint8()
        self.SFreeListEntry = SINGLE_LIST_ENTRY()
        self.Lock = v_uint32()


class ERESOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemResourcesList = LIST_ENTRY()
        self.OwnerTable = v_ptr32()
        self.ActiveCount = v_uint16()
        self.Flag = v_uint16()
        self.SharedWaiters = v_ptr32()
        self.ExclusiveWaiters = v_ptr32()
        self.OwnerThreads = vstruct.VArray([ OWNER_ENTRY() for i in xrange(2) ])
        self.ContentionCount = v_uint32()
        self.NumberOfSharedWaiters = v_uint16()
        self.NumberOfExclusiveWaiters = v_uint16()
        self.Address = v_ptr32()
        self.SpinLock = v_uint32()


class MBCB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self.NodeIsInZone = v_uint16()
        self.PagesToWrite = v_uint32()
        self.DirtyPages = v_uint32()
        self.Reserved = v_uint32()
        self.BitmapRanges = LIST_ENTRY()
        self.ResumeWritePage = v_uint64()
        self.BitmapRange1 = BITMAP_RANGE()
        self.BitmapRange2 = BITMAP_RANGE()
        self.BitmapRange3 = BITMAP_RANGE()


class RTL_ATOM_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashLink = v_ptr32()
        self.HandleIndex = v_uint16()
        self.Atom = v_uint16()
        self.ReferenceCount = v_uint16()
        self.Flags = v_uint8()
        self.NameLength = v_uint8()
        self.Name = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0010 = v_bytes(size=2)


class _unnamed_12979(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Overlay = _unnamed_14765()
        self._pad0030 = v_bytes(size=8)


class CHILD_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.List = v_uint32()


class _unnamed_16094(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()


class RTL_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint64()
        self.End = v_uint64()
        self.UserData = v_ptr32()
        self.Owner = v_ptr32()
        self.Attributes = v_uint8()
        self.Flags = v_uint8()
        self._pad0020 = v_bytes(size=6)


class PCI_MJ_DISPATCH_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PnpIrpMaximumMinorFunction = v_uint32()
        self.PnpIrpDispatchTable = v_ptr32()
        self.PowerIrpMaximumMinorFunction = v_uint32()
        self.PowerIrpDispatchTable = v_ptr32()
        self.SystemControlIrpDispatchStyle = v_uint32()
        self.SystemControlIrpDispatchFunction = v_ptr32()
        self.OtherIrpDispatchStyle = v_uint32()
        self.OtherIrpDispatchFunction = v_ptr32()


class EX_PUSH_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Waiting = v_uint32()


class ARBITER_INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Context = v_ptr32()
        self.InterfaceReference = v_ptr32()
        self.InterfaceDereference = v_ptr32()
        self.ArbiterHandler = v_ptr32()
        self.Flags = v_uint32()


class SLIST_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Alignment = v_uint64()


class _unnamed_16135(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Srb = v_ptr32()


class _unnamed_16642(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BlockedDriverGuid = GUID()


class _unnamed_16131(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vpb = v_ptr32()
        self.DeviceObject = v_ptr32()


class HEAP_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.Signature = v_uint32()
        self.Flags = v_uint32()
        self.Heap = v_ptr32()
        self.LargestUnCommittedRange = v_uint32()
        self.BaseAddress = v_ptr32()
        self.NumberOfPages = v_uint32()
        self.FirstEntry = v_ptr32()
        self.LastValidEntry = v_ptr32()
        self.NumberOfUnCommittedPages = v_uint32()
        self.NumberOfUnCommittedRanges = v_uint32()
        self.UnCommittedRanges = v_ptr32()
        self.AllocatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self.LastEntryInSegment = v_ptr32()


class POP_DEVICE_POWER_IRP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Free = SINGLE_LIST_ENTRY()
        self.Irp = v_ptr32()
        self.Notify = v_ptr32()
        self.Pending = LIST_ENTRY()
        self.Complete = LIST_ENTRY()
        self.Abort = LIST_ENTRY()
        self.Failed = LIST_ENTRY()


class HEAP_FREE_ENTRY_EXTRA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TagIndex = v_uint16()
        self.FreeBackTraceIndex = v_uint16()


class PRIVATE_CACHE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self._pad0004 = v_bytes(size=2)
        self.ReadAheadMask = v_uint32()
        self.FileObject = v_ptr32()
        self._pad0010 = v_bytes(size=4)
        self.FileOffset1 = LARGE_INTEGER()
        self.BeyondLastByte1 = LARGE_INTEGER()
        self.FileOffset2 = LARGE_INTEGER()
        self.BeyondLastByte2 = LARGE_INTEGER()
        self.ReadAheadOffset = vstruct.VArray([ LARGE_INTEGER() for i in xrange(2) ])
        self.ReadAheadLength = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ReadAheadSpinLock = v_uint32()
        self.PrivateLinks = LIST_ENTRY()
        self._pad0058 = v_bytes(size=4)


class SEP_AUDIT_POLICY_CATEGORIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.System = v_uint32()
        self.AccountLogon = v_uint32()


class IMAGE_SECTION_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.Misc = _unnamed_14793()
        self.VirtualAddress = v_uint32()
        self.SizeOfRawData = v_uint32()
        self.PointerToRawData = v_uint32()
        self.PointerToRelocations = v_uint32()
        self.PointerToLinenumbers = v_uint32()
        self.NumberOfRelocations = v_uint16()
        self.NumberOfLinenumbers = v_uint16()
        self.Characteristics = v_uint32()


class ACL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AclRevision = v_uint8()
        self.Sbz1 = v_uint8()
        self.AclSize = v_uint16()
        self.AceCount = v_uint16()
        self.Sbz2 = v_uint16()


class _unnamed_10498(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class _unnamed_10880(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FnArea = FNSAVE_FORMAT()
        self._pad0208 = v_bytes(size=412)


class VACB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseAddress = v_ptr32()
        self.SharedCacheMap = v_ptr32()
        self.Overlay = _unnamed_11926()
        self.LruList = LIST_ENTRY()


class WAIT_CONTEXT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.DeviceRoutine = v_ptr32()
        self.DeviceContext = v_ptr32()
        self.NumberOfMapRegisters = v_uint32()
        self.DeviceObject = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.BufferChainingDpc = v_ptr32()


class CM_KEY_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.Flags = v_uint16()
        self.LastWriteTime = LARGE_INTEGER()
        self.Spare = v_uint32()
        self.Parent = v_uint32()
        self.SubKeyCounts = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.SubKeyLists = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ValueList = CHILD_LIST()
        self.Security = v_uint32()
        self.Class = v_uint32()
        self.MaxNameLen = v_uint32()
        self.MaxClassLen = v_uint32()
        self.MaxValueNameLen = v_uint32()
        self.MaxValueDataLen = v_uint32()
        self.WorkVar = v_uint32()
        self.NameLength = v_uint16()
        self.ClassLength = v_uint16()
        self.Name = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0050 = v_bytes(size=2)


class SE_AUDIT_PROCESS_CREATION_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImageFileName = v_ptr32()


class ACTIVATION_CONTEXT_STACK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.NextCookieSequenceNumber = v_uint32()
        self.ActiveFrame = v_ptr32()
        self.FrameListCache = LIST_ENTRY()


class SECURITY_TOKEN_PROXY_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.ProxyClass = v_uint32()
        self.PathInfo = UNICODE_STRING()
        self.ContainerMask = v_uint32()
        self.ObjectMask = v_uint32()


class _unnamed_16639(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VetoType = v_uint32()
        self.DeviceIdVetoNameBuffer = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0008 = v_bytes(size=2)


class _unnamed_16636(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationCode = v_uint32()
        self.NotificationData = v_uint32()


class _unnamed_16634(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Notification = v_ptr32()


class EX_RUNDOWN_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()


class _unnamed_16631(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationStructure = v_ptr32()
        self.DeviceIds = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0008 = v_bytes(size=2)


class CM_NOTIFY_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HiveList = LIST_ENTRY()
        self.PostList = LIST_ENTRY()
        self.KeyControlBlock = v_ptr32()
        self.KeyBody = v_ptr32()
        self.Filter = v_uint32()
        self.SubjectContext = SECURITY_SUBJECT_CONTEXT()


class MMPTE_PROTOTYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class PCI_HEADER_TYPE_DEPENDENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.type0 = _unnamed_14410()


class CM_BIG_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.Count = v_uint16()
        self.List = v_uint32()


class IMAGE_DOS_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e_magic = v_uint16()
        self.e_cblp = v_uint16()
        self.e_cp = v_uint16()
        self.e_crlc = v_uint16()
        self.e_cparhdr = v_uint16()
        self.e_minalloc = v_uint16()
        self.e_maxalloc = v_uint16()
        self.e_ss = v_uint16()
        self.e_sp = v_uint16()
        self.e_csum = v_uint16()
        self.e_ip = v_uint16()
        self.e_cs = v_uint16()
        self.e_lfarlc = v_uint16()
        self.e_ovno = v_uint16()
        self.e_res = vstruct.VArray([ v_uint16() for i in xrange(4) ])
        self.e_oemid = v_uint16()
        self.e_oeminfo = v_uint16()
        self.e_res2 = vstruct.VArray([ v_uint16() for i in xrange(10) ])
        self.e_lfanew = v_uint32()


class _unnamed_15795(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceClass = _unnamed_16624()


class DBGKD_FILL_MEMORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_uint64()
        self.Length = v_uint32()
        self.Flags = v_uint16()
        self.PatternLength = v_uint16()


class CM_KEY_SECURITY_CACHE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cell = v_uint32()
        self.CachedSecurity = v_ptr32()


class _unnamed_16663(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.CheckSum = v_uint32()


class _unnamed_16255(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr32()
        self.Argument2 = v_ptr32()
        self.Argument3 = v_ptr32()
        self.Argument4 = v_ptr32()


class _unnamed_12606(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImageInformation = v_ptr32()


class _unnamed_12605(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImageCommitment = v_uint32()


class _unnamed_16226(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InPath = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.Type = v_uint32()


class ARBITER_ORDERING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint64()
        self.End = v_uint64()


class MMVIEW(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = v_uint32()
        self.ControlArea = v_ptr32()


class EXCEPTION_RECORD32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_uint32()
        self.ExceptionAddress = v_uint32()
        self.NumberParameters = v_uint32()
        self.ExceptionInformation = vstruct.VArray([ v_uint32() for i in xrange(15) ])


class DBGKD_READ_MEMORY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TargetBaseAddress = v_uint32()
        self.TransferCount = v_uint32()
        self.ActualBytesRead = v_uint32()


class QUAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DoNotUseThisField = v_uint64()


class _unnamed_11926(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileOffset = LARGE_INTEGER()


class LPCP_PORT_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ConnectionPort = v_ptr32()
        self.ConnectedPort = v_ptr32()
        self.MsgQueue = LPCP_PORT_QUEUE()
        self.Creator = CLIENT_ID()
        self.ClientSectionBase = v_ptr32()
        self.ServerSectionBase = v_ptr32()
        self.PortContext = v_ptr32()
        self.ClientThread = v_ptr32()
        self.SecurityQos = SECURITY_QUALITY_OF_SERVICE()
        self.StaticSecurity = SECURITY_CLIENT_CONTEXT()
        self.LpcReplyChainHead = LIST_ENTRY()
        self.LpcDataInfoChainHead = LIST_ENTRY()
        self.ServerProcess = v_ptr32()
        self.MaxMessageLength = v_uint16()
        self.MaxConnectionInfoLength = v_uint16()
        self.Flags = v_uint32()
        self.WaitEvent = KEVENT()


class CALL_PERFORMANCE_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SpinLock = v_uint32()
        self.HashTable = vstruct.VArray([ LIST_ENTRY() for i in xrange(64) ])


class EXCEPTION_POINTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionRecord = v_ptr32()
        self.ContextRecord = v_ptr32()


class CM_KEY_SECURITY_CACHE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cell = v_uint32()
        self.ConvKey = v_uint32()
        self.List = LIST_ENTRY()
        self.DescriptorLength = v_uint32()
        self.Descriptor = SECURITY_DESCRIPTOR_RELATIVE()


class POP_TRIGGER_WAIT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Event = KEVENT()
        self.Status = v_uint32()
        self.Link = LIST_ENTRY()
        self.Trigger = v_ptr32()


class DEVICE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.ReferenceCount = v_uint32()
        self.DriverObject = v_ptr32()
        self.NextDevice = v_ptr32()
        self.AttachedDevice = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.Timer = v_ptr32()
        self.Flags = v_uint32()
        self.Characteristics = v_uint32()
        self.Vpb = v_ptr32()
        self.DeviceExtension = v_ptr32()
        self.DeviceType = v_uint32()
        self.StackSize = v_uint8()
        self._pad0034 = v_bytes(size=3)
        self.Queue = _unnamed_11075()
        self.AlignmentRequirement = v_uint32()
        self.DeviceQueue = KDEVICE_QUEUE()
        self.Dpc = KDPC()
        self.ActiveThreadCount = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.DeviceLock = KEVENT()
        self.SectorSize = v_uint16()
        self.Spare1 = v_uint16()
        self.DeviceObjectExtension = v_ptr32()
        self.Reserved = v_ptr32()


class MMVAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartingVpn = v_uint32()
        self.EndingVpn = v_uint32()
        self.Parent = v_ptr32()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.u = _unnamed_14102()
        self.ControlArea = v_ptr32()
        self.FirstPrototypePte = v_ptr32()
        self.LastContiguousPte = v_ptr32()
        self.u2 = _unnamed_14103()


class _unnamed_13227(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags = v_uint32()


class CM_NAME_HASH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ConvKey = v_uint32()
        self.NextHash = v_ptr32()
        self.NameLength = v_uint16()
        self.Name = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class EX_PUSH_LOCK_WAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WakeEvent = KEVENT()
        self.Next = v_ptr32()
        self.ShareCount = v_uint32()
        self.Exclusive = v_uint8()
        self._pad001c = v_bytes(size=3)


class _unnamed_13174(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ShortFlags = v_uint16()
        self.ReferenceCount = v_uint16()


class _unnamed_16299(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Alignment = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class LPCP_MESSAGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = LIST_ENTRY()
        self.SenderPort = v_ptr32()
        self.RepliedToThread = v_ptr32()
        self.PortContext = v_ptr32()
        self._pad0018 = v_bytes(size=4)
        self.Request = PORT_MESSAGE()


class EX_QUEUE_WORKER_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.QueueDisabled = v_uint32()


class PCI_FDO_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.List = SINGLE_LIST_ENTRY()
        self.ExtensionType = v_uint32()
        self.IrpDispatchTable = v_ptr32()
        self.DeviceState = v_uint8()
        self.TentativeNextState = v_uint8()
        self._pad0010 = v_bytes(size=2)
        self.SecondaryExtLock = KEVENT()
        self.PhysicalDeviceObject = v_ptr32()
        self.FunctionalDeviceObject = v_ptr32()
        self.AttachedDeviceObject = v_ptr32()
        self.ChildListLock = KEVENT()
        self.ChildPdoList = v_ptr32()
        self.BusRootFdoExtension = v_ptr32()
        self.ParentFdoExtension = v_ptr32()
        self.ChildBridgePdoList = v_ptr32()
        self.PciBusInterface = v_ptr32()
        self.MaxSubordinateBus = v_uint8()
        self._pad0054 = v_bytes(size=3)
        self.BusHandler = v_ptr32()
        self.BaseBus = v_uint8()
        self.Fake = v_uint8()
        self.ChildDelete = v_uint8()
        self.Scanned = v_uint8()
        self.ArbitersInitialized = v_uint8()
        self.BrokenVideoHackApplied = v_uint8()
        self.Hibernated = v_uint8()
        self._pad0060 = v_bytes(size=1)
        self.PowerState = PCI_POWER_STATE()
        self.SecondaryExtension = SINGLE_LIST_ENTRY()
        self.ChildWaitWakeCount = v_uint32()
        self.PreservedConfig = v_ptr32()
        self.Lock = PCI_LOCK()
        self.HotPlugParameters = _unnamed_14395()
        self._pad00bc = v_bytes(size=3)
        self.BusHackFlags = v_uint32()


class _unnamed_16573(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReserveDevice = v_ptr32()


class PS_IMPERSONATION_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Token = v_ptr32()
        self.CopyOnOpen = v_uint8()
        self.EffectiveOnly = v_uint8()
        self._pad0008 = v_bytes(size=2)
        self.ImpersonationLevel = v_uint32()


class DBGKD_WRITE_BREAKPOINT32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakPointAddress = v_uint32()
        self.BreakPointHandle = v_uint32()


class MMPFNLIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Total = v_uint32()
        self.ListName = v_uint32()
        self.Flink = v_uint32()
        self.Blink = v_uint32()


class SINGLE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()


class _unnamed_14410(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Spare = vstruct.VArray([ v_uint8() for i in xrange(4) ])


class _unnamed_14411(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrimaryBus = v_uint8()
        self.SecondaryBus = v_uint8()
        self.SubordinateBus = v_uint8()
        self.SubtractiveDecode = v_uint8()


class KNODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProcessorMask = v_uint32()
        self.Color = v_uint32()
        self.MmShiftedColor = v_uint32()
        self.FreeCount = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self._pad0018 = v_bytes(size=4)
        self.DeadStackList = SLIST_HEADER()
        self.PfnDereferenceSListHead = SLIST_HEADER()
        self.PfnDeferredList = v_ptr32()
        self.Seed = v_uint8()
        self.Flags = flags()
        self._pad0030 = v_bytes(size=2)


class _unnamed_14793(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PhysicalAddress = v_uint32()


class _unnamed_16078(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileInformationClass = v_uint32()


class SYSTEM_POWER_CAPABILITIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerButtonPresent = v_uint8()
        self.SleepButtonPresent = v_uint8()
        self.LidPresent = v_uint8()
        self.SystemS1 = v_uint8()
        self.SystemS2 = v_uint8()
        self.SystemS3 = v_uint8()
        self.SystemS4 = v_uint8()
        self.SystemS5 = v_uint8()
        self.HiberFilePresent = v_uint8()
        self.FullWake = v_uint8()
        self.VideoDimPresent = v_uint8()
        self.ApmPresent = v_uint8()
        self.UpsPresent = v_uint8()
        self.ThermalControl = v_uint8()
        self.ProcessorThrottle = v_uint8()
        self.ProcessorMinThrottle = v_uint8()
        self.ProcessorMaxThrottle = v_uint8()
        self.spare2 = vstruct.VArray([ v_uint8() for i in xrange(4) ])
        self.DiskSpinDown = v_uint8()
        self.spare3 = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.SystemBatteriesPresent = v_uint8()
        self.BatteriesAreShortTerm = v_uint8()
        self.BatteryScale = vstruct.VArray([ BATTERY_REPORTING_SCALE() for i in xrange(3) ])
        self.AcOnLineWake = v_uint32()
        self.SoftLidWake = v_uint32()
        self.RtcWake = v_uint32()
        self.MinDeviceWakeState = v_uint32()
        self.DefaultLowLatencyWake = v_uint32()


class DBGKD_SET_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFlags = v_uint32()


class MMEXTEND_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CommittedSize = v_uint64()
        self.ReferenceCount = v_uint32()
        self._pad0010 = v_bytes(size=4)


class _unnamed_16075(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.CompletionFilter = v_uint32()


class RTL_USER_PROCESS_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MaximumLength = v_uint32()
        self.Length = v_uint32()
        self.Flags = v_uint32()
        self.DebugFlags = v_uint32()
        self.ConsoleHandle = v_ptr32()
        self.ConsoleFlags = v_uint32()
        self.StandardInput = v_ptr32()
        self.StandardOutput = v_ptr32()
        self.StandardError = v_ptr32()
        self.CurrentDirectory = CURDIR()
        self.DllPath = UNICODE_STRING()
        self.ImagePathName = UNICODE_STRING()
        self.CommandLine = UNICODE_STRING()
        self.Environment = v_ptr32()
        self.StartingX = v_uint32()
        self.StartingY = v_uint32()
        self.CountX = v_uint32()
        self.CountY = v_uint32()
        self.CountCharsX = v_uint32()
        self.CountCharsY = v_uint32()
        self.FillAttribute = v_uint32()
        self.WindowFlags = v_uint32()
        self.ShowWindowFlags = v_uint32()
        self.WindowTitle = UNICODE_STRING()
        self.DesktopInfo = UNICODE_STRING()
        self.ShellInfo = UNICODE_STRING()
        self.RuntimeData = UNICODE_STRING()
        self.CurrentDirectores = vstruct.VArray([ RTL_DRIVE_LETTER_CURDIR() for i in xrange(32) ])


class u(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.KeyNode = CM_KEY_NODE()


class IO_RESOURCE_REQUIREMENTS_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.SlotNumber = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.AlternativeLists = v_uint32()
        self.List = vstruct.VArray([ IO_RESOURCE_LIST() for i in xrange(1) ])


class POWER_CHANNEL_SUMMARY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.TotalCount = v_uint32()
        self.D0Count = v_uint32()
        self.NotifyList = LIST_ENTRY()




########NEW FILE########
__FILENAME__ = win32k
# Version: 5.1
# Architecture: i386
import vstruct
from vstruct.primitives import *

DEVICE_RELATION_TYPE = v_enum()
DEVICE_RELATION_TYPE.BusRelations = 0
DEVICE_RELATION_TYPE.EjectionRelations = 1
DEVICE_RELATION_TYPE.PowerRelations = 2
DEVICE_RELATION_TYPE.RemovalRelations = 3
DEVICE_RELATION_TYPE.TargetDeviceRelation = 4
DEVICE_RELATION_TYPE.SingleBusRelations = 5


IO_ALLOCATION_ACTION = v_enum()
IO_ALLOCATION_ACTION.KeepObject = 1
IO_ALLOCATION_ACTION.DeallocateObject = 2
IO_ALLOCATION_ACTION.DeallocateObjectKeepRegisters = 3


BUS_QUERY_ID_TYPE = v_enum()
BUS_QUERY_ID_TYPE.BusQueryDeviceID = 0
BUS_QUERY_ID_TYPE.BusQueryHardwareIDs = 1
BUS_QUERY_ID_TYPE.BusQueryCompatibleIDs = 2
BUS_QUERY_ID_TYPE.BusQueryInstanceID = 3
BUS_QUERY_ID_TYPE.BusQueryDeviceSerialNumber = 4


DEVICE_POWER_STATE = v_enum()
DEVICE_POWER_STATE.PowerDeviceUnspecified = 0
DEVICE_POWER_STATE.PowerDeviceD0 = 1
DEVICE_POWER_STATE.PowerDeviceD1 = 2
DEVICE_POWER_STATE.PowerDeviceD2 = 3
DEVICE_POWER_STATE.PowerDeviceD3 = 4
DEVICE_POWER_STATE.PowerDeviceMaximum = 5


FSINFOCLASS = v_enum()
FSINFOCLASS.FileFsVolumeInformation = 1
FSINFOCLASS.FileFsLabelInformation = 2
FSINFOCLASS.FileFsSizeInformation = 3
FSINFOCLASS.FileFsDeviceInformation = 4
FSINFOCLASS.FileFsAttributeInformation = 5
FSINFOCLASS.FileFsControlInformation = 6
FSINFOCLASS.FileFsFullSizeInformation = 7
FSINFOCLASS.FileFsObjectIdInformation = 8
FSINFOCLASS.FileFsDriverPathInformation = 9
FSINFOCLASS.FileFsMaximumInformation = 10


GDIObjType = v_enum()
GDIObjType.GDIObjType_DEF_TYPE = 0
GDIObjType.GDIObjType_DC_TYPE = 1
GDIObjType.GDIObjType_UNUSED1_TYPE = 2
GDIObjType.GDIObjType_UNUSED2_TYPE = 3
GDIObjType.GDIObjType_RGN_TYPE = 4
GDIObjType.GDIObjType_SURF_TYPE = 5
GDIObjType.GDIObjType_CLIENTOBJ_TYPE = 6
GDIObjType.GDIObjType_PATH_TYPE = 7
GDIObjType.GDIObjType_PAL_TYPE = 8
GDIObjType.GDIObjType_ICMLCS_TYPE = 9
GDIObjType.GDIObjType_LFONT_TYPE = 10
GDIObjType.GDIObjType_RFONT_TYPE = 11
GDIObjType.GDIObjType_PFE_TYPE = 12
GDIObjType.GDIObjType_PFT_TYPE = 13
GDIObjType.GDIObjType_ICMCXF_TYPE = 14
GDIObjType.GDIObjType_SPRITE_TYPE = 15
GDIObjType.GDIObjType_BRUSH_TYPE = 16
GDIObjType.GDIObjType_UMPD_TYPE = 17
GDIObjType.GDIObjType_UNUSED4_TYPE = 18
GDIObjType.GDIObjType_SPACE_TYPE = 19
GDIObjType.GDIObjType_UNUSED5_TYPE = 20
GDIObjType.GDIObjType_META_TYPE = 21
GDIObjType.GDIObjType_EFSTATE_TYPE = 22
GDIObjType.GDIObjType_BMFD_TYPE = 23
GDIObjType.GDIObjType_VTFD_TYPE = 24
GDIObjType.GDIObjType_TTFD_TYPE = 25
GDIObjType.GDIObjType_RC_TYPE = 26
GDIObjType.GDIObjType_TEMP_TYPE = 27
GDIObjType.GDIObjType_DRVOBJ_TYPE = 28
GDIObjType.GDIObjType_DCIOBJ_TYPE = 29
GDIObjType.GDIObjType_SPOOL_TYPE = 30
GDIObjType.GDIObjType_MAX_TYPE = 30
GDIObjType.GDIObjTypeTotal = 31


POOL_TYPE = v_enum()
POOL_TYPE.NonPagedPool = 0
POOL_TYPE.PagedPool = 1
POOL_TYPE.NonPagedPoolMustSucceed = 2
POOL_TYPE.DontUseThisType = 3
POOL_TYPE.NonPagedPoolCacheAligned = 4
POOL_TYPE.PagedPoolCacheAligned = 5
POOL_TYPE.NonPagedPoolCacheAlignedMustS = 6
POOL_TYPE.MaxPoolType = 7
POOL_TYPE.NonPagedPoolSession = 32
POOL_TYPE.PagedPoolSession = 33
POOL_TYPE.NonPagedPoolMustSucceedSession = 34
POOL_TYPE.DontUseThisTypeSession = 35
POOL_TYPE.NonPagedPoolCacheAlignedSession = 36
POOL_TYPE.PagedPoolCacheAlignedSession = 37
POOL_TYPE.NonPagedPoolCacheAlignedMustSSession = 38


MODE = v_enum()
MODE.KernelMode = 0
MODE.UserMode = 1
MODE.MaximumMode = 2


OB_OPEN_REASON = v_enum()
OB_OPEN_REASON.ObCreateHandle = 0
OB_OPEN_REASON.ObOpenHandle = 1
OB_OPEN_REASON.ObDuplicateHandle = 2
OB_OPEN_REASON.ObInheritHandle = 3
OB_OPEN_REASON.ObMaxOpenReason = 4


DEVICE_TEXT_TYPE = v_enum()
DEVICE_TEXT_TYPE.DeviceTextDescription = 0
DEVICE_TEXT_TYPE.DeviceTextLocationInformation = 1


POWER_STATE_TYPE = v_enum()
POWER_STATE_TYPE.SystemPowerState = 0
POWER_STATE_TYPE.DevicePowerState = 1


FILE_INFORMATION_CLASS = v_enum()
FILE_INFORMATION_CLASS.FileDirectoryInformation = 1
FILE_INFORMATION_CLASS.FileFullDirectoryInformation = 2
FILE_INFORMATION_CLASS.FileBothDirectoryInformation = 3
FILE_INFORMATION_CLASS.FileBasicInformation = 4
FILE_INFORMATION_CLASS.FileStandardInformation = 5
FILE_INFORMATION_CLASS.FileInternalInformation = 6
FILE_INFORMATION_CLASS.FileEaInformation = 7
FILE_INFORMATION_CLASS.FileAccessInformation = 8
FILE_INFORMATION_CLASS.FileNameInformation = 9
FILE_INFORMATION_CLASS.FileRenameInformation = 10
FILE_INFORMATION_CLASS.FileLinkInformation = 11
FILE_INFORMATION_CLASS.FileNamesInformation = 12
FILE_INFORMATION_CLASS.FileDispositionInformation = 13
FILE_INFORMATION_CLASS.FilePositionInformation = 14
FILE_INFORMATION_CLASS.FileFullEaInformation = 15
FILE_INFORMATION_CLASS.FileModeInformation = 16
FILE_INFORMATION_CLASS.FileAlignmentInformation = 17
FILE_INFORMATION_CLASS.FileAllInformation = 18
FILE_INFORMATION_CLASS.FileAllocationInformation = 19
FILE_INFORMATION_CLASS.FileEndOfFileInformation = 20
FILE_INFORMATION_CLASS.FileAlternateNameInformation = 21
FILE_INFORMATION_CLASS.FileStreamInformation = 22
FILE_INFORMATION_CLASS.FilePipeInformation = 23
FILE_INFORMATION_CLASS.FilePipeLocalInformation = 24
FILE_INFORMATION_CLASS.FilePipeRemoteInformation = 25
FILE_INFORMATION_CLASS.FileMailslotQueryInformation = 26
FILE_INFORMATION_CLASS.FileMailslotSetInformation = 27
FILE_INFORMATION_CLASS.FileCompressionInformation = 28
FILE_INFORMATION_CLASS.FileObjectIdInformation = 29
FILE_INFORMATION_CLASS.FileCompletionInformation = 30
FILE_INFORMATION_CLASS.FileMoveClusterInformation = 31
FILE_INFORMATION_CLASS.FileQuotaInformation = 32
FILE_INFORMATION_CLASS.FileReparsePointInformation = 33
FILE_INFORMATION_CLASS.FileNetworkOpenInformation = 34
FILE_INFORMATION_CLASS.FileAttributeTagInformation = 35
FILE_INFORMATION_CLASS.FileTrackingInformation = 36
FILE_INFORMATION_CLASS.FileIdBothDirectoryInformation = 37
FILE_INFORMATION_CLASS.FileIdFullDirectoryInformation = 38
FILE_INFORMATION_CLASS.FileValidDataLengthInformation = 39
FILE_INFORMATION_CLASS.FileShortNameInformation = 40
FILE_INFORMATION_CLASS.FileMaximumInformation = 41


GDILoObjType = v_enum()
GDILoObjType.GDILoObjType_LO_BRUSH_TYPE = 1048576
GDILoObjType.GDILoObjType_LO_DC_TYPE = 65536
GDILoObjType.GDILoObjType_LO_BITMAP_TYPE = 327680
GDILoObjType.GDILoObjType_LO_PALETTE_TYPE = 524288
GDILoObjType.GDILoObjType_LO_FONT_TYPE = 655360
GDILoObjType.GDILoObjType_LO_REGION_TYPE = 262144
GDILoObjType.GDILoObjType_LO_ICMLCS_TYPE = 589824
GDILoObjType.GDILoObjType_LO_CLIENTOBJ_TYPE = 393216
GDILoObjType.GDILoObjType_LO_ALTDC_TYPE = 2162688
GDILoObjType.GDILoObjType_LO_PEN_TYPE = 3145728
GDILoObjType.GDILoObjType_LO_EXTPEN_TYPE = 5242880
GDILoObjType.GDILoObjType_LO_DIBSECTION_TYPE = 2424832
GDILoObjType.GDILoObjType_LO_METAFILE16_TYPE = 2490368
GDILoObjType.GDILoObjType_LO_METAFILE_TYPE = 4587520
GDILoObjType.GDILoObjType_LO_METADC16_TYPE = 6684672


SECURITY_OPERATION_CODE = v_enum()
SECURITY_OPERATION_CODE.SetSecurityDescriptor = 0
SECURITY_OPERATION_CODE.QuerySecurityDescriptor = 1
SECURITY_OPERATION_CODE.DeleteSecurityDescriptor = 2
SECURITY_OPERATION_CODE.AssignSecurityDescriptor = 3


SECURITY_IMPERSONATION_LEVEL = v_enum()
SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous = 0
SECURITY_IMPERSONATION_LEVEL.SecurityIdentification = 1
SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation = 2
SECURITY_IMPERSONATION_LEVEL.SecurityDelegation = 3


DEVICE_USAGE_NOTIFICATION_TYPE = v_enum()
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeUndefined = 0
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypePaging = 1
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeHibernation = 2
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeDumpFile = 3


INTERFACE_TYPE = v_enum()
INTERFACE_TYPE.InterfaceTypeUndefined = -1
INTERFACE_TYPE.Internal = 0
INTERFACE_TYPE.Isa = 1
INTERFACE_TYPE.Eisa = 2
INTERFACE_TYPE.MicroChannel = 3
INTERFACE_TYPE.TurboChannel = 4
INTERFACE_TYPE.PCIBus = 5
INTERFACE_TYPE.VMEBus = 6
INTERFACE_TYPE.NuBus = 7
INTERFACE_TYPE.PCMCIABus = 8
INTERFACE_TYPE.CBus = 9
INTERFACE_TYPE.MPIBus = 10
INTERFACE_TYPE.MPSABus = 11
INTERFACE_TYPE.ProcessorInternal = 12
INTERFACE_TYPE.InternalPowerBus = 13
INTERFACE_TYPE.PNPISABus = 14
INTERFACE_TYPE.PNPBus = 15
INTERFACE_TYPE.MaximumInterfaceType = 16


MEMORY_TYPE = v_enum()
MEMORY_TYPE.MemoryExceptionBlock = 0
MEMORY_TYPE.MemorySystemBlock = 1
MEMORY_TYPE.MemoryFree = 2
MEMORY_TYPE.MemoryBad = 3
MEMORY_TYPE.MemoryLoadedProgram = 4
MEMORY_TYPE.MemoryFirmwareTemporary = 5
MEMORY_TYPE.MemoryFirmwarePermanent = 6
MEMORY_TYPE.MemoryFreeContiguous = 7
MEMORY_TYPE.MemorySpecialMemory = 8
MEMORY_TYPE.MemoryMaximum = 9


ReplacesCorHdrNumericDefines = v_enum()
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY = 1
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED = 2
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY = 4
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED = 8
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2 = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MINOR = 0
ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB = 1
ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA = 1
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA = 2
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT = 1
ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT = 2
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED = 4
ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED = 16
ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE = 32
ReplacesCorHdrNumericDefines.MAX_CLASS_NAME = 1024
ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME = 1024


SYSTEM_POWER_STATE = v_enum()
SYSTEM_POWER_STATE.PowerSystemUnspecified = 0
SYSTEM_POWER_STATE.PowerSystemWorking = 1
SYSTEM_POWER_STATE.PowerSystemSleeping1 = 2
SYSTEM_POWER_STATE.PowerSystemSleeping2 = 3
SYSTEM_POWER_STATE.PowerSystemSleeping3 = 4
SYSTEM_POWER_STATE.PowerSystemHibernate = 5
SYSTEM_POWER_STATE.PowerSystemShutdown = 6
SYSTEM_POWER_STATE.PowerSystemMaximum = 7


MEMORY_CACHING_TYPE_ORIG = v_enum()
MEMORY_CACHING_TYPE_ORIG.MmFrameBufferCached = 2


POWER_ACTION = v_enum()
POWER_ACTION.PowerActionNone = 0
POWER_ACTION.PowerActionReserved = 1
POWER_ACTION.PowerActionSleep = 2
POWER_ACTION.PowerActionHibernate = 3
POWER_ACTION.PowerActionShutdown = 4
POWER_ACTION.PowerActionShutdownReset = 5
POWER_ACTION.PowerActionShutdownOff = 6
POWER_ACTION.PowerActionWarmEject = 7


class OBJECT_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.RootDirectory = v_ptr32()
        self.ObjectName = v_ptr32()
        self.Attributes = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.SecurityQualityOfService = v_ptr32()


class SECURITY_SUBJECT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientToken = v_ptr32()
        self.ImpersonationLevel = v_uint32()
        self.PrimaryToken = v_ptr32()
        self.ProcessAuditId = v_ptr32()


class CM_FULL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.PartialResourceList = CM_PARTIAL_RESOURCE_LIST()


class FAST_IO_DISPATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFastIoDispatch = v_uint32()
        self.FastIoCheckIfPossible = v_ptr32()
        self.FastIoRead = v_ptr32()
        self.FastIoWrite = v_ptr32()
        self.FastIoQueryBasicInfo = v_ptr32()
        self.FastIoQueryStandardInfo = v_ptr32()
        self.FastIoLock = v_ptr32()
        self.FastIoUnlockSingle = v_ptr32()
        self.FastIoUnlockAll = v_ptr32()
        self.FastIoUnlockAllByKey = v_ptr32()
        self.FastIoDeviceControl = v_ptr32()
        self.AcquireFileForNtCreateSection = v_ptr32()
        self.ReleaseFileForNtCreateSection = v_ptr32()
        self.FastIoDetachDevice = v_ptr32()
        self.FastIoQueryNetworkOpenInfo = v_ptr32()
        self.AcquireForModWrite = v_ptr32()
        self.MdlRead = v_ptr32()
        self.MdlReadComplete = v_ptr32()
        self.PrepareMdlWrite = v_ptr32()
        self.MdlWriteComplete = v_ptr32()
        self.FastIoReadCompressed = v_ptr32()
        self.FastIoWriteCompressed = v_ptr32()
        self.MdlReadCompleteCompressed = v_ptr32()
        self.MdlWriteCompleteCompressed = v_ptr32()
        self.FastIoQueryOpen = v_ptr32()
        self.ReleaseForModWrite = v_ptr32()
        self.AcquireForCcFlush = v_ptr32()
        self.ReleaseForCcFlush = v_ptr32()


class ACCESS_STATE::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InitialPrivilegeSet = INITIAL_PRIVILEGE_SET()


class LARGE_INTEGER::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class IMAGE_FILE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Machine = v_uint16()
        self.NumberOfSections = v_uint16()
        self.TimeDateStamp = v_uint32()
        self.PointerToSymbolTable = v_uint32()
        self.NumberOfSymbols = v_uint32()
        self.SizeOfOptionalHeader = v_uint16()
        self.Characteristics = v_uint16()


class IO_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Option = v_uint8()
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Spare1 = v_uint8()
        self.Flags = v_uint16()
        self.Spare2 = v_uint16()
        self.u = IO_RESOURCE_DESCRIPTOR::__unnamed()


class EX_PUSH_LOCK_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locks = vstruct.VArray([ v_ptr32() for i in xrange(1) ])


class EX_PUSH_LOCK::__unnamed::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Waiting = v_uint32()


class IMAGE_NT_HEADERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.FileHeader = IMAGE_FILE_HEADER()
        self.OptionalHeader = IMAGE_OPTIONAL_HEADER()


class IMAGE_OPTIONAL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint16()
        self.MajorLinkerVersion = v_uint8()
        self.MinorLinkerVersion = v_uint8()
        self.SizeOfCode = v_uint32()
        self.SizeOfInitializedData = v_uint32()
        self.SizeOfUninitializedData = v_uint32()
        self.AddressOfEntryPoint = v_uint32()
        self.BaseOfCode = v_uint32()
        self.BaseOfData = v_uint32()
        self.ImageBase = v_uint32()
        self.SectionAlignment = v_uint32()
        self.FileAlignment = v_uint32()
        self.MajorOperatingSystemVersion = v_uint16()
        self.MinorOperatingSystemVersion = v_uint16()
        self.MajorImageVersion = v_uint16()
        self.MinorImageVersion = v_uint16()
        self.MajorSubsystemVersion = v_uint16()
        self.MinorSubsystemVersion = v_uint16()
        self.Win32VersionValue = v_uint32()
        self.SizeOfImage = v_uint32()
        self.SizeOfHeaders = v_uint32()
        self.CheckSum = v_uint32()
        self.Subsystem = v_uint16()
        self.DllCharacteristics = v_uint16()
        self.SizeOfStackReserve = v_uint32()
        self.SizeOfStackCommit = v_uint32()
        self.SizeOfHeapReserve = v_uint32()
        self.SizeOfHeapCommit = v_uint32()
        self.LoaderFlags = v_uint32()
        self.NumberOfRvaAndSizes = v_uint32()
        self.DataDirectory = vstruct.VArray([ IMAGE_DATA_DIRECTORY() for i in xrange(16) ])


class OWNER_ENTRY::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerCount = v_uint32()


class ETHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class FAST_MUTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Owner = v_ptr32()
        self.Contention = v_uint32()
        self.Event = KEVENT()
        self.OldIrql = v_uint32()


class VPB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.Flags = v_uint16()
        self.VolumeLabelLength = v_uint16()
        self.DeviceObject = v_ptr32()
        self.RealDevice = v_ptr32()
        self.SerialNumber = v_uint32()
        self.ReferenceCount = v_uint32()
        self.VolumeLabel = vstruct.VArray([ v_uint16() for i in xrange(32) ])


class IO_RESOURCE_DESCRIPTOR::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = IO_RESOURCE_DESCRIPTOR::__unnamed::__unnamed()


class tagWin32AllocStats(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwMaxMem = v_uint32()
        self.dwCrtMem = v_uint32()
        self.dwMaxAlloc = v_uint32()
        self.dwCrtAlloc = v_uint32()
        self.pHead = v_ptr32()


class KDEVICE_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceListHead = LIST_ENTRY()
        self.Lock = v_uint32()
        self.Busy = v_uint8()
        self._pad0014 = v_bytes(size=3)


class ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.einfo = EINFO()
        self.ObjectOwner = OBJECTOWNER()
        self.FullUnique = v_uint16()
        self.Objt = v_uint8()
        self.Flags = v_uint8()
        self.pUser = v_ptr32()


class IRP::__unnamed::__unnamed::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.CurrentStackLocation = v_ptr32()


class CM_PARTIAL_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.PartialDescriptors = vstruct.VArray([ CM_PARTIAL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class IO_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityQos = v_ptr32()
        self.AccessState = v_ptr32()
        self.DesiredAccess = v_uint32()
        self.FullCreateOptions = v_uint32()


class LUID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Luid = LUID()
        self.Attributes = v_uint32()


class IRP::__unnamed::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.Thread = v_ptr32()
        self.AuxiliaryBuffer = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.CurrentStackLocation = v_ptr32()
        self.OriginalFileObject = v_ptr32()


class DEVICE_CAPABILITIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.DeviceD1 = v_uint32()
        self.Address = v_uint32()
        self.UINumber = v_uint32()
        self.DeviceState = vstruct.VArray([ DEVICE_POWER_STATE() for i in xrange(7) ])
        self.SystemWake = v_uint32()
        self.DeviceWake = v_uint32()
        self.D1Latency = v_uint32()
        self.D2Latency = v_uint32()
        self.D3Latency = v_uint32()


class INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Context = v_ptr32()
        self.InterfaceReference = v_ptr32()
        self.InterfaceDereference = v_ptr32()


class SLIST_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Alignment = v_uint64()


class KTHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class IO_STACK_LOCATION::__unnamed::__unnamed::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReplaceIfExists = v_uint8()
        self.AdvanceOnly = v_uint8()
        self._pad0004 = v_bytes(size=2)


class IO_STATUS_BLOCK::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()


class IMAGE_DATA_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_uint32()
        self.Size = v_uint32()


class FILE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Vpb = v_ptr32()
        self.FsContext = v_ptr32()
        self.FsContext2 = v_ptr32()
        self.SectionObjectPointer = v_ptr32()
        self.PrivateCacheMap = v_ptr32()
        self.FinalStatus = v_uint32()
        self.RelatedFileObject = v_ptr32()
        self.LockOperation = v_uint8()
        self.DeletePending = v_uint8()
        self.ReadAccess = v_uint8()
        self.WriteAccess = v_uint8()
        self.DeleteAccess = v_uint8()
        self.SharedRead = v_uint8()
        self.SharedWrite = v_uint8()
        self.SharedDelete = v_uint8()
        self.Flags = v_uint32()
        self.FileName = UNICODE_STRING()
        self.CurrentByteOffset = LARGE_INTEGER()
        self.Waiters = v_uint32()
        self.Busy = v_uint32()
        self.LastLock = v_ptr32()
        self.Lock = KEVENT()
        self.Event = KEVENT()
        self.CompletionContext = v_ptr32()


class ERESOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemResourcesList = LIST_ENTRY()
        self.OwnerTable = v_ptr32()
        self.ActiveCount = v_uint16()
        self.Flag = v_uint16()
        self.SharedWaiters = v_ptr32()
        self.ExclusiveWaiters = v_ptr32()
        self.OwnerThreads = vstruct.VArray([ OWNER_ENTRY() for i in xrange(2) ])
        self.ContentionCount = v_uint32()
        self.NumberOfSharedWaiters = v_uint16()
        self.NumberOfExclusiveWaiters = v_uint16()
        self.Address = v_ptr32()
        self.SpinLock = v_uint32()


class FILE_NETWORK_OPEN_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0038 = v_bytes(size=4)


class GENERAL_LOOKASIDE::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LastAllocateMisses = v_uint32()


class OBJECTOWNER_S(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint32()


class OBJECT_HANDLE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleAttributes = v_uint32()
        self.GrantedAccess = v_uint32()


class IRP::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Overlay = IRP::__unnamed::__unnamed()
        self._pad0030 = v_bytes(size=8)


class INITIAL_PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(3) ])


class ULARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class GENERAL_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.Allocate = v_ptr32()
        self.Free = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])


class EX_PUSH_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Waiting = v_uint32()


class CM_PARTIAL_RESOURCE_DESCRIPTOR::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Generic = CM_PARTIAL_RESOURCE_DESCRIPTOR::__unnamed::__unnamed()


class SECTION_OBJECT_POINTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSectionObject = v_ptr32()
        self.SharedCacheMap = v_ptr32()
        self.ImageSectionObject = v_ptr32()


class DEVOBJ_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()


class tagVSTATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.fl = v_uint32()
        self.bSystemStable = v_uint32()
        self.ulRandomSeed = v_uint32()
        self.ulFailureMask = v_uint32()
        self.ulDebugLevel = v_uint32()
        self.hsemPoolTracker = v_ptr32()
        self.lePoolTrackerHead = LIST_ENTRY()


class EX_RUNDOWN_REF::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()


class POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemState = v_uint32()


class UNICODE_STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class GDIHandleBitFields(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Index = v_uint32()


class ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OperationID = LUID()
        self.SecurityEvaluated = v_uint8()
        self.GenerateAudit = v_uint8()
        self.GenerateOnClose = v_uint8()
        self.PrivilegesAllocated = v_uint8()
        self.Flags = v_uint32()
        self.RemainingDesiredAccess = v_uint32()
        self.PreviouslyGrantedAccess = v_uint32()
        self.OriginalDesiredAccess = v_uint32()
        self.SubjectSecurityContext = SECURITY_SUBJECT_CONTEXT()
        self.SecurityDescriptor = v_ptr32()
        self.AuxData = v_ptr32()
        self.Privileges = ACCESS_STATE::__unnamed()
        self.AuditPrivileges = v_uint8()
        self._pad0064 = v_bytes(size=3)
        self.ObjectName = UNICODE_STRING()
        self.ObjectTypeName = UNICODE_STRING()


class FILE_STANDARD_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.NumberOfLinks = v_uint32()
        self.DeletePending = v_uint8()
        self.Directory = v_uint8()
        self._pad0018 = v_bytes(size=2)


class KAPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.Spare0 = v_uint32()
        self.Thread = v_ptr32()
        self.ApcListEntry = LIST_ENTRY()
        self.KernelRoutine = v_ptr32()
        self.RundownRoutine = v_ptr32()
        self.NormalRoutine = v_ptr32()
        self.NormalContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.ApcStateIndex = v_uint8()
        self.ApcMode = v_uint8()
        self.Inserted = v_uint8()
        self._pad0030 = v_bytes(size=1)


class WAIT_CONTEXT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.DeviceRoutine = v_ptr32()
        self.DeviceContext = v_ptr32()
        self.NumberOfMapRegisters = v_uint32()
        self.DeviceObject = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.BufferChainingDpc = v_ptr32()


class EX_PUSH_LOCK::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Waiting = v_uint32()


class MDL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Size = v_uint16()
        self.MdlFlags = v_uint16()
        self.Process = v_ptr32()
        self.MappedSystemVa = v_ptr32()
        self.StartVa = v_ptr32()
        self.ByteCount = v_uint32()
        self.ByteOffset = v_uint32()


class EX_RUNDOWN_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()


class W32THREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pEThread = v_ptr32()
        self.RefCount = v_uint32()
        self.ptlW32 = v_ptr32()
        self.pgdiDcattr = v_ptr32()
        self.pgdiBrushAttr = v_ptr32()
        self.pUMPDObjs = v_ptr32()
        self.pUMPDHeap = v_ptr32()
        self.dwEngAcquireCount = v_uint32()
        self.pSemTable = v_ptr32()
        self.pUMPDObj = v_ptr32()


class KDPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Number = v_uint8()
        self.Importance = v_uint8()
        self.DpcListEntry = LIST_ENTRY()
        self.DeferredRoutine = v_ptr32()
        self.DeferredContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.Lock = v_ptr32()


class OWNER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerThread = v_uint32()
        self.OwnerCount = v_uint32()


class KEVENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class KSEMAPHORE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.Limit = v_uint32()


class PAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = FAST_MUTEX()


class OBJECT_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mutex = ERESOURCE()
        self.TypeList = LIST_ENTRY()
        self.Name = UNICODE_STRING()
        self.DefaultObject = v_ptr32()
        self.Index = v_uint32()
        self.TotalNumberOfObjects = v_uint32()
        self.TotalNumberOfHandles = v_uint32()
        self.HighWaterNumberOfObjects = v_uint32()
        self.HighWaterNumberOfHandles = v_uint32()
        self.TypeInfo = OBJECT_TYPE_INITIALIZER()
        self.Key = v_uint32()
        self.ObjectLocks = vstruct.VArray([ ERESOURCE() for i in xrange(4) ])


class DEVICE_OBJECT::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self._pad0028 = v_bytes(size=32)


class DISPATCHER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.Absolute = v_uint8()
        self.Size = v_uint8()
        self.Inserted = v_uint8()
        self.SignalState = v_uint32()
        self.WaitListHead = LIST_ENTRY()


class IRP::__unnamed::__unnamed::__unnamed::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CurrentStackLocation = v_ptr32()


class HOBJ(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class IO_TIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class OBJECT_TYPE_INITIALIZER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.UseDefaultObject = v_uint8()
        self.CaseInsensitive = v_uint8()
        self.InvalidAttributes = v_uint32()
        self.GenericMapping = GENERIC_MAPPING()
        self.ValidAccessMask = v_uint32()
        self.SecurityRequired = v_uint8()
        self.MaintainHandleCount = v_uint8()
        self.MaintainTypeList = v_uint8()
        self._pad0020 = v_bytes(size=1)
        self.PoolType = v_uint32()
        self.DefaultPagedPoolCharge = v_uint32()
        self.DefaultNonPagedPoolCharge = v_uint32()
        self.DumpProcedure = v_ptr32()
        self.OpenProcedure = v_ptr32()
        self.CloseProcedure = v_ptr32()
        self.DeleteProcedure = v_ptr32()
        self.ParseProcedure = v_ptr32()
        self.SecurityProcedure = v_ptr32()
        self.QueryNameProcedure = v_ptr32()
        self.OkayToCloseProcedure = v_ptr32()


class SCSI_REQUEST_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class IO_STACK_LOCATION::__unnamed::__unnamed::__unnamed::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReplaceIfExists = v_uint8()
        self.AdvanceOnly = v_uint8()


class FILE_BASIC_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0028 = v_bytes(size=4)


class DEVICE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.ReferenceCount = v_uint32()
        self.DriverObject = v_ptr32()
        self.NextDevice = v_ptr32()
        self.AttachedDevice = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.Timer = v_ptr32()
        self.Flags = v_uint32()
        self.Characteristics = v_uint32()
        self.Vpb = v_ptr32()
        self.DeviceExtension = v_ptr32()
        self.DeviceType = v_uint32()
        self.StackSize = v_uint8()
        self._pad0034 = v_bytes(size=3)
        self.Queue = DEVICE_OBJECT::__unnamed()
        self.AlignmentRequirement = v_uint32()
        self.DeviceQueue = KDEVICE_QUEUE()
        self.Dpc = KDPC()
        self.ActiveThreadCount = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.DeviceLock = KEVENT()
        self.SectorSize = v_uint16()
        self.Spare1 = v_uint16()
        self.DeviceObjectExtension = v_ptr32()
        self.Reserved = v_ptr32()


class LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_ptr32()
        self.Blink = v_ptr32()


class EINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pobj = v_ptr32()


class SECURITY_QUALITY_OF_SERVICE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.ImpersonationLevel = v_uint32()
        self.ContextTrackingMode = v_uint8()
        self.EffectiveOnly = v_uint8()
        self._pad000c = v_bytes(size=2)


class COMPRESSED_DATA_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CompressionFormatAndEngine = v_uint16()
        self.CompressionUnitShift = v_uint8()
        self.ChunkShift = v_uint8()
        self.ClusterShift = v_uint8()
        self.Reserved = v_uint8()
        self.NumberOfChunks = v_uint16()
        self.CompressedChunkSizes = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class BASEOBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.hHmgr = v_ptr32()
        self.ulShareCount = v_uint32()
        self.cExclusiveLock = v_uint16()
        self.BaseFlags = v_uint16()
        self.Tid = v_ptr32()


class HSEMAPHORE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class LUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class LARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class tagPOOLRECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExtraData = v_ptr32()
        self.size = v_uint32()
        self.trace = vstruct.VArray([ v_ptr32() for i in xrange(6) ])


class GUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data1 = v_uint32()
        self.Data2 = v_uint16()
        self.Data3 = v_uint16()
        self.Data4 = vstruct.VArray([ v_uint8() for i in xrange(8) ])


class OBJECT_DUMP_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Stream = v_ptr32()
        self.Detail = v_uint32()


class NPAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = v_uint32()
        self._pad0050 = v_bytes(size=4)


class ULARGE_INTEGER::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class OBJECTOWNER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Share = OBJECTOWNER_S()


class tagWin32PoolHead(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.size = v_uint32()
        self.pPrev = v_ptr32()
        self.pNext = v_ptr32()
        self.pTrace = v_ptr32()


class TL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.next = v_ptr32()
        self.pobj = v_ptr32()
        self.pfnFree = v_ptr32()


class IO_STACK_LOCATION::__unnamed::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr32()
        self.Argument2 = v_ptr32()
        self.Argument3 = v_ptr32()
        self.Argument4 = v_ptr32()


class CM_PARTIAL_RESOURCE_DESCRIPTOR::__unnamed::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class ERESOURCE::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_ptr32()


class IO_STACK_LOCATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorFunction = v_uint8()
        self.MinorFunction = v_uint8()
        self.Flags = v_uint8()
        self.Control = v_uint8()
        self.Parameters = IO_STACK_LOCATION::__unnamed()
        self.DeviceObject = v_ptr32()
        self.FileObject = v_ptr32()
        self.CompletionRoutine = v_ptr32()
        self.Context = v_ptr32()


class IO_RESOURCE_DESCRIPTOR::__unnamed::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Priority = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class GENERIC_MAPPING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GenericRead = v_uint32()
        self.GenericWrite = v_uint32()
        self.GenericExecute = v_uint32()
        self.GenericAll = v_uint32()


class IRP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.MdlAddress = v_ptr32()
        self.Flags = v_uint32()
        self.AssociatedIrp = IRP::__unnamed()
        self.ThreadListEntry = LIST_ENTRY()
        self.IoStatus = IO_STATUS_BLOCK()
        self.RequestorMode = v_uint8()
        self.PendingReturned = v_uint8()
        self.StackCount = v_uint8()
        self.CurrentLocation = v_uint8()
        self.Cancel = v_uint8()
        self.CancelIrql = v_uint8()
        self.ApcEnvironment = v_uint8()
        self.AllocationFlags = v_uint8()
        self.UserIosb = v_ptr32()
        self.UserEvent = v_ptr32()
        self.Overlay = IRP::__unnamed()
        self.CancelRoutine = v_ptr32()
        self.UserBuffer = v_ptr32()
        self.Tail = IRP::__unnamed()


class OBJECT_NAME_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = UNICODE_STRING()


class IO_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.Descriptors = vstruct.VArray([ IO_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class DRIVER_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Flags = v_uint32()
        self.DriverStart = v_ptr32()
        self.DriverSize = v_uint32()
        self.DriverSection = v_ptr32()
        self.DriverExtension = v_ptr32()
        self.DriverName = UNICODE_STRING()
        self.HardwareDatabase = v_ptr32()
        self.FastIoDispatch = v_ptr32()
        self.DriverInit = v_ptr32()
        self.DriverStartIo = v_ptr32()
        self.DriverUnload = v_ptr32()
        self.MajorFunction = vstruct.VArray([ v_ptr32() for i in xrange(28) ])


class IO_STATUS_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.Information = v_uint32()


class PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(1) ])


class CM_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.List = vstruct.VArray([ CM_FULL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class EPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class LIST_ENTRY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint32()
        self.Blink = v_uint32()


class tagVERIFIERTRACKHDR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.list = LIST_ENTRY()
        self.ulSize = v_uint32()
        self.ulTag = v_uint32()


class SINGLE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()


class POWER_SEQUENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SequenceD1 = v_uint32()
        self.SequenceD2 = v_uint32()
        self.SequenceD3 = v_uint32()


class IO_COMPLETION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = v_ptr32()
        self.Key = v_ptr32()


class DRIVER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DriverObject = v_ptr32()
        self.AddDevice = v_ptr32()
        self.Count = v_uint32()
        self.ServiceKeyName = UNICODE_STRING()


class IO_STACK_LOCATION::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Create = IO_STACK_LOCATION::__unnamed::__unnamed()


class KDEVICE_QUEUE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceListEntry = LIST_ENTRY()
        self.SortKey = v_uint32()
        self.Inserted = v_uint8()
        self._pad0010 = v_bytes(size=3)


class LIST_ENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint64()
        self.Blink = v_uint64()


class IO_RESOURCE_REQUIREMENTS_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.SlotNumber = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.AlternativeLists = v_uint32()
        self.List = vstruct.VArray([ IO_RESOURCE_LIST() for i in xrange(1) ])


class SLIST_HEADER::__unnamed(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = SINGLE_LIST_ENTRY()
        self.Depth = v_uint16()
        self.Sequence = v_uint16()


class CM_PARTIAL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Flags = v_uint16()
        self.u = CM_PARTIAL_RESOURCE_DESCRIPTOR::__unnamed()




########NEW FILE########
__FILENAME__ = ntdll
# Version: 6.1
# Architecture: amd64
import vstruct
from vstruct.primitives import *

KPROCESS_STATE = v_enum()
KPROCESS_STATE.ProcessInMemory = 0
KPROCESS_STATE.ProcessOutOfMemory = 1
KPROCESS_STATE.ProcessInTransition = 2
KPROCESS_STATE.ProcessOutTransition = 3
KPROCESS_STATE.ProcessInSwap = 4
KPROCESS_STATE.ProcessOutSwap = 5
KPROCESS_STATE.ProcessAllSwapStates = 6


PS_STD_HANDLE_STATE = v_enum()
PS_STD_HANDLE_STATE.PsNeverDuplicate = 0
PS_STD_HANDLE_STATE.PsRequestDuplicate = 1
PS_STD_HANDLE_STATE.PsAlwaysDuplicate = 2
PS_STD_HANDLE_STATE.PsMaxStdHandleStates = 3


WHEA_ERROR_SEVERITY = v_enum()
WHEA_ERROR_SEVERITY.WheaErrSevRecoverable = 0
WHEA_ERROR_SEVERITY.WheaErrSevFatal = 1
WHEA_ERROR_SEVERITY.WheaErrSevCorrected = 2
WHEA_ERROR_SEVERITY.WheaErrSevInformational = 3


REG_NOTIFY_CLASS = v_enum()
REG_NOTIFY_CLASS.RegNtDeleteKey = 0
REG_NOTIFY_CLASS.RegNtPreDeleteKey = 0
REG_NOTIFY_CLASS.RegNtSetValueKey = 1
REG_NOTIFY_CLASS.RegNtPreSetValueKey = 1
REG_NOTIFY_CLASS.RegNtDeleteValueKey = 2
REG_NOTIFY_CLASS.RegNtPreDeleteValueKey = 2
REG_NOTIFY_CLASS.RegNtSetInformationKey = 3
REG_NOTIFY_CLASS.RegNtPreSetInformationKey = 3
REG_NOTIFY_CLASS.RegNtRenameKey = 4
REG_NOTIFY_CLASS.RegNtPreRenameKey = 4
REG_NOTIFY_CLASS.RegNtEnumerateKey = 5
REG_NOTIFY_CLASS.RegNtPreEnumerateKey = 5
REG_NOTIFY_CLASS.RegNtEnumerateValueKey = 6
REG_NOTIFY_CLASS.RegNtPreEnumerateValueKey = 6
REG_NOTIFY_CLASS.RegNtQueryKey = 7
REG_NOTIFY_CLASS.RegNtPreQueryKey = 7
REG_NOTIFY_CLASS.RegNtQueryValueKey = 8
REG_NOTIFY_CLASS.RegNtPreQueryValueKey = 8
REG_NOTIFY_CLASS.RegNtQueryMultipleValueKey = 9
REG_NOTIFY_CLASS.RegNtPreQueryMultipleValueKey = 9
REG_NOTIFY_CLASS.RegNtPreCreateKey = 10
REG_NOTIFY_CLASS.RegNtPostCreateKey = 11
REG_NOTIFY_CLASS.RegNtPreOpenKey = 12
REG_NOTIFY_CLASS.RegNtPostOpenKey = 13
REG_NOTIFY_CLASS.RegNtKeyHandleClose = 14
REG_NOTIFY_CLASS.RegNtPreKeyHandleClose = 14
REG_NOTIFY_CLASS.RegNtPostDeleteKey = 15
REG_NOTIFY_CLASS.RegNtPostSetValueKey = 16
REG_NOTIFY_CLASS.RegNtPostDeleteValueKey = 17
REG_NOTIFY_CLASS.RegNtPostSetInformationKey = 18
REG_NOTIFY_CLASS.RegNtPostRenameKey = 19
REG_NOTIFY_CLASS.RegNtPostEnumerateKey = 20
REG_NOTIFY_CLASS.RegNtPostEnumerateValueKey = 21
REG_NOTIFY_CLASS.RegNtPostQueryKey = 22
REG_NOTIFY_CLASS.RegNtPostQueryValueKey = 23
REG_NOTIFY_CLASS.RegNtPostQueryMultipleValueKey = 24
REG_NOTIFY_CLASS.RegNtPostKeyHandleClose = 25
REG_NOTIFY_CLASS.RegNtPreCreateKeyEx = 26
REG_NOTIFY_CLASS.RegNtPostCreateKeyEx = 27
REG_NOTIFY_CLASS.RegNtPreOpenKeyEx = 28
REG_NOTIFY_CLASS.RegNtPostOpenKeyEx = 29
REG_NOTIFY_CLASS.RegNtPreFlushKey = 30
REG_NOTIFY_CLASS.RegNtPostFlushKey = 31
REG_NOTIFY_CLASS.RegNtPreLoadKey = 32
REG_NOTIFY_CLASS.RegNtPostLoadKey = 33
REG_NOTIFY_CLASS.RegNtPreUnLoadKey = 34
REG_NOTIFY_CLASS.RegNtPostUnLoadKey = 35
REG_NOTIFY_CLASS.RegNtPreQueryKeySecurity = 36
REG_NOTIFY_CLASS.RegNtPostQueryKeySecurity = 37
REG_NOTIFY_CLASS.RegNtPreSetKeySecurity = 38
REG_NOTIFY_CLASS.RegNtPostSetKeySecurity = 39
REG_NOTIFY_CLASS.RegNtCallbackObjectContextCleanup = 40
REG_NOTIFY_CLASS.RegNtPreRestoreKey = 41
REG_NOTIFY_CLASS.RegNtPostRestoreKey = 42
REG_NOTIFY_CLASS.RegNtPreSaveKey = 43
REG_NOTIFY_CLASS.RegNtPostSaveKey = 44
REG_NOTIFY_CLASS.RegNtPreReplaceKey = 45
REG_NOTIFY_CLASS.RegNtPostReplaceKey = 46
REG_NOTIFY_CLASS.MaxRegNtNotifyClass = 47


DEVICE_RELATION_TYPE = v_enum()
DEVICE_RELATION_TYPE.BusRelations = 0
DEVICE_RELATION_TYPE.EjectionRelations = 1
DEVICE_RELATION_TYPE.PowerRelations = 2
DEVICE_RELATION_TYPE.RemovalRelations = 3
DEVICE_RELATION_TYPE.TargetDeviceRelation = 4
DEVICE_RELATION_TYPE.SingleBusRelations = 5
DEVICE_RELATION_TYPE.TransportRelations = 6


FILE_INFORMATION_CLASS = v_enum()
FILE_INFORMATION_CLASS.FileDirectoryInformation = 1
FILE_INFORMATION_CLASS.FileFullDirectoryInformation = 2
FILE_INFORMATION_CLASS.FileBothDirectoryInformation = 3
FILE_INFORMATION_CLASS.FileBasicInformation = 4
FILE_INFORMATION_CLASS.FileStandardInformation = 5
FILE_INFORMATION_CLASS.FileInternalInformation = 6
FILE_INFORMATION_CLASS.FileEaInformation = 7
FILE_INFORMATION_CLASS.FileAccessInformation = 8
FILE_INFORMATION_CLASS.FileNameInformation = 9
FILE_INFORMATION_CLASS.FileRenameInformation = 10
FILE_INFORMATION_CLASS.FileLinkInformation = 11
FILE_INFORMATION_CLASS.FileNamesInformation = 12
FILE_INFORMATION_CLASS.FileDispositionInformation = 13
FILE_INFORMATION_CLASS.FilePositionInformation = 14
FILE_INFORMATION_CLASS.FileFullEaInformation = 15
FILE_INFORMATION_CLASS.FileModeInformation = 16
FILE_INFORMATION_CLASS.FileAlignmentInformation = 17
FILE_INFORMATION_CLASS.FileAllInformation = 18
FILE_INFORMATION_CLASS.FileAllocationInformation = 19
FILE_INFORMATION_CLASS.FileEndOfFileInformation = 20
FILE_INFORMATION_CLASS.FileAlternateNameInformation = 21
FILE_INFORMATION_CLASS.FileStreamInformation = 22
FILE_INFORMATION_CLASS.FilePipeInformation = 23
FILE_INFORMATION_CLASS.FilePipeLocalInformation = 24
FILE_INFORMATION_CLASS.FilePipeRemoteInformation = 25
FILE_INFORMATION_CLASS.FileMailslotQueryInformation = 26
FILE_INFORMATION_CLASS.FileMailslotSetInformation = 27
FILE_INFORMATION_CLASS.FileCompressionInformation = 28
FILE_INFORMATION_CLASS.FileObjectIdInformation = 29
FILE_INFORMATION_CLASS.FileCompletionInformation = 30
FILE_INFORMATION_CLASS.FileMoveClusterInformation = 31
FILE_INFORMATION_CLASS.FileQuotaInformation = 32
FILE_INFORMATION_CLASS.FileReparsePointInformation = 33
FILE_INFORMATION_CLASS.FileNetworkOpenInformation = 34
FILE_INFORMATION_CLASS.FileAttributeTagInformation = 35
FILE_INFORMATION_CLASS.FileTrackingInformation = 36
FILE_INFORMATION_CLASS.FileIdBothDirectoryInformation = 37
FILE_INFORMATION_CLASS.FileIdFullDirectoryInformation = 38
FILE_INFORMATION_CLASS.FileValidDataLengthInformation = 39
FILE_INFORMATION_CLASS.FileShortNameInformation = 40
FILE_INFORMATION_CLASS.FileIoCompletionNotificationInformation = 41
FILE_INFORMATION_CLASS.FileIoStatusBlockRangeInformation = 42
FILE_INFORMATION_CLASS.FileIoPriorityHintInformation = 43
FILE_INFORMATION_CLASS.FileSfioReserveInformation = 44
FILE_INFORMATION_CLASS.FileSfioVolumeInformation = 45
FILE_INFORMATION_CLASS.FileHardLinkInformation = 46
FILE_INFORMATION_CLASS.FileProcessIdsUsingFileInformation = 47
FILE_INFORMATION_CLASS.FileNormalizedNameInformation = 48
FILE_INFORMATION_CLASS.FileNetworkPhysicalNameInformation = 49
FILE_INFORMATION_CLASS.FileIdGlobalTxDirectoryInformation = 50
FILE_INFORMATION_CLASS.FileIsRemoteDeviceInformation = 51
FILE_INFORMATION_CLASS.FileAttributeCacheInformation = 52
FILE_INFORMATION_CLASS.FileNumaNodeInformation = 53
FILE_INFORMATION_CLASS.FileStandardLinkInformation = 54
FILE_INFORMATION_CLASS.FileRemoteProtocolInformation = 55
FILE_INFORMATION_CLASS.FileMaximumInformation = 56


ALTERNATIVE_ARCHITECTURE_TYPE = v_enum()
ALTERNATIVE_ARCHITECTURE_TYPE.StandardDesign = 0
ALTERNATIVE_ARCHITECTURE_TYPE.NEC98x86 = 1
ALTERNATIVE_ARCHITECTURE_TYPE.EndAlternatives = 2


BUS_QUERY_ID_TYPE = v_enum()
BUS_QUERY_ID_TYPE.BusQueryDeviceID = 0
BUS_QUERY_ID_TYPE.BusQueryHardwareIDs = 1
BUS_QUERY_ID_TYPE.BusQueryCompatibleIDs = 2
BUS_QUERY_ID_TYPE.BusQueryInstanceID = 3
BUS_QUERY_ID_TYPE.BusQueryDeviceSerialNumber = 4
BUS_QUERY_ID_TYPE.BusQueryContainerID = 5


KOBJECTS = v_enum()
KOBJECTS.EventNotificationObject = 0
KOBJECTS.EventSynchronizationObject = 1
KOBJECTS.MutantObject = 2
KOBJECTS.ProcessObject = 3
KOBJECTS.QueueObject = 4
KOBJECTS.SemaphoreObject = 5
KOBJECTS.ThreadObject = 6
KOBJECTS.GateObject = 7
KOBJECTS.TimerNotificationObject = 8
KOBJECTS.TimerSynchronizationObject = 9
KOBJECTS.Spare2Object = 10
KOBJECTS.Spare3Object = 11
KOBJECTS.Spare4Object = 12
KOBJECTS.Spare5Object = 13
KOBJECTS.Spare6Object = 14
KOBJECTS.Spare7Object = 15
KOBJECTS.Spare8Object = 16
KOBJECTS.Spare9Object = 17
KOBJECTS.ApcObject = 18
KOBJECTS.DpcObject = 19
KOBJECTS.DeviceQueueObject = 20
KOBJECTS.EventPairObject = 21
KOBJECTS.InterruptObject = 22
KOBJECTS.ProfileObject = 23
KOBJECTS.ThreadedDpcObject = 24
KOBJECTS.MaximumKernelObject = 25


NT_PRODUCT_TYPE = v_enum()
NT_PRODUCT_TYPE.NtProductWinNt = 1
NT_PRODUCT_TYPE.NtProductLanManNt = 2
NT_PRODUCT_TYPE.NtProductServer = 3


DEVICE_POWER_STATE = v_enum()
DEVICE_POWER_STATE.PowerDeviceUnspecified = 0
DEVICE_POWER_STATE.PowerDeviceD0 = 1
DEVICE_POWER_STATE.PowerDeviceD1 = 2
DEVICE_POWER_STATE.PowerDeviceD2 = 3
DEVICE_POWER_STATE.PowerDeviceD3 = 4
DEVICE_POWER_STATE.PowerDeviceMaximum = 5


WHEA_ERROR_SOURCE_TYPE = v_enum()
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMCE = 0
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCMC = 1
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCPE = 2
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeNMI = 3
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypePCIe = 4
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeGeneric = 5
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeINIT = 6
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeBOOT = 7
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeSCIGeneric = 8
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFMCA = 9
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCMC = 10
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCPE = 11
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMax = 12


PROC_HYPERVISOR_STATE = v_enum()
PROC_HYPERVISOR_STATE.ProcHypervisorNone = 0
PROC_HYPERVISOR_STATE.ProcHypervisorPresent = 1
PROC_HYPERVISOR_STATE.ProcHypervisorPower = 2


RTL_GENERIC_COMPARE_RESULTS = v_enum()
RTL_GENERIC_COMPARE_RESULTS.GenericLessThan = 0
RTL_GENERIC_COMPARE_RESULTS.GenericGreaterThan = 1
RTL_GENERIC_COMPARE_RESULTS.GenericEqual = 2


KWAIT_BLOCK_STATE = v_enum()
KWAIT_BLOCK_STATE.WaitBlockBypassStart = 0
KWAIT_BLOCK_STATE.WaitBlockBypassComplete = 1
KWAIT_BLOCK_STATE.WaitBlockActive = 2
KWAIT_BLOCK_STATE.WaitBlockInactive = 3
KWAIT_BLOCK_STATE.WaitBlockAllStates = 4


PF_FILE_ACCESS_TYPE = v_enum()
PF_FILE_ACCESS_TYPE.PfFileAccessTypeRead = 0
PF_FILE_ACCESS_TYPE.PfFileAccessTypeWrite = 1
PF_FILE_ACCESS_TYPE.PfFileAccessTypeMax = 2


PROCESSOR_CACHE_TYPE = v_enum()
PROCESSOR_CACHE_TYPE.CacheUnified = 0
PROCESSOR_CACHE_TYPE.CacheInstruction = 1
PROCESSOR_CACHE_TYPE.CacheData = 2
PROCESSOR_CACHE_TYPE.CacheTrace = 3


PS_ATTRIBUTE_NUM = v_enum()
PS_ATTRIBUTE_NUM.PsAttributeParentProcess = 0
PS_ATTRIBUTE_NUM.PsAttributeDebugObject = 1
PS_ATTRIBUTE_NUM.PsAttributeToken = 2
PS_ATTRIBUTE_NUM.PsAttributeClientId = 3
PS_ATTRIBUTE_NUM.PsAttributeTebAddress = 4
PS_ATTRIBUTE_NUM.PsAttributeImageName = 5
PS_ATTRIBUTE_NUM.PsAttributeImageInfo = 6
PS_ATTRIBUTE_NUM.PsAttributeMemoryReserve = 7
PS_ATTRIBUTE_NUM.PsAttributePriorityClass = 8
PS_ATTRIBUTE_NUM.PsAttributeErrorMode = 9
PS_ATTRIBUTE_NUM.PsAttributeStdHandleInfo = 10
PS_ATTRIBUTE_NUM.PsAttributeHandleList = 11
PS_ATTRIBUTE_NUM.PsAttributeGroupAffinity = 12
PS_ATTRIBUTE_NUM.PsAttributePreferredNode = 13
PS_ATTRIBUTE_NUM.PsAttributeIdealProcessor = 14
PS_ATTRIBUTE_NUM.PsAttributeUmsThread = 15
PS_ATTRIBUTE_NUM.PsAttributeExecuteOptions = 16
PS_ATTRIBUTE_NUM.PsAttributeMax = 17


MCA_EXCEPTION_TYPE = v_enum()
MCA_EXCEPTION_TYPE.HAL_MCE_RECORD = 0
MCA_EXCEPTION_TYPE.HAL_MCA_RECORD = 1


EVENT_TYPE = v_enum()
EVENT_TYPE.NotificationEvent = 0
EVENT_TYPE.SynchronizationEvent = 1


TP_CALLBACK_PRIORITY = v_enum()
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_HIGH = 0
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_NORMAL = 1
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_LOW = 2
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_INVALID = 3


FSINFOCLASS = v_enum()
FSINFOCLASS.FileFsVolumeInformation = 1
FSINFOCLASS.FileFsLabelInformation = 2
FSINFOCLASS.FileFsSizeInformation = 3
FSINFOCLASS.FileFsDeviceInformation = 4
FSINFOCLASS.FileFsAttributeInformation = 5
FSINFOCLASS.FileFsControlInformation = 6
FSINFOCLASS.FileFsFullSizeInformation = 7
FSINFOCLASS.FileFsObjectIdInformation = 8
FSINFOCLASS.FileFsDriverPathInformation = 9
FSINFOCLASS.FileFsVolumeFlagsInformation = 10
FSINFOCLASS.FileFsMaximumInformation = 11


INTERLOCKED_RESULT = v_enum()
INTERLOCKED_RESULT.ResultNegative = 1
INTERLOCKED_RESULT.ResultZero = 0
INTERLOCKED_RESULT.ResultPositive = 2


WORKING_SET_TYPE = v_enum()
WORKING_SET_TYPE.WorkingSetTypeUser = 0
WORKING_SET_TYPE.WorkingSetTypeSession = 1
WORKING_SET_TYPE.WorkingSetTypeSystemTypes = 2
WORKING_SET_TYPE.WorkingSetTypeSystemCache = 2
WORKING_SET_TYPE.WorkingSetTypePagedPool = 3
WORKING_SET_TYPE.WorkingSetTypeSystemPtes = 4
WORKING_SET_TYPE.WorkingSetTypeMaximum = 5


POOL_TYPE = v_enum()
POOL_TYPE.NonPagedPool = 0
POOL_TYPE.PagedPool = 1
POOL_TYPE.NonPagedPoolMustSucceed = 2
POOL_TYPE.DontUseThisType = 3
POOL_TYPE.NonPagedPoolCacheAligned = 4
POOL_TYPE.PagedPoolCacheAligned = 5
POOL_TYPE.NonPagedPoolCacheAlignedMustS = 6
POOL_TYPE.MaxPoolType = 7
POOL_TYPE.NonPagedPoolSession = 32
POOL_TYPE.PagedPoolSession = 33
POOL_TYPE.NonPagedPoolMustSucceedSession = 34
POOL_TYPE.DontUseThisTypeSession = 35
POOL_TYPE.NonPagedPoolCacheAlignedSession = 36
POOL_TYPE.PagedPoolCacheAlignedSession = 37
POOL_TYPE.NonPagedPoolCacheAlignedMustSSession = 38


IO_PRIORITY_HINT = v_enum()
IO_PRIORITY_HINT.IoPriorityVeryLow = 0
IO_PRIORITY_HINT.IoPriorityLow = 1
IO_PRIORITY_HINT.IoPriorityNormal = 2
IO_PRIORITY_HINT.IoPriorityHigh = 3
IO_PRIORITY_HINT.IoPriorityCritical = 4
IO_PRIORITY_HINT.MaxIoPriorityTypes = 5


MODE = v_enum()
MODE.KernelMode = 0
MODE.UserMode = 1
MODE.MaximumMode = 2


FS_FILTER_SECTION_SYNC_TYPE = v_enum()
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeOther = 0
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeCreateSection = 1


OB_OPEN_REASON = v_enum()
OB_OPEN_REASON.ObCreateHandle = 0
OB_OPEN_REASON.ObOpenHandle = 1
OB_OPEN_REASON.ObDuplicateHandle = 2
OB_OPEN_REASON.ObInheritHandle = 3
OB_OPEN_REASON.ObMaxOpenReason = 4


HEAP_FAILURE_TYPE = v_enum()
HEAP_FAILURE_TYPE.heap_failure_internal = 0
HEAP_FAILURE_TYPE.heap_failure_unknown = 1
HEAP_FAILURE_TYPE.heap_failure_generic = 2
HEAP_FAILURE_TYPE.heap_failure_entry_corruption = 3
HEAP_FAILURE_TYPE.heap_failure_multiple_entries_corruption = 4
HEAP_FAILURE_TYPE.heap_failure_virtual_block_corruption = 5
HEAP_FAILURE_TYPE.heap_failure_buffer_overrun = 6
HEAP_FAILURE_TYPE.heap_failure_buffer_underrun = 7
HEAP_FAILURE_TYPE.heap_failure_block_not_busy = 8
HEAP_FAILURE_TYPE.heap_failure_invalid_argument = 9
HEAP_FAILURE_TYPE.heap_failure_usage_after_free = 10
HEAP_FAILURE_TYPE.heap_failure_cross_heap_operation = 11
HEAP_FAILURE_TYPE.heap_failure_freelists_corruption = 12
HEAP_FAILURE_TYPE.heap_failure_listentry_corruption = 13


PS_IFEO_KEY_STATE = v_enum()
PS_IFEO_KEY_STATE.PsReadIFEOAllValues = 0
PS_IFEO_KEY_STATE.PsSkipIFEODebugger = 1
PS_IFEO_KEY_STATE.PsSkipAllIFEO = 2
PS_IFEO_KEY_STATE.PsMaxIFEOKeyStates = 3


POWER_STATE_TYPE = v_enum()
POWER_STATE_TYPE.SystemPowerState = 0
POWER_STATE_TYPE.DevicePowerState = 1


IRQ_PRIORITY = v_enum()
IRQ_PRIORITY.IrqPriorityUndefined = 0
IRQ_PRIORITY.IrqPriorityLow = 1
IRQ_PRIORITY.IrqPriorityNormal = 2
IRQ_PRIORITY.IrqPriorityHigh = 3


KWAIT_STATE = v_enum()
KWAIT_STATE.WaitInProgress = 0
KWAIT_STATE.WaitCommitted = 1
KWAIT_STATE.WaitAborted = 2
KWAIT_STATE.MaximumWaitState = 3


LSA_FOREST_TRUST_RECORD_TYPE = v_enum()
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName = 0
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx = 1
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo = 2
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustRecordTypeLast = 2


IO_ALLOCATION_ACTION = v_enum()
IO_ALLOCATION_ACTION.KeepObject = 1
IO_ALLOCATION_ACTION.DeallocateObject = 2
IO_ALLOCATION_ACTION.DeallocateObjectKeepRegisters = 3


EXCEPTION_DISPOSITION = v_enum()
EXCEPTION_DISPOSITION.ExceptionContinueExecution = 0
EXCEPTION_DISPOSITION.ExceptionContinueSearch = 1
EXCEPTION_DISPOSITION.ExceptionNestedException = 2
EXCEPTION_DISPOSITION.ExceptionCollidedUnwind = 3


SECURITY_OPERATION_CODE = v_enum()
SECURITY_OPERATION_CODE.SetSecurityDescriptor = 0
SECURITY_OPERATION_CODE.QuerySecurityDescriptor = 1
SECURITY_OPERATION_CODE.DeleteSecurityDescriptor = 2
SECURITY_OPERATION_CODE.AssignSecurityDescriptor = 3


PP_NPAGED_LOOKASIDE_NUMBER = v_enum()
PP_NPAGED_LOOKASIDE_NUMBER.LookasideSmallIrpList = 0
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMediumIrpList = 1
PP_NPAGED_LOOKASIDE_NUMBER.LookasideLargeIrpList = 2
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMdlList = 3
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCreateInfoList = 4
PP_NPAGED_LOOKASIDE_NUMBER.LookasideNameBufferList = 5
PP_NPAGED_LOOKASIDE_NUMBER.LookasideTwilightList = 6
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCompletionList = 7
PP_NPAGED_LOOKASIDE_NUMBER.LookasideScratchBufferList = 8
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMaximumList = 9


WHEA_ERROR_PACKET_DATA_FORMAT = v_enum()
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatIPFSalRecord = 0
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatXPFMCA = 1
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMemory = 2
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIExpress = 3
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatNMIPort = 4
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXBus = 5
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXDevice = 6
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatGeneric = 7
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMax = 8


FS_FILTER_STREAM_FO_NOTIFICATION_TYPE = v_enum()
FS_FILTER_STREAM_FO_NOTIFICATION_TYPE.NotifyTypeCreate = 0
FS_FILTER_STREAM_FO_NOTIFICATION_TYPE.NotifyTypeRetired = 1


DISPLAYCONFIG_SCANLINE_ORDERING = v_enum()
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = 2
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = -1


SECURITY_IMPERSONATION_LEVEL = v_enum()
SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous = 0
SECURITY_IMPERSONATION_LEVEL.SecurityIdentification = 1
SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation = 2
SECURITY_IMPERSONATION_LEVEL.SecurityDelegation = 3


DEVICE_USAGE_NOTIFICATION_TYPE = v_enum()
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeUndefined = 0
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypePaging = 1
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeHibernation = 2
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeDumpFile = 3


POWER_ACTION = v_enum()
POWER_ACTION.PowerActionNone = 0
POWER_ACTION.PowerActionReserved = 1
POWER_ACTION.PowerActionSleep = 2
POWER_ACTION.PowerActionHibernate = 3
POWER_ACTION.PowerActionShutdown = 4
POWER_ACTION.PowerActionShutdownReset = 5
POWER_ACTION.PowerActionShutdownOff = 6
POWER_ACTION.PowerActionWarmEject = 7


INTERFACE_TYPE = v_enum()
INTERFACE_TYPE.InterfaceTypeUndefined = -1
INTERFACE_TYPE.Internal = 0
INTERFACE_TYPE.Isa = 1
INTERFACE_TYPE.Eisa = 2
INTERFACE_TYPE.MicroChannel = 3
INTERFACE_TYPE.TurboChannel = 4
INTERFACE_TYPE.PCIBus = 5
INTERFACE_TYPE.VMEBus = 6
INTERFACE_TYPE.NuBus = 7
INTERFACE_TYPE.PCMCIABus = 8
INTERFACE_TYPE.CBus = 9
INTERFACE_TYPE.MPIBus = 10
INTERFACE_TYPE.MPSABus = 11
INTERFACE_TYPE.ProcessorInternal = 12
INTERFACE_TYPE.InternalPowerBus = 13
INTERFACE_TYPE.PNPISABus = 14
INTERFACE_TYPE.PNPBus = 15
INTERFACE_TYPE.Vmcs = 16
INTERFACE_TYPE.MaximumInterfaceType = 17


PS_RESOURCE_TYPE = v_enum()
PS_RESOURCE_TYPE.PsResourceNonPagedPool = 0
PS_RESOURCE_TYPE.PsResourcePagedPool = 1
PS_RESOURCE_TYPE.PsResourcePageFile = 2
PS_RESOURCE_TYPE.PsResourceWorkingSet = 3
PS_RESOURCE_TYPE.PsResourceCpuRate = 4
PS_RESOURCE_TYPE.PsResourceMax = 5


MM_PAGE_ACCESS_TYPE = v_enum()
MM_PAGE_ACCESS_TYPE.MmPteAccessType = 0
MM_PAGE_ACCESS_TYPE.MmCcReadAheadType = 1
MM_PAGE_ACCESS_TYPE.MmPfnRepurposeType = 2
MM_PAGE_ACCESS_TYPE.MmMaximumPageAccessType = 3


WHEA_ERROR_TYPE = v_enum()
WHEA_ERROR_TYPE.WheaErrTypeProcessor = 0
WHEA_ERROR_TYPE.WheaErrTypeMemory = 1
WHEA_ERROR_TYPE.WheaErrTypePCIExpress = 2
WHEA_ERROR_TYPE.WheaErrTypeNMI = 3
WHEA_ERROR_TYPE.WheaErrTypePCIXBus = 4
WHEA_ERROR_TYPE.WheaErrTypePCIXDevice = 5
WHEA_ERROR_TYPE.WheaErrTypeGeneric = 6


HARDWARE_COUNTER_TYPE = v_enum()
HARDWARE_COUNTER_TYPE.PMCCounter = 0
HARDWARE_COUNTER_TYPE.MaxHardwareCounterType = 1


ReplacesCorHdrNumericDefines = v_enum()
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY = 1
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED = 2
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY = 4
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED = 8
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2 = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MINOR = 0
ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB = 1
ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA = 1
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA = 2
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT = 1
ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT = 2
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED = 4
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED = 16
ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE = 32
ReplacesCorHdrNumericDefines.MAX_CLASS_NAME = 1024
ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME = 1024


SYSTEM_POWER_STATE = v_enum()
SYSTEM_POWER_STATE.PowerSystemUnspecified = 0
SYSTEM_POWER_STATE.PowerSystemWorking = 1
SYSTEM_POWER_STATE.PowerSystemSleeping1 = 2
SYSTEM_POWER_STATE.PowerSystemSleeping2 = 3
SYSTEM_POWER_STATE.PowerSystemSleeping3 = 4
SYSTEM_POWER_STATE.PowerSystemHibernate = 5
SYSTEM_POWER_STATE.PowerSystemShutdown = 6
SYSTEM_POWER_STATE.PowerSystemMaximum = 7


MEMORY_CACHING_TYPE_ORIG = v_enum()
MEMORY_CACHING_TYPE_ORIG.MmFrameBufferCached = 2


DEVICE_TEXT_TYPE = v_enum()
DEVICE_TEXT_TYPE.DeviceTextDescription = 0
DEVICE_TEXT_TYPE.DeviceTextLocationInformation = 1


PS_CREATE_STATE = v_enum()
PS_CREATE_STATE.PsCreateInitialState = 0
PS_CREATE_STATE.PsCreateFailOnFileOpen = 1
PS_CREATE_STATE.PsCreateFailOnSectionCreate = 2
PS_CREATE_STATE.PsCreateFailExeFormat = 3
PS_CREATE_STATE.PsCreateFailMachineMismatch = 4
PS_CREATE_STATE.PsCreateFailExeName = 5
PS_CREATE_STATE.PsCreateSuccess = 6
PS_CREATE_STATE.PsCreateMaximumStates = 7


class KEXECUTE_OPTIONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteDisable = v_uint8()


class IO_PRIORITY_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.ThreadPriority = v_uint32()
        self.PagePriority = v_uint32()
        self.IoPriority = v_uint32()


class SID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.SubAuthorityCount = v_uint8()
        self.IdentifierAuthority = SID_IDENTIFIER_AUTHORITY()
        self.SubAuthority = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class WHEA_ERROR_PACKET_V2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Version = v_uint32()
        self.Length = v_uint32()
        self.Flags = WHEA_ERROR_PACKET_FLAGS()
        self.ErrorType = v_uint32()
        self.ErrorSeverity = v_uint32()
        self.ErrorSourceId = v_uint32()
        self.ErrorSourceType = v_uint32()
        self.NotifyType = GUID()
        self.Context = v_uint64()
        self.DataFormat = v_uint32()
        self.Reserved1 = v_uint32()
        self.DataOffset = v_uint32()
        self.DataLength = v_uint32()
        self.PshedDataOffset = v_uint32()
        self.PshedDataLength = v_uint32()


class GROUP_AFFINITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint64()
        self.Group = v_uint16()
        self.Reserved = vstruct.VArray([ v_uint16() for i in xrange(3) ])


class UMS_CONTROL_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_8000(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdType = v_uint32()


class CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DosPath = UNICODE_STRING()
        self.Handle = v_ptr64()


class KREQUEST_PACKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CurrentPacket = vstruct.VArray([ v_ptr64() for i in xrange(3) ])
        self.WorkerRoutine = v_ptr64()


class PERFINFO_GROUPMASK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Masks = vstruct.VArray([ v_uint32() for i in xrange(8) ])


class HARDWARE_PTE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint64()


class HANDLE_TABLE_ENTRY_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AuditMask = v_uint32()


class SINGLE_LIST_ENTRY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_uint32()


class _unnamed_10205(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length40 = v_uint32()
        self.Alignment40 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class _unnamed_9413(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Balance = v_uint64()


class _unnamed_10201(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Priority = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class PS_CPU_QUOTA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.SessionId = v_uint32()
        self.CpuShareWeight = v_uint32()
        self.CapturedWeightData = PSP_CPU_SHARE_CAPTURED_WEIGHT_DATA()
        self.DuplicateInputMarker = v_uint32()
        self._pad0040 = v_bytes(size=28)
        self.CycleCredit = v_uint64()
        self.BlockCurrentGeneration = v_uint32()
        self.CpuCyclePercent = v_uint32()
        self.CyclesFinishedForCurrentGeneration = v_uint8()
        self._pad0080 = v_bytes(size=47)
        self.Cpu = vstruct.VArray([ PS_PER_CPU_QUOTA_CACHE_AWARE() for i in xrange(256) ])


class RTL_TRACE_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Database = v_ptr64()
        self.NextSegment = v_ptr64()
        self.TotalSize = v_uint64()
        self.SegmentStart = v_ptr64()
        self.SegmentEnd = v_ptr64()
        self.SegmentFree = v_ptr64()


class CM_PARTIAL_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.PartialDescriptors = vstruct.VArray([ CM_PARTIAL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class DEVICE_CAPABILITIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.DeviceD1 = v_uint32()
        self.Address = v_uint32()
        self.UINumber = v_uint32()
        self.DeviceState = vstruct.VArray([ DEVICE_POWER_STATE() for i in xrange(7) ])
        self.SystemWake = v_uint32()
        self.DeviceWake = v_uint32()
        self.D1Latency = v_uint32()
        self.D2Latency = v_uint32()
        self.D3Latency = v_uint32()


class _unnamed_7991(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint8()


class HEAP_FAILURE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint32()
        self.StructureSize = v_uint32()
        self.FailureType = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.HeapAddress = v_ptr64()
        self.Address = v_ptr64()
        self.Param1 = v_ptr64()
        self.Param2 = v_ptr64()
        self.Param3 = v_ptr64()
        self.PreviousBlock = v_ptr64()
        self.NextBlock = v_ptr64()
        self.ExpectedEncodedEntry = HEAP_ENTRY()
        self.ExpectedDecodedEntry = HEAP_ENTRY()
        self.StackTrace = vstruct.VArray([ v_ptr64() for i in xrange(32) ])


class RTL_BALANCED_LINKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parent = v_ptr64()
        self.LeftChild = v_ptr64()
        self.RightChild = v_ptr64()
        self.Balance = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self._pad0020 = v_bytes(size=4)


class _unnamed_9396(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Generic = _unnamed_9633()
        self._pad0010 = v_bytes(size=4)


class KPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.ProfileListHead = LIST_ENTRY()
        self.DirectoryTableBase = v_uint64()
        self.ThreadListHead = LIST_ENTRY()
        self.ProcessLock = v_uint64()
        self.Affinity = KAFFINITY_EX()
        self.ReadyListHead = LIST_ENTRY()
        self.SwapListEntry = SINGLE_LIST_ENTRY()
        self.ActiveProcessors = KAFFINITY_EX()
        self.AutoAlignment = v_uint32()
        self.BasePriority = v_uint8()
        self.QuantumReset = v_uint8()
        self.Visited = v_uint8()
        self.Unused3 = v_uint8()
        self.ThreadSeed = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.IdealNode = vstruct.VArray([ v_uint16() for i in xrange(4) ])
        self.IdealGlobalNode = v_uint16()
        self.Flags = KEXECUTE_OPTIONS()
        self.Unused1 = v_uint8()
        self.Unused2 = v_uint32()
        self.Unused4 = v_uint32()
        self.StackCount = KSTACK_COUNT()
        self.ProcessListEntry = LIST_ENTRY()
        self.CycleTime = v_uint64()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.InstrumentationCallback = v_ptr64()
        self.LdtSystemDescriptor = KGDTENTRY64()
        self.LdtBaseAddress = v_ptr64()
        self.LdtProcessLock = KGUARDED_MUTEX()
        self.LdtFreeSelectorHint = v_uint16()
        self.LdtTableLength = v_uint16()
        self._pad0160 = v_bytes(size=4)


class DEVICE_OBJECT_POWER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class HEAP_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint64()
        self.TagIndex = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self.TagName = vstruct.VArray([ v_uint16() for i in xrange(24) ])
        self._pad0048 = v_bytes(size=4)


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Primary = v_uint32()


class TP_CALLBACK_ENVIRON_V3(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Pool = v_ptr64()
        self.CleanupGroup = v_ptr64()
        self.CleanupGroupCancelCallback = v_ptr64()
        self.RaceDll = v_ptr64()
        self.ActivationContext = v_ptr64()
        self.FinalizationCallback = v_ptr64()
        self.u = _unnamed_5516()
        self.CallbackPriority = v_uint32()
        self.Size = v_uint32()
        self._pad0048 = v_bytes(size=4)


class _unnamed_7904(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.StartSid = v_ptr64()
        self.SidList = v_ptr64()
        self.SidListLength = v_uint32()
        self._pad0020 = v_bytes(size=4)


class WHEA_ERROR_PACKET_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousError = v_uint32()


class ALPC_PROCESS_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = EX_PUSH_LOCK()
        self.ViewListHead = LIST_ENTRY()
        self.PagedPoolQuotaCache = v_uint64()


class OBJECT_HANDLE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleAttributes = v_uint32()
        self.GrantedAccess = v_uint32()


class _unnamed_7861(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.InputBufferLength = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.FsControlCode = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Type3InputBuffer = v_ptr64()


class PROC_PERF_DOMAIN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = LIST_ENTRY()
        self.Master = v_ptr64()
        self.Members = KAFFINITY_EX()
        self.FeedbackHandler = v_ptr64()
        self.GetFFHThrottleState = v_ptr64()
        self.BoostPolicyHandler = v_ptr64()
        self.PerfSelectionHandler = v_ptr64()
        self.PerfHandler = v_ptr64()
        self.Processors = v_ptr64()
        self.PerfChangeTime = v_uint64()
        self.ProcessorCount = v_uint32()
        self.PreviousFrequencyMhz = v_uint32()
        self.CurrentFrequencyMhz = v_uint32()
        self.PreviousFrequency = v_uint32()
        self.CurrentFrequency = v_uint32()
        self.CurrentPerfContext = v_uint32()
        self.DesiredFrequency = v_uint32()
        self.MaxFrequency = v_uint32()
        self.MinPerfPercent = v_uint32()
        self.MinThrottlePercent = v_uint32()
        self.MaxPercent = v_uint32()
        self.MinPercent = v_uint32()
        self.ConstrainedMaxPercent = v_uint32()
        self.ConstrainedMinPercent = v_uint32()
        self.Coordination = v_uint8()
        self._pad00b4 = v_bytes(size=3)
        self.PerfChangeIntervalCount = v_uint32()


class XSTATE_CONFIGURATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnabledFeatures = v_uint64()
        self.Size = v_uint32()
        self.OptimizedSave = v_uint32()
        self.Features = vstruct.VArray([ XSTATE_FEATURE() for i in xrange(64) ])


class PS_CLIENT_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImpersonationData = v_uint64()


class RTL_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = RTL_BALANCED_LINKS()
        self.OrderedPointer = v_ptr64()
        self.WhichOrderedElement = v_uint32()
        self.NumberGenericTableElements = v_uint32()
        self.DepthOfTree = v_uint32()
        self._pad0038 = v_bytes(size=4)
        self.RestartKey = v_ptr64()
        self.DeleteCount = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.CompareRoutine = v_ptr64()
        self.AllocateRoutine = v_ptr64()
        self.FreeRoutine = v_ptr64()
        self.TableContext = v_ptr64()


class RTL_TRACE_DATABASE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint32()
        self.Flags = v_uint32()
        self.Tag = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.SegmentList = v_ptr64()
        self.MaximumSize = v_uint64()
        self.CurrentSize = v_uint64()
        self.Owner = v_ptr64()
        self.Lock = RTL_CRITICAL_SECTION()
        self.NoOfBuckets = v_uint32()
        self._pad0060 = v_bytes(size=4)
        self.Buckets = v_ptr64()
        self.HashFunction = v_ptr64()
        self.NoOfTraces = v_uint64()
        self.NoOfHits = v_uint64()
        self.HashCounter = vstruct.VArray([ v_uint32() for i in xrange(16) ])


class OWNER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerThread = v_uint64()
        self.IoPriorityBoosted = v_uint32()
        self._pad0010 = v_bytes(size=4)


class DEVOBJ_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DeviceObject = v_ptr64()
        self.PowerFlags = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Dope = v_ptr64()
        self.ExtensionFlags = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.DeviceNode = v_ptr64()
        self.AttachedTo = v_ptr64()
        self.StartIoCount = v_uint32()
        self.StartIoKey = v_uint32()
        self.StartIoFlags = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.Vpb = v_ptr64()
        self.DependentList = LIST_ENTRY()
        self.ProviderList = LIST_ENTRY()


class HEAP_LOCAL_SEGMENT_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Hint = v_ptr64()
        self.ActiveSubsegment = v_ptr64()
        self.CachedItems = vstruct.VArray([ v_ptr64() for i in xrange(16) ])
        self.SListHeader = SLIST_HEADER()
        self.Counters = HEAP_BUCKET_COUNTERS()
        self.LocalData = v_ptr64()
        self.LastOpSequence = v_uint32()
        self.BucketIndex = v_uint16()
        self.LastUsed = v_uint16()
        self._pad00c0 = v_bytes(size=8)


class _unnamed_8005(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceTextType = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.LocaleId = v_uint32()
        self._pad0010 = v_bytes(size=4)


class HEAP_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalMemoryReserved = v_uint64()
        self.TotalMemoryCommitted = v_uint64()
        self.TotalMemoryLargeUCR = v_uint64()
        self.TotalSizeInVirtualBlocks = v_uint64()
        self.TotalSegments = v_uint32()
        self.TotalUCRs = v_uint32()
        self.CommittOps = v_uint32()
        self.DeCommitOps = v_uint32()
        self.LockAcquires = v_uint32()
        self.LockCollisions = v_uint32()
        self.CommitRate = v_uint32()
        self.DecommittRate = v_uint32()
        self.CommitFailures = v_uint32()
        self.InBlockCommitFailures = v_uint32()
        self.CompactHeapCalls = v_uint32()
        self.CompactedUCRs = v_uint32()
        self.AllocAndFreeOps = v_uint32()
        self.InBlockDeccommits = v_uint32()
        self.InBlockDeccomitSize = v_uint64()
        self.HighWatermarkSize = v_uint64()
        self.LastPolledSize = v_uint64()


class MAILSLOT_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MailslotQuota = v_uint32()
        self.MaximumMessageSize = v_uint32()
        self.ReadTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0018 = v_bytes(size=7)


class FS_FILTER_CALLBACK_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbackData = v_uint32()
        self.Operation = v_uint8()
        self.Reserved = v_uint8()
        self._pad0008 = v_bytes(size=2)
        self.DeviceObject = v_ptr64()
        self.FileObject = v_ptr64()
        self.Parameters = FS_FILTER_PARAMETERS()


class REQUEST_MAILBOX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.RequestSummary = v_uint64()
        self.RequestPacket = KREQUEST_PACKET()
        self._pad0040 = v_bytes(size=16)


class PPM_IDLE_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DomainMembers = KAFFINITY_EX()
        self.IdleCheck = v_ptr64()
        self.IdleHandler = v_ptr64()
        self.Context = v_ptr64()
        self.Latency = v_uint32()
        self.Power = v_uint32()
        self.TimeCheck = v_uint32()
        self.StateFlags = v_uint32()
        self.PromotePercent = v_uint8()
        self.DemotePercent = v_uint8()
        self.PromotePercentBase = v_uint8()
        self.DemotePercentBase = v_uint8()
        self.StateType = v_uint8()
        self._pad0058 = v_bytes(size=3)


class ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OperationID = LUID()
        self.SecurityEvaluated = v_uint8()
        self.GenerateAudit = v_uint8()
        self.GenerateOnClose = v_uint8()
        self.PrivilegesAllocated = v_uint8()
        self.Flags = v_uint32()
        self.RemainingDesiredAccess = v_uint32()
        self.PreviouslyGrantedAccess = v_uint32()
        self.OriginalDesiredAccess = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.SubjectSecurityContext = SECURITY_SUBJECT_CONTEXT()
        self.SecurityDescriptor = v_ptr64()
        self.AuxData = v_ptr64()
        self.Privileges = _unnamed_7557()
        self.AuditPrivileges = v_uint8()
        self._pad0080 = v_bytes(size=3)
        self.ObjectName = UNICODE_STRING()
        self.ObjectTypeName = UNICODE_STRING()


class FILE_STANDARD_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.NumberOfLinks = v_uint32()
        self.DeletePending = v_uint8()
        self.Directory = v_uint8()
        self._pad0018 = v_bytes(size=2)


class _unnamed_9633(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length = v_uint32()


class PROC_IDLE_ACCOUNTING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StateCount = v_uint32()
        self.TotalTransitions = v_uint32()
        self.ResetCount = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.StartTime = v_uint64()
        self.BucketLimits = vstruct.VArray([ v_uint64() for i in xrange(16) ])
        self.State = vstruct.VArray([ PROC_IDLE_STATE_ACCOUNTING() for i in xrange(1) ])


class _unnamed_9636(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint16()
        self.Group = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint64()


class GDI_TEB_BATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.HDC = v_uint64()
        self.Buffer = vstruct.VArray([ v_uint32() for i in xrange(310) ])


class THREAD_PERFORMANCE_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.ProcessorNumber = PROCESSOR_NUMBER()
        self.ContextSwitches = v_uint32()
        self.HwCountersCount = v_uint32()
        self.UpdateCount = v_uint64()
        self.WaitReasonBitMap = v_uint64()
        self.HardwareCounters = v_uint64()
        self.CycleTime = COUNTER_READING()
        self.HwCounters = vstruct.VArray([ COUNTER_READING() for i in xrange(16) ])


class PAGEFAULT_HISTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ECP_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class SECTION_OBJECT_POINTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSectionObject = v_ptr64()
        self.SharedCacheMap = v_ptr64()
        self.ImageSectionObject = v_ptr64()


class MDL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Size = v_uint16()
        self.MdlFlags = v_uint16()
        self._pad0010 = v_bytes(size=4)
        self.Process = v_ptr64()
        self.MappedSystemVa = v_ptr64()
        self.StartVa = v_ptr64()
        self.ByteCount = v_uint32()
        self.ByteOffset = v_uint32()


class KTRAP_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P1Home = v_uint64()
        self.P2Home = v_uint64()
        self.P3Home = v_uint64()
        self.P4Home = v_uint64()
        self.P5 = v_uint64()
        self.PreviousMode = v_uint8()
        self.PreviousIrql = v_uint8()
        self.FaultIndicator = v_uint8()
        self.ExceptionActive = v_uint8()
        self.MxCsr = v_uint32()
        self.Rax = v_uint64()
        self.Rcx = v_uint64()
        self.Rdx = v_uint64()
        self.R8 = v_uint64()
        self.R9 = v_uint64()
        self.R10 = v_uint64()
        self.R11 = v_uint64()
        self.GsBase = v_uint64()
        self.Xmm0 = M128A()
        self.Xmm1 = M128A()
        self.Xmm2 = M128A()
        self.Xmm3 = M128A()
        self.Xmm4 = M128A()
        self.Xmm5 = M128A()
        self.FaultAddress = v_uint64()
        self.Dr0 = v_uint64()
        self.Dr1 = v_uint64()
        self.Dr2 = v_uint64()
        self.Dr3 = v_uint64()
        self.Dr6 = v_uint64()
        self.Dr7 = v_uint64()
        self.DebugControl = v_uint64()
        self.LastBranchToRip = v_uint64()
        self.LastBranchFromRip = v_uint64()
        self.LastExceptionToRip = v_uint64()
        self.LastExceptionFromRip = v_uint64()
        self.SegDs = v_uint16()
        self.SegEs = v_uint16()
        self.SegFs = v_uint16()
        self.SegGs = v_uint16()
        self.TrapFrame = v_uint64()
        self.Rbx = v_uint64()
        self.Rdi = v_uint64()
        self.Rsi = v_uint64()
        self.Rbp = v_uint64()
        self.ErrorCode = v_uint64()
        self.Rip = v_uint64()
        self.SegCs = v_uint16()
        self.Fill0 = v_uint8()
        self.Logging = v_uint8()
        self.Fill1 = vstruct.VArray([ v_uint16() for i in xrange(2) ])
        self.EFlags = v_uint32()
        self.Fill2 = v_uint32()
        self.Rsp = v_uint64()
        self.SegSs = v_uint16()
        self.Fill3 = v_uint16()
        self.CodePatchCycle = v_uint32()


class MCI_ADDR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_uint32()
        self.Reserved = v_uint32()


class IO_TIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.TimerFlag = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.TimerList = LIST_ENTRY()
        self.TimerRoutine = v_ptr64()
        self.Context = v_ptr64()
        self.DeviceObject = v_ptr64()


class WHEA_REVISION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinorRevision = v_uint8()
        self.MajorRevision = v_uint8()


class TP_CLEANUP_GROUP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class PROC_IDLE_SNAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Time = v_uint64()
        self.Idle = v_uint64()


class _unnamed_7700(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceQueueEntry = KDEVICE_QUEUE_ENTRY()
        self._pad0020 = v_bytes(size=8)
        self.Thread = v_ptr64()
        self.AuxiliaryBuffer = v_ptr64()
        self.ListEntry = LIST_ENTRY()
        self.CurrentStackLocation = v_ptr64()
        self.OriginalFileObject = v_ptr64()


class SECURITY_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.Sbz1 = v_uint8()
        self.Control = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Owner = v_ptr64()
        self.Group = v_ptr64()
        self.Sacl = v_ptr64()
        self.Dacl = v_ptr64()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SectionOffset = v_uint32()
        self.SectionLength = v_uint32()
        self.Revision = WHEA_REVISION()
        self.ValidBits = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS()
        self.Reserved = v_uint8()
        self.Flags = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS()
        self.SectionType = GUID()
        self.FRUId = GUID()
        self.SectionSeverity = v_uint32()
        self.FRUText = vstruct.VArray([ v_uint8() for i in xrange(20) ])


class OBJECT_TYPE_INITIALIZER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.ObjectTypeFlags = v_uint8()
        self._pad0004 = v_bytes(size=1)
        self.ObjectTypeCode = v_uint32()
        self.InvalidAttributes = v_uint32()
        self.GenericMapping = GENERIC_MAPPING()
        self.ValidAccessMask = v_uint32()
        self.RetainAccess = v_uint32()
        self.PoolType = v_uint32()
        self.DefaultPagedPoolCharge = v_uint32()
        self.DefaultNonPagedPoolCharge = v_uint32()
        self.DumpProcedure = v_ptr64()
        self.OpenProcedure = v_ptr64()
        self.CloseProcedure = v_ptr64()
        self.DeleteProcedure = v_ptr64()
        self.ParseProcedure = v_ptr64()
        self.SecurityProcedure = v_ptr64()
        self.QueryNameProcedure = v_ptr64()
        self.OkayToCloseProcedure = v_ptr64()


class TP_DIRECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callback = v_ptr64()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()
        self._pad0010 = v_bytes(size=3)


class XSTATE_SAVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Prev = v_ptr64()
        self.Thread = v_ptr64()
        self.Level = v_uint8()
        self._pad0018 = v_bytes(size=7)
        self.XStateContext = XSTATE_CONTEXT()


class HEAP_ENTRY_EXTRA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatorBackTraceIndex = v_uint16()
        self.TagIndex = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Settable = v_uint64()


class HEAP_PSEUDO_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint64()


class PAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()


class RTL_BITMAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfBitMap = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_ptr64()


class LARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class NPAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()


class _unnamed_7557(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InitialPrivilegeSet = INITIAL_PRIVILEGE_SET()


class _unnamed_7828(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FileInformationClass = v_uint32()
        self._pad0010 = v_bytes(size=4)


class _unnamed_7825(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.CompletionFilter = v_uint32()
        self._pad0010 = v_bytes(size=4)


class _unnamed_5486(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class VPB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.Flags = v_uint16()
        self.VolumeLabelLength = v_uint16()
        self.DeviceObject = v_ptr64()
        self.RealDevice = v_ptr64()
        self.SerialNumber = v_uint32()
        self.ReferenceCount = v_uint32()
        self.VolumeLabel = vstruct.VArray([ v_uint16() for i in xrange(32) ])


class PP_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P = v_ptr64()
        self.L = v_ptr64()


class OBJECT_NAME_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = UNICODE_STRING()


class IO_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.Descriptors = vstruct.VArray([ IO_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class KUSER_SHARED_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TickCountLowDeprecated = v_uint32()
        self.TickCountMultiplier = v_uint32()
        self.InterruptTime = KSYSTEM_TIME()
        self.SystemTime = KSYSTEM_TIME()
        self.TimeZoneBias = KSYSTEM_TIME()
        self.ImageNumberLow = v_uint16()
        self.ImageNumberHigh = v_uint16()
        self.NtSystemRoot = vstruct.VArray([ v_uint16() for i in xrange(260) ])
        self.MaxStackTraceDepth = v_uint32()
        self.CryptoExponent = v_uint32()
        self.TimeZoneId = v_uint32()
        self.LargePageMinimum = v_uint32()
        self.Reserved2 = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self.NtProductType = v_uint32()
        self.ProductTypeIsValid = v_uint8()
        self._pad026c = v_bytes(size=3)
        self.NtMajorVersion = v_uint32()
        self.NtMinorVersion = v_uint32()
        self.ProcessorFeatures = vstruct.VArray([ v_uint8() for i in xrange(64) ])
        self.Reserved1 = v_uint32()
        self.Reserved3 = v_uint32()
        self.TimeSlip = v_uint32()
        self.AlternativeArchitecture = v_uint32()
        self.AltArchitecturePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.SystemExpirationDate = LARGE_INTEGER()
        self.SuiteMask = v_uint32()
        self.KdDebuggerEnabled = v_uint8()
        self.NXSupportPolicy = v_uint8()
        self._pad02d8 = v_bytes(size=2)
        self.ActiveConsoleId = v_uint32()
        self.DismountCount = v_uint32()
        self.ComPlusPackage = v_uint32()
        self.LastSystemRITEventTickCount = v_uint32()
        self.NumberOfPhysicalPages = v_uint32()
        self.SafeBootMode = v_uint8()
        self.TscQpcData = v_uint8()
        self.TscQpcPad = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.SharedDataFlags = v_uint32()
        self.DataFlagsPad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.TestRetInstruction = v_uint64()
        self.SystemCall = v_uint32()
        self.SystemCallReturn = v_uint32()
        self.SystemCallPad = vstruct.VArray([ v_uint64() for i in xrange(3) ])
        self.TickCount = KSYSTEM_TIME()
        self.TickCountPad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.Cookie = v_uint32()
        self.CookiePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.ConsoleSessionForegroundProcessId = v_uint64()
        self.Wow64SharedInformation = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.UserModeGlobalLogger = vstruct.VArray([ v_uint16() for i in xrange(16) ])
        self.ImageFileExecutionOptions = v_uint32()
        self.LangGenerationCount = v_uint32()
        self.Reserved5 = v_uint64()
        self.InterruptTimeBias = v_uint64()
        self.TscQpcBias = v_uint64()
        self.ActiveProcessorCount = v_uint32()
        self.ActiveGroupCount = v_uint16()
        self.Reserved4 = v_uint16()
        self.AitSamplingValue = v_uint32()
        self.AppCompatFlag = v_uint32()
        self.SystemDllNativeRelocation = v_uint64()
        self.SystemDllWowRelocation = v_uint32()
        self.XStatePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.XState = XSTATE_CONFIGURATION()


class SYSTEM_POWER_STATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved1 = v_uint32()


class _unnamed_10186(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumVector = v_uint32()
        self.MaximumVector = v_uint32()
        self.AffinityPolicy = v_uint16()
        self.Group = v_uint16()
        self.PriorityPolicy = v_uint32()
        self.TargetedProcessors = v_uint64()


class FS_FILTER_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AcquireForModifiedPageWriter = _unnamed_9724()
        self._pad0028 = v_bytes(size=24)


class HEAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.SegmentSignature = v_uint32()
        self.SegmentFlags = v_uint32()
        self.SegmentListEntry = LIST_ENTRY()
        self.Heap = v_ptr64()
        self.BaseAddress = v_ptr64()
        self.NumberOfPages = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.FirstEntry = v_ptr64()
        self.LastValidEntry = v_ptr64()
        self.NumberOfUnCommittedPages = v_uint32()
        self.NumberOfUnCommittedRanges = v_uint32()
        self.SegmentAllocatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self._pad0060 = v_bytes(size=4)
        self.UCRSegmentList = LIST_ENTRY()
        self.Flags = v_uint32()
        self.ForceFlags = v_uint32()
        self.CompatibilityFlags = v_uint32()
        self.EncodeFlagMask = v_uint32()
        self.Encoding = HEAP_ENTRY()
        self.PointerKey = v_uint64()
        self.Interceptor = v_uint32()
        self.VirtualMemoryThreshold = v_uint32()
        self.Signature = v_uint32()
        self._pad00a8 = v_bytes(size=4)
        self.SegmentReserve = v_uint64()
        self.SegmentCommit = v_uint64()
        self.DeCommitFreeBlockThreshold = v_uint64()
        self.DeCommitTotalFreeThreshold = v_uint64()
        self.TotalFreeSize = v_uint64()
        self.MaximumAllocationSize = v_uint64()
        self.ProcessHeapsListIndex = v_uint16()
        self.HeaderValidateLength = v_uint16()
        self._pad00e0 = v_bytes(size=4)
        self.HeaderValidateCopy = v_ptr64()
        self.NextAvailableTagIndex = v_uint16()
        self.MaximumTagIndex = v_uint16()
        self._pad00f0 = v_bytes(size=4)
        self.TagEntries = v_ptr64()
        self.UCRList = LIST_ENTRY()
        self.AlignRound = v_uint64()
        self.AlignMask = v_uint64()
        self.VirtualAllocdBlocks = LIST_ENTRY()
        self.SegmentList = LIST_ENTRY()
        self.AllocatorBackTraceIndex = v_uint16()
        self._pad013c = v_bytes(size=2)
        self.NonDedicatedListLength = v_uint32()
        self.BlocksIndex = v_ptr64()
        self.UCRIndex = v_ptr64()
        self.PseudoTagEntries = v_ptr64()
        self.FreeLists = LIST_ENTRY()
        self.LockVariable = v_ptr64()
        self.CommitRoutine = v_ptr64()
        self.FrontEndHeap = v_ptr64()
        self.FrontHeapLockCount = v_uint16()
        self.FrontEndHeapType = v_uint8()
        self._pad0188 = v_bytes(size=5)
        self.Counters = HEAP_COUNTERS()
        self.TuningParameters = HEAP_TUNING_PARAMETERS()


class IO_STATUS_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Information = v_uint64()


class PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(1) ])


class CM_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.List = vstruct.VArray([ CM_FULL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class EPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pcb = KPROCESS()
        self.ProcessLock = EX_PUSH_LOCK()
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.UniqueProcessId = v_ptr64()
        self.ActiveProcessLinks = LIST_ENTRY()
        self.ProcessQuotaUsage = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.ProcessQuotaPeak = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.CommitCharge = v_uint64()
        self.QuotaBlock = v_ptr64()
        self.CpuQuotaBlock = v_ptr64()
        self.PeakVirtualSize = v_uint64()
        self.VirtualSize = v_uint64()
        self.SessionProcessLinks = LIST_ENTRY()
        self.DebugPort = v_ptr64()
        self.ExceptionPortData = v_ptr64()
        self.ObjectTable = v_ptr64()
        self.Token = EX_FAST_REF()
        self.WorkingSetPage = v_uint64()
        self.AddressCreationLock = EX_PUSH_LOCK()
        self.RotateInProgress = v_ptr64()
        self.ForkInProgress = v_ptr64()
        self.HardwareTrigger = v_uint64()
        self.PhysicalVadRoot = v_ptr64()
        self.CloneRoot = v_ptr64()
        self.NumberOfPrivatePages = v_uint64()
        self.NumberOfLockedPages = v_uint64()
        self.Win32Process = v_ptr64()
        self.Job = v_ptr64()
        self.SectionObject = v_ptr64()
        self.SectionBaseAddress = v_ptr64()
        self.Cookie = v_uint32()
        self.Spare8 = v_uint32()
        self.WorkingSetWatch = v_ptr64()
        self.Win32WindowStation = v_ptr64()
        self.InheritedFromUniqueProcessId = v_ptr64()
        self.LdtInformation = v_ptr64()
        self.Spare = v_ptr64()
        self.ConsoleHostProcess = v_uint64()
        self.DeviceMap = v_ptr64()
        self.EtwDataSource = v_ptr64()
        self.FreeTebHint = v_ptr64()
        self.PageDirectoryPte = HARDWARE_PTE()
        self.Session = v_ptr64()
        self.ImageFileName = vstruct.VArray([ v_uint8() for i in xrange(15) ])
        self.PriorityClass = v_uint8()
        self.JobLinks = LIST_ENTRY()
        self.LockedPagesList = v_ptr64()
        self.ThreadListHead = LIST_ENTRY()
        self.SecurityPort = v_ptr64()
        self.Wow64Process = v_ptr64()
        self.ActiveThreads = v_uint32()
        self.ImagePathHash = v_uint32()
        self.DefaultHardErrorProcessing = v_uint32()
        self.LastThreadExitStatus = v_uint32()
        self.Peb = v_ptr64()
        self.PrefetchTrace = EX_FAST_REF()
        self.ReadOperationCount = LARGE_INTEGER()
        self.WriteOperationCount = LARGE_INTEGER()
        self.OtherOperationCount = LARGE_INTEGER()
        self.ReadTransferCount = LARGE_INTEGER()
        self.WriteTransferCount = LARGE_INTEGER()
        self.OtherTransferCount = LARGE_INTEGER()
        self.CommitChargeLimit = v_uint64()
        self.CommitChargePeak = v_uint64()
        self.AweInfo = v_ptr64()
        self.SeAuditProcessCreationInfo = SE_AUDIT_PROCESS_CREATION_INFO()
        self.Vm = MMSUPPORT()
        self.MmProcessLinks = LIST_ENTRY()
        self.HighestUserAddress = v_ptr64()
        self.ModifiedPageCount = v_uint32()
        self.Flags2 = v_uint32()
        self.Flags = v_uint32()
        self.ExitStatus = v_uint32()
        self.VadRoot = MM_AVL_TABLE()
        self.AlpcContext = ALPC_PROCESS_CONTEXT()
        self.TimerResolutionLink = LIST_ENTRY()
        self.RequestedTimerResolution = v_uint32()
        self.ActiveThreadsHighWatermark = v_uint32()
        self.SmallestTimerResolution = v_uint32()
        self._pad04c0 = v_bytes(size=4)
        self.TimerResolutionStackRecord = v_ptr64()


class TP_TASK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callbacks = v_ptr64()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()
        self._pad0010 = v_bytes(size=3)
        self.PostGuard = TP_NBQ_GUARD()
        self.NBQNode = v_ptr64()


class TEB_ACTIVE_FRAME_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FrameName = v_ptr64()


class KTIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.DueTime = ULARGE_INTEGER()
        self.TimerListEntry = LIST_ENTRY()
        self.Dpc = v_ptr64()
        self.Processor = v_uint32()
        self.Period = v_uint32()


class _unnamed_7896(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Srb = v_ptr64()


class CM_PARTIAL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Flags = v_uint16()
        self.u = _unnamed_9396()


class OBJECT_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.RootDirectory = v_ptr64()
        self.ObjectName = v_ptr64()
        self.Attributes = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.SecurityDescriptor = v_ptr64()
        self.SecurityQualityOfService = v_ptr64()


class CM_FULL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.PartialResourceList = CM_PARTIAL_RESOURCE_LIST()


class KTIMER_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TimerExpiry = vstruct.VArray([ v_ptr64() for i in xrange(64) ])
        self.TimerEntries = vstruct.VArray([ KTIMER_TABLE_ENTRY() for i in xrange(256) ])


class FAST_IO_DISPATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFastIoDispatch = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FastIoCheckIfPossible = v_ptr64()
        self.FastIoRead = v_ptr64()
        self.FastIoWrite = v_ptr64()
        self.FastIoQueryBasicInfo = v_ptr64()
        self.FastIoQueryStandardInfo = v_ptr64()
        self.FastIoLock = v_ptr64()
        self.FastIoUnlockSingle = v_ptr64()
        self.FastIoUnlockAll = v_ptr64()
        self.FastIoUnlockAllByKey = v_ptr64()
        self.FastIoDeviceControl = v_ptr64()
        self.AcquireFileForNtCreateSection = v_ptr64()
        self.ReleaseFileForNtCreateSection = v_ptr64()
        self.FastIoDetachDevice = v_ptr64()
        self.FastIoQueryNetworkOpenInfo = v_ptr64()
        self.AcquireForModWrite = v_ptr64()
        self.MdlRead = v_ptr64()
        self.MdlReadComplete = v_ptr64()
        self.PrepareMdlWrite = v_ptr64()
        self.MdlWriteComplete = v_ptr64()
        self.FastIoReadCompressed = v_ptr64()
        self.FastIoWriteCompressed = v_ptr64()
        self.MdlReadCompleteCompressed = v_ptr64()
        self.MdlWriteCompleteCompressed = v_ptr64()
        self.FastIoQueryOpen = v_ptr64()
        self.ReleaseForModWrite = v_ptr64()
        self.AcquireForCcFlush = v_ptr64()
        self.ReleaseForCcFlush = v_ptr64()


class RTL_DYNAMIC_HASH_TABLE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ChainHead = v_ptr64()
        self.PrevLinkage = v_ptr64()
        self.Signature = v_uint64()


class MMWSL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class PROC_IDLE_STATE_ACCOUNTING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalTime = v_uint64()
        self.IdleTransitions = v_uint32()
        self.FailedTransitions = v_uint32()
        self.InvalidBucketIndex = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.MinTime = v_uint64()
        self.MaxTime = v_uint64()
        self.IdleTimeBuckets = vstruct.VArray([ PROC_IDLE_STATE_BUCKET() for i in xrange(16) ])


class KGDTENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LimitLow = v_uint16()
        self.BaseLow = v_uint16()
        self.Bytes = _unnamed_6010()
        self.BaseUpper = v_uint32()
        self.MustBeZero = v_uint32()


class KSPECIAL_REGISTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cr0 = v_uint64()
        self.Cr2 = v_uint64()
        self.Cr3 = v_uint64()
        self.Cr4 = v_uint64()
        self.KernelDr0 = v_uint64()
        self.KernelDr1 = v_uint64()
        self.KernelDr2 = v_uint64()
        self.KernelDr3 = v_uint64()
        self.KernelDr6 = v_uint64()
        self.KernelDr7 = v_uint64()
        self.Gdtr = KDESCRIPTOR()
        self.Idtr = KDESCRIPTOR()
        self.Tr = v_uint16()
        self.Ldtr = v_uint16()
        self.MxCsr = v_uint32()
        self.DebugControl = v_uint64()
        self.LastBranchToRip = v_uint64()
        self.LastBranchFromRip = v_uint64()
        self.LastExceptionToRip = v_uint64()
        self.LastExceptionFromRip = v_uint64()
        self.Cr8 = v_uint64()
        self.MsrGsBase = v_uint64()
        self.MsrGsSwap = v_uint64()
        self.MsrStar = v_uint64()
        self.MsrLStar = v_uint64()
        self.MsrCStar = v_uint64()
        self.MsrSyscallMask = v_uint64()


class _unnamed_9666(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length48 = v_uint32()


class RTL_CRITICAL_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DebugInfo = v_ptr64()
        self.LockCount = v_uint32()
        self.RecursionCount = v_uint32()
        self.OwningThread = v_ptr64()
        self.LockSemaphore = v_ptr64()
        self.SpinCount = v_uint64()


class _unnamed_9663(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length40 = v_uint32()


class KSYSTEM_TIME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.High1Time = v_uint32()
        self.High2Time = v_uint32()


class PROC_IDLE_STATE_BUCKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalTime = v_uint64()
        self.MinTime = v_uint64()
        self.MaxTime = v_uint64()
        self.Count = v_uint32()
        self._pad0020 = v_bytes(size=4)


class RTL_STD_LIST_HEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Lock = RTL_STACK_DATABASE_LOCK()


class _unnamed_9669(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length64 = v_uint32()


class DPH_HEAP_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pNextAlloc = v_ptr64()
        self._pad0020 = v_bytes(size=24)
        self.pUserAllocation = v_ptr64()
        self.pVirtualBlock = v_ptr64()
        self.nVirtualBlockSize = v_uint64()
        self.nVirtualAccessSize = v_uint64()
        self.nUserRequestedSize = v_uint64()
        self.nUserActualSize = v_uint64()
        self.UserValue = v_ptr64()
        self.UserFlags = v_uint32()
        self._pad0060 = v_bytes(size=4)
        self.StackTrace = v_ptr64()
        self.AdjacencyEntry = LIST_ENTRY()
        self.pVirtualRegion = v_ptr64()


class _unnamed_7639(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserApcRoutine = v_ptr64()
        self.UserApcContext = v_ptr64()


class LUID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Luid = LUID()
        self.Attributes = v_uint32()


class _unnamed_8013(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InPath = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self._pad0008 = v_bytes(size=4)
        self.Type = v_uint32()
        self._pad0010 = v_bytes(size=4)


class IMAGE_NT_HEADERS64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.FileHeader = IMAGE_FILE_HEADER()
        self.OptionalHeader = IMAGE_OPTIONAL_HEADER64()


class HEAP_BUCKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BlockUnits = v_uint16()
        self.SizeIndex = v_uint8()
        self.UseAffinity = v_uint8()


class KTHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.CycleTime = v_uint64()
        self.QuantumTarget = v_uint64()
        self.InitialStack = v_ptr64()
        self.StackLimit = v_ptr64()
        self.KernelStack = v_ptr64()
        self.ThreadLock = v_uint64()
        self.WaitRegister = KWAIT_STATUS_REGISTER()
        self.Running = v_uint8()
        self.Alerted = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.KernelStackResident = v_uint32()
        self.ApcState = KAPC_STATE()
        self.DeferredProcessor = v_uint32()
        self._pad0088 = v_bytes(size=4)
        self.ApcQueueLock = v_uint64()
        self.WaitStatus = v_uint64()
        self.WaitBlockList = v_ptr64()
        self.WaitListEntry = LIST_ENTRY()
        self.Queue = v_ptr64()
        self.Teb = v_ptr64()
        self.Timer = KTIMER()
        self.AutoAlignment = v_uint32()
        self.Spare0 = v_uint32()
        self.WaitBlock = vstruct.VArray([ KWAIT_BLOCK() for i in xrange(4) ])
        self.QueueListEntry = LIST_ENTRY()
        self.TrapFrame = v_ptr64()
        self.FirstArgument = v_ptr64()
        self.CallbackStack = v_ptr64()
        self.ApcStateIndex = v_uint8()
        self.BasePriority = v_uint8()
        self.PriorityDecrement = v_uint8()
        self.Preempted = v_uint8()
        self.AdjustReason = v_uint8()
        self.AdjustIncrement = v_uint8()
        self.PreviousMode = v_uint8()
        self.Saturation = v_uint8()
        self.SystemCallNumber = v_uint32()
        self.FreezeCount = v_uint32()
        self.UserAffinity = GROUP_AFFINITY()
        self.Process = v_ptr64()
        self.Affinity = GROUP_AFFINITY()
        self.IdealProcessor = v_uint32()
        self.UserIdealProcessor = v_uint32()
        self.ApcStatePointer = vstruct.VArray([ v_ptr64() for i in xrange(2) ])
        self.SavedApcState = KAPC_STATE()
        self.Win32Thread = v_ptr64()
        self.StackBase = v_ptr64()
        self.SuspendApc = KAPC()
        self.SuspendSemaphore = KSEMAPHORE()
        self.ThreadListEntry = LIST_ENTRY()
        self.MutantListHead = LIST_ENTRY()
        self.SListFaultAddress = v_ptr64()
        self.ReadOperationCount = v_uint64()
        self.WriteOperationCount = v_uint64()
        self.OtherOperationCount = v_uint64()
        self.ReadTransferCount = v_uint64()
        self.WriteTransferCount = v_uint64()
        self.OtherTransferCount = v_uint64()
        self.ThreadCounters = v_ptr64()
        self.XStateSave = v_ptr64()


class _unnamed_8934(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BankNumber = v_uint8()
        self.Reserved2 = vstruct.VArray([ v_uint8() for i in xrange(7) ])
        self.Status = MCI_STATS()
        self.Address = MCI_ADDR()
        self.Misc = v_uint64()


class _unnamed_7758(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Key = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.ByteOffset = LARGE_INTEGER()


class CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P1Home = v_uint64()
        self.P2Home = v_uint64()
        self.P3Home = v_uint64()
        self.P4Home = v_uint64()
        self.P5Home = v_uint64()
        self.P6Home = v_uint64()
        self.ContextFlags = v_uint32()
        self.MxCsr = v_uint32()
        self.SegCs = v_uint16()
        self.SegDs = v_uint16()
        self.SegEs = v_uint16()
        self.SegFs = v_uint16()
        self.SegGs = v_uint16()
        self.SegSs = v_uint16()
        self.EFlags = v_uint32()
        self.Dr0 = v_uint64()
        self.Dr1 = v_uint64()
        self.Dr2 = v_uint64()
        self.Dr3 = v_uint64()
        self.Dr6 = v_uint64()
        self.Dr7 = v_uint64()
        self.Rax = v_uint64()
        self.Rcx = v_uint64()
        self.Rdx = v_uint64()
        self.Rbx = v_uint64()
        self.Rsp = v_uint64()
        self.Rbp = v_uint64()
        self.Rsi = v_uint64()
        self.Rdi = v_uint64()
        self.R8 = v_uint64()
        self.R9 = v_uint64()
        self.R10 = v_uint64()
        self.R11 = v_uint64()
        self.R12 = v_uint64()
        self.R13 = v_uint64()
        self.R14 = v_uint64()
        self.R15 = v_uint64()
        self.Rip = v_uint64()
        self.FltSave = XSAVE_FORMAT()
        self.VectorRegister = vstruct.VArray([ M128A() for i in xrange(26) ])
        self.VectorControl = v_uint64()
        self.DebugControl = v_uint64()
        self.LastBranchToRip = v_uint64()
        self.LastBranchFromRip = v_uint64()
        self.LastExceptionToRip = v_uint64()
        self.LastExceptionFromRip = v_uint64()


class MCI_STATS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MciStatus = _unnamed_8929()


class _unnamed_7751(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr64()
        self.Options = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self._pad0018 = v_bytes(size=4)
        self.Parameters = v_ptr64()


class _unnamed_8940(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_uint64()
        self.Type = v_uint64()


class PROC_PERF_LOAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BusyPercentage = v_uint8()
        self.FrequencyPercentage = v_uint8()


class AUX_ACCESS_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegesUsed = v_ptr64()
        self.GenericMapping = GENERIC_MAPPING()
        self.AccessesToAudit = v_uint32()
        self.MaximumAuditMask = v_uint32()
        self.TransactionId = GUID()
        self.NewSecurityDescriptor = v_ptr64()
        self.ExistingSecurityDescriptor = v_ptr64()
        self.ParentSecurityDescriptor = v_ptr64()
        self.DeRefSecurityDescriptor = v_ptr64()
        self.SDLock = v_ptr64()
        self.AccessReasons = ACCESS_REASONS()


class HEAP_LOCAL_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeletedSubSegments = SLIST_HEADER()
        self.CrtZone = v_ptr64()
        self.LowFragHeap = v_ptr64()
        self.Sequence = v_uint32()
        self._pad0030 = v_bytes(size=12)
        self.SegmentInfo = vstruct.VArray([ HEAP_LOCAL_SEGMENT_INFO() for i in xrange(128) ])


class DPH_BLOCK_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartStamp = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Heap = v_ptr64()
        self.RequestedSize = v_uint64()
        self.ActualSize = v_uint64()
        self.FreeQueue = LIST_ENTRY()
        self.StackTrace = v_ptr64()
        self.Padding = v_uint32()
        self.EndStamp = v_uint32()


class PF_KERNEL_GLOBALS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AccessBufferAgeThreshold = v_uint64()
        self.AccessBufferRef = EX_RUNDOWN_REF()
        self.AccessBufferExistsEvent = KEVENT()
        self.AccessBufferMax = v_uint32()
        self._pad0040 = v_bytes(size=20)
        self.AccessBufferList = SLIST_HEADER()
        self.StreamSequenceNumber = v_uint32()
        self.Flags = v_uint32()
        self.ScenarioPrefetchCount = v_uint32()
        self._pad0060 = v_bytes(size=4)


class _unnamed_7918(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()


class EVENT_DATA_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Ptr = v_uint64()
        self.Size = v_uint32()
        self.Reserved = v_uint32()


class _unnamed_8834(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FilePointerIndex = v_uint32()


class _unnamed_8835(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FilePointerIndex = v_uint32()


class _unnamed_7858(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FsInformationClass = v_uint32()
        self._pad0010 = v_bytes(size=4)


class IO_DRIVER_CREATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=6)
        self.ExtraCreateParameter = v_ptr64()
        self.DeviceObjectHint = v_ptr64()
        self.TxnParameters = v_ptr64()


class EJOB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Event = KEVENT()
        self.JobLinks = LIST_ENTRY()
        self.ProcessListHead = LIST_ENTRY()
        self.JobLock = ERESOURCE()
        self.TotalUserTime = LARGE_INTEGER()
        self.TotalKernelTime = LARGE_INTEGER()
        self.ThisPeriodTotalUserTime = LARGE_INTEGER()
        self.ThisPeriodTotalKernelTime = LARGE_INTEGER()
        self.TotalPageFaultCount = v_uint32()
        self.TotalProcesses = v_uint32()
        self.ActiveProcesses = v_uint32()
        self.TotalTerminatedProcesses = v_uint32()
        self.PerProcessUserTimeLimit = LARGE_INTEGER()
        self.PerJobUserTimeLimit = LARGE_INTEGER()
        self.MinimumWorkingSetSize = v_uint64()
        self.MaximumWorkingSetSize = v_uint64()
        self.LimitFlags = v_uint32()
        self.ActiveProcessLimit = v_uint32()
        self.Affinity = KAFFINITY_EX()
        self.PriorityClass = v_uint8()
        self._pad0128 = v_bytes(size=7)
        self.AccessState = v_ptr64()
        self.UIRestrictionsClass = v_uint32()
        self.EndOfJobTimeAction = v_uint32()
        self.CompletionPort = v_ptr64()
        self.CompletionKey = v_ptr64()
        self.SessionId = v_uint32()
        self.SchedulingClass = v_uint32()
        self.ReadOperationCount = v_uint64()
        self.WriteOperationCount = v_uint64()
        self.OtherOperationCount = v_uint64()
        self.ReadTransferCount = v_uint64()
        self.WriteTransferCount = v_uint64()
        self.OtherTransferCount = v_uint64()
        self.ProcessMemoryLimit = v_uint64()
        self.JobMemoryLimit = v_uint64()
        self.PeakProcessMemoryUsed = v_uint64()
        self.PeakJobMemoryUsed = v_uint64()
        self.CurrentJobMemoryUsed = v_uint64()
        self.MemoryLimitsLock = EX_PUSH_LOCK()
        self.JobSetLinks = LIST_ENTRY()
        self.MemberLevel = v_uint32()
        self.JobFlags = v_uint32()


class HANDLE_TRACE_DEBUG_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RefCount = v_uint32()
        self.TableSize = v_uint32()
        self.BitMaskFlags = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.CloseCompactionLock = FAST_MUTEX()
        self.CurrentStackIndex = v_uint32()
        self._pad0050 = v_bytes(size=4)
        self.TraceDb = vstruct.VArray([ HANDLE_TRACE_DB_ENTRY() for i in xrange(1) ])


class KPROCESSOR_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SpecialRegisters = KSPECIAL_REGISTERS()
        self._pad00e0 = v_bytes(size=8)
        self.ContextFrame = CONTEXT()


class KAPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.SpareByte0 = v_uint8()
        self.Size = v_uint8()
        self.SpareByte1 = v_uint8()
        self.SpareLong0 = v_uint32()
        self.Thread = v_ptr64()
        self.ApcListEntry = LIST_ENTRY()
        self.KernelRoutine = v_ptr64()
        self.RundownRoutine = v_ptr64()
        self.NormalRoutine = v_ptr64()
        self.NormalContext = v_ptr64()
        self.SystemArgument1 = v_ptr64()
        self.SystemArgument2 = v_ptr64()
        self.ApcStateIndex = v_uint8()
        self.ApcMode = v_uint8()
        self.Inserted = v_uint8()
        self._pad0058 = v_bytes(size=5)


class RTL_STACK_DATABASE_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = RTL_SRWLOCK()


class SID_IDENTIFIER_AUTHORITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Value = vstruct.VArray([ v_uint8() for i in xrange(6) ])


class _unnamed_9235(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsULONG = v_uint32()


class XSTATE_FEATURE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.Size = v_uint32()


class WHEA_TIMESTAMP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Seconds = v_uint64()


class ACTIVATION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class RTL_CRITICAL_SECTION_DEBUG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.CriticalSection = v_ptr64()
        self.ProcessLocksList = LIST_ENTRY()
        self.EntryCount = v_uint32()
        self.ContentionCount = v_uint32()
        self.Flags = v_uint32()
        self.CreatorBackTraceIndexHigh = v_uint16()
        self.SpareUSHORT = v_uint16()


class DISPATCHER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.TimerControlFlags = v_uint8()
        self.ThreadControlFlags = v_uint8()
        self.TimerMiscFlags = v_uint8()
        self.SignalState = v_uint32()
        self.WaitListHead = LIST_ENTRY()


class ASSEMBLY_STORAGE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class PROCESSOR_POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleStates = v_ptr64()
        self.IdleTimeLast = v_uint64()
        self.IdleTimeTotal = v_uint64()
        self.IdleTimeEntry = v_uint64()
        self.IdleAccounting = v_ptr64()
        self.Hypervisor = v_uint32()
        self.PerfHistoryTotal = v_uint32()
        self.ThermalConstraint = v_uint8()
        self.PerfHistoryCount = v_uint8()
        self.PerfHistorySlot = v_uint8()
        self.Reserved = v_uint8()
        self.LastSysTime = v_uint32()
        self.WmiDispatchPtr = v_uint64()
        self.WmiInterfaceEnabled = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.FFHThrottleStateInfo = PPM_FFH_THROTTLE_STATE_INFO()
        self.PerfActionDpc = KDPC()
        self.PerfActionMask = v_uint32()
        self._pad00b0 = v_bytes(size=4)
        self.IdleCheck = PROC_IDLE_SNAP()
        self.PerfCheck = PROC_IDLE_SNAP()
        self.Domain = v_ptr64()
        self.PerfConstraint = v_ptr64()
        self.Load = v_ptr64()
        self.PerfHistory = v_ptr64()
        self.Utility = v_uint32()
        self.OverUtilizedHistory = v_uint32()
        self.AffinityCount = v_uint32()
        self.AffinityHistory = v_uint32()


class _unnamed_8058(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemContext = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Type = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.State = POWER_STATE()
        self._pad0018 = v_bytes(size=4)
        self.ShutdownType = v_uint32()
        self._pad0020 = v_bytes(size=4)


class POWER_SEQUENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SequenceD1 = v_uint32()
        self.SequenceD2 = v_uint32()
        self.SequenceD3 = v_uint32()


class DPH_HEAP_ROOT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.HeapFlags = v_uint32()
        self.HeapCritSect = v_ptr64()
        self.nRemoteLockAcquired = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.pVirtualStorageListHead = v_ptr64()
        self.pVirtualStorageListTail = v_ptr64()
        self.nVirtualStorageRanges = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.nVirtualStorageBytes = v_uint64()
        self.BusyNodesTable = RTL_AVL_TABLE()
        self.NodeToAllocate = v_ptr64()
        self.nBusyAllocations = v_uint32()
        self._pad00b0 = v_bytes(size=4)
        self.nBusyAllocationBytesCommitted = v_uint64()
        self.pFreeAllocationListHead = v_ptr64()
        self.pFreeAllocationListTail = v_ptr64()
        self.nFreeAllocations = v_uint32()
        self._pad00d0 = v_bytes(size=4)
        self.nFreeAllocationBytesCommitted = v_uint64()
        self.AvailableAllocationHead = LIST_ENTRY()
        self.nAvailableAllocations = v_uint32()
        self._pad00f0 = v_bytes(size=4)
        self.nAvailableAllocationBytesCommitted = v_uint64()
        self.pUnusedNodeListHead = v_ptr64()
        self.pUnusedNodeListTail = v_ptr64()
        self.nUnusedNodes = v_uint32()
        self._pad0110 = v_bytes(size=4)
        self.nBusyAllocationBytesAccessible = v_uint64()
        self.pNodePoolListHead = v_ptr64()
        self.pNodePoolListTail = v_ptr64()
        self.nNodePools = v_uint32()
        self._pad0130 = v_bytes(size=4)
        self.nNodePoolBytes = v_uint64()
        self.NextHeap = LIST_ENTRY()
        self.ExtraFlags = v_uint32()
        self.Seed = v_uint32()
        self.NormalHeap = v_ptr64()
        self.CreateStackTrace = v_ptr64()
        self.FirstThread = v_ptr64()


class JOB_ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class SECURITY_QUALITY_OF_SERVICE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.ImpersonationLevel = v_uint32()
        self.ContextTrackingMode = v_uint8()
        self.EffectiveOnly = v_uint8()
        self._pad000c = v_bytes(size=2)


class COMPRESSED_DATA_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CompressionFormatAndEngine = v_uint16()
        self.CompressionUnitShift = v_uint8()
        self.ChunkShift = v_uint8()
        self.ClusterShift = v_uint8()
        self.Reserved = v_uint8()
        self.NumberOfChunks = v_uint16()
        self.CompressedChunkSizes = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class KSTACK_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StackControl = KERNEL_STACK_CONTROL()
        self.NpxFrame = XSAVE_FORMAT()


class WHEA_ERROR_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = WHEA_ERROR_RECORD_HEADER()
        self.SectionDescriptor = vstruct.VArray([ WHEA_ERROR_RECORD_SECTION_DESCRIPTOR() for i in xrange(1) ])


class PS_PER_CPU_QUOTA_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SortedListEntry = LIST_ENTRY()
        self.IdleOnlyListHead = LIST_ENTRY()
        self.CycleBaseAllowance = v_uint64()
        self.CyclesRemaining = v_uint64()
        self.CurrentGeneration = v_uint32()
        self._pad0040 = v_bytes(size=12)


class PROC_PERF_CONSTRAINT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Prcb = v_ptr64()
        self.PerfContext = v_uint64()
        self.PercentageCap = v_uint32()
        self.ThermalCap = v_uint32()
        self.TargetFrequency = v_uint32()
        self.AcumulatedFullFrequency = v_uint32()
        self.AcumulatedZeroFrequency = v_uint32()
        self.FrequencyHistoryTotal = v_uint32()
        self.AverageFrequency = v_uint32()
        self._pad0030 = v_bytes(size=4)


class LUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class CLIENT_ID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_ptr64()
        self.UniqueThread = v_ptr64()


class IMAGE_OPTIONAL_HEADER64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint16()
        self.MajorLinkerVersion = v_uint8()
        self.MinorLinkerVersion = v_uint8()
        self.SizeOfCode = v_uint32()
        self.SizeOfInitializedData = v_uint32()
        self.SizeOfUninitializedData = v_uint32()
        self.AddressOfEntryPoint = v_uint32()
        self.BaseOfCode = v_uint32()
        self.ImageBase = v_uint64()
        self.SectionAlignment = v_uint32()
        self.FileAlignment = v_uint32()
        self.MajorOperatingSystemVersion = v_uint16()
        self.MinorOperatingSystemVersion = v_uint16()
        self.MajorImageVersion = v_uint16()
        self.MinorImageVersion = v_uint16()
        self.MajorSubsystemVersion = v_uint16()
        self.MinorSubsystemVersion = v_uint16()
        self.Win32VersionValue = v_uint32()
        self.SizeOfImage = v_uint32()
        self.SizeOfHeaders = v_uint32()
        self.CheckSum = v_uint32()
        self.Subsystem = v_uint16()
        self.DllCharacteristics = v_uint16()
        self.SizeOfStackReserve = v_uint64()
        self.SizeOfStackCommit = v_uint64()
        self.SizeOfHeapReserve = v_uint64()
        self.SizeOfHeapCommit = v_uint64()
        self.LoaderFlags = v_uint32()
        self.NumberOfRvaAndSizes = v_uint32()
        self.DataDirectory = vstruct.VArray([ IMAGE_DATA_DIRECTORY() for i in xrange(16) ])


class RTL_STACK_TRACE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashChain = RTL_STD_LIST_ENTRY()
        self.TraceCount = v_uint16()
        self.IndexHigh = v_uint16()
        self.Index = v_uint16()
        self.Depth = v_uint16()
        self.BackTrace = vstruct.VArray([ v_ptr64() for i in xrange(32) ])


class OBJECT_DUMP_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Stream = v_ptr64()
        self.Detail = v_uint32()
        self._pad0010 = v_bytes(size=4)


class HANDLE_TRACE_DB_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientId = CLIENT_ID()
        self.Handle = v_ptr64()
        self.Type = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.StackTrace = vstruct.VArray([ v_ptr64() for i in xrange(16) ])


class GENERAL_LOOKASIDE_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr64()
        self.FreeEx = v_ptr64()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])


class RTL_SRWLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint64()


class STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_ptr64()


class _unnamed_7211(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self._pad0048 = v_bytes(size=56)


class TP_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class LIST_ENTRY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint32()
        self.Blink = v_uint32()


class KDESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pad = vstruct.VArray([ v_uint16() for i in xrange(3) ])
        self.Limit = v_uint16()
        self.Base = v_ptr64()


class SINGLE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()


class PPM_FFH_THROTTLE_STATE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnableLogging = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.MismatchCount = v_uint32()
        self.Initialized = v_uint8()
        self._pad0010 = v_bytes(size=7)
        self.LastValue = v_uint64()
        self.LastLogTickCount = LARGE_INTEGER()


class _unnamed_7819(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FileName = v_ptr64()
        self.FileInformationClass = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.FileIndex = v_uint32()
        self._pad0020 = v_bytes(size=4)


class KDEVICE_QUEUE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceListEntry = LIST_ENTRY()
        self.SortKey = v_uint32()
        self.Inserted = v_uint8()
        self._pad0018 = v_bytes(size=3)


class CACHED_KSTACK_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SListHead = SLIST_HEADER()
        self.MinimumFree = v_uint32()
        self.Misses = v_uint32()
        self.MissesLast = v_uint32()
        self.Pad0 = v_uint32()


class _unnamed_10196(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.MinBusNumber = v_uint32()
        self.MaxBusNumber = v_uint32()
        self.Reserved = v_uint32()


class _unnamed_10193(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumChannel = v_uint32()
        self.MaximumChannel = v_uint32()


class EX_FAST_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr64()


class INTERLOCK_SEQ(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint16()
        self.FreeEntryOffset = v_uint16()
        self.Sequence = v_uint32()


class KSPIN_LOCK_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Lock = v_ptr64()


class RTL_ACTIVATION_CONTEXT_STACK_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Previous = v_ptr64()
        self.ActivationContext = v_ptr64()
        self.Flags = v_uint32()
        self._pad0018 = v_bytes(size=4)


class FS_FILTER_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbacks = v_uint32()
        self.Reserved = v_uint32()
        self.PreAcquireForSectionSynchronization = v_ptr64()
        self.PostAcquireForSectionSynchronization = v_ptr64()
        self.PreReleaseForSectionSynchronization = v_ptr64()
        self.PostReleaseForSectionSynchronization = v_ptr64()
        self.PreAcquireForCcFlush = v_ptr64()
        self.PostAcquireForCcFlush = v_ptr64()
        self.PreReleaseForCcFlush = v_ptr64()
        self.PostReleaseForCcFlush = v_ptr64()
        self.PreAcquireForModifiedPageWriter = v_ptr64()
        self.PostAcquireForModifiedPageWriter = v_ptr64()
        self.PreReleaseForModifiedPageWriter = v_ptr64()
        self.PostReleaseForModifiedPageWriter = v_ptr64()


class HANDLE_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr64()
        self.GrantedAccess = v_uint32()
        self._pad0010 = v_bytes(size=4)


class IO_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Option = v_uint8()
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Spare1 = v_uint8()
        self.Flags = v_uint16()
        self.Spare2 = v_uint16()
        self.u = _unnamed_9587()


class EX_PUSH_LOCK_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locks = vstruct.VArray([ v_ptr64() for i in xrange(32) ])


class RTL_TRACE_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint32()
        self.Count = v_uint32()
        self.Size = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.UserCount = v_uint64()
        self.UserSize = v_uint64()
        self.UserContext = v_ptr64()
        self.Next = v_ptr64()
        self.Trace = v_ptr64()


class _unnamed_7969(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Capabilities = v_ptr64()


class SCSI_REQUEST_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ETHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Tcb = KTHREAD()
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self._pad0378 = v_bytes(size=8)
        self.ExitStatus = v_uint32()
        self._pad0380 = v_bytes(size=4)
        self.PostBlockList = LIST_ENTRY()
        self.TerminationPort = v_ptr64()
        self.ActiveTimerListLock = v_uint64()
        self.ActiveTimerListHead = LIST_ENTRY()
        self.Cid = CLIENT_ID()
        self.KeyedWaitSemaphore = KSEMAPHORE()
        self.ClientSecurity = PS_CLIENT_SECURITY_CONTEXT()
        self.IrpList = LIST_ENTRY()
        self.TopLevelIrp = v_uint64()
        self.DeviceToVerify = v_ptr64()
        self.CpuQuotaApc = v_ptr64()
        self.Win32StartAddress = v_ptr64()
        self.LegacyPowerObject = v_ptr64()
        self.ThreadListEntry = LIST_ENTRY()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.ThreadLock = EX_PUSH_LOCK()
        self.ReadClusterSize = v_uint32()
        self.MmLockOrdering = v_uint32()
        self.CrossThreadFlags = v_uint32()
        self.SameThreadPassiveFlags = v_uint32()
        self.SameThreadApcFlags = v_uint32()
        self.CacheManagerActive = v_uint8()
        self.DisablePageFaultClustering = v_uint8()
        self.ActiveFaultCount = v_uint8()
        self.LockOrderState = v_uint8()
        self.AlpcMessageId = v_uint64()
        self.AlpcMessage = v_ptr64()
        self.AlpcWaitListEntry = LIST_ENTRY()
        self.CacheManagerCount = v_uint32()
        self.IoBoostCount = v_uint32()
        self.IrpListLock = v_uint64()
        self.ReservedForSynchTracking = v_ptr64()
        self.CmCallbackListHead = SINGLE_LIST_ENTRY()


class FAST_MUTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Owner = v_ptr64()
        self.Contention = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Event = KEVENT()
        self.OldIrql = v_uint32()
        self._pad0038 = v_bytes(size=4)


class WHEA_ERROR_RECORD_HEADER_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PlatformId = v_uint32()


class KDEVICE_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DeviceListHead = LIST_ENTRY()
        self.Lock = v_uint64()
        self.Busy = v_uint8()
        self._pad0028 = v_bytes(size=7)


class IO_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityQos = v_ptr64()
        self.AccessState = v_ptr64()
        self.DesiredAccess = v_uint32()
        self.FullCreateOptions = v_uint32()


class TERMINATION_PORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Port = v_ptr64()


class PROC_HISTORY_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Utility = v_uint16()
        self.Frequency = v_uint8()
        self.Reserved = v_uint8()


class _unnamed_7831(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FileInformationClass = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.FileObject = v_ptr64()
        self.ReplaceIfExists = v_uint8()
        self.AdvanceOnly = v_uint8()
        self._pad0020 = v_bytes(size=6)


class IO_CLIENT_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextExtension = v_ptr64()
        self.ClientIdentificationAddress = v_ptr64()


class INITIAL_PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(3) ])


class WHEA_ERROR_RECORD_HEADER_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Recovered = v_uint32()


class KTIMER_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint64()
        self.Entry = LIST_ENTRY()
        self.Time = ULARGE_INTEGER()


class _unnamed_9653(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(3) ])


class KWAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitListEntry = LIST_ENTRY()
        self.Thread = v_ptr64()
        self.Object = v_ptr64()
        self.NextWaitBlock = v_ptr64()
        self.WaitKey = v_uint16()
        self.WaitType = v_uint8()
        self.BlockState = v_uint8()
        self.SpareLong = v_uint32()


class _unnamed_9655(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint32()
        self.Length = v_uint32()
        self.Reserved = v_uint32()


class _unnamed_9659(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class ACTIVATION_CONTEXT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_7624(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsynchronousParameters = _unnamed_7639()


class _unnamed_7627(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Overlay = _unnamed_7700()
        self._pad0058 = v_bytes(size=8)


class _unnamed_7621(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MasterIrp = v_ptr64()


class FILE_NETWORK_OPEN_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0038 = v_bytes(size=4)


class HEAP_USERDATA_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SFreeListEntry = SINGLE_LIST_ENTRY()
        self.Reserved = v_ptr64()
        self.SizeIndex = v_uint64()
        self.Signature = v_uint64()


class _unnamed_8025(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerState = v_uint32()


class RTL_DRIVE_LETTER_CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint16()
        self.Length = v_uint16()
        self.TimeStamp = v_uint32()
        self.DosPath = STRING()


class KIDTENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OffsetLow = v_uint16()
        self.Selector = v_uint16()
        self.IstIndex = v_uint16()
        self.OffsetMiddle = v_uint16()
        self.OffsetHigh = v_uint32()
        self.Reserved1 = v_uint32()


class CACHE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint8()
        self.Associativity = v_uint8()
        self.LineSize = v_uint16()
        self.Size = v_uint32()
        self.Type = v_uint32()


class ULARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class _unnamed_8922(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mca = _unnamed_8934()


class TEB_ACTIVE_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Previous = v_ptr64()
        self.Context = v_ptr64()


class GENERAL_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr64()
        self.FreeEx = v_ptr64()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self._pad0080 = v_bytes(size=32)


class _unnamed_8929(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.McaErrorCode = v_uint16()
        self.ModelErrorCode = v_uint16()
        self.OtherInformation = v_uint32()


class _unnamed_7723(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr64()
        self.Options = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.FileAttributes = v_uint16()
        self.ShareAccess = v_uint16()
        self._pad0018 = v_bytes(size=4)
        self.EaLength = v_uint32()
        self._pad0020 = v_bytes(size=4)


class KWAIT_STATUS_REGISTER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint8()


class NAMED_PIPE_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NamedPipeType = v_uint32()
        self.ReadMode = v_uint32()
        self.CompletionMode = v_uint32()
        self.MaximumInstances = v_uint32()
        self.InboundQuota = v_uint32()
        self.OutboundQuota = v_uint32()
        self.DefaultTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0028 = v_bytes(size=7)


class _unnamed_7866(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_ptr64()
        self.Key = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.ByteOffset = LARGE_INTEGER()


class NT_TIB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_ptr64()
        self.StackBase = v_ptr64()
        self.StackLimit = v_ptr64()
        self.SubSystemTib = v_ptr64()
        self.FiberData = v_ptr64()
        self.ArbitraryUserPointer = v_ptr64()
        self.Self = v_ptr64()


class RTL_STD_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()


class POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemState = v_uint32()


class UNICODE_STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_ptr64()


class HEAP_LIST_LOOKUP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExtendedLookup = v_ptr64()
        self.ArraySize = v_uint32()
        self.ExtraItem = v_uint32()
        self.ItemCount = v_uint32()
        self.OutOfRangeItems = v_uint32()
        self.BaseIndex = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.ListHead = v_ptr64()
        self.ListsInUseUlong = v_ptr64()
        self.ListHints = v_ptr64()


class EPROCESS_QUOTA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class HEAP_DEBUGGING_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterceptorFunction = v_ptr64()
        self.InterceptorValue = v_uint16()
        self._pad000c = v_bytes(size=2)
        self.ExtendedOptions = v_uint32()
        self.StackTraceDepth = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.MinTotalBlockSize = v_uint64()
        self.MaxTotalBlockSize = v_uint64()
        self.HeapLeakEnumerationRoutine = v_ptr64()


class PEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InheritedAddressSpace = v_uint8()
        self.ReadImageFileExecOptions = v_uint8()
        self.BeingDebugged = v_uint8()
        self.BitField = v_uint8()
        self._pad0008 = v_bytes(size=4)
        self.Mutant = v_ptr64()
        self.ImageBaseAddress = v_ptr64()
        self.Ldr = v_ptr64()
        self.ProcessParameters = v_ptr64()
        self.SubSystemData = v_ptr64()
        self.ProcessHeap = v_ptr64()
        self.FastPebLock = v_ptr64()
        self.AtlThunkSListPtr = v_ptr64()
        self.IFEOKey = v_ptr64()
        self.CrossProcessFlags = v_uint32()
        self._pad0058 = v_bytes(size=4)
        self.KernelCallbackTable = v_ptr64()
        self.SystemReserved = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.AtlThunkSListPtr32 = v_uint32()
        self.ApiSetMap = v_ptr64()
        self.TlsExpansionCounter = v_uint32()
        self._pad0078 = v_bytes(size=4)
        self.TlsBitmap = v_ptr64()
        self.TlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ReadOnlySharedMemoryBase = v_ptr64()
        self.HotpatchInformation = v_ptr64()
        self.ReadOnlyStaticServerData = v_ptr64()
        self.AnsiCodePageData = v_ptr64()
        self.OemCodePageData = v_ptr64()
        self.UnicodeCaseTableData = v_ptr64()
        self.NumberOfProcessors = v_uint32()
        self.NtGlobalFlag = v_uint32()
        self.CriticalSectionTimeout = LARGE_INTEGER()
        self.HeapSegmentReserve = v_uint64()
        self.HeapSegmentCommit = v_uint64()
        self.HeapDeCommitTotalFreeThreshold = v_uint64()
        self.HeapDeCommitFreeBlockThreshold = v_uint64()
        self.NumberOfHeaps = v_uint32()
        self.MaximumNumberOfHeaps = v_uint32()
        self.ProcessHeaps = v_ptr64()
        self.GdiSharedHandleTable = v_ptr64()
        self.ProcessStarterHelper = v_ptr64()
        self.GdiDCAttributeList = v_uint32()
        self._pad0110 = v_bytes(size=4)
        self.LoaderLock = v_ptr64()
        self.OSMajorVersion = v_uint32()
        self.OSMinorVersion = v_uint32()
        self.OSBuildNumber = v_uint16()
        self.OSCSDVersion = v_uint16()
        self.OSPlatformId = v_uint32()
        self.ImageSubsystem = v_uint32()
        self.ImageSubsystemMajorVersion = v_uint32()
        self.ImageSubsystemMinorVersion = v_uint32()
        self._pad0138 = v_bytes(size=4)
        self.ActiveProcessAffinityMask = v_uint64()
        self.GdiHandleBuffer = vstruct.VArray([ v_uint32() for i in xrange(60) ])
        self.PostProcessInitRoutine = v_ptr64()
        self.TlsExpansionBitmap = v_ptr64()
        self.TlsExpansionBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(32) ])
        self.SessionId = v_uint32()
        self._pad02c8 = v_bytes(size=4)
        self.AppCompatFlags = ULARGE_INTEGER()
        self.AppCompatFlagsUser = ULARGE_INTEGER()
        self.pShimData = v_ptr64()
        self.AppCompatInfo = v_ptr64()
        self.CSDVersion = UNICODE_STRING()
        self.ActivationContextData = v_ptr64()
        self.ProcessAssemblyStorageMap = v_ptr64()
        self.SystemDefaultActivationContextData = v_ptr64()
        self.SystemAssemblyStorageMap = v_ptr64()
        self.MinimumStackCommit = v_uint64()
        self.FlsCallback = v_ptr64()
        self.FlsListHead = LIST_ENTRY()
        self.FlsBitmap = v_ptr64()
        self.FlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.FlsHighIndex = v_uint32()
        self._pad0358 = v_bytes(size=4)
        self.WerRegistrationData = v_ptr64()
        self.WerShipAssertPtr = v_ptr64()
        self.pContextData = v_ptr64()
        self.pImageHeaderHash = v_ptr64()
        self.TracingFlags = v_uint32()
        self._pad0380 = v_bytes(size=4)


class _unnamed_7927(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_ptr64()
        self.Size = v_uint16()
        self.Version = v_uint16()
        self._pad0010 = v_bytes(size=4)
        self.Interface = v_ptr64()
        self.InterfaceSpecificData = v_ptr64()


class STACK_TRACE_DATABASE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(104) ])
        self.Reserved2 = v_ptr64()
        self.PeakHashCollisionListLength = v_uint64()
        self.LowerMemoryStart = v_ptr64()
        self.PreCommitted = v_uint8()
        self.DumpInProgress = v_uint8()
        self._pad0088 = v_bytes(size=6)
        self.CommitBase = v_ptr64()
        self.CurrentLowerCommitLimit = v_ptr64()
        self.CurrentUpperCommitLimit = v_ptr64()
        self.NextFreeLowerMemory = v_ptr64()
        self.NextFreeUpperMemory = v_ptr64()
        self.NumberOfEntriesLookedUp = v_uint32()
        self.NumberOfEntriesAdded = v_uint32()
        self.EntryIndexArray = v_ptr64()
        self.NumberOfEntriesAllocated = v_uint32()
        self.NumberOfEntriesAvailable = v_uint32()
        self.NumberOfAllocationFailures = v_uint32()
        self._pad00d0 = v_bytes(size=4)
        self.FreeLists = vstruct.VArray([ SLIST_HEADER() for i in xrange(32) ])
        self.NumberOfBuckets = v_uint32()
        self._pad02d8 = v_bytes(size=4)
        self.Buckets = vstruct.VArray([ RTL_STD_LIST_HEAD() for i in xrange(1) ])
        self._pad02f0 = v_bytes(size=8)


class _unnamed_7844(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()


class KDPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.Importance = v_uint8()
        self.Number = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DpcListEntry = LIST_ENTRY()
        self.DeferredRoutine = v_ptr64()
        self.DeferredContext = v_ptr64()
        self.SystemArgument1 = v_ptr64()
        self.SystemArgument2 = v_ptr64()
        self.DpcData = v_ptr64()


class KEVENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class KSEMAPHORE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.Limit = v_uint32()
        self._pad0020 = v_bytes(size=4)


class MM_PAGE_ACCESS_INFO_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = SINGLE_LIST_ENTRY()
        self.Type = v_uint32()
        self.EmptySequenceNumber = v_uint32()
        self.CreateTime = v_uint64()
        self.EmptyTime = v_uint64()
        self.PageEntry = v_ptr64()
        self.FileEntry = v_ptr64()
        self.FirstFileEntry = v_ptr64()
        self.Process = v_ptr64()
        self.SessionId = v_uint32()
        self._pad0048 = v_bytes(size=4)


class OBJECT_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TypeList = LIST_ENTRY()
        self.Name = UNICODE_STRING()
        self.DefaultObject = v_ptr64()
        self.Index = v_uint8()
        self._pad002c = v_bytes(size=3)
        self.TotalNumberOfObjects = v_uint32()
        self.TotalNumberOfHandles = v_uint32()
        self.HighWaterNumberOfObjects = v_uint32()
        self.HighWaterNumberOfHandles = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.TypeInfo = OBJECT_TYPE_INITIALIZER()
        self.TypeLock = EX_PUSH_LOCK()
        self.Key = v_uint32()
        self._pad00c0 = v_bytes(size=4)
        self.CallbackList = LIST_ENTRY()


class HANDLE_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TableCode = v_uint64()
        self.QuotaProcess = v_ptr64()
        self.UniqueProcessId = v_ptr64()
        self.HandleLock = EX_PUSH_LOCK()
        self.HandleTableList = LIST_ENTRY()
        self.HandleContentionEvent = EX_PUSH_LOCK()
        self.DebugInfo = v_ptr64()
        self.ExtraInfoPages = v_uint32()
        self.Flags = v_uint32()
        self.FirstFreeHandle = v_uint32()
        self._pad0050 = v_bytes(size=4)
        self.LastFreeHandleEntry = v_ptr64()
        self.HandleCount = v_uint32()
        self.NextHandleNeedingPool = v_uint32()
        self.HandleCountHighWatermark = v_uint32()
        self._pad0068 = v_bytes(size=4)


class MMSUPPORT_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkingSetType = v_uint8()
        self.SessionMaster = v_uint8()
        self.MemoryPriority = v_uint8()
        self.WsleDeleted = v_uint8()


class HEAP_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = _unnamed_8532()


class EXCEPTION_REGISTRATION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Handler = v_ptr64()


class FILE_BASIC_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0028 = v_bytes(size=4)


class LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_ptr64()
        self.Blink = v_ptr64()


class M128A(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Low = v_uint64()
        self.High = v_uint64()


class RTL_DYNAMIC_HASH_TABLE_ENUMERATOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashEntry = RTL_DYNAMIC_HASH_TABLE_ENTRY()
        self.ChainHead = v_ptr64()
        self.BucketIndex = v_uint32()
        self._pad0028 = v_bytes(size=4)


class _unnamed_8069(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedResources = v_ptr64()
        self.AllocatedResourcesTranslated = v_ptr64()


class KERNEL_STACK_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Current = KERNEL_STACK_SEGMENT()
        self.Previous = KERNEL_STACK_SEGMENT()


class _unnamed_7661(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Create = _unnamed_7723()


class GUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data1 = v_uint32()
        self.Data2 = v_uint16()
        self.Data3 = v_uint16()
        self.Data4 = vstruct.VArray([ v_uint8() for i in xrange(8) ])


class HEAP_UCR_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.SegmentEntry = LIST_ENTRY()
        self.Address = v_ptr64()
        self.Size = v_uint64()


class MCA_EXCEPTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VersionNumber = v_uint32()
        self.ExceptionType = v_uint32()
        self.TimeStamp = LARGE_INTEGER()
        self.ProcessorNumber = v_uint32()
        self.Reserved1 = v_uint32()
        self.u = _unnamed_8922()
        self.ExtCnt = v_uint32()
        self.Reserved3 = v_uint32()
        self.ExtReg = vstruct.VArray([ v_uint64() for i in xrange(24) ])


class PSP_CPU_QUOTA_APC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class KAPC_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ApcListHead = vstruct.VArray([ LIST_ENTRY() for i in xrange(2) ])
        self.Process = v_ptr64()
        self.KernelApcInProgress = v_uint8()
        self.KernelApcPending = v_uint8()
        self.UserApcPending = v_uint8()
        self._pad0030 = v_bytes(size=5)


class SLIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self._pad0010 = v_bytes(size=8)


class COUNTER_READING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.Index = v_uint32()
        self.Start = v_uint64()
        self.Total = v_uint64()


class KDPC_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DpcListHead = LIST_ENTRY()
        self.DpcLock = v_uint64()
        self.DpcQueueDepth = v_uint32()
        self.DpcCount = v_uint32()


class _unnamed_8532(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CriticalSection = RTL_CRITICAL_SECTION()


class _unnamed_7892(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vpb = v_ptr64()
        self.DeviceObject = v_ptr64()


class IO_STATUS_BLOCK32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.Information = v_uint32()


class XSAVE_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LegacyState = XSAVE_FORMAT()
        self.Header = XSAVE_AREA_HEADER()


class GENERIC_MAPPING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GenericRead = v_uint32()
        self.GenericWrite = v_uint32()
        self.GenericExecute = v_uint32()
        self.GenericAll = v_uint32()


class IRP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.MdlAddress = v_ptr64()
        self.Flags = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.AssociatedIrp = _unnamed_7621()
        self.ThreadListEntry = LIST_ENTRY()
        self.IoStatus = IO_STATUS_BLOCK()
        self.RequestorMode = v_uint8()
        self.PendingReturned = v_uint8()
        self.StackCount = v_uint8()
        self.CurrentLocation = v_uint8()
        self.Cancel = v_uint8()
        self.CancelIrql = v_uint8()
        self.ApcEnvironment = v_uint8()
        self.AllocationFlags = v_uint8()
        self.UserIosb = v_ptr64()
        self.UserEvent = v_ptr64()
        self.Overlay = _unnamed_7624()
        self.CancelRoutine = v_ptr64()
        self.UserBuffer = v_ptr64()
        self.Tail = _unnamed_7627()


class KTHREAD_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitReasonBitMap = v_uint64()
        self.UserData = v_ptr64()
        self.Flags = v_uint32()
        self.ContextSwitches = v_uint32()
        self.CycleTimeBias = v_uint64()
        self.HardwareCounters = v_uint64()
        self.HwCounter = vstruct.VArray([ COUNTER_READING() for i in xrange(16) ])


class HEAP_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousBlockPrivateData = v_ptr64()
        self.Size = v_uint16()
        self.Flags = v_uint8()
        self.SmallTagIndex = v_uint8()
        self.PreviousSize = v_uint16()
        self.SegmentOffset = v_uint8()
        self.UnusedBytes = v_uint8()


class DRIVER_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DeviceObject = v_ptr64()
        self.Flags = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.DriverStart = v_ptr64()
        self.DriverSize = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.DriverSection = v_ptr64()
        self.DriverExtension = v_ptr64()
        self.DriverName = UNICODE_STRING()
        self.HardwareDatabase = v_ptr64()
        self.FastIoDispatch = v_ptr64()
        self.DriverInit = v_ptr64()
        self.DriverStartIo = v_ptr64()
        self.DriverUnload = v_ptr64()
        self.MajorFunction = vstruct.VArray([ v_ptr64() for i in xrange(28) ])


class _unnamed_6629(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint64()
        self.HeaderType = v_uint64()


class _unnamed_6628(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint64()
        self.HeaderType = v_uint64()


class _unnamed_6627(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint64()
        self.HeaderType = v_uint64()


class FILE_GET_QUOTA_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextEntryOffset = v_uint32()
        self.SidLength = v_uint32()
        self.Sid = SID()


class _unnamed_5473(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class KGATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class IO_COMPLETION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = v_ptr64()
        self.Key = v_ptr64()


class DRIVER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DriverObject = v_ptr64()
        self.AddDevice = v_ptr64()
        self.Count = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.ServiceKeyName = UNICODE_STRING()
        self.ClientDriverExtension = v_ptr64()
        self.FsFilterCallbacks = v_ptr64()


class TP_NBQ_GUARD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GuardLinks = LIST_ENTRY()
        self.Guards = vstruct.VArray([ v_ptr64() for i in xrange(2) ])


class flags(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Removable = v_uint8()


class MM_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = MMADDRESS_NODE()
        self.DepthOfTree = v_uint64()
        self.NodeHint = v_ptr64()
        self.NodeFreeHint = v_ptr64()


class WHEA_PERSISTENCE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint64()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FRUId = v_uint8()


class _unnamed_10215(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length64 = v_uint32()
        self.Alignment64 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class EXCEPTION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_ptr64()
        self.ExceptionAddress = v_ptr64()
        self.NumberParameters = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.ExceptionInformation = vstruct.VArray([ v_uint64() for i in xrange(15) ])


class _unnamed_10210(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length48 = v_uint32()
        self.Alignment48 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class PROCESSOR_NUMBER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.Number = v_uint8()
        self.Reserved = v_uint8()


class MM_PAGE_ACCESS_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = MM_PAGE_ACCESS_INFO_FLAGS()
        self._pad0008 = v_bytes(size=4)


class KPCR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.IdtBase = v_ptr64()
        self.Unused = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.Irql = v_uint8()
        self.SecondLevelCacheAssociativity = v_uint8()
        self.ObsoleteNumber = v_uint8()
        self.Fill0 = v_uint8()
        self.Unused0 = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.StallScaleFactor = v_uint32()
        self.Unused1 = vstruct.VArray([ v_ptr64() for i in xrange(3) ])
        self.KernelReserved = vstruct.VArray([ v_uint32() for i in xrange(15) ])
        self.SecondLevelCacheSize = v_uint32()
        self.HalReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.Unused2 = v_uint32()
        self._pad0108 = v_bytes(size=4)
        self.KdVersionBlock = v_ptr64()
        self.Unused3 = v_ptr64()
        self.PcrAlign1 = vstruct.VArray([ v_uint32() for i in xrange(24) ])
        self._pad0180 = v_bytes(size=8)
        self.Prcb = KPRCB()


class IMAGE_FILE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Machine = v_uint16()
        self.NumberOfSections = v_uint16()
        self.TimeDateStamp = v_uint32()
        self.PointerToSymbolTable = v_uint32()
        self.NumberOfSymbols = v_uint32()
        self.SizeOfOptionalHeader = v_uint16()
        self.Characteristics = v_uint16()


class LFH_BLOCK_ZONE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.FreePointer = v_ptr64()
        self.Limit = v_ptr64()


class TP_CALLBACK_INSTANCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class LFH_HEAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = RTL_CRITICAL_SECTION()
        self.SubSegmentZones = LIST_ENTRY()
        self.ZoneBlockSize = v_uint64()
        self.Heap = v_ptr64()
        self.SegmentChange = v_uint32()
        self.SegmentCreate = v_uint32()
        self.SegmentInsertInFree = v_uint32()
        self.SegmentDelete = v_uint32()
        self.CacheAllocs = v_uint32()
        self.CacheFrees = v_uint32()
        self.SizeInCache = v_uint64()
        self.RunInfo = HEAP_BUCKET_RUN_INFO()
        self.UserBlockCache = vstruct.VArray([ USER_MEMORY_CACHE_ENTRY() for i in xrange(12) ])
        self.Buckets = vstruct.VArray([ HEAP_BUCKET() for i in xrange(128) ])
        self.LocalData = vstruct.VArray([ HEAP_LOCAL_DATA() for i in xrange(1) ])


class _unnamed_7983(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoResourceRequirementList = v_ptr64()


class HEAP_BUCKET_RUN_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Bucket = v_uint32()
        self.RunLength = v_uint32()


class PEB_LDR_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Initialized = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.SsHandle = v_ptr64()
        self.InLoadOrderModuleList = LIST_ENTRY()
        self.InMemoryOrderModuleList = LIST_ENTRY()
        self.InInitializationOrderModuleList = LIST_ENTRY()
        self.EntryInProgress = v_ptr64()
        self.ShutdownInProgress = v_uint8()
        self._pad0050 = v_bytes(size=7)
        self.ShutdownThreadId = v_ptr64()


class _unnamed_7986(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WhichSpace = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_ptr64()
        self.Offset = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Length = v_uint32()
        self._pad0020 = v_bytes(size=4)


class KQUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.EntryListHead = LIST_ENTRY()
        self.CurrentCount = v_uint32()
        self.MaximumCount = v_uint32()
        self.ThreadListHead = LIST_ENTRY()


class MM_PAGE_ACCESS_INFO_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.File = _unnamed_8834()


class SECURITY_SUBJECT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientToken = v_ptr64()
        self.ImpersonationLevel = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.PrimaryToken = v_ptr64()
        self.ProcessAuditId = v_ptr64()


class _unnamed_7876(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Length = v_uint32()
        self._pad0010 = v_bytes(size=4)


class _unnamed_7871(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.InputBufferLength = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.IoControlCode = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Type3InputBuffer = v_ptr64()


class INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Context = v_ptr64()
        self.InterfaceReference = v_ptr64()
        self.InterfaceDereference = v_ptr64()


class SLIST_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Alignment = v_uint64()
        self.Region = v_uint64()


class _unnamed_7879(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.SecurityDescriptor = v_ptr64()


class IMAGE_DATA_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_uint32()
        self.Size = v_uint32()


class FILE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DeviceObject = v_ptr64()
        self.Vpb = v_ptr64()
        self.FsContext = v_ptr64()
        self.FsContext2 = v_ptr64()
        self.SectionObjectPointer = v_ptr64()
        self.PrivateCacheMap = v_ptr64()
        self.FinalStatus = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.RelatedFileObject = v_ptr64()
        self.LockOperation = v_uint8()
        self.DeletePending = v_uint8()
        self.ReadAccess = v_uint8()
        self.WriteAccess = v_uint8()
        self.DeleteAccess = v_uint8()
        self.SharedRead = v_uint8()
        self.SharedWrite = v_uint8()
        self.SharedDelete = v_uint8()
        self.Flags = v_uint32()
        self._pad0058 = v_bytes(size=4)
        self.FileName = UNICODE_STRING()
        self.CurrentByteOffset = LARGE_INTEGER()
        self.Waiters = v_uint32()
        self.Busy = v_uint32()
        self.LastLock = v_ptr64()
        self.Lock = KEVENT()
        self.Event = KEVENT()
        self.CompletionContext = v_ptr64()
        self.IrpListLock = v_uint64()
        self.IrpList = LIST_ENTRY()
        self.FileObjectExtension = v_ptr64()


class PPM_IDLE_STATES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Flags = _unnamed_9235()
        self.TargetState = v_uint32()
        self.ActualState = v_uint32()
        self.OldState = v_uint32()
        self.NewlyUnparked = v_uint8()
        self._pad0018 = v_bytes(size=3)
        self.TargetProcessors = KAFFINITY_EX()
        self.State = vstruct.VArray([ PPM_IDLE_STATE() for i in xrange(1) ])


class HEAP_SUBSEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LocalInfo = v_ptr64()
        self.UserBlocks = v_ptr64()
        self.AggregateExchg = INTERLOCK_SEQ()
        self.BlockSize = v_uint16()
        self.Flags = v_uint16()
        self.BlockCount = v_uint16()
        self.SizeIndex = v_uint8()
        self.AffinityIndex = v_uint8()
        self.SFreeListEntry = SINGLE_LIST_ENTRY()
        self.Lock = v_uint32()
        self._pad0030 = v_bytes(size=4)


class ERESOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemResourcesList = LIST_ENTRY()
        self.OwnerTable = v_ptr64()
        self.ActiveCount = v_uint16()
        self.Flag = v_uint16()
        self._pad0020 = v_bytes(size=4)
        self.SharedWaiters = v_ptr64()
        self.ExclusiveWaiters = v_ptr64()
        self.OwnerEntry = OWNER_ENTRY()
        self.ActiveEntries = v_uint32()
        self.ContentionCount = v_uint32()
        self.NumberOfSharedWaiters = v_uint32()
        self.NumberOfExclusiveWaiters = v_uint32()
        self.Reserved2 = v_ptr64()
        self.Address = v_ptr64()
        self.SpinLock = v_uint64()


class KGUARDED_MUTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Owner = v_ptr64()
        self.Contention = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Gate = KGATE()
        self.KernelApcDisable = v_uint16()
        self.SpecialApcDisable = v_uint16()
        self._pad0038 = v_bytes(size=4)


class ACCESS_REASONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(32) ])


class TP_TASK_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteCallback = v_ptr64()
        self.Unposted = v_ptr64()


class _unnamed_9727(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationType = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.SafeToRecurse = v_uint8()
        self._pad0010 = v_bytes(size=7)


class _unnamed_9726(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SyncType = v_uint32()
        self.PageProtection = v_uint32()


class _unnamed_9725(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ResourceToRelease = v_ptr64()


class _unnamed_9724(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EndingOffset = v_ptr64()
        self.ResourceToRelease = v_ptr64()


class _unnamed_9649(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Channel = v_uint32()
        self.Port = v_uint32()
        self.Reserved1 = v_uint32()


class _unnamed_9646(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Raw = _unnamed_9641()


class _unnamed_9641(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.MessageCount = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint64()


class _unnamed_9728(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr64()
        self.Argument2 = v_ptr64()
        self.Argument3 = v_ptr64()
        self.Argument4 = v_ptr64()
        self.Argument5 = v_ptr64()


class EX_PUSH_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint64()


class XSTATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint64()
        self.Length = v_uint32()
        self.Reserved1 = v_uint32()
        self.Area = v_ptr64()
        self.Buffer = v_ptr64()


class HEAP_FREE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousBlockPrivateData = v_ptr64()
        self.Size = v_uint16()
        self.Flags = v_uint8()
        self.SmallTagIndex = v_uint8()
        self.PreviousSize = v_uint16()
        self.SegmentOffset = v_uint8()
        self.UnusedBytes = v_uint8()
        self.FreeList = LIST_ENTRY()


class KSTACK_COUNT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Value = v_uint32()


class _unnamed_8031(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerSequence = v_ptr64()


class HEAP_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.SegmentSignature = v_uint32()
        self.SegmentFlags = v_uint32()
        self.SegmentListEntry = LIST_ENTRY()
        self.Heap = v_ptr64()
        self.BaseAddress = v_ptr64()
        self.NumberOfPages = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.FirstEntry = v_ptr64()
        self.LastValidEntry = v_ptr64()
        self.NumberOfUnCommittedPages = v_uint32()
        self.NumberOfUnCommittedRanges = v_uint32()
        self.SegmentAllocatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self._pad0060 = v_bytes(size=4)
        self.UCRSegmentList = LIST_ENTRY()


class WHEA_ERROR_RECORD_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Revision = WHEA_REVISION()
        self.SignatureEnd = v_uint32()
        self.SectionCount = v_uint16()
        self.Severity = v_uint32()
        self.ValidBits = WHEA_ERROR_RECORD_HEADER_VALIDBITS()
        self.Length = v_uint32()
        self.Timestamp = WHEA_TIMESTAMP()
        self.PlatformId = GUID()
        self.PartitionId = GUID()
        self.CreatorId = GUID()
        self.NotifyType = GUID()
        self.RecordId = v_uint64()
        self.Flags = WHEA_ERROR_RECORD_HEADER_FLAGS()
        self.PersistenceInfo = WHEA_PERSISTENCE_INFO()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(12) ])


class EVENT_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint16()
        self.Version = v_uint8()
        self.Channel = v_uint8()
        self.Level = v_uint8()
        self.Opcode = v_uint8()
        self.Task = v_uint16()
        self.Keyword = v_uint64()


class _unnamed_9587(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = _unnamed_10176()


class MMSUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkingSetMutex = EX_PUSH_LOCK()
        self.ExitGate = v_ptr64()
        self.AccessLog = v_ptr64()
        self.WorkingSetExpansionLinks = LIST_ENTRY()
        self.AgeDistribution = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self.MinimumWorkingSetSize = v_uint32()
        self.WorkingSetSize = v_uint32()
        self.WorkingSetPrivateSize = v_uint32()
        self.MaximumWorkingSetSize = v_uint32()
        self.ChargedWslePages = v_uint32()
        self.ActualWslePages = v_uint32()
        self.WorkingSetSizeOverhead = v_uint32()
        self.PeakWorkingSetSize = v_uint32()
        self.HardFaultCount = v_uint32()
        self.VmWorkingSetList = v_ptr64()
        self.NextPageColor = v_uint16()
        self.LastTrimStamp = v_uint16()
        self.PageFaultCount = v_uint32()
        self.RepurposeCount = v_uint32()
        self.Spare = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.Flags = MMSUPPORT_FLAGS()


class PSP_CPU_SHARE_CAPTURED_WEIGHT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CapturedCpuShareWeight = v_uint32()
        self.CapturedTotalWeight = v_uint32()


class FLS_CALLBACK_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ACL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AclRevision = v_uint8()
        self.Sbz1 = v_uint8()
        self.AclSize = v_uint16()
        self.AceCount = v_uint16()
        self.Sbz2 = v_uint16()


class _unnamed_7739(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr64()
        self.Options = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self._pad0018 = v_bytes(size=4)
        self.Parameters = v_ptr64()


class LIST_ENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint64()
        self.Blink = v_uint64()


class WAIT_CONTEXT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.DeviceRoutine = v_ptr64()
        self.DeviceContext = v_ptr64()
        self.NumberOfMapRegisters = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.DeviceObject = v_ptr64()
        self.CurrentIrp = v_ptr64()
        self.BufferChainingDpc = v_ptr64()


class SE_AUDIT_PROCESS_CREATION_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImageFileName = v_ptr64()


class ACTIVATION_CONTEXT_STACK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ActiveFrame = v_ptr64()
        self.FrameListCache = LIST_ENTRY()
        self.Flags = v_uint32()
        self.NextCookieSequenceNumber = v_uint32()
        self.StackId = v_uint32()
        self._pad0028 = v_bytes(size=4)


class LDR_DATA_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InLoadOrderLinks = LIST_ENTRY()
        self.InMemoryOrderLinks = LIST_ENTRY()
        self.InInitializationOrderLinks = LIST_ENTRY()
        self.DllBase = v_ptr64()
        self.EntryPoint = v_ptr64()
        self.SizeOfImage = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.FullDllName = UNICODE_STRING()
        self.BaseDllName = UNICODE_STRING()
        self.Flags = v_uint32()
        self.LoadCount = v_uint16()
        self.TlsIndex = v_uint16()
        self.HashLinks = LIST_ENTRY()
        self.TimeDateStamp = v_uint32()
        self._pad0088 = v_bytes(size=4)
        self.EntryPointActivationContext = v_ptr64()
        self.PatchInformation = v_ptr64()
        self.ForwarderLinks = LIST_ENTRY()
        self.ServiceTagLinks = LIST_ENTRY()
        self.StaticLinks = LIST_ENTRY()
        self.ContextInformation = v_ptr64()
        self.OriginalBase = v_uint64()
        self.LoadTime = LARGE_INTEGER()


class LOOKASIDE_LIST_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE_POOL()


class TEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.EnvironmentPointer = v_ptr64()
        self.ClientId = CLIENT_ID()
        self.ActiveRpcHandle = v_ptr64()
        self.ThreadLocalStoragePointer = v_ptr64()
        self.ProcessEnvironmentBlock = v_ptr64()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_ptr64()
        self.Win32ThreadInfo = v_ptr64()
        self.User32Reserved = vstruct.VArray([ v_uint32() for i in xrange(26) ])
        self.UserReserved = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self._pad0100 = v_bytes(size=4)
        self.WOW32Reserved = v_ptr64()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()
        self.SystemReserved1 = vstruct.VArray([ v_ptr64() for i in xrange(54) ])
        self.ExceptionCode = v_uint32()
        self._pad02c8 = v_bytes(size=4)
        self.ActivationContextStackPointer = v_ptr64()
        self.SpareBytes = vstruct.VArray([ v_uint8() for i in xrange(24) ])
        self.TxFsContext = v_uint32()
        self._pad02f0 = v_bytes(size=4)
        self.GdiTebBatch = GDI_TEB_BATCH()
        self.RealClientId = CLIENT_ID()
        self.GdiCachedProcessHandle = v_ptr64()
        self.GdiClientPID = v_uint32()
        self.GdiClientTID = v_uint32()
        self.GdiThreadLocalInfo = v_ptr64()
        self.Win32ClientInfo = vstruct.VArray([ v_uint64() for i in xrange(62) ])
        self.glDispatchTable = vstruct.VArray([ v_ptr64() for i in xrange(233) ])
        self.glReserved1 = vstruct.VArray([ v_uint64() for i in xrange(29) ])
        self.glReserved2 = v_ptr64()
        self.glSectionInfo = v_ptr64()
        self.glSection = v_ptr64()
        self.glTable = v_ptr64()
        self.glCurrentRC = v_ptr64()
        self.glContext = v_ptr64()
        self.LastStatusValue = v_uint32()
        self._pad1258 = v_bytes(size=4)
        self.StaticUnicodeString = UNICODE_STRING()
        self.StaticUnicodeBuffer = vstruct.VArray([ v_uint16() for i in xrange(261) ])
        self._pad1478 = v_bytes(size=6)
        self.DeallocationStack = v_ptr64()
        self.TlsSlots = vstruct.VArray([ v_ptr64() for i in xrange(64) ])
        self.TlsLinks = LIST_ENTRY()
        self.Vdm = v_ptr64()
        self.ReservedForNtRpc = v_ptr64()
        self.DbgSsReserved = vstruct.VArray([ v_ptr64() for i in xrange(2) ])
        self.HardErrorMode = v_uint32()
        self._pad16b8 = v_bytes(size=4)
        self.Instrumentation = vstruct.VArray([ v_ptr64() for i in xrange(11) ])
        self.ActivityId = GUID()
        self.SubProcessTag = v_ptr64()
        self.EtwLocalData = v_ptr64()
        self.EtwTraceData = v_ptr64()
        self.WinSockData = v_ptr64()
        self.GdiBatchCount = v_uint32()
        self.CurrentIdealProcessor = PROCESSOR_NUMBER()
        self.GuaranteedStackBytes = v_uint32()
        self._pad1750 = v_bytes(size=4)
        self.ReservedForPerf = v_ptr64()
        self.ReservedForOle = v_ptr64()
        self.WaitingOnLoaderLock = v_uint32()
        self._pad1768 = v_bytes(size=4)
        self.SavedPriorityState = v_ptr64()
        self.SoftPatchPtr1 = v_uint64()
        self.ThreadPoolData = v_ptr64()
        self.TlsExpansionSlots = v_ptr64()
        self.DeallocationBStore = v_ptr64()
        self.BStoreLimit = v_ptr64()
        self.MuiGeneration = v_uint32()
        self.IsImpersonating = v_uint32()
        self.NlsCache = v_ptr64()
        self.pShimData = v_ptr64()
        self.HeapVirtualAffinity = v_uint32()
        self._pad17b8 = v_bytes(size=4)
        self.CurrentTransactionHandle = v_ptr64()
        self.ActiveFrame = v_ptr64()
        self.FlsData = v_ptr64()
        self.PreferredLanguages = v_ptr64()
        self.UserPrefLanguages = v_ptr64()
        self.MergedPrefLanguages = v_ptr64()
        self.MuiImpersonation = v_uint32()
        self.CrossTebFlags = v_uint16()
        self.SameTebFlags = v_uint16()
        self.TxnScopeEnterCallback = v_ptr64()
        self.TxnScopeExitCallback = v_ptr64()
        self.TxnScopeContext = v_ptr64()
        self.LockCount = v_uint32()
        self.SpareUlong0 = v_uint32()
        self.ResourceRetValue = v_ptr64()


class EX_RUNDOWN_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint64()


class XSAVE_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint16()
        self.StatusWord = v_uint16()
        self.TagWord = v_uint8()
        self.Reserved1 = v_uint8()
        self.ErrorOpcode = v_uint16()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint16()
        self.Reserved2 = v_uint16()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint16()
        self.Reserved3 = v_uint16()
        self.MxCsr = v_uint32()
        self.MxCsr_Mask = v_uint32()
        self.FloatRegisters = vstruct.VArray([ M128A() for i in xrange(8) ])
        self.XmmRegisters = vstruct.VArray([ M128A() for i in xrange(16) ])
        self.Reserved4 = vstruct.VArray([ v_uint8() for i in xrange(96) ])


class PO_DIAG_STACK_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StackDepth = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Stack = vstruct.VArray([ v_ptr64() for i in xrange(1) ])


class IMAGE_DOS_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e_magic = v_uint16()
        self.e_cblp = v_uint16()
        self.e_cp = v_uint16()
        self.e_crlc = v_uint16()
        self.e_cparhdr = v_uint16()
        self.e_minalloc = v_uint16()
        self.e_maxalloc = v_uint16()
        self.e_ss = v_uint16()
        self.e_sp = v_uint16()
        self.e_csum = v_uint16()
        self.e_ip = v_uint16()
        self.e_cs = v_uint16()
        self.e_lfarlc = v_uint16()
        self.e_ovno = v_uint16()
        self.e_res = vstruct.VArray([ v_uint16() for i in xrange(4) ])
        self.e_oemid = v_uint16()
        self.e_oeminfo = v_uint16()
        self.e_res2 = vstruct.VArray([ v_uint16() for i in xrange(10) ])
        self.e_lfanew = v_uint32()


class RTL_DYNAMIC_HASH_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Linkage = LIST_ENTRY()
        self.Signature = v_uint64()


class MMADDRESS_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_9413()
        self.LeftChild = v_ptr64()
        self.RightChild = v_ptr64()
        self.StartingVpn = v_uint64()
        self.EndingVpn = v_uint64()


class TXN_PARAMETER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.TxFsContext = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.TransactionObject = v_ptr64()


class _unnamed_6010(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMiddle = v_uint8()
        self.Flags1 = v_uint8()
        self.Flags2 = v_uint8()
        self.BaseHigh = v_uint8()


class _unnamed_6011(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMiddle = v_uint32()


class QUAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UseThisFieldToCopy = v_uint64()


class HEAP_TUNING_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CommittThresholdShift = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.MaxPreCommittThreshold = v_uint64()


class _unnamed_7839(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.EaList = v_ptr64()
        self.EaListLength = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.EaIndex = v_uint32()
        self._pad0020 = v_bytes(size=4)


class KPRCB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MxCsr = v_uint32()
        self.LegacyNumber = v_uint8()
        self.ReservedMustBeZero = v_uint8()
        self.InterruptRequest = v_uint8()
        self.IdleHalt = v_uint8()
        self.CurrentThread = v_ptr64()
        self.NextThread = v_ptr64()
        self.IdleThread = v_ptr64()
        self.NestingLevel = v_uint8()
        self.PrcbPad00 = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.Number = v_uint32()
        self.RspBase = v_uint64()
        self.PrcbLock = v_uint64()
        self.PrcbPad01 = v_uint64()
        self.ProcessorState = KPROCESSOR_STATE()
        self.CpuType = v_uint8()
        self.CpuID = v_uint8()
        self.CpuStep = v_uint16()
        self.MHz = v_uint32()
        self.HalReserved = vstruct.VArray([ v_uint64() for i in xrange(8) ])
        self.MinorVersion = v_uint16()
        self.MajorVersion = v_uint16()
        self.BuildType = v_uint8()
        self.CpuVendor = v_uint8()
        self.CoresPerPhysicalProcessor = v_uint8()
        self.LogicalProcessorsPerCore = v_uint8()
        self.ApicMask = v_uint32()
        self.CFlushSize = v_uint32()
        self.AcpiReserved = v_ptr64()
        self.InitialApicId = v_uint32()
        self.Stride = v_uint32()
        self.Group = v_uint16()
        self._pad0660 = v_bytes(size=6)
        self.GroupSetMember = v_uint64()
        self.GroupIndex = v_uint8()
        self._pad0670 = v_bytes(size=7)
        self.LockQueue = vstruct.VArray([ KSPIN_LOCK_QUEUE() for i in xrange(17) ])
        self.PPLookasideList = vstruct.VArray([ PP_LOOKASIDE_LIST() for i in xrange(16) ])
        self.PPNPagedLookasideList = vstruct.VArray([ GENERAL_LOOKASIDE_POOL() for i in xrange(32) ])
        self.PPPagedLookasideList = vstruct.VArray([ GENERAL_LOOKASIDE_POOL() for i in xrange(32) ])
        self.PacketBarrier = v_uint32()
        self._pad2088 = v_bytes(size=4)
        self.DeferredReadyListHead = SINGLE_LIST_ENTRY()
        self.MmPageFaultCount = v_uint32()
        self.MmCopyOnWriteCount = v_uint32()
        self.MmTransitionCount = v_uint32()
        self.MmDemandZeroCount = v_uint32()
        self.MmPageReadCount = v_uint32()
        self.MmPageReadIoCount = v_uint32()
        self.MmDirtyPagesWriteCount = v_uint32()
        self.MmDirtyWriteIoCount = v_uint32()
        self.MmMappedPagesWriteCount = v_uint32()
        self.MmMappedWriteIoCount = v_uint32()
        self.KeSystemCalls = v_uint32()
        self.KeContextSwitches = v_uint32()
        self.CcFastReadNoWait = v_uint32()
        self.CcFastReadWait = v_uint32()
        self.CcFastReadNotPossible = v_uint32()
        self.CcCopyReadNoWait = v_uint32()
        self.CcCopyReadWait = v_uint32()
        self.CcCopyReadNoWaitMiss = v_uint32()
        self.LookasideIrpFloat = v_uint32()
        self.IoReadOperationCount = v_uint32()
        self.IoWriteOperationCount = v_uint32()
        self.IoOtherOperationCount = v_uint32()
        self.IoReadTransferCount = LARGE_INTEGER()
        self.IoWriteTransferCount = LARGE_INTEGER()
        self.IoOtherTransferCount = LARGE_INTEGER()
        self.TargetCount = v_uint32()
        self.IpiFrozen = v_uint32()
        self._pad2180 = v_bytes(size=120)
        self.DpcData = vstruct.VArray([ KDPC_DATA() for i in xrange(2) ])
        self.DpcStack = v_ptr64()
        self.MaximumDpcQueueDepth = v_uint32()
        self.DpcRequestRate = v_uint32()
        self.MinimumDpcRate = v_uint32()
        self.DpcLastCount = v_uint32()
        self.ThreadDpcEnable = v_uint8()
        self.QuantumEnd = v_uint8()
        self.DpcRoutineActive = v_uint8()
        self.IdleSchedule = v_uint8()
        self.DpcRequestSummary = v_uint32()
        self.TimerHand = v_uint32()
        self.MasterOffset = v_uint32()
        self.LastTick = v_uint32()
        self.UnusedPad = v_uint32()
        self.PrcbPad50 = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.TimerTable = KTIMER_TABLE()
        self.DpcGate = KGATE()
        self.PrcbPad52 = v_ptr64()
        self.CallDpc = KDPC()
        self.ClockKeepAlive = v_uint32()
        self.ClockCheckSlot = v_uint8()
        self.ClockPollCycle = v_uint8()
        self.NmiActive = v_uint16()
        self.DpcWatchdogPeriod = v_uint32()
        self.DpcWatchdogCount = v_uint32()
        self.TickOffset = v_uint64()
        self.KeSpinLockOrdering = v_uint32()
        self.PrcbPad70 = v_uint32()
        self.WaitListHead = LIST_ENTRY()
        self.WaitLock = v_uint64()
        self.ReadySummary = v_uint32()
        self.QueueIndex = v_uint32()
        self.TimerExpirationDpc = KDPC()
        self.PrcbPad72 = vstruct.VArray([ v_uint64() for i in xrange(4) ])
        self.DispatcherReadyListHead = vstruct.VArray([ LIST_ENTRY() for i in xrange(32) ])
        self.InterruptCount = v_uint32()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.DpcTime = v_uint32()
        self.InterruptTime = v_uint32()
        self.AdjustDpcThreshold = v_uint32()
        self.DebuggerSavedIRQL = v_uint8()
        self.PrcbPad80 = vstruct.VArray([ v_uint8() for i in xrange(7) ])
        self.DpcTimeCount = v_uint32()
        self.DpcTimeLimit = v_uint32()
        self.PeriodicCount = v_uint32()
        self.PeriodicBias = v_uint32()
        self.AvailableTime = v_uint32()
        self.KeExceptionDispatchCount = v_uint32()
        self.ParentNode = v_ptr64()
        self.StartCycles = v_uint64()
        self.PrcbPad82 = vstruct.VArray([ v_uint64() for i in xrange(3) ])
        self.MmSpinLockOrdering = v_uint32()
        self.PageColor = v_uint32()
        self.NodeColor = v_uint32()
        self.NodeShiftedColor = v_uint32()
        self.SecondaryColorMask = v_uint32()
        self.PrcbPad83 = v_uint32()
        self.CycleTime = v_uint64()
        self.CcFastMdlReadNoWait = v_uint32()
        self.CcFastMdlReadWait = v_uint32()
        self.CcFastMdlReadNotPossible = v_uint32()
        self.CcMapDataNoWait = v_uint32()
        self.CcMapDataWait = v_uint32()
        self.CcPinMappedDataCount = v_uint32()
        self.CcPinReadNoWait = v_uint32()
        self.CcPinReadWait = v_uint32()
        self.CcMdlReadNoWait = v_uint32()
        self.CcMdlReadWait = v_uint32()
        self.CcLazyWriteHotSpots = v_uint32()
        self.CcLazyWriteIos = v_uint32()
        self.CcLazyWritePages = v_uint32()
        self.CcDataFlushes = v_uint32()
        self.CcDataPages = v_uint32()
        self.CcLostDelayedWrites = v_uint32()
        self.CcFastReadResourceMiss = v_uint32()
        self.CcCopyReadWaitMiss = v_uint32()
        self.CcFastMdlReadResourceMiss = v_uint32()
        self.CcMapDataNoWaitMiss = v_uint32()
        self.CcMapDataWaitMiss = v_uint32()
        self.CcPinReadNoWaitMiss = v_uint32()
        self.CcPinReadWaitMiss = v_uint32()
        self.CcMdlReadNoWaitMiss = v_uint32()
        self.CcMdlReadWaitMiss = v_uint32()
        self.CcReadAheadIos = v_uint32()
        self.MmCacheTransitionCount = v_uint32()
        self.MmCacheReadCount = v_uint32()
        self.MmCacheIoCount = v_uint32()
        self.PrcbPad91 = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.RuntimeAccumulation = v_uint64()
        self.PowerState = PROCESSOR_POWER_STATE()
        self.PrcbPad92 = vstruct.VArray([ v_uint8() for i in xrange(16) ])
        self.KeAlignmentFixupCount = v_uint32()
        self._pad4918 = v_bytes(size=4)
        self.DpcWatchdogDpc = KDPC()
        self.DpcWatchdogTimer = KTIMER()
        self.Cache = vstruct.VArray([ CACHE_DESCRIPTOR() for i in xrange(5) ])
        self.CacheCount = v_uint32()
        self.CachedCommit = v_uint32()
        self.CachedResidentAvailable = v_uint32()
        self.HyperPte = v_ptr64()
        self.WheaInfo = v_ptr64()
        self.EtwSupport = v_ptr64()
        self._pad4a00 = v_bytes(size=8)
        self.InterruptObjectPool = SLIST_HEADER()
        self.HypercallPageList = SLIST_HEADER()
        self.HypercallPageVirtual = v_ptr64()
        self.VirtualApicAssist = v_ptr64()
        self.StatisticsPage = v_ptr64()
        self.RateControl = v_ptr64()
        self.CacheProcessorMask = vstruct.VArray([ v_uint64() for i in xrange(5) ])
        self.PackageProcessorSet = KAFFINITY_EX()
        self.CoreProcessorSet = v_uint64()
        self.PebsIndexAddress = v_ptr64()
        self.PrcbPad93 = vstruct.VArray([ v_uint64() for i in xrange(12) ])
        self.SpinLockAcquireCount = v_uint32()
        self.SpinLockContentionCount = v_uint32()
        self.SpinLockSpinCount = v_uint32()
        self.IpiSendRequestBroadcastCount = v_uint32()
        self.IpiSendRequestRoutineCount = v_uint32()
        self.IpiSendSoftwareInterruptCount = v_uint32()
        self.ExInitializeResourceCount = v_uint32()
        self.ExReInitializeResourceCount = v_uint32()
        self.ExDeleteResourceCount = v_uint32()
        self.ExecutiveResourceAcquiresCount = v_uint32()
        self.ExecutiveResourceContentionsCount = v_uint32()
        self.ExecutiveResourceReleaseExclusiveCount = v_uint32()
        self.ExecutiveResourceReleaseSharedCount = v_uint32()
        self.ExecutiveResourceConvertsCount = v_uint32()
        self.ExAcqResExclusiveAttempts = v_uint32()
        self.ExAcqResExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResExclusiveAcquiresExclusiveRecursive = v_uint32()
        self.ExAcqResExclusiveWaits = v_uint32()
        self.ExAcqResExclusiveNotAcquires = v_uint32()
        self.ExAcqResSharedAttempts = v_uint32()
        self.ExAcqResSharedAcquiresExclusive = v_uint32()
        self.ExAcqResSharedAcquiresShared = v_uint32()
        self.ExAcqResSharedAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedWaits = v_uint32()
        self.ExAcqResSharedNotAcquires = v_uint32()
        self.ExAcqResSharedStarveExclusiveAttempts = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresShared = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedStarveExclusiveWaits = v_uint32()
        self.ExAcqResSharedStarveExclusiveNotAcquires = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAttempts = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresShared = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedWaitForExclusiveWaits = v_uint32()
        self.ExAcqResSharedWaitForExclusiveNotAcquires = v_uint32()
        self.ExSetResOwnerPointerExclusive = v_uint32()
        self.ExSetResOwnerPointerSharedNew = v_uint32()
        self.ExSetResOwnerPointerSharedOld = v_uint32()
        self.ExTryToAcqExclusiveAttempts = v_uint32()
        self.ExTryToAcqExclusiveAcquires = v_uint32()
        self.ExBoostExclusiveOwner = v_uint32()
        self.ExBoostSharedOwners = v_uint32()
        self.ExEtwSynchTrackingNotificationsCount = v_uint32()
        self.ExEtwSynchTrackingNotificationsAccountedCount = v_uint32()
        self.VendorString = vstruct.VArray([ v_uint8() for i in xrange(13) ])
        self.PrcbPad10 = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.FeatureBits = v_uint32()
        self._pad4bd0 = v_bytes(size=4)
        self.UpdateSignature = LARGE_INTEGER()
        self.Context = v_ptr64()
        self.ContextFlags = v_uint32()
        self._pad4be8 = v_bytes(size=4)
        self.ExtendedState = v_ptr64()
        self._pad4c00 = v_bytes(size=16)
        self.Mailbox = v_ptr64()
        self._pad4c80 = v_bytes(size=120)
        self.RequestMailbox = vstruct.VArray([ REQUEST_MAILBOX() for i in xrange(1) ])
        self._pad4d00 = v_bytes(size=64)


class RTL_DYNAMIC_HASH_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.Shift = v_uint32()
        self.TableSize = v_uint32()
        self.Pivot = v_uint32()
        self.DivisorMask = v_uint32()
        self.NumEntries = v_uint32()
        self.NonEmptyBuckets = v_uint32()
        self.NumEnumerators = v_uint32()
        self.Directory = v_ptr64()


class _unnamed_5519(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFunction = v_uint32()


class KAFFINITY_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint16()
        self.Size = v_uint16()
        self.Reserved = v_uint32()
        self.Bitmap = vstruct.VArray([ v_uint64() for i in xrange(4) ])


class DEVICE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.ReferenceCount = v_uint32()
        self.DriverObject = v_ptr64()
        self.NextDevice = v_ptr64()
        self.AttachedDevice = v_ptr64()
        self.CurrentIrp = v_ptr64()
        self.Timer = v_ptr64()
        self.Flags = v_uint32()
        self.Characteristics = v_uint32()
        self.Vpb = v_ptr64()
        self.DeviceExtension = v_ptr64()
        self.DeviceType = v_uint32()
        self.StackSize = v_uint8()
        self._pad0050 = v_bytes(size=3)
        self.Queue = _unnamed_7211()
        self.AlignmentRequirement = v_uint32()
        self._pad00a0 = v_bytes(size=4)
        self.DeviceQueue = KDEVICE_QUEUE()
        self.Dpc = KDPC()
        self.ActiveThreadCount = v_uint32()
        self._pad0110 = v_bytes(size=4)
        self.SecurityDescriptor = v_ptr64()
        self.DeviceLock = KEVENT()
        self.SectorSize = v_uint16()
        self.Spare1 = v_uint16()
        self._pad0138 = v_bytes(size=4)
        self.DeviceObjectExtension = v_ptr64()
        self.Reserved = v_ptr64()
        self._pad0150 = v_bytes(size=8)


class USER_MEMORY_CACHE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserBlocks = SLIST_HEADER()
        self.AvailableBlocks = v_uint32()
        self._pad0020 = v_bytes(size=12)


class _unnamed_5516(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()


class KTSS64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved0 = v_uint32()
        self.Rsp0 = v_uint64()
        self.Rsp1 = v_uint64()
        self.Rsp2 = v_uint64()
        self.Ist = vstruct.VArray([ v_uint64() for i in xrange(8) ])
        self.Reserved1 = v_uint64()
        self.Reserved2 = v_uint16()
        self.IoMapBase = v_uint16()


class EX_PUSH_LOCK_WAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WakeEvent = KEVENT()
        self.Next = v_ptr64()
        self.Last = v_ptr64()
        self.Previous = v_ptr64()
        self.ShareCount = v_uint32()
        self.Flags = v_uint32()
        self._pad0040 = v_bytes(size=8)


class KERNEL_STACK_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StackBase = v_uint64()
        self.StackLimit = v_uint64()
        self.KernelStack = v_uint64()
        self.InitialStack = v_uint64()
        self.ActualLimit = v_uint64()


class _unnamed_10176(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Alignment = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class IO_STACK_LOCATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorFunction = v_uint8()
        self.MinorFunction = v_uint8()
        self.Flags = v_uint8()
        self.Control = v_uint8()
        self._pad0008 = v_bytes(size=4)
        self.Parameters = _unnamed_7661()
        self.DeviceObject = v_ptr64()
        self.FileObject = v_ptr64()
        self.CompletionRoutine = v_ptr64()
        self.Context = v_ptr64()


class KNODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PagedPoolSListHead = SLIST_HEADER()
        self.NonPagedPoolSListHead = vstruct.VArray([ SLIST_HEADER() for i in xrange(3) ])
        self.Affinity = GROUP_AFFINITY()
        self.ProximityId = v_uint32()
        self.NodeNumber = v_uint16()
        self.PrimaryNodeNumber = v_uint16()
        self.MaximumProcessors = v_uint8()
        self.Color = v_uint8()
        self.Flags = flags()
        self.NodePad0 = v_uint8()
        self.Seed = v_uint32()
        self.MmShiftedColor = v_uint32()
        self._pad0068 = v_bytes(size=4)
        self.FreeCount = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.Right = v_uint32()
        self.Left = v_uint32()
        self.CachedKernelStacks = CACHED_KSTACK_LIST()
        self.ParkLock = v_uint32()
        self.NodePad1 = v_uint32()
        self._pad00c0 = v_bytes(size=24)


class _unnamed_8078(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr64()
        self.Argument2 = v_ptr64()
        self.Argument3 = v_ptr64()
        self.Argument4 = v_ptr64()


class XSAVE_AREA_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint64()
        self.Reserved = vstruct.VArray([ v_uint64() for i in xrange(7) ])


class MM_DRIVER_VERIFIER_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint32()
        self.RaiseIrqls = v_uint32()
        self.AcquireSpinLocks = v_uint32()
        self.SynchronizeExecutions = v_uint32()
        self.AllocationsAttempted = v_uint32()
        self.AllocationsSucceeded = v_uint32()
        self.AllocationsSucceededSpecialPool = v_uint32()
        self.AllocationsWithNoTag = v_uint32()
        self.TrimRequests = v_uint32()
        self.Trims = v_uint32()
        self.AllocationsFailed = v_uint32()
        self.AllocationsFailedDeliberately = v_uint32()
        self.Loads = v_uint32()
        self.Unloads = v_uint32()
        self.UnTrackedPool = v_uint32()
        self.UserTrims = v_uint32()
        self.CurrentPagedPoolAllocations = v_uint32()
        self.CurrentNonPagedPoolAllocations = v_uint32()
        self.PeakPagedPoolAllocations = v_uint32()
        self.PeakNonPagedPoolAllocations = v_uint32()
        self.PagedBytes = v_uint64()
        self.NonPagedBytes = v_uint64()
        self.PeakPagedBytes = v_uint64()
        self.PeakNonPagedBytes = v_uint64()
        self.BurstAllocationsFailedDeliberately = v_uint32()
        self.SessionTrims = v_uint32()
        self.OptionChanges = v_uint32()
        self.VerifyMode = v_uint32()
        self.PreviousBucketName = UNICODE_STRING()
        self.ActivityCounter = v_uint32()
        self.PreviousActivityCounter = v_uint32()
        self.WorkerTrimRequests = v_uint32()
        self._pad00a0 = v_bytes(size=4)


class _unnamed_8073(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProviderId = v_uint64()
        self.DataPath = v_ptr64()
        self.BufferSize = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Buffer = v_ptr64()


class RTL_USER_PROCESS_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MaximumLength = v_uint32()
        self.Length = v_uint32()
        self.Flags = v_uint32()
        self.DebugFlags = v_uint32()
        self.ConsoleHandle = v_ptr64()
        self.ConsoleFlags = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.StandardInput = v_ptr64()
        self.StandardOutput = v_ptr64()
        self.StandardError = v_ptr64()
        self.CurrentDirectory = CURDIR()
        self.DllPath = UNICODE_STRING()
        self.ImagePathName = UNICODE_STRING()
        self.CommandLine = UNICODE_STRING()
        self.Environment = v_ptr64()
        self.StartingX = v_uint32()
        self.StartingY = v_uint32()
        self.CountX = v_uint32()
        self.CountY = v_uint32()
        self.CountCharsX = v_uint32()
        self.CountCharsY = v_uint32()
        self.FillAttribute = v_uint32()
        self.WindowFlags = v_uint32()
        self.ShowWindowFlags = v_uint32()
        self._pad00b0 = v_bytes(size=4)
        self.WindowTitle = UNICODE_STRING()
        self.DesktopInfo = UNICODE_STRING()
        self.ShellInfo = UNICODE_STRING()
        self.RuntimeData = UNICODE_STRING()
        self.CurrentDirectores = vstruct.VArray([ RTL_DRIVE_LETTER_CURDIR() for i in xrange(32) ])
        self.EnvironmentSize = v_uint64()
        self.EnvironmentVersion = v_uint64()


class IO_RESOURCE_REQUIREMENTS_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.SlotNumber = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.AlternativeLists = v_uint32()
        self.List = vstruct.VArray([ IO_RESOURCE_LIST() for i in xrange(1) ])


class HEAP_BUCKET_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalBlocks = v_uint32()
        self.SubSegmentCounts = v_uint32()




########NEW FILE########
__FILENAME__ = ntoskrnl
# Version: 6.1
# Architecture: amd64
# CompanyName: Microsoft Corporation
# FileDescription: NT Kernel & System
# FileVersion: 6.1.7601.17514 (win7sp1_rtm.101119-1850)
# InternalName: ntkrnlmp.exe
# LegalCopyright:  Microsoft Corporation. All rights reserved.
# OriginalFilename: ntkrnlmp.exe
# ProductName: Microsoft Windows Operating System
# ProductVersion: 6.1.7601.17514
import vstruct
from vstruct.primitives import *

KPROCESS_STATE = v_enum()
KPROCESS_STATE.ProcessInMemory = 0
KPROCESS_STATE.ProcessOutOfMemory = 1
KPROCESS_STATE.ProcessInTransition = 2
KPROCESS_STATE.ProcessOutTransition = 3
KPROCESS_STATE.ProcessInSwap = 4
KPROCESS_STATE.ProcessOutSwap = 5
KPROCESS_STATE.ProcessAllSwapStates = 6


MI_STORE_BIT_TYPE = v_enum()
MI_STORE_BIT_TYPE.MiStoreBitTypeInStore = 0
MI_STORE_BIT_TYPE.MiStoreBitTypeEvicted = 1
MI_STORE_BIT_TYPE.MiStoreBitTypeMax = 2


IO_ALLOCATION_ACTION = v_enum()
IO_ALLOCATION_ACTION.KeepObject = 1
IO_ALLOCATION_ACTION.DeallocateObject = 2
IO_ALLOCATION_ACTION.DeallocateObjectKeepRegisters = 3


LOCK_OPERATION = v_enum()
LOCK_OPERATION.IoReadAccess = 0
LOCK_OPERATION.IoWriteAccess = 1
LOCK_OPERATION.IoModifyAccess = 2


CONFIGURATION_TYPE = v_enum()
CONFIGURATION_TYPE.ArcSystem = 0
CONFIGURATION_TYPE.CentralProcessor = 1
CONFIGURATION_TYPE.FloatingPointProcessor = 2
CONFIGURATION_TYPE.PrimaryIcache = 3
CONFIGURATION_TYPE.PrimaryDcache = 4
CONFIGURATION_TYPE.SecondaryIcache = 5
CONFIGURATION_TYPE.SecondaryDcache = 6
CONFIGURATION_TYPE.SecondaryCache = 7
CONFIGURATION_TYPE.EisaAdapter = 8
CONFIGURATION_TYPE.TcAdapter = 9
CONFIGURATION_TYPE.ScsiAdapter = 10
CONFIGURATION_TYPE.DtiAdapter = 11
CONFIGURATION_TYPE.MultiFunctionAdapter = 12
CONFIGURATION_TYPE.DiskController = 13
CONFIGURATION_TYPE.TapeController = 14
CONFIGURATION_TYPE.CdromController = 15
CONFIGURATION_TYPE.WormController = 16
CONFIGURATION_TYPE.SerialController = 17
CONFIGURATION_TYPE.NetworkController = 18
CONFIGURATION_TYPE.DisplayController = 19
CONFIGURATION_TYPE.ParallelController = 20
CONFIGURATION_TYPE.PointerController = 21
CONFIGURATION_TYPE.KeyboardController = 22
CONFIGURATION_TYPE.AudioController = 23
CONFIGURATION_TYPE.OtherController = 24
CONFIGURATION_TYPE.DiskPeripheral = 25
CONFIGURATION_TYPE.FloppyDiskPeripheral = 26
CONFIGURATION_TYPE.TapePeripheral = 27
CONFIGURATION_TYPE.ModemPeripheral = 28
CONFIGURATION_TYPE.MonitorPeripheral = 29
CONFIGURATION_TYPE.PrinterPeripheral = 30
CONFIGURATION_TYPE.PointerPeripheral = 31
CONFIGURATION_TYPE.KeyboardPeripheral = 32
CONFIGURATION_TYPE.TerminalPeripheral = 33
CONFIGURATION_TYPE.OtherPeripheral = 34
CONFIGURATION_TYPE.LinePeripheral = 35
CONFIGURATION_TYPE.NetworkPeripheral = 36
CONFIGURATION_TYPE.SystemMemory = 37
CONFIGURATION_TYPE.DockingInformation = 38
CONFIGURATION_TYPE.RealModeIrqRoutingTable = 39
CONFIGURATION_TYPE.RealModePCIEnumeration = 40
CONFIGURATION_TYPE.MaximumType = 41


CM_SHARE_DISPOSITION = v_enum()
CM_SHARE_DISPOSITION.CmResourceShareUndetermined = 0
CM_SHARE_DISPOSITION.CmResourceShareDeviceExclusive = 1
CM_SHARE_DISPOSITION.CmResourceShareDriverExclusive = 2
CM_SHARE_DISPOSITION.CmResourceShareShared = 3


KWAIT_BLOCK_STATE = v_enum()
KWAIT_BLOCK_STATE.WaitBlockBypassStart = 0
KWAIT_BLOCK_STATE.WaitBlockBypassComplete = 1
KWAIT_BLOCK_STATE.WaitBlockActive = 2
KWAIT_BLOCK_STATE.WaitBlockInactive = 3
KWAIT_BLOCK_STATE.WaitBlockAllStates = 4


PROCESSOR_CACHE_TYPE = v_enum()
PROCESSOR_CACHE_TYPE.CacheUnified = 0
PROCESSOR_CACHE_TYPE.CacheInstruction = 1
PROCESSOR_CACHE_TYPE.CacheData = 2
PROCESSOR_CACHE_TYPE.CacheTrace = 3


EVENT_TYPE = v_enum()
EVENT_TYPE.NotificationEvent = 0
EVENT_TYPE.SynchronizationEvent = 1


WHEA_ERROR_TYPE = v_enum()
WHEA_ERROR_TYPE.WheaErrTypeProcessor = 0
WHEA_ERROR_TYPE.WheaErrTypeMemory = 1
WHEA_ERROR_TYPE.WheaErrTypePCIExpress = 2
WHEA_ERROR_TYPE.WheaErrTypeNMI = 3
WHEA_ERROR_TYPE.WheaErrTypePCIXBus = 4
WHEA_ERROR_TYPE.WheaErrTypePCIXDevice = 5
WHEA_ERROR_TYPE.WheaErrTypeGeneric = 6


PROFILE_DEPARTURE_STYLE = v_enum()
PROFILE_DEPARTURE_STYLE.PDS_UPDATE_DEFAULT = 1
PROFILE_DEPARTURE_STYLE.PDS_UPDATE_ON_REMOVE = 2
PROFILE_DEPARTURE_STYLE.PDS_UPDATE_ON_INTERFACE = 3
PROFILE_DEPARTURE_STYLE.PDS_UPDATE_ON_EJECT = 4


OB_OPEN_REASON = v_enum()
OB_OPEN_REASON.ObCreateHandle = 0
OB_OPEN_REASON.ObOpenHandle = 1
OB_OPEN_REASON.ObDuplicateHandle = 2
OB_OPEN_REASON.ObInheritHandle = 3
OB_OPEN_REASON.ObMaxOpenReason = 4


PNP_DEVNODE_STATE = v_enum()
PNP_DEVNODE_STATE.DeviceNodeUnspecified = 768
PNP_DEVNODE_STATE.DeviceNodeUninitialized = 769
PNP_DEVNODE_STATE.DeviceNodeInitialized = 770
PNP_DEVNODE_STATE.DeviceNodeDriversAdded = 771
PNP_DEVNODE_STATE.DeviceNodeResourcesAssigned = 772
PNP_DEVNODE_STATE.DeviceNodeStartPending = 773
PNP_DEVNODE_STATE.DeviceNodeStartCompletion = 774
PNP_DEVNODE_STATE.DeviceNodeStartPostWork = 775
PNP_DEVNODE_STATE.DeviceNodeStarted = 776
PNP_DEVNODE_STATE.DeviceNodeQueryStopped = 777
PNP_DEVNODE_STATE.DeviceNodeStopped = 778
PNP_DEVNODE_STATE.DeviceNodeRestartCompletion = 779
PNP_DEVNODE_STATE.DeviceNodeEnumeratePending = 780
PNP_DEVNODE_STATE.DeviceNodeEnumerateCompletion = 781
PNP_DEVNODE_STATE.DeviceNodeAwaitingQueuedDeletion = 782
PNP_DEVNODE_STATE.DeviceNodeAwaitingQueuedRemoval = 783
PNP_DEVNODE_STATE.DeviceNodeQueryRemoved = 784
PNP_DEVNODE_STATE.DeviceNodeRemovePendingCloses = 785
PNP_DEVNODE_STATE.DeviceNodeRemoved = 786
PNP_DEVNODE_STATE.DeviceNodeDeletePendingCloses = 787
PNP_DEVNODE_STATE.DeviceNodeDeleted = 788
PNP_DEVNODE_STATE.MaxDeviceNodeState = 789


POWER_STATE_TYPE = v_enum()
POWER_STATE_TYPE.SystemPowerState = 0
POWER_STATE_TYPE.DevicePowerState = 1


TYPE_OF_MEMORY = v_enum()
TYPE_OF_MEMORY.LoaderExceptionBlock = 0
TYPE_OF_MEMORY.LoaderSystemBlock = 1
TYPE_OF_MEMORY.LoaderFree = 2
TYPE_OF_MEMORY.LoaderBad = 3
TYPE_OF_MEMORY.LoaderLoadedProgram = 4
TYPE_OF_MEMORY.LoaderFirmwareTemporary = 5
TYPE_OF_MEMORY.LoaderFirmwarePermanent = 6
TYPE_OF_MEMORY.LoaderOsloaderHeap = 7
TYPE_OF_MEMORY.LoaderOsloaderStack = 8
TYPE_OF_MEMORY.LoaderSystemCode = 9
TYPE_OF_MEMORY.LoaderHalCode = 10
TYPE_OF_MEMORY.LoaderBootDriver = 11
TYPE_OF_MEMORY.LoaderConsoleInDriver = 12
TYPE_OF_MEMORY.LoaderConsoleOutDriver = 13
TYPE_OF_MEMORY.LoaderStartupDpcStack = 14
TYPE_OF_MEMORY.LoaderStartupKernelStack = 15
TYPE_OF_MEMORY.LoaderStartupPanicStack = 16
TYPE_OF_MEMORY.LoaderStartupPcrPage = 17
TYPE_OF_MEMORY.LoaderStartupPdrPage = 18
TYPE_OF_MEMORY.LoaderRegistryData = 19
TYPE_OF_MEMORY.LoaderMemoryData = 20
TYPE_OF_MEMORY.LoaderNlsData = 21
TYPE_OF_MEMORY.LoaderSpecialMemory = 22
TYPE_OF_MEMORY.LoaderBBTMemory = 23
TYPE_OF_MEMORY.LoaderReserve = 24
TYPE_OF_MEMORY.LoaderXIPRom = 25
TYPE_OF_MEMORY.LoaderHALCachedMemory = 26
TYPE_OF_MEMORY.LoaderLargePageFiller = 27
TYPE_OF_MEMORY.LoaderErrorLogMemory = 28
TYPE_OF_MEMORY.LoaderMaximum = 29


KTM_STATE = v_enum()
KTM_STATE.KKtmUninitialized = 0
KTM_STATE.KKtmInitialized = 1
KTM_STATE.KKtmRecovering = 2
KTM_STATE.KKtmOnline = 3
KTM_STATE.KKtmRecoveryFailed = 4
KTM_STATE.KKtmOffline = 5


PP_NPAGED_LOOKASIDE_NUMBER = v_enum()
PP_NPAGED_LOOKASIDE_NUMBER.LookasideSmallIrpList = 0
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMediumIrpList = 1
PP_NPAGED_LOOKASIDE_NUMBER.LookasideLargeIrpList = 2
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMdlList = 3
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCreateInfoList = 4
PP_NPAGED_LOOKASIDE_NUMBER.LookasideNameBufferList = 5
PP_NPAGED_LOOKASIDE_NUMBER.LookasideTwilightList = 6
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCompletionList = 7
PP_NPAGED_LOOKASIDE_NUMBER.LookasideScratchBufferList = 8
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMaximumList = 9


PLUGPLAY_EVENT_CATEGORY = v_enum()
PLUGPLAY_EVENT_CATEGORY.HardwareProfileChangeEvent = 0
PLUGPLAY_EVENT_CATEGORY.TargetDeviceChangeEvent = 1
PLUGPLAY_EVENT_CATEGORY.DeviceClassChangeEvent = 2
PLUGPLAY_EVENT_CATEGORY.CustomDeviceEvent = 3
PLUGPLAY_EVENT_CATEGORY.DeviceInstallEvent = 4
PLUGPLAY_EVENT_CATEGORY.DeviceArrivalEvent = 5
PLUGPLAY_EVENT_CATEGORY.VetoEvent = 6
PLUGPLAY_EVENT_CATEGORY.BlockedDriverEvent = 7
PLUGPLAY_EVENT_CATEGORY.InvalidIDEvent = 8
PLUGPLAY_EVENT_CATEGORY.DevicePropertyChangeEvent = 9
PLUGPLAY_EVENT_CATEGORY.DeviceInstanceRemovalEvent = 10
PLUGPLAY_EVENT_CATEGORY.MaxPlugEventCategory = 11


IO_SESSION_STATE = v_enum()
IO_SESSION_STATE.IoSessionStateCreated = 1
IO_SESSION_STATE.IoSessionStateInitialized = 2
IO_SESSION_STATE.IoSessionStateConnected = 3
IO_SESSION_STATE.IoSessionStateDisconnected = 4
IO_SESSION_STATE.IoSessionStateDisconnectedLoggedOn = 5
IO_SESSION_STATE.IoSessionStateLoggedOn = 6
IO_SESSION_STATE.IoSessionStateLoggedOff = 7
IO_SESSION_STATE.IoSessionStateTerminated = 8
IO_SESSION_STATE.IoSessionStateMax = 9


PF_FILE_ACCESS_TYPE = v_enum()
PF_FILE_ACCESS_TYPE.PfFileAccessTypeRead = 0
PF_FILE_ACCESS_TYPE.PfFileAccessTypeWrite = 1
PF_FILE_ACCESS_TYPE.PfFileAccessTypeMax = 2


ARBITER_RESULT = v_enum()
ARBITER_RESULT.ArbiterResultUndefined = -1
ARBITER_RESULT.ArbiterResultSuccess = 0
ARBITER_RESULT.ArbiterResultExternalConflict = 1
ARBITER_RESULT.ArbiterResultNullRequest = 2


MI_DYNAMIC_MEMORY_LOCKTYPE = v_enum()
MI_DYNAMIC_MEMORY_LOCKTYPE.AlreadyHeld = 0
MI_DYNAMIC_MEMORY_LOCKTYPE.AcquiredShared = 1
MI_DYNAMIC_MEMORY_LOCKTYPE.UseSpinLock = 2
MI_DYNAMIC_MEMORY_LOCKTYPE.UseSpinLockRaiseIrql = 3


DEVICE_TEXT_TYPE = v_enum()
DEVICE_TEXT_TYPE.DeviceTextDescription = 0
DEVICE_TEXT_TYPE.DeviceTextLocationInformation = 1


POWER_ACTION = v_enum()
POWER_ACTION.PowerActionNone = 0
POWER_ACTION.PowerActionReserved = 1
POWER_ACTION.PowerActionSleep = 2
POWER_ACTION.PowerActionHibernate = 3
POWER_ACTION.PowerActionShutdown = 4
POWER_ACTION.PowerActionShutdownReset = 5
POWER_ACTION.PowerActionShutdownOff = 6
POWER_ACTION.PowerActionWarmEject = 7


CONFIGURATION_CLASS = v_enum()
CONFIGURATION_CLASS.SystemClass = 0
CONFIGURATION_CLASS.ProcessorClass = 1
CONFIGURATION_CLASS.CacheClass = 2
CONFIGURATION_CLASS.AdapterClass = 3
CONFIGURATION_CLASS.ControllerClass = 4
CONFIGURATION_CLASS.PeripheralClass = 5
CONFIGURATION_CLASS.MemoryClass = 6
CONFIGURATION_CLASS.MaximumClass = 7


ARBITER_REQUEST_SOURCE = v_enum()
ARBITER_REQUEST_SOURCE.ArbiterRequestUndefined = -1
ARBITER_REQUEST_SOURCE.ArbiterRequestLegacyReported = 0
ARBITER_REQUEST_SOURCE.ArbiterRequestHalReported = 1
ARBITER_REQUEST_SOURCE.ArbiterRequestLegacyAssigned = 2
ARBITER_REQUEST_SOURCE.ArbiterRequestPnpDetected = 3
ARBITER_REQUEST_SOURCE.ArbiterRequestPnpEnumerated = 4


PS_STD_HANDLE_STATE = v_enum()
PS_STD_HANDLE_STATE.PsNeverDuplicate = 0
PS_STD_HANDLE_STATE.PsRequestDuplicate = 1
PS_STD_HANDLE_STATE.PsAlwaysDuplicate = 2
PS_STD_HANDLE_STATE.PsMaxStdHandleStates = 3


KOBJECTS = v_enum()
KOBJECTS.EventNotificationObject = 0
KOBJECTS.EventSynchronizationObject = 1
KOBJECTS.MutantObject = 2
KOBJECTS.ProcessObject = 3
KOBJECTS.QueueObject = 4
KOBJECTS.SemaphoreObject = 5
KOBJECTS.ThreadObject = 6
KOBJECTS.GateObject = 7
KOBJECTS.TimerNotificationObject = 8
KOBJECTS.TimerSynchronizationObject = 9
KOBJECTS.Spare2Object = 10
KOBJECTS.Spare3Object = 11
KOBJECTS.Spare4Object = 12
KOBJECTS.Spare5Object = 13
KOBJECTS.Spare6Object = 14
KOBJECTS.Spare7Object = 15
KOBJECTS.Spare8Object = 16
KOBJECTS.Spare9Object = 17
KOBJECTS.ApcObject = 18
KOBJECTS.DpcObject = 19
KOBJECTS.DeviceQueueObject = 20
KOBJECTS.EventPairObject = 21
KOBJECTS.InterruptObject = 22
KOBJECTS.ProfileObject = 23
KOBJECTS.ThreadedDpcObject = 24
KOBJECTS.MaximumKernelObject = 25


CM_LOAD_FAILURE_TYPE = v_enum()
CM_LOAD_FAILURE_TYPE._None = 0
CM_LOAD_FAILURE_TYPE.CmInitializeHive = 1
CM_LOAD_FAILURE_TYPE.HvInitializeHive = 2
CM_LOAD_FAILURE_TYPE.HvpBuildMap = 3
CM_LOAD_FAILURE_TYPE.HvpBuildMapAndCopy = 4
CM_LOAD_FAILURE_TYPE.HvpInitMap = 5
CM_LOAD_FAILURE_TYPE.HvLoadHive = 6
CM_LOAD_FAILURE_TYPE.HvpReadFileImageAndBuildMap = 7
CM_LOAD_FAILURE_TYPE.HvpRecoverData = 8
CM_LOAD_FAILURE_TYPE.HvpRecoverWholeHive = 9
CM_LOAD_FAILURE_TYPE.HvpMapFileImageAndBuildMap = 10
CM_LOAD_FAILURE_TYPE.CmpValidateHiveSecurityDescriptors = 11
CM_LOAD_FAILURE_TYPE.HvpEnlistBinInMap = 12
CM_LOAD_FAILURE_TYPE.CmCheckRegistry = 13
CM_LOAD_FAILURE_TYPE.CmRegistryIO = 14
CM_LOAD_FAILURE_TYPE.CmCheckRegistry2 = 15
CM_LOAD_FAILURE_TYPE.CmpCheckKey = 16
CM_LOAD_FAILURE_TYPE.CmpCheckValueList = 17
CM_LOAD_FAILURE_TYPE.HvCheckHive = 18
CM_LOAD_FAILURE_TYPE.HvCheckBin = 19


ETW_BUFFER_STATE = v_enum()
ETW_BUFFER_STATE.EtwBufferStateFree = 0
ETW_BUFFER_STATE.EtwBufferStateGeneralLogging = 1
ETW_BUFFER_STATE.EtwBufferStateCSwitch = 2
ETW_BUFFER_STATE.EtwBufferStateFlush = 3
ETW_BUFFER_STATE.EtwBufferStateMaximum = 4


PS_ATTRIBUTE_NUM = v_enum()
PS_ATTRIBUTE_NUM.PsAttributeParentProcess = 0
PS_ATTRIBUTE_NUM.PsAttributeDebugObject = 1
PS_ATTRIBUTE_NUM.PsAttributeToken = 2
PS_ATTRIBUTE_NUM.PsAttributeClientId = 3
PS_ATTRIBUTE_NUM.PsAttributeTebAddress = 4
PS_ATTRIBUTE_NUM.PsAttributeImageName = 5
PS_ATTRIBUTE_NUM.PsAttributeImageInfo = 6
PS_ATTRIBUTE_NUM.PsAttributeMemoryReserve = 7
PS_ATTRIBUTE_NUM.PsAttributePriorityClass = 8
PS_ATTRIBUTE_NUM.PsAttributeErrorMode = 9
PS_ATTRIBUTE_NUM.PsAttributeStdHandleInfo = 10
PS_ATTRIBUTE_NUM.PsAttributeHandleList = 11
PS_ATTRIBUTE_NUM.PsAttributeGroupAffinity = 12
PS_ATTRIBUTE_NUM.PsAttributePreferredNode = 13
PS_ATTRIBUTE_NUM.PsAttributeIdealProcessor = 14
PS_ATTRIBUTE_NUM.PsAttributeUmsThread = 15
PS_ATTRIBUTE_NUM.PsAttributeExecuteOptions = 16
PS_ATTRIBUTE_NUM.PsAttributeMax = 17


POWER_POLICY_DEVICE_TYPE = v_enum()
POWER_POLICY_DEVICE_TYPE.PolicyDeviceSystemButton = 0
POWER_POLICY_DEVICE_TYPE.PolicyDeviceThermalZone = 1
POWER_POLICY_DEVICE_TYPE.PolicyDeviceBattery = 2
POWER_POLICY_DEVICE_TYPE.PolicyDeviceMemory = 3
POWER_POLICY_DEVICE_TYPE.PolicyInitiatePowerActionAPI = 4
POWER_POLICY_DEVICE_TYPE.PolicySetPowerStateAPI = 5
POWER_POLICY_DEVICE_TYPE.PolicyImmediateDozeS4 = 6
POWER_POLICY_DEVICE_TYPE.PolicySystemIdle = 7
POWER_POLICY_DEVICE_TYPE.PolicyDeviceMax = 8


UoWActionType = v_enum()
UoWActionType.UoWAddThisKey = 0
UoWActionType.UoWAddChildKey = 1
UoWActionType.UoWDeleteThisKey = 2
UoWActionType.UoWDeleteChildKey = 3
UoWActionType.UoWSetValueNew = 4
UoWActionType.UoWSetValueExisting = 5
UoWActionType.UoWDeleteValue = 6
UoWActionType.UoWSetKeyUserFlags = 7
UoWActionType.UoWSetLastWriteTime = 8
UoWActionType.UoWSetSecurityDescriptor = 9
UoWActionType.UoWRenameSubKey = 10
UoWActionType.UoWRenameOldSubKey = 11
UoWActionType.UoWRenameNewSubKey = 12
UoWActionType.UoWIsolation = 13
UoWActionType.UoWInvalid = 14


_unnamed_29164 = v_enum()
_unnamed_29164.KTMOH_CommitTransaction_Result = 1
_unnamed_29164.KTMOH_RollbackTransaction_Result = 2


WHEA_ERROR_PACKET_DATA_FORMAT = v_enum()
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatIPFSalRecord = 0
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatXPFMCA = 1
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMemory = 2
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIExpress = 3
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatNMIPort = 4
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXBus = 5
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXDevice = 6
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatGeneric = 7
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMax = 8


DPFLTR_TYPE = v_enum()
DPFLTR_TYPE.DPFLTR_SYSTEM_ID = 0
DPFLTR_TYPE.DPFLTR_SMSS_ID = 1
DPFLTR_TYPE.DPFLTR_SETUP_ID = 2
DPFLTR_TYPE.DPFLTR_NTFS_ID = 3
DPFLTR_TYPE.DPFLTR_FSTUB_ID = 4
DPFLTR_TYPE.DPFLTR_CRASHDUMP_ID = 5
DPFLTR_TYPE.DPFLTR_CDAUDIO_ID = 6
DPFLTR_TYPE.DPFLTR_CDROM_ID = 7
DPFLTR_TYPE.DPFLTR_CLASSPNP_ID = 8
DPFLTR_TYPE.DPFLTR_DISK_ID = 9
DPFLTR_TYPE.DPFLTR_REDBOOK_ID = 10
DPFLTR_TYPE.DPFLTR_STORPROP_ID = 11
DPFLTR_TYPE.DPFLTR_SCSIPORT_ID = 12
DPFLTR_TYPE.DPFLTR_SCSIMINIPORT_ID = 13
DPFLTR_TYPE.DPFLTR_CONFIG_ID = 14
DPFLTR_TYPE.DPFLTR_I8042PRT_ID = 15
DPFLTR_TYPE.DPFLTR_SERMOUSE_ID = 16
DPFLTR_TYPE.DPFLTR_LSERMOUS_ID = 17
DPFLTR_TYPE.DPFLTR_KBDHID_ID = 18
DPFLTR_TYPE.DPFLTR_MOUHID_ID = 19
DPFLTR_TYPE.DPFLTR_KBDCLASS_ID = 20
DPFLTR_TYPE.DPFLTR_MOUCLASS_ID = 21
DPFLTR_TYPE.DPFLTR_TWOTRACK_ID = 22
DPFLTR_TYPE.DPFLTR_WMILIB_ID = 23
DPFLTR_TYPE.DPFLTR_ACPI_ID = 24
DPFLTR_TYPE.DPFLTR_AMLI_ID = 25
DPFLTR_TYPE.DPFLTR_HALIA64_ID = 26
DPFLTR_TYPE.DPFLTR_VIDEO_ID = 27
DPFLTR_TYPE.DPFLTR_SVCHOST_ID = 28
DPFLTR_TYPE.DPFLTR_VIDEOPRT_ID = 29
DPFLTR_TYPE.DPFLTR_TCPIP_ID = 30
DPFLTR_TYPE.DPFLTR_DMSYNTH_ID = 31
DPFLTR_TYPE.DPFLTR_NTOSPNP_ID = 32
DPFLTR_TYPE.DPFLTR_FASTFAT_ID = 33
DPFLTR_TYPE.DPFLTR_SAMSS_ID = 34
DPFLTR_TYPE.DPFLTR_PNPMGR_ID = 35
DPFLTR_TYPE.DPFLTR_NETAPI_ID = 36
DPFLTR_TYPE.DPFLTR_SCSERVER_ID = 37
DPFLTR_TYPE.DPFLTR_SCCLIENT_ID = 38
DPFLTR_TYPE.DPFLTR_SERIAL_ID = 39
DPFLTR_TYPE.DPFLTR_SERENUM_ID = 40
DPFLTR_TYPE.DPFLTR_UHCD_ID = 41
DPFLTR_TYPE.DPFLTR_RPCPROXY_ID = 42
DPFLTR_TYPE.DPFLTR_AUTOCHK_ID = 43
DPFLTR_TYPE.DPFLTR_DCOMSS_ID = 44
DPFLTR_TYPE.DPFLTR_UNIMODEM_ID = 45
DPFLTR_TYPE.DPFLTR_SIS_ID = 46
DPFLTR_TYPE.DPFLTR_FLTMGR_ID = 47
DPFLTR_TYPE.DPFLTR_WMICORE_ID = 48
DPFLTR_TYPE.DPFLTR_BURNENG_ID = 49
DPFLTR_TYPE.DPFLTR_IMAPI_ID = 50
DPFLTR_TYPE.DPFLTR_SXS_ID = 51
DPFLTR_TYPE.DPFLTR_FUSION_ID = 52
DPFLTR_TYPE.DPFLTR_IDLETASK_ID = 53
DPFLTR_TYPE.DPFLTR_SOFTPCI_ID = 54
DPFLTR_TYPE.DPFLTR_TAPE_ID = 55
DPFLTR_TYPE.DPFLTR_MCHGR_ID = 56
DPFLTR_TYPE.DPFLTR_IDEP_ID = 57
DPFLTR_TYPE.DPFLTR_PCIIDE_ID = 58
DPFLTR_TYPE.DPFLTR_FLOPPY_ID = 59
DPFLTR_TYPE.DPFLTR_FDC_ID = 60
DPFLTR_TYPE.DPFLTR_TERMSRV_ID = 61
DPFLTR_TYPE.DPFLTR_W32TIME_ID = 62
DPFLTR_TYPE.DPFLTR_PREFETCHER_ID = 63
DPFLTR_TYPE.DPFLTR_RSFILTER_ID = 64
DPFLTR_TYPE.DPFLTR_FCPORT_ID = 65
DPFLTR_TYPE.DPFLTR_PCI_ID = 66
DPFLTR_TYPE.DPFLTR_DMIO_ID = 67
DPFLTR_TYPE.DPFLTR_DMCONFIG_ID = 68
DPFLTR_TYPE.DPFLTR_DMADMIN_ID = 69
DPFLTR_TYPE.DPFLTR_WSOCKTRANSPORT_ID = 70
DPFLTR_TYPE.DPFLTR_VSS_ID = 71
DPFLTR_TYPE.DPFLTR_PNPMEM_ID = 72
DPFLTR_TYPE.DPFLTR_PROCESSOR_ID = 73
DPFLTR_TYPE.DPFLTR_DMSERVER_ID = 74
DPFLTR_TYPE.DPFLTR_SR_ID = 75
DPFLTR_TYPE.DPFLTR_INFINIBAND_ID = 76
DPFLTR_TYPE.DPFLTR_IHVDRIVER_ID = 77
DPFLTR_TYPE.DPFLTR_IHVVIDEO_ID = 78
DPFLTR_TYPE.DPFLTR_IHVAUDIO_ID = 79
DPFLTR_TYPE.DPFLTR_IHVNETWORK_ID = 80
DPFLTR_TYPE.DPFLTR_IHVSTREAMING_ID = 81
DPFLTR_TYPE.DPFLTR_IHVBUS_ID = 82
DPFLTR_TYPE.DPFLTR_HPS_ID = 83
DPFLTR_TYPE.DPFLTR_RTLTHREADPOOL_ID = 84
DPFLTR_TYPE.DPFLTR_LDR_ID = 85
DPFLTR_TYPE.DPFLTR_TCPIP6_ID = 86
DPFLTR_TYPE.DPFLTR_ISAPNP_ID = 87
DPFLTR_TYPE.DPFLTR_SHPC_ID = 88
DPFLTR_TYPE.DPFLTR_STORPORT_ID = 89
DPFLTR_TYPE.DPFLTR_STORMINIPORT_ID = 90
DPFLTR_TYPE.DPFLTR_PRINTSPOOLER_ID = 91
DPFLTR_TYPE.DPFLTR_VSSDYNDISK_ID = 92
DPFLTR_TYPE.DPFLTR_VERIFIER_ID = 93
DPFLTR_TYPE.DPFLTR_VDS_ID = 94
DPFLTR_TYPE.DPFLTR_VDSBAS_ID = 95
DPFLTR_TYPE.DPFLTR_VDSDYN_ID = 96
DPFLTR_TYPE.DPFLTR_VDSDYNDR_ID = 97
DPFLTR_TYPE.DPFLTR_VDSLDR_ID = 98
DPFLTR_TYPE.DPFLTR_VDSUTIL_ID = 99
DPFLTR_TYPE.DPFLTR_DFRGIFC_ID = 100
DPFLTR_TYPE.DPFLTR_DEFAULT_ID = 101
DPFLTR_TYPE.DPFLTR_MM_ID = 102
DPFLTR_TYPE.DPFLTR_DFSC_ID = 103
DPFLTR_TYPE.DPFLTR_WOW64_ID = 104
DPFLTR_TYPE.DPFLTR_ALPC_ID = 105
DPFLTR_TYPE.DPFLTR_WDI_ID = 106
DPFLTR_TYPE.DPFLTR_PERFLIB_ID = 107
DPFLTR_TYPE.DPFLTR_KTM_ID = 108
DPFLTR_TYPE.DPFLTR_IOSTRESS_ID = 109
DPFLTR_TYPE.DPFLTR_HEAP_ID = 110
DPFLTR_TYPE.DPFLTR_WHEA_ID = 111
DPFLTR_TYPE.DPFLTR_USERGDI_ID = 112
DPFLTR_TYPE.DPFLTR_MMCSS_ID = 113
DPFLTR_TYPE.DPFLTR_TPM_ID = 114
DPFLTR_TYPE.DPFLTR_THREADORDER_ID = 115
DPFLTR_TYPE.DPFLTR_ENVIRON_ID = 116
DPFLTR_TYPE.DPFLTR_EMS_ID = 117
DPFLTR_TYPE.DPFLTR_WDT_ID = 118
DPFLTR_TYPE.DPFLTR_FVEVOL_ID = 119
DPFLTR_TYPE.DPFLTR_NDIS_ID = 120
DPFLTR_TYPE.DPFLTR_NVCTRACE_ID = 121
DPFLTR_TYPE.DPFLTR_LUAFV_ID = 122
DPFLTR_TYPE.DPFLTR_APPCOMPAT_ID = 123
DPFLTR_TYPE.DPFLTR_USBSTOR_ID = 124
DPFLTR_TYPE.DPFLTR_SBP2PORT_ID = 125
DPFLTR_TYPE.DPFLTR_COVERAGE_ID = 126
DPFLTR_TYPE.DPFLTR_CACHEMGR_ID = 127
DPFLTR_TYPE.DPFLTR_MOUNTMGR_ID = 128
DPFLTR_TYPE.DPFLTR_CFR_ID = 129
DPFLTR_TYPE.DPFLTR_TXF_ID = 130
DPFLTR_TYPE.DPFLTR_KSECDD_ID = 131
DPFLTR_TYPE.DPFLTR_FLTREGRESS_ID = 132
DPFLTR_TYPE.DPFLTR_MPIO_ID = 133
DPFLTR_TYPE.DPFLTR_MSDSM_ID = 134
DPFLTR_TYPE.DPFLTR_UDFS_ID = 135
DPFLTR_TYPE.DPFLTR_PSHED_ID = 136
DPFLTR_TYPE.DPFLTR_STORVSP_ID = 137
DPFLTR_TYPE.DPFLTR_LSASS_ID = 138
DPFLTR_TYPE.DPFLTR_SSPICLI_ID = 139
DPFLTR_TYPE.DPFLTR_CNG_ID = 140
DPFLTR_TYPE.DPFLTR_EXFAT_ID = 141
DPFLTR_TYPE.DPFLTR_FILETRACE_ID = 142
DPFLTR_TYPE.DPFLTR_XSAVE_ID = 143
DPFLTR_TYPE.DPFLTR_SE_ID = 144
DPFLTR_TYPE.DPFLTR_DRIVEEXTENDER_ID = 145
DPFLTR_TYPE.DPFLTR_ENDOFTABLE_ID = 146


INTERLOCKED_RESULT = v_enum()
INTERLOCKED_RESULT.ResultNegative = 1
INTERLOCKED_RESULT.ResultZero = 0
INTERLOCKED_RESULT.ResultPositive = 2


IO_PRIORITY_HINT = v_enum()
IO_PRIORITY_HINT.IoPriorityVeryLow = 0
IO_PRIORITY_HINT.IoPriorityLow = 1
IO_PRIORITY_HINT.IoPriorityNormal = 2
IO_PRIORITY_HINT.IoPriorityHigh = 3
IO_PRIORITY_HINT.IoPriorityCritical = 4
IO_PRIORITY_HINT.MaxIoPriorityTypes = 5


SYSTEM_POWER_CONDITION = v_enum()
SYSTEM_POWER_CONDITION.PoAc = 0
SYSTEM_POWER_CONDITION.PoDc = 1
SYSTEM_POWER_CONDITION.PoHot = 2
SYSTEM_POWER_CONDITION.PoConditionMaximum = 3


KTRANSACTION_OUTCOME = v_enum()
KTRANSACTION_OUTCOME.KTxOutcomeUninitialized = 0
KTRANSACTION_OUTCOME.KTxOutcomeUndetermined = 1
KTRANSACTION_OUTCOME.KTxOutcomeCommitted = 2
KTRANSACTION_OUTCOME.KTxOutcomeAborted = 3
KTRANSACTION_OUTCOME.KTxOutcomeUnavailable = 4


KENLISTMENT_STATE = v_enum()
KENLISTMENT_STATE.KEnlistmentUninitialized = 0
KENLISTMENT_STATE.KEnlistmentActive = 256
KENLISTMENT_STATE.KEnlistmentPreparing = 257
KENLISTMENT_STATE.KEnlistmentPrepared = 258
KENLISTMENT_STATE.KEnlistmentInDoubt = 259
KENLISTMENT_STATE.KEnlistmentCommitted = 260
KENLISTMENT_STATE.KEnlistmentCommittedNotify = 261
KENLISTMENT_STATE.KEnlistmentCommitRequested = 262
KENLISTMENT_STATE.KEnlistmentAborted = 263
KENLISTMENT_STATE.KEnlistmentDelegated = 264
KENLISTMENT_STATE.KEnlistmentDelegatedDisconnected = 265
KENLISTMENT_STATE.KEnlistmentPrePreparing = 266
KENLISTMENT_STATE.KEnlistmentForgotten = 267
KENLISTMENT_STATE.KEnlistmentRecovering = 268
KENLISTMENT_STATE.KEnlistmentAborting = 269
KENLISTMENT_STATE.KEnlistmentReadOnly = 270
KENLISTMENT_STATE.KEnlistmentOutcomeUnavailable = 271
KENLISTMENT_STATE.KEnlistmentOffline = 272
KENLISTMENT_STATE.KEnlistmentPrePrepared = 273
KENLISTMENT_STATE.KEnlistmentInitialized = 274


ETW_PROVIDER_STATE = v_enum()
ETW_PROVIDER_STATE.EtwProviderStateFree = 0
ETW_PROVIDER_STATE.EtwProviderStateTransition = 1
ETW_PROVIDER_STATE.EtwProviderStateActive = 2
ETW_PROVIDER_STATE.EtwProviderStateMax = 3


EX_POOL_PRIORITY = v_enum()
EX_POOL_PRIORITY.LowPoolPriority = 0
EX_POOL_PRIORITY.LowPoolPrioritySpecialPoolOverrun = 8
EX_POOL_PRIORITY.LowPoolPrioritySpecialPoolUnderrun = 9
EX_POOL_PRIORITY.NormalPoolPriority = 16
EX_POOL_PRIORITY.NormalPoolPrioritySpecialPoolOverrun = 24
EX_POOL_PRIORITY.NormalPoolPrioritySpecialPoolUnderrun = 25
EX_POOL_PRIORITY.HighPoolPriority = 32
EX_POOL_PRIORITY.HighPoolPrioritySpecialPoolOverrun = 40
EX_POOL_PRIORITY.HighPoolPrioritySpecialPoolUnderrun = 41


KINTERRUPT_POLARITY = v_enum()
KINTERRUPT_POLARITY.InterruptPolarityUnknown = 0
KINTERRUPT_POLARITY.InterruptActiveHigh = 1
KINTERRUPT_POLARITY.InterruptActiveLow = 2


PNP_VETO_TYPE = v_enum()
PNP_VETO_TYPE.PNP_VetoTypeUnknown = 0
PNP_VETO_TYPE.PNP_VetoLegacyDevice = 1
PNP_VETO_TYPE.PNP_VetoPendingClose = 2
PNP_VETO_TYPE.PNP_VetoWindowsApp = 3
PNP_VETO_TYPE.PNP_VetoWindowsService = 4
PNP_VETO_TYPE.PNP_VetoOutstandingOpen = 5
PNP_VETO_TYPE.PNP_VetoDevice = 6
PNP_VETO_TYPE.PNP_VetoDriver = 7
PNP_VETO_TYPE.PNP_VetoIllegalDeviceRequest = 8
PNP_VETO_TYPE.PNP_VetoInsufficientPower = 9
PNP_VETO_TYPE.PNP_VetoNonDisableable = 10
PNP_VETO_TYPE.PNP_VetoLegacyDriver = 11
PNP_VETO_TYPE.PNP_VetoInsufficientRights = 12


SECURITY_IMPERSONATION_LEVEL = v_enum()
SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous = 0
SECURITY_IMPERSONATION_LEVEL.SecurityIdentification = 1
SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation = 2
SECURITY_IMPERSONATION_LEVEL.SecurityDelegation = 3


KRESOURCEMANAGER_STATE = v_enum()
KRESOURCEMANAGER_STATE.KResourceManagerUninitialized = 0
KRESOURCEMANAGER_STATE.KResourceManagerOffline = 1
KRESOURCEMANAGER_STATE.KResourceManagerOnline = 2


ALTERNATIVE_ARCHITECTURE_TYPE = v_enum()
ALTERNATIVE_ARCHITECTURE_TYPE.StandardDesign = 0
ALTERNATIVE_ARCHITECTURE_TYPE.NEC98x86 = 1
ALTERNATIVE_ARCHITECTURE_TYPE.EndAlternatives = 2


PCW_CALLBACK_TYPE = v_enum()
PCW_CALLBACK_TYPE.PcwCallbackAddCounter = 0
PCW_CALLBACK_TYPE.PcwCallbackRemoveCounter = 1
PCW_CALLBACK_TYPE.PcwCallbackEnumerateInstances = 2
PCW_CALLBACK_TYPE.PcwCallbackCollectData = 3


REQUESTER_TYPE = v_enum()
REQUESTER_TYPE.KernelRequester = 0
REQUESTER_TYPE.UserProcessRequester = 1
REQUESTER_TYPE.UserSharedServiceRequester = 2


SYSTEM_POWER_STATE = v_enum()
SYSTEM_POWER_STATE.PowerSystemUnspecified = 0
SYSTEM_POWER_STATE.PowerSystemWorking = 1
SYSTEM_POWER_STATE.PowerSystemSleeping1 = 2
SYSTEM_POWER_STATE.PowerSystemSleeping2 = 3
SYSTEM_POWER_STATE.PowerSystemSleeping3 = 4
SYSTEM_POWER_STATE.PowerSystemHibernate = 5
SYSTEM_POWER_STATE.PowerSystemShutdown = 6
SYSTEM_POWER_STATE.PowerSystemMaximum = 7


MEMORY_CACHING_TYPE_ORIG = v_enum()
MEMORY_CACHING_TYPE_ORIG.MmFrameBufferCached = 2


PROFILE_STATUS = v_enum()
PROFILE_STATUS.DOCK_NOTDOCKDEVICE = 0
PROFILE_STATUS.DOCK_QUIESCENT = 1
PROFILE_STATUS.DOCK_ARRIVING = 2
PROFILE_STATUS.DOCK_DEPARTING = 3
PROFILE_STATUS.DOCK_EJECTIRP_COMPLETED = 4


MM_POOL_PRIORITIES = v_enum()
MM_POOL_PRIORITIES.MmHighPriority = 0
MM_POOL_PRIORITIES.MmNormalPriority = 1
MM_POOL_PRIORITIES.MmLowPriority = 2
MM_POOL_PRIORITIES.MmMaximumPoolPriority = 3


BLOB_ID = v_enum()
BLOB_ID.BLOB_TYPE_UNKNOWN = 0
BLOB_ID.BLOB_TYPE_CONNECTION_INFO = 1
BLOB_ID.BLOB_TYPE_MESSAGE = 2
BLOB_ID.BLOB_TYPE_SECURITY_CONTEXT = 3
BLOB_ID.BLOB_TYPE_SECTION = 4
BLOB_ID.BLOB_TYPE_REGION = 5
BLOB_ID.BLOB_TYPE_VIEW = 6
BLOB_ID.BLOB_TYPE_RESERVE = 7
BLOB_ID.BLOB_TYPE_DIRECT_TRANSFER = 8
BLOB_ID.BLOB_TYPE_HANDLE_DATA = 9
BLOB_ID.BLOB_TYPE_MAX_ID = 10


REG_NOTIFY_CLASS = v_enum()
REG_NOTIFY_CLASS.RegNtDeleteKey = 0
REG_NOTIFY_CLASS.RegNtPreDeleteKey = 0
REG_NOTIFY_CLASS.RegNtSetValueKey = 1
REG_NOTIFY_CLASS.RegNtPreSetValueKey = 1
REG_NOTIFY_CLASS.RegNtDeleteValueKey = 2
REG_NOTIFY_CLASS.RegNtPreDeleteValueKey = 2
REG_NOTIFY_CLASS.RegNtSetInformationKey = 3
REG_NOTIFY_CLASS.RegNtPreSetInformationKey = 3
REG_NOTIFY_CLASS.RegNtRenameKey = 4
REG_NOTIFY_CLASS.RegNtPreRenameKey = 4
REG_NOTIFY_CLASS.RegNtEnumerateKey = 5
REG_NOTIFY_CLASS.RegNtPreEnumerateKey = 5
REG_NOTIFY_CLASS.RegNtEnumerateValueKey = 6
REG_NOTIFY_CLASS.RegNtPreEnumerateValueKey = 6
REG_NOTIFY_CLASS.RegNtQueryKey = 7
REG_NOTIFY_CLASS.RegNtPreQueryKey = 7
REG_NOTIFY_CLASS.RegNtQueryValueKey = 8
REG_NOTIFY_CLASS.RegNtPreQueryValueKey = 8
REG_NOTIFY_CLASS.RegNtQueryMultipleValueKey = 9
REG_NOTIFY_CLASS.RegNtPreQueryMultipleValueKey = 9
REG_NOTIFY_CLASS.RegNtPreCreateKey = 10
REG_NOTIFY_CLASS.RegNtPostCreateKey = 11
REG_NOTIFY_CLASS.RegNtPreOpenKey = 12
REG_NOTIFY_CLASS.RegNtPostOpenKey = 13
REG_NOTIFY_CLASS.RegNtKeyHandleClose = 14
REG_NOTIFY_CLASS.RegNtPreKeyHandleClose = 14
REG_NOTIFY_CLASS.RegNtPostDeleteKey = 15
REG_NOTIFY_CLASS.RegNtPostSetValueKey = 16
REG_NOTIFY_CLASS.RegNtPostDeleteValueKey = 17
REG_NOTIFY_CLASS.RegNtPostSetInformationKey = 18
REG_NOTIFY_CLASS.RegNtPostRenameKey = 19
REG_NOTIFY_CLASS.RegNtPostEnumerateKey = 20
REG_NOTIFY_CLASS.RegNtPostEnumerateValueKey = 21
REG_NOTIFY_CLASS.RegNtPostQueryKey = 22
REG_NOTIFY_CLASS.RegNtPostQueryValueKey = 23
REG_NOTIFY_CLASS.RegNtPostQueryMultipleValueKey = 24
REG_NOTIFY_CLASS.RegNtPostKeyHandleClose = 25
REG_NOTIFY_CLASS.RegNtPreCreateKeyEx = 26
REG_NOTIFY_CLASS.RegNtPostCreateKeyEx = 27
REG_NOTIFY_CLASS.RegNtPreOpenKeyEx = 28
REG_NOTIFY_CLASS.RegNtPostOpenKeyEx = 29
REG_NOTIFY_CLASS.RegNtPreFlushKey = 30
REG_NOTIFY_CLASS.RegNtPostFlushKey = 31
REG_NOTIFY_CLASS.RegNtPreLoadKey = 32
REG_NOTIFY_CLASS.RegNtPostLoadKey = 33
REG_NOTIFY_CLASS.RegNtPreUnLoadKey = 34
REG_NOTIFY_CLASS.RegNtPostUnLoadKey = 35
REG_NOTIFY_CLASS.RegNtPreQueryKeySecurity = 36
REG_NOTIFY_CLASS.RegNtPostQueryKeySecurity = 37
REG_NOTIFY_CLASS.RegNtPreSetKeySecurity = 38
REG_NOTIFY_CLASS.RegNtPostSetKeySecurity = 39
REG_NOTIFY_CLASS.RegNtCallbackObjectContextCleanup = 40
REG_NOTIFY_CLASS.RegNtPreRestoreKey = 41
REG_NOTIFY_CLASS.RegNtPostRestoreKey = 42
REG_NOTIFY_CLASS.RegNtPreSaveKey = 43
REG_NOTIFY_CLASS.RegNtPostSaveKey = 44
REG_NOTIFY_CLASS.RegNtPreReplaceKey = 45
REG_NOTIFY_CLASS.RegNtPostReplaceKey = 46
REG_NOTIFY_CLASS.MaxRegNtNotifyClass = 47


MM_POOL_FAILURE_REASONS = v_enum()
MM_POOL_FAILURE_REASONS.MmNonPagedNoPtes = 0
MM_POOL_FAILURE_REASONS.MmPriorityTooLow = 1
MM_POOL_FAILURE_REASONS.MmNonPagedNoPagesAvailable = 2
MM_POOL_FAILURE_REASONS.MmPagedNoPtes = 3
MM_POOL_FAILURE_REASONS.MmSessionPagedNoPtes = 4
MM_POOL_FAILURE_REASONS.MmPagedNoPagesAvailable = 5
MM_POOL_FAILURE_REASONS.MmSessionPagedNoPagesAvailable = 6
MM_POOL_FAILURE_REASONS.MmPagedNoCommit = 7
MM_POOL_FAILURE_REASONS.MmSessionPagedNoCommit = 8
MM_POOL_FAILURE_REASONS.MmNonPagedNoResidentAvailable = 9
MM_POOL_FAILURE_REASONS.MmNonPagedNoCommit = 10
MM_POOL_FAILURE_REASONS.MmMaximumFailureReason = 11


BUS_QUERY_ID_TYPE = v_enum()
BUS_QUERY_ID_TYPE.BusQueryDeviceID = 0
BUS_QUERY_ID_TYPE.BusQueryHardwareIDs = 1
BUS_QUERY_ID_TYPE.BusQueryCompatibleIDs = 2
BUS_QUERY_ID_TYPE.BusQueryInstanceID = 3
BUS_QUERY_ID_TYPE.BusQueryDeviceSerialNumber = 4
BUS_QUERY_ID_TYPE.BusQueryContainerID = 5


PROC_HYPERVISOR_STATE = v_enum()
PROC_HYPERVISOR_STATE.ProcHypervisorNone = 0
PROC_HYPERVISOR_STATE.ProcHypervisorPresent = 1
PROC_HYPERVISOR_STATE.ProcHypervisorPower = 2


MM_PREEMPTIVE_TRIMS = v_enum()
MM_PREEMPTIVE_TRIMS.MmPreemptForNonPaged = 0
MM_PREEMPTIVE_TRIMS.MmPreemptForPaged = 1
MM_PREEMPTIVE_TRIMS.MmPreemptForNonPagedPriority = 2
MM_PREEMPTIVE_TRIMS.MmPreemptForPagedPriority = 3
MM_PREEMPTIVE_TRIMS.MmMaximumPreempt = 4


WHEA_ERROR_SEVERITY = v_enum()
WHEA_ERROR_SEVERITY.WheaErrSevRecoverable = 0
WHEA_ERROR_SEVERITY.WheaErrSevFatal = 1
WHEA_ERROR_SEVERITY.WheaErrSevCorrected = 2
WHEA_ERROR_SEVERITY.WheaErrSevInformational = 3


VI_DEADLOCK_RESOURCE_TYPE = v_enum()
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockUnknown = 0
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockMutex = 1
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockMutexAbandoned = 2
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockFastMutex = 3
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockFastMutexUnsafe = 4
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockSpinLock = 5
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockInStackQueuedSpinLock = 6
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockUnusedSpinLock = 7
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockEresource = 8
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockTypeMaximum = 9


KWAIT_STATE = v_enum()
KWAIT_STATE.WaitInProgress = 0
KWAIT_STATE.WaitCommitted = 1
KWAIT_STATE.WaitAborted = 2
KWAIT_STATE.MaximumWaitState = 3


OBJECT_INFORMATION_CLASS = v_enum()
OBJECT_INFORMATION_CLASS.ObjectBasicInformation = 0
OBJECT_INFORMATION_CLASS.ObjectNameInformation = 1
OBJECT_INFORMATION_CLASS.ObjectTypeInformation = 2
OBJECT_INFORMATION_CLASS.ObjectTypesInformation = 3
OBJECT_INFORMATION_CLASS.ObjectHandleFlagInformation = 4
OBJECT_INFORMATION_CLASS.ObjectSessionInformation = 5
OBJECT_INFORMATION_CLASS.MaxObjectInfoClass = 6


PS_IFEO_KEY_STATE = v_enum()
PS_IFEO_KEY_STATE.PsReadIFEOAllValues = 0
PS_IFEO_KEY_STATE.PsSkipIFEODebugger = 1
PS_IFEO_KEY_STATE.PsSkipAllIFEO = 2
PS_IFEO_KEY_STATE.PsMaxIFEOKeyStates = 3


ARBITER_ACTION = v_enum()
ARBITER_ACTION.ArbiterActionTestAllocation = 0
ARBITER_ACTION.ArbiterActionRetestAllocation = 1
ARBITER_ACTION.ArbiterActionCommitAllocation = 2
ARBITER_ACTION.ArbiterActionRollbackAllocation = 3
ARBITER_ACTION.ArbiterActionQueryAllocatedResources = 4
ARBITER_ACTION.ArbiterActionWriteReservedResources = 5
ARBITER_ACTION.ArbiterActionQueryConflict = 6
ARBITER_ACTION.ArbiterActionQueryArbitrate = 7
ARBITER_ACTION.ArbiterActionAddReserved = 8
ARBITER_ACTION.ArbiterActionBootAllocation = 9


ETW_GUID_TYPE = v_enum()
ETW_GUID_TYPE.EtwTraceGuidType = 0
ETW_GUID_TYPE.EtwNotificationGuidType = 1
ETW_GUID_TYPE.EtwGuidTypeMax = 2


HEAP_FAILURE_TYPE = v_enum()
HEAP_FAILURE_TYPE.heap_failure_internal = 0
HEAP_FAILURE_TYPE.heap_failure_unknown = 1
HEAP_FAILURE_TYPE.heap_failure_generic = 2
HEAP_FAILURE_TYPE.heap_failure_entry_corruption = 3
HEAP_FAILURE_TYPE.heap_failure_multiple_entries_corruption = 4
HEAP_FAILURE_TYPE.heap_failure_virtual_block_corruption = 5
HEAP_FAILURE_TYPE.heap_failure_buffer_overrun = 6
HEAP_FAILURE_TYPE.heap_failure_buffer_underrun = 7
HEAP_FAILURE_TYPE.heap_failure_block_not_busy = 8
HEAP_FAILURE_TYPE.heap_failure_invalid_argument = 9
HEAP_FAILURE_TYPE.heap_failure_usage_after_free = 10
HEAP_FAILURE_TYPE.heap_failure_cross_heap_operation = 11
HEAP_FAILURE_TYPE.heap_failure_freelists_corruption = 12
HEAP_FAILURE_TYPE.heap_failure_listentry_corruption = 13


MM_POOL_TYPES = v_enum()
MM_POOL_TYPES.MmNonPagedPool = 0
MM_POOL_TYPES.MmPagedPool = 1
MM_POOL_TYPES.MmSessionPagedPool = 2
MM_POOL_TYPES.MmMaximumPoolType = 3


IO_PAGING_PRIORITY = v_enum()
IO_PAGING_PRIORITY.IoPagingPriorityInvalid = 0
IO_PAGING_PRIORITY.IoPagingPriorityNormal = 1
IO_PAGING_PRIORITY.IoPagingPriorityHigh = 2
IO_PAGING_PRIORITY.IoPagingPriorityReserved1 = 3
IO_PAGING_PRIORITY.IoPagingPriorityReserved2 = 4


POP_DEVICE_IDLE_TYPE = v_enum()
POP_DEVICE_IDLE_TYPE.DeviceIdleNormal = 0
POP_DEVICE_IDLE_TYPE.DeviceIdleDisk = 1


KTRANSACTION_STATE = v_enum()
KTRANSACTION_STATE.KTransactionUninitialized = 0
KTRANSACTION_STATE.KTransactionActive = 1
KTRANSACTION_STATE.KTransactionPreparing = 2
KTRANSACTION_STATE.KTransactionPrepared = 3
KTRANSACTION_STATE.KTransactionInDoubt = 4
KTRANSACTION_STATE.KTransactionCommitted = 5
KTRANSACTION_STATE.KTransactionAborted = 6
KTRANSACTION_STATE.KTransactionDelegated = 7
KTRANSACTION_STATE.KTransactionPrePreparing = 8
KTRANSACTION_STATE.KTransactionForgotten = 9
KTRANSACTION_STATE.KTransactionRecovering = 10
KTRANSACTION_STATE.KTransactionPrePrepared = 11


EXCEPTION_DISPOSITION = v_enum()
EXCEPTION_DISPOSITION.ExceptionContinueExecution = 0
EXCEPTION_DISPOSITION.ExceptionContinueSearch = 1
EXCEPTION_DISPOSITION.ExceptionNestedException = 2
EXCEPTION_DISPOSITION.ExceptionCollidedUnwind = 3


SECURITY_OPERATION_CODE = v_enum()
SECURITY_OPERATION_CODE.SetSecurityDescriptor = 0
SECURITY_OPERATION_CODE.QuerySecurityDescriptor = 1
SECURITY_OPERATION_CODE.DeleteSecurityDescriptor = 2
SECURITY_OPERATION_CODE.AssignSecurityDescriptor = 3


IRPLOCK = v_enum()
IRPLOCK.IRPLOCK_CANCELABLE = 0
IRPLOCK.IRPLOCK_CANCEL_STARTED = 1
IRPLOCK.IRPLOCK_CANCEL_COMPLETE = 2
IRPLOCK.IRPLOCK_COMPLETED = 3


FS_FILTER_STREAM_FO_NOTIFICATION_TYPE = v_enum()
FS_FILTER_STREAM_FO_NOTIFICATION_TYPE.NotifyTypeCreate = 0
FS_FILTER_STREAM_FO_NOTIFICATION_TYPE.NotifyTypeRetired = 1


DEVICE_USAGE_NOTIFICATION_TYPE = v_enum()
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeUndefined = 0
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypePaging = 1
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeHibernation = 2
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeDumpFile = 3


INTERFACE_TYPE = v_enum()
INTERFACE_TYPE.InterfaceTypeUndefined = -1
INTERFACE_TYPE.Internal = 0
INTERFACE_TYPE.Isa = 1
INTERFACE_TYPE.Eisa = 2
INTERFACE_TYPE.MicroChannel = 3
INTERFACE_TYPE.TurboChannel = 4
INTERFACE_TYPE.PCIBus = 5
INTERFACE_TYPE.VMEBus = 6
INTERFACE_TYPE.NuBus = 7
INTERFACE_TYPE.PCMCIABus = 8
INTERFACE_TYPE.CBus = 9
INTERFACE_TYPE.MPIBus = 10
INTERFACE_TYPE.MPSABus = 11
INTERFACE_TYPE.ProcessorInternal = 12
INTERFACE_TYPE.InternalPowerBus = 13
INTERFACE_TYPE.PNPISABus = 14
INTERFACE_TYPE.PNPBus = 15
INTERFACE_TYPE.Vmcs = 16
INTERFACE_TYPE.MaximumInterfaceType = 17


KWAIT_REASON = v_enum()
KWAIT_REASON.Executive = 0
KWAIT_REASON.FreePage = 1
KWAIT_REASON.PageIn = 2
KWAIT_REASON.PoolAllocation = 3
KWAIT_REASON.DelayExecution = 4
KWAIT_REASON.Suspended = 5
KWAIT_REASON.UserRequest = 6
KWAIT_REASON.WrExecutive = 7
KWAIT_REASON.WrFreePage = 8
KWAIT_REASON.WrPageIn = 9
KWAIT_REASON.WrPoolAllocation = 10
KWAIT_REASON.WrDelayExecution = 11
KWAIT_REASON.WrSuspended = 12
KWAIT_REASON.WrUserRequest = 13
KWAIT_REASON.WrEventPair = 14
KWAIT_REASON.WrQueue = 15
KWAIT_REASON.WrLpcReceive = 16
KWAIT_REASON.WrLpcReply = 17
KWAIT_REASON.WrVirtualMemory = 18
KWAIT_REASON.WrPageOut = 19
KWAIT_REASON.WrRendezvous = 20
KWAIT_REASON.WrKeyedEvent = 21
KWAIT_REASON.WrTerminated = 22
KWAIT_REASON.WrProcessInSwap = 23
KWAIT_REASON.WrCpuRateControl = 24
KWAIT_REASON.WrCalloutStack = 25
KWAIT_REASON.WrKernel = 26
KWAIT_REASON.WrResource = 27
KWAIT_REASON.WrPushLock = 28
KWAIT_REASON.WrMutex = 29
KWAIT_REASON.WrQuantumEnd = 30
KWAIT_REASON.WrDispatchInt = 31
KWAIT_REASON.WrPreempted = 32
KWAIT_REASON.WrYieldExecution = 33
KWAIT_REASON.WrFastMutex = 34
KWAIT_REASON.WrGuardedMutex = 35
KWAIT_REASON.WrRundown = 36
KWAIT_REASON.MaximumWaitReason = 37


PS_RESOURCE_TYPE = v_enum()
PS_RESOURCE_TYPE.PsResourceNonPagedPool = 0
PS_RESOURCE_TYPE.PsResourcePagedPool = 1
PS_RESOURCE_TYPE.PsResourcePageFile = 2
PS_RESOURCE_TYPE.PsResourceWorkingSet = 3
PS_RESOURCE_TYPE.PsResourceCpuRate = 4
PS_RESOURCE_TYPE.PsResourceMax = 5


MM_PAGE_ACCESS_TYPE = v_enum()
MM_PAGE_ACCESS_TYPE.MmPteAccessType = 0
MM_PAGE_ACCESS_TYPE.MmCcReadAheadType = 1
MM_PAGE_ACCESS_TYPE.MmPfnRepurposeType = 2
MM_PAGE_ACCESS_TYPE.MmMaximumPageAccessType = 3


ReplacesCorHdrNumericDefines = v_enum()
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY = 1
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED = 2
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY = 4
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED = 8
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2 = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MINOR = 0
ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB = 1
ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA = 1
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA = 2
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT = 1
ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT = 2
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED = 4
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED = 16
ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE = 32
ReplacesCorHdrNumericDefines.MAX_CLASS_NAME = 1024
ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME = 1024


HSTORAGE_TYPE = v_enum()
HSTORAGE_TYPE.Stable = 0
HSTORAGE_TYPE.Volatile = 1
HSTORAGE_TYPE.InvalidStorage = 2


MI_PFN_CACHE_ATTRIBUTE = v_enum()
MI_PFN_CACHE_ATTRIBUTE.MiNonCached = 0
MI_PFN_CACHE_ATTRIBUTE.MiCached = 1
MI_PFN_CACHE_ATTRIBUTE.MiWriteCombined = 2
MI_PFN_CACHE_ATTRIBUTE.MiNotMapped = 3


CREATE_FILE_TYPE = v_enum()
CREATE_FILE_TYPE.CreateFileTypeNone = 0
CREATE_FILE_TYPE.CreateFileTypeNamedPipe = 1
CREATE_FILE_TYPE.CreateFileTypeMailslot = 2


POLICY_AUDIT_EVENT_TYPE = v_enum()
POLICY_AUDIT_EVENT_TYPE.AuditCategorySystem = 0
POLICY_AUDIT_EVENT_TYPE.AuditCategoryLogon = 1
POLICY_AUDIT_EVENT_TYPE.AuditCategoryObjectAccess = 2
POLICY_AUDIT_EVENT_TYPE.AuditCategoryPrivilegeUse = 3
POLICY_AUDIT_EVENT_TYPE.AuditCategoryDetailedTracking = 4
POLICY_AUDIT_EVENT_TYPE.AuditCategoryPolicyChange = 5
POLICY_AUDIT_EVENT_TYPE.AuditCategoryAccountManagement = 6
POLICY_AUDIT_EVENT_TYPE.AuditCategoryDirectoryServiceAccess = 7
POLICY_AUDIT_EVENT_TYPE.AuditCategoryAccountLogon = 8


ETW_RT_EVENT_LOSS = v_enum()
ETW_RT_EVENT_LOSS.EtwRtEventNoLoss = 0
ETW_RT_EVENT_LOSS.EtwRtEventLost = 1
ETW_RT_EVENT_LOSS.EtwRtBufferLost = 2
ETW_RT_EVENT_LOSS.EtwRtBackupLost = 3
ETW_RT_EVENT_LOSS.EtwRtEventLossMax = 4


WOW64_SHARED_INFORMATION = v_enum()
WOW64_SHARED_INFORMATION.SharedNtdll32LdrInitializeThunk = 0
WOW64_SHARED_INFORMATION.SharedNtdll32KiUserExceptionDispatcher = 1
WOW64_SHARED_INFORMATION.SharedNtdll32KiUserApcDispatcher = 2
WOW64_SHARED_INFORMATION.SharedNtdll32KiUserCallbackDispatcher = 3
WOW64_SHARED_INFORMATION.SharedNtdll32LdrHotPatchRoutine = 4
WOW64_SHARED_INFORMATION.SharedNtdll32ExpInterlockedPopEntrySListFault = 5
WOW64_SHARED_INFORMATION.SharedNtdll32ExpInterlockedPopEntrySListResume = 6
WOW64_SHARED_INFORMATION.SharedNtdll32ExpInterlockedPopEntrySListEnd = 7
WOW64_SHARED_INFORMATION.SharedNtdll32RtlUserThreadStart = 8
WOW64_SHARED_INFORMATION.SharedNtdll32pQueryProcessDebugInformationRemote = 9
WOW64_SHARED_INFORMATION.SharedNtdll32EtwpNotificationThread = 10
WOW64_SHARED_INFORMATION.SharedNtdll32BaseAddress = 11
WOW64_SHARED_INFORMATION.Wow64SharedPageEntriesCount = 12


PNP_DEVICE_ACTION_REQUEST = v_enum()
PNP_DEVICE_ACTION_REQUEST.AssignResources = 0
PNP_DEVICE_ACTION_REQUEST.ClearDeviceProblem = 1
PNP_DEVICE_ACTION_REQUEST.ClearProblem = 2
PNP_DEVICE_ACTION_REQUEST.ClearEjectProblem = 3
PNP_DEVICE_ACTION_REQUEST.HaltDevice = 4
PNP_DEVICE_ACTION_REQUEST.QueryPowerRelations = 5
PNP_DEVICE_ACTION_REQUEST.Rebalance = 6
PNP_DEVICE_ACTION_REQUEST.ReenumerateBootDevices = 7
PNP_DEVICE_ACTION_REQUEST.ReenumerateDeviceOnly = 8
PNP_DEVICE_ACTION_REQUEST.ReenumerateDeviceTree = 9
PNP_DEVICE_ACTION_REQUEST.ReenumerateRootDevices = 10
PNP_DEVICE_ACTION_REQUEST.RequeryDeviceState = 11
PNP_DEVICE_ACTION_REQUEST.ResetDevice = 12
PNP_DEVICE_ACTION_REQUEST.ResourceRequirementsChanged = 13
PNP_DEVICE_ACTION_REQUEST.RestartEnumeration = 14
PNP_DEVICE_ACTION_REQUEST.SetDeviceProblem = 15
PNP_DEVICE_ACTION_REQUEST.StartDevice = 16
PNP_DEVICE_ACTION_REQUEST.StartSystemDevicesPass0 = 17
PNP_DEVICE_ACTION_REQUEST.StartSystemDevicesPass1 = 18


DEVICE_RELATION_TYPE = v_enum()
DEVICE_RELATION_TYPE.BusRelations = 0
DEVICE_RELATION_TYPE.EjectionRelations = 1
DEVICE_RELATION_TYPE.PowerRelations = 2
DEVICE_RELATION_TYPE.RemovalRelations = 3
DEVICE_RELATION_TYPE.TargetDeviceRelation = 4
DEVICE_RELATION_TYPE.SingleBusRelations = 5
DEVICE_RELATION_TYPE.TransportRelations = 6


FILE_INFORMATION_CLASS = v_enum()
FILE_INFORMATION_CLASS.FileDirectoryInformation = 1
FILE_INFORMATION_CLASS.FileFullDirectoryInformation = 2
FILE_INFORMATION_CLASS.FileBothDirectoryInformation = 3
FILE_INFORMATION_CLASS.FileBasicInformation = 4
FILE_INFORMATION_CLASS.FileStandardInformation = 5
FILE_INFORMATION_CLASS.FileInternalInformation = 6
FILE_INFORMATION_CLASS.FileEaInformation = 7
FILE_INFORMATION_CLASS.FileAccessInformation = 8
FILE_INFORMATION_CLASS.FileNameInformation = 9
FILE_INFORMATION_CLASS.FileRenameInformation = 10
FILE_INFORMATION_CLASS.FileLinkInformation = 11
FILE_INFORMATION_CLASS.FileNamesInformation = 12
FILE_INFORMATION_CLASS.FileDispositionInformation = 13
FILE_INFORMATION_CLASS.FilePositionInformation = 14
FILE_INFORMATION_CLASS.FileFullEaInformation = 15
FILE_INFORMATION_CLASS.FileModeInformation = 16
FILE_INFORMATION_CLASS.FileAlignmentInformation = 17
FILE_INFORMATION_CLASS.FileAllInformation = 18
FILE_INFORMATION_CLASS.FileAllocationInformation = 19
FILE_INFORMATION_CLASS.FileEndOfFileInformation = 20
FILE_INFORMATION_CLASS.FileAlternateNameInformation = 21
FILE_INFORMATION_CLASS.FileStreamInformation = 22
FILE_INFORMATION_CLASS.FilePipeInformation = 23
FILE_INFORMATION_CLASS.FilePipeLocalInformation = 24
FILE_INFORMATION_CLASS.FilePipeRemoteInformation = 25
FILE_INFORMATION_CLASS.FileMailslotQueryInformation = 26
FILE_INFORMATION_CLASS.FileMailslotSetInformation = 27
FILE_INFORMATION_CLASS.FileCompressionInformation = 28
FILE_INFORMATION_CLASS.FileObjectIdInformation = 29
FILE_INFORMATION_CLASS.FileCompletionInformation = 30
FILE_INFORMATION_CLASS.FileMoveClusterInformation = 31
FILE_INFORMATION_CLASS.FileQuotaInformation = 32
FILE_INFORMATION_CLASS.FileReparsePointInformation = 33
FILE_INFORMATION_CLASS.FileNetworkOpenInformation = 34
FILE_INFORMATION_CLASS.FileAttributeTagInformation = 35
FILE_INFORMATION_CLASS.FileTrackingInformation = 36
FILE_INFORMATION_CLASS.FileIdBothDirectoryInformation = 37
FILE_INFORMATION_CLASS.FileIdFullDirectoryInformation = 38
FILE_INFORMATION_CLASS.FileValidDataLengthInformation = 39
FILE_INFORMATION_CLASS.FileShortNameInformation = 40
FILE_INFORMATION_CLASS.FileIoCompletionNotificationInformation = 41
FILE_INFORMATION_CLASS.FileIoStatusBlockRangeInformation = 42
FILE_INFORMATION_CLASS.FileIoPriorityHintInformation = 43
FILE_INFORMATION_CLASS.FileSfioReserveInformation = 44
FILE_INFORMATION_CLASS.FileSfioVolumeInformation = 45
FILE_INFORMATION_CLASS.FileHardLinkInformation = 46
FILE_INFORMATION_CLASS.FileProcessIdsUsingFileInformation = 47
FILE_INFORMATION_CLASS.FileNormalizedNameInformation = 48
FILE_INFORMATION_CLASS.FileNetworkPhysicalNameInformation = 49
FILE_INFORMATION_CLASS.FileIdGlobalTxDirectoryInformation = 50
FILE_INFORMATION_CLASS.FileIsRemoteDeviceInformation = 51
FILE_INFORMATION_CLASS.FileAttributeCacheInformation = 52
FILE_INFORMATION_CLASS.FileNumaNodeInformation = 53
FILE_INFORMATION_CLASS.FileStandardLinkInformation = 54
FILE_INFORMATION_CLASS.FileRemoteProtocolInformation = 55
FILE_INFORMATION_CLASS.FileMaximumInformation = 56


DEVICE_POWER_STATE = v_enum()
DEVICE_POWER_STATE.PowerDeviceUnspecified = 0
DEVICE_POWER_STATE.PowerDeviceD0 = 1
DEVICE_POWER_STATE.PowerDeviceD1 = 2
DEVICE_POWER_STATE.PowerDeviceD2 = 3
DEVICE_POWER_STATE.PowerDeviceD3 = 4
DEVICE_POWER_STATE.PowerDeviceMaximum = 5


MEMORY_CACHING_TYPE = v_enum()
MEMORY_CACHING_TYPE.MmNonCached = 0
MEMORY_CACHING_TYPE.MmCached = 1
MEMORY_CACHING_TYPE.MmWriteCombined = 2
MEMORY_CACHING_TYPE.MmHardwareCoherentCached = 3
MEMORY_CACHING_TYPE.MmNonCachedUnordered = 4
MEMORY_CACHING_TYPE.MmUSWCCached = 5
MEMORY_CACHING_TYPE.MmMaximumCacheType = 6


NT_PRODUCT_TYPE = v_enum()
NT_PRODUCT_TYPE.NtProductWinNt = 1
NT_PRODUCT_TYPE.NtProductLanManNt = 2
NT_PRODUCT_TYPE.NtProductServer = 3


IOP_PRIORITY_HINT = v_enum()
IOP_PRIORITY_HINT.IopIoPriorityNotSet = 0
IOP_PRIORITY_HINT.IopIoPriorityVeryLow = 1
IOP_PRIORITY_HINT.IopIoPriorityLow = 2
IOP_PRIORITY_HINT.IopIoPriorityNormal = 3
IOP_PRIORITY_HINT.IopIoPriorityHigh = 4
IOP_PRIORITY_HINT.IopIoPriorityCritical = 5
IOP_PRIORITY_HINT.MaxIopIoPriorityTypes = 6


WHEA_ERROR_SOURCE_TYPE = v_enum()
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMCE = 0
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCMC = 1
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCPE = 2
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeNMI = 3
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypePCIe = 4
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeGeneric = 5
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeINIT = 6
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeBOOT = 7
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeSCIGeneric = 8
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFMCA = 9
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCMC = 10
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCPE = 11
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMax = 12


PS_CREATE_STATE = v_enum()
PS_CREATE_STATE.PsCreateInitialState = 0
PS_CREATE_STATE.PsCreateFailOnFileOpen = 1
PS_CREATE_STATE.PsCreateFailOnSectionCreate = 2
PS_CREATE_STATE.PsCreateFailExeFormat = 3
PS_CREATE_STATE.PsCreateFailMachineMismatch = 4
PS_CREATE_STATE.PsCreateFailExeName = 5
PS_CREATE_STATE.PsCreateSuccess = 6
PS_CREATE_STATE.PsCreateMaximumStates = 7


RTL_GENERIC_COMPARE_RESULTS = v_enum()
RTL_GENERIC_COMPARE_RESULTS.GenericLessThan = 0
RTL_GENERIC_COMPARE_RESULTS.GenericGreaterThan = 1
RTL_GENERIC_COMPARE_RESULTS.GenericEqual = 2


TPM_BOOT_ENTROPY_RESULT_CODE = v_enum()
TPM_BOOT_ENTROPY_RESULT_CODE.TpmBootEntropyStructureUninitialized = 0
TPM_BOOT_ENTROPY_RESULT_CODE.TpmBootEntropyDisabledByPolicy = 1
TPM_BOOT_ENTROPY_RESULT_CODE.TpmBootEntropyNoTpmFound = 2
TPM_BOOT_ENTROPY_RESULT_CODE.TpmBootEntropyTpmError = 3
TPM_BOOT_ENTROPY_RESULT_CODE.TpmBootEntropySuccess = 4


TP_CALLBACK_PRIORITY = v_enum()
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_HIGH = 0
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_NORMAL = 1
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_LOW = 2
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_INVALID = 3


FSINFOCLASS = v_enum()
FSINFOCLASS.FileFsVolumeInformation = 1
FSINFOCLASS.FileFsLabelInformation = 2
FSINFOCLASS.FileFsSizeInformation = 3
FSINFOCLASS.FileFsDeviceInformation = 4
FSINFOCLASS.FileFsAttributeInformation = 5
FSINFOCLASS.FileFsControlInformation = 6
FSINFOCLASS.FileFsFullSizeInformation = 7
FSINFOCLASS.FileFsObjectIdInformation = 8
FSINFOCLASS.FileFsDriverPathInformation = 9
FSINFOCLASS.FileFsVolumeFlagsInformation = 10
FSINFOCLASS.FileFsMaximumInformation = 11


WORKING_SET_TYPE = v_enum()
WORKING_SET_TYPE.WorkingSetTypeUser = 0
WORKING_SET_TYPE.WorkingSetTypeSession = 1
WORKING_SET_TYPE.WorkingSetTypeSystemTypes = 2
WORKING_SET_TYPE.WorkingSetTypeSystemCache = 2
WORKING_SET_TYPE.WorkingSetTypePagedPool = 3
WORKING_SET_TYPE.WorkingSetTypeSystemPtes = 4
WORKING_SET_TYPE.WorkingSetTypeMaximum = 5


POOL_TYPE = v_enum()
POOL_TYPE.NonPagedPool = 0
POOL_TYPE.PagedPool = 1
POOL_TYPE.NonPagedPoolMustSucceed = 2
POOL_TYPE.DontUseThisType = 3
POOL_TYPE.NonPagedPoolCacheAligned = 4
POOL_TYPE.PagedPoolCacheAligned = 5
POOL_TYPE.NonPagedPoolCacheAlignedMustS = 6
POOL_TYPE.MaxPoolType = 7
POOL_TYPE.NonPagedPoolSession = 32
POOL_TYPE.PagedPoolSession = 33
POOL_TYPE.NonPagedPoolMustSucceedSession = 34
POOL_TYPE.DontUseThisTypeSession = 35
POOL_TYPE.NonPagedPoolCacheAlignedSession = 36
POOL_TYPE.PagedPoolCacheAlignedSession = 37
POOL_TYPE.NonPagedPoolCacheAlignedMustSSession = 38


MODE = v_enum()
MODE.KernelMode = 0
MODE.UserMode = 1
MODE.MaximumMode = 2


FS_FILTER_SECTION_SYNC_TYPE = v_enum()
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeOther = 0
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeCreateSection = 1


FILE_OBJECT_EXTENSION_TYPE = v_enum()
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeTransactionParams = 0
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeDeviceObjectHint = 1
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeIosbRange = 2
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeGeneric = 3
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeSfio = 4
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeSymlink = 5
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeOplockKey = 6
FILE_OBJECT_EXTENSION_TYPE.MaxFoExtTypes = 7


IRQ_PRIORITY = v_enum()
IRQ_PRIORITY.IrqPriorityUndefined = 0
IRQ_PRIORITY.IrqPriorityLow = 1
IRQ_PRIORITY.IrqPriorityNormal = 2
IRQ_PRIORITY.IrqPriorityHigh = 3


MI_SYSTEM_VA_TYPE = v_enum()
MI_SYSTEM_VA_TYPE.MiVaUnused = 0
MI_SYSTEM_VA_TYPE.MiVaSessionSpace = 1
MI_SYSTEM_VA_TYPE.MiVaProcessSpace = 2
MI_SYSTEM_VA_TYPE.MiVaBootLoaded = 3
MI_SYSTEM_VA_TYPE.MiVaPfnDatabase = 4
MI_SYSTEM_VA_TYPE.MiVaNonPagedPool = 5
MI_SYSTEM_VA_TYPE.MiVaPagedPool = 6
MI_SYSTEM_VA_TYPE.MiVaSpecialPoolPaged = 7
MI_SYSTEM_VA_TYPE.MiVaSystemCache = 8
MI_SYSTEM_VA_TYPE.MiVaSystemPtes = 9
MI_SYSTEM_VA_TYPE.MiVaHal = 10
MI_SYSTEM_VA_TYPE.MiVaSessionGlobalSpace = 11
MI_SYSTEM_VA_TYPE.MiVaDriverImages = 12
MI_SYSTEM_VA_TYPE.MiVaSpecialPoolNonPaged = 13
MI_SYSTEM_VA_TYPE.MiVaMaximumType = 14


LSA_FOREST_TRUST_RECORD_TYPE = v_enum()
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName = 0
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx = 1
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo = 2
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustRecordTypeLast = 2


MMLISTS = v_enum()
MMLISTS.ZeroedPageList = 0
MMLISTS.FreePageList = 1
MMLISTS.StandbyPageList = 2
MMLISTS.ModifiedPageList = 3
MMLISTS.ModifiedNoWritePageList = 4
MMLISTS.BadPageList = 5
MMLISTS.ActiveAndValid = 6
MMLISTS.TransitionPage = 7


TOKEN_TYPE = v_enum()
TOKEN_TYPE.TokenPrimary = 1
TOKEN_TYPE.TokenImpersonation = 2


HARDWARE_COUNTER_TYPE = v_enum()
HARDWARE_COUNTER_TYPE.PMCCounter = 0
HARDWARE_COUNTER_TYPE.MaxHardwareCounterType = 1


TRANSFER_TYPE = v_enum()
TRANSFER_TYPE.ReadTransfer = 0
TRANSFER_TYPE.WriteTransfer = 1
TRANSFER_TYPE.OtherTransfer = 2


KINTERRUPT_MODE = v_enum()
KINTERRUPT_MODE.LevelSensitive = 0
KINTERRUPT_MODE.Latched = 1


class _unnamed_21437(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemContext = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Type = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.State = POWER_STATE()
        self._pad0018 = v_bytes(size=4)
        self.ShutdownType = v_uint32()
        self._pad0020 = v_bytes(size=4)


class KEXECUTE_OPTIONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteDisable = v_uint8()


class MI_COLOR_BASE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ColorPointer = v_ptr64()
        self.ColorMask = v_uint16()
        self.ColorNode = v_uint16()
        self._pad0010 = v_bytes(size=4)


class _unnamed_21384(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceTextType = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.LocaleId = v_uint32()
        self._pad0010 = v_bytes(size=4)


class IO_PRIORITY_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.ThreadPriority = v_uint32()
        self.PagePriority = v_uint32()
        self.IoPriority = v_uint32()


class IOV_FORCED_PENDING_TRACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Irp = v_ptr64()
        self.Thread = v_ptr64()
        self.StackTrace = vstruct.VArray([ v_ptr64() for i in xrange(62) ])


class SEGMENT_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseAddress = v_ptr64()
        self.TotalNumberOfPtes = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.SizeOfSegment = LARGE_INTEGER()
        self.NonExtendedPtes = v_uint32()
        self.ImageCommitment = v_uint32()
        self.ControlArea = v_ptr64()
        self.Subsection = v_ptr64()
        self.MmSectionFlags = v_ptr64()
        self.MmSubSectionFlags = v_ptr64()


class VOLUME_CACHE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self.NodeByteCode = v_uint16()
        self.UseCount = v_uint32()
        self.DeviceObject = v_ptr64()
        self.VolumeCacheMapLinks = LIST_ENTRY()
        self.Flags = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.DirtyPages = v_uint64()
        self.PagesQueuedToDisk = v_uint32()
        self._pad0038 = v_bytes(size=4)


class SID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.SubAuthorityCount = v_uint8()
        self.IdentifierAuthority = SID_IDENTIFIER_AUTHORITY()
        self.SubAuthority = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class MMPTE_HARDWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint64()


class _unnamed_23507(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReadMemory = DBGKD_READ_MEMORY32()
        self._pad0028 = v_bytes(size=28)


class WHEA_ERROR_PACKET_V2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Version = v_uint32()
        self.Length = v_uint32()
        self.Flags = WHEA_ERROR_PACKET_FLAGS()
        self.ErrorType = v_uint32()
        self.ErrorSeverity = v_uint32()
        self.ErrorSourceId = v_uint32()
        self.ErrorSourceType = v_uint32()
        self.NotifyType = GUID()
        self.Context = v_uint64()
        self.DataFormat = v_uint32()
        self.Reserved1 = v_uint32()
        self.DataOffset = v_uint32()
        self.DataLength = v_uint32()
        self.PshedDataOffset = v_uint32()
        self.PshedDataLength = v_uint32()


class GROUP_AFFINITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint64()
        self.Group = v_uint16()
        self.Reserved = vstruct.VArray([ v_uint16() for i in xrange(3) ])


class UMS_CONTROL_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UmsContext = v_ptr64()
        self.CompletionListEntry = v_ptr64()
        self.CompletionListEvent = v_ptr64()
        self.ServiceSequenceNumber = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.UmsQueue = KQUEUE()
        self.QueueEntry = LIST_ENTRY()
        self.YieldingUmsContext = v_ptr64()
        self.YieldingParam = v_ptr64()
        self.UmsTeb = v_ptr64()
        self.PrimaryFlags = v_uint32()
        self._pad0090 = v_bytes(size=4)
        self.TebSelector = v_uint16()
        self._pad0098 = v_bytes(size=6)


class VI_VERIFIER_ISSUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IssueType = v_uint64()
        self.Address = v_ptr64()
        self.Parameters = vstruct.VArray([ v_uint64() for i in xrange(2) ])


class DBGKD_LOAD_SYMBOLS32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PathNameLength = v_uint32()
        self.BaseOfDll = v_uint32()
        self.ProcessId = v_uint32()
        self.CheckSum = v_uint32()
        self.SizeOfImage = v_uint32()
        self.UnloadSymbols = v_uint8()
        self._pad0018 = v_bytes(size=3)


class _unnamed_24120(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24174()


class CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DosPath = UNICODE_STRING()
        self.Handle = v_ptr64()


class DBGKD_GET_INTERNAL_BREAKPOINT32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakpointAddress = v_uint32()
        self.Flags = v_uint32()
        self.Calls = v_uint32()
        self.MaxCallsPerPeriod = v_uint32()
        self.MinInstructions = v_uint32()
        self.MaxInstructions = v_uint32()
        self.TotalInstructions = v_uint32()


class DBGKD_MANIPULATE_STATE32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ApiNumber = v_uint32()
        self.ProcessorLevel = v_uint16()
        self.Processor = v_uint16()
        self.ReturnStatus = v_uint32()
        self.u = _unnamed_23507()


class _unnamed_21448(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedResources = v_ptr64()
        self.AllocatedResourcesTranslated = v_ptr64()


class SEP_TOKEN_PRIVILEGES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Present = v_uint64()
        self.Enabled = v_uint64()
        self.EnabledByDefault = v_uint64()


class KALPC_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SectionObject = v_ptr64()
        self.Size = v_uint64()
        self.HandleTable = v_ptr64()
        self.SectionHandle = v_ptr64()
        self.OwnerProcess = v_ptr64()
        self.OwnerPort = v_ptr64()
        self.u1 = _unnamed_24120()
        self.NumberOfRegions = v_uint32()
        self.RegionListHead = LIST_ENTRY()


class KREQUEST_PACKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CurrentPacket = vstruct.VArray([ v_ptr64() for i in xrange(3) ])
        self.WorkerRoutine = v_ptr64()


class PERFINFO_GROUPMASK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Masks = vstruct.VArray([ v_uint32() for i in xrange(8) ])


class HARDWARE_PTE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint64()


class ETW_PERF_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalActiveSessions = v_uint32()
        self.TotalBufferMemoryNonPagedPool = v_uint32()
        self.TotalBufferMemoryPagedPool = v_uint32()
        self.TotalGuidsEnabled = v_uint32()
        self.TotalGuidsNotEnabled = v_uint32()
        self.TotalGuidsPreEnabled = v_uint32()


class HANDLE_TABLE_ENTRY_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AuditMask = v_uint32()


class DBGKD_WRITE_MEMORY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TargetBaseAddress = v_uint32()
        self.TransferCount = v_uint32()
        self.ActualBytesWritten = v_uint32()


class SINGLE_LIST_ENTRY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_uint32()


class CACHED_KSTACK_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SListHead = SLIST_HEADER()
        self.MinimumFree = v_uint32()
        self.Misses = v_uint32()
        self.MissesLast = v_uint32()
        self.Pad0 = v_uint32()


class _unnamed_22378(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags = v_uint64()


class _unnamed_22379(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags3 = v_uint64()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SectionOffset = v_uint32()
        self.SectionLength = v_uint32()
        self.Revision = WHEA_REVISION()
        self.ValidBits = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS()
        self.Reserved = v_uint8()
        self.Flags = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS()
        self.SectionType = GUID()
        self.FRUId = GUID()
        self.SectionSeverity = v_uint32()
        self.FRUText = vstruct.VArray([ v_uint8() for i in xrange(20) ])


class AUX_ACCESS_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegesUsed = v_ptr64()
        self.GenericMapping = GENERIC_MAPPING()
        self.AccessesToAudit = v_uint32()
        self.MaximumAuditMask = v_uint32()
        self.TransactionId = GUID()
        self.NewSecurityDescriptor = v_ptr64()
        self.ExistingSecurityDescriptor = v_ptr64()
        self.ParentSecurityDescriptor = v_ptr64()
        self.DeRefSecurityDescriptor = v_ptr64()
        self.SDLock = v_ptr64()
        self.AccessReasons = ACCESS_REASONS()


class EX_WORK_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkerQueue = KQUEUE()
        self.DynamicThreadCount = v_uint32()
        self.WorkItemsProcessed = v_uint32()
        self.WorkItemsProcessedLastPass = v_uint32()
        self.QueueDepthLastPass = v_uint32()
        self.Info = EX_QUEUE_WORKER_INFO()
        self._pad0058 = v_bytes(size=4)


class MMWSLENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint64()


class PNP_DEVICE_COMPLETION_REQUEST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.DeviceNode = v_ptr64()
        self.Context = v_ptr64()
        self.CompletionState = v_uint32()
        self.IrpPended = v_uint32()
        self.Status = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.Information = v_ptr64()
        self.WorkItem = WORK_QUEUE_ITEM()
        self.FailingDriver = v_ptr64()
        self.ReferenceCount = v_uint32()
        self._pad0068 = v_bytes(size=4)


class _unnamed_22375(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Balance = v_uint64()


class PS_CPU_QUOTA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.SessionId = v_uint32()
        self.CpuShareWeight = v_uint32()
        self.CapturedWeightData = PSP_CPU_SHARE_CAPTURED_WEIGHT_DATA()
        self.DuplicateInputMarker = v_uint32()
        self._pad0040 = v_bytes(size=28)
        self.CycleCredit = v_uint64()
        self.BlockCurrentGeneration = v_uint32()
        self.CpuCyclePercent = v_uint32()
        self.CyclesFinishedForCurrentGeneration = v_uint8()
        self._pad0080 = v_bytes(size=47)
        self.Cpu = vstruct.VArray([ PS_PER_CPU_QUOTA_CACHE_AWARE() for i in xrange(256) ])


class _unnamed_29494(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mbr = _unnamed_29540()
        self._pad0010 = v_bytes(size=8)


class CM_PARTIAL_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.PartialDescriptors = vstruct.VArray([ CM_PARTIAL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class DBGKD_RESTORE_BREAKPOINT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakPointHandle = v_uint32()


class IMAGE_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PageHashes = v_ptr64()


class DEVICE_CAPABILITIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.DeviceD1 = v_uint32()
        self.Address = v_uint32()
        self.UINumber = v_uint32()
        self.DeviceState = vstruct.VArray([ DEVICE_POWER_STATE() for i in xrange(7) ])
        self.SystemWake = v_uint32()
        self.DeviceWake = v_uint32()
        self.D1Latency = v_uint32()
        self.D2Latency = v_uint32()
        self.D3Latency = v_uint32()


class IOP_FILE_OBJECT_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FoExtFlags = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FoExtPerTypeExtension = vstruct.VArray([ v_ptr64() for i in xrange(7) ])
        self.FoIoPriorityHint = v_uint32()
        self._pad0048 = v_bytes(size=4)


class VACB_LEVEL_REFERENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reference = v_uint32()
        self.SpecialReference = v_uint32()


class _unnamed_26924(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClassGuid = GUID()
        self.SymbolicLinkName = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0014 = v_bytes(size=2)


class _unnamed_26927(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceIds = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class TOKEN_AUDIT_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PerUserPolicy = vstruct.VArray([ v_uint8() for i in xrange(27) ])


class PCW_INSTANCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class DUAL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Map = v_ptr64()
        self.SmallDir = v_ptr64()
        self.Guard = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.FreeDisplay = vstruct.VArray([ FREE_DISPLAY() for i in xrange(24) ])
        self.FreeSummary = v_uint32()
        self._pad0268 = v_bytes(size=4)
        self.FreeBins = LIST_ENTRY()


class CALLBACK_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class RTL_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint64()
        self.End = v_uint64()
        self.UserData = v_ptr64()
        self.Owner = v_ptr64()
        self.Attributes = v_uint8()
        self.Flags = v_uint8()
        self._pad0028 = v_bytes(size=6)


class CONFIGURATION_COMPONENT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parent = v_ptr64()
        self.Child = v_ptr64()
        self.Sibling = v_ptr64()
        self.ComponentEntry = CONFIGURATION_COMPONENT()
        self.ConfigurationData = v_ptr64()


class _unnamed_28582(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsUSHORT = v_uint16()


class EXCEPTION_RECORD64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_uint64()
        self.ExceptionAddress = v_uint64()
        self.NumberParameters = v_uint32()
        self.unusedAlignment = v_uint32()
        self.ExceptionInformation = vstruct.VArray([ v_uint64() for i in xrange(15) ])


class KPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.ProfileListHead = LIST_ENTRY()
        self.DirectoryTableBase = v_uint64()
        self.ThreadListHead = LIST_ENTRY()
        self.ProcessLock = v_uint64()
        self.Affinity = KAFFINITY_EX()
        self.ReadyListHead = LIST_ENTRY()
        self.SwapListEntry = SINGLE_LIST_ENTRY()
        self.ActiveProcessors = KAFFINITY_EX()
        self.AutoAlignment = v_uint32()
        self.BasePriority = v_uint8()
        self.QuantumReset = v_uint8()
        self.Visited = v_uint8()
        self.Unused3 = v_uint8()
        self.ThreadSeed = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.IdealNode = vstruct.VArray([ v_uint16() for i in xrange(4) ])
        self.IdealGlobalNode = v_uint16()
        self.Flags = KEXECUTE_OPTIONS()
        self.Unused1 = v_uint8()
        self.Unused2 = v_uint32()
        self.Unused4 = v_uint32()
        self.StackCount = KSTACK_COUNT()
        self.ProcessListEntry = LIST_ENTRY()
        self.CycleTime = v_uint64()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.InstrumentationCallback = v_ptr64()
        self.LdtSystemDescriptor = KGDTENTRY64()
        self.LdtBaseAddress = v_ptr64()
        self.LdtProcessLock = KGUARDED_MUTEX()
        self.LdtFreeSelectorHint = v_uint16()
        self.LdtTableLength = v_uint16()
        self._pad0160 = v_bytes(size=4)


class ALPC_COMMUNICATION_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ConnectionPort = v_ptr64()
        self.ServerCommunicationPort = v_ptr64()
        self.ClientCommunicationPort = v_ptr64()
        self.CommunicationList = LIST_ENTRY()
        self.HandleTable = ALPC_HANDLE_TABLE()


class DEVICE_OBJECT_POWER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleCount = v_uint32()
        self.BusyCount = v_uint32()
        self.BusyReference = v_uint32()
        self.TotalBusyCount = v_uint32()
        self.ConservationIdleTime = v_uint32()
        self.PerformanceIdleTime = v_uint32()
        self.DeviceObject = v_ptr64()
        self.IdleList = LIST_ENTRY()
        self.IdleType = v_uint32()
        self.IdleState = v_uint32()
        self.CurrentState = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.Volume = LIST_ENTRY()
        self.Specific = _unnamed_23077()


class _unnamed_24379(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.QueueType = v_uint32()


class MMPTE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint64()


class COUNTER_READING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.Index = v_uint32()
        self.Start = v_uint64()
        self.Total = v_uint64()


class HEAP_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint64()
        self.TagIndex = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self.TagName = vstruct.VArray([ v_uint16() for i in xrange(24) ])
        self._pad0048 = v_bytes(size=4)


class _unnamed_29211(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Head = v_uint64()


class ALPC_COMPLETION_LIST_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_27537()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Primary = v_uint32()


class TP_CALLBACK_ENVIRON_V3(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Pool = v_ptr64()
        self.CleanupGroup = v_ptr64()
        self.CleanupGroupCancelCallback = v_ptr64()
        self.RaceDll = v_ptr64()
        self.ActivationContext = v_ptr64()
        self.FinalizationCallback = v_ptr64()
        self.u = _unnamed_18815()
        self.CallbackPriority = v_uint32()
        self.Size = v_uint32()
        self._pad0048 = v_bytes(size=4)


class _unnamed_24051(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.DataInfoOffset = v_uint16()


class MEMORY_ALLOCATION_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.MemoryType = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.BasePage = v_uint64()
        self.PageCount = v_uint64()


class MMPTE_TRANSITION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint64()


class WHEA_ERROR_PACKET_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousError = v_uint32()


class ARM_DBGKD_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Continue = v_uint32()
        self.CurrentSymbolStart = v_uint32()
        self.CurrentSymbolEnd = v_uint32()


class ALPC_PROCESS_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = EX_PUSH_LOCK()
        self.ViewListHead = LIST_ENTRY()
        self.PagedPoolQuotaCache = v_uint64()


class DIAGNOSTIC_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CallerType = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Process = v_ptr64()
        self.ServiceTag = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.ReasonSize = v_uint64()


class OBJECT_HANDLE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleAttributes = v_uint32()
        self.GrantedAccess = v_uint32()


class KSPIN_LOCK_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Lock = v_ptr64()


class HEAP_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = _unnamed_23833()


class XSTATE_CONFIGURATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnabledFeatures = v_uint64()
        self.Size = v_uint32()
        self.OptimizedSave = v_uint32()
        self.Features = vstruct.VArray([ XSTATE_FEATURE() for i in xrange(64) ])


class PS_CLIENT_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImpersonationData = v_uint64()


class RTL_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = RTL_BALANCED_LINKS()
        self.OrderedPointer = v_ptr64()
        self.WhichOrderedElement = v_uint32()
        self.NumberGenericTableElements = v_uint32()
        self.DepthOfTree = v_uint32()
        self._pad0038 = v_bytes(size=4)
        self.RestartKey = v_ptr64()
        self.DeleteCount = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.CompareRoutine = v_ptr64()
        self.AllocateRoutine = v_ptr64()
        self.FreeRoutine = v_ptr64()
        self.TableContext = v_ptr64()


class _unnamed_26621(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Generic = _unnamed_27286()
        self._pad0010 = v_bytes(size=4)


class _unnamed_27306(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint32()
        self.Length = v_uint32()
        self.Reserved = v_uint32()


class PNP_ASSIGN_RESOURCES_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IncludeFailedDevices = v_uint32()
        self.DeviceCount = v_uint32()
        self.DeviceList = vstruct.VArray([ v_ptr64() for i in xrange(1) ])


class _unnamed_27302(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Channel = v_uint32()
        self.Port = v_uint32()
        self.Reserved1 = v_uint32()


class MAPPED_FILE_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlArea = v_ptr64()
        self.TotalNumberOfPtes = v_uint32()
        self.SegmentFlags = SEGMENT_FLAGS()
        self.NumberOfCommittedPages = v_uint64()
        self.SizeOfSegment = v_uint64()
        self.ExtendInfo = v_ptr64()
        self.SegmentLock = EX_PUSH_LOCK()


class _unnamed_26712(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length64 = v_uint32()
        self.Alignment64 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class DBGKD_GET_INTERNAL_BREAKPOINT64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakpointAddress = v_uint64()
        self.Flags = v_uint32()
        self.Calls = v_uint32()
        self.MaxCallsPerPeriod = v_uint32()
        self.MinInstructions = v_uint32()
        self.MaxInstructions = v_uint32()
        self.TotalInstructions = v_uint32()


class OWNER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerThread = v_uint64()
        self.IoPriorityBoosted = v_uint32()
        self._pad0010 = v_bytes(size=4)


class ETW_BUFFER_HANDLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TraceBuffer = v_ptr64()
        self.BufferFastRef = v_ptr64()


class DEVOBJ_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DeviceObject = v_ptr64()
        self.PowerFlags = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Dope = v_ptr64()
        self.ExtensionFlags = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.DeviceNode = v_ptr64()
        self.AttachedTo = v_ptr64()
        self.StartIoCount = v_uint32()
        self.StartIoKey = v_uint32()
        self.StartIoFlags = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.Vpb = v_ptr64()
        self.DependentList = LIST_ENTRY()
        self.ProviderList = LIST_ENTRY()


class HEAP_LOCAL_SEGMENT_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ARBITER_ALLOCATION_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint64()
        self.End = v_uint64()
        self.CurrentMinimum = v_uint64()
        self.CurrentMaximum = v_uint64()
        self.Entry = v_ptr64()
        self.CurrentAlternative = v_ptr64()
        self.AlternativeCount = v_uint32()
        self._pad0038 = v_bytes(size=4)
        self.Alternatives = v_ptr64()
        self.Flags = v_uint16()
        self.RangeAttributes = v_uint8()
        self.RangeAvailableAttributes = v_uint8()
        self._pad0048 = v_bytes(size=4)
        self.WorkSpace = v_uint64()


class BLOB_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ResourceId = v_uint32()
        self.PoolTag = v_uint32()
        self.Flags = v_uint32()
        self.CreatedObjects = v_uint32()
        self.DeletedObjects = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.DeleteProcedure = v_ptr64()
        self.DestroyProcedure = v_ptr64()
        self.UsualSize = v_uint64()
        self.LookasideIndex = v_uint32()
        self._pad0038 = v_bytes(size=4)


class DBGKD_SET_INTERNAL_BREAKPOINT64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakpointAddress = v_uint64()
        self.Flags = v_uint32()
        self._pad0010 = v_bytes(size=4)


class OPEN_PACKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.FileObject = v_ptr64()
        self.FinalStatus = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Information = v_uint64()
        self.ParseCheck = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.RelatedFileObject = v_ptr64()
        self.OriginalAttributes = v_ptr64()
        self.AllocationSize = LARGE_INTEGER()
        self.CreateOptions = v_uint32()
        self.FileAttributes = v_uint16()
        self.ShareAccess = v_uint16()
        self.EaBuffer = v_ptr64()
        self.EaLength = v_uint32()
        self.Options = v_uint32()
        self.Disposition = v_uint32()
        self._pad0060 = v_bytes(size=4)
        self.BasicInformation = v_ptr64()
        self.NetworkInformation = v_ptr64()
        self.CreateFileType = v_uint32()
        self._pad0078 = v_bytes(size=4)
        self.MailslotOrPipeParameters = v_ptr64()
        self.Override = v_uint8()
        self.QueryOnly = v_uint8()
        self.DeleteOnly = v_uint8()
        self.FullAttributes = v_uint8()
        self._pad0088 = v_bytes(size=4)
        self.LocalFileObject = v_ptr64()
        self.InternalFlags = v_uint32()
        self._pad0098 = v_bytes(size=4)
        self.DriverCreateContext = IO_DRIVER_CREATE_CONTEXT()


class HANDLE_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr64()
        self.GrantedAccess = v_uint32()
        self._pad0010 = v_bytes(size=4)


class HEAP_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalMemoryReserved = v_uint64()
        self.TotalMemoryCommitted = v_uint64()
        self.TotalMemoryLargeUCR = v_uint64()
        self.TotalSizeInVirtualBlocks = v_uint64()
        self.TotalSegments = v_uint32()
        self.TotalUCRs = v_uint32()
        self.CommittOps = v_uint32()
        self.DeCommitOps = v_uint32()
        self.LockAcquires = v_uint32()
        self.LockCollisions = v_uint32()
        self.CommitRate = v_uint32()
        self.DecommittRate = v_uint32()
        self.CommitFailures = v_uint32()
        self.InBlockCommitFailures = v_uint32()
        self.CompactHeapCalls = v_uint32()
        self.CompactedUCRs = v_uint32()
        self.AllocAndFreeOps = v_uint32()
        self.InBlockDeccommits = v_uint32()
        self.InBlockDeccomitSize = v_uint64()
        self.HighWatermarkSize = v_uint64()
        self.LastPolledSize = v_uint64()


class WHEA_MEMORY_ERROR_SECTION_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ErrorStatus = v_uint64()


class BLOB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ResourceList = LIST_ENTRY()
        self.u1 = _unnamed_24097()
        self.ResourceId = v_uint8()
        self.CachedReferences = v_uint16()
        self.ReferenceCount = v_uint32()
        self.Lock = EX_PUSH_LOCK()


class WORK_QUEUE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkQueueLinks = LIST_ENTRY()
        self.Parameters = _unnamed_23696()
        self.Function = v_uint8()
        self._pad0020 = v_bytes(size=7)


class PI_BUS_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.NumberCSNs = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.ReadDataPort = v_ptr64()
        self.DataPortMapped = v_uint8()
        self._pad0018 = v_bytes(size=7)
        self.AddressPort = v_ptr64()
        self.AddrPortMapped = v_uint8()
        self._pad0028 = v_bytes(size=7)
        self.CommandPort = v_ptr64()
        self.CmdPortMapped = v_uint8()
        self._pad0034 = v_bytes(size=3)
        self.NextSlotNumber = v_uint32()
        self.DeviceList = SINGLE_LIST_ENTRY()
        self.CardList = SINGLE_LIST_ENTRY()
        self.PhysicalBusDevice = v_ptr64()
        self.FunctionalBusDevice = v_ptr64()
        self.AttachedDevice = v_ptr64()
        self.BusNumber = v_uint32()
        self.SystemPowerState = v_uint32()
        self.DevicePowerState = v_uint32()
        self._pad0070 = v_bytes(size=4)


class MAILSLOT_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MailslotQuota = v_uint32()
        self.MaximumMessageSize = v_uint32()
        self.ReadTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0018 = v_bytes(size=7)


class FS_FILTER_CALLBACK_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbackData = v_uint32()
        self.Operation = v_uint8()
        self.Reserved = v_uint8()
        self._pad0008 = v_bytes(size=2)
        self.DeviceObject = v_ptr64()
        self.FileObject = v_ptr64()
        self.Parameters = FS_FILTER_PARAMETERS()


class REQUEST_MAILBOX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.RequestSummary = v_uint64()
        self.RequestPacket = KREQUEST_PACKET()
        self._pad0040 = v_bytes(size=16)


class PPM_IDLE_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DomainMembers = KAFFINITY_EX()
        self.IdleCheck = v_ptr64()
        self.IdleHandler = v_ptr64()
        self.HvConfig = v_uint64()
        self.Context = v_ptr64()
        self.Latency = v_uint32()
        self.Power = v_uint32()
        self.TimeCheck = v_uint32()
        self.StateFlags = v_uint32()
        self.PromotePercent = v_uint8()
        self.DemotePercent = v_uint8()
        self.PromotePercentBase = v_uint8()
        self.DemotePercentBase = v_uint8()
        self.StateType = v_uint8()
        self._pad0060 = v_bytes(size=3)


class XSTATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint64()
        self.Length = v_uint32()
        self.Reserved1 = v_uint32()
        self.Area = v_ptr64()
        self.Buffer = v_ptr64()


class ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OperationID = LUID()
        self.SecurityEvaluated = v_uint8()
        self.GenerateAudit = v_uint8()
        self.GenerateOnClose = v_uint8()
        self.PrivilegesAllocated = v_uint8()
        self.Flags = v_uint32()
        self.RemainingDesiredAccess = v_uint32()
        self.PreviouslyGrantedAccess = v_uint32()
        self.OriginalDesiredAccess = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.SubjectSecurityContext = SECURITY_SUBJECT_CONTEXT()
        self.SecurityDescriptor = v_ptr64()
        self.AuxData = v_ptr64()
        self.Privileges = _unnamed_20937()
        self.AuditPrivileges = v_uint8()
        self._pad0080 = v_bytes(size=3)
        self.ObjectName = UNICODE_STRING()
        self.ObjectTypeName = UNICODE_STRING()


class DBGKD_SWITCH_PARTITION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Partition = v_uint32()


class TP_CALLBACK_INSTANCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class AMD64_DBGKD_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TraceFlag = v_uint32()
        self.Dr7 = v_uint64()
        self.CurrentSymbolStart = v_uint64()
        self.CurrentSymbolEnd = v_uint64()


class PROC_IDLE_ACCOUNTING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StateCount = v_uint32()
        self.TotalTransitions = v_uint32()
        self.ResetCount = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.StartTime = v_uint64()
        self.BucketLimits = vstruct.VArray([ v_uint64() for i in xrange(16) ])
        self.State = vstruct.VArray([ PROC_IDLE_STATE_ACCOUNTING() for i in xrange(1) ])


class _unnamed_19929(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint64()
        self.HeaderType = v_uint64()


class GDI_TEB_BATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.HDC = v_uint64()
        self.Buffer = vstruct.VArray([ v_uint32() for i in xrange(310) ])


class DBGKD_SET_SPECIAL_CALL32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SpecialCall = v_uint32()


class SYSTEM_POWER_LEVEL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Enable = v_uint8()
        self.Spare = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.BatteryLevel = v_uint32()
        self.PowerPolicy = POWER_ACTION_POLICY()
        self.MinSystemState = v_uint32()


class DBGKD_SET_SPECIAL_CALL64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SpecialCall = v_uint64()


class DBGKM_EXCEPTION32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionRecord = EXCEPTION_RECORD32()
        self.FirstChance = v_uint32()


class PAGEFAULT_HISTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_27001(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsUCHAR = v_uint8()


class ECP_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Flags = v_uint32()
        self.EcpList = LIST_ENTRY()


class _unnamed_21379(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdType = v_uint32()


class PEB32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InheritedAddressSpace = v_uint8()
        self.ReadImageFileExecOptions = v_uint8()
        self.BeingDebugged = v_uint8()
        self.BitField = v_uint8()
        self.Mutant = v_uint32()
        self.ImageBaseAddress = v_uint32()
        self.Ldr = v_uint32()
        self.ProcessParameters = v_uint32()
        self.SubSystemData = v_uint32()
        self.ProcessHeap = v_uint32()
        self.FastPebLock = v_uint32()
        self.AtlThunkSListPtr = v_uint32()
        self.IFEOKey = v_uint32()
        self.CrossProcessFlags = v_uint32()
        self.KernelCallbackTable = v_uint32()
        self.SystemReserved = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.AtlThunkSListPtr32 = v_uint32()
        self.ApiSetMap = v_uint32()
        self.TlsExpansionCounter = v_uint32()
        self.TlsBitmap = v_uint32()
        self.TlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ReadOnlySharedMemoryBase = v_uint32()
        self.HotpatchInformation = v_uint32()
        self.ReadOnlyStaticServerData = v_uint32()
        self.AnsiCodePageData = v_uint32()
        self.OemCodePageData = v_uint32()
        self.UnicodeCaseTableData = v_uint32()
        self.NumberOfProcessors = v_uint32()
        self.NtGlobalFlag = v_uint32()
        self._pad0070 = v_bytes(size=4)
        self.CriticalSectionTimeout = LARGE_INTEGER()
        self.HeapSegmentReserve = v_uint32()
        self.HeapSegmentCommit = v_uint32()
        self.HeapDeCommitTotalFreeThreshold = v_uint32()
        self.HeapDeCommitFreeBlockThreshold = v_uint32()
        self.NumberOfHeaps = v_uint32()
        self.MaximumNumberOfHeaps = v_uint32()
        self.ProcessHeaps = v_uint32()
        self.GdiSharedHandleTable = v_uint32()
        self.ProcessStarterHelper = v_uint32()
        self.GdiDCAttributeList = v_uint32()
        self.LoaderLock = v_uint32()
        self.OSMajorVersion = v_uint32()
        self.OSMinorVersion = v_uint32()
        self.OSBuildNumber = v_uint16()
        self.OSCSDVersion = v_uint16()
        self.OSPlatformId = v_uint32()
        self.ImageSubsystem = v_uint32()
        self.ImageSubsystemMajorVersion = v_uint32()
        self.ImageSubsystemMinorVersion = v_uint32()
        self.ActiveProcessAffinityMask = v_uint32()
        self.GdiHandleBuffer = vstruct.VArray([ v_uint32() for i in xrange(34) ])
        self.PostProcessInitRoutine = v_uint32()
        self.TlsExpansionBitmap = v_uint32()
        self.TlsExpansionBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(32) ])
        self.SessionId = v_uint32()
        self.AppCompatFlags = ULARGE_INTEGER()
        self.AppCompatFlagsUser = ULARGE_INTEGER()
        self.pShimData = v_uint32()
        self.AppCompatInfo = v_uint32()
        self.CSDVersion = STRING32()
        self.ActivationContextData = v_uint32()
        self.ProcessAssemblyStorageMap = v_uint32()
        self.SystemDefaultActivationContextData = v_uint32()
        self.SystemAssemblyStorageMap = v_uint32()
        self.MinimumStackCommit = v_uint32()
        self.FlsCallback = v_uint32()
        self.FlsListHead = LIST_ENTRY32()
        self.FlsBitmap = v_uint32()
        self.FlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.FlsHighIndex = v_uint32()
        self.WerRegistrationData = v_uint32()
        self.WerShipAssertPtr = v_uint32()
        self.pContextData = v_uint32()
        self.pImageHeaderHash = v_uint32()
        self.TracingFlags = v_uint32()
        self._pad0248 = v_bytes(size=4)


class NT_TIB64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_uint64()
        self.StackBase = v_uint64()
        self.StackLimit = v_uint64()
        self.SubSystemTib = v_uint64()
        self.FiberData = v_uint64()
        self.ArbitraryUserPointer = v_uint64()
        self.Self = v_uint64()


class SECTION_OBJECT_POINTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSectionObject = v_ptr64()
        self.SharedCacheMap = v_ptr64()
        self.ImageSectionObject = v_ptr64()


class MDL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Size = v_uint16()
        self.MdlFlags = v_uint16()
        self._pad0010 = v_bytes(size=4)
        self.Process = v_ptr64()
        self.MappedSystemVa = v_ptr64()
        self.StartVa = v_ptr64()
        self.ByteCount = v_uint32()
        self.ByteOffset = v_uint32()


class _unnamed_21370(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint8()


class KTRAP_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P1Home = v_uint64()
        self.P2Home = v_uint64()
        self.P3Home = v_uint64()
        self.P4Home = v_uint64()
        self.P5 = v_uint64()
        self.PreviousMode = v_uint8()
        self.PreviousIrql = v_uint8()
        self.FaultIndicator = v_uint8()
        self.ExceptionActive = v_uint8()
        self.MxCsr = v_uint32()
        self.Rax = v_uint64()
        self.Rcx = v_uint64()
        self.Rdx = v_uint64()
        self.R8 = v_uint64()
        self.R9 = v_uint64()
        self.R10 = v_uint64()
        self.R11 = v_uint64()
        self.GsBase = v_uint64()
        self.Xmm0 = M128A()
        self.Xmm1 = M128A()
        self.Xmm2 = M128A()
        self.Xmm3 = M128A()
        self.Xmm4 = M128A()
        self.Xmm5 = M128A()
        self.FaultAddress = v_uint64()
        self.Dr0 = v_uint64()
        self.Dr1 = v_uint64()
        self.Dr2 = v_uint64()
        self.Dr3 = v_uint64()
        self.Dr6 = v_uint64()
        self.Dr7 = v_uint64()
        self.DebugControl = v_uint64()
        self.LastBranchToRip = v_uint64()
        self.LastBranchFromRip = v_uint64()
        self.LastExceptionToRip = v_uint64()
        self.LastExceptionFromRip = v_uint64()
        self.SegDs = v_uint16()
        self.SegEs = v_uint16()
        self.SegFs = v_uint16()
        self.SegGs = v_uint16()
        self.TrapFrame = v_uint64()
        self.Rbx = v_uint64()
        self.Rdi = v_uint64()
        self.Rsi = v_uint64()
        self.Rbp = v_uint64()
        self.ErrorCode = v_uint64()
        self.Rip = v_uint64()
        self.SegCs = v_uint16()
        self.Fill0 = v_uint8()
        self.Logging = v_uint8()
        self.Fill1 = vstruct.VArray([ v_uint16() for i in xrange(2) ])
        self.EFlags = v_uint32()
        self.Fill2 = v_uint32()
        self.Rsp = v_uint64()
        self.SegSs = v_uint16()
        self.Fill3 = v_uint16()
        self.CodePatchCycle = v_uint32()


class CM_INDEX_HINT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.HashKey = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class PRIVATE_CACHE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self._pad0004 = v_bytes(size=2)
        self.ReadAheadMask = v_uint32()
        self.FileObject = v_ptr64()
        self.FileOffset1 = LARGE_INTEGER()
        self.BeyondLastByte1 = LARGE_INTEGER()
        self.FileOffset2 = LARGE_INTEGER()
        self.BeyondLastByte2 = LARGE_INTEGER()
        self.SequentialReadCount = v_uint32()
        self.ReadAheadLength = v_uint32()
        self.ReadAheadOffset = LARGE_INTEGER()
        self.ReadAheadBeyondLastByte = LARGE_INTEGER()
        self.ReadAheadSpinLock = v_uint64()
        self.PrivateLinks = LIST_ENTRY()
        self.ReadAheadWorkItem = v_ptr64()


class MMPTE_SOFTWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint64()


class _unnamed_21275(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Srb = v_ptr64()


class IO_TIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.TimerFlag = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.TimerList = LIST_ENTRY()
        self.TimerRoutine = v_ptr64()
        self.Context = v_ptr64()
        self.DeviceObject = v_ptr64()


class MM_STORE_KEY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.KeyLow = v_uint64()


class WHEA_REVISION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinorRevision = v_uint8()
        self.MajorRevision = v_uint8()


class _unnamed_25432(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = MMSECURE_FLAGS()
        self._pad0008 = v_bytes(size=4)


class _unnamed_21118(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr64()
        self.Options = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self._pad0018 = v_bytes(size=4)
        self.Parameters = v_ptr64()


class MM_SESSION_SPACE_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Initialized = v_uint32()


class EVENT_FILTER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint16()
        self.Version = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(5) ])
        self.InstanceId = v_uint64()
        self.Size = v_uint32()
        self.NextOffset = v_uint32()


class _unnamed_18815(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()


class PROC_IDLE_SNAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Time = v_uint64()
        self.Idle = v_uint64()


class _unnamed_28620(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MissedEtwRegistration = v_uint32()


class RTL_DYNAMIC_HASH_TABLE_ENUMERATOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashEntry = RTL_DYNAMIC_HASH_TABLE_ENTRY()
        self.ChainHead = v_ptr64()
        self.BucketIndex = v_uint32()
        self._pad0028 = v_bytes(size=4)


class SECURITY_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.Sbz1 = v_uint8()
        self.Control = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Owner = v_ptr64()
        self.Group = v_ptr64()
        self.Sacl = v_ptr64()
        self.Dacl = v_ptr64()


class _unnamed_22477(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mdl = MDL()
        self.Page = vstruct.VArray([ v_uint64() for i in xrange(1) ])


class PCW_PROCESSOR_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleTime = v_uint64()
        self.AvailableTime = v_uint64()
        self.UserTime = v_uint64()
        self.KernelTime = v_uint64()
        self.Interrupts = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.DpcTime = v_uint64()
        self.InterruptTime = v_uint64()
        self.DpcCount = v_uint32()
        self.DpcRate = v_uint32()
        self.C1Time = v_uint64()
        self.C2Time = v_uint64()
        self.C3Time = v_uint64()
        self.C1Transitions = v_uint64()
        self.C2Transitions = v_uint64()
        self.C3Transitions = v_uint64()
        self.ParkingStatus = v_uint32()
        self.CurrentFrequency = v_uint32()
        self.PercentMaxFrequency = v_uint32()
        self.StateFlags = v_uint32()


class OBJECT_TYPE_INITIALIZER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.ObjectTypeFlags = v_uint8()
        self._pad0004 = v_bytes(size=1)
        self.ObjectTypeCode = v_uint32()
        self.InvalidAttributes = v_uint32()
        self.GenericMapping = GENERIC_MAPPING()
        self.ValidAccessMask = v_uint32()
        self.RetainAccess = v_uint32()
        self.PoolType = v_uint32()
        self.DefaultPagedPoolCharge = v_uint32()
        self.DefaultNonPagedPoolCharge = v_uint32()
        self.DumpProcedure = v_ptr64()
        self.OpenProcedure = v_ptr64()
        self.CloseProcedure = v_ptr64()
        self.DeleteProcedure = v_ptr64()
        self.ParseProcedure = v_ptr64()
        self.SecurityProcedure = v_ptr64()
        self.QueryNameProcedure = v_ptr64()
        self.OkayToCloseProcedure = v_ptr64()


class TP_DIRECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callback = v_ptr64()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()
        self._pad0010 = v_bytes(size=3)


class XSTATE_SAVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Prev = v_ptr64()
        self.Thread = v_ptr64()
        self.Level = v_uint8()
        self._pad0018 = v_bytes(size=7)
        self.XStateContext = XSTATE_CONTEXT()


class PTE_TRACKER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.Mdl = v_ptr64()
        self.Count = v_uint64()
        self.SystemVa = v_ptr64()
        self.StartVa = v_ptr64()
        self.Offset = v_uint32()
        self.Length = v_uint32()
        self.Page = v_uint64()
        self.IoMapping = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.CallingAddress = v_ptr64()
        self.CallersCaller = v_ptr64()


class HEAP_ENTRY_EXTRA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatorBackTraceIndex = v_uint16()
        self.TagIndex = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Settable = v_uint64()


class POP_DEVICE_SYS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IrpMinor = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.SystemState = v_uint32()
        self.SpinLock = v_uint64()
        self.Thread = v_ptr64()
        self.AbortEvent = v_ptr64()
        self.ReadySemaphore = v_ptr64()
        self.FinishedSemaphore = v_ptr64()
        self.GetNewDeviceList = v_uint8()
        self._pad0038 = v_bytes(size=7)
        self.Order = PO_DEVICE_NOTIFY_ORDER()
        self.Pending = LIST_ENTRY()
        self.Status = v_uint32()
        self._pad02e8 = v_bytes(size=4)
        self.FailedDevice = v_ptr64()
        self.Waking = v_uint8()
        self.Cancelled = v_uint8()
        self.IgnoreErrors = v_uint8()
        self.IgnoreNotImplemented = v_uint8()
        self.TimeRefreshLockAcquired = v_uint8()
        self._pad02f8 = v_bytes(size=3)


class VI_DEADLOCK_RESOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.NodeCount = v_uint32()
        self.ResourceAddress = v_ptr64()
        self.ThreadOwner = v_ptr64()
        self.ResourceList = LIST_ENTRY()
        self.HashChainList = LIST_ENTRY()
        self.StackTrace = vstruct.VArray([ v_ptr64() for i in xrange(8) ])
        self.LastAcquireTrace = vstruct.VArray([ v_ptr64() for i in xrange(8) ])
        self.LastReleaseTrace = vstruct.VArray([ v_ptr64() for i in xrange(8) ])


class UNEXPECTED_INTERRUPT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PushImmOp = v_uint8()
        self.PushImm = v_uint32()
        self.PushRbp = v_uint8()
        self.JmpOp = v_uint8()
        self.JmpOffset = v_uint32()
        self._pad0010 = v_bytes(size=5)


class HEAP_PSEUDO_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint64()


class MMPFNLIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Total = v_uint64()
        self.ListName = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.Flink = v_uint64()
        self.Blink = v_uint64()
        self.Lock = v_uint64()


class CM_KEY_REFERENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.KeyCell = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.KeyHive = v_ptr64()


class MMSECTION_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BeingDeleted = v_uint32()


class MI_SPECIAL_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PteBase = v_ptr64()
        self.Lock = v_uint64()
        self.Paged = MI_SPECIAL_POOL_PTE_LIST()
        self.NonPaged = MI_SPECIAL_POOL_PTE_LIST()
        self.PagesInUse = v_uint64()
        self.SpecialPoolPdes = RTL_BITMAP()


class MM_SUBSECTION_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = MMSUBSECTION_NODE()
        self.DepthOfTree = v_uint64()
        self.NodeHint = v_ptr64()


class NETWORK_LOADER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DHCPServerACK = v_ptr64()
        self.DHCPServerACKLength = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.BootServerReplyPacket = v_ptr64()
        self.BootServerReplyPacketLength = v_uint32()
        self._pad0020 = v_bytes(size=4)


class CM_TRANS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TransactionListEntry = LIST_ENTRY()
        self.KCBUoWListHead = LIST_ENTRY()
        self.LazyCommitListEntry = LIST_ENTRY()
        self.KtmTrans = v_ptr64()
        self.CmRm = v_ptr64()
        self.KtmEnlistmentObject = v_ptr64()
        self.KtmEnlistmentHandle = v_ptr64()
        self.KtmUow = GUID()
        self.StartLsn = v_uint64()
        self.TransState = v_uint32()
        self.HiveCount = v_uint32()
        self.HiveArray = vstruct.VArray([ v_ptr64() for i in xrange(7) ])


class POP_POWER_ACTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Updates = v_uint8()
        self.State = v_uint8()
        self.Shutdown = v_uint8()
        self._pad0004 = v_bytes(size=1)
        self.Action = v_uint32()
        self.LightestState = v_uint32()
        self.Flags = v_uint32()
        self.Status = v_uint32()
        self.DeviceType = v_uint32()
        self.DeviceTypeFlags = v_uint32()
        self.IrpMinor = v_uint8()
        self.Waking = v_uint8()
        self._pad0020 = v_bytes(size=2)
        self.SystemState = v_uint32()
        self.NextSystemState = v_uint32()
        self.EffectiveSystemState = v_uint32()
        self.CurrentSystemState = v_uint32()
        self.ShutdownBugCode = v_ptr64()
        self.DevState = v_ptr64()
        self.HiberContext = v_ptr64()
        self.WakeTime = v_uint64()
        self.SleepTime = v_uint64()
        self.ProgrammedRTCTime = v_uint64()
        self.WakeOnRTC = v_uint8()
        self._pad0068 = v_bytes(size=7)
        self.WakeTimerInfo = v_ptr64()
        self.FilteredCapabilities = SYSTEM_POWER_CAPABILITIES()
        self._pad00c0 = v_bytes(size=4)


class OBJECT_CREATE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Attributes = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.RootDirectory = v_ptr64()
        self.ProbeMode = v_uint8()
        self._pad0014 = v_bytes(size=3)
        self.PagedPoolCharge = v_uint32()
        self.NonPagedPoolCharge = v_uint32()
        self.SecurityDescriptorCharge = v_uint32()
        self.SecurityDescriptor = v_ptr64()
        self.SecurityQos = v_ptr64()
        self.SecurityQualityOfService = SECURITY_QUALITY_OF_SERVICE()
        self._pad0040 = v_bytes(size=4)


class OBJECT_HEADER_CREATOR_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TypeList = LIST_ENTRY()
        self.CreatorUniqueProcess = v_ptr64()
        self.CreatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self._pad0020 = v_bytes(size=4)


class PAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()


class ETHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Tcb = KTHREAD()
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self._pad0378 = v_bytes(size=8)
        self.ExitStatus = v_uint32()
        self._pad0380 = v_bytes(size=4)
        self.PostBlockList = LIST_ENTRY()
        self.TerminationPort = v_ptr64()
        self.ActiveTimerListLock = v_uint64()
        self.ActiveTimerListHead = LIST_ENTRY()
        self.Cid = CLIENT_ID()
        self.KeyedWaitSemaphore = KSEMAPHORE()
        self.ClientSecurity = PS_CLIENT_SECURITY_CONTEXT()
        self.IrpList = LIST_ENTRY()
        self.TopLevelIrp = v_uint64()
        self.DeviceToVerify = v_ptr64()
        self.CpuQuotaApc = v_ptr64()
        self.Win32StartAddress = v_ptr64()
        self.LegacyPowerObject = v_ptr64()
        self.ThreadListEntry = LIST_ENTRY()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.ThreadLock = EX_PUSH_LOCK()
        self.ReadClusterSize = v_uint32()
        self.MmLockOrdering = v_uint32()
        self.CrossThreadFlags = v_uint32()
        self.SameThreadPassiveFlags = v_uint32()
        self.SameThreadApcFlags = v_uint32()
        self.CacheManagerActive = v_uint8()
        self.DisablePageFaultClustering = v_uint8()
        self.ActiveFaultCount = v_uint8()
        self.LockOrderState = v_uint8()
        self.AlpcMessageId = v_uint64()
        self.AlpcMessage = v_ptr64()
        self.AlpcWaitListEntry = LIST_ENTRY()
        self.CacheManagerCount = v_uint32()
        self.IoBoostCount = v_uint32()
        self.IrpListLock = v_uint64()
        self.ReservedForSynchTracking = v_ptr64()
        self.CmCallbackListHead = SINGLE_LIST_ENTRY()


class PO_NOTIFY_ORDER_LEVEL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceCount = v_uint32()
        self.ActiveCount = v_uint32()
        self.WaitSleep = LIST_ENTRY()
        self.ReadySleep = LIST_ENTRY()
        self.ReadyS0 = LIST_ENTRY()
        self.WaitS0 = LIST_ENTRY()


class RTL_BITMAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfBitMap = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_ptr64()


class LARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class IA64_DBGKD_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Continue = v_uint32()
        self.CurrentSymbolStart = v_uint64()
        self.CurrentSymbolEnd = v_uint64()


class NPAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()


class HBIN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.FileOffset = v_uint32()
        self.Size = v_uint32()
        self.Reserved1 = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.TimeStamp = LARGE_INTEGER()
        self.Spare = v_uint32()


class _unnamed_21245(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_ptr64()
        self.Key = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.ByteOffset = LARGE_INTEGER()


class _unnamed_23833(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CriticalSection = RTL_CRITICAL_SECTION()


class BITMAP_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Links = LIST_ENTRY()
        self.BasePage = v_uint64()
        self.FirstDirtyPage = v_uint32()
        self.LastDirtyPage = v_uint32()
        self.DirtyPages = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.Bitmap = v_ptr64()


class SYSTEM_TRACE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Marker = v_uint32()
        self.Header = v_uint32()
        self.ThreadId = v_uint32()
        self.ProcessId = v_uint32()
        self.SystemTime = LARGE_INTEGER()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()


class ETW_REG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RegList = LIST_ENTRY()
        self.GuidEntry = v_ptr64()
        self.Index = v_uint16()
        self.Flags = v_uint16()
        self.EnableMask = v_uint8()
        self._pad0020 = v_bytes(size=3)
        self.SessionId = v_uint32()
        self._pad0040 = v_bytes(size=28)
        self.Process = v_ptr64()
        self.CallbackContext = v_ptr64()


class KLOCK_QUEUE_HANDLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LockQueue = KSPIN_LOCK_QUEUE()
        self.OldIrql = v_uint8()
        self._pad0018 = v_bytes(size=7)


class CLIENT_ID32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_uint32()
        self.UniqueThread = v_uint32()


class CLS_LSN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.offset = _unnamed_29085()


class ALIGNED_AFFINITY_SUMMARY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CpuSet = KAFFINITY_EX()
        self.SMTSet = KAFFINITY_EX()
        self._pad0080 = v_bytes(size=48)


class VPB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.Flags = v_uint16()
        self.VolumeLabelLength = v_uint16()
        self.DeviceObject = v_ptr64()
        self.RealDevice = v_ptr64()
        self.SerialNumber = v_uint32()
        self.ReferenceCount = v_uint32()
        self.VolumeLabel = vstruct.VArray([ v_uint16() for i in xrange(32) ])


class OBP_LOOKUP_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Directory = v_ptr64()
        self.Object = v_ptr64()
        self.HashValue = v_uint32()
        self.HashIndex = v_uint16()
        self.DirectoryLocked = v_uint8()
        self.LockedExclusive = v_uint8()
        self.LockStateSignature = v_uint32()
        self._pad0020 = v_bytes(size=4)


class OB_DUPLICATE_OBJECT_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SourceProcess = v_ptr64()
        self.SourceHandle = v_ptr64()
        self.Object = v_ptr64()
        self.TargetAccess = v_uint32()
        self.ObjectInfo = HANDLE_TABLE_ENTRY_INFO()
        self.HandleAttributes = v_uint32()
        self._pad0028 = v_bytes(size=4)


class PP_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P = v_ptr64()
        self.L = v_ptr64()


class SEP_LOGON_SESSION_REFERENCES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.LogonId = LUID()
        self.BuddyLogonId = LUID()
        self.ReferenceCount = v_uint32()
        self.Flags = v_uint32()
        self.pDeviceMap = v_ptr64()
        self.Token = v_ptr64()
        self.AccountName = UNICODE_STRING()
        self.AuthorityName = UNICODE_STRING()


class _unnamed_18818(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFunction = v_uint32()


class PSP_CPU_QUOTA_APC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class MMPTE_TIMESTAMP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MustBeZero = v_uint64()


class OBJECT_NAME_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = UNICODE_STRING()


class OBJECT_HEADER_PROCESS_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExclusiveProcess = v_ptr64()
        self.Reserved = v_uint64()


class KUSER_SHARED_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TickCountLowDeprecated = v_uint32()
        self.TickCountMultiplier = v_uint32()
        self.InterruptTime = KSYSTEM_TIME()
        self.SystemTime = KSYSTEM_TIME()
        self.TimeZoneBias = KSYSTEM_TIME()
        self.ImageNumberLow = v_uint16()
        self.ImageNumberHigh = v_uint16()
        self.NtSystemRoot = vstruct.VArray([ v_uint16() for i in xrange(260) ])
        self.MaxStackTraceDepth = v_uint32()
        self.CryptoExponent = v_uint32()
        self.TimeZoneId = v_uint32()
        self.LargePageMinimum = v_uint32()
        self.Reserved2 = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self.NtProductType = v_uint32()
        self.ProductTypeIsValid = v_uint8()
        self._pad026c = v_bytes(size=3)
        self.NtMajorVersion = v_uint32()
        self.NtMinorVersion = v_uint32()
        self.ProcessorFeatures = vstruct.VArray([ v_uint8() for i in xrange(64) ])
        self.Reserved1 = v_uint32()
        self.Reserved3 = v_uint32()
        self.TimeSlip = v_uint32()
        self.AlternativeArchitecture = v_uint32()
        self.AltArchitecturePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.SystemExpirationDate = LARGE_INTEGER()
        self.SuiteMask = v_uint32()
        self.KdDebuggerEnabled = v_uint8()
        self.NXSupportPolicy = v_uint8()
        self._pad02d8 = v_bytes(size=2)
        self.ActiveConsoleId = v_uint32()
        self.DismountCount = v_uint32()
        self.ComPlusPackage = v_uint32()
        self.LastSystemRITEventTickCount = v_uint32()
        self.NumberOfPhysicalPages = v_uint32()
        self.SafeBootMode = v_uint8()
        self.TscQpcData = v_uint8()
        self.TscQpcPad = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.SharedDataFlags = v_uint32()
        self.DataFlagsPad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.TestRetInstruction = v_uint64()
        self.SystemCall = v_uint32()
        self.SystemCallReturn = v_uint32()
        self.SystemCallPad = vstruct.VArray([ v_uint64() for i in xrange(3) ])
        self.TickCount = KSYSTEM_TIME()
        self.TickCountPad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.Cookie = v_uint32()
        self.CookiePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.ConsoleSessionForegroundProcessId = v_uint64()
        self.Wow64SharedInformation = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.UserModeGlobalLogger = vstruct.VArray([ v_uint16() for i in xrange(16) ])
        self.ImageFileExecutionOptions = v_uint32()
        self.LangGenerationCount = v_uint32()
        self.Reserved5 = v_uint64()
        self.InterruptTimeBias = v_uint64()
        self.TscQpcBias = v_uint64()
        self.ActiveProcessorCount = v_uint32()
        self.ActiveGroupCount = v_uint16()
        self.Reserved4 = v_uint16()
        self.AitSamplingValue = v_uint32()
        self.AppCompatFlag = v_uint32()
        self.SystemDllNativeRelocation = v_uint64()
        self.SystemDllWowRelocation = v_uint32()
        self.XStatePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.XState = XSTATE_CONFIGURATION()


class _unnamed_27347(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PhysicalAddress = v_uint32()


class LPCP_MESSAGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = LIST_ENTRY()
        self.SenderPort = v_ptr64()
        self.RepliedToThread = v_ptr64()
        self.PortContext = v_ptr64()
        self.Request = PORT_MESSAGE()


class HEAP_FREE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousBlockPrivateData = v_ptr64()
        self.Size = v_uint16()
        self.Flags = v_uint8()
        self.SmallTagIndex = v_uint8()
        self.PreviousSize = v_uint16()
        self.SegmentOffset = v_uint8()
        self.UnusedBytes = v_uint8()
        self.FreeList = LIST_ENTRY()


class KTM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cookie = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Mutex = KMUTANT()
        self.State = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.NamespaceLink = KTMOBJECT_NAMESPACE_LINK()
        self.TmIdentity = GUID()
        self.Flags = v_uint32()
        self.VolatileFlags = v_uint32()
        self.LogFileName = UNICODE_STRING()
        self.LogFileObject = v_ptr64()
        self.MarshallingContext = v_ptr64()
        self.LogManagementContext = v_ptr64()
        self.Transactions = KTMOBJECT_NAMESPACE()
        self.ResourceManagers = KTMOBJECT_NAMESPACE()
        self.LsnOrderedMutex = KMUTANT()
        self.LsnOrderedList = LIST_ENTRY()
        self.CommitVirtualClock = LARGE_INTEGER()
        self.CommitVirtualClockMutex = FAST_MUTEX()
        self.BaseLsn = CLS_LSN()
        self.CurrentReadLsn = CLS_LSN()
        self.LastRecoveredLsn = CLS_LSN()
        self.TmRmHandle = v_ptr64()
        self.TmRm = v_ptr64()
        self.LogFullNotifyEvent = KEVENT()
        self.CheckpointWorkItem = WORK_QUEUE_ITEM()
        self.CheckpointTargetLsn = CLS_LSN()
        self.LogFullCompletedWorkItem = WORK_QUEUE_ITEM()
        self.LogWriteResource = ERESOURCE()
        self.LogFlags = v_uint32()
        self.LogFullStatus = v_uint32()
        self.RecoveryStatus = v_uint32()
        self._pad0388 = v_bytes(size=4)
        self.LastCheckBaseLsn = CLS_LSN()
        self.RestartOrderedList = LIST_ENTRY()
        self.OfflineWorkItem = WORK_QUEUE_ITEM()


class PRIVATE_CACHE_MAP_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DontUse = v_uint32()


class VF_TARGET_VERIFIED_DRIVER_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SuspectDriverEntry = v_ptr64()
        self.WMICallback = v_ptr64()
        self.EtwHandlesListHead = LIST_ENTRY()
        self.u1 = _unnamed_26910()
        self._pad0028 = v_bytes(size=4)
        self.Signature = v_uint64()
        self.PoolPageHeaders = SLIST_HEADER()
        self.PoolTrackers = SLIST_HEADER()
        self.CurrentPagedPoolAllocations = v_uint32()
        self.CurrentNonPagedPoolAllocations = v_uint32()
        self.PeakPagedPoolAllocations = v_uint32()
        self.PeakNonPagedPoolAllocations = v_uint32()
        self.PagedBytes = v_uint64()
        self.NonPagedBytes = v_uint64()
        self.PeakPagedBytes = v_uint64()
        self.PeakNonPagedBytes = v_uint64()
        self.RaiseIrqls = v_uint32()
        self.AcquireSpinLocks = v_uint32()
        self.SynchronizeExecutions = v_uint32()
        self.AllocationsWithNoTag = v_uint32()
        self.AllocationsFailed = v_uint32()
        self.AllocationsFailedDeliberately = v_uint32()
        self.LockedBytes = v_uint64()
        self.PeakLockedBytes = v_uint64()
        self.MappedLockedBytes = v_uint64()
        self.PeakMappedLockedBytes = v_uint64()
        self.MappedIoSpaceBytes = v_uint64()
        self.PeakMappedIoSpaceBytes = v_uint64()
        self.PagesForMdlBytes = v_uint64()
        self.PeakPagesForMdlBytes = v_uint64()
        self.ContiguousMemoryBytes = v_uint64()
        self.PeakContiguousMemoryBytes = v_uint64()
        self.ContiguousMemoryListHead = LIST_ENTRY()
        self._pad0100 = v_bytes(size=8)


class TEB64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB64()
        self.EnvironmentPointer = v_uint64()
        self.ClientId = CLIENT_ID64()
        self.ActiveRpcHandle = v_uint64()
        self.ThreadLocalStoragePointer = v_uint64()
        self.ProcessEnvironmentBlock = v_uint64()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_uint64()
        self.Win32ThreadInfo = v_uint64()
        self.User32Reserved = vstruct.VArray([ v_uint32() for i in xrange(26) ])
        self.UserReserved = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self._pad0100 = v_bytes(size=4)
        self.WOW32Reserved = v_uint64()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()
        self.SystemReserved1 = vstruct.VArray([ v_uint64() for i in xrange(54) ])
        self.ExceptionCode = v_uint32()
        self._pad02c8 = v_bytes(size=4)
        self.ActivationContextStackPointer = v_uint64()
        self.SpareBytes = vstruct.VArray([ v_uint8() for i in xrange(24) ])
        self.TxFsContext = v_uint32()
        self._pad02f0 = v_bytes(size=4)
        self.GdiTebBatch = GDI_TEB_BATCH64()
        self.RealClientId = CLIENT_ID64()
        self.GdiCachedProcessHandle = v_uint64()
        self.GdiClientPID = v_uint32()
        self.GdiClientTID = v_uint32()
        self.GdiThreadLocalInfo = v_uint64()
        self.Win32ClientInfo = vstruct.VArray([ v_uint64() for i in xrange(62) ])
        self.glDispatchTable = vstruct.VArray([ v_uint64() for i in xrange(233) ])
        self.glReserved1 = vstruct.VArray([ v_uint64() for i in xrange(29) ])
        self.glReserved2 = v_uint64()
        self.glSectionInfo = v_uint64()
        self.glSection = v_uint64()
        self.glTable = v_uint64()
        self.glCurrentRC = v_uint64()
        self.glContext = v_uint64()
        self.LastStatusValue = v_uint32()
        self._pad1258 = v_bytes(size=4)
        self.StaticUnicodeString = STRING64()
        self.StaticUnicodeBuffer = vstruct.VArray([ v_uint16() for i in xrange(261) ])
        self._pad1478 = v_bytes(size=6)
        self.DeallocationStack = v_uint64()
        self.TlsSlots = vstruct.VArray([ v_uint64() for i in xrange(64) ])
        self.TlsLinks = LIST_ENTRY64()
        self.Vdm = v_uint64()
        self.ReservedForNtRpc = v_uint64()
        self.DbgSsReserved = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.HardErrorMode = v_uint32()
        self._pad16b8 = v_bytes(size=4)
        self.Instrumentation = vstruct.VArray([ v_uint64() for i in xrange(11) ])
        self.ActivityId = GUID()
        self.SubProcessTag = v_uint64()
        self.EtwLocalData = v_uint64()
        self.EtwTraceData = v_uint64()
        self.WinSockData = v_uint64()
        self.GdiBatchCount = v_uint32()
        self.CurrentIdealProcessor = PROCESSOR_NUMBER()
        self.GuaranteedStackBytes = v_uint32()
        self._pad1750 = v_bytes(size=4)
        self.ReservedForPerf = v_uint64()
        self.ReservedForOle = v_uint64()
        self.WaitingOnLoaderLock = v_uint32()
        self._pad1768 = v_bytes(size=4)
        self.SavedPriorityState = v_uint64()
        self.SoftPatchPtr1 = v_uint64()
        self.ThreadPoolData = v_uint64()
        self.TlsExpansionSlots = v_uint64()
        self.DeallocationBStore = v_uint64()
        self.BStoreLimit = v_uint64()
        self.MuiGeneration = v_uint32()
        self.IsImpersonating = v_uint32()
        self.NlsCache = v_uint64()
        self.pShimData = v_uint64()
        self.HeapVirtualAffinity = v_uint32()
        self._pad17b8 = v_bytes(size=4)
        self.CurrentTransactionHandle = v_uint64()
        self.ActiveFrame = v_uint64()
        self.FlsData = v_uint64()
        self.PreferredLanguages = v_uint64()
        self.UserPrefLanguages = v_uint64()
        self.MergedPrefLanguages = v_uint64()
        self.MuiImpersonation = v_uint32()
        self.CrossTebFlags = v_uint16()
        self.SameTebFlags = v_uint16()
        self.TxnScopeEnterCallback = v_uint64()
        self.TxnScopeExitCallback = v_uint64()
        self.TxnScopeContext = v_uint64()
        self.LockCount = v_uint32()
        self.SpareUlong0 = v_uint32()
        self.ResourceRetValue = v_uint64()


class IO_STATUS_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Information = v_uint64()


class HCELL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.u = _unnamed_22910()


class CM_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.List = vstruct.VArray([ CM_FULL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class EPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pcb = KPROCESS()
        self.ProcessLock = EX_PUSH_LOCK()
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.UniqueProcessId = v_ptr64()
        self.ActiveProcessLinks = LIST_ENTRY()
        self.ProcessQuotaUsage = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.ProcessQuotaPeak = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.CommitCharge = v_uint64()
        self.QuotaBlock = v_ptr64()
        self.CpuQuotaBlock = v_ptr64()
        self.PeakVirtualSize = v_uint64()
        self.VirtualSize = v_uint64()
        self.SessionProcessLinks = LIST_ENTRY()
        self.DebugPort = v_ptr64()
        self.ExceptionPortData = v_ptr64()
        self.ObjectTable = v_ptr64()
        self.Token = EX_FAST_REF()
        self.WorkingSetPage = v_uint64()
        self.AddressCreationLock = EX_PUSH_LOCK()
        self.RotateInProgress = v_ptr64()
        self.ForkInProgress = v_ptr64()
        self.HardwareTrigger = v_uint64()
        self.PhysicalVadRoot = v_ptr64()
        self.CloneRoot = v_ptr64()
        self.NumberOfPrivatePages = v_uint64()
        self.NumberOfLockedPages = v_uint64()
        self.Win32Process = v_ptr64()
        self.Job = v_ptr64()
        self.SectionObject = v_ptr64()
        self.SectionBaseAddress = v_ptr64()
        self.Cookie = v_uint32()
        self.UmsScheduledThreads = v_uint32()
        self.WorkingSetWatch = v_ptr64()
        self.Win32WindowStation = v_ptr64()
        self.InheritedFromUniqueProcessId = v_ptr64()
        self.LdtInformation = v_ptr64()
        self.Spare = v_ptr64()
        self.ConsoleHostProcess = v_uint64()
        self.DeviceMap = v_ptr64()
        self.EtwDataSource = v_ptr64()
        self.FreeTebHint = v_ptr64()
        self.FreeUmsTebHint = v_ptr64()
        self.PageDirectoryPte = HARDWARE_PTE()
        self.Session = v_ptr64()
        self.ImageFileName = vstruct.VArray([ v_uint8() for i in xrange(15) ])
        self.PriorityClass = v_uint8()
        self.JobLinks = LIST_ENTRY()
        self.LockedPagesList = v_ptr64()
        self.ThreadListHead = LIST_ENTRY()
        self.SecurityPort = v_ptr64()
        self.Wow64Process = v_ptr64()
        self.ActiveThreads = v_uint32()
        self.ImagePathHash = v_uint32()
        self.DefaultHardErrorProcessing = v_uint32()
        self.LastThreadExitStatus = v_uint32()
        self.Peb = v_ptr64()
        self.PrefetchTrace = EX_FAST_REF()
        self.ReadOperationCount = LARGE_INTEGER()
        self.WriteOperationCount = LARGE_INTEGER()
        self.OtherOperationCount = LARGE_INTEGER()
        self.ReadTransferCount = LARGE_INTEGER()
        self.WriteTransferCount = LARGE_INTEGER()
        self.OtherTransferCount = LARGE_INTEGER()
        self.CommitChargeLimit = v_uint64()
        self.CommitChargePeak = v_uint64()
        self.AweInfo = v_ptr64()
        self.SeAuditProcessCreationInfo = SE_AUDIT_PROCESS_CREATION_INFO()
        self.Vm = MMSUPPORT()
        self.MmProcessLinks = LIST_ENTRY()
        self.HighestUserAddress = v_ptr64()
        self.ModifiedPageCount = v_uint32()
        self.Flags2 = v_uint32()
        self.Flags = v_uint32()
        self.ExitStatus = v_uint32()
        self.VadRoot = MM_AVL_TABLE()
        self.AlpcContext = ALPC_PROCESS_CONTEXT()
        self.TimerResolutionLink = LIST_ENTRY()
        self.RequestedTimerResolution = v_uint32()
        self.ActiveThreadsHighWatermark = v_uint32()
        self.SmallestTimerResolution = v_uint32()
        self._pad04c8 = v_bytes(size=4)
        self.TimerResolutionStackRecord = v_ptr64()


class ALPC_PORT_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.SecurityQos = SECURITY_QUALITY_OF_SERVICE()
        self.MaxMessageLength = v_uint64()
        self.MemoryBandwidth = v_uint64()
        self.MaxPoolUsage = v_uint64()
        self.MaxSectionSize = v_uint64()
        self.MaxViewSize = v_uint64()
        self.MaxTotalSectionSize = v_uint64()
        self.DupObjectTypes = v_uint32()
        self.Reserved = v_uint32()


class CM_KEY_BODY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.KeyControlBlock = v_ptr64()
        self.NotifyBlock = v_ptr64()
        self.ProcessID = v_ptr64()
        self.KeyBodyList = LIST_ENTRY()
        self.Flags = v_uint32()
        self._pad0038 = v_bytes(size=4)
        self.KtmTrans = v_ptr64()
        self.KtmUow = v_ptr64()
        self.ContextListHead = LIST_ENTRY()


class KMUTANT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.MutantListEntry = LIST_ENTRY()
        self.OwnerThread = v_ptr64()
        self.Abandoned = v_uint8()
        self.ApcDisable = v_uint8()
        self._pad0038 = v_bytes(size=6)


class POWER_SEQUENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SequenceD1 = v_uint32()
        self.SequenceD2 = v_uint32()
        self.SequenceD3 = v_uint32()


class TEB_ACTIVE_FRAME_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FrameName = v_ptr64()


class _unnamed_22448(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags = v_uint32()


class KTIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.DueTime = ULARGE_INTEGER()
        self.TimerListEntry = LIST_ENTRY()
        self.Dpc = v_ptr64()
        self.Processor = v_uint32()
        self.Period = v_uint32()


class RTL_UMS_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = SINGLE_LIST_ENTRY()
        self._pad0010 = v_bytes(size=8)
        self.Context = CONTEXT()
        self.Teb = v_ptr64()
        self.UserContext = v_ptr64()
        self.ScheduledThread = v_uint32()
        self._pad04f8 = v_bytes(size=4)
        self.KernelUpdateLock = v_uint64()
        self.QuantumValue = v_uint64()
        self.AffinityMask = GROUP_AFFINITY()
        self.Priority = v_uint32()
        self._pad0520 = v_bytes(size=4)
        self.PrimaryUmsContext = v_ptr64()
        self.SwitchCount = v_uint32()
        self.KernelYieldCount = v_uint32()
        self.MixedYieldCount = v_uint32()
        self.YieldCount = v_uint32()
        self._pad0540 = v_bytes(size=8)


class MM_PAGED_POOL_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mutex = KGUARDED_MUTEX()
        self.PagedPoolAllocationMap = RTL_BITMAP()
        self.FirstPteForPagedPool = v_ptr64()
        self.PagedPoolHint = v_uint32()
        self._pad0058 = v_bytes(size=4)
        self.PagedPoolCommit = v_uint64()
        self.AllocatedPagedPool = v_uint64()


class HIVE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileName = v_ptr64()
        self.BaseName = v_ptr64()
        self.RegRootName = v_ptr64()
        self.CmHive = v_ptr64()
        self.HHiveFlags = v_uint32()
        self.CmHiveFlags = v_uint32()
        self.CmKcbCacheSize = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.CmHive2 = v_ptr64()
        self.HiveMounted = v_uint8()
        self.ThreadFinished = v_uint8()
        self.ThreadStarted = v_uint8()
        self.Allocate = v_uint8()
        self.WinPERequired = v_uint8()
        self._pad0040 = v_bytes(size=3)
        self.StartEvent = KEVENT()
        self.FinishedEvent = KEVENT()
        self.MountLock = KEVENT()


class WHEA_ERROR_STATUS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ErrorStatus = v_uint64()


class CM_PARTIAL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Flags = v_uint16()
        self.u = _unnamed_26621()


class RTLP_RANGE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint64()
        self.End = v_uint64()
        self.Allocated = _unnamed_28570()
        self.Attributes = v_uint8()
        self.PublicFlags = v_uint8()
        self.PrivateFlags = v_uint16()
        self._pad0028 = v_bytes(size=4)
        self.ListEntry = LIST_ENTRY()


class _unnamed_21102(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr64()
        self.Options = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.FileAttributes = v_uint16()
        self.ShareAccess = v_uint16()
        self._pad0018 = v_bytes(size=4)
        self.EaLength = v_uint32()
        self._pad0020 = v_bytes(size=4)


class KBUGCHECK_ACTIVE_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BugCheckState = v_uint32()


class _unnamed_19928(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint64()
        self.HeaderType = v_uint64()


class _unnamed_20590(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self._pad0048 = v_bytes(size=56)


class ALPC_COMPLETION_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = LIST_ENTRY()
        self.OwnerProcess = v_ptr64()
        self.Mdl = v_ptr64()
        self.UserVa = v_ptr64()
        self.UserLimit = v_ptr64()
        self.DataUserVa = v_ptr64()
        self.SystemVa = v_ptr64()
        self.TotalSize = v_uint64()
        self.Header = v_ptr64()
        self.List = v_ptr64()
        self.ListSize = v_uint64()
        self.Bitmap = v_ptr64()
        self.BitmapSize = v_uint64()
        self.Data = v_ptr64()
        self.DataSize = v_uint64()
        self.BitmapLimit = v_uint32()
        self.BitmapNextHint = v_uint32()
        self.ConcurrencyCount = v_uint32()
        self.AttributeFlags = v_uint32()
        self.AttributeSize = v_uint32()
        self._pad0098 = v_bytes(size=4)


class CM_FULL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.PartialResourceList = CM_PARTIAL_RESOURCE_LIST()


class DBGKD_GET_VERSION64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.ProtocolVersion = v_uint8()
        self.KdSecondaryVersion = v_uint8()
        self.Flags = v_uint16()
        self.MachineType = v_uint16()
        self.MaxPacketType = v_uint8()
        self.MaxStateChange = v_uint8()
        self.MaxManipulate = v_uint8()
        self.Simulation = v_uint8()
        self.Unused = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self.KernBase = v_uint64()
        self.PsLoadedModuleList = v_uint64()
        self.DebuggerDataList = v_uint64()


class KTIMER_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TimerExpiry = vstruct.VArray([ v_ptr64() for i in xrange(64) ])
        self.TimerEntries = vstruct.VArray([ KTIMER_TABLE_ENTRY() for i in xrange(256) ])


class _unnamed_27299(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Raw = _unnamed_27294()


class FAST_IO_DISPATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFastIoDispatch = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FastIoCheckIfPossible = v_ptr64()
        self.FastIoRead = v_ptr64()
        self.FastIoWrite = v_ptr64()
        self.FastIoQueryBasicInfo = v_ptr64()
        self.FastIoQueryStandardInfo = v_ptr64()
        self.FastIoLock = v_ptr64()
        self.FastIoUnlockSingle = v_ptr64()
        self.FastIoUnlockAll = v_ptr64()
        self.FastIoUnlockAllByKey = v_ptr64()
        self.FastIoDeviceControl = v_ptr64()
        self.AcquireFileForNtCreateSection = v_ptr64()
        self.ReleaseFileForNtCreateSection = v_ptr64()
        self.FastIoDetachDevice = v_ptr64()
        self.FastIoQueryNetworkOpenInfo = v_ptr64()
        self.AcquireForModWrite = v_ptr64()
        self.MdlRead = v_ptr64()
        self.MdlReadComplete = v_ptr64()
        self.PrepareMdlWrite = v_ptr64()
        self.MdlWriteComplete = v_ptr64()
        self.FastIoReadCompressed = v_ptr64()
        self.FastIoWriteCompressed = v_ptr64()
        self.MdlReadCompleteCompressed = v_ptr64()
        self.MdlWriteCompleteCompressed = v_ptr64()
        self.FastIoQueryOpen = v_ptr64()
        self.ReleaseForModWrite = v_ptr64()
        self.AcquireForCcFlush = v_ptr64()
        self.ReleaseForCcFlush = v_ptr64()


class _unnamed_21237(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FsInformationClass = v_uint32()
        self._pad0010 = v_bytes(size=4)


class SLIST_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Alignment = v_uint64()
        self.Region = v_uint64()


class CM_KEY_CONTROL_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RefCount = v_uint32()
        self.ExtFlags = v_uint32()
        self.DelayedDeref = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.KeyHash = CM_KEY_HASH()
        self.KcbPushlock = EX_PUSH_LOCK()
        self.Owner = v_ptr64()
        self.SlotHint = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.ParentKcb = v_ptr64()
        self.NameBlock = v_ptr64()
        self.CachedSecurity = v_ptr64()
        self.ValueCache = CACHED_CHILD_LIST()
        self.IndexHint = v_ptr64()
        self.KeyBodyListHead = LIST_ENTRY()
        self.KeyBodyArray = vstruct.VArray([ v_ptr64() for i in xrange(4) ])
        self.KcbLastWriteTime = LARGE_INTEGER()
        self.KcbMaxNameLen = v_uint16()
        self.KcbMaxValueNameLen = v_uint16()
        self.KcbMaxValueDataLen = v_uint32()
        self.KcbUserFlags = v_uint32()
        self._pad00c0 = v_bytes(size=4)
        self.RealKeyName = v_ptr64()
        self.KCBUoWListHead = LIST_ENTRY()
        self.DelayQueueEntry = LIST_ENTRY()
        self.TransKCBOwner = v_ptr64()
        self.KCBLock = CM_INTENT_LOCK()
        self.KeyLock = CM_INTENT_LOCK()
        self.TransValueCache = CHILD_LIST()
        self.TransValueListOwner = v_ptr64()
        self.FullKCBName = v_ptr64()


class _unnamed_27294(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.MessageCount = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint64()


class RTL_DYNAMIC_HASH_TABLE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ChainHead = v_ptr64()
        self.PrevLinkage = v_ptr64()
        self.Signature = v_uint64()


class MMWSL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FirstFree = v_uint32()
        self.FirstDynamic = v_uint32()
        self.LastEntry = v_uint32()
        self.NextSlot = v_uint32()
        self.Wsle = v_ptr64()
        self.LowestPagableAddress = v_ptr64()
        self.LastInitializedWsle = v_uint32()
        self.NextAgingSlot = v_uint32()
        self.NumberOfCommittedPageTables = v_uint32()
        self.VadBitMapHint = v_uint32()
        self.NonDirectCount = v_uint32()
        self.LastVadBit = v_uint32()
        self.MaximumLastVadBit = v_uint32()
        self.LastAllocationSizeHint = v_uint32()
        self.LastAllocationSize = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.NonDirectHash = v_ptr64()
        self.HashTableStart = v_ptr64()
        self.HighestPermittedHashAddress = v_ptr64()
        self.MaximumUserPageTablePages = v_uint32()
        self.MaximumUserPageDirectoryPages = v_uint32()
        self.CommittedPageTables = v_ptr64()
        self.NumberOfCommittedPageDirectories = v_uint32()
        self._pad0078 = v_bytes(size=4)
        self.CommittedPageDirectories = vstruct.VArray([ v_uint64() for i in xrange(128) ])
        self.NumberOfCommittedPageDirectoryParents = v_uint32()
        self._pad0480 = v_bytes(size=4)
        self.CommittedPageDirectoryParents = vstruct.VArray([ v_uint64() for i in xrange(1) ])


class KTMOBJECT_NAMESPACE_LINK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Links = RTL_BALANCED_LINKS()
        self.Expired = v_uint8()
        self._pad0028 = v_bytes(size=7)


class MI_IMAGE_SECURITY_REFERENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = IMAGE_SECURITY_CONTEXT()
        self.DynamicRelocations = v_ptr64()
        self.ReferenceCount = v_uint32()
        self._pad0018 = v_bytes(size=4)


class WHEA_MEMORY_ERROR_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ValidBits = WHEA_MEMORY_ERROR_SECTION_VALIDBITS()
        self.ErrorStatus = WHEA_ERROR_STATUS()
        self.PhysicalAddress = v_uint64()
        self.PhysicalAddressMask = v_uint64()
        self.Node = v_uint16()
        self.Card = v_uint16()
        self.Module = v_uint16()
        self.Bank = v_uint16()
        self.Device = v_uint16()
        self.Row = v_uint16()
        self.Column = v_uint16()
        self.BitPosition = v_uint16()
        self.RequesterId = v_uint64()
        self.ResponderId = v_uint64()
        self.TargetId = v_uint64()
        self.ErrorType = v_uint8()


class DBGKD_CONTINUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContinueStatus = v_uint32()


class PROC_IDLE_STATE_ACCOUNTING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalTime = v_uint64()
        self.IdleTransitions = v_uint32()
        self.FailedTransitions = v_uint32()
        self.InvalidBucketIndex = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.MinTime = v_uint64()
        self.MaxTime = v_uint64()
        self.IdleTimeBuckets = vstruct.VArray([ PROC_IDLE_STATE_BUCKET() for i in xrange(16) ])


class _unnamed_28314(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags = v_uint32()


class CALL_HASH_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.CallersAddress = v_ptr64()
        self.CallersCaller = v_ptr64()
        self.CallCount = v_uint32()
        self._pad0028 = v_bytes(size=4)


class WORK_QUEUE_ITEM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.List = LIST_ENTRY()
        self.WorkerRoutine = v_ptr64()
        self.Parameter = v_ptr64()


class _unnamed_21392(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InPath = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self._pad0008 = v_bytes(size=4)
        self.Type = v_uint32()
        self._pad0010 = v_bytes(size=4)


class KGDTENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LimitLow = v_uint16()
        self.BaseLow = v_uint16()
        self.Bytes = _unnamed_19309()
        self.BaseUpper = v_uint32()
        self.MustBeZero = v_uint32()


class KSPECIAL_REGISTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cr0 = v_uint64()
        self.Cr2 = v_uint64()
        self.Cr3 = v_uint64()
        self.Cr4 = v_uint64()
        self.KernelDr0 = v_uint64()
        self.KernelDr1 = v_uint64()
        self.KernelDr2 = v_uint64()
        self.KernelDr3 = v_uint64()
        self.KernelDr6 = v_uint64()
        self.KernelDr7 = v_uint64()
        self.Gdtr = KDESCRIPTOR()
        self.Idtr = KDESCRIPTOR()
        self.Tr = v_uint16()
        self.Ldtr = v_uint16()
        self.MxCsr = v_uint32()
        self.DebugControl = v_uint64()
        self.LastBranchToRip = v_uint64()
        self.LastBranchFromRip = v_uint64()
        self.LastExceptionToRip = v_uint64()
        self.LastExceptionFromRip = v_uint64()
        self.Cr8 = v_uint64()
        self.MsrGsBase = v_uint64()
        self.MsrGsSwap = v_uint64()
        self.MsrStar = v_uint64()
        self.MsrLStar = v_uint64()
        self.MsrCStar = v_uint64()
        self.MsrSyscallMask = v_uint64()


class POWER_ACTION_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Action = v_uint32()
        self.Flags = v_uint32()
        self.EventCode = v_uint32()


class FLS_CALLBACK_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class RTL_CRITICAL_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DebugInfo = v_ptr64()
        self.LockCount = v_uint32()
        self.RecursionCount = v_uint32()
        self.OwningThread = v_ptr64()
        self.LockSemaphore = v_ptr64()
        self.SpinCount = v_uint64()


class DBGKM_EXCEPTION64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionRecord = EXCEPTION_RECORD64()
        self.FirstChance = v_uint32()
        self._pad00a0 = v_bytes(size=4)


class _unnamed_23696(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Read = _unnamed_23697()


class _unnamed_23697(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileObject = v_ptr64()


class KSYSTEM_TIME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.High1Time = v_uint32()
        self.High2Time = v_uint32()


class _unnamed_22182(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_ptr64()


class SEGMENT_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalNumberOfPtes4132 = v_uint32()


class ACL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AclRevision = v_uint8()
        self.Sbz1 = v_uint8()
        self.AclSize = v_uint16()
        self.AceCount = v_uint16()
        self.Sbz2 = v_uint16()


class _unnamed_26929(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceId = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class KQUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.EntryListHead = LIST_ENTRY()
        self.CurrentCount = v_uint32()
        self.MaximumCount = v_uint32()
        self.ThreadListHead = LIST_ENTRY()


class POOL_TRACKER_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Key = v_uint32()
        self.NonPagedAllocs = v_uint32()
        self.NonPagedFrees = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.NonPagedBytes = v_uint64()
        self.PagedAllocs = v_uint32()
        self.PagedFrees = v_uint32()
        self.PagedBytes = v_uint64()


class VF_TRACKER_STAMP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Thread = v_ptr64()
        self.Flags = v_uint8()
        self.OldIrql = v_uint8()
        self.NewIrql = v_uint8()
        self.Processor = v_uint8()
        self._pad0010 = v_bytes(size=4)


class ARC_DISK_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DiskSignatures = LIST_ENTRY()


class SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlArea = v_ptr64()
        self.TotalNumberOfPtes = v_uint32()
        self.SegmentFlags = SEGMENT_FLAGS()
        self.NumberOfCommittedPages = v_uint64()
        self.SizeOfSegment = v_uint64()
        self.ExtendInfo = v_ptr64()
        self.SegmentLock = EX_PUSH_LOCK()
        self.u1 = _unnamed_22243()
        self.u2 = _unnamed_22244()
        self.PrototypePte = v_ptr64()
        self.ThePtes = vstruct.VArray([ MMPTE() for i in xrange(1) ])


class LUID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Luid = LUID()
        self.Attributes = v_uint32()


class _unnamed_18785(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class iobuf(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ptr = v_ptr64()
        self.cnt = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.base = v_ptr64()
        self.flag = v_uint32()
        self.file = v_uint32()
        self.charbuf = v_uint32()
        self.bufsiz = v_uint32()
        self.tmpfname = v_ptr64()


class IMAGE_NT_HEADERS64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.FileHeader = IMAGE_FILE_HEADER()
        self.OptionalHeader = IMAGE_OPTIONAL_HEADER64()


class PCW_COUNTER_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint16()
        self.StructIndex = v_uint16()
        self.Offset = v_uint16()
        self.Size = v_uint16()


class FIRMWARE_INFORMATION_LOADER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FirmwareTypeEfi = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.u = _unnamed_22031()


class _unnamed_21306(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_ptr64()
        self.Size = v_uint16()
        self.Version = v_uint16()
        self._pad0010 = v_bytes(size=4)
        self.Interface = v_ptr64()
        self.InterfaceSpecificData = v_ptr64()


class MMMOD_WRITER_MDL_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Links = LIST_ENTRY()
        self.u = _unnamed_22354()
        self.Irp = v_ptr64()
        self.u1 = _unnamed_22355()
        self.PagingFile = v_ptr64()
        self.File = v_ptr64()
        self.ControlArea = v_ptr64()
        self.FileResource = v_ptr64()
        self.WriteOffset = LARGE_INTEGER()
        self.IssueTime = LARGE_INTEGER()
        self.PointerMdl = v_ptr64()
        self.Mdl = MDL()
        self.Page = vstruct.VArray([ v_uint64() for i in xrange(1) ])


class CACHED_CHILD_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.ValueList = v_uint64()


class PCW_MASK_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CounterMask = v_uint64()
        self.InstanceMask = v_ptr64()
        self.InstanceId = v_uint32()
        self.CollectMultiple = v_uint8()
        self._pad0018 = v_bytes(size=3)
        self.Buffer = v_ptr64()
        self.CancelEvent = v_ptr64()


class KTHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.CycleTime = v_uint64()
        self.QuantumTarget = v_uint64()
        self.InitialStack = v_ptr64()
        self.StackLimit = v_ptr64()
        self.KernelStack = v_ptr64()
        self.ThreadLock = v_uint64()
        self.WaitRegister = KWAIT_STATUS_REGISTER()
        self.Running = v_uint8()
        self.Alerted = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.KernelStackResident = v_uint32()
        self.ApcState = KAPC_STATE()
        self.DeferredProcessor = v_uint32()
        self._pad0088 = v_bytes(size=4)
        self.ApcQueueLock = v_uint64()
        self.WaitStatus = v_uint64()
        self.WaitBlockList = v_ptr64()
        self.WaitListEntry = LIST_ENTRY()
        self.Queue = v_ptr64()
        self.Teb = v_ptr64()
        self.Timer = KTIMER()
        self.AutoAlignment = v_uint32()
        self.Spare0 = v_uint32()
        self.WaitBlock = vstruct.VArray([ KWAIT_BLOCK() for i in xrange(4) ])
        self.QueueListEntry = LIST_ENTRY()
        self.TrapFrame = v_ptr64()
        self.FirstArgument = v_ptr64()
        self.CallbackStack = v_ptr64()
        self.ApcStateIndex = v_uint8()
        self.BasePriority = v_uint8()
        self.PriorityDecrement = v_uint8()
        self.Preempted = v_uint8()
        self.AdjustReason = v_uint8()
        self.AdjustIncrement = v_uint8()
        self.PreviousMode = v_uint8()
        self.Saturation = v_uint8()
        self.SystemCallNumber = v_uint32()
        self.FreezeCount = v_uint32()
        self.UserAffinity = GROUP_AFFINITY()
        self.Process = v_ptr64()
        self.Affinity = GROUP_AFFINITY()
        self.IdealProcessor = v_uint32()
        self.UserIdealProcessor = v_uint32()
        self.ApcStatePointer = vstruct.VArray([ v_ptr64() for i in xrange(2) ])
        self.SavedApcState = KAPC_STATE()
        self.Win32Thread = v_ptr64()
        self.StackBase = v_ptr64()
        self.SuspendApc = KAPC()
        self.SuspendSemaphore = KSEMAPHORE()
        self.ThreadListEntry = LIST_ENTRY()
        self.MutantListHead = LIST_ENTRY()
        self.SListFaultAddress = v_ptr64()
        self.ReadOperationCount = v_uint64()
        self.WriteOperationCount = v_uint64()
        self.OtherOperationCount = v_uint64()
        self.ReadTransferCount = v_uint64()
        self.WriteTransferCount = v_uint64()
        self.OtherTransferCount = v_uint64()
        self.ThreadCounters = v_ptr64()
        self.XStateSave = v_ptr64()


class WMI_TRACE_PACKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.HookId = v_uint16()


class _unnamed_21966(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.I386 = I386_LOADER_BLOCK()


class ALPC_PORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PortListEntry = LIST_ENTRY()
        self.CommunicationInfo = v_ptr64()
        self.OwnerProcess = v_ptr64()
        self.CompletionPort = v_ptr64()
        self.CompletionKey = v_ptr64()
        self.CompletionPacketLookaside = v_ptr64()
        self.PortContext = v_ptr64()
        self.StaticSecurity = SECURITY_CLIENT_CONTEXT()
        self.MainQueue = LIST_ENTRY()
        self.PendingQueue = LIST_ENTRY()
        self.LargeMessageQueue = LIST_ENTRY()
        self.WaitQueue = LIST_ENTRY()
        self.Semaphore = v_ptr64()
        self.PortAttributes = ALPC_PORT_ATTRIBUTES()
        self.Lock = EX_PUSH_LOCK()
        self.ResourceListLock = EX_PUSH_LOCK()
        self.ResourceListHead = LIST_ENTRY()
        self.CompletionList = v_ptr64()
        self.MessageZone = v_ptr64()
        self.CallbackObject = v_ptr64()
        self.CallbackContext = v_ptr64()
        self.CanceledQueue = LIST_ENTRY()
        self.SequenceNo = v_uint32()
        self.u1 = _unnamed_24171()
        self.TargetQueuePort = v_ptr64()
        self.TargetSequencePort = v_ptr64()
        self.CachedMessage = v_ptr64()
        self.MainQueueLength = v_uint32()
        self.PendingQueueLength = v_uint32()
        self.LargeMessageQueueLength = v_uint32()
        self.CanceledQueueLength = v_uint32()
        self.WaitQueueLength = v_uint32()
        self._pad01a0 = v_bytes(size=4)


class _unnamed_22244(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImageInformation = v_ptr64()


class ADAPTER_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class PCAT_FIRMWARE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PlaceHolder = v_uint32()


class _unnamed_22243(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImageCommitment = v_uint64()


class _unnamed_25467(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsULONG = v_uint32()


class _unnamed_22363(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Balance = v_uint64()


class PROC_HISTORY_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Utility = v_uint16()
        self.Frequency = v_uint8()
        self.Reserved = v_uint8()


class CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P1Home = v_uint64()
        self.P2Home = v_uint64()
        self.P3Home = v_uint64()
        self.P4Home = v_uint64()
        self.P5Home = v_uint64()
        self.P6Home = v_uint64()
        self.ContextFlags = v_uint32()
        self.MxCsr = v_uint32()
        self.SegCs = v_uint16()
        self.SegDs = v_uint16()
        self.SegEs = v_uint16()
        self.SegFs = v_uint16()
        self.SegGs = v_uint16()
        self.SegSs = v_uint16()
        self.EFlags = v_uint32()
        self.Dr0 = v_uint64()
        self.Dr1 = v_uint64()
        self.Dr2 = v_uint64()
        self.Dr3 = v_uint64()
        self.Dr6 = v_uint64()
        self.Dr7 = v_uint64()
        self.Rax = v_uint64()
        self.Rcx = v_uint64()
        self.Rdx = v_uint64()
        self.Rbx = v_uint64()
        self.Rsp = v_uint64()
        self.Rbp = v_uint64()
        self.Rsi = v_uint64()
        self.Rdi = v_uint64()
        self.R8 = v_uint64()
        self.R9 = v_uint64()
        self.R10 = v_uint64()
        self.R11 = v_uint64()
        self.R12 = v_uint64()
        self.R13 = v_uint64()
        self.R14 = v_uint64()
        self.R15 = v_uint64()
        self.Rip = v_uint64()
        self.FltSave = XSAVE_FORMAT()
        self.VectorRegister = vstruct.VArray([ M128A() for i in xrange(26) ])
        self.VectorControl = v_uint64()
        self.DebugControl = v_uint64()
        self.LastBranchToRip = v_uint64()
        self.LastBranchFromRip = v_uint64()
        self.LastExceptionToRip = v_uint64()
        self.LastExceptionFromRip = v_uint64()


class MMSUBSECTION_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u = _unnamed_22448()
        self.StartingSector = v_uint32()
        self.NumberOfFullSectors = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.u1 = _unnamed_22464()
        self.LeftChild = v_ptr64()
        self.RightChild = v_ptr64()


class LOADER_PERFORMANCE_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartTime = v_uint64()
        self.EndTime = v_uint64()


class DBGKD_GET_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Unused = v_uint32()


class VACB_LEVEL_ALLOCATION_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VacbLevelList = LIST_ENTRY()
        self.VacbLevelWithBcbListHeads = v_ptr64()
        self.VacbLevelsAllocated = v_uint32()
        self._pad0020 = v_bytes(size=4)


class KTRANSACTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutcomeEvent = KEVENT()
        self.cookie = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.Mutex = KMUTANT()
        self.TreeTx = v_ptr64()
        self.GlobalNamespaceLink = KTMOBJECT_NAMESPACE_LINK()
        self.TmNamespaceLink = KTMOBJECT_NAMESPACE_LINK()
        self.UOW = GUID()
        self.State = v_uint32()
        self.Flags = v_uint32()
        self.EnlistmentHead = LIST_ENTRY()
        self.EnlistmentCount = v_uint32()
        self.RecoverableEnlistmentCount = v_uint32()
        self.PrePrepareRequiredEnlistmentCount = v_uint32()
        self.PrepareRequiredEnlistmentCount = v_uint32()
        self.OutcomeRequiredEnlistmentCount = v_uint32()
        self.PendingResponses = v_uint32()
        self.SuperiorEnlistment = v_ptr64()
        self.LastLsn = CLS_LSN()
        self.PromotedEntry = LIST_ENTRY()
        self.PromoterTransaction = v_ptr64()
        self.PromotePropagation = v_ptr64()
        self.IsolationLevel = v_uint32()
        self.IsolationFlags = v_uint32()
        self.Timeout = LARGE_INTEGER()
        self.Description = UNICODE_STRING()
        self.RollbackThread = v_ptr64()
        self.RollbackWorkItem = WORK_QUEUE_ITEM()
        self.RollbackDpc = KDPC()
        self.RollbackTimer = KTIMER()
        self.LsnOrderedEntry = LIST_ENTRY()
        self.Outcome = v_uint32()
        self._pad0200 = v_bytes(size=4)
        self.Tm = v_ptr64()
        self.CommitReservation = v_uint64()
        self.TransactionHistory = vstruct.VArray([ KTRANSACTION_HISTORY() for i in xrange(10) ])
        self.TransactionHistoryCount = v_uint32()
        self._pad0268 = v_bytes(size=4)
        self.DTCPrivateInformation = v_ptr64()
        self.DTCPrivateInformationLength = v_uint32()
        self._pad0278 = v_bytes(size=4)
        self.DTCPrivateInformationMutex = KMUTANT()
        self.PromotedTxSelfHandle = v_ptr64()
        self.PendingPromotionCount = v_uint32()
        self._pad02c0 = v_bytes(size=4)
        self.PromotionCompletedEvent = KEVENT()


class GENERIC_MAPPING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GenericRead = v_uint32()
        self.GenericWrite = v_uint32()
        self.GenericExecute = v_uint32()
        self.GenericAll = v_uint32()


class DEVICE_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Sibling = v_ptr64()
        self.Child = v_ptr64()
        self.Parent = v_ptr64()
        self.LastChild = v_ptr64()
        self.PhysicalDeviceObject = v_ptr64()
        self.InstancePath = UNICODE_STRING()
        self.ServiceName = UNICODE_STRING()
        self.PendingIrp = v_ptr64()
        self.Level = v_uint32()
        self._pad0058 = v_bytes(size=4)
        self.Notify = PO_DEVICE_NOTIFY()
        self.PoIrpManager = PO_IRP_MANAGER()
        self.State = v_uint32()
        self.PreviousState = v_uint32()
        self.StateHistory = vstruct.VArray([ PNP_DEVNODE_STATE() for i in xrange(20) ])
        self.StateHistoryEntry = v_uint32()
        self.CompletionStatus = v_uint32()
        self.Flags = v_uint32()
        self.UserFlags = v_uint32()
        self.Problem = v_uint32()
        self._pad0150 = v_bytes(size=4)
        self.ResourceList = v_ptr64()
        self.ResourceListTranslated = v_ptr64()
        self.DuplicatePDO = v_ptr64()
        self.ResourceRequirements = v_ptr64()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.ChildInterfaceType = v_uint32()
        self.ChildBusNumber = v_uint32()
        self.ChildBusTypeIndex = v_uint16()
        self.RemovalPolicy = v_uint8()
        self.HardwareRemovalPolicy = v_uint8()
        self._pad0188 = v_bytes(size=4)
        self.TargetDeviceNotify = LIST_ENTRY()
        self.DeviceArbiterList = LIST_ENTRY()
        self.DeviceTranslatorList = LIST_ENTRY()
        self.NoTranslatorMask = v_uint16()
        self.QueryTranslatorMask = v_uint16()
        self.NoArbiterMask = v_uint16()
        self.QueryArbiterMask = v_uint16()
        self.OverUsed1 = _unnamed_23139()
        self.OverUsed2 = _unnamed_23140()
        self.BootResources = v_ptr64()
        self.BootResourcesTranslated = v_ptr64()
        self.CapabilityFlags = v_uint32()
        self._pad01e8 = v_bytes(size=4)
        self.DockInfo = _unnamed_23141()
        self.DisableableDepends = v_uint32()
        self._pad0210 = v_bytes(size=4)
        self.PendedSetInterfaceState = LIST_ENTRY()
        self.LegacyBusListEntry = LIST_ENTRY()
        self.DriverUnloadRetryCount = v_uint32()
        self._pad0238 = v_bytes(size=4)
        self.PreviousParent = v_ptr64()
        self.DeletedChildren = v_uint32()
        self.NumaNodeIndex = v_uint32()
        self.ContainerID = GUID()
        self.OverrideFlags = v_uint8()
        self.RequiresUnloadedDriver = v_uint8()
        self._pad0260 = v_bytes(size=6)
        self.PendingEjectRelations = v_ptr64()


class KALPC_MESSAGE_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientContext = v_ptr64()
        self.ServerContext = v_ptr64()
        self.PortContext = v_ptr64()
        self.CancelPortContext = v_ptr64()
        self.SecurityData = v_ptr64()
        self.View = v_ptr64()
        self.HandleData = v_ptr64()


class IO_CLIENT_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextExtension = v_ptr64()
        self.ClientIdentificationAddress = v_ptr64()


class _unnamed_21018(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserApcRoutine = v_ptr64()
        self.UserApcContext = v_ptr64()


class PROC_PERF_LOAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BusyPercentage = v_uint8()
        self.FrequencyPercentage = v_uint8()


class _unnamed_26910(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = _unnamed_28620()


class PROCESSOR_PERFSTATE_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint32()
        self.MaxThrottle = v_uint8()
        self.MinThrottle = v_uint8()
        self.BusyAdjThreshold = v_uint8()
        self.Spare = v_uint8()
        self.TimeCheck = v_uint32()
        self.IncreaseTime = v_uint32()
        self.DecreaseTime = v_uint32()
        self.IncreasePercent = v_uint32()
        self.DecreasePercent = v_uint32()


class IO_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.Descriptors = vstruct.VArray([ IO_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class STACK_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumStackTraces = v_uint16()
        self.TraceCapacity = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.StackTrace = vstruct.VArray([ v_ptr64() for i in xrange(16) ])
        self.StackTableHash = vstruct.VArray([ v_uint16() for i in xrange(16381) ])
        self._pad8088 = v_bytes(size=6)


class OBJECT_REF_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ObjectHeader = v_ptr64()
        self.NextRef = v_ptr64()
        self.ImageFileName = vstruct.VArray([ v_uint8() for i in xrange(16) ])
        self.NextPos = v_uint16()
        self.MaxStacks = v_uint16()
        self.StackInfo = vstruct.VArray([ OBJECT_REF_STACK_INFO() for i in xrange(0) ])
        self._pad0028 = v_bytes(size=4)


class OBJECT_HEADER_HANDLE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleCountDataBase = v_ptr64()
        self._pad0010 = v_bytes(size=8)


class ETW_LOGGER_HANDLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DereferenceAndLeave = v_uint8()


class IMAGE_ROM_OPTIONAL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint16()
        self.MajorLinkerVersion = v_uint8()
        self.MinorLinkerVersion = v_uint8()
        self.SizeOfCode = v_uint32()
        self.SizeOfInitializedData = v_uint32()
        self.SizeOfUninitializedData = v_uint32()
        self.AddressOfEntryPoint = v_uint32()
        self.BaseOfCode = v_uint32()
        self.BaseOfData = v_uint32()
        self.BaseOfBss = v_uint32()
        self.GprMask = v_uint32()
        self.CprMask = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.GpValue = v_uint32()


class SYSTEM_POWER_STATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved1 = v_uint32()


class _unnamed_25217(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FilePointerIndex = v_uint32()


class OBJECT_REF_STACK_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Sequence = v_uint32()
        self.Index = v_uint16()
        self.NumTraces = v_uint16()
        self.Tag = v_uint32()


class PF_KERNEL_GLOBALS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AccessBufferAgeThreshold = v_uint64()
        self.AccessBufferRef = EX_RUNDOWN_REF()
        self.AccessBufferExistsEvent = KEVENT()
        self.AccessBufferMax = v_uint32()
        self._pad0040 = v_bytes(size=20)
        self.AccessBufferList = SLIST_HEADER()
        self.StreamSequenceNumber = v_uint32()
        self.Flags = v_uint32()
        self.ScenarioPrefetchCount = v_uint32()
        self._pad0060 = v_bytes(size=4)


class _unnamed_24209(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24211()


class DBGKD_QUERY_SPECIAL_CALLS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumberOfSpecialCalls = v_uint32()


class _unnamed_25218(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FilePointerIndex = v_uint32()


class DBGKD_READ_MEMORY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TargetBaseAddress = v_uint64()
        self.TransferCount = v_uint32()
        self.ActualBytesRead = v_uint32()


class MI_SYSTEM_PTE_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Bitmap = RTL_BITMAP()
        self.Flags = v_uint32()
        self.Hint = v_uint32()
        self.BasePte = v_ptr64()
        self.FailureCount = v_ptr64()
        self.Vm = v_ptr64()
        self.TotalSystemPtes = v_uint32()
        self.TotalFreeSystemPtes = v_uint32()
        self.CachedPteCount = v_uint32()
        self.PteFailures = v_uint32()
        self.SpinLock = v_uint64()


class KEXCEPTION_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P1Home = v_uint64()
        self.P2Home = v_uint64()
        self.P3Home = v_uint64()
        self.P4Home = v_uint64()
        self.P5 = v_uint64()
        self.InitialStack = v_uint64()
        self.Xmm6 = M128A()
        self.Xmm7 = M128A()
        self.Xmm8 = M128A()
        self.Xmm9 = M128A()
        self.Xmm10 = M128A()
        self.Xmm11 = M128A()
        self.Xmm12 = M128A()
        self.Xmm13 = M128A()
        self.Xmm14 = M128A()
        self.Xmm15 = M128A()
        self.TrapFrame = v_uint64()
        self.CallbackStack = v_uint64()
        self.OutputBuffer = v_uint64()
        self.OutputLength = v_uint64()
        self.MxCsr = v_uint64()
        self.Rbp = v_uint64()
        self.Rbx = v_uint64()
        self.Rdi = v_uint64()
        self.Rsi = v_uint64()
        self.R12 = v_uint64()
        self.R13 = v_uint64()
        self.R14 = v_uint64()
        self.R15 = v_uint64()
        self.Return = v_uint64()


class KALPC_HANDLE_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.ObjectType = v_uint32()
        self.DuplicateContext = v_ptr64()


class PO_MEMORY_IMAGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.ImageType = v_uint32()
        self.CheckSum = v_uint32()
        self.LengthSelf = v_uint32()
        self.PageSelf = v_uint64()
        self.PageSize = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.SystemTime = LARGE_INTEGER()
        self.InterruptTime = v_uint64()
        self.FeatureFlags = v_uint32()
        self.HiberFlags = v_uint8()
        self.spare = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.NoHiberPtes = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.HiberVa = v_uint64()
        self.HiberPte = LARGE_INTEGER()
        self.NoFreePages = v_uint32()
        self.FreeMapCheck = v_uint32()
        self.WakeCheck = v_uint32()
        self._pad0060 = v_bytes(size=4)
        self.FirstTablePage = v_uint64()
        self.PerfInfo = PO_HIBER_PERF()
        self.FirmwareRuntimeInformationPages = v_uint32()
        self._pad00c8 = v_bytes(size=4)
        self.FirmwareRuntimeInformation = vstruct.VArray([ v_uint64() for i in xrange(1) ])
        self.NoBootLoaderLogPages = v_uint32()
        self._pad00d8 = v_bytes(size=4)
        self.BootLoaderLogPages = vstruct.VArray([ v_uint64() for i in xrange(8) ])
        self.NotUsed = v_uint32()
        self.ResumeContextCheck = v_uint32()
        self.ResumeContextPages = v_uint32()
        self._pad0128 = v_bytes(size=4)


class LOOKASIDE_LIST_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE_POOL()


class ACTIVATION_CONTEXT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class EVENT_DATA_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Ptr = v_uint64()
        self.Size = v_uint32()
        self.Reserved = v_uint32()


class HHIVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.GetCellRoutine = v_ptr64()
        self.ReleaseCellRoutine = v_ptr64()
        self.Allocate = v_ptr64()
        self.Free = v_ptr64()
        self.FileSetSize = v_ptr64()
        self.FileWrite = v_ptr64()
        self.FileRead = v_ptr64()
        self.FileFlush = v_ptr64()
        self.HiveLoadFailure = v_ptr64()
        self.BaseBlock = v_ptr64()
        self.DirtyVector = RTL_BITMAP()
        self.DirtyCount = v_uint32()
        self.DirtyAlloc = v_uint32()
        self.BaseBlockAlloc = v_uint32()
        self.Cluster = v_uint32()
        self.Flat = v_uint8()
        self.ReadOnly = v_uint8()
        self.DirtyFlag = v_uint8()
        self._pad007c = v_bytes(size=1)
        self.HvBinHeadersUse = v_uint32()
        self.HvFreeCellsUse = v_uint32()
        self.HvUsedCellsUse = v_uint32()
        self.CmUsedCellsUse = v_uint32()
        self.HiveFlags = v_uint32()
        self.CurrentLog = v_uint32()
        self.LogSize = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.RefreshCount = v_uint32()
        self.StorageTypeCount = v_uint32()
        self.Version = v_uint32()
        self.Storage = vstruct.VArray([ DUAL() for i in xrange(2) ])


class VF_AVL_TREE_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.p = v_ptr64()
        self.RangeSize = v_uint64()


class IO_DRIVER_CREATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=6)
        self.ExtraCreateParameter = v_ptr64()
        self.DeviceObjectHint = v_ptr64()
        self.TxnParameters = v_ptr64()


class TEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.EnvironmentPointer = v_ptr64()
        self.ClientId = CLIENT_ID()
        self.ActiveRpcHandle = v_ptr64()
        self.ThreadLocalStoragePointer = v_ptr64()
        self.ProcessEnvironmentBlock = v_ptr64()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_ptr64()
        self.Win32ThreadInfo = v_ptr64()
        self.User32Reserved = vstruct.VArray([ v_uint32() for i in xrange(26) ])
        self.UserReserved = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self._pad0100 = v_bytes(size=4)
        self.WOW32Reserved = v_ptr64()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()
        self.SystemReserved1 = vstruct.VArray([ v_ptr64() for i in xrange(54) ])
        self.ExceptionCode = v_uint32()
        self._pad02c8 = v_bytes(size=4)
        self.ActivationContextStackPointer = v_ptr64()
        self.SpareBytes = vstruct.VArray([ v_uint8() for i in xrange(24) ])
        self.TxFsContext = v_uint32()
        self._pad02f0 = v_bytes(size=4)
        self.GdiTebBatch = GDI_TEB_BATCH()
        self.RealClientId = CLIENT_ID()
        self.GdiCachedProcessHandle = v_ptr64()
        self.GdiClientPID = v_uint32()
        self.GdiClientTID = v_uint32()
        self.GdiThreadLocalInfo = v_ptr64()
        self.Win32ClientInfo = vstruct.VArray([ v_uint64() for i in xrange(62) ])
        self.glDispatchTable = vstruct.VArray([ v_ptr64() for i in xrange(233) ])
        self.glReserved1 = vstruct.VArray([ v_uint64() for i in xrange(29) ])
        self.glReserved2 = v_ptr64()
        self.glSectionInfo = v_ptr64()
        self.glSection = v_ptr64()
        self.glTable = v_ptr64()
        self.glCurrentRC = v_ptr64()
        self.glContext = v_ptr64()
        self.LastStatusValue = v_uint32()
        self._pad1258 = v_bytes(size=4)
        self.StaticUnicodeString = UNICODE_STRING()
        self.StaticUnicodeBuffer = vstruct.VArray([ v_uint16() for i in xrange(261) ])
        self._pad1478 = v_bytes(size=6)
        self.DeallocationStack = v_ptr64()
        self.TlsSlots = vstruct.VArray([ v_ptr64() for i in xrange(64) ])
        self.TlsLinks = LIST_ENTRY()
        self.Vdm = v_ptr64()
        self.ReservedForNtRpc = v_ptr64()
        self.DbgSsReserved = vstruct.VArray([ v_ptr64() for i in xrange(2) ])
        self.HardErrorMode = v_uint32()
        self._pad16b8 = v_bytes(size=4)
        self.Instrumentation = vstruct.VArray([ v_ptr64() for i in xrange(11) ])
        self.ActivityId = GUID()
        self.SubProcessTag = v_ptr64()
        self.EtwLocalData = v_ptr64()
        self.EtwTraceData = v_ptr64()
        self.WinSockData = v_ptr64()
        self.GdiBatchCount = v_uint32()
        self.CurrentIdealProcessor = PROCESSOR_NUMBER()
        self.GuaranteedStackBytes = v_uint32()
        self._pad1750 = v_bytes(size=4)
        self.ReservedForPerf = v_ptr64()
        self.ReservedForOle = v_ptr64()
        self.WaitingOnLoaderLock = v_uint32()
        self._pad1768 = v_bytes(size=4)
        self.SavedPriorityState = v_ptr64()
        self.SoftPatchPtr1 = v_uint64()
        self.ThreadPoolData = v_ptr64()
        self.TlsExpansionSlots = v_ptr64()
        self.DeallocationBStore = v_ptr64()
        self.BStoreLimit = v_ptr64()
        self.MuiGeneration = v_uint32()
        self.IsImpersonating = v_uint32()
        self.NlsCache = v_ptr64()
        self.pShimData = v_ptr64()
        self.HeapVirtualAffinity = v_uint32()
        self._pad17b8 = v_bytes(size=4)
        self.CurrentTransactionHandle = v_ptr64()
        self.ActiveFrame = v_ptr64()
        self.FlsData = v_ptr64()
        self.PreferredLanguages = v_ptr64()
        self.UserPrefLanguages = v_ptr64()
        self.MergedPrefLanguages = v_ptr64()
        self.MuiImpersonation = v_uint32()
        self.CrossTebFlags = v_uint16()
        self.SameTebFlags = v_uint16()
        self.TxnScopeEnterCallback = v_ptr64()
        self.TxnScopeExitCallback = v_ptr64()
        self.TxnScopeContext = v_ptr64()
        self.LockCount = v_uint32()
        self.SpareUlong0 = v_uint32()
        self.ResourceRetValue = v_ptr64()


class CLIENT_ID64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_uint64()
        self.UniqueThread = v_uint64()


class IA64_LOADER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PlaceHolder = v_uint32()


class OBJECT_SYMBOLIC_LINK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LinkTarget = UNICODE_STRING()
        self.DosDeviceDriveIndex = v_uint32()
        self._pad0020 = v_bytes(size=4)


class HEAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.SegmentSignature = v_uint32()
        self.SegmentFlags = v_uint32()
        self.SegmentListEntry = LIST_ENTRY()
        self.Heap = v_ptr64()
        self.BaseAddress = v_ptr64()
        self.NumberOfPages = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.FirstEntry = v_ptr64()
        self.LastValidEntry = v_ptr64()
        self.NumberOfUnCommittedPages = v_uint32()
        self.NumberOfUnCommittedRanges = v_uint32()
        self.SegmentAllocatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self._pad0060 = v_bytes(size=4)
        self.UCRSegmentList = LIST_ENTRY()
        self.Flags = v_uint32()
        self.ForceFlags = v_uint32()
        self.CompatibilityFlags = v_uint32()
        self.EncodeFlagMask = v_uint32()
        self.Encoding = HEAP_ENTRY()
        self.PointerKey = v_uint64()
        self.Interceptor = v_uint32()
        self.VirtualMemoryThreshold = v_uint32()
        self.Signature = v_uint32()
        self._pad00a8 = v_bytes(size=4)
        self.SegmentReserve = v_uint64()
        self.SegmentCommit = v_uint64()
        self.DeCommitFreeBlockThreshold = v_uint64()
        self.DeCommitTotalFreeThreshold = v_uint64()
        self.TotalFreeSize = v_uint64()
        self.MaximumAllocationSize = v_uint64()
        self.ProcessHeapsListIndex = v_uint16()
        self.HeaderValidateLength = v_uint16()
        self._pad00e0 = v_bytes(size=4)
        self.HeaderValidateCopy = v_ptr64()
        self.NextAvailableTagIndex = v_uint16()
        self.MaximumTagIndex = v_uint16()
        self._pad00f0 = v_bytes(size=4)
        self.TagEntries = v_ptr64()
        self.UCRList = LIST_ENTRY()
        self.AlignRound = v_uint64()
        self.AlignMask = v_uint64()
        self.VirtualAllocdBlocks = LIST_ENTRY()
        self.SegmentList = LIST_ENTRY()
        self.AllocatorBackTraceIndex = v_uint16()
        self._pad013c = v_bytes(size=2)
        self.NonDedicatedListLength = v_uint32()
        self.BlocksIndex = v_ptr64()
        self.UCRIndex = v_ptr64()
        self.PseudoTagEntries = v_ptr64()
        self.FreeLists = LIST_ENTRY()
        self.LockVariable = v_ptr64()
        self.CommitRoutine = v_ptr64()
        self.FrontEndHeap = v_ptr64()
        self.FrontHeapLockCount = v_uint16()
        self.FrontEndHeapType = v_uint8()
        self._pad0188 = v_bytes(size=5)
        self.Counters = HEAP_COUNTERS()
        self.TuningParameters = HEAP_TUNING_PARAMETERS()


class EJOB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Event = KEVENT()
        self.JobLinks = LIST_ENTRY()
        self.ProcessListHead = LIST_ENTRY()
        self.JobLock = ERESOURCE()
        self.TotalUserTime = LARGE_INTEGER()
        self.TotalKernelTime = LARGE_INTEGER()
        self.ThisPeriodTotalUserTime = LARGE_INTEGER()
        self.ThisPeriodTotalKernelTime = LARGE_INTEGER()
        self.TotalPageFaultCount = v_uint32()
        self.TotalProcesses = v_uint32()
        self.ActiveProcesses = v_uint32()
        self.TotalTerminatedProcesses = v_uint32()
        self.PerProcessUserTimeLimit = LARGE_INTEGER()
        self.PerJobUserTimeLimit = LARGE_INTEGER()
        self.MinimumWorkingSetSize = v_uint64()
        self.MaximumWorkingSetSize = v_uint64()
        self.LimitFlags = v_uint32()
        self.ActiveProcessLimit = v_uint32()
        self.Affinity = KAFFINITY_EX()
        self.PriorityClass = v_uint8()
        self._pad0128 = v_bytes(size=7)
        self.AccessState = v_ptr64()
        self.UIRestrictionsClass = v_uint32()
        self.EndOfJobTimeAction = v_uint32()
        self.CompletionPort = v_ptr64()
        self.CompletionKey = v_ptr64()
        self.SessionId = v_uint32()
        self.SchedulingClass = v_uint32()
        self.ReadOperationCount = v_uint64()
        self.WriteOperationCount = v_uint64()
        self.OtherOperationCount = v_uint64()
        self.ReadTransferCount = v_uint64()
        self.WriteTransferCount = v_uint64()
        self.OtherTransferCount = v_uint64()
        self.ProcessMemoryLimit = v_uint64()
        self.JobMemoryLimit = v_uint64()
        self.PeakProcessMemoryUsed = v_uint64()
        self.PeakJobMemoryUsed = v_uint64()
        self.CurrentJobMemoryUsed = v_uint64()
        self.MemoryLimitsLock = EX_PUSH_LOCK()
        self.JobSetLinks = LIST_ENTRY()
        self.MemberLevel = v_uint32()
        self.JobFlags = v_uint32()


class PROCESSOR_IDLESTATE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TimeCheck = v_uint32()
        self.DemotePercent = v_uint8()
        self.PromotePercent = v_uint8()
        self.Spare = vstruct.VArray([ v_uint8() for i in xrange(2) ])


class EFI_FIRMWARE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FirmwareVersion = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.VirtualEfiRuntimeServices = v_ptr64()
        self.SetVirtualAddressMapStatus = v_uint32()
        self.MissedMappingsCount = v_uint32()


class DBGKD_READ_WRITE_IO_EXTENDED64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.AddressSpace = v_uint32()
        self.IoAddress = v_uint64()
        self.DataValue = v_uint32()
        self._pad0020 = v_bytes(size=4)


class _unnamed_18772(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = SINGLE_LIST_ENTRY()
        self.Packet = v_ptr64()
        self.Lookaside = v_ptr64()


class HANDLE_TRACE_DEBUG_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RefCount = v_uint32()
        self.TableSize = v_uint32()
        self.BitMaskFlags = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.CloseCompactionLock = FAST_MUTEX()
        self.CurrentStackIndex = v_uint32()
        self._pad0050 = v_bytes(size=4)
        self.TraceDb = vstruct.VArray([ HANDLE_TRACE_DB_ENTRY() for i in xrange(1) ])


class _unnamed_27317(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length48 = v_uint32()


class KPROCESSOR_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SpecialRegisters = KSPECIAL_REGISTERS()
        self._pad00e0 = v_bytes(size=8)
        self.ContextFrame = CONTEXT()


class OBJECT_HEADER_NAME_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Directory = v_ptr64()
        self.Name = UNICODE_STRING()
        self.ReferenceCount = v_uint32()
        self._pad0020 = v_bytes(size=4)


class _unnamed_27310(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class KAPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.SpareByte0 = v_uint8()
        self.Size = v_uint8()
        self.SpareByte1 = v_uint8()
        self.SpareLong0 = v_uint32()
        self.Thread = v_ptr64()
        self.ApcListEntry = LIST_ENTRY()
        self.KernelRoutine = v_ptr64()
        self.RundownRoutine = v_ptr64()
        self.NormalRoutine = v_ptr64()
        self.NormalContext = v_ptr64()
        self.SystemArgument1 = v_ptr64()
        self.SystemArgument2 = v_ptr64()
        self.ApcStateIndex = v_uint8()
        self.ApcMode = v_uint8()
        self.Inserted = v_uint8()
        self._pad0058 = v_bytes(size=5)


class ETW_BUFFER_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProcessorNumber = v_uint8()
        self.Alignment = v_uint8()
        self.LoggerId = v_uint16()


class POOL_TRACKER_BIG_PAGES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Va = v_ptr64()
        self.Key = v_uint32()
        self.PoolType = v_uint32()
        self.NumberOfBytes = v_uint64()


class _unnamed_21130(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr64()
        self.Options = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self._pad0018 = v_bytes(size=4)
        self.Parameters = v_ptr64()


class SID_IDENTIFIER_AUTHORITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Value = vstruct.VArray([ v_uint8() for i in xrange(6) ])


class RTL_RANGE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = LIST_ENTRY()
        self.Flags = v_uint32()
        self.Count = v_uint32()
        self.Stamp = v_uint32()
        self._pad0020 = v_bytes(size=4)


class _unnamed_24045(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s2 = _unnamed_24051()


class DRIVER_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DeviceObject = v_ptr64()
        self.Flags = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.DriverStart = v_ptr64()
        self.DriverSize = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.DriverSection = v_ptr64()
        self.DriverExtension = v_ptr64()
        self.DriverName = UNICODE_STRING()
        self.HardwareDatabase = v_ptr64()
        self.FastIoDispatch = v_ptr64()
        self.DriverInit = v_ptr64()
        self.DriverStartIo = v_ptr64()
        self.DriverUnload = v_ptr64()
        self.MajorFunction = vstruct.VArray([ v_ptr64() for i in xrange(28) ])


class VI_POOL_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PageHeader = VI_POOL_PAGE_HEADER()
        self._pad0020 = v_bytes(size=8)


class POOL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousSize = v_uint32()
        self.PoolTag = v_uint32()
        self.ProcessBilled = v_ptr64()


class SHARED_CACHE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self.NodeByteSize = v_uint16()
        self.OpenCount = v_uint32()
        self.FileSize = LARGE_INTEGER()
        self.BcbList = LIST_ENTRY()
        self.SectionSize = LARGE_INTEGER()
        self.ValidDataLength = LARGE_INTEGER()
        self.ValidDataGoal = LARGE_INTEGER()
        self.InitialVacbs = vstruct.VArray([ v_ptr64() for i in xrange(4) ])
        self.Vacbs = v_ptr64()
        self.FileObjectFastRef = EX_FAST_REF()
        self.VacbLock = EX_PUSH_LOCK()
        self.DirtyPages = v_uint32()
        self._pad0078 = v_bytes(size=4)
        self.LoggedStreamLinks = LIST_ENTRY()
        self.SharedCacheMapLinks = LIST_ENTRY()
        self.Flags = v_uint32()
        self.Status = v_uint32()
        self.Mbcb = v_ptr64()
        self.Section = v_ptr64()
        self.CreateEvent = v_ptr64()
        self.WaitOnActiveCount = v_ptr64()
        self.PagesToWrite = v_uint32()
        self._pad00c8 = v_bytes(size=4)
        self.BeyondLastFlush = v_uint64()
        self.Callbacks = v_ptr64()
        self.LazyWriteContext = v_ptr64()
        self.PrivateList = LIST_ENTRY()
        self.LogHandle = v_ptr64()
        self.FlushToLsnRoutine = v_ptr64()
        self.DirtyPageThreshold = v_uint32()
        self.LazyWritePassCount = v_uint32()
        self.UninitializeEvent = v_ptr64()
        self.BcbLock = KGUARDED_MUTEX()
        self.LastUnmapBehindOffset = LARGE_INTEGER()
        self.Event = KEVENT()
        self.HighWaterMappingOffset = LARGE_INTEGER()
        self.PrivateCacheMap = PRIVATE_CACHE_MAP()
        self.WriteBehindWorkQueueEntry = v_ptr64()
        self.VolumeCacheMap = v_ptr64()
        self.ProcImagePathHash = v_uint32()
        self.WritesInProgress = v_uint32()
        self.PipelinedReadAheadSize = v_uint32()
        self._pad01f8 = v_bytes(size=4)


class XSAVE_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint16()
        self.StatusWord = v_uint16()
        self.TagWord = v_uint8()
        self.Reserved1 = v_uint8()
        self.ErrorOpcode = v_uint16()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint16()
        self.Reserved2 = v_uint16()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint16()
        self.Reserved3 = v_uint16()
        self.MxCsr = v_uint32()
        self.MxCsr_Mask = v_uint32()
        self.FloatRegisters = vstruct.VArray([ M128A() for i in xrange(8) ])
        self.XmmRegisters = vstruct.VArray([ M128A() for i in xrange(16) ])
        self.Reserved4 = vstruct.VArray([ v_uint8() for i in xrange(96) ])


class REMOTE_PORT_VIEW(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.ViewSize = v_uint64()
        self.ViewBase = v_ptr64()


class IO_MINI_COMPLETION_PACKET_USER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.PacketType = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.KeyContext = v_ptr64()
        self.ApcContext = v_ptr64()
        self.IoStatus = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.IoStatusInformation = v_uint64()
        self.MiniPacketCallback = v_ptr64()
        self.Context = v_ptr64()
        self.Allocated = v_uint8()
        self._pad0050 = v_bytes(size=7)


class XSTATE_FEATURE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.Size = v_uint32()


class KALPC_VIEW(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ViewListEntry = LIST_ENTRY()
        self.Region = v_ptr64()
        self.OwnerPort = v_ptr64()
        self.OwnerProcess = v_ptr64()
        self.Address = v_ptr64()
        self.Size = v_uint64()
        self.SecureViewHandle = v_ptr64()
        self.WriteAccessHandle = v_ptr64()
        self.u1 = _unnamed_24209()
        self.NumberOfOwnerMessages = v_uint32()
        self.ProcessViewListEntry = LIST_ENTRY()


class LOADER_PARAMETER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OsMajorVersion = v_uint32()
        self.OsMinorVersion = v_uint32()
        self.Size = v_uint32()
        self.Reserved = v_uint32()
        self.LoadOrderListHead = LIST_ENTRY()
        self.MemoryDescriptorListHead = LIST_ENTRY()
        self.BootDriverListHead = LIST_ENTRY()
        self.KernelStack = v_uint64()
        self.Prcb = v_uint64()
        self.Process = v_uint64()
        self.Thread = v_uint64()
        self.RegistryLength = v_uint32()
        self._pad0068 = v_bytes(size=4)
        self.RegistryBase = v_ptr64()
        self.ConfigurationRoot = v_ptr64()
        self.ArcBootDeviceName = v_ptr64()
        self.ArcHalDeviceName = v_ptr64()
        self.NtBootPathName = v_ptr64()
        self.NtHalPathName = v_ptr64()
        self.LoadOptions = v_ptr64()
        self.NlsData = v_ptr64()
        self.ArcDiskInformation = v_ptr64()
        self.OemFontFile = v_ptr64()
        self.Extension = v_ptr64()
        self.u = _unnamed_21966()
        self.FirmwareInformation = FIRMWARE_INFORMATION_LOADER_BLOCK()


class KAFFINITY_ENUMERATION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Affinity = v_ptr64()
        self.CurrentMask = v_uint64()
        self.CurrentIndex = v_uint16()
        self._pad0018 = v_bytes(size=6)


class MI_VERIFIER_POOL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VerifierPoolEntry = v_ptr64()


class WHEA_TIMESTAMP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Seconds = v_uint64()


class ACTIVATION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class TRACE_ENABLE_CONTEXT_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LoggerId = v_uint16()
        self.Level = v_uint8()
        self.InternalFlag = v_uint8()
        self.EnableFlags = v_uint32()
        self.EnableFlagsHigh = v_uint32()
        self.Reserved = v_uint32()


class ETW_REF_CLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartTime = LARGE_INTEGER()
        self.StartPerfClock = LARGE_INTEGER()


class _unnamed_21297(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()


class RTL_CRITICAL_SECTION_DEBUG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.CriticalSection = v_ptr64()
        self.ProcessLocksList = LIST_ENTRY()
        self.EntryCount = v_uint32()
        self.ContentionCount = v_uint32()
        self.Flags = v_uint32()
        self.CreatorBackTraceIndexHigh = v_uint16()
        self.SpareUSHORT = v_uint16()


class PNP_DEVICE_EVENT_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.Argument = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.CallerEvent = v_ptr64()
        self.Callback = v_ptr64()
        self.Context = v_ptr64()
        self.VetoType = v_ptr64()
        self.VetoName = v_ptr64()
        self.Data = PLUGPLAY_EVENT_BLOCK()


class ARBITER_CONFLICT_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwningObject = v_ptr64()
        self.Start = v_uint64()
        self.End = v_uint64()


class SHARED_CACHE_MAP_LIST_CURSOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SharedCacheMapLinks = LIST_ENTRY()
        self.Flags = v_uint32()
        self._pad0018 = v_bytes(size=4)


class ETW_SESSION_PERF_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BufferMemoryPagedPool = v_uint32()
        self.BufferMemoryNonPagedPool = v_uint32()
        self.EventsLoggedCount = v_uint64()
        self.EventsLost = v_uint32()
        self.NumConsumers = v_uint32()


class PHYSICAL_MEMORY_RUN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BasePage = v_uint64()
        self.PageCount = v_uint64()


class MMVAD_FLAGS3(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreferredNode = v_uint64()


class MMVAD_FLAGS2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileOffset = v_uint32()


class ARBITER_BOOT_ALLOCATION_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ArbitrationList = v_ptr64()


class TOKEN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TokenSource = TOKEN_SOURCE()
        self.TokenId = LUID()
        self.AuthenticationId = LUID()
        self.ParentTokenId = LUID()
        self.ExpirationTime = LARGE_INTEGER()
        self.TokenLock = v_ptr64()
        self.ModifiedId = LUID()
        self.Privileges = SEP_TOKEN_PRIVILEGES()
        self.AuditPolicy = SEP_AUDIT_POLICY()
        self.SessionId = v_uint32()
        self.UserAndGroupCount = v_uint32()
        self.RestrictedSidCount = v_uint32()
        self.VariableLength = v_uint32()
        self.DynamicCharged = v_uint32()
        self.DynamicAvailable = v_uint32()
        self.DefaultOwnerIndex = v_uint32()
        self.UserAndGroups = v_ptr64()
        self.RestrictedSids = v_ptr64()
        self.PrimaryGroup = v_ptr64()
        self.DynamicPart = v_ptr64()
        self.DefaultDacl = v_ptr64()
        self.TokenType = v_uint32()
        self.ImpersonationLevel = v_uint32()
        self.TokenFlags = v_uint32()
        self.TokenInUse = v_uint8()
        self._pad00c8 = v_bytes(size=3)
        self.IntegrityLevelIndex = v_uint32()
        self.MandatoryPolicy = v_uint32()
        self.LogonSession = v_ptr64()
        self.OriginatingLogonSession = LUID()
        self.SidHash = SID_AND_ATTRIBUTES_HASH()
        self.RestrictedSidHash = SID_AND_ATTRIBUTES_HASH()
        self.pSecurityAttributes = v_ptr64()
        self.VariablePart = v_uint64()


class _unnamed_23415(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReadMemory = DBGKD_READ_MEMORY64()
        self._pad0028 = v_bytes(size=24)


class DISPATCHER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.TimerControlFlags = v_uint8()
        self.ThreadControlFlags = v_uint8()
        self.TimerMiscFlags = v_uint8()
        self.SignalState = v_uint32()
        self.WaitListHead = LIST_ENTRY()


class PROCESSOR_IDLESTATE_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint16()
        self.Flags = _unnamed_28582()
        self.PolicyCount = v_uint32()
        self.Policy = vstruct.VArray([ PROCESSOR_IDLESTATE_INFO() for i in xrange(3) ])


class _unnamed_26681(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumVector = v_uint32()
        self.MaximumVector = v_uint32()
        self.AffinityPolicy = v_uint16()
        self.Group = v_uint16()
        self.PriorityPolicy = v_uint32()
        self.TargetedProcessors = v_uint64()


class DBGKD_READ_WRITE_IO64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoAddress = v_uint64()
        self.DataSize = v_uint32()
        self.DataValue = v_uint32()


class ASSEMBLY_STORAGE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_26702(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length40 = v_uint32()
        self.Alignment40 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class _unnamed_19310(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMiddle = v_uint32()


class PROCESSOR_POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleStates = v_ptr64()
        self.IdleTimeLast = v_uint64()
        self.IdleTimeTotal = v_uint64()
        self.IdleTimeEntry = v_uint64()
        self.IdleAccounting = v_ptr64()
        self.Hypervisor = v_uint32()
        self.PerfHistoryTotal = v_uint32()
        self.ThermalConstraint = v_uint8()
        self.PerfHistoryCount = v_uint8()
        self.PerfHistorySlot = v_uint8()
        self.Reserved = v_uint8()
        self.LastSysTime = v_uint32()
        self.WmiDispatchPtr = v_uint64()
        self.WmiInterfaceEnabled = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.FFHThrottleStateInfo = PPM_FFH_THROTTLE_STATE_INFO()
        self.PerfActionDpc = KDPC()
        self.PerfActionMask = v_uint32()
        self._pad00b0 = v_bytes(size=4)
        self.IdleCheck = PROC_IDLE_SNAP()
        self.PerfCheck = PROC_IDLE_SNAP()
        self.Domain = v_ptr64()
        self.PerfConstraint = v_ptr64()
        self.Load = v_ptr64()
        self.PerfHistory = v_ptr64()
        self.Utility = v_uint32()
        self.OverUtilizedHistory = v_uint32()
        self.AffinityCount = v_uint32()
        self.AffinityHistory = v_uint32()


class TP_TASK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callbacks = v_ptr64()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()
        self._pad0010 = v_bytes(size=3)
        self.PostGuard = TP_NBQ_GUARD()
        self.NBQNode = v_ptr64()


class SECURITY_CLIENT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityQos = SECURITY_QUALITY_OF_SERVICE()
        self._pad0010 = v_bytes(size=4)
        self.ClientToken = v_ptr64()
        self.DirectlyAccessClientToken = v_uint8()
        self.DirectAccessEffectiveOnly = v_uint8()
        self.ServerIsRemote = v_uint8()
        self._pad001c = v_bytes(size=1)
        self.ClientTokenControl = TOKEN_CONTROL()
        self._pad0048 = v_bytes(size=4)


class _unnamed_21348(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Capabilities = v_ptr64()


class SID_AND_ATTRIBUTES_HASH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SidCount = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.SidAttr = v_ptr64()
        self.Hash = vstruct.VArray([ v_uint64() for i in xrange(32) ])


class DBGKD_MANIPULATE_STATE64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ApiNumber = v_uint32()
        self.ProcessorLevel = v_uint16()
        self.Processor = v_uint16()
        self.ReturnStatus = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.u = _unnamed_23415()


class _unnamed_26707(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length48 = v_uint32()
        self.Alignment48 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class LPCP_PORT_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NonPagedPortQueue = v_ptr64()
        self.Semaphore = v_ptr64()
        self.ReceiveHead = LIST_ENTRY()


class PHYSICAL_MEMORY_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumberOfRuns = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.NumberOfPages = v_uint64()
        self.Run = vstruct.VArray([ PHYSICAL_MEMORY_RUN() for i in xrange(1) ])


class MMWSLE_FREE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MustBeZero = v_uint64()


class MMBANKED_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BasePhysicalPage = v_uint64()
        self.BasedPte = v_ptr64()
        self.BankSize = v_uint32()
        self.BankShift = v_uint32()
        self.BankedRoutine = v_ptr64()
        self.Context = v_ptr64()
        self.CurrentMappedPte = v_ptr64()
        self.BankTemplate = vstruct.VArray([ MMPTE() for i in xrange(1) ])


class JOB_ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class DEVICE_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Failed = v_uint32()


class SECURITY_QUALITY_OF_SERVICE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.ImpersonationLevel = v_uint32()
        self.ContextTrackingMode = v_uint8()
        self.EffectiveOnly = v_uint8()
        self._pad000c = v_bytes(size=2)


class MSUBSECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlArea = v_ptr64()
        self.SubsectionBase = v_ptr64()
        self.NextSubsection = v_ptr64()
        self.PtesInSubsection = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.UnusedPtes = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.u = _unnamed_22448()
        self.StartingSector = v_uint32()
        self.NumberOfFullSectors = v_uint32()
        self._pad0038 = v_bytes(size=4)
        self.u1 = _unnamed_22464()
        self.LeftChild = v_ptr64()
        self.RightChild = v_ptr64()
        self.DereferenceList = LIST_ENTRY()
        self.NumberOfMappedViews = v_uint64()


class KSTACK_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StackControl = KERNEL_STACK_CONTROL()
        self.NpxFrame = XSAVE_FORMAT()


class WHEA_ERROR_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = WHEA_ERROR_RECORD_HEADER()
        self.SectionDescriptor = vstruct.VArray([ WHEA_ERROR_RECORD_SECTION_DESCRIPTOR() for i in xrange(1) ])


class _unnamed_21040(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Create = _unnamed_21102()


class _unnamed_22855(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.List = v_ptr64()
        self.Index = v_uint32()
        self.Cell = v_uint32()
        self.CellPoint = v_ptr64()


class _unnamed_22854(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cell = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.CellPoint = v_ptr64()
        self.RootPoint = v_ptr64()
        self.Index = v_uint32()
        self._pad0020 = v_bytes(size=4)


class POP_SHUTDOWN_BUG_CHECK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ThreadHandle = v_ptr64()
        self.ThreadId = v_ptr64()
        self.ProcessId = v_ptr64()
        self.Code = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.Parameter1 = v_uint64()
        self.Parameter2 = v_uint64()
        self.Parameter3 = v_uint64()
        self.Parameter4 = v_uint64()


class _unnamed_22856(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Space = v_uint32()
        self.MapPoint = v_uint32()
        self.BinPoint = v_ptr64()


class _unnamed_22851(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Failure = v_uint32()
        self.Status = v_uint32()
        self.Point = v_uint32()


class ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedResources = v_ptr64()


class VIRTUAL_EFI_RUNTIME_SERVICES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GetTime = v_uint64()
        self.SetTime = v_uint64()
        self.GetWakeupTime = v_uint64()
        self.SetWakeupTime = v_uint64()
        self.SetVirtualAddressMap = v_uint64()
        self.ConvertPointer = v_uint64()
        self.GetVariable = v_uint64()
        self.GetNextVariableName = v_uint64()
        self.SetVariable = v_uint64()
        self.GetNextHighMonotonicCount = v_uint64()
        self.ResetSystem = v_uint64()
        self.UpdateCapsule = v_uint64()
        self.QueryCapsuleCapabilities = v_uint64()
        self.QueryVariableInfo = v_uint64()


class _unnamed_22852(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Action = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Handle = v_ptr64()
        self.Status = v_uint32()
        self._pad0018 = v_bytes(size=4)


class OBJECT_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PointerCount = v_uint64()
        self.HandleCount = v_uint64()
        self.Lock = EX_PUSH_LOCK()
        self.TypeIndex = v_uint8()
        self.TraceFlags = v_uint8()
        self.InfoMask = v_uint8()
        self.Flags = v_uint8()
        self._pad0020 = v_bytes(size=4)
        self.ObjectCreateInfo = v_ptr64()
        self.SecurityDescriptor = v_ptr64()
        self.Body = QUAD()


class RTL_DYNAMIC_HASH_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Linkage = LIST_ENTRY()
        self.Signature = v_uint64()


class _unnamed_23139(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LegacyDeviceNode = v_ptr64()


class CLIENT_ID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_ptr64()
        self.UniqueThread = v_ptr64()


class IMAGE_OPTIONAL_HEADER64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint16()
        self.MajorLinkerVersion = v_uint8()
        self.MinorLinkerVersion = v_uint8()
        self.SizeOfCode = v_uint32()
        self.SizeOfInitializedData = v_uint32()
        self.SizeOfUninitializedData = v_uint32()
        self.AddressOfEntryPoint = v_uint32()
        self.BaseOfCode = v_uint32()
        self.ImageBase = v_uint64()
        self.SectionAlignment = v_uint32()
        self.FileAlignment = v_uint32()
        self.MajorOperatingSystemVersion = v_uint16()
        self.MinorOperatingSystemVersion = v_uint16()
        self.MajorImageVersion = v_uint16()
        self.MinorImageVersion = v_uint16()
        self.MajorSubsystemVersion = v_uint16()
        self.MinorSubsystemVersion = v_uint16()
        self.Win32VersionValue = v_uint32()
        self.SizeOfImage = v_uint32()
        self.SizeOfHeaders = v_uint32()
        self.CheckSum = v_uint32()
        self.Subsystem = v_uint16()
        self.DllCharacteristics = v_uint16()
        self.SizeOfStackReserve = v_uint64()
        self.SizeOfStackCommit = v_uint64()
        self.SizeOfHeapReserve = v_uint64()
        self.SizeOfHeapCommit = v_uint64()
        self.LoaderFlags = v_uint32()
        self.NumberOfRvaAndSizes = v_uint32()
        self.DataDirectory = vstruct.VArray([ IMAGE_DATA_DIRECTORY() for i in xrange(16) ])


class _unnamed_23643(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileOffset = LARGE_INTEGER()


class MMPFN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_22080()
        self.u2 = _unnamed_22081()
        self.PteAddress = v_ptr64()
        self.u3 = _unnamed_22083()
        self.UsedPageTableEntries = v_uint16()
        self.VaType = v_uint8()
        self.ViewCount = v_uint8()
        self.OriginalPte = MMPTE()
        self.u4 = _unnamed_22084()


class OBJECT_DUMP_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Stream = v_ptr64()
        self.Detail = v_uint32()
        self._pad0010 = v_bytes(size=4)


class CACHE_MANAGER_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AcquireForLazyWrite = v_ptr64()
        self.ReleaseFromLazyWrite = v_ptr64()
        self.AcquireForReadAhead = v_ptr64()
        self.ReleaseFromReadAhead = v_ptr64()


class DBGKD_CONTINUE2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContinueStatus = v_uint32()
        self.ControlSet = AMD64_DBGKD_CONTROL_SET()


class HANDLE_TRACE_DB_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientId = CLIENT_ID()
        self.Handle = v_ptr64()
        self.Type = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.StackTrace = vstruct.VArray([ v_ptr64() for i in xrange(16) ])


class CPU_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Eax = v_uint32()
        self.Ebx = v_uint32()
        self.Ecx = v_uint32()
        self.Edx = v_uint32()


class TOKEN_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TokenId = LUID()
        self.AuthenticationId = LUID()
        self.ModifiedId = LUID()
        self.TokenSource = TOKEN_SOURCE()


class GENERAL_LOOKASIDE_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr64()
        self.FreeEx = v_ptr64()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])


class _unnamed_22858(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileOffset = v_uint32()


class ALPC_DISPATCH_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PortObject = v_ptr64()
        self.Message = v_ptr64()
        self.CommunicationInfo = v_ptr64()
        self.TargetThread = v_ptr64()
        self.TargetPort = v_ptr64()
        self.Flags = v_uint32()
        self.TotalLength = v_uint16()
        self.Type = v_uint16()
        self.DataInfoOffset = v_uint16()
        self._pad0038 = v_bytes(size=6)


class LPCP_NONPAGED_PORT_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Semaphore = KSEMAPHORE()
        self.BackPointer = v_ptr64()


class KTRANSACTION_HISTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RecordType = v_uint32()
        self.Payload = v_uint32()


class RTL_SRWLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint64()


class BATTERY_REPORTING_SCALE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Granularity = v_uint32()
        self.Capacity = v_uint32()


class MMPAGING_FILE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint64()
        self.MaximumSize = v_uint64()
        self.MinimumSize = v_uint64()
        self.FreeSpace = v_uint64()
        self.PeakUsage = v_uint64()
        self.HighestPage = v_uint64()
        self.File = v_ptr64()
        self.Entry = vstruct.VArray([ v_ptr64() for i in xrange(2) ])
        self.PageFileName = UNICODE_STRING()
        self.Bitmap = v_ptr64()
        self.EvictStoreBitmap = v_ptr64()
        self.BitmapHint = v_uint32()
        self.LastAllocationSize = v_uint32()
        self.ToBeEvictedCount = v_uint32()
        self.PageFileNumber = v_uint16()
        self.AdriftMdls = v_uint16()
        self.FileHandle = v_ptr64()
        self.Lock = v_uint64()
        self.LockOwner = v_ptr64()


class STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_ptr64()


class SID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Sid = v_ptr64()
        self.Attributes = v_uint32()
        self._pad0010 = v_bytes(size=4)


class TP_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_24321(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24379()


class CMP_OFFSET_ARRAY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileOffset = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.DataBuffer = v_ptr64()
        self.DataLength = v_uint32()
        self._pad0018 = v_bytes(size=4)


class CM_KEY_VALUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.NameLength = v_uint16()
        self.DataLength = v_uint32()
        self.Data = v_uint32()
        self.Type = v_uint32()
        self.Flags = v_uint16()
        self.Spare = v_uint16()
        self.Name = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0018 = v_bytes(size=2)


class _unnamed_22355(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.KeepForever = v_uint64()


class LIST_ENTRY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint32()
        self.Blink = v_uint32()


class KDESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pad = vstruct.VArray([ v_uint16() for i in xrange(3) ])
        self.Limit = v_uint16()
        self.Base = v_ptr64()


class _unnamed_26688(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumChannel = v_uint32()
        self.MaximumChannel = v_uint32()


class SINGLE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()


class FILE_NETWORK_OPEN_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0038 = v_bytes(size=4)


class DBGKD_QUERY_MEMORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_uint64()
        self.Reserved = v_uint64()
        self.AddressSpace = v_uint32()
        self.Flags = v_uint32()


class MMVAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_22375()
        self.LeftChild = v_ptr64()
        self.RightChild = v_ptr64()
        self.StartingVpn = v_uint64()
        self.EndingVpn = v_uint64()
        self.u = _unnamed_22378()
        self.PushLock = EX_PUSH_LOCK()
        self.u5 = _unnamed_22379()
        self.u2 = _unnamed_22395()
        self._pad0048 = v_bytes(size=4)
        self.Subsection = v_ptr64()
        self.FirstPrototypePte = v_ptr64()
        self.LastContiguousPte = v_ptr64()
        self.ViewLinks = LIST_ENTRY()
        self.VadsProcess = v_ptr64()


class VF_AVL_TREE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.NodeToFree = v_ptr64()
        self.NodeRangeSize = v_uint64()
        self.NodeCount = v_uint64()
        self.Tables = v_ptr64()
        self.TablesNo = v_uint32()
        self.u1 = _unnamed_29012()
        self._pad0040 = v_bytes(size=16)


class CONTEXT32_UPDATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumberEntries = v_uint32()


class KDEVICE_QUEUE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceListEntry = LIST_ENTRY()
        self.SortKey = v_uint32()
        self.Inserted = v_uint8()
        self._pad0018 = v_bytes(size=3)


class MMPTE_SUBSECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint64()


class PO_DEVICE_NOTIFY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = LIST_ENTRY()
        self.PowerChildren = LIST_ENTRY()
        self.PowerParents = LIST_ENTRY()
        self.TargetDevice = v_ptr64()
        self.OrderLevel = v_uint8()
        self._pad0040 = v_bytes(size=7)
        self.DeviceObject = v_ptr64()
        self.DeviceName = v_ptr64()
        self.DriverName = v_ptr64()
        self.ChildCount = v_uint32()
        self.ActiveChild = v_uint32()
        self.ParentCount = v_uint32()
        self.ActiveParent = v_uint32()


class ALPC_HANDLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr64()


class HMAP_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Directory = vstruct.VArray([ v_ptr64() for i in xrange(1024) ])


class TPM_BOOT_ENTROPY_LDR_RESULT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Policy = v_uint64()
        self.ResultCode = v_uint32()
        self.ResultStatus = v_uint32()
        self.Time = v_uint64()
        self.EntropyLength = v_uint32()
        self.EntropyData = vstruct.VArray([ v_uint8() for i in xrange(40) ])
        self._pad0048 = v_bytes(size=4)


class NBQUEUE_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SListEntry = SLIST_ENTRY()
        self.Next = v_uint64()
        self.Data = v_uint64()


class KTMOBJECT_NAMESPACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Table = RTL_AVL_TABLE()
        self.Mutex = KMUTANT()
        self.LinksOffset = v_uint16()
        self.GuidOffset = v_uint16()
        self.Expired = v_uint8()
        self._pad00a8 = v_bytes(size=3)


class PERFINFO_TRACE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Marker = v_uint32()
        self.Header = v_uint32()
        self.TS = v_uint64()
        self.Data = vstruct.VArray([ v_uint8() for i in xrange(1) ])
        self._pad0018 = v_bytes(size=7)


class OBJECT_HEADER_QUOTA_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PagedPoolCharge = v_uint32()
        self.NonPagedPoolCharge = v_uint32()
        self.SecurityDescriptorCharge = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.SecurityDescriptorQuotaBlock = v_ptr64()
        self.Reserved = v_uint64()


class _unnamed_25427(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.List = LIST_ENTRY()


class HEAP_STOP_ON_VALUES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocAddress = v_uint64()
        self.AllocTag = HEAP_STOP_ON_TAG()
        self._pad0010 = v_bytes(size=4)
        self.ReAllocAddress = v_uint64()
        self.ReAllocTag = HEAP_STOP_ON_TAG()
        self._pad0020 = v_bytes(size=4)
        self.FreeAddress = v_uint64()
        self.FreeTag = HEAP_STOP_ON_TAG()
        self._pad0030 = v_bytes(size=4)


class FS_FILTER_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AcquireForModifiedPageWriter = _unnamed_27930()
        self._pad0028 = v_bytes(size=24)


class DBGKD_READ_MEMORY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TargetBaseAddress = v_uint32()
        self.TransferCount = v_uint32()
        self.ActualBytesRead = v_uint32()


class RTL_HANDLE_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self._pad0008 = v_bytes(size=4)


class VI_POOL_ENTRY_INUSE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_ptr64()
        self.CallingAddress = v_ptr64()
        self.NumberOfBytes = v_uint64()
        self.Tag = v_uint64()


class PEB64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InheritedAddressSpace = v_uint8()
        self.ReadImageFileExecOptions = v_uint8()
        self.BeingDebugged = v_uint8()
        self.BitField = v_uint8()
        self._pad0008 = v_bytes(size=4)
        self.Mutant = v_uint64()
        self.ImageBaseAddress = v_uint64()
        self.Ldr = v_uint64()
        self.ProcessParameters = v_uint64()
        self.SubSystemData = v_uint64()
        self.ProcessHeap = v_uint64()
        self.FastPebLock = v_uint64()
        self.AtlThunkSListPtr = v_uint64()
        self.IFEOKey = v_uint64()
        self.CrossProcessFlags = v_uint32()
        self._pad0058 = v_bytes(size=4)
        self.KernelCallbackTable = v_uint64()
        self.SystemReserved = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.AtlThunkSListPtr32 = v_uint32()
        self.ApiSetMap = v_uint64()
        self.TlsExpansionCounter = v_uint32()
        self._pad0078 = v_bytes(size=4)
        self.TlsBitmap = v_uint64()
        self.TlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ReadOnlySharedMemoryBase = v_uint64()
        self.HotpatchInformation = v_uint64()
        self.ReadOnlyStaticServerData = v_uint64()
        self.AnsiCodePageData = v_uint64()
        self.OemCodePageData = v_uint64()
        self.UnicodeCaseTableData = v_uint64()
        self.NumberOfProcessors = v_uint32()
        self.NtGlobalFlag = v_uint32()
        self.CriticalSectionTimeout = LARGE_INTEGER()
        self.HeapSegmentReserve = v_uint64()
        self.HeapSegmentCommit = v_uint64()
        self.HeapDeCommitTotalFreeThreshold = v_uint64()
        self.HeapDeCommitFreeBlockThreshold = v_uint64()
        self.NumberOfHeaps = v_uint32()
        self.MaximumNumberOfHeaps = v_uint32()
        self.ProcessHeaps = v_uint64()
        self.GdiSharedHandleTable = v_uint64()
        self.ProcessStarterHelper = v_uint64()
        self.GdiDCAttributeList = v_uint32()
        self._pad0110 = v_bytes(size=4)
        self.LoaderLock = v_uint64()
        self.OSMajorVersion = v_uint32()
        self.OSMinorVersion = v_uint32()
        self.OSBuildNumber = v_uint16()
        self.OSCSDVersion = v_uint16()
        self.OSPlatformId = v_uint32()
        self.ImageSubsystem = v_uint32()
        self.ImageSubsystemMajorVersion = v_uint32()
        self.ImageSubsystemMinorVersion = v_uint32()
        self._pad0138 = v_bytes(size=4)
        self.ActiveProcessAffinityMask = v_uint64()
        self.GdiHandleBuffer = vstruct.VArray([ v_uint32() for i in xrange(60) ])
        self.PostProcessInitRoutine = v_uint64()
        self.TlsExpansionBitmap = v_uint64()
        self.TlsExpansionBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(32) ])
        self.SessionId = v_uint32()
        self._pad02c8 = v_bytes(size=4)
        self.AppCompatFlags = ULARGE_INTEGER()
        self.AppCompatFlagsUser = ULARGE_INTEGER()
        self.pShimData = v_uint64()
        self.AppCompatInfo = v_uint64()
        self.CSDVersion = STRING64()
        self.ActivationContextData = v_uint64()
        self.ProcessAssemblyStorageMap = v_uint64()
        self.SystemDefaultActivationContextData = v_uint64()
        self.SystemAssemblyStorageMap = v_uint64()
        self.MinimumStackCommit = v_uint64()
        self.FlsCallback = v_uint64()
        self.FlsListHead = LIST_ENTRY64()
        self.FlsBitmap = v_uint64()
        self.FlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.FlsHighIndex = v_uint32()
        self._pad0358 = v_bytes(size=4)
        self.WerRegistrationData = v_uint64()
        self.WerShipAssertPtr = v_uint64()
        self.pContextData = v_uint64()
        self.pImageHeaderHash = v_uint64()
        self.TracingFlags = v_uint32()
        self._pad0380 = v_bytes(size=4)


class ARBITER_ALTERNATIVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Minimum = v_uint64()
        self.Maximum = v_uint64()
        self.Length = v_uint64()
        self.Alignment = v_uint64()
        self.Priority = v_uint32()
        self.Flags = v_uint32()
        self.Descriptor = v_ptr64()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self._pad0040 = v_bytes(size=4)


class HEAP_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Counters = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self._pad0040 = v_bytes(size=12)


class _unnamed_20937(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InitialPrivilegeSet = INITIAL_PRIVILEGE_SET()


class EX_FAST_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr64()


class INTERLOCK_SEQ(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint16()
        self.FreeEntryOffset = v_uint16()
        self.Sequence = v_uint32()


class HMAP_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Table = vstruct.VArray([ HMAP_ENTRY() for i in xrange(512) ])


class PNP_RESOURCE_REQUEST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PhysicalDevice = v_ptr64()
        self.Flags = v_uint32()
        self.AllocationType = v_uint32()
        self.Priority = v_uint32()
        self.Position = v_uint32()
        self.ResourceRequirements = v_ptr64()
        self.ReqList = v_ptr64()
        self.ResourceAssignment = v_ptr64()
        self.TranslatedResourceAssignment = v_ptr64()
        self.Status = v_uint32()
        self._pad0040 = v_bytes(size=4)


class RTL_ACTIVATION_CONTEXT_STACK_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Previous = v_ptr64()
        self.ActivationContext = v_ptr64()
        self.Flags = v_uint32()
        self._pad0018 = v_bytes(size=4)


class VI_DEADLOCK_GLOBALS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TimeAcquire = v_uint64()
        self.TimeRelease = v_uint64()
        self.ResourceDatabase = v_ptr64()
        self.ResourceDatabaseCount = v_uint64()
        self.ResourceAddressRange = vstruct.VArray([ VF_ADDRESS_RANGE() for i in xrange(1023) ])
        self.ThreadDatabase = v_ptr64()
        self.ThreadDatabaseCount = v_uint64()
        self.ThreadAddressRange = vstruct.VArray([ VF_ADDRESS_RANGE() for i in xrange(1023) ])
        self.AllocationFailures = v_uint32()
        self.NodesTrimmedBasedOnAge = v_uint32()
        self.NodesTrimmedBasedOnCount = v_uint32()
        self.NodesSearched = v_uint32()
        self.MaxNodesSearched = v_uint32()
        self.SequenceNumber = v_uint32()
        self.RecursionDepthLimit = v_uint32()
        self.SearchedNodesLimit = v_uint32()
        self.DepthLimitHits = v_uint32()
        self.SearchLimitHits = v_uint32()
        self.ABC_ACB_Skipped = v_uint32()
        self.OutOfOrderReleases = v_uint32()
        self.NodesReleasedOutOfOrder = v_uint32()
        self.TotalReleases = v_uint32()
        self.RootNodesDeleted = v_uint32()
        self.ForgetHistoryCounter = v_uint32()
        self.Instigator = v_ptr64()
        self.NumberOfParticipants = v_uint32()
        self._pad8060 = v_bytes(size=4)
        self.Participant = vstruct.VArray([ v_ptr64() for i in xrange(32) ])
        self.ChildrenCountWatermark = v_uint32()
        self._pad8168 = v_bytes(size=4)


class FS_FILTER_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbacks = v_uint32()
        self.Reserved = v_uint32()
        self.PreAcquireForSectionSynchronization = v_ptr64()
        self.PostAcquireForSectionSynchronization = v_ptr64()
        self.PreReleaseForSectionSynchronization = v_ptr64()
        self.PostReleaseForSectionSynchronization = v_ptr64()
        self.PreAcquireForCcFlush = v_ptr64()
        self.PostAcquireForCcFlush = v_ptr64()
        self.PreReleaseForCcFlush = v_ptr64()
        self.PostReleaseForCcFlush = v_ptr64()
        self.PreAcquireForModifiedPageWriter = v_ptr64()
        self.PostAcquireForModifiedPageWriter = v_ptr64()
        self.PreReleaseForModifiedPageWriter = v_ptr64()
        self.PostReleaseForModifiedPageWriter = v_ptr64()


class MM_DRIVER_VERIFIER_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint32()
        self.RaiseIrqls = v_uint32()
        self.AcquireSpinLocks = v_uint32()
        self.SynchronizeExecutions = v_uint32()
        self.AllocationsAttempted = v_uint32()
        self.AllocationsSucceeded = v_uint32()
        self.AllocationsSucceededSpecialPool = v_uint32()
        self.AllocationsWithNoTag = v_uint32()
        self.TrimRequests = v_uint32()
        self.Trims = v_uint32()
        self.AllocationsFailed = v_uint32()
        self.AllocationsFailedDeliberately = v_uint32()
        self.Loads = v_uint32()
        self.Unloads = v_uint32()
        self.UnTrackedPool = v_uint32()
        self.UserTrims = v_uint32()
        self.CurrentPagedPoolAllocations = v_uint32()
        self.CurrentNonPagedPoolAllocations = v_uint32()
        self.PeakPagedPoolAllocations = v_uint32()
        self.PeakNonPagedPoolAllocations = v_uint32()
        self.PagedBytes = v_uint64()
        self.NonPagedBytes = v_uint64()
        self.PeakPagedBytes = v_uint64()
        self.PeakNonPagedBytes = v_uint64()
        self.BurstAllocationsFailedDeliberately = v_uint32()
        self.SessionTrims = v_uint32()
        self.OptionChanges = v_uint32()
        self.VerifyMode = v_uint32()
        self.PreviousBucketName = UNICODE_STRING()
        self.ActivityCounter = v_uint32()
        self.PreviousActivityCounter = v_uint32()
        self.WorkerTrimRequests = v_uint32()
        self._pad00a0 = v_bytes(size=4)


class IO_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Option = v_uint8()
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Spare1 = v_uint8()
        self.Flags = v_uint16()
        self.Spare2 = v_uint16()
        self.u = _unnamed_26616()


class EX_PUSH_LOCK_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locks = vstruct.VArray([ v_ptr64() for i in xrange(32) ])


class _unnamed_29543(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DiskId = GUID()


class _unnamed_29540(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.CheckSum = v_uint32()


class CM_KCB_UOW(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TransactionListEntry = LIST_ENTRY()
        self.KCBLock = v_ptr64()
        self.KeyLock = v_ptr64()
        self.KCBListEntry = LIST_ENTRY()
        self.KeyControlBlock = v_ptr64()
        self.Transaction = v_ptr64()
        self.UoWState = v_uint32()
        self.ActionType = v_uint32()
        self.StorageType = v_uint32()
        self._pad0050 = v_bytes(size=4)
        self.ChildKCB = v_ptr64()
        self.NewChildKCB = v_ptr64()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FRUId = v_uint8()


class _unnamed_27515(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TestAllocation = ARBITER_TEST_ALLOCATION_PARAMETERS()
        self._pad0020 = v_bytes(size=8)


class _unnamed_24280(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Initialized = v_uint32()


class SCSI_REQUEST_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class MMVAD_LONG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_22375()
        self.LeftChild = v_ptr64()
        self.RightChild = v_ptr64()
        self.StartingVpn = v_uint64()
        self.EndingVpn = v_uint64()
        self.u = _unnamed_22378()
        self.PushLock = EX_PUSH_LOCK()
        self.u5 = _unnamed_22379()
        self.u2 = _unnamed_22395()
        self._pad0048 = v_bytes(size=4)
        self.Subsection = v_ptr64()
        self.FirstPrototypePte = v_ptr64()
        self.LastContiguousPte = v_ptr64()
        self.ViewLinks = LIST_ENTRY()
        self.VadsProcess = v_ptr64()
        self.u3 = _unnamed_25427()
        self.u4 = _unnamed_25428()


class ARBITER_ADD_RESERVED_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReserveDevice = v_ptr64()


class VF_ADDRESS_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_ptr64()
        self.End = v_ptr64()


class STRING64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_uint64()


class MBCB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self.NodeIsInZone = v_uint16()
        self.PagesToWrite = v_uint32()
        self.DirtyPages = v_uint32()
        self.Reserved = v_uint32()
        self.BitmapRanges = LIST_ENTRY()
        self.ResumeWritePage = v_uint64()
        self.MostRecentlyDirtiedPage = v_uint64()
        self.BitmapRange1 = BITMAP_RANGE()
        self.BitmapRange2 = BITMAP_RANGE()
        self.BitmapRange3 = BITMAP_RANGE()


class _unnamed_22107(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReferenceCount = v_uint16()
        self.ShortFlags = v_uint16()


class FAST_MUTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Owner = v_ptr64()
        self.Contention = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Event = KEVENT()
        self.OldIrql = v_uint32()
        self._pad0038 = v_bytes(size=4)


class TRACE_ENABLE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IsEnabled = v_uint32()
        self.Level = v_uint8()
        self.Reserved1 = v_uint8()
        self.LoggerId = v_uint16()
        self.EnableProperty = v_uint32()
        self.Reserved2 = v_uint32()
        self.MatchAnyKeyword = v_uint64()
        self.MatchAllKeyword = v_uint64()


class MM_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = MMADDRESS_NODE()
        self.DepthOfTree = v_uint64()
        self.NodeHint = v_ptr64()
        self.NodeFreeHint = v_ptr64()


class VF_SUSPECT_DRIVER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Links = LIST_ENTRY()
        self.Loads = v_uint32()
        self.Unloads = v_uint32()
        self.BaseName = UNICODE_STRING()


class MM_SESSION_SPACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReferenceCount = v_uint32()
        self.u = _unnamed_28314()
        self.SessionId = v_uint32()
        self.ProcessReferenceToSession = v_uint32()
        self.ProcessList = LIST_ENTRY()
        self.LastProcessSwappedOutTime = LARGE_INTEGER()
        self.SessionPageDirectoryIndex = v_uint64()
        self.NonPagablePages = v_uint64()
        self.CommittedPages = v_uint64()
        self.PagedPoolStart = v_ptr64()
        self.PagedPoolEnd = v_ptr64()
        self.SessionObject = v_ptr64()
        self.SessionObjectHandle = v_ptr64()
        self.ResidentProcessCount = v_uint32()
        self.SessionPoolAllocationFailures = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self._pad0078 = v_bytes(size=4)
        self.ImageList = LIST_ENTRY()
        self.LocaleId = v_uint32()
        self.AttachCount = v_uint32()
        self.AttachGate = KGATE()
        self.WsListEntry = LIST_ENTRY()
        self._pad00c0 = v_bytes(size=8)
        self.Lookaside = vstruct.VArray([ GENERAL_LOOKASIDE() for i in xrange(21) ])
        self.Session = MMSESSION()
        self.PagedPoolInfo = MM_PAGED_POOL_INFO()
        self.Vm = MMSUPPORT()
        self.Wsle = v_ptr64()
        self.DriverUnload = v_ptr64()
        self._pad0cc0 = v_bytes(size=40)
        self.PagedPool = POOL_DESCRIPTOR()
        self.PageDirectory = MMPTE()
        self.SessionVaLock = KGUARDED_MUTEX()
        self.DynamicVaBitMap = RTL_BITMAP()
        self.DynamicVaHint = v_uint32()
        self._pad1e58 = v_bytes(size=4)
        self.SpecialPool = MI_SPECIAL_POOL()
        self.SessionPteLock = KGUARDED_MUTEX()
        self.PoolBigEntriesInUse = v_uint32()
        self.PagedPoolPdeCount = v_uint32()
        self.SpecialPoolPdeCount = v_uint32()
        self.DynamicSessionPdeCount = v_uint32()
        self.SystemPteInfo = MI_SYSTEM_PTE_TYPE()
        self.PoolTrackTableExpansion = v_ptr64()
        self.PoolTrackTableExpansionSize = v_uint64()
        self.PoolTrackBigPages = v_ptr64()
        self.PoolTrackBigPagesSize = v_uint64()
        self.IoState = v_uint32()
        self.IoStateSequence = v_uint32()
        self.IoNotificationEvent = KEVENT()
        self.CpuQuotaBlock = v_ptr64()
        self._pad1f80 = v_bytes(size=8)


class WHEA_ERROR_RECORD_HEADER_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PlatformId = v_uint32()


class CM_NAME_CONTROL_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Compressed = v_uint8()
        self._pad0002 = v_bytes(size=1)
        self.RefCount = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.NameHash = CM_NAME_HASH()


class _unnamed_29012(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeSize = v_uint32()


class KDEVICE_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DeviceListHead = LIST_ENTRY()
        self.Lock = v_uint64()
        self.Busy = v_uint8()
        self._pad0028 = v_bytes(size=7)


class ARBITER_RETEST_ALLOCATION_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ArbitrationList = v_ptr64()
        self.AllocateFromCount = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.AllocateFrom = v_ptr64()


class NT_TIB32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_uint32()
        self.StackBase = v_uint32()
        self.StackLimit = v_uint32()
        self.SubSystemTib = v_uint32()
        self.FiberData = v_uint32()
        self.ArbitraryUserPointer = v_uint32()
        self.Self = v_uint32()


class _unnamed_21223(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()


class _unnamed_27286(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length = v_uint32()


class PORT_MESSAGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_24044()
        self.u2 = _unnamed_24045()
        self.ClientId = CLIENT_ID()
        self.MessageId = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.ClientViewSize = v_uint64()


class RELATIVE_SYMLINK_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExposedNamespaceLength = v_uint16()
        self.Flags = v_uint16()
        self.DeviceNameLength = v_uint16()
        self.Reserved = v_uint16()
        self.InteriorMountPoint = v_ptr64()
        self.OpenedName = UNICODE_STRING()


class IO_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityQos = v_ptr64()
        self.AccessState = v_ptr64()
        self.DesiredAccess = v_uint32()
        self.FullCreateOptions = v_uint32()


class TERMINATION_PORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Port = v_ptr64()


class _unnamed_27289(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint16()
        self.Group = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint64()


class VF_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RtlTable = RTL_AVL_TABLE()
        self.ReservedNode = v_ptr64()


class SYSTEM_POWER_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint32()
        self.PowerButton = POWER_ACTION_POLICY()
        self.SleepButton = POWER_ACTION_POLICY()
        self.LidClose = POWER_ACTION_POLICY()
        self.LidOpenWake = v_uint32()
        self.Reserved = v_uint32()
        self.Idle = POWER_ACTION_POLICY()
        self.IdleTimeout = v_uint32()
        self.IdleSensitivity = v_uint8()
        self.DynamicThrottle = v_uint8()
        self.Spare2 = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.MinSleep = v_uint32()
        self.MaxSleep = v_uint32()
        self.ReducedLatencySleep = v_uint32()
        self.WinLogonFlags = v_uint32()
        self.Spare3 = v_uint32()
        self.DozeS4Timeout = v_uint32()
        self.BroadcastCapacityResolution = v_uint32()
        self.DischargePolicy = vstruct.VArray([ SYSTEM_POWER_LEVEL() for i in xrange(4) ])
        self.VideoTimeout = v_uint32()
        self.VideoDimDisplay = v_uint8()
        self._pad00c8 = v_bytes(size=3)
        self.VideoReserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.SpindownTimeout = v_uint32()
        self.OptimizeForPower = v_uint8()
        self.FanThrottleTolerance = v_uint8()
        self.ForcedThrottle = v_uint8()
        self.MinThrottle = v_uint8()
        self.OverThrottled = POWER_ACTION_POLICY()


class _unnamed_27930(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EndingOffset = v_ptr64()
        self.ResourceToRelease = v_ptr64()


class _unnamed_27933(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationType = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.SafeToRecurse = v_uint8()
        self._pad0010 = v_bytes(size=7)


class _unnamed_27932(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SyncType = v_uint32()
        self.PageProtection = v_uint32()


class INITIAL_PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(3) ])


class _unnamed_27934(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr64()
        self.Argument2 = v_ptr64()
        self.Argument3 = v_ptr64()
        self.Argument4 = v_ptr64()
        self.Argument5 = v_ptr64()


class GENERAL_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr64()
        self.FreeEx = v_ptr64()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self._pad0080 = v_bytes(size=32)


class _unnamed_26671(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Alignment = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class POOL_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PoolType = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.PagedLock = KGUARDED_MUTEX()
        self.RunningAllocs = v_uint32()
        self.RunningDeAllocs = v_uint32()
        self.TotalBigPages = v_uint32()
        self.ThreadsProcessingDeferrals = v_uint32()
        self.TotalBytes = v_uint64()
        self._pad0080 = v_bytes(size=40)
        self.PoolIndex = v_uint32()
        self._pad00c0 = v_bytes(size=60)
        self.TotalPages = v_uint32()
        self._pad0100 = v_bytes(size=60)
        self.PendingFrees = v_ptr64()
        self.PendingFreeDepth = v_uint32()
        self._pad0140 = v_bytes(size=52)
        self.ListHeads = vstruct.VArray([ LIST_ENTRY() for i in xrange(256) ])


class GDI_TEB_BATCH64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.HDC = v_uint64()
        self.Buffer = vstruct.VArray([ v_uint32() for i in xrange(310) ])


class CM_RM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RmListEntry = LIST_ENTRY()
        self.TransactionListHead = LIST_ENTRY()
        self.TmHandle = v_ptr64()
        self.Tm = v_ptr64()
        self.RmHandle = v_ptr64()
        self.KtmRm = v_ptr64()
        self.RefCount = v_uint32()
        self.ContainerNum = v_uint32()
        self.ContainerSize = v_uint64()
        self.CmHive = v_ptr64()
        self.LogFileObject = v_ptr64()
        self.MarshallingContext = v_ptr64()
        self.RmFlags = v_uint32()
        self.LogStartStatus1 = v_uint32()
        self.LogStartStatus2 = v_uint32()
        self._pad0078 = v_bytes(size=4)
        self.BaseLsn = v_uint64()
        self.RmLock = v_ptr64()


class WHEA_ERROR_RECORD_HEADER_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Recovered = v_uint32()


class _unnamed_21410(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerSequence = v_ptr64()


class _unnamed_24171(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24280()


class SMBIOS_TABLE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_24174(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Internal = v_uint32()


class DUMP_STACK_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Init = DUMP_INITIALIZATION_CONTEXT()
        self.PartitionOffset = LARGE_INTEGER()
        self.DumpPointers = v_ptr64()
        self.PointersLength = v_uint32()
        self._pad00b8 = v_bytes(size=4)
        self.ModulePrefix = v_ptr64()
        self.DriverList = LIST_ENTRY()
        self.InitMsg = STRING()
        self.ProgMsg = STRING()
        self.DoneMsg = STRING()
        self.FileObject = v_ptr64()
        self.UsageType = v_uint32()
        self._pad0110 = v_bytes(size=4)


class PNP_DEVICE_EVENT_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.EventQueueMutex = KMUTANT()
        self.Lock = KGUARDED_MUTEX()
        self.List = LIST_ENTRY()


class KWAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitListEntry = LIST_ENTRY()
        self.Thread = v_ptr64()
        self.Object = v_ptr64()
        self.NextWaitBlock = v_ptr64()
        self.WaitKey = v_uint16()
        self.WaitType = v_uint8()
        self.BlockState = v_uint8()
        self.SpareLong = v_uint32()


class DBGKD_READ_WRITE_IO32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.IoAddress = v_uint32()
        self.DataValue = v_uint32()


class POP_HIBER_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WriteToFile = v_uint8()
        self.ReserveLoaderMemory = v_uint8()
        self.ReserveFreeMemory = v_uint8()
        self.Reset = v_uint8()
        self.HiberFlags = v_uint8()
        self.WroteHiberFile = v_uint8()
        self.MapFrozen = v_uint8()
        self._pad0008 = v_bytes(size=1)
        self.MemoryMap = RTL_BITMAP()
        self.DiscardedMemoryPages = RTL_BITMAP()
        self.ClonedRanges = LIST_ENTRY()
        self.ClonedRangeCount = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.NextCloneRange = v_ptr64()
        self.NextPreserve = v_uint64()
        self.LoaderMdl = v_ptr64()
        self.AllocatedMdl = v_ptr64()
        self.PagesOut = v_uint64()
        self.IoPages = v_ptr64()
        self.IoPagesCount = v_uint32()
        self._pad0078 = v_bytes(size=4)
        self.CurrentMcb = v_ptr64()
        self.DumpStack = v_ptr64()
        self.WakeState = v_ptr64()
        self.PreferredIoWriteSize = v_uint32()
        self.IoProgress = v_uint32()
        self.HiberVa = v_uint64()
        self.HiberPte = LARGE_INTEGER()
        self.Status = v_uint32()
        self._pad00b0 = v_bytes(size=4)
        self.MemoryImage = v_ptr64()
        self.CompressionWorkspace = v_ptr64()
        self.CompressedWriteBuffer = v_ptr64()
        self.CompressedWriteBufferSize = v_uint32()
        self.MaxCompressedOutputSize = v_uint32()
        self.PerformanceStats = v_ptr64()
        self.CompressionBlock = v_ptr64()
        self.DmaIO = v_ptr64()
        self.TemporaryHeap = v_ptr64()
        self.BootLoaderLogMdl = v_ptr64()
        self.FirmwareRuntimeInformationMdl = v_ptr64()
        self.ResumeContext = v_ptr64()
        self.ResumeContextPages = v_uint32()
        self._pad0110 = v_bytes(size=4)


class RTL_HANDLE_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MaximumNumberOfHandles = v_uint32()
        self.SizeOfHandleTableEntry = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.FreeHandles = v_ptr64()
        self.CommittedHandles = v_ptr64()
        self.UnCommittedHandles = v_ptr64()
        self.MaxReservedHandles = v_ptr64()


class OBJECT_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.RootDirectory = v_ptr64()
        self.ObjectName = v_ptr64()
        self.Attributes = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.SecurityDescriptor = v_ptr64()
        self.SecurityQualityOfService = v_ptr64()


class CM_KEY_SECURITY_CACHE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cell = v_uint32()
        self.ConvKey = v_uint32()
        self.List = LIST_ENTRY()
        self.DescriptorLength = v_uint32()
        self.RealRefCount = v_uint32()
        self.Descriptor = SECURITY_DESCRIPTOR_RELATIVE()
        self._pad0038 = v_bytes(size=4)


class PPC_DBGKD_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Continue = v_uint32()
        self.CurrentSymbolStart = v_uint32()
        self.CurrentSymbolEnd = v_uint32()


class _unnamed_23077(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Disk = _unnamed_27387()


class ETW_SYSTEMTIME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Year = v_uint16()
        self.Month = v_uint16()
        self.DayOfWeek = v_uint16()
        self.Day = v_uint16()
        self.Hour = v_uint16()
        self.Minute = v_uint16()
        self.Second = v_uint16()
        self.Milliseconds = v_uint16()


class AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityAttributeCount = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.SecurityAttributesList = LIST_ENTRY()
        self.WorkingSecurityAttributeCount = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.WorkingSecurityAttributesList = LIST_ENTRY()


class PROCESSOR_NUMBER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.Number = v_uint8()
        self.Reserved = v_uint8()


class HEAP_USERDATA_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SFreeListEntry = SINGLE_LIST_ENTRY()
        self.Reserved = v_ptr64()
        self.SizeIndex = v_uint64()
        self.Signature = v_uint64()


class _unnamed_29085(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.idxRecord = v_uint32()
        self.cidContainer = v_uint32()


class _unnamed_21255(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Length = v_uint32()
        self._pad0010 = v_bytes(size=4)


class RTL_DRIVE_LETTER_CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint16()
        self.Length = v_uint16()
        self.TimeStamp = v_uint32()
        self.DosPath = STRING()


class _unnamed_21250(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.InputBufferLength = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.IoControlCode = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Type3InputBuffer = v_ptr64()


class VF_TRACKER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TrackerFlags = v_uint32()
        self.TrackerSize = v_uint32()
        self.TrackerIndex = v_uint32()
        self.TraceDepth = v_uint32()


class KIDTENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OffsetLow = v_uint16()
        self.Selector = v_uint16()
        self.IstIndex = v_uint16()
        self.OffsetMiddle = v_uint16()
        self.OffsetHigh = v_uint32()
        self.Reserved1 = v_uint32()


class CACHE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint8()
        self.Associativity = v_uint8()
        self.LineSize = v_uint16()
        self.Size = v_uint32()
        self.Type = v_uint32()


class _unnamed_21258(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.SecurityDescriptor = v_ptr64()


class ARBITER_QUERY_ARBITRATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ArbitrationList = v_ptr64()


class DBGKD_BREAKPOINTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakPointCount = v_uint32()
        self.ContinueStatus = v_uint32()


class ULARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class _unnamed_21079(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceQueueEntry = KDEVICE_QUEUE_ENTRY()
        self._pad0020 = v_bytes(size=8)
        self.Thread = v_ptr64()
        self.AuxiliaryBuffer = v_ptr64()
        self.ListEntry = LIST_ENTRY()
        self.CurrentStackLocation = v_ptr64()
        self.OriginalFileObject = v_ptr64()


class TEB_ACTIVE_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Previous = v_ptr64()
        self.Context = v_ptr64()


class ETIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.KeTimer = KTIMER()
        self.TimerApc = KAPC()
        self.TimerDpc = KDPC()
        self.ActiveTimerListEntry = LIST_ENTRY()
        self.Lock = v_uint64()
        self.Period = v_uint32()
        self.ApcAssociated = v_uint8()
        self._pad00f8 = v_bytes(size=3)
        self.WakeReason = v_ptr64()
        self.WakeTimerListEntry = LIST_ENTRY()


class DBGKD_LOAD_SYMBOLS64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PathNameLength = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.BaseOfDll = v_uint64()
        self.ProcessId = v_uint64()
        self.CheckSum = v_uint32()
        self.SizeOfImage = v_uint32()
        self.UnloadSymbols = v_uint8()
        self._pad0028 = v_bytes(size=7)


class KTIMER_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint64()
        self.Entry = LIST_ENTRY()
        self.Time = ULARGE_INTEGER()


class FREE_DISPLAY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RealVectorSize = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Display = RTL_BITMAP()


class MM_PAGE_ACCESS_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = MM_PAGE_ACCESS_INFO_FLAGS()
        self._pad0008 = v_bytes(size=4)


class ARBITER_ORDERING_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint16()
        self.Maximum = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Orderings = v_ptr64()


class OBJECT_DIRECTORY_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ChainLink = v_ptr64()
        self.Object = v_ptr64()
        self.HashValue = v_uint32()
        self._pad0018 = v_bytes(size=4)


class CM_KEY_HASH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ConvKey = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.NextHash = v_ptr64()
        self.KeyHive = v_ptr64()
        self.KeyCell = v_uint32()
        self._pad0020 = v_bytes(size=4)


class KTMNOTIFICATION_PACKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ARBITER_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.AlternativeCount = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Alternatives = v_ptr64()
        self.PhysicalDeviceObject = v_ptr64()
        self.RequestSource = v_uint32()
        self.Flags = v_uint32()
        self.WorkSpace = v_uint64()
        self.InterfaceType = v_uint32()
        self.SlotNumber = v_uint32()
        self.BusNumber = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.Assignment = v_ptr64()
        self.SelectedAlternative = v_ptr64()
        self.Result = v_uint32()
        self._pad0060 = v_bytes(size=4)


class _unnamed_21210(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FileInformationClass = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.FileObject = v_ptr64()
        self.ReplaceIfExists = v_uint8()
        self.AdvanceOnly = v_uint8()
        self._pad0020 = v_bytes(size=6)


class _unnamed_22083(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReferenceCount = v_uint16()
        self.e1 = MMPFNENTRY()


class KWAIT_STATUS_REGISTER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint8()


class CACHE_UNINITIALIZE_EVENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Event = KEVENT()


class _unnamed_22084(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PteFrame = v_uint64()


class MMPFNENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PageLocation = v_uint8()
        self.Priority = v_uint8()


class NT_TIB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_ptr64()
        self.StackBase = v_ptr64()
        self.StackLimit = v_ptr64()
        self.SubSystemTib = v_ptr64()
        self.FiberData = v_ptr64()
        self.ArbitraryUserPointer = v_ptr64()
        self.Self = v_ptr64()


class ARBITER_TEST_ALLOCATION_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ArbitrationList = v_ptr64()
        self.AllocateFromCount = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.AllocateFrom = v_ptr64()


class POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemState = v_uint32()


class _unnamed_21003(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsynchronousParameters = _unnamed_21018()


class UNICODE_STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_ptr64()


class _unnamed_21001(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MasterIrp = v_ptr64()


class MMSESSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemSpaceViewLock = KGUARDED_MUTEX()
        self.SystemSpaceViewLockPointer = v_ptr64()
        self.SystemSpaceViewTable = v_ptr64()
        self.SystemSpaceHashSize = v_uint32()
        self.SystemSpaceHashEntries = v_uint32()
        self.SystemSpaceHashKey = v_uint32()
        self.BitmapFailures = v_uint32()


class _unnamed_21006(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Overlay = _unnamed_21079()
        self._pad0058 = v_bytes(size=8)


class HEAP_LIST_LOOKUP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExtendedLookup = v_ptr64()
        self.ArraySize = v_uint32()
        self.ExtraItem = v_uint32()
        self.ItemCount = v_uint32()
        self.OutOfRangeItems = v_uint32()
        self.BaseIndex = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.ListHead = v_ptr64()
        self.ListsInUseUlong = v_ptr64()
        self.ListHints = v_ptr64()


class SYSPTES_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = LIST_ENTRY()
        self.Count = v_uint64()
        self.NumberOfEntries = v_uint64()
        self.NumberOfEntriesPeak = v_uint64()


class DUMMY_FILE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ObjectHeader = OBJECT_HEADER()
        self.FileObjectBody = vstruct.VArray([ v_uint8() for i in xrange(216) ])


class _unnamed_25428(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Banked = v_ptr64()


class LOADER_PARAMETER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.Profile = PROFILE_PARAMETER_BLOCK()
        self._pad0018 = v_bytes(size=4)
        self.EmInfFileImage = v_ptr64()
        self.EmInfFileSize = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.TriageDumpBlock = v_ptr64()
        self.LoaderPagesSpanned = v_uint64()
        self.HeadlessLoaderBlock = v_ptr64()
        self.SMBiosEPSHeader = v_ptr64()
        self.DrvDBImage = v_ptr64()
        self.DrvDBSize = v_uint32()
        self._pad0058 = v_bytes(size=4)
        self.NetworkLoaderBlock = v_ptr64()
        self.FirmwareDescriptorListHead = LIST_ENTRY()
        self.AcpiTable = v_ptr64()
        self.AcpiTableSize = v_uint32()
        self.LastBootSucceeded = v_uint32()
        self.LoaderPerformanceData = v_ptr64()
        self.BootApplicationPersistentData = LIST_ENTRY()
        self.WmdTestResult = v_ptr64()
        self.BootIdentifier = GUID()
        self.ResumePages = v_uint32()
        self._pad00b8 = v_bytes(size=4)
        self.DumpHeader = v_ptr64()
        self.BgContext = v_ptr64()
        self.NumaLocalityInfo = v_ptr64()
        self.NumaGroupAssignment = v_ptr64()
        self.AttachedHives = LIST_ENTRY()
        self.MemoryCachingRequirementsCount = v_uint32()
        self._pad00f0 = v_bytes(size=4)
        self.MemoryCachingRequirements = v_ptr64()
        self.TpmBootEntropyResult = TPM_BOOT_ENTROPY_LDR_RESULT()
        self.ProcessorCounterFrequency = v_uint64()


class EPROCESS_QUOTA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_24211(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WriteAccess = v_uint32()


class FILE_SEGMENT_ELEMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Buffer = v_ptr64()


class HEAP_DEBUGGING_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterceptorFunction = v_ptr64()
        self.InterceptorValue = v_uint16()
        self._pad000c = v_bytes(size=2)
        self.ExtendedOptions = v_uint32()
        self.StackTraceDepth = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.MinTotalBlockSize = v_uint64()
        self.MaxTotalBlockSize = v_uint64()
        self.HeapLeakEnumerationRoutine = v_ptr64()


class _unnamed_22226(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e2 = _unnamed_22291()


class PENDING_RELATIONS_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = LIST_ENTRY()
        self.WorkItem = WORK_QUEUE_ITEM()
        self.DeviceEvent = v_ptr64()
        self.DeviceObject = v_ptr64()
        self.RelationsList = v_ptr64()
        self.EjectIrp = v_ptr64()
        self.Lock = v_uint32()
        self.Problem = v_uint32()
        self.ProfileChangingEject = v_uint8()
        self.DisplaySafeRemovalDialog = v_uint8()
        self._pad005c = v_bytes(size=2)
        self.LightestSleepState = v_uint32()
        self.DockInterface = v_ptr64()


class _unnamed_22223(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags = v_uint32()


class ACCESS_REASONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(32) ])


class DOCK_INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Context = v_ptr64()
        self.InterfaceReference = v_ptr64()
        self.InterfaceDereference = v_ptr64()
        self.ProfileDepartureSetMode = v_ptr64()
        self.ProfileDepartureUpdate = v_ptr64()


class MMVAD_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CommitCharge = v_uint64()


class MMSUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkingSetMutex = EX_PUSH_LOCK()
        self.ExitGate = v_ptr64()
        self.AccessLog = v_ptr64()
        self.WorkingSetExpansionLinks = LIST_ENTRY()
        self.AgeDistribution = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self.MinimumWorkingSetSize = v_uint32()
        self.WorkingSetSize = v_uint32()
        self.WorkingSetPrivateSize = v_uint32()
        self.MaximumWorkingSetSize = v_uint32()
        self.ChargedWslePages = v_uint32()
        self.ActualWslePages = v_uint32()
        self.WorkingSetSizeOverhead = v_uint32()
        self.PeakWorkingSetSize = v_uint32()
        self.HardFaultCount = v_uint32()
        self.VmWorkingSetList = v_ptr64()
        self.NextPageColor = v_uint16()
        self.LastTrimStamp = v_uint16()
        self.PageFaultCount = v_uint32()
        self.RepurposeCount = v_uint32()
        self.Spare = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.Flags = MMSUPPORT_FLAGS()


class HBASE_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Sequence1 = v_uint32()
        self.Sequence2 = v_uint32()
        self.TimeStamp = LARGE_INTEGER()
        self.Major = v_uint32()
        self.Minor = v_uint32()
        self.Type = v_uint32()
        self.Format = v_uint32()
        self.RootCell = v_uint32()
        self.Length = v_uint32()
        self.Cluster = v_uint32()
        self.FileName = vstruct.VArray([ v_uint8() for i in xrange(64) ])
        self.RmId = GUID()
        self.LogId = GUID()
        self.Flags = v_uint32()
        self.TmId = GUID()
        self.GuidSignature = v_uint32()
        self.Reserved1 = vstruct.VArray([ v_uint32() for i in xrange(85) ])
        self.CheckSum = v_uint32()
        self.Reserved2 = vstruct.VArray([ v_uint32() for i in xrange(882) ])
        self.ThawTmId = GUID()
        self.ThawRmId = GUID()
        self.ThawLogId = GUID()
        self.BootType = v_uint32()
        self.BootRecover = v_uint32()


class BUS_EXTENSION_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.BusExtension = v_ptr64()


class _unnamed_23701(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Event = v_ptr64()


class CMHIVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Hive = HHIVE()
        self.FileHandles = vstruct.VArray([ v_ptr64() for i in xrange(6) ])
        self.NotifyList = LIST_ENTRY()
        self.HiveList = LIST_ENTRY()
        self.PreloadedHiveList = LIST_ENTRY()
        self.HiveRundown = EX_RUNDOWN_REF()
        self.ParseCacheEntries = LIST_ENTRY()
        self.KcbCacheTable = v_ptr64()
        self.KcbCacheTableSize = v_uint32()
        self.Identity = v_uint32()
        self.HiveLock = v_ptr64()
        self.ViewLock = EX_PUSH_LOCK()
        self.ViewLockOwner = v_ptr64()
        self.ViewLockLast = v_uint32()
        self.ViewUnLockLast = v_uint32()
        self.WriterLock = v_ptr64()
        self.FlusherLock = v_ptr64()
        self.FlushDirtyVector = RTL_BITMAP()
        self.FlushOffsetArray = v_ptr64()
        self.FlushOffsetArrayCount = v_uint32()
        self.FlushHiveTruncated = v_uint32()
        self.FlushLock2 = v_ptr64()
        self.SecurityLock = EX_PUSH_LOCK()
        self.MappedViewList = LIST_ENTRY()
        self.PinnedViewList = LIST_ENTRY()
        self.FlushedViewList = LIST_ENTRY()
        self.MappedViewCount = v_uint16()
        self.PinnedViewCount = v_uint16()
        self.UseCount = v_uint32()
        self.ViewsPerHive = v_uint32()
        self._pad06c0 = v_bytes(size=4)
        self.FileObject = v_ptr64()
        self.LastShrinkHiveSize = v_uint32()
        self._pad06d0 = v_bytes(size=4)
        self.ActualFileSize = LARGE_INTEGER()
        self.FileFullPath = UNICODE_STRING()
        self.FileUserName = UNICODE_STRING()
        self.HiveRootPath = UNICODE_STRING()
        self.SecurityCount = v_uint32()
        self.SecurityCacheSize = v_uint32()
        self.SecurityHitHint = v_uint32()
        self._pad0718 = v_bytes(size=4)
        self.SecurityCache = v_ptr64()
        self.SecurityHash = vstruct.VArray([ LIST_ENTRY() for i in xrange(64) ])
        self.UnloadEventCount = v_uint32()
        self._pad0b28 = v_bytes(size=4)
        self.UnloadEventArray = v_ptr64()
        self.RootKcb = v_ptr64()
        self.Frozen = v_uint8()
        self._pad0b40 = v_bytes(size=7)
        self.UnloadWorkItem = v_ptr64()
        self.UnloadWorkItemHolder = CM_WORKITEM()
        self.GrowOnlyMode = v_uint8()
        self._pad0b74 = v_bytes(size=3)
        self.GrowOffset = v_uint32()
        self.KcbConvertListHead = LIST_ENTRY()
        self.KnodeConvertListHead = LIST_ENTRY()
        self.CellRemapArray = v_ptr64()
        self.Flags = v_uint32()
        self._pad0ba8 = v_bytes(size=4)
        self.TrustClassEntry = LIST_ENTRY()
        self.FlushCount = v_uint32()
        self._pad0bc0 = v_bytes(size=4)
        self.CmRm = v_ptr64()
        self.CmRmInitFailPoint = v_uint32()
        self.CmRmInitFailStatus = v_uint32()
        self.CreatorOwner = v_ptr64()
        self.RundownThread = v_ptr64()
        self.LastWriteTime = LARGE_INTEGER()


class I386_LOADER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CommonDataArea = v_ptr64()
        self.MachineType = v_uint32()
        self.VirtualBias = v_uint32()


class PS_PER_CPU_QUOTA_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SortedListEntry = LIST_ENTRY()
        self.IdleOnlyListHead = LIST_ENTRY()
        self.CycleBaseAllowance = v_uint64()
        self.CyclesRemaining = v_uint64()
        self.CurrentGeneration = v_uint32()
        self._pad0040 = v_bytes(size=12)


class DBGKD_GET_SET_BUS_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BusDataType = v_uint32()
        self.BusNumber = v_uint32()
        self.SlotNumber = v_uint32()
        self.Offset = v_uint32()
        self.Length = v_uint32()


class KDPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.Importance = v_uint8()
        self.Number = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DpcListEntry = LIST_ENTRY()
        self.DeferredRoutine = v_ptr64()
        self.DeferredContext = v_ptr64()
        self.SystemArgument1 = v_ptr64()
        self.SystemArgument2 = v_ptr64()
        self.DpcData = v_ptr64()


class _unnamed_22857(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Bin = v_ptr64()
        self.CellPoint = v_ptr64()


class KEVENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class _unnamed_23703(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reason = v_uint32()


class KSEMAPHORE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.Limit = v_uint32()
        self._pad0020 = v_bytes(size=4)


class MM_PAGE_ACCESS_INFO_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = SINGLE_LIST_ENTRY()
        self.Type = v_uint32()
        self.EmptySequenceNumber = v_uint32()
        self.CreateTime = v_uint64()
        self.EmptyTime = v_uint64()
        self.PageEntry = v_ptr64()
        self.FileEntry = v_ptr64()
        self.FirstFileEntry = v_ptr64()
        self.Process = v_ptr64()
        self.SessionId = v_uint32()
        self._pad0048 = v_bytes(size=4)


class SECTION_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartingVa = v_ptr64()
        self.EndingVa = v_ptr64()
        self.Parent = v_ptr64()
        self.LeftChild = v_ptr64()
        self.RightChild = v_ptr64()
        self.Segment = v_ptr64()


class IMAGE_DEBUG_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Characteristics = v_uint32()
        self.TimeDateStamp = v_uint32()
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.Type = v_uint32()
        self.SizeOfData = v_uint32()
        self.AddressOfRawData = v_uint32()
        self.PointerToRawData = v_uint32()


class CONFIGURATION_COMPONENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Class = v_uint32()
        self.Type = v_uint32()
        self.Flags = DEVICE_FLAGS()
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Key = v_uint32()
        self.AffinityMask = v_uint32()
        self.ConfigurationDataLength = v_uint32()
        self.IdentifierLength = v_uint32()
        self.Identifier = v_ptr64()


class PROC_PERF_CONSTRAINT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Prcb = v_ptr64()
        self.PerfContext = v_uint64()
        self.PercentageCap = v_uint32()
        self.ThermalCap = v_uint32()
        self.TargetFrequency = v_uint32()
        self.AcumulatedFullFrequency = v_uint32()
        self.AcumulatedZeroFrequency = v_uint32()
        self.FrequencyHistoryTotal = v_uint32()
        self.AverageFrequency = v_uint32()
        self._pad0030 = v_bytes(size=4)


class CM_INTENT_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerCount = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.OwnerTable = v_ptr64()


class _unnamed_22080(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint64()


class _unnamed_27320(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length64 = v_uint32()


class _unnamed_22081(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Blink = v_uint64()


class KALPC_SECURITY_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleTable = v_ptr64()
        self.ContextHandle = v_ptr64()
        self.OwningProcess = v_ptr64()
        self.OwnerPort = v_ptr64()
        self.DynamicSecurity = SECURITY_CLIENT_CONTEXT()
        self.u1 = _unnamed_24437()
        self._pad0070 = v_bytes(size=4)


class LUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class RELATION_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.MaxCount = v_uint32()
        self.Devices = vstruct.VArray([ v_ptr64() for i in xrange(1) ])


class DBGKD_SET_INTERNAL_BREAKPOINT32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakpointAddress = v_uint32()
        self.Flags = v_uint32()


class THERMAL_INFORMATION_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ThermalStamp = v_uint32()
        self.ThermalConstant1 = v_uint32()
        self.ThermalConstant2 = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.Processors = KAFFINITY_EX()
        self.SamplingPeriod = v_uint32()
        self.CurrentTemperature = v_uint32()
        self.PassiveTripPoint = v_uint32()
        self.CriticalTripPoint = v_uint32()
        self.ActiveTripPointCount = v_uint8()
        self._pad004c = v_bytes(size=3)
        self.ActiveTripPoint = vstruct.VArray([ v_uint32() for i in xrange(10) ])
        self.S4TransitionTripPoint = v_uint32()


class POP_THERMAL_ZONE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = LIST_ENTRY()
        self.State = v_uint8()
        self.Flags = v_uint8()
        self.Mode = v_uint8()
        self.PendingMode = v_uint8()
        self.ActivePoint = v_uint8()
        self.PendingActivePoint = v_uint8()
        self._pad0018 = v_bytes(size=2)
        self.Throttle = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.LastTime = v_uint64()
        self.SampleRate = v_uint32()
        self.LastTemp = v_uint32()
        self.PassiveTimer = KTIMER()
        self.PassiveDpc = KDPC()
        self.OverThrottled = POP_ACTION_TRIGGER()
        self.Irp = v_ptr64()
        self.Info = THERMAL_INFORMATION_EX()
        self.InfoLastUpdateTime = LARGE_INTEGER()
        self.Metrics = POP_THERMAL_ZONE_METRICS()


class POOL_HACKER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = POOL_HEADER()
        self.Contents = vstruct.VArray([ v_uint32() for i in xrange(8) ])


class COMPRESSED_DATA_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CompressionFormatAndEngine = v_uint16()
        self.CompressionUnitShift = v_uint8()
        self.ChunkShift = v_uint8()
        self.ClusterShift = v_uint8()
        self.Reserved = v_uint8()
        self.NumberOfChunks = v_uint16()
        self.CompressedChunkSizes = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class HANDLE_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TableCode = v_uint64()
        self.QuotaProcess = v_ptr64()
        self.UniqueProcessId = v_ptr64()
        self.HandleLock = EX_PUSH_LOCK()
        self.HandleTableList = LIST_ENTRY()
        self.HandleContentionEvent = EX_PUSH_LOCK()
        self.DebugInfo = v_ptr64()
        self.ExtraInfoPages = v_uint32()
        self.Flags = v_uint32()
        self.FirstFreeHandle = v_uint32()
        self._pad0050 = v_bytes(size=4)
        self.LastFreeHandleEntry = v_ptr64()
        self.HandleCount = v_uint32()
        self.NextHandleNeedingPool = v_uint32()
        self.HandleCountHighWatermark = v_uint32()
        self._pad0068 = v_bytes(size=4)


class PO_HIBER_PERF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoTicks = v_uint64()
        self.InitTicks = v_uint64()
        self.CopyTicks = v_uint64()
        self.ElapsedTicks = v_uint64()
        self.CompressTicks = v_uint64()
        self.ResumeAppTime = v_uint64()
        self.HiberFileResumeTime = v_uint64()
        self.BytesCopied = v_uint64()
        self.PagesProcessed = v_uint64()
        self.PagesWritten = v_uint32()
        self.DumpCount = v_uint32()
        self.FileRuns = v_uint32()
        self._pad0058 = v_bytes(size=4)


class DEFERRED_WRITE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self.NodeByteSize = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.FileObject = v_ptr64()
        self.BytesToWrite = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.DeferredWriteLinks = LIST_ENTRY()
        self.Event = v_ptr64()
        self.PostRoutine = v_ptr64()
        self.Context1 = v_ptr64()
        self.Context2 = v_ptr64()


class HEAP_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousBlockPrivateData = v_ptr64()
        self.Size = v_uint16()
        self.Flags = v_uint8()
        self.SmallTagIndex = v_uint8()
        self.PreviousSize = v_uint16()
        self.SegmentOffset = v_uint8()
        self.UnusedBytes = v_uint8()


class _unnamed_21137(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Key = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.ByteOffset = LARGE_INTEGER()


class _unnamed_21283(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.StartSid = v_ptr64()
        self.SidList = v_ptr64()
        self.SidListLength = v_uint32()
        self._pad0020 = v_bytes(size=4)


class ARBITER_INSTANCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.MutexEvent = v_ptr64()
        self.Name = v_ptr64()
        self.OrderingName = v_ptr64()
        self.ResourceType = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.Allocation = v_ptr64()
        self.PossibleAllocation = v_ptr64()
        self.OrderingList = ARBITER_ORDERING_LIST()
        self.ReservedList = ARBITER_ORDERING_LIST()
        self.ReferenceCount = v_uint32()
        self._pad0060 = v_bytes(size=4)
        self.Interface = v_ptr64()
        self.AllocationStackMaxSize = v_uint32()
        self._pad0070 = v_bytes(size=4)
        self.AllocationStack = v_ptr64()
        self.UnpackRequirement = v_ptr64()
        self.PackResource = v_ptr64()
        self.UnpackResource = v_ptr64()
        self.ScoreRequirement = v_ptr64()
        self.TestAllocation = v_ptr64()
        self.RetestAllocation = v_ptr64()
        self.CommitAllocation = v_ptr64()
        self.RollbackAllocation = v_ptr64()
        self.BootAllocation = v_ptr64()
        self.QueryArbitrate = v_ptr64()
        self.QueryConflict = v_ptr64()
        self.AddReserved = v_ptr64()
        self.StartArbiter = v_ptr64()
        self.PreprocessEntry = v_ptr64()
        self.AllocateEntry = v_ptr64()
        self.GetNextAllocationRange = v_ptr64()
        self.FindSuitableRange = v_ptr64()
        self.AddAllocation = v_ptr64()
        self.BacktrackAllocation = v_ptr64()
        self.OverrideConflict = v_ptr64()
        self.InitializeRangeList = v_ptr64()
        self.TransactionInProgress = v_uint8()
        self._pad0128 = v_bytes(size=7)
        self.TransactionEvent = v_ptr64()
        self.Extension = v_ptr64()
        self.BusDeviceObject = v_ptr64()
        self.ConflictCallbackContext = v_ptr64()
        self.ConflictCallback = v_ptr64()
        self.PdoDescriptionString = vstruct.VArray([ v_uint16() for i in xrange(336) ])
        self.PdoSymbolicNameString = vstruct.VArray([ v_uint8() for i in xrange(672) ])
        self.PdoAddressString = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0698 = v_bytes(size=6)


class NAMED_PIPE_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NamedPipeType = v_uint32()
        self.ReadMode = v_uint32()
        self.CompletionMode = v_uint32()
        self.MaximumInstances = v_uint32()
        self.InboundQuota = v_uint32()
        self.OutboundQuota = v_uint32()
        self.DefaultTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0028 = v_bytes(size=7)


class MMSUPPORT_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkingSetType = v_uint8()
        self.SessionMaster = v_uint8()
        self.MemoryPriority = v_uint8()
        self.WsleDeleted = v_uint8()


class PROC_PERF_DOMAIN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = LIST_ENTRY()
        self.Master = v_ptr64()
        self.Members = KAFFINITY_EX()
        self.FeedbackHandler = v_ptr64()
        self.GetFFHThrottleState = v_ptr64()
        self.BoostPolicyHandler = v_ptr64()
        self.PerfSelectionHandler = v_ptr64()
        self.PerfHandler = v_ptr64()
        self.Processors = v_ptr64()
        self.PerfChangeTime = v_uint64()
        self.ProcessorCount = v_uint32()
        self.PreviousFrequencyMhz = v_uint32()
        self.CurrentFrequencyMhz = v_uint32()
        self.PreviousFrequency = v_uint32()
        self.CurrentFrequency = v_uint32()
        self.CurrentPerfContext = v_uint32()
        self.DesiredFrequency = v_uint32()
        self.MaxFrequency = v_uint32()
        self.MinPerfPercent = v_uint32()
        self.MinThrottlePercent = v_uint32()
        self.MaxPercent = v_uint32()
        self.MinPercent = v_uint32()
        self.ConstrainedMaxPercent = v_uint32()
        self.ConstrainedMinPercent = v_uint32()
        self.Coordination = v_uint8()
        self._pad00b4 = v_bytes(size=3)
        self.PerfChangeIntervalCount = v_uint32()


class EXCEPTION_REGISTRATION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Handler = v_ptr64()


class FILE_BASIC_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0028 = v_bytes(size=4)


class PLUGPLAY_EVENT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EventGuid = GUID()
        self.EventCategory = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Result = v_ptr64()
        self.Flags = v_uint32()
        self.TotalSize = v_uint32()
        self.DeviceObject = v_ptr64()
        self.u = _unnamed_25968()


class LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_ptr64()
        self.Blink = v_ptr64()


class M128A(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Low = v_uint64()
        self.High = v_uint64()


class CM_KEY_SECURITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.Reserved = v_uint16()
        self.Flink = v_uint32()
        self.Blink = v_uint32()
        self.ReferenceCount = v_uint32()
        self.DescriptorLength = v_uint32()
        self.Descriptor = SECURITY_DESCRIPTOR_RELATIVE()


class _unnamed_22031(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EfiInformation = EFI_FIRMWARE_INFORMATION()


class PNP_DEVICE_COMPLETION_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DispatchedList = LIST_ENTRY()
        self.DispatchedCount = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.CompletedList = LIST_ENTRY()
        self.CompletedSemaphore = KSEMAPHORE()
        self.SpinLock = v_uint64()


class HMAP_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BlockAddress = v_uint64()
        self.BinAddress = v_uint64()
        self.CmView = v_ptr64()
        self.MemAlloc = v_uint32()
        self._pad0020 = v_bytes(size=4)


class _unnamed_22853(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CheckStack = v_ptr64()


class POP_ACTION_TRIGGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.Flags = v_uint32()
        self.Wait = v_ptr64()
        self.Battery = _unnamed_26758()
        self._pad0018 = v_bytes(size=4)


class ETW_REALTIME_CONSUMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Links = LIST_ENTRY()
        self.ProcessHandle = v_ptr64()
        self.ProcessObject = v_ptr64()
        self.NextNotDelivered = v_ptr64()
        self.RealtimeConnectContext = v_ptr64()
        self.DisconnectEvent = v_ptr64()
        self.DataAvailableEvent = v_ptr64()
        self.UserBufferCount = v_ptr64()
        self.UserBufferListHead = v_ptr64()
        self.BuffersLost = v_uint32()
        self.EmptyBuffersCount = v_uint32()
        self.LoggerId = v_uint32()
        self.ShutDownRequested = v_uint8()
        self.NewBuffersLost = v_uint8()
        self.Disconnected = v_uint8()
        self._pad0060 = v_bytes(size=1)
        self.ReservedBufferSpaceBitMap = RTL_BITMAP()
        self.ReservedBufferSpace = v_ptr64()
        self.ReservedBufferSpaceSize = v_uint32()
        self.UserPagesAllocated = v_uint32()
        self.UserPagesReused = v_uint32()
        self.Wow = v_uint8()
        self._pad0088 = v_bytes(size=3)


class _unnamed_26860(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllSharedExportThunks = VF_TARGET_ALL_SHARED_EXPORT_THUNKS()


class CM_CACHED_VALUE_INDEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CellIndex = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Data = _unnamed_27360()


class MI_EXTRA_IMAGE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfHeaders = v_uint32()
        self.SizeOfImage = v_uint32()


class DEVICE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DosDevicesDirectory = v_ptr64()
        self.GlobalDosDevicesDirectory = v_ptr64()
        self.DosDevicesDirectoryHandle = v_ptr64()
        self.ReferenceCount = v_uint32()
        self.DriveMap = v_uint32()
        self.DriveType = vstruct.VArray([ v_uint8() for i in xrange(32) ])


class DBGKD_READ_WRITE_IO_EXTENDED32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.AddressSpace = v_uint32()
        self.IoAddress = v_uint32()
        self.DataValue = v_uint32()


class _unnamed_26693(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.MinBusNumber = v_uint32()
        self.MaxBusNumber = v_uint32()
        self.Reserved = v_uint32()


class CONTROL_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Segment = v_ptr64()
        self.DereferenceList = LIST_ENTRY()
        self.NumberOfSectionReferences = v_uint64()
        self.NumberOfPfnReferences = v_uint64()
        self.NumberOfMappedViews = v_uint64()
        self.NumberOfUserReferences = v_uint64()
        self.u = _unnamed_22223()
        self.FlushInProgressCount = v_uint32()
        self.FilePointer = EX_FAST_REF()
        self.ControlAreaLock = v_uint32()
        self.ModifiedWriteCount = v_uint32()
        self.WaitingForDeletion = v_ptr64()
        self.u2 = _unnamed_22226()
        self.LockedPages = v_uint64()
        self.ViewList = LIST_ENTRY()


class _unnamed_26691(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(3) ])


class KERNEL_STACK_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Current = KERNEL_STACK_SEGMENT()
        self.Previous = KERNEL_STACK_SEGMENT()


class VI_TRACK_IRQL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Thread = v_ptr64()
        self.OldIrql = v_uint8()
        self.NewIrql = v_uint8()
        self.Processor = v_uint16()
        self.TickCount = v_uint32()
        self.StackTrace = vstruct.VArray([ v_ptr64() for i in xrange(5) ])


class GUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data1 = v_uint32()
        self.Data2 = v_uint16()
        self.Data3 = v_uint16()
        self.Data4 = vstruct.VArray([ v_uint8() for i in xrange(8) ])


class HEAP_UCR_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.SegmentEntry = LIST_ENTRY()
        self.Address = v_ptr64()
        self.Size = v_uint64()


class _unnamed_26698(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Priority = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class _unnamed_26653(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Last = v_uint32()
        self.u = _unnamed_26650()


class _unnamed_21218(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.EaList = v_ptr64()
        self.EaListLength = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.EaIndex = v_uint32()
        self._pad0020 = v_bytes(size=4)


class POP_SYSTEM_IDLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AverageIdleness = v_uint32()
        self.LowestIdleness = v_uint32()
        self.Time = v_uint32()
        self.Timeout = v_uint32()
        self.LastUserInput = v_uint32()
        self.Action = POWER_ACTION_POLICY()
        self.MinState = v_uint32()
        self.SystemRequired = v_uint8()
        self.IdleWorker = v_uint8()
        self.Sampling = v_uint8()
        self._pad0028 = v_bytes(size=1)
        self.LastTick = v_uint64()
        self.LastSystemRequiredTime = v_uint32()
        self._pad0038 = v_bytes(size=4)


class KAPC_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ApcListHead = vstruct.VArray([ LIST_ENTRY() for i in xrange(2) ])
        self.Process = v_ptr64()
        self.KernelApcInProgress = v_uint8()
        self.KernelApcPending = v_uint8()
        self.UserApcPending = v_uint8()
        self._pad0030 = v_bytes(size=5)


class SLIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self._pad0010 = v_bytes(size=8)


class _unnamed_19309(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMiddle = v_uint8()
        self.Flags1 = v_uint8()
        self.Flags2 = v_uint8()
        self.BaseHigh = v_uint8()


class MMVAD_SHORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_22375()
        self.LeftChild = v_ptr64()
        self.RightChild = v_ptr64()
        self.StartingVpn = v_uint64()
        self.EndingVpn = v_uint64()
        self.u = _unnamed_22378()
        self.PushLock = EX_PUSH_LOCK()
        self.u5 = _unnamed_22379()


class DBGKD_GET_VERSION32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.ProtocolVersion = v_uint16()
        self.Flags = v_uint16()
        self.KernBase = v_uint32()
        self.PsLoadedModuleList = v_uint32()
        self.MachineType = v_uint16()
        self.ThCallbackStack = v_uint16()
        self.NextCallback = v_uint16()
        self.FramePointer = v_uint16()
        self.KiCallUserMode = v_uint32()
        self.KeUserCallbackDispatcher = v_uint32()
        self.BreakpointWithStatus = v_uint32()
        self.DebuggerDataList = v_uint32()


class CM_CELL_REMAP_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OldCell = v_uint32()
        self.NewCell = v_uint32()


class PNP_DEVICE_ACTION_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.DeviceObject = v_ptr64()
        self.RequestType = v_uint32()
        self.ReorderingBarrier = v_uint8()
        self._pad0020 = v_bytes(size=3)
        self.RequestArgument = v_uint64()
        self.CompletionEvent = v_ptr64()
        self.CompletionStatus = v_ptr64()


class _unnamed_26650(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserData = v_uint32()


class KDPC_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DpcListHead = LIST_ENTRY()
        self.DpcLock = v_uint64()
        self.DpcQueueDepth = v_uint32()
        self.DpcCount = v_uint32()


class _unnamed_26656(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u = _unnamed_26650()


class _unnamed_24439(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revoked = v_uint32()


class IO_STATUS_BLOCK32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.Information = v_uint32()


class XSAVE_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LegacyState = XSAVE_FORMAT()
        self.Header = XSAVE_AREA_HEADER()


class _unnamed_21198(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FileName = v_ptr64()
        self.FileInformationClass = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.FileIndex = v_uint32()
        self._pad0020 = v_bytes(size=4)


class IRP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.MdlAddress = v_ptr64()
        self.Flags = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.AssociatedIrp = _unnamed_21001()
        self.ThreadListEntry = LIST_ENTRY()
        self.IoStatus = IO_STATUS_BLOCK()
        self.RequestorMode = v_uint8()
        self.PendingReturned = v_uint8()
        self.StackCount = v_uint8()
        self.CurrentLocation = v_uint8()
        self.Cancel = v_uint8()
        self.CancelIrql = v_uint8()
        self.ApcEnvironment = v_uint8()
        self.AllocationFlags = v_uint8()
        self.UserIosb = v_ptr64()
        self.UserEvent = v_ptr64()
        self.Overlay = _unnamed_21003()
        self.CancelRoutine = v_ptr64()
        self.UserBuffer = v_ptr64()
        self.Tail = _unnamed_21006()


class KTHREAD_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitReasonBitMap = v_uint64()
        self.UserData = v_ptr64()
        self.Flags = v_uint32()
        self.ContextSwitches = v_uint32()
        self.CycleTimeBias = v_uint64()
        self.HardwareCounters = v_uint64()
        self.HwCounter = vstruct.VArray([ COUNTER_READING() for i in xrange(16) ])


class _unnamed_24437(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24439()


class MMADDRESS_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_25432()
        self.EndVa = v_ptr64()


class _unnamed_21850(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Long = v_uint64()


class OBJECT_REF_TRACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StackTrace = vstruct.VArray([ v_ptr64() for i in xrange(16) ])


class KALPC_RESERVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerPort = v_ptr64()
        self.HandleTable = v_ptr64()
        self.Handle = v_ptr64()
        self.Message = v_ptr64()
        self.Active = v_uint32()
        self._pad0028 = v_bytes(size=4)


class KINTERRUPT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.InterruptListEntry = LIST_ENTRY()
        self.ServiceRoutine = v_ptr64()
        self.MessageServiceRoutine = v_ptr64()
        self.MessageIndex = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.ServiceContext = v_ptr64()
        self.SpinLock = v_uint64()
        self.TickCount = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.ActualLock = v_ptr64()
        self.DispatchAddress = v_ptr64()
        self.Vector = v_uint32()
        self.Irql = v_uint8()
        self.SynchronizeIrql = v_uint8()
        self.FloatingSave = v_uint8()
        self.Connected = v_uint8()
        self.Number = v_uint32()
        self.ShareVector = v_uint8()
        self.Pad = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.Mode = v_uint32()
        self.Polarity = v_uint32()
        self.ServiceCount = v_uint32()
        self.DispatchCount = v_uint32()
        self.Rsvd1 = v_uint64()
        self.TrapFrame = v_ptr64()
        self.Reserved = v_ptr64()
        self.DispatchCode = vstruct.VArray([ v_uint32() for i in xrange(4) ])


class SECURITY_DESCRIPTOR_RELATIVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.Sbz1 = v_uint8()
        self.Control = v_uint16()
        self.Owner = v_uint32()
        self.Group = v_uint32()
        self.Sacl = v_uint32()
        self.Dacl = v_uint32()


class DUMP_INITIALIZATION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Reserved = v_uint32()
        self.MemoryBlock = v_ptr64()
        self.CommonBuffer = vstruct.VArray([ v_ptr64() for i in xrange(2) ])
        self.PhysicalAddress = vstruct.VArray([ LARGE_INTEGER() for i in xrange(2) ])
        self.StallRoutine = v_ptr64()
        self.OpenRoutine = v_ptr64()
        self.WriteRoutine = v_ptr64()
        self.FinishRoutine = v_ptr64()
        self.AdapterObject = v_ptr64()
        self.MappedRegisterBase = v_ptr64()
        self.PortConfiguration = v_ptr64()
        self.CrashDump = v_uint8()
        self._pad006c = v_bytes(size=3)
        self.MaximumTransferSize = v_uint32()
        self.CommonBufferSize = v_uint32()
        self._pad0078 = v_bytes(size=4)
        self.TargetAddress = v_ptr64()
        self.WritePendingRoutine = v_ptr64()
        self.PartitionStyle = v_uint32()
        self.DiskInfo = _unnamed_29494()
        self._pad00a0 = v_bytes(size=4)


class _unnamed_27314(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length40 = v_uint32()


class CELL_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u = u()


class VERIFIER_SHARED_EXPORT_THUNK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class FILE_GET_QUOTA_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextEntryOffset = v_uint32()
        self.SidLength = v_uint32()
        self.Sid = SID()


class OBJECT_HANDLE_COUNT_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Process = v_ptr64()
        self.HandleCount = v_uint32()
        self._pad0010 = v_bytes(size=4)


class PORT_MESSAGE32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_24044()
        self.u2 = _unnamed_24045()
        self.ClientId = CLIENT_ID32()
        self.MessageId = v_uint32()
        self.ClientViewSize = v_uint32()


class KGATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class IO_COMPLETION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = v_ptr64()
        self.Key = v_ptr64()


class _unnamed_26942(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BlockedDriverGuid = GUID()


class DRIVER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DriverObject = v_ptr64()
        self.AddDevice = v_ptr64()
        self.Count = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.ServiceKeyName = UNICODE_STRING()
        self.ClientDriverExtension = v_ptr64()
        self.FsFilterCallbacks = v_ptr64()


class _unnamed_26946(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerSettingGuid = GUID()
        self.Flags = v_uint32()
        self.SessionId = v_uint32()
        self.DataLength = v_uint32()
        self.Data = vstruct.VArray([ v_uint8() for i in xrange(1) ])
        self._pad0020 = v_bytes(size=3)


class PCW_REGISTRATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_26944(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ParentId = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class PO_IRP_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CurrentIrp = v_ptr64()
        self.PendingIrpList = v_ptr64()


class TP_NBQ_GUARD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GuardLinks = LIST_ENTRY()
        self.Guards = vstruct.VArray([ v_ptr64() for i in xrange(2) ])


class _unnamed_21457(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr64()
        self.Argument2 = v_ptr64()
        self.Argument3 = v_ptr64()
        self.Argument4 = v_ptr64()


class flags(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Removable = v_uint8()


class _unnamed_21452(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProviderId = v_uint64()
        self.DataPath = v_ptr64()
        self.BufferSize = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Buffer = v_ptr64()


class DBGKD_SEARCH_MEMORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SearchAddress = v_uint64()
        self.SearchLength = v_uint64()
        self.PatternLength = v_uint32()
        self._pad0018 = v_bytes(size=4)


class _unnamed_22910(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OldCell = _unnamed_26653()


class ALPC_COMPLETION_PACKET_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint64()
        self.Size = v_uint32()
        self.ActiveCount = v_uint32()
        self.PendingNullCount = v_uint32()
        self.PendingCheckCompletionListCount = v_uint32()
        self.PendingDelete = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.FreeListHead = SINGLE_LIST_ENTRY()
        self.CompletionPort = v_ptr64()
        self.CompletionKey = v_ptr64()
        self.Entry = vstruct.VArray([ ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY() for i in xrange(1) ])


class WHEA_PERSISTENCE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint64()


class ETW_LAST_ENABLE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnableFlags = LARGE_INTEGER()
        self.LoggerId = v_uint16()
        self.Level = v_uint8()
        self.Enabled = v_uint8()
        self._pad0010 = v_bytes(size=4)


class HEAP_VIRTUAL_ALLOC_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = LIST_ENTRY()
        self.ExtraStuff = HEAP_ENTRY_EXTRA()
        self.CommitSize = v_uint64()
        self.ReserveSize = v_uint64()
        self.BusyBlock = HEAP_ENTRY()


class VI_DEADLOCK_THREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Thread = v_ptr64()
        self.CurrentSpinNode = v_ptr64()
        self.CurrentOtherNode = v_ptr64()
        self.ListEntry = LIST_ENTRY()
        self.NodeCount = v_uint32()
        self.PagingCount = v_uint32()
        self.ThreadUsesEresources = v_uint8()
        self._pad0038 = v_bytes(size=7)


class PPM_PERF_STATES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.MaxFrequency = v_uint32()
        self.PStateCap = v_uint32()
        self.TStateCap = v_uint32()
        self.MaxPerfState = v_uint32()
        self.MinPerfState = v_uint32()
        self.LowestPState = v_uint32()
        self.IncreaseTime = v_uint32()
        self.DecreaseTime = v_uint32()
        self.BusyAdjThreshold = v_uint8()
        self.Reserved = v_uint8()
        self.ThrottleStatesOnly = v_uint8()
        self.PolicyType = v_uint8()
        self.TimerInterval = v_uint32()
        self.Flags = _unnamed_27702()
        self.TargetProcessors = KAFFINITY_EX()
        self.PStateHandler = v_ptr64()
        self.PStateContext = v_uint64()
        self.TStateHandler = v_ptr64()
        self.TStateContext = v_uint64()
        self.FeedbackHandler = v_ptr64()
        self.GetFFHThrottleState = v_ptr64()
        self.State = vstruct.VArray([ PPM_PERF_STATE() for i in xrange(1) ])


class _unnamed_24097(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24098()


class GDI_TEB_BATCH32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.HDC = v_uint32()
        self.Buffer = vstruct.VArray([ v_uint32() for i in xrange(310) ])


class ARBITER_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parameters = _unnamed_27515()


class EXCEPTION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_ptr64()
        self.ExceptionAddress = v_ptr64()
        self.NumberParameters = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.ExceptionInformation = vstruct.VArray([ v_uint64() for i in xrange(15) ])


class _unnamed_23699(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SharedCacheMap = v_ptr64()


class MMPTE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u = _unnamed_21850()


class VI_DEADLOCK_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parent = v_ptr64()
        self.ChildrenList = LIST_ENTRY()
        self.SiblingsList = LIST_ENTRY()
        self.ResourceList = LIST_ENTRY()
        self.Root = v_ptr64()
        self.ThreadEntry = v_ptr64()
        self.u1 = _unnamed_28937()
        self.ChildrenCount = v_uint32()
        self.StackTrace = vstruct.VArray([ v_ptr64() for i in xrange(8) ])
        self.ParentStackTrace = vstruct.VArray([ v_ptr64() for i in xrange(8) ])


class PROC_IDLE_STATE_BUCKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalTime = v_uint64()
        self.MinTime = v_uint64()
        self.MaxTime = v_uint64()
        self.Count = v_uint32()
        self._pad0020 = v_bytes(size=4)


class _unnamed_24098(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReferenceCache = v_uint8()


class VACB_ARRAY_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VacbArrayIndex = v_uint32()
        self.MappingCount = v_uint32()
        self.HighestMappedIndex = v_uint32()
        self.Reserved = v_uint32()


class HEAP_STOP_ON_TAG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HeapAndTagIndex = v_uint32()


class KPCR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.IdtBase = v_ptr64()
        self.Unused = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.Irql = v_uint8()
        self.SecondLevelCacheAssociativity = v_uint8()
        self.ObsoleteNumber = v_uint8()
        self.Fill0 = v_uint8()
        self.Unused0 = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.StallScaleFactor = v_uint32()
        self.Unused1 = vstruct.VArray([ v_ptr64() for i in xrange(3) ])
        self.KernelReserved = vstruct.VArray([ v_uint32() for i in xrange(15) ])
        self.SecondLevelCacheSize = v_uint32()
        self.HalReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.Unused2 = v_uint32()
        self._pad0108 = v_bytes(size=4)
        self.KdVersionBlock = v_ptr64()
        self.Unused3 = v_ptr64()
        self.PcrAlign1 = vstruct.VArray([ v_uint32() for i in xrange(24) ])
        self._pad0180 = v_bytes(size=8)
        self.Prcb = KPRCB()


class IMAGE_FILE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Machine = v_uint16()
        self.NumberOfSections = v_uint16()
        self.TimeDateStamp = v_uint32()
        self.PointerToSymbolTable = v_uint32()
        self.NumberOfSymbols = v_uint32()
        self.SizeOfOptionalHeader = v_uint16()
        self.Characteristics = v_uint16()


class CM_KEY_INDEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.Count = v_uint16()
        self.List = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class FILE_STANDARD_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.NumberOfLinks = v_uint32()
        self.DeletePending = v_uint8()
        self.Directory = v_uint8()
        self._pad0018 = v_bytes(size=2)


class RELATION_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.TagCount = v_uint32()
        self.FirstLevel = v_uint32()
        self.MaxLevel = v_uint32()
        self.Entries = vstruct.VArray([ v_ptr64() for i in xrange(1) ])


class PI_RESOURCE_ARBITER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceArbiterList = LIST_ENTRY()
        self.ResourceType = v_uint8()
        self._pad0018 = v_bytes(size=7)
        self.ArbiterInterface = v_ptr64()
        self.DeviceNode = v_ptr64()
        self.ResourceList = LIST_ENTRY()
        self.BestResourceList = LIST_ENTRY()
        self.BestConfig = LIST_ENTRY()
        self.ActiveArbiterList = LIST_ENTRY()
        self.State = v_uint8()
        self.ResourcesChanged = v_uint8()
        self._pad0070 = v_bytes(size=6)


class _unnamed_26939(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VetoType = v_uint32()
        self.DeviceIdVetoNameBuffer = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0008 = v_bytes(size=2)


class _unnamed_26936(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationCode = v_uint32()
        self.NotificationData = v_uint32()


class _unnamed_21404(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerState = v_uint32()


class _unnamed_26934(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Notification = v_ptr64()


class TOKEN_SOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SourceName = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.SourceIdentifier = LUID()


class _unnamed_25968(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceClass = _unnamed_26924()
        self._pad0020 = v_bytes(size=12)


class _unnamed_22291(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumberOfSystemCacheViews = v_uint32()
        self.WritableUserReferences = v_uint32()
        self.SubsectionRoot = v_ptr64()


class _unnamed_26931(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationStructure = v_ptr64()
        self.DeviceIds = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0010 = v_bytes(size=6)


class TRACE_ENABLE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LoggerId = v_uint16()
        self.Level = v_uint8()
        self.InternalFlag = v_uint8()
        self.EnableFlags = v_uint32()


class _unnamed_27360(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CellData = CELL_DATA()


class PEB_LDR_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Initialized = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.SsHandle = v_ptr64()
        self.InLoadOrderModuleList = LIST_ENTRY()
        self.InMemoryOrderModuleList = LIST_ENTRY()
        self.InInitializationOrderModuleList = LIST_ENTRY()
        self.EntryInProgress = v_ptr64()
        self.ShutdownInProgress = v_uint8()
        self._pad0050 = v_bytes(size=7)
        self.ShutdownThreadId = v_ptr64()


class DBGKD_WRITE_BREAKPOINT64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakPointAddress = v_uint64()
        self.BreakPointHandle = v_uint32()
        self._pad0010 = v_bytes(size=4)


class FSRTL_ADVANCED_FCB_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self.NodeByteSize = v_uint16()
        self.Flags = v_uint8()
        self.IsFastIoPossible = v_uint8()
        self.Flags2 = v_uint8()
        self.Reserved = v_uint8()
        self.Resource = v_ptr64()
        self.PagingIoResource = v_ptr64()
        self.AllocationSize = LARGE_INTEGER()
        self.FileSize = LARGE_INTEGER()
        self.ValidDataLength = LARGE_INTEGER()
        self.FastMutex = v_ptr64()
        self.FilterContexts = LIST_ENTRY()
        self.PushLock = EX_PUSH_LOCK()
        self.FileContextSupportPointer = v_ptr64()


class _unnamed_21271(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vpb = v_ptr64()
        self.DeviceObject = v_ptr64()


class DIAGNOSTIC_BUFFER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint64()
        self.CallerType = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.ProcessImageNameOffset = v_uint64()
        self.ProcessId = v_uint32()
        self.ServiceTag = v_uint32()
        self.ReasonOffset = v_uint64()


class MM_PAGE_ACCESS_INFO_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.File = _unnamed_25217()


class SECURITY_SUBJECT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientToken = v_ptr64()
        self.ImpersonationLevel = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.PrimaryToken = v_ptr64()
        self.ProcessAuditId = v_ptr64()


class _unnamed_22464(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Balance = v_uint64()


class X86_DBGKD_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TraceFlag = v_uint32()
        self.Dr7 = v_uint32()
        self.CurrentSymbolStart = v_uint32()
        self.CurrentSymbolEnd = v_uint32()


class PROFILE_PARAMETER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint16()
        self.Reserved = v_uint16()
        self.DockingState = v_uint16()
        self.Capabilities = v_uint16()
        self.DockID = v_uint32()
        self.SerialNumber = v_uint32()


class ALPC_MESSAGE_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedAttributes = v_uint32()
        self.ValidAttributes = v_uint32()


class POP_THERMAL_ZONE_METRICS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MetricsResource = ERESOURCE()
        self.ActiveCount = v_uint32()
        self.PassiveCount = v_uint32()
        self.LastActiveStartTick = LARGE_INTEGER()
        self.AverageActiveTime = LARGE_INTEGER()
        self.LastPassiveStartTick = LARGE_INTEGER()
        self.AveragePassiveTime = LARGE_INTEGER()
        self.StartTickSinceLastReset = LARGE_INTEGER()


class PCW_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = v_ptr64()
        self.Size = v_uint32()
        self._pad0010 = v_bytes(size=4)


class DEVICE_RELATIONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Objects = vstruct.VArray([ v_ptr64() for i in xrange(1) ])


class ETW_PROVIDER_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RefCount = v_uint32()
        self.State = v_uint32()
        self.RegEntry = v_ptr64()
        self.Caller = v_ptr64()


class MMSUBSECTION_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SubsectionAccessed = v_uint16()
        self.SubsectionStatic = v_uint16()


class INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Context = v_ptr64()
        self.InterfaceReference = v_ptr64()
        self.InterfaceDereference = v_ptr64()


class STRING32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_uint32()


class WMI_LOGGER_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LoggerId = v_uint32()
        self.BufferSize = v_uint32()
        self.MaximumEventSize = v_uint32()
        self.CollectionOn = v_uint32()
        self.LoggerMode = v_uint32()
        self.AcceptNewEvents = v_uint32()
        self.GetCpuClock = v_ptr64()
        self.StartTime = LARGE_INTEGER()
        self.LogFileHandle = v_ptr64()
        self.LoggerThread = v_ptr64()
        self.LoggerStatus = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.NBQHead = v_ptr64()
        self.OverflowNBQHead = v_ptr64()
        self.QueueBlockFreeList = SLIST_HEADER()
        self.GlobalList = LIST_ENTRY()
        self.BatchedBufferList = v_ptr64()
        self.LoggerName = UNICODE_STRING()
        self.LogFileName = UNICODE_STRING()
        self.LogFilePattern = UNICODE_STRING()
        self.NewLogFileName = UNICODE_STRING()
        self.ClockType = v_uint32()
        self.MaximumFileSize = v_uint32()
        self.LastFlushedBuffer = v_uint32()
        self.FlushTimer = v_uint32()
        self.FlushThreshold = v_uint32()
        self._pad00d0 = v_bytes(size=4)
        self.ByteOffset = LARGE_INTEGER()
        self.MinimumBuffers = v_uint32()
        self.BuffersAvailable = v_uint32()
        self.NumberOfBuffers = v_uint32()
        self.MaximumBuffers = v_uint32()
        self.EventsLost = v_uint32()
        self.BuffersWritten = v_uint32()
        self.LogBuffersLost = v_uint32()
        self.RealTimeBuffersDelivered = v_uint32()
        self.RealTimeBuffersLost = v_uint32()
        self._pad0100 = v_bytes(size=4)
        self.SequencePtr = v_ptr64()
        self.LocalSequence = v_uint32()
        self.InstanceGuid = GUID()
        self.FileCounter = v_uint32()
        self.BufferCallback = v_ptr64()
        self.PoolType = v_uint32()
        self._pad0130 = v_bytes(size=4)
        self.ReferenceTime = ETW_REF_CLOCK()
        self.Consumers = LIST_ENTRY()
        self.NumConsumers = v_uint32()
        self._pad0158 = v_bytes(size=4)
        self.TransitionConsumer = v_ptr64()
        self.RealtimeLogfileHandle = v_ptr64()
        self.RealtimeLogfileName = UNICODE_STRING()
        self.RealtimeWriteOffset = LARGE_INTEGER()
        self.RealtimeReadOffset = LARGE_INTEGER()
        self.RealtimeLogfileSize = LARGE_INTEGER()
        self.RealtimeLogfileUsage = v_uint64()
        self.RealtimeMaximumFileSize = v_uint64()
        self.RealtimeBuffersSaved = v_uint32()
        self._pad01a8 = v_bytes(size=4)
        self.RealtimeReferenceTime = ETW_REF_CLOCK()
        self.NewRTEventsLost = v_uint32()
        self._pad01c0 = v_bytes(size=4)
        self.LoggerEvent = KEVENT()
        self.FlushEvent = KEVENT()
        self.FlushTimeOutTimer = KTIMER()
        self.FlushDpc = KDPC()
        self.LoggerMutex = KMUTANT()
        self.LoggerLock = EX_PUSH_LOCK()
        self.BufferListSpinLock = v_uint64()
        self.ClientSecurityContext = SECURITY_CLIENT_CONTEXT()
        self.SecurityDescriptor = EX_FAST_REF()
        self.BufferSequenceNumber = v_uint64()
        self.Flags = v_uint32()
        self.RequestFlag = v_uint32()
        self.HookIdMap = RTL_BITMAP()
        self._pad0330 = v_bytes(size=8)


class THREAD_PERFORMANCE_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.ProcessorNumber = PROCESSOR_NUMBER()
        self.ContextSwitches = v_uint32()
        self.HwCountersCount = v_uint32()
        self.UpdateCount = v_uint64()
        self.WaitReasonBitMap = v_uint64()
        self.HardwareCounters = v_uint64()
        self.CycleTime = COUNTER_READING()
        self.HwCounters = vstruct.VArray([ COUNTER_READING() for i in xrange(16) ])


class IO_STACK_LOCATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorFunction = v_uint8()
        self.MinorFunction = v_uint8()
        self.Flags = v_uint8()
        self.Control = v_uint8()
        self._pad0008 = v_bytes(size=4)
        self.Parameters = _unnamed_21040()
        self.DeviceObject = v_ptr64()
        self.FileObject = v_ptr64()
        self.CompletionRoutine = v_ptr64()
        self.Context = v_ptr64()


class DBGKD_READ_WRITE_MSR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Msr = v_uint32()
        self.DataValueLow = v_uint32()
        self.DataValueHigh = v_uint32()


class ARBITER_QUERY_CONFLICT_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PhysicalDeviceObject = v_ptr64()
        self.ConflictingResource = v_ptr64()
        self.ConflictCount = v_ptr64()
        self.Conflicts = v_ptr64()


class _unnamed_27931(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ResourceToRelease = v_ptr64()


class IMAGE_DATA_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_uint32()
        self.Size = v_uint32()


class FILE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DeviceObject = v_ptr64()
        self.Vpb = v_ptr64()
        self.FsContext = v_ptr64()
        self.FsContext2 = v_ptr64()
        self.SectionObjectPointer = v_ptr64()
        self.PrivateCacheMap = v_ptr64()
        self.FinalStatus = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.RelatedFileObject = v_ptr64()
        self.LockOperation = v_uint8()
        self.DeletePending = v_uint8()
        self.ReadAccess = v_uint8()
        self.WriteAccess = v_uint8()
        self.DeleteAccess = v_uint8()
        self.SharedRead = v_uint8()
        self.SharedWrite = v_uint8()
        self.SharedDelete = v_uint8()
        self.Flags = v_uint32()
        self._pad0058 = v_bytes(size=4)
        self.FileName = UNICODE_STRING()
        self.CurrentByteOffset = LARGE_INTEGER()
        self.Waiters = v_uint32()
        self.Busy = v_uint32()
        self.LastLock = v_ptr64()
        self.Lock = KEVENT()
        self.Event = KEVENT()
        self.CompletionContext = v_ptr64()
        self.IrpListLock = v_uint64()
        self.IrpList = LIST_ENTRY()
        self.FileObjectExtension = v_ptr64()


class PPM_IDLE_STATES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Flags = _unnamed_25467()
        self.TargetState = v_uint32()
        self.ActualState = v_uint32()
        self.OldState = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.TargetProcessors = KAFFINITY_EX()
        self.State = vstruct.VArray([ PPM_IDLE_STATE() for i in xrange(1) ])


class MMWSLE_HASH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Index = v_uint32()


class _unnamed_27702(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsULONG = v_uint32()


class MMPTE_PROTOTYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint64()


class VF_TARGET_DRIVER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TreeNode = VF_AVL_TREE_NODE()
        self.u1 = _unnamed_26860()
        self.VerifiedData = v_ptr64()


class PCW_CALLBACK_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AddCounter = PCW_COUNTER_INFORMATION()
        self._pad0028 = v_bytes(size=24)


class KENLISTMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cookie = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.NamespaceLink = KTMOBJECT_NAMESPACE_LINK()
        self.EnlistmentId = GUID()
        self.Mutex = KMUTANT()
        self.NextSameTx = LIST_ENTRY()
        self.NextSameRm = LIST_ENTRY()
        self.ResourceManager = v_ptr64()
        self.Transaction = v_ptr64()
        self.State = v_uint32()
        self.Flags = v_uint32()
        self.NotificationMask = v_uint32()
        self._pad00b8 = v_bytes(size=4)
        self.Key = v_ptr64()
        self.KeyRefCount = v_uint32()
        self._pad00c8 = v_bytes(size=4)
        self.RecoveryInformation = v_ptr64()
        self.RecoveryInformationLength = v_uint32()
        self._pad00d8 = v_bytes(size=4)
        self.DynamicNameInformation = v_ptr64()
        self.DynamicNameInformationLength = v_uint32()
        self._pad00e8 = v_bytes(size=4)
        self.FinalNotification = v_ptr64()
        self.SupSubEnlistment = v_ptr64()
        self.SupSubEnlHandle = v_ptr64()
        self.SubordinateTxHandle = v_ptr64()
        self.CrmEnlistmentEnId = GUID()
        self.CrmEnlistmentTmId = GUID()
        self.CrmEnlistmentRmId = GUID()
        self.NextHistory = v_uint32()
        self.History = vstruct.VArray([ KENLISTMENT_HISTORY() for i in xrange(20) ])
        self._pad01e0 = v_bytes(size=4)


class HEAP_SUBSEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LocalInfo = v_ptr64()
        self.UserBlocks = v_ptr64()
        self.AggregateExchg = INTERLOCK_SEQ()
        self.BlockSize = v_uint16()
        self.Flags = v_uint16()
        self.BlockCount = v_uint16()
        self.SizeIndex = v_uint8()
        self.AffinityIndex = v_uint8()
        self.SFreeListEntry = SINGLE_LIST_ENTRY()
        self.Lock = v_uint32()
        self._pad0030 = v_bytes(size=4)


class ERESOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemResourcesList = LIST_ENTRY()
        self.OwnerTable = v_ptr64()
        self.ActiveCount = v_uint16()
        self.Flag = v_uint16()
        self._pad0020 = v_bytes(size=4)
        self.SharedWaiters = v_ptr64()
        self.ExclusiveWaiters = v_ptr64()
        self.OwnerEntry = OWNER_ENTRY()
        self.ActiveEntries = v_uint32()
        self.ContentionCount = v_uint32()
        self.NumberOfSharedWaiters = v_uint32()
        self.NumberOfExclusiveWaiters = v_uint32()
        self.Reserved2 = v_ptr64()
        self.Address = v_ptr64()
        self.SpinLock = v_uint64()


class SUBSECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlArea = v_ptr64()
        self.SubsectionBase = v_ptr64()
        self.NextSubsection = v_ptr64()
        self.PtesInSubsection = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.UnusedPtes = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.u = _unnamed_22448()
        self.StartingSector = v_uint32()
        self.NumberOfFullSectors = v_uint32()
        self._pad0038 = v_bytes(size=4)


class CM_WORKITEM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.Private = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.WorkerRoutine = v_ptr64()
        self.Parameter = v_ptr64()


class KGUARDED_MUTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Owner = v_ptr64()
        self.Contention = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Gate = KGATE()
        self.KernelApcDisable = v_uint16()
        self.SpecialApcDisable = v_uint16()
        self._pad0038 = v_bytes(size=4)


class DBGKD_SET_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFlags = v_uint32()


class HEADLESS_LOADER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UsedBiosSettings = v_uint8()
        self.DataBits = v_uint8()
        self.StopBits = v_uint8()
        self.Parity = v_uint8()
        self.BaudRate = v_uint32()
        self.PortNumber = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.PortAddress = v_ptr64()
        self.PciDeviceId = v_uint16()
        self.PciVendorId = v_uint16()
        self.PciBusNumber = v_uint8()
        self._pad001e = v_bytes(size=1)
        self.PciBusSegment = v_uint16()
        self.PciSlotNumber = v_uint8()
        self.PciFunctionNumber = v_uint8()
        self._pad0024 = v_bytes(size=2)
        self.PciFlags = v_uint32()
        self.SystemGUID = GUID()
        self.IsMMIODevice = v_uint8()
        self.TerminalType = v_uint8()
        self._pad0040 = v_bytes(size=6)


class KALPC_REGION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RegionListEntry = LIST_ENTRY()
        self.Section = v_ptr64()
        self.Offset = v_uint64()
        self.Size = v_uint64()
        self.ViewSize = v_uint64()
        self.u1 = _unnamed_24191()
        self.NumberOfViews = v_uint32()
        self.ViewListHead = LIST_ENTRY()
        self.ReadOnlyView = v_ptr64()
        self.ReadWriteView = v_ptr64()


class POOL_BLOCK_HEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = POOL_HEADER()
        self.List = LIST_ENTRY()


class TEB32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB32()
        self.EnvironmentPointer = v_uint32()
        self.ClientId = CLIENT_ID32()
        self.ActiveRpcHandle = v_uint32()
        self.ThreadLocalStoragePointer = v_uint32()
        self.ProcessEnvironmentBlock = v_uint32()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_uint32()
        self.Win32ThreadInfo = v_uint32()
        self.User32Reserved = vstruct.VArray([ v_uint32() for i in xrange(26) ])
        self.UserReserved = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self.WOW32Reserved = v_uint32()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()
        self.SystemReserved1 = vstruct.VArray([ v_uint32() for i in xrange(54) ])
        self.ExceptionCode = v_uint32()
        self.ActivationContextStackPointer = v_uint32()
        self.SpareBytes = vstruct.VArray([ v_uint8() for i in xrange(36) ])
        self.TxFsContext = v_uint32()
        self.GdiTebBatch = GDI_TEB_BATCH32()
        self.RealClientId = CLIENT_ID32()
        self.GdiCachedProcessHandle = v_uint32()
        self.GdiClientPID = v_uint32()
        self.GdiClientTID = v_uint32()
        self.GdiThreadLocalInfo = v_uint32()
        self.Win32ClientInfo = vstruct.VArray([ v_uint32() for i in xrange(62) ])
        self.glDispatchTable = vstruct.VArray([ v_uint32() for i in xrange(233) ])
        self.glReserved1 = vstruct.VArray([ v_uint32() for i in xrange(29) ])
        self.glReserved2 = v_uint32()
        self.glSectionInfo = v_uint32()
        self.glSection = v_uint32()
        self.glTable = v_uint32()
        self.glCurrentRC = v_uint32()
        self.glContext = v_uint32()
        self.LastStatusValue = v_uint32()
        self.StaticUnicodeString = STRING32()
        self.StaticUnicodeBuffer = vstruct.VArray([ v_uint16() for i in xrange(261) ])
        self._pad0e0c = v_bytes(size=2)
        self.DeallocationStack = v_uint32()
        self.TlsSlots = vstruct.VArray([ v_uint32() for i in xrange(64) ])
        self.TlsLinks = LIST_ENTRY32()
        self.Vdm = v_uint32()
        self.ReservedForNtRpc = v_uint32()
        self.DbgSsReserved = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.HardErrorMode = v_uint32()
        self.Instrumentation = vstruct.VArray([ v_uint32() for i in xrange(9) ])
        self.ActivityId = GUID()
        self.SubProcessTag = v_uint32()
        self.EtwLocalData = v_uint32()
        self.EtwTraceData = v_uint32()
        self.WinSockData = v_uint32()
        self.GdiBatchCount = v_uint32()
        self.CurrentIdealProcessor = PROCESSOR_NUMBER()
        self.GuaranteedStackBytes = v_uint32()
        self.ReservedForPerf = v_uint32()
        self.ReservedForOle = v_uint32()
        self.WaitingOnLoaderLock = v_uint32()
        self.SavedPriorityState = v_uint32()
        self.SoftPatchPtr1 = v_uint32()
        self.ThreadPoolData = v_uint32()
        self.TlsExpansionSlots = v_uint32()
        self.MuiGeneration = v_uint32()
        self.IsImpersonating = v_uint32()
        self.NlsCache = v_uint32()
        self.pShimData = v_uint32()
        self.HeapVirtualAffinity = v_uint32()
        self.CurrentTransactionHandle = v_uint32()
        self.ActiveFrame = v_uint32()
        self.FlsData = v_uint32()
        self.PreferredLanguages = v_uint32()
        self.UserPrefLanguages = v_uint32()
        self.MergedPrefLanguages = v_uint32()
        self.MuiImpersonation = v_uint32()
        self.CrossTebFlags = v_uint16()
        self.SameTebFlags = v_uint16()
        self.TxnScopeEnterCallback = v_uint32()
        self.TxnScopeExitCallback = v_uint32()
        self.TxnScopeContext = v_uint32()
        self.LockCount = v_uint32()
        self.SpareUlong0 = v_uint32()
        self.ResourceRetValue = v_uint32()


class PEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InheritedAddressSpace = v_uint8()
        self.ReadImageFileExecOptions = v_uint8()
        self.BeingDebugged = v_uint8()
        self.BitField = v_uint8()
        self._pad0008 = v_bytes(size=4)
        self.Mutant = v_ptr64()
        self.ImageBaseAddress = v_ptr64()
        self.Ldr = v_ptr64()
        self.ProcessParameters = v_ptr64()
        self.SubSystemData = v_ptr64()
        self.ProcessHeap = v_ptr64()
        self.FastPebLock = v_ptr64()
        self.AtlThunkSListPtr = v_ptr64()
        self.IFEOKey = v_ptr64()
        self.CrossProcessFlags = v_uint32()
        self._pad0058 = v_bytes(size=4)
        self.KernelCallbackTable = v_ptr64()
        self.SystemReserved = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.AtlThunkSListPtr32 = v_uint32()
        self.ApiSetMap = v_ptr64()
        self.TlsExpansionCounter = v_uint32()
        self._pad0078 = v_bytes(size=4)
        self.TlsBitmap = v_ptr64()
        self.TlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ReadOnlySharedMemoryBase = v_ptr64()
        self.HotpatchInformation = v_ptr64()
        self.ReadOnlyStaticServerData = v_ptr64()
        self.AnsiCodePageData = v_ptr64()
        self.OemCodePageData = v_ptr64()
        self.UnicodeCaseTableData = v_ptr64()
        self.NumberOfProcessors = v_uint32()
        self.NtGlobalFlag = v_uint32()
        self.CriticalSectionTimeout = LARGE_INTEGER()
        self.HeapSegmentReserve = v_uint64()
        self.HeapSegmentCommit = v_uint64()
        self.HeapDeCommitTotalFreeThreshold = v_uint64()
        self.HeapDeCommitFreeBlockThreshold = v_uint64()
        self.NumberOfHeaps = v_uint32()
        self.MaximumNumberOfHeaps = v_uint32()
        self.ProcessHeaps = v_ptr64()
        self.GdiSharedHandleTable = v_ptr64()
        self.ProcessStarterHelper = v_ptr64()
        self.GdiDCAttributeList = v_uint32()
        self._pad0110 = v_bytes(size=4)
        self.LoaderLock = v_ptr64()
        self.OSMajorVersion = v_uint32()
        self.OSMinorVersion = v_uint32()
        self.OSBuildNumber = v_uint16()
        self.OSCSDVersion = v_uint16()
        self.OSPlatformId = v_uint32()
        self.ImageSubsystem = v_uint32()
        self.ImageSubsystemMajorVersion = v_uint32()
        self.ImageSubsystemMinorVersion = v_uint32()
        self._pad0138 = v_bytes(size=4)
        self.ActiveProcessAffinityMask = v_uint64()
        self.GdiHandleBuffer = vstruct.VArray([ v_uint32() for i in xrange(60) ])
        self.PostProcessInitRoutine = v_ptr64()
        self.TlsExpansionBitmap = v_ptr64()
        self.TlsExpansionBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(32) ])
        self.SessionId = v_uint32()
        self._pad02c8 = v_bytes(size=4)
        self.AppCompatFlags = ULARGE_INTEGER()
        self.AppCompatFlagsUser = ULARGE_INTEGER()
        self.pShimData = v_ptr64()
        self.AppCompatInfo = v_ptr64()
        self.CSDVersion = UNICODE_STRING()
        self.ActivationContextData = v_ptr64()
        self.ProcessAssemblyStorageMap = v_ptr64()
        self.SystemDefaultActivationContextData = v_ptr64()
        self.SystemAssemblyStorageMap = v_ptr64()
        self.MinimumStackCommit = v_uint64()
        self.FlsCallback = v_ptr64()
        self.FlsListHead = LIST_ENTRY()
        self.FlsBitmap = v_ptr64()
        self.FlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.FlsHighIndex = v_uint32()
        self._pad0358 = v_bytes(size=4)
        self.WerRegistrationData = v_ptr64()
        self.WerShipAssertPtr = v_ptr64()
        self.pContextData = v_ptr64()
        self.pImageHeaderHash = v_ptr64()
        self.TracingFlags = v_uint32()
        self._pad0380 = v_bytes(size=4)


class CHILD_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.List = v_uint32()


class TP_TASK_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteCallback = v_ptr64()
        self.Unposted = v_ptr64()


class RTL_BALANCED_LINKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parent = v_ptr64()
        self.LeftChild = v_ptr64()
        self.RightChild = v_ptr64()
        self.Balance = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self._pad0020 = v_bytes(size=4)


class DBGKD_ANY_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.X86ControlSet = X86_DBGKD_CONTROL_SET()
        self._pad001c = v_bytes(size=12)


class _unnamed_23140(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextResourceDeviceNode = v_ptr64()


class _unnamed_23141(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DockStatus = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.ListEntry = LIST_ENTRY()
        self.SerialNumber = v_ptr64()


class KENLISTMENT_HISTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Notification = v_uint32()
        self.NewState = v_uint32()


class ARBITER_INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Context = v_ptr64()
        self.InterfaceReference = v_ptr64()
        self.InterfaceDereference = v_ptr64()
        self.ArbiterHandler = v_ptr64()
        self.Flags = v_uint32()
        self._pad0030 = v_bytes(size=4)


class MI_SECTION_CREATION_GATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Gate = KGATE()


class OBJECT_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashBuckets = vstruct.VArray([ v_ptr64() for i in xrange(37) ])
        self.Lock = EX_PUSH_LOCK()
        self.DeviceMap = v_ptr64()
        self.SessionId = v_uint32()
        self._pad0140 = v_bytes(size=4)
        self.NamespaceEntry = v_ptr64()
        self.Flags = v_uint32()
        self._pad0150 = v_bytes(size=4)


class MI_SPECIAL_POOL_PTE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FreePteHead = MMPTE()
        self.FreePteTail = MMPTE()


class EX_PUSH_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint64()


class KSTACK_COUNT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Value = v_uint32()


class MI_PAGEFILE_TRACES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.Priority = v_uint8()
        self.IrpPriority = v_uint8()
        self._pad0008 = v_bytes(size=2)
        self.CurrentTime = LARGE_INTEGER()
        self.AvailablePages = v_uint64()
        self.ModifiedPagesTotal = v_uint64()
        self.ModifiedPagefilePages = v_uint64()
        self.ModifiedNoWritePages = v_uint64()
        self.MdlHack = _unnamed_22477()


class _unnamed_21362(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoResourceRequirementList = v_ptr64()


class _unnamed_27387(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleTime = v_uint32()
        self.NonIdleTime = v_uint32()


class PPM_PERF_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Frequency = v_uint32()
        self.Power = v_uint32()
        self.PercentFrequency = v_uint8()
        self.IncreaseLevel = v_uint8()
        self.DecreaseLevel = v_uint8()
        self.Type = v_uint8()
        self._pad0010 = v_bytes(size=4)
        self.Control = v_uint64()
        self.Status = v_uint64()
        self.TotalHitCount = v_uint32()
        self.DesiredCount = v_uint32()


class XSAVE_AREA_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint64()
        self.Reserved = vstruct.VArray([ v_uint64() for i in xrange(7) ])


class _unnamed_21365(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WhichSpace = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_ptr64()
        self.Offset = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Length = v_uint32()
        self._pad0020 = v_bytes(size=4)


class HEAP_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.SegmentSignature = v_uint32()
        self.SegmentFlags = v_uint32()
        self.SegmentListEntry = LIST_ENTRY()
        self.Heap = v_ptr64()
        self.BaseAddress = v_ptr64()
        self.NumberOfPages = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.FirstEntry = v_ptr64()
        self.LastValidEntry = v_ptr64()
        self.NumberOfUnCommittedPages = v_uint32()
        self.NumberOfUnCommittedRanges = v_uint32()
        self.SegmentAllocatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self._pad0060 = v_bytes(size=4)
        self.UCRSegmentList = LIST_ENTRY()


class _unnamed_21240(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.InputBufferLength = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.FsControlCode = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Type3InputBuffer = v_ptr64()


class HEAP_FREE_ENTRY_EXTRA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TagIndex = v_uint16()
        self.FreeBackTraceIndex = v_uint16()


class WHEA_ERROR_RECORD_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Revision = WHEA_REVISION()
        self.SignatureEnd = v_uint32()
        self.SectionCount = v_uint16()
        self.Severity = v_uint32()
        self.ValidBits = WHEA_ERROR_RECORD_HEADER_VALIDBITS()
        self.Length = v_uint32()
        self.Timestamp = WHEA_TIMESTAMP()
        self.PlatformId = GUID()
        self.PartitionId = GUID()
        self.CreatorId = GUID()
        self.NotifyType = GUID()
        self.RecordId = v_uint64()
        self.Flags = WHEA_ERROR_RECORD_HEADER_FLAGS()
        self.PersistenceInfo = WHEA_PERSISTENCE_INFO()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(12) ])


class EVENT_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint16()
        self.Version = v_uint8()
        self.Channel = v_uint8()
        self.Level = v_uint8()
        self.Opcode = v_uint8()
        self.Task = v_uint16()
        self.Keyword = v_uint64()


class CM_VIEW_OF_FILE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MappedViewLinks = LIST_ENTRY()
        self.PinnedViewLinks = LIST_ENTRY()
        self.FlushedViewLinks = LIST_ENTRY()
        self.CmHive = v_ptr64()
        self.Bcb = v_ptr64()
        self.ViewAddress = v_ptr64()
        self.FileOffset = v_uint32()
        self.Size = v_uint32()
        self.UseCount = v_uint32()
        self._pad0058 = v_bytes(size=4)


class PSP_CPU_SHARE_CAPTURED_WEIGHT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CapturedCpuShareWeight = v_uint32()
        self.CapturedTotalWeight = v_uint32()


class IMAGE_SECTION_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.Misc = _unnamed_27347()
        self.VirtualAddress = v_uint32()
        self.SizeOfRawData = v_uint32()
        self.PointerToRawData = v_uint32()
        self.PointerToRelocations = v_uint32()
        self.PointerToLinenumbers = v_uint32()
        self.NumberOfRelocations = v_uint16()
        self.NumberOfLinenumbers = v_uint16()
        self.Characteristics = v_uint32()


class PO_DEVICE_NOTIFY_ORDER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint8()
        self._pad0008 = v_bytes(size=7)
        self.WarmEjectPdoPointer = v_ptr64()
        self.OrderLevel = vstruct.VArray([ PO_NOTIFY_ORDER_LEVEL() for i in xrange(9) ])


class RTL_ATOM_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.CriticalSection = RTL_CRITICAL_SECTION()
        self.RtlHandleTable = RTL_HANDLE_TABLE()
        self.NumberOfBuckets = v_uint32()
        self._pad0068 = v_bytes(size=4)
        self.Buckets = vstruct.VArray([ v_ptr64() for i in xrange(1) ])


class MMSECURE_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReadOnly = v_uint32()


class DBGKD_WRITE_MEMORY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TargetBaseAddress = v_uint64()
        self.TransferCount = v_uint32()
        self.ActualBytesWritten = v_uint32()


class _unnamed_24194(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Secure = v_uint32()


class LIST_ENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint64()
        self.Blink = v_uint64()


class VACB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseAddress = v_ptr64()
        self.SharedCacheMap = v_ptr64()
        self.Overlay = _unnamed_23643()
        self.Links = LIST_ENTRY()
        self.ArrayHead = v_ptr64()


class WAIT_CONTEXT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.DeviceRoutine = v_ptr64()
        self.DeviceContext = v_ptr64()
        self.NumberOfMapRegisters = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.DeviceObject = v_ptr64()
        self.CurrentIrp = v_ptr64()
        self.BufferChainingDpc = v_ptr64()


class CM_KEY_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.Flags = v_uint16()
        self.LastWriteTime = LARGE_INTEGER()
        self.Spare = v_uint32()
        self.Parent = v_uint32()
        self.SubKeyCounts = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.SubKeyLists = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ValueList = CHILD_LIST()
        self.Security = v_uint32()
        self.Class = v_uint32()
        self.MaxNameLen = v_uint32()
        self.MaxClassLen = v_uint32()
        self.MaxValueNameLen = v_uint32()
        self.MaxValueDataLen = v_uint32()
        self.WorkVar = v_uint32()
        self.NameLength = v_uint16()
        self.ClassLength = v_uint16()
        self.Name = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0050 = v_bytes(size=2)


class _unnamed_22354(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoStatus = IO_STATUS_BLOCK()


class SE_AUDIT_PROCESS_CREATION_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImageFileName = v_ptr64()


class ACTIVATION_CONTEXT_STACK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ActiveFrame = v_ptr64()
        self.FrameListCache = LIST_ENTRY()
        self.Flags = v_uint32()
        self.NextCookieSequenceNumber = v_uint32()
        self.StackId = v_uint32()
        self._pad0028 = v_bytes(size=4)


class KRESOURCEMANAGER_COMPLETION_BINDING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationListHead = LIST_ENTRY()
        self.Port = v_ptr64()
        self.Key = v_uint64()
        self.BindingProcess = v_ptr64()


class LDR_DATA_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InLoadOrderLinks = LIST_ENTRY()
        self.InMemoryOrderLinks = LIST_ENTRY()
        self.InInitializationOrderLinks = LIST_ENTRY()
        self.DllBase = v_ptr64()
        self.EntryPoint = v_ptr64()
        self.SizeOfImage = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.FullDllName = UNICODE_STRING()
        self.BaseDllName = UNICODE_STRING()
        self.Flags = v_uint32()
        self.LoadCount = v_uint16()
        self.TlsIndex = v_uint16()
        self.HashLinks = LIST_ENTRY()
        self.TimeDateStamp = v_uint32()
        self._pad0088 = v_bytes(size=4)
        self.EntryPointActivationContext = v_ptr64()
        self.PatchInformation = v_ptr64()
        self.ForwarderLinks = LIST_ENTRY()
        self.ServiceTagLinks = LIST_ENTRY()
        self.StaticLinks = LIST_ENTRY()
        self.ContextInformation = v_ptr64()
        self.OriginalBase = v_uint64()
        self.LoadTime = LARGE_INTEGER()


class SEP_AUDIT_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AdtTokenPolicy = TOKEN_AUDIT_POLICY()
        self.PolicySetStatus = v_uint8()


class _unnamed_26871(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SnapSharedExportsFailed = v_uint32()


class EX_RUNDOWN_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint64()


class _unnamed_24044(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24046()


class CM_NOTIFY_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HiveList = LIST_ENTRY()
        self.PostList = LIST_ENTRY()
        self.KeyControlBlock = v_ptr64()
        self.KeyBody = v_ptr64()
        self.Filter = v_uint32()
        self._pad0038 = v_bytes(size=4)
        self.SubjectContext = SECURITY_SUBJECT_CONTEXT()


class _unnamed_24046(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataLength = v_uint16()
        self.TotalLength = v_uint16()


class PO_IRP_MANAGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceIrpQueue = PO_IRP_QUEUE()
        self.SystemIrpQueue = PO_IRP_QUEUE()


class _unnamed_24191(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24194()


class CM_BIG_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.Count = v_uint16()
        self.List = v_uint32()


class MMWSLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_22182()


class _unnamed_19930(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint64()
        self.HeaderType = v_uint64()


class VI_POOL_PAGE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextPage = v_ptr64()
        self.VerifierEntry = v_ptr64()
        self.Signature = v_uint64()


class PO_DIAG_STACK_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StackDepth = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Stack = vstruct.VArray([ v_ptr64() for i in xrange(1) ])


class _unnamed_22395(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags2 = v_uint32()


class IMAGE_DOS_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e_magic = v_uint16()
        self.e_cblp = v_uint16()
        self.e_cp = v_uint16()
        self.e_crlc = v_uint16()
        self.e_cparhdr = v_uint16()
        self.e_minalloc = v_uint16()
        self.e_maxalloc = v_uint16()
        self.e_ss = v_uint16()
        self.e_sp = v_uint16()
        self.e_csum = v_uint16()
        self.e_ip = v_uint16()
        self.e_cs = v_uint16()
        self.e_lfarlc = v_uint16()
        self.e_ovno = v_uint16()
        self.e_res = vstruct.VArray([ v_uint16() for i in xrange(4) ])
        self.e_oemid = v_uint16()
        self.e_oeminfo = v_uint16()
        self.e_res2 = vstruct.VArray([ v_uint16() for i in xrange(10) ])
        self.e_lfanew = v_uint32()


class _unnamed_27537(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_29211()


class DBGKD_FILL_MEMORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_uint64()
        self.Length = v_uint32()
        self.Flags = v_uint16()
        self.PatternLength = v_uint16()


class CM_KEY_SECURITY_CACHE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cell = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.CachedSecurity = v_ptr64()


class MMADDRESS_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_22363()
        self.LeftChild = v_ptr64()
        self.RightChild = v_ptr64()
        self.StartingVpn = v_uint64()
        self.EndingVpn = v_uint64()


class TXN_PARAMETER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.TxFsContext = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.TransactionObject = v_ptr64()


class KALPC_MESSAGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = LIST_ENTRY()
        self.ExtensionBuffer = v_ptr64()
        self.ExtensionBufferSize = v_uint64()
        self.QuotaProcess = v_ptr64()
        self.SequenceNo = v_uint32()
        self.u1 = _unnamed_24321()
        self.CancelSequencePort = v_ptr64()
        self.CancelQueuePort = v_ptr64()
        self.CancelSequenceNo = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.CancelListEntry = LIST_ENTRY()
        self.WaitingThread = v_ptr64()
        self.Reserve = v_ptr64()
        self.PortQueue = v_ptr64()
        self.OwnerPort = v_ptr64()
        self.MessageAttributes = KALPC_MESSAGE_ATTRIBUTES()
        self.DataUserVa = v_ptr64()
        self.DataSystemVa = v_ptr64()
        self.CommunicationInfo = v_ptr64()
        self.ConnectionPort = v_ptr64()
        self.ServerThread = v_ptr64()
        self.PortMessage = PORT_MESSAGE()


class ARBITER_ORDERING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint64()
        self.End = v_uint64()


class MMVIEW(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = v_uint64()
        self.Writable = v_uint64()
        self.ViewLinks = LIST_ENTRY()
        self.SessionViewVa = v_ptr64()
        self.SessionId = v_uint32()
        self._pad0030 = v_bytes(size=4)


class EXCEPTION_RECORD32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_uint32()
        self.ExceptionAddress = v_uint32()
        self.NumberParameters = v_uint32()
        self.ExceptionInformation = vstruct.VArray([ v_uint32() for i in xrange(15) ])


class ETW_GUID_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GuidList = LIST_ENTRY()
        self.RefCount = v_uint32()
        self.Guid = GUID()
        self._pad0028 = v_bytes(size=4)
        self.RegListHead = LIST_ENTRY()
        self.SecurityDescriptor = v_ptr64()
        self.LastEnable = ETW_LAST_ENABLE_INFO()
        self.ProviderEnableInfo = TRACE_ENABLE_INFO()
        self.EnableInfo = vstruct.VArray([ TRACE_ENABLE_INFO() for i in xrange(8) ])
        self.FilterData = vstruct.VArray([ v_ptr64() for i in xrange(8) ])


class WMI_BUFFER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BufferSize = v_uint32()
        self.SavedOffset = v_uint32()
        self.CurrentOffset = v_uint32()
        self.ReferenceCount = v_uint32()
        self.TimeStamp = LARGE_INTEGER()
        self.SequenceNumber = v_uint64()
        self.Padding0 = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ClientContext = ETW_BUFFER_CONTEXT()
        self.State = v_uint32()
        self.Offset = v_uint32()
        self.BufferFlag = v_uint16()
        self.BufferType = v_uint16()
        self.Padding1 = vstruct.VArray([ v_uint32() for i in xrange(4) ])


class QUAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UseThisFieldToCopy = v_uint64()


class OBJECT_HANDLE_COUNT_DATABASE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CountEntries = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.HandleCountEntries = vstruct.VArray([ OBJECT_HANDLE_COUNT_ENTRY() for i in xrange(1) ])


class VF_KE_CRITICAL_REGION_TRACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Thread = v_ptr64()
        self.StackTrace = vstruct.VArray([ v_ptr64() for i in xrange(7) ])


class TIME_FIELDS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Year = v_uint16()
        self.Month = v_uint16()
        self.Day = v_uint16()
        self.Hour = v_uint16()
        self.Minute = v_uint16()
        self.Second = v_uint16()
        self.Milliseconds = v_uint16()
        self.Weekday = v_uint16()


class HEAP_TUNING_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CommittThresholdShift = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.MaxPreCommittThreshold = v_uint64()


class LPCP_PORT_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ConnectionPort = v_ptr64()
        self.ConnectedPort = v_ptr64()
        self.MsgQueue = LPCP_PORT_QUEUE()
        self.Creator = CLIENT_ID()
        self.ClientSectionBase = v_ptr64()
        self.ServerSectionBase = v_ptr64()
        self.PortContext = v_ptr64()
        self.ClientThread = v_ptr64()
        self.SecurityQos = SECURITY_QUALITY_OF_SERVICE()
        self._pad0070 = v_bytes(size=4)
        self.StaticSecurity = SECURITY_CLIENT_CONTEXT()
        self.LpcReplyChainHead = LIST_ENTRY()
        self.LpcDataInfoChainHead = LIST_ENTRY()
        self.ServerProcess = v_ptr64()
        self.MaxMessageLength = v_uint16()
        self.MaxConnectionInfoLength = v_uint16()
        self.Flags = v_uint32()
        self.WaitEvent = KEVENT()


class CALL_PERFORMANCE_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SpinLock = v_uint64()
        self.HashTable = vstruct.VArray([ LIST_ENTRY() for i in xrange(64) ])


class KPRCB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MxCsr = v_uint32()
        self.LegacyNumber = v_uint8()
        self.ReservedMustBeZero = v_uint8()
        self.InterruptRequest = v_uint8()
        self.IdleHalt = v_uint8()
        self.CurrentThread = v_ptr64()
        self.NextThread = v_ptr64()
        self.IdleThread = v_ptr64()
        self.NestingLevel = v_uint8()
        self.PrcbPad00 = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.Number = v_uint32()
        self.RspBase = v_uint64()
        self.PrcbLock = v_uint64()
        self.PrcbPad01 = v_uint64()
        self.ProcessorState = KPROCESSOR_STATE()
        self.CpuType = v_uint8()
        self.CpuID = v_uint8()
        self.CpuStep = v_uint16()
        self.MHz = v_uint32()
        self.HalReserved = vstruct.VArray([ v_uint64() for i in xrange(8) ])
        self.MinorVersion = v_uint16()
        self.MajorVersion = v_uint16()
        self.BuildType = v_uint8()
        self.CpuVendor = v_uint8()
        self.CoresPerPhysicalProcessor = v_uint8()
        self.LogicalProcessorsPerCore = v_uint8()
        self.ApicMask = v_uint32()
        self.CFlushSize = v_uint32()
        self.AcpiReserved = v_ptr64()
        self.InitialApicId = v_uint32()
        self.Stride = v_uint32()
        self.Group = v_uint16()
        self._pad0660 = v_bytes(size=6)
        self.GroupSetMember = v_uint64()
        self.GroupIndex = v_uint8()
        self._pad0670 = v_bytes(size=7)
        self.LockQueue = vstruct.VArray([ KSPIN_LOCK_QUEUE() for i in xrange(17) ])
        self.PPLookasideList = vstruct.VArray([ PP_LOOKASIDE_LIST() for i in xrange(16) ])
        self.PPNPagedLookasideList = vstruct.VArray([ GENERAL_LOOKASIDE_POOL() for i in xrange(32) ])
        self.PPPagedLookasideList = vstruct.VArray([ GENERAL_LOOKASIDE_POOL() for i in xrange(32) ])
        self.PacketBarrier = v_uint32()
        self._pad2088 = v_bytes(size=4)
        self.DeferredReadyListHead = SINGLE_LIST_ENTRY()
        self.MmPageFaultCount = v_uint32()
        self.MmCopyOnWriteCount = v_uint32()
        self.MmTransitionCount = v_uint32()
        self.MmDemandZeroCount = v_uint32()
        self.MmPageReadCount = v_uint32()
        self.MmPageReadIoCount = v_uint32()
        self.MmDirtyPagesWriteCount = v_uint32()
        self.MmDirtyWriteIoCount = v_uint32()
        self.MmMappedPagesWriteCount = v_uint32()
        self.MmMappedWriteIoCount = v_uint32()
        self.KeSystemCalls = v_uint32()
        self.KeContextSwitches = v_uint32()
        self.CcFastReadNoWait = v_uint32()
        self.CcFastReadWait = v_uint32()
        self.CcFastReadNotPossible = v_uint32()
        self.CcCopyReadNoWait = v_uint32()
        self.CcCopyReadWait = v_uint32()
        self.CcCopyReadNoWaitMiss = v_uint32()
        self.LookasideIrpFloat = v_uint32()
        self.IoReadOperationCount = v_uint32()
        self.IoWriteOperationCount = v_uint32()
        self.IoOtherOperationCount = v_uint32()
        self.IoReadTransferCount = LARGE_INTEGER()
        self.IoWriteTransferCount = LARGE_INTEGER()
        self.IoOtherTransferCount = LARGE_INTEGER()
        self.TargetCount = v_uint32()
        self.IpiFrozen = v_uint32()
        self._pad2180 = v_bytes(size=120)
        self.DpcData = vstruct.VArray([ KDPC_DATA() for i in xrange(2) ])
        self.DpcStack = v_ptr64()
        self.MaximumDpcQueueDepth = v_uint32()
        self.DpcRequestRate = v_uint32()
        self.MinimumDpcRate = v_uint32()
        self.DpcLastCount = v_uint32()
        self.ThreadDpcEnable = v_uint8()
        self.QuantumEnd = v_uint8()
        self.DpcRoutineActive = v_uint8()
        self.IdleSchedule = v_uint8()
        self.DpcRequestSummary = v_uint32()
        self.TimerHand = v_uint32()
        self.MasterOffset = v_uint32()
        self.LastTick = v_uint32()
        self.UnusedPad = v_uint32()
        self.PrcbPad50 = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.TimerTable = KTIMER_TABLE()
        self.DpcGate = KGATE()
        self.PrcbPad52 = v_ptr64()
        self.CallDpc = KDPC()
        self.ClockKeepAlive = v_uint32()
        self.ClockCheckSlot = v_uint8()
        self.ClockPollCycle = v_uint8()
        self.NmiActive = v_uint16()
        self.DpcWatchdogPeriod = v_uint32()
        self.DpcWatchdogCount = v_uint32()
        self.TickOffset = v_uint64()
        self.KeSpinLockOrdering = v_uint32()
        self.PrcbPad70 = v_uint32()
        self.WaitListHead = LIST_ENTRY()
        self.WaitLock = v_uint64()
        self.ReadySummary = v_uint32()
        self.QueueIndex = v_uint32()
        self.TimerExpirationDpc = KDPC()
        self.PrcbPad72 = vstruct.VArray([ v_uint64() for i in xrange(4) ])
        self.DispatcherReadyListHead = vstruct.VArray([ LIST_ENTRY() for i in xrange(32) ])
        self.InterruptCount = v_uint32()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.DpcTime = v_uint32()
        self.InterruptTime = v_uint32()
        self.AdjustDpcThreshold = v_uint32()
        self.DebuggerSavedIRQL = v_uint8()
        self.PrcbPad80 = vstruct.VArray([ v_uint8() for i in xrange(7) ])
        self.DpcTimeCount = v_uint32()
        self.DpcTimeLimit = v_uint32()
        self.PeriodicCount = v_uint32()
        self.PeriodicBias = v_uint32()
        self.AvailableTime = v_uint32()
        self.KeExceptionDispatchCount = v_uint32()
        self.ParentNode = v_ptr64()
        self.StartCycles = v_uint64()
        self.PrcbPad82 = vstruct.VArray([ v_uint64() for i in xrange(3) ])
        self.MmSpinLockOrdering = v_uint32()
        self.PageColor = v_uint32()
        self.NodeColor = v_uint32()
        self.NodeShiftedColor = v_uint32()
        self.SecondaryColorMask = v_uint32()
        self.PrcbPad83 = v_uint32()
        self.CycleTime = v_uint64()
        self.CcFastMdlReadNoWait = v_uint32()
        self.CcFastMdlReadWait = v_uint32()
        self.CcFastMdlReadNotPossible = v_uint32()
        self.CcMapDataNoWait = v_uint32()
        self.CcMapDataWait = v_uint32()
        self.CcPinMappedDataCount = v_uint32()
        self.CcPinReadNoWait = v_uint32()
        self.CcPinReadWait = v_uint32()
        self.CcMdlReadNoWait = v_uint32()
        self.CcMdlReadWait = v_uint32()
        self.CcLazyWriteHotSpots = v_uint32()
        self.CcLazyWriteIos = v_uint32()
        self.CcLazyWritePages = v_uint32()
        self.CcDataFlushes = v_uint32()
        self.CcDataPages = v_uint32()
        self.CcLostDelayedWrites = v_uint32()
        self.CcFastReadResourceMiss = v_uint32()
        self.CcCopyReadWaitMiss = v_uint32()
        self.CcFastMdlReadResourceMiss = v_uint32()
        self.CcMapDataNoWaitMiss = v_uint32()
        self.CcMapDataWaitMiss = v_uint32()
        self.CcPinReadNoWaitMiss = v_uint32()
        self.CcPinReadWaitMiss = v_uint32()
        self.CcMdlReadNoWaitMiss = v_uint32()
        self.CcMdlReadWaitMiss = v_uint32()
        self.CcReadAheadIos = v_uint32()
        self.MmCacheTransitionCount = v_uint32()
        self.MmCacheReadCount = v_uint32()
        self.MmCacheIoCount = v_uint32()
        self.PrcbPad91 = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.RuntimeAccumulation = v_uint64()
        self.PowerState = PROCESSOR_POWER_STATE()
        self.PrcbPad92 = vstruct.VArray([ v_uint8() for i in xrange(16) ])
        self.KeAlignmentFixupCount = v_uint32()
        self._pad4918 = v_bytes(size=4)
        self.DpcWatchdogDpc = KDPC()
        self.DpcWatchdogTimer = KTIMER()
        self.Cache = vstruct.VArray([ CACHE_DESCRIPTOR() for i in xrange(5) ])
        self.CacheCount = v_uint32()
        self.CachedCommit = v_uint32()
        self.CachedResidentAvailable = v_uint32()
        self.HyperPte = v_ptr64()
        self.WheaInfo = v_ptr64()
        self.EtwSupport = v_ptr64()
        self._pad4a00 = v_bytes(size=8)
        self.InterruptObjectPool = SLIST_HEADER()
        self.HypercallPageList = SLIST_HEADER()
        self.HypercallPageVirtual = v_ptr64()
        self.VirtualApicAssist = v_ptr64()
        self.StatisticsPage = v_ptr64()
        self.RateControl = v_ptr64()
        self.CacheProcessorMask = vstruct.VArray([ v_uint64() for i in xrange(5) ])
        self.PackageProcessorSet = KAFFINITY_EX()
        self.CoreProcessorSet = v_uint64()
        self.PebsIndexAddress = v_ptr64()
        self.PrcbPad93 = vstruct.VArray([ v_uint64() for i in xrange(12) ])
        self.SpinLockAcquireCount = v_uint32()
        self.SpinLockContentionCount = v_uint32()
        self.SpinLockSpinCount = v_uint32()
        self.IpiSendRequestBroadcastCount = v_uint32()
        self.IpiSendRequestRoutineCount = v_uint32()
        self.IpiSendSoftwareInterruptCount = v_uint32()
        self.ExInitializeResourceCount = v_uint32()
        self.ExReInitializeResourceCount = v_uint32()
        self.ExDeleteResourceCount = v_uint32()
        self.ExecutiveResourceAcquiresCount = v_uint32()
        self.ExecutiveResourceContentionsCount = v_uint32()
        self.ExecutiveResourceReleaseExclusiveCount = v_uint32()
        self.ExecutiveResourceReleaseSharedCount = v_uint32()
        self.ExecutiveResourceConvertsCount = v_uint32()
        self.ExAcqResExclusiveAttempts = v_uint32()
        self.ExAcqResExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResExclusiveAcquiresExclusiveRecursive = v_uint32()
        self.ExAcqResExclusiveWaits = v_uint32()
        self.ExAcqResExclusiveNotAcquires = v_uint32()
        self.ExAcqResSharedAttempts = v_uint32()
        self.ExAcqResSharedAcquiresExclusive = v_uint32()
        self.ExAcqResSharedAcquiresShared = v_uint32()
        self.ExAcqResSharedAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedWaits = v_uint32()
        self.ExAcqResSharedNotAcquires = v_uint32()
        self.ExAcqResSharedStarveExclusiveAttempts = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresShared = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedStarveExclusiveWaits = v_uint32()
        self.ExAcqResSharedStarveExclusiveNotAcquires = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAttempts = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresShared = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedWaitForExclusiveWaits = v_uint32()
        self.ExAcqResSharedWaitForExclusiveNotAcquires = v_uint32()
        self.ExSetResOwnerPointerExclusive = v_uint32()
        self.ExSetResOwnerPointerSharedNew = v_uint32()
        self.ExSetResOwnerPointerSharedOld = v_uint32()
        self.ExTryToAcqExclusiveAttempts = v_uint32()
        self.ExTryToAcqExclusiveAcquires = v_uint32()
        self.ExBoostExclusiveOwner = v_uint32()
        self.ExBoostSharedOwners = v_uint32()
        self.ExEtwSynchTrackingNotificationsCount = v_uint32()
        self.ExEtwSynchTrackingNotificationsAccountedCount = v_uint32()
        self.VendorString = vstruct.VArray([ v_uint8() for i in xrange(13) ])
        self.PrcbPad10 = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.FeatureBits = v_uint32()
        self._pad4bd0 = v_bytes(size=4)
        self.UpdateSignature = LARGE_INTEGER()
        self.Context = v_ptr64()
        self.ContextFlags = v_uint32()
        self._pad4be8 = v_bytes(size=4)
        self.ExtendedState = v_ptr64()
        self._pad4c00 = v_bytes(size=16)
        self.Mailbox = v_ptr64()
        self._pad4c80 = v_bytes(size=120)
        self.RequestMailbox = vstruct.VArray([ REQUEST_MAILBOX() for i in xrange(1) ])
        self._pad4d00 = v_bytes(size=64)


class EXCEPTION_POINTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionRecord = v_ptr64()
        self.ContextRecord = v_ptr64()


class PPM_FFH_THROTTLE_STATE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnableLogging = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.MismatchCount = v_uint32()
        self.Initialized = v_uint8()
        self._pad0010 = v_bytes(size=7)
        self.LastValue = v_uint64()
        self.LastLogTickCount = LARGE_INTEGER()


class RTL_DYNAMIC_HASH_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.Shift = v_uint32()
        self.TableSize = v_uint32()
        self.Pivot = v_uint32()
        self.DivisorMask = v_uint32()
        self.NumEntries = v_uint32()
        self.NonEmptyBuckets = v_uint32()
        self.NumEnumerators = v_uint32()
        self.Directory = v_ptr64()


class PCW_REGISTRATION_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Name = v_ptr64()
        self.CounterCount = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Counters = v_ptr64()
        self.Callback = v_ptr64()
        self.CallbackContext = v_ptr64()


class POP_TRIGGER_WAIT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Event = KEVENT()
        self.Status = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.Link = LIST_ENTRY()
        self.Trigger = v_ptr64()


class KAFFINITY_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint16()
        self.Size = v_uint16()
        self.Reserved = v_uint32()
        self.Bitmap = vstruct.VArray([ v_uint64() for i in xrange(4) ])


class ETW_WMITRACE_WORK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LoggerId = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.LoggerName = vstruct.VArray([ v_uint8() for i in xrange(65) ])
        self.FileName = vstruct.VArray([ v_uint8() for i in xrange(129) ])
        self._pad00cc = v_bytes(size=2)
        self.MaximumFileSize = v_uint32()
        self.MinBuffers = v_uint32()
        self.MaxBuffers = v_uint32()
        self.BufferSize = v_uint32()
        self.Mode = v_uint32()
        self.FlushTimer = v_uint32()
        self._pad00e8 = v_bytes(size=4)
        self.Status = v_uint32()
        self._pad00f0 = v_bytes(size=4)


class DEVICE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.ReferenceCount = v_uint32()
        self.DriverObject = v_ptr64()
        self.NextDevice = v_ptr64()
        self.AttachedDevice = v_ptr64()
        self.CurrentIrp = v_ptr64()
        self.Timer = v_ptr64()
        self.Flags = v_uint32()
        self.Characteristics = v_uint32()
        self.Vpb = v_ptr64()
        self.DeviceExtension = v_ptr64()
        self.DeviceType = v_uint32()
        self.StackSize = v_uint8()
        self._pad0050 = v_bytes(size=3)
        self.Queue = _unnamed_20590()
        self.AlignmentRequirement = v_uint32()
        self._pad00a0 = v_bytes(size=4)
        self.DeviceQueue = KDEVICE_QUEUE()
        self.Dpc = KDPC()
        self.ActiveThreadCount = v_uint32()
        self._pad0110 = v_bytes(size=4)
        self.SecurityDescriptor = v_ptr64()
        self.DeviceLock = KEVENT()
        self.SectorSize = v_uint16()
        self.Spare1 = v_uint16()
        self._pad0138 = v_bytes(size=4)
        self.DeviceObjectExtension = v_ptr64()
        self.Reserved = v_ptr64()
        self._pad0150 = v_bytes(size=8)


class KRESOURCEMANAGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationAvailable = KEVENT()
        self.cookie = v_uint32()
        self.State = v_uint32()
        self.Flags = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.Mutex = KMUTANT()
        self.NamespaceLink = KTMOBJECT_NAMESPACE_LINK()
        self.RmId = GUID()
        self.NotificationQueue = KQUEUE()
        self.NotificationMutex = KMUTANT()
        self.EnlistmentHead = LIST_ENTRY()
        self.EnlistmentCount = v_uint32()
        self._pad0128 = v_bytes(size=4)
        self.NotificationRoutine = v_ptr64()
        self.Key = v_ptr64()
        self.ProtocolListHead = LIST_ENTRY()
        self.PendingPropReqListHead = LIST_ENTRY()
        self.CRMListEntry = LIST_ENTRY()
        self.Tm = v_ptr64()
        self.Description = UNICODE_STRING()
        self.Enlistments = KTMOBJECT_NAMESPACE()
        self.CompletionBinding = KRESOURCEMANAGER_COMPLETION_BINDING()


class CM_NAME_HASH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ConvKey = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.NextHash = v_ptr64()
        self.NameLength = v_uint16()
        self.Name = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0018 = v_bytes(size=4)


class KTSS64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved0 = v_uint32()
        self.Rsp0 = v_uint64()
        self.Rsp1 = v_uint64()
        self.Rsp2 = v_uint64()
        self.Ist = vstruct.VArray([ v_uint64() for i in xrange(8) ])
        self.Reserved1 = v_uint64()
        self.Reserved2 = v_uint16()
        self.IoMapBase = v_uint16()


class EX_PUSH_LOCK_WAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WakeEvent = KEVENT()
        self.Next = v_ptr64()
        self.Last = v_ptr64()
        self.Previous = v_ptr64()
        self.ShareCount = v_uint32()
        self.Flags = v_uint32()
        self._pad0040 = v_bytes(size=8)


class _unnamed_26758(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint32()


class _unnamed_26759(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()


class KERNEL_STACK_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StackBase = v_uint64()
        self.StackLimit = v_uint64()
        self.KernelStack = v_uint64()
        self.InitialStack = v_uint64()
        self.ActualLimit = v_uint64()


class VF_POOL_TRACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_ptr64()
        self.Size = v_uint64()
        self.Thread = v_ptr64()
        self.StackTrace = vstruct.VArray([ v_ptr64() for i in xrange(13) ])


class SECTION_IMAGE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TransferAddress = v_ptr64()
        self.ZeroBits = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.MaximumStackSize = v_uint64()
        self.CommittedStackSize = v_uint64()
        self.SubSystemType = v_uint32()
        self.SubSystemMinorVersion = v_uint16()
        self.SubSystemMajorVersion = v_uint16()
        self.GpValue = v_uint32()
        self.ImageCharacteristics = v_uint16()
        self.DllCharacteristics = v_uint16()
        self.Machine = v_uint16()
        self.ImageContainsCode = v_uint8()
        self.ImageFlags = v_uint8()
        self.LoaderFlags = v_uint32()
        self.ImageFileSize = v_uint32()
        self.CheckSum = v_uint32()


class HIVE_LOAD_FAILURE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Hive = v_ptr64()
        self.Index = v_uint32()
        self.RecoverableIndex = v_uint32()
        self.Locations = vstruct.VArray([ _unnamed_22851() for i in xrange(8) ])
        self.RecoverableLocations = vstruct.VArray([ _unnamed_22851() for i in xrange(8) ])
        self.RegistryIO = _unnamed_22852()
        self.CheckRegistry2 = _unnamed_22853()
        self.CheckKey = _unnamed_22854()
        self.CheckValueList = _unnamed_22855()
        self.CheckHive = _unnamed_22856()
        self.CheckHive1 = _unnamed_22856()
        self.CheckBin = _unnamed_22857()
        self.RecoverData = _unnamed_22858()
        self._pad0160 = v_bytes(size=4)


class PCW_BUFFER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class EX_QUEUE_WORKER_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.QueueDisabled = v_uint32()


class PCW_COUNTER_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CounterMask = v_uint64()
        self.InstanceMask = v_ptr64()


class MI_SECTION_IMAGE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExportedImageInformation = SECTION_IMAGE_INFORMATION()
        self.InternalImageInformation = MI_EXTRA_IMAGE_INFORMATION()


class DBGKD_WRITE_BREAKPOINT32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakPointAddress = v_uint32()
        self.BreakPointHandle = v_uint32()


class TP_CLEANUP_GROUP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_28937(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Active = v_uint32()


class ETW_REPLY_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Queue = KQUEUE()
        self.EventsLost = v_uint32()
        self._pad0048 = v_bytes(size=4)


class OBJECT_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TypeList = LIST_ENTRY()
        self.Name = UNICODE_STRING()
        self.DefaultObject = v_ptr64()
        self.Index = v_uint8()
        self._pad002c = v_bytes(size=3)
        self.TotalNumberOfObjects = v_uint32()
        self.TotalNumberOfHandles = v_uint32()
        self.HighWaterNumberOfObjects = v_uint32()
        self.HighWaterNumberOfHandles = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.TypeInfo = OBJECT_TYPE_INITIALIZER()
        self.TypeLock = EX_PUSH_LOCK()
        self.Key = v_uint32()
        self._pad00c0 = v_bytes(size=4)
        self.CallbackList = LIST_ENTRY()


class ALPC_MESSAGE_ZONE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mdl = v_ptr64()
        self.UserVa = v_ptr64()
        self.UserLimit = v_ptr64()
        self.SystemVa = v_ptr64()
        self.SystemLimit = v_ptr64()
        self.Size = v_uint64()


class KNODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PagedPoolSListHead = SLIST_HEADER()
        self.NonPagedPoolSListHead = vstruct.VArray([ SLIST_HEADER() for i in xrange(3) ])
        self.Affinity = GROUP_AFFINITY()
        self.ProximityId = v_uint32()
        self.NodeNumber = v_uint16()
        self.PrimaryNodeNumber = v_uint16()
        self.MaximumProcessors = v_uint8()
        self.Color = v_uint8()
        self.Flags = flags()
        self.NodePad0 = v_uint8()
        self.Seed = v_uint32()
        self.MmShiftedColor = v_uint32()
        self._pad0068 = v_bytes(size=4)
        self.FreeCount = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.Right = v_uint32()
        self.Left = v_uint32()
        self.CachedKernelStacks = CACHED_KSTACK_LIST()
        self.ParkLock = v_uint32()
        self.NodePad1 = v_uint32()
        self._pad00c0 = v_bytes(size=24)


class PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(1) ])


class ALPC_HANDLE_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Handles = v_ptr64()
        self.TotalHandles = v_uint32()
        self.Flags = v_uint32()
        self.Lock = EX_PUSH_LOCK()


class CM_KEY_HASH_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = EX_PUSH_LOCK()
        self.Owner = v_ptr64()
        self.Entry = v_ptr64()


class IO_WORKITEM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkItem = WORK_QUEUE_ITEM()
        self.Routine = v_ptr64()
        self.IoObject = v_ptr64()
        self.Context = v_ptr64()
        self.Type = v_uint32()
        self._pad0040 = v_bytes(size=4)


class NLS_DATA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AnsiCodePageData = v_ptr64()
        self.OemCodePageData = v_ptr64()
        self.UnicodeCaseTableData = v_ptr64()


class SYSTEM_POWER_CAPABILITIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerButtonPresent = v_uint8()
        self.SleepButtonPresent = v_uint8()
        self.LidPresent = v_uint8()
        self.SystemS1 = v_uint8()
        self.SystemS2 = v_uint8()
        self.SystemS3 = v_uint8()
        self.SystemS4 = v_uint8()
        self.SystemS5 = v_uint8()
        self.HiberFilePresent = v_uint8()
        self.FullWake = v_uint8()
        self.VideoDimPresent = v_uint8()
        self.ApmPresent = v_uint8()
        self.UpsPresent = v_uint8()
        self.ThermalControl = v_uint8()
        self.ProcessorThrottle = v_uint8()
        self.ProcessorMinThrottle = v_uint8()
        self.ProcessorMaxThrottle = v_uint8()
        self.FastSystemS4 = v_uint8()
        self.spare2 = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.DiskSpinDown = v_uint8()
        self.spare3 = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.SystemBatteriesPresent = v_uint8()
        self.BatteriesAreShortTerm = v_uint8()
        self.BatteryScale = vstruct.VArray([ BATTERY_REPORTING_SCALE() for i in xrange(3) ])
        self.AcOnLineWake = v_uint32()
        self.SoftLidWake = v_uint32()
        self.RtcWake = v_uint32()
        self.MinDeviceWakeState = v_uint32()
        self.DefaultLowLatencyWake = v_uint32()


class THERMAL_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ThermalStamp = v_uint32()
        self.ThermalConstant1 = v_uint32()
        self.ThermalConstant2 = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.Processors = v_uint64()
        self.SamplingPeriod = v_uint32()
        self.CurrentTemperature = v_uint32()
        self.PassiveTripPoint = v_uint32()
        self.CriticalTripPoint = v_uint32()
        self.ActiveTripPointCount = v_uint8()
        self._pad002c = v_bytes(size=3)
        self.ActiveTripPoint = vstruct.VArray([ v_uint32() for i in xrange(10) ])
        self._pad0058 = v_bytes(size=4)


class MMEXTEND_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CommittedSize = v_uint64()
        self.ReferenceCount = v_uint32()
        self._pad0010 = v_bytes(size=4)


class VF_TARGET_ALL_SHARED_EXPORT_THUNKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SharedExportThunks = v_ptr64()
        self.PoolSharedExportThunks = v_ptr64()
        self.OrderDependentSharedExportThunks = v_ptr64()


class RTL_USER_PROCESS_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MaximumLength = v_uint32()
        self.Length = v_uint32()
        self.Flags = v_uint32()
        self.DebugFlags = v_uint32()
        self.ConsoleHandle = v_ptr64()
        self.ConsoleFlags = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.StandardInput = v_ptr64()
        self.StandardOutput = v_ptr64()
        self.StandardError = v_ptr64()
        self.CurrentDirectory = CURDIR()
        self.DllPath = UNICODE_STRING()
        self.ImagePathName = UNICODE_STRING()
        self.CommandLine = UNICODE_STRING()
        self.Environment = v_ptr64()
        self.StartingX = v_uint32()
        self.StartingY = v_uint32()
        self.CountX = v_uint32()
        self.CountY = v_uint32()
        self.CountCharsX = v_uint32()
        self.CountCharsY = v_uint32()
        self.FillAttribute = v_uint32()
        self.WindowFlags = v_uint32()
        self.ShowWindowFlags = v_uint32()
        self._pad00b0 = v_bytes(size=4)
        self.WindowTitle = UNICODE_STRING()
        self.DesktopInfo = UNICODE_STRING()
        self.ShellInfo = UNICODE_STRING()
        self.RuntimeData = UNICODE_STRING()
        self.CurrentDirectores = vstruct.VArray([ RTL_DRIVE_LETTER_CURDIR() for i in xrange(32) ])
        self.EnvironmentSize = v_uint64()
        self.EnvironmentVersion = v_uint64()


class _unnamed_28570(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserData = v_ptr64()
        self.Owner = v_ptr64()


class _unnamed_28571(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = LIST_ENTRY()


class _unnamed_21204(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.CompletionFilter = v_uint32()
        self._pad0010 = v_bytes(size=4)


class _unnamed_21207(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FileInformationClass = v_uint32()
        self._pad0010 = v_bytes(size=4)


class ALPC_COMPLETION_LIST_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartMagic = v_uint64()
        self.TotalSize = v_uint32()
        self.ListOffset = v_uint32()
        self.ListSize = v_uint32()
        self.BitmapOffset = v_uint32()
        self.BitmapSize = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSize = v_uint32()
        self.AttributeFlags = v_uint32()
        self.AttributeSize = v_uint32()
        self._pad0080 = v_bytes(size=84)
        self.State = ALPC_COMPLETION_LIST_STATE()
        self.LastMessageId = v_uint32()
        self.LastCallbackId = v_uint32()
        self._pad0100 = v_bytes(size=112)
        self.PostCount = v_uint32()
        self._pad0180 = v_bytes(size=124)
        self.ReturnCount = v_uint32()
        self._pad0200 = v_bytes(size=124)
        self.LogSequenceNumber = v_uint32()
        self._pad0280 = v_bytes(size=124)
        self.UserLock = RTL_SRWLOCK()
        self.EndMagic = v_uint64()
        self._pad0300 = v_bytes(size=112)


class LAZY_WRITER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ScanDpc = KDPC()
        self.ScanTimer = KTIMER()
        self.ScanActive = v_uint8()
        self.OtherWork = v_uint8()
        self.PendingTeardownScan = v_uint8()
        self.PendingPeriodicScan = v_uint8()
        self.PendingLowMemoryScan = v_uint8()
        self.PendingPowerScan = v_uint8()
        self._pad0088 = v_bytes(size=2)


class u(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.KeyNode = CM_KEY_NODE()


class VI_FAULT_TRACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Thread = v_ptr64()
        self.StackTrace = vstruct.VArray([ v_ptr64() for i in xrange(8) ])


class IO_RESOURCE_REQUIREMENTS_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.SlotNumber = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.AlternativeLists = v_uint32()
        self.List = vstruct.VArray([ IO_RESOURCE_LIST() for i in xrange(1) ])


class _unnamed_26616(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = _unnamed_26671()


class VF_WATCHDOG_IRP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.Irp = v_ptr64()
        self.DueTickCount = v_uint32()
        self.Inserted = v_uint8()
        self.TrackedStackLocation = v_uint8()
        self.CancelTimeoutTicks = v_uint16()


class MMWSLE_NONDIRECT_HASH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Key = v_ptr64()
        self.Index = v_uint32()
        self._pad0010 = v_bytes(size=4)


class RTL_ATOM_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashLink = v_ptr64()
        self.HandleIndex = v_uint16()
        self.Atom = v_uint16()
        self.ReferenceCount = v_uint16()
        self.Flags = v_uint8()
        self.NameLength = v_uint8()
        self.Name = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0018 = v_bytes(size=6)


class KUMS_CONTEXT_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P1Home = v_uint64()
        self.P2Home = v_uint64()
        self.P3Home = v_uint64()
        self.P4Home = v_uint64()
        self.StackTop = v_ptr64()
        self.StackSize = v_uint64()
        self.RspOffset = v_uint64()
        self.Rip = v_uint64()
        self.FltSave = v_ptr64()
        self.Volatile = v_uint64()
        self.TrapFrame = v_ptr64()
        self.ExceptionFrame = v_ptr64()
        self.SourceThread = v_ptr64()
        self.Return = v_uint64()




########NEW FILE########
__FILENAME__ = win32k
# Version: 6.1
# Architecture: amd64
import vstruct
from vstruct.primitives import *

ETW_THREAD_FLAG = v_enum()
ETW_THREAD_FLAG.ETW_THREAD_FLAG_HAD_INPUT = 0
ETW_THREAD_FLAG.ETW_THREAD_FLAG_HAD_VISIBLE_WINDOWS = 1
ETW_THREAD_FLAG.ETW_THREAD_FLAG_HAS_NEW_INPUT = 2
ETW_THREAD_FLAG.ETW_THREAD_FLAG_MAX = 3


TOUCHSTATE = v_enum()
TOUCHSTATE.TOUCHSTATE_INVALID = -1
TOUCHSTATE.TOUCHSTATE_NONE = 0
TOUCHSTATE.TOUCHSTATE_DOWN = 1
TOUCHSTATE.TOUCHSTATE_MOVE = 2
TOUCHSTATE.TOUCHSTATE_UPOUTOFRANGE = 3
TOUCHSTATE.TOUCHSTATE_INAIR = 4
TOUCHSTATE.TOUCHSTATE_INAIRMOVE = 5
TOUCHSTATE.TOUCHSTATE_INAIROUTOFRANGE = 6
TOUCHSTATE.TOUCHSTATE_COUNT = 7


PS_STD_HANDLE_STATE = v_enum()
PS_STD_HANDLE_STATE.PsNeverDuplicate = 0
PS_STD_HANDLE_STATE.PsRequestDuplicate = 1
PS_STD_HANDLE_STATE.PsAlwaysDuplicate = 2
PS_STD_HANDLE_STATE.PsMaxStdHandleStates = 3


WHEA_ERROR_SEVERITY = v_enum()
WHEA_ERROR_SEVERITY.WheaErrSevRecoverable = 0
WHEA_ERROR_SEVERITY.WheaErrSevFatal = 1
WHEA_ERROR_SEVERITY.WheaErrSevCorrected = 2
WHEA_ERROR_SEVERITY.WheaErrSevInformational = 3


D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED = v_enum()
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_UNINITIALIZED = 0
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_HD15 = 1
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_DVI = 2
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_HDMI = 3
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_HDMI2 = 4
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_SVIDEO_4PIN = 5
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_SVIDEO_7PIN = 6
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_RCA_COMPOSITE = 7
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_RCA_3COMPONENT = 8
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_BNC = 9
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_RF = 10
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_SDTVDONGLE = 11
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_INTERNAL = 12
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_OTHER = 255


D3DKMDT_MONITOR_FREQUENCY_RANGE_CONSTRAINT = v_enum()
D3DKMDT_MONITOR_FREQUENCY_RANGE_CONSTRAINT.D3DKMDT_MFRC_UNINITIALIZED = 0
D3DKMDT_MONITOR_FREQUENCY_RANGE_CONSTRAINT.D3DKMDT_MFRC_ACTIVESIZE = 1
D3DKMDT_MONITOR_FREQUENCY_RANGE_CONSTRAINT.D3DKMDT_MFRC_MAXPIXELRATE = 2


WOW64_SHARED_INFORMATION = v_enum()
WOW64_SHARED_INFORMATION.SharedNtdll32LdrInitializeThunk = 0
WOW64_SHARED_INFORMATION.SharedNtdll32KiUserExceptionDispatcher = 1
WOW64_SHARED_INFORMATION.SharedNtdll32KiUserApcDispatcher = 2
WOW64_SHARED_INFORMATION.SharedNtdll32KiUserCallbackDispatcher = 3
WOW64_SHARED_INFORMATION.SharedNtdll32LdrHotPatchRoutine = 4
WOW64_SHARED_INFORMATION.SharedNtdll32ExpInterlockedPopEntrySListFault = 5
WOW64_SHARED_INFORMATION.SharedNtdll32ExpInterlockedPopEntrySListResume = 6
WOW64_SHARED_INFORMATION.SharedNtdll32ExpInterlockedPopEntrySListEnd = 7
WOW64_SHARED_INFORMATION.SharedNtdll32RtlUserThreadStart = 8
WOW64_SHARED_INFORMATION.SharedNtdll32pQueryProcessDebugInformationRemote = 9
WOW64_SHARED_INFORMATION.SharedNtdll32EtwpNotificationThread = 10
WOW64_SHARED_INFORMATION.SharedNtdll32BaseAddress = 11
WOW64_SHARED_INFORMATION.Wow64SharedPageEntriesCount = 12


REG_NOTIFY_CLASS = v_enum()
REG_NOTIFY_CLASS.RegNtDeleteKey = 0
REG_NOTIFY_CLASS.RegNtPreDeleteKey = 0
REG_NOTIFY_CLASS.RegNtSetValueKey = 1
REG_NOTIFY_CLASS.RegNtPreSetValueKey = 1
REG_NOTIFY_CLASS.RegNtDeleteValueKey = 2
REG_NOTIFY_CLASS.RegNtPreDeleteValueKey = 2
REG_NOTIFY_CLASS.RegNtSetInformationKey = 3
REG_NOTIFY_CLASS.RegNtPreSetInformationKey = 3
REG_NOTIFY_CLASS.RegNtRenameKey = 4
REG_NOTIFY_CLASS.RegNtPreRenameKey = 4
REG_NOTIFY_CLASS.RegNtEnumerateKey = 5
REG_NOTIFY_CLASS.RegNtPreEnumerateKey = 5
REG_NOTIFY_CLASS.RegNtEnumerateValueKey = 6
REG_NOTIFY_CLASS.RegNtPreEnumerateValueKey = 6
REG_NOTIFY_CLASS.RegNtQueryKey = 7
REG_NOTIFY_CLASS.RegNtPreQueryKey = 7
REG_NOTIFY_CLASS.RegNtQueryValueKey = 8
REG_NOTIFY_CLASS.RegNtPreQueryValueKey = 8
REG_NOTIFY_CLASS.RegNtQueryMultipleValueKey = 9
REG_NOTIFY_CLASS.RegNtPreQueryMultipleValueKey = 9
REG_NOTIFY_CLASS.RegNtPreCreateKey = 10
REG_NOTIFY_CLASS.RegNtPostCreateKey = 11
REG_NOTIFY_CLASS.RegNtPreOpenKey = 12
REG_NOTIFY_CLASS.RegNtPostOpenKey = 13
REG_NOTIFY_CLASS.RegNtKeyHandleClose = 14
REG_NOTIFY_CLASS.RegNtPreKeyHandleClose = 14
REG_NOTIFY_CLASS.RegNtPostDeleteKey = 15
REG_NOTIFY_CLASS.RegNtPostSetValueKey = 16
REG_NOTIFY_CLASS.RegNtPostDeleteValueKey = 17
REG_NOTIFY_CLASS.RegNtPostSetInformationKey = 18
REG_NOTIFY_CLASS.RegNtPostRenameKey = 19
REG_NOTIFY_CLASS.RegNtPostEnumerateKey = 20
REG_NOTIFY_CLASS.RegNtPostEnumerateValueKey = 21
REG_NOTIFY_CLASS.RegNtPostQueryKey = 22
REG_NOTIFY_CLASS.RegNtPostQueryValueKey = 23
REG_NOTIFY_CLASS.RegNtPostQueryMultipleValueKey = 24
REG_NOTIFY_CLASS.RegNtPostKeyHandleClose = 25
REG_NOTIFY_CLASS.RegNtPreCreateKeyEx = 26
REG_NOTIFY_CLASS.RegNtPostCreateKeyEx = 27
REG_NOTIFY_CLASS.RegNtPreOpenKeyEx = 28
REG_NOTIFY_CLASS.RegNtPostOpenKeyEx = 29
REG_NOTIFY_CLASS.RegNtPreFlushKey = 30
REG_NOTIFY_CLASS.RegNtPostFlushKey = 31
REG_NOTIFY_CLASS.RegNtPreLoadKey = 32
REG_NOTIFY_CLASS.RegNtPostLoadKey = 33
REG_NOTIFY_CLASS.RegNtPreUnLoadKey = 34
REG_NOTIFY_CLASS.RegNtPostUnLoadKey = 35
REG_NOTIFY_CLASS.RegNtPreQueryKeySecurity = 36
REG_NOTIFY_CLASS.RegNtPostQueryKeySecurity = 37
REG_NOTIFY_CLASS.RegNtPreSetKeySecurity = 38
REG_NOTIFY_CLASS.RegNtPostSetKeySecurity = 39
REG_NOTIFY_CLASS.RegNtCallbackObjectContextCleanup = 40
REG_NOTIFY_CLASS.RegNtPreRestoreKey = 41
REG_NOTIFY_CLASS.RegNtPostRestoreKey = 42
REG_NOTIFY_CLASS.RegNtPreSaveKey = 43
REG_NOTIFY_CLASS.RegNtPostSaveKey = 44
REG_NOTIFY_CLASS.RegNtPreReplaceKey = 45
REG_NOTIFY_CLASS.RegNtPostReplaceKey = 46
REG_NOTIFY_CLASS.MaxRegNtNotifyClass = 47


DEVICE_RELATION_TYPE = v_enum()
DEVICE_RELATION_TYPE.BusRelations = 0
DEVICE_RELATION_TYPE.EjectionRelations = 1
DEVICE_RELATION_TYPE.PowerRelations = 2
DEVICE_RELATION_TYPE.RemovalRelations = 3
DEVICE_RELATION_TYPE.TargetDeviceRelation = 4
DEVICE_RELATION_TYPE.SingleBusRelations = 5
DEVICE_RELATION_TYPE.TransportRelations = 6


D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE = v_enum()
D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE.D3DKMDT_VPPMT_UNINITIALIZED = 0
D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE.D3DKMDT_VPPMT_NOPROTECTION = 1
D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE.D3DKMDT_VPPMT_MACROVISION_APSTRIGGER = 2
D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE.D3DKMDT_VPPMT_MACROVISION_FULLSUPPORT = 3
D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE.D3DKMDT_VPPMT_NOTSPECIFIED = 255


IO_ALLOCATION_ACTION = v_enum()
IO_ALLOCATION_ACTION.KeepObject = 1
IO_ALLOCATION_ACTION.DeallocateObject = 2
IO_ALLOCATION_ACTION.DeallocateObjectKeepRegisters = 3


_unnamed_13236 = v_enum()
_unnamed_13236.DMM_DIAG_INFO_VISTA_BETA2_VERSION = 4097
_unnamed_13236.DMM_DIAG_INFO_VISTA_RC1_VERSION = 4098
_unnamed_13236.DMM_DIAG_INFO_VISTA_RTM_VERSION = 4099
_unnamed_13236.DMM_DIAG_INFO_WIN7_MQ_VERSION = 8192
_unnamed_13236.DMM_DIAG_INFO_WIN7_M3_VERSION = 8193
_unnamed_13236.DMM_DIAG_INFO_VERSION = 8193


BUS_QUERY_ID_TYPE = v_enum()
BUS_QUERY_ID_TYPE.BusQueryDeviceID = 0
BUS_QUERY_ID_TYPE.BusQueryHardwareIDs = 1
BUS_QUERY_ID_TYPE.BusQueryCompatibleIDs = 2
BUS_QUERY_ID_TYPE.BusQueryInstanceID = 3
BUS_QUERY_ID_TYPE.BusQueryDeviceSerialNumber = 4
BUS_QUERY_ID_TYPE.BusQueryContainerID = 5


PROFILE_MAP = v_enum()
PROFILE_MAP.PMAP_COLORS = 0
PROFILE_MAP.PMAP_CURSORS = 1
PROFILE_MAP.PMAP_WINDOWSM = 2
PROFILE_MAP.PMAP_WINDOWSU = 3
PROFILE_MAP.PMAP_DESKTOP = 4
PROFILE_MAP.PMAP_ICONS = 5
PROFILE_MAP.PMAP_FONTS = 6
PROFILE_MAP.PMAP_TRUETYPE = 7
PROFILE_MAP.PMAP_KBDLAYOUT = 8
PROFILE_MAP.PMAP_INPUT = 9
PROFILE_MAP.PMAP_SUBSYSTEMS = 10
PROFILE_MAP.PMAP_BEEP = 11
PROFILE_MAP.PMAP_MOUSE = 12
PROFILE_MAP.PMAP_KEYBOARD = 13
PROFILE_MAP.PMAP_STICKYKEYS = 14
PROFILE_MAP.PMAP_KEYBOARDRESPONSE = 15
PROFILE_MAP.PMAP_MOUSEKEYS = 16
PROFILE_MAP.PMAP_TOGGLEKEYS = 17
PROFILE_MAP.PMAP_TIMEOUT = 18
PROFILE_MAP.PMAP_SOUNDSENTRY = 19
PROFILE_MAP.PMAP_SHOWSOUNDS = 20
PROFILE_MAP.PMAP_AEDEBUG = 21
PROFILE_MAP.PMAP_NETWORK = 22
PROFILE_MAP.PMAP_METRICS = 23
PROFILE_MAP.PMAP_UKBDLAYOUT = 24
PROFILE_MAP.PMAP_UKBDLAYOUTTOGGLE = 25
PROFILE_MAP.PMAP_WINLOGON = 26
PROFILE_MAP.PMAP_KEYBOARDPREF = 27
PROFILE_MAP.PMAP_SCREENREADER = 28
PROFILE_MAP.PMAP_HIGHCONTRAST = 29
PROFILE_MAP.PMAP_IMECOMPAT = 30
PROFILE_MAP.PMAP_IMM = 31
PROFILE_MAP.PMAP_POOLLIMITS = 32
PROFILE_MAP.PMAP_COMPAT32 = 33
PROFILE_MAP.PMAP_SETUPPROGRAMNAMES = 34
PROFILE_MAP.PMAP_INPUTMETHOD = 35
PROFILE_MAP.PMAP_MOUCLASS_PARAMS = 36
PROFILE_MAP.PMAP_KBDCLASS_PARAMS = 37
PROFILE_MAP.PMAP_COMPUTERNAME = 38
PROFILE_MAP.PMAP_TS = 39
PROFILE_MAP.PMAP_TABLETPC = 40
PROFILE_MAP.PMAP_MEDIACENTER = 41
PROFILE_MAP.PMAP_TS_EXCLUDE_DESKTOP_VERSION = 42
PROFILE_MAP.PMAP_WOW64_COMPAT32 = 43
PROFILE_MAP.PMAP_WOW64_IMECOMPAT = 44
PROFILE_MAP.PMAP_SERVERR2 = 45
PROFILE_MAP.PMAP_STARTER = 46
PROFILE_MAP.PMAP_ACCESS = 47
PROFILE_MAP.PMAP_AUDIODESCRIPTION = 48
PROFILE_MAP.PMAP_CONTROL = 49
PROFILE_MAP.PMAP_LAST = 49


NT_PRODUCT_TYPE = v_enum()
NT_PRODUCT_TYPE.NtProductWinNt = 1
NT_PRODUCT_TYPE.NtProductLanManNt = 2
NT_PRODUCT_TYPE.NtProductServer = 3


DMM_VIDPNCHANGE_TYPE = v_enum()
DMM_VIDPNCHANGE_TYPE.DMM_CVR_UNINITIALIZED = 0
DMM_VIDPNCHANGE_TYPE.DMM_CVR_UPDATEMODALITY = 1
DMM_VIDPNCHANGE_TYPE.DMM_CVR_ADDPATH = 2
DMM_VIDPNCHANGE_TYPE.DMM_CVR_ADDPATHS = 3
DMM_VIDPNCHANGE_TYPE.DMM_CVR_REMOVEPATH = 4
DMM_VIDPNCHANGE_TYPE.DMM_CVR_REMOVEALLPATHS = 5


DEVICE_POWER_STATE = v_enum()
DEVICE_POWER_STATE.PowerDeviceUnspecified = 0
DEVICE_POWER_STATE.PowerDeviceD0 = 1
DEVICE_POWER_STATE.PowerDeviceD1 = 2
DEVICE_POWER_STATE.PowerDeviceD2 = 3
DEVICE_POWER_STATE.PowerDeviceD3 = 4
DEVICE_POWER_STATE.PowerDeviceMaximum = 5


WHEA_ERROR_SOURCE_TYPE = v_enum()
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMCE = 0
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCMC = 1
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCPE = 2
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeNMI = 3
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypePCIe = 4
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeGeneric = 5
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeINIT = 6
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeBOOT = 7
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeSCIGeneric = 8
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFMCA = 9
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCMC = 10
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCPE = 11
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMax = 12


DXGK_DIAG_CODE_POINT_TYPE = v_enum()
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_NONE = 0
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_RECOMMEND_FUNC_VIDPN = 1
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_OS_RECOMMENDED_VIDPN = 2
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_SDC_LOG_FAILURE = 3
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_SDC_INVALIDATE_ERROR = 4
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CDS_LOG_FAILURE = 5
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CDS_FAILURE_DB = 7
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_RETRIEVE_BTL = 8
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_RETRIEVE_DB = 9
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_QDC_LOG_FAILURE = 10
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_POWER_ON_GDI = 11
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_POWER_OFF_GDI = 12
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_POWER_ON_MONITOR = 13
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_POWER_OFF_MONITOR = 14
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_POWER_DIM_MONITOR = 15
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_POWER_UNDIM_MONITOR = 16
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_BACKTRACK = 17
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_CLOSEST_TARGET_MODE = 18
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_NO_EXACT_SOURCE_MODE = 19
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_NO_EXACT_TARGET_MODE = 20
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_SOURCE_MODE_NOT_PINNED = 21
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_TARGET_MODE_NOT_PINNED = 22
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_RESTARTED = 23
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_TDR = 24
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_ACPI_EVENT_NOTIFICATION = 25
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CREATEMDEV_USE_DEFAULT_MODE = 26
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CONNECTED_SET_LOG_FAILURE = 27
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_INVALIDATE_DXGK_MODE_CACHE = 28
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_REBUILD_DXGK_MODE_CACHE = 29
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CREATEFUNVIDPN_RELAX_REFRESH_MATCH = 30
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CREATEFUNVIDPN_CCDBML_FAIL_VISTABML_SUCCESSED = 31
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_BEST_SOURCE_MODE = 32
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_BEST_TARGET_MODE = 33
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_ADD_DEVICE = 34
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_START_ADAPTER = 35
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_STOP_ADAPTER = 36
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CHILD_POLLING = 37
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CHILD_POLLING_TARGET = 38
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_INDICATE_CHILD_STATUS = 39
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_HANDLE_IRP = 40
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CHANGE_UNSUPPORTED_MONITOR_MODE_FLAG = 41
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_ACPI_NOTIFY_CALLBACK = 42
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_EXCLUDE_EVICTALL_DISABLEGDI = 43
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_EXCLUDE_EVICTALL_ENABLEGDI = 44
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_EXCLUDE_MODESWITCH = 45
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_SYNC_MONITOR_EVENT = 46
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_PNP_NOTIFY_GDI = 47
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_PNP_ENABLE_VGA = 48
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_TDR_SWITCH_GDI = 49
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_CDD_CREATE_DEVICE_FAILED = 50
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_CDD_DEVICE_REMOVED = 51
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_CDD_DRVASSERTMODE_TRUE_FAILED = 52
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_CDD_RECREATE_DEVICE_FAILED = 53
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CDD_MAPSHADOWBUFFER_FAILED = 54
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_COMMIT_VIDPN_LOG_FAILURE = 55
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_DRIVER_RECOMMEND_LOG_FAILURE = 56
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_SDC_ENFORCED_CLONE_PATH_INVALID_SOURCE_IDX = 57
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_DRVPROBEANDCAPTURE_FAILED = 58
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_DXGKCDDENABLE_OPTIMIZED_MODE_CHANGE = 59
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_DXGKSETDISPLAYMODE_OPTIMIZED_MODE_CHANGE = 60
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_MON_DEPART_GETRECENTTOP_FAIL = 61
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_MON_ARRIVE_INC_ADD_FAIL = 62
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CCD_DATABASE_PERSIST = 63
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CCD_DATABASE_PERSIST_NO_CONNECTIVITY_HASH = 64
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_MAX = 64
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_FORCE_UINT32 = -1


DMM_VIDPN_MONITOR_TYPE = v_enum()
DMM_VIDPN_MONITOR_TYPE.DMM_VMT_UNINITIALIZED = 0
DMM_VIDPN_MONITOR_TYPE.DMM_VMT_PHYSICAL_MONITOR = 1
DMM_VIDPN_MONITOR_TYPE.DMM_VMT_BOOT_PERSISTENT_MONITOR = 2
DMM_VIDPN_MONITOR_TYPE.DMM_VMT_PERSISTENT_MONITOR = 3
DMM_VIDPN_MONITOR_TYPE.DMM_VMT_TEMPORARY_MONITOR = 4
DMM_VIDPN_MONITOR_TYPE.DMM_VMT_SIMULATED_MONITOR = 5


D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING = v_enum()
D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING.D3DDDI_VSSLO_UNINITIALIZED = 0
D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING.D3DDDI_VSSLO_PROGRESSIVE = 1
D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING.D3DDDI_VSSLO_INTERLACED_UPPERFIELDFIRST = 2
D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING.D3DDDI_VSSLO_INTERLACED_LOWERFIELDFIRST = 3
D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING.D3DDDI_VSSLO_OTHER = 255


D3DKMDT_MONITOR_ORIENTATION = v_enum()
D3DKMDT_MONITOR_ORIENTATION.D3DKMDT_MO_UNINITIALIZED = 0
D3DKMDT_MONITOR_ORIENTATION.D3DKMDT_MO_0DEG = 1
D3DKMDT_MONITOR_ORIENTATION.D3DKMDT_MO_90DEG = 2
D3DKMDT_MONITOR_ORIENTATION.D3DKMDT_MO_180DEG = 3
D3DKMDT_MONITOR_ORIENTATION.D3DKMDT_MO_270DEG = 4


D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY = v_enum()
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_UNINITIALIZED = -2
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_OTHER = -1
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_HD15 = 0
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_SVIDEO = 1
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_COMPOSITE_VIDEO = 2
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_COMPONENT_VIDEO = 3
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_DVI = 4
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_HDMI = 5
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_LVDS = 6
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_D_JPN = 8
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_SDI = 9
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_DISPLAYPORT_EXTERNAL = 10
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_DISPLAYPORT_EMBEDDED = 11
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_UDI_EXTERNAL = 12
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_UDI_EMBEDDED = 13
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_SDTVDONGLE = 14
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_INTERNAL = -2147483648
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_SVIDEO_4PIN = 1
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_SVIDEO_7PIN = 1
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_RF = 2
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_RCA_3COMPONENT = 3
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_BNC = 3


PS_CREATE_STATE = v_enum()
PS_CREATE_STATE.PsCreateInitialState = 0
PS_CREATE_STATE.PsCreateFailOnFileOpen = 1
PS_CREATE_STATE.PsCreateFailOnSectionCreate = 2
PS_CREATE_STATE.PsCreateFailExeFormat = 3
PS_CREATE_STATE.PsCreateFailMachineMismatch = 4
PS_CREATE_STATE.PsCreateFailExeName = 5
PS_CREATE_STATE.PsCreateSuccess = 6
PS_CREATE_STATE.PsCreateMaximumStates = 7


EVENT_TYPE = v_enum()
EVENT_TYPE.NotificationEvent = 0
EVENT_TYPE.SynchronizationEvent = 1


D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE = v_enum()
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_UNINITIALIZED = 0
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_PRIMARY = 1
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_SECONDARY = 2
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_TERTIARY = 3
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_QUATERNARY = 4
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_QUINARY = 5
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_SENARY = 6
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_SEPTENARY = 7
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_OCTONARY = 8
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_NONARY = 9
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_DENARY = 10
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_MAX = 32
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_NOTSPECIFIED = 255


PS_IFEO_KEY_STATE = v_enum()
PS_IFEO_KEY_STATE.PsReadIFEOAllValues = 0
PS_IFEO_KEY_STATE.PsSkipIFEODebugger = 1
PS_IFEO_KEY_STATE.PsSkipAllIFEO = 2
PS_IFEO_KEY_STATE.PsMaxIFEOKeyStates = 3


D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE = v_enum()
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_RenderCommandBuffer = 0
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_DeferredCommandBuffer = 1
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_SystemCommandBuffer = 2
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_MmIoFlipCommandBuffer = 3
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_WaitCommandBuffer = 4
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_SignalCommandBuffer = 5
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_DeviceCommandBuffer = 6
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_SoftwareCommandBuffer = 7
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_QueuePacketTypeMax = 8


INTERLOCKED_RESULT = v_enum()
INTERLOCKED_RESULT.ResultNegative = 1
INTERLOCKED_RESULT.ResultZero = 0
INTERLOCKED_RESULT.ResultPositive = 2


D3DKMDT_VIDPN_PRESENT_PATH_CONTENT = v_enum()
D3DKMDT_VIDPN_PRESENT_PATH_CONTENT.D3DKMDT_VPPC_UNINITIALIZED = 0
D3DKMDT_VIDPN_PRESENT_PATH_CONTENT.D3DKMDT_VPPC_GRAPHICS = 1
D3DKMDT_VIDPN_PRESENT_PATH_CONTENT.D3DKMDT_VPPC_VIDEO = 2
D3DKMDT_VIDPN_PRESENT_PATH_CONTENT.D3DKMDT_VPPC_NOTSPECIFIED = 255


THRESHOLD_SELECTOR = v_enum()
THRESHOLD_SELECTOR.ThresholdMouse = 0
THRESHOLD_SELECTOR.ThresholdPen = 1
THRESHOLD_SELECTOR.ThresholdMouseDragOut = 2
THRESHOLD_SELECTOR.ThresholdPenDragOut = 3
THRESHOLD_SELECTOR.ThresholdMouseSideMove = 4
THRESHOLD_SELECTOR.ThresholdPenSideMove = 5
THRESHOLD_SELECTOR.ThresholdAlways = 6
THRESHOLD_SELECTOR.ThresholdLast = 7


POOL_TYPE = v_enum()
POOL_TYPE.NonPagedPool = 0
POOL_TYPE.PagedPool = 1
POOL_TYPE.NonPagedPoolMustSucceed = 2
POOL_TYPE.DontUseThisType = 3
POOL_TYPE.NonPagedPoolCacheAligned = 4
POOL_TYPE.PagedPoolCacheAligned = 5
POOL_TYPE.NonPagedPoolCacheAlignedMustS = 6
POOL_TYPE.MaxPoolType = 7
POOL_TYPE.NonPagedPoolSession = 32
POOL_TYPE.PagedPoolSession = 33
POOL_TYPE.NonPagedPoolMustSucceedSession = 34
POOL_TYPE.DontUseThisTypeSession = 35
POOL_TYPE.NonPagedPoolCacheAlignedSession = 36
POOL_TYPE.PagedPoolCacheAlignedSession = 37
POOL_TYPE.NonPagedPoolCacheAlignedMustSSession = 38


DMM_CLIENT_TYPE = v_enum()
DMM_CLIENT_TYPE.DMM_CT_UNINITIALIZED = 0
DMM_CLIENT_TYPE.DMM_CT_CDD_NOPATHDATA = 1
DMM_CLIENT_TYPE.DMM_CT_USERMODE = 2
DMM_CLIENT_TYPE.DMM_CT_CDD_PATHDATA = 3
DMM_CLIENT_TYPE.DMM_CT_DXGPORT = 4


FSINFOCLASS = v_enum()
FSINFOCLASS.FileFsVolumeInformation = 1
FSINFOCLASS.FileFsLabelInformation = 2
FSINFOCLASS.FileFsSizeInformation = 3
FSINFOCLASS.FileFsDeviceInformation = 4
FSINFOCLASS.FileFsAttributeInformation = 5
FSINFOCLASS.FileFsControlInformation = 6
FSINFOCLASS.FileFsFullSizeInformation = 7
FSINFOCLASS.FileFsObjectIdInformation = 8
FSINFOCLASS.FileFsDriverPathInformation = 9
FSINFOCLASS.FileFsVolumeFlagsInformation = 10
FSINFOCLASS.FileFsMaximumInformation = 11


D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE = v_enum()
D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE.D3DKMT_ClientRenderBuffer = 0
D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE.D3DKMT_ClientPagingBuffer = 1
D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE.D3DKMT_SystemPagingBuffer = 2
D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE.D3DKMT_SystemPreemptionBuffer = 3
D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE.D3DKMT_DmaPacketTypeMax = 4


MODE = v_enum()
MODE.KernelMode = 0
MODE.UserMode = 1
MODE.MaximumMode = 2


SM_STORAGE_MODIFIER = v_enum()
SM_STORAGE_MODIFIER.SmStorageActual = 0
SM_STORAGE_MODIFIER.SmStorageNonActual = 1


DMM_MONITOR_PRESENCE_EVENT_TYPE = v_enum()
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_UNINITIALIZED = 0
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_ADDMONITOR = 1
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_REMOVEMONITOR = 2
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_DRIVERARRIVAL = 3
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_DRIVERQUERYREMOVE = 4
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_DRIVERREMOVECANCELLED = 5
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_DRIVERREMOVECOMPLETE = 6
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_DEVICENODEREADY = 7
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_EDIDCHANGE = 8
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_MONITORDISABLE = 9
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_MONITORENABLE = 10
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_ADAPTERADD = 11
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_ADAPTERREMOVAL = 12
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_INVALIDATION = 13
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_ADDSIMULATEDMONITOR = 1073741825
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_REMOVESIMULATEDMONITOR = 1073741826
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_MAXVALID = 1073741826


WINDOW_ARRANGEMENT_COMMAND = v_enum()
WINDOW_ARRANGEMENT_COMMAND.WARR_MOVE_FIRST = 10
WINDOW_ARRANGEMENT_COMMAND.WARR_RESTORE_UP = 10
WINDOW_ARRANGEMENT_COMMAND.WARR_RESTORE_DOWN = 11
WINDOW_ARRANGEMENT_COMMAND.WARR_VRESTORE_UP = 12
WINDOW_ARRANGEMENT_COMMAND.WARR_VRESTORE_DOWN = 13
WINDOW_ARRANGEMENT_COMMAND.WARR_VMAXIMIZE_RIGHT = 14
WINDOW_ARRANGEMENT_COMMAND.WARR_VMAXIMIZE_LEFT = 15
WINDOW_ARRANGEMENT_COMMAND.WARR_MOVE_NEXT_MONITOR_LEFT = 16
WINDOW_ARRANGEMENT_COMMAND.WARR_MOVE_NEXT_MONITOR_RIGHT = 17
WINDOW_ARRANGEMENT_COMMAND.WARR_MOVE_LAST = 18


OB_OPEN_REASON = v_enum()
OB_OPEN_REASON.ObCreateHandle = 0
OB_OPEN_REASON.ObOpenHandle = 1
OB_OPEN_REASON.ObDuplicateHandle = 2
OB_OPEN_REASON.ObInheritHandle = 3
OB_OPEN_REASON.ObMaxOpenReason = 4


DMM_MODE_PRUNING_ALGORITHM = v_enum()
DMM_MODE_PRUNING_ALGORITHM.DMM_MPA_UNINITIALIZED = 0
DMM_MODE_PRUNING_ALGORITHM.DMM_MPA_GDI = 1
DMM_MODE_PRUNING_ALGORITHM.DMM_MPA_VISTA = 2
DMM_MODE_PRUNING_ALGORITHM.DMM_MPA_GDI_VISTA_UNION = 3
DMM_MODE_PRUNING_ALGORITHM.DMM_MPA_MAXVALID = 3


DEVICE_TEXT_TYPE = v_enum()
DEVICE_TEXT_TYPE.DeviceTextDescription = 0
DEVICE_TEXT_TYPE.DeviceTextLocationInformation = 1


POWER_STATE_TYPE = v_enum()
POWER_STATE_TYPE.SystemPowerState = 0
POWER_STATE_TYPE.DevicePowerState = 1


PS_ATTRIBUTE_NUM = v_enum()
PS_ATTRIBUTE_NUM.PsAttributeParentProcess = 0
PS_ATTRIBUTE_NUM.PsAttributeDebugObject = 1
PS_ATTRIBUTE_NUM.PsAttributeToken = 2
PS_ATTRIBUTE_NUM.PsAttributeClientId = 3
PS_ATTRIBUTE_NUM.PsAttributeTebAddress = 4
PS_ATTRIBUTE_NUM.PsAttributeImageName = 5
PS_ATTRIBUTE_NUM.PsAttributeImageInfo = 6
PS_ATTRIBUTE_NUM.PsAttributeMemoryReserve = 7
PS_ATTRIBUTE_NUM.PsAttributePriorityClass = 8
PS_ATTRIBUTE_NUM.PsAttributeErrorMode = 9
PS_ATTRIBUTE_NUM.PsAttributeStdHandleInfo = 10
PS_ATTRIBUTE_NUM.PsAttributeHandleList = 11
PS_ATTRIBUTE_NUM.PsAttributeGroupAffinity = 12
PS_ATTRIBUTE_NUM.PsAttributePreferredNode = 13
PS_ATTRIBUTE_NUM.PsAttributeIdealProcessor = 14
PS_ATTRIBUTE_NUM.PsAttributeUmsThread = 15
PS_ATTRIBUTE_NUM.PsAttributeExecuteOptions = 16
PS_ATTRIBUTE_NUM.PsAttributeMax = 17


IRQ_PRIORITY = v_enum()
IRQ_PRIORITY.IrqPriorityUndefined = 0
IRQ_PRIORITY.IrqPriorityLow = 1
IRQ_PRIORITY.IrqPriorityNormal = 2
IRQ_PRIORITY.IrqPriorityHigh = 3


D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS = v_enum()
D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS.D3DKMT_AllocationPriorityClassMinimum = 0
D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS.D3DKMT_AllocationPriorityClassLow = 1
D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS.D3DKMT_AllocationPriorityClassNormal = 2
D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS.D3DKMT_AllocationPriorityClassHigh = 3
D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS.D3DKMT_AllocationPriorityClassMaximum = 4
D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS.D3DKMT_MaxAllocationPriorityClass = 5


D3DKMDT_MONITOR_CAPABILITIES_ORIGIN = v_enum()
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_UNINITIALIZED = 0
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_DEFAULTMONITORPROFILE = 1
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_MONITORDESCRIPTOR = 2
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_MONITORDESCRIPTOR_REGISTRYOVERRIDE = 3
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_SPECIFICCAP_REGISTRYOVERRIDE = 4
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_DRIVER = 5
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_MAXVALID = 5


D3DKMDT_PIXEL_VALUE_ACCESS_MODE = v_enum()
D3DKMDT_PIXEL_VALUE_ACCESS_MODE.D3DKMDT_PVAM_UNINITIALIZED = 0
D3DKMDT_PIXEL_VALUE_ACCESS_MODE.D3DKMDT_PVAM_DIRECT = 1
D3DKMDT_PIXEL_VALUE_ACCESS_MODE.D3DKMDT_PVAM_PRESETPALETTE = 2
D3DKMDT_PIXEL_VALUE_ACCESS_MODE.D3DKMDT_PVAM_SETTABLEPALETTE = 3
D3DKMDT_PIXEL_VALUE_ACCESS_MODE.D3DKMDT_PVAM_MAXVALID = 3


SECURITY_OPERATION_CODE = v_enum()
SECURITY_OPERATION_CODE.SetSecurityDescriptor = 0
SECURITY_OPERATION_CODE.QuerySecurityDescriptor = 1
SECURITY_OPERATION_CODE.DeleteSecurityDescriptor = 2
SECURITY_OPERATION_CODE.AssignSecurityDescriptor = 3


D3DKMDT_TEXT_RENDERING_FORMAT = v_enum()
D3DKMDT_TEXT_RENDERING_FORMAT.D3DKMDT_TRF_UNINITIALIZED = 0


RTL_GENERIC_COMPARE_RESULTS = v_enum()
RTL_GENERIC_COMPARE_RESULTS.GenericLessThan = 0
RTL_GENERIC_COMPARE_RESULTS.GenericGreaterThan = 1
RTL_GENERIC_COMPARE_RESULTS.GenericEqual = 2


SYSTEM_POWER_STATE = v_enum()
SYSTEM_POWER_STATE.PowerSystemUnspecified = 0
SYSTEM_POWER_STATE.PowerSystemWorking = 1
SYSTEM_POWER_STATE.PowerSystemSleeping1 = 2
SYSTEM_POWER_STATE.PowerSystemSleeping2 = 3
SYSTEM_POWER_STATE.PowerSystemSleeping3 = 4
SYSTEM_POWER_STATE.PowerSystemHibernate = 5
SYSTEM_POWER_STATE.PowerSystemShutdown = 6
SYSTEM_POWER_STATE.PowerSystemMaximum = 7


D3DKMDT_VIDPN_SOURCE_MODE_TYPE = v_enum()
D3DKMDT_VIDPN_SOURCE_MODE_TYPE.D3DKMDT_RMT_UNINITIALIZED = 0
D3DKMDT_VIDPN_SOURCE_MODE_TYPE.D3DKMDT_RMT_GRAPHICS = 1
D3DKMDT_VIDPN_SOURCE_MODE_TYPE.D3DKMDT_RMT_TEXT = 2


FILE_INFORMATION_CLASS = v_enum()
FILE_INFORMATION_CLASS.FileDirectoryInformation = 1
FILE_INFORMATION_CLASS.FileFullDirectoryInformation = 2
FILE_INFORMATION_CLASS.FileBothDirectoryInformation = 3
FILE_INFORMATION_CLASS.FileBasicInformation = 4
FILE_INFORMATION_CLASS.FileStandardInformation = 5
FILE_INFORMATION_CLASS.FileInternalInformation = 6
FILE_INFORMATION_CLASS.FileEaInformation = 7
FILE_INFORMATION_CLASS.FileAccessInformation = 8
FILE_INFORMATION_CLASS.FileNameInformation = 9
FILE_INFORMATION_CLASS.FileRenameInformation = 10
FILE_INFORMATION_CLASS.FileLinkInformation = 11
FILE_INFORMATION_CLASS.FileNamesInformation = 12
FILE_INFORMATION_CLASS.FileDispositionInformation = 13
FILE_INFORMATION_CLASS.FilePositionInformation = 14
FILE_INFORMATION_CLASS.FileFullEaInformation = 15
FILE_INFORMATION_CLASS.FileModeInformation = 16
FILE_INFORMATION_CLASS.FileAlignmentInformation = 17
FILE_INFORMATION_CLASS.FileAllInformation = 18
FILE_INFORMATION_CLASS.FileAllocationInformation = 19
FILE_INFORMATION_CLASS.FileEndOfFileInformation = 20
FILE_INFORMATION_CLASS.FileAlternateNameInformation = 21
FILE_INFORMATION_CLASS.FileStreamInformation = 22
FILE_INFORMATION_CLASS.FilePipeInformation = 23
FILE_INFORMATION_CLASS.FilePipeLocalInformation = 24
FILE_INFORMATION_CLASS.FilePipeRemoteInformation = 25
FILE_INFORMATION_CLASS.FileMailslotQueryInformation = 26
FILE_INFORMATION_CLASS.FileMailslotSetInformation = 27
FILE_INFORMATION_CLASS.FileCompressionInformation = 28
FILE_INFORMATION_CLASS.FileObjectIdInformation = 29
FILE_INFORMATION_CLASS.FileCompletionInformation = 30
FILE_INFORMATION_CLASS.FileMoveClusterInformation = 31
FILE_INFORMATION_CLASS.FileQuotaInformation = 32
FILE_INFORMATION_CLASS.FileReparsePointInformation = 33
FILE_INFORMATION_CLASS.FileNetworkOpenInformation = 34
FILE_INFORMATION_CLASS.FileAttributeTagInformation = 35
FILE_INFORMATION_CLASS.FileTrackingInformation = 36
FILE_INFORMATION_CLASS.FileIdBothDirectoryInformation = 37
FILE_INFORMATION_CLASS.FileIdFullDirectoryInformation = 38
FILE_INFORMATION_CLASS.FileValidDataLengthInformation = 39
FILE_INFORMATION_CLASS.FileShortNameInformation = 40
FILE_INFORMATION_CLASS.FileIoCompletionNotificationInformation = 41
FILE_INFORMATION_CLASS.FileIoStatusBlockRangeInformation = 42
FILE_INFORMATION_CLASS.FileIoPriorityHintInformation = 43
FILE_INFORMATION_CLASS.FileSfioReserveInformation = 44
FILE_INFORMATION_CLASS.FileSfioVolumeInformation = 45
FILE_INFORMATION_CLASS.FileHardLinkInformation = 46
FILE_INFORMATION_CLASS.FileProcessIdsUsingFileInformation = 47
FILE_INFORMATION_CLASS.FileNormalizedNameInformation = 48
FILE_INFORMATION_CLASS.FileNetworkPhysicalNameInformation = 49
FILE_INFORMATION_CLASS.FileIdGlobalTxDirectoryInformation = 50
FILE_INFORMATION_CLASS.FileIsRemoteDeviceInformation = 51
FILE_INFORMATION_CLASS.FileAttributeCacheInformation = 52
FILE_INFORMATION_CLASS.FileNumaNodeInformation = 53
FILE_INFORMATION_CLASS.FileStandardLinkInformation = 54
FILE_INFORMATION_CLASS.FileRemoteProtocolInformation = 55
FILE_INFORMATION_CLASS.FileMaximumInformation = 56


EXCEPTION_DISPOSITION = v_enum()
EXCEPTION_DISPOSITION.ExceptionContinueExecution = 0
EXCEPTION_DISPOSITION.ExceptionContinueSearch = 1
EXCEPTION_DISPOSITION.ExceptionNestedException = 2
EXCEPTION_DISPOSITION.ExceptionCollidedUnwind = 3


D3DKMDT_VIDPN_PRESENT_PATH_SCALING = v_enum()
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_UNINITIALIZED = 0
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_IDENTITY = 1
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_CENTERED = 2
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_STRETCHED = 3
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_ASPECTRATIOCENTEREDMAX = 4
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_CUSTOM = 5
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_RESERVED1 = 253
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_UNPINNED = 254
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_NOTSPECIFIED = 255


DEVICE_USAGE_NOTIFICATION_TYPE = v_enum()
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeUndefined = 0
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypePaging = 1
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeHibernation = 2
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeDumpFile = 3


D3DDDI_GAMMARAMP_TYPE = v_enum()
D3DDDI_GAMMARAMP_TYPE.D3DDDI_GAMMARAMP_UNINITIALIZED = 0
D3DDDI_GAMMARAMP_TYPE.D3DDDI_GAMMARAMP_DEFAULT = 1
D3DDDI_GAMMARAMP_TYPE.D3DDDI_GAMMARAMP_RGB256x3x16 = 2
D3DDDI_GAMMARAMP_TYPE.D3DDDI_GAMMARAMP_DXGI_1 = 3


EX_POOL_PRIORITY = v_enum()
EX_POOL_PRIORITY.LowPoolPriority = 0
EX_POOL_PRIORITY.LowPoolPrioritySpecialPoolOverrun = 8
EX_POOL_PRIORITY.LowPoolPrioritySpecialPoolUnderrun = 9
EX_POOL_PRIORITY.NormalPoolPriority = 16
EX_POOL_PRIORITY.NormalPoolPrioritySpecialPoolOverrun = 24
EX_POOL_PRIORITY.NormalPoolPrioritySpecialPoolUnderrun = 25
EX_POOL_PRIORITY.HighPoolPriority = 32
EX_POOL_PRIORITY.HighPoolPrioritySpecialPoolOverrun = 40
EX_POOL_PRIORITY.HighPoolPrioritySpecialPoolUnderrun = 41


WHEA_ERROR_PACKET_DATA_FORMAT = v_enum()
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatIPFSalRecord = 0
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatXPFMCA = 1
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMemory = 2
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIExpress = 3
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatNMIPort = 4
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXBus = 5
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXDevice = 6
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatGeneric = 7
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMax = 8


DISPLAYCONFIG_SCANLINE_ORDERING = v_enum()
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = 2
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = -1


TP_CALLBACK_PRIORITY = v_enum()
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_HIGH = 0
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_NORMAL = 1
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_LOW = 2
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_INVALID = 3


SECURITY_IMPERSONATION_LEVEL = v_enum()
SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous = 0
SECURITY_IMPERSONATION_LEVEL.SecurityIdentification = 1
SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation = 2
SECURITY_IMPERSONATION_LEVEL.SecurityDelegation = 3


D3DKMDT_VIDEO_SIGNAL_STANDARD = v_enum()
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_UNINITIALIZED = 0
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_VESA_DMT = 1
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_VESA_GTF = 2
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_VESA_CVT = 3
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_IBM = 4
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_APPLE = 5
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_NTSC_M = 6
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_NTSC_J = 7
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_NTSC_443 = 8
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_B = 9
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_B1 = 10
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_G = 11
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_H = 12
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_I = 13
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_D = 14
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_N = 15
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_NC = 16
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_B = 17
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_D = 18
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_G = 19
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_H = 20
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_K = 21
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_K1 = 22
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_L = 23
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_L1 = 24
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_EIA_861 = 25
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_EIA_861A = 26
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_EIA_861B = 27
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_K = 28
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_K1 = 29
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_L = 30
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_M = 31
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_OTHER = 255


D3DKMDT_COLOR_BASIS = v_enum()
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_UNINITIALIZED = 0
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_INTENSITY = 1
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_SRGB = 2
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_SCRGB = 3
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_YCBCR = 4
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_YPBPR = 5
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_MAXVALID = 5


DXGK_RECOMMENDFUNCTIONALVIDPN_REASON = v_enum()
DXGK_RECOMMENDFUNCTIONALVIDPN_REASON.DXGK_RFVR_UNINITIALIZED = 0
DXGK_RECOMMENDFUNCTIONALVIDPN_REASON.DXGK_RFVR_HOTKEY = 1
DXGK_RECOMMENDFUNCTIONALVIDPN_REASON.DXGK_RFVR_USERMODE = 2


D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT = v_enum()
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttempt = 0
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptSuccess = 1
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissNoCommand = 2
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissNotEnabled = 3
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissNextFence = 4
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissPagingCommand = 5
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissSplittedCommand = 6
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissFenceCommand = 7
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissRenderPendingFlip = 8
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissNotMakingProgress = 9
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissLessPriority = 10
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissRemainingQuantum = 11
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissRemainingPreemptionQuantum = 12
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissAlreadyPreempting = 13
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissGlobalBlock = 14
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissAlreadyRunning = 15
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptStatisticsMax = 16


INTERFACE_TYPE = v_enum()
INTERFACE_TYPE.InterfaceTypeUndefined = -1
INTERFACE_TYPE.Internal = 0
INTERFACE_TYPE.Isa = 1
INTERFACE_TYPE.Eisa = 2
INTERFACE_TYPE.MicroChannel = 3
INTERFACE_TYPE.TurboChannel = 4
INTERFACE_TYPE.PCIBus = 5
INTERFACE_TYPE.VMEBus = 6
INTERFACE_TYPE.NuBus = 7
INTERFACE_TYPE.PCMCIABus = 8
INTERFACE_TYPE.CBus = 9
INTERFACE_TYPE.MPIBus = 10
INTERFACE_TYPE.MPSABus = 11
INTERFACE_TYPE.ProcessorInternal = 12
INTERFACE_TYPE.InternalPowerBus = 13
INTERFACE_TYPE.PNPISABus = 14
INTERFACE_TYPE.PNPBus = 15
INTERFACE_TYPE.Vmcs = 16
INTERFACE_TYPE.MaximumInterfaceType = 17


ALTERNATIVE_ARCHITECTURE_TYPE = v_enum()
ALTERNATIVE_ARCHITECTURE_TYPE.StandardDesign = 0
ALTERNATIVE_ARCHITECTURE_TYPE.NEC98x86 = 1
ALTERNATIVE_ARCHITECTURE_TYPE.EndAlternatives = 2


D3DKMDT_VIDPN_PRESENT_PATH_ROTATION = v_enum()
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_UNINITIALIZED = 0
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_IDENTITY = 1
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_ROTATE90 = 2
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_ROTATE180 = 3
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_ROTATE270 = 4
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_UNPINNED = 254
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_NOTSPECIFIED = 255


WHEA_ERROR_TYPE = v_enum()
WHEA_ERROR_TYPE.WheaErrTypeProcessor = 0
WHEA_ERROR_TYPE.WheaErrTypeMemory = 1
WHEA_ERROR_TYPE.WheaErrTypePCIExpress = 2
WHEA_ERROR_TYPE.WheaErrTypeNMI = 3
WHEA_ERROR_TYPE.WheaErrTypePCIXBus = 4
WHEA_ERROR_TYPE.WheaErrTypePCIXDevice = 5
WHEA_ERROR_TYPE.WheaErrTypeGeneric = 6


DXGK_DIAG_TYPE = v_enum()
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_NONE = 0
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_SDC = 1
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_HPD = 2
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_DC_ORIGIN = 3
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_USER_CDS = 4
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_DRV_CDS = 5
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_CODE_POINT = 6
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_QDC = 7
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_MONITOR_MGR = 8
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_CONNECTEDSET_NOT_FOUND = 9
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_DISPDIAG_COLLECTED = 10
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_BML_PACKET = 11
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_BML_PACKET_EX = 12
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_COMMIT_VIDPN_FAILED = 13
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_DRIVER_RECOMMEND_VIDPN = 14
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_MAX = 14
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_FORCE_UINT32 = -1


ReplacesCorHdrNumericDefines = v_enum()
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY = 1
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED = 2
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY = 4
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED = 8
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2 = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MINOR = 0
ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB = 1
ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA = 1
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA = 2
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT = 1
ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT = 2
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED = 4
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED = 16
ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE = 32
ReplacesCorHdrNumericDefines.MAX_CLASS_NAME = 1024
ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME = 1024


D3DKMDT_MODE_PREFERENCE = v_enum()
D3DKMDT_MODE_PREFERENCE.D3DKMDT_MP_UNINITIALIZED = 0
D3DKMDT_MODE_PREFERENCE.D3DKMDT_MP_PREFERRED = 1
D3DKMDT_MODE_PREFERENCE.D3DKMDT_MP_NOTPREFERRED = 2
D3DKMDT_MODE_PREFERENCE.D3DKMDT_MP_MAXVALID = 2


eTHRESHOLD_MARGIN_DIRECTION = v_enum()
eTHRESHOLD_MARGIN_DIRECTION.ThresholdMarginTop = 0
eTHRESHOLD_MARGIN_DIRECTION.ThresholdMarginLeft = 1
eTHRESHOLD_MARGIN_DIRECTION.ThresholdMarginRight = 2
eTHRESHOLD_MARGIN_DIRECTION.ThresholdMarginBottom = 3
eTHRESHOLD_MARGIN_DIRECTION.ThresholdMarginMax = 4


MOVERECT_STYLE = v_enum()
MOVERECT_STYLE.MoveRectKeepPositionAtCursor = 0
MOVERECT_STYLE.MoveRectMidTopAtCursor = 1
MOVERECT_STYLE.MoveRectKeepAspectRatioAtCursor = 2
MOVERECT_STYLE.MoveRectSidewiseKeepPositionAtCursor = 3


D3DKMDT_MONITOR_TIMING_TYPE = v_enum()
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_UNINITIALIZED = 0
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_ESTABLISHED = 1
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_STANDARD = 2
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_EXTRASTANDARD = 3
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_DETAILED = 4
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_DEFAULTMONITORPROFILE = 5
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_DRIVER = 6
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_MAXVALID = 6


MEMORY_CACHING_TYPE_ORIG = v_enum()
MEMORY_CACHING_TYPE_ORIG.MmFrameBufferCached = 2


D3DDDIFORMAT = v_enum()
D3DDDIFORMAT.D3DDDIFMT_UNKNOWN = 0
D3DDDIFORMAT.D3DDDIFMT_R8G8B8 = 20
D3DDDIFORMAT.D3DDDIFMT_A8R8G8B8 = 21
D3DDDIFORMAT.D3DDDIFMT_X8R8G8B8 = 22
D3DDDIFORMAT.D3DDDIFMT_R5G6B5 = 23
D3DDDIFORMAT.D3DDDIFMT_X1R5G5B5 = 24
D3DDDIFORMAT.D3DDDIFMT_A1R5G5B5 = 25
D3DDDIFORMAT.D3DDDIFMT_A4R4G4B4 = 26
D3DDDIFORMAT.D3DDDIFMT_R3G3B2 = 27
D3DDDIFORMAT.D3DDDIFMT_A8 = 28
D3DDDIFORMAT.D3DDDIFMT_A8R3G3B2 = 29
D3DDDIFORMAT.D3DDDIFMT_X4R4G4B4 = 30
D3DDDIFORMAT.D3DDDIFMT_A2B10G10R10 = 31
D3DDDIFORMAT.D3DDDIFMT_A8B8G8R8 = 32
D3DDDIFORMAT.D3DDDIFMT_X8B8G8R8 = 33
D3DDDIFORMAT.D3DDDIFMT_G16R16 = 34
D3DDDIFORMAT.D3DDDIFMT_A2R10G10B10 = 35
D3DDDIFORMAT.D3DDDIFMT_A16B16G16R16 = 36
D3DDDIFORMAT.D3DDDIFMT_A8P8 = 40
D3DDDIFORMAT.D3DDDIFMT_P8 = 41
D3DDDIFORMAT.D3DDDIFMT_L8 = 50
D3DDDIFORMAT.D3DDDIFMT_A8L8 = 51
D3DDDIFORMAT.D3DDDIFMT_A4L4 = 52
D3DDDIFORMAT.D3DDDIFMT_V8U8 = 60
D3DDDIFORMAT.D3DDDIFMT_L6V5U5 = 61
D3DDDIFORMAT.D3DDDIFMT_X8L8V8U8 = 62
D3DDDIFORMAT.D3DDDIFMT_Q8W8V8U8 = 63
D3DDDIFORMAT.D3DDDIFMT_V16U16 = 64
D3DDDIFORMAT.D3DDDIFMT_W11V11U10 = 65
D3DDDIFORMAT.D3DDDIFMT_A2W10V10U10 = 67
D3DDDIFORMAT.D3DDDIFMT_UYVY = 1498831189
D3DDDIFORMAT.D3DDDIFMT_R8G8_B8G8 = 1195525970
D3DDDIFORMAT.D3DDDIFMT_YUY2 = 844715353
D3DDDIFORMAT.D3DDDIFMT_G8R8_G8B8 = 1111970375
D3DDDIFORMAT.D3DDDIFMT_DXT1 = 827611204
D3DDDIFORMAT.D3DDDIFMT_DXT2 = 844388420
D3DDDIFORMAT.D3DDDIFMT_DXT3 = 861165636
D3DDDIFORMAT.D3DDDIFMT_DXT4 = 877942852
D3DDDIFORMAT.D3DDDIFMT_DXT5 = 894720068
D3DDDIFORMAT.D3DDDIFMT_D16_LOCKABLE = 70
D3DDDIFORMAT.D3DDDIFMT_D32 = 71
D3DDDIFORMAT.D3DDDIFMT_D15S1 = 73
D3DDDIFORMAT.D3DDDIFMT_D24S8 = 75
D3DDDIFORMAT.D3DDDIFMT_D24X8 = 77
D3DDDIFORMAT.D3DDDIFMT_D24X4S4 = 79
D3DDDIFORMAT.D3DDDIFMT_D16 = 80
D3DDDIFORMAT.D3DDDIFMT_D32F_LOCKABLE = 82
D3DDDIFORMAT.D3DDDIFMT_D24FS8 = 83
D3DDDIFORMAT.D3DDDIFMT_D32_LOCKABLE = 84
D3DDDIFORMAT.D3DDDIFMT_S8_LOCKABLE = 85
D3DDDIFORMAT.D3DDDIFMT_S1D15 = 72
D3DDDIFORMAT.D3DDDIFMT_S8D24 = 74
D3DDDIFORMAT.D3DDDIFMT_X8D24 = 76
D3DDDIFORMAT.D3DDDIFMT_X4S4D24 = 78
D3DDDIFORMAT.D3DDDIFMT_L16 = 81
D3DDDIFORMAT.D3DDDIFMT_VERTEXDATA = 100
D3DDDIFORMAT.D3DDDIFMT_INDEX16 = 101
D3DDDIFORMAT.D3DDDIFMT_INDEX32 = 102
D3DDDIFORMAT.D3DDDIFMT_Q16W16V16U16 = 110
D3DDDIFORMAT.D3DDDIFMT_MULTI2_ARGB8 = 827606349
D3DDDIFORMAT.D3DDDIFMT_R16F = 111
D3DDDIFORMAT.D3DDDIFMT_G16R16F = 112
D3DDDIFORMAT.D3DDDIFMT_A16B16G16R16F = 113
D3DDDIFORMAT.D3DDDIFMT_R32F = 114
D3DDDIFORMAT.D3DDDIFMT_G32R32F = 115
D3DDDIFORMAT.D3DDDIFMT_A32B32G32R32F = 116
D3DDDIFORMAT.D3DDDIFMT_CxV8U8 = 117
D3DDDIFORMAT.D3DDDIFMT_A1 = 118
D3DDDIFORMAT.D3DDDIFMT_A2B10G10R10_XR_BIAS = 119
D3DDDIFORMAT.D3DDDIFMT_DXVACOMPBUFFER_BASE = 150
D3DDDIFORMAT.D3DDDIFMT_PICTUREPARAMSDATA = 150
D3DDDIFORMAT.D3DDDIFMT_MACROBLOCKDATA = 151
D3DDDIFORMAT.D3DDDIFMT_RESIDUALDIFFERENCEDATA = 152
D3DDDIFORMAT.D3DDDIFMT_DEBLOCKINGDATA = 153
D3DDDIFORMAT.D3DDDIFMT_INVERSEQUANTIZATIONDATA = 154
D3DDDIFORMAT.D3DDDIFMT_SLICECONTROLDATA = 155
D3DDDIFORMAT.D3DDDIFMT_BITSTREAMDATA = 156
D3DDDIFORMAT.D3DDDIFMT_MOTIONVECTORBUFFER = 157
D3DDDIFORMAT.D3DDDIFMT_FILMGRAINBUFFER = 158
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED9 = 159
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED10 = 160
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED11 = 161
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED12 = 162
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED13 = 163
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED14 = 164
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED15 = 165
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED16 = 166
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED17 = 167
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED18 = 168
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED19 = 169
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED20 = 170
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED21 = 171
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED22 = 172
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED23 = 173
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED24 = 174
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED25 = 175
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED26 = 176
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED27 = 177
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED28 = 178
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED29 = 179
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED30 = 180
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED31 = 181
D3DDDIFORMAT.D3DDDIFMT_DXVACOMPBUFFER_MAX = 181
D3DDDIFORMAT.D3DDDIFMT_BINARYBUFFER = 199
D3DDDIFORMAT.D3DDDIFMT_FORCE_UINT = 2147483647


POWER_ACTION = v_enum()
POWER_ACTION.PowerActionNone = 0
POWER_ACTION.PowerActionReserved = 1
POWER_ACTION.PowerActionSleep = 2
POWER_ACTION.PowerActionHibernate = 3
POWER_ACTION.PowerActionShutdown = 4
POWER_ACTION.PowerActionShutdownReset = 5
POWER_ACTION.PowerActionShutdownOff = 6
POWER_ACTION.PowerActionWarmEject = 7


D3DKMDT_MONITOR_DESCRIPTOR_TYPE = v_enum()
D3DKMDT_MONITOR_DESCRIPTOR_TYPE.D3DKMDT_MDT_UNINITIALIZED = 0
D3DKMDT_MONITOR_DESCRIPTOR_TYPE.D3DKMDT_MDT_VESA_EDID_V1_BASEBLOCK = 1
D3DKMDT_MONITOR_DESCRIPTOR_TYPE.D3DKMDT_MDT_VESA_EDID_V1_BLOCKMAP = 2
D3DKMDT_MONITOR_DESCRIPTOR_TYPE.D3DKMDT_MDT_OTHER = 255


SM_RANGE_TYPES = v_enum()
SM_RANGE_TYPES.SmRangeSharedInfo = 0
SM_RANGE_TYPES.SmRangeNonSharedInfo = 1
SM_RANGE_TYPES.SmRangeBool = 2


WINDOWCOMPOSITIONATTRIB = v_enum()
WINDOWCOMPOSITIONATTRIB.WCA_UNDEFINED = 0
WINDOWCOMPOSITIONATTRIB.WCA_NCRENDERING_ENABLED = 1
WINDOWCOMPOSITIONATTRIB.WCA_NCRENDERING_POLICY = 2
WINDOWCOMPOSITIONATTRIB.WCA_TRANSITIONS_FORCEDISABLED = 3
WINDOWCOMPOSITIONATTRIB.WCA_ALLOW_NCPAINT = 4
WINDOWCOMPOSITIONATTRIB.WCA_CAPTION_BUTTON_BOUNDS = 5
WINDOWCOMPOSITIONATTRIB.WCA_NONCLIENT_RTL_LAYOUT = 6
WINDOWCOMPOSITIONATTRIB.WCA_FORCE_ICONIC_REPRESENTATION = 7
WINDOWCOMPOSITIONATTRIB.WCA_FLIP3D_POLICY = 8
WINDOWCOMPOSITIONATTRIB.WCA_EXTENDED_FRAME_BOUNDS = 9
WINDOWCOMPOSITIONATTRIB.WCA_HAS_ICONIC_BITMAP = 10
WINDOWCOMPOSITIONATTRIB.WCA_THEME_ATTRIBUTES = 11
WINDOWCOMPOSITIONATTRIB.WCA_NCRENDERING_EXILED = 12
WINDOWCOMPOSITIONATTRIB.WCA_NCADORNMENTINFO = 13
WINDOWCOMPOSITIONATTRIB.WCA_EXCLUDED_FROM_LIVEPREVIEW = 14
WINDOWCOMPOSITIONATTRIB.WCA_VIDEO_OVERLAY_ACTIVE = 15
WINDOWCOMPOSITIONATTRIB.WCA_FORCE_ACTIVEWINDOW_APPEARANCE = 16
WINDOWCOMPOSITIONATTRIB.WCA_DISALLOW_PEEK = 17
WINDOWCOMPOSITIONATTRIB.WCA_LAST = 18


class _unnamed_10519(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceTextType = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.LocaleId = v_uint32()
        self._pad0010 = v_bytes(size=4)


class _unnamed_10514(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdType = v_uint32()


class _unnamed_14487(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Priority = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class _unnamed_14482(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.MinBusNumber = v_uint32()
        self.MaxBusNumber = v_uint32()
        self.Reserved = v_uint32()


class tagTOUCHINPUTINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = THROBJHEAD()
        self.dwcInputs = v_uint32()
        self.uFlags = v_uint32()
        self.TouchInput = vstruct.VArray([ tagTOUCHINPUT() for i in xrange(1) ])


class tagHOOK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = THRDESKHEAD()
        self.phkNext = v_ptr64()
        self.iHook = v_uint32()
        self._pad0038 = v_bytes(size=4)
        self.offPfn = v_uint64()
        self.flags = v_uint32()
        self.ihmod = v_uint32()
        self.ptiHooked = v_ptr64()
        self.rpdesk = v_ptr64()
        self.nTimeout = v_uint32()
        self._pad0060 = v_bytes(size=4)


class VK_TO_WCHAR_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pVkToWchars = v_ptr64()
        self.nModifications = v_uint8()
        self.cbSize = v_uint8()
        self._pad0010 = v_bytes(size=6)


class D3DKMDT_2DREGION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cx = v_uint32()
        self.cy = v_uint32()


class DEADKEY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwBoth = v_uint32()
        self.wchComposed = v_uint16()
        self.uFlags = v_uint16()


class CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DosPath = UNICODE_STRING()
        self.Handle = v_ptr64()


class _unnamed_13900(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = _unnamed_14462()


class tagPROPLIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cEntries = v_uint32()
        self.iFirstFree = v_uint32()
        self.aprop = vstruct.VArray([ tagPROP() for i in xrange(1) ])


class _unnamed_9808(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMiddle = v_uint32()


class _unnamed_9807(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMiddle = v_uint8()
        self.Flags1 = v_uint8()
        self.Flags2 = v_uint8()
        self.BaseHigh = v_uint8()


class tagDESKTOPINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pvDesktopBase = v_ptr64()
        self.pvDesktopLimit = v_ptr64()
        self.spwnd = v_ptr64()
        self.fsHooks = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.aphkStart = vstruct.VArray([ v_ptr64() for i in xrange(16) ])
        self.spwndShell = v_ptr64()
        self.ppiShellProcess = v_ptr64()
        self.spwndBkGnd = v_ptr64()
        self.spwndTaskman = v_ptr64()
        self.spwndProgman = v_ptr64()
        self.pvwplShellHook = v_ptr64()
        self.cntMBox = v_uint32()
        self._pad00d8 = v_bytes(size=4)
        self.spwndGestureEngine = v_ptr64()
        self.pvwplMessagePPHandler = v_ptr64()
        self.fComposited = v_uint32()
        self._pad00f0 = v_bytes(size=4)


class _unnamed_10207(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceQueueEntry = KDEVICE_QUEUE_ENTRY()
        self._pad0020 = v_bytes(size=8)
        self.Thread = v_ptr64()
        self.AuxiliaryBuffer = v_ptr64()
        self.ListEntry = LIST_ENTRY()
        self.CurrentStackLocation = v_ptr64()
        self.OriginalFileObject = v_ptr64()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SectionOffset = v_uint32()
        self.SectionLength = v_uint32()
        self.Revision = WHEA_REVISION()
        self.ValidBits = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS()
        self.Reserved = v_uint8()
        self.Flags = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS()
        self.SectionType = GUID()
        self.FRUId = GUID()
        self.SectionSeverity = v_uint32()
        self.FRUText = vstruct.VArray([ v_uint8() for i in xrange(20) ])


class VK_TO_FUNCTION_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vk = v_uint8()
        self.NLSFEProcType = v_uint8()
        self.NLSFEProcCurrent = v_uint8()
        self.NLSFEProcSwitch = v_uint8()
        self.NLSFEProc = vstruct.VArray([ VK_FUNCTION_PARAM() for i in xrange(8) ])
        self.NLSFEProcAlt = vstruct.VArray([ VK_FUNCTION_PARAM() for i in xrange(8) ])


class tagTHREADINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pEThread = v_ptr64()
        self.RefCount = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.ptlW32 = v_ptr64()
        self.pgdiDcattr = v_ptr64()
        self.pgdiBrushAttr = v_ptr64()
        self.pUMPDObjs = v_ptr64()
        self.pUMPDHeap = v_ptr64()
        self.pUMPDObj = v_ptr64()
        self.pProxyPort = v_ptr64()
        self.pClientID = v_ptr64()
        self.GdiTmpTgoList = LIST_ENTRY()
        self.pRBRecursionCount = v_uint32()
        self.pNonRBRecursionCount = v_uint32()
        self.tlSpriteState = TLSPRITESTATE()
        self.pSpriteState = v_ptr64()
        self.pDevHTInfo = v_ptr64()
        self.ulDevHTInfoUniqueness = v_uint32()
        self._pad0128 = v_bytes(size=4)
        self.pdcoAA = v_ptr64()
        self.pdcoRender = v_ptr64()
        self.pdcoSrc = v_ptr64()
        self.bEnableEngUpdateDeviceSurface = v_uint8()
        self.bIncludeSprites = v_uint8()
        self._pad0144 = v_bytes(size=2)
        self.ulWindowSystemRendering = v_uint32()
        self.iVisRgnUniqueness = v_uint32()
        self._pad0150 = v_bytes(size=4)
        self.ptl = v_ptr64()
        self.ppi = v_ptr64()
        self.pq = v_ptr64()
        self.spklActive = v_ptr64()
        self.pcti = v_ptr64()
        self.rpdesk = v_ptr64()
        self.pDeskInfo = v_ptr64()
        self.ulClientDelta = v_uint64()
        self.pClientInfo = v_ptr64()
        self.TIF_flags = v_uint32()
        self._pad01a0 = v_bytes(size=4)
        self.pstrAppName = v_ptr64()
        self.psmsSent = v_ptr64()
        self.psmsCurrent = v_ptr64()
        self.psmsReceiveList = v_ptr64()
        self.timeLast = v_uint32()
        self._pad01c8 = v_bytes(size=4)
        self.idLast = v_uint64()
        self.exitCode = v_uint32()
        self._pad01d8 = v_bytes(size=4)
        self.hdesk = v_ptr64()
        self.cPaintsReady = v_uint32()
        self.cTimersReady = v_uint32()
        self.pMenuState = v_ptr64()
        self.ptdb = v_ptr64()
        self.psiiList = v_ptr64()
        self.dwExpWinVer = v_uint32()
        self.dwCompatFlags = v_uint32()
        self.dwCompatFlags2 = v_uint32()
        self._pad0210 = v_bytes(size=4)
        self.pqAttach = v_ptr64()
        self.ptiSibling = v_ptr64()
        self.pmsd = v_ptr64()
        self.fsHooks = v_uint32()
        self._pad0230 = v_bytes(size=4)
        self.sphkCurrent = v_ptr64()
        self.lParamHkCurrent = v_uint64()
        self.wParamHkCurrent = v_uint64()
        self.pSBTrack = v_ptr64()
        self.hEventQueueClient = v_ptr64()
        self.pEventQueueServer = v_ptr64()
        self.PtiLink = LIST_ENTRY()
        self.iCursorLevel = v_uint32()
        self.ptLast = tagPOINT()
        self.ptLastReal = tagPOINT()
        self._pad0288 = v_bytes(size=4)
        self.spwndDefaultIme = v_ptr64()
        self.spDefaultImc = v_ptr64()
        self.hklPrev = v_ptr64()
        self.cEnterCount = v_uint32()
        self._pad02a8 = v_bytes(size=4)
        self.mlPost = tagMLIST()
        self.fsChangeBitsRemoved = v_uint16()
        self.wchInjected = v_uint16()
        self.fsReserveKeys = v_uint32()
        self.apEvent = v_ptr64()
        self.amdesk = v_uint32()
        self.cWindows = v_uint32()
        self.cVisWindows = v_uint32()
        self._pad02e0 = v_bytes(size=4)
        self.aphkStart = vstruct.VArray([ v_ptr64() for i in xrange(16) ])
        self.cti = tagCLIENTTHREADINFO()
        self.hPrevHidData = v_ptr64()
        self.hTouchInputCurrent = v_ptr64()
        self.hGestureInfoCurrent = v_ptr64()
        self.MsgPPInfo = tagMSGPPINFO()
        self.cNestedStableVisRgn = v_uint32()
        self.readyHead = LIST_ENTRY()
        self.fSpecialInitialization = v_uint32()
        self._pad03a8 = v_bytes(size=4)


class D3DKMDT_VIDEO_SIGNAL_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VideoStandard = v_uint32()
        self.TotalSize = D3DKMDT_2DREGION()
        self.ActiveSize = D3DKMDT_2DREGION()
        self.VSyncFreq = D3DDDI_RATIONAL()
        self.HSyncFreq = D3DDDI_RATIONAL()
        self._pad0028 = v_bytes(size=4)
        self.PixelRate = v_uint64()
        self.ScanLineOrdering = v_uint32()
        self._pad0038 = v_bytes(size=4)


class CM_PARTIAL_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.PartialDescriptors = vstruct.VArray([ CM_PARTIAL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class HGESTUREINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class DEVICE_CAPABILITIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.DeviceD1 = v_uint32()
        self.Address = v_uint32()
        self.UINumber = v_uint32()
        self.DeviceState = vstruct.VArray([ DEVICE_POWER_STATE() for i in xrange(7) ])
        self.SystemWake = v_uint32()
        self.DeviceWake = v_uint32()
        self.D1Latency = v_uint32()
        self.D2Latency = v_uint32()
        self.D3Latency = v_uint32()


class tagMONITOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = HEAD()
        self.pMonitorNext = v_ptr64()
        self.dwMONFlags = v_uint32()
        self.rcMonitorReal = tagRECT()
        self.rcWorkReal = tagRECT()
        self._pad0040 = v_bytes(size=4)
        self.hrgnMonitorReal = v_ptr64()
        self.Spare0 = v_uint16()
        self.cWndStack = v_uint16()
        self._pad0050 = v_bytes(size=4)
        self.hDev = v_ptr64()
        self.hDevReal = v_ptr64()
        self.DockTargets = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self._pad0080 = v_bytes(size=4)
        self.Flink = v_ptr64()
        self.Blink = v_ptr64()


class _unnamed_10363(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FileInformationClass = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.FileObject = v_ptr64()
        self.ReplaceIfExists = v_uint8()
        self.AdvanceOnly = v_uint8()
        self._pad0020 = v_bytes(size=6)


class KPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class DEVICE_OBJECT_POWER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class tagTEXTMETRICW(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.tmHeight = v_uint32()
        self.tmAscent = v_uint32()
        self.tmDescent = v_uint32()
        self.tmInternalLeading = v_uint32()
        self.tmExternalLeading = v_uint32()
        self.tmAveCharWidth = v_uint32()
        self.tmMaxCharWidth = v_uint32()
        self.tmWeight = v_uint32()
        self.tmOverhang = v_uint32()
        self.tmDigitizedAspectX = v_uint32()
        self.tmDigitizedAspectY = v_uint32()
        self.tmFirstChar = v_uint16()
        self.tmLastChar = v_uint16()
        self.tmDefaultChar = v_uint16()
        self.tmBreakChar = v_uint16()
        self.tmItalic = v_uint8()
        self.tmUnderlined = v_uint8()
        self.tmStruckOut = v_uint8()
        self.tmPitchAndFamily = v_uint8()
        self.tmCharSet = v_uint8()
        self._pad003c = v_bytes(size=3)


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Primary = v_uint32()


class TP_CALLBACK_ENVIRON_V3(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Pool = v_ptr64()
        self.CleanupGroup = v_ptr64()
        self.CleanupGroupCancelCallback = v_ptr64()
        self.RaceDll = v_ptr64()
        self.ActivationContext = v_ptr64()
        self.FinalizationCallback = v_ptr64()
        self.u = _unnamed_9312()
        self.CallbackPriority = v_uint32()
        self.Size = v_uint32()
        self._pad0048 = v_bytes(size=4)


class HDESK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class RTL_ACTIVATION_CONTEXT_STACK_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Previous = v_ptr64()
        self.ActivationContext = v_ptr64()
        self.Flags = v_uint32()
        self._pad0018 = v_bytes(size=4)


class OBJECT_HANDLE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleAttributes = v_uint32()
        self.GrantedAccess = v_uint32()


class DMA_OPERATIONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.PutDmaAdapter = v_ptr64()
        self.AllocateCommonBuffer = v_ptr64()
        self.FreeCommonBuffer = v_ptr64()
        self.AllocateAdapterChannel = v_ptr64()
        self.FlushAdapterBuffers = v_ptr64()
        self.FreeAdapterChannel = v_ptr64()
        self.FreeMapRegisters = v_ptr64()
        self.MapTransfer = v_ptr64()
        self.GetDmaAlignment = v_ptr64()
        self.ReadDmaCounter = v_ptr64()
        self.GetScatterGatherList = v_ptr64()
        self.PutScatterGatherList = v_ptr64()
        self.CalculateScatterGatherList = v_ptr64()
        self.BuildScatterGatherList = v_ptr64()
        self.BuildMdlFromScatterGatherList = v_ptr64()


class XSTATE_CONFIGURATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnabledFeatures = v_uint64()
        self.Size = v_uint32()
        self.OptimizedSave = v_uint32()
        self.Features = vstruct.VArray([ XSTATE_FEATURE() for i in xrange(64) ])


class _unnamed_10357(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.CompletionFilter = v_uint32()
        self._pad0010 = v_bytes(size=4)


class RTL_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = RTL_BALANCED_LINKS()
        self.OrderedPointer = v_ptr64()
        self.WhichOrderedElement = v_uint32()
        self.NumberGenericTableElements = v_uint32()
        self.DepthOfTree = v_uint32()
        self._pad0038 = v_bytes(size=4)
        self.RestartKey = v_ptr64()
        self.DeleteCount = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.CompareRoutine = v_ptr64()
        self.AllocateRoutine = v_ptr64()
        self.FreeRoutine = v_ptr64()
        self.TableContext = v_ptr64()


class tagHID_TLC_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.link = LIST_ENTRY()
        self.usUsagePage = v_uint16()
        self.usUsage = v_uint16()
        self.cDevices = v_uint32()
        self.cDirectRequest = v_uint32()
        self.cUsagePageRequest = v_uint32()
        self.cExcludeRequest = v_uint32()
        self.cExcludeOrphaned = v_uint32()


class WHEA_ERROR_PACKET_V2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Version = v_uint32()
        self.Length = v_uint32()
        self.Flags = WHEA_ERROR_PACKET_FLAGS()
        self.ErrorType = v_uint32()
        self.ErrorSeverity = v_uint32()
        self.ErrorSourceId = v_uint32()
        self.ErrorSourceType = v_uint32()
        self.NotifyType = GUID()
        self.Context = v_uint64()
        self.DataFormat = v_uint32()
        self.Reserved1 = v_uint32()
        self.DataOffset = v_uint32()
        self.DataLength = v_uint32()
        self.PshedDataOffset = v_uint32()
        self.PshedDataLength = v_uint32()


class DXGK_DIAG_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.Size = v_uint32()
        self.LogTimestamp = v_uint64()
        self.ProcessName = vstruct.VArray([ v_uint8() for i in xrange(16) ])
        self.ThreadId = v_uint64()
        self.Index = v_uint32()
        self.WdLogIdx = v_uint32()


class DMM_VIDPNPATHANDTARGETMODESET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PathInfo = D3DKMDT_VIDPN_PRESENT_PATH()
        self.TargetModeSet = DMM_VIDPNTARGETMODESET_SERIALIZATION()


class VK_TO_WCHARS1(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualKey = v_uint8()
        self.Attributes = v_uint8()
        self.wch = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class OWNER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerThread = v_uint64()
        self.IoPriorityBoosted = v_uint32()
        self._pad0010 = v_bytes(size=4)


class DEVOBJ_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DeviceObject = v_ptr64()
        self.PowerFlags = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Dope = v_ptr64()
        self.ExtensionFlags = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.DeviceNode = v_ptr64()
        self.AttachedTo = v_ptr64()
        self.StartIoCount = v_uint32()
        self.StartIoKey = v_uint32()
        self.StartIoFlags = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.Vpb = v_ptr64()
        self.DependentList = LIST_ENTRY()
        self.ProviderList = LIST_ENTRY()


class D3DKMDT_MONITOR_FREQUENCY_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Origin = v_uint32()
        self.RangeLimits = D3DKMDT_FREQUENCY_RANGE()
        self.ConstraintType = v_uint32()
        self.Constraint = _unnamed_11215()


class tagQ(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.mlInput = tagMLIST()
        self.ptiSysLock = v_ptr64()
        self.idSysLock = v_uint64()
        self.idSysPeek = v_uint64()
        self.ptiMouse = v_ptr64()
        self.ptiKeyboard = v_ptr64()
        self.spwndCapture = v_ptr64()
        self.spwndFocus = v_ptr64()
        self.spwndActive = v_ptr64()
        self.spwndActivePrev = v_ptr64()
        self.codeCapture = v_uint32()
        self.msgDblClk = v_uint32()
        self.xbtnDblClk = v_uint16()
        self._pad006c = v_bytes(size=2)
        self.timeDblClk = v_uint32()
        self.hwndDblClk = v_ptr64()
        self.ptDblClk = tagPOINT()
        self.ptMouseMove = tagPOINT()
        self.afKeyRecentDown = vstruct.VArray([ v_uint8() for i in xrange(32) ])
        self.afKeyState = vstruct.VArray([ v_uint8() for i in xrange(64) ])
        self.caret = tagCARET()
        self.spcurCurrent = v_ptr64()
        self.iCursorLevel = v_uint32()
        self.QF_flags = v_uint32()
        self.cThreads = v_uint16()
        self.cLockCount = v_uint16()
        self.msgJournal = v_uint32()
        self.ExtraInfo = v_uint64()
        self.ulEtwReserved1 = v_uint32()
        self._pad0158 = v_bytes(size=4)


class _unnamed_10148(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self._pad0048 = v_bytes(size=56)


class CALLPROCDATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = PROCDESKHEAD()
        self.spcpdNext = v_ptr64()
        self.pfnClientPrevious = v_uint64()
        self.wType = v_uint16()
        self._pad0040 = v_bytes(size=6)


class WM_VALUES_STRINGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pszName = v_ptr64()
        self.fInternal = v_uint8()
        self.fDefined = v_uint8()
        self._pad0010 = v_bytes(size=6)


class MAILSLOT_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MailslotQuota = v_uint32()
        self.MaximumMessageSize = v_uint32()
        self.ReadTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0018 = v_bytes(size=7)


class HIMC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class _unnamed_10417(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vpb = v_ptr64()
        self.DeviceObject = v_ptr64()


class ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OperationID = LUID()
        self.SecurityEvaluated = v_uint8()
        self.GenerateAudit = v_uint8()
        self.GenerateOnClose = v_uint8()
        self.PrivilegesAllocated = v_uint8()
        self.Flags = v_uint32()
        self.RemainingDesiredAccess = v_uint32()
        self.PreviouslyGrantedAccess = v_uint32()
        self.OriginalDesiredAccess = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.SubjectSecurityContext = SECURITY_SUBJECT_CONTEXT()
        self.SecurityDescriptor = v_ptr64()
        self.AuxData = v_ptr64()
        self.Privileges = _unnamed_10796()
        self.AuditPrivileges = v_uint8()
        self._pad0080 = v_bytes(size=3)
        self.ObjectName = UNICODE_STRING()
        self.ObjectTypeName = UNICODE_STRING()


class FILE_STANDARD_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.NumberOfLinks = v_uint32()
        self.DeletePending = v_uint8()
        self.Directory = v_uint8()
        self._pad0018 = v_bytes(size=2)


class _unnamed_9985(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint64()
        self.HeaderType = v_uint64()


class _unnamed_9984(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint64()
        self.HeaderType = v_uint64()


class _unnamed_9983(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint64()
        self.HeaderType = v_uint64()


class tagRECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.left = v_uint32()
        self.top = v_uint32()
        self.right = v_uint32()
        self.bottom = v_uint32()


class GDI_TEB_BATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.HDC = v_uint64()
        self.Buffer = vstruct.VArray([ v_uint32() for i in xrange(310) ])


class ECP_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_13949(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length48 = v_uint32()


class tagMENUSTATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pGlobalPopupMenu = v_ptr64()
        self.fMenuStarted = v_uint32()
        self.ptMouseLast = tagPOINT()
        self.mnFocus = v_uint32()
        self.cmdLast = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.ptiMenuStateOwner = v_ptr64()
        self.dwLockCount = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.pmnsPrev = v_ptr64()
        self.ptButtonDown = tagPOINT()
        self.uButtonDownHitArea = v_uint64()
        self.uButtonDownIndex = v_uint32()
        self.vkButtonDown = v_uint32()
        self.uDraggingHitArea = v_uint64()
        self.uDraggingIndex = v_uint32()
        self.uDraggingFlags = v_uint32()
        self.hdcWndAni = v_ptr64()
        self.dwAniStartTime = v_uint32()
        self.ixAni = v_uint32()
        self.iyAni = v_uint32()
        self.cxAni = v_uint32()
        self.cyAni = v_uint32()
        self._pad0080 = v_bytes(size=4)
        self.hbmAni = v_ptr64()
        self.hdcAni = v_ptr64()


class SECTION_OBJECT_POINTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSectionObject = v_ptr64()
        self.SharedCacheMap = v_ptr64()
        self.ImageSectionObject = v_ptr64()


class MDL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Size = v_uint16()
        self.MdlFlags = v_uint16()
        self._pad0010 = v_bytes(size=4)
        self.Process = v_ptr64()
        self.MappedSystemVa = v_ptr64()
        self.StartVa = v_ptr64()
        self.ByteCount = v_uint32()
        self.ByteOffset = v_uint32()


class tagMSGPPINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwIndexMsgPP = v_uint32()


class _unnamed_13942(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class VWPLELEMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataOrTag = v_uint64()
        self.pwnd = v_ptr64()


class _unnamed_13946(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length40 = v_uint32()


class IO_TIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class VSC_VK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vsc = v_uint8()
        self._pad0002 = v_bytes(size=1)
        self.Vk = v_uint16()


class WHEA_REVISION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinorRevision = v_uint8()
        self.MajorRevision = v_uint8()


class MAGNIFICATION_INPUT_TRANSFORM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.rcSource = tagRECT()
        self.rcScreen = tagRECT()
        self.ptiMagThreadInfo = v_ptr64()
        self.magFactorX = v_uint32()
        self.magFactorY = v_uint32()


class TP_CLEANUP_GROUP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class DMM_VIDPNPATHANDTARGETMODE_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PathInfo = D3DKMDT_VIDPN_PRESENT_PATH()
        self.TargetMode = D3DKMDT_VIDPN_TARGET_MODE()


class _unnamed_10483(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Capabilities = v_ptr64()


class D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_SUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NoProtection = v_uint32()


class D3DDDI_DXGI_RGB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Red = v_uint32()
        self.Green = v_uint32()
        self.Blue = v_uint32()


class OBJECT_TYPE_INITIALIZER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.ObjectTypeFlags = v_uint8()
        self._pad0004 = v_bytes(size=1)
        self.ObjectTypeCode = v_uint32()
        self.InvalidAttributes = v_uint32()
        self.GenericMapping = GENERIC_MAPPING()
        self.ValidAccessMask = v_uint32()
        self.RetainAccess = v_uint32()
        self.PoolType = v_uint32()
        self.DefaultPagedPoolCharge = v_uint32()
        self.DefaultNonPagedPoolCharge = v_uint32()
        self.DumpProcedure = v_ptr64()
        self.OpenProcedure = v_ptr64()
        self.CloseProcedure = v_ptr64()
        self.DeleteProcedure = v_ptr64()
        self.ParseProcedure = v_ptr64()
        self.SecurityProcedure = v_ptr64()
        self.QueryNameProcedure = v_ptr64()
        self.OkayToCloseProcedure = v_ptr64()


class MOVESIZEDATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.spwnd = v_ptr64()
        self.rcDrag = tagRECT()
        self.rcDragCursor = tagRECT()
        self.rcPreview = tagRECT()
        self.rcPreviewCursor = tagRECT()
        self.rcParent = tagRECT()
        self.ptMinTrack = tagPOINT()
        self.ptMaxTrack = tagPOINT()
        self.rcWindow = tagRECT()
        self.rcNormalStartCheckPt = tagRECT()
        self.dxMouse = v_uint32()
        self.dyMouse = v_uint32()
        self.cmd = v_uint32()
        self.impx = v_uint32()
        self.impy = v_uint32()
        self.ptRestore = tagPOINT()
        self.Flags = v_uint32()
        self.pStartMonitorCurrentHitTarget = v_ptr64()
        self.StartCurrentHitTarget = v_uint32()
        self._pad00b8 = v_bytes(size=4)
        self.pMonitorCurrentHitTarget = v_ptr64()
        self.CurrentHitTarget = v_uint32()
        self.MoveRectStyle = v_uint32()
        self.ptHitWindowRelative = tagPOINT()
        self.ptStartHitWindowRelative = tagPOINT()
        self.ptLastTrack = tagPOINT()
        self.ulCountDragOutOfTopTarget = v_uint32()
        self.ulCountDragOutOfLeftRightTarget = v_uint32()
        self.ulCountSizeOutOfTopBottomTarget = v_uint32()
        self._pad00f0 = v_bytes(size=4)


class TP_DIRECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callback = v_ptr64()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()
        self._pad0010 = v_bytes(size=3)


class LARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class _unnamed_13938(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint32()
        self.Length = v_uint32()
        self.Reserved = v_uint32()


class _unnamed_13936(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(3) ])


class _unnamed_13932(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Channel = v_uint32()
        self.Port = v_uint32()
        self.Reserved1 = v_uint32()


class tagQMSG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pqmsgNext = v_ptr64()
        self.pqmsgPrev = v_ptr64()
        self.msg = tagMSG()
        self.ExtraInfo = v_uint64()
        self.ptMouseReal = tagPOINT()
        self.dwQEvent = v_uint32()
        self.Wow64Message = v_uint32()
        self.pti = v_ptr64()
        self.MsgPPInfo = tagMSGPPINFO()
        self._pad0068 = v_bytes(size=4)


class PAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()


class RTL_BITMAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfBitMap = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_ptr64()


class TLSPRITESTATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.bInsideDriverCall = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.flOriginalSurfFlags = v_uint32()
        self.iOriginalType = v_uint32()
        self.flSpriteSurfFlags = v_uint32()
        self.iSpriteType = v_uint32()
        self.flags = v_uint32()
        self.iType = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.pState = v_ptr64()
        self.pfnStrokeAndFillPath = v_ptr64()
        self.pfnStrokePath = v_ptr64()
        self.pfnFillPath = v_ptr64()
        self.pfnPaint = v_ptr64()
        self.pfnBitBlt = v_ptr64()
        self.pfnCopyBits = v_ptr64()
        self.pfnStretchBlt = v_ptr64()
        self.pfnTextOut = v_ptr64()
        self.pfnLineTo = v_ptr64()
        self.pfnTransparentBlt = v_ptr64()
        self.pfnAlphaBlend = v_ptr64()
        self.pfnPlgBlt = v_ptr64()
        self.pfnGradientFill = v_ptr64()
        self.pfnSaveScreenBits = v_ptr64()
        self.pfnStretchBltROP = v_ptr64()
        self.pfnDrawStream = v_ptr64()


class HICON(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class NPAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()


class tagWin32PoolHead(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.size = v_uint64()
        self.pPrev = v_ptr64()
        self.pNext = v_ptr64()
        self.pTrace = v_ptr64()


class VPB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.Flags = v_uint16()
        self.VolumeLabelLength = v_uint16()
        self.DeviceObject = v_ptr64()
        self.RealDevice = v_ptr64()
        self.SerialNumber = v_uint32()
        self.ReferenceCount = v_uint32()
        self.VolumeLabel = vstruct.VArray([ v_uint16() for i in xrange(32) ])


class tagTOUCHINPUT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.x = v_uint32()
        self.y = v_uint32()
        self.hSource = v_ptr64()
        self.dwID = v_uint32()
        self.dwFlags = v_uint32()
        self.dwMask = v_uint32()
        self.dwTime = v_uint32()
        self.dwExtraInfo = v_uint64()
        self.cxContact = v_uint32()
        self.cyContact = v_uint32()


class HEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.h = v_ptr64()
        self.cLockObj = v_uint32()
        self._pad0010 = v_bytes(size=4)


class OBJECT_NAME_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = UNICODE_STRING()


class IO_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.Descriptors = vstruct.VArray([ IO_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class KUSER_SHARED_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TickCountLowDeprecated = v_uint32()
        self.TickCountMultiplier = v_uint32()
        self.InterruptTime = KSYSTEM_TIME()
        self.SystemTime = KSYSTEM_TIME()
        self.TimeZoneBias = KSYSTEM_TIME()
        self.ImageNumberLow = v_uint16()
        self.ImageNumberHigh = v_uint16()
        self.NtSystemRoot = vstruct.VArray([ v_uint16() for i in xrange(260) ])
        self.MaxStackTraceDepth = v_uint32()
        self.CryptoExponent = v_uint32()
        self.TimeZoneId = v_uint32()
        self.LargePageMinimum = v_uint32()
        self.Reserved2 = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self.NtProductType = v_uint32()
        self.ProductTypeIsValid = v_uint8()
        self._pad026c = v_bytes(size=3)
        self.NtMajorVersion = v_uint32()
        self.NtMinorVersion = v_uint32()
        self.ProcessorFeatures = vstruct.VArray([ v_uint8() for i in xrange(64) ])
        self.Reserved1 = v_uint32()
        self.Reserved3 = v_uint32()
        self.TimeSlip = v_uint32()
        self.AlternativeArchitecture = v_uint32()
        self.AltArchitecturePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.SystemExpirationDate = LARGE_INTEGER()
        self.SuiteMask = v_uint32()
        self.KdDebuggerEnabled = v_uint8()
        self.NXSupportPolicy = v_uint8()
        self._pad02d8 = v_bytes(size=2)
        self.ActiveConsoleId = v_uint32()
        self.DismountCount = v_uint32()
        self.ComPlusPackage = v_uint32()
        self.LastSystemRITEventTickCount = v_uint32()
        self.NumberOfPhysicalPages = v_uint32()
        self.SafeBootMode = v_uint8()
        self.TscQpcData = v_uint8()
        self.TscQpcPad = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.SharedDataFlags = v_uint32()
        self.DataFlagsPad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.TestRetInstruction = v_uint64()
        self.SystemCall = v_uint32()
        self.SystemCallReturn = v_uint32()
        self.SystemCallPad = vstruct.VArray([ v_uint64() for i in xrange(3) ])
        self.TickCount = KSYSTEM_TIME()
        self.TickCountPad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.Cookie = v_uint32()
        self.CookiePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.ConsoleSessionForegroundProcessId = v_uint64()
        self.Wow64SharedInformation = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.UserModeGlobalLogger = vstruct.VArray([ v_uint16() for i in xrange(16) ])
        self.ImageFileExecutionOptions = v_uint32()
        self.LangGenerationCount = v_uint32()
        self.Reserved5 = v_uint64()
        self.InterruptTimeBias = v_uint64()
        self.TscQpcBias = v_uint64()
        self.ActiveProcessorCount = v_uint32()
        self.ActiveGroupCount = v_uint16()
        self.Reserved4 = v_uint16()
        self.AitSamplingValue = v_uint32()
        self.AppCompatFlag = v_uint32()
        self.SystemDllNativeRelocation = v_uint64()
        self.SystemDllWowRelocation = v_uint32()
        self.XStatePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.XState = XSTATE_CONFIGURATION()


class SYSTEM_POWER_STATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved1 = v_uint32()


class IO_STATUS_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Information = v_uint64()


class PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(1) ])


class CM_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.List = vstruct.VArray([ CM_FULL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class DMM_MONITOR_SOURCE_MODE_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Info = D3DKMDT_MONITOR_SOURCE_MODE()
        self.TimingType = v_uint32()
        self._pad0068 = v_bytes(size=4)


class EPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class tagPROFILEVALUEINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwValue = v_uint32()
        self.uSection = v_uint32()
        self.pwszKeyName = v_ptr64()


class tagDISPLAYINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.hDev = v_ptr64()
        self.pmdev = v_ptr64()
        self.hDevInfo = v_ptr64()
        self.hdcScreen = v_ptr64()
        self.hdcBits = v_ptr64()
        self.hdcGray = v_ptr64()
        self.hbmGray = v_ptr64()
        self.cxGray = v_uint32()
        self.cyGray = v_uint32()
        self.pdceFirst = v_ptr64()
        self.pspbFirst = v_ptr64()
        self.cMonitors = v_uint32()
        self._pad0058 = v_bytes(size=4)
        self.pMonitorPrimary = v_ptr64()
        self.pMonitorFirst = v_ptr64()
        self.rcScreenReal = tagRECT()
        self.hrgnScreenReal = v_ptr64()
        self.dmLogPixels = v_uint16()
        self.BitCountMax = v_uint16()
        self.fDesktopIsRect = v_uint32()
        self.DockThresholdMax = v_uint32()
        self._pad0090 = v_bytes(size=4)
        self.SpatialListHead = KLIST_ENTRY()
        self.cFullScreen = v_uint16()
        self.Spare0 = v_uint16()
        self._pad00a8 = v_bytes(size=4)


class TP_TASK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callbacks = v_ptr64()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()
        self._pad0010 = v_bytes(size=3)
        self.PostGuard = TP_NBQ_GUARD()
        self.NBQNode = v_ptr64()


class PROCDESKHEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.h = v_ptr64()
        self.cLockObj = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.hTaskWow = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.rpdesk = v_ptr64()
        self.pSelf = v_ptr64()


class PFNCLIENTWORKER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pfnButtonWndProc = v_ptr64()
        self.pfnComboBoxWndProc = v_ptr64()
        self.pfnComboListBoxProc = v_ptr64()
        self.pfnDialogWndProc = v_ptr64()
        self.pfnEditWndProc = v_ptr64()
        self.pfnListBoxWndProc = v_ptr64()
        self.pfnMDIClientWndProc = v_ptr64()
        self.pfnStaticWndProc = v_ptr64()
        self.pfnImeWndProc = v_ptr64()
        self.pfnGhostWndProc = v_ptr64()
        self.pfnCtfHookProc = v_ptr64()


class DMM_COMMITVIDPNREQUESTSET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumCommitVidPnRequests = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.CommitVidPnRequestOffset = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class D3DKMDT_MONITOR_SOURCE_MODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.VideoSignalInfo = D3DKMDT_VIDEO_SIGNAL_INFO()
        self.ColorBasis = v_uint32()
        self.ColorCoeffDynamicRanges = D3DKMDT_COLOR_COEFF_DYNAMIC_RANGES()
        self.Origin = v_uint32()
        self.Preference = v_uint32()
        self._pad0060 = v_bytes(size=4)


class _unnamed_11215(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ActiveSize = D3DKMDT_2DREGION()


class CM_PARTIAL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Flags = v_uint16()
        self.u = _unnamed_13586()


class TP_CALLBACK_INSTANCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class tagSBCALC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.posMin = v_uint32()
        self.posMax = v_uint32()
        self.page = v_uint32()
        self.pos = v_uint32()
        self.pxTop = v_uint32()
        self.pxBottom = v_uint32()
        self.pxLeft = v_uint32()
        self.pxRight = v_uint32()
        self.cpxThumb = v_uint32()
        self.pxUpArrow = v_uint32()
        self.pxDownArrow = v_uint32()
        self.pxStart = v_uint32()
        self.pxThumbBottom = v_uint32()
        self.pxThumbTop = v_uint32()
        self.cpx = v_uint32()
        self.pxMin = v_uint32()


class OBJECT_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.RootDirectory = v_ptr64()
        self.ObjectName = v_ptr64()
        self.Attributes = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.SecurityDescriptor = v_ptr64()
        self.SecurityQualityOfService = v_ptr64()


class CM_FULL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.PartialResourceList = CM_PARTIAL_RESOURCE_LIST()


class FAST_IO_DISPATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFastIoDispatch = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FastIoCheckIfPossible = v_ptr64()
        self.FastIoRead = v_ptr64()
        self.FastIoWrite = v_ptr64()
        self.FastIoQueryBasicInfo = v_ptr64()
        self.FastIoQueryStandardInfo = v_ptr64()
        self.FastIoLock = v_ptr64()
        self.FastIoUnlockSingle = v_ptr64()
        self.FastIoUnlockAll = v_ptr64()
        self.FastIoUnlockAllByKey = v_ptr64()
        self.FastIoDeviceControl = v_ptr64()
        self.AcquireFileForNtCreateSection = v_ptr64()
        self.ReleaseFileForNtCreateSection = v_ptr64()
        self.FastIoDetachDevice = v_ptr64()
        self.FastIoQueryNetworkOpenInfo = v_ptr64()
        self.AcquireForModWrite = v_ptr64()
        self.MdlRead = v_ptr64()
        self.MdlReadComplete = v_ptr64()
        self.PrepareMdlWrite = v_ptr64()
        self.MdlWriteComplete = v_ptr64()
        self.FastIoReadCompressed = v_ptr64()
        self.FastIoWriteCompressed = v_ptr64()
        self.MdlReadCompleteCompressed = v_ptr64()
        self.MdlWriteCompleteCompressed = v_ptr64()
        self.FastIoQueryOpen = v_ptr64()
        self.ReleaseForModWrite = v_ptr64()
        self.AcquireForCcFlush = v_ptr64()
        self.ReleaseForCcFlush = v_ptr64()


class tagPROCESS_HID_REQUEST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.link = LIST_ENTRY()
        self.usUsagePage = v_uint16()
        self.usUsage = v_uint16()
        self.fSinkable = v_uint32()
        self.pTLCInfo = v_ptr64()
        self.spwndTarget = v_ptr64()


class KFLOATING_SAVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Dummy = v_uint32()


class RTL_DYNAMIC_HASH_TABLE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ChainHead = v_ptr64()
        self.PrevLinkage = v_ptr64()
        self.Signature = v_uint64()


class tagSBDATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.posMin = v_uint32()
        self.posMax = v_uint32()
        self.page = v_uint32()
        self.pos = v_uint32()


class D3DDDI_GAMMA_RAMP_RGB256x3x16(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Red = vstruct.VArray([ v_uint16() for i in xrange(256) ])
        self.Green = vstruct.VArray([ v_uint16() for i in xrange(256) ])
        self.Blue = vstruct.VArray([ v_uint16() for i in xrange(256) ])


class tagUAHMENUPOPUPMETRICS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.rgcx = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.fUpdateMaxWidths = v_uint32()


class _unnamed_10527(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InPath = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self._pad0008 = v_bytes(size=4)
        self.Type = v_uint32()
        self._pad0010 = v_bytes(size=4)


class THROBJHEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.h = v_ptr64()
        self.cLockObj = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.pti = v_ptr64()


class DMM_VIDPNTARGETMODESET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumModes = v_uint8()
        self._pad0008 = v_bytes(size=7)
        self.ModeSerialization = vstruct.VArray([ D3DKMDT_VIDPN_TARGET_MODE() for i in xrange(1) ])


class KGDTENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LimitLow = v_uint16()
        self.BaseLow = v_uint16()
        self.Bytes = _unnamed_9807()
        self.BaseUpper = v_uint32()
        self.MustBeZero = v_uint32()


class KSPECIAL_REGISTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cr0 = v_uint64()
        self.Cr2 = v_uint64()
        self.Cr3 = v_uint64()
        self.Cr4 = v_uint64()
        self.KernelDr0 = v_uint64()
        self.KernelDr1 = v_uint64()
        self.KernelDr2 = v_uint64()
        self.KernelDr3 = v_uint64()
        self.KernelDr6 = v_uint64()
        self.KernelDr7 = v_uint64()
        self.Gdtr = KDESCRIPTOR()
        self.Idtr = KDESCRIPTOR()
        self.Tr = v_uint16()
        self.Ldtr = v_uint16()
        self.MxCsr = v_uint32()
        self.DebugControl = v_uint64()
        self.LastBranchToRip = v_uint64()
        self.LastBranchFromRip = v_uint64()
        self.LastExceptionToRip = v_uint64()
        self.LastExceptionFromRip = v_uint64()
        self.Cr8 = v_uint64()
        self.MsrGsBase = v_uint64()
        self.MsrGsSwap = v_uint64()
        self.MsrStar = v_uint64()
        self.MsrLStar = v_uint64()
        self.MsrCStar = v_uint64()
        self.MsrSyscallMask = v_uint64()


class _unnamed_10441(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_ptr64()
        self.Size = v_uint16()
        self.Version = v_uint16()
        self._pad0010 = v_bytes(size=4)
        self.Interface = v_ptr64()
        self.InterfaceSpecificData = v_ptr64()


class TP_NBQ_GUARD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GuardLinks = LIST_ENTRY()
        self.Guards = vstruct.VArray([ v_ptr64() for i in xrange(2) ])


class RTL_CRITICAL_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DebugInfo = v_ptr64()
        self.LockCount = v_uint32()
        self.RecursionCount = v_uint32()
        self.OwningThread = v_ptr64()
        self.LockSemaphore = v_ptr64()
        self.SpinCount = v_uint64()


class KSYSTEM_TIME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.High1Time = v_uint32()
        self.High2Time = v_uint32()


class DMA_ADAPTER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DmaOperations = v_ptr64()


class WNDMSG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.maxMsgs = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.abMsgs = v_ptr64()


class D3DDDI_RATIONAL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Numerator = v_uint32()
        self.Denominator = v_uint32()


class LUID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Luid = LUID()
        self.Attributes = v_uint32()


class IMAGE_NT_HEADERS64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.FileHeader = IMAGE_FILE_HEADER()
        self.OptionalHeader = IMAGE_OPTIONAL_HEADER64()


class tagSBTRACK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.fHitOld = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.spwndTrack = v_ptr64()
        self.spwndSB = v_ptr64()
        self.spwndSBNotify = v_ptr64()
        self.rcTrack = tagRECT()
        self.xxxpfnSB = v_ptr64()
        self.cmdSB = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.hTimerSB = v_uint64()
        self.dpxThumb = v_uint32()
        self.pxOld = v_uint32()
        self.posOld = v_uint32()
        self.posNew = v_uint32()
        self.nBar = v_uint32()
        self._pad0060 = v_bytes(size=4)
        self.pSBCalc = v_ptr64()


class KTHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class HFONT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class tagDPISERVERINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.gclBorder = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.hCaptionFont = v_ptr64()
        self.hMsgFont = v_ptr64()
        self.cxMsgFontChar = v_uint32()
        self.cyMsgFontChar = v_uint32()
        self.wMaxBtnSize = v_uint32()
        self._pad0028 = v_bytes(size=4)


class HDC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P1Home = v_uint64()
        self.P2Home = v_uint64()
        self.P3Home = v_uint64()
        self.P4Home = v_uint64()
        self.P5Home = v_uint64()
        self.P6Home = v_uint64()
        self.ContextFlags = v_uint32()
        self.MxCsr = v_uint32()
        self.SegCs = v_uint16()
        self.SegDs = v_uint16()
        self.SegEs = v_uint16()
        self.SegFs = v_uint16()
        self.SegGs = v_uint16()
        self.SegSs = v_uint16()
        self.EFlags = v_uint32()
        self.Dr0 = v_uint64()
        self.Dr1 = v_uint64()
        self.Dr2 = v_uint64()
        self.Dr3 = v_uint64()
        self.Dr6 = v_uint64()
        self.Dr7 = v_uint64()
        self.Rax = v_uint64()
        self.Rcx = v_uint64()
        self.Rdx = v_uint64()
        self.Rbx = v_uint64()
        self.Rsp = v_uint64()
        self.Rbp = v_uint64()
        self.Rsi = v_uint64()
        self.Rdi = v_uint64()
        self.R8 = v_uint64()
        self.R9 = v_uint64()
        self.R10 = v_uint64()
        self.R11 = v_uint64()
        self.R12 = v_uint64()
        self.R13 = v_uint64()
        self.R14 = v_uint64()
        self.R15 = v_uint64()
        self.Rip = v_uint64()
        self.FltSave = XSAVE_FORMAT()
        self.VectorRegister = vstruct.VArray([ M128A() for i in xrange(26) ])
        self.VectorControl = v_uint64()
        self.DebugControl = v_uint64()
        self.LastBranchToRip = v_uint64()
        self.LastBranchFromRip = v_uint64()
        self.LastExceptionToRip = v_uint64()
        self.LastExceptionFromRip = v_uint64()


class WAIT_CONTEXT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.DeviceRoutine = v_ptr64()
        self.DeviceContext = v_ptr64()
        self.NumberOfMapRegisters = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.DeviceObject = v_ptr64()
        self.CurrentIrp = v_ptr64()
        self.BufferChainingDpc = v_ptr64()


class AUX_ACCESS_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegesUsed = v_ptr64()
        self.GenericMapping = GENERIC_MAPPING()
        self.AccessesToAudit = v_uint32()
        self.MaximumAuditMask = v_uint32()
        self.TransactionId = GUID()
        self.NewSecurityDescriptor = v_ptr64()
        self.ExistingSecurityDescriptor = v_ptr64()
        self.ParentSecurityDescriptor = v_ptr64()
        self.DeRefSecurityDescriptor = v_ptr64()
        self.SDLock = v_ptr64()
        self.AccessReasons = ACCESS_REASONS()


class LIGATURE1(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualKey = v_uint8()
        self._pad0002 = v_bytes(size=1)
        self.ModificationNumber = v_uint16()
        self.wch = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class D3DKMDT_VIDPN_PRESENT_PATH_SCALING_SUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Identity = v_uint32()


class EVENT_DATA_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Ptr = v_uint64()
        self.Size = v_uint32()
        self.Reserved = v_uint32()


class TEB_ACTIVE_FRAME_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FrameName = v_ptr64()


class DRIVER_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DeviceObject = v_ptr64()
        self.Flags = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.DriverStart = v_ptr64()
        self.DriverSize = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.DriverSection = v_ptr64()
        self.DriverExtension = v_ptr64()
        self.DriverName = UNICODE_STRING()
        self.HardwareDatabase = v_ptr64()
        self.FastIoDispatch = v_ptr64()
        self.DriverInit = v_ptr64()
        self.DriverStartIo = v_ptr64()
        self.DriverUnload = v_ptr64()
        self.MajorFunction = vstruct.VArray([ v_ptr64() for i in xrange(28) ])


class HMONITOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class EJOB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class D3DKMDT_GAMMA_RAMP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.DataSize = v_uint64()
        self.Data = _unnamed_13776()


class VK_TO_BIT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vk = v_uint8()
        self.ModBits = v_uint8()


class KPROCESSOR_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SpecialRegisters = KSPECIAL_REGISTERS()
        self._pad00e0 = v_bytes(size=8)
        self.ContextFrame = CONTEXT()


class KAPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.SpareByte0 = v_uint8()
        self.Size = v_uint8()
        self.SpareByte1 = v_uint8()
        self.SpareLong0 = v_uint32()
        self.Thread = v_ptr64()
        self.ApcListEntry = LIST_ENTRY()
        self.KernelRoutine = v_ptr64()
        self.RundownRoutine = v_ptr64()
        self.NormalRoutine = v_ptr64()
        self.NormalContext = v_ptr64()
        self.SystemArgument1 = v_ptr64()
        self.SystemArgument2 = v_ptr64()
        self.ApcStateIndex = v_uint8()
        self.ApcMode = v_uint8()
        self.Inserted = v_uint8()
        self._pad0058 = v_bytes(size=5)


class tagIMEINFOEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.hkl = v_ptr64()
        self.ImeInfo = tagIMEINFO()
        self.wszUIClass = vstruct.VArray([ v_uint16() for i in xrange(16) ])
        self.fdwInitConvMode = v_uint32()
        self.fInitOpen = v_uint32()
        self.fLoadFlag = v_uint32()
        self.dwProdVersion = v_uint32()
        self.dwImeWinVersion = v_uint32()
        self.wszImeDescription = vstruct.VArray([ v_uint16() for i in xrange(50) ])
        self.wszImeFile = vstruct.VArray([ v_uint16() for i in xrange(80) ])
        self.fSysWow64Only = v_uint32()


class D3DKMDT_FREQUENCY_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinVSyncFreq = D3DDDI_RATIONAL()
        self.MaxVSyncFreq = D3DDDI_RATIONAL()
        self.MinHSyncFreq = D3DDDI_RATIONAL()
        self.MaxHSyncFreq = D3DDDI_RATIONAL()


class _unnamed_10432(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()


class tagWND(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = THRDESKHEAD()
        self.state = v_uint32()
        self.state2 = v_uint32()
        self.ExStyle = v_uint32()
        self.style = v_uint32()
        self.hModule = v_ptr64()
        self.hMod16 = v_uint16()
        self.fnid = v_uint16()
        self._pad0048 = v_bytes(size=4)
        self.spwndNext = v_ptr64()
        self.spwndPrev = v_ptr64()
        self.spwndParent = v_ptr64()
        self.spwndChild = v_ptr64()
        self.spwndOwner = v_ptr64()
        self.rcWindow = tagRECT()
        self.rcClient = tagRECT()
        self.lpfnWndProc = v_ptr64()
        self.pcls = v_ptr64()
        self.hrgnUpdate = v_ptr64()
        self.ppropList = v_ptr64()
        self.pSBInfo = v_ptr64()
        self.spmenuSys = v_ptr64()
        self.spmenu = v_ptr64()
        self.hrgnClip = v_ptr64()
        self.hrgnNewFrame = v_ptr64()
        self.strName = LARGE_UNICODE_STRING()
        self.cbwndExtra = v_uint32()
        self._pad00f0 = v_bytes(size=4)
        self.spwndLastActive = v_ptr64()
        self.hImc = v_ptr64()
        self.dwUserData = v_uint64()
        self.pActCtx = v_ptr64()
        self.pTransform = v_ptr64()
        self.spwndClipboardListenerNext = v_ptr64()
        self.ExStyle2 = v_uint32()
        self._pad0128 = v_bytes(size=4)


class _unnamed_14496(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length48 = v_uint32()
        self.Alignment48 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class XSTATE_FEATURE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.Size = v_uint32()


class D3DDDI_GAMMA_RAMP_DXGI_1(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Scale = D3DDDI_DXGI_RGB()
        self.Offset = D3DDDI_DXGI_RGB()
        self.GammaCurve = vstruct.VArray([ D3DDDI_DXGI_RGB() for i in xrange(1025) ])


class WHEA_TIMESTAMP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Seconds = v_uint64()


class ACTIVATION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class tagUAHMENUITEMMETRICS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.rgsizeBar = vstruct.VArray([ tagSIZE() for i in xrange(2) ])
        self._pad0020 = v_bytes(size=16)


class KLIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_ptr64()
        self.Blink = v_ptr64()


class _unnamed_10401(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Length = v_uint32()
        self._pad0010 = v_bytes(size=4)


class _unnamed_10404(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.SecurityDescriptor = v_ptr64()


class RTL_CRITICAL_SECTION_DEBUG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.CriticalSection = v_ptr64()
        self.ProcessLocksList = LIST_ENTRY()
        self.EntryCount = v_uint32()
        self.ContentionCount = v_uint32()
        self.Flags = v_uint32()
        self.CreatorBackTraceIndexHigh = v_uint16()
        self.SpareUSHORT = v_uint16()


class DISPATCHER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.TimerControlFlags = v_uint8()
        self.ThreadControlFlags = v_uint8()
        self.TimerMiscFlags = v_uint8()
        self.SignalState = v_uint32()
        self.WaitListHead = LIST_ENTRY()


class HBITMAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class tagW32JOB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pNext = v_ptr64()
        self.Job = v_ptr64()
        self.pAtomTable = v_ptr64()
        self.restrictions = v_uint32()
        self.uProcessCount = v_uint32()
        self.uMaxProcesses = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.ppiTable = v_ptr64()
        self.ughCrt = v_uint32()
        self.ughMax = v_uint32()
        self.pgh = v_ptr64()


class ASSEMBLY_STORAGE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class tagMBSTRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.szName = vstruct.VArray([ v_uint16() for i in xrange(15) ])
        self._pad0020 = v_bytes(size=2)
        self.uID = v_uint32()
        self.uStr = v_uint32()


class POWER_SEQUENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SequenceD1 = v_uint32()
        self.SequenceD2 = v_uint32()
        self.SequenceD3 = v_uint32()


class DMM_MONITORDESCRIPTOR_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint32()
        self.Type = v_uint32()
        self.Origin = v_uint32()
        self.Data = vstruct.VArray([ v_uint8() for i in xrange(128) ])


class tagCLS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pclsNext = v_ptr64()
        self.atomClassName = v_uint16()
        self.atomNVClassName = v_uint16()
        self.fnid = v_uint16()
        self._pad0010 = v_bytes(size=2)
        self.rpdeskParent = v_ptr64()
        self.pdce = v_ptr64()
        self.hTaskWow = v_uint16()
        self.CSF_flags = v_uint16()
        self._pad0028 = v_bytes(size=4)
        self.lpszClientAnsiMenuName = v_ptr64()
        self.lpszClientUnicodeMenuName = v_ptr64()
        self.spcpdFirst = v_ptr64()
        self.pclsBase = v_ptr64()
        self.pclsClone = v_ptr64()
        self.cWndReferenceCount = v_uint32()
        self.style = v_uint32()
        self.lpfnWndProc = v_ptr64()
        self.cbclsExtra = v_uint32()
        self.cbwndExtra = v_uint32()
        self.hModule = v_ptr64()
        self.spicn = v_ptr64()
        self.spcur = v_ptr64()
        self.hbrBackground = v_ptr64()
        self.lpszMenuName = v_ptr64()
        self.lpszAnsiClassName = v_ptr64()
        self.spicnSm = v_ptr64()


class SM_VALUES_STRINGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pszName = v_ptr64()
        self.ulValue = v_uint32()
        self.RangeType = v_uint32()
        self.StorageType = v_uint32()
        self._pad0018 = v_bytes(size=4)


class HBRUSH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class SECURITY_QUALITY_OF_SERVICE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.ImpersonationLevel = v_uint32()
        self.ContextTrackingMode = v_uint8()
        self.EffectiveOnly = v_uint8()
        self._pad000c = v_bytes(size=2)


class COMPRESSED_DATA_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CompressionFormatAndEngine = v_uint16()
        self.CompressionUnitShift = v_uint8()
        self.ChunkShift = v_uint8()
        self.ClusterShift = v_uint8()
        self.Reserved = v_uint8()
        self.NumberOfChunks = v_uint16()
        self.CompressedChunkSizes = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class WHEA_ERROR_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = WHEA_ERROR_RECORD_HEADER()
        self.SectionDescriptor = vstruct.VArray([ WHEA_ERROR_RECORD_SECTION_DESCRIPTOR() for i in xrange(1) ])


class _unnamed_10572(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemContext = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Type = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.State = POWER_STATE()
        self._pad0018 = v_bytes(size=4)
        self.ShutdownType = v_uint32()
        self._pad0020 = v_bytes(size=4)


class LUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class tagDESKTOP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwSessionId = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.pDeskInfo = v_ptr64()
        self.pDispInfo = v_ptr64()
        self.rpdeskNext = v_ptr64()
        self.rpwinstaParent = v_ptr64()
        self.dwDTFlags = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.dwDesktopId = v_uint64()
        self.spmenuSys = v_ptr64()
        self.spmenuDialogSys = v_ptr64()
        self.spmenuHScroll = v_ptr64()
        self.spmenuVScroll = v_ptr64()
        self.spwndForeground = v_ptr64()
        self.spwndTray = v_ptr64()
        self.spwndMessage = v_ptr64()
        self.spwndTooltip = v_ptr64()
        self.hsectionDesktop = v_ptr64()
        self.pheapDesktop = v_ptr64()
        self.ulHeapSize = v_uint32()
        self._pad0090 = v_bytes(size=4)
        self.cciConsole = CONSOLE_CARET_INFO()
        self.PtiList = LIST_ENTRY()
        self.spwndTrack = v_ptr64()
        self.htEx = v_uint32()
        self.rcMouseHover = tagRECT()
        self.dwMouseHoverTime = v_uint32()
        self.pMagInputTransform = v_ptr64()


class tagPOOLRECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExtraData = v_ptr64()
        self.size = v_uint64()
        self.trace = vstruct.VArray([ v_ptr64() for i in xrange(6) ])


class CLIENT_ID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_ptr64()
        self.UniqueThread = v_ptr64()


class IMAGE_OPTIONAL_HEADER64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint16()
        self.MajorLinkerVersion = v_uint8()
        self.MinorLinkerVersion = v_uint8()
        self.SizeOfCode = v_uint32()
        self.SizeOfInitializedData = v_uint32()
        self.SizeOfUninitializedData = v_uint32()
        self.AddressOfEntryPoint = v_uint32()
        self.BaseOfCode = v_uint32()
        self.ImageBase = v_uint64()
        self.SectionAlignment = v_uint32()
        self.FileAlignment = v_uint32()
        self.MajorOperatingSystemVersion = v_uint16()
        self.MinorOperatingSystemVersion = v_uint16()
        self.MajorImageVersion = v_uint16()
        self.MinorImageVersion = v_uint16()
        self.MajorSubsystemVersion = v_uint16()
        self.MinorSubsystemVersion = v_uint16()
        self.Win32VersionValue = v_uint32()
        self.SizeOfImage = v_uint32()
        self.SizeOfHeaders = v_uint32()
        self.CheckSum = v_uint32()
        self.Subsystem = v_uint16()
        self.DllCharacteristics = v_uint16()
        self.SizeOfStackReserve = v_uint64()
        self.SizeOfStackCommit = v_uint64()
        self.SizeOfHeapReserve = v_uint64()
        self.SizeOfHeapCommit = v_uint64()
        self.LoaderFlags = v_uint32()
        self.NumberOfRvaAndSizes = v_uint32()
        self.DataDirectory = vstruct.VArray([ IMAGE_DATA_DIRECTORY() for i in xrange(16) ])


class OBJECT_DUMP_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Stream = v_ptr64()
        self.Detail = v_uint32()
        self._pad0010 = v_bytes(size=4)


class _unnamed_10089(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsynchronousParameters = _unnamed_10107()


class GENERAL_LOOKASIDE_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr64()
        self.FreeEx = v_ptr64()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])


class tagSPB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pspbNext = v_ptr64()
        self.spwnd = v_ptr64()
        self.hbm = v_ptr64()
        self.rc = tagRECT()
        self.hrgn = v_ptr64()
        self.flags = v_uint32()
        self._pad0038 = v_bytes(size=4)
        self.ulSaveId = v_uint64()


class _unnamed_13929(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Raw = _unnamed_13924()


class _unnamed_13924(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.MessageCount = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint64()


class DMM_VIDPNSET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumVidPns = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.VidPnOffset = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_ptr64()


class TP_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_9282(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class tagPROP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.hData = v_ptr64()
        self.atomKey = v_uint16()
        self.fs = v_uint16()
        self._pad0010 = v_bytes(size=4)


class LIST_ENTRY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint32()
        self.Blink = v_uint32()


class KDESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pad = vstruct.VArray([ v_uint16() for i in xrange(3) ])
        self.Limit = v_uint16()
        self.Base = v_ptr64()


class _unnamed_10583(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedResources = v_ptr64()
        self.AllocatedResourcesTranslated = v_ptr64()


class SINGLE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()


class _unnamed_10587(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProviderId = v_uint64()
        self.DataPath = v_ptr64()
        self.BufferSize = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Buffer = v_ptr64()


class CONTEXT32_UPDATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumberEntries = v_uint32()


class KDEVICE_QUEUE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceListEntry = LIST_ENTRY()
        self.SortKey = v_uint32()
        self.Inserted = v_uint8()
        self._pad0018 = v_bytes(size=3)


class D3DKMDT_VIDPN_SOURCE_MODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint32()
        self.Type = v_uint32()
        self.Format = _unnamed_11143()


class tagCLIENTTHREADINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CTIF_flags = v_uint32()
        self.fsChangeBits = v_uint16()
        self.fsWakeBits = v_uint16()
        self.fsWakeBitsJournal = v_uint16()
        self.fsWakeMask = v_uint16()
        self.tickLastMsgChecked = v_uint32()


class tagKbdNlsLayer(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OEMIdentifier = v_uint16()
        self.LayoutInformation = v_uint16()
        self.NumOfVkToF = v_uint32()
        self.pVkToF = v_ptr64()
        self.NumOfMouseVKey = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.pusMouseVKey = v_ptr64()


class KSPIN_LOCK_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Lock = v_ptr64()


class tagPROCESS_HID_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.link = LIST_ENTRY()
        self.InclusionList = LIST_ENTRY()
        self.UsagePageList = LIST_ENTRY()
        self.ExclusionList = LIST_ENTRY()
        self.spwndTargetMouse = v_ptr64()
        self.spwndTargetKbd = v_ptr64()
        self.nSinks = v_uint32()
        self._pad0058 = v_bytes(size=4)
        self.pLastRequest = v_ptr64()
        self.UsagePageLast = v_uint16()
        self.UsageLast = v_uint16()
        self.fRawMouse = v_uint32()


class WHEA_ERROR_PACKET_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousError = v_uint32()


class _unnamed_10351(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FileName = v_ptr64()
        self.FileInformationClass = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.FileIndex = v_uint32()
        self._pad0020 = v_bytes(size=4)


class WHEA_PERSISTENCE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint64()


class EX_PUSH_LOCK_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locks = vstruct.VArray([ v_ptr64() for i in xrange(1) ])


class tagMLIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pqmsgRead = v_ptr64()
        self.pqmsgWriteLast = v_ptr64()
        self.cMsgs = v_uint32()
        self._pad0018 = v_bytes(size=4)


class _unnamed_10290(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Key = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.ByteOffset = LARGE_INTEGER()


class DMM_MONITORDESCRIPTORSET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumDescriptors = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.DescriptorSerialization = vstruct.VArray([ DMM_MONITORDESCRIPTOR_SERIALIZATION() for i in xrange(1) ])


class tagCLIP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.fmt = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.hData = v_ptr64()
        self.fGlobalHandle = v_uint32()
        self._pad0018 = v_bytes(size=4)


class tagSMS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.psmsNext = v_ptr64()
        self.psmsReceiveNext = v_ptr64()
        self.ptiSender = v_ptr64()
        self.ptiReceiver = v_ptr64()
        self.lpResultCallBack = v_ptr64()
        self.dwData = v_uint64()
        self.ptiCallBackSender = v_ptr64()
        self.lRet = v_uint64()
        self.tSent = v_uint32()
        self.flags = v_uint32()
        self.wParam = v_uint64()
        self.lParam = v_uint64()
        self.message = v_uint32()
        self._pad0060 = v_bytes(size=4)
        self.spwnd = v_ptr64()
        self.pvCapture = v_ptr64()


class SCSI_REQUEST_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ETHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class FAST_MUTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Owner = v_ptr64()
        self.Contention = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Event = KEVENT()
        self.OldIrql = v_uint32()
        self._pad0038 = v_bytes(size=4)


class WHEA_ERROR_RECORD_HEADER_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PlatformId = v_uint32()


class D3DKMDT_VIDPN_PRESENT_PATH_TRANSFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Scaling = v_uint32()
        self.ScalingSupport = D3DKMDT_VIDPN_PRESENT_PATH_SCALING_SUPPORT()
        self.Rotation = v_uint32()
        self.RotationSupport = D3DKMDT_VIDPN_PRESENT_PATH_ROTATION_SUPPORT()


class KDEVICE_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DeviceListHead = LIST_ENTRY()
        self.Lock = v_uint64()
        self.Busy = v_uint8()
        self._pad0028 = v_bytes(size=7)


class CALLBACKWND(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.hwnd = v_ptr64()
        self.pwnd = v_ptr64()
        self.pActCtx = v_ptr64()


class IO_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityQos = v_ptr64()
        self.AccessState = v_ptr64()
        self.DesiredAccess = v_uint32()
        self.FullCreateOptions = v_uint32()


class tagSIZE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cx = v_uint32()
        self.cy = v_uint32()


class tagDESKTOPVIEW(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pdvNext = v_ptr64()
        self.pdesk = v_ptr64()
        self.ulClientDelta = v_uint64()


class PROCMARKHEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.h = v_ptr64()
        self.cLockObj = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.hTaskWow = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.ppi = v_ptr64()


class INITIAL_PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(3) ])


class D3DKMDT_COLOR_COEFF_DYNAMIC_RANGES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FirstChannel = v_uint32()
        self.SecondChannel = v_uint32()
        self.ThirdChannel = v_uint32()
        self.FourthChannel = v_uint32()


class WHEA_ERROR_RECORD_HEADER_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Recovered = v_uint32()


class MODIFIERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pVkToBit = v_ptr64()
        self.wMaxModBits = v_uint16()
        self.ModNumber = vstruct.VArray([ v_uint8() for i in xrange(0) ])
        self._pad0010 = v_bytes(size=6)


class _unnamed_14501(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length64 = v_uint32()
        self.Alignment64 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class PFNCLIENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pfnScrollBarWndProc = v_ptr64()
        self.pfnTitleWndProc = v_ptr64()
        self.pfnMenuWndProc = v_ptr64()
        self.pfnDesktopWndProc = v_ptr64()
        self.pfnDefWindowProc = v_ptr64()
        self.pfnMessageWindowProc = v_ptr64()
        self.pfnSwitchWindowProc = v_ptr64()
        self.pfnButtonWndProc = v_ptr64()
        self.pfnComboBoxWndProc = v_ptr64()
        self.pfnComboListBoxProc = v_ptr64()
        self.pfnDialogWndProc = v_ptr64()
        self.pfnEditWndProc = v_ptr64()
        self.pfnListBoxWndProc = v_ptr64()
        self.pfnMDIClientWndProc = v_ptr64()
        self.pfnStaticWndProc = v_ptr64()
        self.pfnImeWndProc = v_ptr64()
        self.pfnGhostWndProc = v_ptr64()
        self.pfnHkINLPCWPSTRUCT = v_ptr64()
        self.pfnHkINLPCWPRETSTRUCT = v_ptr64()
        self.pfnDispatchHook = v_ptr64()
        self.pfnDispatchDefWindowProc = v_ptr64()
        self.pfnDispatchMessage = v_ptr64()
        self.pfnMDIActivateDlgProc = v_ptr64()


class _unnamed_10539(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerState = v_uint32()


class ACTIVATION_CONTEXT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class FILE_NETWORK_OPEN_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0038 = v_bytes(size=4)


class tagSVR_INSTANCE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = THROBJHEAD()
        self.next = v_ptr64()
        self.nextInThisThread = v_ptr64()
        self.afCmd = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.spwndEvent = v_ptr64()
        self.pcii = v_ptr64()


class _unnamed_14479(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumChannel = v_uint32()
        self.MaximumChannel = v_uint32()


class RTL_DRIVE_LETTER_CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint16()
        self.Length = v_uint16()
        self.TimeStamp = v_uint32()
        self.DosPath = STRING()


class _unnamed_14472(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumVector = v_uint32()
        self.MaximumVector = v_uint32()
        self.AffinityPolicy = v_uint16()
        self.Group = v_uint16()
        self.PriorityPolicy = v_uint32()
        self.TargetedProcessors = v_uint64()


class KIDTENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OffsetLow = v_uint16()
        self.Selector = v_uint16()
        self.IstIndex = v_uint16()
        self.OffsetMiddle = v_uint16()
        self.OffsetHigh = v_uint32()
        self.Reserved1 = v_uint32()


class _unnamed_10386(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.InputBufferLength = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.FsControlCode = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Type3InputBuffer = v_ptr64()


class ULARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class VWPL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cPwnd = v_uint32()
        self.cElem = v_uint32()
        self.cThreshhold = v_uint32()
        self.fTagged = v_uint32()
        self.aElement = vstruct.VArray([ VWPLELEMENT() for i in xrange(0) ])


class _unnamed_10383(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FsInformationClass = v_uint32()
        self._pad0010 = v_bytes(size=4)


class TEB_ACTIVE_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Previous = v_ptr64()
        self.Context = v_ptr64()


class GENERAL_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr64()
        self.FreeEx = v_ptr64()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self._pad0080 = v_bytes(size=32)


class tagCURSOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = PROCMARKHEAD()
        self.pcurNext = v_ptr64()
        self.strName = UNICODE_STRING()
        self.atomModName = v_uint16()
        self.rt = v_uint16()
        self._pad0040 = v_bytes(size=4)
        self.CURSORF_flags = v_uint32()
        self.xHotspot = v_uint16()
        self.yHotspot = v_uint16()
        self.hbmMask = v_ptr64()
        self.hbmColor = v_ptr64()
        self.hbmAlpha = v_ptr64()
        self.rcBounds = tagRECT()
        self.hbmUserAlpha = v_ptr64()
        self.bpp = v_uint32()
        self.cx = v_uint32()
        self.cy = v_uint32()
        self._pad0088 = v_bytes(size=4)


class _unnamed_10545(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerSequence = v_ptr64()


class tagDCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pdceNext = v_ptr64()
        self.hdc = v_ptr64()
        self.pwndOrg = v_ptr64()
        self.pwndClip = v_ptr64()
        self.pwndRedirect = v_ptr64()
        self.hrgnClip = v_ptr64()
        self.hrgnClipPublic = v_ptr64()
        self.hrgnSavedVis = v_ptr64()
        self.DCX_flags = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.ptiOwner = v_ptr64()
        self.ppiOwner = v_ptr64()
        self.pMonitor = v_ptr64()


class VSC_LPWSTR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.vsc = v_uint8()
        self._pad0008 = v_bytes(size=7)
        self.pwsz = v_ptr64()


class NAMED_PIPE_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NamedPipeType = v_uint32()
        self.ReadMode = v_uint32()
        self.CompletionMode = v_uint32()
        self.MaximumInstances = v_uint32()
        self.InboundQuota = v_uint32()
        self.OutboundQuota = v_uint32()
        self.DefaultTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0028 = v_bytes(size=7)


class NT_TIB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_ptr64()
        self.StackBase = v_ptr64()
        self.StackLimit = v_ptr64()
        self.SubSystemTib = v_ptr64()
        self.FiberData = v_ptr64()
        self.ArbitraryUserPointer = v_ptr64()
        self.Self = v_ptr64()


class SCATTER_GATHER_ELEMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = LARGE_INTEGER()
        self.Length = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.Reserved = v_uint64()


class POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemState = v_uint32()


class UNICODE_STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_ptr64()


class DMM_MONITORSOURCEMODESET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumModes = v_uint8()
        self._pad0008 = v_bytes(size=7)
        self.ModeSerialization = vstruct.VArray([ DMM_MONITOR_SOURCE_MODE_SERIALIZATION() for i in xrange(1) ])


class D3DKMDT_VIDPN_TARGET_MODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.VideoSignalInfo = D3DKMDT_VIDEO_SIGNAL_INFO()
        self.Preference = v_uint32()
        self._pad0048 = v_bytes(size=4)


class tagWOWTHREADINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pwtiNext = v_ptr64()
        self.idTask = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.idWaitObject = v_uint64()
        self.idParentProcess = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.pIdleEvent = v_ptr64()
        self.fAssigned = v_uint32()
        self._pad0030 = v_bytes(size=4)


class _unnamed_10092(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Overlay = _unnamed_10207()
        self._pad0058 = v_bytes(size=8)


class ACCESS_REASONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(32) ])


class _unnamed_10271(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr64()
        self.Options = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self._pad0018 = v_bytes(size=4)
        self.Parameters = v_ptr64()


class HANDLEENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.phead = v_ptr64()
        self.pOwner = v_ptr64()
        self.bType = v_uint8()
        self.bFlags = v_uint8()
        self.wUniq = v_uint16()
        self._pad0018 = v_bytes(size=4)


class W32THREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pEThread = v_ptr64()
        self.RefCount = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.ptlW32 = v_ptr64()
        self.pgdiDcattr = v_ptr64()
        self.pgdiBrushAttr = v_ptr64()
        self.pUMPDObjs = v_ptr64()
        self.pUMPDHeap = v_ptr64()
        self.pUMPDObj = v_ptr64()
        self.pProxyPort = v_ptr64()
        self.pClientID = v_ptr64()
        self.GdiTmpTgoList = LIST_ENTRY()
        self.pRBRecursionCount = v_uint32()
        self.pNonRBRecursionCount = v_uint32()
        self.tlSpriteState = TLSPRITESTATE()
        self.pSpriteState = v_ptr64()
        self.pDevHTInfo = v_ptr64()
        self.ulDevHTInfoUniqueness = v_uint32()
        self._pad0128 = v_bytes(size=4)
        self.pdcoAA = v_ptr64()
        self.pdcoRender = v_ptr64()
        self.pdcoSrc = v_ptr64()
        self.bEnableEngUpdateDeviceSurface = v_uint8()
        self.bIncludeSprites = v_uint8()
        self._pad0144 = v_bytes(size=2)
        self.ulWindowSystemRendering = v_uint32()
        self.iVisRgnUniqueness = v_uint32()
        self._pad0150 = v_bytes(size=4)


class KDPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.Importance = v_uint8()
        self.Number = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DpcListEntry = LIST_ENTRY()
        self.DeferredRoutine = v_ptr64()
        self.DeferredContext = v_ptr64()
        self.SystemArgument1 = v_ptr64()
        self.SystemArgument2 = v_ptr64()
        self.DpcData = v_ptr64()


class KEVENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class KSEMAPHORE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.Limit = v_uint32()
        self._pad0020 = v_bytes(size=4)


class OBJECT_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TypeList = LIST_ENTRY()
        self.Name = UNICODE_STRING()
        self.DefaultObject = v_ptr64()
        self.Index = v_uint8()
        self._pad002c = v_bytes(size=3)
        self.TotalNumberOfObjects = v_uint32()
        self.TotalNumberOfHandles = v_uint32()
        self.HighWaterNumberOfObjects = v_uint32()
        self.HighWaterNumberOfHandles = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.TypeInfo = OBJECT_TYPE_INITIALIZER()
        self.TypeLock = EX_PUSH_LOCK()
        self.Key = v_uint32()
        self._pad00c0 = v_bytes(size=4)
        self.CallbackList = LIST_ENTRY()


class tagIMEINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwPrivateDataSize = v_uint32()
        self.fdwProperty = v_uint32()
        self.fdwConversionCaps = v_uint32()
        self.fdwSentenceCaps = v_uint32()
        self.fdwUICaps = v_uint32()
        self.fdwSCSCaps = v_uint32()
        self.fdwSelectCaps = v_uint32()


class DXGK_DIAG_CODE_POINT_PACKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DXGK_DIAG_HEADER()
        self.CodePointType = v_uint32()
        self.Param1 = v_uint32()
        self.Param2 = v_uint32()
        self.Param3 = v_uint32()


class _unnamed_10168(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Create = _unnamed_10255()


class W32PROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Process = v_ptr64()
        self.RefCount = v_uint32()
        self.W32PF_Flags = v_uint32()
        self.InputIdleEvent = v_ptr64()
        self.StartCursorHideTime = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.NextStart = v_ptr64()
        self.pDCAttrList = v_ptr64()
        self.pBrushAttrList = v_ptr64()
        self.W32Pid = v_uint32()
        self.GDIHandleCount = v_uint32()
        self.GDIHandleCountPeak = v_uint32()
        self.UserHandleCount = v_uint32()
        self.UserHandleCountPeak = v_uint32()
        self._pad0050 = v_bytes(size=4)
        self.GDIPushLock = EX_PUSH_LOCK()
        self.GDIEngUserMemAllocTable = RTL_AVL_TABLE()
        self.GDIDcAttrFreeList = LIST_ENTRY()
        self.GDIBrushAttrFreeList = LIST_ENTRY()
        self.GDIW32PIDLockedBitmaps = LIST_ENTRY()
        self.hSecureGdiSharedHandleTable = v_ptr64()
        self.DxProcess = v_ptr64()


class tagKBDFILE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = HEAD()
        self.pkfNext = v_ptr64()
        self.hBase = v_ptr64()
        self.pKbdTbl = v_ptr64()
        self.Size = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.pKbdNlsTbl = v_ptr64()
        self.awchDllName = vstruct.VArray([ v_uint16() for i in xrange(32) ])


class DMM_COMMITVIDPNREQUEST_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AffectedVidPnSourceId = v_uint32()
        self.RequestDiagInfo = DMM_COMMITVIDPNREQUEST_DIAGINFO()
        self.VidPnSerialization = DMM_VIDPN_SERIALIZATION()


class _unnamed_10360(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.FileInformationClass = v_uint32()
        self._pad0010 = v_bytes(size=4)


class _unnamed_13586(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Generic = _unnamed_13916()
        self._pad0010 = v_bytes(size=4)


class EXCEPTION_REGISTRATION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self.Handler = v_ptr64()


class FILE_BASIC_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0028 = v_bytes(size=4)


class LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_ptr64()
        self.Blink = v_ptr64()


class M128A(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Low = v_uint64()
        self.High = v_uint64()


class tagUSERSTARTUPINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cb = v_uint32()
        self.dwX = v_uint32()
        self.dwY = v_uint32()
        self.dwXSize = v_uint32()
        self.dwYSize = v_uint32()
        self.dwFlags = v_uint32()
        self.wShowWindow = v_uint16()
        self.cbReserved2 = v_uint16()


class _unnamed_13369(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Attrib = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.cbData = v_uint64()


class tagHID_PAGEONLY_REQUEST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.link = LIST_ENTRY()
        self.usUsagePage = v_uint16()
        self._pad0014 = v_bytes(size=2)
        self.cRefCount = v_uint32()


class _unnamed_11143(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Graphics = D3DKMDT_GRAPHICS_RENDERING_FORMAT()


class _unnamed_13366(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Attrib = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.cbData = v_uint64()


class RTL_DYNAMIC_HASH_TABLE_ENUMERATOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashEntry = RTL_DYNAMIC_HASH_TABLE_ENTRY()
        self.ChainHead = v_ptr64()
        self.BucketIndex = v_uint32()
        self._pad0028 = v_bytes(size=4)


class tagWINDOWSTATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwSessionId = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.rpwinstaNext = v_ptr64()
        self.rpdeskList = v_ptr64()
        self.pTerm = v_ptr64()
        self.dwWSF_Flags = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.spklList = v_ptr64()
        self.ptiClipLock = v_ptr64()
        self.ptiDrawingClipboard = v_ptr64()
        self.spwndClipOpen = v_ptr64()
        self.spwndClipViewer = v_ptr64()
        self.spwndClipOwner = v_ptr64()
        self.pClipBase = v_ptr64()
        self.cNumClipFormats = v_uint32()
        self.iClipSerialNumber = v_uint32()
        self.iClipSequenceNumber = v_uint32()
        self._pad0070 = v_bytes(size=4)
        self.spwndClipboardListener = v_ptr64()
        self.pGlobalAtomTable = v_ptr64()
        self.luidEndSession = LUID()
        self.luidUser = LUID()
        self.psidUser = v_ptr64()


class DMM_VIDPNPATHSFROMSOURCE_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SourceMode = D3DKMDT_VIDPN_SOURCE_MODE()
        self.NumPathsFromSource = v_uint8()
        self._pad0030 = v_bytes(size=7)
        self.PathAndTargetModeSerialization = vstruct.VArray([ DMM_VIDPNPATHANDTARGETMODE_SERIALIZATION() for i in xrange(1) ])


class GUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data1 = v_uint32()
        self.Data2 = v_uint16()
        self.Data3 = v_uint16()
        self.Data4 = vstruct.VArray([ v_uint8() for i in xrange(8) ])


class D3DKMDT_GRAPHICS_RENDERING_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrimSurfSize = D3DKMDT_2DREGION()
        self.VisibleRegionSize = D3DKMDT_2DREGION()
        self.Stride = v_uint32()
        self.PixelFormat = v_uint32()
        self.ColorBasis = v_uint32()
        self.PixelValueAccessMode = v_uint32()


class SLIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr64()
        self._pad0010 = v_bytes(size=8)


class IO_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Option = v_uint8()
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Spare1 = v_uint8()
        self.Flags = v_uint16()
        self.Spare2 = v_uint16()
        self.u = _unnamed_13900()


class IO_STATUS_BLOCK32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.Information = v_uint32()


class GENERIC_MAPPING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GenericRead = v_uint32()
        self.GenericWrite = v_uint32()
        self.GenericExecute = v_uint32()
        self.GenericAll = v_uint32()


class IRP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.MdlAddress = v_ptr64()
        self.Flags = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.AssociatedIrp = _unnamed_10086()
        self.ThreadListEntry = LIST_ENTRY()
        self.IoStatus = IO_STATUS_BLOCK()
        self.RequestorMode = v_uint8()
        self.PendingReturned = v_uint8()
        self.StackCount = v_uint8()
        self.CurrentLocation = v_uint8()
        self.Cancel = v_uint8()
        self.CancelIrql = v_uint8()
        self.ApcEnvironment = v_uint8()
        self.AllocationFlags = v_uint8()
        self.UserIosb = v_ptr64()
        self.UserEvent = v_ptr64()
        self.Overlay = _unnamed_10089()
        self.CancelRoutine = v_ptr64()
        self.UserBuffer = v_ptr64()
        self.Tail = _unnamed_10092()


class _unnamed_10500(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WhichSpace = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_ptr64()
        self.Offset = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Length = v_uint32()
        self._pad0020 = v_bytes(size=4)


class _unnamed_10505(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint8()


class D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CopyProtectionType = v_uint32()
        self.APSTriggerBits = v_uint32()
        self.OEMCopyProtection = vstruct.VArray([ v_uint8() for i in xrange(256) ])
        self.CopyProtectionSupport = D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_SUPPORT()


class _unnamed_14491(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length40 = v_uint32()
        self.Alignment40 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class DMM_VIDPN_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.NumActiveSources = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.PathsFromSourceSerializationOffsets = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class IO_COMPLETION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = v_ptr64()
        self.Key = v_ptr64()


class DRIVER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DriverObject = v_ptr64()
        self.AddDevice = v_ptr64()
        self.Count = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.ServiceKeyName = UNICODE_STRING()


class _unnamed_13919(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint16()
        self.Group = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint64()


class DMM_COFUNCPATHSMODALITY_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumPathsFromSource = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.PathAndTargetModeSetOffset = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class tagTDB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ptdbNext = v_ptr64()
        self.nEvents = v_uint32()
        self.nPriority = v_uint32()
        self.pti = v_ptr64()
        self.pwti = v_ptr64()
        self.hTaskWow = v_uint16()
        self.TDB_Flags = v_uint16()
        self._pad0028 = v_bytes(size=4)


class _unnamed_13916(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length = v_uint32()


class KPRCB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MxCsr = v_uint32()
        self.LegacyNumber = v_uint8()
        self.ReservedMustBeZero = v_uint8()
        self.InterruptRequest = v_uint8()
        self.IdleHalt = v_uint8()
        self.CurrentThread = v_ptr64()
        self.NextThread = v_ptr64()
        self.IdleThread = v_ptr64()
        self.NestingLevel = v_uint8()
        self.PrcbPad00 = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.Number = v_uint32()
        self.RspBase = v_uint64()
        self.PrcbLock = v_uint64()
        self.PrcbPad01 = v_uint64()
        self.ProcessorState = KPROCESSOR_STATE()
        self.CpuType = v_uint8()
        self.CpuID = v_uint8()
        self.CpuStep = v_uint16()
        self.MHz = v_uint32()
        self.HalReserved = vstruct.VArray([ v_uint64() for i in xrange(8) ])
        self.MinorVersion = v_uint16()
        self.MajorVersion = v_uint16()
        self.BuildType = v_uint8()
        self.CpuVendor = v_uint8()
        self.CoresPerPhysicalProcessor = v_uint8()
        self.LogicalProcessorsPerCore = v_uint8()
        self.ApicMask = v_uint32()
        self.CFlushSize = v_uint32()
        self.AcpiReserved = v_ptr64()
        self.InitialApicId = v_uint32()
        self.Stride = v_uint32()
        self.Group = v_uint16()
        self._pad0660 = v_bytes(size=6)
        self.GroupSetMember = v_uint64()
        self.GroupIndex = v_uint8()
        self._pad0670 = v_bytes(size=7)


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FRUId = v_uint8()


class tagWin32AllocStats(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwMaxMem = v_uint64()
        self.dwCrtMem = v_uint64()
        self.dwMaxAlloc = v_uint32()
        self.dwCrtAlloc = v_uint32()
        self.pHead = v_ptr64()


class LARGE_UNICODE_STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.MaximumLength = v_uint32()
        self.Buffer = v_ptr64()


class EXCEPTION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_ptr64()
        self.ExceptionAddress = v_ptr64()
        self.NumberParameters = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.ExceptionInformation = vstruct.VArray([ v_uint64() for i in xrange(15) ])


class HTOUCHINPUT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class PROCESSOR_NUMBER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.Number = v_uint8()
        self.Reserved = v_uint8()


class _unnamed_10592(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr64()
        self.Argument2 = v_ptr64()
        self.Argument3 = v_ptr64()
        self.Argument4 = v_ptr64()


class KPCR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.IdtBase = v_ptr64()
        self.Unused = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.Irql = v_uint8()
        self.SecondLevelCacheAssociativity = v_uint8()
        self.ObsoleteNumber = v_uint8()
        self.Fill0 = v_uint8()
        self.Unused0 = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.StallScaleFactor = v_uint32()
        self.Unused1 = vstruct.VArray([ v_ptr64() for i in xrange(3) ])
        self.KernelReserved = vstruct.VArray([ v_uint32() for i in xrange(15) ])
        self.SecondLevelCacheSize = v_uint32()
        self.HalReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.Unused2 = v_uint32()
        self._pad0108 = v_bytes(size=4)
        self.KdVersionBlock = v_ptr64()
        self.Unused3 = v_ptr64()
        self.PcrAlign1 = vstruct.VArray([ v_uint32() for i in xrange(24) ])
        self._pad0180 = v_bytes(size=8)
        self.Prcb = KPRCB()


class IMAGE_FILE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Machine = v_uint16()
        self.NumberOfSections = v_uint16()
        self.TimeDateStamp = v_uint32()
        self.PointerToSymbolTable = v_uint32()
        self.NumberOfSymbols = v_uint32()
        self.SizeOfOptionalHeader = v_uint16()
        self.Characteristics = v_uint16()


class SCATTER_GATHER_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumberOfElements = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.Reserved = v_uint64()
        self.Elements = vstruct.VArray([ SCATTER_GATHER_ELEMENT() for i in xrange(0) ])


class tagPROCESSINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Process = v_ptr64()
        self.RefCount = v_uint32()
        self.W32PF_Flags = v_uint32()
        self.InputIdleEvent = v_ptr64()
        self.StartCursorHideTime = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.NextStart = v_ptr64()
        self.pDCAttrList = v_ptr64()
        self.pBrushAttrList = v_ptr64()
        self.W32Pid = v_uint32()
        self.GDIHandleCount = v_uint32()
        self.GDIHandleCountPeak = v_uint32()
        self.UserHandleCount = v_uint32()
        self.UserHandleCountPeak = v_uint32()
        self._pad0050 = v_bytes(size=4)
        self.GDIPushLock = EX_PUSH_LOCK()
        self.GDIEngUserMemAllocTable = RTL_AVL_TABLE()
        self.GDIDcAttrFreeList = LIST_ENTRY()
        self.GDIBrushAttrFreeList = LIST_ENTRY()
        self.GDIW32PIDLockedBitmaps = LIST_ENTRY()
        self.hSecureGdiSharedHandleTable = v_ptr64()
        self.DxProcess = v_ptr64()
        self.ptiList = v_ptr64()
        self.ptiMainThread = v_ptr64()
        self.rpdeskStartup = v_ptr64()
        self.pclsPrivateList = v_ptr64()
        self.pclsPublicList = v_ptr64()
        self.pwpi = v_ptr64()
        self.ppiNext = v_ptr64()
        self.ppiNextRunning = v_ptr64()
        self.cThreads = v_uint32()
        self._pad0148 = v_bytes(size=4)
        self.hdeskStartup = v_ptr64()
        self.cSysExpunge = v_uint32()
        self.dwhmodLibLoadedMask = v_uint32()
        self.ahmodLibLoaded = vstruct.VArray([ v_ptr64() for i in xrange(32) ])
        self.rpwinsta = v_ptr64()
        self.hwinsta = v_ptr64()
        self.amwinsta = v_uint32()
        self.dwHotkey = v_uint32()
        self.hMonitor = v_ptr64()
        self.pdvList = v_ptr64()
        self.iClipSerialNumber = v_uint32()
        self._pad0288 = v_bytes(size=4)
        self.bmHandleFlags = RTL_BITMAP()
        self.pCursorCache = v_ptr64()
        self.pClientBase = v_ptr64()
        self.dwLpkEntryPoints = v_uint32()
        self._pad02b0 = v_bytes(size=4)
        self.pW32Job = v_ptr64()
        self.dwImeCompatFlags = v_uint32()
        self.luidSession = LUID()
        self.usi = tagUSERSTARTUPINFO()
        self.Flags = v_uint32()
        self.dwLayout = v_uint32()
        self.pHidTable = v_ptr64()
        self.dwRegisteredClasses = v_uint32()
        self._pad02f8 = v_bytes(size=4)
        self.pvwplWndGCList = v_ptr64()


class HKL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class PEB_LDR_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Initialized = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.SsHandle = v_ptr64()
        self.InLoadOrderModuleList = LIST_ENTRY()
        self.InMemoryOrderModuleList = LIST_ENTRY()
        self.InInitializationOrderModuleList = LIST_ENTRY()
        self.EntryInProgress = v_ptr64()
        self.ShutdownInProgress = v_uint8()
        self._pad0050 = v_bytes(size=7)
        self.ShutdownThreadId = v_ptr64()


class DMM_MONITORFREQUENCYRANGESET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumFrequencyRanges = v_uint8()
        self._pad0008 = v_bytes(size=7)
        self.FrequencyRangeSerialization = vstruct.VArray([ D3DKMDT_MONITOR_FREQUENCY_RANGE() for i in xrange(1) ])


class SECURITY_SUBJECT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientToken = v_ptr64()
        self.ImpersonationLevel = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.PrimaryToken = v_ptr64()
        self.ProcessAuditId = v_ptr64()


class DMM_MONITOR_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.VideoPresentTargetId = v_uint32()
        self.Orientation = v_uint32()
        self.IsSimulatedMonitor = v_uint8()
        self.IsUsingDefaultProfile = v_uint8()
        self._pad0010 = v_bytes(size=2)
        self.ModePruningAlgorithm = v_uint32()
        self.MonitorPowerState = v_uint32()
        self.SourceModeSetOffset = v_uint32()
        self.FrequencyRangeSetOffset = v_uint32()
        self.DescriptorSetOffset = v_uint32()
        self.MonitorType = v_uint32()


class tagKbdLayer(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pCharModifiers = v_ptr64()
        self.pVkToWcharTable = v_ptr64()
        self.pDeadKey = v_ptr64()
        self.pKeyNames = v_ptr64()
        self.pKeyNamesExt = v_ptr64()
        self.pKeyNamesDead = v_ptr64()
        self.pusVSCtoVK = v_ptr64()
        self.bMaxVSCtoVK = v_uint8()
        self._pad0040 = v_bytes(size=7)
        self.pVSCtoVK_E0 = v_ptr64()
        self.pVSCtoVK_E1 = v_ptr64()
        self.fLocaleFlags = v_uint32()
        self.nLgMax = v_uint8()
        self.cbLgEntry = v_uint8()
        self._pad0058 = v_bytes(size=2)
        self.pLigature = v_ptr64()
        self.dwType = v_uint32()
        self.dwSubType = v_uint32()


class HWND(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class _unnamed_9269(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class tagMSG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.hwnd = v_ptr64()
        self.message = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.wParam = v_uint64()
        self.lParam = v_uint64()
        self.time = v_uint32()
        self.pt = tagPOINT()
        self._pad0030 = v_bytes(size=4)


class _unnamed_10283(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr64()
        self.Options = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self._pad0018 = v_bytes(size=4)
        self.Parameters = v_ptr64()


class INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Context = v_ptr64()
        self.InterfaceReference = v_ptr64()
        self.InterfaceDereference = v_ptr64()


class SLIST_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Alignment = v_uint64()
        self.Region = v_uint64()


class IMAGE_DATA_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_uint32()
        self.Size = v_uint32()


class FILE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.DeviceObject = v_ptr64()
        self.Vpb = v_ptr64()
        self.FsContext = v_ptr64()
        self.FsContext2 = v_ptr64()
        self.SectionObjectPointer = v_ptr64()
        self.PrivateCacheMap = v_ptr64()
        self.FinalStatus = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.RelatedFileObject = v_ptr64()
        self.LockOperation = v_uint8()
        self.DeletePending = v_uint8()
        self.ReadAccess = v_uint8()
        self.WriteAccess = v_uint8()
        self.DeleteAccess = v_uint8()
        self.SharedRead = v_uint8()
        self.SharedWrite = v_uint8()
        self.SharedDelete = v_uint8()
        self.Flags = v_uint32()
        self._pad0058 = v_bytes(size=4)
        self.FileName = UNICODE_STRING()
        self.CurrentByteOffset = LARGE_INTEGER()
        self.Waiters = v_uint32()
        self.Busy = v_uint32()
        self.LastLock = v_ptr64()
        self.Lock = KEVENT()
        self.Event = KEVENT()
        self.CompletionContext = v_ptr64()
        self.IrpListLock = v_uint64()
        self.IrpList = LIST_ENTRY()
        self.FileObjectExtension = v_ptr64()


class tagWOWPROCESSINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pwpiNext = v_ptr64()
        self.ptiScheduled = v_ptr64()
        self.ptdbHead = v_ptr64()
        self.lpfnWowExitTask = v_ptr64()
        self.pEventWowExec = v_ptr64()
        self.hEventWowExecClient = v_ptr64()
        self.nSendLock = v_uint32()
        self.nRecvLock = v_uint32()
        self.CSOwningThread = v_ptr64()
        self.CSLockCount = v_uint32()
        self._pad0048 = v_bytes(size=4)


class tagMENU(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = PROCDESKHEAD()
        self.fFlags = v_uint32()
        self.iItem = v_uint32()
        self.cAlloced = v_uint32()
        self.cItems = v_uint32()
        self.cxMenu = v_uint32()
        self.cyMenu = v_uint32()
        self.cxTextAlign = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.spwndNotify = v_ptr64()
        self.rgItems = v_ptr64()
        self.pParentMenus = v_ptr64()
        self.dwContextHelpId = v_uint32()
        self.cyMax = v_uint32()
        self.dwMenuData = v_uint64()
        self.hbrBack = v_ptr64()
        self.iTop = v_uint32()
        self.iMaxTop = v_uint32()
        self.dwArrowsOn = v_uint32()
        self.umpm = tagUAHMENUPOPUPMETRICS()


class ERESOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemResourcesList = LIST_ENTRY()
        self.OwnerTable = v_ptr64()
        self.ActiveCount = v_uint16()
        self.Flag = v_uint16()
        self._pad0020 = v_bytes(size=4)
        self.SharedWaiters = v_ptr64()
        self.ExclusiveWaiters = v_ptr64()
        self.OwnerEntry = OWNER_ENTRY()
        self.ActiveEntries = v_uint32()
        self.ContentionCount = v_uint32()
        self.NumberOfSharedWaiters = v_uint32()
        self.NumberOfExclusiveWaiters = v_uint32()
        self.Reserved2 = v_ptr64()
        self.Address = v_ptr64()
        self.SpinLock = v_uint64()


class _unnamed_9315(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFunction = v_uint32()


class _unnamed_9312(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()


class PEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InheritedAddressSpace = v_uint8()
        self.ReadImageFileExecOptions = v_uint8()
        self.BeingDebugged = v_uint8()
        self.BitField = v_uint8()
        self._pad0008 = v_bytes(size=4)
        self.Mutant = v_ptr64()
        self.ImageBaseAddress = v_ptr64()
        self.Ldr = v_ptr64()
        self.ProcessParameters = v_ptr64()
        self.SubSystemData = v_ptr64()
        self.ProcessHeap = v_ptr64()
        self.FastPebLock = v_ptr64()
        self.AtlThunkSListPtr = v_ptr64()
        self.IFEOKey = v_ptr64()
        self.CrossProcessFlags = v_uint32()
        self._pad0058 = v_bytes(size=4)
        self.KernelCallbackTable = v_ptr64()
        self.SystemReserved = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.AtlThunkSListPtr32 = v_uint32()
        self.ApiSetMap = v_ptr64()
        self.TlsExpansionCounter = v_uint32()
        self._pad0078 = v_bytes(size=4)
        self.TlsBitmap = v_ptr64()
        self.TlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ReadOnlySharedMemoryBase = v_ptr64()
        self.HotpatchInformation = v_ptr64()
        self.ReadOnlyStaticServerData = v_ptr64()
        self.AnsiCodePageData = v_ptr64()
        self.OemCodePageData = v_ptr64()
        self.UnicodeCaseTableData = v_ptr64()
        self.NumberOfProcessors = v_uint32()
        self.NtGlobalFlag = v_uint32()
        self.CriticalSectionTimeout = LARGE_INTEGER()
        self.HeapSegmentReserve = v_uint64()
        self.HeapSegmentCommit = v_uint64()
        self.HeapDeCommitTotalFreeThreshold = v_uint64()
        self.HeapDeCommitFreeBlockThreshold = v_uint64()
        self.NumberOfHeaps = v_uint32()
        self.MaximumNumberOfHeaps = v_uint32()
        self.ProcessHeaps = v_ptr64()
        self.GdiSharedHandleTable = v_ptr64()
        self.ProcessStarterHelper = v_ptr64()
        self.GdiDCAttributeList = v_uint32()
        self._pad0110 = v_bytes(size=4)
        self.LoaderLock = v_ptr64()
        self.OSMajorVersion = v_uint32()
        self.OSMinorVersion = v_uint32()
        self.OSBuildNumber = v_uint16()
        self.OSCSDVersion = v_uint16()
        self.OSPlatformId = v_uint32()
        self.ImageSubsystem = v_uint32()
        self.ImageSubsystemMajorVersion = v_uint32()
        self.ImageSubsystemMinorVersion = v_uint32()
        self._pad0138 = v_bytes(size=4)
        self.ActiveProcessAffinityMask = v_uint64()
        self.GdiHandleBuffer = vstruct.VArray([ v_uint32() for i in xrange(60) ])
        self.PostProcessInitRoutine = v_ptr64()
        self.TlsExpansionBitmap = v_ptr64()
        self.TlsExpansionBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(32) ])
        self.SessionId = v_uint32()
        self._pad02c8 = v_bytes(size=4)
        self.AppCompatFlags = ULARGE_INTEGER()
        self.AppCompatFlagsUser = ULARGE_INTEGER()
        self.pShimData = v_ptr64()
        self.AppCompatInfo = v_ptr64()
        self.CSDVersion = UNICODE_STRING()
        self.ActivationContextData = v_ptr64()
        self.ProcessAssemblyStorageMap = v_ptr64()
        self.SystemDefaultActivationContextData = v_ptr64()
        self.SystemAssemblyStorageMap = v_ptr64()
        self.MinimumStackCommit = v_uint64()
        self.FlsCallback = v_ptr64()
        self.FlsListHead = LIST_ENTRY()
        self.FlsBitmap = v_ptr64()
        self.FlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.FlsHighIndex = v_uint32()
        self._pad0358 = v_bytes(size=4)
        self.WerRegistrationData = v_ptr64()
        self.WerShipAssertPtr = v_ptr64()
        self.pContextData = v_ptr64()
        self.pImageHeaderHash = v_ptr64()
        self.TracingFlags = v_uint32()
        self._pad0380 = v_bytes(size=4)


class THRDESKHEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.h = v_ptr64()
        self.cLockObj = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.pti = v_ptr64()
        self.rpdesk = v_ptr64()
        self.pSelf = v_ptr64()


class tagPOPUPMENU(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.fIsMenuBar = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.spwndNotify = v_ptr64()
        self.spwndPopupMenu = v_ptr64()
        self.spwndNextPopup = v_ptr64()
        self.spwndPrevPopup = v_ptr64()
        self.spmenu = v_ptr64()
        self.spmenuAlternate = v_ptr64()
        self.spwndActivePopup = v_ptr64()
        self.ppopupmenuRoot = v_ptr64()
        self.ppmDelayedFree = v_ptr64()
        self.posSelectedItem = v_uint32()
        self.posDropped = v_uint32()


class TP_TASK_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteCallback = v_ptr64()
        self.Unposted = v_ptr64()


class RTL_BALANCED_LINKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parent = v_ptr64()
        self.LeftChild = v_ptr64()
        self.RightChild = v_ptr64()
        self.Balance = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self._pad0020 = v_bytes(size=4)


class _unnamed_10421(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Srb = v_ptr64()


class VK_FUNCTION_PARAM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NLSFEProcIndex = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.NLSFEProcParam = v_uint32()


class EX_PUSH_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint64()


class D3DMATRIX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self._11 = v_uint32()
        self._12 = v_uint32()
        self._13 = v_uint32()
        self._14 = v_uint32()
        self._21 = v_uint32()
        self._22 = v_uint32()
        self._23 = v_uint32()
        self._24 = v_uint32()
        self._31 = v_uint32()
        self._32 = v_uint32()
        self._33 = v_uint32()
        self._34 = v_uint32()
        self._41 = v_uint32()
        self._42 = v_uint32()
        self._43 = v_uint32()
        self._44 = v_uint32()


class _unnamed_13952(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length64 = v_uint32()


class CONSOLE_CARET_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.hwnd = v_ptr64()
        self.rc = tagRECT()


class D3DKMDT_VIDPN_PRESENT_PATH_ROTATION_SUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Identity = v_uint32()


class _unnamed_14462(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Alignment = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class WHEA_ERROR_RECORD_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Revision = WHEA_REVISION()
        self.SignatureEnd = v_uint32()
        self.SectionCount = v_uint16()
        self.Severity = v_uint32()
        self.ValidBits = WHEA_ERROR_RECORD_HEADER_VALIDBITS()
        self.Length = v_uint32()
        self.Timestamp = WHEA_TIMESTAMP()
        self.PlatformId = GUID()
        self.PartitionId = GUID()
        self.CreatorId = GUID()
        self.NotifyType = GUID()
        self.RecordId = v_uint64()
        self.Flags = WHEA_ERROR_RECORD_HEADER_FLAGS()
        self.PersistenceInfo = WHEA_PERSISTENCE_INFO()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(12) ])


class EVENT_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint16()
        self.Version = v_uint8()
        self.Channel = v_uint8()
        self.Level = v_uint8()
        self.Opcode = v_uint8()
        self.Task = v_uint16()
        self.Keyword = v_uint64()


class HRGN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class _unnamed_10391(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_ptr64()
        self.Key = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.ByteOffset = LARGE_INTEGER()


class _unnamed_10396(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.InputBufferLength = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.IoControlCode = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.Type3InputBuffer = v_ptr64()


class tagSBINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WSBflags = v_uint32()
        self.Horz = tagSBDATA()
        self.Vert = tagSBDATA()


class FLS_CALLBACK_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_10255(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr64()
        self.Options = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.FileAttributes = v_uint16()
        self.ShareAccess = v_uint16()
        self._pad0018 = v_bytes(size=4)
        self.EaLength = v_uint32()
        self._pad0020 = v_bytes(size=4)


class LIST_ENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint64()
        self.Blink = v_uint64()


class tagOEMBITMAPINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.x = v_uint32()
        self.y = v_uint32()
        self.cx = v_uint32()
        self.cy = v_uint32()


class _unnamed_10497(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoResourceRequirementList = v_ptr64()


class ACTIVATION_CONTEXT_STACK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ActiveFrame = v_ptr64()
        self.FrameListCache = LIST_ENTRY()
        self.Flags = v_uint32()
        self.NextCookieSequenceNumber = v_uint32()
        self.StackId = v_uint32()
        self._pad0028 = v_bytes(size=4)


class tagITEM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.fType = v_uint32()
        self.fState = v_uint32()
        self.wID = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.spSubMenu = v_ptr64()
        self.hbmpChecked = v_ptr64()
        self.hbmpUnchecked = v_ptr64()
        self.lpstr = v_ptr64()
        self.cch = v_uint32()
        self._pad0038 = v_bytes(size=4)
        self.dwItemData = v_uint64()
        self.xItem = v_uint32()
        self.yItem = v_uint32()
        self.cxItem = v_uint32()
        self.cyItem = v_uint32()
        self.dxTab = v_uint32()
        self.ulX = v_uint32()
        self.ulWidth = v_uint32()
        self._pad0060 = v_bytes(size=4)
        self.hbmp = v_ptr64()
        self.cxBmp = v_uint32()
        self.cyBmp = v_uint32()
        self.umim = tagUAHMENUITEMMETRICS()


class IO_DRIVER_CREATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self._pad0008 = v_bytes(size=6)
        self.ExtraCreateParameter = v_ptr64()
        self.DeviceObjectHint = v_ptr64()
        self.TxnParameters = v_ptr64()


class LOOKASIDE_LIST_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE_POOL()


class TEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.EnvironmentPointer = v_ptr64()
        self.ClientId = CLIENT_ID()
        self.ActiveRpcHandle = v_ptr64()
        self.ThreadLocalStoragePointer = v_ptr64()
        self.ProcessEnvironmentBlock = v_ptr64()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_ptr64()
        self.Win32ThreadInfo = v_ptr64()
        self.User32Reserved = vstruct.VArray([ v_uint32() for i in xrange(26) ])
        self.UserReserved = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self._pad0100 = v_bytes(size=4)
        self.WOW32Reserved = v_ptr64()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()
        self.SystemReserved1 = vstruct.VArray([ v_ptr64() for i in xrange(54) ])
        self.ExceptionCode = v_uint32()
        self._pad02c8 = v_bytes(size=4)
        self.ActivationContextStackPointer = v_ptr64()
        self.SpareBytes = vstruct.VArray([ v_uint8() for i in xrange(24) ])
        self.TxFsContext = v_uint32()
        self._pad02f0 = v_bytes(size=4)
        self.GdiTebBatch = GDI_TEB_BATCH()
        self.RealClientId = CLIENT_ID()
        self.GdiCachedProcessHandle = v_ptr64()
        self.GdiClientPID = v_uint32()
        self.GdiClientTID = v_uint32()
        self.GdiThreadLocalInfo = v_ptr64()
        self.Win32ClientInfo = vstruct.VArray([ v_uint64() for i in xrange(62) ])
        self.glDispatchTable = vstruct.VArray([ v_ptr64() for i in xrange(233) ])
        self.glReserved1 = vstruct.VArray([ v_uint64() for i in xrange(29) ])
        self.glReserved2 = v_ptr64()
        self.glSectionInfo = v_ptr64()
        self.glSection = v_ptr64()
        self.glTable = v_ptr64()
        self.glCurrentRC = v_ptr64()
        self.glContext = v_ptr64()
        self.LastStatusValue = v_uint32()
        self._pad1258 = v_bytes(size=4)
        self.StaticUnicodeString = UNICODE_STRING()
        self.StaticUnicodeBuffer = vstruct.VArray([ v_uint16() for i in xrange(261) ])
        self._pad1478 = v_bytes(size=6)
        self.DeallocationStack = v_ptr64()
        self.TlsSlots = vstruct.VArray([ v_ptr64() for i in xrange(64) ])
        self.TlsLinks = LIST_ENTRY()
        self.Vdm = v_ptr64()
        self.ReservedForNtRpc = v_ptr64()
        self.DbgSsReserved = vstruct.VArray([ v_ptr64() for i in xrange(2) ])
        self.HardErrorMode = v_uint32()
        self._pad16b8 = v_bytes(size=4)
        self.Instrumentation = vstruct.VArray([ v_ptr64() for i in xrange(11) ])
        self.ActivityId = GUID()
        self.SubProcessTag = v_ptr64()
        self.EtwLocalData = v_ptr64()
        self.EtwTraceData = v_ptr64()
        self.WinSockData = v_ptr64()
        self.GdiBatchCount = v_uint32()
        self.CurrentIdealProcessor = PROCESSOR_NUMBER()
        self.GuaranteedStackBytes = v_uint32()
        self._pad1750 = v_bytes(size=4)
        self.ReservedForPerf = v_ptr64()
        self.ReservedForOle = v_ptr64()
        self.WaitingOnLoaderLock = v_uint32()
        self._pad1768 = v_bytes(size=4)
        self.SavedPriorityState = v_ptr64()
        self.SoftPatchPtr1 = v_uint64()
        self.ThreadPoolData = v_ptr64()
        self.TlsExpansionSlots = v_ptr64()
        self.DeallocationBStore = v_ptr64()
        self.BStoreLimit = v_ptr64()
        self.MuiGeneration = v_uint32()
        self.IsImpersonating = v_uint32()
        self.NlsCache = v_ptr64()
        self.pShimData = v_ptr64()
        self.HeapVirtualAffinity = v_uint32()
        self._pad17b8 = v_bytes(size=4)
        self.CurrentTransactionHandle = v_ptr64()
        self.ActiveFrame = v_ptr64()
        self.FlsData = v_ptr64()
        self.PreferredLanguages = v_ptr64()
        self.UserPrefLanguages = v_ptr64()
        self.MergedPrefLanguages = v_ptr64()
        self.MuiImpersonation = v_uint32()
        self.CrossTebFlags = v_uint16()
        self.SameTebFlags = v_uint16()
        self.TxnScopeEnterCallback = v_ptr64()
        self.TxnScopeExitCallback = v_ptr64()
        self.TxnScopeContext = v_ptr64()
        self.LockCount = v_uint32()
        self.SpareUlong0 = v_uint32()
        self.ResourceRetValue = v_ptr64()


class tagWIN32HEAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class XSAVE_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint16()
        self.StatusWord = v_uint16()
        self.TagWord = v_uint8()
        self.Reserved1 = v_uint8()
        self.ErrorOpcode = v_uint16()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint16()
        self.Reserved2 = v_uint16()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint16()
        self.Reserved3 = v_uint16()
        self.MxCsr = v_uint32()
        self.MxCsr_Mask = v_uint32()
        self.FloatRegisters = vstruct.VArray([ M128A() for i in xrange(8) ])
        self.XmmRegisters = vstruct.VArray([ M128A() for i in xrange(16) ])
        self.Reserved4 = vstruct.VArray([ v_uint8() for i in xrange(96) ])


class DMM_COMMITVIDPNREQUEST_DIAGINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientType = v_uint32()
        self.ReclaimClonedTarget = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.ModeChangeRequestId = v_uint32()


class IMAGE_DOS_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e_magic = v_uint16()
        self.e_cblp = v_uint16()
        self.e_cp = v_uint16()
        self.e_crlc = v_uint16()
        self.e_cparhdr = v_uint16()
        self.e_minalloc = v_uint16()
        self.e_maxalloc = v_uint16()
        self.e_ss = v_uint16()
        self.e_sp = v_uint16()
        self.e_csum = v_uint16()
        self.e_ip = v_uint16()
        self.e_cs = v_uint16()
        self.e_lfarlc = v_uint16()
        self.e_ovno = v_uint16()
        self.e_res = vstruct.VArray([ v_uint16() for i in xrange(4) ])
        self.e_oemid = v_uint16()
        self.e_oeminfo = v_uint16()
        self.e_res2 = vstruct.VArray([ v_uint16() for i in xrange(10) ])
        self.e_lfanew = v_uint32()


class RTL_DYNAMIC_HASH_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Linkage = LIST_ENTRY()
        self.Signature = v_uint64()


class _unnamed_13776(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pRgb256x3x16 = v_ptr64()


class _unnamed_10086(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MasterIrp = v_ptr64()


class TXN_PARAMETER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.TxFsContext = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.TransactionObject = v_ptr64()


class _unnamed_10796(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InitialPrivilegeSet = INITIAL_PRIVILEGE_SET()


class QUAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UseThisFieldToCopy = v_uint64()


class RTL_DYNAMIC_HASH_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.Shift = v_uint32()
        self.TableSize = v_uint32()
        self.Pivot = v_uint32()
        self.DivisorMask = v_uint32()
        self.NumEntries = v_uint32()
        self.NonEmptyBuckets = v_uint32()
        self.NumEnumerators = v_uint32()
        self.Directory = v_ptr64()


class tagSERVERINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwSRVIFlags = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.cHandleEntries = v_uint64()
        self.mpFnidPfn = vstruct.VArray([ v_ptr64() for i in xrange(32) ])
        self.aStoCidPfn = vstruct.VArray([ v_ptr64() for i in xrange(7) ])
        self.mpFnid_serverCBWndProc = vstruct.VArray([ v_uint16() for i in xrange(31) ])
        self._pad0188 = v_bytes(size=2)
        self.apfnClientA = PFNCLIENT()
        self.apfnClientW = PFNCLIENT()
        self.apfnClientWorker = PFNCLIENTWORKER()
        self.cbHandleTable = v_uint32()
        self.atomSysClass = vstruct.VArray([ v_uint16() for i in xrange(25) ])
        self._pad0388 = v_bytes(size=2)
        self.dwDefaultHeapBase = v_uint32()
        self.dwDefaultHeapSize = v_uint32()
        self.uiShellMsg = v_uint32()
        self.MBStrings = vstruct.VArray([ tagMBSTRING() for i in xrange(11) ])
        self.atomIconSmProp = v_uint16()
        self.atomIconProp = v_uint16()
        self.atomContextHelpIdProp = v_uint16()
        self.atomFrostedWindowProp = v_uint16()
        self.acOemToAnsi = vstruct.VArray([ v_uint8() for i in xrange(256) ])
        self.acAnsiToOem = vstruct.VArray([ v_uint8() for i in xrange(256) ])
        self.dwInstalledEventHooks = v_uint32()
        self.aiSysMet = vstruct.VArray([ v_uint32() for i in xrange(97) ])
        self.argbSystemUnmatched = vstruct.VArray([ v_uint32() for i in xrange(31) ])
        self.argbSystem = vstruct.VArray([ v_uint32() for i in xrange(31) ])
        self._pad09d8 = v_bytes(size=4)
        self.ahbrSystem = vstruct.VArray([ v_ptr64() for i in xrange(31) ])
        self.hbrGray = v_ptr64()
        self.ptCursor = tagPOINT()
        self.ptCursorReal = tagPOINT()
        self.dwLastRITEventTickCount = v_uint32()
        self.nEvents = v_uint32()
        self.dtScroll = v_uint32()
        self.dtLBSearch = v_uint32()
        self.dtCaretBlink = v_uint32()
        self.ucWheelScrollLines = v_uint32()
        self.ucWheelScrollChars = v_uint32()
        self.wMaxLeftOverlapChars = v_uint32()
        self.wMaxRightOverlapChars = v_uint32()
        self.cxSysFontChar = v_uint32()
        self.cySysFontChar = v_uint32()
        self.tmSysFont = tagTEXTMETRICW()
        self.dpiSystem = tagDPISERVERINFO()
        self.hIconSmWindows = v_ptr64()
        self.hIcoWindows = v_ptr64()
        self.dwKeyCache = v_uint32()
        self.dwAsyncKeyCache = v_uint32()
        self.cCaptures = v_uint32()
        self.oembmi = vstruct.VArray([ tagOEMBITMAPINFO() for i in xrange(93) ])
        self.rcScreenReal = tagRECT()
        self.BitCount = v_uint16()
        self.dmLogPixels = v_uint16()
        self.Planes = v_uint8()
        self.BitsPixel = v_uint8()
        self._pad117c = v_bytes(size=2)
        self.PUSIFlags = v_uint32()
        self.uCaretWidth = v_uint32()
        self.UILangID = v_uint16()
        self._pad1188 = v_bytes(size=2)
        self.dwLastSystemRITEventTickCountUpdate = v_uint32()
        self.adwDBGTAGFlags = vstruct.VArray([ v_uint32() for i in xrange(35) ])
        self.dwTagCount = v_uint32()
        self.dwRIPFlags = v_uint32()


class DEVICE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.ReferenceCount = v_uint32()
        self.DriverObject = v_ptr64()
        self.NextDevice = v_ptr64()
        self.AttachedDevice = v_ptr64()
        self.CurrentIrp = v_ptr64()
        self.Timer = v_ptr64()
        self.Flags = v_uint32()
        self.Characteristics = v_uint32()
        self.Vpb = v_ptr64()
        self.DeviceExtension = v_ptr64()
        self.DeviceType = v_uint32()
        self.StackSize = v_uint8()
        self._pad0050 = v_bytes(size=3)
        self.Queue = _unnamed_10148()
        self.AlignmentRequirement = v_uint32()
        self._pad00a0 = v_bytes(size=4)
        self.DeviceQueue = KDEVICE_QUEUE()
        self.Dpc = KDPC()
        self.ActiveThreadCount = v_uint32()
        self._pad0110 = v_bytes(size=4)
        self.SecurityDescriptor = v_ptr64()
        self.DeviceLock = KEVENT()
        self.SectorSize = v_uint16()
        self.Spare1 = v_uint16()
        self._pad0138 = v_bytes(size=4)
        self.DeviceObjectExtension = v_ptr64()
        self.Reserved = v_ptr64()
        self._pad0150 = v_bytes(size=8)


class KTSS64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved0 = v_uint32()
        self.Rsp0 = v_uint64()
        self.Rsp1 = v_uint64()
        self.Rsp2 = v_uint64()
        self.Ist = vstruct.VArray([ v_uint64() for i in xrange(8) ])
        self.Reserved1 = v_uint64()
        self.Reserved2 = v_uint16()
        self.IoMapBase = v_uint16()


class tagCLIENTINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CI_flags = v_uint64()
        self.cSpins = v_uint64()
        self.dwExpWinVer = v_uint32()
        self.dwCompatFlags = v_uint32()
        self.dwCompatFlags2 = v_uint32()
        self.dwTIFlags = v_uint32()
        self.pDeskInfo = v_ptr64()
        self.ulClientDelta = v_uint64()
        self.phkCurrent = v_ptr64()
        self.fsHooks = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.CallbackWnd = CALLBACKWND()
        self.dwHookCurrent = v_uint32()
        self.cInDDEMLCallback = v_uint32()
        self.pClientThreadInfo = v_ptr64()
        self.dwHookData = v_uint64()
        self.dwKeyCache = v_uint32()
        self.afKeyState = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.dwAsyncKeyCache = v_uint32()
        self.afAsyncKeyState = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.afAsyncKeyStateRecentDown = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.hKL = v_ptr64()
        self.CodePage = v_uint16()
        self.achDbcsCF = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self._pad00a0 = v_bytes(size=4)
        self.msgDbcsCB = tagMSG()
        self.lpdwRegisteredClasses = v_ptr64()


class HWINSTA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class TL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.next = v_ptr64()
        self.pobj = v_ptr64()
        self.pfnFree = v_ptr64()


class IO_STACK_LOCATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorFunction = v_uint8()
        self.MinorFunction = v_uint8()
        self.Flags = v_uint8()
        self.Control = v_uint8()
        self._pad0008 = v_bytes(size=4)
        self.Parameters = _unnamed_10168()
        self.DeviceObject = v_ptr64()
        self.FileObject = v_ptr64()
        self.CompletionRoutine = v_ptr64()
        self.Context = v_ptr64()


class tagTERMINAL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwTERMF_Flags = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.spwndDesktopOwner = v_ptr64()
        self.ptiDesktop = v_ptr64()
        self.pqDesktop = v_ptr64()
        self.dwNestedLevel = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.pEventTermInit = v_ptr64()
        self.rpdeskDestroy = v_ptr64()
        self.pEventInputReady = v_ptr64()


class D3DKMDT_VIDPN_PRESENT_PATH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VidPnSourceId = v_uint32()
        self.VidPnTargetId = v_uint32()
        self.ImportanceOrdinal = v_uint32()
        self.ContentTransformation = D3DKMDT_VIDPN_PRESENT_PATH_TRANSFORMATION()
        self.VisibleFromActiveTLOffset = D3DKMDT_2DREGION()
        self.VisibleFromActiveBROffset = D3DKMDT_2DREGION()
        self.VidPnTargetColorBasis = v_uint32()
        self.VidPnTargetColorCoeffDynamicRanges = D3DKMDT_COLOR_COEFF_DYNAMIC_RANGES()
        self.Content = v_uint32()
        self.CopyProtection = D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION()
        self.GammaRamp = D3DKMDT_GAMMA_RAMP()


class tagMENULIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pNext = v_ptr64()
        self.pMenu = v_ptr64()


class VK_VALUES_STRINGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pszMultiNames = v_ptr64()
        self.fReserved = v_uint8()
        self._pad0010 = v_bytes(size=7)


class tagKL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = HEAD()
        self.pklNext = v_ptr64()
        self.pklPrev = v_ptr64()
        self.dwKL_Flags = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.hkl = v_ptr64()
        self.spkf = v_ptr64()
        self.spkfPrimary = v_ptr64()
        self.dwFontSigs = v_uint32()
        self.iBaseCharset = v_uint32()
        self.CodePage = v_uint16()
        self.wchDiacritic = v_uint16()
        self._pad0050 = v_bytes(size=4)
        self.piiex = v_ptr64()
        self.uNumTbl = v_uint32()
        self._pad0060 = v_bytes(size=4)
        self.pspkfExtra = v_ptr64()
        self.dwLastKbdType = v_uint32()
        self.dwLastKbdSubType = v_uint32()
        self.dwKLID = v_uint32()
        self._pad0078 = v_bytes(size=4)


class tagPOINT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.x = v_uint32()
        self.y = v_uint32()


class RTL_USER_PROCESS_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MaximumLength = v_uint32()
        self.Length = v_uint32()
        self.Flags = v_uint32()
        self.DebugFlags = v_uint32()
        self.ConsoleHandle = v_ptr64()
        self.ConsoleFlags = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.StandardInput = v_ptr64()
        self.StandardOutput = v_ptr64()
        self.StandardError = v_ptr64()
        self.CurrentDirectory = CURDIR()
        self.DllPath = UNICODE_STRING()
        self.ImagePathName = UNICODE_STRING()
        self.CommandLine = UNICODE_STRING()
        self.Environment = v_ptr64()
        self.StartingX = v_uint32()
        self.StartingY = v_uint32()
        self.CountX = v_uint32()
        self.CountY = v_uint32()
        self.CountCharsX = v_uint32()
        self.CountCharsY = v_uint32()
        self.FillAttribute = v_uint32()
        self.WindowFlags = v_uint32()
        self.ShowWindowFlags = v_uint32()
        self._pad00b0 = v_bytes(size=4)
        self.WindowTitle = UNICODE_STRING()
        self.DesktopInfo = UNICODE_STRING()
        self.ShellInfo = UNICODE_STRING()
        self.RuntimeData = UNICODE_STRING()
        self.CurrentDirectores = vstruct.VArray([ RTL_DRIVE_LETTER_CURDIR() for i in xrange(32) ])
        self.EnvironmentSize = v_uint64()
        self.EnvironmentVersion = v_uint64()


class tagSHAREDINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.psi = v_ptr64()
        self.aheList = v_ptr64()
        self.HeEntrySize = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.pDispInfo = v_ptr64()
        self.ulSharedDelta = v_uint64()
        self.awmControl = vstruct.VArray([ WNDMSG() for i in xrange(31) ])
        self.DefWindowMsgs = WNDMSG()
        self.DefWindowSpecMsgs = WNDMSG()


class _unnamed_10107(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserApcRoutine = v_ptr64()
        self.UserApcContext = v_ptr64()


class tagIMC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = THRDESKHEAD()
        self.pImcNext = v_ptr64()
        self.dwClientImcData = v_uint64()
        self.hImeWnd = v_ptr64()


class IO_RESOURCE_REQUIREMENTS_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.SlotNumber = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.AlternativeLists = v_uint32()
        self.List = vstruct.VArray([ IO_RESOURCE_LIST() for i in xrange(1) ])


class tagCARET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.spwnd = v_ptr64()
        self.fVisible = v_uint32()
        self.iHideLevel = v_uint32()
        self.x = v_uint32()
        self.y = v_uint32()
        self.cy = v_uint32()
        self.cx = v_uint32()
        self.hBitmap = v_ptr64()
        self.hTimer = v_uint64()
        self.tid = v_uint32()
        self.xOwnDc = v_uint32()
        self.yOwnDc = v_uint32()
        self.cxOwnDc = v_uint32()
        self.cyOwnDc = v_uint32()
        self._pad0048 = v_bytes(size=4)




########NEW FILE########
__FILENAME__ = ntdll
# Version: 6.1
# Architecture: i386
import vstruct
from vstruct.primitives import *

KPROCESS_STATE = v_enum()
KPROCESS_STATE.ProcessInMemory = 0
KPROCESS_STATE.ProcessOutOfMemory = 1
KPROCESS_STATE.ProcessInTransition = 2
KPROCESS_STATE.ProcessOutTransition = 3
KPROCESS_STATE.ProcessInSwap = 4
KPROCESS_STATE.ProcessOutSwap = 5
KPROCESS_STATE.ProcessAllSwapStates = 6


WHEA_ERROR_SEVERITY = v_enum()
WHEA_ERROR_SEVERITY.WheaErrSevRecoverable = 0
WHEA_ERROR_SEVERITY.WheaErrSevFatal = 1
WHEA_ERROR_SEVERITY.WheaErrSevCorrected = 2
WHEA_ERROR_SEVERITY.WheaErrSevInformational = 3


REG_NOTIFY_CLASS = v_enum()
REG_NOTIFY_CLASS.RegNtDeleteKey = 0
REG_NOTIFY_CLASS.RegNtPreDeleteKey = 0
REG_NOTIFY_CLASS.RegNtSetValueKey = 1
REG_NOTIFY_CLASS.RegNtPreSetValueKey = 1
REG_NOTIFY_CLASS.RegNtDeleteValueKey = 2
REG_NOTIFY_CLASS.RegNtPreDeleteValueKey = 2
REG_NOTIFY_CLASS.RegNtSetInformationKey = 3
REG_NOTIFY_CLASS.RegNtPreSetInformationKey = 3
REG_NOTIFY_CLASS.RegNtRenameKey = 4
REG_NOTIFY_CLASS.RegNtPreRenameKey = 4
REG_NOTIFY_CLASS.RegNtEnumerateKey = 5
REG_NOTIFY_CLASS.RegNtPreEnumerateKey = 5
REG_NOTIFY_CLASS.RegNtEnumerateValueKey = 6
REG_NOTIFY_CLASS.RegNtPreEnumerateValueKey = 6
REG_NOTIFY_CLASS.RegNtQueryKey = 7
REG_NOTIFY_CLASS.RegNtPreQueryKey = 7
REG_NOTIFY_CLASS.RegNtQueryValueKey = 8
REG_NOTIFY_CLASS.RegNtPreQueryValueKey = 8
REG_NOTIFY_CLASS.RegNtQueryMultipleValueKey = 9
REG_NOTIFY_CLASS.RegNtPreQueryMultipleValueKey = 9
REG_NOTIFY_CLASS.RegNtPreCreateKey = 10
REG_NOTIFY_CLASS.RegNtPostCreateKey = 11
REG_NOTIFY_CLASS.RegNtPreOpenKey = 12
REG_NOTIFY_CLASS.RegNtPostOpenKey = 13
REG_NOTIFY_CLASS.RegNtKeyHandleClose = 14
REG_NOTIFY_CLASS.RegNtPreKeyHandleClose = 14
REG_NOTIFY_CLASS.RegNtPostDeleteKey = 15
REG_NOTIFY_CLASS.RegNtPostSetValueKey = 16
REG_NOTIFY_CLASS.RegNtPostDeleteValueKey = 17
REG_NOTIFY_CLASS.RegNtPostSetInformationKey = 18
REG_NOTIFY_CLASS.RegNtPostRenameKey = 19
REG_NOTIFY_CLASS.RegNtPostEnumerateKey = 20
REG_NOTIFY_CLASS.RegNtPostEnumerateValueKey = 21
REG_NOTIFY_CLASS.RegNtPostQueryKey = 22
REG_NOTIFY_CLASS.RegNtPostQueryValueKey = 23
REG_NOTIFY_CLASS.RegNtPostQueryMultipleValueKey = 24
REG_NOTIFY_CLASS.RegNtPostKeyHandleClose = 25
REG_NOTIFY_CLASS.RegNtPreCreateKeyEx = 26
REG_NOTIFY_CLASS.RegNtPostCreateKeyEx = 27
REG_NOTIFY_CLASS.RegNtPreOpenKeyEx = 28
REG_NOTIFY_CLASS.RegNtPostOpenKeyEx = 29
REG_NOTIFY_CLASS.RegNtPreFlushKey = 30
REG_NOTIFY_CLASS.RegNtPostFlushKey = 31
REG_NOTIFY_CLASS.RegNtPreLoadKey = 32
REG_NOTIFY_CLASS.RegNtPostLoadKey = 33
REG_NOTIFY_CLASS.RegNtPreUnLoadKey = 34
REG_NOTIFY_CLASS.RegNtPostUnLoadKey = 35
REG_NOTIFY_CLASS.RegNtPreQueryKeySecurity = 36
REG_NOTIFY_CLASS.RegNtPostQueryKeySecurity = 37
REG_NOTIFY_CLASS.RegNtPreSetKeySecurity = 38
REG_NOTIFY_CLASS.RegNtPostSetKeySecurity = 39
REG_NOTIFY_CLASS.RegNtCallbackObjectContextCleanup = 40
REG_NOTIFY_CLASS.RegNtPreRestoreKey = 41
REG_NOTIFY_CLASS.RegNtPostRestoreKey = 42
REG_NOTIFY_CLASS.RegNtPreSaveKey = 43
REG_NOTIFY_CLASS.RegNtPostSaveKey = 44
REG_NOTIFY_CLASS.RegNtPreReplaceKey = 45
REG_NOTIFY_CLASS.RegNtPostReplaceKey = 46
REG_NOTIFY_CLASS.MaxRegNtNotifyClass = 47


DEVICE_RELATION_TYPE = v_enum()
DEVICE_RELATION_TYPE.BusRelations = 0
DEVICE_RELATION_TYPE.EjectionRelations = 1
DEVICE_RELATION_TYPE.PowerRelations = 2
DEVICE_RELATION_TYPE.RemovalRelations = 3
DEVICE_RELATION_TYPE.TargetDeviceRelation = 4
DEVICE_RELATION_TYPE.SingleBusRelations = 5
DEVICE_RELATION_TYPE.TransportRelations = 6


FILE_INFORMATION_CLASS = v_enum()
FILE_INFORMATION_CLASS.FileDirectoryInformation = 1
FILE_INFORMATION_CLASS.FileFullDirectoryInformation = 2
FILE_INFORMATION_CLASS.FileBothDirectoryInformation = 3
FILE_INFORMATION_CLASS.FileBasicInformation = 4
FILE_INFORMATION_CLASS.FileStandardInformation = 5
FILE_INFORMATION_CLASS.FileInternalInformation = 6
FILE_INFORMATION_CLASS.FileEaInformation = 7
FILE_INFORMATION_CLASS.FileAccessInformation = 8
FILE_INFORMATION_CLASS.FileNameInformation = 9
FILE_INFORMATION_CLASS.FileRenameInformation = 10
FILE_INFORMATION_CLASS.FileLinkInformation = 11
FILE_INFORMATION_CLASS.FileNamesInformation = 12
FILE_INFORMATION_CLASS.FileDispositionInformation = 13
FILE_INFORMATION_CLASS.FilePositionInformation = 14
FILE_INFORMATION_CLASS.FileFullEaInformation = 15
FILE_INFORMATION_CLASS.FileModeInformation = 16
FILE_INFORMATION_CLASS.FileAlignmentInformation = 17
FILE_INFORMATION_CLASS.FileAllInformation = 18
FILE_INFORMATION_CLASS.FileAllocationInformation = 19
FILE_INFORMATION_CLASS.FileEndOfFileInformation = 20
FILE_INFORMATION_CLASS.FileAlternateNameInformation = 21
FILE_INFORMATION_CLASS.FileStreamInformation = 22
FILE_INFORMATION_CLASS.FilePipeInformation = 23
FILE_INFORMATION_CLASS.FilePipeLocalInformation = 24
FILE_INFORMATION_CLASS.FilePipeRemoteInformation = 25
FILE_INFORMATION_CLASS.FileMailslotQueryInformation = 26
FILE_INFORMATION_CLASS.FileMailslotSetInformation = 27
FILE_INFORMATION_CLASS.FileCompressionInformation = 28
FILE_INFORMATION_CLASS.FileObjectIdInformation = 29
FILE_INFORMATION_CLASS.FileCompletionInformation = 30
FILE_INFORMATION_CLASS.FileMoveClusterInformation = 31
FILE_INFORMATION_CLASS.FileQuotaInformation = 32
FILE_INFORMATION_CLASS.FileReparsePointInformation = 33
FILE_INFORMATION_CLASS.FileNetworkOpenInformation = 34
FILE_INFORMATION_CLASS.FileAttributeTagInformation = 35
FILE_INFORMATION_CLASS.FileTrackingInformation = 36
FILE_INFORMATION_CLASS.FileIdBothDirectoryInformation = 37
FILE_INFORMATION_CLASS.FileIdFullDirectoryInformation = 38
FILE_INFORMATION_CLASS.FileValidDataLengthInformation = 39
FILE_INFORMATION_CLASS.FileShortNameInformation = 40
FILE_INFORMATION_CLASS.FileIoCompletionNotificationInformation = 41
FILE_INFORMATION_CLASS.FileIoStatusBlockRangeInformation = 42
FILE_INFORMATION_CLASS.FileIoPriorityHintInformation = 43
FILE_INFORMATION_CLASS.FileSfioReserveInformation = 44
FILE_INFORMATION_CLASS.FileSfioVolumeInformation = 45
FILE_INFORMATION_CLASS.FileHardLinkInformation = 46
FILE_INFORMATION_CLASS.FileProcessIdsUsingFileInformation = 47
FILE_INFORMATION_CLASS.FileNormalizedNameInformation = 48
FILE_INFORMATION_CLASS.FileNetworkPhysicalNameInformation = 49
FILE_INFORMATION_CLASS.FileIdGlobalTxDirectoryInformation = 50
FILE_INFORMATION_CLASS.FileIsRemoteDeviceInformation = 51
FILE_INFORMATION_CLASS.FileAttributeCacheInformation = 52
FILE_INFORMATION_CLASS.FileNumaNodeInformation = 53
FILE_INFORMATION_CLASS.FileStandardLinkInformation = 54
FILE_INFORMATION_CLASS.FileRemoteProtocolInformation = 55
FILE_INFORMATION_CLASS.FileMaximumInformation = 56


ALTERNATIVE_ARCHITECTURE_TYPE = v_enum()
ALTERNATIVE_ARCHITECTURE_TYPE.StandardDesign = 0
ALTERNATIVE_ARCHITECTURE_TYPE.NEC98x86 = 1
ALTERNATIVE_ARCHITECTURE_TYPE.EndAlternatives = 2


BUS_QUERY_ID_TYPE = v_enum()
BUS_QUERY_ID_TYPE.BusQueryDeviceID = 0
BUS_QUERY_ID_TYPE.BusQueryHardwareIDs = 1
BUS_QUERY_ID_TYPE.BusQueryCompatibleIDs = 2
BUS_QUERY_ID_TYPE.BusQueryInstanceID = 3
BUS_QUERY_ID_TYPE.BusQueryDeviceSerialNumber = 4
BUS_QUERY_ID_TYPE.BusQueryContainerID = 5


KOBJECTS = v_enum()
KOBJECTS.EventNotificationObject = 0
KOBJECTS.EventSynchronizationObject = 1
KOBJECTS.MutantObject = 2
KOBJECTS.ProcessObject = 3
KOBJECTS.QueueObject = 4
KOBJECTS.SemaphoreObject = 5
KOBJECTS.ThreadObject = 6
KOBJECTS.GateObject = 7
KOBJECTS.TimerNotificationObject = 8
KOBJECTS.TimerSynchronizationObject = 9
KOBJECTS.Spare2Object = 10
KOBJECTS.Spare3Object = 11
KOBJECTS.Spare4Object = 12
KOBJECTS.Spare5Object = 13
KOBJECTS.Spare6Object = 14
KOBJECTS.Spare7Object = 15
KOBJECTS.Spare8Object = 16
KOBJECTS.Spare9Object = 17
KOBJECTS.ApcObject = 18
KOBJECTS.DpcObject = 19
KOBJECTS.DeviceQueueObject = 20
KOBJECTS.EventPairObject = 21
KOBJECTS.InterruptObject = 22
KOBJECTS.ProfileObject = 23
KOBJECTS.ThreadedDpcObject = 24
KOBJECTS.MaximumKernelObject = 25


NT_PRODUCT_TYPE = v_enum()
NT_PRODUCT_TYPE.NtProductWinNt = 1
NT_PRODUCT_TYPE.NtProductLanManNt = 2
NT_PRODUCT_TYPE.NtProductServer = 3


DEVICE_POWER_STATE = v_enum()
DEVICE_POWER_STATE.PowerDeviceUnspecified = 0
DEVICE_POWER_STATE.PowerDeviceD0 = 1
DEVICE_POWER_STATE.PowerDeviceD1 = 2
DEVICE_POWER_STATE.PowerDeviceD2 = 3
DEVICE_POWER_STATE.PowerDeviceD3 = 4
DEVICE_POWER_STATE.PowerDeviceMaximum = 5


WHEA_ERROR_SOURCE_TYPE = v_enum()
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMCE = 0
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCMC = 1
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCPE = 2
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeNMI = 3
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypePCIe = 4
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeGeneric = 5
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeINIT = 6
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeBOOT = 7
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeSCIGeneric = 8
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFMCA = 9
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCMC = 10
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCPE = 11
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMax = 12


PROC_HYPERVISOR_STATE = v_enum()
PROC_HYPERVISOR_STATE.ProcHypervisorNone = 0
PROC_HYPERVISOR_STATE.ProcHypervisorPresent = 1
PROC_HYPERVISOR_STATE.ProcHypervisorPower = 2


RTL_GENERIC_COMPARE_RESULTS = v_enum()
RTL_GENERIC_COMPARE_RESULTS.GenericLessThan = 0
RTL_GENERIC_COMPARE_RESULTS.GenericGreaterThan = 1
RTL_GENERIC_COMPARE_RESULTS.GenericEqual = 2


KWAIT_BLOCK_STATE = v_enum()
KWAIT_BLOCK_STATE.WaitBlockBypassStart = 0
KWAIT_BLOCK_STATE.WaitBlockBypassComplete = 1
KWAIT_BLOCK_STATE.WaitBlockActive = 2
KWAIT_BLOCK_STATE.WaitBlockInactive = 3
KWAIT_BLOCK_STATE.WaitBlockAllStates = 4


WHEA_ERROR_TYPE = v_enum()
WHEA_ERROR_TYPE.WheaErrTypeProcessor = 0
WHEA_ERROR_TYPE.WheaErrTypeMemory = 1
WHEA_ERROR_TYPE.WheaErrTypePCIExpress = 2
WHEA_ERROR_TYPE.WheaErrTypeNMI = 3
WHEA_ERROR_TYPE.WheaErrTypePCIXBus = 4
WHEA_ERROR_TYPE.WheaErrTypePCIXDevice = 5
WHEA_ERROR_TYPE.WheaErrTypeGeneric = 6


PROCESSOR_CACHE_TYPE = v_enum()
PROCESSOR_CACHE_TYPE.CacheUnified = 0
PROCESSOR_CACHE_TYPE.CacheInstruction = 1
PROCESSOR_CACHE_TYPE.CacheData = 2
PROCESSOR_CACHE_TYPE.CacheTrace = 3


MCA_EXCEPTION_TYPE = v_enum()
MCA_EXCEPTION_TYPE.HAL_MCE_RECORD = 0
MCA_EXCEPTION_TYPE.HAL_MCA_RECORD = 1


EVENT_TYPE = v_enum()
EVENT_TYPE.NotificationEvent = 0
EVENT_TYPE.SynchronizationEvent = 1


KSPIN_LOCK_QUEUE_NUMBER = v_enum()
KSPIN_LOCK_QUEUE_NUMBER.LockQueueUnusedSpare0 = 0
KSPIN_LOCK_QUEUE_NUMBER.LockQueueExpansionLock = 1
KSPIN_LOCK_QUEUE_NUMBER.LockQueueUnusedSpare2 = 2
KSPIN_LOCK_QUEUE_NUMBER.LockQueueSystemSpaceLock = 3
KSPIN_LOCK_QUEUE_NUMBER.LockQueueVacbLock = 4
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMasterLock = 5
KSPIN_LOCK_QUEUE_NUMBER.LockQueueNonPagedPoolLock = 6
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoCancelLock = 7
KSPIN_LOCK_QUEUE_NUMBER.LockQueueWorkQueueLock = 8
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoVpbLock = 9
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoDatabaseLock = 10
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoCompletionLock = 11
KSPIN_LOCK_QUEUE_NUMBER.LockQueueNtfsStructLock = 12
KSPIN_LOCK_QUEUE_NUMBER.LockQueueAfdWorkQueueLock = 13
KSPIN_LOCK_QUEUE_NUMBER.LockQueueBcbLock = 14
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMmNonPagedPoolLock = 15
KSPIN_LOCK_QUEUE_NUMBER.LockQueueUnusedSpare16 = 16
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMaximumLock = 17


TP_CALLBACK_PRIORITY = v_enum()
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_HIGH = 0
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_NORMAL = 1
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_LOW = 2
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_INVALID = 3


FSINFOCLASS = v_enum()
FSINFOCLASS.FileFsVolumeInformation = 1
FSINFOCLASS.FileFsLabelInformation = 2
FSINFOCLASS.FileFsSizeInformation = 3
FSINFOCLASS.FileFsDeviceInformation = 4
FSINFOCLASS.FileFsAttributeInformation = 5
FSINFOCLASS.FileFsControlInformation = 6
FSINFOCLASS.FileFsFullSizeInformation = 7
FSINFOCLASS.FileFsObjectIdInformation = 8
FSINFOCLASS.FileFsDriverPathInformation = 9
FSINFOCLASS.FileFsVolumeFlagsInformation = 10
FSINFOCLASS.FileFsMaximumInformation = 11


WORKING_SET_TYPE = v_enum()
WORKING_SET_TYPE.WorkingSetTypeUser = 0
WORKING_SET_TYPE.WorkingSetTypeSession = 1
WORKING_SET_TYPE.WorkingSetTypeSystemTypes = 2
WORKING_SET_TYPE.WorkingSetTypeSystemCache = 2
WORKING_SET_TYPE.WorkingSetTypePagedPool = 3
WORKING_SET_TYPE.WorkingSetTypeSystemPtes = 4
WORKING_SET_TYPE.WorkingSetTypeMaximum = 5


POOL_TYPE = v_enum()
POOL_TYPE.NonPagedPool = 0
POOL_TYPE.PagedPool = 1
POOL_TYPE.NonPagedPoolMustSucceed = 2
POOL_TYPE.DontUseThisType = 3
POOL_TYPE.NonPagedPoolCacheAligned = 4
POOL_TYPE.PagedPoolCacheAligned = 5
POOL_TYPE.NonPagedPoolCacheAlignedMustS = 6
POOL_TYPE.MaxPoolType = 7
POOL_TYPE.NonPagedPoolSession = 32
POOL_TYPE.PagedPoolSession = 33
POOL_TYPE.NonPagedPoolMustSucceedSession = 34
POOL_TYPE.DontUseThisTypeSession = 35
POOL_TYPE.NonPagedPoolCacheAlignedSession = 36
POOL_TYPE.PagedPoolCacheAlignedSession = 37
POOL_TYPE.NonPagedPoolCacheAlignedMustSSession = 38


IO_PRIORITY_HINT = v_enum()
IO_PRIORITY_HINT.IoPriorityVeryLow = 0
IO_PRIORITY_HINT.IoPriorityLow = 1
IO_PRIORITY_HINT.IoPriorityNormal = 2
IO_PRIORITY_HINT.IoPriorityHigh = 3
IO_PRIORITY_HINT.IoPriorityCritical = 4
IO_PRIORITY_HINT.MaxIoPriorityTypes = 5


MODE = v_enum()
MODE.KernelMode = 0
MODE.UserMode = 1
MODE.MaximumMode = 2


FS_FILTER_SECTION_SYNC_TYPE = v_enum()
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeOther = 0
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeCreateSection = 1


OB_OPEN_REASON = v_enum()
OB_OPEN_REASON.ObCreateHandle = 0
OB_OPEN_REASON.ObOpenHandle = 1
OB_OPEN_REASON.ObDuplicateHandle = 2
OB_OPEN_REASON.ObInheritHandle = 3
OB_OPEN_REASON.ObMaxOpenReason = 4


HEAP_FAILURE_TYPE = v_enum()
HEAP_FAILURE_TYPE.heap_failure_internal = 0
HEAP_FAILURE_TYPE.heap_failure_unknown = 1
HEAP_FAILURE_TYPE.heap_failure_generic = 2
HEAP_FAILURE_TYPE.heap_failure_entry_corruption = 3
HEAP_FAILURE_TYPE.heap_failure_multiple_entries_corruption = 4
HEAP_FAILURE_TYPE.heap_failure_virtual_block_corruption = 5
HEAP_FAILURE_TYPE.heap_failure_buffer_overrun = 6
HEAP_FAILURE_TYPE.heap_failure_buffer_underrun = 7
HEAP_FAILURE_TYPE.heap_failure_block_not_busy = 8
HEAP_FAILURE_TYPE.heap_failure_invalid_argument = 9
HEAP_FAILURE_TYPE.heap_failure_usage_after_free = 10
HEAP_FAILURE_TYPE.heap_failure_cross_heap_operation = 11
HEAP_FAILURE_TYPE.heap_failure_freelists_corruption = 12
HEAP_FAILURE_TYPE.heap_failure_listentry_corruption = 13


DEVICE_TEXT_TYPE = v_enum()
DEVICE_TEXT_TYPE.DeviceTextDescription = 0
DEVICE_TEXT_TYPE.DeviceTextLocationInformation = 1


POWER_STATE_TYPE = v_enum()
POWER_STATE_TYPE.SystemPowerState = 0
POWER_STATE_TYPE.DevicePowerState = 1


IRQ_PRIORITY = v_enum()
IRQ_PRIORITY.IrqPriorityUndefined = 0
IRQ_PRIORITY.IrqPriorityLow = 1
IRQ_PRIORITY.IrqPriorityNormal = 2
IRQ_PRIORITY.IrqPriorityHigh = 3


KWAIT_STATE = v_enum()
KWAIT_STATE.WaitInProgress = 0
KWAIT_STATE.WaitCommitted = 1
KWAIT_STATE.WaitAborted = 2
KWAIT_STATE.MaximumWaitState = 3


LSA_FOREST_TRUST_RECORD_TYPE = v_enum()
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName = 0
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx = 1
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo = 2
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustRecordTypeLast = 2


IO_ALLOCATION_ACTION = v_enum()
IO_ALLOCATION_ACTION.KeepObject = 1
IO_ALLOCATION_ACTION.DeallocateObject = 2
IO_ALLOCATION_ACTION.DeallocateObjectKeepRegisters = 3


EXCEPTION_DISPOSITION = v_enum()
EXCEPTION_DISPOSITION.ExceptionContinueExecution = 0
EXCEPTION_DISPOSITION.ExceptionContinueSearch = 1
EXCEPTION_DISPOSITION.ExceptionNestedException = 2
EXCEPTION_DISPOSITION.ExceptionCollidedUnwind = 3


SECURITY_OPERATION_CODE = v_enum()
SECURITY_OPERATION_CODE.SetSecurityDescriptor = 0
SECURITY_OPERATION_CODE.QuerySecurityDescriptor = 1
SECURITY_OPERATION_CODE.DeleteSecurityDescriptor = 2
SECURITY_OPERATION_CODE.AssignSecurityDescriptor = 3


PP_NPAGED_LOOKASIDE_NUMBER = v_enum()
PP_NPAGED_LOOKASIDE_NUMBER.LookasideSmallIrpList = 0
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMediumIrpList = 1
PP_NPAGED_LOOKASIDE_NUMBER.LookasideLargeIrpList = 2
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMdlList = 3
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCreateInfoList = 4
PP_NPAGED_LOOKASIDE_NUMBER.LookasideNameBufferList = 5
PP_NPAGED_LOOKASIDE_NUMBER.LookasideTwilightList = 6
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCompletionList = 7
PP_NPAGED_LOOKASIDE_NUMBER.LookasideScratchBufferList = 8
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMaximumList = 9


WHEA_ERROR_PACKET_DATA_FORMAT = v_enum()
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatIPFSalRecord = 0
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatXPFMCA = 1
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMemory = 2
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIExpress = 3
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatNMIPort = 4
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXBus = 5
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXDevice = 6
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatGeneric = 7
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMax = 8


FS_FILTER_STREAM_FO_NOTIFICATION_TYPE = v_enum()
FS_FILTER_STREAM_FO_NOTIFICATION_TYPE.NotifyTypeCreate = 0
FS_FILTER_STREAM_FO_NOTIFICATION_TYPE.NotifyTypeRetired = 1


DISPLAYCONFIG_SCANLINE_ORDERING = v_enum()
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = 2
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = -1


SECURITY_IMPERSONATION_LEVEL = v_enum()
SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous = 0
SECURITY_IMPERSONATION_LEVEL.SecurityIdentification = 1
SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation = 2
SECURITY_IMPERSONATION_LEVEL.SecurityDelegation = 3


DEVICE_USAGE_NOTIFICATION_TYPE = v_enum()
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeUndefined = 0
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypePaging = 1
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeHibernation = 2
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeDumpFile = 3


INTERFACE_TYPE = v_enum()
INTERFACE_TYPE.InterfaceTypeUndefined = -1
INTERFACE_TYPE.Internal = 0
INTERFACE_TYPE.Isa = 1
INTERFACE_TYPE.Eisa = 2
INTERFACE_TYPE.MicroChannel = 3
INTERFACE_TYPE.TurboChannel = 4
INTERFACE_TYPE.PCIBus = 5
INTERFACE_TYPE.VMEBus = 6
INTERFACE_TYPE.NuBus = 7
INTERFACE_TYPE.PCMCIABus = 8
INTERFACE_TYPE.CBus = 9
INTERFACE_TYPE.MPIBus = 10
INTERFACE_TYPE.MPSABus = 11
INTERFACE_TYPE.ProcessorInternal = 12
INTERFACE_TYPE.InternalPowerBus = 13
INTERFACE_TYPE.PNPISABus = 14
INTERFACE_TYPE.PNPBus = 15
INTERFACE_TYPE.Vmcs = 16
INTERFACE_TYPE.MaximumInterfaceType = 17


PS_RESOURCE_TYPE = v_enum()
PS_RESOURCE_TYPE.PsResourceNonPagedPool = 0
PS_RESOURCE_TYPE.PsResourcePagedPool = 1
PS_RESOURCE_TYPE.PsResourcePageFile = 2
PS_RESOURCE_TYPE.PsResourceWorkingSet = 3
PS_RESOURCE_TYPE.PsResourceCpuRate = 4
PS_RESOURCE_TYPE.PsResourceMax = 5


MM_PAGE_ACCESS_TYPE = v_enum()
MM_PAGE_ACCESS_TYPE.MmPteAccessType = 0
MM_PAGE_ACCESS_TYPE.MmCcReadAheadType = 1
MM_PAGE_ACCESS_TYPE.MmPfnRepurposeType = 2
MM_PAGE_ACCESS_TYPE.MmMaximumPageAccessType = 3


PF_FILE_ACCESS_TYPE = v_enum()
PF_FILE_ACCESS_TYPE.PfFileAccessTypeRead = 0
PF_FILE_ACCESS_TYPE.PfFileAccessTypeWrite = 1
PF_FILE_ACCESS_TYPE.PfFileAccessTypeMax = 2


HARDWARE_COUNTER_TYPE = v_enum()
HARDWARE_COUNTER_TYPE.PMCCounter = 0
HARDWARE_COUNTER_TYPE.MaxHardwareCounterType = 1


ReplacesCorHdrNumericDefines = v_enum()
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY = 1
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED = 2
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY = 4
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED = 8
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2 = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MINOR = 0
ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB = 1
ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA = 1
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA = 2
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT = 1
ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT = 2
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED = 4
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED = 16
ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE = 32
ReplacesCorHdrNumericDefines.MAX_CLASS_NAME = 1024
ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME = 1024


SYSTEM_POWER_STATE = v_enum()
SYSTEM_POWER_STATE.PowerSystemUnspecified = 0
SYSTEM_POWER_STATE.PowerSystemWorking = 1
SYSTEM_POWER_STATE.PowerSystemSleeping1 = 2
SYSTEM_POWER_STATE.PowerSystemSleeping2 = 3
SYSTEM_POWER_STATE.PowerSystemSleeping3 = 4
SYSTEM_POWER_STATE.PowerSystemHibernate = 5
SYSTEM_POWER_STATE.PowerSystemShutdown = 6
SYSTEM_POWER_STATE.PowerSystemMaximum = 7


MEMORY_CACHING_TYPE_ORIG = v_enum()
MEMORY_CACHING_TYPE_ORIG.MmFrameBufferCached = 2


POWER_ACTION = v_enum()
POWER_ACTION.PowerActionNone = 0
POWER_ACTION.PowerActionReserved = 1
POWER_ACTION.PowerActionSleep = 2
POWER_ACTION.PowerActionHibernate = 3
POWER_ACTION.PowerActionShutdown = 4
POWER_ACTION.PowerActionShutdownReset = 5
POWER_ACTION.PowerActionShutdownOff = 6
POWER_ACTION.PowerActionWarmEject = 7


class KEXECUTE_OPTIONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteDisable = v_uint8()


class _unnamed_9072(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMid = v_uint32()


class IO_PRIORITY_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.ThreadPriority = v_uint32()
        self.PagePriority = v_uint32()
        self.IoPriority = v_uint32()


class SID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.SubAuthorityCount = v_uint8()
        self.IdentifierAuthority = SID_IDENTIFIER_AUTHORITY()
        self.SubAuthority = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class WHEA_ERROR_PACKET_V2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Version = v_uint32()
        self.Length = v_uint32()
        self.Flags = WHEA_ERROR_PACKET_FLAGS()
        self.ErrorType = v_uint32()
        self.ErrorSeverity = v_uint32()
        self.ErrorSourceId = v_uint32()
        self.ErrorSourceType = v_uint32()
        self.NotifyType = GUID()
        self.Context = v_uint64()
        self.DataFormat = v_uint32()
        self.Reserved1 = v_uint32()
        self.DataOffset = v_uint32()
        self.DataLength = v_uint32()
        self.PshedDataOffset = v_uint32()
        self.PshedDataLength = v_uint32()


class GROUP_AFFINITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint32()
        self.Group = v_uint16()
        self.Reserved = vstruct.VArray([ v_uint16() for i in xrange(3) ])


class _unnamed_8002(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()


class KTSS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Backlink = v_uint16()
        self.Reserved0 = v_uint16()
        self.Esp0 = v_uint32()
        self.Ss0 = v_uint16()
        self.Reserved1 = v_uint16()
        self.NotUsed1 = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.CR3 = v_uint32()
        self.Eip = v_uint32()
        self.EFlags = v_uint32()
        self.Eax = v_uint32()
        self.Ecx = v_uint32()
        self.Edx = v_uint32()
        self.Ebx = v_uint32()
        self.Esp = v_uint32()
        self.Ebp = v_uint32()
        self.Esi = v_uint32()
        self.Edi = v_uint32()
        self.Es = v_uint16()
        self.Reserved2 = v_uint16()
        self.Cs = v_uint16()
        self.Reserved3 = v_uint16()
        self.Ss = v_uint16()
        self.Reserved4 = v_uint16()
        self.Ds = v_uint16()
        self.Reserved5 = v_uint16()
        self.Fs = v_uint16()
        self.Reserved6 = v_uint16()
        self.Gs = v_uint16()
        self.Reserved7 = v_uint16()
        self.LDT = v_uint16()
        self.Reserved8 = v_uint16()
        self.Flags = v_uint16()
        self.IoMapBase = v_uint16()
        self.IoMaps = vstruct.VArray([ KiIoAccessMap() for i in xrange(1) ])
        self.IntDirectionMap = vstruct.VArray([ v_uint8() for i in xrange(32) ])


class CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DosPath = UNICODE_STRING()
        self.Handle = v_ptr32()


class PERFINFO_GROUPMASK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Masks = vstruct.VArray([ v_uint32() for i in xrange(8) ])


class HANDLE_TABLE_ENTRY_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AuditMask = v_uint32()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SectionOffset = v_uint32()
        self.SectionLength = v_uint32()
        self.Revision = WHEA_REVISION()
        self.ValidBits = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS()
        self.Reserved = v_uint8()
        self.Flags = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS()
        self.SectionType = GUID()
        self.FRUId = GUID()
        self.SectionSeverity = v_uint32()
        self.FRUText = vstruct.VArray([ v_uint8() for i in xrange(20) ])


class PS_CPU_QUOTA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.SessionId = v_uint32()
        self.CpuShareWeight = v_uint32()
        self.CapturedWeightData = PSP_CPU_SHARE_CAPTURED_WEIGHT_DATA()
        self.DuplicateInputMarker = v_uint32()
        self._pad0040 = v_bytes(size=36)
        self.CycleCredit = v_uint64()
        self.BlockCurrentGeneration = v_uint32()
        self.CpuCyclePercent = v_uint32()
        self.CyclesFinishedForCurrentGeneration = v_uint8()
        self._pad0080 = v_bytes(size=47)
        self.Cpu = vstruct.VArray([ PS_PER_CPU_QUOTA_CACHE_AWARE() for i in xrange(32) ])


class RTL_TRACE_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint32()
        self.Database = v_ptr32()
        self.NextSegment = v_ptr32()
        self.TotalSize = v_uint32()
        self.SegmentStart = v_ptr32()
        self.SegmentEnd = v_ptr32()
        self.SegmentFree = v_ptr32()


class _unnamed_9787(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EndingOffset = v_ptr32()
        self.ResourceToRelease = v_ptr32()


class CM_PARTIAL_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.PartialDescriptors = vstruct.VArray([ CM_PARTIAL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class _unnamed_9788(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ResourceToRelease = v_ptr32()


class DEVICE_CAPABILITIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.DeviceD1 = v_uint32()
        self.Address = v_uint32()
        self.UINumber = v_uint32()
        self.DeviceState = vstruct.VArray([ DEVICE_POWER_STATE() for i in xrange(7) ])
        self.SystemWake = v_uint32()
        self.DeviceWake = v_uint32()
        self.D1Latency = v_uint32()
        self.D2Latency = v_uint32()
        self.D3Latency = v_uint32()


class _unnamed_5734(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFunction = v_uint32()


class _unnamed_5731(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()


class RTL_BALANCED_LINKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parent = v_ptr32()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.Balance = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])


class KPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.ProfileListHead = LIST_ENTRY()
        self.DirectoryTableBase = v_uint32()
        self.LdtDescriptor = KGDTENTRY()
        self.Int21Descriptor = KIDTENTRY()
        self.ThreadListHead = LIST_ENTRY()
        self.ProcessLock = v_uint32()
        self.Affinity = KAFFINITY_EX()
        self.ReadyListHead = LIST_ENTRY()
        self.SwapListEntry = SINGLE_LIST_ENTRY()
        self.ActiveProcessors = KAFFINITY_EX()
        self.AutoAlignment = v_uint32()
        self.BasePriority = v_uint8()
        self.QuantumReset = v_uint8()
        self.Visited = v_uint8()
        self.Unused3 = v_uint8()
        self.ThreadSeed = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.IdealNode = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self.IdealGlobalNode = v_uint16()
        self.Flags = KEXECUTE_OPTIONS()
        self.Unused1 = v_uint8()
        self.IopmOffset = v_uint16()
        self.Unused4 = v_uint32()
        self.StackCount = KSTACK_COUNT()
        self.ProcessListEntry = LIST_ENTRY()
        self.CycleTime = v_uint64()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.VdmTrapcHandler = v_ptr32()
        self._pad0098 = v_bytes(size=4)


class DEVICE_OBJECT_POWER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_7305(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self._pad0028 = v_bytes(size=32)


class _unnamed_7909(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.CompletionFilter = v_uint32()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Primary = v_uint32()


class TP_CALLBACK_ENVIRON_V3(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint32()
        self.Pool = v_ptr32()
        self.CleanupGroup = v_ptr32()
        self.CleanupGroupCancelCallback = v_ptr32()
        self.RaceDll = v_ptr32()
        self.ActivationContext = v_ptr32()
        self.FinalizationCallback = v_ptr32()
        self.u = _unnamed_5731()
        self.CallbackPriority = v_uint32()
        self.Size = v_uint32()


class _unnamed_7903(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileName = v_ptr32()
        self.FileInformationClass = v_uint32()
        self.FileIndex = v_uint32()


class WHEA_ERROR_PACKET_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousError = v_uint32()


class ALPC_PROCESS_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = EX_PUSH_LOCK()
        self.ViewListHead = LIST_ENTRY()
        self.PagedPoolQuotaCache = v_uint32()


class OBJECT_HANDLE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleAttributes = v_uint32()
        self.GrantedAccess = v_uint32()


class HEAP_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = _unnamed_8613()


class KTIMER_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint32()
        self.Entry = LIST_ENTRY()
        self._pad0010 = v_bytes(size=4)
        self.Time = ULARGE_INTEGER()


class PS_CLIENT_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImpersonationData = v_uint32()


class RTL_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = RTL_BALANCED_LINKS()
        self.OrderedPointer = v_ptr32()
        self.WhichOrderedElement = v_uint32()
        self.NumberGenericTableElements = v_uint32()
        self.DepthOfTree = v_uint32()
        self.RestartKey = v_ptr32()
        self.DeleteCount = v_uint32()
        self.CompareRoutine = v_ptr32()
        self.AllocateRoutine = v_ptr32()
        self.FreeRoutine = v_ptr32()
        self.TableContext = v_ptr32()


class RTL_TRACE_DATABASE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint32()
        self.Flags = v_uint32()
        self.Tag = v_uint32()
        self.SegmentList = v_ptr32()
        self.MaximumSize = v_uint32()
        self.CurrentSize = v_uint32()
        self.Owner = v_ptr32()
        self.Lock = RTL_CRITICAL_SECTION()
        self.NoOfBuckets = v_uint32()
        self.Buckets = v_ptr32()
        self.HashFunction = v_ptr32()
        self.NoOfTraces = v_uint32()
        self.NoOfHits = v_uint32()
        self.HashCounter = vstruct.VArray([ v_uint32() for i in xrange(16) ])


class OWNER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerThread = v_uint32()
        self.IoPriorityBoosted = v_uint32()


class DEVOBJ_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.PowerFlags = v_uint32()
        self.Dope = v_ptr32()
        self.ExtensionFlags = v_uint32()
        self.DeviceNode = v_ptr32()
        self.AttachedTo = v_ptr32()
        self.StartIoCount = v_uint32()
        self.StartIoKey = v_uint32()
        self.StartIoFlags = v_uint32()
        self.Vpb = v_ptr32()
        self.DependentList = LIST_ENTRY()
        self.ProviderList = LIST_ENTRY()


class HEAP_LOCAL_SEGMENT_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Hint = v_ptr32()
        self.ActiveSubsegment = v_ptr32()
        self.CachedItems = vstruct.VArray([ v_ptr32() for i in xrange(16) ])
        self.SListHeader = SLIST_HEADER()
        self.Counters = HEAP_BUCKET_COUNTERS()
        self.LocalData = v_ptr32()
        self.LastOpSequence = v_uint32()
        self.BucketIndex = v_uint16()
        self.LastUsed = v_uint16()
        self._pad0068 = v_bytes(size=4)


class HANDLE_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr32()
        self.GrantedAccess = v_uint32()


class HEAP_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalMemoryReserved = v_uint32()
        self.TotalMemoryCommitted = v_uint32()
        self.TotalMemoryLargeUCR = v_uint32()
        self.TotalSizeInVirtualBlocks = v_uint32()
        self.TotalSegments = v_uint32()
        self.TotalUCRs = v_uint32()
        self.CommittOps = v_uint32()
        self.DeCommitOps = v_uint32()
        self.LockAcquires = v_uint32()
        self.LockCollisions = v_uint32()
        self.CommitRate = v_uint32()
        self.DecommittRate = v_uint32()
        self.CommitFailures = v_uint32()
        self.InBlockCommitFailures = v_uint32()
        self.CompactHeapCalls = v_uint32()
        self.CompactedUCRs = v_uint32()
        self.AllocAndFreeOps = v_uint32()
        self.InBlockDeccommits = v_uint32()
        self.InBlockDeccomitSize = v_uint32()
        self.HighWatermarkSize = v_uint32()
        self.LastPolledSize = v_uint32()


class MAILSLOT_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MailslotQuota = v_uint32()
        self.MaximumMessageSize = v_uint32()
        self.ReadTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0018 = v_bytes(size=7)


class FS_FILTER_CALLBACK_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbackData = v_uint32()
        self.Operation = v_uint8()
        self.Reserved = v_uint8()
        self._pad0008 = v_bytes(size=2)
        self.DeviceObject = v_ptr32()
        self.FileObject = v_ptr32()
        self.Parameters = FS_FILTER_PARAMETERS()


class PPM_IDLE_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DomainMembers = KAFFINITY_EX()
        self.IdleCheck = v_ptr32()
        self.IdleHandler = v_ptr32()
        self.Context = v_ptr32()
        self.Latency = v_uint32()
        self.Power = v_uint32()
        self.TimeCheck = v_uint32()
        self.StateFlags = v_uint32()
        self.PromotePercent = v_uint8()
        self.DemotePercent = v_uint8()
        self.PromotePercentBase = v_uint8()
        self.DemotePercentBase = v_uint8()
        self.StateType = v_uint8()
        self._pad0030 = v_bytes(size=3)


class _unnamed_9730(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length40 = v_uint32()


class _unnamed_9733(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length48 = v_uint32()


class ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OperationID = LUID()
        self.SecurityEvaluated = v_uint8()
        self.GenerateAudit = v_uint8()
        self.GenerateOnClose = v_uint8()
        self.PrivilegesAllocated = v_uint8()
        self.Flags = v_uint32()
        self.RemainingDesiredAccess = v_uint32()
        self.PreviouslyGrantedAccess = v_uint32()
        self.OriginalDesiredAccess = v_uint32()
        self.SubjectSecurityContext = SECURITY_SUBJECT_CONTEXT()
        self.SecurityDescriptor = v_ptr32()
        self.AuxData = v_ptr32()
        self.Privileges = _unnamed_7641()
        self.AuditPrivileges = v_uint8()
        self._pad0064 = v_bytes(size=3)
        self.ObjectName = UNICODE_STRING()
        self.ObjectTypeName = UNICODE_STRING()


class _unnamed_9736(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length64 = v_uint32()


class TP_CALLBACK_INSTANCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class PROC_IDLE_ACCOUNTING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StateCount = v_uint32()
        self.TotalTransitions = v_uint32()
        self.ResetCount = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.StartTime = v_uint64()
        self.BucketLimits = vstruct.VArray([ v_uint64() for i in xrange(16) ])
        self.State = vstruct.VArray([ PROC_IDLE_STATE_ACCOUNTING() for i in xrange(1) ])


class GDI_TEB_BATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.HDC = v_uint32()
        self.Buffer = vstruct.VArray([ v_uint32() for i in xrange(310) ])


class THREAD_PERFORMANCE_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.ProcessorNumber = PROCESSOR_NUMBER()
        self.ContextSwitches = v_uint32()
        self.HwCountersCount = v_uint32()
        self.UpdateCount = v_uint64()
        self.WaitReasonBitMap = v_uint64()
        self.HardwareCounters = v_uint64()
        self.CycleTime = COUNTER_READING()
        self.HwCounters = vstruct.VArray([ COUNTER_READING() for i in xrange(16) ])


class PAGEFAULT_HISTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ECP_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_7641(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InitialPrivilegeSet = INITIAL_PRIVILEGE_SET()


class SECTION_OBJECT_POINTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSectionObject = v_ptr32()
        self.SharedCacheMap = v_ptr32()
        self.ImageSectionObject = v_ptr32()


class MDL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Size = v_uint16()
        self.MdlFlags = v_uint16()
        self.Process = v_ptr32()
        self.MappedSystemVa = v_ptr32()
        self.StartVa = v_ptr32()
        self.ByteCount = v_uint32()
        self.ByteOffset = v_uint32()


class KTRAP_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DbgEbp = v_uint32()
        self.DbgEip = v_uint32()
        self.DbgArgMark = v_uint32()
        self.DbgArgPointer = v_uint32()
        self.TempSegCs = v_uint16()
        self.Logging = v_uint8()
        self.Reserved = v_uint8()
        self.TempEsp = v_uint32()
        self.Dr0 = v_uint32()
        self.Dr1 = v_uint32()
        self.Dr2 = v_uint32()
        self.Dr3 = v_uint32()
        self.Dr6 = v_uint32()
        self.Dr7 = v_uint32()
        self.SegGs = v_uint32()
        self.SegEs = v_uint32()
        self.SegDs = v_uint32()
        self.Edx = v_uint32()
        self.Ecx = v_uint32()
        self.Eax = v_uint32()
        self.PreviousPreviousMode = v_uint32()
        self.ExceptionList = v_ptr32()
        self.SegFs = v_uint32()
        self.Edi = v_uint32()
        self.Esi = v_uint32()
        self.Ebx = v_uint32()
        self.Ebp = v_uint32()
        self.ErrCode = v_uint32()
        self.Eip = v_uint32()
        self.SegCs = v_uint32()
        self.EFlags = v_uint32()
        self.HardwareEsp = v_uint32()
        self.HardwareSegSs = v_uint32()
        self.V86Es = v_uint32()
        self.V86Ds = v_uint32()
        self.V86Fs = v_uint32()
        self.V86Gs = v_uint32()


class MCI_ADDR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_uint32()
        self.Reserved = v_uint32()


class IO_TIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.TimerFlag = v_uint16()
        self.TimerList = LIST_ENTRY()
        self.TimerRoutine = v_ptr32()
        self.Context = v_ptr32()
        self.DeviceObject = v_ptr32()


class WHEA_REVISION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinorRevision = v_uint8()
        self.MajorRevision = v_uint8()


class _unnamed_10248(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumChannel = v_uint32()
        self.MaximumChannel = v_uint32()


class _unnamed_10241(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumVector = v_uint32()
        self.MaximumVector = v_uint32()
        self.AffinityPolicy = v_uint16()
        self.Group = v_uint16()
        self.PriorityPolicy = v_uint32()
        self.TargetedProcessors = v_uint32()


class TP_CLEANUP_GROUP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class PROC_IDLE_SNAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Time = v_uint64()
        self.Idle = v_uint64()


class _unnamed_7705(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MasterIrp = v_ptr32()


class SECURITY_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.Sbz1 = v_uint8()
        self.Control = v_uint16()
        self.Owner = v_ptr32()
        self.Group = v_ptr32()
        self.Sacl = v_ptr32()
        self.Dacl = v_ptr32()


class _unnamed_7708(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsynchronousParameters = _unnamed_7723()


class OBJECT_TYPE_INITIALIZER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.ObjectTypeFlags = v_uint8()
        self._pad0004 = v_bytes(size=1)
        self.ObjectTypeCode = v_uint32()
        self.InvalidAttributes = v_uint32()
        self.GenericMapping = GENERIC_MAPPING()
        self.ValidAccessMask = v_uint32()
        self.RetainAccess = v_uint32()
        self.PoolType = v_uint32()
        self.DefaultPagedPoolCharge = v_uint32()
        self.DefaultNonPagedPoolCharge = v_uint32()
        self.DumpProcedure = v_ptr32()
        self.OpenProcedure = v_ptr32()
        self.CloseProcedure = v_ptr32()
        self.DeleteProcedure = v_ptr32()
        self.ParseProcedure = v_ptr32()
        self.SecurityProcedure = v_ptr32()
        self.QueryNameProcedure = v_ptr32()
        self.OkayToCloseProcedure = v_ptr32()


class TP_DIRECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callback = v_ptr32()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()
        self._pad000c = v_bytes(size=3)


class XSTATE_SAVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved1 = v_uint64()
        self.Reserved2 = v_uint32()
        self.Prev = v_ptr32()
        self.Reserved3 = v_ptr32()
        self.Thread = v_ptr32()
        self.Reserved4 = v_ptr32()
        self.Level = v_uint8()
        self._pad0020 = v_bytes(size=3)


class HEAP_ENTRY_EXTRA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatorBackTraceIndex = v_uint16()
        self.TagIndex = v_uint16()
        self.Settable = v_uint32()


class HEAP_PSEUDO_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint32()


class PAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = FAST_MUTEX()
        self._pad00c0 = v_bytes(size=32)


class LARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class NPAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = v_uint32()
        self._pad00c0 = v_bytes(size=60)


class _unnamed_5688(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class _unnamed_7823(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self.Parameters = v_ptr32()


class VPB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.Flags = v_uint16()
        self.VolumeLabelLength = v_uint16()
        self.DeviceObject = v_ptr32()
        self.RealDevice = v_ptr32()
        self.SerialNumber = v_uint32()
        self.ReferenceCount = v_uint32()
        self.VolumeLabel = vstruct.VArray([ v_uint16() for i in xrange(32) ])


class PP_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P = v_ptr32()
        self.L = v_ptr32()


class OBJECT_NAME_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = UNICODE_STRING()


class IO_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.Descriptors = vstruct.VArray([ IO_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class KUSER_SHARED_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TickCountLowDeprecated = v_uint32()
        self.TickCountMultiplier = v_uint32()
        self.InterruptTime = KSYSTEM_TIME()
        self.SystemTime = KSYSTEM_TIME()
        self.TimeZoneBias = KSYSTEM_TIME()
        self.ImageNumberLow = v_uint16()
        self.ImageNumberHigh = v_uint16()
        self.NtSystemRoot = vstruct.VArray([ v_uint16() for i in xrange(260) ])
        self.MaxStackTraceDepth = v_uint32()
        self.CryptoExponent = v_uint32()
        self.TimeZoneId = v_uint32()
        self.LargePageMinimum = v_uint32()
        self.Reserved2 = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self.NtProductType = v_uint32()
        self.ProductTypeIsValid = v_uint8()
        self._pad026c = v_bytes(size=3)
        self.NtMajorVersion = v_uint32()
        self.NtMinorVersion = v_uint32()
        self.ProcessorFeatures = vstruct.VArray([ v_uint8() for i in xrange(64) ])
        self.Reserved1 = v_uint32()
        self.Reserved3 = v_uint32()
        self.TimeSlip = v_uint32()
        self.AlternativeArchitecture = v_uint32()
        self.AltArchitecturePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.SystemExpirationDate = LARGE_INTEGER()
        self.SuiteMask = v_uint32()
        self.KdDebuggerEnabled = v_uint8()
        self.NXSupportPolicy = v_uint8()
        self._pad02d8 = v_bytes(size=2)
        self.ActiveConsoleId = v_uint32()
        self.DismountCount = v_uint32()
        self.ComPlusPackage = v_uint32()
        self.LastSystemRITEventTickCount = v_uint32()
        self.NumberOfPhysicalPages = v_uint32()
        self.SafeBootMode = v_uint8()
        self.TscQpcData = v_uint8()
        self.TscQpcPad = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.SharedDataFlags = v_uint32()
        self.DataFlagsPad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.TestRetInstruction = v_uint64()
        self.SystemCall = v_uint32()
        self.SystemCallReturn = v_uint32()
        self.SystemCallPad = vstruct.VArray([ v_uint64() for i in xrange(3) ])
        self.TickCount = KSYSTEM_TIME()
        self.TickCountPad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.Cookie = v_uint32()
        self.CookiePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.ConsoleSessionForegroundProcessId = v_uint64()
        self.Wow64SharedInformation = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.UserModeGlobalLogger = vstruct.VArray([ v_uint16() for i in xrange(16) ])
        self.ImageFileExecutionOptions = v_uint32()
        self.LangGenerationCount = v_uint32()
        self.Reserved5 = v_uint64()
        self.InterruptTimeBias = v_uint64()
        self.TscQpcBias = v_uint64()
        self.ActiveProcessorCount = v_uint32()
        self.ActiveGroupCount = v_uint16()
        self.Reserved4 = v_uint16()
        self.AitSamplingValue = v_uint32()
        self.AppCompatFlag = v_uint32()
        self.SystemDllNativeRelocation = v_uint64()
        self.SystemDllWowRelocation = v_uint32()
        self.XStatePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.XState = XSTATE_CONFIGURATION()


class SYSTEM_POWER_STATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved1 = v_uint32()


class FS_FILTER_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AcquireForModifiedPageWriter = _unnamed_9787()
        self._pad0014 = v_bytes(size=12)


class HEAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.SegmentSignature = v_uint32()
        self.SegmentFlags = v_uint32()
        self.SegmentListEntry = LIST_ENTRY()
        self.Heap = v_ptr32()
        self.BaseAddress = v_ptr32()
        self.NumberOfPages = v_uint32()
        self.FirstEntry = v_ptr32()
        self.LastValidEntry = v_ptr32()
        self.NumberOfUnCommittedPages = v_uint32()
        self.NumberOfUnCommittedRanges = v_uint32()
        self.SegmentAllocatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self.UCRSegmentList = LIST_ENTRY()
        self.Flags = v_uint32()
        self.ForceFlags = v_uint32()
        self.CompatibilityFlags = v_uint32()
        self.EncodeFlagMask = v_uint32()
        self.Encoding = HEAP_ENTRY()
        self.PointerKey = v_uint32()
        self.Interceptor = v_uint32()
        self.VirtualMemoryThreshold = v_uint32()
        self.Signature = v_uint32()
        self.SegmentReserve = v_uint32()
        self.SegmentCommit = v_uint32()
        self.DeCommitFreeBlockThreshold = v_uint32()
        self.DeCommitTotalFreeThreshold = v_uint32()
        self.TotalFreeSize = v_uint32()
        self.MaximumAllocationSize = v_uint32()
        self.ProcessHeapsListIndex = v_uint16()
        self.HeaderValidateLength = v_uint16()
        self.HeaderValidateCopy = v_ptr32()
        self.NextAvailableTagIndex = v_uint16()
        self.MaximumTagIndex = v_uint16()
        self.TagEntries = v_ptr32()
        self.UCRList = LIST_ENTRY()
        self.AlignRound = v_uint32()
        self.AlignMask = v_uint32()
        self.VirtualAllocdBlocks = LIST_ENTRY()
        self.SegmentList = LIST_ENTRY()
        self.AllocatorBackTraceIndex = v_uint16()
        self._pad00b4 = v_bytes(size=2)
        self.NonDedicatedListLength = v_uint32()
        self.BlocksIndex = v_ptr32()
        self.UCRIndex = v_ptr32()
        self.PseudoTagEntries = v_ptr32()
        self.FreeLists = LIST_ENTRY()
        self.LockVariable = v_ptr32()
        self.CommitRoutine = v_ptr32()
        self.FrontEndHeap = v_ptr32()
        self.FrontHeapLockCount = v_uint16()
        self.FrontEndHeapType = v_uint8()
        self._pad00dc = v_bytes(size=1)
        self.Counters = HEAP_COUNTERS()
        self.TuningParameters = HEAP_TUNING_PARAMETERS()


class IO_STATUS_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.Information = v_uint32()


class PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(1) ])


class CM_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.List = vstruct.VArray([ CM_FULL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class EPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pcb = KPROCESS()
        self.ProcessLock = EX_PUSH_LOCK()
        self._pad00a0 = v_bytes(size=4)
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.UniqueProcessId = v_ptr32()
        self.ActiveProcessLinks = LIST_ENTRY()
        self.ProcessQuotaUsage = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ProcessQuotaPeak = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.CommitCharge = v_uint32()
        self.QuotaBlock = v_ptr32()
        self.CpuQuotaBlock = v_ptr32()
        self.PeakVirtualSize = v_uint32()
        self.VirtualSize = v_uint32()
        self.SessionProcessLinks = LIST_ENTRY()
        self.DebugPort = v_ptr32()
        self.ExceptionPortData = v_ptr32()
        self.ObjectTable = v_ptr32()
        self.Token = EX_FAST_REF()
        self.WorkingSetPage = v_uint32()
        self.AddressCreationLock = EX_PUSH_LOCK()
        self.RotateInProgress = v_ptr32()
        self.ForkInProgress = v_ptr32()
        self.HardwareTrigger = v_uint32()
        self.PhysicalVadRoot = v_ptr32()
        self.CloneRoot = v_ptr32()
        self.NumberOfPrivatePages = v_uint32()
        self.NumberOfLockedPages = v_uint32()
        self.Win32Process = v_ptr32()
        self.Job = v_ptr32()
        self.SectionObject = v_ptr32()
        self.SectionBaseAddress = v_ptr32()
        self.Cookie = v_uint32()
        self.Spare8 = v_uint32()
        self.WorkingSetWatch = v_ptr32()
        self.Win32WindowStation = v_ptr32()
        self.InheritedFromUniqueProcessId = v_ptr32()
        self.LdtInformation = v_ptr32()
        self.VdmObjects = v_ptr32()
        self.ConsoleHostProcess = v_uint32()
        self.DeviceMap = v_ptr32()
        self.EtwDataSource = v_ptr32()
        self.FreeTebHint = v_ptr32()
        self._pad0160 = v_bytes(size=4)
        self.PageDirectoryPte = HARDWARE_PTE_X86()
        self._pad0168 = v_bytes(size=4)
        self.Session = v_ptr32()
        self.ImageFileName = vstruct.VArray([ v_uint8() for i in xrange(15) ])
        self.PriorityClass = v_uint8()
        self.JobLinks = LIST_ENTRY()
        self.LockedPagesList = v_ptr32()
        self.ThreadListHead = LIST_ENTRY()
        self.SecurityPort = v_ptr32()
        self.PaeTop = v_ptr32()
        self.ActiveThreads = v_uint32()
        self.ImagePathHash = v_uint32()
        self.DefaultHardErrorProcessing = v_uint32()
        self.LastThreadExitStatus = v_uint32()
        self.Peb = v_ptr32()
        self.PrefetchTrace = EX_FAST_REF()
        self.ReadOperationCount = LARGE_INTEGER()
        self.WriteOperationCount = LARGE_INTEGER()
        self.OtherOperationCount = LARGE_INTEGER()
        self.ReadTransferCount = LARGE_INTEGER()
        self.WriteTransferCount = LARGE_INTEGER()
        self.OtherTransferCount = LARGE_INTEGER()
        self.CommitChargeLimit = v_uint32()
        self.CommitChargePeak = v_uint32()
        self.AweInfo = v_ptr32()
        self.SeAuditProcessCreationInfo = SE_AUDIT_PROCESS_CREATION_INFO()
        self.Vm = MMSUPPORT()
        self.MmProcessLinks = LIST_ENTRY()
        self.HighestUserAddress = v_ptr32()
        self.ModifiedPageCount = v_uint32()
        self.Flags2 = v_uint32()
        self.Flags = v_uint32()
        self.ExitStatus = v_uint32()
        self.VadRoot = MM_AVL_TABLE()
        self.AlpcContext = ALPC_PROCESS_CONTEXT()
        self.TimerResolutionLink = LIST_ENTRY()
        self.RequestedTimerResolution = v_uint32()
        self.ActiveThreadsHighWatermark = v_uint32()
        self.SmallestTimerResolution = v_uint32()
        self.TimerResolutionStackRecord = v_ptr32()


class TP_TASK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callbacks = v_ptr32()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()
        self._pad000c = v_bytes(size=3)
        self.PostGuard = TP_NBQ_GUARD()
        self.NBQNode = v_ptr32()


class TEB_ACTIVE_FRAME_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.FrameName = v_ptr32()


class KTIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.DueTime = ULARGE_INTEGER()
        self.TimerListEntry = LIST_ENTRY()
        self.Dpc = v_ptr32()
        self.Period = v_uint32()


class _unnamed_7955(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self.InputBufferLength = v_uint32()
        self.IoControlCode = v_uint32()
        self.Type3InputBuffer = v_ptr32()


class _unnamed_7950(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_ptr32()
        self.Key = v_uint32()
        self.ByteOffset = LARGE_INTEGER()


class CM_PARTIAL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Flags = v_uint16()
        self.u = _unnamed_9480()


class _unnamed_8913(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FilePointerIndex = v_uint32()


class OBJECT_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.RootDirectory = v_ptr32()
        self.ObjectName = v_ptr32()
        self.Attributes = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.SecurityQualityOfService = v_ptr32()


class _unnamed_8084(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdType = v_uint32()


class CM_FULL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.PartialResourceList = CM_PARTIAL_RESOURCE_LIST()


class KTIMER_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TimerExpiry = vstruct.VArray([ v_ptr32() for i in xrange(16) ])
        self.TimerEntries = vstruct.VArray([ KTIMER_TABLE_ENTRY() for i in xrange(256) ])


class _unnamed_8089(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceTextType = v_uint32()
        self.LocaleId = v_uint32()


class _unnamed_8162(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr32()
        self.Argument2 = v_ptr32()
        self.Argument3 = v_ptr32()
        self.Argument4 = v_ptr32()


class FAST_IO_DISPATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFastIoDispatch = v_uint32()
        self.FastIoCheckIfPossible = v_ptr32()
        self.FastIoRead = v_ptr32()
        self.FastIoWrite = v_ptr32()
        self.FastIoQueryBasicInfo = v_ptr32()
        self.FastIoQueryStandardInfo = v_ptr32()
        self.FastIoLock = v_ptr32()
        self.FastIoUnlockSingle = v_ptr32()
        self.FastIoUnlockAll = v_ptr32()
        self.FastIoUnlockAllByKey = v_ptr32()
        self.FastIoDeviceControl = v_ptr32()
        self.AcquireFileForNtCreateSection = v_ptr32()
        self.ReleaseFileForNtCreateSection = v_ptr32()
        self.FastIoDetachDevice = v_ptr32()
        self.FastIoQueryNetworkOpenInfo = v_ptr32()
        self.AcquireForModWrite = v_ptr32()
        self.MdlRead = v_ptr32()
        self.MdlReadComplete = v_ptr32()
        self.PrepareMdlWrite = v_ptr32()
        self.MdlWriteComplete = v_ptr32()
        self.FastIoReadCompressed = v_ptr32()
        self.FastIoWriteCompressed = v_ptr32()
        self.MdlReadCompleteCompressed = v_ptr32()
        self.MdlWriteCompleteCompressed = v_ptr32()
        self.FastIoQueryOpen = v_ptr32()
        self.ReleaseForModWrite = v_ptr32()
        self.AcquireForCcFlush = v_ptr32()
        self.ReleaseForCcFlush = v_ptr32()


class RTL_DYNAMIC_HASH_TABLE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ChainHead = v_ptr32()
        self.PrevLinkage = v_ptr32()
        self.Signature = v_uint32()


class MMWSL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class PROC_IDLE_STATE_ACCOUNTING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalTime = v_uint64()
        self.IdleTransitions = v_uint32()
        self.FailedTransitions = v_uint32()
        self.InvalidBucketIndex = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.MinTime = v_uint64()
        self.MaxTime = v_uint64()
        self.IdleTimeBuckets = vstruct.VArray([ PROC_IDLE_STATE_BUCKET() for i in xrange(16) ])


class _unnamed_9708(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.MessageCount = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint32()


class _unnamed_9067(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMid = v_uint8()
        self.Flags1 = v_uint8()
        self.Flags2 = v_uint8()
        self.BaseHi = v_uint8()


class _unnamed_9700(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length = v_uint32()


class _unnamed_9703(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint16()
        self.Group = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint32()


class KSPECIAL_REGISTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cr0 = v_uint32()
        self.Cr2 = v_uint32()
        self.Cr3 = v_uint32()
        self.Cr4 = v_uint32()
        self.KernelDr0 = v_uint32()
        self.KernelDr1 = v_uint32()
        self.KernelDr2 = v_uint32()
        self.KernelDr3 = v_uint32()
        self.KernelDr6 = v_uint32()
        self.KernelDr7 = v_uint32()
        self.Gdtr = DESCRIPTOR()
        self.Idtr = DESCRIPTOR()
        self.Tr = v_uint16()
        self.Ldtr = v_uint16()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(6) ])


class RTL_CRITICAL_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DebugInfo = v_ptr32()
        self.LockCount = v_uint32()
        self.RecursionCount = v_uint32()
        self.OwningThread = v_ptr32()
        self.LockSemaphore = v_ptr32()
        self.SpinCount = v_uint32()


class KSYSTEM_TIME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.High1Time = v_uint32()
        self.High2Time = v_uint32()


class PROC_IDLE_STATE_BUCKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalTime = v_uint64()
        self.MinTime = v_uint64()
        self.MaxTime = v_uint64()
        self.Count = v_uint32()
        self._pad0020 = v_bytes(size=4)


class RTL_STD_LIST_HEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Lock = RTL_STACK_DATABASE_LOCK()


class FLOATING_SAVE_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint32()
        self.StatusWord = v_uint32()
        self.TagWord = v_uint32()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint32()
        self.RegisterArea = vstruct.VArray([ v_uint8() for i in xrange(80) ])
        self.Cr0NpxState = v_uint32()


class DPH_HEAP_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pNextAlloc = v_ptr32()
        self._pad0010 = v_bytes(size=12)
        self.pUserAllocation = v_ptr32()
        self.pVirtualBlock = v_ptr32()
        self.nVirtualBlockSize = v_uint32()
        self.nVirtualAccessSize = v_uint32()
        self.nUserRequestedSize = v_uint32()
        self.nUserActualSize = v_uint32()
        self.UserValue = v_ptr32()
        self.UserFlags = v_uint32()
        self.StackTrace = v_ptr32()
        self.AdjacencyEntry = LIST_ENTRY()
        self.pVirtualRegion = v_ptr32()


class KQUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.EntryListHead = LIST_ENTRY()
        self.CurrentCount = v_uint32()
        self.MaximumCount = v_uint32()
        self.ThreadListHead = LIST_ENTRY()


class _unnamed_7745(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Create = _unnamed_7807()


class LUID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Luid = LUID()
        self.Attributes = v_uint32()


class _unnamed_8011(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_ptr32()
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Interface = v_ptr32()
        self.InterfaceSpecificData = v_ptr32()


class HEAP_BUCKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BlockUnits = v_uint16()
        self.SizeIndex = v_uint8()
        self.UseAffinity = v_uint8()


class _unnamed_9789(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SyncType = v_uint32()
        self.PageProtection = v_uint32()


class KTHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.CycleTime = v_uint64()
        self.HighCycleTime = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.QuantumTarget = v_uint64()
        self.InitialStack = v_ptr32()
        self.StackLimit = v_ptr32()
        self.KernelStack = v_ptr32()
        self.ThreadLock = v_uint32()
        self.WaitRegister = KWAIT_STATUS_REGISTER()
        self.Running = v_uint8()
        self.Alerted = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.KernelStackResident = v_uint32()
        self.ApcState = KAPC_STATE()
        self.NextProcessor = v_uint32()
        self.DeferredProcessor = v_uint32()
        self.ApcQueueLock = v_uint32()
        self.ContextSwitches = v_uint32()
        self.State = v_uint8()
        self.NpxState = v_uint8()
        self.WaitIrql = v_uint8()
        self.WaitMode = v_uint8()
        self.WaitStatus = v_uint32()
        self.WaitBlockList = v_ptr32()
        self.WaitListEntry = LIST_ENTRY()
        self.Queue = v_ptr32()
        self.WaitTime = v_uint32()
        self.KernelApcDisable = v_uint16()
        self.SpecialApcDisable = v_uint16()
        self.Teb = v_ptr32()
        self._pad0090 = v_bytes(size=4)
        self.Timer = KTIMER()
        self.AutoAlignment = v_uint32()
        self.ServiceTable = v_ptr32()
        self.WaitBlock = vstruct.VArray([ KWAIT_BLOCK() for i in xrange(4) ])
        self.QueueListEntry = LIST_ENTRY()
        self.TrapFrame = v_ptr32()
        self.FirstArgument = v_ptr32()
        self.CallbackStack = v_ptr32()
        self.ApcStateIndex = v_uint8()
        self.BasePriority = v_uint8()
        self.PriorityDecrement = v_uint8()
        self.Preempted = v_uint8()
        self.AdjustReason = v_uint8()
        self.AdjustIncrement = v_uint8()
        self.PreviousMode = v_uint8()
        self.Saturation = v_uint8()
        self.SystemCallNumber = v_uint32()
        self.FreezeCount = v_uint32()
        self.UserAffinity = GROUP_AFFINITY()
        self.Process = v_ptr32()
        self.Affinity = GROUP_AFFINITY()
        self.IdealProcessor = v_uint32()
        self.UserIdealProcessor = v_uint32()
        self.ApcStatePointer = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self.SavedApcState = KAPC_STATE()
        self.SuspendCount = v_uint8()
        self.Spare1 = v_uint8()
        self.OtherPlatformFill = v_uint8()
        self._pad018c = v_bytes(size=1)
        self.Win32Thread = v_ptr32()
        self.StackBase = v_ptr32()
        self.SuspendApc = KAPC()
        self.UserTime = v_uint32()
        self.SuspendSemaphore = KSEMAPHORE()
        self.SListFaultCount = v_uint32()
        self.ThreadListEntry = LIST_ENTRY()
        self.MutantListHead = LIST_ENTRY()
        self.SListFaultAddress = v_ptr32()
        self.ThreadCounters = v_ptr32()
        self.XStateSave = v_ptr32()
        self._pad0200 = v_bytes(size=4)


class _unnamed_8613(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CriticalSection = RTL_CRITICAL_SECTION()


class _unnamed_10231(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Alignment = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class _unnamed_10260(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length40 = v_uint32()
        self.Alignment40 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class PROC_HISTORY_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Utility = v_uint16()
        self.Frequency = v_uint8()
        self.Reserved = v_uint8()


class CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFlags = v_uint32()
        self.Dr0 = v_uint32()
        self.Dr1 = v_uint32()
        self.Dr2 = v_uint32()
        self.Dr3 = v_uint32()
        self.Dr6 = v_uint32()
        self.Dr7 = v_uint32()
        self.FloatSave = FLOATING_SAVE_AREA()
        self.SegGs = v_uint32()
        self.SegFs = v_uint32()
        self.SegEs = v_uint32()
        self.SegDs = v_uint32()
        self.Edi = v_uint32()
        self.Esi = v_uint32()
        self.Ebx = v_uint32()
        self.Edx = v_uint32()
        self.Ecx = v_uint32()
        self.Eax = v_uint32()
        self.Ebp = v_uint32()
        self.Eip = v_uint32()
        self.SegCs = v_uint32()
        self.EFlags = v_uint32()
        self.Esp = v_uint32()
        self.SegSs = v_uint32()
        self.ExtendedRegisters = vstruct.VArray([ v_uint8() for i in xrange(512) ])


class _unnamed_9012(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BankNumber = v_uint8()
        self.Reserved2 = vstruct.VArray([ v_uint8() for i in xrange(7) ])
        self.Status = MCI_STATS()
        self.Address = MCI_ADDR()
        self.Misc = v_uint64()


class MCI_STATS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MciStats = _unnamed_9007()


class _unnamed_9019(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_uint64()
        self.Type = v_uint64()


class _unnamed_9790(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationType = v_uint32()
        self.SafeToRecurse = v_uint8()
        self._pad0008 = v_bytes(size=3)


class _unnamed_9791(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr32()
        self.Argument2 = v_ptr32()
        self.Argument3 = v_ptr32()
        self.Argument4 = v_ptr32()
        self.Argument5 = v_ptr32()


class PROC_PERF_LOAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BusyPercentage = v_uint8()
        self.FrequencyPercentage = v_uint8()


class AUX_ACCESS_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegesUsed = v_ptr32()
        self.GenericMapping = GENERIC_MAPPING()
        self.AccessesToAudit = v_uint32()
        self.MaximumAuditMask = v_uint32()
        self.TransactionId = GUID()
        self.NewSecurityDescriptor = v_ptr32()
        self.ExistingSecurityDescriptor = v_ptr32()
        self.ParentSecurityDescriptor = v_ptr32()
        self.DeRefSecurityDescriptor = v_ptr32()
        self.SDLock = v_ptr32()
        self.AccessReasons = ACCESS_REASONS()


class _unnamed_9496(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Balance = v_uint32()


class HEAP_LOCAL_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeletedSubSegments = SLIST_HEADER()
        self.CrtZone = v_ptr32()
        self.LowFragHeap = v_ptr32()
        self.Sequence = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.SegmentInfo = vstruct.VArray([ HEAP_LOCAL_SEGMENT_INFO() for i in xrange(128) ])


class _unnamed_5701(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class DPH_BLOCK_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartStamp = v_uint32()
        self.Heap = v_ptr32()
        self.RequestedSize = v_uint32()
        self.ActualSize = v_uint32()
        self.FreeQueue = LIST_ENTRY()
        self.StackTrace = v_ptr32()
        self.EndStamp = v_uint32()


class PF_KERNEL_GLOBALS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AccessBufferAgeThreshold = v_uint64()
        self.AccessBufferRef = EX_RUNDOWN_REF()
        self.AccessBufferExistsEvent = KEVENT()
        self.AccessBufferMax = v_uint32()
        self.AccessBufferList = SLIST_HEADER()
        self.StreamSequenceNumber = v_uint32()
        self.Flags = v_uint32()
        self.ScenarioPrefetchCount = v_uint32()
        self._pad0040 = v_bytes(size=12)


class _unnamed_7912(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileInformationClass = v_uint32()


class _unnamed_7915(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileInformationClass = v_uint32()
        self.FileObject = v_ptr32()
        self.ReplaceIfExists = v_uint8()
        self.AdvanceOnly = v_uint8()
        self._pad0010 = v_bytes(size=2)


class EVENT_DATA_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Ptr = v_uint64()
        self.Size = v_uint32()
        self.Reserved = v_uint32()


class KDEVICE_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceListHead = LIST_ENTRY()
        self.Lock = v_uint32()
        self.Busy = v_uint8()
        self._pad0014 = v_bytes(size=3)


class IO_DRIVER_CREATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self._pad0004 = v_bytes(size=2)
        self.ExtraCreateParameter = v_ptr32()
        self.DeviceObjectHint = v_ptr32()
        self.TxnParameters = v_ptr32()


class EJOB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Event = KEVENT()
        self.JobLinks = LIST_ENTRY()
        self.ProcessListHead = LIST_ENTRY()
        self.JobLock = ERESOURCE()
        self.TotalUserTime = LARGE_INTEGER()
        self.TotalKernelTime = LARGE_INTEGER()
        self.ThisPeriodTotalUserTime = LARGE_INTEGER()
        self.ThisPeriodTotalKernelTime = LARGE_INTEGER()
        self.TotalPageFaultCount = v_uint32()
        self.TotalProcesses = v_uint32()
        self.ActiveProcesses = v_uint32()
        self.TotalTerminatedProcesses = v_uint32()
        self.PerProcessUserTimeLimit = LARGE_INTEGER()
        self.PerJobUserTimeLimit = LARGE_INTEGER()
        self.MinimumWorkingSetSize = v_uint32()
        self.MaximumWorkingSetSize = v_uint32()
        self.LimitFlags = v_uint32()
        self.ActiveProcessLimit = v_uint32()
        self.Affinity = KAFFINITY_EX()
        self.PriorityClass = v_uint8()
        self._pad00b8 = v_bytes(size=3)
        self.AccessState = v_ptr32()
        self.UIRestrictionsClass = v_uint32()
        self.EndOfJobTimeAction = v_uint32()
        self.CompletionPort = v_ptr32()
        self.CompletionKey = v_ptr32()
        self.SessionId = v_uint32()
        self.SchedulingClass = v_uint32()
        self._pad00d8 = v_bytes(size=4)
        self.ReadOperationCount = v_uint64()
        self.WriteOperationCount = v_uint64()
        self.OtherOperationCount = v_uint64()
        self.ReadTransferCount = v_uint64()
        self.WriteTransferCount = v_uint64()
        self.OtherTransferCount = v_uint64()
        self.ProcessMemoryLimit = v_uint32()
        self.JobMemoryLimit = v_uint32()
        self.PeakProcessMemoryUsed = v_uint32()
        self.PeakJobMemoryUsed = v_uint32()
        self.CurrentJobMemoryUsed = v_uint64()
        self.MemoryLimitsLock = EX_PUSH_LOCK()
        self.JobSetLinks = LIST_ENTRY()
        self.MemberLevel = v_uint32()
        self.JobFlags = v_uint32()
        self._pad0138 = v_bytes(size=4)


class HANDLE_TRACE_DEBUG_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RefCount = v_uint32()
        self.TableSize = v_uint32()
        self.BitMaskFlags = v_uint32()
        self.CloseCompactionLock = FAST_MUTEX()
        self.CurrentStackIndex = v_uint32()
        self.TraceDb = vstruct.VArray([ HANDLE_TRACE_DB_ENTRY() for i in xrange(1) ])


class KPROCESSOR_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFrame = CONTEXT()
        self.SpecialRegisters = KSPECIAL_REGISTERS()


class KiIoAccessMap(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DirectionMap = vstruct.VArray([ v_uint8() for i in xrange(32) ])
        self.IoMap = vstruct.VArray([ v_uint8() for i in xrange(8196) ])


class KAPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.SpareByte0 = v_uint8()
        self.Size = v_uint8()
        self.SpareByte1 = v_uint8()
        self.SpareLong0 = v_uint32()
        self.Thread = v_ptr32()
        self.ApcListEntry = LIST_ENTRY()
        self.KernelRoutine = v_ptr32()
        self.RundownRoutine = v_ptr32()
        self.NormalRoutine = v_ptr32()
        self.NormalContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.ApcStateIndex = v_uint8()
        self.ApcMode = v_uint8()
        self.Inserted = v_uint8()
        self._pad0030 = v_bytes(size=1)


class RTL_STACK_DATABASE_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = RTL_SRWLOCK()


class SID_IDENTIFIER_AUTHORITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Value = vstruct.VArray([ v_uint8() for i in xrange(6) ])


class XSTATE_FEATURE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.Size = v_uint32()


class WHEA_TIMESTAMP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Seconds = v_uint64()


class ACTIVATION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class RTL_CRITICAL_SECTION_DEBUG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self.CriticalSection = v_ptr32()
        self.ProcessLocksList = LIST_ENTRY()
        self.EntryCount = v_uint32()
        self.ContentionCount = v_uint32()
        self.Flags = v_uint32()
        self.CreatorBackTraceIndexHigh = v_uint16()
        self.SpareUSHORT = v_uint16()


class DISPATCHER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.TimerControlFlags = v_uint8()
        self.ThreadControlFlags = v_uint8()
        self.TimerMiscFlags = v_uint8()
        self.SignalState = v_uint32()
        self.WaitListHead = LIST_ENTRY()


class _unnamed_8053(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Capabilities = v_ptr32()


class PROCESSOR_POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleStates = v_ptr32()
        self._pad0008 = v_bytes(size=4)
        self.IdleTimeLast = v_uint64()
        self.IdleTimeTotal = v_uint64()
        self.IdleTimeEntry = v_uint64()
        self.IdleAccounting = v_ptr32()
        self.Hypervisor = v_uint32()
        self.PerfHistoryTotal = v_uint32()
        self.ThermalConstraint = v_uint8()
        self.PerfHistoryCount = v_uint8()
        self.PerfHistorySlot = v_uint8()
        self.Reserved = v_uint8()
        self.LastSysTime = v_uint32()
        self.WmiDispatchPtr = v_uint32()
        self.WmiInterfaceEnabled = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.FFHThrottleStateInfo = PPM_FFH_THROTTLE_STATE_INFO()
        self.PerfActionDpc = KDPC()
        self.PerfActionMask = v_uint32()
        self._pad0088 = v_bytes(size=4)
        self.IdleCheck = PROC_IDLE_SNAP()
        self.PerfCheck = PROC_IDLE_SNAP()
        self.Domain = v_ptr32()
        self.PerfConstraint = v_ptr32()
        self.Load = v_ptr32()
        self.PerfHistory = v_ptr32()
        self.Utility = v_uint32()
        self.OverUtilizedHistory = v_uint32()
        self.AffinityCount = v_uint32()
        self.AffinityHistory = v_uint32()


class POWER_SEQUENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SequenceD1 = v_uint32()
        self.SequenceD2 = v_uint32()
        self.SequenceD3 = v_uint32()


class _unnamed_8115(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerSequence = v_ptr32()


class DPH_HEAP_ROOT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.HeapFlags = v_uint32()
        self.HeapCritSect = v_ptr32()
        self.nRemoteLockAcquired = v_uint32()
        self.pVirtualStorageListHead = v_ptr32()
        self.pVirtualStorageListTail = v_ptr32()
        self.nVirtualStorageRanges = v_uint32()
        self.nVirtualStorageBytes = v_uint32()
        self.BusyNodesTable = RTL_AVL_TABLE()
        self.NodeToAllocate = v_ptr32()
        self.nBusyAllocations = v_uint32()
        self.nBusyAllocationBytesCommitted = v_uint32()
        self.pFreeAllocationListHead = v_ptr32()
        self.pFreeAllocationListTail = v_ptr32()
        self.nFreeAllocations = v_uint32()
        self.nFreeAllocationBytesCommitted = v_uint32()
        self.AvailableAllocationHead = LIST_ENTRY()
        self.nAvailableAllocations = v_uint32()
        self.nAvailableAllocationBytesCommitted = v_uint32()
        self.pUnusedNodeListHead = v_ptr32()
        self.pUnusedNodeListTail = v_ptr32()
        self.nUnusedNodes = v_uint32()
        self.nBusyAllocationBytesAccessible = v_uint32()
        self.pNodePoolListHead = v_ptr32()
        self.pNodePoolListTail = v_ptr32()
        self.nNodePools = v_uint32()
        self.nNodePoolBytes = v_uint32()
        self.NextHeap = LIST_ENTRY()
        self.ExtraFlags = v_uint32()
        self.Seed = v_uint32()
        self.NormalHeap = v_ptr32()
        self.CreateStackTrace = v_ptr32()
        self.FirstThread = v_ptr32()


class JOB_ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class SECURITY_QUALITY_OF_SERVICE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.ImpersonationLevel = v_uint32()
        self.ContextTrackingMode = v_uint8()
        self.EffectiveOnly = v_uint8()
        self._pad000c = v_bytes(size=2)


class COMPRESSED_DATA_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CompressionFormatAndEngine = v_uint16()
        self.CompressionUnitShift = v_uint8()
        self.ChunkShift = v_uint8()
        self.ClusterShift = v_uint8()
        self.Reserved = v_uint8()
        self.NumberOfChunks = v_uint16()
        self.CompressedChunkSizes = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class _unnamed_10270(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length64 = v_uint32()
        self.Alignment64 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class WHEA_ERROR_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = WHEA_ERROR_RECORD_HEADER()
        self.SectionDescriptor = vstruct.VArray([ WHEA_ERROR_RECORD_SECTION_DESCRIPTOR() for i in xrange(1) ])


class PS_PER_CPU_QUOTA_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SortedListEntry = LIST_ENTRY()
        self.IdleOnlyListHead = LIST_ENTRY()
        self.CycleBaseAllowance = v_uint64()
        self.CyclesRemaining = v_uint64()
        self.CurrentGeneration = v_uint32()
        self._pad0040 = v_bytes(size=28)


class PROC_PERF_CONSTRAINT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Prcb = v_ptr32()
        self.PerfContext = v_uint32()
        self.PercentageCap = v_uint32()
        self.ThermalCap = v_uint32()
        self.TargetFrequency = v_uint32()
        self.AcumulatedFullFrequency = v_uint32()
        self.AcumulatedZeroFrequency = v_uint32()
        self.FrequencyHistoryTotal = v_uint32()
        self.AverageFrequency = v_uint32()


class LUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class _unnamed_7711(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Overlay = _unnamed_7784()
        self._pad0030 = v_bytes(size=8)


class CLIENT_ID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_ptr32()
        self.UniqueThread = v_ptr32()


class RTL_STACK_TRACE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashChain = RTL_STD_LIST_ENTRY()
        self.TraceCount = v_uint16()
        self.IndexHigh = v_uint16()
        self.Index = v_uint16()
        self.Depth = v_uint16()
        self.BackTrace = vstruct.VArray([ v_ptr32() for i in xrange(32) ])


class OBJECT_DUMP_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Stream = v_ptr32()
        self.Detail = v_uint32()


class HANDLE_TRACE_DB_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientId = CLIENT_ID()
        self.Handle = v_ptr32()
        self.Type = v_uint32()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(16) ])


class GENERAL_LOOKASIDE_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr32()
        self.FreeEx = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])


class HARDWARE_PTE_X86(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class RTL_SRWLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint32()


class HEAP_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint32()
        self.TagIndex = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self.TagName = vstruct.VArray([ v_uint16() for i in xrange(24) ])


class STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class TP_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class LIST_ENTRY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint32()
        self.Blink = v_uint32()


class SINGLE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()


class PPM_FFH_THROTTLE_STATE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnableLogging = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.MismatchCount = v_uint32()
        self.Initialized = v_uint8()
        self._pad0010 = v_bytes(size=7)
        self.LastValue = v_uint64()
        self.LastLogTickCount = LARGE_INTEGER()


class KDEVICE_QUEUE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceListEntry = LIST_ENTRY()
        self.SortKey = v_uint32()
        self.Inserted = v_uint8()
        self._pad0010 = v_bytes(size=3)


class CACHED_KSTACK_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SListHead = SLIST_HEADER()
        self.MinimumFree = v_uint32()
        self.Misses = v_uint32()
        self.MissesLast = v_uint32()
        self.Pad0 = v_uint32()


class HEAP_FAILURE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint32()
        self.StructureSize = v_uint32()
        self.FailureType = v_uint32()
        self.HeapAddress = v_ptr32()
        self.Address = v_ptr32()
        self.Param1 = v_ptr32()
        self.Param2 = v_ptr32()
        self.Param3 = v_ptr32()
        self.PreviousBlock = v_ptr32()
        self.NextBlock = v_ptr32()
        self.ExpectedEncodedEntry = HEAP_ENTRY()
        self.ExpectedDecodedEntry = HEAP_ENTRY()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(32) ])


class EX_FAST_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr32()


class INTERLOCK_SEQ(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint16()
        self.FreeEntryOffset = v_uint16()
        self.Sequence = v_uint32()


class KSPIN_LOCK_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Lock = v_ptr32()


class RTL_ACTIVATION_CONTEXT_STACK_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Previous = v_ptr32()
        self.ActivationContext = v_ptr32()
        self.Flags = v_uint32()


class FS_FILTER_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbacks = v_uint32()
        self.Reserved = v_uint32()
        self.PreAcquireForSectionSynchronization = v_ptr32()
        self.PostAcquireForSectionSynchronization = v_ptr32()
        self.PreReleaseForSectionSynchronization = v_ptr32()
        self.PostReleaseForSectionSynchronization = v_ptr32()
        self.PreAcquireForCcFlush = v_ptr32()
        self.PostAcquireForCcFlush = v_ptr32()
        self.PreReleaseForCcFlush = v_ptr32()
        self.PostReleaseForCcFlush = v_ptr32()
        self.PreAcquireForModifiedPageWriter = v_ptr32()
        self.PostAcquireForModifiedPageWriter = v_ptr32()
        self.PreReleaseForModifiedPageWriter = v_ptr32()
        self.PostReleaseForModifiedPageWriter = v_ptr32()


class MM_DRIVER_VERIFIER_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint32()
        self.RaiseIrqls = v_uint32()
        self.AcquireSpinLocks = v_uint32()
        self.SynchronizeExecutions = v_uint32()
        self.AllocationsAttempted = v_uint32()
        self.AllocationsSucceeded = v_uint32()
        self.AllocationsSucceededSpecialPool = v_uint32()
        self.AllocationsWithNoTag = v_uint32()
        self.TrimRequests = v_uint32()
        self.Trims = v_uint32()
        self.AllocationsFailed = v_uint32()
        self.AllocationsFailedDeliberately = v_uint32()
        self.Loads = v_uint32()
        self.Unloads = v_uint32()
        self.UnTrackedPool = v_uint32()
        self.UserTrims = v_uint32()
        self.CurrentPagedPoolAllocations = v_uint32()
        self.CurrentNonPagedPoolAllocations = v_uint32()
        self.PeakPagedPoolAllocations = v_uint32()
        self.PeakNonPagedPoolAllocations = v_uint32()
        self.PagedBytes = v_uint32()
        self.NonPagedBytes = v_uint32()
        self.PeakPagedBytes = v_uint32()
        self.PeakNonPagedBytes = v_uint32()
        self.BurstAllocationsFailedDeliberately = v_uint32()
        self.SessionTrims = v_uint32()
        self.OptionChanges = v_uint32()
        self.VerifyMode = v_uint32()
        self.PreviousBucketName = UNICODE_STRING()
        self.ActivityCounter = v_uint32()
        self.PreviousActivityCounter = v_uint32()
        self.WorkerTrimRequests = v_uint32()


class IO_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Option = v_uint8()
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Spare1 = v_uint8()
        self.Flags = v_uint16()
        self.Spare2 = v_uint16()
        self.u = _unnamed_9655()


class EX_PUSH_LOCK_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locks = vstruct.VArray([ v_ptr32() for i in xrange(32) ])


class _unnamed_7963(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self.SecurityDescriptor = v_ptr32()


class _unnamed_7960(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self.Length = v_uint32()


class RTL_TRACE_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint32()
        self.Count = v_uint32()
        self.Size = v_uint32()
        self.UserCount = v_uint32()
        self.UserSize = v_uint32()
        self.UserContext = v_ptr32()
        self.Next = v_ptr32()
        self.Trace = v_ptr32()


class IMAGE_OPTIONAL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint16()
        self.MajorLinkerVersion = v_uint8()
        self.MinorLinkerVersion = v_uint8()
        self.SizeOfCode = v_uint32()
        self.SizeOfInitializedData = v_uint32()
        self.SizeOfUninitializedData = v_uint32()
        self.AddressOfEntryPoint = v_uint32()
        self.BaseOfCode = v_uint32()
        self.BaseOfData = v_uint32()
        self.ImageBase = v_uint32()
        self.SectionAlignment = v_uint32()
        self.FileAlignment = v_uint32()
        self.MajorOperatingSystemVersion = v_uint16()
        self.MinorOperatingSystemVersion = v_uint16()
        self.MajorImageVersion = v_uint16()
        self.MinorImageVersion = v_uint16()
        self.MajorSubsystemVersion = v_uint16()
        self.MinorSubsystemVersion = v_uint16()
        self.Win32VersionValue = v_uint32()
        self.SizeOfImage = v_uint32()
        self.SizeOfHeaders = v_uint32()
        self.CheckSum = v_uint32()
        self.Subsystem = v_uint16()
        self.DllCharacteristics = v_uint16()
        self.SizeOfStackReserve = v_uint32()
        self.SizeOfStackCommit = v_uint32()
        self.SizeOfHeapReserve = v_uint32()
        self.SizeOfHeapCommit = v_uint32()
        self.LoaderFlags = v_uint32()
        self.NumberOfRvaAndSizes = v_uint32()
        self.DataDirectory = vstruct.VArray([ IMAGE_DATA_DIRECTORY() for i in xrange(16) ])


class SCSI_REQUEST_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ETHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Tcb = KTHREAD()
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self.ExitStatus = v_uint32()
        self.PostBlockList = LIST_ENTRY()
        self.TerminationPort = v_ptr32()
        self.ActiveTimerListLock = v_uint32()
        self.ActiveTimerListHead = LIST_ENTRY()
        self.Cid = CLIENT_ID()
        self.KeyedWaitSemaphore = KSEMAPHORE()
        self.ClientSecurity = PS_CLIENT_SECURITY_CONTEXT()
        self.IrpList = LIST_ENTRY()
        self.TopLevelIrp = v_uint32()
        self.DeviceToVerify = v_ptr32()
        self.CpuQuotaApc = v_ptr32()
        self.Win32StartAddress = v_ptr32()
        self.LegacyPowerObject = v_ptr32()
        self.ThreadListEntry = LIST_ENTRY()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.ThreadLock = EX_PUSH_LOCK()
        self.ReadClusterSize = v_uint32()
        self.MmLockOrdering = v_uint32()
        self.CrossThreadFlags = v_uint32()
        self.SameThreadPassiveFlags = v_uint32()
        self.SameThreadApcFlags = v_uint32()
        self.CacheManagerActive = v_uint8()
        self.DisablePageFaultClustering = v_uint8()
        self.ActiveFaultCount = v_uint8()
        self.LockOrderState = v_uint8()
        self.AlpcMessageId = v_uint32()
        self.AlpcMessage = v_ptr32()
        self.AlpcWaitListEntry = LIST_ENTRY()
        self.CacheManagerCount = v_uint32()
        self.IoBoostCount = v_uint32()
        self.IrpListLock = v_uint32()
        self.ReservedForSynchTracking = v_ptr32()
        self.CmCallbackListHead = SINGLE_LIST_ENTRY()
        self._pad02b8 = v_bytes(size=4)


class ASSEMBLY_STORAGE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class FAST_MUTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Owner = v_ptr32()
        self.Contention = v_uint32()
        self.Event = KEVENT()
        self.OldIrql = v_uint32()


class WHEA_ERROR_RECORD_HEADER_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PlatformId = v_uint32()


class _unnamed_8157(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProviderId = v_uint32()
        self.DataPath = v_ptr32()
        self.BufferSize = v_uint32()
        self.Buffer = v_ptr32()


class _unnamed_8153(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedResources = v_ptr32()
        self.AllocatedResourcesTranslated = v_ptr32()


class IO_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityQos = v_ptr32()
        self.AccessState = v_ptr32()
        self.DesiredAccess = v_uint32()
        self.FullCreateOptions = v_uint32()


class TERMINATION_PORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Port = v_ptr32()


class _unnamed_9303(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsULONG = v_uint32()


class IO_CLIENT_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextExtension = v_ptr32()
        self.ClientIdentificationAddress = v_ptr32()


class INITIAL_PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(3) ])


class WHEA_ERROR_RECORD_HEADER_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Recovered = v_uint32()


class XSTATE_CONFIGURATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnabledFeatures = v_uint64()
        self.Size = v_uint32()
        self.OptimizedSave = v_uint32()
        self.Features = vstruct.VArray([ XSTATE_FEATURE() for i in xrange(64) ])


class _unnamed_9713(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Raw = _unnamed_9708()


class _unnamed_9716(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Channel = v_uint32()
        self.Port = v_uint32()
        self.Reserved1 = v_uint32()


class KWAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitListEntry = LIST_ENTRY()
        self.Thread = v_ptr32()
        self.Object = v_ptr32()
        self.NextWaitBlock = v_ptr32()
        self.WaitKey = v_uint16()
        self.WaitType = v_uint8()
        self.BlockState = v_uint8()


class _unnamed_9655(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = _unnamed_10231()


class ACTIVATION_CONTEXT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class FILE_NETWORK_OPEN_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0038 = v_bytes(size=4)


class DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pad = v_uint16()
        self.Limit = v_uint16()
        self.Base = v_uint32()


class HEAP_USERDATA_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SFreeListEntry = SINGLE_LIST_ENTRY()
        self.Reserved = v_ptr32()
        self.SizeIndex = v_uint32()
        self.Signature = v_uint32()


class RTL_DRIVE_LETTER_CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint16()
        self.Length = v_uint16()
        self.TimeStamp = v_uint32()
        self.DosPath = STRING()


class CACHE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint8()
        self.Associativity = v_uint8()
        self.LineSize = v_uint16()
        self.Size = v_uint32()
        self.Type = v_uint32()


class GENERAL_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr32()
        self.FreeEx = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self._pad0080 = v_bytes(size=56)


class TEB_ACTIVE_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.Previous = v_ptr32()
        self.Context = v_ptr32()


class ULARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class _unnamed_9007(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.McaCod = v_uint16()
        self.MsCod = v_uint16()
        self.OtherInfo = v_uint32()


class _unnamed_9000(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mca = _unnamed_9012()


class _unnamed_7723(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserApcRoutine = v_ptr32()
        self.UserApcContext = v_ptr32()


class KWAIT_STATUS_REGISTER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint8()


class KGDTENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LimitLow = v_uint16()
        self.BaseLow = v_uint16()
        self.HighWord = _unnamed_6512()


class NAMED_PIPE_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NamedPipeType = v_uint32()
        self.ReadMode = v_uint32()
        self.CompletionMode = v_uint32()
        self.MaximumInstances = v_uint32()
        self.InboundQuota = v_uint32()
        self.OutboundQuota = v_uint32()
        self.DefaultTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0028 = v_bytes(size=7)


class NT_TIB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_ptr32()
        self.StackBase = v_ptr32()
        self.StackLimit = v_ptr32()
        self.SubSystemTib = v_ptr32()
        self.FiberData = v_ptr32()
        self.ArbitraryUserPointer = v_ptr32()
        self.Self = v_ptr32()


class RTL_STD_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()


class POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemState = v_uint32()


class UNICODE_STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class _unnamed_9480(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Generic = _unnamed_9700()


class HEAP_LIST_LOOKUP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExtendedLookup = v_ptr32()
        self.ArraySize = v_uint32()
        self.ExtraItem = v_uint32()
        self.ItemCount = v_uint32()
        self.OutOfRangeItems = v_uint32()
        self.BaseIndex = v_uint32()
        self.ListHead = v_ptr32()
        self.ListsInUseUlong = v_ptr32()
        self.ListHints = v_ptr32()


class EPROCESS_QUOTA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class HEAP_DEBUGGING_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterceptorFunction = v_ptr32()
        self.InterceptorValue = v_uint16()
        self._pad0008 = v_bytes(size=2)
        self.ExtendedOptions = v_uint32()
        self.StackTraceDepth = v_uint32()
        self.MinTotalBlockSize = v_uint32()
        self.MaxTotalBlockSize = v_uint32()
        self.HeapLeakEnumerationRoutine = v_ptr32()


class PEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InheritedAddressSpace = v_uint8()
        self.ReadImageFileExecOptions = v_uint8()
        self.BeingDebugged = v_uint8()
        self.BitField = v_uint8()
        self.Mutant = v_ptr32()
        self.ImageBaseAddress = v_ptr32()
        self.Ldr = v_ptr32()
        self.ProcessParameters = v_ptr32()
        self.SubSystemData = v_ptr32()
        self.ProcessHeap = v_ptr32()
        self.FastPebLock = v_ptr32()
        self.AtlThunkSListPtr = v_ptr32()
        self.IFEOKey = v_ptr32()
        self.CrossProcessFlags = v_uint32()
        self.KernelCallbackTable = v_ptr32()
        self.SystemReserved = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.AtlThunkSListPtr32 = v_uint32()
        self.ApiSetMap = v_ptr32()
        self.TlsExpansionCounter = v_uint32()
        self.TlsBitmap = v_ptr32()
        self.TlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ReadOnlySharedMemoryBase = v_ptr32()
        self.HotpatchInformation = v_ptr32()
        self.ReadOnlyStaticServerData = v_ptr32()
        self.AnsiCodePageData = v_ptr32()
        self.OemCodePageData = v_ptr32()
        self.UnicodeCaseTableData = v_ptr32()
        self.NumberOfProcessors = v_uint32()
        self.NtGlobalFlag = v_uint32()
        self._pad0070 = v_bytes(size=4)
        self.CriticalSectionTimeout = LARGE_INTEGER()
        self.HeapSegmentReserve = v_uint32()
        self.HeapSegmentCommit = v_uint32()
        self.HeapDeCommitTotalFreeThreshold = v_uint32()
        self.HeapDeCommitFreeBlockThreshold = v_uint32()
        self.NumberOfHeaps = v_uint32()
        self.MaximumNumberOfHeaps = v_uint32()
        self.ProcessHeaps = v_ptr32()
        self.GdiSharedHandleTable = v_ptr32()
        self.ProcessStarterHelper = v_ptr32()
        self.GdiDCAttributeList = v_uint32()
        self.LoaderLock = v_ptr32()
        self.OSMajorVersion = v_uint32()
        self.OSMinorVersion = v_uint32()
        self.OSBuildNumber = v_uint16()
        self.OSCSDVersion = v_uint16()
        self.OSPlatformId = v_uint32()
        self.ImageSubsystem = v_uint32()
        self.ImageSubsystemMajorVersion = v_uint32()
        self.ImageSubsystemMinorVersion = v_uint32()
        self.ActiveProcessAffinityMask = v_uint32()
        self.GdiHandleBuffer = vstruct.VArray([ v_uint32() for i in xrange(34) ])
        self.PostProcessInitRoutine = v_ptr32()
        self.TlsExpansionBitmap = v_ptr32()
        self.TlsExpansionBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(32) ])
        self.SessionId = v_uint32()
        self.AppCompatFlags = ULARGE_INTEGER()
        self.AppCompatFlagsUser = ULARGE_INTEGER()
        self.pShimData = v_ptr32()
        self.AppCompatInfo = v_ptr32()
        self.CSDVersion = UNICODE_STRING()
        self.ActivationContextData = v_ptr32()
        self.ProcessAssemblyStorageMap = v_ptr32()
        self.SystemDefaultActivationContextData = v_ptr32()
        self.SystemAssemblyStorageMap = v_ptr32()
        self.MinimumStackCommit = v_uint32()
        self.FlsCallback = v_ptr32()
        self.FlsListHead = LIST_ENTRY()
        self.FlsBitmap = v_ptr32()
        self.FlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.FlsHighIndex = v_uint32()
        self.WerRegistrationData = v_ptr32()
        self.WerShipAssertPtr = v_ptr32()
        self.pContextData = v_ptr32()
        self.pImageHeaderHash = v_ptr32()
        self.TracingFlags = v_uint32()
        self._pad0248 = v_bytes(size=4)


class _unnamed_7923(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.EaList = v_ptr32()
        self.EaListLength = v_uint32()
        self.EaIndex = v_uint32()


class STACK_TRACE_DATABASE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(56) ])
        self.Reserved2 = v_ptr32()
        self.PeakHashCollisionListLength = v_uint32()
        self.LowerMemoryStart = v_ptr32()
        self.PreCommitted = v_uint8()
        self.DumpInProgress = v_uint8()
        self._pad0048 = v_bytes(size=2)
        self.CommitBase = v_ptr32()
        self.CurrentLowerCommitLimit = v_ptr32()
        self.CurrentUpperCommitLimit = v_ptr32()
        self.NextFreeLowerMemory = v_ptr32()
        self.NextFreeUpperMemory = v_ptr32()
        self.NumberOfEntriesLookedUp = v_uint32()
        self.NumberOfEntriesAdded = v_uint32()
        self.EntryIndexArray = v_ptr32()
        self.NumberOfEntriesAllocated = v_uint32()
        self.NumberOfEntriesAvailable = v_uint32()
        self.NumberOfAllocationFailures = v_uint32()
        self._pad0078 = v_bytes(size=4)
        self.FreeLists = vstruct.VArray([ SLIST_HEADER() for i in xrange(32) ])
        self.NumberOfBuckets = v_uint32()
        self.Buckets = vstruct.VArray([ RTL_STD_LIST_HEAD() for i in xrange(1) ])
        self._pad0188 = v_bytes(size=4)


class _unnamed_7835(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self.Parameters = v_ptr32()


class _unnamed_7842(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Key = v_uint32()
        self.ByteOffset = LARGE_INTEGER()


class _unnamed_7928(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()


class KDPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.Importance = v_uint8()
        self.Number = v_uint16()
        self.DpcListEntry = LIST_ENTRY()
        self.DeferredRoutine = v_ptr32()
        self.DeferredContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.DpcData = v_ptr32()


class KEVENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class KSEMAPHORE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.Limit = v_uint32()


class MM_PAGE_ACCESS_INFO_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = SINGLE_LIST_ENTRY()
        self.Type = v_uint32()
        self.EmptySequenceNumber = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.CreateTime = v_uint64()
        self.EmptyTime = v_uint64()
        self.PageEntry = v_ptr32()
        self.FileEntry = v_ptr32()
        self.FirstFileEntry = v_ptr32()
        self.Process = v_ptr32()
        self.SessionId = v_uint32()
        self._pad0038 = v_bytes(size=4)


class OBJECT_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TypeList = LIST_ENTRY()
        self.Name = UNICODE_STRING()
        self.DefaultObject = v_ptr32()
        self.Index = v_uint8()
        self._pad0018 = v_bytes(size=3)
        self.TotalNumberOfObjects = v_uint32()
        self.TotalNumberOfHandles = v_uint32()
        self.HighWaterNumberOfObjects = v_uint32()
        self.HighWaterNumberOfHandles = v_uint32()
        self.TypeInfo = OBJECT_TYPE_INITIALIZER()
        self.TypeLock = EX_PUSH_LOCK()
        self.Key = v_uint32()
        self.CallbackList = LIST_ENTRY()


class HANDLE_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TableCode = v_uint32()
        self.QuotaProcess = v_ptr32()
        self.UniqueProcessId = v_ptr32()
        self.HandleLock = EX_PUSH_LOCK()
        self.HandleTableList = LIST_ENTRY()
        self.HandleContentionEvent = EX_PUSH_LOCK()
        self.DebugInfo = v_ptr32()
        self.ExtraInfoPages = v_uint32()
        self.Flags = v_uint32()
        self.FirstFreeHandle = v_uint32()
        self.LastFreeHandleEntry = v_ptr32()
        self.HandleCount = v_uint32()
        self.NextHandleNeedingPool = v_uint32()
        self.HandleCountHighWatermark = v_uint32()


class MMSUPPORT_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkingSetType = v_uint8()
        self.SessionMaster = v_uint8()
        self.MemoryPriority = v_uint8()
        self.WsleDeleted = v_uint8()


class PROC_PERF_DOMAIN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = LIST_ENTRY()
        self.Master = v_ptr32()
        self.Members = KAFFINITY_EX()
        self.FeedbackHandler = v_ptr32()
        self.GetFFHThrottleState = v_ptr32()
        self.BoostPolicyHandler = v_ptr32()
        self.PerfSelectionHandler = v_ptr32()
        self.PerfHandler = v_ptr32()
        self.Processors = v_ptr32()
        self.PerfChangeTime = v_uint64()
        self.ProcessorCount = v_uint32()
        self.PreviousFrequencyMhz = v_uint32()
        self.CurrentFrequencyMhz = v_uint32()
        self.PreviousFrequency = v_uint32()
        self.CurrentFrequency = v_uint32()
        self.CurrentPerfContext = v_uint32()
        self.DesiredFrequency = v_uint32()
        self.MaxFrequency = v_uint32()
        self.MinPerfPercent = v_uint32()
        self.MinThrottlePercent = v_uint32()
        self.MaxPercent = v_uint32()
        self.MinPercent = v_uint32()
        self.ConstrainedMaxPercent = v_uint32()
        self.ConstrainedMinPercent = v_uint32()
        self.Coordination = v_uint8()
        self._pad0074 = v_bytes(size=3)
        self.PerfChangeIntervalCount = v_uint32()


class EXCEPTION_REGISTRATION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Handler = v_ptr32()


class FILE_BASIC_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0028 = v_bytes(size=4)


class LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_ptr32()
        self.Blink = v_ptr32()


class M128A(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Low = v_uint64()
        self.High = v_uint64()


class RTL_DYNAMIC_HASH_TABLE_ENUMERATOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashEntry = RTL_DYNAMIC_HASH_TABLE_ENTRY()
        self.ChainHead = v_ptr32()
        self.BucketIndex = v_uint32()


class _unnamed_8067(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoResourceRequirementList = v_ptr32()


class GUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data1 = v_uint32()
        self.Data2 = v_uint16()
        self.Data3 = v_uint16()
        self.Data4 = vstruct.VArray([ v_uint8() for i in xrange(8) ])


class HEAP_UCR_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.SegmentEntry = LIST_ENTRY()
        self.Address = v_ptr32()
        self.Size = v_uint32()


class MCA_EXCEPTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VersionNumber = v_uint32()
        self.ExceptionType = v_uint32()
        self.TimeStamp = LARGE_INTEGER()
        self.ProcessorNumber = v_uint32()
        self.Reserved1 = v_uint32()
        self.u = _unnamed_9000()
        self.ExtCnt = v_uint32()
        self.Reserved3 = v_uint32()
        self.ExtReg = vstruct.VArray([ v_uint64() for i in xrange(24) ])


class PSP_CPU_QUOTA_APC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class KAPC_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ApcListHead = vstruct.VArray([ LIST_ENTRY() for i in xrange(2) ])
        self.Process = v_ptr32()
        self.KernelApcInProgress = v_uint8()
        self.KernelApcPending = v_uint8()
        self.UserApcPending = v_uint8()
        self._pad0018 = v_bytes(size=1)


class COUNTER_READING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.Index = v_uint32()
        self.Start = v_uint64()
        self.Total = v_uint64()


class _unnamed_8109(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerState = v_uint32()


class KDPC_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DpcListHead = LIST_ENTRY()
        self.DpcLock = v_uint32()
        self.DpcQueueDepth = v_uint32()
        self.DpcCount = v_uint32()


class KIDTENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint16()
        self.Selector = v_uint16()
        self.Access = v_uint16()
        self.ExtendedOffset = v_uint16()


class XSAVE_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LegacyState = XSAVE_FORMAT()
        self.Header = XSAVE_AREA_HEADER()


class _unnamed_10265(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length48 = v_uint32()
        self.Alignment48 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class GENERIC_MAPPING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GenericRead = v_uint32()
        self.GenericWrite = v_uint32()
        self.GenericExecute = v_uint32()
        self.GenericAll = v_uint32()


class IRP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.MdlAddress = v_ptr32()
        self.Flags = v_uint32()
        self.AssociatedIrp = _unnamed_7705()
        self.ThreadListEntry = LIST_ENTRY()
        self.IoStatus = IO_STATUS_BLOCK()
        self.RequestorMode = v_uint8()
        self.PendingReturned = v_uint8()
        self.StackCount = v_uint8()
        self.CurrentLocation = v_uint8()
        self.Cancel = v_uint8()
        self.CancelIrql = v_uint8()
        self.ApcEnvironment = v_uint8()
        self.AllocationFlags = v_uint8()
        self.UserIosb = v_ptr32()
        self.UserEvent = v_ptr32()
        self.Overlay = _unnamed_7708()
        self.CancelRoutine = v_ptr32()
        self.UserBuffer = v_ptr32()
        self.Tail = _unnamed_7711()


class KTHREAD_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitReasonBitMap = v_uint64()
        self.UserData = v_ptr32()
        self.Flags = v_uint32()
        self.ContextSwitches = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.CycleTimeBias = v_uint64()
        self.HardwareCounters = v_uint64()
        self.HwCounter = vstruct.VArray([ COUNTER_READING() for i in xrange(16) ])


class DRIVER_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Flags = v_uint32()
        self.DriverStart = v_ptr32()
        self.DriverSize = v_uint32()
        self.DriverSection = v_ptr32()
        self.DriverExtension = v_ptr32()
        self.DriverName = UNICODE_STRING()
        self.HardwareDatabase = v_ptr32()
        self.FastIoDispatch = v_ptr32()
        self.DriverInit = v_ptr32()
        self.DriverStartIo = v_ptr32()
        self.DriverUnload = v_ptr32()
        self.MajorFunction = vstruct.VArray([ v_ptr32() for i in xrange(28) ])


class FILE_GET_QUOTA_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextEntryOffset = v_uint32()
        self.SidLength = v_uint32()
        self.Sid = SID()


class KGATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class IO_COMPLETION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = v_ptr32()
        self.Key = v_ptr32()


class DRIVER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DriverObject = v_ptr32()
        self.AddDevice = v_ptr32()
        self.Count = v_uint32()
        self.ServiceKeyName = UNICODE_STRING()
        self.ClientDriverExtension = v_ptr32()
        self.FsFilterCallbacks = v_ptr32()


class TP_NBQ_GUARD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GuardLinks = LIST_ENTRY()
        self.Guards = vstruct.VArray([ v_ptr32() for i in xrange(2) ])


class flags(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Removable = v_uint8()


class MM_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = MMADDRESS_NODE()
        self.DepthOfTree = v_uint32()
        self.NodeHint = v_ptr32()
        self.NodeFreeHint = v_ptr32()


class WHEA_PERSISTENCE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint64()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FRUId = v_uint8()


class EXCEPTION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_ptr32()
        self.ExceptionAddress = v_ptr32()
        self.NumberParameters = v_uint32()
        self.ExceptionInformation = vstruct.VArray([ v_uint32() for i in xrange(15) ])


class PROCESSOR_NUMBER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.Number = v_uint8()
        self.Reserved = v_uint8()


class MM_PAGE_ACCESS_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = MM_PAGE_ACCESS_INFO_FLAGS()
        self.PointerProtoPte = v_ptr32()


class KPCR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.SelfPcr = v_ptr32()
        self.Prcb = v_ptr32()
        self.Irql = v_uint8()
        self._pad0028 = v_bytes(size=3)
        self.IRR = v_uint32()
        self.IrrActive = v_uint32()
        self.IDR = v_uint32()
        self.KdVersionBlock = v_ptr32()
        self.IDT = v_ptr32()
        self.GDT = v_ptr32()
        self.TSS = v_ptr32()
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.SetMember = v_uint32()
        self.StallScaleFactor = v_uint32()
        self.SpareUnused = v_uint8()
        self.Number = v_uint8()
        self.Spare0 = v_uint8()
        self.SecondLevelCacheAssociativity = v_uint8()
        self.VdmAlert = v_uint32()
        self.KernelReserved = vstruct.VArray([ v_uint32() for i in xrange(14) ])
        self.SecondLevelCacheSize = v_uint32()
        self.HalReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.InterruptMode = v_uint32()
        self.Spare1 = v_uint8()
        self._pad00dc = v_bytes(size=3)
        self.KernelReserved2 = vstruct.VArray([ v_uint32() for i in xrange(17) ])
        self.PrcbData = KPRCB()


class _unnamed_7807(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.FileAttributes = v_uint16()
        self.ShareAccess = v_uint16()
        self.EaLength = v_uint32()


class IMAGE_FILE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Machine = v_uint16()
        self.NumberOfSections = v_uint16()
        self.TimeDateStamp = v_uint32()
        self.PointerToSymbolTable = v_uint32()
        self.NumberOfSymbols = v_uint32()
        self.SizeOfOptionalHeader = v_uint16()
        self.Characteristics = v_uint16()


class LFH_BLOCK_ZONE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.FreePointer = v_ptr32()
        self.Limit = v_ptr32()


class FILE_STANDARD_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.NumberOfLinks = v_uint32()
        self.DeletePending = v_uint8()
        self.Directory = v_uint8()
        self._pad0018 = v_bytes(size=2)


class LFH_HEAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = RTL_CRITICAL_SECTION()
        self.SubSegmentZones = LIST_ENTRY()
        self.ZoneBlockSize = v_uint32()
        self.Heap = v_ptr32()
        self.SegmentChange = v_uint32()
        self.SegmentCreate = v_uint32()
        self.SegmentInsertInFree = v_uint32()
        self.SegmentDelete = v_uint32()
        self.CacheAllocs = v_uint32()
        self.CacheFrees = v_uint32()
        self.SizeInCache = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.RunInfo = HEAP_BUCKET_RUN_INFO()
        self.UserBlockCache = vstruct.VArray([ USER_MEMORY_CACHE_ENTRY() for i in xrange(12) ])
        self.Buckets = vstruct.VArray([ HEAP_BUCKET() for i in xrange(128) ])
        self.LocalData = vstruct.VArray([ HEAP_LOCAL_DATA() for i in xrange(1) ])


class _unnamed_7980(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Srb = v_ptr32()


class HEAP_BUCKET_RUN_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Bucket = v_uint32()
        self.RunLength = v_uint32()


class PEB_LDR_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Initialized = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.SsHandle = v_ptr32()
        self.InLoadOrderModuleList = LIST_ENTRY()
        self.InMemoryOrderModuleList = LIST_ENTRY()
        self.InInitializationOrderModuleList = LIST_ENTRY()
        self.EntryInProgress = v_ptr32()
        self.ShutdownInProgress = v_uint8()
        self._pad002c = v_bytes(size=3)
        self.ShutdownThreadId = v_ptr32()


class _unnamed_7988(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.StartSid = v_ptr32()
        self.SidList = v_ptr32()
        self.SidListLength = v_uint32()


class _unnamed_7942(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FsInformationClass = v_uint32()


class HEAP_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Flags = v_uint8()
        self.SmallTagIndex = v_uint8()
        self.PreviousSize = v_uint16()
        self.SegmentOffset = v_uint8()
        self.UnusedBytes = v_uint8()


class MM_PAGE_ACCESS_INFO_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.File = _unnamed_8913()


class SECURITY_SUBJECT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientToken = v_ptr32()
        self.ImpersonationLevel = v_uint32()
        self.PrimaryToken = v_ptr32()
        self.ProcessAuditId = v_ptr32()


class _unnamed_7976(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vpb = v_ptr32()
        self.DeviceObject = v_ptr32()


class INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Context = v_ptr32()
        self.InterfaceReference = v_ptr32()
        self.InterfaceDereference = v_ptr32()


class SLIST_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Alignment = v_uint64()


class IMAGE_DATA_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_uint32()
        self.Size = v_uint32()


class FILE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Vpb = v_ptr32()
        self.FsContext = v_ptr32()
        self.FsContext2 = v_ptr32()
        self.SectionObjectPointer = v_ptr32()
        self.PrivateCacheMap = v_ptr32()
        self.FinalStatus = v_uint32()
        self.RelatedFileObject = v_ptr32()
        self.LockOperation = v_uint8()
        self.DeletePending = v_uint8()
        self.ReadAccess = v_uint8()
        self.WriteAccess = v_uint8()
        self.DeleteAccess = v_uint8()
        self.SharedRead = v_uint8()
        self.SharedWrite = v_uint8()
        self.SharedDelete = v_uint8()
        self.Flags = v_uint32()
        self.FileName = UNICODE_STRING()
        self.CurrentByteOffset = LARGE_INTEGER()
        self.Waiters = v_uint32()
        self.Busy = v_uint32()
        self.LastLock = v_ptr32()
        self.Lock = KEVENT()
        self.Event = KEVENT()
        self.CompletionContext = v_ptr32()
        self.IrpListLock = v_uint32()
        self.IrpList = LIST_ENTRY()
        self.FileObjectExtension = v_ptr32()


class PPM_IDLE_STATES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Flags = _unnamed_9303()
        self.TargetState = v_uint32()
        self.ActualState = v_uint32()
        self.OldState = v_uint32()
        self.NewlyUnparked = v_uint8()
        self._pad0018 = v_bytes(size=3)
        self.TargetProcessors = KAFFINITY_EX()
        self.State = vstruct.VArray([ PPM_IDLE_STATE() for i in xrange(1) ])


class _unnamed_8142(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemContext = v_uint32()
        self.Type = v_uint32()
        self.State = POWER_STATE()
        self.ShutdownType = v_uint32()


class HEAP_SUBSEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LocalInfo = v_ptr32()
        self.UserBlocks = v_ptr32()
        self.AggregateExchg = INTERLOCK_SEQ()
        self.BlockSize = v_uint16()
        self.Flags = v_uint16()
        self.BlockCount = v_uint16()
        self.SizeIndex = v_uint8()
        self.AffinityIndex = v_uint8()
        self.SFreeListEntry = SINGLE_LIST_ENTRY()
        self.Lock = v_uint32()


class ERESOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemResourcesList = LIST_ENTRY()
        self.OwnerTable = v_ptr32()
        self.ActiveCount = v_uint16()
        self.Flag = v_uint16()
        self.SharedWaiters = v_ptr32()
        self.ExclusiveWaiters = v_ptr32()
        self.OwnerEntry = OWNER_ENTRY()
        self.ActiveEntries = v_uint32()
        self.ContentionCount = v_uint32()
        self.NumberOfSharedWaiters = v_uint32()
        self.NumberOfExclusiveWaiters = v_uint32()
        self.Address = v_ptr32()
        self.SpinLock = v_uint32()


class ACCESS_REASONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(32) ])


class TP_TASK_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteCallback = v_ptr32()
        self.Unposted = v_ptr32()


class _unnamed_9726(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class _unnamed_9722(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint32()
        self.Length = v_uint32()
        self.Reserved = v_uint32()


class _unnamed_9720(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(3) ])


class EX_PUSH_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint32()


class XSTATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint64()
        self.Length = v_uint32()
        self.Reserved1 = v_uint32()
        self.Area = v_ptr32()
        self.Reserved2 = v_uint32()
        self.Buffer = v_ptr32()
        self.Reserved3 = v_uint32()


class HEAP_FREE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Flags = v_uint8()
        self.SmallTagIndex = v_uint8()
        self.PreviousSize = v_uint16()
        self.SegmentOffset = v_uint8()
        self.UnusedBytes = v_uint8()
        self.FreeList = LIST_ENTRY()


class KSTACK_COUNT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Value = v_uint32()


class MMSUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkingSetMutex = EX_PUSH_LOCK()
        self.ExitGate = v_ptr32()
        self.AccessLog = v_ptr32()
        self.WorkingSetExpansionLinks = LIST_ENTRY()
        self.AgeDistribution = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self.MinimumWorkingSetSize = v_uint32()
        self.WorkingSetSize = v_uint32()
        self.WorkingSetPrivateSize = v_uint32()
        self.MaximumWorkingSetSize = v_uint32()
        self.ChargedWslePages = v_uint32()
        self.ActualWslePages = v_uint32()
        self.WorkingSetSizeOverhead = v_uint32()
        self.PeakWorkingSetSize = v_uint32()
        self.HardFaultCount = v_uint32()
        self.VmWorkingSetList = v_ptr32()
        self.NextPageColor = v_uint16()
        self.LastTrimStamp = v_uint16()
        self.PageFaultCount = v_uint32()
        self.RepurposeCount = v_uint32()
        self.Spare = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.Flags = MMSUPPORT_FLAGS()


class HEAP_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.SegmentSignature = v_uint32()
        self.SegmentFlags = v_uint32()
        self.SegmentListEntry = LIST_ENTRY()
        self.Heap = v_ptr32()
        self.BaseAddress = v_ptr32()
        self.NumberOfPages = v_uint32()
        self.FirstEntry = v_ptr32()
        self.LastValidEntry = v_ptr32()
        self.NumberOfUnCommittedPages = v_uint32()
        self.NumberOfUnCommittedRanges = v_uint32()
        self.SegmentAllocatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self.UCRSegmentList = LIST_ENTRY()


class WHEA_ERROR_RECORD_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Revision = WHEA_REVISION()
        self.SignatureEnd = v_uint32()
        self.SectionCount = v_uint16()
        self.Severity = v_uint32()
        self.ValidBits = WHEA_ERROR_RECORD_HEADER_VALIDBITS()
        self.Length = v_uint32()
        self.Timestamp = WHEA_TIMESTAMP()
        self.PlatformId = GUID()
        self.PartitionId = GUID()
        self.CreatorId = GUID()
        self.NotifyType = GUID()
        self.RecordId = v_uint64()
        self.Flags = WHEA_ERROR_RECORD_HEADER_FLAGS()
        self.PersistenceInfo = WHEA_PERSISTENCE_INFO()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(12) ])


class EVENT_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint16()
        self.Version = v_uint8()
        self.Channel = v_uint8()
        self.Level = v_uint8()
        self.Opcode = v_uint8()
        self.Task = v_uint16()
        self.Keyword = v_uint64()


class _unnamed_8914(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FilePointerIndex = v_uint32()


class _unnamed_10251(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.MinBusNumber = v_uint32()
        self.MaxBusNumber = v_uint32()
        self.Reserved = v_uint32()


class _unnamed_10256(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Priority = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class FLS_CALLBACK_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ACL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AclRevision = v_uint8()
        self.Sbz1 = v_uint8()
        self.AclSize = v_uint16()
        self.AceCount = v_uint16()
        self.Sbz2 = v_uint16()


class LIST_ENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint64()
        self.Blink = v_uint64()


class WAIT_CONTEXT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.DeviceRoutine = v_ptr32()
        self.DeviceContext = v_ptr32()
        self.NumberOfMapRegisters = v_uint32()
        self.DeviceObject = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.BufferChainingDpc = v_ptr32()


class SE_AUDIT_PROCESS_CREATION_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImageFileName = v_ptr32()


class ACTIVATION_CONTEXT_STACK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ActiveFrame = v_ptr32()
        self.FrameListCache = LIST_ENTRY()
        self.Flags = v_uint32()
        self.NextCookieSequenceNumber = v_uint32()
        self.StackId = v_uint32()


class LDR_DATA_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InLoadOrderLinks = LIST_ENTRY()
        self.InMemoryOrderLinks = LIST_ENTRY()
        self.InInitializationOrderLinks = LIST_ENTRY()
        self.DllBase = v_ptr32()
        self.EntryPoint = v_ptr32()
        self.SizeOfImage = v_uint32()
        self.FullDllName = UNICODE_STRING()
        self.BaseDllName = UNICODE_STRING()
        self.Flags = v_uint32()
        self.LoadCount = v_uint16()
        self.TlsIndex = v_uint16()
        self.HashLinks = LIST_ENTRY()
        self.TimeDateStamp = v_uint32()
        self.EntryPointActivationContext = v_ptr32()
        self.PatchInformation = v_ptr32()
        self.ForwarderLinks = LIST_ENTRY()
        self.ServiceTagLinks = LIST_ENTRY()
        self.StaticLinks = LIST_ENTRY()
        self.ContextInformation = v_ptr32()
        self.OriginalBase = v_uint32()
        self.LoadTime = LARGE_INTEGER()


class LOOKASIDE_LIST_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE_POOL()


class TEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.EnvironmentPointer = v_ptr32()
        self.ClientId = CLIENT_ID()
        self.ActiveRpcHandle = v_ptr32()
        self.ThreadLocalStoragePointer = v_ptr32()
        self.ProcessEnvironmentBlock = v_ptr32()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_ptr32()
        self.Win32ThreadInfo = v_ptr32()
        self.User32Reserved = vstruct.VArray([ v_uint32() for i in xrange(26) ])
        self.UserReserved = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self.WOW32Reserved = v_ptr32()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()
        self.SystemReserved1 = vstruct.VArray([ v_ptr32() for i in xrange(54) ])
        self.ExceptionCode = v_uint32()
        self.ActivationContextStackPointer = v_ptr32()
        self.SpareBytes = vstruct.VArray([ v_uint8() for i in xrange(36) ])
        self.TxFsContext = v_uint32()
        self.GdiTebBatch = GDI_TEB_BATCH()
        self.RealClientId = CLIENT_ID()
        self.GdiCachedProcessHandle = v_ptr32()
        self.GdiClientPID = v_uint32()
        self.GdiClientTID = v_uint32()
        self.GdiThreadLocalInfo = v_ptr32()
        self.Win32ClientInfo = vstruct.VArray([ v_uint32() for i in xrange(62) ])
        self.glDispatchTable = vstruct.VArray([ v_ptr32() for i in xrange(233) ])
        self.glReserved1 = vstruct.VArray([ v_uint32() for i in xrange(29) ])
        self.glReserved2 = v_ptr32()
        self.glSectionInfo = v_ptr32()
        self.glSection = v_ptr32()
        self.glTable = v_ptr32()
        self.glCurrentRC = v_ptr32()
        self.glContext = v_ptr32()
        self.LastStatusValue = v_uint32()
        self.StaticUnicodeString = UNICODE_STRING()
        self.StaticUnicodeBuffer = vstruct.VArray([ v_uint16() for i in xrange(261) ])
        self._pad0e0c = v_bytes(size=2)
        self.DeallocationStack = v_ptr32()
        self.TlsSlots = vstruct.VArray([ v_ptr32() for i in xrange(64) ])
        self.TlsLinks = LIST_ENTRY()
        self.Vdm = v_ptr32()
        self.ReservedForNtRpc = v_ptr32()
        self.DbgSsReserved = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self.HardErrorMode = v_uint32()
        self.Instrumentation = vstruct.VArray([ v_ptr32() for i in xrange(9) ])
        self.ActivityId = GUID()
        self.SubProcessTag = v_ptr32()
        self.EtwLocalData = v_ptr32()
        self.EtwTraceData = v_ptr32()
        self.WinSockData = v_ptr32()
        self.GdiBatchCount = v_uint32()
        self.CurrentIdealProcessor = PROCESSOR_NUMBER()
        self.GuaranteedStackBytes = v_uint32()
        self.ReservedForPerf = v_ptr32()
        self.ReservedForOle = v_ptr32()
        self.WaitingOnLoaderLock = v_uint32()
        self.SavedPriorityState = v_ptr32()
        self.SoftPatchPtr1 = v_uint32()
        self.ThreadPoolData = v_ptr32()
        self.TlsExpansionSlots = v_ptr32()
        self.MuiGeneration = v_uint32()
        self.IsImpersonating = v_uint32()
        self.NlsCache = v_ptr32()
        self.pShimData = v_ptr32()
        self.HeapVirtualAffinity = v_uint32()
        self.CurrentTransactionHandle = v_ptr32()
        self.ActiveFrame = v_ptr32()
        self.FlsData = v_ptr32()
        self.PreferredLanguages = v_ptr32()
        self.UserPrefLanguages = v_ptr32()
        self.MergedPrefLanguages = v_ptr32()
        self.MuiImpersonation = v_uint32()
        self.CrossTebFlags = v_uint16()
        self.SameTebFlags = v_uint16()
        self.TxnScopeEnterCallback = v_ptr32()
        self.TxnScopeExitCallback = v_ptr32()
        self.TxnScopeContext = v_ptr32()
        self.LockCount = v_uint32()
        self.SpareUlong0 = v_uint32()
        self.ResourceRetValue = v_ptr32()


class EX_RUNDOWN_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()


class XSAVE_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint16()
        self.StatusWord = v_uint16()
        self.TagWord = v_uint8()
        self.Reserved1 = v_uint8()
        self.ErrorOpcode = v_uint16()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint16()
        self.Reserved2 = v_uint16()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint16()
        self.Reserved3 = v_uint16()
        self.MxCsr = v_uint32()
        self.MxCsr_Mask = v_uint32()
        self.FloatRegisters = vstruct.VArray([ M128A() for i in xrange(8) ])
        self.XmmRegisters = vstruct.VArray([ M128A() for i in xrange(8) ])
        self.Reserved4 = vstruct.VArray([ v_uint8() for i in xrange(192) ])
        self.StackControl = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self.Cr0NpxState = v_uint32()


class PO_DIAG_STACK_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StackDepth = v_uint32()
        self.Stack = vstruct.VArray([ v_ptr32() for i in xrange(1) ])


class IMAGE_DOS_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e_magic = v_uint16()
        self.e_cblp = v_uint16()
        self.e_cp = v_uint16()
        self.e_crlc = v_uint16()
        self.e_cparhdr = v_uint16()
        self.e_minalloc = v_uint16()
        self.e_maxalloc = v_uint16()
        self.e_ss = v_uint16()
        self.e_sp = v_uint16()
        self.e_csum = v_uint16()
        self.e_ip = v_uint16()
        self.e_cs = v_uint16()
        self.e_lfarlc = v_uint16()
        self.e_ovno = v_uint16()
        self.e_res = vstruct.VArray([ v_uint16() for i in xrange(4) ])
        self.e_oemid = v_uint16()
        self.e_oeminfo = v_uint16()
        self.e_res2 = vstruct.VArray([ v_uint16() for i in xrange(10) ])
        self.e_lfanew = v_uint32()


class RTL_DYNAMIC_HASH_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Linkage = LIST_ENTRY()
        self.Signature = v_uint32()


class MMADDRESS_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_9496()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.StartingVpn = v_uint32()
        self.EndingVpn = v_uint32()


class TXN_PARAMETER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.TxFsContext = v_uint16()
        self.TransactionObject = v_ptr32()


class QUAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UseThisFieldToCopy = v_uint64()


class HEAP_TUNING_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CommittThresholdShift = v_uint32()
        self.MaxPreCommittThreshold = v_uint32()


class KPRCB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinorVersion = v_uint16()
        self.MajorVersion = v_uint16()
        self.CurrentThread = v_ptr32()
        self.NextThread = v_ptr32()
        self.IdleThread = v_ptr32()
        self.LegacyNumber = v_uint8()
        self.NestingLevel = v_uint8()
        self.BuildType = v_uint16()
        self.CpuType = v_uint8()
        self.CpuID = v_uint8()
        self.CpuStep = v_uint16()
        self.ProcessorState = KPROCESSOR_STATE()
        self.KernelReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.HalReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.CFlushSize = v_uint32()
        self.CoresPerPhysicalProcessor = v_uint8()
        self.LogicalProcessorsPerCore = v_uint8()
        self.PrcbPad0 = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.MHz = v_uint32()
        self.CpuVendor = v_uint8()
        self.GroupIndex = v_uint8()
        self.Group = v_uint16()
        self.GroupSetMember = v_uint32()
        self.Number = v_uint32()
        self.PrcbPad1 = vstruct.VArray([ v_uint8() for i in xrange(72) ])
        self.LockQueue = vstruct.VArray([ KSPIN_LOCK_QUEUE() for i in xrange(17) ])
        self.NpxThread = v_ptr32()
        self.InterruptCount = v_uint32()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.DpcTime = v_uint32()
        self.DpcTimeCount = v_uint32()
        self.InterruptTime = v_uint32()
        self.AdjustDpcThreshold = v_uint32()
        self.PageColor = v_uint32()
        self.DebuggerSavedIRQL = v_uint8()
        self.NodeColor = v_uint8()
        self.PrcbPad20 = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.NodeShiftedColor = v_uint32()
        self.ParentNode = v_ptr32()
        self.SecondaryColorMask = v_uint32()
        self.DpcTimeLimit = v_uint32()
        self.PrcbPad21 = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.CcFastReadNoWait = v_uint32()
        self.CcFastReadWait = v_uint32()
        self.CcFastReadNotPossible = v_uint32()
        self.CcCopyReadNoWait = v_uint32()
        self.CcCopyReadWait = v_uint32()
        self.CcCopyReadNoWaitMiss = v_uint32()
        self.MmSpinLockOrdering = v_uint32()
        self.IoReadOperationCount = v_uint32()
        self.IoWriteOperationCount = v_uint32()
        self.IoOtherOperationCount = v_uint32()
        self.IoReadTransferCount = LARGE_INTEGER()
        self.IoWriteTransferCount = LARGE_INTEGER()
        self.IoOtherTransferCount = LARGE_INTEGER()
        self.CcFastMdlReadNoWait = v_uint32()
        self.CcFastMdlReadWait = v_uint32()
        self.CcFastMdlReadNotPossible = v_uint32()
        self.CcMapDataNoWait = v_uint32()
        self.CcMapDataWait = v_uint32()
        self.CcPinMappedDataCount = v_uint32()
        self.CcPinReadNoWait = v_uint32()
        self.CcPinReadWait = v_uint32()
        self.CcMdlReadNoWait = v_uint32()
        self.CcMdlReadWait = v_uint32()
        self.CcLazyWriteHotSpots = v_uint32()
        self.CcLazyWriteIos = v_uint32()
        self.CcLazyWritePages = v_uint32()
        self.CcDataFlushes = v_uint32()
        self.CcDataPages = v_uint32()
        self.CcLostDelayedWrites = v_uint32()
        self.CcFastReadResourceMiss = v_uint32()
        self.CcCopyReadWaitMiss = v_uint32()
        self.CcFastMdlReadResourceMiss = v_uint32()
        self.CcMapDataNoWaitMiss = v_uint32()
        self.CcMapDataWaitMiss = v_uint32()
        self.CcPinReadNoWaitMiss = v_uint32()
        self.CcPinReadWaitMiss = v_uint32()
        self.CcMdlReadNoWaitMiss = v_uint32()
        self.CcMdlReadWaitMiss = v_uint32()
        self.CcReadAheadIos = v_uint32()
        self.KeAlignmentFixupCount = v_uint32()
        self.KeExceptionDispatchCount = v_uint32()
        self.KeSystemCalls = v_uint32()
        self.AvailableTime = v_uint32()
        self.PrcbPad22 = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.PPLookasideList = vstruct.VArray([ PP_LOOKASIDE_LIST() for i in xrange(16) ])
        self.PPNPagedLookasideList = vstruct.VArray([ GENERAL_LOOKASIDE_POOL() for i in xrange(32) ])
        self.PPPagedLookasideList = vstruct.VArray([ GENERAL_LOOKASIDE_POOL() for i in xrange(32) ])
        self.PacketBarrier = v_uint32()
        self.ReverseStall = v_uint32()
        self.IpiFrame = v_ptr32()
        self.PrcbPad3 = vstruct.VArray([ v_uint8() for i in xrange(52) ])
        self.CurrentPacket = vstruct.VArray([ v_ptr32() for i in xrange(3) ])
        self.TargetSet = v_uint32()
        self.WorkerRoutine = v_ptr32()
        self.IpiFrozen = v_uint32()
        self.PrcbPad4 = vstruct.VArray([ v_uint8() for i in xrange(40) ])
        self.RequestSummary = v_uint32()
        self.SignalDone = v_ptr32()
        self.PrcbPad50 = vstruct.VArray([ v_uint8() for i in xrange(56) ])
        self.DpcData = vstruct.VArray([ KDPC_DATA() for i in xrange(2) ])
        self.DpcStack = v_ptr32()
        self.MaximumDpcQueueDepth = v_uint32()
        self.DpcRequestRate = v_uint32()
        self.MinimumDpcRate = v_uint32()
        self.DpcLastCount = v_uint32()
        self.PrcbLock = v_uint32()
        self.DpcGate = KGATE()
        self.ThreadDpcEnable = v_uint8()
        self.QuantumEnd = v_uint8()
        self.DpcRoutineActive = v_uint8()
        self.IdleSchedule = v_uint8()
        self.DpcRequestSummary = v_uint32()
        self.TimerHand = v_uint32()
        self.LastTick = v_uint32()
        self.MasterOffset = v_uint32()
        self.PrcbPad41 = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.PeriodicCount = v_uint32()
        self.PeriodicBias = v_uint32()
        self._pad1958 = v_bytes(size=4)
        self.TickOffset = v_uint64()
        self.TimerTable = KTIMER_TABLE()
        self.CallDpc = KDPC()
        self.ClockKeepAlive = v_uint32()
        self.ClockCheckSlot = v_uint8()
        self.ClockPollCycle = v_uint8()
        self.PrcbPad6 = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.DpcWatchdogPeriod = v_uint32()
        self.DpcWatchdogCount = v_uint32()
        self.ThreadWatchdogPeriod = v_uint32()
        self.ThreadWatchdogCount = v_uint32()
        self.KeSpinLockOrdering = v_uint32()
        self.PrcbPad70 = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.WaitListHead = LIST_ENTRY()
        self.WaitLock = v_uint32()
        self.ReadySummary = v_uint32()
        self.QueueIndex = v_uint32()
        self.DeferredReadyListHead = SINGLE_LIST_ENTRY()
        self.StartCycles = v_uint64()
        self.CycleTime = v_uint64()
        self.HighCycleTime = v_uint32()
        self.PrcbPad71 = v_uint32()
        self.PrcbPad72 = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.DispatcherReadyListHead = vstruct.VArray([ LIST_ENTRY() for i in xrange(32) ])
        self.ChainedInterruptList = v_ptr32()
        self.LookasideIrpFloat = v_uint32()
        self.MmPageFaultCount = v_uint32()
        self.MmCopyOnWriteCount = v_uint32()
        self.MmTransitionCount = v_uint32()
        self.MmCacheTransitionCount = v_uint32()
        self.MmDemandZeroCount = v_uint32()
        self.MmPageReadCount = v_uint32()
        self.MmPageReadIoCount = v_uint32()
        self.MmCacheReadCount = v_uint32()
        self.MmCacheIoCount = v_uint32()
        self.MmDirtyPagesWriteCount = v_uint32()
        self.MmDirtyWriteIoCount = v_uint32()
        self.MmMappedPagesWriteCount = v_uint32()
        self.MmMappedWriteIoCount = v_uint32()
        self.CachedCommit = v_uint32()
        self.CachedResidentAvailable = v_uint32()
        self.HyperPte = v_ptr32()
        self.PrcbPad8 = vstruct.VArray([ v_uint8() for i in xrange(4) ])
        self.VendorString = vstruct.VArray([ v_uint8() for i in xrange(13) ])
        self.InitialApicId = v_uint8()
        self.LogicalProcessorsPerPhysicalProcessor = v_uint8()
        self.PrcbPad9 = vstruct.VArray([ v_uint8() for i in xrange(5) ])
        self.FeatureBits = v_uint32()
        self._pad3388 = v_bytes(size=4)
        self.UpdateSignature = LARGE_INTEGER()
        self.IsrTime = v_uint64()
        self.RuntimeAccumulation = v_uint64()
        self.PowerState = PROCESSOR_POWER_STATE()
        self.DpcWatchdogDpc = KDPC()
        self.DpcWatchdogTimer = KTIMER()
        self.WheaInfo = v_ptr32()
        self.EtwSupport = v_ptr32()
        self.InterruptObjectPool = SLIST_HEADER()
        self.HypercallPageList = SLIST_HEADER()
        self.HypercallPageVirtual = v_ptr32()
        self.VirtualApicAssist = v_ptr32()
        self.StatisticsPage = v_ptr32()
        self.RateControl = v_ptr32()
        self.Cache = vstruct.VArray([ CACHE_DESCRIPTOR() for i in xrange(5) ])
        self.CacheCount = v_uint32()
        self.CacheProcessorMask = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self.PackageProcessorSet = KAFFINITY_EX()
        self.PrcbPad91 = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.CoreProcessorSet = v_uint32()
        self.TimerExpirationDpc = KDPC()
        self.SpinLockAcquireCount = v_uint32()
        self.SpinLockContentionCount = v_uint32()
        self.SpinLockSpinCount = v_uint32()
        self.IpiSendRequestBroadcastCount = v_uint32()
        self.IpiSendRequestRoutineCount = v_uint32()
        self.IpiSendSoftwareInterruptCount = v_uint32()
        self.ExInitializeResourceCount = v_uint32()
        self.ExReInitializeResourceCount = v_uint32()
        self.ExDeleteResourceCount = v_uint32()
        self.ExecutiveResourceAcquiresCount = v_uint32()
        self.ExecutiveResourceContentionsCount = v_uint32()
        self.ExecutiveResourceReleaseExclusiveCount = v_uint32()
        self.ExecutiveResourceReleaseSharedCount = v_uint32()
        self.ExecutiveResourceConvertsCount = v_uint32()
        self.ExAcqResExclusiveAttempts = v_uint32()
        self.ExAcqResExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResExclusiveAcquiresExclusiveRecursive = v_uint32()
        self.ExAcqResExclusiveWaits = v_uint32()
        self.ExAcqResExclusiveNotAcquires = v_uint32()
        self.ExAcqResSharedAttempts = v_uint32()
        self.ExAcqResSharedAcquiresExclusive = v_uint32()
        self.ExAcqResSharedAcquiresShared = v_uint32()
        self.ExAcqResSharedAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedWaits = v_uint32()
        self.ExAcqResSharedNotAcquires = v_uint32()
        self.ExAcqResSharedStarveExclusiveAttempts = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresShared = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedStarveExclusiveWaits = v_uint32()
        self.ExAcqResSharedStarveExclusiveNotAcquires = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAttempts = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresShared = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedWaitForExclusiveWaits = v_uint32()
        self.ExAcqResSharedWaitForExclusiveNotAcquires = v_uint32()
        self.ExSetResOwnerPointerExclusive = v_uint32()
        self.ExSetResOwnerPointerSharedNew = v_uint32()
        self.ExSetResOwnerPointerSharedOld = v_uint32()
        self.ExTryToAcqExclusiveAttempts = v_uint32()
        self.ExTryToAcqExclusiveAcquires = v_uint32()
        self.ExBoostExclusiveOwner = v_uint32()
        self.ExBoostSharedOwners = v_uint32()
        self.ExEtwSynchTrackingNotificationsCount = v_uint32()
        self.ExEtwSynchTrackingNotificationsAccountedCount = v_uint32()
        self.Context = v_ptr32()
        self.ContextFlags = v_uint32()
        self.ExtendedState = v_ptr32()
        self._pad3628 = v_bytes(size=4)


class _unnamed_7784(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.Thread = v_ptr32()
        self.AuxiliaryBuffer = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.CurrentStackLocation = v_ptr32()
        self.OriginalFileObject = v_ptr32()


class RTL_DYNAMIC_HASH_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.Shift = v_uint32()
        self.TableSize = v_uint32()
        self.Pivot = v_uint32()
        self.DivisorMask = v_uint32()
        self.NumEntries = v_uint32()
        self.NonEmptyBuckets = v_uint32()
        self.NumEnumerators = v_uint32()
        self.Directory = v_ptr32()


class KAFFINITY_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint16()
        self.Size = v_uint16()
        self.Reserved = v_uint32()
        self.Bitmap = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class DEVICE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.ReferenceCount = v_uint32()
        self.DriverObject = v_ptr32()
        self.NextDevice = v_ptr32()
        self.AttachedDevice = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.Timer = v_ptr32()
        self.Flags = v_uint32()
        self.Characteristics = v_uint32()
        self.Vpb = v_ptr32()
        self.DeviceExtension = v_ptr32()
        self.DeviceType = v_uint32()
        self.StackSize = v_uint8()
        self._pad0034 = v_bytes(size=3)
        self.Queue = _unnamed_7305()
        self.AlignmentRequirement = v_uint32()
        self.DeviceQueue = KDEVICE_QUEUE()
        self.Dpc = KDPC()
        self.ActiveThreadCount = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.DeviceLock = KEVENT()
        self.SectorSize = v_uint16()
        self.Spare1 = v_uint16()
        self.DeviceObjectExtension = v_ptr32()
        self.Reserved = v_ptr32()


class USER_MEMORY_CACHE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserBlocks = SLIST_HEADER()
        self.AvailableBlocks = v_uint32()
        self._pad0010 = v_bytes(size=4)


class _unnamed_6512(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Bytes = _unnamed_9067()


class EX_PUSH_LOCK_WAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WakeEvent = KEVENT()
        self.Next = v_ptr32()
        self.Last = v_ptr32()
        self.Previous = v_ptr32()
        self.ShareCount = v_uint32()
        self.Flags = v_uint32()
        self._pad0030 = v_bytes(size=12)


class _unnamed_8097(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InPath = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.Type = v_uint32()


class _unnamed_7945(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self.InputBufferLength = v_uint32()
        self.FsControlCode = v_uint32()
        self.Type3InputBuffer = v_ptr32()


class IMAGE_NT_HEADERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.FileHeader = IMAGE_FILE_HEADER()
        self.OptionalHeader = IMAGE_OPTIONAL_HEADER()


class IO_STACK_LOCATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorFunction = v_uint8()
        self.MinorFunction = v_uint8()
        self.Flags = v_uint8()
        self.Control = v_uint8()
        self.Parameters = _unnamed_7745()
        self.DeviceObject = v_ptr32()
        self.FileObject = v_ptr32()
        self.CompletionRoutine = v_ptr32()
        self.Context = v_ptr32()


class KNODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PagedPoolSListHead = SLIST_HEADER()
        self.NonPagedPoolSListHead = vstruct.VArray([ SLIST_HEADER() for i in xrange(3) ])
        self.Affinity = GROUP_AFFINITY()
        self.ProximityId = v_uint32()
        self.NodeNumber = v_uint16()
        self.PrimaryNodeNumber = v_uint16()
        self.MaximumProcessors = v_uint8()
        self.Color = v_uint8()
        self.Flags = flags()
        self.NodePad0 = v_uint8()
        self.Seed = v_uint32()
        self.MmShiftedColor = v_uint32()
        self.FreeCount = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.CachedKernelStacks = CACHED_KSTACK_LIST()
        self.ParkLock = v_uint32()
        self.NodePad1 = v_uint32()
        self._pad0080 = v_bytes(size=24)


class XSAVE_AREA_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint64()
        self.Reserved = vstruct.VArray([ v_uint64() for i in xrange(7) ])


class PSP_CPU_SHARE_CAPTURED_WEIGHT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CapturedCpuShareWeight = v_uint32()
        self.CapturedTotalWeight = v_uint32()


class _unnamed_8070(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WhichSpace = v_uint32()
        self.Buffer = v_ptr32()
        self.Offset = v_uint32()
        self.Length = v_uint32()


class _unnamed_8075(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint8()


class RTL_USER_PROCESS_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MaximumLength = v_uint32()
        self.Length = v_uint32()
        self.Flags = v_uint32()
        self.DebugFlags = v_uint32()
        self.ConsoleHandle = v_ptr32()
        self.ConsoleFlags = v_uint32()
        self.StandardInput = v_ptr32()
        self.StandardOutput = v_ptr32()
        self.StandardError = v_ptr32()
        self.CurrentDirectory = CURDIR()
        self.DllPath = UNICODE_STRING()
        self.ImagePathName = UNICODE_STRING()
        self.CommandLine = UNICODE_STRING()
        self.Environment = v_ptr32()
        self.StartingX = v_uint32()
        self.StartingY = v_uint32()
        self.CountX = v_uint32()
        self.CountY = v_uint32()
        self.CountCharsX = v_uint32()
        self.CountCharsY = v_uint32()
        self.FillAttribute = v_uint32()
        self.WindowFlags = v_uint32()
        self.ShowWindowFlags = v_uint32()
        self.WindowTitle = UNICODE_STRING()
        self.DesktopInfo = UNICODE_STRING()
        self.ShellInfo = UNICODE_STRING()
        self.RuntimeData = UNICODE_STRING()
        self.CurrentDirectores = vstruct.VArray([ RTL_DRIVE_LETTER_CURDIR() for i in xrange(32) ])
        self.EnvironmentSize = v_uint32()
        self.EnvironmentVersion = v_uint32()


class IO_RESOURCE_REQUIREMENTS_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.SlotNumber = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.AlternativeLists = v_uint32()
        self.List = vstruct.VArray([ IO_RESOURCE_LIST() for i in xrange(1) ])


class HEAP_BUCKET_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalBlocks = v_uint32()
        self.SubSegmentCounts = v_uint32()




########NEW FILE########
__FILENAME__ = ntoskrnl
# Version: 6.1
# Architecture: i386
import vstruct
from vstruct.primitives import *

KPROCESS_STATE = v_enum()
KPROCESS_STATE.ProcessInMemory = 0
KPROCESS_STATE.ProcessOutOfMemory = 1
KPROCESS_STATE.ProcessInTransition = 2
KPROCESS_STATE.ProcessOutTransition = 3
KPROCESS_STATE.ProcessInSwap = 4
KPROCESS_STATE.ProcessOutSwap = 5
KPROCESS_STATE.ProcessAllSwapStates = 6


MI_STORE_BIT_TYPE = v_enum()
MI_STORE_BIT_TYPE.MiStoreBitTypeInStore = 0
MI_STORE_BIT_TYPE.MiStoreBitTypeEvicted = 1
MI_STORE_BIT_TYPE.MiStoreBitTypeMax = 2


IO_ALLOCATION_ACTION = v_enum()
IO_ALLOCATION_ACTION.KeepObject = 1
IO_ALLOCATION_ACTION.DeallocateObject = 2
IO_ALLOCATION_ACTION.DeallocateObjectKeepRegisters = 3


LOCK_OPERATION = v_enum()
LOCK_OPERATION.IoReadAccess = 0
LOCK_OPERATION.IoWriteAccess = 1
LOCK_OPERATION.IoModifyAccess = 2


CONFIGURATION_TYPE = v_enum()
CONFIGURATION_TYPE.ArcSystem = 0
CONFIGURATION_TYPE.CentralProcessor = 1
CONFIGURATION_TYPE.FloatingPointProcessor = 2
CONFIGURATION_TYPE.PrimaryIcache = 3
CONFIGURATION_TYPE.PrimaryDcache = 4
CONFIGURATION_TYPE.SecondaryIcache = 5
CONFIGURATION_TYPE.SecondaryDcache = 6
CONFIGURATION_TYPE.SecondaryCache = 7
CONFIGURATION_TYPE.EisaAdapter = 8
CONFIGURATION_TYPE.TcAdapter = 9
CONFIGURATION_TYPE.ScsiAdapter = 10
CONFIGURATION_TYPE.DtiAdapter = 11
CONFIGURATION_TYPE.MultiFunctionAdapter = 12
CONFIGURATION_TYPE.DiskController = 13
CONFIGURATION_TYPE.TapeController = 14
CONFIGURATION_TYPE.CdromController = 15
CONFIGURATION_TYPE.WormController = 16
CONFIGURATION_TYPE.SerialController = 17
CONFIGURATION_TYPE.NetworkController = 18
CONFIGURATION_TYPE.DisplayController = 19
CONFIGURATION_TYPE.ParallelController = 20
CONFIGURATION_TYPE.PointerController = 21
CONFIGURATION_TYPE.KeyboardController = 22
CONFIGURATION_TYPE.AudioController = 23
CONFIGURATION_TYPE.OtherController = 24
CONFIGURATION_TYPE.DiskPeripheral = 25
CONFIGURATION_TYPE.FloppyDiskPeripheral = 26
CONFIGURATION_TYPE.TapePeripheral = 27
CONFIGURATION_TYPE.ModemPeripheral = 28
CONFIGURATION_TYPE.MonitorPeripheral = 29
CONFIGURATION_TYPE.PrinterPeripheral = 30
CONFIGURATION_TYPE.PointerPeripheral = 31
CONFIGURATION_TYPE.KeyboardPeripheral = 32
CONFIGURATION_TYPE.TerminalPeripheral = 33
CONFIGURATION_TYPE.OtherPeripheral = 34
CONFIGURATION_TYPE.LinePeripheral = 35
CONFIGURATION_TYPE.NetworkPeripheral = 36
CONFIGURATION_TYPE.SystemMemory = 37
CONFIGURATION_TYPE.DockingInformation = 38
CONFIGURATION_TYPE.RealModeIrqRoutingTable = 39
CONFIGURATION_TYPE.RealModePCIEnumeration = 40
CONFIGURATION_TYPE.MaximumType = 41


CM_SHARE_DISPOSITION = v_enum()
CM_SHARE_DISPOSITION.CmResourceShareUndetermined = 0
CM_SHARE_DISPOSITION.CmResourceShareDeviceExclusive = 1
CM_SHARE_DISPOSITION.CmResourceShareDriverExclusive = 2
CM_SHARE_DISPOSITION.CmResourceShareShared = 3


KWAIT_BLOCK_STATE = v_enum()
KWAIT_BLOCK_STATE.WaitBlockBypassStart = 0
KWAIT_BLOCK_STATE.WaitBlockBypassComplete = 1
KWAIT_BLOCK_STATE.WaitBlockActive = 2
KWAIT_BLOCK_STATE.WaitBlockInactive = 3
KWAIT_BLOCK_STATE.WaitBlockAllStates = 4


PROCESSOR_CACHE_TYPE = v_enum()
PROCESSOR_CACHE_TYPE.CacheUnified = 0
PROCESSOR_CACHE_TYPE.CacheInstruction = 1
PROCESSOR_CACHE_TYPE.CacheData = 2
PROCESSOR_CACHE_TYPE.CacheTrace = 3


EVENT_TYPE = v_enum()
EVENT_TYPE.NotificationEvent = 0
EVENT_TYPE.SynchronizationEvent = 1


KSPIN_LOCK_QUEUE_NUMBER = v_enum()
KSPIN_LOCK_QUEUE_NUMBER.LockQueueUnusedSpare0 = 0
KSPIN_LOCK_QUEUE_NUMBER.LockQueueExpansionLock = 1
KSPIN_LOCK_QUEUE_NUMBER.LockQueueUnusedSpare2 = 2
KSPIN_LOCK_QUEUE_NUMBER.LockQueueSystemSpaceLock = 3
KSPIN_LOCK_QUEUE_NUMBER.LockQueueVacbLock = 4
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMasterLock = 5
KSPIN_LOCK_QUEUE_NUMBER.LockQueueNonPagedPoolLock = 6
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoCancelLock = 7
KSPIN_LOCK_QUEUE_NUMBER.LockQueueWorkQueueLock = 8
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoVpbLock = 9
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoDatabaseLock = 10
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoCompletionLock = 11
KSPIN_LOCK_QUEUE_NUMBER.LockQueueNtfsStructLock = 12
KSPIN_LOCK_QUEUE_NUMBER.LockQueueAfdWorkQueueLock = 13
KSPIN_LOCK_QUEUE_NUMBER.LockQueueBcbLock = 14
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMmNonPagedPoolLock = 15
KSPIN_LOCK_QUEUE_NUMBER.LockQueueUnusedSpare16 = 16
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMaximumLock = 17


PROFILE_DEPARTURE_STYLE = v_enum()
PROFILE_DEPARTURE_STYLE.PDS_UPDATE_DEFAULT = 1
PROFILE_DEPARTURE_STYLE.PDS_UPDATE_ON_REMOVE = 2
PROFILE_DEPARTURE_STYLE.PDS_UPDATE_ON_INTERFACE = 3
PROFILE_DEPARTURE_STYLE.PDS_UPDATE_ON_EJECT = 4


OB_OPEN_REASON = v_enum()
OB_OPEN_REASON.ObCreateHandle = 0
OB_OPEN_REASON.ObOpenHandle = 1
OB_OPEN_REASON.ObDuplicateHandle = 2
OB_OPEN_REASON.ObInheritHandle = 3
OB_OPEN_REASON.ObMaxOpenReason = 4


PNP_DEVNODE_STATE = v_enum()
PNP_DEVNODE_STATE.DeviceNodeUnspecified = 768
PNP_DEVNODE_STATE.DeviceNodeUninitialized = 769
PNP_DEVNODE_STATE.DeviceNodeInitialized = 770
PNP_DEVNODE_STATE.DeviceNodeDriversAdded = 771
PNP_DEVNODE_STATE.DeviceNodeResourcesAssigned = 772
PNP_DEVNODE_STATE.DeviceNodeStartPending = 773
PNP_DEVNODE_STATE.DeviceNodeStartCompletion = 774
PNP_DEVNODE_STATE.DeviceNodeStartPostWork = 775
PNP_DEVNODE_STATE.DeviceNodeStarted = 776
PNP_DEVNODE_STATE.DeviceNodeQueryStopped = 777
PNP_DEVNODE_STATE.DeviceNodeStopped = 778
PNP_DEVNODE_STATE.DeviceNodeRestartCompletion = 779
PNP_DEVNODE_STATE.DeviceNodeEnumeratePending = 780
PNP_DEVNODE_STATE.DeviceNodeEnumerateCompletion = 781
PNP_DEVNODE_STATE.DeviceNodeAwaitingQueuedDeletion = 782
PNP_DEVNODE_STATE.DeviceNodeAwaitingQueuedRemoval = 783
PNP_DEVNODE_STATE.DeviceNodeQueryRemoved = 784
PNP_DEVNODE_STATE.DeviceNodeRemovePendingCloses = 785
PNP_DEVNODE_STATE.DeviceNodeRemoved = 786
PNP_DEVNODE_STATE.DeviceNodeDeletePendingCloses = 787
PNP_DEVNODE_STATE.DeviceNodeDeleted = 788
PNP_DEVNODE_STATE.MaxDeviceNodeState = 789


POWER_STATE_TYPE = v_enum()
POWER_STATE_TYPE.SystemPowerState = 0
POWER_STATE_TYPE.DevicePowerState = 1


TYPE_OF_MEMORY = v_enum()
TYPE_OF_MEMORY.LoaderExceptionBlock = 0
TYPE_OF_MEMORY.LoaderSystemBlock = 1
TYPE_OF_MEMORY.LoaderFree = 2
TYPE_OF_MEMORY.LoaderBad = 3
TYPE_OF_MEMORY.LoaderLoadedProgram = 4
TYPE_OF_MEMORY.LoaderFirmwareTemporary = 5
TYPE_OF_MEMORY.LoaderFirmwarePermanent = 6
TYPE_OF_MEMORY.LoaderOsloaderHeap = 7
TYPE_OF_MEMORY.LoaderOsloaderStack = 8
TYPE_OF_MEMORY.LoaderSystemCode = 9
TYPE_OF_MEMORY.LoaderHalCode = 10
TYPE_OF_MEMORY.LoaderBootDriver = 11
TYPE_OF_MEMORY.LoaderConsoleInDriver = 12
TYPE_OF_MEMORY.LoaderConsoleOutDriver = 13
TYPE_OF_MEMORY.LoaderStartupDpcStack = 14
TYPE_OF_MEMORY.LoaderStartupKernelStack = 15
TYPE_OF_MEMORY.LoaderStartupPanicStack = 16
TYPE_OF_MEMORY.LoaderStartupPcrPage = 17
TYPE_OF_MEMORY.LoaderStartupPdrPage = 18
TYPE_OF_MEMORY.LoaderRegistryData = 19
TYPE_OF_MEMORY.LoaderMemoryData = 20
TYPE_OF_MEMORY.LoaderNlsData = 21
TYPE_OF_MEMORY.LoaderSpecialMemory = 22
TYPE_OF_MEMORY.LoaderBBTMemory = 23
TYPE_OF_MEMORY.LoaderReserve = 24
TYPE_OF_MEMORY.LoaderXIPRom = 25
TYPE_OF_MEMORY.LoaderHALCachedMemory = 26
TYPE_OF_MEMORY.LoaderLargePageFiller = 27
TYPE_OF_MEMORY.LoaderErrorLogMemory = 28
TYPE_OF_MEMORY.LoaderMaximum = 29


KTM_STATE = v_enum()
KTM_STATE.KKtmUninitialized = 0
KTM_STATE.KKtmInitialized = 1
KTM_STATE.KKtmRecovering = 2
KTM_STATE.KKtmOnline = 3
KTM_STATE.KKtmRecoveryFailed = 4
KTM_STATE.KKtmOffline = 5


PP_NPAGED_LOOKASIDE_NUMBER = v_enum()
PP_NPAGED_LOOKASIDE_NUMBER.LookasideSmallIrpList = 0
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMediumIrpList = 1
PP_NPAGED_LOOKASIDE_NUMBER.LookasideLargeIrpList = 2
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMdlList = 3
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCreateInfoList = 4
PP_NPAGED_LOOKASIDE_NUMBER.LookasideNameBufferList = 5
PP_NPAGED_LOOKASIDE_NUMBER.LookasideTwilightList = 6
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCompletionList = 7
PP_NPAGED_LOOKASIDE_NUMBER.LookasideScratchBufferList = 8
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMaximumList = 9


PLUGPLAY_EVENT_CATEGORY = v_enum()
PLUGPLAY_EVENT_CATEGORY.HardwareProfileChangeEvent = 0
PLUGPLAY_EVENT_CATEGORY.TargetDeviceChangeEvent = 1
PLUGPLAY_EVENT_CATEGORY.DeviceClassChangeEvent = 2
PLUGPLAY_EVENT_CATEGORY.CustomDeviceEvent = 3
PLUGPLAY_EVENT_CATEGORY.DeviceInstallEvent = 4
PLUGPLAY_EVENT_CATEGORY.DeviceArrivalEvent = 5
PLUGPLAY_EVENT_CATEGORY.VetoEvent = 6
PLUGPLAY_EVENT_CATEGORY.BlockedDriverEvent = 7
PLUGPLAY_EVENT_CATEGORY.InvalidIDEvent = 8
PLUGPLAY_EVENT_CATEGORY.DevicePropertyChangeEvent = 9
PLUGPLAY_EVENT_CATEGORY.DeviceInstanceRemovalEvent = 10
PLUGPLAY_EVENT_CATEGORY.MaxPlugEventCategory = 11


IO_SESSION_STATE = v_enum()
IO_SESSION_STATE.IoSessionStateCreated = 1
IO_SESSION_STATE.IoSessionStateInitialized = 2
IO_SESSION_STATE.IoSessionStateConnected = 3
IO_SESSION_STATE.IoSessionStateDisconnected = 4
IO_SESSION_STATE.IoSessionStateDisconnectedLoggedOn = 5
IO_SESSION_STATE.IoSessionStateLoggedOn = 6
IO_SESSION_STATE.IoSessionStateLoggedOff = 7
IO_SESSION_STATE.IoSessionStateTerminated = 8
IO_SESSION_STATE.IoSessionStateMax = 9


WHEA_ERROR_TYPE = v_enum()
WHEA_ERROR_TYPE.WheaErrTypeProcessor = 0
WHEA_ERROR_TYPE.WheaErrTypeMemory = 1
WHEA_ERROR_TYPE.WheaErrTypePCIExpress = 2
WHEA_ERROR_TYPE.WheaErrTypeNMI = 3
WHEA_ERROR_TYPE.WheaErrTypePCIXBus = 4
WHEA_ERROR_TYPE.WheaErrTypePCIXDevice = 5
WHEA_ERROR_TYPE.WheaErrTypeGeneric = 6


ARBITER_RESULT = v_enum()
ARBITER_RESULT.ArbiterResultUndefined = -1
ARBITER_RESULT.ArbiterResultSuccess = 0
ARBITER_RESULT.ArbiterResultExternalConflict = 1
ARBITER_RESULT.ArbiterResultNullRequest = 2


MI_DYNAMIC_MEMORY_LOCKTYPE = v_enum()
MI_DYNAMIC_MEMORY_LOCKTYPE.AlreadyHeld = 0
MI_DYNAMIC_MEMORY_LOCKTYPE.AcquiredShared = 1
MI_DYNAMIC_MEMORY_LOCKTYPE.UseSpinLock = 2
MI_DYNAMIC_MEMORY_LOCKTYPE.UseSpinLockRaiseIrql = 3


DEVICE_TEXT_TYPE = v_enum()
DEVICE_TEXT_TYPE.DeviceTextDescription = 0
DEVICE_TEXT_TYPE.DeviceTextLocationInformation = 1


POWER_ACTION = v_enum()
POWER_ACTION.PowerActionNone = 0
POWER_ACTION.PowerActionReserved = 1
POWER_ACTION.PowerActionSleep = 2
POWER_ACTION.PowerActionHibernate = 3
POWER_ACTION.PowerActionShutdown = 4
POWER_ACTION.PowerActionShutdownReset = 5
POWER_ACTION.PowerActionShutdownOff = 6
POWER_ACTION.PowerActionWarmEject = 7


CONFIGURATION_CLASS = v_enum()
CONFIGURATION_CLASS.SystemClass = 0
CONFIGURATION_CLASS.ProcessorClass = 1
CONFIGURATION_CLASS.CacheClass = 2
CONFIGURATION_CLASS.AdapterClass = 3
CONFIGURATION_CLASS.ControllerClass = 4
CONFIGURATION_CLASS.PeripheralClass = 5
CONFIGURATION_CLASS.MemoryClass = 6
CONFIGURATION_CLASS.MaximumClass = 7


ARBITER_REQUEST_SOURCE = v_enum()
ARBITER_REQUEST_SOURCE.ArbiterRequestUndefined = -1
ARBITER_REQUEST_SOURCE.ArbiterRequestLegacyReported = 0
ARBITER_REQUEST_SOURCE.ArbiterRequestHalReported = 1
ARBITER_REQUEST_SOURCE.ArbiterRequestLegacyAssigned = 2
ARBITER_REQUEST_SOURCE.ArbiterRequestPnpDetected = 3
ARBITER_REQUEST_SOURCE.ArbiterRequestPnpEnumerated = 4


KOBJECTS = v_enum()
KOBJECTS.EventNotificationObject = 0
KOBJECTS.EventSynchronizationObject = 1
KOBJECTS.MutantObject = 2
KOBJECTS.ProcessObject = 3
KOBJECTS.QueueObject = 4
KOBJECTS.SemaphoreObject = 5
KOBJECTS.ThreadObject = 6
KOBJECTS.GateObject = 7
KOBJECTS.TimerNotificationObject = 8
KOBJECTS.TimerSynchronizationObject = 9
KOBJECTS.Spare2Object = 10
KOBJECTS.Spare3Object = 11
KOBJECTS.Spare4Object = 12
KOBJECTS.Spare5Object = 13
KOBJECTS.Spare6Object = 14
KOBJECTS.Spare7Object = 15
KOBJECTS.Spare8Object = 16
KOBJECTS.Spare9Object = 17
KOBJECTS.ApcObject = 18
KOBJECTS.DpcObject = 19
KOBJECTS.DeviceQueueObject = 20
KOBJECTS.EventPairObject = 21
KOBJECTS.InterruptObject = 22
KOBJECTS.ProfileObject = 23
KOBJECTS.ThreadedDpcObject = 24
KOBJECTS.MaximumKernelObject = 25


PNP_DEVICE_ACTION_REQUEST = v_enum()
PNP_DEVICE_ACTION_REQUEST.AssignResources = 0
PNP_DEVICE_ACTION_REQUEST.ClearDeviceProblem = 1
PNP_DEVICE_ACTION_REQUEST.ClearProblem = 2
PNP_DEVICE_ACTION_REQUEST.ClearEjectProblem = 3
PNP_DEVICE_ACTION_REQUEST.HaltDevice = 4
PNP_DEVICE_ACTION_REQUEST.QueryPowerRelations = 5
PNP_DEVICE_ACTION_REQUEST.Rebalance = 6
PNP_DEVICE_ACTION_REQUEST.ReenumerateBootDevices = 7
PNP_DEVICE_ACTION_REQUEST.ReenumerateDeviceOnly = 8
PNP_DEVICE_ACTION_REQUEST.ReenumerateDeviceTree = 9
PNP_DEVICE_ACTION_REQUEST.ReenumerateRootDevices = 10
PNP_DEVICE_ACTION_REQUEST.RequeryDeviceState = 11
PNP_DEVICE_ACTION_REQUEST.ResetDevice = 12
PNP_DEVICE_ACTION_REQUEST.ResourceRequirementsChanged = 13
PNP_DEVICE_ACTION_REQUEST.RestartEnumeration = 14
PNP_DEVICE_ACTION_REQUEST.SetDeviceProblem = 15
PNP_DEVICE_ACTION_REQUEST.StartDevice = 16
PNP_DEVICE_ACTION_REQUEST.StartSystemDevicesPass0 = 17
PNP_DEVICE_ACTION_REQUEST.StartSystemDevicesPass1 = 18


ETW_BUFFER_STATE = v_enum()
ETW_BUFFER_STATE.EtwBufferStateFree = 0
ETW_BUFFER_STATE.EtwBufferStateGeneralLogging = 1
ETW_BUFFER_STATE.EtwBufferStateCSwitch = 2
ETW_BUFFER_STATE.EtwBufferStateFlush = 3
ETW_BUFFER_STATE.EtwBufferStateMaximum = 4


POWER_POLICY_DEVICE_TYPE = v_enum()
POWER_POLICY_DEVICE_TYPE.PolicyDeviceSystemButton = 0
POWER_POLICY_DEVICE_TYPE.PolicyDeviceThermalZone = 1
POWER_POLICY_DEVICE_TYPE.PolicyDeviceBattery = 2
POWER_POLICY_DEVICE_TYPE.PolicyDeviceMemory = 3
POWER_POLICY_DEVICE_TYPE.PolicyInitiatePowerActionAPI = 4
POWER_POLICY_DEVICE_TYPE.PolicySetPowerStateAPI = 5
POWER_POLICY_DEVICE_TYPE.PolicyImmediateDozeS4 = 6
POWER_POLICY_DEVICE_TYPE.PolicySystemIdle = 7
POWER_POLICY_DEVICE_TYPE.PolicyDeviceMax = 8


UoWActionType = v_enum()
UoWActionType.UoWAddThisKey = 0
UoWActionType.UoWAddChildKey = 1
UoWActionType.UoWDeleteThisKey = 2
UoWActionType.UoWDeleteChildKey = 3
UoWActionType.UoWSetValueNew = 4
UoWActionType.UoWSetValueExisting = 5
UoWActionType.UoWDeleteValue = 6
UoWActionType.UoWSetKeyUserFlags = 7
UoWActionType.UoWSetLastWriteTime = 8
UoWActionType.UoWSetSecurityDescriptor = 9
UoWActionType.UoWRenameSubKey = 10
UoWActionType.UoWRenameOldSubKey = 11
UoWActionType.UoWRenameNewSubKey = 12
UoWActionType.UoWIsolation = 13
UoWActionType.UoWInvalid = 14


WHEA_ERROR_PACKET_DATA_FORMAT = v_enum()
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatIPFSalRecord = 0
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatXPFMCA = 1
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMemory = 2
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIExpress = 3
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatNMIPort = 4
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXBus = 5
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXDevice = 6
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatGeneric = 7
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMax = 8


DPFLTR_TYPE = v_enum()
DPFLTR_TYPE.DPFLTR_SYSTEM_ID = 0
DPFLTR_TYPE.DPFLTR_SMSS_ID = 1
DPFLTR_TYPE.DPFLTR_SETUP_ID = 2
DPFLTR_TYPE.DPFLTR_NTFS_ID = 3
DPFLTR_TYPE.DPFLTR_FSTUB_ID = 4
DPFLTR_TYPE.DPFLTR_CRASHDUMP_ID = 5
DPFLTR_TYPE.DPFLTR_CDAUDIO_ID = 6
DPFLTR_TYPE.DPFLTR_CDROM_ID = 7
DPFLTR_TYPE.DPFLTR_CLASSPNP_ID = 8
DPFLTR_TYPE.DPFLTR_DISK_ID = 9
DPFLTR_TYPE.DPFLTR_REDBOOK_ID = 10
DPFLTR_TYPE.DPFLTR_STORPROP_ID = 11
DPFLTR_TYPE.DPFLTR_SCSIPORT_ID = 12
DPFLTR_TYPE.DPFLTR_SCSIMINIPORT_ID = 13
DPFLTR_TYPE.DPFLTR_CONFIG_ID = 14
DPFLTR_TYPE.DPFLTR_I8042PRT_ID = 15
DPFLTR_TYPE.DPFLTR_SERMOUSE_ID = 16
DPFLTR_TYPE.DPFLTR_LSERMOUS_ID = 17
DPFLTR_TYPE.DPFLTR_KBDHID_ID = 18
DPFLTR_TYPE.DPFLTR_MOUHID_ID = 19
DPFLTR_TYPE.DPFLTR_KBDCLASS_ID = 20
DPFLTR_TYPE.DPFLTR_MOUCLASS_ID = 21
DPFLTR_TYPE.DPFLTR_TWOTRACK_ID = 22
DPFLTR_TYPE.DPFLTR_WMILIB_ID = 23
DPFLTR_TYPE.DPFLTR_ACPI_ID = 24
DPFLTR_TYPE.DPFLTR_AMLI_ID = 25
DPFLTR_TYPE.DPFLTR_HALIA64_ID = 26
DPFLTR_TYPE.DPFLTR_VIDEO_ID = 27
DPFLTR_TYPE.DPFLTR_SVCHOST_ID = 28
DPFLTR_TYPE.DPFLTR_VIDEOPRT_ID = 29
DPFLTR_TYPE.DPFLTR_TCPIP_ID = 30
DPFLTR_TYPE.DPFLTR_DMSYNTH_ID = 31
DPFLTR_TYPE.DPFLTR_NTOSPNP_ID = 32
DPFLTR_TYPE.DPFLTR_FASTFAT_ID = 33
DPFLTR_TYPE.DPFLTR_SAMSS_ID = 34
DPFLTR_TYPE.DPFLTR_PNPMGR_ID = 35
DPFLTR_TYPE.DPFLTR_NETAPI_ID = 36
DPFLTR_TYPE.DPFLTR_SCSERVER_ID = 37
DPFLTR_TYPE.DPFLTR_SCCLIENT_ID = 38
DPFLTR_TYPE.DPFLTR_SERIAL_ID = 39
DPFLTR_TYPE.DPFLTR_SERENUM_ID = 40
DPFLTR_TYPE.DPFLTR_UHCD_ID = 41
DPFLTR_TYPE.DPFLTR_RPCPROXY_ID = 42
DPFLTR_TYPE.DPFLTR_AUTOCHK_ID = 43
DPFLTR_TYPE.DPFLTR_DCOMSS_ID = 44
DPFLTR_TYPE.DPFLTR_UNIMODEM_ID = 45
DPFLTR_TYPE.DPFLTR_SIS_ID = 46
DPFLTR_TYPE.DPFLTR_FLTMGR_ID = 47
DPFLTR_TYPE.DPFLTR_WMICORE_ID = 48
DPFLTR_TYPE.DPFLTR_BURNENG_ID = 49
DPFLTR_TYPE.DPFLTR_IMAPI_ID = 50
DPFLTR_TYPE.DPFLTR_SXS_ID = 51
DPFLTR_TYPE.DPFLTR_FUSION_ID = 52
DPFLTR_TYPE.DPFLTR_IDLETASK_ID = 53
DPFLTR_TYPE.DPFLTR_SOFTPCI_ID = 54
DPFLTR_TYPE.DPFLTR_TAPE_ID = 55
DPFLTR_TYPE.DPFLTR_MCHGR_ID = 56
DPFLTR_TYPE.DPFLTR_IDEP_ID = 57
DPFLTR_TYPE.DPFLTR_PCIIDE_ID = 58
DPFLTR_TYPE.DPFLTR_FLOPPY_ID = 59
DPFLTR_TYPE.DPFLTR_FDC_ID = 60
DPFLTR_TYPE.DPFLTR_TERMSRV_ID = 61
DPFLTR_TYPE.DPFLTR_W32TIME_ID = 62
DPFLTR_TYPE.DPFLTR_PREFETCHER_ID = 63
DPFLTR_TYPE.DPFLTR_RSFILTER_ID = 64
DPFLTR_TYPE.DPFLTR_FCPORT_ID = 65
DPFLTR_TYPE.DPFLTR_PCI_ID = 66
DPFLTR_TYPE.DPFLTR_DMIO_ID = 67
DPFLTR_TYPE.DPFLTR_DMCONFIG_ID = 68
DPFLTR_TYPE.DPFLTR_DMADMIN_ID = 69
DPFLTR_TYPE.DPFLTR_WSOCKTRANSPORT_ID = 70
DPFLTR_TYPE.DPFLTR_VSS_ID = 71
DPFLTR_TYPE.DPFLTR_PNPMEM_ID = 72
DPFLTR_TYPE.DPFLTR_PROCESSOR_ID = 73
DPFLTR_TYPE.DPFLTR_DMSERVER_ID = 74
DPFLTR_TYPE.DPFLTR_SR_ID = 75
DPFLTR_TYPE.DPFLTR_INFINIBAND_ID = 76
DPFLTR_TYPE.DPFLTR_IHVDRIVER_ID = 77
DPFLTR_TYPE.DPFLTR_IHVVIDEO_ID = 78
DPFLTR_TYPE.DPFLTR_IHVAUDIO_ID = 79
DPFLTR_TYPE.DPFLTR_IHVNETWORK_ID = 80
DPFLTR_TYPE.DPFLTR_IHVSTREAMING_ID = 81
DPFLTR_TYPE.DPFLTR_IHVBUS_ID = 82
DPFLTR_TYPE.DPFLTR_HPS_ID = 83
DPFLTR_TYPE.DPFLTR_RTLTHREADPOOL_ID = 84
DPFLTR_TYPE.DPFLTR_LDR_ID = 85
DPFLTR_TYPE.DPFLTR_TCPIP6_ID = 86
DPFLTR_TYPE.DPFLTR_ISAPNP_ID = 87
DPFLTR_TYPE.DPFLTR_SHPC_ID = 88
DPFLTR_TYPE.DPFLTR_STORPORT_ID = 89
DPFLTR_TYPE.DPFLTR_STORMINIPORT_ID = 90
DPFLTR_TYPE.DPFLTR_PRINTSPOOLER_ID = 91
DPFLTR_TYPE.DPFLTR_VSSDYNDISK_ID = 92
DPFLTR_TYPE.DPFLTR_VERIFIER_ID = 93
DPFLTR_TYPE.DPFLTR_VDS_ID = 94
DPFLTR_TYPE.DPFLTR_VDSBAS_ID = 95
DPFLTR_TYPE.DPFLTR_VDSDYN_ID = 96
DPFLTR_TYPE.DPFLTR_VDSDYNDR_ID = 97
DPFLTR_TYPE.DPFLTR_VDSLDR_ID = 98
DPFLTR_TYPE.DPFLTR_VDSUTIL_ID = 99
DPFLTR_TYPE.DPFLTR_DFRGIFC_ID = 100
DPFLTR_TYPE.DPFLTR_DEFAULT_ID = 101
DPFLTR_TYPE.DPFLTR_MM_ID = 102
DPFLTR_TYPE.DPFLTR_DFSC_ID = 103
DPFLTR_TYPE.DPFLTR_WOW64_ID = 104
DPFLTR_TYPE.DPFLTR_ALPC_ID = 105
DPFLTR_TYPE.DPFLTR_WDI_ID = 106
DPFLTR_TYPE.DPFLTR_PERFLIB_ID = 107
DPFLTR_TYPE.DPFLTR_KTM_ID = 108
DPFLTR_TYPE.DPFLTR_IOSTRESS_ID = 109
DPFLTR_TYPE.DPFLTR_HEAP_ID = 110
DPFLTR_TYPE.DPFLTR_WHEA_ID = 111
DPFLTR_TYPE.DPFLTR_USERGDI_ID = 112
DPFLTR_TYPE.DPFLTR_MMCSS_ID = 113
DPFLTR_TYPE.DPFLTR_TPM_ID = 114
DPFLTR_TYPE.DPFLTR_THREADORDER_ID = 115
DPFLTR_TYPE.DPFLTR_ENVIRON_ID = 116
DPFLTR_TYPE.DPFLTR_EMS_ID = 117
DPFLTR_TYPE.DPFLTR_WDT_ID = 118
DPFLTR_TYPE.DPFLTR_FVEVOL_ID = 119
DPFLTR_TYPE.DPFLTR_NDIS_ID = 120
DPFLTR_TYPE.DPFLTR_NVCTRACE_ID = 121
DPFLTR_TYPE.DPFLTR_LUAFV_ID = 122
DPFLTR_TYPE.DPFLTR_APPCOMPAT_ID = 123
DPFLTR_TYPE.DPFLTR_USBSTOR_ID = 124
DPFLTR_TYPE.DPFLTR_SBP2PORT_ID = 125
DPFLTR_TYPE.DPFLTR_COVERAGE_ID = 126
DPFLTR_TYPE.DPFLTR_CACHEMGR_ID = 127
DPFLTR_TYPE.DPFLTR_MOUNTMGR_ID = 128
DPFLTR_TYPE.DPFLTR_CFR_ID = 129
DPFLTR_TYPE.DPFLTR_TXF_ID = 130
DPFLTR_TYPE.DPFLTR_KSECDD_ID = 131
DPFLTR_TYPE.DPFLTR_FLTREGRESS_ID = 132
DPFLTR_TYPE.DPFLTR_MPIO_ID = 133
DPFLTR_TYPE.DPFLTR_MSDSM_ID = 134
DPFLTR_TYPE.DPFLTR_UDFS_ID = 135
DPFLTR_TYPE.DPFLTR_PSHED_ID = 136
DPFLTR_TYPE.DPFLTR_STORVSP_ID = 137
DPFLTR_TYPE.DPFLTR_LSASS_ID = 138
DPFLTR_TYPE.DPFLTR_SSPICLI_ID = 139
DPFLTR_TYPE.DPFLTR_CNG_ID = 140
DPFLTR_TYPE.DPFLTR_EXFAT_ID = 141
DPFLTR_TYPE.DPFLTR_FILETRACE_ID = 142
DPFLTR_TYPE.DPFLTR_XSAVE_ID = 143
DPFLTR_TYPE.DPFLTR_SE_ID = 144
DPFLTR_TYPE.DPFLTR_DRIVEEXTENDER_ID = 145
DPFLTR_TYPE.DPFLTR_ENDOFTABLE_ID = 146


IO_PRIORITY_HINT = v_enum()
IO_PRIORITY_HINT.IoPriorityVeryLow = 0
IO_PRIORITY_HINT.IoPriorityLow = 1
IO_PRIORITY_HINT.IoPriorityNormal = 2
IO_PRIORITY_HINT.IoPriorityHigh = 3
IO_PRIORITY_HINT.IoPriorityCritical = 4
IO_PRIORITY_HINT.MaxIoPriorityTypes = 5


SYSTEM_POWER_CONDITION = v_enum()
SYSTEM_POWER_CONDITION.PoAc = 0
SYSTEM_POWER_CONDITION.PoDc = 1
SYSTEM_POWER_CONDITION.PoHot = 2
SYSTEM_POWER_CONDITION.PoConditionMaximum = 3


KTRANSACTION_OUTCOME = v_enum()
KTRANSACTION_OUTCOME.KTxOutcomeUninitialized = 0
KTRANSACTION_OUTCOME.KTxOutcomeUndetermined = 1
KTRANSACTION_OUTCOME.KTxOutcomeCommitted = 2
KTRANSACTION_OUTCOME.KTxOutcomeAborted = 3
KTRANSACTION_OUTCOME.KTxOutcomeUnavailable = 4


KENLISTMENT_STATE = v_enum()
KENLISTMENT_STATE.KEnlistmentUninitialized = 0
KENLISTMENT_STATE.KEnlistmentActive = 256
KENLISTMENT_STATE.KEnlistmentPreparing = 257
KENLISTMENT_STATE.KEnlistmentPrepared = 258
KENLISTMENT_STATE.KEnlistmentInDoubt = 259
KENLISTMENT_STATE.KEnlistmentCommitted = 260
KENLISTMENT_STATE.KEnlistmentCommittedNotify = 261
KENLISTMENT_STATE.KEnlistmentCommitRequested = 262
KENLISTMENT_STATE.KEnlistmentAborted = 263
KENLISTMENT_STATE.KEnlistmentDelegated = 264
KENLISTMENT_STATE.KEnlistmentDelegatedDisconnected = 265
KENLISTMENT_STATE.KEnlistmentPrePreparing = 266
KENLISTMENT_STATE.KEnlistmentForgotten = 267
KENLISTMENT_STATE.KEnlistmentRecovering = 268
KENLISTMENT_STATE.KEnlistmentAborting = 269
KENLISTMENT_STATE.KEnlistmentReadOnly = 270
KENLISTMENT_STATE.KEnlistmentOutcomeUnavailable = 271
KENLISTMENT_STATE.KEnlistmentOffline = 272
KENLISTMENT_STATE.KEnlistmentPrePrepared = 273
KENLISTMENT_STATE.KEnlistmentInitialized = 274


ETW_PROVIDER_STATE = v_enum()
ETW_PROVIDER_STATE.EtwProviderStateFree = 0
ETW_PROVIDER_STATE.EtwProviderStateTransition = 1
ETW_PROVIDER_STATE.EtwProviderStateActive = 2
ETW_PROVIDER_STATE.EtwProviderStateMax = 3


EX_POOL_PRIORITY = v_enum()
EX_POOL_PRIORITY.LowPoolPriority = 0
EX_POOL_PRIORITY.LowPoolPrioritySpecialPoolOverrun = 8
EX_POOL_PRIORITY.LowPoolPrioritySpecialPoolUnderrun = 9
EX_POOL_PRIORITY.NormalPoolPriority = 16
EX_POOL_PRIORITY.NormalPoolPrioritySpecialPoolOverrun = 24
EX_POOL_PRIORITY.NormalPoolPrioritySpecialPoolUnderrun = 25
EX_POOL_PRIORITY.HighPoolPriority = 32
EX_POOL_PRIORITY.HighPoolPrioritySpecialPoolOverrun = 40
EX_POOL_PRIORITY.HighPoolPrioritySpecialPoolUnderrun = 41


KINTERRUPT_POLARITY = v_enum()
KINTERRUPT_POLARITY.InterruptPolarityUnknown = 0
KINTERRUPT_POLARITY.InterruptActiveHigh = 1
KINTERRUPT_POLARITY.InterruptActiveLow = 2


PNP_VETO_TYPE = v_enum()
PNP_VETO_TYPE.PNP_VetoTypeUnknown = 0
PNP_VETO_TYPE.PNP_VetoLegacyDevice = 1
PNP_VETO_TYPE.PNP_VetoPendingClose = 2
PNP_VETO_TYPE.PNP_VetoWindowsApp = 3
PNP_VETO_TYPE.PNP_VetoWindowsService = 4
PNP_VETO_TYPE.PNP_VetoOutstandingOpen = 5
PNP_VETO_TYPE.PNP_VetoDevice = 6
PNP_VETO_TYPE.PNP_VetoDriver = 7
PNP_VETO_TYPE.PNP_VetoIllegalDeviceRequest = 8
PNP_VETO_TYPE.PNP_VetoInsufficientPower = 9
PNP_VETO_TYPE.PNP_VetoNonDisableable = 10
PNP_VETO_TYPE.PNP_VetoLegacyDriver = 11
PNP_VETO_TYPE.PNP_VetoInsufficientRights = 12


SECURITY_IMPERSONATION_LEVEL = v_enum()
SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous = 0
SECURITY_IMPERSONATION_LEVEL.SecurityIdentification = 1
SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation = 2
SECURITY_IMPERSONATION_LEVEL.SecurityDelegation = 3


KRESOURCEMANAGER_STATE = v_enum()
KRESOURCEMANAGER_STATE.KResourceManagerUninitialized = 0
KRESOURCEMANAGER_STATE.KResourceManagerOffline = 1
KRESOURCEMANAGER_STATE.KResourceManagerOnline = 2


ALTERNATIVE_ARCHITECTURE_TYPE = v_enum()
ALTERNATIVE_ARCHITECTURE_TYPE.StandardDesign = 0
ALTERNATIVE_ARCHITECTURE_TYPE.NEC98x86 = 1
ALTERNATIVE_ARCHITECTURE_TYPE.EndAlternatives = 2


PCW_CALLBACK_TYPE = v_enum()
PCW_CALLBACK_TYPE.PcwCallbackAddCounter = 0
PCW_CALLBACK_TYPE.PcwCallbackRemoveCounter = 1
PCW_CALLBACK_TYPE.PcwCallbackEnumerateInstances = 2
PCW_CALLBACK_TYPE.PcwCallbackCollectData = 3


REQUESTER_TYPE = v_enum()
REQUESTER_TYPE.KernelRequester = 0
REQUESTER_TYPE.UserProcessRequester = 1
REQUESTER_TYPE.UserSharedServiceRequester = 2


PF_FILE_ACCESS_TYPE = v_enum()
PF_FILE_ACCESS_TYPE.PfFileAccessTypeRead = 0
PF_FILE_ACCESS_TYPE.PfFileAccessTypeWrite = 1
PF_FILE_ACCESS_TYPE.PfFileAccessTypeMax = 2


MEMORY_CACHING_TYPE_ORIG = v_enum()
MEMORY_CACHING_TYPE_ORIG.MmFrameBufferCached = 2


PROFILE_STATUS = v_enum()
PROFILE_STATUS.DOCK_NOTDOCKDEVICE = 0
PROFILE_STATUS.DOCK_QUIESCENT = 1
PROFILE_STATUS.DOCK_ARRIVING = 2
PROFILE_STATUS.DOCK_DEPARTING = 3
PROFILE_STATUS.DOCK_EJECTIRP_COMPLETED = 4


MM_POOL_PRIORITIES = v_enum()
MM_POOL_PRIORITIES.MmHighPriority = 0
MM_POOL_PRIORITIES.MmNormalPriority = 1
MM_POOL_PRIORITIES.MmLowPriority = 2
MM_POOL_PRIORITIES.MmMaximumPoolPriority = 3


BLOB_ID = v_enum()
BLOB_ID.BLOB_TYPE_UNKNOWN = 0
BLOB_ID.BLOB_TYPE_CONNECTION_INFO = 1
BLOB_ID.BLOB_TYPE_MESSAGE = 2
BLOB_ID.BLOB_TYPE_SECURITY_CONTEXT = 3
BLOB_ID.BLOB_TYPE_SECTION = 4
BLOB_ID.BLOB_TYPE_REGION = 5
BLOB_ID.BLOB_TYPE_VIEW = 6
BLOB_ID.BLOB_TYPE_RESERVE = 7
BLOB_ID.BLOB_TYPE_DIRECT_TRANSFER = 8
BLOB_ID.BLOB_TYPE_HANDLE_DATA = 9
BLOB_ID.BLOB_TYPE_MAX_ID = 10


REG_NOTIFY_CLASS = v_enum()
REG_NOTIFY_CLASS.RegNtDeleteKey = 0
REG_NOTIFY_CLASS.RegNtPreDeleteKey = 0
REG_NOTIFY_CLASS.RegNtSetValueKey = 1
REG_NOTIFY_CLASS.RegNtPreSetValueKey = 1
REG_NOTIFY_CLASS.RegNtDeleteValueKey = 2
REG_NOTIFY_CLASS.RegNtPreDeleteValueKey = 2
REG_NOTIFY_CLASS.RegNtSetInformationKey = 3
REG_NOTIFY_CLASS.RegNtPreSetInformationKey = 3
REG_NOTIFY_CLASS.RegNtRenameKey = 4
REG_NOTIFY_CLASS.RegNtPreRenameKey = 4
REG_NOTIFY_CLASS.RegNtEnumerateKey = 5
REG_NOTIFY_CLASS.RegNtPreEnumerateKey = 5
REG_NOTIFY_CLASS.RegNtEnumerateValueKey = 6
REG_NOTIFY_CLASS.RegNtPreEnumerateValueKey = 6
REG_NOTIFY_CLASS.RegNtQueryKey = 7
REG_NOTIFY_CLASS.RegNtPreQueryKey = 7
REG_NOTIFY_CLASS.RegNtQueryValueKey = 8
REG_NOTIFY_CLASS.RegNtPreQueryValueKey = 8
REG_NOTIFY_CLASS.RegNtQueryMultipleValueKey = 9
REG_NOTIFY_CLASS.RegNtPreQueryMultipleValueKey = 9
REG_NOTIFY_CLASS.RegNtPreCreateKey = 10
REG_NOTIFY_CLASS.RegNtPostCreateKey = 11
REG_NOTIFY_CLASS.RegNtPreOpenKey = 12
REG_NOTIFY_CLASS.RegNtPostOpenKey = 13
REG_NOTIFY_CLASS.RegNtKeyHandleClose = 14
REG_NOTIFY_CLASS.RegNtPreKeyHandleClose = 14
REG_NOTIFY_CLASS.RegNtPostDeleteKey = 15
REG_NOTIFY_CLASS.RegNtPostSetValueKey = 16
REG_NOTIFY_CLASS.RegNtPostDeleteValueKey = 17
REG_NOTIFY_CLASS.RegNtPostSetInformationKey = 18
REG_NOTIFY_CLASS.RegNtPostRenameKey = 19
REG_NOTIFY_CLASS.RegNtPostEnumerateKey = 20
REG_NOTIFY_CLASS.RegNtPostEnumerateValueKey = 21
REG_NOTIFY_CLASS.RegNtPostQueryKey = 22
REG_NOTIFY_CLASS.RegNtPostQueryValueKey = 23
REG_NOTIFY_CLASS.RegNtPostQueryMultipleValueKey = 24
REG_NOTIFY_CLASS.RegNtPostKeyHandleClose = 25
REG_NOTIFY_CLASS.RegNtPreCreateKeyEx = 26
REG_NOTIFY_CLASS.RegNtPostCreateKeyEx = 27
REG_NOTIFY_CLASS.RegNtPreOpenKeyEx = 28
REG_NOTIFY_CLASS.RegNtPostOpenKeyEx = 29
REG_NOTIFY_CLASS.RegNtPreFlushKey = 30
REG_NOTIFY_CLASS.RegNtPostFlushKey = 31
REG_NOTIFY_CLASS.RegNtPreLoadKey = 32
REG_NOTIFY_CLASS.RegNtPostLoadKey = 33
REG_NOTIFY_CLASS.RegNtPreUnLoadKey = 34
REG_NOTIFY_CLASS.RegNtPostUnLoadKey = 35
REG_NOTIFY_CLASS.RegNtPreQueryKeySecurity = 36
REG_NOTIFY_CLASS.RegNtPostQueryKeySecurity = 37
REG_NOTIFY_CLASS.RegNtPreSetKeySecurity = 38
REG_NOTIFY_CLASS.RegNtPostSetKeySecurity = 39
REG_NOTIFY_CLASS.RegNtCallbackObjectContextCleanup = 40
REG_NOTIFY_CLASS.RegNtPreRestoreKey = 41
REG_NOTIFY_CLASS.RegNtPostRestoreKey = 42
REG_NOTIFY_CLASS.RegNtPreSaveKey = 43
REG_NOTIFY_CLASS.RegNtPostSaveKey = 44
REG_NOTIFY_CLASS.RegNtPreReplaceKey = 45
REG_NOTIFY_CLASS.RegNtPostReplaceKey = 46
REG_NOTIFY_CLASS.MaxRegNtNotifyClass = 47


MM_POOL_FAILURE_REASONS = v_enum()
MM_POOL_FAILURE_REASONS.MmNonPagedNoPtes = 0
MM_POOL_FAILURE_REASONS.MmPriorityTooLow = 1
MM_POOL_FAILURE_REASONS.MmNonPagedNoPagesAvailable = 2
MM_POOL_FAILURE_REASONS.MmPagedNoPtes = 3
MM_POOL_FAILURE_REASONS.MmSessionPagedNoPtes = 4
MM_POOL_FAILURE_REASONS.MmPagedNoPagesAvailable = 5
MM_POOL_FAILURE_REASONS.MmSessionPagedNoPagesAvailable = 6
MM_POOL_FAILURE_REASONS.MmPagedNoCommit = 7
MM_POOL_FAILURE_REASONS.MmSessionPagedNoCommit = 8
MM_POOL_FAILURE_REASONS.MmNonPagedNoResidentAvailable = 9
MM_POOL_FAILURE_REASONS.MmNonPagedNoCommit = 10
MM_POOL_FAILURE_REASONS.MmMaximumFailureReason = 11


BUS_QUERY_ID_TYPE = v_enum()
BUS_QUERY_ID_TYPE.BusQueryDeviceID = 0
BUS_QUERY_ID_TYPE.BusQueryHardwareIDs = 1
BUS_QUERY_ID_TYPE.BusQueryCompatibleIDs = 2
BUS_QUERY_ID_TYPE.BusQueryInstanceID = 3
BUS_QUERY_ID_TYPE.BusQueryDeviceSerialNumber = 4
BUS_QUERY_ID_TYPE.BusQueryContainerID = 5


PROC_HYPERVISOR_STATE = v_enum()
PROC_HYPERVISOR_STATE.ProcHypervisorNone = 0
PROC_HYPERVISOR_STATE.ProcHypervisorPresent = 1
PROC_HYPERVISOR_STATE.ProcHypervisorPower = 2


_unnamed_28527 = v_enum()
_unnamed_28527.KTMOH_CommitTransaction_Result = 1
_unnamed_28527.KTMOH_RollbackTransaction_Result = 2


MM_PREEMPTIVE_TRIMS = v_enum()
MM_PREEMPTIVE_TRIMS.MmPreemptForNonPaged = 0
MM_PREEMPTIVE_TRIMS.MmPreemptForPaged = 1
MM_PREEMPTIVE_TRIMS.MmPreemptForNonPagedPriority = 2
MM_PREEMPTIVE_TRIMS.MmPreemptForPagedPriority = 3
MM_PREEMPTIVE_TRIMS.MmMaximumPreempt = 4


WHEA_ERROR_SEVERITY = v_enum()
WHEA_ERROR_SEVERITY.WheaErrSevRecoverable = 0
WHEA_ERROR_SEVERITY.WheaErrSevFatal = 1
WHEA_ERROR_SEVERITY.WheaErrSevCorrected = 2
WHEA_ERROR_SEVERITY.WheaErrSevInformational = 3


VI_DEADLOCK_RESOURCE_TYPE = v_enum()
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockUnknown = 0
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockMutex = 1
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockMutexAbandoned = 2
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockFastMutex = 3
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockFastMutexUnsafe = 4
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockSpinLock = 5
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockInStackQueuedSpinLock = 6
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockUnusedSpinLock = 7
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockEresource = 8
VI_DEADLOCK_RESOURCE_TYPE.VfDeadlockTypeMaximum = 9


KWAIT_STATE = v_enum()
KWAIT_STATE.WaitInProgress = 0
KWAIT_STATE.WaitCommitted = 1
KWAIT_STATE.WaitAborted = 2
KWAIT_STATE.MaximumWaitState = 3


OBJECT_INFORMATION_CLASS = v_enum()
OBJECT_INFORMATION_CLASS.ObjectBasicInformation = 0
OBJECT_INFORMATION_CLASS.ObjectNameInformation = 1
OBJECT_INFORMATION_CLASS.ObjectTypeInformation = 2
OBJECT_INFORMATION_CLASS.ObjectTypesInformation = 3
OBJECT_INFORMATION_CLASS.ObjectHandleFlagInformation = 4
OBJECT_INFORMATION_CLASS.ObjectSessionInformation = 5
OBJECT_INFORMATION_CLASS.MaxObjectInfoClass = 6


ARBITER_ACTION = v_enum()
ARBITER_ACTION.ArbiterActionTestAllocation = 0
ARBITER_ACTION.ArbiterActionRetestAllocation = 1
ARBITER_ACTION.ArbiterActionCommitAllocation = 2
ARBITER_ACTION.ArbiterActionRollbackAllocation = 3
ARBITER_ACTION.ArbiterActionQueryAllocatedResources = 4
ARBITER_ACTION.ArbiterActionWriteReservedResources = 5
ARBITER_ACTION.ArbiterActionQueryConflict = 6
ARBITER_ACTION.ArbiterActionQueryArbitrate = 7
ARBITER_ACTION.ArbiterActionAddReserved = 8
ARBITER_ACTION.ArbiterActionBootAllocation = 9


ETW_GUID_TYPE = v_enum()
ETW_GUID_TYPE.EtwTraceGuidType = 0
ETW_GUID_TYPE.EtwNotificationGuidType = 1
ETW_GUID_TYPE.EtwGuidTypeMax = 2


HEAP_FAILURE_TYPE = v_enum()
HEAP_FAILURE_TYPE.heap_failure_internal = 0
HEAP_FAILURE_TYPE.heap_failure_unknown = 1
HEAP_FAILURE_TYPE.heap_failure_generic = 2
HEAP_FAILURE_TYPE.heap_failure_entry_corruption = 3
HEAP_FAILURE_TYPE.heap_failure_multiple_entries_corruption = 4
HEAP_FAILURE_TYPE.heap_failure_virtual_block_corruption = 5
HEAP_FAILURE_TYPE.heap_failure_buffer_overrun = 6
HEAP_FAILURE_TYPE.heap_failure_buffer_underrun = 7
HEAP_FAILURE_TYPE.heap_failure_block_not_busy = 8
HEAP_FAILURE_TYPE.heap_failure_invalid_argument = 9
HEAP_FAILURE_TYPE.heap_failure_usage_after_free = 10
HEAP_FAILURE_TYPE.heap_failure_cross_heap_operation = 11
HEAP_FAILURE_TYPE.heap_failure_freelists_corruption = 12
HEAP_FAILURE_TYPE.heap_failure_listentry_corruption = 13


MM_POOL_TYPES = v_enum()
MM_POOL_TYPES.MmNonPagedPool = 0
MM_POOL_TYPES.MmPagedPool = 1
MM_POOL_TYPES.MmSessionPagedPool = 2
MM_POOL_TYPES.MmMaximumPoolType = 3


IO_PAGING_PRIORITY = v_enum()
IO_PAGING_PRIORITY.IoPagingPriorityInvalid = 0
IO_PAGING_PRIORITY.IoPagingPriorityNormal = 1
IO_PAGING_PRIORITY.IoPagingPriorityHigh = 2
IO_PAGING_PRIORITY.IoPagingPriorityReserved1 = 3
IO_PAGING_PRIORITY.IoPagingPriorityReserved2 = 4


POP_DEVICE_IDLE_TYPE = v_enum()
POP_DEVICE_IDLE_TYPE.DeviceIdleNormal = 0
POP_DEVICE_IDLE_TYPE.DeviceIdleDisk = 1


KTRANSACTION_STATE = v_enum()
KTRANSACTION_STATE.KTransactionUninitialized = 0
KTRANSACTION_STATE.KTransactionActive = 1
KTRANSACTION_STATE.KTransactionPreparing = 2
KTRANSACTION_STATE.KTransactionPrepared = 3
KTRANSACTION_STATE.KTransactionInDoubt = 4
KTRANSACTION_STATE.KTransactionCommitted = 5
KTRANSACTION_STATE.KTransactionAborted = 6
KTRANSACTION_STATE.KTransactionDelegated = 7
KTRANSACTION_STATE.KTransactionPrePreparing = 8
KTRANSACTION_STATE.KTransactionForgotten = 9
KTRANSACTION_STATE.KTransactionRecovering = 10
KTRANSACTION_STATE.KTransactionPrePrepared = 11


EXCEPTION_DISPOSITION = v_enum()
EXCEPTION_DISPOSITION.ExceptionContinueExecution = 0
EXCEPTION_DISPOSITION.ExceptionContinueSearch = 1
EXCEPTION_DISPOSITION.ExceptionNestedException = 2
EXCEPTION_DISPOSITION.ExceptionCollidedUnwind = 3


SECURITY_OPERATION_CODE = v_enum()
SECURITY_OPERATION_CODE.SetSecurityDescriptor = 0
SECURITY_OPERATION_CODE.QuerySecurityDescriptor = 1
SECURITY_OPERATION_CODE.DeleteSecurityDescriptor = 2
SECURITY_OPERATION_CODE.AssignSecurityDescriptor = 3


IRPLOCK = v_enum()
IRPLOCK.IRPLOCK_CANCELABLE = 0
IRPLOCK.IRPLOCK_CANCEL_STARTED = 1
IRPLOCK.IRPLOCK_CANCEL_COMPLETE = 2
IRPLOCK.IRPLOCK_COMPLETED = 3


FS_FILTER_STREAM_FO_NOTIFICATION_TYPE = v_enum()
FS_FILTER_STREAM_FO_NOTIFICATION_TYPE.NotifyTypeCreate = 0
FS_FILTER_STREAM_FO_NOTIFICATION_TYPE.NotifyTypeRetired = 1


DEVICE_USAGE_NOTIFICATION_TYPE = v_enum()
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeUndefined = 0
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypePaging = 1
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeHibernation = 2
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeDumpFile = 3


INTERFACE_TYPE = v_enum()
INTERFACE_TYPE.InterfaceTypeUndefined = -1
INTERFACE_TYPE.Internal = 0
INTERFACE_TYPE.Isa = 1
INTERFACE_TYPE.Eisa = 2
INTERFACE_TYPE.MicroChannel = 3
INTERFACE_TYPE.TurboChannel = 4
INTERFACE_TYPE.PCIBus = 5
INTERFACE_TYPE.VMEBus = 6
INTERFACE_TYPE.NuBus = 7
INTERFACE_TYPE.PCMCIABus = 8
INTERFACE_TYPE.CBus = 9
INTERFACE_TYPE.MPIBus = 10
INTERFACE_TYPE.MPSABus = 11
INTERFACE_TYPE.ProcessorInternal = 12
INTERFACE_TYPE.InternalPowerBus = 13
INTERFACE_TYPE.PNPISABus = 14
INTERFACE_TYPE.PNPBus = 15
INTERFACE_TYPE.Vmcs = 16
INTERFACE_TYPE.MaximumInterfaceType = 17


KWAIT_REASON = v_enum()
KWAIT_REASON.Executive = 0
KWAIT_REASON.FreePage = 1
KWAIT_REASON.PageIn = 2
KWAIT_REASON.PoolAllocation = 3
KWAIT_REASON.DelayExecution = 4
KWAIT_REASON.Suspended = 5
KWAIT_REASON.UserRequest = 6
KWAIT_REASON.WrExecutive = 7
KWAIT_REASON.WrFreePage = 8
KWAIT_REASON.WrPageIn = 9
KWAIT_REASON.WrPoolAllocation = 10
KWAIT_REASON.WrDelayExecution = 11
KWAIT_REASON.WrSuspended = 12
KWAIT_REASON.WrUserRequest = 13
KWAIT_REASON.WrEventPair = 14
KWAIT_REASON.WrQueue = 15
KWAIT_REASON.WrLpcReceive = 16
KWAIT_REASON.WrLpcReply = 17
KWAIT_REASON.WrVirtualMemory = 18
KWAIT_REASON.WrPageOut = 19
KWAIT_REASON.WrRendezvous = 20
KWAIT_REASON.WrKeyedEvent = 21
KWAIT_REASON.WrTerminated = 22
KWAIT_REASON.WrProcessInSwap = 23
KWAIT_REASON.WrCpuRateControl = 24
KWAIT_REASON.WrCalloutStack = 25
KWAIT_REASON.WrKernel = 26
KWAIT_REASON.WrResource = 27
KWAIT_REASON.WrPushLock = 28
KWAIT_REASON.WrMutex = 29
KWAIT_REASON.WrQuantumEnd = 30
KWAIT_REASON.WrDispatchInt = 31
KWAIT_REASON.WrPreempted = 32
KWAIT_REASON.WrYieldExecution = 33
KWAIT_REASON.WrFastMutex = 34
KWAIT_REASON.WrGuardedMutex = 35
KWAIT_REASON.WrRundown = 36
KWAIT_REASON.MaximumWaitReason = 37


PS_RESOURCE_TYPE = v_enum()
PS_RESOURCE_TYPE.PsResourceNonPagedPool = 0
PS_RESOURCE_TYPE.PsResourcePagedPool = 1
PS_RESOURCE_TYPE.PsResourcePageFile = 2
PS_RESOURCE_TYPE.PsResourceWorkingSet = 3
PS_RESOURCE_TYPE.PsResourceCpuRate = 4
PS_RESOURCE_TYPE.PsResourceMax = 5


MM_PAGE_ACCESS_TYPE = v_enum()
MM_PAGE_ACCESS_TYPE.MmPteAccessType = 0
MM_PAGE_ACCESS_TYPE.MmCcReadAheadType = 1
MM_PAGE_ACCESS_TYPE.MmPfnRepurposeType = 2
MM_PAGE_ACCESS_TYPE.MmMaximumPageAccessType = 3


ReplacesCorHdrNumericDefines = v_enum()
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY = 1
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED = 2
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY = 4
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED = 8
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2 = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MINOR = 0
ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB = 1
ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA = 1
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA = 2
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT = 1
ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT = 2
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED = 4
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED = 16
ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE = 32
ReplacesCorHdrNumericDefines.MAX_CLASS_NAME = 1024
ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME = 1024


HSTORAGE_TYPE = v_enum()
HSTORAGE_TYPE.Stable = 0
HSTORAGE_TYPE.Volatile = 1
HSTORAGE_TYPE.InvalidStorage = 2


MI_PFN_CACHE_ATTRIBUTE = v_enum()
MI_PFN_CACHE_ATTRIBUTE.MiNonCached = 0
MI_PFN_CACHE_ATTRIBUTE.MiCached = 1
MI_PFN_CACHE_ATTRIBUTE.MiWriteCombined = 2
MI_PFN_CACHE_ATTRIBUTE.MiNotMapped = 3


CREATE_FILE_TYPE = v_enum()
CREATE_FILE_TYPE.CreateFileTypeNone = 0
CREATE_FILE_TYPE.CreateFileTypeNamedPipe = 1
CREATE_FILE_TYPE.CreateFileTypeMailslot = 2


POLICY_AUDIT_EVENT_TYPE = v_enum()
POLICY_AUDIT_EVENT_TYPE.AuditCategorySystem = 0
POLICY_AUDIT_EVENT_TYPE.AuditCategoryLogon = 1
POLICY_AUDIT_EVENT_TYPE.AuditCategoryObjectAccess = 2
POLICY_AUDIT_EVENT_TYPE.AuditCategoryPrivilegeUse = 3
POLICY_AUDIT_EVENT_TYPE.AuditCategoryDetailedTracking = 4
POLICY_AUDIT_EVENT_TYPE.AuditCategoryPolicyChange = 5
POLICY_AUDIT_EVENT_TYPE.AuditCategoryAccountManagement = 6
POLICY_AUDIT_EVENT_TYPE.AuditCategoryDirectoryServiceAccess = 7
POLICY_AUDIT_EVENT_TYPE.AuditCategoryAccountLogon = 8


ETW_RT_EVENT_LOSS = v_enum()
ETW_RT_EVENT_LOSS.EtwRtEventNoLoss = 0
ETW_RT_EVENT_LOSS.EtwRtEventLost = 1
ETW_RT_EVENT_LOSS.EtwRtBufferLost = 2
ETW_RT_EVENT_LOSS.EtwRtBackupLost = 3
ETW_RT_EVENT_LOSS.EtwRtEventLossMax = 4


WOW64_SHARED_INFORMATION = v_enum()
WOW64_SHARED_INFORMATION.SharedNtdll32LdrInitializeThunk = 0
WOW64_SHARED_INFORMATION.SharedNtdll32KiUserExceptionDispatcher = 1
WOW64_SHARED_INFORMATION.SharedNtdll32KiUserApcDispatcher = 2
WOW64_SHARED_INFORMATION.SharedNtdll32KiUserCallbackDispatcher = 3
WOW64_SHARED_INFORMATION.SharedNtdll32LdrHotPatchRoutine = 4
WOW64_SHARED_INFORMATION.SharedNtdll32ExpInterlockedPopEntrySListFault = 5
WOW64_SHARED_INFORMATION.SharedNtdll32ExpInterlockedPopEntrySListResume = 6
WOW64_SHARED_INFORMATION.SharedNtdll32ExpInterlockedPopEntrySListEnd = 7
WOW64_SHARED_INFORMATION.SharedNtdll32RtlUserThreadStart = 8
WOW64_SHARED_INFORMATION.SharedNtdll32pQueryProcessDebugInformationRemote = 9
WOW64_SHARED_INFORMATION.SharedNtdll32EtwpNotificationThread = 10
WOW64_SHARED_INFORMATION.SharedNtdll32BaseAddress = 11
WOW64_SHARED_INFORMATION.Wow64SharedPageEntriesCount = 12


CM_LOAD_FAILURE_TYPE = v_enum()
CM_LOAD_FAILURE_TYPE._None = 0
CM_LOAD_FAILURE_TYPE.CmInitializeHive = 1
CM_LOAD_FAILURE_TYPE.HvInitializeHive = 2
CM_LOAD_FAILURE_TYPE.HvpBuildMap = 3
CM_LOAD_FAILURE_TYPE.HvpBuildMapAndCopy = 4
CM_LOAD_FAILURE_TYPE.HvpInitMap = 5
CM_LOAD_FAILURE_TYPE.HvLoadHive = 6
CM_LOAD_FAILURE_TYPE.HvpReadFileImageAndBuildMap = 7
CM_LOAD_FAILURE_TYPE.HvpRecoverData = 8
CM_LOAD_FAILURE_TYPE.HvpRecoverWholeHive = 9
CM_LOAD_FAILURE_TYPE.HvpMapFileImageAndBuildMap = 10
CM_LOAD_FAILURE_TYPE.CmpValidateHiveSecurityDescriptors = 11
CM_LOAD_FAILURE_TYPE.HvpEnlistBinInMap = 12
CM_LOAD_FAILURE_TYPE.CmCheckRegistry = 13
CM_LOAD_FAILURE_TYPE.CmRegistryIO = 14
CM_LOAD_FAILURE_TYPE.CmCheckRegistry2 = 15
CM_LOAD_FAILURE_TYPE.CmpCheckKey = 16
CM_LOAD_FAILURE_TYPE.CmpCheckValueList = 17
CM_LOAD_FAILURE_TYPE.HvCheckHive = 18
CM_LOAD_FAILURE_TYPE.HvCheckBin = 19


DEVICE_RELATION_TYPE = v_enum()
DEVICE_RELATION_TYPE.BusRelations = 0
DEVICE_RELATION_TYPE.EjectionRelations = 1
DEVICE_RELATION_TYPE.PowerRelations = 2
DEVICE_RELATION_TYPE.RemovalRelations = 3
DEVICE_RELATION_TYPE.TargetDeviceRelation = 4
DEVICE_RELATION_TYPE.SingleBusRelations = 5
DEVICE_RELATION_TYPE.TransportRelations = 6


FILE_INFORMATION_CLASS = v_enum()
FILE_INFORMATION_CLASS.FileDirectoryInformation = 1
FILE_INFORMATION_CLASS.FileFullDirectoryInformation = 2
FILE_INFORMATION_CLASS.FileBothDirectoryInformation = 3
FILE_INFORMATION_CLASS.FileBasicInformation = 4
FILE_INFORMATION_CLASS.FileStandardInformation = 5
FILE_INFORMATION_CLASS.FileInternalInformation = 6
FILE_INFORMATION_CLASS.FileEaInformation = 7
FILE_INFORMATION_CLASS.FileAccessInformation = 8
FILE_INFORMATION_CLASS.FileNameInformation = 9
FILE_INFORMATION_CLASS.FileRenameInformation = 10
FILE_INFORMATION_CLASS.FileLinkInformation = 11
FILE_INFORMATION_CLASS.FileNamesInformation = 12
FILE_INFORMATION_CLASS.FileDispositionInformation = 13
FILE_INFORMATION_CLASS.FilePositionInformation = 14
FILE_INFORMATION_CLASS.FileFullEaInformation = 15
FILE_INFORMATION_CLASS.FileModeInformation = 16
FILE_INFORMATION_CLASS.FileAlignmentInformation = 17
FILE_INFORMATION_CLASS.FileAllInformation = 18
FILE_INFORMATION_CLASS.FileAllocationInformation = 19
FILE_INFORMATION_CLASS.FileEndOfFileInformation = 20
FILE_INFORMATION_CLASS.FileAlternateNameInformation = 21
FILE_INFORMATION_CLASS.FileStreamInformation = 22
FILE_INFORMATION_CLASS.FilePipeInformation = 23
FILE_INFORMATION_CLASS.FilePipeLocalInformation = 24
FILE_INFORMATION_CLASS.FilePipeRemoteInformation = 25
FILE_INFORMATION_CLASS.FileMailslotQueryInformation = 26
FILE_INFORMATION_CLASS.FileMailslotSetInformation = 27
FILE_INFORMATION_CLASS.FileCompressionInformation = 28
FILE_INFORMATION_CLASS.FileObjectIdInformation = 29
FILE_INFORMATION_CLASS.FileCompletionInformation = 30
FILE_INFORMATION_CLASS.FileMoveClusterInformation = 31
FILE_INFORMATION_CLASS.FileQuotaInformation = 32
FILE_INFORMATION_CLASS.FileReparsePointInformation = 33
FILE_INFORMATION_CLASS.FileNetworkOpenInformation = 34
FILE_INFORMATION_CLASS.FileAttributeTagInformation = 35
FILE_INFORMATION_CLASS.FileTrackingInformation = 36
FILE_INFORMATION_CLASS.FileIdBothDirectoryInformation = 37
FILE_INFORMATION_CLASS.FileIdFullDirectoryInformation = 38
FILE_INFORMATION_CLASS.FileValidDataLengthInformation = 39
FILE_INFORMATION_CLASS.FileShortNameInformation = 40
FILE_INFORMATION_CLASS.FileIoCompletionNotificationInformation = 41
FILE_INFORMATION_CLASS.FileIoStatusBlockRangeInformation = 42
FILE_INFORMATION_CLASS.FileIoPriorityHintInformation = 43
FILE_INFORMATION_CLASS.FileSfioReserveInformation = 44
FILE_INFORMATION_CLASS.FileSfioVolumeInformation = 45
FILE_INFORMATION_CLASS.FileHardLinkInformation = 46
FILE_INFORMATION_CLASS.FileProcessIdsUsingFileInformation = 47
FILE_INFORMATION_CLASS.FileNormalizedNameInformation = 48
FILE_INFORMATION_CLASS.FileNetworkPhysicalNameInformation = 49
FILE_INFORMATION_CLASS.FileIdGlobalTxDirectoryInformation = 50
FILE_INFORMATION_CLASS.FileIsRemoteDeviceInformation = 51
FILE_INFORMATION_CLASS.FileAttributeCacheInformation = 52
FILE_INFORMATION_CLASS.FileNumaNodeInformation = 53
FILE_INFORMATION_CLASS.FileStandardLinkInformation = 54
FILE_INFORMATION_CLASS.FileRemoteProtocolInformation = 55
FILE_INFORMATION_CLASS.FileMaximumInformation = 56


DEVICE_POWER_STATE = v_enum()
DEVICE_POWER_STATE.PowerDeviceUnspecified = 0
DEVICE_POWER_STATE.PowerDeviceD0 = 1
DEVICE_POWER_STATE.PowerDeviceD1 = 2
DEVICE_POWER_STATE.PowerDeviceD2 = 3
DEVICE_POWER_STATE.PowerDeviceD3 = 4
DEVICE_POWER_STATE.PowerDeviceMaximum = 5


MEMORY_CACHING_TYPE = v_enum()
MEMORY_CACHING_TYPE.MmNonCached = 0
MEMORY_CACHING_TYPE.MmCached = 1
MEMORY_CACHING_TYPE.MmWriteCombined = 2
MEMORY_CACHING_TYPE.MmHardwareCoherentCached = 3
MEMORY_CACHING_TYPE.MmNonCachedUnordered = 4
MEMORY_CACHING_TYPE.MmUSWCCached = 5
MEMORY_CACHING_TYPE.MmMaximumCacheType = 6


NT_PRODUCT_TYPE = v_enum()
NT_PRODUCT_TYPE.NtProductWinNt = 1
NT_PRODUCT_TYPE.NtProductLanManNt = 2
NT_PRODUCT_TYPE.NtProductServer = 3


IOP_PRIORITY_HINT = v_enum()
IOP_PRIORITY_HINT.IopIoPriorityNotSet = 0
IOP_PRIORITY_HINT.IopIoPriorityVeryLow = 1
IOP_PRIORITY_HINT.IopIoPriorityLow = 2
IOP_PRIORITY_HINT.IopIoPriorityNormal = 3
IOP_PRIORITY_HINT.IopIoPriorityHigh = 4
IOP_PRIORITY_HINT.IopIoPriorityCritical = 5
IOP_PRIORITY_HINT.MaxIopIoPriorityTypes = 6


WHEA_ERROR_SOURCE_TYPE = v_enum()
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMCE = 0
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCMC = 1
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCPE = 2
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeNMI = 3
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypePCIe = 4
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeGeneric = 5
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeINIT = 6
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeBOOT = 7
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeSCIGeneric = 8
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFMCA = 9
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCMC = 10
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCPE = 11
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMax = 12


RTL_GENERIC_COMPARE_RESULTS = v_enum()
RTL_GENERIC_COMPARE_RESULTS.GenericLessThan = 0
RTL_GENERIC_COMPARE_RESULTS.GenericGreaterThan = 1
RTL_GENERIC_COMPARE_RESULTS.GenericEqual = 2


TPM_BOOT_ENTROPY_RESULT_CODE = v_enum()
TPM_BOOT_ENTROPY_RESULT_CODE.TpmBootEntropyStructureUninitialized = 0
TPM_BOOT_ENTROPY_RESULT_CODE.TpmBootEntropyDisabledByPolicy = 1
TPM_BOOT_ENTROPY_RESULT_CODE.TpmBootEntropyNoTpmFound = 2
TPM_BOOT_ENTROPY_RESULT_CODE.TpmBootEntropyTpmError = 3
TPM_BOOT_ENTROPY_RESULT_CODE.TpmBootEntropySuccess = 4


TP_CALLBACK_PRIORITY = v_enum()
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_HIGH = 0
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_NORMAL = 1
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_LOW = 2
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_INVALID = 3


FSINFOCLASS = v_enum()
FSINFOCLASS.FileFsVolumeInformation = 1
FSINFOCLASS.FileFsLabelInformation = 2
FSINFOCLASS.FileFsSizeInformation = 3
FSINFOCLASS.FileFsDeviceInformation = 4
FSINFOCLASS.FileFsAttributeInformation = 5
FSINFOCLASS.FileFsControlInformation = 6
FSINFOCLASS.FileFsFullSizeInformation = 7
FSINFOCLASS.FileFsObjectIdInformation = 8
FSINFOCLASS.FileFsDriverPathInformation = 9
FSINFOCLASS.FileFsVolumeFlagsInformation = 10
FSINFOCLASS.FileFsMaximumInformation = 11


WORKING_SET_TYPE = v_enum()
WORKING_SET_TYPE.WorkingSetTypeUser = 0
WORKING_SET_TYPE.WorkingSetTypeSession = 1
WORKING_SET_TYPE.WorkingSetTypeSystemTypes = 2
WORKING_SET_TYPE.WorkingSetTypeSystemCache = 2
WORKING_SET_TYPE.WorkingSetTypePagedPool = 3
WORKING_SET_TYPE.WorkingSetTypeSystemPtes = 4
WORKING_SET_TYPE.WorkingSetTypeMaximum = 5


POOL_TYPE = v_enum()
POOL_TYPE.NonPagedPool = 0
POOL_TYPE.PagedPool = 1
POOL_TYPE.NonPagedPoolMustSucceed = 2
POOL_TYPE.DontUseThisType = 3
POOL_TYPE.NonPagedPoolCacheAligned = 4
POOL_TYPE.PagedPoolCacheAligned = 5
POOL_TYPE.NonPagedPoolCacheAlignedMustS = 6
POOL_TYPE.MaxPoolType = 7
POOL_TYPE.NonPagedPoolSession = 32
POOL_TYPE.PagedPoolSession = 33
POOL_TYPE.NonPagedPoolMustSucceedSession = 34
POOL_TYPE.DontUseThisTypeSession = 35
POOL_TYPE.NonPagedPoolCacheAlignedSession = 36
POOL_TYPE.PagedPoolCacheAlignedSession = 37
POOL_TYPE.NonPagedPoolCacheAlignedMustSSession = 38


MODE = v_enum()
MODE.KernelMode = 0
MODE.UserMode = 1
MODE.MaximumMode = 2


FS_FILTER_SECTION_SYNC_TYPE = v_enum()
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeOther = 0
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeCreateSection = 1


FILE_OBJECT_EXTENSION_TYPE = v_enum()
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeTransactionParams = 0
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeDeviceObjectHint = 1
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeIosbRange = 2
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeGeneric = 3
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeSfio = 4
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeSymlink = 5
FILE_OBJECT_EXTENSION_TYPE.FoExtTypeOplockKey = 6
FILE_OBJECT_EXTENSION_TYPE.MaxFoExtTypes = 7


IRQ_PRIORITY = v_enum()
IRQ_PRIORITY.IrqPriorityUndefined = 0
IRQ_PRIORITY.IrqPriorityLow = 1
IRQ_PRIORITY.IrqPriorityNormal = 2
IRQ_PRIORITY.IrqPriorityHigh = 3


MI_SYSTEM_VA_TYPE = v_enum()
MI_SYSTEM_VA_TYPE.MiVaUnused = 0
MI_SYSTEM_VA_TYPE.MiVaSessionSpace = 1
MI_SYSTEM_VA_TYPE.MiVaProcessSpace = 2
MI_SYSTEM_VA_TYPE.MiVaBootLoaded = 3
MI_SYSTEM_VA_TYPE.MiVaPfnDatabase = 4
MI_SYSTEM_VA_TYPE.MiVaNonPagedPool = 5
MI_SYSTEM_VA_TYPE.MiVaPagedPool = 6
MI_SYSTEM_VA_TYPE.MiVaSpecialPoolPaged = 7
MI_SYSTEM_VA_TYPE.MiVaSystemCache = 8
MI_SYSTEM_VA_TYPE.MiVaSystemPtes = 9
MI_SYSTEM_VA_TYPE.MiVaHal = 10
MI_SYSTEM_VA_TYPE.MiVaSessionGlobalSpace = 11
MI_SYSTEM_VA_TYPE.MiVaDriverImages = 12
MI_SYSTEM_VA_TYPE.MiVaSpecialPoolNonPaged = 13
MI_SYSTEM_VA_TYPE.MiVaMaximumType = 14


LSA_FOREST_TRUST_RECORD_TYPE = v_enum()
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName = 0
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx = 1
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo = 2
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustRecordTypeLast = 2


SYSTEM_POWER_STATE = v_enum()
SYSTEM_POWER_STATE.PowerSystemUnspecified = 0
SYSTEM_POWER_STATE.PowerSystemWorking = 1
SYSTEM_POWER_STATE.PowerSystemSleeping1 = 2
SYSTEM_POWER_STATE.PowerSystemSleeping2 = 3
SYSTEM_POWER_STATE.PowerSystemSleeping3 = 4
SYSTEM_POWER_STATE.PowerSystemHibernate = 5
SYSTEM_POWER_STATE.PowerSystemShutdown = 6
SYSTEM_POWER_STATE.PowerSystemMaximum = 7


MMLISTS = v_enum()
MMLISTS.ZeroedPageList = 0
MMLISTS.FreePageList = 1
MMLISTS.StandbyPageList = 2
MMLISTS.ModifiedPageList = 3
MMLISTS.ModifiedNoWritePageList = 4
MMLISTS.BadPageList = 5
MMLISTS.ActiveAndValid = 6
MMLISTS.TransitionPage = 7


TOKEN_TYPE = v_enum()
TOKEN_TYPE.TokenPrimary = 1
TOKEN_TYPE.TokenImpersonation = 2


HARDWARE_COUNTER_TYPE = v_enum()
HARDWARE_COUNTER_TYPE.PMCCounter = 0
HARDWARE_COUNTER_TYPE.MaxHardwareCounterType = 1


TRANSFER_TYPE = v_enum()
TRANSFER_TYPE.ReadTransfer = 0
TRANSFER_TYPE.WriteTransfer = 1
TRANSFER_TYPE.OtherTransfer = 2


KINTERRUPT_MODE = v_enum()
KINTERRUPT_MODE.LevelSensitive = 0
KINTERRUPT_MODE.Latched = 1


class KEXECUTE_OPTIONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteDisable = v_uint8()


class MI_COLOR_BASE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ColorPointer = v_ptr32()
        self.ColorMask = v_uint16()
        self.ColorNode = v_uint16()


class PSP_CPU_QUOTA_APC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class IO_PRIORITY_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.ThreadPriority = v_uint32()
        self.PagePriority = v_uint32()
        self.IoPriority = v_uint32()


class IOV_FORCED_PENDING_TRACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Irp = v_ptr32()
        self.Thread = v_ptr32()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(62) ])


class SEGMENT_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseAddress = v_ptr32()
        self.TotalNumberOfPtes = v_uint32()
        self.SizeOfSegment = LARGE_INTEGER()
        self.NonExtendedPtes = v_uint32()
        self.ImageCommitment = v_uint32()
        self.ControlArea = v_ptr32()
        self.Subsection = v_ptr32()
        self.MmSectionFlags = v_ptr32()
        self.MmSubSectionFlags = v_ptr32()


class VOLUME_CACHE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self.NodeByteCode = v_uint16()
        self.UseCount = v_uint32()
        self.DeviceObject = v_ptr32()
        self.VolumeCacheMapLinks = LIST_ENTRY()
        self.Flags = v_uint32()
        self.DirtyPages = v_uint32()
        self.PagesQueuedToDisk = v_uint32()


class SID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.SubAuthorityCount = v_uint8()
        self.IdentifierAuthority = SID_IDENTIFIER_AUTHORITY()
        self.SubAuthority = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class MMPTE_HARDWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class POP_CPU_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Eax = v_uint32()
        self.Ebx = v_uint32()
        self.Ecx = v_uint32()
        self.Edx = v_uint32()


class WHEA_ERROR_PACKET_V2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Version = v_uint32()
        self.Length = v_uint32()
        self.Flags = WHEA_ERROR_PACKET_FLAGS()
        self.ErrorType = v_uint32()
        self.ErrorSeverity = v_uint32()
        self.ErrorSourceId = v_uint32()
        self.ErrorSourceType = v_uint32()
        self.NotifyType = GUID()
        self.Context = v_uint64()
        self.DataFormat = v_uint32()
        self.Reserved1 = v_uint32()
        self.DataOffset = v_uint32()
        self.DataLength = v_uint32()
        self.PshedDataOffset = v_uint32()
        self.PshedDataLength = v_uint32()


class GROUP_AFFINITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint32()
        self.Group = v_uint16()
        self.Reserved = vstruct.VArray([ v_uint16() for i in xrange(3) ])


class _unnamed_26919(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length48 = v_uint32()


class VI_VERIFIER_ISSUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IssueType = v_uint32()
        self.Address = v_ptr32()
        self.Parameters = vstruct.VArray([ v_uint32() for i in xrange(2) ])


class DBGKD_LOAD_SYMBOLS32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PathNameLength = v_uint32()
        self.BaseOfDll = v_uint32()
        self.ProcessId = v_uint32()
        self.CheckSum = v_uint32()
        self.SizeOfImage = v_uint32()
        self.UnloadSymbols = v_uint8()
        self._pad0018 = v_bytes(size=3)


class KTSS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Backlink = v_uint16()
        self.Reserved0 = v_uint16()
        self.Esp0 = v_uint32()
        self.Ss0 = v_uint16()
        self.Reserved1 = v_uint16()
        self.NotUsed1 = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.CR3 = v_uint32()
        self.Eip = v_uint32()
        self.EFlags = v_uint32()
        self.Eax = v_uint32()
        self.Ecx = v_uint32()
        self.Edx = v_uint32()
        self.Ebx = v_uint32()
        self.Esp = v_uint32()
        self.Ebp = v_uint32()
        self.Esi = v_uint32()
        self.Edi = v_uint32()
        self.Es = v_uint16()
        self.Reserved2 = v_uint16()
        self.Cs = v_uint16()
        self.Reserved3 = v_uint16()
        self.Ss = v_uint16()
        self.Reserved4 = v_uint16()
        self.Ds = v_uint16()
        self.Reserved5 = v_uint16()
        self.Fs = v_uint16()
        self.Reserved6 = v_uint16()
        self.Gs = v_uint16()
        self.Reserved7 = v_uint16()
        self.LDT = v_uint16()
        self.Reserved8 = v_uint16()
        self.Flags = v_uint16()
        self.IoMapBase = v_uint16()
        self.IoMaps = vstruct.VArray([ KiIoAccessMap() for i in xrange(1) ])
        self.IntDirectionMap = vstruct.VArray([ v_uint8() for i in xrange(32) ])


class CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DosPath = UNICODE_STRING()
        self.Handle = v_ptr32()


class DBGKD_GET_INTERNAL_BREAKPOINT32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakpointAddress = v_uint32()
        self.Flags = v_uint32()
        self.Calls = v_uint32()
        self.MaxCallsPerPeriod = v_uint32()
        self.MinInstructions = v_uint32()
        self.MaxInstructions = v_uint32()
        self.TotalInstructions = v_uint32()


class PO_IRP_MANAGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceIrpQueue = PO_IRP_QUEUE()
        self.SystemIrpQueue = PO_IRP_QUEUE()


class DBGKD_MANIPULATE_STATE32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ApiNumber = v_uint32()
        self.ProcessorLevel = v_uint16()
        self.Processor = v_uint16()
        self.ReturnStatus = v_uint32()
        self.u = _unnamed_23376()


class SEP_TOKEN_PRIVILEGES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Present = v_uint64()
        self.Enabled = v_uint64()
        self.EnabledByDefault = v_uint64()


class KALPC_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SectionObject = v_ptr32()
        self.Size = v_uint32()
        self.HandleTable = v_ptr32()
        self.SectionHandle = v_ptr32()
        self.OwnerProcess = v_ptr32()
        self.OwnerPort = v_ptr32()
        self.u1 = _unnamed_23990()
        self.NumberOfRegions = v_uint32()
        self.RegionListHead = LIST_ENTRY()


class PERFINFO_GROUPMASK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Masks = vstruct.VArray([ v_uint32() for i in xrange(8) ])


class HARDWARE_PTE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class ETW_PERF_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalActiveSessions = v_uint32()
        self.TotalBufferMemoryNonPagedPool = v_uint32()
        self.TotalBufferMemoryPagedPool = v_uint32()
        self.TotalGuidsEnabled = v_uint32()
        self.TotalGuidsNotEnabled = v_uint32()
        self.TotalGuidsPreEnabled = v_uint32()


class HANDLE_TABLE_ENTRY_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AuditMask = v_uint32()


class DBGKD_WRITE_MEMORY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TargetBaseAddress = v_uint32()
        self.TransferCount = v_uint32()
        self.ActualBytesWritten = v_uint32()


class _unnamed_20730(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self.Parameters = v_ptr32()


class CACHED_KSTACK_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SListHead = SLIST_HEADER()
        self.MinimumFree = v_uint32()
        self.Misses = v_uint32()
        self.MissesLast = v_uint32()
        self.Pad0 = v_uint32()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SectionOffset = v_uint32()
        self.SectionLength = v_uint32()
        self.Revision = WHEA_REVISION()
        self.ValidBits = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS()
        self.Reserved = v_uint8()
        self.Flags = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS()
        self.SectionType = GUID()
        self.FRUId = GUID()
        self.SectionSeverity = v_uint32()
        self.FRUText = vstruct.VArray([ v_uint8() for i in xrange(20) ])


class EX_WORK_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkerQueue = KQUEUE()
        self.DynamicThreadCount = v_uint32()
        self.WorkItemsProcessed = v_uint32()
        self.WorkItemsProcessedLastPass = v_uint32()
        self.QueueDepthLastPass = v_uint32()
        self.Info = EX_QUEUE_WORKER_INFO()


class MMWSLENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class PNP_DEVICE_COMPLETION_REQUEST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.DeviceNode = v_ptr32()
        self.Context = v_ptr32()
        self.CompletionState = v_uint32()
        self.IrpPended = v_uint32()
        self.Status = v_uint32()
        self.Information = v_ptr32()
        self.WorkItem = WORK_QUEUE_ITEM()
        self.FailingDriver = v_ptr32()
        self.ReferenceCount = v_uint32()


class PS_CPU_QUOTA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.SessionId = v_uint32()
        self.CpuShareWeight = v_uint32()
        self.CapturedWeightData = PSP_CPU_SHARE_CAPTURED_WEIGHT_DATA()
        self.DuplicateInputMarker = v_uint32()
        self._pad0040 = v_bytes(size=36)
        self.CycleCredit = v_uint64()
        self.BlockCurrentGeneration = v_uint32()
        self.CpuCyclePercent = v_uint32()
        self.CyclesFinishedForCurrentGeneration = v_uint8()
        self._pad0080 = v_bytes(size=47)
        self.Cpu = vstruct.VArray([ PS_PER_CPU_QUOTA_CACHE_AWARE() for i in xrange(32) ])


class CHILD_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.List = v_uint32()


class CM_PARTIAL_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.PartialDescriptors = vstruct.VArray([ CM_PARTIAL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class _unnamed_20798(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileName = v_ptr32()
        self.FileInformationClass = v_uint32()
        self.FileIndex = v_uint32()


class DBGKD_RESTORE_BREAKPOINT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakPointHandle = v_uint32()


class IMAGE_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PageHashes = v_ptr32()


class DEVICE_CAPABILITIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.DeviceD1 = v_uint32()
        self.Address = v_uint32()
        self.UINumber = v_uint32()
        self.DeviceState = vstruct.VArray([ DEVICE_POWER_STATE() for i in xrange(7) ])
        self.SystemWake = v_uint32()
        self.DeviceWake = v_uint32()
        self.D1Latency = v_uint32()
        self.D2Latency = v_uint32()
        self.D3Latency = v_uint32()


class _unnamed_26916(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length40 = v_uint32()


class IOP_FILE_OBJECT_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FoExtFlags = v_uint32()
        self.FoExtPerTypeExtension = vstruct.VArray([ v_ptr32() for i in xrange(7) ])
        self.FoIoPriorityHint = v_uint32()


class VACB_LEVEL_REFERENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reference = v_uint32()
        self.SpecialReference = v_uint32()


class TOKEN_AUDIT_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PerUserPolicy = vstruct.VArray([ v_uint8() for i in xrange(27) ])


class _unnamed_26922(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length64 = v_uint32()


class ACL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AclRevision = v_uint8()
        self.Sbz1 = v_uint8()
        self.AclSize = v_uint16()
        self.AceCount = v_uint16()
        self.Sbz2 = v_uint16()


class PCW_INSTANCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_20897(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()


class DUAL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Map = v_ptr32()
        self.SmallDir = v_ptr32()
        self.Guard = v_uint32()
        self.FreeDisplay = vstruct.VArray([ FREE_DISPLAY() for i in xrange(24) ])
        self.FreeSummary = v_uint32()
        self.FreeBins = LIST_ENTRY()


class CALLBACK_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_20603(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsynchronousParameters = _unnamed_20618()


class CONFIGURATION_COMPONENT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parent = v_ptr32()
        self.Child = v_ptr32()
        self.Sibling = v_ptr32()
        self.ComponentEntry = CONFIGURATION_COMPONENT()
        self.ConfigurationData = v_ptr32()


class EXCEPTION_RECORD64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_uint64()
        self.ExceptionAddress = v_uint64()
        self.NumberParameters = v_uint32()
        self.unusedAlignment = v_uint32()
        self.ExceptionInformation = vstruct.VArray([ v_uint64() for i in xrange(15) ])


class _unnamed_20679(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.Thread = v_ptr32()
        self.AuxiliaryBuffer = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.CurrentStackLocation = v_ptr32()
        self.OriginalFileObject = v_ptr32()


class KPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.ProfileListHead = LIST_ENTRY()
        self.DirectoryTableBase = v_uint32()
        self.LdtDescriptor = KGDTENTRY()
        self.Int21Descriptor = KIDTENTRY()
        self.ThreadListHead = LIST_ENTRY()
        self.ProcessLock = v_uint32()
        self.Affinity = KAFFINITY_EX()
        self.ReadyListHead = LIST_ENTRY()
        self.SwapListEntry = SINGLE_LIST_ENTRY()
        self.ActiveProcessors = KAFFINITY_EX()
        self.AutoAlignment = v_uint32()
        self.BasePriority = v_uint8()
        self.QuantumReset = v_uint8()
        self.Visited = v_uint8()
        self.Unused3 = v_uint8()
        self.ThreadSeed = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.IdealNode = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self.IdealGlobalNode = v_uint16()
        self.Flags = KEXECUTE_OPTIONS()
        self.Unused1 = v_uint8()
        self.IopmOffset = v_uint16()
        self.Unused4 = v_uint32()
        self.StackCount = KSTACK_COUNT()
        self.ProcessListEntry = LIST_ENTRY()
        self.CycleTime = v_uint64()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.VdmTrapcHandler = v_ptr32()
        self._pad0098 = v_bytes(size=4)


class ALPC_COMMUNICATION_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ConnectionPort = v_ptr32()
        self.ServerCommunicationPort = v_ptr32()
        self.ClientCommunicationPort = v_ptr32()
        self.CommunicationList = LIST_ENTRY()
        self.HandleTable = ALPC_HANDLE_TABLE()


class DEVICE_OBJECT_POWER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleCount = v_uint32()
        self.BusyCount = v_uint32()
        self.BusyReference = v_uint32()
        self.TotalBusyCount = v_uint32()
        self.ConservationIdleTime = v_uint32()
        self.PerformanceIdleTime = v_uint32()
        self.DeviceObject = v_ptr32()
        self.IdleList = LIST_ENTRY()
        self.IdleType = v_uint32()
        self.IdleState = v_uint32()
        self.CurrentState = v_uint32()
        self.Volume = LIST_ENTRY()
        self.Specific = _unnamed_22946()


class _unnamed_20965(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WhichSpace = v_uint32()
        self.Buffer = v_ptr32()
        self.Offset = v_uint32()
        self.Length = v_uint32()


class MMPTE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class HEAP_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint32()
        self.TagIndex = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self.TagName = vstruct.VArray([ v_uint16() for i in xrange(24) ])


class ALPC_COMPLETION_LIST_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_27139()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Primary = v_uint32()


class TP_CALLBACK_ENVIRON_V3(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint32()
        self.Pool = v_ptr32()
        self.CleanupGroup = v_ptr32()
        self.CleanupGroupCancelCallback = v_ptr32()
        self.RaceDll = v_ptr32()
        self.ActivationContext = v_ptr32()
        self.FinalizationCallback = v_ptr32()
        self.u = _unnamed_18626()
        self.CallbackPriority = v_uint32()
        self.Size = v_uint32()


class VI_POOL_ENTRY_INUSE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_ptr32()
        self.CallingAddress = v_ptr32()
        self.NumberOfBytes = v_uint32()
        self.Tag = v_uint32()


class MEMORY_ALLOCATION_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.MemoryType = v_uint32()
        self.BasePage = v_uint32()
        self.PageCount = v_uint32()


class MMPTE_TRANSITION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class WHEA_ERROR_PACKET_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousError = v_uint32()


class ARM_DBGKD_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Continue = v_uint32()
        self.CurrentSymbolStart = v_uint32()
        self.CurrentSymbolEnd = v_uint32()


class ALPC_PROCESS_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = EX_PUSH_LOCK()
        self.ViewListHead = LIST_ENTRY()
        self.PagedPoolQuotaCache = v_uint32()


class DIAGNOSTIC_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CallerType = v_uint32()
        self.Process = v_ptr32()
        self.ServiceTag = v_uint32()
        self.ReasonSize = v_uint32()


class OBJECT_HANDLE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleAttributes = v_uint32()
        self.GrantedAccess = v_uint32()


class _unnamed_20702(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.FileAttributes = v_uint16()
        self.ShareAccess = v_uint16()
        self.EaLength = v_uint32()


class KSPIN_LOCK_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Lock = v_ptr32()


class HEAP_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = _unnamed_23705()


class XSTATE_CONFIGURATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnabledFeatures = v_uint64()
        self.Size = v_uint32()
        self.OptimizedSave = v_uint32()
        self.Features = vstruct.VArray([ XSTATE_FEATURE() for i in xrange(64) ])


class PS_CLIENT_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImpersonationData = v_uint32()


class RTL_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = RTL_BALANCED_LINKS()
        self.OrderedPointer = v_ptr32()
        self.WhichOrderedElement = v_uint32()
        self.NumberGenericTableElements = v_uint32()
        self.DepthOfTree = v_uint32()
        self.RestartKey = v_ptr32()
        self.DeleteCount = v_uint32()
        self.CompareRoutine = v_ptr32()
        self.AllocateRoutine = v_ptr32()
        self.FreeRoutine = v_ptr32()
        self.TableContext = v_ptr32()


class EXCEPTION_REGISTRATION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Handler = v_ptr32()


class _unnamed_23376(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReadMemory = DBGKD_READ_MEMORY32()
        self._pad0028 = v_bytes(size=28)


class _unnamed_27306(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsULONG = v_uint32()


class PNP_ASSIGN_RESOURCES_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IncludeFailedDevices = v_uint32()
        self.DeviceCount = v_uint32()
        self.DeviceList = vstruct.VArray([ v_ptr32() for i in xrange(1) ])


class _unnamed_28922(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DiskId = GUID()


class MAPPED_FILE_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlArea = v_ptr32()
        self.TotalNumberOfPtes = v_uint32()
        self.SegmentFlags = SEGMENT_FLAGS()
        self.NumberOfCommittedPages = v_uint32()
        self.SizeOfSegment = v_uint64()
        self.ExtendInfo = v_ptr32()
        self.SegmentLock = EX_PUSH_LOCK()


class DBGKD_GET_INTERNAL_BREAKPOINT64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakpointAddress = v_uint64()
        self.Flags = v_uint32()
        self.Calls = v_uint32()
        self.MaxCallsPerPeriod = v_uint32()
        self.MinInstructions = v_uint32()
        self.MaxInstructions = v_uint32()
        self.TotalInstructions = v_uint32()


class OWNER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerThread = v_uint32()
        self.IoPriorityBoosted = v_uint32()


class ETW_BUFFER_HANDLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TraceBuffer = v_ptr32()
        self.BufferFastRef = v_ptr32()


class DEVOBJ_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.PowerFlags = v_uint32()
        self.Dope = v_ptr32()
        self.ExtensionFlags = v_uint32()
        self.DeviceNode = v_ptr32()
        self.AttachedTo = v_ptr32()
        self.StartIoCount = v_uint32()
        self.StartIoKey = v_uint32()
        self.StartIoFlags = v_uint32()
        self.Vpb = v_ptr32()
        self.DependentList = LIST_ENTRY()
        self.ProviderList = LIST_ENTRY()


class HEAP_LOCAL_SEGMENT_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ARBITER_ALLOCATION_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint64()
        self.End = v_uint64()
        self.CurrentMinimum = v_uint64()
        self.CurrentMaximum = v_uint64()
        self.Entry = v_ptr32()
        self.CurrentAlternative = v_ptr32()
        self.AlternativeCount = v_uint32()
        self.Alternatives = v_ptr32()
        self.Flags = v_uint16()
        self.RangeAttributes = v_uint8()
        self.RangeAvailableAttributes = v_uint8()
        self.WorkSpace = v_uint32()


class BLOB_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ResourceId = v_uint32()
        self.PoolTag = v_uint32()
        self.Flags = v_uint32()
        self.CreatedObjects = v_uint32()
        self.DeletedObjects = v_uint32()
        self.DeleteProcedure = v_ptr32()
        self.DestroyProcedure = v_ptr32()
        self.UsualSize = v_uint32()
        self.LookasideIndex = v_uint32()


class DBGKD_SET_INTERNAL_BREAKPOINT64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakpointAddress = v_uint64()
        self.Flags = v_uint32()
        self._pad0010 = v_bytes(size=4)


class OPEN_PACKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.FileObject = v_ptr32()
        self.FinalStatus = v_uint32()
        self.Information = v_uint32()
        self.ParseCheck = v_uint32()
        self.RelatedFileObject = v_ptr32()
        self.OriginalAttributes = v_ptr32()
        self._pad0020 = v_bytes(size=4)
        self.AllocationSize = LARGE_INTEGER()
        self.CreateOptions = v_uint32()
        self.FileAttributes = v_uint16()
        self.ShareAccess = v_uint16()
        self.EaBuffer = v_ptr32()
        self.EaLength = v_uint32()
        self.Options = v_uint32()
        self.Disposition = v_uint32()
        self.BasicInformation = v_ptr32()
        self.NetworkInformation = v_ptr32()
        self.CreateFileType = v_uint32()
        self.MailslotOrPipeParameters = v_ptr32()
        self.Override = v_uint8()
        self.QueryOnly = v_uint8()
        self.DeleteOnly = v_uint8()
        self.FullAttributes = v_uint8()
        self.LocalFileObject = v_ptr32()
        self.InternalFlags = v_uint32()
        self.DriverCreateContext = IO_DRIVER_CREATE_CONTEXT()
        self._pad0070 = v_bytes(size=4)


class _unnamed_28049(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = LIST_ENTRY()


class _unnamed_18596(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class HEAP_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalMemoryReserved = v_uint32()
        self.TotalMemoryCommitted = v_uint32()
        self.TotalMemoryLargeUCR = v_uint32()
        self.TotalSizeInVirtualBlocks = v_uint32()
        self.TotalSegments = v_uint32()
        self.TotalUCRs = v_uint32()
        self.CommittOps = v_uint32()
        self.DeCommitOps = v_uint32()
        self.LockAcquires = v_uint32()
        self.LockCollisions = v_uint32()
        self.CommitRate = v_uint32()
        self.DecommittRate = v_uint32()
        self.CommitFailures = v_uint32()
        self.InBlockCommitFailures = v_uint32()
        self.CompactHeapCalls = v_uint32()
        self.CompactedUCRs = v_uint32()
        self.AllocAndFreeOps = v_uint32()
        self.InBlockDeccommits = v_uint32()
        self.InBlockDeccomitSize = v_uint32()
        self.HighWatermarkSize = v_uint32()
        self.LastPolledSize = v_uint32()


class WHEA_MEMORY_ERROR_SECTION_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ErrorStatus = v_uint64()


class BLOB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ResourceList = LIST_ENTRY()
        self.u1 = _unnamed_23967()
        self.ResourceId = v_uint8()
        self.CachedReferences = v_uint16()
        self.ReferenceCount = v_uint32()
        self.Lock = EX_PUSH_LOCK()
        self.Pad = v_uint32()


class WORK_QUEUE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkQueueLinks = LIST_ENTRY()
        self.Parameters = _unnamed_23571()
        self.Function = v_uint8()
        self._pad0010 = v_bytes(size=3)


class PI_BUS_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.NumberCSNs = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.ReadDataPort = v_ptr32()
        self.DataPortMapped = v_uint8()
        self._pad0010 = v_bytes(size=3)
        self.AddressPort = v_ptr32()
        self.AddrPortMapped = v_uint8()
        self._pad0018 = v_bytes(size=3)
        self.CommandPort = v_ptr32()
        self.CmdPortMapped = v_uint8()
        self._pad0020 = v_bytes(size=3)
        self.NextSlotNumber = v_uint32()
        self.DeviceList = SINGLE_LIST_ENTRY()
        self.CardList = SINGLE_LIST_ENTRY()
        self.PhysicalBusDevice = v_ptr32()
        self.FunctionalBusDevice = v_ptr32()
        self.AttachedDevice = v_ptr32()
        self.BusNumber = v_uint32()
        self.SystemPowerState = v_uint32()
        self.DevicePowerState = v_uint32()


class MAILSLOT_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MailslotQuota = v_uint32()
        self.MaximumMessageSize = v_uint32()
        self.ReadTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0018 = v_bytes(size=7)


class FS_FILTER_CALLBACK_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbackData = v_uint32()
        self.Operation = v_uint8()
        self.Reserved = v_uint8()
        self._pad0008 = v_bytes(size=2)
        self.DeviceObject = v_ptr32()
        self.FileObject = v_ptr32()
        self.Parameters = FS_FILTER_PARAMETERS()


class PPM_IDLE_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DomainMembers = KAFFINITY_EX()
        self.IdleCheck = v_ptr32()
        self.IdleHandler = v_ptr32()
        self._pad0018 = v_bytes(size=4)
        self.HvConfig = v_uint64()
        self.Context = v_ptr32()
        self.Latency = v_uint32()
        self.Power = v_uint32()
        self.TimeCheck = v_uint32()
        self.StateFlags = v_uint32()
        self.PromotePercent = v_uint8()
        self.DemotePercent = v_uint8()
        self.PromotePercentBase = v_uint8()
        self.DemotePercentBase = v_uint8()
        self.StateType = v_uint8()
        self._pad0040 = v_bytes(size=7)


class _unnamed_21803(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags = v_uint32()


class _unnamed_23914(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s2 = _unnamed_23920()


class ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OperationID = LUID()
        self.SecurityEvaluated = v_uint8()
        self.GenerateAudit = v_uint8()
        self.GenerateOnClose = v_uint8()
        self.PrivilegesAllocated = v_uint8()
        self.Flags = v_uint32()
        self.RemainingDesiredAccess = v_uint32()
        self.PreviouslyGrantedAccess = v_uint32()
        self.OriginalDesiredAccess = v_uint32()
        self.SubjectSecurityContext = SECURITY_SUBJECT_CONTEXT()
        self.SecurityDescriptor = v_ptr32()
        self.AuxData = v_ptr32()
        self.Privileges = _unnamed_20536()
        self.AuditPrivileges = v_uint8()
        self._pad0064 = v_bytes(size=3)
        self.ObjectName = UNICODE_STRING()
        self.ObjectTypeName = UNICODE_STRING()


class _unnamed_21806(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e2 = _unnamed_21872()


class DBGKD_SWITCH_PARTITION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Partition = v_uint32()


class TP_CALLBACK_INSTANCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class EX_PUSH_LOCK_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locks = vstruct.VArray([ v_ptr32() for i in xrange(32) ])


class _unnamed_26431(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.MinBusNumber = v_uint32()
        self.MaxBusNumber = v_uint32()
        self.Reserved = v_uint32()


class PROC_IDLE_ACCOUNTING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StateCount = v_uint32()
        self.TotalTransitions = v_uint32()
        self.ResetCount = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.StartTime = v_uint64()
        self.BucketLimits = vstruct.VArray([ v_uint64() for i in xrange(16) ])
        self.State = vstruct.VArray([ PROC_IDLE_STATE_ACCOUNTING() for i in xrange(1) ])


class _unnamed_26436(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Priority = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class GDI_TEB_BATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.HDC = v_uint32()
        self.Buffer = vstruct.VArray([ v_uint32() for i in xrange(310) ])


class DBGKD_SET_SPECIAL_CALL32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SpecialCall = v_uint32()


class SYSTEM_POWER_LEVEL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Enable = v_uint8()
        self.Spare = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.BatteryLevel = v_uint32()
        self.PowerPolicy = POWER_ACTION_POLICY()
        self.MinSystemState = v_uint32()


class DBGKD_SET_SPECIAL_CALL64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SpecialCall = v_uint64()


class DBGKM_EXCEPTION32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionRecord = EXCEPTION_RECORD32()
        self.FirstChance = v_uint32()


class PAGEFAULT_HISTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ECP_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Flags = v_uint32()
        self.EcpList = LIST_ENTRY()


class PROCESSOR_PERFSTATE_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint32()
        self.MaxThrottle = v_uint8()
        self.MinThrottle = v_uint8()
        self.BusyAdjThreshold = v_uint8()
        self.Spare = v_uint8()
        self.TimeCheck = v_uint32()
        self.IncreaseTime = v_uint32()
        self.DecreaseTime = v_uint32()
        self.IncreasePercent = v_uint32()
        self.DecreasePercent = v_uint32()


class NT_TIB64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_uint64()
        self.StackBase = v_uint64()
        self.StackLimit = v_uint64()
        self.SubSystemTib = v_uint64()
        self.FiberData = v_uint64()
        self.ArbitraryUserPointer = v_uint64()
        self.Self = v_uint64()


class SECTION_OBJECT_POINTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSectionObject = v_ptr32()
        self.SharedCacheMap = v_ptr32()
        self.ImageSectionObject = v_ptr32()


class MDL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Size = v_uint16()
        self.MdlFlags = v_uint16()
        self.Process = v_ptr32()
        self.MappedSystemVa = v_ptr32()
        self.StartVa = v_ptr32()
        self.ByteCount = v_uint32()
        self.ByteOffset = v_uint32()


class _unnamed_20875(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Srb = v_ptr32()


class KTRAP_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DbgEbp = v_uint32()
        self.DbgEip = v_uint32()
        self.DbgArgMark = v_uint32()
        self.DbgArgPointer = v_uint32()
        self.TempSegCs = v_uint16()
        self.Logging = v_uint8()
        self.Reserved = v_uint8()
        self.TempEsp = v_uint32()
        self.Dr0 = v_uint32()
        self.Dr1 = v_uint32()
        self.Dr2 = v_uint32()
        self.Dr3 = v_uint32()
        self.Dr6 = v_uint32()
        self.Dr7 = v_uint32()
        self.SegGs = v_uint32()
        self.SegEs = v_uint32()
        self.SegDs = v_uint32()
        self.Edx = v_uint32()
        self.Ecx = v_uint32()
        self.Eax = v_uint32()
        self.PreviousPreviousMode = v_uint32()
        self.ExceptionList = v_ptr32()
        self.SegFs = v_uint32()
        self.Edi = v_uint32()
        self.Esi = v_uint32()
        self.Ebx = v_uint32()
        self.Ebp = v_uint32()
        self.ErrCode = v_uint32()
        self.Eip = v_uint32()
        self.SegCs = v_uint32()
        self.EFlags = v_uint32()
        self.HardwareEsp = v_uint32()
        self.HardwareSegSs = v_uint32()
        self.V86Es = v_uint32()
        self.V86Ds = v_uint32()
        self.V86Fs = v_uint32()
        self.V86Gs = v_uint32()


class _unnamed_20871(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vpb = v_ptr32()
        self.DeviceObject = v_ptr32()


class CM_INDEX_HINT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.HashKey = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class SEP_AUDIT_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AdtTokenPolicy = TOKEN_AUDIT_POLICY()
        self.PolicySetStatus = v_uint8()


class AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityAttributeCount = v_uint32()
        self.SecurityAttributesList = LIST_ENTRY()
        self.WorkingSecurityAttributeCount = v_uint32()
        self.WorkingSecurityAttributesList = LIST_ENTRY()


class IO_TIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.TimerFlag = v_uint16()
        self.TimerList = LIST_ENTRY()
        self.TimerRoutine = v_ptr32()
        self.Context = v_ptr32()
        self.DeviceObject = v_ptr32()


class MM_STORE_KEY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.KeyLow = v_uint32()


class WHEA_REVISION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinorRevision = v_uint8()
        self.MajorRevision = v_uint8()


class TP_CLEANUP_GROUP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_21052(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProviderId = v_uint32()
        self.DataPath = v_ptr32()
        self.BufferSize = v_uint32()
        self.Buffer = v_ptr32()


class EVENT_FILTER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint16()
        self.Version = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(5) ])
        self.InstanceId = v_uint64()
        self.Size = v_uint32()
        self.NextOffset = v_uint32()


class PROC_IDLE_SNAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Time = v_uint64()
        self.Idle = v_uint64()


class _unnamed_21057(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr32()
        self.Argument2 = v_ptr32()
        self.Argument3 = v_ptr32()
        self.Argument4 = v_ptr32()


class _unnamed_21872(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumberOfSystemCacheViews = v_uint32()
        self.WritableUserReferences = v_uint32()
        self.SubsectionRoot = v_ptr32()


class RTL_DYNAMIC_HASH_TABLE_ENUMERATOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashEntry = RTL_DYNAMIC_HASH_TABLE_ENTRY()
        self.ChainHead = v_ptr32()
        self.BucketIndex = v_uint32()


class _unnamed_26445(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length48 = v_uint32()
        self.Alignment48 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class SECURITY_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.Sbz1 = v_uint8()
        self.Control = v_uint16()
        self.Owner = v_ptr32()
        self.Group = v_ptr32()
        self.Sacl = v_ptr32()
        self.Dacl = v_ptr32()


class _unnamed_26440(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length40 = v_uint32()
        self.Alignment40 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class PCW_PROCESSOR_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleTime = v_uint64()
        self.AvailableTime = v_uint64()
        self.UserTime = v_uint64()
        self.KernelTime = v_uint64()
        self.Interrupts = v_uint32()
        self._pad0028 = v_bytes(size=4)
        self.DpcTime = v_uint64()
        self.InterruptTime = v_uint64()
        self.DpcCount = v_uint32()
        self.DpcRate = v_uint32()
        self.C1Time = v_uint64()
        self.C2Time = v_uint64()
        self.C3Time = v_uint64()
        self.C1Transitions = v_uint64()
        self.C2Transitions = v_uint64()
        self.C3Transitions = v_uint64()
        self.ParkingStatus = v_uint32()
        self.CurrentFrequency = v_uint32()
        self.PercentMaxFrequency = v_uint32()
        self.StateFlags = v_uint32()


class OBJECT_TYPE_INITIALIZER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.ObjectTypeFlags = v_uint8()
        self._pad0004 = v_bytes(size=1)
        self.ObjectTypeCode = v_uint32()
        self.InvalidAttributes = v_uint32()
        self.GenericMapping = GENERIC_MAPPING()
        self.ValidAccessMask = v_uint32()
        self.RetainAccess = v_uint32()
        self.PoolType = v_uint32()
        self.DefaultPagedPoolCharge = v_uint32()
        self.DefaultNonPagedPoolCharge = v_uint32()
        self.DumpProcedure = v_ptr32()
        self.OpenProcedure = v_ptr32()
        self.CloseProcedure = v_ptr32()
        self.DeleteProcedure = v_ptr32()
        self.ParseProcedure = v_ptr32()
        self.SecurityProcedure = v_ptr32()
        self.QueryNameProcedure = v_ptr32()
        self.OkayToCloseProcedure = v_ptr32()


class TP_DIRECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callback = v_ptr32()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()
        self._pad000c = v_bytes(size=3)


class XSTATE_SAVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved1 = v_uint64()
        self.Reserved2 = v_uint32()
        self.Prev = v_ptr32()
        self.Reserved3 = v_ptr32()
        self.Thread = v_ptr32()
        self.Reserved4 = v_ptr32()
        self.Level = v_uint8()
        self._pad0020 = v_bytes(size=3)


class PTE_TRACKER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.Mdl = v_ptr32()
        self.Count = v_uint32()
        self.SystemVa = v_ptr32()
        self.StartVa = v_ptr32()
        self.Offset = v_uint32()
        self.Length = v_uint32()
        self.Page = v_uint32()
        self.IoMapping = v_uint32()
        self.CallingAddress = v_ptr32()
        self.CallersCaller = v_ptr32()


class HEAP_ENTRY_EXTRA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatorBackTraceIndex = v_uint16()
        self.TagIndex = v_uint16()
        self.Settable = v_uint32()


class POP_DEVICE_SYS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IrpMinor = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.SystemState = v_uint32()
        self.SpinLock = v_uint32()
        self.Thread = v_ptr32()
        self.AbortEvent = v_ptr32()
        self.ReadySemaphore = v_ptr32()
        self.FinishedSemaphore = v_ptr32()
        self.GetNewDeviceList = v_uint8()
        self._pad0020 = v_bytes(size=3)
        self.Order = PO_DEVICE_NOTIFY_ORDER()
        self.Pending = LIST_ENTRY()
        self.Status = v_uint32()
        self.FailedDevice = v_ptr32()
        self.Waking = v_uint8()
        self.Cancelled = v_uint8()
        self.IgnoreErrors = v_uint8()
        self.IgnoreNotImplemented = v_uint8()
        self.TimeRefreshLockAcquired = v_uint8()
        self._pad01a8 = v_bytes(size=3)


class _unnamed_26888(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length = v_uint32()


class VI_DEADLOCK_RESOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.NodeCount = v_uint32()
        self.ResourceAddress = v_ptr32()
        self.ThreadOwner = v_ptr32()
        self.ResourceList = LIST_ENTRY()
        self.HashChainList = LIST_ENTRY()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(8) ])
        self.LastAcquireTrace = vstruct.VArray([ v_ptr32() for i in xrange(8) ])
        self.LastReleaseTrace = vstruct.VArray([ v_ptr32() for i in xrange(8) ])


class HEAP_PSEUDO_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint32()


class _unnamed_26962(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CellData = CELL_DATA()


class MMPFNLIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Total = v_uint32()
        self.ListName = v_uint32()
        self.Flink = v_uint32()
        self.Blink = v_uint32()
        self.Lock = v_uint32()


class CM_KEY_REFERENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.KeyCell = v_uint32()
        self.KeyHive = v_ptr32()


class MMSECTION_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BeingDeleted = v_uint32()


class MI_SPECIAL_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PteBase = v_ptr32()
        self.Lock = v_uint32()
        self.Paged = MI_SPECIAL_POOL_PTE_LIST()
        self.NonPaged = MI_SPECIAL_POOL_PTE_LIST()
        self.PagesInUse = v_uint32()
        self.SpecialPoolPdes = RTL_BITMAP()


class MM_SUBSECTION_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = MMSUBSECTION_NODE()
        self.DepthOfTree = v_uint32()
        self.NodeHint = v_ptr32()


class _unnamed_27139(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_28591()


class NETWORK_LOADER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DHCPServerACK = v_ptr32()
        self.DHCPServerACKLength = v_uint32()
        self.BootServerReplyPacket = v_ptr32()
        self.BootServerReplyPacketLength = v_uint32()


class _unnamed_20737(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Key = v_uint32()
        self.ByteOffset = LARGE_INTEGER()


class CM_TRANS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TransactionListEntry = LIST_ENTRY()
        self.KCBUoWListHead = LIST_ENTRY()
        self.LazyCommitListEntry = LIST_ENTRY()
        self.KtmTrans = v_ptr32()
        self.CmRm = v_ptr32()
        self.KtmEnlistmentObject = v_ptr32()
        self.KtmEnlistmentHandle = v_ptr32()
        self.KtmUow = GUID()
        self.StartLsn = v_uint64()
        self.TransState = v_uint32()
        self.HiveCount = v_uint32()
        self.HiveArray = vstruct.VArray([ v_ptr32() for i in xrange(7) ])
        self._pad0068 = v_bytes(size=4)


class POP_POWER_ACTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Updates = v_uint8()
        self.State = v_uint8()
        self.Shutdown = v_uint8()
        self._pad0004 = v_bytes(size=1)
        self.Action = v_uint32()
        self.LightestState = v_uint32()
        self.Flags = v_uint32()
        self.Status = v_uint32()
        self.DeviceType = v_uint32()
        self.DeviceTypeFlags = v_uint32()
        self.IrpMinor = v_uint8()
        self.Waking = v_uint8()
        self._pad0020 = v_bytes(size=2)
        self.SystemState = v_uint32()
        self.NextSystemState = v_uint32()
        self.EffectiveSystemState = v_uint32()
        self.CurrentSystemState = v_uint32()
        self.ShutdownBugCode = v_ptr32()
        self.DevState = v_ptr32()
        self.HiberContext = v_ptr32()
        self._pad0040 = v_bytes(size=4)
        self.WakeTime = v_uint64()
        self.SleepTime = v_uint64()
        self.ProgrammedRTCTime = v_uint64()
        self.WakeOnRTC = v_uint8()
        self._pad005c = v_bytes(size=3)
        self.WakeTimerInfo = v_ptr32()
        self.FilteredCapabilities = SYSTEM_POWER_CAPABILITIES()
        self._pad00b0 = v_bytes(size=4)


class OBJECT_CREATE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Attributes = v_uint32()
        self.RootDirectory = v_ptr32()
        self.ProbeMode = v_uint8()
        self._pad000c = v_bytes(size=3)
        self.PagedPoolCharge = v_uint32()
        self.NonPagedPoolCharge = v_uint32()
        self.SecurityDescriptorCharge = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.SecurityQos = v_ptr32()
        self.SecurityQualityOfService = SECURITY_QUALITY_OF_SERVICE()


class OBJECT_HEADER_CREATOR_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TypeList = LIST_ENTRY()
        self.CreatorUniqueProcess = v_ptr32()
        self.CreatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()


class PAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = FAST_MUTEX()
        self._pad00c0 = v_bytes(size=32)


class _unnamed_24236(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.QueueType = v_uint32()


class PO_NOTIFY_ORDER_LEVEL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceCount = v_uint32()
        self.ActiveCount = v_uint32()
        self.WaitSleep = LIST_ENTRY()
        self.ReadySleep = LIST_ENTRY()
        self.ReadyS0 = LIST_ENTRY()
        self.WaitS0 = LIST_ENTRY()


class RTL_BITMAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfBitMap = v_uint32()
        self.Buffer = v_ptr32()


class LARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class IA64_DBGKD_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Continue = v_uint32()
        self.CurrentSymbolStart = v_uint64()
        self.CurrentSymbolEnd = v_uint64()


class NPAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = v_uint32()
        self._pad00c0 = v_bytes(size=60)


class HBIN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.FileOffset = v_uint32()
        self.Size = v_uint32()
        self.Reserved1 = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.TimeStamp = LARGE_INTEGER()
        self.Spare = v_uint32()


class _unnamed_21980(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags2 = v_uint32()


class BITMAP_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Links = LIST_ENTRY()
        self.BasePage = v_uint64()
        self.FirstDirtyPage = v_uint32()
        self.LastDirtyPage = v_uint32()
        self.DirtyPages = v_uint32()
        self.Bitmap = v_ptr32()


class SYSTEM_TRACE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Marker = v_uint32()
        self.Header = v_uint32()
        self.ThreadId = v_uint32()
        self.ProcessId = v_uint32()
        self.SystemTime = LARGE_INTEGER()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()


class ETW_REG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RegList = LIST_ENTRY()
        self.GuidEntry = v_ptr32()
        self.Index = v_uint16()
        self.Flags = v_uint16()
        self.EnableMask = v_uint8()
        self._pad0014 = v_bytes(size=3)
        self.SessionId = v_uint32()
        self._pad0024 = v_bytes(size=12)
        self.Process = v_ptr32()
        self.CallbackContext = v_ptr32()


class KLOCK_QUEUE_HANDLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LockQueue = KSPIN_LOCK_QUEUE()
        self.OldIrql = v_uint8()
        self._pad000c = v_bytes(size=3)


class CLIENT_ID32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_uint32()
        self.UniqueThread = v_uint32()


class CLS_LSN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.offset = _unnamed_28441()


class ALIGNED_AFFINITY_SUMMARY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CpuSet = KAFFINITY_EX()
        self.SMTSet = KAFFINITY_EX()
        self._pad0040 = v_bytes(size=40)


class VPB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.Flags = v_uint16()
        self.VolumeLabelLength = v_uint16()
        self.DeviceObject = v_ptr32()
        self.RealDevice = v_ptr32()
        self.SerialNumber = v_uint32()
        self.ReferenceCount = v_uint32()
        self.VolumeLabel = vstruct.VArray([ v_uint16() for i in xrange(32) ])


class OBP_LOOKUP_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Directory = v_ptr32()
        self.Object = v_ptr32()
        self.HashValue = v_uint32()
        self.HashIndex = v_uint16()
        self.DirectoryLocked = v_uint8()
        self.LockedExclusive = v_uint8()
        self.LockStateSignature = v_uint32()


class OB_DUPLICATE_OBJECT_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SourceProcess = v_ptr32()
        self.SourceHandle = v_ptr32()
        self.Object = v_ptr32()
        self.TargetAccess = v_uint32()
        self.ObjectInfo = HANDLE_TABLE_ENTRY_INFO()
        self.HandleAttributes = v_uint32()


class PP_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P = v_ptr32()
        self.L = v_ptr32()


class SEP_LOGON_SESSION_REFERENCES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.LogonId = LUID()
        self.BuddyLogonId = LUID()
        self.ReferenceCount = v_uint32()
        self.Flags = v_uint32()
        self.pDeviceMap = v_ptr32()
        self.Token = v_ptr32()
        self.AccountName = UNICODE_STRING()
        self.AuthorityName = UNICODE_STRING()


class _unnamed_26746(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsUCHAR = v_uint8()


class _unnamed_23990(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24044()


class MMPTE_TIMESTAMP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MustBeZero = v_uint32()


class OBJECT_NAME_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = UNICODE_STRING()


class OBJECT_HEADER_PROCESS_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExclusiveProcess = v_ptr32()
        self.Reserved = v_uint32()


class LPCP_MESSAGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = LIST_ENTRY()
        self.SenderPort = v_ptr32()
        self.RepliedToThread = v_ptr32()
        self.PortContext = v_ptr32()
        self._pad0018 = v_bytes(size=4)
        self.Request = PORT_MESSAGE()


class KUSER_SHARED_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TickCountLowDeprecated = v_uint32()
        self.TickCountMultiplier = v_uint32()
        self.InterruptTime = KSYSTEM_TIME()
        self.SystemTime = KSYSTEM_TIME()
        self.TimeZoneBias = KSYSTEM_TIME()
        self.ImageNumberLow = v_uint16()
        self.ImageNumberHigh = v_uint16()
        self.NtSystemRoot = vstruct.VArray([ v_uint16() for i in xrange(260) ])
        self.MaxStackTraceDepth = v_uint32()
        self.CryptoExponent = v_uint32()
        self.TimeZoneId = v_uint32()
        self.LargePageMinimum = v_uint32()
        self.Reserved2 = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self.NtProductType = v_uint32()
        self.ProductTypeIsValid = v_uint8()
        self._pad026c = v_bytes(size=3)
        self.NtMajorVersion = v_uint32()
        self.NtMinorVersion = v_uint32()
        self.ProcessorFeatures = vstruct.VArray([ v_uint8() for i in xrange(64) ])
        self.Reserved1 = v_uint32()
        self.Reserved3 = v_uint32()
        self.TimeSlip = v_uint32()
        self.AlternativeArchitecture = v_uint32()
        self.AltArchitecturePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.SystemExpirationDate = LARGE_INTEGER()
        self.SuiteMask = v_uint32()
        self.KdDebuggerEnabled = v_uint8()
        self.NXSupportPolicy = v_uint8()
        self._pad02d8 = v_bytes(size=2)
        self.ActiveConsoleId = v_uint32()
        self.DismountCount = v_uint32()
        self.ComPlusPackage = v_uint32()
        self.LastSystemRITEventTickCount = v_uint32()
        self.NumberOfPhysicalPages = v_uint32()
        self.SafeBootMode = v_uint8()
        self.TscQpcData = v_uint8()
        self.TscQpcPad = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.SharedDataFlags = v_uint32()
        self.DataFlagsPad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.TestRetInstruction = v_uint64()
        self.SystemCall = v_uint32()
        self.SystemCallReturn = v_uint32()
        self.SystemCallPad = vstruct.VArray([ v_uint64() for i in xrange(3) ])
        self.TickCount = KSYSTEM_TIME()
        self.TickCountPad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.Cookie = v_uint32()
        self.CookiePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.ConsoleSessionForegroundProcessId = v_uint64()
        self.Wow64SharedInformation = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.UserModeGlobalLogger = vstruct.VArray([ v_uint16() for i in xrange(16) ])
        self.ImageFileExecutionOptions = v_uint32()
        self.LangGenerationCount = v_uint32()
        self.Reserved5 = v_uint64()
        self.InterruptTimeBias = v_uint64()
        self.TscQpcBias = v_uint64()
        self.ActiveProcessorCount = v_uint32()
        self.ActiveGroupCount = v_uint16()
        self.Reserved4 = v_uint16()
        self.AitSamplingValue = v_uint32()
        self.AppCompatFlag = v_uint32()
        self.SystemDllNativeRelocation = v_uint64()
        self.SystemDllWowRelocation = v_uint32()
        self.XStatePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.XState = XSTATE_CONFIGURATION()


class SYSTEM_POWER_STATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved1 = v_uint32()


class _unnamed_20640(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Create = _unnamed_20702()


class _unnamed_25279(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.List = LIST_ENTRY()


class KTM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cookie = v_uint32()
        self.Mutex = KMUTANT()
        self.State = v_uint32()
        self.NamespaceLink = KTMOBJECT_NAMESPACE_LINK()
        self.TmIdentity = GUID()
        self.Flags = v_uint32()
        self.VolatileFlags = v_uint32()
        self.LogFileName = UNICODE_STRING()
        self.LogFileObject = v_ptr32()
        self.MarshallingContext = v_ptr32()
        self.LogManagementContext = v_ptr32()
        self.Transactions = KTMOBJECT_NAMESPACE()
        self.ResourceManagers = KTMOBJECT_NAMESPACE()
        self.LsnOrderedMutex = KMUTANT()
        self.LsnOrderedList = LIST_ENTRY()
        self.CommitVirtualClock = LARGE_INTEGER()
        self.CommitVirtualClockMutex = FAST_MUTEX()
        self.BaseLsn = CLS_LSN()
        self.CurrentReadLsn = CLS_LSN()
        self.LastRecoveredLsn = CLS_LSN()
        self.TmRmHandle = v_ptr32()
        self.TmRm = v_ptr32()
        self.LogFullNotifyEvent = KEVENT()
        self.CheckpointWorkItem = WORK_QUEUE_ITEM()
        self.CheckpointTargetLsn = CLS_LSN()
        self.LogFullCompletedWorkItem = WORK_QUEUE_ITEM()
        self.LogWriteResource = ERESOURCE()
        self.LogFlags = v_uint32()
        self.LogFullStatus = v_uint32()
        self.RecoveryStatus = v_uint32()
        self._pad0218 = v_bytes(size=4)
        self.LastCheckBaseLsn = CLS_LSN()
        self.RestartOrderedList = LIST_ENTRY()
        self.OfflineWorkItem = WORK_QUEUE_ITEM()


class PRIVATE_CACHE_MAP_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DontUse = v_uint32()


class _unnamed_20906(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_ptr32()
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Interface = v_ptr32()
        self.InterfaceSpecificData = v_ptr32()


class VF_TARGET_VERIFIED_DRIVER_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SuspectDriverEntry = v_ptr32()
        self.WMICallback = v_ptr32()
        self.EtwHandlesListHead = LIST_ENTRY()
        self.u1 = _unnamed_26653()
        self.Signature = v_uint32()
        self.PoolPageHeaders = SLIST_HEADER()
        self.PoolTrackers = SLIST_HEADER()
        self.CurrentPagedPoolAllocations = v_uint32()
        self.CurrentNonPagedPoolAllocations = v_uint32()
        self.PeakPagedPoolAllocations = v_uint32()
        self.PeakNonPagedPoolAllocations = v_uint32()
        self.PagedBytes = v_uint32()
        self.NonPagedBytes = v_uint32()
        self.PeakPagedBytes = v_uint32()
        self.PeakNonPagedBytes = v_uint32()
        self.RaiseIrqls = v_uint32()
        self.AcquireSpinLocks = v_uint32()
        self.SynchronizeExecutions = v_uint32()
        self.AllocationsWithNoTag = v_uint32()
        self.AllocationsFailed = v_uint32()
        self.AllocationsFailedDeliberately = v_uint32()
        self.LockedBytes = v_uint32()
        self.PeakLockedBytes = v_uint32()
        self.MappedLockedBytes = v_uint32()
        self.PeakMappedLockedBytes = v_uint32()
        self.MappedIoSpaceBytes = v_uint32()
        self.PeakMappedIoSpaceBytes = v_uint32()
        self.PagesForMdlBytes = v_uint32()
        self.PeakPagesForMdlBytes = v_uint32()
        self.ContiguousMemoryBytes = v_uint32()
        self.PeakContiguousMemoryBytes = v_uint32()
        self.ContiguousMemoryListHead = LIST_ENTRY()


class HEAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.SegmentSignature = v_uint32()
        self.SegmentFlags = v_uint32()
        self.SegmentListEntry = LIST_ENTRY()
        self.Heap = v_ptr32()
        self.BaseAddress = v_ptr32()
        self.NumberOfPages = v_uint32()
        self.FirstEntry = v_ptr32()
        self.LastValidEntry = v_ptr32()
        self.NumberOfUnCommittedPages = v_uint32()
        self.NumberOfUnCommittedRanges = v_uint32()
        self.SegmentAllocatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self.UCRSegmentList = LIST_ENTRY()
        self.Flags = v_uint32()
        self.ForceFlags = v_uint32()
        self.CompatibilityFlags = v_uint32()
        self.EncodeFlagMask = v_uint32()
        self.Encoding = HEAP_ENTRY()
        self.PointerKey = v_uint32()
        self.Interceptor = v_uint32()
        self.VirtualMemoryThreshold = v_uint32()
        self.Signature = v_uint32()
        self.SegmentReserve = v_uint32()
        self.SegmentCommit = v_uint32()
        self.DeCommitFreeBlockThreshold = v_uint32()
        self.DeCommitTotalFreeThreshold = v_uint32()
        self.TotalFreeSize = v_uint32()
        self.MaximumAllocationSize = v_uint32()
        self.ProcessHeapsListIndex = v_uint16()
        self.HeaderValidateLength = v_uint16()
        self.HeaderValidateCopy = v_ptr32()
        self.NextAvailableTagIndex = v_uint16()
        self.MaximumTagIndex = v_uint16()
        self.TagEntries = v_ptr32()
        self.UCRList = LIST_ENTRY()
        self.AlignRound = v_uint32()
        self.AlignMask = v_uint32()
        self.VirtualAllocdBlocks = LIST_ENTRY()
        self.SegmentList = LIST_ENTRY()
        self.AllocatorBackTraceIndex = v_uint16()
        self._pad00b4 = v_bytes(size=2)
        self.NonDedicatedListLength = v_uint32()
        self.BlocksIndex = v_ptr32()
        self.UCRIndex = v_ptr32()
        self.PseudoTagEntries = v_ptr32()
        self.FreeLists = LIST_ENTRY()
        self.LockVariable = v_ptr32()
        self.CommitRoutine = v_ptr32()
        self.FrontEndHeap = v_ptr32()
        self.FrontHeapLockCount = v_uint16()
        self.FrontEndHeapType = v_uint8()
        self._pad00dc = v_bytes(size=1)
        self.Counters = HEAP_COUNTERS()
        self.TuningParameters = HEAP_TUNING_PARAMETERS()


class HANDLE_TRACE_DEBUG_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RefCount = v_uint32()
        self.TableSize = v_uint32()
        self.BitMaskFlags = v_uint32()
        self.CloseCompactionLock = FAST_MUTEX()
        self.CurrentStackIndex = v_uint32()
        self.TraceDb = vstruct.VArray([ HANDLE_TRACE_DB_ENTRY() for i in xrange(1) ])


class HCELL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.u = _unnamed_22491()


class CM_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.List = vstruct.VArray([ CM_FULL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class EPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pcb = KPROCESS()
        self.ProcessLock = EX_PUSH_LOCK()
        self._pad00a0 = v_bytes(size=4)
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.UniqueProcessId = v_ptr32()
        self.ActiveProcessLinks = LIST_ENTRY()
        self.ProcessQuotaUsage = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ProcessQuotaPeak = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.CommitCharge = v_uint32()
        self.QuotaBlock = v_ptr32()
        self.CpuQuotaBlock = v_ptr32()
        self.PeakVirtualSize = v_uint32()
        self.VirtualSize = v_uint32()
        self.SessionProcessLinks = LIST_ENTRY()
        self.DebugPort = v_ptr32()
        self.ExceptionPortData = v_ptr32()
        self.ObjectTable = v_ptr32()
        self.Token = EX_FAST_REF()
        self.WorkingSetPage = v_uint32()
        self.AddressCreationLock = EX_PUSH_LOCK()
        self.RotateInProgress = v_ptr32()
        self.ForkInProgress = v_ptr32()
        self.HardwareTrigger = v_uint32()
        self.PhysicalVadRoot = v_ptr32()
        self.CloneRoot = v_ptr32()
        self.NumberOfPrivatePages = v_uint32()
        self.NumberOfLockedPages = v_uint32()
        self.Win32Process = v_ptr32()
        self.Job = v_ptr32()
        self.SectionObject = v_ptr32()
        self.SectionBaseAddress = v_ptr32()
        self.Cookie = v_uint32()
        self.Spare8 = v_uint32()
        self.WorkingSetWatch = v_ptr32()
        self.Win32WindowStation = v_ptr32()
        self.InheritedFromUniqueProcessId = v_ptr32()
        self.LdtInformation = v_ptr32()
        self.VdmObjects = v_ptr32()
        self.ConsoleHostProcess = v_uint32()
        self.DeviceMap = v_ptr32()
        self.EtwDataSource = v_ptr32()
        self.FreeTebHint = v_ptr32()
        self._pad0160 = v_bytes(size=4)
        self.PageDirectoryPte = HARDWARE_PTE()
        self._pad0168 = v_bytes(size=4)
        self.Session = v_ptr32()
        self.ImageFileName = vstruct.VArray([ v_uint8() for i in xrange(15) ])
        self.PriorityClass = v_uint8()
        self.JobLinks = LIST_ENTRY()
        self.LockedPagesList = v_ptr32()
        self.ThreadListHead = LIST_ENTRY()
        self.SecurityPort = v_ptr32()
        self.PaeTop = v_ptr32()
        self.ActiveThreads = v_uint32()
        self.ImagePathHash = v_uint32()
        self.DefaultHardErrorProcessing = v_uint32()
        self.LastThreadExitStatus = v_uint32()
        self.Peb = v_ptr32()
        self.PrefetchTrace = EX_FAST_REF()
        self.ReadOperationCount = LARGE_INTEGER()
        self.WriteOperationCount = LARGE_INTEGER()
        self.OtherOperationCount = LARGE_INTEGER()
        self.ReadTransferCount = LARGE_INTEGER()
        self.WriteTransferCount = LARGE_INTEGER()
        self.OtherTransferCount = LARGE_INTEGER()
        self.CommitChargeLimit = v_uint32()
        self.CommitChargePeak = v_uint32()
        self.AweInfo = v_ptr32()
        self.SeAuditProcessCreationInfo = SE_AUDIT_PROCESS_CREATION_INFO()
        self.Vm = MMSUPPORT()
        self.MmProcessLinks = LIST_ENTRY()
        self.HighestUserAddress = v_ptr32()
        self.ModifiedPageCount = v_uint32()
        self.Flags2 = v_uint32()
        self.Flags = v_uint32()
        self.ExitStatus = v_uint32()
        self.VadRoot = MM_AVL_TABLE()
        self.AlpcContext = ALPC_PROCESS_CONTEXT()
        self.TimerResolutionLink = LIST_ENTRY()
        self.RequestedTimerResolution = v_uint32()
        self.ActiveThreadsHighWatermark = v_uint32()
        self.SmallestTimerResolution = v_uint32()
        self.TimerResolutionStackRecord = v_ptr32()


class _unnamed_25316(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsULONG = v_uint32()


class ALPC_PORT_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.SecurityQos = SECURITY_QUALITY_OF_SERVICE()
        self.MaxMessageLength = v_uint32()
        self.MemoryBandwidth = v_uint32()
        self.MaxPoolUsage = v_uint32()
        self.MaxSectionSize = v_uint32()
        self.MaxViewSize = v_uint32()
        self.MaxTotalSectionSize = v_uint32()
        self.DupObjectTypes = v_uint32()


class CM_KEY_BODY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.KeyControlBlock = v_ptr32()
        self.NotifyBlock = v_ptr32()
        self.ProcessID = v_ptr32()
        self.KeyBodyList = LIST_ENTRY()
        self.Flags = v_uint32()
        self.KtmTrans = v_ptr32()
        self.KtmUow = v_ptr32()
        self.ContextListHead = LIST_ENTRY()


class KMUTANT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.MutantListEntry = LIST_ENTRY()
        self.OwnerThread = v_ptr32()
        self.Abandoned = v_uint8()
        self.ApcDisable = v_uint8()
        self._pad0020 = v_bytes(size=2)


class POWER_SEQUENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SequenceD1 = v_uint32()
        self.SequenceD2 = v_uint32()
        self.SequenceD3 = v_uint32()


class TEB_ACTIVE_FRAME_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.FrameName = v_ptr32()


class KAPC_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ApcListHead = vstruct.VArray([ LIST_ENTRY() for i in xrange(2) ])
        self.Process = v_ptr32()
        self.KernelApcInProgress = v_uint8()
        self.KernelApcPending = v_uint8()
        self.UserApcPending = v_uint8()
        self._pad0018 = v_bytes(size=1)


class KTIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.DueTime = ULARGE_INTEGER()
        self.TimerListEntry = LIST_ENTRY()
        self.Dpc = v_ptr32()
        self.Period = v_uint32()


class MM_PAGED_POOL_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mutex = KGUARDED_MUTEX()
        self.PagedPoolAllocationMap = RTL_BITMAP()
        self.FirstPteForPagedPool = v_ptr32()
        self.PagedPoolHint = v_uint32()
        self.PagedPoolCommit = v_uint32()
        self.AllocatedPagedPool = v_uint32()


class HIVE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileName = v_ptr32()
        self.BaseName = v_ptr32()
        self.RegRootName = v_ptr32()
        self.CmHive = v_ptr32()
        self.HHiveFlags = v_uint32()
        self.CmHiveFlags = v_uint32()
        self.CmKcbCacheSize = v_uint32()
        self.CmHive2 = v_ptr32()
        self.HiveMounted = v_uint8()
        self.ThreadFinished = v_uint8()
        self.ThreadStarted = v_uint8()
        self.Allocate = v_uint8()
        self.WinPERequired = v_uint8()
        self._pad0028 = v_bytes(size=3)
        self.StartEvent = KEVENT()
        self.FinishedEvent = KEVENT()
        self.MountLock = KEVENT()


class WHEA_ERROR_STATUS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ErrorStatus = v_uint64()


class CM_PARTIAL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Flags = v_uint16()
        self.u = _unnamed_26359()


class DEVICE_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Sibling = v_ptr32()
        self.Child = v_ptr32()
        self.Parent = v_ptr32()
        self.LastChild = v_ptr32()
        self.PhysicalDeviceObject = v_ptr32()
        self.InstancePath = UNICODE_STRING()
        self.ServiceName = UNICODE_STRING()
        self.PendingIrp = v_ptr32()
        self.Level = v_uint32()
        self.Notify = PO_DEVICE_NOTIFY()
        self.PoIrpManager = PO_IRP_MANAGER()
        self.State = v_uint32()
        self.PreviousState = v_uint32()
        self.StateHistory = vstruct.VArray([ PNP_DEVNODE_STATE() for i in xrange(20) ])
        self.StateHistoryEntry = v_uint32()
        self.CompletionStatus = v_uint32()
        self.Flags = v_uint32()
        self.UserFlags = v_uint32()
        self.Problem = v_uint32()
        self.ResourceList = v_ptr32()
        self.ResourceListTranslated = v_ptr32()
        self.DuplicatePDO = v_ptr32()
        self.ResourceRequirements = v_ptr32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.ChildInterfaceType = v_uint32()
        self.ChildBusNumber = v_uint32()
        self.ChildBusTypeIndex = v_uint16()
        self.RemovalPolicy = v_uint8()
        self.HardwareRemovalPolicy = v_uint8()
        self.TargetDeviceNotify = LIST_ENTRY()
        self.DeviceArbiterList = LIST_ENTRY()
        self.DeviceTranslatorList = LIST_ENTRY()
        self.NoTranslatorMask = v_uint16()
        self.QueryTranslatorMask = v_uint16()
        self.NoArbiterMask = v_uint16()
        self.QueryArbiterMask = v_uint16()
        self.OverUsed1 = _unnamed_23008()
        self.OverUsed2 = _unnamed_23009()
        self.BootResources = v_ptr32()
        self.BootResourcesTranslated = v_ptr32()
        self.CapabilityFlags = v_uint32()
        self.DockInfo = _unnamed_23010()
        self.DisableableDepends = v_uint32()
        self.PendedSetInterfaceState = LIST_ENTRY()
        self.LegacyBusListEntry = LIST_ENTRY()
        self.DriverUnloadRetryCount = v_uint32()
        self.PreviousParent = v_ptr32()
        self.DeletedChildren = v_uint32()
        self.NumaNodeIndex = v_uint32()
        self.ContainerID = GUID()
        self.OverrideFlags = v_uint8()
        self.RequiresUnloadedDriver = v_uint8()
        self._pad0184 = v_bytes(size=2)
        self.PendingEjectRelations = v_ptr32()


class _unnamed_20992(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InPath = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.Type = v_uint32()


class OBJECT_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.RootDirectory = v_ptr32()
        self.ObjectName = v_ptr32()
        self.Attributes = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.SecurityQualityOfService = v_ptr32()


class CM_VIEW_OF_FILE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MappedViewLinks = LIST_ENTRY()
        self.PinnedViewLinks = LIST_ENTRY()
        self.FlushedViewLinks = LIST_ENTRY()
        self.CmHive = v_ptr32()
        self.Bcb = v_ptr32()
        self.ViewAddress = v_ptr32()
        self.FileOffset = v_uint32()
        self.Size = v_uint32()
        self.UseCount = v_uint32()


class ALPC_COMPLETION_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = LIST_ENTRY()
        self.OwnerProcess = v_ptr32()
        self.Mdl = v_ptr32()
        self.UserVa = v_ptr32()
        self.UserLimit = v_ptr32()
        self.DataUserVa = v_ptr32()
        self.SystemVa = v_ptr32()
        self.TotalSize = v_uint32()
        self.Header = v_ptr32()
        self.List = v_ptr32()
        self.ListSize = v_uint32()
        self.Bitmap = v_ptr32()
        self.BitmapSize = v_uint32()
        self.Data = v_ptr32()
        self.DataSize = v_uint32()
        self.BitmapLimit = v_uint32()
        self.BitmapNextHint = v_uint32()
        self.ConcurrencyCount = v_uint32()
        self.AttributeFlags = v_uint32()
        self.AttributeSize = v_uint32()


class _unnamed_20804(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.CompletionFilter = v_uint32()


class CM_FULL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.PartialResourceList = CM_PARTIAL_RESOURCE_LIST()


class _unnamed_28919(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.CheckSum = v_uint32()


class DBGKD_GET_VERSION64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.ProtocolVersion = v_uint8()
        self.KdSecondaryVersion = v_uint8()
        self.Flags = v_uint16()
        self.MachineType = v_uint16()
        self.MaxPacketType = v_uint8()
        self.MaxStateChange = v_uint8()
        self.MaxManipulate = v_uint8()
        self.Simulation = v_uint8()
        self.Unused = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self.KernBase = v_uint64()
        self.PsLoadedModuleList = v_uint64()
        self.DebuggerDataList = v_uint64()


class KTIMER_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TimerExpiry = vstruct.VArray([ v_ptr32() for i in xrange(16) ])
        self.TimerEntries = vstruct.VArray([ KTIMER_TABLE_ENTRY() for i in xrange(256) ])


class _unnamed_28441(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.idxRecord = v_uint32()
        self.cidContainer = v_uint32()


class FAST_IO_DISPATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFastIoDispatch = v_uint32()
        self.FastIoCheckIfPossible = v_ptr32()
        self.FastIoRead = v_ptr32()
        self.FastIoWrite = v_ptr32()
        self.FastIoQueryBasicInfo = v_ptr32()
        self.FastIoQueryStandardInfo = v_ptr32()
        self.FastIoLock = v_ptr32()
        self.FastIoUnlockSingle = v_ptr32()
        self.FastIoUnlockAll = v_ptr32()
        self.FastIoUnlockAllByKey = v_ptr32()
        self.FastIoDeviceControl = v_ptr32()
        self.AcquireFileForNtCreateSection = v_ptr32()
        self.ReleaseFileForNtCreateSection = v_ptr32()
        self.FastIoDetachDevice = v_ptr32()
        self.FastIoQueryNetworkOpenInfo = v_ptr32()
        self.AcquireForModWrite = v_ptr32()
        self.MdlRead = v_ptr32()
        self.MdlReadComplete = v_ptr32()
        self.PrepareMdlWrite = v_ptr32()
        self.MdlWriteComplete = v_ptr32()
        self.FastIoReadCompressed = v_ptr32()
        self.FastIoWriteCompressed = v_ptr32()
        self.MdlReadCompleteCompressed = v_ptr32()
        self.MdlWriteCompleteCompressed = v_ptr32()
        self.FastIoQueryOpen = v_ptr32()
        self.ReleaseForModWrite = v_ptr32()
        self.AcquireForCcFlush = v_ptr32()
        self.ReleaseForCcFlush = v_ptr32()


class _unnamed_20837(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FsInformationClass = v_uint32()


class SLIST_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Alignment = v_uint64()


class CM_KEY_CONTROL_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RefCount = v_uint32()
        self.ExtFlags = v_uint32()
        self.DelayedDeref = v_uint32()
        self.KeyHash = CM_KEY_HASH()
        self.KcbPushlock = EX_PUSH_LOCK()
        self.Owner = v_ptr32()
        self.SlotHint = v_uint32()
        self.ParentKcb = v_ptr32()
        self.NameBlock = v_ptr32()
        self.CachedSecurity = v_ptr32()
        self.ValueCache = CACHED_CHILD_LIST()
        self.IndexHint = v_ptr32()
        self.KeyBodyListHead = LIST_ENTRY()
        self.KeyBodyArray = vstruct.VArray([ v_ptr32() for i in xrange(4) ])
        self.KcbLastWriteTime = LARGE_INTEGER()
        self.KcbMaxNameLen = v_uint16()
        self.KcbMaxValueNameLen = v_uint16()
        self.KcbMaxValueDataLen = v_uint32()
        self.KcbUserFlags = v_uint32()
        self.KCBUoWListHead = LIST_ENTRY()
        self.DelayQueueEntry = LIST_ENTRY()
        self.TransKCBOwner = v_ptr32()
        self.KCBLock = CM_INTENT_LOCK()
        self.KeyLock = CM_INTENT_LOCK()
        self.TransValueCache = CHILD_LIST()
        self.TransValueListOwner = v_ptr32()
        self.FullKCBName = v_ptr32()


class _unnamed_25361(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMid = v_uint8()
        self.Flags1 = v_uint8()
        self.Flags2 = v_uint8()
        self.BaseHi = v_uint8()


class RTL_DYNAMIC_HASH_TABLE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ChainHead = v_ptr32()
        self.PrevLinkage = v_ptr32()
        self.Signature = v_uint32()


class MMWSL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FirstFree = v_uint32()
        self.FirstDynamic = v_uint32()
        self.LastEntry = v_uint32()
        self.NextSlot = v_uint32()
        self.Wsle = v_ptr32()
        self.LowestPagableAddress = v_ptr32()
        self.LastInitializedWsle = v_uint32()
        self.NextAgingSlot = v_uint32()
        self.NumberOfCommittedPageTables = v_uint32()
        self.VadBitMapHint = v_uint32()
        self.NonDirectCount = v_uint32()
        self.LastVadBit = v_uint32()
        self.MaximumLastVadBit = v_uint32()
        self.LastAllocationSizeHint = v_uint32()
        self.LastAllocationSize = v_uint32()
        self.NonDirectHash = v_ptr32()
        self.HashTableStart = v_ptr32()
        self.HighestPermittedHashAddress = v_ptr32()
        self.UsedPageTableEntries = vstruct.VArray([ v_uint16() for i in xrange(768) ])
        self.CommittedPageTables = vstruct.VArray([ v_uint32() for i in xrange(24) ])


class KTMOBJECT_NAMESPACE_LINK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Links = RTL_BALANCED_LINKS()
        self.Expired = v_uint8()
        self._pad0014 = v_bytes(size=3)


class MI_IMAGE_SECURITY_REFERENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = IMAGE_SECURITY_CONTEXT()
        self.DynamicRelocations = v_ptr32()
        self.ReferenceCount = v_uint32()


class WHEA_MEMORY_ERROR_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ValidBits = WHEA_MEMORY_ERROR_SECTION_VALIDBITS()
        self.ErrorStatus = WHEA_ERROR_STATUS()
        self.PhysicalAddress = v_uint64()
        self.PhysicalAddressMask = v_uint64()
        self.Node = v_uint16()
        self.Card = v_uint16()
        self.Module = v_uint16()
        self.Bank = v_uint16()
        self.Device = v_uint16()
        self.Row = v_uint16()
        self.Column = v_uint16()
        self.BitPosition = v_uint16()
        self.RequesterId = v_uint64()
        self.ResponderId = v_uint64()
        self.TargetId = v_uint64()
        self.ErrorType = v_uint8()


class DBGKD_CONTINUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContinueStatus = v_uint32()


class PROC_IDLE_STATE_ACCOUNTING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalTime = v_uint64()
        self.IdleTransitions = v_uint32()
        self.FailedTransitions = v_uint32()
        self.InvalidBucketIndex = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.MinTime = v_uint64()
        self.MaxTime = v_uint64()
        self.IdleTimeBuckets = vstruct.VArray([ PROC_IDLE_STATE_BUCKET() for i in xrange(16) ])


class _unnamed_26667(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClassGuid = GUID()
        self.SymbolicLinkName = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0014 = v_bytes(size=2)


class _unnamed_21693(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReferenceCount = v_uint16()
        self.ShortFlags = v_uint16()


class CALL_HASH_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.CallersAddress = v_ptr32()
        self.CallersCaller = v_ptr32()
        self.CallCount = v_uint32()


class _unnamed_21937(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.KeepForever = v_uint32()


class _unnamed_21936(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoStatus = IO_STATUS_BLOCK()


class _unnamed_24149(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Initialized = v_uint32()


class KSPECIAL_REGISTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cr0 = v_uint32()
        self.Cr2 = v_uint32()
        self.Cr3 = v_uint32()
        self.Cr4 = v_uint32()
        self.KernelDr0 = v_uint32()
        self.KernelDr1 = v_uint32()
        self.KernelDr2 = v_uint32()
        self.KernelDr3 = v_uint32()
        self.KernelDr6 = v_uint32()
        self.KernelDr7 = v_uint32()
        self.Gdtr = DESCRIPTOR()
        self.Idtr = DESCRIPTOR()
        self.Tr = v_uint16()
        self.Ldtr = v_uint16()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(6) ])


class POWER_ACTION_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Action = v_uint32()
        self.Flags = v_uint32()
        self.EventCode = v_uint32()


class FLS_CALLBACK_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_22060(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mdl = MDL()
        self.Page = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class RTL_CRITICAL_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DebugInfo = v_ptr32()
        self.LockCount = v_uint32()
        self.RecursionCount = v_uint32()
        self.OwningThread = v_ptr32()
        self.LockSemaphore = v_ptr32()
        self.SpinCount = v_uint32()


class DBGKM_EXCEPTION64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionRecord = EXCEPTION_RECORD64()
        self.FirstChance = v_uint32()
        self._pad00a0 = v_bytes(size=4)


class ALPC_COMPLETION_PACKET_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint32()
        self.Size = v_uint32()
        self.ActiveCount = v_uint32()
        self.PendingNullCount = v_uint32()
        self.PendingCheckCompletionListCount = v_uint32()
        self.PendingDelete = v_uint32()
        self.FreeListHead = SINGLE_LIST_ENTRY()
        self.CompletionPort = v_ptr32()
        self.CompletionKey = v_ptr32()
        self.Entry = vstruct.VArray([ ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY() for i in xrange(1) ])


class XSAVE_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint16()
        self.StatusWord = v_uint16()
        self.TagWord = v_uint8()
        self.Reserved1 = v_uint8()
        self.ErrorOpcode = v_uint16()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint16()
        self.Reserved2 = v_uint16()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint16()
        self.Reserved3 = v_uint16()
        self.MxCsr = v_uint32()
        self.MxCsr_Mask = v_uint32()
        self.FloatRegisters = vstruct.VArray([ M128A() for i in xrange(8) ])
        self.XmmRegisters = vstruct.VArray([ M128A() for i in xrange(8) ])
        self.Reserved4 = vstruct.VArray([ v_uint8() for i in xrange(192) ])
        self.StackControl = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self.Cr0NpxState = v_uint32()


class KSYSTEM_TIME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.High1Time = v_uint32()
        self.High2Time = v_uint32()


class _unnamed_23511(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileOffset = LARGE_INTEGER()


class _unnamed_26409(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Alignment = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class FLOATING_SAVE_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint32()
        self.StatusWord = v_uint32()
        self.TagWord = v_uint32()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint32()
        self.RegisterArea = vstruct.VArray([ v_uint8() for i in xrange(80) ])
        self.Cr0NpxState = v_uint32()


class _unnamed_21960(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Balance = v_uint32()


class KQUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.EntryListHead = LIST_ENTRY()
        self.CurrentCount = v_uint32()
        self.MaximumCount = v_uint32()
        self.ThreadListHead = LIST_ENTRY()


class POOL_TRACKER_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Key = v_uint32()
        self.NonPagedAllocs = v_uint32()
        self.NonPagedFrees = v_uint32()
        self.NonPagedBytes = v_uint32()
        self.PagedAllocs = v_uint32()
        self.PagedFrees = v_uint32()
        self.PagedBytes = v_uint32()


class VF_TRACKER_STAMP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Thread = v_ptr32()
        self.Flags = v_uint8()
        self.OldIrql = v_uint8()
        self.NewIrql = v_uint8()
        self.Processor = v_uint8()


class ARC_DISK_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DiskSignatures = LIST_ENTRY()


class SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlArea = v_ptr32()
        self.TotalNumberOfPtes = v_uint32()
        self.SegmentFlags = SEGMENT_FLAGS()
        self.NumberOfCommittedPages = v_uint32()
        self.SizeOfSegment = v_uint64()
        self.ExtendInfo = v_ptr32()
        self.SegmentLock = EX_PUSH_LOCK()
        self.u1 = _unnamed_21824()
        self.u2 = _unnamed_21825()
        self.PrototypePte = v_ptr32()
        self.ThePtes = vstruct.VArray([ MMPTE() for i in xrange(1) ])


class LUID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Luid = LUID()
        self.Attributes = v_uint32()


class iobuf(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ptr = v_ptr32()
        self.cnt = v_uint32()
        self.base = v_ptr32()
        self.flag = v_uint32()
        self.file = v_uint32()
        self.charbuf = v_uint32()
        self.bufsiz = v_uint32()
        self.tmpfname = v_ptr32()


class PCW_CALLBACK_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AddCounter = PCW_COUNTER_INFORMATION()
        self._pad0020 = v_bytes(size=16)


class PCW_COUNTER_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint16()
        self.StructIndex = v_uint16()
        self.Offset = v_uint16()
        self.Size = v_uint16()


class FIRMWARE_INFORMATION_LOADER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FirmwareTypeEfi = v_uint32()
        self.u = _unnamed_21620()


class MMMOD_WRITER_MDL_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Links = LIST_ENTRY()
        self.u = _unnamed_21936()
        self.Irp = v_ptr32()
        self.u1 = _unnamed_21937()
        self.PagingFile = v_ptr32()
        self.File = v_ptr32()
        self.ControlArea = v_ptr32()
        self.FileResource = v_ptr32()
        self.WriteOffset = LARGE_INTEGER()
        self.IssueTime = LARGE_INTEGER()
        self.PointerMdl = v_ptr32()
        self.Mdl = MDL()
        self.Page = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self._pad0060 = v_bytes(size=4)


class CACHED_CHILD_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.ValueList = v_uint32()


class PCW_MASK_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CounterMask = v_uint64()
        self.InstanceMask = v_ptr32()
        self.InstanceId = v_uint32()
        self.CollectMultiple = v_uint8()
        self._pad0014 = v_bytes(size=3)
        self.Buffer = v_ptr32()
        self.CancelEvent = v_ptr32()
        self._pad0020 = v_bytes(size=4)


class KTHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.CycleTime = v_uint64()
        self.HighCycleTime = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.QuantumTarget = v_uint64()
        self.InitialStack = v_ptr32()
        self.StackLimit = v_ptr32()
        self.KernelStack = v_ptr32()
        self.ThreadLock = v_uint32()
        self.WaitRegister = KWAIT_STATUS_REGISTER()
        self.Running = v_uint8()
        self.Alerted = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.KernelStackResident = v_uint32()
        self.ApcState = KAPC_STATE()
        self.NextProcessor = v_uint32()
        self.DeferredProcessor = v_uint32()
        self.ApcQueueLock = v_uint32()
        self.ContextSwitches = v_uint32()
        self.State = v_uint8()
        self.NpxState = v_uint8()
        self.WaitIrql = v_uint8()
        self.WaitMode = v_uint8()
        self.WaitStatus = v_uint32()
        self.WaitBlockList = v_ptr32()
        self.WaitListEntry = LIST_ENTRY()
        self.Queue = v_ptr32()
        self.WaitTime = v_uint32()
        self.KernelApcDisable = v_uint16()
        self.SpecialApcDisable = v_uint16()
        self.Teb = v_ptr32()
        self._pad0090 = v_bytes(size=4)
        self.Timer = KTIMER()
        self.AutoAlignment = v_uint32()
        self.ServiceTable = v_ptr32()
        self.WaitBlock = vstruct.VArray([ KWAIT_BLOCK() for i in xrange(4) ])
        self.QueueListEntry = LIST_ENTRY()
        self.TrapFrame = v_ptr32()
        self.FirstArgument = v_ptr32()
        self.CallbackStack = v_ptr32()
        self.ApcStateIndex = v_uint8()
        self.BasePriority = v_uint8()
        self.PriorityDecrement = v_uint8()
        self.Preempted = v_uint8()
        self.AdjustReason = v_uint8()
        self.AdjustIncrement = v_uint8()
        self.PreviousMode = v_uint8()
        self.Saturation = v_uint8()
        self.SystemCallNumber = v_uint32()
        self.FreezeCount = v_uint32()
        self.UserAffinity = GROUP_AFFINITY()
        self.Process = v_ptr32()
        self.Affinity = GROUP_AFFINITY()
        self.IdealProcessor = v_uint32()
        self.UserIdealProcessor = v_uint32()
        self.ApcStatePointer = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self.SavedApcState = KAPC_STATE()
        self.SuspendCount = v_uint8()
        self.Spare1 = v_uint8()
        self.OtherPlatformFill = v_uint8()
        self._pad018c = v_bytes(size=1)
        self.Win32Thread = v_ptr32()
        self.StackBase = v_ptr32()
        self.SuspendApc = KAPC()
        self.UserTime = v_uint32()
        self.SuspendSemaphore = KSEMAPHORE()
        self.SListFaultCount = v_uint32()
        self.ThreadListEntry = LIST_ENTRY()
        self.MutantListHead = LIST_ENTRY()
        self.SListFaultAddress = v_ptr32()
        self.ThreadCounters = v_ptr32()
        self.XStateSave = v_ptr32()
        self._pad0200 = v_bytes(size=4)


class WMI_TRACE_PACKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.HookId = v_uint16()


class ALPC_PORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PortListEntry = LIST_ENTRY()
        self.CommunicationInfo = v_ptr32()
        self.OwnerProcess = v_ptr32()
        self.CompletionPort = v_ptr32()
        self.CompletionKey = v_ptr32()
        self.CompletionPacketLookaside = v_ptr32()
        self.PortContext = v_ptr32()
        self.StaticSecurity = SECURITY_CLIENT_CONTEXT()
        self.MainQueue = LIST_ENTRY()
        self.PendingQueue = LIST_ENTRY()
        self.LargeMessageQueue = LIST_ENTRY()
        self.WaitQueue = LIST_ENTRY()
        self.Semaphore = v_ptr32()
        self.PortAttributes = ALPC_PORT_ATTRIBUTES()
        self.Lock = EX_PUSH_LOCK()
        self.ResourceListLock = EX_PUSH_LOCK()
        self.ResourceListHead = LIST_ENTRY()
        self.CompletionList = v_ptr32()
        self.MessageZone = v_ptr32()
        self.CallbackObject = v_ptr32()
        self.CallbackContext = v_ptr32()
        self.CanceledQueue = LIST_ENTRY()
        self.SequenceNo = v_uint32()
        self.u1 = _unnamed_24041()
        self.TargetQueuePort = v_ptr32()
        self.TargetSequencePort = v_ptr32()
        self.CachedMessage = v_ptr32()
        self.MainQueueLength = v_uint32()
        self.PendingQueueLength = v_uint32()
        self.LargeMessageQueueLength = v_uint32()
        self.CanceledQueueLength = v_uint32()
        self.WaitQueueLength = v_uint32()


class ADAPTER_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class PCAT_FIRMWARE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PlaceHolder = v_uint32()


class XSAVE_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LegacyState = XSAVE_FORMAT()
        self.Header = XSAVE_AREA_HEADER()


class CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFlags = v_uint32()
        self.Dr0 = v_uint32()
        self.Dr1 = v_uint32()
        self.Dr2 = v_uint32()
        self.Dr3 = v_uint32()
        self.Dr6 = v_uint32()
        self.Dr7 = v_uint32()
        self.FloatSave = FLOATING_SAVE_AREA()
        self.SegGs = v_uint32()
        self.SegFs = v_uint32()
        self.SegEs = v_uint32()
        self.SegDs = v_uint32()
        self.Edi = v_uint32()
        self.Esi = v_uint32()
        self.Ebx = v_uint32()
        self.Edx = v_uint32()
        self.Ecx = v_uint32()
        self.Eax = v_uint32()
        self.Ebp = v_uint32()
        self.Eip = v_uint32()
        self.SegCs = v_uint32()
        self.EFlags = v_uint32()
        self.Esp = v_uint32()
        self.SegSs = v_uint32()
        self.ExtendedRegisters = vstruct.VArray([ v_uint8() for i in xrange(512) ])


class MMSUBSECTION_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u = _unnamed_22031()
        self.StartingSector = v_uint32()
        self.NumberOfFullSectors = v_uint32()
        self.u1 = _unnamed_22047()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()


class LOADER_PERFORMANCE_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartTime = v_uint64()
        self.EndTime = v_uint64()


class VF_TARGET_DRIVER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TreeNode = VF_AVL_TREE_NODE()
        self.u1 = _unnamed_26603()
        self.VerifiedData = v_ptr32()


class _unnamed_21948(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Balance = v_uint32()


class _unnamed_21037(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemContext = v_uint32()
        self.Type = v_uint32()
        self.State = POWER_STATE()
        self.ShutdownType = v_uint32()


class DBGKD_GET_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Unused = v_uint32()


class VACB_LEVEL_ALLOCATION_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VacbLevelList = LIST_ENTRY()
        self.VacbLevelWithBcbListHeads = v_ptr32()
        self.VacbLevelsAllocated = v_uint32()


class KTRANSACTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutcomeEvent = KEVENT()
        self.cookie = v_uint32()
        self.Mutex = KMUTANT()
        self.TreeTx = v_ptr32()
        self.GlobalNamespaceLink = KTMOBJECT_NAMESPACE_LINK()
        self.TmNamespaceLink = KTMOBJECT_NAMESPACE_LINK()
        self.UOW = GUID()
        self.State = v_uint32()
        self.Flags = v_uint32()
        self.EnlistmentHead = LIST_ENTRY()
        self.EnlistmentCount = v_uint32()
        self.RecoverableEnlistmentCount = v_uint32()
        self.PrePrepareRequiredEnlistmentCount = v_uint32()
        self.PrepareRequiredEnlistmentCount = v_uint32()
        self.OutcomeRequiredEnlistmentCount = v_uint32()
        self.PendingResponses = v_uint32()
        self.SuperiorEnlistment = v_ptr32()
        self._pad00a0 = v_bytes(size=4)
        self.LastLsn = CLS_LSN()
        self.PromotedEntry = LIST_ENTRY()
        self.PromoterTransaction = v_ptr32()
        self.PromotePropagation = v_ptr32()
        self.IsolationLevel = v_uint32()
        self.IsolationFlags = v_uint32()
        self.Timeout = LARGE_INTEGER()
        self.Description = UNICODE_STRING()
        self.RollbackThread = v_ptr32()
        self.RollbackWorkItem = WORK_QUEUE_ITEM()
        self.RollbackDpc = KDPC()
        self._pad0108 = v_bytes(size=4)
        self.RollbackTimer = KTIMER()
        self.LsnOrderedEntry = LIST_ENTRY()
        self.Outcome = v_uint32()
        self.Tm = v_ptr32()
        self.CommitReservation = v_uint64()
        self.TransactionHistory = vstruct.VArray([ KTRANSACTION_HISTORY() for i in xrange(10) ])
        self.TransactionHistoryCount = v_uint32()
        self.DTCPrivateInformation = v_ptr32()
        self.DTCPrivateInformationLength = v_uint32()
        self.DTCPrivateInformationMutex = KMUTANT()
        self.PromotedTxSelfHandle = v_ptr32()
        self.PendingPromotionCount = v_uint32()
        self.PromotionCompletedEvent = KEVENT()
        self._pad01e0 = v_bytes(size=4)


class TRACE_ENABLE_CONTEXT_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LoggerId = v_uint16()
        self.Level = v_uint8()
        self.InternalFlag = v_uint8()
        self.EnableFlags = v_uint32()
        self.EnableFlagsHigh = v_uint32()
        self.Reserved = v_uint32()


class KALPC_MESSAGE_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientContext = v_ptr32()
        self.ServerContext = v_ptr32()
        self.PortContext = v_ptr32()
        self.CancelPortContext = v_ptr32()
        self.SecurityData = v_ptr32()
        self.View = v_ptr32()
        self.HandleData = v_ptr32()


class PROC_PERF_LOAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BusyPercentage = v_uint8()
        self.FrequencyPercentage = v_uint8()


class AUX_ACCESS_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegesUsed = v_ptr32()
        self.GenericMapping = GENERIC_MAPPING()
        self.AccessesToAudit = v_uint32()
        self.MaximumAuditMask = v_uint32()
        self.TransactionId = GUID()
        self.NewSecurityDescriptor = v_ptr32()
        self.ExistingSecurityDescriptor = v_ptr32()
        self.ParentSecurityDescriptor = v_ptr32()
        self.DeRefSecurityDescriptor = v_ptr32()
        self.SDLock = v_ptr32()
        self.AccessReasons = ACCESS_REASONS()


class _unnamed_26912(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class _unnamed_24061(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24064()


class _unnamed_21010(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerSequence = v_ptr32()


class IO_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.Descriptors = vstruct.VArray([ IO_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class _unnamed_24064(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Secure = v_uint32()


class _unnamed_20948(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Capabilities = v_ptr32()


class _unnamed_20600(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MasterIrp = v_ptr32()


class _unnamed_20606(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Overlay = _unnamed_20679()
        self._pad0030 = v_bytes(size=8)


class OBJECT_HEADER_HANDLE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleCountDataBase = v_ptr32()
        self._pad0008 = v_bytes(size=4)


class ETW_LOGGER_HANDLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DereferenceAndLeave = v_uint8()


class IMAGE_ROM_OPTIONAL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint16()
        self.MajorLinkerVersion = v_uint8()
        self.MinorLinkerVersion = v_uint8()
        self.SizeOfCode = v_uint32()
        self.SizeOfInitializedData = v_uint32()
        self.SizeOfUninitializedData = v_uint32()
        self.AddressOfEntryPoint = v_uint32()
        self.BaseOfCode = v_uint32()
        self.BaseOfData = v_uint32()
        self.BaseOfBss = v_uint32()
        self.GprMask = v_uint32()
        self.CprMask = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.GpValue = v_uint32()


class HEAP_FREE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Flags = v_uint8()
        self.SmallTagIndex = v_uint8()
        self.PreviousSize = v_uint16()
        self.SegmentOffset = v_uint8()
        self.UnusedBytes = v_uint8()
        self.FreeList = LIST_ENTRY()


class POOL_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PoolType = v_uint32()
        self.PagedLock = KGUARDED_MUTEX()
        self._pad0040 = v_bytes(size=28)
        self.RunningAllocs = v_uint32()
        self.RunningDeAllocs = v_uint32()
        self.TotalBigPages = v_uint32()
        self.ThreadsProcessingDeferrals = v_uint32()
        self.TotalBytes = v_uint32()
        self._pad0080 = v_bytes(size=44)
        self.PoolIndex = v_uint32()
        self._pad00c0 = v_bytes(size=60)
        self.TotalPages = v_uint32()
        self._pad0100 = v_bytes(size=60)
        self.PendingFrees = v_ptr32()
        self.PendingFreeDepth = v_uint32()
        self._pad0140 = v_bytes(size=56)
        self.ListHeads = vstruct.VArray([ LIST_ENTRY() for i in xrange(512) ])


class OBJECT_REF_STACK_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Sequence = v_uint32()
        self.Index = v_uint16()
        self.NumTraces = v_uint16()
        self.Tag = v_uint32()


class PF_KERNEL_GLOBALS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AccessBufferAgeThreshold = v_uint64()
        self.AccessBufferRef = EX_RUNDOWN_REF()
        self.AccessBufferExistsEvent = KEVENT()
        self.AccessBufferMax = v_uint32()
        self.AccessBufferList = SLIST_HEADER()
        self.StreamSequenceNumber = v_uint32()
        self.Flags = v_uint32()
        self.ScenarioPrefetchCount = v_uint32()
        self._pad0040 = v_bytes(size=12)


class GDI_TEB_BATCH64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.HDC = v_uint64()
        self.Buffer = vstruct.VArray([ v_uint32() for i in xrange(310) ])


class STACK_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumStackTraces = v_uint16()
        self.TraceCapacity = v_uint16()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(16) ])
        self.StackTableHash = vstruct.VArray([ v_uint16() for i in xrange(16381) ])
        self._pad8040 = v_bytes(size=2)


class DBGKD_READ_MEMORY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TargetBaseAddress = v_uint64()
        self.TransferCount = v_uint32()
        self.ActualBytesRead = v_uint32()


class MI_SYSTEM_PTE_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Bitmap = RTL_BITMAP()
        self.Flags = v_uint32()
        self.Hint = v_uint32()
        self.BasePte = v_ptr32()
        self.FailureCount = v_ptr32()
        self.Vm = v_ptr32()
        self.TotalSystemPtes = v_uint32()
        self.TotalFreeSystemPtes = v_uint32()
        self.CachedPteCount = v_uint32()
        self.PteFailures = v_uint32()
        self.SpinLock = v_uint32()


class _unnamed_22047(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Balance = v_uint32()


class PO_MEMORY_IMAGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.ImageType = v_uint32()
        self.CheckSum = v_uint32()
        self.LengthSelf = v_uint32()
        self.PageSelf = v_uint32()
        self.PageSize = v_uint32()
        self.SystemTime = LARGE_INTEGER()
        self.InterruptTime = v_uint64()
        self.FeatureFlags = v_uint32()
        self.HiberFlags = v_uint8()
        self.spare = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.NoHiberPtes = v_uint32()
        self.HiberVa = v_uint32()
        self.HiberPte = LARGE_INTEGER()
        self.NoFreePages = v_uint32()
        self.FreeMapCheck = v_uint32()
        self.WakeCheck = v_uint32()
        self.FirstTablePage = v_uint32()
        self.PerfInfo = PO_HIBER_PERF()
        self.FirmwareRuntimeInformationPages = v_uint32()
        self.FirmwareRuntimeInformation = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.NoBootLoaderLogPages = v_uint32()
        self.BootLoaderLogPages = vstruct.VArray([ v_uint32() for i in xrange(8) ])
        self.NotUsed = v_uint32()
        self.ResumeContextCheck = v_uint32()
        self.ResumeContextPages = v_uint32()


class ETHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Tcb = KTHREAD()
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self.ExitStatus = v_uint32()
        self.PostBlockList = LIST_ENTRY()
        self.TerminationPort = v_ptr32()
        self.ActiveTimerListLock = v_uint32()
        self.ActiveTimerListHead = LIST_ENTRY()
        self.Cid = CLIENT_ID()
        self.KeyedWaitSemaphore = KSEMAPHORE()
        self.ClientSecurity = PS_CLIENT_SECURITY_CONTEXT()
        self.IrpList = LIST_ENTRY()
        self.TopLevelIrp = v_uint32()
        self.DeviceToVerify = v_ptr32()
        self.CpuQuotaApc = v_ptr32()
        self.Win32StartAddress = v_ptr32()
        self.LegacyPowerObject = v_ptr32()
        self.ThreadListEntry = LIST_ENTRY()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.ThreadLock = EX_PUSH_LOCK()
        self.ReadClusterSize = v_uint32()
        self.MmLockOrdering = v_uint32()
        self.CrossThreadFlags = v_uint32()
        self.SameThreadPassiveFlags = v_uint32()
        self.SameThreadApcFlags = v_uint32()
        self.CacheManagerActive = v_uint8()
        self.DisablePageFaultClustering = v_uint8()
        self.ActiveFaultCount = v_uint8()
        self.LockOrderState = v_uint8()
        self.AlpcMessageId = v_uint32()
        self.AlpcMessage = v_ptr32()
        self.AlpcWaitListEntry = LIST_ENTRY()
        self.CacheManagerCount = v_uint32()
        self.IoBoostCount = v_uint32()
        self.IrpListLock = v_uint32()
        self.ReservedForSynchTracking = v_ptr32()
        self.CmCallbackListHead = SINGLE_LIST_ENTRY()
        self._pad02b8 = v_bytes(size=4)


class EVENT_DATA_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Ptr = v_uint64()
        self.Size = v_uint32()
        self.Reserved = v_uint32()


class WHEA_ERROR_RECORD_HEADER_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Recovered = v_uint32()


class HHIVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.GetCellRoutine = v_ptr32()
        self.ReleaseCellRoutine = v_ptr32()
        self.Allocate = v_ptr32()
        self.Free = v_ptr32()
        self.FileSetSize = v_ptr32()
        self.FileWrite = v_ptr32()
        self.FileRead = v_ptr32()
        self.FileFlush = v_ptr32()
        self.HiveLoadFailure = v_ptr32()
        self.BaseBlock = v_ptr32()
        self.DirtyVector = RTL_BITMAP()
        self.DirtyCount = v_uint32()
        self.DirtyAlloc = v_uint32()
        self.BaseBlockAlloc = v_uint32()
        self.Cluster = v_uint32()
        self.Flat = v_uint8()
        self.ReadOnly = v_uint8()
        self.DirtyFlag = v_uint8()
        self._pad0048 = v_bytes(size=1)
        self.HvBinHeadersUse = v_uint32()
        self.HvFreeCellsUse = v_uint32()
        self.HvUsedCellsUse = v_uint32()
        self.CmUsedCellsUse = v_uint32()
        self.HiveFlags = v_uint32()
        self.CurrentLog = v_uint32()
        self.LogSize = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.RefreshCount = v_uint32()
        self.StorageTypeCount = v_uint32()
        self.Version = v_uint32()
        self.Storage = vstruct.VArray([ DUAL() for i in xrange(2) ])


class VF_AVL_TREE_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.p = v_ptr32()
        self.RangeSize = v_uint32()


class IO_DRIVER_CREATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self._pad0004 = v_bytes(size=2)
        self.ExtraCreateParameter = v_ptr32()
        self.DeviceObjectHint = v_ptr32()
        self.TxnParameters = v_ptr32()


class CLIENT_ID64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_uint64()
        self.UniqueThread = v_uint64()


class IA64_LOADER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PlaceHolder = v_uint32()


class OBJECT_SYMBOLIC_LINK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LinkTarget = UNICODE_STRING()
        self.DosDeviceDriveIndex = v_uint32()
        self._pad0018 = v_bytes(size=4)


class TEB64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB64()
        self.EnvironmentPointer = v_uint64()
        self.ClientId = CLIENT_ID64()
        self.ActiveRpcHandle = v_uint64()
        self.ThreadLocalStoragePointer = v_uint64()
        self.ProcessEnvironmentBlock = v_uint64()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_uint64()
        self.Win32ThreadInfo = v_uint64()
        self.User32Reserved = vstruct.VArray([ v_uint32() for i in xrange(26) ])
        self.UserReserved = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self._pad0100 = v_bytes(size=4)
        self.WOW32Reserved = v_uint64()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()
        self.SystemReserved1 = vstruct.VArray([ v_uint64() for i in xrange(54) ])
        self.ExceptionCode = v_uint32()
        self._pad02c8 = v_bytes(size=4)
        self.ActivationContextStackPointer = v_uint64()
        self.SpareBytes = vstruct.VArray([ v_uint8() for i in xrange(24) ])
        self.TxFsContext = v_uint32()
        self._pad02f0 = v_bytes(size=4)
        self.GdiTebBatch = GDI_TEB_BATCH64()
        self.RealClientId = CLIENT_ID64()
        self.GdiCachedProcessHandle = v_uint64()
        self.GdiClientPID = v_uint32()
        self.GdiClientTID = v_uint32()
        self.GdiThreadLocalInfo = v_uint64()
        self.Win32ClientInfo = vstruct.VArray([ v_uint64() for i in xrange(62) ])
        self.glDispatchTable = vstruct.VArray([ v_uint64() for i in xrange(233) ])
        self.glReserved1 = vstruct.VArray([ v_uint64() for i in xrange(29) ])
        self.glReserved2 = v_uint64()
        self.glSectionInfo = v_uint64()
        self.glSection = v_uint64()
        self.glTable = v_uint64()
        self.glCurrentRC = v_uint64()
        self.glContext = v_uint64()
        self.LastStatusValue = v_uint32()
        self._pad1258 = v_bytes(size=4)
        self.StaticUnicodeString = STRING64()
        self.StaticUnicodeBuffer = vstruct.VArray([ v_uint16() for i in xrange(261) ])
        self._pad1478 = v_bytes(size=6)
        self.DeallocationStack = v_uint64()
        self.TlsSlots = vstruct.VArray([ v_uint64() for i in xrange(64) ])
        self.TlsLinks = LIST_ENTRY64()
        self.Vdm = v_uint64()
        self.ReservedForNtRpc = v_uint64()
        self.DbgSsReserved = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.HardErrorMode = v_uint32()
        self._pad16b8 = v_bytes(size=4)
        self.Instrumentation = vstruct.VArray([ v_uint64() for i in xrange(11) ])
        self.ActivityId = GUID()
        self.SubProcessTag = v_uint64()
        self.EtwLocalData = v_uint64()
        self.EtwTraceData = v_uint64()
        self.WinSockData = v_uint64()
        self.GdiBatchCount = v_uint32()
        self.CurrentIdealProcessor = PROCESSOR_NUMBER()
        self.GuaranteedStackBytes = v_uint32()
        self._pad1750 = v_bytes(size=4)
        self.ReservedForPerf = v_uint64()
        self.ReservedForOle = v_uint64()
        self.WaitingOnLoaderLock = v_uint32()
        self._pad1768 = v_bytes(size=4)
        self.SavedPriorityState = v_uint64()
        self.SoftPatchPtr1 = v_uint64()
        self.ThreadPoolData = v_uint64()
        self.TlsExpansionSlots = v_uint64()
        self.DeallocationBStore = v_uint64()
        self.BStoreLimit = v_uint64()
        self.MuiGeneration = v_uint32()
        self.IsImpersonating = v_uint32()
        self.NlsCache = v_uint64()
        self.pShimData = v_uint64()
        self.HeapVirtualAffinity = v_uint32()
        self._pad17b8 = v_bytes(size=4)
        self.CurrentTransactionHandle = v_uint64()
        self.ActiveFrame = v_uint64()
        self.FlsData = v_uint64()
        self.PreferredLanguages = v_uint64()
        self.UserPrefLanguages = v_uint64()
        self.MergedPrefLanguages = v_uint64()
        self.MuiImpersonation = v_uint32()
        self.CrossTebFlags = v_uint16()
        self.SameTebFlags = v_uint16()
        self.TxnScopeEnterCallback = v_uint64()
        self.TxnScopeExitCallback = v_uint64()
        self.TxnScopeContext = v_uint64()
        self.LockCount = v_uint32()
        self.SpareUlong0 = v_uint32()
        self.ResourceRetValue = v_uint64()


class EJOB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Event = KEVENT()
        self.JobLinks = LIST_ENTRY()
        self.ProcessListHead = LIST_ENTRY()
        self.JobLock = ERESOURCE()
        self.TotalUserTime = LARGE_INTEGER()
        self.TotalKernelTime = LARGE_INTEGER()
        self.ThisPeriodTotalUserTime = LARGE_INTEGER()
        self.ThisPeriodTotalKernelTime = LARGE_INTEGER()
        self.TotalPageFaultCount = v_uint32()
        self.TotalProcesses = v_uint32()
        self.ActiveProcesses = v_uint32()
        self.TotalTerminatedProcesses = v_uint32()
        self.PerProcessUserTimeLimit = LARGE_INTEGER()
        self.PerJobUserTimeLimit = LARGE_INTEGER()
        self.MinimumWorkingSetSize = v_uint32()
        self.MaximumWorkingSetSize = v_uint32()
        self.LimitFlags = v_uint32()
        self.ActiveProcessLimit = v_uint32()
        self.Affinity = KAFFINITY_EX()
        self.PriorityClass = v_uint8()
        self._pad00b8 = v_bytes(size=3)
        self.AccessState = v_ptr32()
        self.UIRestrictionsClass = v_uint32()
        self.EndOfJobTimeAction = v_uint32()
        self.CompletionPort = v_ptr32()
        self.CompletionKey = v_ptr32()
        self.SessionId = v_uint32()
        self.SchedulingClass = v_uint32()
        self._pad00d8 = v_bytes(size=4)
        self.ReadOperationCount = v_uint64()
        self.WriteOperationCount = v_uint64()
        self.OtherOperationCount = v_uint64()
        self.ReadTransferCount = v_uint64()
        self.WriteTransferCount = v_uint64()
        self.OtherTransferCount = v_uint64()
        self.ProcessMemoryLimit = v_uint32()
        self.JobMemoryLimit = v_uint32()
        self.PeakProcessMemoryUsed = v_uint32()
        self.PeakJobMemoryUsed = v_uint32()
        self.CurrentJobMemoryUsed = v_uint64()
        self.MemoryLimitsLock = EX_PUSH_LOCK()
        self.JobSetLinks = LIST_ENTRY()
        self.MemberLevel = v_uint32()
        self.JobFlags = v_uint32()
        self._pad0138 = v_bytes(size=4)


class PROCESSOR_IDLESTATE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TimeCheck = v_uint32()
        self.DemotePercent = v_uint8()
        self.PromotePercent = v_uint8()
        self.Spare = vstruct.VArray([ v_uint8() for i in xrange(2) ])


class EFI_FIRMWARE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FirmwareVersion = v_uint32()
        self.VirtualEfiRuntimeServices = v_ptr32()
        self.SetVirtualAddressMapStatus = v_uint32()
        self.MissedMappingsCount = v_uint32()


class DBGKD_READ_WRITE_IO_EXTENDED64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.AddressSpace = v_uint32()
        self.IoAddress = v_uint64()
        self.DataValue = v_uint32()
        self._pad0020 = v_bytes(size=4)


class _unnamed_25280(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Banked = v_ptr32()


class IO_STATUS_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.Information = v_uint32()


class KPROCESSOR_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFrame = CONTEXT()
        self.SpecialRegisters = KSPECIAL_REGISTERS()


class KiIoAccessMap(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DirectionMap = vstruct.VArray([ v_uint8() for i in xrange(32) ])
        self.IoMap = vstruct.VArray([ v_uint8() for i in xrange(8196) ])


class KAPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.SpareByte0 = v_uint8()
        self.Size = v_uint8()
        self.SpareByte1 = v_uint8()
        self.SpareLong0 = v_uint32()
        self.Thread = v_ptr32()
        self.ApcListEntry = LIST_ENTRY()
        self.KernelRoutine = v_ptr32()
        self.RundownRoutine = v_ptr32()
        self.NormalRoutine = v_ptr32()
        self.NormalContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.ApcStateIndex = v_uint8()
        self.ApcMode = v_uint8()
        self.Inserted = v_uint8()
        self._pad0030 = v_bytes(size=1)


class ETW_BUFFER_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProcessorNumber = v_uint8()
        self.Alignment = v_uint8()
        self.LoggerId = v_uint16()


class POOL_TRACKER_BIG_PAGES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Va = v_ptr32()
        self.Key = v_uint32()
        self.PoolType = v_uint32()
        self.NumberOfBytes = v_uint32()


class SID_IDENTIFIER_AUTHORITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Value = vstruct.VArray([ v_uint8() for i in xrange(6) ])


class RTL_RANGE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = LIST_ENTRY()
        self.Flags = v_uint32()
        self.Count = v_uint32()
        self.Stamp = v_uint32()


class _unnamed_28293(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Active = v_uint32()


class _unnamed_25284(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = MMSECURE_FLAGS()


class DRIVER_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Flags = v_uint32()
        self.DriverStart = v_ptr32()
        self.DriverSize = v_uint32()
        self.DriverSection = v_ptr32()
        self.DriverExtension = v_ptr32()
        self.DriverName = UNICODE_STRING()
        self.HardwareDatabase = v_ptr32()
        self.FastIoDispatch = v_ptr32()
        self.DriverInit = v_ptr32()
        self.DriverStartIo = v_ptr32()
        self.DriverUnload = v_ptr32()
        self.MajorFunction = vstruct.VArray([ v_ptr32() for i in xrange(28) ])


class VI_POOL_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PageHeader = VI_POOL_PAGE_HEADER()
        self._pad0010 = v_bytes(size=4)


class ALPC_COMPLETION_PACKET_LOOKASIDE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = SINGLE_LIST_ENTRY()
        self.Packet = v_ptr32()
        self.Lookaside = v_ptr32()


class SHARED_CACHE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self.NodeByteSize = v_uint16()
        self.OpenCount = v_uint32()
        self.FileSize = LARGE_INTEGER()
        self.BcbList = LIST_ENTRY()
        self.SectionSize = LARGE_INTEGER()
        self.ValidDataLength = LARGE_INTEGER()
        self.ValidDataGoal = LARGE_INTEGER()
        self.InitialVacbs = vstruct.VArray([ v_ptr32() for i in xrange(4) ])
        self.Vacbs = v_ptr32()
        self.FileObjectFastRef = EX_FAST_REF()
        self.VacbLock = EX_PUSH_LOCK()
        self.DirtyPages = v_uint32()
        self.LoggedStreamLinks = LIST_ENTRY()
        self.SharedCacheMapLinks = LIST_ENTRY()
        self.Flags = v_uint32()
        self.Status = v_uint32()
        self.Mbcb = v_ptr32()
        self.Section = v_ptr32()
        self.CreateEvent = v_ptr32()
        self.WaitOnActiveCount = v_ptr32()
        self.PagesToWrite = v_uint32()
        self._pad0080 = v_bytes(size=4)
        self.BeyondLastFlush = v_uint64()
        self.Callbacks = v_ptr32()
        self.LazyWriteContext = v_ptr32()
        self.PrivateList = LIST_ENTRY()
        self.LogHandle = v_ptr32()
        self.FlushToLsnRoutine = v_ptr32()
        self.DirtyPageThreshold = v_uint32()
        self.LazyWritePassCount = v_uint32()
        self.UninitializeEvent = v_ptr32()
        self.BcbLock = KGUARDED_MUTEX()
        self._pad00d0 = v_bytes(size=4)
        self.LastUnmapBehindOffset = LARGE_INTEGER()
        self.Event = KEVENT()
        self.HighWaterMappingOffset = LARGE_INTEGER()
        self.PrivateCacheMap = PRIVATE_CACHE_MAP()
        self.WriteBehindWorkQueueEntry = v_ptr32()
        self.VolumeCacheMap = v_ptr32()
        self.ProcImagePathHash = v_uint32()
        self.WritesInProgress = v_uint32()


class MMPTE_PROTOTYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class REMOTE_PORT_VIEW(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.ViewSize = v_uint32()
        self.ViewBase = v_ptr32()


class IO_MINI_COMPLETION_PACKET_USER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.PacketType = v_uint32()
        self.KeyContext = v_ptr32()
        self.ApcContext = v_ptr32()
        self.IoStatus = v_uint32()
        self.IoStatusInformation = v_uint32()
        self.MiniPacketCallback = v_ptr32()
        self.Context = v_ptr32()
        self.Allocated = v_uint8()
        self._pad0028 = v_bytes(size=3)


class XSTATE_FEATURE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.Size = v_uint32()


class GDI_TEB_BATCH32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.HDC = v_uint32()
        self.Buffer = vstruct.VArray([ v_uint32() for i in xrange(310) ])


class LOADER_PARAMETER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OsMajorVersion = v_uint32()
        self.OsMinorVersion = v_uint32()
        self.Size = v_uint32()
        self.Reserved = v_uint32()
        self.LoadOrderListHead = LIST_ENTRY()
        self.MemoryDescriptorListHead = LIST_ENTRY()
        self.BootDriverListHead = LIST_ENTRY()
        self.KernelStack = v_uint32()
        self.Prcb = v_uint32()
        self.Process = v_uint32()
        self.Thread = v_uint32()
        self.RegistryLength = v_uint32()
        self.RegistryBase = v_ptr32()
        self.ConfigurationRoot = v_ptr32()
        self.ArcBootDeviceName = v_ptr32()
        self.ArcHalDeviceName = v_ptr32()
        self.NtBootPathName = v_ptr32()
        self.NtHalPathName = v_ptr32()
        self.LoadOptions = v_ptr32()
        self.NlsData = v_ptr32()
        self.ArcDiskInformation = v_ptr32()
        self.OemFontFile = v_ptr32()
        self.Extension = v_ptr32()
        self.u = _unnamed_21552()
        self.FirmwareInformation = FIRMWARE_INFORMATION_LOADER_BLOCK()


class KAFFINITY_ENUMERATION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Affinity = v_ptr32()
        self.CurrentMask = v_uint32()
        self.CurrentIndex = v_uint16()
        self._pad000c = v_bytes(size=2)


class MI_VERIFIER_POOL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VerifierPoolEntry = v_ptr32()


class WHEA_TIMESTAMP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Seconds = v_uint64()


class ACTIVATION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class MMBANKED_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BasePhysicalPage = v_uint32()
        self.BasedPte = v_ptr32()
        self.BankSize = v_uint32()
        self.BankShift = v_uint32()
        self.BankedRoutine = v_ptr32()
        self.Context = v_ptr32()
        self.CurrentMappedPte = v_ptr32()
        self.BankTemplate = vstruct.VArray([ MMPTE() for i in xrange(1) ])


class ETW_REF_CLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartTime = LARGE_INTEGER()
        self.StartPerfClock = LARGE_INTEGER()


class RTL_CRITICAL_SECTION_DEBUG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self.CriticalSection = v_ptr32()
        self.ProcessLocksList = LIST_ENTRY()
        self.EntryCount = v_uint32()
        self.ContentionCount = v_uint32()
        self.Flags = v_uint32()
        self.CreatorBackTraceIndexHigh = v_uint16()
        self.SpareUSHORT = v_uint16()


class _unnamed_18583(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class ARBITER_CONFLICT_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwningObject = v_ptr32()
        self._pad0008 = v_bytes(size=4)
        self.Start = v_uint64()
        self.End = v_uint64()


class KALPC_VIEW(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ViewListEntry = LIST_ENTRY()
        self.Region = v_ptr32()
        self.OwnerPort = v_ptr32()
        self.OwnerProcess = v_ptr32()
        self.Address = v_ptr32()
        self.Size = v_uint32()
        self.SecureViewHandle = v_ptr32()
        self.WriteAccessHandle = v_ptr32()
        self.u1 = _unnamed_24079()
        self.NumberOfOwnerMessages = v_uint32()
        self.ProcessViewListEntry = LIST_ENTRY()


class ETW_SESSION_PERF_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BufferMemoryPagedPool = v_uint32()
        self.BufferMemoryNonPagedPool = v_uint32()
        self.EventsLoggedCount = v_uint64()
        self.EventsLost = v_uint32()
        self.NumConsumers = v_uint32()


class _unnamed_20536(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InitialPrivilegeSet = INITIAL_PRIVILEGE_SET()


class MMVAD_FLAGS3(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreferredNode = v_uint32()


class MMVAD_FLAGS2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileOffset = v_uint32()


class ARBITER_BOOT_ALLOCATION_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ArbitrationList = v_ptr32()


class _unnamed_26689(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerSettingGuid = GUID()
        self.Flags = v_uint32()
        self.SessionId = v_uint32()
        self.DataLength = v_uint32()
        self.Data = vstruct.VArray([ v_uint8() for i in xrange(1) ])
        self._pad0020 = v_bytes(size=3)


class TOKEN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TokenSource = TOKEN_SOURCE()
        self.TokenId = LUID()
        self.AuthenticationId = LUID()
        self.ParentTokenId = LUID()
        self.ExpirationTime = LARGE_INTEGER()
        self.TokenLock = v_ptr32()
        self.ModifiedId = LUID()
        self._pad0040 = v_bytes(size=4)
        self.Privileges = SEP_TOKEN_PRIVILEGES()
        self.AuditPolicy = SEP_AUDIT_POLICY()
        self.SessionId = v_uint32()
        self.UserAndGroupCount = v_uint32()
        self.RestrictedSidCount = v_uint32()
        self.VariableLength = v_uint32()
        self.DynamicCharged = v_uint32()
        self.DynamicAvailable = v_uint32()
        self.DefaultOwnerIndex = v_uint32()
        self.UserAndGroups = v_ptr32()
        self.RestrictedSids = v_ptr32()
        self.PrimaryGroup = v_ptr32()
        self.DynamicPart = v_ptr32()
        self.DefaultDacl = v_ptr32()
        self.TokenType = v_uint32()
        self.ImpersonationLevel = v_uint32()
        self.TokenFlags = v_uint32()
        self.TokenInUse = v_uint8()
        self._pad00b4 = v_bytes(size=3)
        self.IntegrityLevelIndex = v_uint32()
        self.MandatoryPolicy = v_uint32()
        self.LogonSession = v_ptr32()
        self.OriginatingLogonSession = LUID()
        self.SidHash = SID_AND_ATTRIBUTES_HASH()
        self.RestrictedSidHash = SID_AND_ATTRIBUTES_HASH()
        self.pSecurityAttributes = v_ptr32()
        self.VariablePart = v_uint32()


class DISPATCHER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.TimerControlFlags = v_uint8()
        self.ThreadControlFlags = v_uint8()
        self.TimerMiscFlags = v_uint8()
        self.SignalState = v_uint32()
        self.WaitListHead = LIST_ENTRY()


class PROCESSOR_IDLESTATE_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint16()
        self.Flags = _unnamed_28060()
        self.PolicyCount = v_uint32()
        self.Policy = vstruct.VArray([ PROCESSOR_IDLESTATE_INFO() for i in xrange(3) ])


class _unnamed_23009(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextResourceDeviceNode = v_ptr32()


class _unnamed_23008(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LegacyDeviceNode = v_ptr32()


class _unnamed_26682(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VetoType = v_uint32()
        self.DeviceIdVetoNameBuffer = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0008 = v_bytes(size=2)


class DBGKD_READ_WRITE_IO64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoAddress = v_uint64()
        self.DataSize = v_uint32()
        self.DataValue = v_uint32()


class _unnamed_26687(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ParentId = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class ASSEMBLY_STORAGE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class PROCESSOR_POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleStates = v_ptr32()
        self._pad0008 = v_bytes(size=4)
        self.IdleTimeLast = v_uint64()
        self.IdleTimeTotal = v_uint64()
        self.IdleTimeEntry = v_uint64()
        self.IdleAccounting = v_ptr32()
        self.Hypervisor = v_uint32()
        self.PerfHistoryTotal = v_uint32()
        self.ThermalConstraint = v_uint8()
        self.PerfHistoryCount = v_uint8()
        self.PerfHistorySlot = v_uint8()
        self.Reserved = v_uint8()
        self.LastSysTime = v_uint32()
        self.WmiDispatchPtr = v_uint32()
        self.WmiInterfaceEnabled = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.FFHThrottleStateInfo = PPM_FFH_THROTTLE_STATE_INFO()
        self.PerfActionDpc = KDPC()
        self.PerfActionMask = v_uint32()
        self._pad0088 = v_bytes(size=4)
        self.IdleCheck = PROC_IDLE_SNAP()
        self.PerfCheck = PROC_IDLE_SNAP()
        self.Domain = v_ptr32()
        self.PerfConstraint = v_ptr32()
        self.Load = v_ptr32()
        self.PerfHistory = v_ptr32()
        self.Utility = v_uint32()
        self.OverUtilizedHistory = v_uint32()
        self.AffinityCount = v_uint32()
        self.AffinityHistory = v_uint32()


class TP_TASK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callbacks = v_ptr32()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()
        self._pad000c = v_bytes(size=3)
        self.PostGuard = TP_NBQ_GUARD()
        self.NBQNode = v_ptr32()


class _unnamed_20840(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self.InputBufferLength = v_uint32()
        self.FsControlCode = v_uint32()
        self.Type3InputBuffer = v_ptr32()


class SECURITY_CLIENT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityQos = SECURITY_QUALITY_OF_SERVICE()
        self.ClientToken = v_ptr32()
        self.DirectlyAccessClientToken = v_uint8()
        self.DirectAccessEffectiveOnly = v_uint8()
        self.ServerIsRemote = v_uint8()
        self._pad0014 = v_bytes(size=1)
        self.ClientTokenControl = TOKEN_CONTROL()


class _unnamed_26949(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PhysicalAddress = v_uint32()


class _unnamed_20845(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_ptr32()
        self.Key = v_uint32()
        self.ByteOffset = LARGE_INTEGER()


class DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pad = v_uint16()
        self.Limit = v_uint16()
        self.Base = v_uint32()


class DBGKD_MANIPULATE_STATE64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ApiNumber = v_uint32()
        self.ProcessorLevel = v_uint16()
        self.Processor = v_uint16()
        self.ReturnStatus = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.u = _unnamed_23285()


class LPCP_PORT_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NonPagedPortQueue = v_ptr32()
        self.Semaphore = v_ptr32()
        self.ReceiveHead = LIST_ENTRY()


class PHYSICAL_MEMORY_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumberOfRuns = v_uint32()
        self.NumberOfPages = v_uint32()
        self.Run = vstruct.VArray([ PHYSICAL_MEMORY_RUN() for i in xrange(1) ])


class MMWSLE_FREE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MustBeZero = v_uint32()


class CACHE_UNINITIALIZE_EVENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Event = KEVENT()


class JOB_ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class DEVICE_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Failed = v_uint32()


class MMSESSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemSpaceViewLock = KGUARDED_MUTEX()
        self.SystemSpaceViewLockPointer = v_ptr32()
        self.SystemSpaceViewTable = v_ptr32()
        self.SystemSpaceHashSize = v_uint32()
        self.SystemSpaceHashEntries = v_uint32()
        self.SystemSpaceHashKey = v_uint32()
        self.BitmapFailures = v_uint32()


class MSUBSECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlArea = v_ptr32()
        self.SubsectionBase = v_ptr32()
        self.NextSubsection = v_ptr32()
        self.PtesInSubsection = v_uint32()
        self.UnusedPtes = v_uint32()
        self.u = _unnamed_22031()
        self.StartingSector = v_uint32()
        self.NumberOfFullSectors = v_uint32()
        self.u1 = _unnamed_22047()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.DereferenceList = LIST_ENTRY()
        self.NumberOfMappedViews = v_uint32()


class KSTACK_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FnArea = FNSAVE_FORMAT()
        self._pad01e0 = v_bytes(size=372)
        self.StackControl = KERNEL_STACK_CONTROL()
        self.Cr0NpxState = v_uint32()
        self.Padding = vstruct.VArray([ v_uint32() for i in xrange(4) ])


class WHEA_ERROR_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = WHEA_ERROR_RECORD_HEADER()
        self.SectionDescriptor = vstruct.VArray([ WHEA_ERROR_RECORD_SECTION_DESCRIPTOR() for i in xrange(1) ])


class _unnamed_20962(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoResourceRequirementList = v_ptr32()


class CMHIVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Hive = HHIVE()
        self.FileHandles = vstruct.VArray([ v_ptr32() for i in xrange(6) ])
        self.NotifyList = LIST_ENTRY()
        self.HiveList = LIST_ENTRY()
        self.PreloadedHiveList = LIST_ENTRY()
        self.HiveRundown = EX_RUNDOWN_REF()
        self.ParseCacheEntries = LIST_ENTRY()
        self.KcbCacheTable = v_ptr32()
        self.KcbCacheTableSize = v_uint32()
        self.Identity = v_uint32()
        self.HiveLock = v_ptr32()
        self.ViewLock = EX_PUSH_LOCK()
        self.ViewLockOwner = v_ptr32()
        self.ViewLockLast = v_uint32()
        self.ViewUnLockLast = v_uint32()
        self.WriterLock = v_ptr32()
        self.FlusherLock = v_ptr32()
        self.FlushDirtyVector = RTL_BITMAP()
        self.FlushOffsetArray = v_ptr32()
        self.FlushOffsetArrayCount = v_uint32()
        self.FlushHiveTruncated = v_uint32()
        self.FlushLock2 = v_ptr32()
        self.SecurityLock = EX_PUSH_LOCK()
        self.MappedViewList = LIST_ENTRY()
        self.PinnedViewList = LIST_ENTRY()
        self.FlushedViewList = LIST_ENTRY()
        self.MappedViewCount = v_uint16()
        self.PinnedViewCount = v_uint16()
        self.UseCount = v_uint32()
        self.ViewsPerHive = v_uint32()
        self.FileObject = v_ptr32()
        self.LastShrinkHiveSize = v_uint32()
        self.ActualFileSize = LARGE_INTEGER()
        self.FileFullPath = UNICODE_STRING()
        self.FileUserName = UNICODE_STRING()
        self.HiveRootPath = UNICODE_STRING()
        self.SecurityCount = v_uint32()
        self.SecurityCacheSize = v_uint32()
        self.SecurityHitHint = v_uint32()
        self.SecurityCache = v_ptr32()
        self.SecurityHash = vstruct.VArray([ LIST_ENTRY() for i in xrange(64) ])
        self.UnloadEventCount = v_uint32()
        self.UnloadEventArray = v_ptr32()
        self.RootKcb = v_ptr32()
        self.Frozen = v_uint8()
        self._pad05d8 = v_bytes(size=3)
        self.UnloadWorkItem = v_ptr32()
        self.UnloadWorkItemHolder = CM_WORKITEM()
        self.GrowOnlyMode = v_uint8()
        self._pad05f4 = v_bytes(size=3)
        self.GrowOffset = v_uint32()
        self.KcbConvertListHead = LIST_ENTRY()
        self.KnodeConvertListHead = LIST_ENTRY()
        self.CellRemapArray = v_ptr32()
        self.Flags = v_uint32()
        self.TrustClassEntry = LIST_ENTRY()
        self.FlushCount = v_uint32()
        self.CmRm = v_ptr32()
        self.CmRmInitFailPoint = v_uint32()
        self.CmRmInitFailStatus = v_uint32()
        self.CreatorOwner = v_ptr32()
        self.RundownThread = v_ptr32()


class PS_PER_CPU_QUOTA_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SortedListEntry = LIST_ENTRY()
        self.IdleOnlyListHead = LIST_ENTRY()
        self.CycleBaseAllowance = v_uint64()
        self.CyclesRemaining = v_uint64()
        self.CurrentGeneration = v_uint32()
        self._pad0040 = v_bytes(size=28)


class POP_SHUTDOWN_BUG_CHECK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ThreadHandle = v_ptr32()
        self.ThreadId = v_ptr32()
        self.ProcessId = v_ptr32()
        self.Code = v_uint32()
        self.Parameter1 = v_uint32()
        self.Parameter2 = v_uint32()
        self.Parameter3 = v_uint32()
        self.Parameter4 = v_uint32()


class SECTION_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartingVa = v_ptr32()
        self.EndingVa = v_ptr32()
        self.Parent = v_ptr32()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.Segment = v_ptr32()


class PROC_PERF_CONSTRAINT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Prcb = v_ptr32()
        self.PerfContext = v_uint32()
        self.PercentageCap = v_uint32()
        self.ThermalCap = v_uint32()
        self.TargetFrequency = v_uint32()
        self.AcumulatedFullFrequency = v_uint32()
        self.AcumulatedZeroFrequency = v_uint32()
        self.FrequencyHistoryTotal = v_uint32()
        self.AverageFrequency = v_uint32()


class ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedResources = v_ptr32()


class LUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class _unnamed_21048(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedResources = v_ptr32()
        self.AllocatedResourcesTranslated = v_ptr32()


class OBJECT_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PointerCount = v_uint32()
        self.HandleCount = v_uint32()
        self.Lock = EX_PUSH_LOCK()
        self.TypeIndex = v_uint8()
        self.TraceFlags = v_uint8()
        self.InfoMask = v_uint8()
        self.Flags = v_uint8()
        self.ObjectCreateInfo = v_ptr32()
        self.SecurityDescriptor = v_ptr32()
        self.Body = QUAD()


class RTL_DYNAMIC_HASH_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Linkage = LIST_ENTRY()
        self.Signature = v_uint32()


class _unnamed_26354(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = _unnamed_26409()


class CM_KEY_SECURITY_CACHE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cell = v_uint32()
        self.CachedSecurity = v_ptr32()


class _unnamed_26359(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Generic = _unnamed_26888()


class _unnamed_26450(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length64 = v_uint32()
        self.Alignment64 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class OBJECT_DUMP_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Stream = v_ptr32()
        self.Detail = v_uint32()


class CACHE_MANAGER_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AcquireForLazyWrite = v_ptr32()
        self.ReleaseFromLazyWrite = v_ptr32()
        self.AcquireForReadAhead = v_ptr32()
        self.ReleaseFromReadAhead = v_ptr32()


class DBGKD_CONTINUE2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContinueStatus = v_uint32()
        self.ControlSet = X86_DBGKD_CONTROL_SET()
        self._pad0020 = v_bytes(size=12)


class _unnamed_26896(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.MessageCount = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint32()


class _unnamed_26891(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint16()
        self.Group = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint32()


class HANDLE_TRACE_DB_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientId = CLIENT_ID()
        self.Handle = v_ptr32()
        self.Type = v_uint32()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(16) ])


class PPC_DBGKD_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Continue = v_uint32()
        self.CurrentSymbolStart = v_uint32()
        self.CurrentSymbolEnd = v_uint32()


class MMADDRESS_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_21948()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.StartingVpn = v_uint32()
        self.EndingVpn = v_uint32()


class GENERAL_LOOKASIDE_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr32()
        self.FreeEx = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])


class ALPC_DISPATCH_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PortObject = v_ptr32()
        self.Message = v_ptr32()
        self.CommunicationInfo = v_ptr32()
        self.TargetThread = v_ptr32()
        self.TargetPort = v_ptr32()
        self.Flags = v_uint32()
        self.TotalLength = v_uint16()
        self.Type = v_uint16()
        self.DataInfoOffset = v_uint16()
        self._pad0020 = v_bytes(size=2)


class PNP_DEVICE_EVENT_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.Argument = v_uint32()
        self.CallerEvent = v_ptr32()
        self.Callback = v_ptr32()
        self.Context = v_ptr32()
        self.VetoType = v_ptr32()
        self.VetoName = v_ptr32()
        self.Data = PLUGPLAY_EVENT_BLOCK()


class _unnamed_21450(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Long = v_uint32()


class LPCP_NONPAGED_PORT_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Semaphore = KSEMAPHORE()
        self.BackPointer = v_ptr32()


class KTRANSACTION_HISTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RecordType = v_uint32()
        self.Payload = v_uint32()


class RTL_SRWLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint32()


class BATTERY_REPORTING_SCALE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Granularity = v_uint32()
        self.Capacity = v_uint32()


class MMPAGING_FILE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.MaximumSize = v_uint32()
        self.MinimumSize = v_uint32()
        self.FreeSpace = v_uint32()
        self.PeakUsage = v_uint32()
        self.HighestPage = v_uint32()
        self.File = v_ptr32()
        self.Entry = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self.PageFileName = UNICODE_STRING()
        self.Bitmap = v_ptr32()
        self.EvictStoreBitmap = v_ptr32()
        self.BitmapHint = v_uint32()
        self.LastAllocationSize = v_uint32()
        self.ToBeEvictedCount = v_uint32()
        self.PageFileNumber = v_uint16()
        self.AdriftMdls = v_uint16()
        self.FileHandle = v_ptr32()
        self.Lock = v_uint32()
        self.LockOwner = v_ptr32()


class SHARED_CACHE_MAP_LIST_CURSOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SharedCacheMapLinks = LIST_ENTRY()
        self.Flags = v_uint32()


class STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class SID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Sid = v_ptr32()
        self.Attributes = v_uint32()


class TP_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class FNSAVE_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint32()
        self.StatusWord = v_uint32()
        self.TagWord = v_uint32()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint32()
        self.RegisterArea = vstruct.VArray([ v_uint8() for i in xrange(80) ])


class _unnamed_28874(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mbr = _unnamed_28919()
        self._pad0010 = v_bytes(size=8)


class CMP_OFFSET_ARRAY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileOffset = v_uint32()
        self.DataBuffer = v_ptr32()
        self.DataLength = v_uint32()


class _unnamed_24081(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WriteAccess = v_uint32()


class KALPC_MESSAGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = LIST_ENTRY()
        self.ExtensionBuffer = v_ptr32()
        self.ExtensionBufferSize = v_uint32()
        self.QuotaProcess = v_ptr32()
        self.SequenceNo = v_uint32()
        self.u1 = _unnamed_24190()
        self.CancelSequencePort = v_ptr32()
        self.CancelQueuePort = v_ptr32()
        self.CancelSequenceNo = v_uint32()
        self.CancelListEntry = LIST_ENTRY()
        self.WaitingThread = v_ptr32()
        self.Reserve = v_ptr32()
        self.PortQueue = v_ptr32()
        self.OwnerPort = v_ptr32()
        self.MessageAttributes = KALPC_MESSAGE_ATTRIBUTES()
        self.DataUserVa = v_ptr32()
        self.DataSystemVa = v_ptr32()
        self.CommunicationInfo = v_ptr32()
        self.ConnectionPort = v_ptr32()
        self.ServerThread = v_ptr32()
        self.PortMessage = PORT_MESSAGE()


class VI_DEADLOCK_GLOBALS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TimeAcquire = v_uint64()
        self.TimeRelease = v_uint64()
        self.ResourceDatabase = v_ptr32()
        self.ResourceDatabaseCount = v_uint32()
        self.ResourceAddressRange = vstruct.VArray([ VF_ADDRESS_RANGE() for i in xrange(1023) ])
        self.ThreadDatabase = v_ptr32()
        self.ThreadDatabaseCount = v_uint32()
        self.ThreadAddressRange = vstruct.VArray([ VF_ADDRESS_RANGE() for i in xrange(1023) ])
        self.AllocationFailures = v_uint32()
        self.NodesTrimmedBasedOnAge = v_uint32()
        self.NodesTrimmedBasedOnCount = v_uint32()
        self.NodesSearched = v_uint32()
        self.MaxNodesSearched = v_uint32()
        self.SequenceNumber = v_uint32()
        self.RecursionDepthLimit = v_uint32()
        self.SearchedNodesLimit = v_uint32()
        self.DepthLimitHits = v_uint32()
        self.SearchLimitHits = v_uint32()
        self.ABC_ACB_Skipped = v_uint32()
        self.OutOfOrderReleases = v_uint32()
        self.NodesReleasedOutOfOrder = v_uint32()
        self.TotalReleases = v_uint32()
        self.RootNodesDeleted = v_uint32()
        self.ForgetHistoryCounter = v_uint32()
        self.Instigator = v_ptr32()
        self.NumberOfParticipants = v_uint32()
        self.Participant = vstruct.VArray([ v_ptr32() for i in xrange(32) ])
        self.ChildrenCountWatermark = v_uint32()
        self._pad40e0 = v_bytes(size=4)


class LIST_ENTRY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint32()
        self.Blink = v_uint32()


class MMWSLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_21762()


class SINGLE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()


class DBGKD_QUERY_MEMORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_uint64()
        self.Reserved = v_uint64()
        self.AddressSpace = v_uint32()
        self.Flags = v_uint32()


class MMVAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_21960()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.StartingVpn = v_uint32()
        self.EndingVpn = v_uint32()
        self.u = _unnamed_21963()
        self.PushLock = EX_PUSH_LOCK()
        self.u5 = _unnamed_21964()
        self.u2 = _unnamed_21980()
        self.Subsection = v_ptr32()
        self.FirstPrototypePte = v_ptr32()
        self.LastContiguousPte = v_ptr32()
        self.ViewLinks = LIST_ENTRY()
        self.VadsProcess = v_ptr32()


class _unnamed_26653(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = _unnamed_28098()


class VF_POOL_TRACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_ptr32()
        self.Size = v_uint32()
        self.Thread = v_ptr32()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(13) ])


class KDEVICE_QUEUE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceListEntry = LIST_ENTRY()
        self.SortKey = v_uint32()
        self.Inserted = v_uint8()
        self._pad0010 = v_bytes(size=3)


class MMPTE_SUBSECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class PO_DEVICE_NOTIFY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = LIST_ENTRY()
        self.PowerChildren = LIST_ENTRY()
        self.PowerParents = LIST_ENTRY()
        self.TargetDevice = v_ptr32()
        self.OrderLevel = v_uint8()
        self._pad0020 = v_bytes(size=3)
        self.DeviceObject = v_ptr32()
        self.DeviceName = v_ptr32()
        self.DriverName = v_ptr32()
        self.ChildCount = v_uint32()
        self.ActiveChild = v_uint32()
        self.ParentCount = v_uint32()
        self.ActiveParent = v_uint32()


class ALPC_HANDLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr32()


class HMAP_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Directory = vstruct.VArray([ v_ptr32() for i in xrange(1024) ])


class RTLP_RANGE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint64()
        self.End = v_uint64()
        self.Allocated = _unnamed_28048()
        self.Attributes = v_uint8()
        self.PublicFlags = v_uint8()
        self.PrivateFlags = v_uint16()
        self.ListEntry = LIST_ENTRY()
        self._pad0028 = v_bytes(size=4)


class TPM_BOOT_ENTROPY_LDR_RESULT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Policy = v_uint64()
        self.ResultCode = v_uint32()
        self.ResultStatus = v_uint32()
        self.Time = v_uint64()
        self.EntropyLength = v_uint32()
        self.EntropyData = vstruct.VArray([ v_uint8() for i in xrange(40) ])
        self._pad0048 = v_bytes(size=4)


class NBQUEUE_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SListEntry = SINGLE_LIST_ENTRY()
        self._pad0008 = v_bytes(size=4)
        self.Next = v_uint64()
        self.Data = v_uint64()


class KTMOBJECT_NAMESPACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Table = RTL_AVL_TABLE()
        self.Mutex = KMUTANT()
        self.LinksOffset = v_uint16()
        self.GuidOffset = v_uint16()
        self.Expired = v_uint8()
        self._pad0060 = v_bytes(size=3)


class PERFINFO_TRACE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Marker = v_uint32()
        self.Header = v_uint32()
        self.TS = v_uint64()
        self.Data = vstruct.VArray([ v_uint8() for i in xrange(1) ])
        self._pad0018 = v_bytes(size=7)


class OBJECT_HEADER_QUOTA_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PagedPoolCharge = v_uint32()
        self.NonPagedPoolCharge = v_uint32()
        self.SecurityDescriptorCharge = v_uint32()
        self.SecurityDescriptorQuotaBlock = v_ptr32()


class HEAP_STOP_ON_VALUES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocAddress = v_uint32()
        self.AllocTag = HEAP_STOP_ON_TAG()
        self.ReAllocAddress = v_uint32()
        self.ReAllocTag = HEAP_STOP_ON_TAG()
        self.FreeAddress = v_uint32()
        self.FreeTag = HEAP_STOP_ON_TAG()


class FS_FILTER_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AcquireForModifiedPageWriter = _unnamed_27530()
        self._pad0014 = v_bytes(size=12)


class DBGKD_READ_MEMORY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TargetBaseAddress = v_uint32()
        self.TransferCount = v_uint32()
        self.ActualBytesRead = v_uint32()


class RTL_HANDLE_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()


class ARBITER_ALTERNATIVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Minimum = v_uint64()
        self.Maximum = v_uint64()
        self.Length = v_uint64()
        self.Alignment = v_uint64()
        self.Priority = v_uint32()
        self.Flags = v_uint32()
        self.Descriptor = v_ptr32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])


class HEAP_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Counters = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self._pad0030 = v_bytes(size=4)


class EX_FAST_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr32()


class INTERLOCK_SEQ(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint16()
        self.FreeEntryOffset = v_uint16()
        self.Sequence = v_uint32()


class HMAP_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Table = vstruct.VArray([ HMAP_ENTRY() for i in xrange(512) ])


class PNP_RESOURCE_REQUEST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PhysicalDevice = v_ptr32()
        self.Flags = v_uint32()
        self.AllocationType = v_uint32()
        self.Priority = v_uint32()
        self.Position = v_uint32()
        self.ResourceRequirements = v_ptr32()
        self.ReqList = v_ptr32()
        self.ResourceAssignment = v_ptr32()
        self.TranslatedResourceAssignment = v_ptr32()
        self.Status = v_uint32()


class RTL_ACTIVATION_CONTEXT_STACK_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Previous = v_ptr32()
        self.ActivationContext = v_ptr32()
        self.Flags = v_uint32()


class FS_FILTER_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbacks = v_uint32()
        self.Reserved = v_uint32()
        self.PreAcquireForSectionSynchronization = v_ptr32()
        self.PostAcquireForSectionSynchronization = v_ptr32()
        self.PreReleaseForSectionSynchronization = v_ptr32()
        self.PostReleaseForSectionSynchronization = v_ptr32()
        self.PreAcquireForCcFlush = v_ptr32()
        self.PostAcquireForCcFlush = v_ptr32()
        self.PreReleaseForCcFlush = v_ptr32()
        self.PostReleaseForCcFlush = v_ptr32()
        self.PreAcquireForModifiedPageWriter = v_ptr32()
        self.PostAcquireForModifiedPageWriter = v_ptr32()
        self.PreReleaseForModifiedPageWriter = v_ptr32()
        self.PostReleaseForModifiedPageWriter = v_ptr32()


class MM_DRIVER_VERIFIER_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint32()
        self.RaiseIrqls = v_uint32()
        self.AcquireSpinLocks = v_uint32()
        self.SynchronizeExecutions = v_uint32()
        self.AllocationsAttempted = v_uint32()
        self.AllocationsSucceeded = v_uint32()
        self.AllocationsSucceededSpecialPool = v_uint32()
        self.AllocationsWithNoTag = v_uint32()
        self.TrimRequests = v_uint32()
        self.Trims = v_uint32()
        self.AllocationsFailed = v_uint32()
        self.AllocationsFailedDeliberately = v_uint32()
        self.Loads = v_uint32()
        self.Unloads = v_uint32()
        self.UnTrackedPool = v_uint32()
        self.UserTrims = v_uint32()
        self.CurrentPagedPoolAllocations = v_uint32()
        self.CurrentNonPagedPoolAllocations = v_uint32()
        self.PeakPagedPoolAllocations = v_uint32()
        self.PeakNonPagedPoolAllocations = v_uint32()
        self.PagedBytes = v_uint32()
        self.NonPagedBytes = v_uint32()
        self.PeakPagedBytes = v_uint32()
        self.PeakNonPagedBytes = v_uint32()
        self.BurstAllocationsFailedDeliberately = v_uint32()
        self.SessionTrims = v_uint32()
        self.OptionChanges = v_uint32()
        self.VerifyMode = v_uint32()
        self.PreviousBucketName = UNICODE_STRING()
        self.ActivityCounter = v_uint32()
        self.PreviousActivityCounter = v_uint32()
        self.WorkerTrimRequests = v_uint32()


class _unnamed_23915(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataLength = v_uint16()
        self.TotalLength = v_uint16()


class IO_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Option = v_uint8()
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Spare1 = v_uint8()
        self.Flags = v_uint16()
        self.Spare2 = v_uint16()
        self.u = _unnamed_26354()


class _unnamed_23913(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_23915()


class _unnamed_27808(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags = v_uint32()


class _unnamed_26685(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BlockedDriverGuid = GUID()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FRUId = v_uint8()


class IMAGE_OPTIONAL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint16()
        self.MajorLinkerVersion = v_uint8()
        self.MinorLinkerVersion = v_uint8()
        self.SizeOfCode = v_uint32()
        self.SizeOfInitializedData = v_uint32()
        self.SizeOfUninitializedData = v_uint32()
        self.AddressOfEntryPoint = v_uint32()
        self.BaseOfCode = v_uint32()
        self.BaseOfData = v_uint32()
        self.ImageBase = v_uint32()
        self.SectionAlignment = v_uint32()
        self.FileAlignment = v_uint32()
        self.MajorOperatingSystemVersion = v_uint16()
        self.MinorOperatingSystemVersion = v_uint16()
        self.MajorImageVersion = v_uint16()
        self.MinorImageVersion = v_uint16()
        self.MajorSubsystemVersion = v_uint16()
        self.MinorSubsystemVersion = v_uint16()
        self.Win32VersionValue = v_uint32()
        self.SizeOfImage = v_uint32()
        self.SizeOfHeaders = v_uint32()
        self.CheckSum = v_uint32()
        self.Subsystem = v_uint16()
        self.DllCharacteristics = v_uint16()
        self.SizeOfStackReserve = v_uint32()
        self.SizeOfStackCommit = v_uint32()
        self.SizeOfHeapReserve = v_uint32()
        self.SizeOfHeapCommit = v_uint32()
        self.LoaderFlags = v_uint32()
        self.NumberOfRvaAndSizes = v_uint32()
        self.DataDirectory = vstruct.VArray([ IMAGE_DATA_DIRECTORY() for i in xrange(16) ])


class SCSI_REQUEST_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class MMVAD_LONG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_21960()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.StartingVpn = v_uint32()
        self.EndingVpn = v_uint32()
        self.u = _unnamed_21963()
        self.PushLock = EX_PUSH_LOCK()
        self.u5 = _unnamed_21964()
        self.u2 = _unnamed_21980()
        self.Subsection = v_ptr32()
        self.FirstPrototypePte = v_ptr32()
        self.LastContiguousPte = v_ptr32()
        self.ViewLinks = LIST_ENTRY()
        self.VadsProcess = v_ptr32()
        self.u3 = _unnamed_25279()
        self.u4 = _unnamed_25280()


class ARBITER_ADD_RESERVED_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReserveDevice = v_ptr32()


class VF_ADDRESS_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_ptr32()
        self.End = v_ptr32()


class STRING64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self._pad0008 = v_bytes(size=4)
        self.Buffer = v_uint64()


class MBCB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self.NodeIsInZone = v_uint16()
        self.PagesToWrite = v_uint32()
        self.DirtyPages = v_uint32()
        self.Reserved = v_uint32()
        self.BitmapRanges = LIST_ENTRY()
        self.ResumeWritePage = v_uint64()
        self.MostRecentlyDirtiedPage = v_uint64()
        self.BitmapRange1 = BITMAP_RANGE()
        self.BitmapRange2 = BITMAP_RANGE()
        self.BitmapRange3 = BITMAP_RANGE()


class FAST_MUTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Owner = v_ptr32()
        self.Contention = v_uint32()
        self.Event = KEVENT()
        self.OldIrql = v_uint32()


class TRACE_ENABLE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IsEnabled = v_uint32()
        self.Level = v_uint8()
        self.Reserved1 = v_uint8()
        self.LoggerId = v_uint16()
        self.EnableProperty = v_uint32()
        self.Reserved2 = v_uint32()
        self.MatchAnyKeyword = v_uint64()
        self.MatchAllKeyword = v_uint64()


class VF_SUSPECT_DRIVER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Links = LIST_ENTRY()
        self.Loads = v_uint32()
        self.Unloads = v_uint32()
        self.BaseName = UNICODE_STRING()


class MM_SESSION_SPACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReferenceCount = v_uint32()
        self.u = _unnamed_27808()
        self.SessionId = v_uint32()
        self.ProcessReferenceToSession = v_uint32()
        self.ProcessList = LIST_ENTRY()
        self.LastProcessSwappedOutTime = LARGE_INTEGER()
        self.SessionPageDirectoryIndex = v_uint32()
        self.NonPagablePages = v_uint32()
        self.CommittedPages = v_uint32()
        self.PagedPoolStart = v_ptr32()
        self.PagedPoolEnd = v_ptr32()
        self.SessionObject = v_ptr32()
        self.SessionObjectHandle = v_ptr32()
        self.ResidentProcessCount = v_uint32()
        self.SessionPoolAllocationFailures = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.ImageList = LIST_ENTRY()
        self.LocaleId = v_uint32()
        self.AttachCount = v_uint32()
        self.AttachGate = KGATE()
        self.WsListEntry = LIST_ENTRY()
        self._pad0080 = v_bytes(size=8)
        self.Lookaside = vstruct.VArray([ GENERAL_LOOKASIDE() for i in xrange(25) ])
        self.Session = MMSESSION()
        self.PagedPoolInfo = MM_PAGED_POOL_INFO()
        self.Vm = MMSUPPORT()
        self.Wsle = v_ptr32()
        self.DriverUnload = v_ptr32()
        self._pad0e00 = v_bytes(size=28)
        self.PagedPool = POOL_DESCRIPTOR()
        self.PageTables = v_ptr32()
        self.SpecialPool = MI_SPECIAL_POOL()
        self.SessionPteLock = KGUARDED_MUTEX()
        self.PoolBigEntriesInUse = v_uint32()
        self.PagedPoolPdeCount = v_uint32()
        self.SpecialPoolPdeCount = v_uint32()
        self.DynamicSessionPdeCount = v_uint32()
        self.SystemPteInfo = MI_SYSTEM_PTE_TYPE()
        self.PoolTrackTableExpansion = v_ptr32()
        self.PoolTrackTableExpansionSize = v_uint32()
        self.PoolTrackBigPages = v_ptr32()
        self.PoolTrackBigPagesSize = v_uint32()
        self.IoState = v_uint32()
        self.IoStateSequence = v_uint32()
        self.IoNotificationEvent = KEVENT()
        self.SessionPoolPdes = RTL_BITMAP()
        self.CpuQuotaBlock = v_ptr32()
        self._pad2000 = v_bytes(size=4)


class WHEA_ERROR_RECORD_HEADER_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PlatformId = v_uint32()


class CM_NAME_CONTROL_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Compressed = v_uint8()
        self._pad0002 = v_bytes(size=1)
        self.RefCount = v_uint16()
        self.NameHash = CM_NAME_HASH()


class KDEVICE_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceListHead = LIST_ENTRY()
        self.Lock = v_uint32()
        self.Busy = v_uint8()
        self._pad0014 = v_bytes(size=3)


class ARBITER_RETEST_ALLOCATION_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ArbitrationList = v_ptr32()
        self.AllocateFromCount = v_uint32()
        self.AllocateFrom = v_ptr32()


class RTL_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint64()
        self.End = v_uint64()
        self.UserData = v_ptr32()
        self.Owner = v_ptr32()
        self.Attributes = v_uint8()
        self.Flags = v_uint8()
        self._pad0020 = v_bytes(size=6)


class _unnamed_20807(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileInformationClass = v_uint32()


class NT_TIB32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_uint32()
        self.StackBase = v_uint32()
        self.StackLimit = v_uint32()
        self.SubSystemTib = v_uint32()
        self.FiberData = v_uint32()
        self.ArbitraryUserPointer = v_uint32()
        self.Self = v_uint32()


class _unnamed_25070(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FilePointerIndex = v_uint32()


class PORT_MESSAGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_23913()
        self.u2 = _unnamed_23914()
        self.ClientId = CLIENT_ID()
        self.MessageId = v_uint32()
        self.ClientViewSize = v_uint32()


class RELATIVE_SYMLINK_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExposedNamespaceLength = v_uint16()
        self.Flags = v_uint16()
        self.DeviceNameLength = v_uint16()
        self.Reserved = v_uint16()
        self.InteriorMountPoint = v_ptr32()
        self.OpenedName = UNICODE_STRING()


class IO_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityQos = v_ptr32()
        self.AccessState = v_ptr32()
        self.DesiredAccess = v_uint32()
        self.FullCreateOptions = v_uint32()


class TERMINATION_PORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Port = v_ptr32()


class PROC_HISTORY_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Utility = v_uint16()
        self.Frequency = v_uint8()
        self.Reserved = v_uint8()


class VF_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RtlTable = RTL_AVL_TABLE()
        self.ReservedNode = v_ptr32()


class _unnamed_26679(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationCode = v_uint32()
        self.NotificationData = v_uint32()


class IO_CLIENT_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextExtension = v_ptr32()
        self.ClientIdentificationAddress = v_ptr32()


class INITIAL_PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(3) ])


class OBJECT_REF_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ObjectHeader = v_ptr32()
        self.NextRef = v_ptr32()
        self.ImageFileName = vstruct.VArray([ v_uint8() for i in xrange(16) ])
        self.NextPos = v_uint16()
        self.MaxStacks = v_uint16()
        self.StackInfo = vstruct.VArray([ OBJECT_REF_STACK_INFO() for i in xrange(0) ])


class _unnamed_26670(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceIds = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class DBGKD_QUERY_SPECIAL_CALLS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumberOfSpecialCalls = v_uint32()


class _unnamed_26672(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceId = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class CM_RM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RmListEntry = LIST_ENTRY()
        self.TransactionListHead = LIST_ENTRY()
        self.TmHandle = v_ptr32()
        self.Tm = v_ptr32()
        self.RmHandle = v_ptr32()
        self.KtmRm = v_ptr32()
        self.RefCount = v_uint32()
        self.ContainerNum = v_uint32()
        self.ContainerSize = v_uint64()
        self.CmHive = v_ptr32()
        self.LogFileObject = v_ptr32()
        self.MarshallingContext = v_ptr32()
        self.RmFlags = v_uint32()
        self.LogStartStatus1 = v_uint32()
        self.LogStartStatus2 = v_uint32()
        self.BaseLsn = v_uint64()
        self.RmLock = v_ptr32()
        self._pad0058 = v_bytes(size=4)


class _unnamed_26674(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationStructure = v_ptr32()
        self.DeviceIds = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0008 = v_bytes(size=2)


class _unnamed_26677(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Notification = v_ptr32()


class KTIMER_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint32()
        self.Entry = LIST_ENTRY()
        self._pad0010 = v_bytes(size=4)
        self.Time = ULARGE_INTEGER()


class _unnamed_26394(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u = _unnamed_26388()


class SMBIOS_TABLE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_26391(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Last = v_uint32()
        self.u = _unnamed_26388()


class HMAP_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BlockAddress = v_uint32()
        self.BinAddress = v_uint32()
        self.CmView = v_ptr32()
        self.MemAlloc = v_uint32()


class DUMP_STACK_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Init = DUMP_INITIALIZATION_CONTEXT()
        self.PartitionOffset = LARGE_INTEGER()
        self.DumpPointers = v_ptr32()
        self.PointersLength = v_uint32()
        self.ModulePrefix = v_ptr32()
        self.DriverList = LIST_ENTRY()
        self.InitMsg = STRING()
        self.ProgMsg = STRING()
        self.DoneMsg = STRING()
        self.FileObject = v_ptr32()
        self.UsageType = v_uint32()
        self._pad00b0 = v_bytes(size=4)


class _unnamed_21825(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImageInformation = v_ptr32()


class _unnamed_21824(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImageCommitment = v_uint32()


class KWAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitListEntry = LIST_ENTRY()
        self.Thread = v_ptr32()
        self.Object = v_ptr32()
        self.NextWaitBlock = v_ptr32()
        self.WaitKey = v_uint16()
        self.WaitType = v_uint8()
        self.BlockState = v_uint8()


class DBGKD_READ_WRITE_IO32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.IoAddress = v_uint32()
        self.DataValue = v_uint32()


class POP_HIBER_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WriteToFile = v_uint8()
        self.ReserveLoaderMemory = v_uint8()
        self.ReserveFreeMemory = v_uint8()
        self.Reset = v_uint8()
        self.HiberFlags = v_uint8()
        self.WroteHiberFile = v_uint8()
        self.MapFrozen = v_uint8()
        self._pad0008 = v_bytes(size=1)
        self.MemoryMap = RTL_BITMAP()
        self.DiscardedMemoryPages = RTL_BITMAP()
        self.ClonedRanges = LIST_ENTRY()
        self.ClonedRangeCount = v_uint32()
        self.NextCloneRange = v_ptr32()
        self.NextPreserve = v_uint32()
        self.LoaderMdl = v_ptr32()
        self.AllocatedMdl = v_ptr32()
        self._pad0038 = v_bytes(size=4)
        self.PagesOut = v_uint64()
        self.IoPages = v_ptr32()
        self.IoPagesCount = v_uint32()
        self.CurrentMcb = v_ptr32()
        self.DumpStack = v_ptr32()
        self.WakeState = v_ptr32()
        self.PreferredIoWriteSize = v_uint32()
        self.IoProgress = v_uint32()
        self.HiberVa = v_uint32()
        self.HiberPte = LARGE_INTEGER()
        self.Status = v_uint32()
        self.MemoryImage = v_ptr32()
        self.CompressionWorkspace = v_ptr32()
        self.CompressedWriteBuffer = v_ptr32()
        self.CompressedWriteBufferSize = v_uint32()
        self.MaxCompressedOutputSize = v_uint32()
        self.PerformanceStats = v_ptr32()
        self.CompressionBlock = v_ptr32()
        self.DmaIO = v_ptr32()
        self.TemporaryHeap = v_ptr32()
        self.BootLoaderLogMdl = v_ptr32()
        self.FirmwareRuntimeInformationMdl = v_ptr32()
        self.ResumeContext = v_ptr32()
        self.ResumeContextPages = v_uint32()


class RTL_HANDLE_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MaximumNumberOfHandles = v_uint32()
        self.SizeOfHandleTableEntry = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.FreeHandles = v_ptr32()
        self.CommittedHandles = v_ptr32()
        self.UnCommittedHandles = v_ptr32()
        self.MaxReservedHandles = v_ptr32()


class _unnamed_26419(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumVector = v_uint32()
        self.MaximumVector = v_uint32()
        self.AffinityPolicy = v_uint16()
        self.Group = v_uint16()
        self.PriorityPolicy = v_uint32()
        self.TargetedProcessors = v_uint32()


class TOKEN_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TokenId = LUID()
        self.AuthenticationId = LUID()
        self.ModifiedId = LUID()
        self.TokenSource = TOKEN_SOURCE()


class ETW_SYSTEMTIME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Year = v_uint16()
        self.Month = v_uint16()
        self.DayOfWeek = v_uint16()
        self.Day = v_uint16()
        self.Hour = v_uint16()
        self.Minute = v_uint16()
        self.Second = v_uint16()
        self.Milliseconds = v_uint16()


class FILE_NETWORK_OPEN_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0038 = v_bytes(size=4)


class PROCESSOR_NUMBER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.Number = v_uint8()
        self.Reserved = v_uint8()


class HEAP_USERDATA_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SFreeListEntry = SINGLE_LIST_ENTRY()
        self.Reserved = v_ptr32()
        self.SizeIndex = v_uint32()
        self.Signature = v_uint32()


class RTL_DRIVE_LETTER_CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint16()
        self.Length = v_uint16()
        self.TimeStamp = v_uint32()
        self.DosPath = STRING()


class VF_TRACKER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TrackerFlags = v_uint32()
        self.TrackerSize = v_uint32()
        self.TrackerIndex = v_uint32()
        self.TraceDepth = v_uint32()


class CACHE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint8()
        self.Associativity = v_uint8()
        self.LineSize = v_uint16()
        self.Size = v_uint32()
        self.Type = v_uint32()


class VF_BTS_DATA_MANAGEMENT_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BTSBufferBase = v_ptr32()
        self.BTSIndex = v_ptr32()
        self.BTSMax = v_ptr32()
        self.BTSInterruptThreshold = v_ptr32()
        self.PEBSBufferBase = v_ptr32()
        self.PEBSIndex = v_ptr32()
        self.PEBSMax = v_ptr32()
        self.PEBSInterruptThreshold = v_ptr32()
        self.PEBSCounterReset = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(12) ])


class ARBITER_QUERY_ARBITRATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ArbitrationList = v_ptr32()


class DBGKD_BREAKPOINTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakPointCount = v_uint32()
        self.ContinueStatus = v_uint32()


class GENERAL_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr32()
        self.FreeEx = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self._pad0080 = v_bytes(size=56)


class TEB_ACTIVE_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.Previous = v_ptr32()
        self.Context = v_ptr32()


class ETIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.KeTimer = KTIMER()
        self.TimerApc = KAPC()
        self.TimerDpc = KDPC()
        self.ActiveTimerListEntry = LIST_ENTRY()
        self.Lock = v_uint32()
        self.Period = v_uint32()
        self.ApcAssociated = v_uint8()
        self._pad008c = v_bytes(size=3)
        self.WakeReason = v_ptr32()
        self.WakeTimerListEntry = LIST_ENTRY()


class DBGKD_LOAD_SYMBOLS64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PathNameLength = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.BaseOfDll = v_uint64()
        self.ProcessId = v_uint64()
        self.CheckSum = v_uint32()
        self.SizeOfImage = v_uint32()
        self.UnloadSymbols = v_uint8()
        self._pad0028 = v_bytes(size=7)


class FREE_DISPLAY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RealVectorSize = v_uint32()
        self.Display = RTL_BITMAP()


class WORK_QUEUE_ITEM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.List = LIST_ENTRY()
        self.WorkerRoutine = v_ptr32()
        self.Parameter = v_ptr32()


class MM_PAGE_ACCESS_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = MM_PAGE_ACCESS_INFO_FLAGS()
        self.PointerProtoPte = v_ptr32()


class ARBITER_ORDERING_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint16()
        self.Maximum = v_uint16()
        self.Orderings = v_ptr32()


class OBJECT_DIRECTORY_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ChainLink = v_ptr32()
        self.Object = v_ptr32()
        self.HashValue = v_uint32()


class FXSAVE_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint16()
        self.StatusWord = v_uint16()
        self.TagWord = v_uint16()
        self.ErrorOpcode = v_uint16()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint32()
        self.MXCsr = v_uint32()
        self.MXCsrMask = v_uint32()
        self.RegisterArea = vstruct.VArray([ v_uint8() for i in xrange(128) ])
        self.Reserved3 = vstruct.VArray([ v_uint8() for i in xrange(128) ])
        self.Reserved4 = vstruct.VArray([ v_uint8() for i in xrange(192) ])


class KTMNOTIFICATION_PACKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ARBITER_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.AlternativeCount = v_uint32()
        self.Alternatives = v_ptr32()
        self.PhysicalDeviceObject = v_ptr32()
        self.RequestSource = v_uint32()
        self.Flags = v_uint32()
        self.WorkSpace = v_uint32()
        self.InterfaceType = v_uint32()
        self.SlotNumber = v_uint32()
        self.BusNumber = v_uint32()
        self.Assignment = v_ptr32()
        self.SelectedAlternative = v_ptr32()
        self.Result = v_uint32()


class KWAIT_STATUS_REGISTER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint8()


class _unnamed_23578(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reason = v_uint32()


class KGDTENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LimitLow = v_uint16()
        self.BaseLow = v_uint16()
        self.HighWord = _unnamed_19407()


class NAMED_PIPE_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NamedPipeType = v_uint32()
        self.ReadMode = v_uint32()
        self.CompletionMode = v_uint32()
        self.MaximumInstances = v_uint32()
        self.InboundQuota = v_uint32()
        self.OutboundQuota = v_uint32()
        self.DefaultTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0028 = v_bytes(size=7)


class _unnamed_23574(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SharedCacheMap = v_ptr32()


class _unnamed_23576(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Event = v_ptr32()


class NT_TIB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_ptr32()
        self.StackBase = v_ptr32()
        self.StackLimit = v_ptr32()
        self.SubSystemTib = v_ptr32()
        self.FiberData = v_ptr32()
        self.ArbitraryUserPointer = v_ptr32()
        self.Self = v_ptr32()


class _unnamed_28060(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsUSHORT = v_uint16()


class _unnamed_23572(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileObject = v_ptr32()


class _unnamed_24079(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24081()


class _unnamed_25366(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMid = v_uint32()


class _unnamed_26904(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Channel = v_uint32()
        self.Port = v_uint32()
        self.Reserved1 = v_uint32()


class ARBITER_TEST_ALLOCATION_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ArbitrationList = v_ptr32()
        self.AllocateFromCount = v_uint32()
        self.AllocateFrom = v_ptr32()


class ULARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class UNICODE_STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class CELL_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u = u()


class SECURITY_QUALITY_OF_SERVICE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.ImpersonationLevel = v_uint32()
        self.ContextTrackingMode = v_uint8()
        self.EffectiveOnly = v_uint8()
        self._pad000c = v_bytes(size=2)


class HEAP_LIST_LOOKUP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExtendedLookup = v_ptr32()
        self.ArraySize = v_uint32()
        self.ExtraItem = v_uint32()
        self.ItemCount = v_uint32()
        self.OutOfRangeItems = v_uint32()
        self.BaseIndex = v_uint32()
        self.ListHead = v_ptr32()
        self.ListsInUseUlong = v_ptr32()
        self.ListHints = v_ptr32()


class _unnamed_21004(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerState = v_uint32()


class _unnamed_20970(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint8()


class _unnamed_20200(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self._pad0028 = v_bytes(size=32)


class COMPRESSED_DATA_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CompressionFormatAndEngine = v_uint16()
        self.CompressionUnitShift = v_uint8()
        self.ChunkShift = v_uint8()
        self.ClusterShift = v_uint8()
        self.Reserved = v_uint8()
        self.NumberOfChunks = v_uint16()
        self.CompressedChunkSizes = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class LOADER_PARAMETER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.Profile = PROFILE_PARAMETER_BLOCK()
        self.EmInfFileImage = v_ptr32()
        self.EmInfFileSize = v_uint32()
        self.TriageDumpBlock = v_ptr32()
        self.LoaderPagesSpanned = v_uint32()
        self.HeadlessLoaderBlock = v_ptr32()
        self.SMBiosEPSHeader = v_ptr32()
        self.DrvDBImage = v_ptr32()
        self.DrvDBSize = v_uint32()
        self.NetworkLoaderBlock = v_ptr32()
        self.HalpIRQLToTPR = v_ptr32()
        self.HalpVectorToIRQL = v_ptr32()
        self.FirmwareDescriptorListHead = LIST_ENTRY()
        self.AcpiTable = v_ptr32()
        self.AcpiTableSize = v_uint32()
        self.LastBootSucceeded = v_uint32()
        self.LoaderPerformanceData = v_ptr32()
        self.BootApplicationPersistentData = LIST_ENTRY()
        self.WmdTestResult = v_ptr32()
        self.BootIdentifier = GUID()
        self.ResumePages = v_uint32()
        self.DumpHeader = v_ptr32()
        self.BgContext = v_ptr32()
        self.NumaLocalityInfo = v_ptr32()
        self.NumaGroupAssignment = v_ptr32()
        self.AttachedHives = LIST_ENTRY()
        self.MemoryCachingRequirementsCount = v_uint32()
        self.MemoryCachingRequirements = v_ptr32()
        self.TpmBootEntropyResult = TPM_BOOT_ENTROPY_LDR_RESULT()
        self.ProcessorCounterFrequency = v_uint64()


class _unnamed_20979(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdType = v_uint32()


class EPROCESS_QUOTA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class CM_KEY_HASH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ConvKey = v_uint32()
        self.NextHash = v_ptr32()
        self.KeyHive = v_ptr32()
        self.KeyCell = v_uint32()


class _unnamed_22491(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OldCell = _unnamed_26391()


class FILE_SEGMENT_ELEMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Buffer = v_ptr64()


class HEAP_DEBUGGING_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterceptorFunction = v_ptr32()
        self.InterceptorValue = v_uint16()
        self._pad0008 = v_bytes(size=2)
        self.ExtendedOptions = v_uint32()
        self.StackTraceDepth = v_uint32()
        self.MinTotalBlockSize = v_uint32()
        self.MaxTotalBlockSize = v_uint32()
        self.HeapLeakEnumerationRoutine = v_ptr32()


class PENDING_RELATIONS_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = LIST_ENTRY()
        self.WorkItem = WORK_QUEUE_ITEM()
        self.DeviceEvent = v_ptr32()
        self.DeviceObject = v_ptr32()
        self.RelationsList = v_ptr32()
        self.EjectIrp = v_ptr32()
        self.Lock = v_uint32()
        self.Problem = v_uint32()
        self.ProfileChangingEject = v_uint8()
        self.DisplaySafeRemovalDialog = v_uint8()
        self._pad0034 = v_bytes(size=2)
        self.LightestSleepState = v_uint32()
        self.DockInterface = v_ptr32()


class OBJECT_HEADER_NAME_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Directory = v_ptr32()
        self.Name = UNICODE_STRING()
        self.ReferenceCount = v_uint32()


class ACCESS_REASONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(32) ])


class CM_KCB_UOW(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TransactionListEntry = LIST_ENTRY()
        self.KCBLock = v_ptr32()
        self.KeyLock = v_ptr32()
        self.KCBListEntry = LIST_ENTRY()
        self.KeyControlBlock = v_ptr32()
        self.Transaction = v_ptr32()
        self.UoWState = v_uint32()
        self.ActionType = v_uint32()
        self.StorageType = v_uint32()
        self._pad0030 = v_bytes(size=4)
        self.ChildKCB = v_ptr32()
        self.NewValueCell = v_uint32()


class MMVAD_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CommitCharge = v_uint32()


class MMSUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkingSetMutex = EX_PUSH_LOCK()
        self.ExitGate = v_ptr32()
        self.AccessLog = v_ptr32()
        self.WorkingSetExpansionLinks = LIST_ENTRY()
        self.AgeDistribution = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self.MinimumWorkingSetSize = v_uint32()
        self.WorkingSetSize = v_uint32()
        self.WorkingSetPrivateSize = v_uint32()
        self.MaximumWorkingSetSize = v_uint32()
        self.ChargedWslePages = v_uint32()
        self.ActualWslePages = v_uint32()
        self.WorkingSetSizeOverhead = v_uint32()
        self.PeakWorkingSetSize = v_uint32()
        self.HardFaultCount = v_uint32()
        self.VmWorkingSetList = v_ptr32()
        self.NextPageColor = v_uint16()
        self.LastTrimStamp = v_uint16()
        self.PageFaultCount = v_uint32()
        self.RepurposeCount = v_uint32()
        self.Spare = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.Flags = MMSUPPORT_FLAGS()


class HBASE_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Sequence1 = v_uint32()
        self.Sequence2 = v_uint32()
        self.TimeStamp = LARGE_INTEGER()
        self.Major = v_uint32()
        self.Minor = v_uint32()
        self.Type = v_uint32()
        self.Format = v_uint32()
        self.RootCell = v_uint32()
        self.Length = v_uint32()
        self.Cluster = v_uint32()
        self.FileName = vstruct.VArray([ v_uint8() for i in xrange(64) ])
        self.RmId = GUID()
        self.LogId = GUID()
        self.Flags = v_uint32()
        self.TmId = GUID()
        self.GuidSignature = v_uint32()
        self.Reserved1 = vstruct.VArray([ v_uint32() for i in xrange(85) ])
        self.CheckSum = v_uint32()
        self.Reserved2 = vstruct.VArray([ v_uint32() for i in xrange(882) ])
        self.ThawTmId = GUID()
        self.ThawRmId = GUID()
        self.ThawLogId = GUID()
        self.BootType = v_uint32()
        self.BootRecover = v_uint32()


class _unnamed_23705(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CriticalSection = RTL_CRITICAL_SECTION()


class BUS_EXTENSION_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.BusExtension = v_ptr32()


class I386_LOADER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CommonDataArea = v_ptr32()
        self.MachineType = v_uint32()
        self.VirtualBias = v_uint32()


class DBGKD_GET_SET_BUS_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BusDataType = v_uint32()
        self.BusNumber = v_uint32()
        self.SlotNumber = v_uint32()
        self.Offset = v_uint32()
        self.Length = v_uint32()


class KDPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.Importance = v_uint8()
        self.Number = v_uint16()
        self.DpcListEntry = LIST_ENTRY()
        self.DeferredRoutine = v_ptr32()
        self.DeferredContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.DpcData = v_ptr32()


class _unnamed_19407(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Bytes = _unnamed_25361()


class _unnamed_21670(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PteFrame = v_uint32()


class PCW_REGISTRATION_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint32()
        self.Name = v_ptr32()
        self.CounterCount = v_uint32()
        self.Counters = v_ptr32()
        self.Callback = v_ptr32()
        self.CallbackContext = v_ptr32()


class KEVENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class KRESOURCEMANAGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationAvailable = KEVENT()
        self.cookie = v_uint32()
        self.State = v_uint32()
        self.Flags = v_uint32()
        self.Mutex = KMUTANT()
        self.NamespaceLink = KTMOBJECT_NAMESPACE_LINK()
        self.RmId = GUID()
        self.NotificationQueue = KQUEUE()
        self.NotificationMutex = KMUTANT()
        self.EnlistmentHead = LIST_ENTRY()
        self.EnlistmentCount = v_uint32()
        self.NotificationRoutine = v_ptr32()
        self.Key = v_ptr32()
        self.ProtocolListHead = LIST_ENTRY()
        self.PendingPropReqListHead = LIST_ENTRY()
        self.CRMListEntry = LIST_ENTRY()
        self.Tm = v_ptr32()
        self.Description = UNICODE_STRING()
        self.Enlistments = KTMOBJECT_NAMESPACE()
        self.CompletionBinding = KRESOURCEMANAGER_COMPLETION_BINDING()


class KSEMAPHORE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.Limit = v_uint32()


class MM_PAGE_ACCESS_INFO_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = SINGLE_LIST_ENTRY()
        self.Type = v_uint32()
        self.EmptySequenceNumber = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.CreateTime = v_uint64()
        self.EmptyTime = v_uint64()
        self.PageEntry = v_ptr32()
        self.FileEntry = v_ptr32()
        self.FirstFileEntry = v_ptr32()
        self.Process = v_ptr32()
        self.SessionId = v_uint32()
        self._pad0038 = v_bytes(size=4)


class _unnamed_26603(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllSharedExportThunks = VF_TARGET_ALL_SHARED_EXPORT_THUNKS()


class IMAGE_DEBUG_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Characteristics = v_uint32()
        self.TimeDateStamp = v_uint32()
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.Type = v_uint32()
        self.SizeOfData = v_uint32()
        self.AddressOfRawData = v_uint32()
        self.PointerToRawData = v_uint32()


class CONFIGURATION_COMPONENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Class = v_uint32()
        self.Type = v_uint32()
        self.Flags = DEVICE_FLAGS()
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Key = v_uint32()
        self.AffinityMask = v_uint32()
        self.ConfigurationDataLength = v_uint32()
        self.IdentifierLength = v_uint32()
        self.Identifier = v_ptr32()


class WHEA_PERSISTENCE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint64()


class CM_INTENT_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerCount = v_uint32()
        self.OwnerTable = v_ptr32()


class LAZY_WRITER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ScanDpc = KDPC()
        self.ScanTimer = KTIMER()
        self.ScanActive = v_uint8()
        self.OtherWork = v_uint8()
        self.PendingTeardownScan = v_uint8()
        self.PendingPeriodicScan = v_uint8()
        self.PendingLowMemoryScan = v_uint8()
        self.PendingPowerScan = v_uint8()
        self._pad0050 = v_bytes(size=2)


class KALPC_SECURITY_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleTable = v_ptr32()
        self.ContextHandle = v_ptr32()
        self.OwningProcess = v_ptr32()
        self.OwnerPort = v_ptr32()
        self.DynamicSecurity = SECURITY_CLIENT_CONTEXT()
        self.u1 = _unnamed_24294()


class VIRTUAL_EFI_RUNTIME_SERVICES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GetTime = v_uint32()
        self.SetTime = v_uint32()
        self.GetWakeupTime = v_uint32()
        self.SetWakeupTime = v_uint32()
        self.SetVirtualAddressMap = v_uint32()
        self.ConvertPointer = v_uint32()
        self.GetVariable = v_uint32()
        self.GetNextVariableName = v_uint32()
        self.SetVariable = v_uint32()
        self.GetNextHighMonotonicCount = v_uint32()
        self.ResetSystem = v_uint32()
        self.UpdateCapsule = v_uint32()
        self.QueryCapsuleCapabilities = v_uint32()
        self.QueryVariableInfo = v_uint32()


class RELATION_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.MaxCount = v_uint32()
        self.Devices = vstruct.VArray([ v_ptr32() for i in xrange(1) ])


class DBGKD_SET_INTERNAL_BREAKPOINT32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakpointAddress = v_uint32()
        self.Flags = v_uint32()


class THERMAL_INFORMATION_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ThermalStamp = v_uint32()
        self.ThermalConstant1 = v_uint32()
        self.ThermalConstant2 = v_uint32()
        self.Processors = KAFFINITY_EX()
        self.SamplingPeriod = v_uint32()
        self.CurrentTemperature = v_uint32()
        self.PassiveTripPoint = v_uint32()
        self.CriticalTripPoint = v_uint32()
        self.ActiveTripPointCount = v_uint8()
        self._pad002c = v_bytes(size=3)
        self.ActiveTripPoint = vstruct.VArray([ v_uint32() for i in xrange(10) ])
        self.S4TransitionTripPoint = v_uint32()


class POP_THERMAL_ZONE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = LIST_ENTRY()
        self.State = v_uint8()
        self.Flags = v_uint8()
        self.Mode = v_uint8()
        self.PendingMode = v_uint8()
        self.ActivePoint = v_uint8()
        self.PendingActivePoint = v_uint8()
        self._pad0010 = v_bytes(size=2)
        self.Throttle = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.LastTime = v_uint64()
        self.SampleRate = v_uint32()
        self.LastTemp = v_uint32()
        self.PassiveTimer = KTIMER()
        self.PassiveDpc = KDPC()
        self.OverThrottled = POP_ACTION_TRIGGER()
        self.Irp = v_ptr32()
        self.Info = THERMAL_INFORMATION_EX()
        self._pad00e0 = v_bytes(size=4)
        self.InfoLastUpdateTime = LARGE_INTEGER()
        self.Metrics = POP_THERMAL_ZONE_METRICS()


class POOL_HACKER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = POOL_HEADER()
        self.Contents = vstruct.VArray([ v_uint32() for i in xrange(8) ])


class HANDLE_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TableCode = v_uint32()
        self.QuotaProcess = v_ptr32()
        self.UniqueProcessId = v_ptr32()
        self.HandleLock = EX_PUSH_LOCK()
        self.HandleTableList = LIST_ENTRY()
        self.HandleContentionEvent = EX_PUSH_LOCK()
        self.DebugInfo = v_ptr32()
        self.ExtraInfoPages = v_uint32()
        self.Flags = v_uint32()
        self.FirstFreeHandle = v_uint32()
        self.LastFreeHandleEntry = v_ptr32()
        self.HandleCount = v_uint32()
        self.NextHandleNeedingPool = v_uint32()
        self.HandleCountHighWatermark = v_uint32()


class PO_HIBER_PERF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoTicks = v_uint64()
        self.InitTicks = v_uint64()
        self.CopyTicks = v_uint64()
        self.ElapsedTicks = v_uint64()
        self.CompressTicks = v_uint64()
        self.ResumeAppTime = v_uint64()
        self.HiberFileResumeTime = v_uint64()
        self.BytesCopied = v_uint64()
        self.PagesProcessed = v_uint64()
        self.PagesWritten = v_uint32()
        self.DumpCount = v_uint32()
        self.FileRuns = v_uint32()
        self._pad0058 = v_bytes(size=4)


class DEFERRED_WRITE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self.NodeByteSize = v_uint16()
        self.FileObject = v_ptr32()
        self.BytesToWrite = v_uint32()
        self.DeferredWriteLinks = LIST_ENTRY()
        self.Event = v_ptr32()
        self.PostRoutine = v_ptr32()
        self.Context1 = v_ptr32()
        self.Context2 = v_ptr32()


class HEAP_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Flags = v_uint8()
        self.SmallTagIndex = v_uint8()
        self.PreviousSize = v_uint16()
        self.SegmentOffset = v_uint8()
        self.UnusedBytes = v_uint8()


class ARBITER_INSTANCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.MutexEvent = v_ptr32()
        self.Name = v_ptr32()
        self.OrderingName = v_ptr32()
        self.ResourceType = v_uint32()
        self.Allocation = v_ptr32()
        self.PossibleAllocation = v_ptr32()
        self.OrderingList = ARBITER_ORDERING_LIST()
        self.ReservedList = ARBITER_ORDERING_LIST()
        self.ReferenceCount = v_uint32()
        self.Interface = v_ptr32()
        self.AllocationStackMaxSize = v_uint32()
        self.AllocationStack = v_ptr32()
        self.UnpackRequirement = v_ptr32()
        self.PackResource = v_ptr32()
        self.UnpackResource = v_ptr32()
        self.ScoreRequirement = v_ptr32()
        self.TestAllocation = v_ptr32()
        self.RetestAllocation = v_ptr32()
        self.CommitAllocation = v_ptr32()
        self.RollbackAllocation = v_ptr32()
        self.BootAllocation = v_ptr32()
        self.QueryArbitrate = v_ptr32()
        self.QueryConflict = v_ptr32()
        self.AddReserved = v_ptr32()
        self.StartArbiter = v_ptr32()
        self.PreprocessEntry = v_ptr32()
        self.AllocateEntry = v_ptr32()
        self.GetNextAllocationRange = v_ptr32()
        self.FindSuitableRange = v_ptr32()
        self.AddAllocation = v_ptr32()
        self.BacktrackAllocation = v_ptr32()
        self.OverrideConflict = v_ptr32()
        self.InitializeRangeList = v_ptr32()
        self.TransactionInProgress = v_uint8()
        self._pad0094 = v_bytes(size=3)
        self.TransactionEvent = v_ptr32()
        self.Extension = v_ptr32()
        self.BusDeviceObject = v_ptr32()
        self.ConflictCallbackContext = v_ptr32()
        self.ConflictCallback = v_ptr32()
        self.PdoDescriptionString = vstruct.VArray([ v_uint16() for i in xrange(336) ])
        self.PdoSymbolicNameString = vstruct.VArray([ v_uint8() for i in xrange(672) ])
        self.PdoAddressString = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad05ec = v_bytes(size=2)


class MMPFNENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PageLocation = v_uint8()
        self.Priority = v_uint8()


class MMSUPPORT_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkingSetType = v_uint8()
        self.SessionMaster = v_uint8()
        self.MemoryPriority = v_uint8()
        self.WsleDeleted = v_uint8()


class PROC_PERF_DOMAIN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = LIST_ENTRY()
        self.Master = v_ptr32()
        self.Members = KAFFINITY_EX()
        self.FeedbackHandler = v_ptr32()
        self.GetFFHThrottleState = v_ptr32()
        self.BoostPolicyHandler = v_ptr32()
        self.PerfSelectionHandler = v_ptr32()
        self.PerfHandler = v_ptr32()
        self.Processors = v_ptr32()
        self.PerfChangeTime = v_uint64()
        self.ProcessorCount = v_uint32()
        self.PreviousFrequencyMhz = v_uint32()
        self.CurrentFrequencyMhz = v_uint32()
        self.PreviousFrequency = v_uint32()
        self.CurrentFrequency = v_uint32()
        self.CurrentPerfContext = v_uint32()
        self.DesiredFrequency = v_uint32()
        self.MaxFrequency = v_uint32()
        self.MinPerfPercent = v_uint32()
        self.MinThrottlePercent = v_uint32()
        self.MaxPercent = v_uint32()
        self.MinPercent = v_uint32()
        self.ConstrainedMaxPercent = v_uint32()
        self.ConstrainedMinPercent = v_uint32()
        self.Coordination = v_uint8()
        self._pad0074 = v_bytes(size=3)
        self.PerfChangeIntervalCount = v_uint32()


class _unnamed_23920(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.DataInfoOffset = v_uint16()


class FILE_BASIC_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0028 = v_bytes(size=4)


class PLUGPLAY_EVENT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EventGuid = GUID()
        self.EventCategory = v_uint32()
        self.Result = v_ptr32()
        self.Flags = v_uint32()
        self.TotalSize = v_uint32()
        self.DeviceObject = v_ptr32()
        self.u = _unnamed_25830()


class LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_ptr32()
        self.Blink = v_ptr32()


class M128A(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Low = v_uint64()
        self.High = v_uint64()


class CM_KEY_SECURITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.Reserved = v_uint16()
        self.Flink = v_uint32()
        self.Blink = v_uint32()
        self.ReferenceCount = v_uint32()
        self.DescriptorLength = v_uint32()
        self.Descriptor = SECURITY_DESCRIPTOR_RELATIVE()


class _unnamed_22031(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags = v_uint32()


class PNP_DEVICE_COMPLETION_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DispatchedList = LIST_ENTRY()
        self.DispatchedCount = v_uint32()
        self.CompletedList = LIST_ENTRY()
        self.CompletedSemaphore = KSEMAPHORE()
        self.SpinLock = v_uint32()


class CLIENT_ID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_ptr32()
        self.UniqueThread = v_ptr32()


class POP_ACTION_TRIGGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.Flags = v_uint32()
        self.Wait = v_ptr32()
        self.Battery = _unnamed_26496()


class ETW_REALTIME_CONSUMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Links = LIST_ENTRY()
        self.ProcessHandle = v_ptr32()
        self.ProcessObject = v_ptr32()
        self.NextNotDelivered = v_ptr32()
        self.RealtimeConnectContext = v_ptr32()
        self.DisconnectEvent = v_ptr32()
        self.DataAvailableEvent = v_ptr32()
        self.UserBufferCount = v_ptr32()
        self.UserBufferListHead = v_ptr32()
        self.BuffersLost = v_uint32()
        self.EmptyBuffersCount = v_uint32()
        self.LoggerId = v_uint32()
        self.ShutDownRequested = v_uint8()
        self.NewBuffersLost = v_uint8()
        self.Disconnected = v_uint8()
        self._pad0038 = v_bytes(size=1)
        self.ReservedBufferSpaceBitMap = RTL_BITMAP()
        self.ReservedBufferSpace = v_ptr32()
        self.ReservedBufferSpaceSize = v_uint32()
        self.UserPagesAllocated = v_uint32()
        self.UserPagesReused = v_uint32()


class _unnamed_23571(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Read = _unnamed_23572()


class MI_EXTRA_IMAGE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfHeaders = v_uint32()
        self.SizeOfImage = v_uint32()


class DEVICE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DosDevicesDirectory = v_ptr32()
        self.GlobalDosDevicesDirectory = v_ptr32()
        self.DosDevicesDirectoryHandle = v_ptr32()
        self.ReferenceCount = v_uint32()
        self.DriveMap = v_uint32()
        self.DriveType = vstruct.VArray([ v_uint8() for i in xrange(32) ])


class DBGKD_READ_WRITE_IO_EXTENDED32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.AddressSpace = v_uint32()
        self.IoAddress = v_uint32()
        self.DataValue = v_uint32()


class CONTROL_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Segment = v_ptr32()
        self.DereferenceList = LIST_ENTRY()
        self.NumberOfSectionReferences = v_uint32()
        self.NumberOfPfnReferences = v_uint32()
        self.NumberOfMappedViews = v_uint32()
        self.NumberOfUserReferences = v_uint32()
        self.u = _unnamed_21803()
        self.FlushInProgressCount = v_uint32()
        self.FilePointer = EX_FAST_REF()
        self.ControlAreaLock = v_uint32()
        self.ModifiedWriteCount = v_uint32()
        self.WaitingForDeletion = v_ptr32()
        self.u2 = _unnamed_21806()
        self.LockedPages = v_uint64()
        self.ViewList = LIST_ENTRY()


class KERNEL_STACK_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousTrapFrame = v_ptr32()
        self.StackControlFlags = v_uint32()
        self.Previous = KERNEL_STACK_SEGMENT()


class VI_TRACK_IRQL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Thread = v_ptr32()
        self.OldIrql = v_uint8()
        self.NewIrql = v_uint8()
        self.Processor = v_uint16()
        self.TickCount = v_uint32()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(5) ])


class GUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data1 = v_uint32()
        self.Data2 = v_uint16()
        self.Data3 = v_uint16()
        self.Data4 = vstruct.VArray([ v_uint8() for i in xrange(8) ])


class HEAP_UCR_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.SegmentEntry = LIST_ENTRY()
        self.Address = v_ptr32()
        self.Size = v_uint32()


class _unnamed_18626(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()


class _unnamed_28048(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserData = v_ptr32()
        self.Owner = v_ptr32()


class _unnamed_20855(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self.Length = v_uint32()


class POP_SYSTEM_IDLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AverageIdleness = v_uint32()
        self.LowestIdleness = v_uint32()
        self.Time = v_uint32()
        self.Timeout = v_uint32()
        self.LastUserInput = v_uint32()
        self.Action = POWER_ACTION_POLICY()
        self.MinState = v_uint32()
        self.SystemRequired = v_uint8()
        self.IdleWorker = v_uint8()
        self.Sampling = v_uint8()
        self._pad0028 = v_bytes(size=1)
        self.LastTick = v_uint64()
        self.LastSystemRequiredTime = v_uint32()
        self._pad0038 = v_bytes(size=4)


class _unnamed_20850(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self.InputBufferLength = v_uint32()
        self.IoControlCode = v_uint32()
        self.Type3InputBuffer = v_ptr32()


class COUNTER_READING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.Index = v_uint32()
        self.Start = v_uint64()
        self.Total = v_uint64()


class MMVAD_SHORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_21960()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.StartingVpn = v_uint32()
        self.EndingVpn = v_uint32()
        self.u = _unnamed_21963()
        self.PushLock = EX_PUSH_LOCK()
        self.u5 = _unnamed_21964()


class DBGKD_GET_VERSION32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.ProtocolVersion = v_uint16()
        self.Flags = v_uint16()
        self.KernBase = v_uint32()
        self.PsLoadedModuleList = v_uint32()
        self.MachineType = v_uint16()
        self.ThCallbackStack = v_uint16()
        self.NextCallback = v_uint16()
        self.FramePointer = v_uint16()
        self.KiCallUserMode = v_uint32()
        self.KeUserCallbackDispatcher = v_uint32()
        self.BreakpointWithStatus = v_uint32()
        self.DebuggerDataList = v_uint32()


class _unnamed_20858(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self.SecurityDescriptor = v_ptr32()


class CM_CELL_REMAP_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OldCell = v_uint32()
        self.NewCell = v_uint32()


class PNP_DEVICE_ACTION_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.DeviceObject = v_ptr32()
        self.RequestType = v_uint32()
        self.ReorderingBarrier = v_uint8()
        self._pad0014 = v_bytes(size=3)
        self.RequestArgument = v_uint32()
        self.CompletionEvent = v_ptr32()
        self.CompletionStatus = v_ptr32()


class KDPC_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DpcListHead = LIST_ENTRY()
        self.DpcLock = v_uint32()
        self.DpcQueueDepth = v_uint32()
        self.DpcCount = v_uint32()


class KIDTENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint16()
        self.Selector = v_uint16()
        self.Access = v_uint16()
        self.ExtendedOffset = v_uint16()


class _unnamed_26901(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Raw = _unnamed_26896()


class _unnamed_28591(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Head = v_uint64()


class POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemState = v_uint32()


class GENERIC_MAPPING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GenericRead = v_uint32()
        self.GenericWrite = v_uint32()
        self.GenericExecute = v_uint32()
        self.GenericAll = v_uint32()


class IRP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.MdlAddress = v_ptr32()
        self.Flags = v_uint32()
        self.AssociatedIrp = _unnamed_20600()
        self.ThreadListEntry = LIST_ENTRY()
        self.IoStatus = IO_STATUS_BLOCK()
        self.RequestorMode = v_uint8()
        self.PendingReturned = v_uint8()
        self.StackCount = v_uint8()
        self.CurrentLocation = v_uint8()
        self.Cancel = v_uint8()
        self.CancelIrql = v_uint8()
        self.ApcEnvironment = v_uint8()
        self.AllocationFlags = v_uint8()
        self.UserIosb = v_ptr32()
        self.UserEvent = v_ptr32()
        self.Overlay = _unnamed_20603()
        self.CancelRoutine = v_ptr32()
        self.UserBuffer = v_ptr32()
        self.Tail = _unnamed_20606()


class KTHREAD_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitReasonBitMap = v_uint64()
        self.UserData = v_ptr32()
        self.Flags = v_uint32()
        self.ContextSwitches = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.CycleTimeBias = v_uint64()
        self.HardwareCounters = v_uint64()
        self.HwCounter = vstruct.VArray([ COUNTER_READING() for i in xrange(16) ])


class MMADDRESS_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_25284()
        self.EndVa = v_ptr32()


class OBJECT_REF_TRACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(16) ])


class KALPC_RESERVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerPort = v_ptr32()
        self.HandleTable = v_ptr32()
        self.Handle = v_ptr32()
        self.Message = v_ptr32()
        self.Active = v_uint32()


class KINTERRUPT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.InterruptListEntry = LIST_ENTRY()
        self.ServiceRoutine = v_ptr32()
        self.MessageServiceRoutine = v_ptr32()
        self.MessageIndex = v_uint32()
        self.ServiceContext = v_ptr32()
        self.SpinLock = v_uint32()
        self.TickCount = v_uint32()
        self.ActualLock = v_ptr32()
        self.DispatchAddress = v_ptr32()
        self.Vector = v_uint32()
        self.Irql = v_uint8()
        self.SynchronizeIrql = v_uint8()
        self.FloatingSave = v_uint8()
        self.Connected = v_uint8()
        self.Number = v_uint32()
        self.ShareVector = v_uint8()
        self.Pad = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.Mode = v_uint32()
        self.Polarity = v_uint32()
        self.ServiceCount = v_uint32()
        self.DispatchCount = v_uint32()
        self._pad0050 = v_bytes(size=4)
        self.Rsvd1 = v_uint64()
        self.DispatchCode = vstruct.VArray([ v_uint32() for i in xrange(135) ])
        self._pad0278 = v_bytes(size=4)


class _unnamed_28368(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeSize = v_uint32()


class SECURITY_DESCRIPTOR_RELATIVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.Sbz1 = v_uint8()
        self.Control = v_uint16()
        self.Owner = v_uint32()
        self.Group = v_uint32()
        self.Sacl = v_uint32()
        self.Dacl = v_uint32()


class DUMP_INITIALIZATION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Reserved = v_uint32()
        self.MemoryBlock = v_ptr32()
        self.CommonBuffer = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self._pad0018 = v_bytes(size=4)
        self.PhysicalAddress = vstruct.VArray([ LARGE_INTEGER() for i in xrange(2) ])
        self.StallRoutine = v_ptr32()
        self.OpenRoutine = v_ptr32()
        self.WriteRoutine = v_ptr32()
        self.FinishRoutine = v_ptr32()
        self.AdapterObject = v_ptr32()
        self.MappedRegisterBase = v_ptr32()
        self.PortConfiguration = v_ptr32()
        self.CrashDump = v_uint8()
        self._pad0048 = v_bytes(size=3)
        self.MaximumTransferSize = v_uint32()
        self.CommonBufferSize = v_uint32()
        self.TargetAddress = v_ptr32()
        self.WritePendingRoutine = v_ptr32()
        self.PartitionStyle = v_uint32()
        self.DiskInfo = _unnamed_28874()
        self._pad0070 = v_bytes(size=4)


class _unnamed_22434(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CheckStack = v_ptr32()


class VERIFIER_SHARED_EXPORT_THUNK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class FILE_GET_QUOTA_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextEntryOffset = v_uint32()
        self.SidLength = v_uint32()
        self.Sid = SID()


class OBJECT_HANDLE_COUNT_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Process = v_ptr32()
        self.HandleCount = v_uint32()


class _unnamed_21552(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.I386 = I386_LOADER_BLOCK()


class KGATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class IO_COMPLETION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = v_ptr32()
        self.Key = v_ptr32()


class DRIVER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DriverObject = v_ptr32()
        self.AddDevice = v_ptr32()
        self.Count = v_uint32()
        self.ServiceKeyName = UNICODE_STRING()
        self.ClientDriverExtension = v_ptr32()
        self.FsFilterCallbacks = v_ptr32()


class TOKEN_SOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SourceName = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.SourceIdentifier = LUID()


class PCW_REGISTRATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class MMPFN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_21666()
        self.u2 = _unnamed_21667()
        self.PteAddress = v_ptr32()
        self.u3 = _unnamed_21669()
        self.OriginalPte = MMPTE()
        self.u4 = _unnamed_21670()


class PO_IRP_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CurrentIrp = v_ptr32()
        self.PendingIrpList = v_ptr32()


class TP_NBQ_GUARD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GuardLinks = LIST_ENTRY()
        self.Guards = vstruct.VArray([ v_ptr32() for i in xrange(2) ])


class flags(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Removable = v_uint8()


class DBGKD_SEARCH_MEMORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SearchAddress = v_uint64()
        self.SearchLength = v_uint64()
        self.PatternLength = v_uint32()
        self._pad0018 = v_bytes(size=4)


class _unnamed_26908(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint32()
        self.Length = v_uint32()
        self.Reserved = v_uint32()


class VF_AVL_TREE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint32()
        self.NodeToFree = v_ptr32()
        self.NodeRangeSize = v_uint32()
        self.NodeCount = v_uint32()
        self.Tables = v_ptr32()
        self.TablesNo = v_uint32()
        self.u1 = _unnamed_28368()
        self._pad0040 = v_bytes(size=36)


class _unnamed_27117(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TestAllocation = ARBITER_TEST_ALLOCATION_PARAMETERS()
        self._pad0010 = v_bytes(size=4)


class MM_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = MMADDRESS_NODE()
        self.DepthOfTree = v_uint32()
        self.NodeHint = v_ptr32()
        self.NodeFreeHint = v_ptr32()


class _unnamed_21620(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EfiInformation = EFI_FIRMWARE_INFORMATION()


class ETW_LAST_ENABLE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnableFlags = LARGE_INTEGER()
        self.LoggerId = v_uint16()
        self.Level = v_uint8()
        self.Enabled = v_uint8()
        self._pad0010 = v_bytes(size=4)


class HEAP_VIRTUAL_ALLOC_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = LIST_ENTRY()
        self.ExtraStuff = HEAP_ENTRY_EXTRA()
        self.CommitSize = v_uint32()
        self.ReserveSize = v_uint32()
        self.BusyBlock = HEAP_ENTRY()


class VI_DEADLOCK_THREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Thread = v_ptr32()
        self.CurrentSpinNode = v_ptr32()
        self.CurrentOtherNode = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.NodeCount = v_uint32()
        self.PagingCount = v_uint32()
        self.ThreadUsesEresources = v_uint8()
        self._pad0020 = v_bytes(size=3)


class PPM_PERF_STATES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.MaxFrequency = v_uint32()
        self.PStateCap = v_uint32()
        self.TStateCap = v_uint32()
        self.MaxPerfState = v_uint32()
        self.MinPerfState = v_uint32()
        self.LowestPState = v_uint32()
        self.IncreaseTime = v_uint32()
        self.DecreaseTime = v_uint32()
        self.BusyAdjThreshold = v_uint8()
        self.Reserved = v_uint8()
        self.ThrottleStatesOnly = v_uint8()
        self.PolicyType = v_uint8()
        self.TimerInterval = v_uint32()
        self.Flags = _unnamed_27306()
        self.TargetProcessors = KAFFINITY_EX()
        self.PStateHandler = v_ptr32()
        self.PStateContext = v_uint32()
        self.TStateHandler = v_ptr32()
        self.TStateContext = v_uint32()
        self.FeedbackHandler = v_ptr32()
        self.GetFFHThrottleState = v_ptr32()
        self._pad0058 = v_bytes(size=4)
        self.State = vstruct.VArray([ PPM_PERF_STATE() for i in xrange(1) ])


class _unnamed_21666(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint32()


class ARBITER_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parameters = _unnamed_27117()


class EXCEPTION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_ptr32()
        self.ExceptionAddress = v_ptr32()
        self.NumberParameters = v_uint32()
        self.ExceptionInformation = vstruct.VArray([ v_uint32() for i in xrange(15) ])


class MMPTE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u = _unnamed_21450()


class _unnamed_28098(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MissedEtwRegistration = v_uint32()


class VI_DEADLOCK_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parent = v_ptr32()
        self.ChildrenList = LIST_ENTRY()
        self.SiblingsList = LIST_ENTRY()
        self.ResourceList = LIST_ENTRY()
        self.Root = v_ptr32()
        self.ThreadEntry = v_ptr32()
        self.u1 = _unnamed_28293()
        self.ChildrenCount = v_uint32()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(8) ])
        self.ParentStackTrace = vstruct.VArray([ v_ptr32() for i in xrange(8) ])


class PROC_IDLE_STATE_BUCKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalTime = v_uint64()
        self.MinTime = v_uint64()
        self.MaxTime = v_uint64()
        self.Count = v_uint32()
        self._pad0020 = v_bytes(size=4)


class VACB_ARRAY_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VacbArrayIndex = v_uint32()
        self.MappingCount = v_uint32()
        self.HighestMappedIndex = v_uint32()
        self.Reserved = v_uint32()


class HEAP_STOP_ON_TAG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HeapAndTagIndex = v_uint32()


class KPCR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.SelfPcr = v_ptr32()
        self.Prcb = v_ptr32()
        self.Irql = v_uint8()
        self._pad0028 = v_bytes(size=3)
        self.IRR = v_uint32()
        self.IrrActive = v_uint32()
        self.IDR = v_uint32()
        self.KdVersionBlock = v_ptr32()
        self.IDT = v_ptr32()
        self.GDT = v_ptr32()
        self.TSS = v_ptr32()
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.SetMember = v_uint32()
        self.StallScaleFactor = v_uint32()
        self.SpareUnused = v_uint8()
        self.Number = v_uint8()
        self.Spare0 = v_uint8()
        self.SecondLevelCacheAssociativity = v_uint8()
        self.VdmAlert = v_uint32()
        self.KernelReserved = vstruct.VArray([ v_uint32() for i in xrange(14) ])
        self.SecondLevelCacheSize = v_uint32()
        self.HalReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.InterruptMode = v_uint32()
        self.Spare1 = v_uint8()
        self._pad00dc = v_bytes(size=3)
        self.KernelReserved2 = vstruct.VArray([ v_uint32() for i in xrange(17) ])
        self.PrcbData = KPRCB()


class SYSTEM_POWER_POLICY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint32()
        self.PowerButton = POWER_ACTION_POLICY()
        self.SleepButton = POWER_ACTION_POLICY()
        self.LidClose = POWER_ACTION_POLICY()
        self.LidOpenWake = v_uint32()
        self.Reserved = v_uint32()
        self.Idle = POWER_ACTION_POLICY()
        self.IdleTimeout = v_uint32()
        self.IdleSensitivity = v_uint8()
        self.DynamicThrottle = v_uint8()
        self.Spare2 = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.MinSleep = v_uint32()
        self.MaxSleep = v_uint32()
        self.ReducedLatencySleep = v_uint32()
        self.WinLogonFlags = v_uint32()
        self.Spare3 = v_uint32()
        self.DozeS4Timeout = v_uint32()
        self.BroadcastCapacityResolution = v_uint32()
        self.DischargePolicy = vstruct.VArray([ SYSTEM_POWER_LEVEL() for i in xrange(4) ])
        self.VideoTimeout = v_uint32()
        self.VideoDimDisplay = v_uint8()
        self._pad00c8 = v_bytes(size=3)
        self.VideoReserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.SpindownTimeout = v_uint32()
        self.OptimizeForPower = v_uint8()
        self.FanThrottleTolerance = v_uint8()
        self.ForcedThrottle = v_uint8()
        self.MinThrottle = v_uint8()
        self.OverThrottled = POWER_ACTION_POLICY()


class IMAGE_FILE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Machine = v_uint16()
        self.NumberOfSections = v_uint16()
        self.TimeDateStamp = v_uint32()
        self.PointerToSymbolTable = v_uint32()
        self.NumberOfSymbols = v_uint32()
        self.SizeOfOptionalHeader = v_uint16()
        self.Characteristics = v_uint16()


class CM_KEY_INDEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.Count = v_uint16()
        self.List = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class FILE_STANDARD_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.NumberOfLinks = v_uint32()
        self.DeletePending = v_uint8()
        self.Directory = v_uint8()
        self._pad0018 = v_bytes(size=2)


class RELATION_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.TagCount = v_uint32()
        self.FirstLevel = v_uint32()
        self.MaxLevel = v_uint32()
        self.Entries = vstruct.VArray([ v_ptr32() for i in xrange(1) ])


class PI_RESOURCE_ARBITER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceArbiterList = LIST_ENTRY()
        self.ResourceType = v_uint8()
        self._pad000c = v_bytes(size=3)
        self.ArbiterInterface = v_ptr32()
        self.DeviceNode = v_ptr32()
        self.ResourceList = LIST_ENTRY()
        self.BestResourceList = LIST_ENTRY()
        self.BestConfig = LIST_ENTRY()
        self.ActiveArbiterList = LIST_ENTRY()
        self.State = v_uint8()
        self.ResourcesChanged = v_uint8()
        self._pad0038 = v_bytes(size=2)


class _unnamed_20618(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserApcRoutine = v_ptr32()
        self.UserApcContext = v_ptr32()


class SYSPTES_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = LIST_ENTRY()
        self.Count = v_uint32()
        self.NumberOfEntries = v_uint32()
        self.NumberOfEntriesPeak = v_uint32()


class MI_SECTION_CREATION_GATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Gate = KGATE()


class TRACE_ENABLE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LoggerId = v_uint16()
        self.Level = v_uint8()
        self.InternalFlag = v_uint8()
        self.EnableFlags = v_uint32()


class PEB_LDR_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Initialized = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.SsHandle = v_ptr32()
        self.InLoadOrderModuleList = LIST_ENTRY()
        self.InMemoryOrderModuleList = LIST_ENTRY()
        self.InInitializationOrderModuleList = LIST_ENTRY()
        self.EntryInProgress = v_ptr32()
        self.ShutdownInProgress = v_uint8()
        self._pad002c = v_bytes(size=3)
        self.ShutdownThreadId = v_ptr32()


class _unnamed_20883(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.StartSid = v_ptr32()
        self.SidList = v_ptr32()
        self.SidListLength = v_uint32()


class DBGKD_WRITE_BREAKPOINT64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakPointAddress = v_uint64()
        self.BreakPointHandle = v_uint32()
        self._pad0010 = v_bytes(size=4)


class _unnamed_18629(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFunction = v_uint32()


class FSRTL_ADVANCED_FCB_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self.NodeByteSize = v_uint16()
        self.Flags = v_uint8()
        self.IsFastIoPossible = v_uint8()
        self.Flags2 = v_uint8()
        self.Reserved = v_uint8()
        self.Resource = v_ptr32()
        self.PagingIoResource = v_ptr32()
        self.AllocationSize = LARGE_INTEGER()
        self.FileSize = LARGE_INTEGER()
        self.ValidDataLength = LARGE_INTEGER()
        self.FastMutex = v_ptr32()
        self.FilterContexts = LIST_ENTRY()
        self.PushLock = EX_PUSH_LOCK()
        self.FileContextSupportPointer = v_ptr32()
        self._pad0040 = v_bytes(size=4)


class ARBITER_INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Context = v_ptr32()
        self.InterfaceReference = v_ptr32()
        self.InterfaceDereference = v_ptr32()
        self.ArbiterHandler = v_ptr32()
        self.Flags = v_uint32()


class DIAGNOSTIC_BUFFER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.CallerType = v_uint32()
        self.ProcessImageNameOffset = v_uint32()
        self.ProcessId = v_uint32()
        self.ServiceTag = v_uint32()
        self.ReasonOffset = v_uint32()


class PNP_DEVICE_EVENT_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.EventQueueMutex = KMUTANT()
        self.Lock = KGUARDED_MUTEX()
        self.List = LIST_ENTRY()


class MM_PAGE_ACCESS_INFO_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.File = _unnamed_25069()


class SECURITY_SUBJECT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientToken = v_ptr32()
        self.ImpersonationLevel = v_uint32()
        self.PrimaryToken = v_ptr32()
        self.ProcessAuditId = v_ptr32()


class X86_DBGKD_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TraceFlag = v_uint32()
        self.Dr7 = v_uint32()
        self.CurrentSymbolStart = v_uint32()
        self.CurrentSymbolEnd = v_uint32()


class PROFILE_PARAMETER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint16()
        self.Reserved = v_uint16()
        self.DockingState = v_uint16()
        self.Capabilities = v_uint16()
        self.DockID = v_uint32()
        self.SerialNumber = v_uint32()


class AMD64_DBGKD_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TraceFlag = v_uint32()
        self.Dr7 = v_uint64()
        self.CurrentSymbolStart = v_uint64()
        self.CurrentSymbolEnd = v_uint64()


class _unnamed_23968(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReferenceCache = v_uint8()


class ALPC_MESSAGE_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedAttributes = v_uint32()
        self.ValidAttributes = v_uint32()


class POP_THERMAL_ZONE_METRICS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MetricsResource = ERESOURCE()
        self.ActiveCount = v_uint32()
        self.PassiveCount = v_uint32()
        self.LastActiveStartTick = LARGE_INTEGER()
        self.AverageActiveTime = LARGE_INTEGER()
        self.LastPassiveStartTick = LARGE_INTEGER()
        self.AveragePassiveTime = LARGE_INTEGER()
        self.StartTickSinceLastReset = LARGE_INTEGER()


class PCW_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = v_ptr32()
        self.Size = v_uint32()


class DEVICE_RELATIONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Objects = vstruct.VArray([ v_ptr32() for i in xrange(1) ])


class _unnamed_23010(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DockStatus = v_uint32()
        self.ListEntry = LIST_ENTRY()
        self.SerialNumber = v_ptr32()


class ETW_PROVIDER_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RefCount = v_uint32()
        self.State = v_uint32()
        self.RegEntry = v_ptr32()
        self.Caller = v_ptr32()


class _unnamed_22946(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Disk = _unnamed_26989()


class _unnamed_20718(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self.Parameters = v_ptr32()


class MMSUBSECTION_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SubsectionAccessed = v_uint16()
        self.SubsectionStatic = v_uint16()


class INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Context = v_ptr32()
        self.InterfaceReference = v_ptr32()
        self.InterfaceDereference = v_ptr32()


class STRING32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_uint32()


class WMI_LOGGER_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LoggerId = v_uint32()
        self.BufferSize = v_uint32()
        self.MaximumEventSize = v_uint32()
        self.CollectionOn = v_uint32()
        self.LoggerMode = v_uint32()
        self.AcceptNewEvents = v_uint32()
        self.GetCpuClock = v_ptr32()
        self._pad0020 = v_bytes(size=4)
        self.StartTime = LARGE_INTEGER()
        self.LogFileHandle = v_ptr32()
        self.LoggerThread = v_ptr32()
        self.LoggerStatus = v_uint32()
        self.NBQHead = v_ptr32()
        self.OverflowNBQHead = v_ptr32()
        self._pad0040 = v_bytes(size=4)
        self.QueueBlockFreeList = SLIST_HEADER()
        self.GlobalList = LIST_ENTRY()
        self.BatchedBufferList = v_ptr32()
        self.LoggerName = UNICODE_STRING()
        self.LogFileName = UNICODE_STRING()
        self.LogFilePattern = UNICODE_STRING()
        self.NewLogFileName = UNICODE_STRING()
        self.ClockType = v_uint32()
        self.MaximumFileSize = v_uint32()
        self.LastFlushedBuffer = v_uint32()
        self.FlushTimer = v_uint32()
        self.FlushThreshold = v_uint32()
        self.ByteOffset = LARGE_INTEGER()
        self.MinimumBuffers = v_uint32()
        self.BuffersAvailable = v_uint32()
        self.NumberOfBuffers = v_uint32()
        self.MaximumBuffers = v_uint32()
        self.EventsLost = v_uint32()
        self.BuffersWritten = v_uint32()
        self.LogBuffersLost = v_uint32()
        self.RealTimeBuffersDelivered = v_uint32()
        self.RealTimeBuffersLost = v_uint32()
        self.SequencePtr = v_ptr32()
        self.LocalSequence = v_uint32()
        self.InstanceGuid = GUID()
        self.FileCounter = v_uint32()
        self.BufferCallback = v_ptr32()
        self.PoolType = v_uint32()
        self.ReferenceTime = ETW_REF_CLOCK()
        self.Consumers = LIST_ENTRY()
        self.NumConsumers = v_uint32()
        self.TransitionConsumer = v_ptr32()
        self.RealtimeLogfileHandle = v_ptr32()
        self.RealtimeLogfileName = UNICODE_STRING()
        self._pad0108 = v_bytes(size=4)
        self.RealtimeWriteOffset = LARGE_INTEGER()
        self.RealtimeReadOffset = LARGE_INTEGER()
        self.RealtimeLogfileSize = LARGE_INTEGER()
        self.RealtimeLogfileUsage = v_uint64()
        self.RealtimeMaximumFileSize = v_uint64()
        self.RealtimeBuffersSaved = v_uint32()
        self._pad0138 = v_bytes(size=4)
        self.RealtimeReferenceTime = ETW_REF_CLOCK()
        self.NewRTEventsLost = v_uint32()
        self.LoggerEvent = KEVENT()
        self.FlushEvent = KEVENT()
        self._pad0170 = v_bytes(size=4)
        self.FlushTimeOutTimer = KTIMER()
        self.FlushDpc = KDPC()
        self.LoggerMutex = KMUTANT()
        self.LoggerLock = EX_PUSH_LOCK()
        self.BufferListSpinLock = v_uint32()
        self.ClientSecurityContext = SECURITY_CLIENT_CONTEXT()
        self.SecurityDescriptor = EX_FAST_REF()
        self.BufferSequenceNumber = v_uint64()
        self.Flags = v_uint32()
        self.RequestFlag = v_uint32()
        self.HookIdMap = RTL_BITMAP()


class THREAD_PERFORMANCE_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.ProcessorNumber = PROCESSOR_NUMBER()
        self.ContextSwitches = v_uint32()
        self.HwCountersCount = v_uint32()
        self.UpdateCount = v_uint64()
        self.WaitReasonBitMap = v_uint64()
        self.HardwareCounters = v_uint64()
        self.CycleTime = COUNTER_READING()
        self.HwCounters = vstruct.VArray([ COUNTER_READING() for i in xrange(16) ])


class ACTIVATION_CONTEXT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class IO_STACK_LOCATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorFunction = v_uint8()
        self.MinorFunction = v_uint8()
        self.Flags = v_uint8()
        self.Control = v_uint8()
        self.Parameters = _unnamed_20640()
        self.DeviceObject = v_ptr32()
        self.FileObject = v_ptr32()
        self.CompletionRoutine = v_ptr32()
        self.Context = v_ptr32()


class DBGKD_READ_WRITE_MSR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Msr = v_uint32()
        self.DataValueLow = v_uint32()
        self.DataValueHigh = v_uint32()


class ARBITER_QUERY_CONFLICT_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PhysicalDeviceObject = v_ptr32()
        self.ConflictingResource = v_ptr32()
        self.ConflictCount = v_ptr32()
        self.Conflicts = v_ptr32()


class IMAGE_DATA_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_uint32()
        self.Size = v_uint32()


class FILE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Vpb = v_ptr32()
        self.FsContext = v_ptr32()
        self.FsContext2 = v_ptr32()
        self.SectionObjectPointer = v_ptr32()
        self.PrivateCacheMap = v_ptr32()
        self.FinalStatus = v_uint32()
        self.RelatedFileObject = v_ptr32()
        self.LockOperation = v_uint8()
        self.DeletePending = v_uint8()
        self.ReadAccess = v_uint8()
        self.WriteAccess = v_uint8()
        self.DeleteAccess = v_uint8()
        self.SharedRead = v_uint8()
        self.SharedWrite = v_uint8()
        self.SharedDelete = v_uint8()
        self.Flags = v_uint32()
        self.FileName = UNICODE_STRING()
        self.CurrentByteOffset = LARGE_INTEGER()
        self.Waiters = v_uint32()
        self.Busy = v_uint32()
        self.LastLock = v_ptr32()
        self.Lock = KEVENT()
        self.Event = KEVENT()
        self.CompletionContext = v_ptr32()
        self.IrpListLock = v_uint32()
        self.IrpList = LIST_ENTRY()
        self.FileObjectExtension = v_ptr32()


class PPM_IDLE_STATES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Flags = _unnamed_25316()
        self.TargetState = v_uint32()
        self.ActualState = v_uint32()
        self.OldState = v_uint32()
        self.NewlyUnparked = v_uint8()
        self._pad0018 = v_bytes(size=3)
        self.TargetProcessors = KAFFINITY_EX()
        self._pad0028 = v_bytes(size=4)
        self.State = vstruct.VArray([ PPM_IDLE_STATE() for i in xrange(1) ])


class _unnamed_23967(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_23968()


class _unnamed_20818(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.EaList = v_ptr32()
        self.EaListLength = v_uint32()
        self.EaIndex = v_uint32()


class SECTION_IMAGE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TransferAddress = v_ptr32()
        self.ZeroBits = v_uint32()
        self.MaximumStackSize = v_uint32()
        self.CommittedStackSize = v_uint32()
        self.SubSystemType = v_uint32()
        self.SubSystemMinorVersion = v_uint16()
        self.SubSystemMajorVersion = v_uint16()
        self.GpValue = v_uint32()
        self.ImageCharacteristics = v_uint16()
        self.DllCharacteristics = v_uint16()
        self.Machine = v_uint16()
        self.ImageContainsCode = v_uint8()
        self.ImageFlags = v_uint8()
        self.LoaderFlags = v_uint32()
        self.ImageFileSize = v_uint32()
        self.CheckSum = v_uint32()


class _unnamed_20810(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileInformationClass = v_uint32()
        self.FileObject = v_ptr32()
        self.ReplaceIfExists = v_uint8()
        self.AdvanceOnly = v_uint8()
        self._pad0010 = v_bytes(size=2)


class KENLISTMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cookie = v_uint32()
        self.NamespaceLink = KTMOBJECT_NAMESPACE_LINK()
        self.EnlistmentId = GUID()
        self.Mutex = KMUTANT()
        self.NextSameTx = LIST_ENTRY()
        self.NextSameRm = LIST_ENTRY()
        self.ResourceManager = v_ptr32()
        self.Transaction = v_ptr32()
        self.State = v_uint32()
        self.Flags = v_uint32()
        self.NotificationMask = v_uint32()
        self.Key = v_ptr32()
        self.KeyRefCount = v_uint32()
        self.RecoveryInformation = v_ptr32()
        self.RecoveryInformationLength = v_uint32()
        self.DynamicNameInformation = v_ptr32()
        self.DynamicNameInformationLength = v_uint32()
        self.FinalNotification = v_ptr32()
        self.SupSubEnlistment = v_ptr32()
        self.SupSubEnlHandle = v_ptr32()
        self.SubordinateTxHandle = v_ptr32()
        self.CrmEnlistmentEnId = GUID()
        self.CrmEnlistmentTmId = GUID()
        self.CrmEnlistmentRmId = GUID()
        self.NextHistory = v_uint32()
        self.History = vstruct.VArray([ KENLISTMENT_HISTORY() for i in xrange(20) ])


class _unnamed_23285(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReadMemory = DBGKD_READ_MEMORY64()
        self._pad0028 = v_bytes(size=24)


class HEAP_SUBSEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LocalInfo = v_ptr32()
        self.UserBlocks = v_ptr32()
        self.AggregateExchg = INTERLOCK_SEQ()
        self.BlockSize = v_uint16()
        self.Flags = v_uint16()
        self.BlockCount = v_uint16()
        self.SizeIndex = v_uint8()
        self.AffinityIndex = v_uint8()
        self.SFreeListEntry = SINGLE_LIST_ENTRY()
        self.Lock = v_uint32()


class ERESOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemResourcesList = LIST_ENTRY()
        self.OwnerTable = v_ptr32()
        self.ActiveCount = v_uint16()
        self.Flag = v_uint16()
        self.SharedWaiters = v_ptr32()
        self.ExclusiveWaiters = v_ptr32()
        self.OwnerEntry = OWNER_ENTRY()
        self.ActiveEntries = v_uint32()
        self.ContentionCount = v_uint32()
        self.NumberOfSharedWaiters = v_uint32()
        self.NumberOfExclusiveWaiters = v_uint32()
        self.Address = v_ptr32()
        self.SpinLock = v_uint32()


class SUBSECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlArea = v_ptr32()
        self.SubsectionBase = v_ptr32()
        self.NextSubsection = v_ptr32()
        self.PtesInSubsection = v_uint32()
        self.UnusedPtes = v_uint32()
        self.u = _unnamed_22031()
        self.StartingSector = v_uint32()
        self.NumberOfFullSectors = v_uint32()


class CM_WORKITEM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.Private = v_uint32()
        self.WorkerRoutine = v_ptr32()
        self.Parameter = v_ptr32()


class KGUARDED_MUTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Owner = v_ptr32()
        self.Contention = v_uint32()
        self.Gate = KGATE()
        self.KernelApcDisable = v_uint16()
        self.SpecialApcDisable = v_uint16()


class DBGKD_SET_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFlags = v_uint32()


class SID_AND_ATTRIBUTES_HASH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SidCount = v_uint32()
        self.SidAttr = v_ptr32()
        self.Hash = vstruct.VArray([ v_uint32() for i in xrange(32) ])


class KALPC_REGION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RegionListEntry = LIST_ENTRY()
        self.Section = v_ptr32()
        self.Offset = v_uint32()
        self.Size = v_uint32()
        self.ViewSize = v_uint32()
        self.u1 = _unnamed_24061()
        self.NumberOfViews = v_uint32()
        self.ViewListHead = LIST_ENTRY()
        self.ReadOnlyView = v_ptr32()
        self.ReadWriteView = v_ptr32()


class POOL_BLOCK_HEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = POOL_HEADER()
        self.List = LIST_ENTRY()


class TEB32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB32()
        self.EnvironmentPointer = v_uint32()
        self.ClientId = CLIENT_ID32()
        self.ActiveRpcHandle = v_uint32()
        self.ThreadLocalStoragePointer = v_uint32()
        self.ProcessEnvironmentBlock = v_uint32()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_uint32()
        self.Win32ThreadInfo = v_uint32()
        self.User32Reserved = vstruct.VArray([ v_uint32() for i in xrange(26) ])
        self.UserReserved = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self.WOW32Reserved = v_uint32()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()
        self.SystemReserved1 = vstruct.VArray([ v_uint32() for i in xrange(54) ])
        self.ExceptionCode = v_uint32()
        self.ActivationContextStackPointer = v_uint32()
        self.SpareBytes = vstruct.VArray([ v_uint8() for i in xrange(36) ])
        self.TxFsContext = v_uint32()
        self.GdiTebBatch = GDI_TEB_BATCH32()
        self.RealClientId = CLIENT_ID32()
        self.GdiCachedProcessHandle = v_uint32()
        self.GdiClientPID = v_uint32()
        self.GdiClientTID = v_uint32()
        self.GdiThreadLocalInfo = v_uint32()
        self.Win32ClientInfo = vstruct.VArray([ v_uint32() for i in xrange(62) ])
        self.glDispatchTable = vstruct.VArray([ v_uint32() for i in xrange(233) ])
        self.glReserved1 = vstruct.VArray([ v_uint32() for i in xrange(29) ])
        self.glReserved2 = v_uint32()
        self.glSectionInfo = v_uint32()
        self.glSection = v_uint32()
        self.glTable = v_uint32()
        self.glCurrentRC = v_uint32()
        self.glContext = v_uint32()
        self.LastStatusValue = v_uint32()
        self.StaticUnicodeString = STRING32()
        self.StaticUnicodeBuffer = vstruct.VArray([ v_uint16() for i in xrange(261) ])
        self._pad0e0c = v_bytes(size=2)
        self.DeallocationStack = v_uint32()
        self.TlsSlots = vstruct.VArray([ v_uint32() for i in xrange(64) ])
        self.TlsLinks = LIST_ENTRY32()
        self.Vdm = v_uint32()
        self.ReservedForNtRpc = v_uint32()
        self.DbgSsReserved = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.HardErrorMode = v_uint32()
        self.Instrumentation = vstruct.VArray([ v_uint32() for i in xrange(9) ])
        self.ActivityId = GUID()
        self.SubProcessTag = v_uint32()
        self.EtwLocalData = v_uint32()
        self.EtwTraceData = v_uint32()
        self.WinSockData = v_uint32()
        self.GdiBatchCount = v_uint32()
        self.CurrentIdealProcessor = PROCESSOR_NUMBER()
        self.GuaranteedStackBytes = v_uint32()
        self.ReservedForPerf = v_uint32()
        self.ReservedForOle = v_uint32()
        self.WaitingOnLoaderLock = v_uint32()
        self.SavedPriorityState = v_uint32()
        self.SoftPatchPtr1 = v_uint32()
        self.ThreadPoolData = v_uint32()
        self.TlsExpansionSlots = v_uint32()
        self.MuiGeneration = v_uint32()
        self.IsImpersonating = v_uint32()
        self.NlsCache = v_uint32()
        self.pShimData = v_uint32()
        self.HeapVirtualAffinity = v_uint32()
        self.CurrentTransactionHandle = v_uint32()
        self.ActiveFrame = v_uint32()
        self.FlsData = v_uint32()
        self.PreferredLanguages = v_uint32()
        self.UserPrefLanguages = v_uint32()
        self.MergedPrefLanguages = v_uint32()
        self.MuiImpersonation = v_uint32()
        self.CrossTebFlags = v_uint16()
        self.SameTebFlags = v_uint16()
        self.TxnScopeEnterCallback = v_uint32()
        self.TxnScopeExitCallback = v_uint32()
        self.TxnScopeContext = v_uint32()
        self.LockCount = v_uint32()
        self.SpareUlong0 = v_uint32()
        self.ResourceRetValue = v_uint32()


class PEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InheritedAddressSpace = v_uint8()
        self.ReadImageFileExecOptions = v_uint8()
        self.BeingDebugged = v_uint8()
        self.BitField = v_uint8()
        self.Mutant = v_ptr32()
        self.ImageBaseAddress = v_ptr32()
        self.Ldr = v_ptr32()
        self.ProcessParameters = v_ptr32()
        self.SubSystemData = v_ptr32()
        self.ProcessHeap = v_ptr32()
        self.FastPebLock = v_ptr32()
        self.AtlThunkSListPtr = v_ptr32()
        self.IFEOKey = v_ptr32()
        self.CrossProcessFlags = v_uint32()
        self.KernelCallbackTable = v_ptr32()
        self.SystemReserved = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.AtlThunkSListPtr32 = v_uint32()
        self.ApiSetMap = v_ptr32()
        self.TlsExpansionCounter = v_uint32()
        self.TlsBitmap = v_ptr32()
        self.TlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ReadOnlySharedMemoryBase = v_ptr32()
        self.HotpatchInformation = v_ptr32()
        self.ReadOnlyStaticServerData = v_ptr32()
        self.AnsiCodePageData = v_ptr32()
        self.OemCodePageData = v_ptr32()
        self.UnicodeCaseTableData = v_ptr32()
        self.NumberOfProcessors = v_uint32()
        self.NtGlobalFlag = v_uint32()
        self._pad0070 = v_bytes(size=4)
        self.CriticalSectionTimeout = LARGE_INTEGER()
        self.HeapSegmentReserve = v_uint32()
        self.HeapSegmentCommit = v_uint32()
        self.HeapDeCommitTotalFreeThreshold = v_uint32()
        self.HeapDeCommitFreeBlockThreshold = v_uint32()
        self.NumberOfHeaps = v_uint32()
        self.MaximumNumberOfHeaps = v_uint32()
        self.ProcessHeaps = v_ptr32()
        self.GdiSharedHandleTable = v_ptr32()
        self.ProcessStarterHelper = v_ptr32()
        self.GdiDCAttributeList = v_uint32()
        self.LoaderLock = v_ptr32()
        self.OSMajorVersion = v_uint32()
        self.OSMinorVersion = v_uint32()
        self.OSBuildNumber = v_uint16()
        self.OSCSDVersion = v_uint16()
        self.OSPlatformId = v_uint32()
        self.ImageSubsystem = v_uint32()
        self.ImageSubsystemMajorVersion = v_uint32()
        self.ImageSubsystemMinorVersion = v_uint32()
        self.ActiveProcessAffinityMask = v_uint32()
        self.GdiHandleBuffer = vstruct.VArray([ v_uint32() for i in xrange(34) ])
        self.PostProcessInitRoutine = v_ptr32()
        self.TlsExpansionBitmap = v_ptr32()
        self.TlsExpansionBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(32) ])
        self.SessionId = v_uint32()
        self.AppCompatFlags = ULARGE_INTEGER()
        self.AppCompatFlagsUser = ULARGE_INTEGER()
        self.pShimData = v_ptr32()
        self.AppCompatInfo = v_ptr32()
        self.CSDVersion = UNICODE_STRING()
        self.ActivationContextData = v_ptr32()
        self.ProcessAssemblyStorageMap = v_ptr32()
        self.SystemDefaultActivationContextData = v_ptr32()
        self.SystemAssemblyStorageMap = v_ptr32()
        self.MinimumStackCommit = v_uint32()
        self.FlsCallback = v_ptr32()
        self.FlsListHead = LIST_ENTRY()
        self.FlsBitmap = v_ptr32()
        self.FlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.FlsHighIndex = v_uint32()
        self.WerRegistrationData = v_ptr32()
        self.WerShipAssertPtr = v_ptr32()
        self.pContextData = v_ptr32()
        self.pImageHeaderHash = v_ptr32()
        self.TracingFlags = v_uint32()
        self._pad0248 = v_bytes(size=4)


class DOCK_INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Context = v_ptr32()
        self.InterfaceReference = v_ptr32()
        self.InterfaceDereference = v_ptr32()
        self.ProfileDepartureSetMode = v_ptr32()
        self.ProfileDepartureUpdate = v_ptr32()


class TP_TASK_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteCallback = v_ptr32()
        self.Unposted = v_ptr32()


class RTL_BALANCED_LINKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parent = v_ptr32()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.Balance = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])


class _unnamed_21762(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_ptr32()


class _unnamed_26429(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(3) ])


class DBGKD_ANY_CONTROL_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.X86ControlSet = X86_DBGKD_CONTROL_SET()
        self._pad001c = v_bytes(size=12)


class _unnamed_26426(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumChannel = v_uint32()
        self.MaximumChannel = v_uint32()


class _unnamed_26388(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserData = v_uint32()


class HANDLE_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr32()
        self.GrantedAccess = v_uint32()


class KENLISTMENT_HISTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Notification = v_uint32()
        self.NewState = v_uint32()


class XSTATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint64()
        self.Length = v_uint32()
        self.Reserved1 = v_uint32()
        self.Area = v_ptr32()
        self.Reserved2 = v_uint32()
        self.Buffer = v_ptr32()
        self.Reserved3 = v_uint32()


class _unnamed_26989(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleTime = v_uint32()
        self.NonIdleTime = v_uint32()


class OBJECT_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashBuckets = vstruct.VArray([ v_ptr32() for i in xrange(37) ])
        self.Lock = EX_PUSH_LOCK()
        self.DeviceMap = v_ptr32()
        self.SessionId = v_uint32()
        self.NamespaceEntry = v_ptr32()
        self.Flags = v_uint32()


class MI_SPECIAL_POOL_PTE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FreePteHead = MMPTE()
        self.FreePteTail = MMPTE()


class EX_PUSH_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint32()


class KSTACK_COUNT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Value = v_uint32()


class MI_PAGEFILE_TRACES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.Priority = v_uint8()
        self.IrpPriority = v_uint8()
        self._pad0008 = v_bytes(size=2)
        self.CurrentTime = LARGE_INTEGER()
        self.AvailablePages = v_uint32()
        self.ModifiedPagesTotal = v_uint32()
        self.ModifiedPagefilePages = v_uint32()
        self.ModifiedNoWritePages = v_uint32()
        self.MdlHack = _unnamed_22060()


class PPM_PERF_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Frequency = v_uint32()
        self.Power = v_uint32()
        self.PercentFrequency = v_uint8()
        self.IncreaseLevel = v_uint8()
        self.DecreaseLevel = v_uint8()
        self.Type = v_uint8()
        self._pad0010 = v_bytes(size=4)
        self.Control = v_uint64()
        self.Status = v_uint64()
        self.TotalHitCount = v_uint32()
        self.DesiredCount = v_uint32()


class XSAVE_AREA_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint64()
        self.Reserved = vstruct.VArray([ v_uint64() for i in xrange(7) ])


class HEAP_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.SegmentSignature = v_uint32()
        self.SegmentFlags = v_uint32()
        self.SegmentListEntry = LIST_ENTRY()
        self.Heap = v_ptr32()
        self.BaseAddress = v_ptr32()
        self.NumberOfPages = v_uint32()
        self.FirstEntry = v_ptr32()
        self.LastValidEntry = v_ptr32()
        self.NumberOfUnCommittedPages = v_uint32()
        self.NumberOfUnCommittedRanges = v_uint32()
        self.SegmentAllocatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self.UCRSegmentList = LIST_ENTRY()


class HEAP_FREE_ENTRY_EXTRA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TagIndex = v_uint16()
        self.FreeBackTraceIndex = v_uint16()


class WHEA_ERROR_RECORD_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Revision = WHEA_REVISION()
        self.SignatureEnd = v_uint32()
        self.SectionCount = v_uint16()
        self.Severity = v_uint32()
        self.ValidBits = WHEA_ERROR_RECORD_HEADER_VALIDBITS()
        self.Length = v_uint32()
        self.Timestamp = WHEA_TIMESTAMP()
        self.PlatformId = GUID()
        self.PartitionId = GUID()
        self.CreatorId = GUID()
        self.NotifyType = GUID()
        self.RecordId = v_uint64()
        self.Flags = WHEA_ERROR_RECORD_HEADER_FLAGS()
        self.PersistenceInfo = WHEA_PERSISTENCE_INFO()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(12) ])


class _unnamed_26497(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()


class _unnamed_26496(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint32()


class EVENT_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint16()
        self.Version = v_uint8()
        self.Channel = v_uint8()
        self.Level = v_uint8()
        self.Opcode = v_uint8()
        self.Task = v_uint16()
        self.Keyword = v_uint64()


class PRIVATE_CACHE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NodeTypeCode = v_uint16()
        self._pad0004 = v_bytes(size=2)
        self.ReadAheadMask = v_uint32()
        self.FileObject = v_ptr32()
        self._pad0010 = v_bytes(size=4)
        self.FileOffset1 = LARGE_INTEGER()
        self.BeyondLastByte1 = LARGE_INTEGER()
        self.FileOffset2 = LARGE_INTEGER()
        self.BeyondLastByte2 = LARGE_INTEGER()
        self.SequentialReadCount = v_uint32()
        self.ReadAheadLength = v_uint32()
        self.ReadAheadOffset = LARGE_INTEGER()
        self.ReadAheadBeyondLastByte = LARGE_INTEGER()
        self.ReadAheadSpinLock = v_uint32()
        self.PrivateLinks = LIST_ENTRY()
        self.ReadAheadWorkItem = v_ptr32()


class _unnamed_25830(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceClass = _unnamed_26667()
        self._pad0020 = v_bytes(size=12)


class PSP_CPU_SHARE_CAPTURED_WEIGHT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CapturedCpuShareWeight = v_uint32()
        self.CapturedTotalWeight = v_uint32()


class IMAGE_SECTION_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.Misc = _unnamed_26949()
        self.VirtualAddress = v_uint32()
        self.SizeOfRawData = v_uint32()
        self.PointerToRawData = v_uint32()
        self.PointerToRelocations = v_uint32()
        self.PointerToLinenumbers = v_uint32()
        self.NumberOfRelocations = v_uint16()
        self.NumberOfLinenumbers = v_uint16()
        self.Characteristics = v_uint32()


class PO_DEVICE_NOTIFY_ORDER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.WarmEjectPdoPointer = v_ptr32()
        self.OrderLevel = vstruct.VArray([ PO_NOTIFY_ORDER_LEVEL() for i in xrange(9) ])


class RTL_ATOM_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.CriticalSection = RTL_CRITICAL_SECTION()
        self.RtlHandleTable = RTL_HANDLE_TABLE()
        self.NumberOfBuckets = v_uint32()
        self.Buckets = vstruct.VArray([ v_ptr32() for i in xrange(1) ])


class _unnamed_24190(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24236()


class MMSECURE_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReadOnly = v_uint32()


class DBGKD_WRITE_MEMORY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TargetBaseAddress = v_uint64()
        self.TransferCount = v_uint32()
        self.ActualBytesWritten = v_uint32()


class LIST_ENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint64()
        self.Blink = v_uint64()


class VACB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseAddress = v_ptr32()
        self.SharedCacheMap = v_ptr32()
        self.Overlay = _unnamed_23511()
        self.Links = LIST_ENTRY()
        self.ArrayHead = v_ptr32()
        self._pad0020 = v_bytes(size=4)


class WAIT_CONTEXT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.DeviceRoutine = v_ptr32()
        self.DeviceContext = v_ptr32()
        self.NumberOfMapRegisters = v_uint32()
        self.DeviceObject = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.BufferChainingDpc = v_ptr32()


class CM_KEY_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.Flags = v_uint16()
        self.LastWriteTime = LARGE_INTEGER()
        self.Spare = v_uint32()
        self.Parent = v_uint32()
        self.SubKeyCounts = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.SubKeyLists = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ValueList = CHILD_LIST()
        self.Security = v_uint32()
        self.Class = v_uint32()
        self.MaxNameLen = v_uint32()
        self.MaxClassLen = v_uint32()
        self.MaxValueNameLen = v_uint32()
        self.MaxValueDataLen = v_uint32()
        self.WorkVar = v_uint32()
        self.NameLength = v_uint16()
        self.ClassLength = v_uint16()
        self.Name = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0050 = v_bytes(size=2)


class CM_KEY_VALUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.NameLength = v_uint16()
        self.DataLength = v_uint32()
        self.Data = v_uint32()
        self.Type = v_uint32()
        self.Flags = v_uint16()
        self.Spare = v_uint16()
        self.Name = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0018 = v_bytes(size=2)


class SE_AUDIT_PROCESS_CREATION_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImageFileName = v_ptr32()


class ACTIVATION_CONTEXT_STACK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ActiveFrame = v_ptr32()
        self.FrameListCache = LIST_ENTRY()
        self.Flags = v_uint32()
        self.NextCookieSequenceNumber = v_uint32()
        self.StackId = v_uint32()


class KRESOURCEMANAGER_COMPLETION_BINDING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationListHead = LIST_ENTRY()
        self.Port = v_ptr32()
        self.Key = v_uint32()
        self.BindingProcess = v_ptr32()


class LDR_DATA_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InLoadOrderLinks = LIST_ENTRY()
        self.InMemoryOrderLinks = LIST_ENTRY()
        self.InInitializationOrderLinks = LIST_ENTRY()
        self.DllBase = v_ptr32()
        self.EntryPoint = v_ptr32()
        self.SizeOfImage = v_uint32()
        self.FullDllName = UNICODE_STRING()
        self.BaseDllName = UNICODE_STRING()
        self.Flags = v_uint32()
        self.LoadCount = v_uint16()
        self.TlsIndex = v_uint16()
        self.HashLinks = LIST_ENTRY()
        self.TimeDateStamp = v_uint32()
        self.EntryPointActivationContext = v_ptr32()
        self.PatchInformation = v_ptr32()
        self.ForwarderLinks = LIST_ENTRY()
        self.ServiceTagLinks = LIST_ENTRY()
        self.StaticLinks = LIST_ENTRY()
        self.ContextInformation = v_ptr32()
        self.OriginalBase = v_uint32()
        self.LoadTime = LARGE_INTEGER()


class LOOKASIDE_LIST_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE_POOL()


class TEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.EnvironmentPointer = v_ptr32()
        self.ClientId = CLIENT_ID()
        self.ActiveRpcHandle = v_ptr32()
        self.ThreadLocalStoragePointer = v_ptr32()
        self.ProcessEnvironmentBlock = v_ptr32()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_ptr32()
        self.Win32ThreadInfo = v_ptr32()
        self.User32Reserved = vstruct.VArray([ v_uint32() for i in xrange(26) ])
        self.UserReserved = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self.WOW32Reserved = v_ptr32()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()
        self.SystemReserved1 = vstruct.VArray([ v_ptr32() for i in xrange(54) ])
        self.ExceptionCode = v_uint32()
        self.ActivationContextStackPointer = v_ptr32()
        self.SpareBytes = vstruct.VArray([ v_uint8() for i in xrange(36) ])
        self.TxFsContext = v_uint32()
        self.GdiTebBatch = GDI_TEB_BATCH()
        self.RealClientId = CLIENT_ID()
        self.GdiCachedProcessHandle = v_ptr32()
        self.GdiClientPID = v_uint32()
        self.GdiClientTID = v_uint32()
        self.GdiThreadLocalInfo = v_ptr32()
        self.Win32ClientInfo = vstruct.VArray([ v_uint32() for i in xrange(62) ])
        self.glDispatchTable = vstruct.VArray([ v_ptr32() for i in xrange(233) ])
        self.glReserved1 = vstruct.VArray([ v_uint32() for i in xrange(29) ])
        self.glReserved2 = v_ptr32()
        self.glSectionInfo = v_ptr32()
        self.glSection = v_ptr32()
        self.glTable = v_ptr32()
        self.glCurrentRC = v_ptr32()
        self.glContext = v_ptr32()
        self.LastStatusValue = v_uint32()
        self.StaticUnicodeString = UNICODE_STRING()
        self.StaticUnicodeBuffer = vstruct.VArray([ v_uint16() for i in xrange(261) ])
        self._pad0e0c = v_bytes(size=2)
        self.DeallocationStack = v_ptr32()
        self.TlsSlots = vstruct.VArray([ v_ptr32() for i in xrange(64) ])
        self.TlsLinks = LIST_ENTRY()
        self.Vdm = v_ptr32()
        self.ReservedForNtRpc = v_ptr32()
        self.DbgSsReserved = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self.HardErrorMode = v_uint32()
        self.Instrumentation = vstruct.VArray([ v_ptr32() for i in xrange(9) ])
        self.ActivityId = GUID()
        self.SubProcessTag = v_ptr32()
        self.EtwLocalData = v_ptr32()
        self.EtwTraceData = v_ptr32()
        self.WinSockData = v_ptr32()
        self.GdiBatchCount = v_uint32()
        self.CurrentIdealProcessor = PROCESSOR_NUMBER()
        self.GuaranteedStackBytes = v_uint32()
        self.ReservedForPerf = v_ptr32()
        self.ReservedForOle = v_ptr32()
        self.WaitingOnLoaderLock = v_uint32()
        self.SavedPriorityState = v_ptr32()
        self.SoftPatchPtr1 = v_uint32()
        self.ThreadPoolData = v_ptr32()
        self.TlsExpansionSlots = v_ptr32()
        self.MuiGeneration = v_uint32()
        self.IsImpersonating = v_uint32()
        self.NlsCache = v_ptr32()
        self.pShimData = v_ptr32()
        self.HeapVirtualAffinity = v_uint32()
        self.CurrentTransactionHandle = v_ptr32()
        self.ActiveFrame = v_ptr32()
        self.FlsData = v_ptr32()
        self.PreferredLanguages = v_ptr32()
        self.UserPrefLanguages = v_ptr32()
        self.MergedPrefLanguages = v_ptr32()
        self.MuiImpersonation = v_uint32()
        self.CrossTebFlags = v_uint16()
        self.SameTebFlags = v_uint16()
        self.TxnScopeEnterCallback = v_ptr32()
        self.TxnScopeExitCallback = v_ptr32()
        self.TxnScopeContext = v_ptr32()
        self.LockCount = v_uint32()
        self.SpareUlong0 = v_uint32()
        self.ResourceRetValue = v_ptr32()


class EX_RUNDOWN_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()


class _unnamed_24044(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Internal = v_uint32()


class CM_NOTIFY_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HiveList = LIST_ENTRY()
        self.PostList = LIST_ENTRY()
        self.KeyControlBlock = v_ptr32()
        self.KeyBody = v_ptr32()
        self.Filter = v_uint32()
        self.SubjectContext = SECURITY_SUBJECT_CONTEXT()


class MMPTE_SOFTWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class _unnamed_24041(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24149()


class _unnamed_21963(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags = v_uint32()


class CM_BIG_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint16()
        self.Count = v_uint16()
        self.List = v_uint32()


class VI_POOL_PAGE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextPage = v_ptr32()
        self.VerifierEntry = v_ptr32()
        self.Signature = v_uint32()


class PO_DIAG_STACK_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StackDepth = v_uint32()
        self.Stack = vstruct.VArray([ v_ptr32() for i in xrange(1) ])


class IMAGE_DOS_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e_magic = v_uint16()
        self.e_cblp = v_uint16()
        self.e_cp = v_uint16()
        self.e_crlc = v_uint16()
        self.e_cparhdr = v_uint16()
        self.e_minalloc = v_uint16()
        self.e_maxalloc = v_uint16()
        self.e_ss = v_uint16()
        self.e_sp = v_uint16()
        self.e_csum = v_uint16()
        self.e_ip = v_uint16()
        self.e_cs = v_uint16()
        self.e_lfarlc = v_uint16()
        self.e_ovno = v_uint16()
        self.e_res = vstruct.VArray([ v_uint16() for i in xrange(4) ])
        self.e_oemid = v_uint16()
        self.e_oeminfo = v_uint16()
        self.e_res2 = vstruct.VArray([ v_uint16() for i in xrange(10) ])
        self.e_lfanew = v_uint32()


class _unnamed_27534(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr32()
        self.Argument2 = v_ptr32()
        self.Argument3 = v_ptr32()
        self.Argument4 = v_ptr32()
        self.Argument5 = v_ptr32()


class DBGKD_FILL_MEMORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_uint64()
        self.Length = v_uint32()
        self.Flags = v_uint16()
        self.PatternLength = v_uint16()


class _unnamed_27531(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ResourceToRelease = v_ptr32()


class _unnamed_27530(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EndingOffset = v_ptr32()
        self.ResourceToRelease = v_ptr32()


class _unnamed_27533(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationType = v_uint32()
        self.SafeToRecurse = v_uint8()
        self._pad0008 = v_bytes(size=3)


class _unnamed_27532(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SyncType = v_uint32()
        self.PageProtection = v_uint32()


class TXN_PARAMETER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.TxFsContext = v_uint16()
        self.TransactionObject = v_ptr32()


class ARBITER_ORDERING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint64()
        self.End = v_uint64()


class MMVIEW(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = v_uint32()
        self.Writable = v_uint32()
        self.ViewLinks = LIST_ENTRY()
        self.SessionViewVa = v_ptr32()
        self.SessionId = v_uint32()


class EXCEPTION_RECORD32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_uint32()
        self.ExceptionAddress = v_uint32()
        self.NumberParameters = v_uint32()
        self.ExceptionInformation = vstruct.VArray([ v_uint32() for i in xrange(15) ])


class ETW_GUID_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GuidList = LIST_ENTRY()
        self.RefCount = v_uint32()
        self.Guid = GUID()
        self.RegListHead = LIST_ENTRY()
        self.SecurityDescriptor = v_ptr32()
        self.LastEnable = ETW_LAST_ENABLE_INFO()
        self.ProviderEnableInfo = TRACE_ENABLE_INFO()
        self.EnableInfo = vstruct.VArray([ TRACE_ENABLE_INFO() for i in xrange(8) ])
        self.FilterData = vstruct.VArray([ v_ptr32() for i in xrange(8) ])


class _unnamed_21964(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFlags3 = v_uint32()


class WMI_BUFFER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BufferSize = v_uint32()
        self.SavedOffset = v_uint32()
        self.CurrentOffset = v_uint32()
        self.ReferenceCount = v_uint32()
        self.TimeStamp = LARGE_INTEGER()
        self.SequenceNumber = v_uint64()
        self.Padding0 = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ClientContext = ETW_BUFFER_CONTEXT()
        self.State = v_uint32()
        self.Offset = v_uint32()
        self.BufferFlag = v_uint16()
        self.BufferType = v_uint16()
        self.Padding1 = vstruct.VArray([ v_uint32() for i in xrange(4) ])


class QUAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UseThisFieldToCopy = v_uint64()


class OBJECT_HANDLE_COUNT_DATABASE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CountEntries = v_uint32()
        self.HandleCountEntries = vstruct.VArray([ OBJECT_HANDLE_COUNT_ENTRY() for i in xrange(1) ])


class MMWSLE_HASH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Index = v_uint32()


class VF_KE_CRITICAL_REGION_TRACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Thread = v_ptr32()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(7) ])


class TIME_FIELDS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Year = v_uint16()
        self.Month = v_uint16()
        self.Day = v_uint16()
        self.Hour = v_uint16()
        self.Minute = v_uint16()
        self.Second = v_uint16()
        self.Milliseconds = v_uint16()
        self.Weekday = v_uint16()


class HEAP_TUNING_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CommittThresholdShift = v_uint32()
        self.MaxPreCommittThreshold = v_uint32()


class LPCP_PORT_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ConnectionPort = v_ptr32()
        self.ConnectedPort = v_ptr32()
        self.MsgQueue = LPCP_PORT_QUEUE()
        self.Creator = CLIENT_ID()
        self.ClientSectionBase = v_ptr32()
        self.ServerSectionBase = v_ptr32()
        self.PortContext = v_ptr32()
        self.ClientThread = v_ptr32()
        self.SecurityQos = SECURITY_QUALITY_OF_SERVICE()
        self.StaticSecurity = SECURITY_CLIENT_CONTEXT()
        self.LpcReplyChainHead = LIST_ENTRY()
        self.LpcDataInfoChainHead = LIST_ENTRY()
        self.ServerProcess = v_ptr32()
        self.MaxMessageLength = v_uint16()
        self.MaxConnectionInfoLength = v_uint16()
        self.Flags = v_uint32()
        self.WaitEvent = KEVENT()


class SEGMENT_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalNumberOfPtes4132 = v_uint32()


class CALL_PERFORMANCE_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SpinLock = v_uint32()
        self.HashTable = vstruct.VArray([ LIST_ENTRY() for i in xrange(64) ])


class KPRCB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinorVersion = v_uint16()
        self.MajorVersion = v_uint16()
        self.CurrentThread = v_ptr32()
        self.NextThread = v_ptr32()
        self.IdleThread = v_ptr32()
        self.LegacyNumber = v_uint8()
        self.NestingLevel = v_uint8()
        self.BuildType = v_uint16()
        self.CpuType = v_uint8()
        self.CpuID = v_uint8()
        self.CpuStep = v_uint16()
        self.ProcessorState = KPROCESSOR_STATE()
        self.KernelReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.HalReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.CFlushSize = v_uint32()
        self.CoresPerPhysicalProcessor = v_uint8()
        self.LogicalProcessorsPerCore = v_uint8()
        self.PrcbPad0 = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.MHz = v_uint32()
        self.CpuVendor = v_uint8()
        self.GroupIndex = v_uint8()
        self.Group = v_uint16()
        self.GroupSetMember = v_uint32()
        self.Number = v_uint32()
        self.PrcbPad1 = vstruct.VArray([ v_uint8() for i in xrange(72) ])
        self.LockQueue = vstruct.VArray([ KSPIN_LOCK_QUEUE() for i in xrange(17) ])
        self.NpxThread = v_ptr32()
        self.InterruptCount = v_uint32()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.DpcTime = v_uint32()
        self.DpcTimeCount = v_uint32()
        self.InterruptTime = v_uint32()
        self.AdjustDpcThreshold = v_uint32()
        self.PageColor = v_uint32()
        self.DebuggerSavedIRQL = v_uint8()
        self.NodeColor = v_uint8()
        self.PrcbPad20 = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.NodeShiftedColor = v_uint32()
        self.ParentNode = v_ptr32()
        self.SecondaryColorMask = v_uint32()
        self.DpcTimeLimit = v_uint32()
        self.PrcbPad21 = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.CcFastReadNoWait = v_uint32()
        self.CcFastReadWait = v_uint32()
        self.CcFastReadNotPossible = v_uint32()
        self.CcCopyReadNoWait = v_uint32()
        self.CcCopyReadWait = v_uint32()
        self.CcCopyReadNoWaitMiss = v_uint32()
        self.MmSpinLockOrdering = v_uint32()
        self.IoReadOperationCount = v_uint32()
        self.IoWriteOperationCount = v_uint32()
        self.IoOtherOperationCount = v_uint32()
        self.IoReadTransferCount = LARGE_INTEGER()
        self.IoWriteTransferCount = LARGE_INTEGER()
        self.IoOtherTransferCount = LARGE_INTEGER()
        self.CcFastMdlReadNoWait = v_uint32()
        self.CcFastMdlReadWait = v_uint32()
        self.CcFastMdlReadNotPossible = v_uint32()
        self.CcMapDataNoWait = v_uint32()
        self.CcMapDataWait = v_uint32()
        self.CcPinMappedDataCount = v_uint32()
        self.CcPinReadNoWait = v_uint32()
        self.CcPinReadWait = v_uint32()
        self.CcMdlReadNoWait = v_uint32()
        self.CcMdlReadWait = v_uint32()
        self.CcLazyWriteHotSpots = v_uint32()
        self.CcLazyWriteIos = v_uint32()
        self.CcLazyWritePages = v_uint32()
        self.CcDataFlushes = v_uint32()
        self.CcDataPages = v_uint32()
        self.CcLostDelayedWrites = v_uint32()
        self.CcFastReadResourceMiss = v_uint32()
        self.CcCopyReadWaitMiss = v_uint32()
        self.CcFastMdlReadResourceMiss = v_uint32()
        self.CcMapDataNoWaitMiss = v_uint32()
        self.CcMapDataWaitMiss = v_uint32()
        self.CcPinReadNoWaitMiss = v_uint32()
        self.CcPinReadWaitMiss = v_uint32()
        self.CcMdlReadNoWaitMiss = v_uint32()
        self.CcMdlReadWaitMiss = v_uint32()
        self.CcReadAheadIos = v_uint32()
        self.KeAlignmentFixupCount = v_uint32()
        self.KeExceptionDispatchCount = v_uint32()
        self.KeSystemCalls = v_uint32()
        self.AvailableTime = v_uint32()
        self.PrcbPad22 = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.PPLookasideList = vstruct.VArray([ PP_LOOKASIDE_LIST() for i in xrange(16) ])
        self.PPNPagedLookasideList = vstruct.VArray([ GENERAL_LOOKASIDE_POOL() for i in xrange(32) ])
        self.PPPagedLookasideList = vstruct.VArray([ GENERAL_LOOKASIDE_POOL() for i in xrange(32) ])
        self.PacketBarrier = v_uint32()
        self.ReverseStall = v_uint32()
        self.IpiFrame = v_ptr32()
        self.PrcbPad3 = vstruct.VArray([ v_uint8() for i in xrange(52) ])
        self.CurrentPacket = vstruct.VArray([ v_ptr32() for i in xrange(3) ])
        self.TargetSet = v_uint32()
        self.WorkerRoutine = v_ptr32()
        self.IpiFrozen = v_uint32()
        self.PrcbPad4 = vstruct.VArray([ v_uint8() for i in xrange(40) ])
        self.RequestSummary = v_uint32()
        self.SignalDone = v_ptr32()
        self.PrcbPad50 = vstruct.VArray([ v_uint8() for i in xrange(56) ])
        self.DpcData = vstruct.VArray([ KDPC_DATA() for i in xrange(2) ])
        self.DpcStack = v_ptr32()
        self.MaximumDpcQueueDepth = v_uint32()
        self.DpcRequestRate = v_uint32()
        self.MinimumDpcRate = v_uint32()
        self.DpcLastCount = v_uint32()
        self.PrcbLock = v_uint32()
        self.DpcGate = KGATE()
        self.ThreadDpcEnable = v_uint8()
        self.QuantumEnd = v_uint8()
        self.DpcRoutineActive = v_uint8()
        self.IdleSchedule = v_uint8()
        self.DpcRequestSummary = v_uint32()
        self.TimerHand = v_uint32()
        self.LastTick = v_uint32()
        self.MasterOffset = v_uint32()
        self.PrcbPad41 = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.PeriodicCount = v_uint32()
        self.PeriodicBias = v_uint32()
        self._pad1958 = v_bytes(size=4)
        self.TickOffset = v_uint64()
        self.TimerTable = KTIMER_TABLE()
        self.CallDpc = KDPC()
        self.ClockKeepAlive = v_uint32()
        self.ClockCheckSlot = v_uint8()
        self.ClockPollCycle = v_uint8()
        self.PrcbPad6 = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.DpcWatchdogPeriod = v_uint32()
        self.DpcWatchdogCount = v_uint32()
        self.ThreadWatchdogPeriod = v_uint32()
        self.ThreadWatchdogCount = v_uint32()
        self.KeSpinLockOrdering = v_uint32()
        self.PrcbPad70 = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.WaitListHead = LIST_ENTRY()
        self.WaitLock = v_uint32()
        self.ReadySummary = v_uint32()
        self.QueueIndex = v_uint32()
        self.DeferredReadyListHead = SINGLE_LIST_ENTRY()
        self.StartCycles = v_uint64()
        self.CycleTime = v_uint64()
        self.HighCycleTime = v_uint32()
        self.PrcbPad71 = v_uint32()
        self.PrcbPad72 = vstruct.VArray([ v_uint64() for i in xrange(2) ])
        self.DispatcherReadyListHead = vstruct.VArray([ LIST_ENTRY() for i in xrange(32) ])
        self.ChainedInterruptList = v_ptr32()
        self.LookasideIrpFloat = v_uint32()
        self.MmPageFaultCount = v_uint32()
        self.MmCopyOnWriteCount = v_uint32()
        self.MmTransitionCount = v_uint32()
        self.MmCacheTransitionCount = v_uint32()
        self.MmDemandZeroCount = v_uint32()
        self.MmPageReadCount = v_uint32()
        self.MmPageReadIoCount = v_uint32()
        self.MmCacheReadCount = v_uint32()
        self.MmCacheIoCount = v_uint32()
        self.MmDirtyPagesWriteCount = v_uint32()
        self.MmDirtyWriteIoCount = v_uint32()
        self.MmMappedPagesWriteCount = v_uint32()
        self.MmMappedWriteIoCount = v_uint32()
        self.CachedCommit = v_uint32()
        self.CachedResidentAvailable = v_uint32()
        self.HyperPte = v_ptr32()
        self.PrcbPad8 = vstruct.VArray([ v_uint8() for i in xrange(4) ])
        self.VendorString = vstruct.VArray([ v_uint8() for i in xrange(13) ])
        self.InitialApicId = v_uint8()
        self.LogicalProcessorsPerPhysicalProcessor = v_uint8()
        self.PrcbPad9 = vstruct.VArray([ v_uint8() for i in xrange(5) ])
        self.FeatureBits = v_uint32()
        self._pad3388 = v_bytes(size=4)
        self.UpdateSignature = LARGE_INTEGER()
        self.IsrTime = v_uint64()
        self.RuntimeAccumulation = v_uint64()
        self.PowerState = PROCESSOR_POWER_STATE()
        self.DpcWatchdogDpc = KDPC()
        self.DpcWatchdogTimer = KTIMER()
        self.WheaInfo = v_ptr32()
        self.EtwSupport = v_ptr32()
        self.InterruptObjectPool = SLIST_HEADER()
        self.HypercallPageList = SLIST_HEADER()
        self.HypercallPageVirtual = v_ptr32()
        self.VirtualApicAssist = v_ptr32()
        self.StatisticsPage = v_ptr32()
        self.RateControl = v_ptr32()
        self.Cache = vstruct.VArray([ CACHE_DESCRIPTOR() for i in xrange(5) ])
        self.CacheCount = v_uint32()
        self.CacheProcessorMask = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self.PackageProcessorSet = KAFFINITY_EX()
        self.PrcbPad91 = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.CoreProcessorSet = v_uint32()
        self.TimerExpirationDpc = KDPC()
        self.SpinLockAcquireCount = v_uint32()
        self.SpinLockContentionCount = v_uint32()
        self.SpinLockSpinCount = v_uint32()
        self.IpiSendRequestBroadcastCount = v_uint32()
        self.IpiSendRequestRoutineCount = v_uint32()
        self.IpiSendSoftwareInterruptCount = v_uint32()
        self.ExInitializeResourceCount = v_uint32()
        self.ExReInitializeResourceCount = v_uint32()
        self.ExDeleteResourceCount = v_uint32()
        self.ExecutiveResourceAcquiresCount = v_uint32()
        self.ExecutiveResourceContentionsCount = v_uint32()
        self.ExecutiveResourceReleaseExclusiveCount = v_uint32()
        self.ExecutiveResourceReleaseSharedCount = v_uint32()
        self.ExecutiveResourceConvertsCount = v_uint32()
        self.ExAcqResExclusiveAttempts = v_uint32()
        self.ExAcqResExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResExclusiveAcquiresExclusiveRecursive = v_uint32()
        self.ExAcqResExclusiveWaits = v_uint32()
        self.ExAcqResExclusiveNotAcquires = v_uint32()
        self.ExAcqResSharedAttempts = v_uint32()
        self.ExAcqResSharedAcquiresExclusive = v_uint32()
        self.ExAcqResSharedAcquiresShared = v_uint32()
        self.ExAcqResSharedAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedWaits = v_uint32()
        self.ExAcqResSharedNotAcquires = v_uint32()
        self.ExAcqResSharedStarveExclusiveAttempts = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresShared = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedStarveExclusiveWaits = v_uint32()
        self.ExAcqResSharedStarveExclusiveNotAcquires = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAttempts = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresShared = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedWaitForExclusiveWaits = v_uint32()
        self.ExAcqResSharedWaitForExclusiveNotAcquires = v_uint32()
        self.ExSetResOwnerPointerExclusive = v_uint32()
        self.ExSetResOwnerPointerSharedNew = v_uint32()
        self.ExSetResOwnerPointerSharedOld = v_uint32()
        self.ExTryToAcqExclusiveAttempts = v_uint32()
        self.ExTryToAcqExclusiveAcquires = v_uint32()
        self.ExBoostExclusiveOwner = v_uint32()
        self.ExBoostSharedOwners = v_uint32()
        self.ExEtwSynchTrackingNotificationsCount = v_uint32()
        self.ExEtwSynchTrackingNotificationsAccountedCount = v_uint32()
        self.Context = v_ptr32()
        self.ContextFlags = v_uint32()
        self.ExtendedState = v_ptr32()
        self._pad3628 = v_bytes(size=4)


class EXCEPTION_POINTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionRecord = v_ptr32()
        self.ContextRecord = v_ptr32()


class PPM_FFH_THROTTLE_STATE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnableLogging = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.MismatchCount = v_uint32()
        self.Initialized = v_uint8()
        self._pad0010 = v_bytes(size=7)
        self.LastValue = v_uint64()
        self.LastLogTickCount = LARGE_INTEGER()


class RTL_DYNAMIC_HASH_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.Shift = v_uint32()
        self.TableSize = v_uint32()
        self.Pivot = v_uint32()
        self.DivisorMask = v_uint32()
        self.NumEntries = v_uint32()
        self.NonEmptyBuckets = v_uint32()
        self.NumEnumerators = v_uint32()
        self.Directory = v_ptr32()


class CM_KEY_SECURITY_CACHE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cell = v_uint32()
        self.ConvKey = v_uint32()
        self.List = LIST_ENTRY()
        self.DescriptorLength = v_uint32()
        self.RealRefCount = v_uint32()
        self.Descriptor = SECURITY_DESCRIPTOR_RELATIVE()


class _unnamed_21669(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ReferenceCount = v_uint16()
        self.e1 = MMPFNENTRY()


class POP_TRIGGER_WAIT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Event = KEVENT()
        self.Status = v_uint32()
        self.Link = LIST_ENTRY()
        self.Trigger = v_ptr32()


class KAFFINITY_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint16()
        self.Size = v_uint16()
        self.Reserved = v_uint32()
        self.Bitmap = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class ETW_WMITRACE_WORK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LoggerId = v_uint32()
        self._pad0008 = v_bytes(size=4)
        self.LoggerName = vstruct.VArray([ v_uint8() for i in xrange(65) ])
        self.FileName = vstruct.VArray([ v_uint8() for i in xrange(129) ])
        self._pad00cc = v_bytes(size=2)
        self.MaximumFileSize = v_uint32()
        self.MinBuffers = v_uint32()
        self.MaxBuffers = v_uint32()
        self.BufferSize = v_uint32()
        self.Mode = v_uint32()
        self.FlushTimer = v_uint32()
        self._pad00e8 = v_bytes(size=4)
        self.Status = v_uint32()
        self._pad00f0 = v_bytes(size=4)


class DEVICE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.ReferenceCount = v_uint32()
        self.DriverObject = v_ptr32()
        self.NextDevice = v_ptr32()
        self.AttachedDevice = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.Timer = v_ptr32()
        self.Flags = v_uint32()
        self.Characteristics = v_uint32()
        self.Vpb = v_ptr32()
        self.DeviceExtension = v_ptr32()
        self.DeviceType = v_uint32()
        self.StackSize = v_uint8()
        self._pad0034 = v_bytes(size=3)
        self.Queue = _unnamed_20200()
        self.AlignmentRequirement = v_uint32()
        self.DeviceQueue = KDEVICE_QUEUE()
        self.Dpc = KDPC()
        self.ActiveThreadCount = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.DeviceLock = KEVENT()
        self.SectorSize = v_uint16()
        self.Spare1 = v_uint16()
        self.DeviceObjectExtension = v_ptr32()
        self.Reserved = v_ptr32()


class _unnamed_21667(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Blink = v_uint32()


class _unnamed_24294(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.s1 = _unnamed_24296()


class _unnamed_24296(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revoked = v_uint32()


class CM_NAME_HASH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ConvKey = v_uint32()
        self.NextHash = v_ptr32()
        self.NameLength = v_uint16()
        self.Name = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class EX_PUSH_LOCK_WAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WakeEvent = KEVENT()
        self.Next = v_ptr32()
        self.Last = v_ptr32()
        self.Previous = v_ptr32()
        self.ShareCount = v_uint32()
        self.Flags = v_uint32()
        self._pad0030 = v_bytes(size=12)


class KALPC_HANDLE_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.ObjectType = v_uint32()
        self.DuplicateContext = v_ptr32()


class KERNEL_STACK_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StackBase = v_uint32()
        self.StackLimit = v_uint32()
        self.KernelStack = v_uint32()
        self.InitialStack = v_uint32()
        self.ActualLimit = v_uint32()


class CM_CACHED_VALUE_INDEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CellIndex = v_uint32()
        self.Data = _unnamed_26962()


class HIVE_LOAD_FAILURE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Hive = v_ptr32()
        self.Index = v_uint32()
        self.RecoverableIndex = v_uint32()
        self.Locations = vstruct.VArray([ _unnamed_22432() for i in xrange(8) ])
        self.RecoverableLocations = vstruct.VArray([ _unnamed_22432() for i in xrange(8) ])
        self.RegistryIO = _unnamed_22433()
        self.CheckRegistry2 = _unnamed_22434()
        self.CheckKey = _unnamed_22435()
        self.CheckValueList = _unnamed_22436()
        self.CheckHive = _unnamed_22437()
        self.CheckHive1 = _unnamed_22437()
        self.CheckBin = _unnamed_22438()
        self.RecoverData = _unnamed_22439()


class PCW_BUFFER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class EX_QUEUE_WORKER_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.QueueDisabled = v_uint32()


class _unnamed_22437(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Space = v_uint32()
        self.MapPoint = v_uint32()
        self.BinPoint = v_ptr32()


class _unnamed_22436(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.List = v_ptr32()
        self.Index = v_uint32()
        self.Cell = v_uint32()
        self.CellPoint = v_ptr32()


class _unnamed_22435(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cell = v_uint32()
        self.CellPoint = v_ptr32()
        self.RootPoint = v_ptr32()
        self.Index = v_uint32()


class PCW_COUNTER_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CounterMask = v_uint64()
        self.InstanceMask = v_ptr32()
        self._pad0010 = v_bytes(size=4)


class _unnamed_22433(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Action = v_uint32()
        self.Handle = v_ptr32()
        self.Status = v_uint32()


class _unnamed_22432(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Failure = v_uint32()
        self.Status = v_uint32()
        self.Point = v_uint32()


class DUMMY_FILE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ObjectHeader = OBJECT_HEADER()
        self.FileObjectBody = vstruct.VArray([ v_uint8() for i in xrange(128) ])


class MI_SECTION_IMAGE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExportedImageInformation = SECTION_IMAGE_INFORMATION()
        self.InternalImageInformation = MI_EXTRA_IMAGE_INFORMATION()


class _unnamed_22439(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FileOffset = v_uint32()


class _unnamed_22438(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Bin = v_ptr32()
        self.CellPoint = v_ptr32()


class VF_BTS_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.JumpedFrom = v_ptr32()
        self.JumpedTo = v_ptr32()
        self.Unused1 = v_uint32()


class DBGKD_WRITE_BREAKPOINT32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BreakPointAddress = v_uint32()
        self.BreakPointHandle = v_uint32()


class IMAGE_NT_HEADERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.FileHeader = IMAGE_FILE_HEADER()
        self.OptionalHeader = IMAGE_OPTIONAL_HEADER()


class PHYSICAL_MEMORY_RUN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BasePage = v_uint32()
        self.PageCount = v_uint32()


class MM_SESSION_SPACE_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Initialized = v_uint32()


class ETW_REPLY_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Queue = KQUEUE()
        self.EventsLost = v_uint32()


class OBJECT_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TypeList = LIST_ENTRY()
        self.Name = UNICODE_STRING()
        self.DefaultObject = v_ptr32()
        self.Index = v_uint8()
        self._pad0018 = v_bytes(size=3)
        self.TotalNumberOfObjects = v_uint32()
        self.TotalNumberOfHandles = v_uint32()
        self.HighWaterNumberOfObjects = v_uint32()
        self.HighWaterNumberOfHandles = v_uint32()
        self.TypeInfo = OBJECT_TYPE_INITIALIZER()
        self.TypeLock = EX_PUSH_LOCK()
        self.Key = v_uint32()
        self.CallbackList = LIST_ENTRY()


class ALPC_MESSAGE_ZONE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mdl = v_ptr32()
        self.UserVa = v_ptr32()
        self.UserLimit = v_ptr32()
        self.SystemVa = v_ptr32()
        self.SystemLimit = v_ptr32()
        self.Size = v_uint32()


class KNODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PagedPoolSListHead = SLIST_HEADER()
        self.NonPagedPoolSListHead = vstruct.VArray([ SLIST_HEADER() for i in xrange(3) ])
        self.Affinity = GROUP_AFFINITY()
        self.ProximityId = v_uint32()
        self.NodeNumber = v_uint16()
        self.PrimaryNodeNumber = v_uint16()
        self.MaximumProcessors = v_uint8()
        self.Color = v_uint8()
        self.Flags = flags()
        self.NodePad0 = v_uint8()
        self.Seed = v_uint32()
        self.MmShiftedColor = v_uint32()
        self.FreeCount = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.CachedKernelStacks = CACHED_KSTACK_LIST()
        self.ParkLock = v_uint32()
        self.NodePad1 = v_uint32()
        self._pad0080 = v_bytes(size=24)


class PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(1) ])


class ALPC_HANDLE_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Handles = v_ptr32()
        self.TotalHandles = v_uint32()
        self.Flags = v_uint32()
        self.Lock = EX_PUSH_LOCK()


class CM_KEY_HASH_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = EX_PUSH_LOCK()
        self.Owner = v_ptr32()
        self.Entry = v_ptr32()


class IO_WORKITEM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkItem = WORK_QUEUE_ITEM()
        self.Routine = v_ptr32()
        self.IoObject = v_ptr32()
        self.Context = v_ptr32()
        self.Type = v_uint32()


class NLS_DATA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AnsiCodePageData = v_ptr32()
        self.OemCodePageData = v_ptr32()
        self.UnicodeCaseTableData = v_ptr32()


class SYSTEM_POWER_CAPABILITIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerButtonPresent = v_uint8()
        self.SleepButtonPresent = v_uint8()
        self.LidPresent = v_uint8()
        self.SystemS1 = v_uint8()
        self.SystemS2 = v_uint8()
        self.SystemS3 = v_uint8()
        self.SystemS4 = v_uint8()
        self.SystemS5 = v_uint8()
        self.HiberFilePresent = v_uint8()
        self.FullWake = v_uint8()
        self.VideoDimPresent = v_uint8()
        self.ApmPresent = v_uint8()
        self.UpsPresent = v_uint8()
        self.ThermalControl = v_uint8()
        self.ProcessorThrottle = v_uint8()
        self.ProcessorMinThrottle = v_uint8()
        self.ProcessorMaxThrottle = v_uint8()
        self.FastSystemS4 = v_uint8()
        self.spare2 = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.DiskSpinDown = v_uint8()
        self.spare3 = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.SystemBatteriesPresent = v_uint8()
        self.BatteriesAreShortTerm = v_uint8()
        self.BatteryScale = vstruct.VArray([ BATTERY_REPORTING_SCALE() for i in xrange(3) ])
        self.AcOnLineWake = v_uint32()
        self.SoftLidWake = v_uint32()
        self.RtcWake = v_uint32()
        self.MinDeviceWakeState = v_uint32()
        self.DefaultLowLatencyWake = v_uint32()


class THERMAL_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ThermalStamp = v_uint32()
        self.ThermalConstant1 = v_uint32()
        self.ThermalConstant2 = v_uint32()
        self.Processors = v_uint32()
        self.SamplingPeriod = v_uint32()
        self.CurrentTemperature = v_uint32()
        self.PassiveTripPoint = v_uint32()
        self.CriticalTripPoint = v_uint32()
        self.ActiveTripPointCount = v_uint8()
        self._pad0024 = v_bytes(size=3)
        self.ActiveTripPoint = vstruct.VArray([ v_uint32() for i in xrange(10) ])


class MMEXTEND_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CommittedSize = v_uint64()
        self.ReferenceCount = v_uint32()
        self._pad0010 = v_bytes(size=4)


class VF_TARGET_ALL_SHARED_EXPORT_THUNKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SharedExportThunks = v_ptr32()
        self.PoolSharedExportThunks = v_ptr32()
        self.OrderDependentSharedExportThunks = v_ptr32()


class RTL_USER_PROCESS_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MaximumLength = v_uint32()
        self.Length = v_uint32()
        self.Flags = v_uint32()
        self.DebugFlags = v_uint32()
        self.ConsoleHandle = v_ptr32()
        self.ConsoleFlags = v_uint32()
        self.StandardInput = v_ptr32()
        self.StandardOutput = v_ptr32()
        self.StandardError = v_ptr32()
        self.CurrentDirectory = CURDIR()
        self.DllPath = UNICODE_STRING()
        self.ImagePathName = UNICODE_STRING()
        self.CommandLine = UNICODE_STRING()
        self.Environment = v_ptr32()
        self.StartingX = v_uint32()
        self.StartingY = v_uint32()
        self.CountX = v_uint32()
        self.CountY = v_uint32()
        self.CountCharsX = v_uint32()
        self.CountCharsY = v_uint32()
        self.FillAttribute = v_uint32()
        self.WindowFlags = v_uint32()
        self.ShowWindowFlags = v_uint32()
        self.WindowTitle = UNICODE_STRING()
        self.DesktopInfo = UNICODE_STRING()
        self.ShellInfo = UNICODE_STRING()
        self.RuntimeData = UNICODE_STRING()
        self.CurrentDirectores = vstruct.VArray([ RTL_DRIVE_LETTER_CURDIR() for i in xrange(32) ])
        self.EnvironmentSize = v_uint32()
        self.EnvironmentVersion = v_uint32()


class _unnamed_20823(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()


class HEADLESS_LOADER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UsedBiosSettings = v_uint8()
        self.DataBits = v_uint8()
        self.StopBits = v_uint8()
        self.Parity = v_uint8()
        self.BaudRate = v_uint32()
        self.PortNumber = v_uint32()
        self.PortAddress = v_ptr32()
        self.PciDeviceId = v_uint16()
        self.PciVendorId = v_uint16()
        self.PciBusNumber = v_uint8()
        self._pad0016 = v_bytes(size=1)
        self.PciBusSegment = v_uint16()
        self.PciSlotNumber = v_uint8()
        self.PciFunctionNumber = v_uint8()
        self._pad001c = v_bytes(size=2)
        self.PciFlags = v_uint32()
        self.SystemGUID = GUID()
        self.IsMMIODevice = v_uint8()
        self.TerminalType = v_uint8()
        self._pad0034 = v_bytes(size=2)


class _unnamed_20984(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceTextType = v_uint32()
        self.LocaleId = v_uint32()


class ALPC_COMPLETION_LIST_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartMagic = v_uint64()
        self.TotalSize = v_uint32()
        self.ListOffset = v_uint32()
        self.ListSize = v_uint32()
        self.BitmapOffset = v_uint32()
        self.BitmapSize = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSize = v_uint32()
        self.AttributeFlags = v_uint32()
        self.AttributeSize = v_uint32()
        self._pad0080 = v_bytes(size=84)
        self.State = ALPC_COMPLETION_LIST_STATE()
        self.LastMessageId = v_uint32()
        self.LastCallbackId = v_uint32()
        self._pad0100 = v_bytes(size=112)
        self.PostCount = v_uint32()
        self._pad0180 = v_bytes(size=124)
        self.ReturnCount = v_uint32()
        self._pad0200 = v_bytes(size=124)
        self.LogSequenceNumber = v_uint32()
        self._pad0280 = v_bytes(size=124)
        self.UserLock = RTL_SRWLOCK()
        self._pad0288 = v_bytes(size=4)
        self.EndMagic = v_uint64()
        self._pad0300 = v_bytes(size=112)


class _unnamed_25069(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FilePointerIndex = v_uint32()


class u(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.KeyNode = CM_KEY_NODE()


class VI_FAULT_TRACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Thread = v_ptr32()
        self.StackTrace = vstruct.VArray([ v_ptr32() for i in xrange(8) ])


class IO_RESOURCE_REQUIREMENTS_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.SlotNumber = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.AlternativeLists = v_uint32()
        self.List = vstruct.VArray([ IO_RESOURCE_LIST() for i in xrange(1) ])


class VF_WATCHDOG_IRP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.Irp = v_ptr32()
        self.DueTickCount = v_uint32()
        self.Inserted = v_uint8()
        self.TrackedStackLocation = v_uint8()
        self.CancelTimeoutTicks = v_uint16()


class _unnamed_26614(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SnapSharedExportsFailed = v_uint32()


class MMWSLE_NONDIRECT_HASH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Key = v_ptr32()
        self.Index = v_uint32()


class RTL_ATOM_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashLink = v_ptr32()
        self.HandleIndex = v_uint16()
        self.Atom = v_uint16()
        self.ReferenceCount = v_uint16()
        self.Flags = v_uint8()
        self.NameLength = v_uint8()
        self.Name = vstruct.VArray([ v_uint16() for i in xrange(1) ])
        self._pad0010 = v_bytes(size=2)


class POOL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousSize = v_uint16()
        self.BlockSize = v_uint16()
        self.PoolTag = v_uint32()




########NEW FILE########
__FILENAME__ = win32k
# Version: 6.1
# Architecture: i386
import vstruct
from vstruct.primitives import *

ETW_THREAD_FLAG = v_enum()
ETW_THREAD_FLAG.ETW_THREAD_FLAG_HAD_INPUT = 0
ETW_THREAD_FLAG.ETW_THREAD_FLAG_HAD_VISIBLE_WINDOWS = 1
ETW_THREAD_FLAG.ETW_THREAD_FLAG_HAS_NEW_INPUT = 2
ETW_THREAD_FLAG.ETW_THREAD_FLAG_MAX = 3


TOUCHSTATE = v_enum()
TOUCHSTATE.TOUCHSTATE_INVALID = -1
TOUCHSTATE.TOUCHSTATE_NONE = 0
TOUCHSTATE.TOUCHSTATE_DOWN = 1
TOUCHSTATE.TOUCHSTATE_MOVE = 2
TOUCHSTATE.TOUCHSTATE_UPOUTOFRANGE = 3
TOUCHSTATE.TOUCHSTATE_INAIR = 4
TOUCHSTATE.TOUCHSTATE_INAIRMOVE = 5
TOUCHSTATE.TOUCHSTATE_INAIROUTOFRANGE = 6
TOUCHSTATE.TOUCHSTATE_COUNT = 7


WHEA_ERROR_SEVERITY = v_enum()
WHEA_ERROR_SEVERITY.WheaErrSevRecoverable = 0
WHEA_ERROR_SEVERITY.WheaErrSevFatal = 1
WHEA_ERROR_SEVERITY.WheaErrSevCorrected = 2
WHEA_ERROR_SEVERITY.WheaErrSevInformational = 3


D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED = v_enum()
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_UNINITIALIZED = 0
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_HD15 = 1
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_DVI = 2
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_HDMI = 3
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_HDMI2 = 4
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_SVIDEO_4PIN = 5
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_SVIDEO_7PIN = 6
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_RCA_COMPOSITE = 7
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_RCA_3COMPONENT = 8
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_BNC = 9
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_RF = 10
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_SDTVDONGLE = 11
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_INTERNAL = 12
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY_DEPRECATED.D3DKMDT_VOT_DEPRECATED_OTHER = 255


SM_STORAGE_MODIFIER = v_enum()
SM_STORAGE_MODIFIER.SmStorageActual = 0
SM_STORAGE_MODIFIER.SmStorageNonActual = 1


DMM_MONITOR_PRESENCE_EVENT_TYPE = v_enum()
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_UNINITIALIZED = 0
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_ADDMONITOR = 1
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_REMOVEMONITOR = 2
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_DRIVERARRIVAL = 3
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_DRIVERQUERYREMOVE = 4
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_DRIVERREMOVECANCELLED = 5
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_DRIVERREMOVECOMPLETE = 6
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_DEVICENODEREADY = 7
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_EDIDCHANGE = 8
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_MONITORDISABLE = 9
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_MONITORENABLE = 10
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_ADAPTERADD = 11
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_ADAPTERREMOVAL = 12
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_INVALIDATION = 13
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_ADDSIMULATEDMONITOR = 1073741825
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_REMOVESIMULATEDMONITOR = 1073741826
DMM_MONITOR_PRESENCE_EVENT_TYPE.DMM_MPET_MAXVALID = 1073741826


REG_NOTIFY_CLASS = v_enum()
REG_NOTIFY_CLASS.RegNtDeleteKey = 0
REG_NOTIFY_CLASS.RegNtPreDeleteKey = 0
REG_NOTIFY_CLASS.RegNtSetValueKey = 1
REG_NOTIFY_CLASS.RegNtPreSetValueKey = 1
REG_NOTIFY_CLASS.RegNtDeleteValueKey = 2
REG_NOTIFY_CLASS.RegNtPreDeleteValueKey = 2
REG_NOTIFY_CLASS.RegNtSetInformationKey = 3
REG_NOTIFY_CLASS.RegNtPreSetInformationKey = 3
REG_NOTIFY_CLASS.RegNtRenameKey = 4
REG_NOTIFY_CLASS.RegNtPreRenameKey = 4
REG_NOTIFY_CLASS.RegNtEnumerateKey = 5
REG_NOTIFY_CLASS.RegNtPreEnumerateKey = 5
REG_NOTIFY_CLASS.RegNtEnumerateValueKey = 6
REG_NOTIFY_CLASS.RegNtPreEnumerateValueKey = 6
REG_NOTIFY_CLASS.RegNtQueryKey = 7
REG_NOTIFY_CLASS.RegNtPreQueryKey = 7
REG_NOTIFY_CLASS.RegNtQueryValueKey = 8
REG_NOTIFY_CLASS.RegNtPreQueryValueKey = 8
REG_NOTIFY_CLASS.RegNtQueryMultipleValueKey = 9
REG_NOTIFY_CLASS.RegNtPreQueryMultipleValueKey = 9
REG_NOTIFY_CLASS.RegNtPreCreateKey = 10
REG_NOTIFY_CLASS.RegNtPostCreateKey = 11
REG_NOTIFY_CLASS.RegNtPreOpenKey = 12
REG_NOTIFY_CLASS.RegNtPostOpenKey = 13
REG_NOTIFY_CLASS.RegNtKeyHandleClose = 14
REG_NOTIFY_CLASS.RegNtPreKeyHandleClose = 14
REG_NOTIFY_CLASS.RegNtPostDeleteKey = 15
REG_NOTIFY_CLASS.RegNtPostSetValueKey = 16
REG_NOTIFY_CLASS.RegNtPostDeleteValueKey = 17
REG_NOTIFY_CLASS.RegNtPostSetInformationKey = 18
REG_NOTIFY_CLASS.RegNtPostRenameKey = 19
REG_NOTIFY_CLASS.RegNtPostEnumerateKey = 20
REG_NOTIFY_CLASS.RegNtPostEnumerateValueKey = 21
REG_NOTIFY_CLASS.RegNtPostQueryKey = 22
REG_NOTIFY_CLASS.RegNtPostQueryValueKey = 23
REG_NOTIFY_CLASS.RegNtPostQueryMultipleValueKey = 24
REG_NOTIFY_CLASS.RegNtPostKeyHandleClose = 25
REG_NOTIFY_CLASS.RegNtPreCreateKeyEx = 26
REG_NOTIFY_CLASS.RegNtPostCreateKeyEx = 27
REG_NOTIFY_CLASS.RegNtPreOpenKeyEx = 28
REG_NOTIFY_CLASS.RegNtPostOpenKeyEx = 29
REG_NOTIFY_CLASS.RegNtPreFlushKey = 30
REG_NOTIFY_CLASS.RegNtPostFlushKey = 31
REG_NOTIFY_CLASS.RegNtPreLoadKey = 32
REG_NOTIFY_CLASS.RegNtPostLoadKey = 33
REG_NOTIFY_CLASS.RegNtPreUnLoadKey = 34
REG_NOTIFY_CLASS.RegNtPostUnLoadKey = 35
REG_NOTIFY_CLASS.RegNtPreQueryKeySecurity = 36
REG_NOTIFY_CLASS.RegNtPostQueryKeySecurity = 37
REG_NOTIFY_CLASS.RegNtPreSetKeySecurity = 38
REG_NOTIFY_CLASS.RegNtPostSetKeySecurity = 39
REG_NOTIFY_CLASS.RegNtCallbackObjectContextCleanup = 40
REG_NOTIFY_CLASS.RegNtPreRestoreKey = 41
REG_NOTIFY_CLASS.RegNtPostRestoreKey = 42
REG_NOTIFY_CLASS.RegNtPreSaveKey = 43
REG_NOTIFY_CLASS.RegNtPostSaveKey = 44
REG_NOTIFY_CLASS.RegNtPreReplaceKey = 45
REG_NOTIFY_CLASS.RegNtPostReplaceKey = 46
REG_NOTIFY_CLASS.MaxRegNtNotifyClass = 47


DEVICE_RELATION_TYPE = v_enum()
DEVICE_RELATION_TYPE.BusRelations = 0
DEVICE_RELATION_TYPE.EjectionRelations = 1
DEVICE_RELATION_TYPE.PowerRelations = 2
DEVICE_RELATION_TYPE.RemovalRelations = 3
DEVICE_RELATION_TYPE.TargetDeviceRelation = 4
DEVICE_RELATION_TYPE.SingleBusRelations = 5
DEVICE_RELATION_TYPE.TransportRelations = 6


D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE = v_enum()
D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE.D3DKMDT_VPPMT_UNINITIALIZED = 0
D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE.D3DKMDT_VPPMT_NOPROTECTION = 1
D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE.D3DKMDT_VPPMT_MACROVISION_APSTRIGGER = 2
D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE.D3DKMDT_VPPMT_MACROVISION_FULLSUPPORT = 3
D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE.D3DKMDT_VPPMT_NOTSPECIFIED = 255


FILE_INFORMATION_CLASS = v_enum()
FILE_INFORMATION_CLASS.FileDirectoryInformation = 1
FILE_INFORMATION_CLASS.FileFullDirectoryInformation = 2
FILE_INFORMATION_CLASS.FileBothDirectoryInformation = 3
FILE_INFORMATION_CLASS.FileBasicInformation = 4
FILE_INFORMATION_CLASS.FileStandardInformation = 5
FILE_INFORMATION_CLASS.FileInternalInformation = 6
FILE_INFORMATION_CLASS.FileEaInformation = 7
FILE_INFORMATION_CLASS.FileAccessInformation = 8
FILE_INFORMATION_CLASS.FileNameInformation = 9
FILE_INFORMATION_CLASS.FileRenameInformation = 10
FILE_INFORMATION_CLASS.FileLinkInformation = 11
FILE_INFORMATION_CLASS.FileNamesInformation = 12
FILE_INFORMATION_CLASS.FileDispositionInformation = 13
FILE_INFORMATION_CLASS.FilePositionInformation = 14
FILE_INFORMATION_CLASS.FileFullEaInformation = 15
FILE_INFORMATION_CLASS.FileModeInformation = 16
FILE_INFORMATION_CLASS.FileAlignmentInformation = 17
FILE_INFORMATION_CLASS.FileAllInformation = 18
FILE_INFORMATION_CLASS.FileAllocationInformation = 19
FILE_INFORMATION_CLASS.FileEndOfFileInformation = 20
FILE_INFORMATION_CLASS.FileAlternateNameInformation = 21
FILE_INFORMATION_CLASS.FileStreamInformation = 22
FILE_INFORMATION_CLASS.FilePipeInformation = 23
FILE_INFORMATION_CLASS.FilePipeLocalInformation = 24
FILE_INFORMATION_CLASS.FilePipeRemoteInformation = 25
FILE_INFORMATION_CLASS.FileMailslotQueryInformation = 26
FILE_INFORMATION_CLASS.FileMailslotSetInformation = 27
FILE_INFORMATION_CLASS.FileCompressionInformation = 28
FILE_INFORMATION_CLASS.FileObjectIdInformation = 29
FILE_INFORMATION_CLASS.FileCompletionInformation = 30
FILE_INFORMATION_CLASS.FileMoveClusterInformation = 31
FILE_INFORMATION_CLASS.FileQuotaInformation = 32
FILE_INFORMATION_CLASS.FileReparsePointInformation = 33
FILE_INFORMATION_CLASS.FileNetworkOpenInformation = 34
FILE_INFORMATION_CLASS.FileAttributeTagInformation = 35
FILE_INFORMATION_CLASS.FileTrackingInformation = 36
FILE_INFORMATION_CLASS.FileIdBothDirectoryInformation = 37
FILE_INFORMATION_CLASS.FileIdFullDirectoryInformation = 38
FILE_INFORMATION_CLASS.FileValidDataLengthInformation = 39
FILE_INFORMATION_CLASS.FileShortNameInformation = 40
FILE_INFORMATION_CLASS.FileIoCompletionNotificationInformation = 41
FILE_INFORMATION_CLASS.FileIoStatusBlockRangeInformation = 42
FILE_INFORMATION_CLASS.FileIoPriorityHintInformation = 43
FILE_INFORMATION_CLASS.FileSfioReserveInformation = 44
FILE_INFORMATION_CLASS.FileSfioVolumeInformation = 45
FILE_INFORMATION_CLASS.FileHardLinkInformation = 46
FILE_INFORMATION_CLASS.FileProcessIdsUsingFileInformation = 47
FILE_INFORMATION_CLASS.FileNormalizedNameInformation = 48
FILE_INFORMATION_CLASS.FileNetworkPhysicalNameInformation = 49
FILE_INFORMATION_CLASS.FileIdGlobalTxDirectoryInformation = 50
FILE_INFORMATION_CLASS.FileIsRemoteDeviceInformation = 51
FILE_INFORMATION_CLASS.FileAttributeCacheInformation = 52
FILE_INFORMATION_CLASS.FileNumaNodeInformation = 53
FILE_INFORMATION_CLASS.FileStandardLinkInformation = 54
FILE_INFORMATION_CLASS.FileRemoteProtocolInformation = 55
FILE_INFORMATION_CLASS.FileMaximumInformation = 56


BUS_QUERY_ID_TYPE = v_enum()
BUS_QUERY_ID_TYPE.BusQueryDeviceID = 0
BUS_QUERY_ID_TYPE.BusQueryHardwareIDs = 1
BUS_QUERY_ID_TYPE.BusQueryCompatibleIDs = 2
BUS_QUERY_ID_TYPE.BusQueryInstanceID = 3
BUS_QUERY_ID_TYPE.BusQueryDeviceSerialNumber = 4
BUS_QUERY_ID_TYPE.BusQueryContainerID = 5


PROFILE_MAP = v_enum()
PROFILE_MAP.PMAP_COLORS = 0
PROFILE_MAP.PMAP_CURSORS = 1
PROFILE_MAP.PMAP_WINDOWSM = 2
PROFILE_MAP.PMAP_WINDOWSU = 3
PROFILE_MAP.PMAP_DESKTOP = 4
PROFILE_MAP.PMAP_ICONS = 5
PROFILE_MAP.PMAP_FONTS = 6
PROFILE_MAP.PMAP_TRUETYPE = 7
PROFILE_MAP.PMAP_KBDLAYOUT = 8
PROFILE_MAP.PMAP_INPUT = 9
PROFILE_MAP.PMAP_SUBSYSTEMS = 10
PROFILE_MAP.PMAP_BEEP = 11
PROFILE_MAP.PMAP_MOUSE = 12
PROFILE_MAP.PMAP_KEYBOARD = 13
PROFILE_MAP.PMAP_STICKYKEYS = 14
PROFILE_MAP.PMAP_KEYBOARDRESPONSE = 15
PROFILE_MAP.PMAP_MOUSEKEYS = 16
PROFILE_MAP.PMAP_TOGGLEKEYS = 17
PROFILE_MAP.PMAP_TIMEOUT = 18
PROFILE_MAP.PMAP_SOUNDSENTRY = 19
PROFILE_MAP.PMAP_SHOWSOUNDS = 20
PROFILE_MAP.PMAP_AEDEBUG = 21
PROFILE_MAP.PMAP_NETWORK = 22
PROFILE_MAP.PMAP_METRICS = 23
PROFILE_MAP.PMAP_UKBDLAYOUT = 24
PROFILE_MAP.PMAP_UKBDLAYOUTTOGGLE = 25
PROFILE_MAP.PMAP_WINLOGON = 26
PROFILE_MAP.PMAP_KEYBOARDPREF = 27
PROFILE_MAP.PMAP_SCREENREADER = 28
PROFILE_MAP.PMAP_HIGHCONTRAST = 29
PROFILE_MAP.PMAP_IMECOMPAT = 30
PROFILE_MAP.PMAP_IMM = 31
PROFILE_MAP.PMAP_POOLLIMITS = 32
PROFILE_MAP.PMAP_COMPAT32 = 33
PROFILE_MAP.PMAP_SETUPPROGRAMNAMES = 34
PROFILE_MAP.PMAP_INPUTMETHOD = 35
PROFILE_MAP.PMAP_MOUCLASS_PARAMS = 36
PROFILE_MAP.PMAP_KBDCLASS_PARAMS = 37
PROFILE_MAP.PMAP_COMPUTERNAME = 38
PROFILE_MAP.PMAP_TS = 39
PROFILE_MAP.PMAP_TABLETPC = 40
PROFILE_MAP.PMAP_MEDIACENTER = 41
PROFILE_MAP.PMAP_TS_EXCLUDE_DESKTOP_VERSION = 42
PROFILE_MAP.PMAP_WOW64_COMPAT32 = 43
PROFILE_MAP.PMAP_WOW64_IMECOMPAT = 44
PROFILE_MAP.PMAP_SERVERR2 = 45
PROFILE_MAP.PMAP_STARTER = 46
PROFILE_MAP.PMAP_ACCESS = 47
PROFILE_MAP.PMAP_AUDIODESCRIPTION = 48
PROFILE_MAP.PMAP_CONTROL = 49
PROFILE_MAP.PMAP_LAST = 49


NT_PRODUCT_TYPE = v_enum()
NT_PRODUCT_TYPE.NtProductWinNt = 1
NT_PRODUCT_TYPE.NtProductLanManNt = 2
NT_PRODUCT_TYPE.NtProductServer = 3


DMM_VIDPNCHANGE_TYPE = v_enum()
DMM_VIDPNCHANGE_TYPE.DMM_CVR_UNINITIALIZED = 0
DMM_VIDPNCHANGE_TYPE.DMM_CVR_UPDATEMODALITY = 1
DMM_VIDPNCHANGE_TYPE.DMM_CVR_ADDPATH = 2
DMM_VIDPNCHANGE_TYPE.DMM_CVR_ADDPATHS = 3
DMM_VIDPNCHANGE_TYPE.DMM_CVR_REMOVEPATH = 4
DMM_VIDPNCHANGE_TYPE.DMM_CVR_REMOVEALLPATHS = 5


DEVICE_POWER_STATE = v_enum()
DEVICE_POWER_STATE.PowerDeviceUnspecified = 0
DEVICE_POWER_STATE.PowerDeviceD0 = 1
DEVICE_POWER_STATE.PowerDeviceD1 = 2
DEVICE_POWER_STATE.PowerDeviceD2 = 3
DEVICE_POWER_STATE.PowerDeviceD3 = 4
DEVICE_POWER_STATE.PowerDeviceMaximum = 5


WHEA_ERROR_SOURCE_TYPE = v_enum()
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMCE = 0
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCMC = 1
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCPE = 2
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeNMI = 3
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypePCIe = 4
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeGeneric = 5
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeINIT = 6
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeBOOT = 7
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeSCIGeneric = 8
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFMCA = 9
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCMC = 10
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCPE = 11
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMax = 12


DXGK_DIAG_CODE_POINT_TYPE = v_enum()
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_NONE = 0
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_RECOMMEND_FUNC_VIDPN = 1
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_OS_RECOMMENDED_VIDPN = 2
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_SDC_LOG_FAILURE = 3
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_SDC_INVALIDATE_ERROR = 4
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CDS_LOG_FAILURE = 5
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CDS_FAILURE_DB = 7
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_RETRIEVE_BTL = 8
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_RETRIEVE_DB = 9
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_QDC_LOG_FAILURE = 10
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_POWER_ON_GDI = 11
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_POWER_OFF_GDI = 12
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_POWER_ON_MONITOR = 13
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_POWER_OFF_MONITOR = 14
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_POWER_DIM_MONITOR = 15
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_POWER_UNDIM_MONITOR = 16
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_BACKTRACK = 17
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_CLOSEST_TARGET_MODE = 18
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_NO_EXACT_SOURCE_MODE = 19
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_NO_EXACT_TARGET_MODE = 20
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_SOURCE_MODE_NOT_PINNED = 21
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_TARGET_MODE_NOT_PINNED = 22
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_RESTARTED = 23
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_TDR = 24
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_ACPI_EVENT_NOTIFICATION = 25
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CREATEMDEV_USE_DEFAULT_MODE = 26
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CONNECTED_SET_LOG_FAILURE = 27
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_INVALIDATE_DXGK_MODE_CACHE = 28
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_REBUILD_DXGK_MODE_CACHE = 29
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CREATEFUNVIDPN_RELAX_REFRESH_MATCH = 30
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CREATEFUNVIDPN_CCDBML_FAIL_VISTABML_SUCCESSED = 31
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_BEST_SOURCE_MODE = 32
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_BML_BEST_TARGET_MODE = 33
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_ADD_DEVICE = 34
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_START_ADAPTER = 35
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_STOP_ADAPTER = 36
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CHILD_POLLING = 37
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CHILD_POLLING_TARGET = 38
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_INDICATE_CHILD_STATUS = 39
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_HANDLE_IRP = 40
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CHANGE_UNSUPPORTED_MONITOR_MODE_FLAG = 41
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_ACPI_NOTIFY_CALLBACK = 42
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_EXCLUDE_EVICTALL_DISABLEGDI = 43
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_EXCLUDE_EVICTALL_ENABLEGDI = 44
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_EXCLUDE_MODESWITCH = 45
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_SYNC_MONITOR_EVENT = 46
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_PNP_NOTIFY_GDI = 47
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_PNP_ENABLE_VGA = 48
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_TDR_SWITCH_GDI = 49
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_CDD_CREATE_DEVICE_FAILED = 50
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_CDD_DEVICE_REMOVED = 51
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_CDD_DRVASSERTMODE_TRUE_FAILED = 52
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_VIDEOPORTCALLOUT_CDD_RECREATE_DEVICE_FAILED = 53
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CDD_MAPSHADOWBUFFER_FAILED = 54
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_COMMIT_VIDPN_LOG_FAILURE = 55
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_DRIVER_RECOMMEND_LOG_FAILURE = 56
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_SDC_ENFORCED_CLONE_PATH_INVALID_SOURCE_IDX = 57
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_DRVPROBEANDCAPTURE_FAILED = 58
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_DXGKCDDENABLE_OPTIMIZED_MODE_CHANGE = 59
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_DXGKSETDISPLAYMODE_OPTIMIZED_MODE_CHANGE = 60
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_MON_DEPART_GETRECENTTOP_FAIL = 61
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_MON_ARRIVE_INC_ADD_FAIL = 62
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CCD_DATABASE_PERSIST = 63
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_CCD_DATABASE_PERSIST_NO_CONNECTIVITY_HASH = 64
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_MAX = 64
DXGK_DIAG_CODE_POINT_TYPE.DXGK_DIAG_CODE_POINT_TYPE_FORCE_UINT32 = -1


DMM_VIDPN_MONITOR_TYPE = v_enum()
DMM_VIDPN_MONITOR_TYPE.DMM_VMT_UNINITIALIZED = 0
DMM_VIDPN_MONITOR_TYPE.DMM_VMT_PHYSICAL_MONITOR = 1
DMM_VIDPN_MONITOR_TYPE.DMM_VMT_BOOT_PERSISTENT_MONITOR = 2
DMM_VIDPN_MONITOR_TYPE.DMM_VMT_PERSISTENT_MONITOR = 3
DMM_VIDPN_MONITOR_TYPE.DMM_VMT_TEMPORARY_MONITOR = 4
DMM_VIDPN_MONITOR_TYPE.DMM_VMT_SIMULATED_MONITOR = 5


D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING = v_enum()
D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING.D3DDDI_VSSLO_UNINITIALIZED = 0
D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING.D3DDDI_VSSLO_PROGRESSIVE = 1
D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING.D3DDDI_VSSLO_INTERLACED_UPPERFIELDFIRST = 2
D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING.D3DDDI_VSSLO_INTERLACED_LOWERFIELDFIRST = 3
D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING.D3DDDI_VSSLO_OTHER = 255


D3DKMDT_MONITOR_ORIENTATION = v_enum()
D3DKMDT_MONITOR_ORIENTATION.D3DKMDT_MO_UNINITIALIZED = 0
D3DKMDT_MONITOR_ORIENTATION.D3DKMDT_MO_0DEG = 1
D3DKMDT_MONITOR_ORIENTATION.D3DKMDT_MO_90DEG = 2
D3DKMDT_MONITOR_ORIENTATION.D3DKMDT_MO_180DEG = 3
D3DKMDT_MONITOR_ORIENTATION.D3DKMDT_MO_270DEG = 4


D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY = v_enum()
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_UNINITIALIZED = -2
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_OTHER = -1
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_HD15 = 0
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_SVIDEO = 1
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_COMPOSITE_VIDEO = 2
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_COMPONENT_VIDEO = 3
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_DVI = 4
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_HDMI = 5
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_LVDS = 6
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_D_JPN = 8
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_SDI = 9
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_DISPLAYPORT_EXTERNAL = 10
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_DISPLAYPORT_EMBEDDED = 11
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_UDI_EXTERNAL = 12
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_UDI_EMBEDDED = 13
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_SDTVDONGLE = 14
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_INTERNAL = -2147483648
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_SVIDEO_4PIN = 1
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_SVIDEO_7PIN = 1
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_RF = 2
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_RCA_3COMPONENT = 3
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY.D3DKMDT_VOT_BNC = 3


EVENT_TYPE = v_enum()
EVENT_TYPE.NotificationEvent = 0
EVENT_TYPE.SynchronizationEvent = 1


KSPIN_LOCK_QUEUE_NUMBER = v_enum()
KSPIN_LOCK_QUEUE_NUMBER.LockQueueUnusedSpare0 = 0
KSPIN_LOCK_QUEUE_NUMBER.LockQueueExpansionLock = 1
KSPIN_LOCK_QUEUE_NUMBER.LockQueueUnusedSpare2 = 2
KSPIN_LOCK_QUEUE_NUMBER.LockQueueSystemSpaceLock = 3
KSPIN_LOCK_QUEUE_NUMBER.LockQueueVacbLock = 4
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMasterLock = 5
KSPIN_LOCK_QUEUE_NUMBER.LockQueueNonPagedPoolLock = 6
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoCancelLock = 7
KSPIN_LOCK_QUEUE_NUMBER.LockQueueWorkQueueLock = 8
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoVpbLock = 9
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoDatabaseLock = 10
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoCompletionLock = 11
KSPIN_LOCK_QUEUE_NUMBER.LockQueueNtfsStructLock = 12
KSPIN_LOCK_QUEUE_NUMBER.LockQueueAfdWorkQueueLock = 13
KSPIN_LOCK_QUEUE_NUMBER.LockQueueBcbLock = 14
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMmNonPagedPoolLock = 15
KSPIN_LOCK_QUEUE_NUMBER.LockQueueUnusedSpare16 = 16
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMaximumLock = 17


D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE = v_enum()
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_UNINITIALIZED = 0
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_PRIMARY = 1
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_SECONDARY = 2
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_TERTIARY = 3
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_QUATERNARY = 4
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_QUINARY = 5
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_SENARY = 6
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_SEPTENARY = 7
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_OCTONARY = 8
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_NONARY = 9
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_DENARY = 10
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_MAX = 32
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.D3DKMDT_VPPI_NOTSPECIFIED = 255


FSINFOCLASS = v_enum()
FSINFOCLASS.FileFsVolumeInformation = 1
FSINFOCLASS.FileFsLabelInformation = 2
FSINFOCLASS.FileFsSizeInformation = 3
FSINFOCLASS.FileFsDeviceInformation = 4
FSINFOCLASS.FileFsAttributeInformation = 5
FSINFOCLASS.FileFsControlInformation = 6
FSINFOCLASS.FileFsFullSizeInformation = 7
FSINFOCLASS.FileFsObjectIdInformation = 8
FSINFOCLASS.FileFsDriverPathInformation = 9
FSINFOCLASS.FileFsVolumeFlagsInformation = 10
FSINFOCLASS.FileFsMaximumInformation = 11


D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE = v_enum()
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_RenderCommandBuffer = 0
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_DeferredCommandBuffer = 1
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_SystemCommandBuffer = 2
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_MmIoFlipCommandBuffer = 3
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_WaitCommandBuffer = 4
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_SignalCommandBuffer = 5
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_DeviceCommandBuffer = 6
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_SoftwareCommandBuffer = 7
D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE.D3DKMT_QueuePacketTypeMax = 8


_unnamed_15459 = v_enum()
_unnamed_15459.DMM_DIAG_INFO_VISTA_BETA2_VERSION = 4097
_unnamed_15459.DMM_DIAG_INFO_VISTA_RC1_VERSION = 4098
_unnamed_15459.DMM_DIAG_INFO_VISTA_RTM_VERSION = 4099
_unnamed_15459.DMM_DIAG_INFO_WIN7_MQ_VERSION = 8192
_unnamed_15459.DMM_DIAG_INFO_WIN7_M3_VERSION = 8193
_unnamed_15459.DMM_DIAG_INFO_VERSION = 8193


D3DKMDT_VIDPN_PRESENT_PATH_CONTENT = v_enum()
D3DKMDT_VIDPN_PRESENT_PATH_CONTENT.D3DKMDT_VPPC_UNINITIALIZED = 0
D3DKMDT_VIDPN_PRESENT_PATH_CONTENT.D3DKMDT_VPPC_GRAPHICS = 1
D3DKMDT_VIDPN_PRESENT_PATH_CONTENT.D3DKMDT_VPPC_VIDEO = 2
D3DKMDT_VIDPN_PRESENT_PATH_CONTENT.D3DKMDT_VPPC_NOTSPECIFIED = 255


THRESHOLD_SELECTOR = v_enum()
THRESHOLD_SELECTOR.ThresholdMouse = 0
THRESHOLD_SELECTOR.ThresholdPen = 1
THRESHOLD_SELECTOR.ThresholdMouseDragOut = 2
THRESHOLD_SELECTOR.ThresholdPenDragOut = 3
THRESHOLD_SELECTOR.ThresholdMouseSideMove = 4
THRESHOLD_SELECTOR.ThresholdPenSideMove = 5
THRESHOLD_SELECTOR.ThresholdAlways = 6
THRESHOLD_SELECTOR.ThresholdLast = 7


POOL_TYPE = v_enum()
POOL_TYPE.NonPagedPool = 0
POOL_TYPE.PagedPool = 1
POOL_TYPE.NonPagedPoolMustSucceed = 2
POOL_TYPE.DontUseThisType = 3
POOL_TYPE.NonPagedPoolCacheAligned = 4
POOL_TYPE.PagedPoolCacheAligned = 5
POOL_TYPE.NonPagedPoolCacheAlignedMustS = 6
POOL_TYPE.MaxPoolType = 7
POOL_TYPE.NonPagedPoolSession = 32
POOL_TYPE.PagedPoolSession = 33
POOL_TYPE.NonPagedPoolMustSucceedSession = 34
POOL_TYPE.DontUseThisTypeSession = 35
POOL_TYPE.NonPagedPoolCacheAlignedSession = 36
POOL_TYPE.PagedPoolCacheAlignedSession = 37
POOL_TYPE.NonPagedPoolCacheAlignedMustSSession = 38


DMM_CLIENT_TYPE = v_enum()
DMM_CLIENT_TYPE.DMM_CT_UNINITIALIZED = 0
DMM_CLIENT_TYPE.DMM_CT_CDD_NOPATHDATA = 1
DMM_CLIENT_TYPE.DMM_CT_USERMODE = 2
DMM_CLIENT_TYPE.DMM_CT_CDD_PATHDATA = 3
DMM_CLIENT_TYPE.DMM_CT_DXGPORT = 4


D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE = v_enum()
D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE.D3DKMT_ClientRenderBuffer = 0
D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE.D3DKMT_ClientPagingBuffer = 1
D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE.D3DKMT_SystemPagingBuffer = 2
D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE.D3DKMT_SystemPreemptionBuffer = 3
D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE.D3DKMT_DmaPacketTypeMax = 4


D3DKMDT_VIDEO_SIGNAL_STANDARD = v_enum()
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_UNINITIALIZED = 0
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_VESA_DMT = 1
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_VESA_GTF = 2
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_VESA_CVT = 3
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_IBM = 4
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_APPLE = 5
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_NTSC_M = 6
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_NTSC_J = 7
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_NTSC_443 = 8
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_B = 9
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_B1 = 10
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_G = 11
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_H = 12
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_I = 13
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_D = 14
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_N = 15
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_NC = 16
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_B = 17
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_D = 18
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_G = 19
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_H = 20
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_K = 21
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_K1 = 22
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_L = 23
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_SECAM_L1 = 24
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_EIA_861 = 25
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_EIA_861A = 26
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_EIA_861B = 27
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_K = 28
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_K1 = 29
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_L = 30
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_PAL_M = 31
D3DKMDT_VIDEO_SIGNAL_STANDARD.D3DKMDT_VSS_OTHER = 255


D3DKMDT_MONITOR_FREQUENCY_RANGE_CONSTRAINT = v_enum()
D3DKMDT_MONITOR_FREQUENCY_RANGE_CONSTRAINT.D3DKMDT_MFRC_UNINITIALIZED = 0
D3DKMDT_MONITOR_FREQUENCY_RANGE_CONSTRAINT.D3DKMDT_MFRC_ACTIVESIZE = 1
D3DKMDT_MONITOR_FREQUENCY_RANGE_CONSTRAINT.D3DKMDT_MFRC_MAXPIXELRATE = 2


WINDOW_ARRANGEMENT_COMMAND = v_enum()
WINDOW_ARRANGEMENT_COMMAND.WARR_MOVE_FIRST = 10
WINDOW_ARRANGEMENT_COMMAND.WARR_RESTORE_UP = 10
WINDOW_ARRANGEMENT_COMMAND.WARR_RESTORE_DOWN = 11
WINDOW_ARRANGEMENT_COMMAND.WARR_VRESTORE_UP = 12
WINDOW_ARRANGEMENT_COMMAND.WARR_VRESTORE_DOWN = 13
WINDOW_ARRANGEMENT_COMMAND.WARR_VMAXIMIZE_RIGHT = 14
WINDOW_ARRANGEMENT_COMMAND.WARR_VMAXIMIZE_LEFT = 15
WINDOW_ARRANGEMENT_COMMAND.WARR_MOVE_NEXT_MONITOR_LEFT = 16
WINDOW_ARRANGEMENT_COMMAND.WARR_MOVE_NEXT_MONITOR_RIGHT = 17
WINDOW_ARRANGEMENT_COMMAND.WARR_MOVE_LAST = 18


OB_OPEN_REASON = v_enum()
OB_OPEN_REASON.ObCreateHandle = 0
OB_OPEN_REASON.ObOpenHandle = 1
OB_OPEN_REASON.ObDuplicateHandle = 2
OB_OPEN_REASON.ObInheritHandle = 3
OB_OPEN_REASON.ObMaxOpenReason = 4


DMM_MODE_PRUNING_ALGORITHM = v_enum()
DMM_MODE_PRUNING_ALGORITHM.DMM_MPA_UNINITIALIZED = 0
DMM_MODE_PRUNING_ALGORITHM.DMM_MPA_GDI = 1
DMM_MODE_PRUNING_ALGORITHM.DMM_MPA_VISTA = 2
DMM_MODE_PRUNING_ALGORITHM.DMM_MPA_GDI_VISTA_UNION = 3
DMM_MODE_PRUNING_ALGORITHM.DMM_MPA_MAXVALID = 3


MODE = v_enum()
MODE.KernelMode = 0
MODE.UserMode = 1
MODE.MaximumMode = 2


POWER_STATE_TYPE = v_enum()
POWER_STATE_TYPE.SystemPowerState = 0
POWER_STATE_TYPE.DevicePowerState = 1


IRQ_PRIORITY = v_enum()
IRQ_PRIORITY.IrqPriorityUndefined = 0
IRQ_PRIORITY.IrqPriorityLow = 1
IRQ_PRIORITY.IrqPriorityNormal = 2
IRQ_PRIORITY.IrqPriorityHigh = 3


D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS = v_enum()
D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS.D3DKMT_AllocationPriorityClassMinimum = 0
D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS.D3DKMT_AllocationPriorityClassLow = 1
D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS.D3DKMT_AllocationPriorityClassNormal = 2
D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS.D3DKMT_AllocationPriorityClassHigh = 3
D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS.D3DKMT_AllocationPriorityClassMaximum = 4
D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS.D3DKMT_MaxAllocationPriorityClass = 5


D3DKMDT_MONITOR_CAPABILITIES_ORIGIN = v_enum()
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_UNINITIALIZED = 0
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_DEFAULTMONITORPROFILE = 1
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_MONITORDESCRIPTOR = 2
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_MONITORDESCRIPTOR_REGISTRYOVERRIDE = 3
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_SPECIFICCAP_REGISTRYOVERRIDE = 4
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_DRIVER = 5
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN.D3DKMDT_MCO_MAXVALID = 5


D3DKMDT_PIXEL_VALUE_ACCESS_MODE = v_enum()
D3DKMDT_PIXEL_VALUE_ACCESS_MODE.D3DKMDT_PVAM_UNINITIALIZED = 0
D3DKMDT_PIXEL_VALUE_ACCESS_MODE.D3DKMDT_PVAM_DIRECT = 1
D3DKMDT_PIXEL_VALUE_ACCESS_MODE.D3DKMDT_PVAM_PRESETPALETTE = 2
D3DKMDT_PIXEL_VALUE_ACCESS_MODE.D3DKMDT_PVAM_SETTABLEPALETTE = 3
D3DKMDT_PIXEL_VALUE_ACCESS_MODE.D3DKMDT_PVAM_MAXVALID = 3


D3DKMDT_TEXT_RENDERING_FORMAT = v_enum()
D3DKMDT_TEXT_RENDERING_FORMAT.D3DKMDT_TRF_UNINITIALIZED = 0


RTL_GENERIC_COMPARE_RESULTS = v_enum()
RTL_GENERIC_COMPARE_RESULTS.GenericLessThan = 0
RTL_GENERIC_COMPARE_RESULTS.GenericGreaterThan = 1
RTL_GENERIC_COMPARE_RESULTS.GenericEqual = 2


SYSTEM_POWER_STATE = v_enum()
SYSTEM_POWER_STATE.PowerSystemUnspecified = 0
SYSTEM_POWER_STATE.PowerSystemWorking = 1
SYSTEM_POWER_STATE.PowerSystemSleeping1 = 2
SYSTEM_POWER_STATE.PowerSystemSleeping2 = 3
SYSTEM_POWER_STATE.PowerSystemSleeping3 = 4
SYSTEM_POWER_STATE.PowerSystemHibernate = 5
SYSTEM_POWER_STATE.PowerSystemShutdown = 6
SYSTEM_POWER_STATE.PowerSystemMaximum = 7


D3DKMDT_VIDPN_SOURCE_MODE_TYPE = v_enum()
D3DKMDT_VIDPN_SOURCE_MODE_TYPE.D3DKMDT_RMT_UNINITIALIZED = 0
D3DKMDT_VIDPN_SOURCE_MODE_TYPE.D3DKMDT_RMT_GRAPHICS = 1
D3DKMDT_VIDPN_SOURCE_MODE_TYPE.D3DKMDT_RMT_TEXT = 2


IO_ALLOCATION_ACTION = v_enum()
IO_ALLOCATION_ACTION.KeepObject = 1
IO_ALLOCATION_ACTION.DeallocateObject = 2
IO_ALLOCATION_ACTION.DeallocateObjectKeepRegisters = 3


EXCEPTION_DISPOSITION = v_enum()
EXCEPTION_DISPOSITION.ExceptionContinueExecution = 0
EXCEPTION_DISPOSITION.ExceptionContinueSearch = 1
EXCEPTION_DISPOSITION.ExceptionNestedException = 2
EXCEPTION_DISPOSITION.ExceptionCollidedUnwind = 3


D3DKMDT_VIDPN_PRESENT_PATH_SCALING = v_enum()
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_UNINITIALIZED = 0
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_IDENTITY = 1
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_CENTERED = 2
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_STRETCHED = 3
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_ASPECTRATIOCENTEREDMAX = 4
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_CUSTOM = 5
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_RESERVED1 = 253
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_UNPINNED = 254
D3DKMDT_VIDPN_PRESENT_PATH_SCALING.D3DKMDT_VPPS_NOTSPECIFIED = 255


D3DDDI_GAMMARAMP_TYPE = v_enum()
D3DDDI_GAMMARAMP_TYPE.D3DDDI_GAMMARAMP_UNINITIALIZED = 0
D3DDDI_GAMMARAMP_TYPE.D3DDDI_GAMMARAMP_DEFAULT = 1
D3DDDI_GAMMARAMP_TYPE.D3DDDI_GAMMARAMP_RGB256x3x16 = 2
D3DDDI_GAMMARAMP_TYPE.D3DDDI_GAMMARAMP_DXGI_1 = 3


SECURITY_OPERATION_CODE = v_enum()
SECURITY_OPERATION_CODE.SetSecurityDescriptor = 0
SECURITY_OPERATION_CODE.QuerySecurityDescriptor = 1
SECURITY_OPERATION_CODE.DeleteSecurityDescriptor = 2
SECURITY_OPERATION_CODE.AssignSecurityDescriptor = 3


WHEA_ERROR_PACKET_DATA_FORMAT = v_enum()
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatIPFSalRecord = 0
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatXPFMCA = 1
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMemory = 2
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIExpress = 3
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatNMIPort = 4
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXBus = 5
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXDevice = 6
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatGeneric = 7
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMax = 8


DISPLAYCONFIG_SCANLINE_ORDERING = v_enum()
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = 2
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = -1


TP_CALLBACK_PRIORITY = v_enum()
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_HIGH = 0
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_NORMAL = 1
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_LOW = 2
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_INVALID = 3


SECURITY_IMPERSONATION_LEVEL = v_enum()
SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous = 0
SECURITY_IMPERSONATION_LEVEL.SecurityIdentification = 1
SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation = 2
SECURITY_IMPERSONATION_LEVEL.SecurityDelegation = 3


DEVICE_USAGE_NOTIFICATION_TYPE = v_enum()
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeUndefined = 0
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypePaging = 1
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeHibernation = 2
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeDumpFile = 3


D3DKMDT_COLOR_BASIS = v_enum()
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_UNINITIALIZED = 0
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_INTENSITY = 1
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_SRGB = 2
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_SCRGB = 3
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_YCBCR = 4
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_YPBPR = 5
D3DKMDT_COLOR_BASIS.D3DKMDT_CB_MAXVALID = 5


DXGK_RECOMMENDFUNCTIONALVIDPN_REASON = v_enum()
DXGK_RECOMMENDFUNCTIONALVIDPN_REASON.DXGK_RFVR_UNINITIALIZED = 0
DXGK_RECOMMENDFUNCTIONALVIDPN_REASON.DXGK_RFVR_HOTKEY = 1
DXGK_RECOMMENDFUNCTIONALVIDPN_REASON.DXGK_RFVR_USERMODE = 2


D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT = v_enum()
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttempt = 0
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptSuccess = 1
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissNoCommand = 2
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissNotEnabled = 3
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissNextFence = 4
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissPagingCommand = 5
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissSplittedCommand = 6
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissFenceCommand = 7
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissRenderPendingFlip = 8
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissNotMakingProgress = 9
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissLessPriority = 10
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissRemainingQuantum = 11
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissRemainingPreemptionQuantum = 12
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissAlreadyPreempting = 13
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissGlobalBlock = 14
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptMissAlreadyRunning = 15
D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT.D3DKMT_PreemptionAttemptStatisticsMax = 16


INTERFACE_TYPE = v_enum()
INTERFACE_TYPE.InterfaceTypeUndefined = -1
INTERFACE_TYPE.Internal = 0
INTERFACE_TYPE.Isa = 1
INTERFACE_TYPE.Eisa = 2
INTERFACE_TYPE.MicroChannel = 3
INTERFACE_TYPE.TurboChannel = 4
INTERFACE_TYPE.PCIBus = 5
INTERFACE_TYPE.VMEBus = 6
INTERFACE_TYPE.NuBus = 7
INTERFACE_TYPE.PCMCIABus = 8
INTERFACE_TYPE.CBus = 9
INTERFACE_TYPE.MPIBus = 10
INTERFACE_TYPE.MPSABus = 11
INTERFACE_TYPE.ProcessorInternal = 12
INTERFACE_TYPE.InternalPowerBus = 13
INTERFACE_TYPE.PNPISABus = 14
INTERFACE_TYPE.PNPBus = 15
INTERFACE_TYPE.Vmcs = 16
INTERFACE_TYPE.MaximumInterfaceType = 17


ALTERNATIVE_ARCHITECTURE_TYPE = v_enum()
ALTERNATIVE_ARCHITECTURE_TYPE.StandardDesign = 0
ALTERNATIVE_ARCHITECTURE_TYPE.NEC98x86 = 1
ALTERNATIVE_ARCHITECTURE_TYPE.EndAlternatives = 2


D3DKMDT_VIDPN_PRESENT_PATH_ROTATION = v_enum()
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_UNINITIALIZED = 0
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_IDENTITY = 1
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_ROTATE90 = 2
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_ROTATE180 = 3
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_ROTATE270 = 4
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_UNPINNED = 254
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION.D3DKMDT_VPPR_NOTSPECIFIED = 255


WHEA_ERROR_TYPE = v_enum()
WHEA_ERROR_TYPE.WheaErrTypeProcessor = 0
WHEA_ERROR_TYPE.WheaErrTypeMemory = 1
WHEA_ERROR_TYPE.WheaErrTypePCIExpress = 2
WHEA_ERROR_TYPE.WheaErrTypeNMI = 3
WHEA_ERROR_TYPE.WheaErrTypePCIXBus = 4
WHEA_ERROR_TYPE.WheaErrTypePCIXDevice = 5
WHEA_ERROR_TYPE.WheaErrTypeGeneric = 6


DXGK_DIAG_TYPE = v_enum()
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_NONE = 0
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_SDC = 1
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_HPD = 2
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_DC_ORIGIN = 3
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_USER_CDS = 4
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_DRV_CDS = 5
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_CODE_POINT = 6
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_QDC = 7
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_MONITOR_MGR = 8
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_CONNECTEDSET_NOT_FOUND = 9
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_DISPDIAG_COLLECTED = 10
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_BML_PACKET = 11
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_BML_PACKET_EX = 12
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_COMMIT_VIDPN_FAILED = 13
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_DRIVER_RECOMMEND_VIDPN = 14
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_MAX = 14
DXGK_DIAG_TYPE.DXGK_DIAG_TYPE_FORCE_UINT32 = -1


ReplacesCorHdrNumericDefines = v_enum()
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY = 1
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED = 2
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY = 4
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED = 8
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2 = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR = 2
ReplacesCorHdrNumericDefines.COR_VERSION_MINOR = 0
ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH = 8
ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB = 1
ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA = 1
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA = 2
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT = 1
ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT = 2
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED = 4
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 8
ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED = 16
ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE = 32
ReplacesCorHdrNumericDefines.MAX_CLASS_NAME = 1024
ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME = 1024


D3DKMDT_MODE_PREFERENCE = v_enum()
D3DKMDT_MODE_PREFERENCE.D3DKMDT_MP_UNINITIALIZED = 0
D3DKMDT_MODE_PREFERENCE.D3DKMDT_MP_PREFERRED = 1
D3DKMDT_MODE_PREFERENCE.D3DKMDT_MP_NOTPREFERRED = 2
D3DKMDT_MODE_PREFERENCE.D3DKMDT_MP_MAXVALID = 2


EX_POOL_PRIORITY = v_enum()
EX_POOL_PRIORITY.LowPoolPriority = 0
EX_POOL_PRIORITY.LowPoolPrioritySpecialPoolOverrun = 8
EX_POOL_PRIORITY.LowPoolPrioritySpecialPoolUnderrun = 9
EX_POOL_PRIORITY.NormalPoolPriority = 16
EX_POOL_PRIORITY.NormalPoolPrioritySpecialPoolOverrun = 24
EX_POOL_PRIORITY.NormalPoolPrioritySpecialPoolUnderrun = 25
EX_POOL_PRIORITY.HighPoolPriority = 32
EX_POOL_PRIORITY.HighPoolPrioritySpecialPoolOverrun = 40
EX_POOL_PRIORITY.HighPoolPrioritySpecialPoolUnderrun = 41


eTHRESHOLD_MARGIN_DIRECTION = v_enum()
eTHRESHOLD_MARGIN_DIRECTION.ThresholdMarginTop = 0
eTHRESHOLD_MARGIN_DIRECTION.ThresholdMarginLeft = 1
eTHRESHOLD_MARGIN_DIRECTION.ThresholdMarginRight = 2
eTHRESHOLD_MARGIN_DIRECTION.ThresholdMarginBottom = 3
eTHRESHOLD_MARGIN_DIRECTION.ThresholdMarginMax = 4


MOVERECT_STYLE = v_enum()
MOVERECT_STYLE.MoveRectKeepPositionAtCursor = 0
MOVERECT_STYLE.MoveRectMidTopAtCursor = 1
MOVERECT_STYLE.MoveRectKeepAspectRatioAtCursor = 2
MOVERECT_STYLE.MoveRectSidewiseKeepPositionAtCursor = 3


D3DDDIFORMAT = v_enum()
D3DDDIFORMAT.D3DDDIFMT_UNKNOWN = 0
D3DDDIFORMAT.D3DDDIFMT_R8G8B8 = 20
D3DDDIFORMAT.D3DDDIFMT_A8R8G8B8 = 21
D3DDDIFORMAT.D3DDDIFMT_X8R8G8B8 = 22
D3DDDIFORMAT.D3DDDIFMT_R5G6B5 = 23
D3DDDIFORMAT.D3DDDIFMT_X1R5G5B5 = 24
D3DDDIFORMAT.D3DDDIFMT_A1R5G5B5 = 25
D3DDDIFORMAT.D3DDDIFMT_A4R4G4B4 = 26
D3DDDIFORMAT.D3DDDIFMT_R3G3B2 = 27
D3DDDIFORMAT.D3DDDIFMT_A8 = 28
D3DDDIFORMAT.D3DDDIFMT_A8R3G3B2 = 29
D3DDDIFORMAT.D3DDDIFMT_X4R4G4B4 = 30
D3DDDIFORMAT.D3DDDIFMT_A2B10G10R10 = 31
D3DDDIFORMAT.D3DDDIFMT_A8B8G8R8 = 32
D3DDDIFORMAT.D3DDDIFMT_X8B8G8R8 = 33
D3DDDIFORMAT.D3DDDIFMT_G16R16 = 34
D3DDDIFORMAT.D3DDDIFMT_A2R10G10B10 = 35
D3DDDIFORMAT.D3DDDIFMT_A16B16G16R16 = 36
D3DDDIFORMAT.D3DDDIFMT_A8P8 = 40
D3DDDIFORMAT.D3DDDIFMT_P8 = 41
D3DDDIFORMAT.D3DDDIFMT_L8 = 50
D3DDDIFORMAT.D3DDDIFMT_A8L8 = 51
D3DDDIFORMAT.D3DDDIFMT_A4L4 = 52
D3DDDIFORMAT.D3DDDIFMT_V8U8 = 60
D3DDDIFORMAT.D3DDDIFMT_L6V5U5 = 61
D3DDDIFORMAT.D3DDDIFMT_X8L8V8U8 = 62
D3DDDIFORMAT.D3DDDIFMT_Q8W8V8U8 = 63
D3DDDIFORMAT.D3DDDIFMT_V16U16 = 64
D3DDDIFORMAT.D3DDDIFMT_W11V11U10 = 65
D3DDDIFORMAT.D3DDDIFMT_A2W10V10U10 = 67
D3DDDIFORMAT.D3DDDIFMT_UYVY = 1498831189
D3DDDIFORMAT.D3DDDIFMT_R8G8_B8G8 = 1195525970
D3DDDIFORMAT.D3DDDIFMT_YUY2 = 844715353
D3DDDIFORMAT.D3DDDIFMT_G8R8_G8B8 = 1111970375
D3DDDIFORMAT.D3DDDIFMT_DXT1 = 827611204
D3DDDIFORMAT.D3DDDIFMT_DXT2 = 844388420
D3DDDIFORMAT.D3DDDIFMT_DXT3 = 861165636
D3DDDIFORMAT.D3DDDIFMT_DXT4 = 877942852
D3DDDIFORMAT.D3DDDIFMT_DXT5 = 894720068
D3DDDIFORMAT.D3DDDIFMT_D16_LOCKABLE = 70
D3DDDIFORMAT.D3DDDIFMT_D32 = 71
D3DDDIFORMAT.D3DDDIFMT_D15S1 = 73
D3DDDIFORMAT.D3DDDIFMT_D24S8 = 75
D3DDDIFORMAT.D3DDDIFMT_D24X8 = 77
D3DDDIFORMAT.D3DDDIFMT_D24X4S4 = 79
D3DDDIFORMAT.D3DDDIFMT_D16 = 80
D3DDDIFORMAT.D3DDDIFMT_D32F_LOCKABLE = 82
D3DDDIFORMAT.D3DDDIFMT_D24FS8 = 83
D3DDDIFORMAT.D3DDDIFMT_D32_LOCKABLE = 84
D3DDDIFORMAT.D3DDDIFMT_S8_LOCKABLE = 85
D3DDDIFORMAT.D3DDDIFMT_S1D15 = 72
D3DDDIFORMAT.D3DDDIFMT_S8D24 = 74
D3DDDIFORMAT.D3DDDIFMT_X8D24 = 76
D3DDDIFORMAT.D3DDDIFMT_X4S4D24 = 78
D3DDDIFORMAT.D3DDDIFMT_L16 = 81
D3DDDIFORMAT.D3DDDIFMT_VERTEXDATA = 100
D3DDDIFORMAT.D3DDDIFMT_INDEX16 = 101
D3DDDIFORMAT.D3DDDIFMT_INDEX32 = 102
D3DDDIFORMAT.D3DDDIFMT_Q16W16V16U16 = 110
D3DDDIFORMAT.D3DDDIFMT_MULTI2_ARGB8 = 827606349
D3DDDIFORMAT.D3DDDIFMT_R16F = 111
D3DDDIFORMAT.D3DDDIFMT_G16R16F = 112
D3DDDIFORMAT.D3DDDIFMT_A16B16G16R16F = 113
D3DDDIFORMAT.D3DDDIFMT_R32F = 114
D3DDDIFORMAT.D3DDDIFMT_G32R32F = 115
D3DDDIFORMAT.D3DDDIFMT_A32B32G32R32F = 116
D3DDDIFORMAT.D3DDDIFMT_CxV8U8 = 117
D3DDDIFORMAT.D3DDDIFMT_A1 = 118
D3DDDIFORMAT.D3DDDIFMT_A2B10G10R10_XR_BIAS = 119
D3DDDIFORMAT.D3DDDIFMT_DXVACOMPBUFFER_BASE = 150
D3DDDIFORMAT.D3DDDIFMT_PICTUREPARAMSDATA = 150
D3DDDIFORMAT.D3DDDIFMT_MACROBLOCKDATA = 151
D3DDDIFORMAT.D3DDDIFMT_RESIDUALDIFFERENCEDATA = 152
D3DDDIFORMAT.D3DDDIFMT_DEBLOCKINGDATA = 153
D3DDDIFORMAT.D3DDDIFMT_INVERSEQUANTIZATIONDATA = 154
D3DDDIFORMAT.D3DDDIFMT_SLICECONTROLDATA = 155
D3DDDIFORMAT.D3DDDIFMT_BITSTREAMDATA = 156
D3DDDIFORMAT.D3DDDIFMT_MOTIONVECTORBUFFER = 157
D3DDDIFORMAT.D3DDDIFMT_FILMGRAINBUFFER = 158
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED9 = 159
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED10 = 160
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED11 = 161
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED12 = 162
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED13 = 163
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED14 = 164
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED15 = 165
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED16 = 166
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED17 = 167
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED18 = 168
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED19 = 169
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED20 = 170
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED21 = 171
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED22 = 172
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED23 = 173
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED24 = 174
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED25 = 175
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED26 = 176
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED27 = 177
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED28 = 178
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED29 = 179
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED30 = 180
D3DDDIFORMAT.D3DDDIFMT_DXVA_RESERVED31 = 181
D3DDDIFORMAT.D3DDDIFMT_DXVACOMPBUFFER_MAX = 181
D3DDDIFORMAT.D3DDDIFMT_BINARYBUFFER = 199
D3DDDIFORMAT.D3DDDIFMT_FORCE_UINT = 2147483647


D3DKMDT_MONITOR_TIMING_TYPE = v_enum()
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_UNINITIALIZED = 0
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_ESTABLISHED = 1
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_STANDARD = 2
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_EXTRASTANDARD = 3
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_DETAILED = 4
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_DEFAULTMONITORPROFILE = 5
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_DRIVER = 6
D3DKMDT_MONITOR_TIMING_TYPE.D3DKMDT_MTT_MAXVALID = 6


MEMORY_CACHING_TYPE_ORIG = v_enum()
MEMORY_CACHING_TYPE_ORIG.MmFrameBufferCached = 2


DEVICE_TEXT_TYPE = v_enum()
DEVICE_TEXT_TYPE.DeviceTextDescription = 0
DEVICE_TEXT_TYPE.DeviceTextLocationInformation = 1


POWER_ACTION = v_enum()
POWER_ACTION.PowerActionNone = 0
POWER_ACTION.PowerActionReserved = 1
POWER_ACTION.PowerActionSleep = 2
POWER_ACTION.PowerActionHibernate = 3
POWER_ACTION.PowerActionShutdown = 4
POWER_ACTION.PowerActionShutdownReset = 5
POWER_ACTION.PowerActionShutdownOff = 6
POWER_ACTION.PowerActionWarmEject = 7


D3DKMDT_MONITOR_DESCRIPTOR_TYPE = v_enum()
D3DKMDT_MONITOR_DESCRIPTOR_TYPE.D3DKMDT_MDT_UNINITIALIZED = 0
D3DKMDT_MONITOR_DESCRIPTOR_TYPE.D3DKMDT_MDT_VESA_EDID_V1_BASEBLOCK = 1
D3DKMDT_MONITOR_DESCRIPTOR_TYPE.D3DKMDT_MDT_VESA_EDID_V1_BLOCKMAP = 2
D3DKMDT_MONITOR_DESCRIPTOR_TYPE.D3DKMDT_MDT_OTHER = 255


SM_RANGE_TYPES = v_enum()
SM_RANGE_TYPES.SmRangeSharedInfo = 0
SM_RANGE_TYPES.SmRangeNonSharedInfo = 1
SM_RANGE_TYPES.SmRangeBool = 2


WINDOWCOMPOSITIONATTRIB = v_enum()
WINDOWCOMPOSITIONATTRIB.WCA_UNDEFINED = 0
WINDOWCOMPOSITIONATTRIB.WCA_NCRENDERING_ENABLED = 1
WINDOWCOMPOSITIONATTRIB.WCA_NCRENDERING_POLICY = 2
WINDOWCOMPOSITIONATTRIB.WCA_TRANSITIONS_FORCEDISABLED = 3
WINDOWCOMPOSITIONATTRIB.WCA_ALLOW_NCPAINT = 4
WINDOWCOMPOSITIONATTRIB.WCA_CAPTION_BUTTON_BOUNDS = 5
WINDOWCOMPOSITIONATTRIB.WCA_NONCLIENT_RTL_LAYOUT = 6
WINDOWCOMPOSITIONATTRIB.WCA_FORCE_ICONIC_REPRESENTATION = 7
WINDOWCOMPOSITIONATTRIB.WCA_FLIP3D_POLICY = 8
WINDOWCOMPOSITIONATTRIB.WCA_EXTENDED_FRAME_BOUNDS = 9
WINDOWCOMPOSITIONATTRIB.WCA_HAS_ICONIC_BITMAP = 10
WINDOWCOMPOSITIONATTRIB.WCA_THEME_ATTRIBUTES = 11
WINDOWCOMPOSITIONATTRIB.WCA_NCRENDERING_EXILED = 12
WINDOWCOMPOSITIONATTRIB.WCA_NCADORNMENTINFO = 13
WINDOWCOMPOSITIONATTRIB.WCA_EXCLUDED_FROM_LIVEPREVIEW = 14
WINDOWCOMPOSITIONATTRIB.WCA_VIDEO_OVERLAY_ACTIVE = 15
WINDOWCOMPOSITIONATTRIB.WCA_FORCE_ACTIVEWINDOW_APPEARANCE = 16
WINDOWCOMPOSITIONATTRIB.WCA_DISALLOW_PEEK = 17
WINDOWCOMPOSITIONATTRIB.WCA_LAST = 18


class tagTOUCHINPUTINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = THROBJHEAD()
        self.dwcInputs = v_uint32()
        self.uFlags = v_uint32()
        self.TouchInput = vstruct.VArray([ tagTOUCHINPUT() for i in xrange(1) ])


class tagHOOK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = THRDESKHEAD()
        self.phkNext = v_ptr32()
        self.iHook = v_uint32()
        self.offPfn = v_uint32()
        self.flags = v_uint32()
        self.ihmod = v_uint32()
        self.ptiHooked = v_ptr32()
        self.rpdesk = v_ptr32()
        self.nTimeout = v_uint32()


class VK_TO_WCHAR_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pVkToWchars = v_ptr32()
        self.nModifications = v_uint8()
        self.cbSize = v_uint8()
        self._pad0008 = v_bytes(size=2)


class D3DKMDT_2DREGION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cx = v_uint32()
        self.cy = v_uint32()


class DEADKEY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwBoth = v_uint32()
        self.wchComposed = v_uint16()
        self.uFlags = v_uint16()


class CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DosPath = UNICODE_STRING()
        self.Handle = v_ptr32()


class tagPROPLIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cEntries = v_uint32()
        self.iFirstFree = v_uint32()
        self.aprop = vstruct.VArray([ tagPROP() for i in xrange(1) ])


class tagDESKTOPINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pvDesktopBase = v_ptr32()
        self.pvDesktopLimit = v_ptr32()
        self.spwnd = v_ptr32()
        self.fsHooks = v_uint32()
        self.aphkStart = vstruct.VArray([ v_ptr32() for i in xrange(16) ])
        self.spwndShell = v_ptr32()
        self.ppiShellProcess = v_ptr32()
        self.spwndBkGnd = v_ptr32()
        self.spwndTaskman = v_ptr32()
        self.spwndProgman = v_ptr32()
        self.pvwplShellHook = v_ptr32()
        self.cntMBox = v_uint32()
        self.spwndGestureEngine = v_ptr32()
        self.pvwplMessagePPHandler = v_ptr32()
        self.fComposited = v_uint32()


class _unnamed_12849(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerSequence = v_ptr32()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SectionOffset = v_uint32()
        self.SectionLength = v_uint32()
        self.Revision = WHEA_REVISION()
        self.ValidBits = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS()
        self.Reserved = v_uint8()
        self.Flags = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS()
        self.SectionType = GUID()
        self.FRUId = GUID()
        self.SectionSeverity = v_uint32()
        self.FRUText = vstruct.VArray([ v_uint8() for i in xrange(20) ])


class VK_TO_FUNCTION_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vk = v_uint8()
        self.NLSFEProcType = v_uint8()
        self.NLSFEProcCurrent = v_uint8()
        self.NLSFEProcSwitch = v_uint8()
        self.NLSFEProc = vstruct.VArray([ VK_FUNCTION_PARAM() for i in xrange(8) ])
        self.NLSFEProcAlt = vstruct.VArray([ VK_FUNCTION_PARAM() for i in xrange(8) ])


class tagTHREADINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pEThread = v_ptr32()
        self.RefCount = v_uint32()
        self.ptlW32 = v_ptr32()
        self.pgdiDcattr = v_ptr32()
        self.pgdiBrushAttr = v_ptr32()
        self.pUMPDObjs = v_ptr32()
        self.pUMPDHeap = v_ptr32()
        self.pUMPDObj = v_ptr32()
        self.GdiTmpTgoList = LIST_ENTRY()
        self.pRBRecursionCount = v_uint32()
        self.pNonRBRecursionCount = v_uint32()
        self.tlSpriteState = TLSPRITESTATE()
        self.pSpriteState = v_ptr32()
        self.pDevHTInfo = v_ptr32()
        self.ulDevHTInfoUniqueness = v_uint32()
        self.pdcoAA = v_ptr32()
        self.pdcoRender = v_ptr32()
        self.pdcoSrc = v_ptr32()
        self.bEnableEngUpdateDeviceSurface = v_uint8()
        self.bIncludeSprites = v_uint8()
        self._pad00ac = v_bytes(size=2)
        self.ulWindowSystemRendering = v_uint32()
        self.iVisRgnUniqueness = v_uint32()
        self.ptl = v_ptr32()
        self.ppi = v_ptr32()
        self.pq = v_ptr32()
        self.spklActive = v_ptr32()
        self.pcti = v_ptr32()
        self.rpdesk = v_ptr32()
        self.pDeskInfo = v_ptr32()
        self.ulClientDelta = v_uint32()
        self.pClientInfo = v_ptr32()
        self.TIF_flags = v_uint32()
        self.pstrAppName = v_ptr32()
        self.psmsSent = v_ptr32()
        self.psmsCurrent = v_ptr32()
        self.psmsReceiveList = v_ptr32()
        self.timeLast = v_uint32()
        self.idLast = v_uint32()
        self.exitCode = v_uint32()
        self.hdesk = v_ptr32()
        self.cPaintsReady = v_uint32()
        self.cTimersReady = v_uint32()
        self.pMenuState = v_ptr32()
        self.ptdb = v_ptr32()
        self.psiiList = v_ptr32()
        self.dwExpWinVer = v_uint32()
        self.dwCompatFlags = v_uint32()
        self.dwCompatFlags2 = v_uint32()
        self._pad0120 = v_bytes(size=4)
        self.pqAttach = v_ptr32()
        self.ptiSibling = v_ptr32()
        self.pmsd = v_ptr32()
        self.fsHooks = v_uint32()
        self.sphkCurrent = v_ptr32()
        self.lParamHkCurrent = v_uint32()
        self.wParamHkCurrent = v_uint32()
        self.pSBTrack = v_ptr32()
        self.hEventQueueClient = v_ptr32()
        self.pEventQueueServer = v_ptr32()
        self.PtiLink = LIST_ENTRY()
        self.iCursorLevel = v_uint32()
        self.ptLast = tagPOINT()
        self.ptLastReal = tagPOINT()
        self.spwndDefaultIme = v_ptr32()
        self.spDefaultImc = v_ptr32()
        self.hklPrev = v_ptr32()
        self.cEnterCount = v_uint32()
        self.mlPost = tagMLIST()
        self.fsChangeBitsRemoved = v_uint16()
        self.wchInjected = v_uint16()
        self.fsReserveKeys = v_uint32()
        self.apEvent = v_ptr32()
        self.amdesk = v_uint32()
        self.cWindows = v_uint32()
        self.cVisWindows = v_uint32()
        self.aphkStart = vstruct.VArray([ v_ptr32() for i in xrange(16) ])
        self.cti = tagCLIENTTHREADINFO()
        self.hPrevHidData = v_ptr32()
        self.hTouchInputCurrent = v_ptr32()
        self.hGestureInfoCurrent = v_ptr32()
        self.MsgPPInfo = tagMSGPPINFO()
        self.cNestedStableVisRgn = v_uint32()
        self.readyHead = LIST_ENTRY()
        self.fSpecialInitialization = v_uint32()


class _unnamed_12843(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerState = v_uint32()


class D3DKMDT_VIDEO_SIGNAL_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VideoStandard = v_uint32()
        self.TotalSize = D3DKMDT_2DREGION()
        self.ActiveSize = D3DKMDT_2DREGION()
        self.VSyncFreq = D3DDDI_RATIONAL()
        self.HSyncFreq = D3DDDI_RATIONAL()
        self.PixelRate = v_uint32()
        self.ScanLineOrdering = v_uint32()


class CM_PARTIAL_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.PartialDescriptors = vstruct.VArray([ CM_PARTIAL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class HGESTUREINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class DEVICE_CAPABILITIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.DeviceD1 = v_uint32()
        self.Address = v_uint32()
        self.UINumber = v_uint32()
        self.DeviceState = vstruct.VArray([ DEVICE_POWER_STATE() for i in xrange(7) ])
        self.SystemWake = v_uint32()
        self.DeviceWake = v_uint32()
        self.D1Latency = v_uint32()
        self.D2Latency = v_uint32()
        self.D3Latency = v_uint32()


class TP_DIRECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callback = v_ptr32()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()
        self._pad000c = v_bytes(size=3)


class tagMONITOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = HEAD()
        self.pMonitorNext = v_ptr32()
        self.dwMONFlags = v_uint32()
        self.rcMonitorReal = tagRECT()
        self.rcWorkReal = tagRECT()
        self.hrgnMonitorReal = v_ptr32()
        self.Spare0 = v_uint16()
        self.cWndStack = v_uint16()
        self.hDev = v_ptr32()
        self.hDevReal = v_ptr32()
        self.DockTargets = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self.Flink = v_ptr32()
        self.Blink = v_ptr32()


class _unnamed_12410(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserApcRoutine = v_ptr32()
        self.UserApcContext = v_ptr32()


class _unnamed_12558(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.FileAttributes = v_uint16()
        self.ShareAccess = v_uint16()
        self.EaLength = v_uint32()


class _unnamed_12735(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()


class KPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class DEVICE_OBJECT_POWER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class tagTEXTMETRICW(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.tmHeight = v_uint32()
        self.tmAscent = v_uint32()
        self.tmDescent = v_uint32()
        self.tmInternalLeading = v_uint32()
        self.tmExternalLeading = v_uint32()
        self.tmAveCharWidth = v_uint32()
        self.tmMaxCharWidth = v_uint32()
        self.tmWeight = v_uint32()
        self.tmOverhang = v_uint32()
        self.tmDigitizedAspectX = v_uint32()
        self.tmDigitizedAspectY = v_uint32()
        self.tmFirstChar = v_uint16()
        self.tmLastChar = v_uint16()
        self.tmDefaultChar = v_uint16()
        self.tmBreakChar = v_uint16()
        self.tmItalic = v_uint8()
        self.tmUnderlined = v_uint8()
        self.tmStruckOut = v_uint8()
        self.tmPitchAndFamily = v_uint8()
        self.tmCharSet = v_uint8()
        self._pad003c = v_bytes(size=3)


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Primary = v_uint32()


class TP_CALLBACK_ENVIRON_V3(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint32()
        self.Pool = v_ptr32()
        self.CleanupGroup = v_ptr32()
        self.CleanupGroupCancelCallback = v_ptr32()
        self.RaceDll = v_ptr32()
        self.ActivationContext = v_ptr32()
        self.FinalizationCallback = v_ptr32()
        self.u = _unnamed_11730()
        self.CallbackPriority = v_uint32()
        self.Size = v_uint32()


class HDESK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class RTL_ACTIVATION_CONTEXT_STACK_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Previous = v_ptr32()
        self.ActivationContext = v_ptr32()
        self.Flags = v_uint32()


class OBJECT_HANDLE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleAttributes = v_uint32()
        self.GrantedAccess = v_uint32()


class XSTATE_CONFIGURATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnabledFeatures = v_uint64()
        self.Size = v_uint32()
        self.OptimizedSave = v_uint32()
        self.Features = vstruct.VArray([ XSTATE_FEATURE() for i in xrange(64) ])


class RTL_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = RTL_BALANCED_LINKS()
        self.OrderedPointer = v_ptr32()
        self.WhichOrderedElement = v_uint32()
        self.NumberGenericTableElements = v_uint32()
        self.DepthOfTree = v_uint32()
        self.RestartKey = v_ptr32()
        self.DeleteCount = v_uint32()
        self.CompareRoutine = v_ptr32()
        self.AllocateRoutine = v_ptr32()
        self.FreeRoutine = v_ptr32()
        self.TableContext = v_ptr32()


class tagHID_TLC_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.link = LIST_ENTRY()
        self.usUsagePage = v_uint16()
        self.usUsage = v_uint16()
        self.cDevices = v_uint32()
        self.cDirectRequest = v_uint32()
        self.cUsagePageRequest = v_uint32()
        self.cExcludeRequest = v_uint32()
        self.cExcludeOrphaned = v_uint32()


class WHEA_ERROR_PACKET_V2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Version = v_uint32()
        self.Length = v_uint32()
        self.Flags = WHEA_ERROR_PACKET_FLAGS()
        self.ErrorType = v_uint32()
        self.ErrorSeverity = v_uint32()
        self.ErrorSourceId = v_uint32()
        self.ErrorSourceType = v_uint32()
        self.NotifyType = GUID()
        self.Context = v_uint64()
        self.DataFormat = v_uint32()
        self.Reserved1 = v_uint32()
        self.DataOffset = v_uint32()
        self.DataLength = v_uint32()
        self.PshedDataOffset = v_uint32()
        self.PshedDataLength = v_uint32()


class DXGK_DIAG_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.Size = v_uint32()
        self.LogTimestamp = v_uint64()
        self.ProcessName = vstruct.VArray([ v_uint8() for i in xrange(16) ])
        self.ThreadId = v_uint64()
        self.Index = v_uint32()
        self.WdLogIdx = v_uint32()


class DMM_VIDPNPATHANDTARGETMODESET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PathInfo = D3DKMDT_VIDPN_PRESENT_PATH()
        self.TargetModeSet = DMM_VIDPNTARGETMODESET_SERIALIZATION()


class _unnamed_12744(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_ptr32()
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Interface = v_ptr32()
        self.InterfaceSpecificData = v_ptr32()


class VK_TO_WCHARS1(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualKey = v_uint8()
        self.Attributes = v_uint8()
        self.wch = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class OWNER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerThread = v_uint32()
        self.IoPriorityBoosted = v_uint32()


class DEVOBJ_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.PowerFlags = v_uint32()
        self.Dope = v_ptr32()
        self.ExtensionFlags = v_uint32()
        self.DeviceNode = v_ptr32()
        self.AttachedTo = v_ptr32()
        self.StartIoCount = v_uint32()
        self.StartIoKey = v_uint32()
        self.StartIoFlags = v_uint32()
        self.Vpb = v_ptr32()
        self.DependentList = LIST_ENTRY()
        self.ProviderList = LIST_ENTRY()


class D3DKMDT_MONITOR_FREQUENCY_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Origin = v_uint32()
        self.RangeLimits = D3DKMDT_FREQUENCY_RANGE()
        self.ConstraintType = v_uint32()
        self.Constraint = _unnamed_13453()


class tagQ(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.mlInput = tagMLIST()
        self.ptiSysLock = v_ptr32()
        self.idSysLock = v_uint32()
        self.idSysPeek = v_uint32()
        self.ptiMouse = v_ptr32()
        self.ptiKeyboard = v_ptr32()
        self.spwndCapture = v_ptr32()
        self.spwndFocus = v_ptr32()
        self.spwndActive = v_ptr32()
        self.spwndActivePrev = v_ptr32()
        self.codeCapture = v_uint32()
        self.msgDblClk = v_uint32()
        self.xbtnDblClk = v_uint16()
        self._pad003c = v_bytes(size=2)
        self.timeDblClk = v_uint32()
        self.hwndDblClk = v_ptr32()
        self.ptDblClk = tagPOINT()
        self.ptMouseMove = tagPOINT()
        self.afKeyRecentDown = vstruct.VArray([ v_uint8() for i in xrange(32) ])
        self.afKeyState = vstruct.VArray([ v_uint8() for i in xrange(64) ])
        self.caret = tagCARET()
        self.spcurCurrent = v_ptr32()
        self.iCursorLevel = v_uint32()
        self.QF_flags = v_uint32()
        self.cThreads = v_uint16()
        self.cLockCount = v_uint16()
        self.msgJournal = v_uint32()
        self.ExtraInfo = v_uint32()
        self.ulEtwReserved1 = v_uint32()


class tagCLS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pclsNext = v_ptr32()
        self.atomClassName = v_uint16()
        self.atomNVClassName = v_uint16()
        self.fnid = v_uint16()
        self._pad000c = v_bytes(size=2)
        self.rpdeskParent = v_ptr32()
        self.pdce = v_ptr32()
        self.hTaskWow = v_uint16()
        self.CSF_flags = v_uint16()
        self.lpszClientAnsiMenuName = v_ptr32()
        self.lpszClientUnicodeMenuName = v_ptr32()
        self.spcpdFirst = v_ptr32()
        self.pclsBase = v_ptr32()
        self.pclsClone = v_ptr32()
        self.cWndReferenceCount = v_uint32()
        self.style = v_uint32()
        self.lpfnWndProc = v_ptr32()
        self.cbclsExtra = v_uint32()
        self.cbwndExtra = v_uint32()
        self.hModule = v_ptr32()
        self.spicn = v_ptr32()
        self.spcur = v_ptr32()
        self.hbrBackground = v_ptr32()
        self.lpszMenuName = v_ptr32()
        self.lpszAnsiClassName = v_ptr32()
        self.spicnSm = v_ptr32()


class CALLPROCDATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = PROCDESKHEAD()
        self.spcpdNext = v_ptr32()
        self.pfnClientPrevious = v_uint32()
        self.wType = v_uint16()
        self._pad0020 = v_bytes(size=2)


class WM_VALUES_STRINGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pszName = v_ptr32()
        self.fInternal = v_uint8()
        self.fDefined = v_uint8()
        self._pad0008 = v_bytes(size=2)


class _unnamed_16080(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Channel = v_uint32()
        self.Port = v_uint32()
        self.Reserved1 = v_uint32()


class HIMC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class _unnamed_16086(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint32()
        self.Length = v_uint32()
        self.Reserved = v_uint32()


class LARGE_UNICODE_STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.MaximumLength = v_uint32()
        self.Buffer = v_ptr32()


class ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OperationID = LUID()
        self.SecurityEvaluated = v_uint8()
        self.GenerateAudit = v_uint8()
        self.GenerateOnClose = v_uint8()
        self.PrivilegesAllocated = v_uint8()
        self.Flags = v_uint32()
        self.RemainingDesiredAccess = v_uint32()
        self.PreviouslyGrantedAccess = v_uint32()
        self.OriginalDesiredAccess = v_uint32()
        self.SubjectSecurityContext = SECURITY_SUBJECT_CONTEXT()
        self.SecurityDescriptor = v_ptr32()
        self.AuxData = v_ptr32()
        self.Privileges = _unnamed_13037()
        self.AuditPrivileges = v_uint8()
        self._pad0064 = v_bytes(size=3)
        self.ObjectName = UNICODE_STRING()
        self.ObjectTypeName = UNICODE_STRING()


class TP_CALLBACK_INSTANCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class tagRECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.left = v_uint32()
        self.top = v_uint32()
        self.right = v_uint32()
        self.bottom = v_uint32()


class GDI_TEB_BATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.HDC = v_uint32()
        self.Buffer = vstruct.VArray([ v_uint32() for i in xrange(310) ])


class _unnamed_16100(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length64 = v_uint32()


class ECP_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class tagMENUSTATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pGlobalPopupMenu = v_ptr32()
        self.fMenuStarted = v_uint32()
        self.ptMouseLast = tagPOINT()
        self.mnFocus = v_uint32()
        self.cmdLast = v_uint32()
        self.ptiMenuStateOwner = v_ptr32()
        self.dwLockCount = v_uint32()
        self.pmnsPrev = v_ptr32()
        self.ptButtonDown = tagPOINT()
        self.uButtonDownHitArea = v_uint32()
        self.uButtonDownIndex = v_uint32()
        self.vkButtonDown = v_uint32()
        self.uDraggingHitArea = v_uint32()
        self.uDraggingIndex = v_uint32()
        self.uDraggingFlags = v_uint32()
        self.hdcWndAni = v_ptr32()
        self.dwAniStartTime = v_uint32()
        self.ixAni = v_uint32()
        self.iyAni = v_uint32()
        self.cxAni = v_uint32()
        self.cyAni = v_uint32()
        self.hbmAni = v_ptr32()
        self.hdcAni = v_ptr32()


class SECTION_OBJECT_POINTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSectionObject = v_ptr32()
        self.SharedCacheMap = v_ptr32()
        self.ImageSectionObject = v_ptr32()


class MDL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Size = v_uint16()
        self.MdlFlags = v_uint16()
        self.Process = v_ptr32()
        self.MappedSystemVa = v_ptr32()
        self.StartVa = v_ptr32()
        self.ByteCount = v_uint32()
        self.ByteOffset = v_uint32()


class tagMSGPPINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwIndexMsgPP = v_uint32()


class VWPLELEMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataOrTag = v_uint32()
        self.pwnd = v_ptr32()


class IO_TIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class VSC_VK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vsc = v_uint8()
        self._pad0002 = v_bytes(size=1)
        self.Vk = v_uint16()


class WHEA_REVISION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinorRevision = v_uint8()
        self.MajorRevision = v_uint8()


class MAGNIFICATION_INPUT_TRANSFORM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.rcSource = tagRECT()
        self.rcScreen = tagRECT()
        self.ptiMagThreadInfo = v_ptr32()
        self.magFactorX = v_uint32()
        self.magFactorY = v_uint32()


class TP_CLEANUP_GROUP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class DMM_VIDPNPATHANDTARGETMODE_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PathInfo = D3DKMDT_VIDPN_PRESENT_PATH()
        self.TargetMode = D3DKMDT_VIDPN_TARGET_MODE()


class D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_SUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NoProtection = v_uint32()


class D3DDDI_DXGI_RGB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Red = v_uint32()
        self.Green = v_uint32()
        self.Blue = v_uint32()


class OBJECT_TYPE_INITIALIZER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.ObjectTypeFlags = v_uint8()
        self._pad0004 = v_bytes(size=1)
        self.ObjectTypeCode = v_uint32()
        self.InvalidAttributes = v_uint32()
        self.GenericMapping = GENERIC_MAPPING()
        self.ValidAccessMask = v_uint32()
        self.RetainAccess = v_uint32()
        self.PoolType = v_uint32()
        self.DefaultPagedPoolCharge = v_uint32()
        self.DefaultNonPagedPoolCharge = v_uint32()
        self.DumpProcedure = v_ptr32()
        self.OpenProcedure = v_ptr32()
        self.CloseProcedure = v_ptr32()
        self.DeleteProcedure = v_ptr32()
        self.ParseProcedure = v_ptr32()
        self.SecurityProcedure = v_ptr32()
        self.QueryNameProcedure = v_ptr32()
        self.OkayToCloseProcedure = v_ptr32()


class MOVESIZEDATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.spwnd = v_ptr32()
        self.rcDrag = tagRECT()
        self.rcDragCursor = tagRECT()
        self.rcPreview = tagRECT()
        self.rcPreviewCursor = tagRECT()
        self.rcParent = tagRECT()
        self.ptMinTrack = tagPOINT()
        self.ptMaxTrack = tagPOINT()
        self.rcWindow = tagRECT()
        self.rcNormalStartCheckPt = tagRECT()
        self.dxMouse = v_uint32()
        self.dyMouse = v_uint32()
        self.cmd = v_uint32()
        self.impx = v_uint32()
        self.impy = v_uint32()
        self.ptRestore = tagPOINT()
        self.Flags = v_uint32()
        self.pStartMonitorCurrentHitTarget = v_ptr32()
        self.StartCurrentHitTarget = v_uint32()
        self.pMonitorCurrentHitTarget = v_ptr32()
        self.CurrentHitTarget = v_uint32()
        self.MoveRectStyle = v_uint32()
        self.ptHitWindowRelative = tagPOINT()
        self.ptStartHitWindowRelative = tagPOINT()
        self.ptLastTrack = tagPOINT()
        self.ulCountDragOutOfTopTarget = v_uint32()
        self.ulCountDragOutOfLeftRightTarget = v_uint32()
        self.ulCountSizeOutOfTopBottomTarget = v_uint32()


class SCSI_REQUEST_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_16620(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length64 = v_uint32()
        self.Alignment64 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class TLSPRITESTATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.bInsideDriverCall = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.flOriginalSurfFlags = v_uint32()
        self.iOriginalType = v_uint32()
        self.flSpriteSurfFlags = v_uint32()
        self.iSpriteType = v_uint32()
        self.flags = v_uint32()
        self.iType = v_uint32()
        self.pState = v_ptr32()
        self.pfnStrokeAndFillPath = v_ptr32()
        self.pfnStrokePath = v_ptr32()
        self.pfnFillPath = v_ptr32()
        self.pfnPaint = v_ptr32()
        self.pfnBitBlt = v_ptr32()
        self.pfnCopyBits = v_ptr32()
        self.pfnStretchBlt = v_ptr32()
        self.pfnTextOut = v_ptr32()
        self.pfnLineTo = v_ptr32()
        self.pfnTransparentBlt = v_ptr32()
        self.pfnAlphaBlend = v_ptr32()
        self.pfnPlgBlt = v_ptr32()
        self.pfnGradientFill = v_ptr32()
        self.pfnSaveScreenBits = v_ptr32()
        self.pfnStretchBltROP = v_ptr32()
        self.pfnDrawStream = v_ptr32()


class _unnamed_15886(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pRgb256x3x16 = v_ptr32()


class tagQMSG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pqmsgNext = v_ptr32()
        self.pqmsgPrev = v_ptr32()
        self.msg = tagMSG()
        self.ExtraInfo = v_uint32()
        self.ptMouseReal = tagPOINT()
        self.dwQEvent = v_uint32()
        self.Wow64Message = v_uint32()
        self.pti = v_ptr32()
        self.MsgPPInfo = tagMSGPPINFO()


class PAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = FAST_MUTEX()


class RTL_BITMAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfBitMap = v_uint32()
        self.Buffer = v_ptr32()


class LARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class HICON(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class NPAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = v_uint32()
        self._pad0050 = v_bytes(size=4)


class _unnamed_12830(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InPath = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])
        self.Type = v_uint32()


class tagWin32PoolHead(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.size = v_uint32()
        self.pPrev = v_ptr32()
        self.pNext = v_ptr32()
        self.pTrace = v_ptr32()


class _unnamed_12686(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FsInformationClass = v_uint32()


class VPB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.Flags = v_uint16()
        self.VolumeLabelLength = v_uint16()
        self.DeviceObject = v_ptr32()
        self.RealDevice = v_ptr32()
        self.SerialNumber = v_uint32()
        self.ReferenceCount = v_uint32()
        self.VolumeLabel = vstruct.VArray([ v_uint16() for i in xrange(32) ])


class _unnamed_12689(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self.InputBufferLength = v_uint32()
        self.FsControlCode = v_uint32()
        self.Type3InputBuffer = v_ptr32()


class HEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.h = v_ptr32()
        self.cLockObj = v_uint32()


class OBJECT_NAME_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = UNICODE_STRING()


class IO_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.Descriptors = vstruct.VArray([ IO_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class KUSER_SHARED_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TickCountLowDeprecated = v_uint32()
        self.TickCountMultiplier = v_uint32()
        self.InterruptTime = KSYSTEM_TIME()
        self.SystemTime = KSYSTEM_TIME()
        self.TimeZoneBias = KSYSTEM_TIME()
        self.ImageNumberLow = v_uint16()
        self.ImageNumberHigh = v_uint16()
        self.NtSystemRoot = vstruct.VArray([ v_uint16() for i in xrange(260) ])
        self.MaxStackTraceDepth = v_uint32()
        self.CryptoExponent = v_uint32()
        self.TimeZoneId = v_uint32()
        self.LargePageMinimum = v_uint32()
        self.Reserved2 = vstruct.VArray([ v_uint32() for i in xrange(7) ])
        self.NtProductType = v_uint32()
        self.ProductTypeIsValid = v_uint8()
        self._pad026c = v_bytes(size=3)
        self.NtMajorVersion = v_uint32()
        self.NtMinorVersion = v_uint32()
        self.ProcessorFeatures = vstruct.VArray([ v_uint8() for i in xrange(64) ])
        self.Reserved1 = v_uint32()
        self.Reserved3 = v_uint32()
        self.TimeSlip = v_uint32()
        self.AlternativeArchitecture = v_uint32()
        self.AltArchitecturePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.SystemExpirationDate = LARGE_INTEGER()
        self.SuiteMask = v_uint32()
        self.KdDebuggerEnabled = v_uint8()
        self.NXSupportPolicy = v_uint8()
        self._pad02d8 = v_bytes(size=2)
        self.ActiveConsoleId = v_uint32()
        self.DismountCount = v_uint32()
        self.ComPlusPackage = v_uint32()
        self.LastSystemRITEventTickCount = v_uint32()
        self.NumberOfPhysicalPages = v_uint32()
        self.SafeBootMode = v_uint8()
        self.TscQpcData = v_uint8()
        self.TscQpcPad = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.SharedDataFlags = v_uint32()
        self.DataFlagsPad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.TestRetInstruction = v_uint64()
        self.SystemCall = v_uint32()
        self.SystemCallReturn = v_uint32()
        self.SystemCallPad = vstruct.VArray([ v_uint64() for i in xrange(3) ])
        self.TickCount = KSYSTEM_TIME()
        self.TickCountPad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.Cookie = v_uint32()
        self.CookiePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.ConsoleSessionForegroundProcessId = v_uint64()
        self.Wow64SharedInformation = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.UserModeGlobalLogger = vstruct.VArray([ v_uint16() for i in xrange(16) ])
        self.ImageFileExecutionOptions = v_uint32()
        self.LangGenerationCount = v_uint32()
        self.Reserved5 = v_uint64()
        self.InterruptTimeBias = v_uint64()
        self.TscQpcBias = v_uint64()
        self.ActiveProcessorCount = v_uint32()
        self.ActiveGroupCount = v_uint16()
        self.Reserved4 = v_uint16()
        self.AitSamplingValue = v_uint32()
        self.AppCompatFlag = v_uint32()
        self.SystemDllNativeRelocation = v_uint64()
        self.SystemDllWowRelocation = v_uint32()
        self.XStatePad = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.XState = XSTATE_CONFIGURATION()


class SYSTEM_POWER_STATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved1 = v_uint32()


class _unnamed_12707(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self.SecurityDescriptor = v_ptr32()


class _unnamed_12704(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self.Length = v_uint32()


class IO_STATUS_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.Information = v_uint32()


class PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(1) ])


class CM_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.List = vstruct.VArray([ CM_FULL_RESOURCE_DESCRIPTOR() for i in xrange(1) ])


class _unnamed_12666(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileInformationClass = v_uint32()
        self.FileObject = v_ptr32()
        self.ReplaceIfExists = v_uint8()
        self.AdvanceOnly = v_uint8()
        self._pad0010 = v_bytes(size=2)


class EPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_12660(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.CompletionFilter = v_uint32()


class _unnamed_12663(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileInformationClass = v_uint32()


class tagPROFILEVALUEINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwValue = v_uint32()
        self.uSection = v_uint32()
        self.pwszKeyName = v_ptr32()


class TP_TASK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callbacks = v_ptr32()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()
        self._pad000c = v_bytes(size=3)
        self.PostGuard = TP_NBQ_GUARD()
        self.NBQNode = v_ptr32()


class TEB_ACTIVE_FRAME_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.FrameName = v_ptr32()


class PFNCLIENTWORKER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pfnButtonWndProc = v_ptr32()
        self.pfnComboBoxWndProc = v_ptr32()
        self.pfnComboListBoxProc = v_ptr32()
        self.pfnDialogWndProc = v_ptr32()
        self.pfnEditWndProc = v_ptr32()
        self.pfnListBoxWndProc = v_ptr32()
        self.pfnMDIClientWndProc = v_ptr32()
        self.pfnStaticWndProc = v_ptr32()
        self.pfnImeWndProc = v_ptr32()
        self.pfnGhostWndProc = v_ptr32()
        self.pfnCtfHookProc = v_ptr32()


class DMM_COMMITVIDPNREQUESTSET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumCommitVidPnRequests = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.CommitVidPnRequestOffset = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class D3DKMDT_MONITOR_SOURCE_MODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint32()
        self.VideoSignalInfo = D3DKMDT_VIDEO_SIGNAL_INFO()
        self.ColorBasis = v_uint32()
        self.ColorCoeffDynamicRanges = D3DKMDT_COLOR_COEFF_DYNAMIC_RANGES()
        self.Origin = v_uint32()
        self.Preference = v_uint32()


class tagDISPLAYINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.hDev = v_ptr32()
        self.pmdev = v_ptr32()
        self.hDevInfo = v_ptr32()
        self.hdcScreen = v_ptr32()
        self.hdcBits = v_ptr32()
        self.hdcGray = v_ptr32()
        self.hbmGray = v_ptr32()
        self.cxGray = v_uint32()
        self.cyGray = v_uint32()
        self.pdceFirst = v_ptr32()
        self.pspbFirst = v_ptr32()
        self.cMonitors = v_uint32()
        self.pMonitorPrimary = v_ptr32()
        self.pMonitorFirst = v_ptr32()
        self.rcScreenReal = tagRECT()
        self.hrgnScreenReal = v_ptr32()
        self.dmLogPixels = v_uint16()
        self.BitCountMax = v_uint16()
        self.fDesktopIsRect = v_uint32()
        self.DockThresholdMax = v_uint32()
        self.SpatialListHead = KLIST_ENTRY()
        self.cFullScreen = v_uint16()
        self.Spare0 = v_uint16()


class CM_PARTIAL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Flags = v_uint16()
        self.u = _unnamed_15793()


class _unnamed_13381(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Graphics = D3DKMDT_GRAPHICS_RENDERING_FORMAT()


class HRGN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class OBJECT_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.RootDirectory = v_ptr32()
        self.ObjectName = v_ptr32()
        self.Attributes = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.SecurityQualityOfService = v_ptr32()


class _unnamed_16067(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint16()
        self.Group = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint32()


class CM_FULL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.PartialResourceList = CM_PARTIAL_RESOURCE_LIST()


class _unnamed_16064(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length = v_uint32()


class FAST_IO_DISPATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFastIoDispatch = v_uint32()
        self.FastIoCheckIfPossible = v_ptr32()
        self.FastIoRead = v_ptr32()
        self.FastIoWrite = v_ptr32()
        self.FastIoQueryBasicInfo = v_ptr32()
        self.FastIoQueryStandardInfo = v_ptr32()
        self.FastIoLock = v_ptr32()
        self.FastIoUnlockSingle = v_ptr32()
        self.FastIoUnlockAll = v_ptr32()
        self.FastIoUnlockAllByKey = v_ptr32()
        self.FastIoDeviceControl = v_ptr32()
        self.AcquireFileForNtCreateSection = v_ptr32()
        self.ReleaseFileForNtCreateSection = v_ptr32()
        self.FastIoDetachDevice = v_ptr32()
        self.FastIoQueryNetworkOpenInfo = v_ptr32()
        self.AcquireForModWrite = v_ptr32()
        self.MdlRead = v_ptr32()
        self.MdlReadComplete = v_ptr32()
        self.PrepareMdlWrite = v_ptr32()
        self.MdlWriteComplete = v_ptr32()
        self.FastIoReadCompressed = v_ptr32()
        self.FastIoWriteCompressed = v_ptr32()
        self.MdlReadCompleteCompressed = v_ptr32()
        self.MdlWriteCompleteCompressed = v_ptr32()
        self.FastIoQueryOpen = v_ptr32()
        self.ReleaseForModWrite = v_ptr32()
        self.AcquireForCcFlush = v_ptr32()
        self.ReleaseForCcFlush = v_ptr32()


class VSC_LPWSTR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.vsc = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.pwsz = v_ptr32()


class _unnamed_12389(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MasterIrp = v_ptr32()


class KFLOATING_SAVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint32()
        self.StatusWord = v_uint32()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint32()
        self.Cr0NpxState = v_uint32()
        self.Spare1 = v_uint32()


class RTL_DYNAMIC_HASH_TABLE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ChainHead = v_ptr32()
        self.PrevLinkage = v_ptr32()
        self.Signature = v_uint32()


class tagSBDATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.posMin = v_uint32()
        self.posMax = v_uint32()
        self.page = v_uint32()
        self.pos = v_uint32()


class D3DDDI_GAMMA_RAMP_RGB256x3x16(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Red = vstruct.VArray([ v_uint16() for i in xrange(256) ])
        self.Green = vstruct.VArray([ v_uint16() for i in xrange(256) ])
        self.Blue = vstruct.VArray([ v_uint16() for i in xrange(256) ])


class tagUAHMENUPOPUPMETRICS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.rgcx = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.fUpdateMaxWidths = v_uint32()


class THROBJHEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.h = v_ptr32()
        self.cLockObj = v_uint32()
        self.pti = v_ptr32()


class DMM_VIDPNTARGETMODESET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumModes = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.ModeSerialization = vstruct.VArray([ D3DKMDT_VIDPN_TARGET_MODE() for i in xrange(1) ])


class KSPECIAL_REGISTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cr0 = v_uint32()
        self.Cr2 = v_uint32()
        self.Cr3 = v_uint32()
        self.Cr4 = v_uint32()
        self.KernelDr0 = v_uint32()
        self.KernelDr1 = v_uint32()
        self.KernelDr2 = v_uint32()
        self.KernelDr3 = v_uint32()
        self.KernelDr6 = v_uint32()
        self.KernelDr7 = v_uint32()
        self.Gdtr = DESCRIPTOR()
        self.Idtr = DESCRIPTOR()
        self.Tr = v_uint16()
        self.Ldtr = v_uint16()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(6) ])


class TP_NBQ_GUARD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GuardLinks = LIST_ENTRY()
        self.Guards = vstruct.VArray([ v_ptr32() for i in xrange(2) ])


class RTL_CRITICAL_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DebugInfo = v_ptr32()
        self.LockCount = v_uint32()
        self.RecursionCount = v_uint32()
        self.OwningThread = v_ptr32()
        self.LockSemaphore = v_ptr32()
        self.SpinCount = v_uint32()


class KSYSTEM_TIME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.High1Time = v_uint32()
        self.High2Time = v_uint32()


class tagTOUCHINPUT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.x = v_uint32()
        self.y = v_uint32()
        self.hSource = v_ptr32()
        self.dwID = v_uint32()
        self.dwFlags = v_uint32()
        self.dwMask = v_uint32()
        self.dwTime = v_uint32()
        self.dwExtraInfo = v_uint32()
        self.cxContact = v_uint32()
        self.cyContact = v_uint32()


class WNDMSG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.maxMsgs = v_uint32()
        self.abMsgs = v_ptr32()


class D3DDDI_RATIONAL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Numerator = v_uint32()
        self.Denominator = v_uint32()


class LUID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Luid = LUID()
        self.Attributes = v_uint32()


class tagSBTRACK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.fHitOld = v_uint32()
        self.spwndTrack = v_ptr32()
        self.spwndSB = v_ptr32()
        self.spwndSBNotify = v_ptr32()
        self.rcTrack = tagRECT()
        self.xxxpfnSB = v_ptr32()
        self.cmdSB = v_uint32()
        self.hTimerSB = v_uint32()
        self.dpxThumb = v_uint32()
        self.pxOld = v_uint32()
        self.posOld = v_uint32()
        self.posNew = v_uint32()
        self.nBar = v_uint32()
        self.pSBCalc = v_ptr32()


class KPROCESSOR_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFrame = CONTEXT()
        self.SpecialRegisters = KSPECIAL_REGISTERS()


class KTHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class HFONT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class tagDPISERVERINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.gclBorder = v_uint32()
        self.hCaptionFont = v_ptr32()
        self.hMsgFont = v_ptr32()
        self.cxMsgFontChar = v_uint32()
        self.cyMsgFontChar = v_uint32()
        self.wMaxBtnSize = v_uint32()


class _unnamed_12876(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemContext = v_uint32()
        self.Type = v_uint32()
        self.State = POWER_STATE()
        self.ShutdownType = v_uint32()


class HDC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFlags = v_uint32()
        self.Dr0 = v_uint32()
        self.Dr1 = v_uint32()
        self.Dr2 = v_uint32()
        self.Dr3 = v_uint32()
        self.Dr6 = v_uint32()
        self.Dr7 = v_uint32()
        self.FloatSave = FLOATING_SAVE_AREA()
        self.SegGs = v_uint32()
        self.SegFs = v_uint32()
        self.SegEs = v_uint32()
        self.SegDs = v_uint32()
        self.Edi = v_uint32()
        self.Esi = v_uint32()
        self.Ebx = v_uint32()
        self.Edx = v_uint32()
        self.Ecx = v_uint32()
        self.Eax = v_uint32()
        self.Ebp = v_uint32()
        self.Eip = v_uint32()
        self.SegCs = v_uint32()
        self.EFlags = v_uint32()
        self.Esp = v_uint32()
        self.SegSs = v_uint32()
        self.ExtendedRegisters = vstruct.VArray([ v_uint8() for i in xrange(512) ])


class AUX_ACCESS_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegesUsed = v_ptr32()
        self.GenericMapping = GENERIC_MAPPING()
        self.AccessesToAudit = v_uint32()
        self.MaximumAuditMask = v_uint32()
        self.TransactionId = GUID()
        self.NewSecurityDescriptor = v_ptr32()
        self.ExistingSecurityDescriptor = v_ptr32()
        self.ParentSecurityDescriptor = v_ptr32()
        self.DeRefSecurityDescriptor = v_ptr32()
        self.SDLock = v_ptr32()
        self.AccessReasons = ACCESS_REASONS()


class LIGATURE1(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualKey = v_uint8()
        self._pad0002 = v_bytes(size=1)
        self.ModificationNumber = v_uint16()
        self.wch = vstruct.VArray([ v_uint16() for i in xrange(1) ])


class _unnamed_12586(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self.Parameters = v_ptr32()


class D3DKMDT_VIDPN_PRESENT_PATH_SCALING_SUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Identity = v_uint32()


class EVENT_DATA_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Ptr = v_uint64()
        self.Size = v_uint32()
        self.Reserved = v_uint32()


class IO_DRIVER_CREATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self._pad0004 = v_bytes(size=2)
        self.ExtraCreateParameter = v_ptr32()
        self.DeviceObjectHint = v_ptr32()
        self.TxnParameters = v_ptr32()


class D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CopyProtectionType = v_uint32()
        self.APSTriggerBits = v_uint32()
        self.OEMCopyProtection = vstruct.VArray([ v_uint8() for i in xrange(256) ])
        self.CopyProtectionSupport = D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_SUPPORT()


class HMONITOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class EJOB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class D3DKMDT_GAMMA_RAMP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.DataSize = v_uint32()
        self.Data = _unnamed_15886()


class VK_TO_BIT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vk = v_uint8()
        self.ModBits = v_uint8()


class MODIFIERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pVkToBit = v_ptr32()
        self.wMaxModBits = v_uint16()
        self.ModNumber = vstruct.VArray([ v_uint8() for i in xrange(0) ])
        self._pad0008 = v_bytes(size=2)


class KAPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.SpareByte0 = v_uint8()
        self.Size = v_uint8()
        self.SpareByte1 = v_uint8()
        self.SpareLong0 = v_uint32()
        self.Thread = v_ptr32()
        self.ApcListEntry = LIST_ENTRY()
        self.KernelRoutine = v_ptr32()
        self.RundownRoutine = v_ptr32()
        self.NormalRoutine = v_ptr32()
        self.NormalContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.ApcStateIndex = v_uint8()
        self.ApcMode = v_uint8()
        self.Inserted = v_uint8()
        self._pad0030 = v_bytes(size=1)


class DMM_MONITOR_SOURCE_MODE_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Info = D3DKMDT_MONITOR_SOURCE_MODE()
        self.TimingType = v_uint32()


class tagIMEINFOEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.hkl = v_ptr32()
        self.ImeInfo = tagIMEINFO()
        self.wszUIClass = vstruct.VArray([ v_uint16() for i in xrange(16) ])
        self.fdwInitConvMode = v_uint32()
        self.fInitOpen = v_uint32()
        self.fLoadFlag = v_uint32()
        self.dwProdVersion = v_uint32()
        self.dwImeWinVersion = v_uint32()
        self.wszImeDescription = vstruct.VArray([ v_uint16() for i in xrange(50) ])
        self.wszImeFile = vstruct.VArray([ v_uint16() for i in xrange(80) ])
        self.fSysWow64Only = v_uint32()


class tagWND(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = THRDESKHEAD()
        self.state = v_uint32()
        self.state2 = v_uint32()
        self.ExStyle = v_uint32()
        self.style = v_uint32()
        self.hModule = v_ptr32()
        self.hMod16 = v_uint16()
        self.fnid = v_uint16()
        self.spwndNext = v_ptr32()
        self.spwndPrev = v_ptr32()
        self.spwndParent = v_ptr32()
        self.spwndChild = v_ptr32()
        self.spwndOwner = v_ptr32()
        self.rcWindow = tagRECT()
        self.rcClient = tagRECT()
        self.lpfnWndProc = v_ptr32()
        self.pcls = v_ptr32()
        self.hrgnUpdate = v_ptr32()
        self.ppropList = v_ptr32()
        self.pSBInfo = v_ptr32()
        self.spmenuSys = v_ptr32()
        self.spmenu = v_ptr32()
        self.hrgnClip = v_ptr32()
        self.hrgnNewFrame = v_ptr32()
        self.strName = LARGE_UNICODE_STRING()
        self.cbwndExtra = v_uint32()
        self.spwndLastActive = v_ptr32()
        self.hImc = v_ptr32()
        self.dwUserData = v_uint32()
        self.pActCtx = v_ptr32()
        self.pTransform = v_ptr32()
        self.spwndClipboardListenerNext = v_ptr32()
        self.ExStyle2 = v_uint32()


class XSTATE_FEATURE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.Size = v_uint32()


class _unnamed_12896(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr32()
        self.Argument2 = v_ptr32()
        self.Argument3 = v_ptr32()
        self.Argument4 = v_ptr32()


class D3DDDI_GAMMA_RAMP_DXGI_1(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Scale = D3DDDI_DXGI_RGB()
        self.Offset = D3DDDI_DXGI_RGB()
        self.GammaCurve = vstruct.VArray([ D3DDDI_DXGI_RGB() for i in xrange(1025) ])


class WHEA_TIMESTAMP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Seconds = v_uint64()


class ACTIVATION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_12891(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProviderId = v_uint32()
        self.DataPath = v_ptr32()
        self.BufferSize = v_uint32()
        self.Buffer = v_ptr32()


class tagUAHMENUITEMMETRICS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.rgsizeBar = vstruct.VArray([ tagSIZE() for i in xrange(2) ])
        self._pad0020 = v_bytes(size=16)


class KLIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_ptr32()
        self.Blink = v_ptr32()


class RTL_CRITICAL_SECTION_DEBUG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self.CriticalSection = v_ptr32()
        self.ProcessLocksList = LIST_ENTRY()
        self.EntryCount = v_uint32()
        self.ContentionCount = v_uint32()
        self.Flags = v_uint32()
        self.CreatorBackTraceIndexHigh = v_uint16()
        self.SpareUSHORT = v_uint16()


class DISPATCHER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.TimerControlFlags = v_uint8()
        self.ThreadControlFlags = v_uint8()
        self.TimerMiscFlags = v_uint8()
        self.SignalState = v_uint32()
        self.WaitListHead = LIST_ENTRY()


class HBITMAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class tagW32JOB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pNext = v_ptr32()
        self.Job = v_ptr32()
        self.pAtomTable = v_ptr32()
        self.restrictions = v_uint32()
        self.uProcessCount = v_uint32()
        self.uMaxProcesses = v_uint32()
        self.ppiTable = v_ptr32()
        self.ughCrt = v_uint32()
        self.ughMax = v_uint32()
        self.pgh = v_ptr32()


class ASSEMBLY_STORAGE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class tagMBSTRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.szName = vstruct.VArray([ v_uint16() for i in xrange(15) ])
        self._pad0020 = v_bytes(size=2)
        self.uID = v_uint32()
        self.uStr = v_uint32()


class POWER_SEQUENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SequenceD1 = v_uint32()
        self.SequenceD2 = v_uint32()
        self.SequenceD3 = v_uint32()


class DMM_MONITORDESCRIPTOR_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint32()
        self.Type = v_uint32()
        self.Origin = v_uint32()
        self.Data = vstruct.VArray([ v_uint8() for i in xrange(128) ])


class DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pad = v_uint16()
        self.Limit = v_uint16()
        self.Base = v_uint32()


class PROCDESKHEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.h = v_ptr32()
        self.cLockObj = v_uint32()
        self.hTaskWow = v_uint32()
        self.rpdesk = v_ptr32()
        self.pSelf = v_ptr32()


class SM_VALUES_STRINGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pszName = v_ptr32()
        self.ulValue = v_uint32()
        self.RangeType = v_uint32()
        self.StorageType = v_uint32()


class HBRUSH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class SECURITY_QUALITY_OF_SERVICE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.ImpersonationLevel = v_uint32()
        self.ContextTrackingMode = v_uint8()
        self.EffectiveOnly = v_uint8()
        self._pad000c = v_bytes(size=2)


class _unnamed_12471(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Create = _unnamed_12558()


class WHEA_ERROR_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = WHEA_ERROR_RECORD_HEADER()
        self.SectionDescriptor = vstruct.VArray([ WHEA_ERROR_RECORD_SECTION_DESCRIPTOR() for i in xrange(1) ])


class LUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class tagDESKTOP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwSessionId = v_uint32()
        self.pDeskInfo = v_ptr32()
        self.pDispInfo = v_ptr32()
        self.rpdeskNext = v_ptr32()
        self.rpwinstaParent = v_ptr32()
        self.dwDTFlags = v_uint32()
        self.dwDesktopId = v_uint32()
        self.spmenuSys = v_ptr32()
        self.spmenuDialogSys = v_ptr32()
        self.spmenuHScroll = v_ptr32()
        self.spmenuVScroll = v_ptr32()
        self.spwndForeground = v_ptr32()
        self.spwndTray = v_ptr32()
        self.spwndMessage = v_ptr32()
        self.spwndTooltip = v_ptr32()
        self.hsectionDesktop = v_ptr32()
        self.pheapDesktop = v_ptr32()
        self.ulHeapSize = v_uint32()
        self.cciConsole = CONSOLE_CARET_INFO()
        self.PtiList = LIST_ENTRY()
        self.spwndTrack = v_ptr32()
        self.htEx = v_uint32()
        self.rcMouseHover = tagRECT()
        self.dwMouseHoverTime = v_uint32()
        self.pMagInputTransform = v_ptr32()


class tagPOOLRECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExtraData = v_ptr32()
        self.size = v_uint32()
        self.trace = vstruct.VArray([ v_ptr32() for i in xrange(6) ])


class CLIENT_ID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_ptr32()
        self.UniqueThread = v_ptr32()


class OBJECT_DUMP_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Stream = v_ptr32()
        self.Detail = v_uint32()


class _unnamed_15793(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Generic = _unnamed_16064()


class _unnamed_16610(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length40 = v_uint32()
        self.Alignment40 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class _unnamed_16615(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length48 = v_uint32()
        self.Alignment48 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class tagSPB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pspbNext = v_ptr32()
        self.spwnd = v_ptr32()
        self.hbm = v_ptr32()
        self.rc = tagRECT()
        self.hrgn = v_ptr32()
        self.flags = v_uint32()
        self.ulSaveId = v_uint32()


class DMM_VIDPNSET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumVidPns = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.VidPnOffset = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class TP_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class tagPROP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.hData = v_ptr32()
        self.atomKey = v_uint16()
        self.fs = v_uint16()


class _unnamed_12822(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceTextType = v_uint32()
        self.LocaleId = v_uint32()


class LIST_ENTRY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint32()
        self.Blink = v_uint32()


class SINGLE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()


class KDEVICE_QUEUE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceListEntry = LIST_ENTRY()
        self.SortKey = v_uint32()
        self.Inserted = v_uint8()
        self._pad0010 = v_bytes(size=3)


class D3DKMDT_VIDPN_SOURCE_MODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint32()
        self.Type = v_uint32()
        self.Format = _unnamed_13381()


class _unnamed_12574(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self.Parameters = v_ptr32()


class tagCLIENTTHREADINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CTIF_flags = v_uint32()
        self.fsChangeBits = v_uint16()
        self.fsWakeBits = v_uint16()
        self.fsWakeBitsJournal = v_uint16()
        self.fsWakeMask = v_uint16()
        self.tickLastMsgChecked = v_uint32()


class tagKbdNlsLayer(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OEMIdentifier = v_uint16()
        self.LayoutInformation = v_uint16()
        self.NumOfVkToF = v_uint32()
        self.pVkToF = v_ptr32()
        self.NumOfMouseVKey = v_uint32()
        self.pusMouseVKey = v_ptr32()


class _unnamed_12654(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileName = v_ptr32()
        self.FileInformationClass = v_uint32()
        self.FileIndex = v_uint32()


class KSPIN_LOCK_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Lock = v_ptr32()


class tagPROCESS_HID_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.link = LIST_ENTRY()
        self.InclusionList = LIST_ENTRY()
        self.UsagePageList = LIST_ENTRY()
        self.ExclusionList = LIST_ENTRY()
        self.spwndTargetMouse = v_ptr32()
        self.spwndTargetKbd = v_ptr32()
        self.nSinks = v_uint32()
        self.pLastRequest = v_ptr32()
        self.UsagePageLast = v_uint16()
        self.UsageLast = v_uint16()
        self.fRawMouse = v_uint32()


class WHEA_ERROR_PACKET_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousError = v_uint32()


class IO_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Option = v_uint8()
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Spare1 = v_uint8()
        self.Flags = v_uint16()
        self.Spare2 = v_uint16()
        self.u = _unnamed_16049()


class EX_PUSH_LOCK_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locks = vstruct.VArray([ v_ptr32() for i in xrange(1) ])


class tagMLIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pqmsgRead = v_ptr32()
        self.pqmsgWriteLast = v_ptr32()
        self.cMsgs = v_uint32()


class DMM_MONITORDESCRIPTORSET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumDescriptors = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.DescriptorSerialization = vstruct.VArray([ DMM_MONITORDESCRIPTOR_SERIALIZATION() for i in xrange(1) ])


class tagCLIP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.fmt = v_uint32()
        self.hData = v_ptr32()
        self.fGlobalHandle = v_uint32()


class tagSMS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.psmsNext = v_ptr32()
        self.psmsReceiveNext = v_ptr32()
        self.ptiSender = v_ptr32()
        self.ptiReceiver = v_ptr32()
        self.lpResultCallBack = v_ptr32()
        self.dwData = v_uint32()
        self.ptiCallBackSender = v_ptr32()
        self.lRet = v_uint32()
        self.tSent = v_uint32()
        self.flags = v_uint32()
        self.wParam = v_uint32()
        self.lParam = v_uint32()
        self.message = v_uint32()
        self.spwnd = v_ptr32()
        self.pvCapture = v_ptr32()


class IMAGE_OPTIONAL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint16()
        self.MajorLinkerVersion = v_uint8()
        self.MinorLinkerVersion = v_uint8()
        self.SizeOfCode = v_uint32()
        self.SizeOfInitializedData = v_uint32()
        self.SizeOfUninitializedData = v_uint32()
        self.AddressOfEntryPoint = v_uint32()
        self.BaseOfCode = v_uint32()
        self.BaseOfData = v_uint32()
        self.ImageBase = v_uint32()
        self.SectionAlignment = v_uint32()
        self.FileAlignment = v_uint32()
        self.MajorOperatingSystemVersion = v_uint16()
        self.MinorOperatingSystemVersion = v_uint16()
        self.MajorImageVersion = v_uint16()
        self.MinorImageVersion = v_uint16()
        self.MajorSubsystemVersion = v_uint16()
        self.MinorSubsystemVersion = v_uint16()
        self.Win32VersionValue = v_uint32()
        self.SizeOfImage = v_uint32()
        self.SizeOfHeaders = v_uint32()
        self.CheckSum = v_uint32()
        self.Subsystem = v_uint16()
        self.DllCharacteristics = v_uint16()
        self.SizeOfStackReserve = v_uint32()
        self.SizeOfStackCommit = v_uint32()
        self.SizeOfHeapReserve = v_uint32()
        self.SizeOfHeapCommit = v_uint32()
        self.LoaderFlags = v_uint32()
        self.NumberOfRvaAndSizes = v_uint32()
        self.DataDirectory = vstruct.VArray([ IMAGE_DATA_DIRECTORY() for i in xrange(16) ])


class _unnamed_12786(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Capabilities = v_ptr32()


class ETHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class FAST_MUTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Owner = v_ptr32()
        self.Contention = v_uint32()
        self.Event = KEVENT()
        self.OldIrql = v_uint32()


class WHEA_ERROR_RECORD_HEADER_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PlatformId = v_uint32()


class D3DKMDT_VIDPN_PRESENT_PATH_TRANSFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Scaling = v_uint32()
        self.ScalingSupport = D3DKMDT_VIDPN_PRESENT_PATH_SCALING_SUPPORT()
        self.Rotation = v_uint32()
        self.RotationSupport = D3DKMDT_VIDPN_PRESENT_PATH_ROTATION_SUPPORT()


class KDEVICE_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceListHead = LIST_ENTRY()
        self.Lock = v_uint32()
        self.Busy = v_uint8()
        self._pad0014 = v_bytes(size=3)


class CALLBACKWND(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.hwnd = v_ptr32()
        self.pwnd = v_ptr32()
        self.pActCtx = v_ptr32()


class _unnamed_12395(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Overlay = _unnamed_12510()
        self._pad0030 = v_bytes(size=8)


class IO_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityQos = v_ptr32()
        self.AccessState = v_ptr32()
        self.DesiredAccess = v_uint32()
        self.FullCreateOptions = v_uint32()


class tagSIZE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cx = v_uint32()
        self.cy = v_uint32()


class tagDESKTOPVIEW(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pdvNext = v_ptr32()
        self.pdesk = v_ptr32()
        self.ulClientDelta = v_uint32()


class _unnamed_12392(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsynchronousParameters = _unnamed_12410()


class PROCMARKHEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.h = v_ptr32()
        self.cLockObj = v_uint32()
        self.hTaskWow = v_uint32()
        self.ppi = v_ptr32()


class INITIAL_PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = vstruct.VArray([ LUID_AND_ATTRIBUTES() for i in xrange(3) ])


class D3DKMDT_COLOR_COEFF_DYNAMIC_RANGES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FirstChannel = v_uint32()
        self.SecondChannel = v_uint32()
        self.ThirdChannel = v_uint32()
        self.FourthChannel = v_uint32()


class WHEA_ERROR_RECORD_HEADER_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Recovered = v_uint32()


class _unnamed_15582(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Attrib = v_uint32()
        self.cbData = v_uint32()


class _unnamed_15585(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Attrib = v_uint32()
        self.cbData = v_uint32()


class D3DKMDT_FREQUENCY_RANGE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinVSyncFreq = D3DDDI_RATIONAL()
        self.MaxVSyncFreq = D3DDDI_RATIONAL()
        self.MinHSyncFreq = D3DDDI_RATIONAL()
        self.MaxHSyncFreq = D3DDDI_RATIONAL()


class PFNCLIENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pfnScrollBarWndProc = v_ptr32()
        self.pfnTitleWndProc = v_ptr32()
        self.pfnMenuWndProc = v_ptr32()
        self.pfnDesktopWndProc = v_ptr32()
        self.pfnDefWindowProc = v_ptr32()
        self.pfnMessageWindowProc = v_ptr32()
        self.pfnSwitchWindowProc = v_ptr32()
        self.pfnButtonWndProc = v_ptr32()
        self.pfnComboBoxWndProc = v_ptr32()
        self.pfnComboListBoxProc = v_ptr32()
        self.pfnDialogWndProc = v_ptr32()
        self.pfnEditWndProc = v_ptr32()
        self.pfnListBoxWndProc = v_ptr32()
        self.pfnMDIClientWndProc = v_ptr32()
        self.pfnStaticWndProc = v_ptr32()
        self.pfnImeWndProc = v_ptr32()
        self.pfnGhostWndProc = v_ptr32()
        self.pfnHkINLPCWPSTRUCT = v_ptr32()
        self.pfnHkINLPCWPRETSTRUCT = v_ptr32()
        self.pfnDispatchHook = v_ptr32()
        self.pfnDispatchDefWindowProc = v_ptr32()
        self.pfnDispatchMessage = v_ptr32()
        self.pfnMDIActivateDlgProc = v_ptr32()


class ACTIVATION_CONTEXT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class FILE_NETWORK_OPEN_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0038 = v_bytes(size=4)


class TEB_ACTIVE_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.Previous = v_ptr32()
        self.Context = v_ptr32()


class tagSVR_INSTANCE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = THROBJHEAD()
        self.next = v_ptr32()
        self.nextInThisThread = v_ptr32()
        self.afCmd = v_uint32()
        self.spwndEvent = v_ptr32()
        self.pcii = v_ptr32()


class RTL_DRIVE_LETTER_CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint16()
        self.Length = v_uint16()
        self.TimeStamp = v_uint32()
        self.DosPath = STRING()


class GENERAL_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr32()
        self.FreeEx = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])


class VWPL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cPwnd = v_uint32()
        self.cElem = v_uint32()
        self.cThreshhold = v_uint32()
        self.fTagged = v_uint32()
        self.aElement = vstruct.VArray([ VWPLELEMENT() for i in xrange(0) ])


class KPRCB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinorVersion = v_uint16()
        self.MajorVersion = v_uint16()
        self.CurrentThread = v_ptr32()
        self.NextThread = v_ptr32()
        self.IdleThread = v_ptr32()
        self.LegacyNumber = v_uint8()
        self.NestingLevel = v_uint8()
        self.BuildType = v_uint16()
        self.CpuType = v_uint8()
        self.CpuID = v_uint8()
        self.CpuStep = v_uint16()
        self.ProcessorState = KPROCESSOR_STATE()
        self.KernelReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.HalReserved = vstruct.VArray([ v_uint32() for i in xrange(16) ])
        self.CFlushSize = v_uint32()
        self.CoresPerPhysicalProcessor = v_uint8()
        self.LogicalProcessorsPerCore = v_uint8()
        self.PrcbPad0 = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.MHz = v_uint32()
        self.CpuVendor = v_uint8()
        self.GroupIndex = v_uint8()
        self.Group = v_uint16()
        self.GroupSetMember = v_uint32()
        self.Number = v_uint32()
        self.PrcbPad1 = vstruct.VArray([ v_uint8() for i in xrange(72) ])
        self.LockQueue = vstruct.VArray([ KSPIN_LOCK_QUEUE() for i in xrange(17) ])


class ULARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class tagCURSOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = PROCMARKHEAD()
        self.pcurNext = v_ptr32()
        self.strName = UNICODE_STRING()
        self.atomModName = v_uint16()
        self.rt = v_uint16()
        self.CURSORF_flags = v_uint32()
        self.xHotspot = v_uint16()
        self.yHotspot = v_uint16()
        self.hbmMask = v_ptr32()
        self.hbmColor = v_ptr32()
        self.hbmAlpha = v_ptr32()
        self.rcBounds = tagRECT()
        self.hbmUserAlpha = v_ptr32()
        self.bpp = v_uint32()
        self.cx = v_uint32()
        self.cy = v_uint32()


class tagDCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pdceNext = v_ptr32()
        self.hdc = v_ptr32()
        self.pwndOrg = v_ptr32()
        self.pwndClip = v_ptr32()
        self.pwndRedirect = v_ptr32()
        self.hrgnClip = v_ptr32()
        self.hrgnClipPublic = v_ptr32()
        self.hrgnSavedVis = v_ptr32()
        self.DCX_flags = v_uint32()
        self.ptiOwner = v_ptr32()
        self.ppiOwner = v_ptr32()
        self.pMonitor = v_ptr32()


class tagPROCESS_HID_REQUEST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.link = LIST_ENTRY()
        self.usUsagePage = v_uint16()
        self.usUsage = v_uint16()
        self.fSinkable = v_uint32()
        self.pTLCInfo = v_ptr32()
        self.spwndTarget = v_ptr32()


class NAMED_PIPE_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NamedPipeType = v_uint32()
        self.ReadMode = v_uint32()
        self.CompletionMode = v_uint32()
        self.MaximumInstances = v_uint32()
        self.InboundQuota = v_uint32()
        self.OutboundQuota = v_uint32()
        self.DefaultTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0028 = v_bytes(size=7)


class NT_TIB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_ptr32()
        self.StackBase = v_ptr32()
        self.StackLimit = v_ptr32()
        self.SubSystemTib = v_ptr32()
        self.FiberData = v_ptr32()
        self.ArbitraryUserPointer = v_ptr32()
        self.Self = v_ptr32()


class POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemState = v_uint32()


class UNICODE_STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class DMM_MONITORSOURCEMODESET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumModes = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.ModeSerialization = vstruct.VArray([ DMM_MONITOR_SOURCE_MODE_SERIALIZATION() for i in xrange(1) ])


class D3DKMDT_VIDPN_TARGET_MODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint32()
        self.VideoSignalInfo = D3DKMDT_VIDEO_SIGNAL_INFO()
        self.Preference = v_uint32()


class COMPRESSED_DATA_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CompressionFormatAndEngine = v_uint16()
        self.CompressionUnitShift = v_uint8()
        self.ChunkShift = v_uint8()
        self.ClusterShift = v_uint8()
        self.Reserved = v_uint8()
        self.NumberOfChunks = v_uint16()
        self.CompressedChunkSizes = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class tagWOWTHREADINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pwtiNext = v_ptr32()
        self.idTask = v_uint32()
        self.idWaitObject = v_uint32()
        self.idParentProcess = v_uint32()
        self.pIdleEvent = v_ptr32()


class _unnamed_12593(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Key = v_uint32()
        self.ByteOffset = LARGE_INTEGER()


class PEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InheritedAddressSpace = v_uint8()
        self.ReadImageFileExecOptions = v_uint8()
        self.BeingDebugged = v_uint8()
        self.BitField = v_uint8()
        self.Mutant = v_ptr32()
        self.ImageBaseAddress = v_ptr32()
        self.Ldr = v_ptr32()
        self.ProcessParameters = v_ptr32()
        self.SubSystemData = v_ptr32()
        self.ProcessHeap = v_ptr32()
        self.FastPebLock = v_ptr32()
        self.AtlThunkSListPtr = v_ptr32()
        self.IFEOKey = v_ptr32()
        self.CrossProcessFlags = v_uint32()
        self.KernelCallbackTable = v_ptr32()
        self.SystemReserved = vstruct.VArray([ v_uint32() for i in xrange(1) ])
        self.AtlThunkSListPtr32 = v_uint32()
        self.ApiSetMap = v_ptr32()
        self.TlsExpansionCounter = v_uint32()
        self.TlsBitmap = v_ptr32()
        self.TlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(2) ])
        self.ReadOnlySharedMemoryBase = v_ptr32()
        self.HotpatchInformation = v_ptr32()
        self.ReadOnlyStaticServerData = v_ptr32()
        self.AnsiCodePageData = v_ptr32()
        self.OemCodePageData = v_ptr32()
        self.UnicodeCaseTableData = v_ptr32()
        self.NumberOfProcessors = v_uint32()
        self.NtGlobalFlag = v_uint32()
        self._pad0070 = v_bytes(size=4)
        self.CriticalSectionTimeout = LARGE_INTEGER()
        self.HeapSegmentReserve = v_uint32()
        self.HeapSegmentCommit = v_uint32()
        self.HeapDeCommitTotalFreeThreshold = v_uint32()
        self.HeapDeCommitFreeBlockThreshold = v_uint32()
        self.NumberOfHeaps = v_uint32()
        self.MaximumNumberOfHeaps = v_uint32()
        self.ProcessHeaps = v_ptr32()
        self.GdiSharedHandleTable = v_ptr32()
        self.ProcessStarterHelper = v_ptr32()
        self.GdiDCAttributeList = v_uint32()
        self.LoaderLock = v_ptr32()
        self.OSMajorVersion = v_uint32()
        self.OSMinorVersion = v_uint32()
        self.OSBuildNumber = v_uint16()
        self.OSCSDVersion = v_uint16()
        self.OSPlatformId = v_uint32()
        self.ImageSubsystem = v_uint32()
        self.ImageSubsystemMajorVersion = v_uint32()
        self.ImageSubsystemMinorVersion = v_uint32()
        self.ActiveProcessAffinityMask = v_uint32()
        self.GdiHandleBuffer = vstruct.VArray([ v_uint32() for i in xrange(34) ])
        self.PostProcessInitRoutine = v_ptr32()
        self.TlsExpansionBitmap = v_ptr32()
        self.TlsExpansionBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(32) ])
        self.SessionId = v_uint32()
        self.AppCompatFlags = ULARGE_INTEGER()
        self.AppCompatFlagsUser = ULARGE_INTEGER()
        self.pShimData = v_ptr32()
        self.AppCompatInfo = v_ptr32()
        self.CSDVersion = UNICODE_STRING()
        self.ActivationContextData = v_ptr32()
        self.ProcessAssemblyStorageMap = v_ptr32()
        self.SystemDefaultActivationContextData = v_ptr32()
        self.SystemAssemblyStorageMap = v_ptr32()
        self.MinimumStackCommit = v_uint32()
        self.FlsCallback = v_ptr32()
        self.FlsListHead = LIST_ENTRY()
        self.FlsBitmap = v_ptr32()
        self.FlsBitmapBits = vstruct.VArray([ v_uint32() for i in xrange(4) ])
        self.FlsHighIndex = v_uint32()
        self.WerRegistrationData = v_ptr32()
        self.WerShipAssertPtr = v_ptr32()
        self.pContextData = v_ptr32()
        self.pImageHeaderHash = v_ptr32()
        self.TracingFlags = v_uint32()
        self._pad0248 = v_bytes(size=4)


class _unnamed_12817(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdType = v_uint32()


class W32THREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pEThread = v_ptr32()
        self.RefCount = v_uint32()
        self.ptlW32 = v_ptr32()
        self.pgdiDcattr = v_ptr32()
        self.pgdiBrushAttr = v_ptr32()
        self.pUMPDObjs = v_ptr32()
        self.pUMPDHeap = v_ptr32()
        self.pUMPDObj = v_ptr32()
        self.GdiTmpTgoList = LIST_ENTRY()
        self.pRBRecursionCount = v_uint32()
        self.pNonRBRecursionCount = v_uint32()
        self.tlSpriteState = TLSPRITESTATE()
        self.pSpriteState = v_ptr32()
        self.pDevHTInfo = v_ptr32()
        self.ulDevHTInfoUniqueness = v_uint32()
        self.pdcoAA = v_ptr32()
        self.pdcoRender = v_ptr32()
        self.pdcoSrc = v_ptr32()
        self.bEnableEngUpdateDeviceSurface = v_uint8()
        self.bIncludeSprites = v_uint8()
        self._pad00ac = v_bytes(size=2)
        self.ulWindowSystemRendering = v_uint32()
        self.iVisRgnUniqueness = v_uint32()


class KDPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.Importance = v_uint8()
        self.Number = v_uint16()
        self.DpcListEntry = LIST_ENTRY()
        self.DeferredRoutine = v_ptr32()
        self.DeferredContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.DpcData = v_ptr32()


class KEVENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class KSEMAPHORE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.Limit = v_uint32()


class _unnamed_16581(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Alignment = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class OBJECT_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TypeList = LIST_ENTRY()
        self.Name = UNICODE_STRING()
        self.DefaultObject = v_ptr32()
        self.Index = v_uint8()
        self._pad0018 = v_bytes(size=3)
        self.TotalNumberOfObjects = v_uint32()
        self.TotalNumberOfHandles = v_uint32()
        self.HighWaterNumberOfObjects = v_uint32()
        self.HighWaterNumberOfHandles = v_uint32()
        self.TypeInfo = OBJECT_TYPE_INITIALIZER()
        self.TypeLock = EX_PUSH_LOCK()
        self.Key = v_uint32()
        self.CallbackList = LIST_ENTRY()


class tagIMEINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwPrivateDataSize = v_uint32()
        self.fdwProperty = v_uint32()
        self.fdwConversionCaps = v_uint32()
        self.fdwSentenceCaps = v_uint32()
        self.fdwUICaps = v_uint32()
        self.fdwSCSCaps = v_uint32()
        self.fdwSelectCaps = v_uint32()


class DXGK_DIAG_CODE_POINT_PACKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DXGK_DIAG_HEADER()
        self.CodePointType = v_uint32()
        self.Param1 = v_uint32()
        self.Param2 = v_uint32()
        self.Param3 = v_uint32()


class W32PROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Process = v_ptr32()
        self.RefCount = v_uint32()
        self.W32PF_Flags = v_uint32()
        self.InputIdleEvent = v_ptr32()
        self.StartCursorHideTime = v_uint32()
        self.NextStart = v_ptr32()
        self.pDCAttrList = v_ptr32()
        self.pBrushAttrList = v_ptr32()
        self.W32Pid = v_uint32()
        self.GDIHandleCount = v_uint32()
        self.GDIHandleCountPeak = v_uint32()
        self.UserHandleCount = v_uint32()
        self.UserHandleCountPeak = v_uint32()
        self.GDIPushLock = EX_PUSH_LOCK()
        self.GDIEngUserMemAllocTable = RTL_AVL_TABLE()
        self.GDIDcAttrFreeList = LIST_ENTRY()
        self.GDIBrushAttrFreeList = LIST_ENTRY()
        self.GDIW32PIDLockedBitmaps = LIST_ENTRY()
        self.hSecureGdiSharedHandleTable = v_ptr32()
        self.DxProcess = v_ptr32()


class tagKBDFILE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = HEAD()
        self.pkfNext = v_ptr32()
        self.hBase = v_ptr32()
        self.pKbdTbl = v_ptr32()
        self.Size = v_uint32()
        self.pKbdNlsTbl = v_ptr32()
        self.awchDllName = vstruct.VArray([ v_uint16() for i in xrange(32) ])


class DMM_COMMITVIDPNREQUEST_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AffectedVidPnSourceId = v_uint32()
        self.RequestDiagInfo = DMM_COMMITVIDPNREQUEST_DIAGINFO()
        self.VidPnSerialization = DMM_VIDPN_SERIALIZATION()


class EXCEPTION_REGISTRATION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Handler = v_ptr32()


class FILE_BASIC_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.FileAttributes = v_uint32()
        self._pad0028 = v_bytes(size=4)


class _unnamed_12887(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedResources = v_ptr32()
        self.AllocatedResourcesTranslated = v_ptr32()


class LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_ptr32()
        self.Blink = v_ptr32()


class tagUSERSTARTUPINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.cb = v_uint32()
        self.dwX = v_uint32()
        self.dwY = v_uint32()
        self.dwXSize = v_uint32()
        self.dwYSize = v_uint32()
        self.dwFlags = v_uint32()
        self.wShowWindow = v_uint16()
        self.cbReserved2 = v_uint16()


class tagHID_PAGEONLY_REQUEST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.link = LIST_ENTRY()
        self.usUsagePage = v_uint16()
        self._pad000c = v_bytes(size=2)
        self.cRefCount = v_uint32()


class RTL_DYNAMIC_HASH_TABLE_ENUMERATOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashEntry = RTL_DYNAMIC_HASH_TABLE_ENTRY()
        self.ChainHead = v_ptr32()
        self.BucketIndex = v_uint32()


class tagWINDOWSTATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwSessionId = v_uint32()
        self.rpwinstaNext = v_ptr32()
        self.rpdeskList = v_ptr32()
        self.pTerm = v_ptr32()
        self.dwWSF_Flags = v_uint32()
        self.spklList = v_ptr32()
        self.ptiClipLock = v_ptr32()
        self.ptiDrawingClipboard = v_ptr32()
        self.spwndClipOpen = v_ptr32()
        self.spwndClipViewer = v_ptr32()
        self.spwndClipOwner = v_ptr32()
        self.pClipBase = v_ptr32()
        self.cNumClipFormats = v_uint32()
        self.iClipSerialNumber = v_uint32()
        self.iClipSequenceNumber = v_uint32()
        self.spwndClipboardListener = v_ptr32()
        self.pGlobalAtomTable = v_ptr32()
        self.luidEndSession = LUID()
        self.luidUser = LUID()
        self.psidUser = v_ptr32()


class _unnamed_16049(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = _unnamed_16581()


class DMM_VIDPNPATHSFROMSOURCE_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SourceMode = D3DKMDT_VIDPN_SOURCE_MODE()
        self.NumPathsFromSource = v_uint8()
        self._pad002c = v_bytes(size=3)
        self.PathAndTargetModeSerialization = vstruct.VArray([ DMM_VIDPNPATHANDTARGETMODE_SERIALIZATION() for i in xrange(1) ])


class GUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data1 = v_uint32()
        self.Data2 = v_uint16()
        self.Data3 = v_uint16()
        self.Data4 = vstruct.VArray([ v_uint8() for i in xrange(8) ])


class D3DKMDT_GRAPHICS_RENDERING_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrimSurfSize = D3DKMDT_2DREGION()
        self.VisibleRegionSize = D3DKMDT_2DREGION()
        self.Stride = v_uint32()
        self.PixelFormat = v_uint32()
        self.ColorBasis = v_uint32()
        self.PixelValueAccessMode = v_uint32()


class GENERIC_MAPPING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GenericRead = v_uint32()
        self.GenericWrite = v_uint32()
        self.GenericExecute = v_uint32()
        self.GenericAll = v_uint32()


class IRP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.MdlAddress = v_ptr32()
        self.Flags = v_uint32()
        self.AssociatedIrp = _unnamed_12389()
        self.ThreadListEntry = LIST_ENTRY()
        self.IoStatus = IO_STATUS_BLOCK()
        self.RequestorMode = v_uint8()
        self.PendingReturned = v_uint8()
        self.StackCount = v_uint8()
        self.CurrentLocation = v_uint8()
        self.Cancel = v_uint8()
        self.CancelIrql = v_uint8()
        self.ApcEnvironment = v_uint8()
        self.AllocationFlags = v_uint8()
        self.UserIosb = v_ptr32()
        self.UserEvent = v_ptr32()
        self.Overlay = _unnamed_12392()
        self.CancelRoutine = v_ptr32()
        self.UserBuffer = v_ptr32()
        self.Tail = _unnamed_12395()


class _unnamed_11700(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class DRIVER_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Flags = v_uint32()
        self.DriverStart = v_ptr32()
        self.DriverSize = v_uint32()
        self.DriverSection = v_ptr32()
        self.DriverExtension = v_ptr32()
        self.DriverName = UNICODE_STRING()
        self.HardwareDatabase = v_ptr32()
        self.FastIoDispatch = v_ptr32()
        self.DriverInit = v_ptr32()
        self.DriverStartIo = v_ptr32()
        self.DriverUnload = v_ptr32()
        self.MajorFunction = vstruct.VArray([ v_ptr32() for i in xrange(28) ])


class MAILSLOT_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MailslotQuota = v_uint32()
        self.MaximumMessageSize = v_uint32()
        self.ReadTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()
        self._pad0018 = v_bytes(size=7)


class DMM_VIDPN_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.NumActiveSources = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.PathsFromSourceSerializationOffsets = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class _unnamed_16606(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Priority = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class _unnamed_16601(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.MinBusNumber = v_uint32()
        self.MaxBusNumber = v_uint32()
        self.Reserved = v_uint32()


class IO_COMPLETION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = v_ptr32()
        self.Key = v_ptr32()


class DRIVER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DriverObject = v_ptr32()
        self.AddDevice = v_ptr32()
        self.Count = v_uint32()
        self.ServiceKeyName = UNICODE_STRING()


class _unnamed_16084(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(3) ])


class DMM_COFUNCPATHSMODALITY_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumPathsFromSource = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.PathAndTargetModeSetOffset = vstruct.VArray([ v_uint32() for i in xrange(1) ])


class tagTDB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ptdbNext = v_ptr32()
        self.nEvents = v_uint32()
        self.nPriority = v_uint32()
        self.pti = v_ptr32()
        self.pwti = v_ptr32()
        self.hTaskWow = v_uint16()
        self.TDB_Flags = v_uint16()


class WHEA_PERSISTENCE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint64()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FRUId = v_uint8()


class tagWin32AllocStats(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwMaxMem = v_uint32()
        self.dwCrtMem = v_uint32()
        self.dwMaxAlloc = v_uint32()
        self.dwCrtAlloc = v_uint32()
        self.pHead = v_ptr32()


class GENERAL_LOOKASIDE_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr32()
        self.FreeEx = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = vstruct.VArray([ v_uint32() for i in xrange(2) ])


class EXCEPTION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_ptr32()
        self.ExceptionAddress = v_ptr32()
        self.NumberParameters = v_uint32()
        self.ExceptionInformation = vstruct.VArray([ v_uint32() for i in xrange(15) ])


class HTOUCHINPUT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class PROCESSOR_NUMBER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.Number = v_uint8()
        self.Reserved = v_uint8()


class IMAGE_FILE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Machine = v_uint16()
        self.NumberOfSections = v_uint16()
        self.TimeDateStamp = v_uint32()
        self.PointerToSymbolTable = v_uint32()
        self.NumberOfSymbols = v_uint32()
        self.SizeOfOptionalHeader = v_uint16()
        self.Characteristics = v_uint16()


class tagPROCESSINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Process = v_ptr32()
        self.RefCount = v_uint32()
        self.W32PF_Flags = v_uint32()
        self.InputIdleEvent = v_ptr32()
        self.StartCursorHideTime = v_uint32()
        self.NextStart = v_ptr32()
        self.pDCAttrList = v_ptr32()
        self.pBrushAttrList = v_ptr32()
        self.W32Pid = v_uint32()
        self.GDIHandleCount = v_uint32()
        self.GDIHandleCountPeak = v_uint32()
        self.UserHandleCount = v_uint32()
        self.UserHandleCountPeak = v_uint32()
        self.GDIPushLock = EX_PUSH_LOCK()
        self.GDIEngUserMemAllocTable = RTL_AVL_TABLE()
        self.GDIDcAttrFreeList = LIST_ENTRY()
        self.GDIBrushAttrFreeList = LIST_ENTRY()
        self.GDIW32PIDLockedBitmaps = LIST_ENTRY()
        self.hSecureGdiSharedHandleTable = v_ptr32()
        self.DxProcess = v_ptr32()
        self.ptiList = v_ptr32()
        self.ptiMainThread = v_ptr32()
        self.rpdeskStartup = v_ptr32()
        self.pclsPrivateList = v_ptr32()
        self.pclsPublicList = v_ptr32()
        self.pwpi = v_ptr32()
        self.ppiNext = v_ptr32()
        self.ppiNextRunning = v_ptr32()
        self.cThreads = v_uint32()
        self.hdeskStartup = v_ptr32()
        self.cSysExpunge = v_uint32()
        self.dwhmodLibLoadedMask = v_uint32()
        self.ahmodLibLoaded = vstruct.VArray([ v_ptr32() for i in xrange(32) ])
        self.rpwinsta = v_ptr32()
        self.hwinsta = v_ptr32()
        self.amwinsta = v_uint32()
        self.dwHotkey = v_uint32()
        self.hMonitor = v_ptr32()
        self.pdvList = v_ptr32()
        self.iClipSerialNumber = v_uint32()
        self.bmHandleFlags = RTL_BITMAP()
        self.pCursorCache = v_ptr32()
        self.pClientBase = v_ptr32()
        self.dwLpkEntryPoints = v_uint32()
        self.pW32Job = v_ptr32()
        self.dwImeCompatFlags = v_uint32()
        self.luidSession = LUID()
        self.usi = tagUSERSTARTUPINFO()
        self.Flags = v_uint32()
        self.dwLayout = v_uint32()
        self.pHidTable = v_ptr32()
        self.dwRegisteredClasses = v_uint32()
        self.pvwplWndGCList = v_ptr32()


class HKL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class FLOATING_SAVE_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint32()
        self.StatusWord = v_uint32()
        self.TagWord = v_uint32()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint32()
        self.RegisterArea = vstruct.VArray([ v_uint8() for i in xrange(80) ])
        self.Cr0NpxState = v_uint32()


class PEB_LDR_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Initialized = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.SsHandle = v_ptr32()
        self.InLoadOrderModuleList = LIST_ENTRY()
        self.InMemoryOrderModuleList = LIST_ENTRY()
        self.InInitializationOrderModuleList = LIST_ENTRY()
        self.EntryInProgress = v_ptr32()
        self.ShutdownInProgress = v_uint8()
        self._pad002c = v_bytes(size=3)
        self.ShutdownThreadId = v_ptr32()


class _unnamed_12724(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Srb = v_ptr32()


class _unnamed_12720(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vpb = v_ptr32()
        self.DeviceObject = v_ptr32()


class DMM_MONITORFREQUENCYRANGESET_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NumFrequencyRanges = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.FrequencyRangeSerialization = vstruct.VArray([ D3DKMDT_MONITOR_FREQUENCY_RANGE() for i in xrange(1) ])


class SECURITY_SUBJECT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientToken = v_ptr32()
        self.ImpersonationLevel = v_uint32()
        self.PrimaryToken = v_ptr32()
        self.ProcessAuditId = v_ptr32()


class DMM_MONITOR_SERIALIZATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.VideoPresentTargetId = v_uint32()
        self.Orientation = v_uint32()
        self.IsSimulatedMonitor = v_uint8()
        self.IsUsingDefaultProfile = v_uint8()
        self._pad0010 = v_bytes(size=2)
        self.ModePruningAlgorithm = v_uint32()
        self.MonitorPowerState = v_uint32()
        self.SourceModeSetOffset = v_uint32()
        self.FrequencyRangeSetOffset = v_uint32()
        self.DescriptorSetOffset = v_uint32()
        self.MonitorType = v_uint32()


class tagKbdLayer(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pCharModifiers = v_ptr32()
        self.pVkToWcharTable = v_ptr32()
        self.pDeadKey = v_ptr32()
        self.pKeyNames = v_ptr32()
        self.pKeyNamesExt = v_ptr32()
        self.pKeyNamesDead = v_ptr32()
        self.pusVSCtoVK = v_ptr32()
        self.bMaxVSCtoVK = v_uint8()
        self._pad0020 = v_bytes(size=3)
        self.pVSCtoVK_E0 = v_ptr32()
        self.pVSCtoVK_E1 = v_ptr32()
        self.fLocaleFlags = v_uint32()
        self.nLgMax = v_uint8()
        self.cbLgEntry = v_uint8()
        self._pad0030 = v_bytes(size=2)
        self.pLigature = v_ptr32()
        self.dwType = v_uint32()
        self.dwSubType = v_uint32()


class _unnamed_11687(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class tagMSG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.hwnd = v_ptr32()
        self.message = v_uint32()
        self.wParam = v_uint32()
        self.lParam = v_uint32()
        self.time = v_uint32()
        self.pt = tagPOINT()


class HWND(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Context = v_ptr32()
        self.InterfaceReference = v_ptr32()
        self.InterfaceDereference = v_ptr32()


class SLIST_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Alignment = v_uint64()


class FILE_STANDARD_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.NumberOfLinks = v_uint32()
        self.DeletePending = v_uint8()
        self.Directory = v_uint8()
        self._pad0018 = v_bytes(size=2)


class _unnamed_13037(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InitialPrivilegeSet = INITIAL_PRIVILEGE_SET()


class IMAGE_DATA_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_uint32()
        self.Size = v_uint32()


class FILE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Vpb = v_ptr32()
        self.FsContext = v_ptr32()
        self.FsContext2 = v_ptr32()
        self.SectionObjectPointer = v_ptr32()
        self.PrivateCacheMap = v_ptr32()
        self.FinalStatus = v_uint32()
        self.RelatedFileObject = v_ptr32()
        self.LockOperation = v_uint8()
        self.DeletePending = v_uint8()
        self.ReadAccess = v_uint8()
        self.WriteAccess = v_uint8()
        self.DeleteAccess = v_uint8()
        self.SharedRead = v_uint8()
        self.SharedWrite = v_uint8()
        self.SharedDelete = v_uint8()
        self.Flags = v_uint32()
        self.FileName = UNICODE_STRING()
        self.CurrentByteOffset = LARGE_INTEGER()
        self.Waiters = v_uint32()
        self.Busy = v_uint32()
        self.LastLock = v_ptr32()
        self.Lock = KEVENT()
        self.Event = KEVENT()
        self.CompletionContext = v_ptr32()
        self.IrpListLock = v_uint32()
        self.IrpList = LIST_ENTRY()
        self.FileObjectExtension = v_ptr32()


class tagWOWPROCESSINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pwpiNext = v_ptr32()
        self.ptiScheduled = v_ptr32()
        self.ptdbHead = v_ptr32()
        self.lpfnWowExitTask = v_ptr32()
        self.pEventWowExec = v_ptr32()
        self.hEventWowExecClient = v_ptr32()
        self.nSendLock = v_uint32()
        self.nRecvLock = v_uint32()
        self.CSOwningThread = v_ptr32()
        self.CSLockCount = v_uint32()


class tagMENU(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = PROCDESKHEAD()
        self.fFlags = v_uint32()
        self.iItem = v_uint32()
        self.cAlloced = v_uint32()
        self.cItems = v_uint32()
        self.cxMenu = v_uint32()
        self.cyMenu = v_uint32()
        self.cxTextAlign = v_uint32()
        self.spwndNotify = v_ptr32()
        self.rgItems = v_ptr32()
        self.pParentMenus = v_ptr32()
        self.dwContextHelpId = v_uint32()
        self.cyMax = v_uint32()
        self.dwMenuData = v_uint32()
        self.hbrBack = v_ptr32()
        self.iTop = v_uint32()
        self.iMaxTop = v_uint32()
        self.dwArrowsOn = v_uint32()
        self.umpm = tagUAHMENUPOPUPMETRICS()


class ERESOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemResourcesList = LIST_ENTRY()
        self.OwnerTable = v_ptr32()
        self.ActiveCount = v_uint16()
        self.Flag = v_uint16()
        self.SharedWaiters = v_ptr32()
        self.ExclusiveWaiters = v_ptr32()
        self.OwnerEntry = OWNER_ENTRY()
        self.ActiveEntries = v_uint32()
        self.ContentionCount = v_uint32()
        self.NumberOfSharedWaiters = v_uint32()
        self.NumberOfExclusiveWaiters = v_uint32()
        self.Address = v_ptr32()
        self.SpinLock = v_uint32()


class ACCESS_REASONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = vstruct.VArray([ v_uint32() for i in xrange(32) ])


class THRDESKHEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.h = v_ptr32()
        self.cLockObj = v_uint32()
        self.pti = v_ptr32()
        self.rpdesk = v_ptr32()
        self.pSelf = v_ptr32()


class _unnamed_16090(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class tagPOPUPMENU(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.fIsMenuBar = v_uint32()
        self.spwndNotify = v_ptr32()
        self.spwndPopupMenu = v_ptr32()
        self.spwndNextPopup = v_ptr32()
        self.spwndPrevPopup = v_ptr32()
        self.spmenu = v_ptr32()
        self.spmenuAlternate = v_ptr32()
        self.spwndActivePopup = v_ptr32()
        self.ppopupmenuRoot = v_ptr32()
        self.ppmDelayedFree = v_ptr32()
        self.posSelectedItem = v_uint32()
        self.posDropped = v_uint32()


class TP_TASK_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteCallback = v_ptr32()
        self.Unposted = v_ptr32()


class _unnamed_16097(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length48 = v_uint32()


class _unnamed_16094(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length40 = v_uint32()


class RTL_BALANCED_LINKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parent = v_ptr32()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.Balance = v_uint8()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(3) ])


class HANDLEENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.phead = v_ptr32()
        self.pOwner = v_ptr32()
        self.bType = v_uint8()
        self.bFlags = v_uint8()
        self.wUniq = v_uint16()


class VK_FUNCTION_PARAM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NLSFEProcIndex = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.NLSFEProcParam = v_uint32()


class EX_PUSH_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint32()


class D3DMATRIX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self._11 = v_uint32()
        self._12 = v_uint32()
        self._13 = v_uint32()
        self._14 = v_uint32()
        self._21 = v_uint32()
        self._22 = v_uint32()
        self._23 = v_uint32()
        self._24 = v_uint32()
        self._31 = v_uint32()
        self._32 = v_uint32()
        self._33 = v_uint32()
        self._34 = v_uint32()
        self._41 = v_uint32()
        self._42 = v_uint32()
        self._43 = v_uint32()
        self._44 = v_uint32()


class _unnamed_13453(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ActiveSize = D3DKMDT_2DREGION()


class CONSOLE_CARET_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.hwnd = v_ptr32()
        self.rc = tagRECT()


class D3DKMDT_VIDPN_PRESENT_PATH_ROTATION_SUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Identity = v_uint32()


class WHEA_ERROR_RECORD_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Revision = WHEA_REVISION()
        self.SignatureEnd = v_uint32()
        self.SectionCount = v_uint16()
        self.Severity = v_uint32()
        self.ValidBits = WHEA_ERROR_RECORD_HEADER_VALIDBITS()
        self.Length = v_uint32()
        self.Timestamp = WHEA_TIMESTAMP()
        self.PlatformId = GUID()
        self.PartitionId = GUID()
        self.CreatorId = GUID()
        self.NotifyType = GUID()
        self.RecordId = v_uint64()
        self.Flags = WHEA_ERROR_RECORD_HEADER_FLAGS()
        self.PersistenceInfo = WHEA_PERSISTENCE_INFO()
        self.Reserved = vstruct.VArray([ v_uint8() for i in xrange(12) ])


class EVENT_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint16()
        self.Version = v_uint8()
        self.Channel = v_uint8()
        self.Level = v_uint8()
        self.Opcode = v_uint8()
        self.Task = v_uint16()
        self.Keyword = v_uint64()


class tagSBCALC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.posMin = v_uint32()
        self.posMax = v_uint32()
        self.page = v_uint32()
        self.pos = v_uint32()
        self.pxTop = v_uint32()
        self.pxBottom = v_uint32()
        self.pxLeft = v_uint32()
        self.pxRight = v_uint32()
        self.cpxThumb = v_uint32()
        self.pxUpArrow = v_uint32()
        self.pxDownArrow = v_uint32()
        self.pxStart = v_uint32()
        self.pxThumbBottom = v_uint32()
        self.pxThumbTop = v_uint32()
        self.cpx = v_uint32()
        self.pxMin = v_uint32()


class _unnamed_12451(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self._pad0028 = v_bytes(size=32)


class tagSBINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WSBflags = v_uint32()
        self.Horz = tagSBDATA()
        self.Vert = tagSBDATA()


class FLS_CALLBACK_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_11733(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFunction = v_uint32()


class _unnamed_11730(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()


class LIST_ENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint64()
        self.Blink = v_uint64()


class tagOEMBITMAPINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.x = v_uint32()
        self.y = v_uint32()
        self.cx = v_uint32()
        self.cy = v_uint32()


class WAIT_CONTEXT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.DeviceRoutine = v_ptr32()
        self.DeviceContext = v_ptr32()
        self.NumberOfMapRegisters = v_uint32()
        self.DeviceObject = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.BufferChainingDpc = v_ptr32()


class _unnamed_16072(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.MessageCount = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint32()


class ACTIVATION_CONTEXT_STACK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ActiveFrame = v_ptr32()
        self.FrameListCache = LIST_ENTRY()
        self.Flags = v_uint32()
        self.NextCookieSequenceNumber = v_uint32()
        self.StackId = v_uint32()


class tagITEM(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.fType = v_uint32()
        self.fState = v_uint32()
        self.wID = v_uint32()
        self.spSubMenu = v_ptr32()
        self.hbmpChecked = v_ptr32()
        self.hbmpUnchecked = v_ptr32()
        self.lpstr = v_ptr32()
        self.cch = v_uint32()
        self.dwItemData = v_uint32()
        self.xItem = v_uint32()
        self.yItem = v_uint32()
        self.cxItem = v_uint32()
        self.cyItem = v_uint32()
        self.dxTab = v_uint32()
        self.ulX = v_uint32()
        self.ulWidth = v_uint32()
        self.hbmp = v_ptr32()
        self.cxBmp = v_uint32()
        self.cyBmp = v_uint32()
        self.umim = tagUAHMENUITEMMETRICS()


class LOOKASIDE_LIST_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE_POOL()


class TEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.EnvironmentPointer = v_ptr32()
        self.ClientId = CLIENT_ID()
        self.ActiveRpcHandle = v_ptr32()
        self.ThreadLocalStoragePointer = v_ptr32()
        self.ProcessEnvironmentBlock = v_ptr32()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_ptr32()
        self.Win32ThreadInfo = v_ptr32()
        self.User32Reserved = vstruct.VArray([ v_uint32() for i in xrange(26) ])
        self.UserReserved = vstruct.VArray([ v_uint32() for i in xrange(5) ])
        self.WOW32Reserved = v_ptr32()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()
        self.SystemReserved1 = vstruct.VArray([ v_ptr32() for i in xrange(54) ])
        self.ExceptionCode = v_uint32()
        self.ActivationContextStackPointer = v_ptr32()
        self.SpareBytes = vstruct.VArray([ v_uint8() for i in xrange(36) ])
        self.TxFsContext = v_uint32()
        self.GdiTebBatch = GDI_TEB_BATCH()
        self.RealClientId = CLIENT_ID()
        self.GdiCachedProcessHandle = v_ptr32()
        self.GdiClientPID = v_uint32()
        self.GdiClientTID = v_uint32()
        self.GdiThreadLocalInfo = v_ptr32()
        self.Win32ClientInfo = vstruct.VArray([ v_uint32() for i in xrange(62) ])
        self.glDispatchTable = vstruct.VArray([ v_ptr32() for i in xrange(233) ])
        self.glReserved1 = vstruct.VArray([ v_uint32() for i in xrange(29) ])
        self.glReserved2 = v_ptr32()
        self.glSectionInfo = v_ptr32()
        self.glSection = v_ptr32()
        self.glTable = v_ptr32()
        self.glCurrentRC = v_ptr32()
        self.glContext = v_ptr32()
        self.LastStatusValue = v_uint32()
        self.StaticUnicodeString = UNICODE_STRING()
        self.StaticUnicodeBuffer = vstruct.VArray([ v_uint16() for i in xrange(261) ])
        self._pad0e0c = v_bytes(size=2)
        self.DeallocationStack = v_ptr32()
        self.TlsSlots = vstruct.VArray([ v_ptr32() for i in xrange(64) ])
        self.TlsLinks = LIST_ENTRY()
        self.Vdm = v_ptr32()
        self.ReservedForNtRpc = v_ptr32()
        self.DbgSsReserved = vstruct.VArray([ v_ptr32() for i in xrange(2) ])
        self.HardErrorMode = v_uint32()
        self.Instrumentation = vstruct.VArray([ v_ptr32() for i in xrange(9) ])
        self.ActivityId = GUID()
        self.SubProcessTag = v_ptr32()
        self.EtwLocalData = v_ptr32()
        self.EtwTraceData = v_ptr32()
        self.WinSockData = v_ptr32()
        self.GdiBatchCount = v_uint32()
        self.CurrentIdealProcessor = PROCESSOR_NUMBER()
        self.GuaranteedStackBytes = v_uint32()
        self.ReservedForPerf = v_ptr32()
        self.ReservedForOle = v_ptr32()
        self.WaitingOnLoaderLock = v_uint32()
        self.SavedPriorityState = v_ptr32()
        self.SoftPatchPtr1 = v_uint32()
        self.ThreadPoolData = v_ptr32()
        self.TlsExpansionSlots = v_ptr32()
        self.MuiGeneration = v_uint32()
        self.IsImpersonating = v_uint32()
        self.NlsCache = v_ptr32()
        self.pShimData = v_ptr32()
        self.HeapVirtualAffinity = v_uint32()
        self.CurrentTransactionHandle = v_ptr32()
        self.ActiveFrame = v_ptr32()
        self.FlsData = v_ptr32()
        self.PreferredLanguages = v_ptr32()
        self.UserPrefLanguages = v_ptr32()
        self.MergedPrefLanguages = v_ptr32()
        self.MuiImpersonation = v_uint32()
        self.CrossTebFlags = v_uint16()
        self.SameTebFlags = v_uint16()
        self.TxnScopeEnterCallback = v_ptr32()
        self.TxnScopeExitCallback = v_ptr32()
        self.TxnScopeContext = v_ptr32()
        self.LockCount = v_uint32()
        self.SpareUlong0 = v_uint32()
        self.ResourceRetValue = v_ptr32()


class tagWIN32HEAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class DMM_COMMITVIDPNREQUEST_DIAGINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientType = v_uint32()
        self.ReclaimClonedTarget = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.ModeChangeRequestId = v_uint32()


class IMAGE_DOS_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e_magic = v_uint16()
        self.e_cblp = v_uint16()
        self.e_cp = v_uint16()
        self.e_crlc = v_uint16()
        self.e_cparhdr = v_uint16()
        self.e_minalloc = v_uint16()
        self.e_maxalloc = v_uint16()
        self.e_ss = v_uint16()
        self.e_sp = v_uint16()
        self.e_csum = v_uint16()
        self.e_ip = v_uint16()
        self.e_cs = v_uint16()
        self.e_lfarlc = v_uint16()
        self.e_ovno = v_uint16()
        self.e_res = vstruct.VArray([ v_uint16() for i in xrange(4) ])
        self.e_oemid = v_uint16()
        self.e_oeminfo = v_uint16()
        self.e_res2 = vstruct.VArray([ v_uint16() for i in xrange(10) ])
        self.e_lfanew = v_uint32()


class RTL_DYNAMIC_HASH_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Linkage = LIST_ENTRY()
        self.Signature = v_uint32()


class TXN_PARAMETER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.TxFsContext = v_uint16()
        self.TransactionObject = v_ptr32()


class QUAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UseThisFieldToCopy = v_uint64()


class _unnamed_12800(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoResourceRequirementList = v_ptr32()


class _unnamed_12803(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WhichSpace = v_uint32()
        self.Buffer = v_ptr32()
        self.Offset = v_uint32()
        self.Length = v_uint32()


class RTL_DYNAMIC_HASH_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.Shift = v_uint32()
        self.TableSize = v_uint32()
        self.Pivot = v_uint32()
        self.DivisorMask = v_uint32()
        self.NumEntries = v_uint32()
        self.NonEmptyBuckets = v_uint32()
        self.NumEnumerators = v_uint32()
        self.Directory = v_ptr32()


class _unnamed_12808(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint8()


class _unnamed_12694(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_ptr32()
        self.Key = v_uint32()
        self.ByteOffset = LARGE_INTEGER()


class tagSERVERINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwSRVIFlags = v_uint32()
        self.cHandleEntries = v_uint32()
        self.mpFnidPfn = vstruct.VArray([ v_ptr32() for i in xrange(32) ])
        self.aStoCidPfn = vstruct.VArray([ v_ptr32() for i in xrange(7) ])
        self.mpFnid_serverCBWndProc = vstruct.VArray([ v_uint16() for i in xrange(31) ])
        self._pad00e4 = v_bytes(size=2)
        self.apfnClientA = PFNCLIENT()
        self.apfnClientW = PFNCLIENT()
        self.apfnClientWorker = PFNCLIENTWORKER()
        self.cbHandleTable = v_uint32()
        self.atomSysClass = vstruct.VArray([ v_uint16() for i in xrange(25) ])
        self._pad0200 = v_bytes(size=2)
        self.dwDefaultHeapBase = v_uint32()
        self.dwDefaultHeapSize = v_uint32()
        self.uiShellMsg = v_uint32()
        self.MBStrings = vstruct.VArray([ tagMBSTRING() for i in xrange(11) ])
        self.atomIconSmProp = v_uint16()
        self.atomIconProp = v_uint16()
        self.atomContextHelpIdProp = v_uint16()
        self.atomFrostedWindowProp = v_uint16()
        self.acOemToAnsi = vstruct.VArray([ v_uint8() for i in xrange(256) ])
        self.acAnsiToOem = vstruct.VArray([ v_uint8() for i in xrange(256) ])
        self.dwInstalledEventHooks = v_uint32()
        self.aiSysMet = vstruct.VArray([ v_uint32() for i in xrange(97) ])
        self.argbSystemUnmatched = vstruct.VArray([ v_uint32() for i in xrange(31) ])
        self.argbSystem = vstruct.VArray([ v_uint32() for i in xrange(31) ])
        self.ahbrSystem = vstruct.VArray([ v_ptr32() for i in xrange(31) ])
        self.hbrGray = v_ptr32()
        self.ptCursor = tagPOINT()
        self.ptCursorReal = tagPOINT()
        self.dwLastRITEventTickCount = v_uint32()
        self.nEvents = v_uint32()
        self.dtScroll = v_uint32()
        self.dtLBSearch = v_uint32()
        self.dtCaretBlink = v_uint32()
        self.ucWheelScrollLines = v_uint32()
        self.ucWheelScrollChars = v_uint32()
        self.wMaxLeftOverlapChars = v_uint32()
        self.wMaxRightOverlapChars = v_uint32()
        self.cxSysFontChar = v_uint32()
        self.cySysFontChar = v_uint32()
        self.tmSysFont = tagTEXTMETRICW()
        self.dpiSystem = tagDPISERVERINFO()
        self.hIconSmWindows = v_ptr32()
        self.hIcoWindows = v_ptr32()
        self.dwKeyCache = v_uint32()
        self.dwAsyncKeyCache = v_uint32()
        self.cCaptures = v_uint32()
        self.oembmi = vstruct.VArray([ tagOEMBITMAPINFO() for i in xrange(93) ])
        self.rcScreenReal = tagRECT()
        self.BitCount = v_uint16()
        self.dmLogPixels = v_uint16()
        self.Planes = v_uint8()
        self.BitsPixel = v_uint8()
        self._pad0f58 = v_bytes(size=2)
        self.PUSIFlags = v_uint32()
        self.uCaretWidth = v_uint32()
        self.UILangID = v_uint16()
        self._pad0f64 = v_bytes(size=2)
        self.dwLastSystemRITEventTickCountUpdate = v_uint32()
        self.adwDBGTAGFlags = vstruct.VArray([ v_uint32() for i in xrange(35) ])
        self.dwTagCount = v_uint32()
        self.dwRIPFlags = v_uint32()


class DEVICE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.ReferenceCount = v_uint32()
        self.DriverObject = v_ptr32()
        self.NextDevice = v_ptr32()
        self.AttachedDevice = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.Timer = v_ptr32()
        self.Flags = v_uint32()
        self.Characteristics = v_uint32()
        self.Vpb = v_ptr32()
        self.DeviceExtension = v_ptr32()
        self.DeviceType = v_uint32()
        self.StackSize = v_uint8()
        self._pad0034 = v_bytes(size=3)
        self.Queue = _unnamed_12451()
        self.AlignmentRequirement = v_uint32()
        self.DeviceQueue = KDEVICE_QUEUE()
        self.Dpc = KDPC()
        self.ActiveThreadCount = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.DeviceLock = KEVENT()
        self.SectorSize = v_uint16()
        self.Spare1 = v_uint16()
        self.DeviceObjectExtension = v_ptr32()
        self.Reserved = v_ptr32()


class _unnamed_12699(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self.InputBufferLength = v_uint32()
        self.IoControlCode = v_uint32()
        self.Type3InputBuffer = v_ptr32()


class _unnamed_12510(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.Thread = v_ptr32()
        self.AuxiliaryBuffer = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.CurrentStackLocation = v_ptr32()
        self.OriginalFileObject = v_ptr32()


class _unnamed_16591(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumVector = v_uint32()
        self.MaximumVector = v_uint32()
        self.AffinityPolicy = v_uint16()
        self.Group = v_uint16()
        self.PriorityPolicy = v_uint32()
        self.TargetedProcessors = v_uint32()


class _unnamed_16598(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumChannel = v_uint32()
        self.MaximumChannel = v_uint32()


class tagCLIENTINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CI_flags = v_uint32()
        self.cSpins = v_uint32()
        self.dwExpWinVer = v_uint32()
        self.dwCompatFlags = v_uint32()
        self.dwCompatFlags2 = v_uint32()
        self.dwTIFlags = v_uint32()
        self.pDeskInfo = v_ptr32()
        self.ulClientDelta = v_uint32()
        self.phkCurrent = v_ptr32()
        self.fsHooks = v_uint32()
        self.CallbackWnd = CALLBACKWND()
        self.dwHookCurrent = v_uint32()
        self.cInDDEMLCallback = v_uint32()
        self.pClientThreadInfo = v_ptr32()
        self.dwHookData = v_uint32()
        self.dwKeyCache = v_uint32()
        self.afKeyState = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.dwAsyncKeyCache = v_uint32()
        self.afAsyncKeyState = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.afAsyncKeyStateRecentDown = vstruct.VArray([ v_uint8() for i in xrange(8) ])
        self.hKL = v_ptr32()
        self.CodePage = v_uint16()
        self.achDbcsCF = vstruct.VArray([ v_uint8() for i in xrange(2) ])
        self.msgDbcsCB = tagMSG()
        self.lpdwRegisteredClasses = v_ptr32()


class HWINSTA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.unused = v_uint32()


class TL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.next = v_ptr32()
        self.pobj = v_ptr32()
        self.pfnFree = v_ptr32()


class IMAGE_NT_HEADERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.FileHeader = IMAGE_FILE_HEADER()
        self.OptionalHeader = IMAGE_OPTIONAL_HEADER()


class IO_STACK_LOCATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorFunction = v_uint8()
        self.MinorFunction = v_uint8()
        self.Flags = v_uint8()
        self.Control = v_uint8()
        self.Parameters = _unnamed_12471()
        self.DeviceObject = v_ptr32()
        self.FileObject = v_ptr32()
        self.CompletionRoutine = v_ptr32()
        self.Context = v_ptr32()


class tagTERMINAL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.dwTERMF_Flags = v_uint32()
        self.spwndDesktopOwner = v_ptr32()
        self.ptiDesktop = v_ptr32()
        self.pqDesktop = v_ptr32()
        self.dwNestedLevel = v_uint32()
        self.pEventTermInit = v_ptr32()
        self.rpdeskDestroy = v_ptr32()
        self.pEventInputReady = v_ptr32()


class D3DKMDT_VIDPN_PRESENT_PATH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VidPnSourceId = v_uint32()
        self.VidPnTargetId = v_uint32()
        self.ImportanceOrdinal = v_uint32()
        self.ContentTransformation = D3DKMDT_VIDPN_PRESENT_PATH_TRANSFORMATION()
        self.VisibleFromActiveTLOffset = D3DKMDT_2DREGION()
        self.VisibleFromActiveBROffset = D3DKMDT_2DREGION()
        self.VidPnTargetColorBasis = v_uint32()
        self.VidPnTargetColorCoeffDynamicRanges = D3DKMDT_COLOR_COEFF_DYNAMIC_RANGES()
        self.Content = v_uint32()
        self.CopyProtection = D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION()
        self.GammaRamp = D3DKMDT_GAMMA_RAMP()


class tagMENULIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pNext = v_ptr32()
        self.pMenu = v_ptr32()


class VK_VALUES_STRINGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pszMultiNames = v_ptr32()
        self.fReserved = v_uint8()
        self._pad0008 = v_bytes(size=3)


class tagKL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = HEAD()
        self.pklNext = v_ptr32()
        self.pklPrev = v_ptr32()
        self.dwKL_Flags = v_uint32()
        self.hkl = v_ptr32()
        self.spkf = v_ptr32()
        self.spkfPrimary = v_ptr32()
        self.dwFontSigs = v_uint32()
        self.iBaseCharset = v_uint32()
        self.CodePage = v_uint16()
        self.wchDiacritic = v_uint16()
        self.piiex = v_ptr32()
        self.uNumTbl = v_uint32()
        self.pspkfExtra = v_ptr32()
        self.dwLastKbdType = v_uint32()
        self.dwLastKbdSubType = v_uint32()
        self.dwKLID = v_uint32()


class tagPOINT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.x = v_uint32()
        self.y = v_uint32()


class RTL_USER_PROCESS_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MaximumLength = v_uint32()
        self.Length = v_uint32()
        self.Flags = v_uint32()
        self.DebugFlags = v_uint32()
        self.ConsoleHandle = v_ptr32()
        self.ConsoleFlags = v_uint32()
        self.StandardInput = v_ptr32()
        self.StandardOutput = v_ptr32()
        self.StandardError = v_ptr32()
        self.CurrentDirectory = CURDIR()
        self.DllPath = UNICODE_STRING()
        self.ImagePathName = UNICODE_STRING()
        self.CommandLine = UNICODE_STRING()
        self.Environment = v_ptr32()
        self.StartingX = v_uint32()
        self.StartingY = v_uint32()
        self.CountX = v_uint32()
        self.CountY = v_uint32()
        self.CountCharsX = v_uint32()
        self.CountCharsY = v_uint32()
        self.FillAttribute = v_uint32()
        self.WindowFlags = v_uint32()
        self.ShowWindowFlags = v_uint32()
        self.WindowTitle = UNICODE_STRING()
        self.DesktopInfo = UNICODE_STRING()
        self.ShellInfo = UNICODE_STRING()
        self.RuntimeData = UNICODE_STRING()
        self.CurrentDirectores = vstruct.VArray([ RTL_DRIVE_LETTER_CURDIR() for i in xrange(32) ])
        self.EnvironmentSize = v_uint32()
        self.EnvironmentVersion = v_uint32()


class _unnamed_16077(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Raw = _unnamed_16072()


class tagSHAREDINFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.psi = v_ptr32()
        self.aheList = v_ptr32()
        self.HeEntrySize = v_uint32()
        self.pDispInfo = v_ptr32()
        self.ulSharedDelta = v_uint32()
        self.awmControl = vstruct.VArray([ WNDMSG() for i in xrange(31) ])
        self.DefWindowMsgs = WNDMSG()
        self.DefWindowSpecMsgs = WNDMSG()


class tagIMC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.head = THRDESKHEAD()
        self.pImcNext = v_ptr32()
        self.dwClientImcData = v_uint32()
        self.hImeWnd = v_ptr32()


class IO_RESOURCE_REQUIREMENTS_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.SlotNumber = v_uint32()
        self.Reserved = vstruct.VArray([ v_uint32() for i in xrange(3) ])
        self.AlternativeLists = v_uint32()
        self.List = vstruct.VArray([ IO_RESOURCE_LIST() for i in xrange(1) ])


class tagCARET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.spwnd = v_ptr32()
        self.fVisible = v_uint32()
        self.iHideLevel = v_uint32()
        self.x = v_uint32()
        self.y = v_uint32()
        self.cy = v_uint32()
        self.cx = v_uint32()
        self.hBitmap = v_ptr32()
        self.hTimer = v_uint32()
        self.tid = v_uint32()
        self.xOwnDc = v_uint32()
        self.yOwnDc = v_uint32()
        self.cxOwnDc = v_uint32()
        self.cyOwnDc = v_uint32()




########NEW FILE########
__FILENAME__ = ntdll
# Version: 6.1
# Architecture: i386
import vstruct
from vstruct.primitives import *

KPROCESS_STATE = v_enum()
KPROCESS_STATE.ProcessInMemory = 0
KPROCESS_STATE.ProcessOutOfMemory = 1
KPROCESS_STATE.ProcessInTransition = 2
KPROCESS_STATE.ProcessOutTransition = 3
KPROCESS_STATE.ProcessInSwap = 4
KPROCESS_STATE.ProcessOutSwap = 5
KPROCESS_STATE.ProcessAllSwapStates = 6


WHEA_ERROR_SEVERITY = v_enum()
WHEA_ERROR_SEVERITY.WheaErrSevRecoverable = 0
WHEA_ERROR_SEVERITY.WheaErrSevFatal = 1
WHEA_ERROR_SEVERITY.WheaErrSevCorrected = 2
WHEA_ERROR_SEVERITY.WheaErrSevInformational = 3


REG_NOTIFY_CLASS = v_enum()
REG_NOTIFY_CLASS.RegNtDeleteKey = 0
REG_NOTIFY_CLASS.RegNtPreDeleteKey = 1
REG_NOTIFY_CLASS.RegNtSetValueKey = 2
REG_NOTIFY_CLASS.RegNtPreSetValueKey = 3
REG_NOTIFY_CLASS.RegNtDeleteValueKey = 4
REG_NOTIFY_CLASS.RegNtPreDeleteValueKey = 5
REG_NOTIFY_CLASS.RegNtSetInformationKey = 6
REG_NOTIFY_CLASS.RegNtPreSetInformationKey = 7
REG_NOTIFY_CLASS.RegNtRenameKey = 8
REG_NOTIFY_CLASS.RegNtPreRenameKey = 9
REG_NOTIFY_CLASS.RegNtEnumerateKey = 10
REG_NOTIFY_CLASS.RegNtPreEnumerateKey = 11
REG_NOTIFY_CLASS.RegNtEnumerateValueKey = 12
REG_NOTIFY_CLASS.RegNtPreEnumerateValueKey = 13
REG_NOTIFY_CLASS.RegNtQueryKey = 14
REG_NOTIFY_CLASS.RegNtPreQueryKey = 15
REG_NOTIFY_CLASS.RegNtQueryValueKey = 16
REG_NOTIFY_CLASS.RegNtPreQueryValueKey = 17
REG_NOTIFY_CLASS.RegNtQueryMultipleValueKey = 18
REG_NOTIFY_CLASS.RegNtPreQueryMultipleValueKey = 19
REG_NOTIFY_CLASS.RegNtPreCreateKey = 20
REG_NOTIFY_CLASS.RegNtPostCreateKey = 21
REG_NOTIFY_CLASS.RegNtPreOpenKey = 22
REG_NOTIFY_CLASS.RegNtPostOpenKey = 23
REG_NOTIFY_CLASS.RegNtKeyHandleClose = 24
REG_NOTIFY_CLASS.RegNtPreKeyHandleClose = 25
REG_NOTIFY_CLASS.RegNtPostDeleteKey = 26
REG_NOTIFY_CLASS.RegNtPostSetValueKey = 27
REG_NOTIFY_CLASS.RegNtPostDeleteValueKey = 28
REG_NOTIFY_CLASS.RegNtPostSetInformationKey = 29
REG_NOTIFY_CLASS.RegNtPostRenameKey = 30
REG_NOTIFY_CLASS.RegNtPostEnumerateKey = 31
REG_NOTIFY_CLASS.RegNtPostEnumerateValueKey = 32
REG_NOTIFY_CLASS.RegNtPostQueryKey = 33
REG_NOTIFY_CLASS.RegNtPostQueryValueKey = 34
REG_NOTIFY_CLASS.RegNtPostQueryMultipleValueKey = 35
REG_NOTIFY_CLASS.RegNtPostKeyHandleClose = 36
REG_NOTIFY_CLASS.RegNtPreCreateKeyEx = 37
REG_NOTIFY_CLASS.RegNtPostCreateKeyEx = 38
REG_NOTIFY_CLASS.RegNtPreOpenKeyEx = 39
REG_NOTIFY_CLASS.RegNtPostOpenKeyEx = 40
REG_NOTIFY_CLASS.RegNtPreFlushKey = 41
REG_NOTIFY_CLASS.RegNtPostFlushKey = 42
REG_NOTIFY_CLASS.RegNtPreLoadKey = 43
REG_NOTIFY_CLASS.RegNtPostLoadKey = 44
REG_NOTIFY_CLASS.RegNtPreUnLoadKey = 45
REG_NOTIFY_CLASS.RegNtPostUnLoadKey = 46
REG_NOTIFY_CLASS.RegNtPreQueryKeySecurity = 47
REG_NOTIFY_CLASS.RegNtPostQueryKeySecurity = 48
REG_NOTIFY_CLASS.RegNtPreSetKeySecurity = 49
REG_NOTIFY_CLASS.RegNtPostSetKeySecurity = 50
REG_NOTIFY_CLASS.RegNtCallbackObjectContextCleanup = 51
REG_NOTIFY_CLASS.RegNtPreRestoreKey = 52
REG_NOTIFY_CLASS.RegNtPostRestoreKey = 53
REG_NOTIFY_CLASS.RegNtPreSaveKey = 54
REG_NOTIFY_CLASS.RegNtPostSaveKey = 55
REG_NOTIFY_CLASS.RegNtPreReplaceKey = 56
REG_NOTIFY_CLASS.RegNtPostReplaceKey = 57
REG_NOTIFY_CLASS.MaxRegNtNotifyClass = 58


DEVICE_RELATION_TYPE = v_enum()
DEVICE_RELATION_TYPE.BusRelations = 0
DEVICE_RELATION_TYPE.EjectionRelations = 1
DEVICE_RELATION_TYPE.PowerRelations = 2
DEVICE_RELATION_TYPE.RemovalRelations = 3
DEVICE_RELATION_TYPE.TargetDeviceRelation = 4
DEVICE_RELATION_TYPE.SingleBusRelations = 5
DEVICE_RELATION_TYPE.TransportRelations = 6


FILE_INFORMATION_CLASS = v_enum()
FILE_INFORMATION_CLASS.FileDirectoryInformation = 0
FILE_INFORMATION_CLASS.FileFullDirectoryInformation = 1
FILE_INFORMATION_CLASS.FileBothDirectoryInformation = 2
FILE_INFORMATION_CLASS.FileBasicInformation = 3
FILE_INFORMATION_CLASS.FileStandardInformation = 4
FILE_INFORMATION_CLASS.FileInternalInformation = 5
FILE_INFORMATION_CLASS.FileEaInformation = 6
FILE_INFORMATION_CLASS.FileAccessInformation = 7
FILE_INFORMATION_CLASS.FileNameInformation = 8
FILE_INFORMATION_CLASS.FileRenameInformation = 9
FILE_INFORMATION_CLASS.FileLinkInformation = 10
FILE_INFORMATION_CLASS.FileNamesInformation = 11
FILE_INFORMATION_CLASS.FileDispositionInformation = 12
FILE_INFORMATION_CLASS.FilePositionInformation = 13
FILE_INFORMATION_CLASS.FileFullEaInformation = 14
FILE_INFORMATION_CLASS.FileModeInformation = 15
FILE_INFORMATION_CLASS.FileAlignmentInformation = 16
FILE_INFORMATION_CLASS.FileAllInformation = 17
FILE_INFORMATION_CLASS.FileAllocationInformation = 18
FILE_INFORMATION_CLASS.FileEndOfFileInformation = 19
FILE_INFORMATION_CLASS.FileAlternateNameInformation = 20
FILE_INFORMATION_CLASS.FileStreamInformation = 21
FILE_INFORMATION_CLASS.FilePipeInformation = 22
FILE_INFORMATION_CLASS.FilePipeLocalInformation = 23
FILE_INFORMATION_CLASS.FilePipeRemoteInformation = 24
FILE_INFORMATION_CLASS.FileMailslotQueryInformation = 25
FILE_INFORMATION_CLASS.FileMailslotSetInformation = 26
FILE_INFORMATION_CLASS.FileCompressionInformation = 27
FILE_INFORMATION_CLASS.FileObjectIdInformation = 28
FILE_INFORMATION_CLASS.FileCompletionInformation = 29
FILE_INFORMATION_CLASS.FileMoveClusterInformation = 30
FILE_INFORMATION_CLASS.FileQuotaInformation = 31
FILE_INFORMATION_CLASS.FileReparsePointInformation = 32
FILE_INFORMATION_CLASS.FileNetworkOpenInformation = 33
FILE_INFORMATION_CLASS.FileAttributeTagInformation = 34
FILE_INFORMATION_CLASS.FileTrackingInformation = 35
FILE_INFORMATION_CLASS.FileIdBothDirectoryInformation = 36
FILE_INFORMATION_CLASS.FileIdFullDirectoryInformation = 37
FILE_INFORMATION_CLASS.FileValidDataLengthInformation = 38
FILE_INFORMATION_CLASS.FileShortNameInformation = 39
FILE_INFORMATION_CLASS.FileIoCompletionNotificationInformation = 40
FILE_INFORMATION_CLASS.FileIoStatusBlockRangeInformation = 41
FILE_INFORMATION_CLASS.FileIoPriorityHintInformation = 42
FILE_INFORMATION_CLASS.FileSfioReserveInformation = 43
FILE_INFORMATION_CLASS.FileSfioVolumeInformation = 44
FILE_INFORMATION_CLASS.FileHardLinkInformation = 45
FILE_INFORMATION_CLASS.FileProcessIdsUsingFileInformation = 46
FILE_INFORMATION_CLASS.FileNormalizedNameInformation = 47
FILE_INFORMATION_CLASS.FileNetworkPhysicalNameInformation = 48
FILE_INFORMATION_CLASS.FileIdGlobalTxDirectoryInformation = 49
FILE_INFORMATION_CLASS.FileIsRemoteDeviceInformation = 50
FILE_INFORMATION_CLASS.FileAttributeCacheInformation = 51
FILE_INFORMATION_CLASS.FileNumaNodeInformation = 52
FILE_INFORMATION_CLASS.FileStandardLinkInformation = 53
FILE_INFORMATION_CLASS.FileRemoteProtocolInformation = 54
FILE_INFORMATION_CLASS.FileMaximumInformation = 55


ALTERNATIVE_ARCHITECTURE_TYPE = v_enum()
ALTERNATIVE_ARCHITECTURE_TYPE.StandardDesign = 0
ALTERNATIVE_ARCHITECTURE_TYPE.NEC98x86 = 1
ALTERNATIVE_ARCHITECTURE_TYPE.EndAlternatives = 2


BUS_QUERY_ID_TYPE = v_enum()
BUS_QUERY_ID_TYPE.BusQueryDeviceID = 0
BUS_QUERY_ID_TYPE.BusQueryHardwareIDs = 1
BUS_QUERY_ID_TYPE.BusQueryCompatibleIDs = 2
BUS_QUERY_ID_TYPE.BusQueryInstanceID = 3
BUS_QUERY_ID_TYPE.BusQueryDeviceSerialNumber = 4
BUS_QUERY_ID_TYPE.BusQueryContainerID = 5


KOBJECTS = v_enum()
KOBJECTS.EventNotificationObject = 0
KOBJECTS.EventSynchronizationObject = 1
KOBJECTS.MutantObject = 2
KOBJECTS.ProcessObject = 3
KOBJECTS.QueueObject = 4
KOBJECTS.SemaphoreObject = 5
KOBJECTS.ThreadObject = 6
KOBJECTS.GateObject = 7
KOBJECTS.TimerNotificationObject = 8
KOBJECTS.TimerSynchronizationObject = 9
KOBJECTS.Spare2Object = 10
KOBJECTS.Spare3Object = 11
KOBJECTS.Spare4Object = 12
KOBJECTS.Spare5Object = 13
KOBJECTS.Spare6Object = 14
KOBJECTS.Spare7Object = 15
KOBJECTS.Spare8Object = 16
KOBJECTS.Spare9Object = 17
KOBJECTS.ApcObject = 18
KOBJECTS.DpcObject = 19
KOBJECTS.DeviceQueueObject = 20
KOBJECTS.EventPairObject = 21
KOBJECTS.InterruptObject = 22
KOBJECTS.ProfileObject = 23
KOBJECTS.ThreadedDpcObject = 24
KOBJECTS.MaximumKernelObject = 25


NT_PRODUCT_TYPE = v_enum()
NT_PRODUCT_TYPE.NtProductWinNt = 0
NT_PRODUCT_TYPE.NtProductLanManNt = 1
NT_PRODUCT_TYPE.NtProductServer = 2


DEVICE_POWER_STATE = v_enum()
DEVICE_POWER_STATE.PowerDeviceUnspecified = 0
DEVICE_POWER_STATE.PowerDeviceD0 = 1
DEVICE_POWER_STATE.PowerDeviceD1 = 2
DEVICE_POWER_STATE.PowerDeviceD2 = 3
DEVICE_POWER_STATE.PowerDeviceD3 = 4
DEVICE_POWER_STATE.PowerDeviceMaximum = 5


WHEA_ERROR_SOURCE_TYPE = v_enum()
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMCE = 0
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCMC = 1
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeCPE = 2
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeNMI = 3
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypePCIe = 4
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeGeneric = 5
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeINIT = 6
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeBOOT = 7
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeSCIGeneric = 8
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFMCA = 9
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCMC = 10
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeIPFCPE = 11
WHEA_ERROR_SOURCE_TYPE.WheaErrSrcTypeMax = 12


PROC_HYPERVISOR_STATE = v_enum()
PROC_HYPERVISOR_STATE.ProcHypervisorNone = 0
PROC_HYPERVISOR_STATE.ProcHypervisorPresent = 1
PROC_HYPERVISOR_STATE.ProcHypervisorPower = 2


RTL_GENERIC_COMPARE_RESULTS = v_enum()
RTL_GENERIC_COMPARE_RESULTS.GenericLessThan = 0
RTL_GENERIC_COMPARE_RESULTS.GenericGreaterThan = 1
RTL_GENERIC_COMPARE_RESULTS.GenericEqual = 2


KWAIT_BLOCK_STATE = v_enum()
KWAIT_BLOCK_STATE.WaitBlockBypassStart = 0
KWAIT_BLOCK_STATE.WaitBlockBypassComplete = 1
KWAIT_BLOCK_STATE.WaitBlockActive = 2
KWAIT_BLOCK_STATE.WaitBlockInactive = 3
KWAIT_BLOCK_STATE.WaitBlockAllStates = 4


WHEA_ERROR_TYPE = v_enum()
WHEA_ERROR_TYPE.WheaErrTypeProcessor = 0
WHEA_ERROR_TYPE.WheaErrTypeMemory = 1
WHEA_ERROR_TYPE.WheaErrTypePCIExpress = 2
WHEA_ERROR_TYPE.WheaErrTypeNMI = 3
WHEA_ERROR_TYPE.WheaErrTypePCIXBus = 4
WHEA_ERROR_TYPE.WheaErrTypePCIXDevice = 5
WHEA_ERROR_TYPE.WheaErrTypeGeneric = 6


PROCESSOR_CACHE_TYPE = v_enum()
PROCESSOR_CACHE_TYPE.CacheUnified = 0
PROCESSOR_CACHE_TYPE.CacheInstruction = 1
PROCESSOR_CACHE_TYPE.CacheData = 2
PROCESSOR_CACHE_TYPE.CacheTrace = 3


MCA_EXCEPTION_TYPE = v_enum()
MCA_EXCEPTION_TYPE.HAL_MCE_RECORD = 0
MCA_EXCEPTION_TYPE.HAL_MCA_RECORD = 1


EVENT_TYPE = v_enum()
EVENT_TYPE.NotificationEvent = 0
EVENT_TYPE.SynchronizationEvent = 1


KSPIN_LOCK_QUEUE_NUMBER = v_enum()
KSPIN_LOCK_QUEUE_NUMBER.LockQueueUnusedSpare0 = 0
KSPIN_LOCK_QUEUE_NUMBER.LockQueueExpansionLock = 1
KSPIN_LOCK_QUEUE_NUMBER.LockQueueUnusedSpare2 = 2
KSPIN_LOCK_QUEUE_NUMBER.LockQueueSystemSpaceLock = 3
KSPIN_LOCK_QUEUE_NUMBER.LockQueueVacbLock = 4
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMasterLock = 5
KSPIN_LOCK_QUEUE_NUMBER.LockQueueNonPagedPoolLock = 6
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoCancelLock = 7
KSPIN_LOCK_QUEUE_NUMBER.LockQueueWorkQueueLock = 8
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoVpbLock = 9
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoDatabaseLock = 10
KSPIN_LOCK_QUEUE_NUMBER.LockQueueIoCompletionLock = 11
KSPIN_LOCK_QUEUE_NUMBER.LockQueueNtfsStructLock = 12
KSPIN_LOCK_QUEUE_NUMBER.LockQueueAfdWorkQueueLock = 13
KSPIN_LOCK_QUEUE_NUMBER.LockQueueBcbLock = 14
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMmNonPagedPoolLock = 15
KSPIN_LOCK_QUEUE_NUMBER.LockQueueUnusedSpare16 = 16
KSPIN_LOCK_QUEUE_NUMBER.LockQueueMaximumLock = 17


TP_CALLBACK_PRIORITY = v_enum()
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_HIGH = 0
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_NORMAL = 1
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_LOW = 2
TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_INVALID = 3


FSINFOCLASS = v_enum()
FSINFOCLASS.FileFsVolumeInformation = 0
FSINFOCLASS.FileFsLabelInformation = 1
FSINFOCLASS.FileFsSizeInformation = 2
FSINFOCLASS.FileFsDeviceInformation = 3
FSINFOCLASS.FileFsAttributeInformation = 4
FSINFOCLASS.FileFsControlInformation = 5
FSINFOCLASS.FileFsFullSizeInformation = 6
FSINFOCLASS.FileFsObjectIdInformation = 7
FSINFOCLASS.FileFsDriverPathInformation = 8
FSINFOCLASS.FileFsVolumeFlagsInformation = 9
FSINFOCLASS.FileFsMaximumInformation = 10


WORKING_SET_TYPE = v_enum()
WORKING_SET_TYPE.WorkingSetTypeUser = 0
WORKING_SET_TYPE.WorkingSetTypeSession = 1
WORKING_SET_TYPE.WorkingSetTypeSystemTypes = 2
WORKING_SET_TYPE.WorkingSetTypeSystemCache = 3
WORKING_SET_TYPE.WorkingSetTypePagedPool = 4
WORKING_SET_TYPE.WorkingSetTypeSystemPtes = 5
WORKING_SET_TYPE.WorkingSetTypeMaximum = 6


POOL_TYPE = v_enum()
POOL_TYPE.NonPagedPool = 0
POOL_TYPE.PagedPool = 1
POOL_TYPE.NonPagedPoolMustSucceed = 2
POOL_TYPE.DontUseThisType = 3
POOL_TYPE.NonPagedPoolCacheAligned = 4
POOL_TYPE.PagedPoolCacheAligned = 5
POOL_TYPE.NonPagedPoolCacheAlignedMustS = 6
POOL_TYPE.MaxPoolType = 7
POOL_TYPE.NonPagedPoolSession = 8
POOL_TYPE.PagedPoolSession = 9
POOL_TYPE.NonPagedPoolMustSucceedSession = 10
POOL_TYPE.DontUseThisTypeSession = 11
POOL_TYPE.NonPagedPoolCacheAlignedSession = 12
POOL_TYPE.PagedPoolCacheAlignedSession = 13
POOL_TYPE.NonPagedPoolCacheAlignedMustSSession = 14


IO_PRIORITY_HINT = v_enum()
IO_PRIORITY_HINT.IoPriorityVeryLow = 0
IO_PRIORITY_HINT.IoPriorityLow = 1
IO_PRIORITY_HINT.IoPriorityNormal = 2
IO_PRIORITY_HINT.IoPriorityHigh = 3
IO_PRIORITY_HINT.IoPriorityCritical = 4
IO_PRIORITY_HINT.MaxIoPriorityTypes = 5


MODE = v_enum()
MODE.KernelMode = 0
MODE.UserMode = 1
MODE.MaximumMode = 2


FS_FILTER_SECTION_SYNC_TYPE = v_enum()
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeOther = 0
FS_FILTER_SECTION_SYNC_TYPE.SyncTypeCreateSection = 1


OB_OPEN_REASON = v_enum()
OB_OPEN_REASON.ObCreateHandle = 0
OB_OPEN_REASON.ObOpenHandle = 1
OB_OPEN_REASON.ObDuplicateHandle = 2
OB_OPEN_REASON.ObInheritHandle = 3
OB_OPEN_REASON.ObMaxOpenReason = 4


HEAP_FAILURE_TYPE = v_enum()
HEAP_FAILURE_TYPE.heap_failure_internal = 0
HEAP_FAILURE_TYPE.heap_failure_unknown = 1
HEAP_FAILURE_TYPE.heap_failure_generic = 2
HEAP_FAILURE_TYPE.heap_failure_entry_corruption = 3
HEAP_FAILURE_TYPE.heap_failure_multiple_entries_corruption = 4
HEAP_FAILURE_TYPE.heap_failure_virtual_block_corruption = 5
HEAP_FAILURE_TYPE.heap_failure_buffer_overrun = 6
HEAP_FAILURE_TYPE.heap_failure_buffer_underrun = 7
HEAP_FAILURE_TYPE.heap_failure_block_not_busy = 8
HEAP_FAILURE_TYPE.heap_failure_invalid_argument = 9
HEAP_FAILURE_TYPE.heap_failure_usage_after_free = 10
HEAP_FAILURE_TYPE.heap_failure_cross_heap_operation = 11
HEAP_FAILURE_TYPE.heap_failure_freelists_corruption = 12
HEAP_FAILURE_TYPE.heap_failure_listentry_corruption = 13


DEVICE_TEXT_TYPE = v_enum()
DEVICE_TEXT_TYPE.DeviceTextDescription = 0
DEVICE_TEXT_TYPE.DeviceTextLocationInformation = 1


POWER_STATE_TYPE = v_enum()
POWER_STATE_TYPE.SystemPowerState = 0
POWER_STATE_TYPE.DevicePowerState = 1


IRQ_PRIORITY = v_enum()
IRQ_PRIORITY.IrqPriorityUndefined = 0
IRQ_PRIORITY.IrqPriorityLow = 1
IRQ_PRIORITY.IrqPriorityNormal = 2
IRQ_PRIORITY.IrqPriorityHigh = 3


KWAIT_STATE = v_enum()
KWAIT_STATE.WaitInProgress = 0
KWAIT_STATE.WaitCommitted = 1
KWAIT_STATE.WaitAborted = 2
KWAIT_STATE.MaximumWaitState = 3


LSA_FOREST_TRUST_RECORD_TYPE = v_enum()
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName = 0
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx = 1
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo = 2
LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustRecordTypeLast = 3


IO_ALLOCATION_ACTION = v_enum()
IO_ALLOCATION_ACTION.KeepObject = 0
IO_ALLOCATION_ACTION.DeallocateObject = 1
IO_ALLOCATION_ACTION.DeallocateObjectKeepRegisters = 2


EXCEPTION_DISPOSITION = v_enum()
EXCEPTION_DISPOSITION.ExceptionContinueExecution = 0
EXCEPTION_DISPOSITION.ExceptionContinueSearch = 1
EXCEPTION_DISPOSITION.ExceptionNestedException = 2
EXCEPTION_DISPOSITION.ExceptionCollidedUnwind = 3


SECURITY_OPERATION_CODE = v_enum()
SECURITY_OPERATION_CODE.SetSecurityDescriptor = 0
SECURITY_OPERATION_CODE.QuerySecurityDescriptor = 1
SECURITY_OPERATION_CODE.DeleteSecurityDescriptor = 2
SECURITY_OPERATION_CODE.AssignSecurityDescriptor = 3


PP_NPAGED_LOOKASIDE_NUMBER = v_enum()
PP_NPAGED_LOOKASIDE_NUMBER.LookasideSmallIrpList = 0
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMediumIrpList = 1
PP_NPAGED_LOOKASIDE_NUMBER.LookasideLargeIrpList = 2
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMdlList = 3
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCreateInfoList = 4
PP_NPAGED_LOOKASIDE_NUMBER.LookasideNameBufferList = 5
PP_NPAGED_LOOKASIDE_NUMBER.LookasideTwilightList = 6
PP_NPAGED_LOOKASIDE_NUMBER.LookasideCompletionList = 7
PP_NPAGED_LOOKASIDE_NUMBER.LookasideScratchBufferList = 8
PP_NPAGED_LOOKASIDE_NUMBER.LookasideMaximumList = 9


WHEA_ERROR_PACKET_DATA_FORMAT = v_enum()
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatIPFSalRecord = 0
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatXPFMCA = 1
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMemory = 2
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIExpress = 3
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatNMIPort = 4
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXBus = 5
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatPCIXDevice = 6
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatGeneric = 7
WHEA_ERROR_PACKET_DATA_FORMAT.WheaDataFormatMax = 8


FS_FILTER_STREAM_FO_NOTIFICATION_TYPE = v_enum()
FS_FILTER_STREAM_FO_NOTIFICATION_TYPE.NotifyTypeCreate = 0
FS_FILTER_STREAM_FO_NOTIFICATION_TYPE.NotifyTypeRetired = 1


DISPLAYCONFIG_SCANLINE_ORDERING = v_enum()
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = 3
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 4
DISPLAYCONFIG_SCANLINE_ORDERING.DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = 5


SECURITY_IMPERSONATION_LEVEL = v_enum()
SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous = 0
SECURITY_IMPERSONATION_LEVEL.SecurityIdentification = 1
SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation = 2
SECURITY_IMPERSONATION_LEVEL.SecurityDelegation = 3


DEVICE_USAGE_NOTIFICATION_TYPE = v_enum()
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeUndefined = 0
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypePaging = 1
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeHibernation = 2
DEVICE_USAGE_NOTIFICATION_TYPE.DeviceUsageTypeDumpFile = 3


INTERFACE_TYPE = v_enum()
INTERFACE_TYPE.InterfaceTypeUndefined = 0
INTERFACE_TYPE.Internal = 1
INTERFACE_TYPE.Isa = 2
INTERFACE_TYPE.Eisa = 3
INTERFACE_TYPE.MicroChannel = 4
INTERFACE_TYPE.TurboChannel = 5
INTERFACE_TYPE.PCIBus = 6
INTERFACE_TYPE.VMEBus = 7
INTERFACE_TYPE.NuBus = 8
INTERFACE_TYPE.PCMCIABus = 9
INTERFACE_TYPE.CBus = 10
INTERFACE_TYPE.MPIBus = 11
INTERFACE_TYPE.MPSABus = 12
INTERFACE_TYPE.ProcessorInternal = 13
INTERFACE_TYPE.InternalPowerBus = 14
INTERFACE_TYPE.PNPISABus = 15
INTERFACE_TYPE.PNPBus = 16
INTERFACE_TYPE.Vmcs = 17
INTERFACE_TYPE.MaximumInterfaceType = 18


PS_RESOURCE_TYPE = v_enum()
PS_RESOURCE_TYPE.PsResourceNonPagedPool = 0
PS_RESOURCE_TYPE.PsResourcePagedPool = 1
PS_RESOURCE_TYPE.PsResourcePageFile = 2
PS_RESOURCE_TYPE.PsResourceWorkingSet = 3
PS_RESOURCE_TYPE.PsResourceCpuRate = 4
PS_RESOURCE_TYPE.PsResourceMax = 5


MM_PAGE_ACCESS_TYPE = v_enum()
MM_PAGE_ACCESS_TYPE.MmPteAccessType = 0
MM_PAGE_ACCESS_TYPE.MmCcReadAheadType = 1
MM_PAGE_ACCESS_TYPE.MmPfnRepurposeType = 2
MM_PAGE_ACCESS_TYPE.MmMaximumPageAccessType = 3


PF_FILE_ACCESS_TYPE = v_enum()
PF_FILE_ACCESS_TYPE.PfFileAccessTypeRead = 0
PF_FILE_ACCESS_TYPE.PfFileAccessTypeWrite = 1
PF_FILE_ACCESS_TYPE.PfFileAccessTypeMax = 2


HARDWARE_COUNTER_TYPE = v_enum()
HARDWARE_COUNTER_TYPE.PMCCounter = 0
HARDWARE_COUNTER_TYPE.MaxHardwareCounterType = 1


ReplacesCorHdrNumericDefines = v_enum()
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY = 0
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED = 1
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY = 2
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED = 3
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 4
ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA = 5
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2 = 6
ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR = 7
ReplacesCorHdrNumericDefines.COR_VERSION_MINOR = 8
ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH = 9
ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH = 10
ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB = 11
ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 12
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA = 13
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA = 14
ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK = 15
ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT = 16
ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT = 17
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED = 18
ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 19
ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED = 20
ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE = 21
ReplacesCorHdrNumericDefines.MAX_CLASS_NAME = 22
ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME = 23


SYSTEM_POWER_STATE = v_enum()
SYSTEM_POWER_STATE.PowerSystemUnspecified = 0
SYSTEM_POWER_STATE.PowerSystemWorking = 1
SYSTEM_POWER_STATE.PowerSystemSleeping1 = 2
SYSTEM_POWER_STATE.PowerSystemSleeping2 = 3
SYSTEM_POWER_STATE.PowerSystemSleeping3 = 4
SYSTEM_POWER_STATE.PowerSystemHibernate = 5
SYSTEM_POWER_STATE.PowerSystemShutdown = 6
SYSTEM_POWER_STATE.PowerSystemMaximum = 7


MEMORY_CACHING_TYPE_ORIG = v_enum()
MEMORY_CACHING_TYPE_ORIG.MmFrameBufferCached = 0


POWER_ACTION = v_enum()
POWER_ACTION.PowerActionNone = 0
POWER_ACTION.PowerActionReserved = 1
POWER_ACTION.PowerActionSleep = 2
POWER_ACTION.PowerActionHibernate = 3
POWER_ACTION.PowerActionShutdown = 4
POWER_ACTION.PowerActionShutdownReset = 5
POWER_ACTION.PowerActionShutdownOff = 6
POWER_ACTION.PowerActionWarmEject = 7


class _unnamed_9074(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.McaCod = v_uint16()
        self.MsCod = v_uint16()
        self.OtherInfo = v_uint32()


class _unnamed_9775(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.MessageCount = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint32()


class _unnamed_9770(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint16()
        self.Group = v_uint16()
        self.Vector = v_uint32()
        self.Affinity = v_uint32()


class _unnamed_9079(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BankNumber = v_uint8()
        self.Reserved2 = v_bytes(size=7) # FIXME Unknown Array Type
        self.Status = MCI_STATS()
        self.Address = MCI_ADDR()
        self.Misc = v_uint64()


class IO_PRIORITY_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint32()
        self.ThreadPriority = v_uint32()
        self.PagePriority = v_uint32()
        self.IoPriority = v_uint32()


class KEXECUTE_OPTIONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteDisable = v_uint8()


class SID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.SubAuthorityCount = v_uint8()
        self.IdentifierAuthority = SID_IDENTIFIER_AUTHORITY()
        self.SubAuthority = v_bytes(size=4) # FIXME Unknown Array Type


class WHEA_ERROR_PACKET_V2(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Version = v_uint32()
        self.Length = v_uint32()
        self.Flags = WHEA_ERROR_PACKET_FLAGS()
        self.ErrorType = v_uint32()
        self.ErrorSeverity = v_uint32()
        self.ErrorSourceId = v_uint32()
        self.ErrorSourceType = v_uint32()
        self.NotifyType = GUID()
        self.Context = v_uint64()
        self.DataFormat = v_uint32()
        self.Reserved1 = v_uint32()
        self.DataOffset = v_uint32()
        self.DataLength = v_uint32()
        self.PshedDataOffset = v_uint32()
        self.PshedDataLength = v_uint32()


class _unnamed_8009(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FsInformationClass = v_uint32()


class GROUP_AFFINITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint32()
        self.Group = v_uint16()
        self.Reserved = v_bytes(size=6) # FIXME Unknown Array Type


class KTSS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Backlink = v_uint16()
        self.Reserved0 = v_uint16()
        self.Esp0 = v_uint32()
        self.Ss0 = v_uint16()
        self.Reserved1 = v_uint16()
        self.NotUsed1 = v_bytes(size=16) # FIXME Unknown Array Type
        self.CR3 = v_uint32()
        self.Eip = v_uint32()
        self.EFlags = v_uint32()
        self.Eax = v_uint32()
        self.Ecx = v_uint32()
        self.Edx = v_uint32()
        self.Ebx = v_uint32()
        self.Esp = v_uint32()
        self.Ebp = v_uint32()
        self.Esi = v_uint32()
        self.Edi = v_uint32()
        self.Es = v_uint16()
        self.Reserved2 = v_uint16()
        self.Cs = v_uint16()
        self.Reserved3 = v_uint16()
        self.Ss = v_uint16()
        self.Reserved4 = v_uint16()
        self.Ds = v_uint16()
        self.Reserved5 = v_uint16()
        self.Fs = v_uint16()
        self.Reserved6 = v_uint16()
        self.Gs = v_uint16()
        self.Reserved7 = v_uint16()
        self.LDT = v_uint16()
        self.Reserved8 = v_uint16()
        self.Flags = v_uint16()
        self.IoMapBase = v_uint16()
        self.IoMaps = v_uint16()
        self.IntDirectionMap = v_bytes(size=32) # FIXME Unknown Array Type


class CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DosPath = UNICODE_STRING()
        self.Handle = v_ptr32()


class PERFINFO_GROUPMASK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Masks = v_bytes(size=32) # FIXME Unknown Array Type


class HANDLE_TABLE_ENTRY_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AuditMask = v_uint32()


class _unnamed_9803(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length64 = v_uint32()


class _unnamed_9800(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length48 = v_uint32()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SectionOffset = v_uint32()
        self.SectionLength = v_uint32()
        self.Revision = WHEA_REVISION()
        self.ValidBits = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS()
        self.Reserved = v_uint8()
        self.Flags = WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS()
        self.SectionType = GUID()
        self.FRUId = GUID()
        self.SectionSeverity = v_uint32()
        self.FRUText = v_bytes(size=20) # FIXME Unknown Array Type


class PS_CPU_QUOTA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.SessionId = v_uint32()
        self.CpuShareWeight = v_uint32()
        self.CapturedWeightData = PSP_CPU_SHARE_CAPTURED_WEIGHT_DATA()
        self.DuplicateInputMarker = v_uint32()
        self._pad0040 = v_bytes(size=36)
        self.CycleCredit = v_uint64()
        self.BlockCurrentGeneration = v_uint32()
        self.CpuCyclePercent = v_uint32()
        self.CyclesFinishedForCurrentGeneration = v_uint8()
        self._pad0080 = v_bytes(size=47)
        self.Cpu = v_uint8()


class _unnamed_9783(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Channel = v_uint32()
        self.Port = v_uint32()
        self.Reserved1 = v_uint32()


class RTL_TRACE_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint32()
        self.Database = v_ptr32()
        self.NextSegment = v_ptr32()
        self.TotalSize = v_uint32()
        self.SegmentStart = v_ptr32()
        self.SegmentEnd = v_ptr32()
        self.SegmentFree = v_ptr32()


class _unnamed_9787(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = v_bytes(size=12) # FIXME Unknown Array Type


class _unnamed_9789(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = v_uint32()
        self.Length = v_uint32()
        self.Reserved = v_uint32()


class DEVICE_CAPABILITIES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.DeviceD1 = v_uint32()
        self.Address = v_uint32()
        self.UINumber = v_uint32()
        self.DeviceState = v_uint32()
        self.SystemWake = v_uint32()
        self.DeviceWake = v_uint32()
        self.D1Latency = v_uint32()
        self.D2Latency = v_uint32()
        self.D3Latency = v_uint32()


class _unnamed_7990(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.EaList = v_ptr32()
        self.EaListLength = v_uint32()
        self.EaIndex = v_uint32()


class _unnamed_7995(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()


class KPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.ProfileListHead = LIST_ENTRY()
        self.DirectoryTableBase = v_uint32()
        self.LdtDescriptor = KGDTENTRY()
        self.Int21Descriptor = KIDTENTRY()
        self.ThreadListHead = LIST_ENTRY()
        self.ProcessLock = v_uint32()
        self.Affinity = KAFFINITY_EX()
        self.ReadyListHead = LIST_ENTRY()
        self.SwapListEntry = SINGLE_LIST_ENTRY()
        self.ActiveProcessors = KAFFINITY_EX()
        self.AutoAlignment = v_uint32()
        self.BasePriority = v_uint8()
        self.QuantumReset = v_uint8()
        self.Visited = v_uint8()
        self.Unused3 = v_uint8()
        self.ThreadSeed = v_bytes(size=16) # FIXME Unknown Array Type
        self.IdealNode = v_bytes(size=8) # FIXME Unknown Array Type
        self.IdealGlobalNode = v_uint16()
        self.Flags = KEXECUTE_OPTIONS()
        self.Unused1 = v_uint8()
        self.IopmOffset = v_uint16()
        self._pad009c = v_bytes(size=2)
        self.Unused4 = v_uint32()
        self.StackCount = KSTACK_COUNT()
        self.ProcessListEntry = LIST_ENTRY()
        self._pad00b0 = v_bytes(size=4)
        self.CycleTime = v_uint64()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.VdmTrapcHandler = v_ptr32()


class DEVICE_OBJECT_POWER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_7909(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Key = v_uint32()
        self.ByteOffset = LARGE_INTEGER()


class _unnamed_10332(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length48 = v_uint32()
        self.Alignment48 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Primary = v_uint32()


class TP_CALLBACK_ENVIRON_V3(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint32()
        self.Pool = v_ptr32()
        self.CleanupGroup = v_ptr32()
        self.CleanupGroupCancelCallback = v_ptr32()
        self.RaceDll = v_ptr32()
        self.ActivationContext = v_ptr32()
        self.FinalizationCallback = v_ptr32()
        self.u = _unnamed_5798()
        self.CallbackPriority = v_uint32()
        self.Size = v_uint32()


class _unnamed_7902(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self.Parameters = v_ptr32()


class RTL_ACTIVATION_CONTEXT_STACK_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Previous = v_ptr32()
        self.ActivationContext = v_ptr32()
        self.Flags = v_uint32()


class ALPC_PROCESS_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = EX_PUSH_LOCK()
        self.ViewListHead = LIST_ENTRY()
        self.PagedPoolQuotaCache = v_uint32()


class OBJECT_HANDLE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HandleAttributes = v_uint32()
        self.GrantedAccess = v_uint32()


class PROC_PERF_DOMAIN(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = LIST_ENTRY()
        self.Master = v_ptr32()
        self.Members = KAFFINITY_EX()
        self.FeedbackHandler = v_ptr32()
        self.GetFFHThrottleState = v_ptr32()
        self.BoostPolicyHandler = v_ptr32()
        self.PerfSelectionHandler = v_ptr32()
        self.PerfHandler = v_ptr32()
        self.Processors = v_ptr32()
        self._pad0040 = v_bytes(size=4)
        self.PerfChangeTime = v_uint64()
        self.ProcessorCount = v_uint32()
        self.PreviousFrequencyMhz = v_uint32()
        self.CurrentFrequencyMhz = v_uint32()
        self.PreviousFrequency = v_uint32()
        self.CurrentFrequency = v_uint32()
        self.CurrentPerfContext = v_uint32()
        self.DesiredFrequency = v_uint32()
        self.MaxFrequency = v_uint32()
        self.MinPerfPercent = v_uint32()
        self.MinThrottlePercent = v_uint32()
        self.MaxPercent = v_uint32()
        self.MinPercent = v_uint32()
        self.ConstrainedMaxPercent = v_uint32()
        self.ConstrainedMinPercent = v_uint32()
        self.Coordination = v_uint8()
        self._pad0084 = v_bytes(size=3)
        self.PerfChangeIntervalCount = v_uint32()


class KTIMER_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint32()
        self.Entry = LIST_ENTRY()
        self._pad0010 = v_bytes(size=4)
        self.Time = ULARGE_INTEGER()


class PS_CLIENT_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImpersonationData = v_uint32()


class RTL_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = RTL_BALANCED_LINKS()
        self.OrderedPointer = v_ptr32()
        self.WhichOrderedElement = v_uint32()
        self.NumberGenericTableElements = v_uint32()
        self.DepthOfTree = v_uint32()
        self.RestartKey = v_ptr32()
        self.DeleteCount = v_uint32()
        self.CompareRoutine = v_ptr32()
        self.AllocateRoutine = v_ptr32()
        self.FreeRoutine = v_ptr32()
        self.TableContext = v_ptr32()


class RTL_TRACE_DATABASE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint32()
        self.Flags = v_uint32()
        self.Tag = v_uint32()
        self.SegmentList = v_ptr32()
        self.MaximumSize = v_uint32()
        self.CurrentSize = v_uint32()
        self.Owner = v_ptr32()
        self.Lock = RTL_CRITICAL_SECTION()
        self.NoOfBuckets = v_uint32()
        self.Buckets = v_ptr32()
        self.HashFunction = v_ptr32()
        self.NoOfTraces = v_uint32()
        self.NoOfHits = v_uint32()
        self.HashCounter = v_bytes(size=64) # FIXME Unknown Array Type


class OWNER_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OwnerThread = v_uint32()
        self.IoPriorityBoosted = v_uint32()


class DEVOBJ_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.PowerFlags = v_uint32()
        self.Dope = v_ptr32()
        self.ExtensionFlags = v_uint32()
        self.DeviceNode = v_ptr32()
        self.AttachedTo = v_ptr32()
        self.StartIoCount = v_uint32()
        self.StartIoKey = v_uint32()
        self.StartIoFlags = v_uint32()
        self.Vpb = v_ptr32()
        self.DependentList = LIST_ENTRY()
        self.ProviderList = LIST_ENTRY()


class HEAP_LOCAL_SEGMENT_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Hint = v_ptr32()
        self.ActiveSubsegment = v_ptr32()
        self.CachedItems = v_bytes(size=64) # FIXME Unknown Array Type
        self.SListHeader = SLIST_HEADER()
        self.Counters = HEAP_BUCKET_COUNTERS()
        self.LocalData = v_ptr32()
        self.LastOpSequence = v_uint32()
        self.BucketIndex = v_uint16()
        self.LastUsed = v_uint16()


class HANDLE_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr32()
        self.GrantedAccess = v_uint32()


class HEAP_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalMemoryReserved = v_uint32()
        self.TotalMemoryCommitted = v_uint32()
        self.TotalMemoryLargeUCR = v_uint32()
        self.TotalSizeInVirtualBlocks = v_uint32()
        self.TotalSegments = v_uint32()
        self.TotalUCRs = v_uint32()
        self.CommittOps = v_uint32()
        self.DeCommitOps = v_uint32()
        self.LockAcquires = v_uint32()
        self.LockCollisions = v_uint32()
        self.CommitRate = v_uint32()
        self.DecommittRate = v_uint32()
        self.CommitFailures = v_uint32()
        self.InBlockCommitFailures = v_uint32()
        self.CompactHeapCalls = v_uint32()
        self.CompactedUCRs = v_uint32()
        self.AllocAndFreeOps = v_uint32()
        self.InBlockDeccommits = v_uint32()
        self.InBlockDeccomitSize = v_uint32()
        self.HighWatermarkSize = v_uint32()
        self.LastPolledSize = v_uint32()


class MAILSLOT_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MailslotQuota = v_uint32()
        self.MaximumMessageSize = v_uint32()
        self.ReadTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()


class FS_FILTER_CALLBACK_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbackData = v_uint32()
        self.Operation = v_uint8()
        self.Reserved = v_uint8()
        self._pad0008 = v_bytes(size=2)
        self.DeviceObject = v_ptr32()
        self.FileObject = v_ptr32()
        self.Parameters = FS_FILTER_PARAMETERS()


class PPM_IDLE_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DomainMembers = KAFFINITY_EX()
        self.IdleCheck = v_ptr32()
        self.IdleHandler = v_ptr32()
        self.Context = v_ptr32()
        self.Latency = v_uint32()
        self.Power = v_uint32()
        self.TimeCheck = v_uint32()
        self.StateFlags = v_uint32()
        self.PromotePercent = v_uint8()
        self.DemotePercent = v_uint8()
        self.PromotePercentBase = v_uint8()
        self.DemotePercentBase = v_uint8()
        self.StateType = v_uint8()


class ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OperationID = LUID()
        self.SecurityEvaluated = v_uint8()
        self.GenerateAudit = v_uint8()
        self.GenerateOnClose = v_uint8()
        self.PrivilegesAllocated = v_uint8()
        self.Flags = v_uint32()
        self.RemainingDesiredAccess = v_uint32()
        self.PreviouslyGrantedAccess = v_uint32()
        self.OriginalDesiredAccess = v_uint32()
        self.SubjectSecurityContext = SECURITY_SUBJECT_CONTEXT()
        self.SecurityDescriptor = v_ptr32()
        self.AuxData = v_ptr32()
        self.Privileges = _unnamed_7708()
        self.AuditPrivileges = v_uint8()
        self._pad0064 = v_bytes(size=3)
        self.ObjectName = UNICODE_STRING()
        self.ObjectTypeName = UNICODE_STRING()


class TP_CALLBACK_INSTANCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class PROC_IDLE_ACCOUNTING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StateCount = v_uint32()
        self.TotalTransitions = v_uint32()
        self.ResetCount = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.StartTime = v_uint64()
        self.BucketLimits = v_bytes(size=128) # FIXME Unknown Array Type
        self.State = v_bytes(size=128) # FIXME Unknown Array Type


class GDI_TEB_BATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.HDC = v_uint32()
        self.Buffer = v_bytes(size=1240) # FIXME Unknown Array Type


class THREAD_PERFORMANCE_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.ProcessorNumber = PROCESSOR_NUMBER()
        self.ContextSwitches = v_uint32()
        self.HwCountersCount = v_uint32()
        self.UpdateCount = v_uint64()
        self.WaitReasonBitMap = v_uint64()
        self.HardwareCounters = v_uint64()
        self.CycleTime = COUNTER_READING()
        self.HwCounters = COUNTER_READING()


class PAGEFAULT_HISTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ECP_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_8043(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Vpb = v_ptr32()
        self.DeviceObject = v_ptr32()


class SECTION_OBJECT_POINTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSectionObject = v_ptr32()
        self.SharedCacheMap = v_ptr32()
        self.ImageSectionObject = v_ptr32()


class _unnamed_8047(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Srb = v_ptr32()


class KTRAP_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DbgEbp = v_uint32()
        self.DbgEip = v_uint32()
        self.DbgArgMark = v_uint32()
        self.DbgArgPointer = v_uint32()
        self.TempSegCs = v_uint16()
        self.Logging = v_uint8()
        self.Reserved = v_uint8()
        self.TempEsp = v_uint32()
        self.Dr0 = v_uint32()
        self.Dr1 = v_uint32()
        self.Dr2 = v_uint32()
        self.Dr3 = v_uint32()
        self.Dr6 = v_uint32()
        self.Dr7 = v_uint32()
        self.SegGs = v_uint32()
        self.SegEs = v_uint32()
        self.SegDs = v_uint32()
        self.Edx = v_uint32()
        self.Ecx = v_uint32()
        self.Eax = v_uint32()
        self.PreviousPreviousMode = v_uint32()
        self.ExceptionList = v_ptr32()
        self.SegFs = v_uint32()
        self.Edi = v_uint32()
        self.Esi = v_uint32()
        self.Ebx = v_uint32()
        self.Ebp = v_uint32()
        self.ErrCode = v_uint32()
        self.Eip = v_uint32()
        self.SegCs = v_uint32()
        self.EFlags = v_uint32()
        self.HardwareEsp = v_uint32()
        self.HardwareSegSs = v_uint32()
        self.V86Es = v_uint32()
        self.V86Ds = v_uint32()
        self.V86Fs = v_uint32()
        self.V86Gs = v_uint32()


class _unnamed_8120(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Capabilities = v_ptr32()


class MCI_ADDR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_uint32()
        self.Reserved = v_uint32()


class IO_TIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.TimerFlag = v_uint16()
        self.TimerList = LIST_ENTRY()
        self.TimerRoutine = v_ptr32()
        self.Context = v_ptr32()
        self.DeviceObject = v_ptr32()


class WHEA_REVISION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinorRevision = v_uint8()
        self.MajorRevision = v_uint8()


class TP_CLEANUP_GROUP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class PROC_IDLE_SNAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Time = v_uint64()
        self.Idle = v_uint64()


class SECURITY_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Revision = v_uint8()
        self.Sbz1 = v_uint8()
        self.Control = v_uint16()
        self.Owner = v_ptr32()
        self.Group = v_ptr32()
        self.Sacl = v_ptr32()
        self.Dacl = v_ptr32()


class _unnamed_7708(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InitialPrivilegeSet = INITIAL_PRIVILEGE_SET()


class OBJECT_TYPE_INITIALIZER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.ObjectTypeFlags = v_uint8()
        self._pad0004 = v_bytes(size=1)
        self.ObjectTypeCode = v_uint32()
        self.InvalidAttributes = v_uint32()
        self.GenericMapping = GENERIC_MAPPING()
        self.ValidAccessMask = v_uint32()
        self.RetainAccess = v_uint32()
        self.PoolType = v_uint32()
        self.DefaultPagedPoolCharge = v_uint32()
        self.DefaultNonPagedPoolCharge = v_uint32()
        self.DumpProcedure = v_ptr32()
        self.OpenProcedure = v_ptr32()
        self.CloseProcedure = v_ptr32()
        self.DeleteProcedure = v_ptr32()
        self.ParseProcedure = v_ptr32()
        self.SecurityProcedure = v_ptr32()
        self.QueryNameProcedure = v_ptr32()
        self.OkayToCloseProcedure = v_ptr32()


class TP_DIRECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callback = v_ptr32()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()


class XSTATE_SAVE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved1 = v_uint64()
        self.Reserved2 = v_uint32()
        self.Prev = v_ptr32()
        self.Reserved3 = v_ptr32()
        self.Thread = v_ptr32()
        self.Reserved4 = v_ptr32()
        self.Level = v_uint8()


class HEAP_ENTRY_EXTRA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatorBackTraceIndex = v_uint16()
        self.TagIndex = v_uint16()
        self.Settable = v_uint32()


class HEAP_PSEUDO_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint32()


class PAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = FAST_MUTEX()


class _unnamed_9563(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Balance = v_uint32()


class LARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class NPAGED_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE()
        self.Lock__ObsoleteButDoNotDelete = v_uint32()


class _unnamed_7790(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserApcRoutine = v_ptr32()
        self.UserApcContext = v_ptr32()


class VPB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.Flags = v_uint16()
        self.VolumeLabelLength = v_uint16()
        self.DeviceObject = v_ptr32()
        self.RealDevice = v_ptr32()
        self.SerialNumber = v_uint32()
        self.ReferenceCount = v_uint32()
        self.VolumeLabel = v_bytes(size=64) # FIXME Unknown Array Type


class PP_LOOKASIDE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.P = v_ptr32()
        self.L = v_ptr32()


class OBJECT_NAME_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Name = UNICODE_STRING()


class IO_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.Descriptors = v_uint32()


class KUSER_SHARED_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TickCountLowDeprecated = v_uint32()
        self.TickCountMultiplier = v_uint32()
        self.InterruptTime = KSYSTEM_TIME()
        self.SystemTime = KSYSTEM_TIME()
        self.TimeZoneBias = KSYSTEM_TIME()
        self.ImageNumberLow = v_uint16()
        self.ImageNumberHigh = v_uint16()
        self.NtSystemRoot = v_bytes(size=520) # FIXME Unknown Array Type
        self.MaxStackTraceDepth = v_uint32()
        self.CryptoExponent = v_uint32()
        self.TimeZoneId = v_uint32()
        self.LargePageMinimum = v_uint32()
        self.Reserved2 = v_bytes(size=28) # FIXME Unknown Array Type
        self.NtProductType = v_uint32()
        self.ProductTypeIsValid = v_uint8()
        self._pad026c = v_bytes(size=3)
        self.NtMajorVersion = v_uint32()
        self.NtMinorVersion = v_uint32()
        self.ProcessorFeatures = v_bytes(size=64) # FIXME Unknown Array Type
        self.Reserved1 = v_uint32()
        self.Reserved3 = v_uint32()
        self.TimeSlip = v_uint32()
        self.AlternativeArchitecture = v_uint32()
        self.AltArchitecturePad = v_bytes(size=4) # FIXME Unknown Array Type
        self.SystemExpirationDate = LARGE_INTEGER()
        self.SuiteMask = v_uint32()
        self.KdDebuggerEnabled = v_uint8()
        self.NXSupportPolicy = v_uint8()
        self._pad02d8 = v_bytes(size=2)
        self.ActiveConsoleId = v_uint32()
        self.DismountCount = v_uint32()
        self.ComPlusPackage = v_uint32()
        self.LastSystemRITEventTickCount = v_uint32()
        self.NumberOfPhysicalPages = v_uint32()
        self.SafeBootMode = v_uint8()
        self.TscQpcData = v_uint8()
        self.TscQpcPad = v_bytes(size=2) # FIXME Unknown Array Type
        self.SharedDataFlags = v_uint32()
        self.DataFlagsPad = v_bytes(size=4) # FIXME Unknown Array Type
        self.TestRetInstruction = v_uint64()
        self.SystemCall = v_uint32()
        self.SystemCallReturn = v_uint32()
        self.SystemCallPad = v_bytes(size=24) # FIXME Unknown Array Type
        self.TickCount = KSYSTEM_TIME()
        self.TickCountPad = v_bytes(size=4) # FIXME Unknown Array Type
        self.Cookie = v_uint32()
        self.CookiePad = v_bytes(size=4) # FIXME Unknown Array Type
        self.ConsoleSessionForegroundProcessId = v_uint64()
        self.Wow64SharedInformation = v_bytes(size=64) # FIXME Unknown Array Type
        self.UserModeGlobalLogger = v_bytes(size=32) # FIXME Unknown Array Type
        self.ImageFileExecutionOptions = v_uint32()
        self.LangGenerationCount = v_uint32()
        self.Reserved5 = v_uint64()
        self.InterruptTimeBias = v_uint64()
        self.TscQpcBias = v_uint64()
        self.ActiveProcessorCount = v_uint32()
        self.ActiveGroupCount = v_uint16()
        self.Reserved4 = v_uint16()
        self.AitSamplingValue = v_uint32()
        self.AppCompatFlag = v_uint32()
        self.SystemDllNativeRelocation = v_uint64()
        self.SystemDllWowRelocation = v_uint32()
        self.XStatePad = v_bytes(size=4) # FIXME Unknown Array Type
        self.XState = XSTATE_CONFIGURATION()


class SYSTEM_POWER_STATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved1 = v_uint32()


class FS_FILTER_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AcquireForModifiedPageWriter = _unnamed_9854()


class HEAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.SegmentSignature = v_uint32()
        self.SegmentFlags = v_uint32()
        self.SegmentListEntry = LIST_ENTRY()
        self.Heap = v_ptr32()
        self.BaseAddress = v_ptr32()
        self.NumberOfPages = v_uint32()
        self.FirstEntry = v_ptr32()
        self.LastValidEntry = v_ptr32()
        self.NumberOfUnCommittedPages = v_uint32()
        self.NumberOfUnCommittedRanges = v_uint32()
        self.SegmentAllocatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self.UCRSegmentList = LIST_ENTRY()
        self.Flags = v_uint32()
        self.ForceFlags = v_uint32()
        self.CompatibilityFlags = v_uint32()
        self.EncodeFlagMask = v_uint32()
        self.Encoding = HEAP_ENTRY()
        self.PointerKey = v_uint32()
        self.Interceptor = v_uint32()
        self.VirtualMemoryThreshold = v_uint32()
        self.Signature = v_uint32()
        self.SegmentReserve = v_uint32()
        self.SegmentCommit = v_uint32()
        self.DeCommitFreeBlockThreshold = v_uint32()
        self.DeCommitTotalFreeThreshold = v_uint32()
        self.TotalFreeSize = v_uint32()
        self.MaximumAllocationSize = v_uint32()
        self.ProcessHeapsListIndex = v_uint16()
        self.HeaderValidateLength = v_uint16()
        self.HeaderValidateCopy = v_ptr32()
        self.NextAvailableTagIndex = v_uint16()
        self.MaximumTagIndex = v_uint16()
        self.TagEntries = v_ptr32()
        self.UCRList = LIST_ENTRY()
        self.AlignRound = v_uint32()
        self.AlignMask = v_uint32()
        self.VirtualAllocdBlocks = LIST_ENTRY()
        self.SegmentList = LIST_ENTRY()
        self.AllocatorBackTraceIndex = v_uint16()
        self._pad00b4 = v_bytes(size=2)
        self.NonDedicatedListLength = v_uint32()
        self.BlocksIndex = v_ptr32()
        self.UCRIndex = v_ptr32()
        self.PseudoTagEntries = v_ptr32()
        self.FreeLists = LIST_ENTRY()
        self.LockVariable = v_ptr32()
        self.CommitRoutine = v_ptr32()
        self.FrontEndHeap = v_ptr32()
        self.FrontHeapLockCount = v_uint16()
        self.FrontEndHeapType = v_uint8()
        self._pad00dc = v_bytes(size=1)
        self.Counters = HEAP_COUNTERS()
        self.TuningParameters = HEAP_TUNING_PARAMETERS()


class IO_STATUS_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Status = v_uint32()
        self.Information = v_uint32()


class PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = v_uint32()


class CM_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.List = v_uint32()


class EPROCESS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pcb = KPROCESS()
        self.ProcessLock = EX_PUSH_LOCK()
        self._pad00d0 = v_bytes(size=4)
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.UniqueProcessId = v_ptr32()
        self.ActiveProcessLinks = LIST_ENTRY()
        self.ProcessQuotaUsage = v_bytes(size=8) # FIXME Unknown Array Type
        self.ProcessQuotaPeak = v_bytes(size=8) # FIXME Unknown Array Type
        self.CommitCharge = v_uint32()
        self.QuotaBlock = v_ptr32()
        self.CpuQuotaBlock = v_ptr32()
        self.PeakVirtualSize = v_uint32()
        self.VirtualSize = v_uint32()
        self.SessionProcessLinks = LIST_ENTRY()
        self.DebugPort = v_ptr32()
        self.ExceptionPortData = v_ptr32()
        self.ObjectTable = v_ptr32()
        self.Token = EX_FAST_REF()
        self.WorkingSetPage = v_uint32()
        self.AddressCreationLock = EX_PUSH_LOCK()
        self.RotateInProgress = v_ptr32()
        self.ForkInProgress = v_ptr32()
        self.HardwareTrigger = v_uint32()
        self.PhysicalVadRoot = v_ptr32()
        self.CloneRoot = v_ptr32()
        self.NumberOfPrivatePages = v_uint32()
        self.NumberOfLockedPages = v_uint32()
        self.Win32Process = v_ptr32()
        self.Job = v_ptr32()
        self.SectionObject = v_ptr32()
        self.SectionBaseAddress = v_ptr32()
        self.Cookie = v_uint32()
        self.Spare8 = v_uint32()
        self.WorkingSetWatch = v_ptr32()
        self.Win32WindowStation = v_ptr32()
        self.InheritedFromUniqueProcessId = v_ptr32()
        self.LdtInformation = v_ptr32()
        self.VdmObjects = v_ptr32()
        self.ConsoleHostProcess = v_uint32()
        self.DeviceMap = v_ptr32()
        self.EtwDataSource = v_ptr32()
        self.FreeTebHint = v_ptr32()
        self._pad0190 = v_bytes(size=4)
        self.PageDirectoryPte = HARDWARE_PTE_X86()
        self._pad0198 = v_bytes(size=4)
        self.Session = v_ptr32()
        self.ImageFileName = v_bytes(size=15) # FIXME Unknown Array Type
        self.PriorityClass = v_uint8()
        self.JobLinks = LIST_ENTRY()
        self.LockedPagesList = v_ptr32()
        self.ThreadListHead = LIST_ENTRY()
        self.SecurityPort = v_ptr32()
        self.PaeTop = v_ptr32()
        self.ActiveThreads = v_uint32()
        self.ImagePathHash = v_uint32()
        self.DefaultHardErrorProcessing = v_uint32()
        self.LastThreadExitStatus = v_uint32()
        self.Peb = v_ptr32()
        self.PrefetchTrace = EX_FAST_REF()
        self.ReadOperationCount = LARGE_INTEGER()
        self.WriteOperationCount = LARGE_INTEGER()
        self.OtherOperationCount = LARGE_INTEGER()
        self.ReadTransferCount = LARGE_INTEGER()
        self.WriteTransferCount = LARGE_INTEGER()
        self.OtherTransferCount = LARGE_INTEGER()
        self.CommitChargeLimit = v_uint32()
        self.CommitChargePeak = v_uint32()
        self.AweInfo = v_ptr32()
        self.SeAuditProcessCreationInfo = SE_AUDIT_PROCESS_CREATION_INFO()
        self.Vm = MMSUPPORT()
        self.MmProcessLinks = LIST_ENTRY()
        self.HighestUserAddress = v_ptr32()
        self.ModifiedPageCount = v_uint32()
        self.Flags2 = v_uint32()
        self.Flags = v_uint32()
        self.ExitStatus = v_uint32()
        self.VadRoot = MM_AVL_TABLE()
        self.AlpcContext = ALPC_PROCESS_CONTEXT()
        self.TimerResolutionLink = LIST_ENTRY()
        self.RequestedTimerResolution = v_uint32()
        self.ActiveThreadsHighWatermark = v_uint32()
        self.SmallestTimerResolution = v_uint32()
        self.TimerResolutionStackRecord = v_ptr32()


class TP_TASK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Callbacks = v_ptr32()
        self.NumaNode = v_uint32()
        self.IdealProcessor = v_uint8()
        self._pad000c = v_bytes(size=3)
        self.PostGuard = TP_NBQ_GUARD()
        self.NBQNode = v_ptr32()


class TEB_ACTIVE_FRAME_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.FrameName = v_ptr32()


class KTIMER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.DueTime = ULARGE_INTEGER()
        self.TimerListEntry = LIST_ENTRY()
        self.Dpc = v_ptr32()
        self.Period = v_uint32()


class CM_PARTIAL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Flags = v_uint16()
        self.u = _unnamed_9547()


class _unnamed_7890(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.Reserved = v_uint16()
        self.ShareAccess = v_uint16()
        self.Parameters = v_ptr32()


class OBJECT_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.RootDirectory = v_ptr32()
        self.ObjectName = v_ptr32()
        self.Attributes = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.SecurityQualityOfService = v_ptr32()


class CM_FULL_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.PartialResourceList = CM_PARTIAL_RESOURCE_LIST()


class KTIMER_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TimerExpiry = v_bytes(size=64) # FIXME Unknown Array Type
        self.TimerEntries = v_bytes(size=64) # FIXME Unknown Array Type


class FAST_IO_DISPATCH(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFastIoDispatch = v_uint32()
        self.FastIoCheckIfPossible = v_ptr32()
        self.FastIoRead = v_ptr32()
        self.FastIoWrite = v_ptr32()
        self.FastIoQueryBasicInfo = v_ptr32()
        self.FastIoQueryStandardInfo = v_ptr32()
        self.FastIoLock = v_ptr32()
        self.FastIoUnlockSingle = v_ptr32()
        self.FastIoUnlockAll = v_ptr32()
        self.FastIoUnlockAllByKey = v_ptr32()
        self.FastIoDeviceControl = v_ptr32()
        self.AcquireFileForNtCreateSection = v_ptr32()
        self.ReleaseFileForNtCreateSection = v_ptr32()
        self.FastIoDetachDevice = v_ptr32()
        self.FastIoQueryNetworkOpenInfo = v_ptr32()
        self.AcquireForModWrite = v_ptr32()
        self.MdlRead = v_ptr32()
        self.MdlReadComplete = v_ptr32()
        self.PrepareMdlWrite = v_ptr32()
        self.MdlWriteComplete = v_ptr32()
        self.FastIoReadCompressed = v_ptr32()
        self.FastIoWriteCompressed = v_ptr32()
        self.MdlReadCompleteCompressed = v_ptr32()
        self.MdlWriteCompleteCompressed = v_ptr32()
        self.FastIoQueryOpen = v_ptr32()
        self.ReleaseForModWrite = v_ptr32()
        self.AcquireForCcFlush = v_ptr32()
        self.ReleaseForCcFlush = v_ptr32()


class _unnamed_8164(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InPath = v_uint8()
        self.Reserved = v_bytes(size=3) # FIXME Unknown Array Type
        self.Type = v_uint32()


class _unnamed_9856(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SyncType = v_uint32()
        self.PageProtection = v_uint32()


class RTL_DYNAMIC_HASH_TABLE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ChainHead = v_ptr32()
        self.PrevLinkage = v_ptr32()
        self.Signature = v_uint32()


class MMWSL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class PROC_IDLE_STATE_ACCOUNTING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalTime = v_uint64()
        self.IdleTransitions = v_uint32()
        self.FailedTransitions = v_uint32()
        self.InvalidBucketIndex = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.MinTime = v_uint64()
        self.MaxTime = v_uint64()
        self.IdleTimeBuckets = v_uint64()


class _unnamed_9067(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mca = _unnamed_9079()


class KSPECIAL_REGISTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Cr0 = v_uint32()
        self.Cr2 = v_uint32()
        self.Cr3 = v_uint32()
        self.Cr4 = v_uint32()
        self.KernelDr0 = v_uint32()
        self.KernelDr1 = v_uint32()
        self.KernelDr2 = v_uint32()
        self.KernelDr3 = v_uint32()
        self.KernelDr6 = v_uint32()
        self.KernelDr7 = v_uint32()
        self.Gdtr = DESCRIPTOR()
        self.Idtr = DESCRIPTOR()
        self.Tr = v_uint16()
        self.Ldtr = v_uint16()
        self.Reserved = v_bytes(size=24) # FIXME Unknown Array Type


class RTL_CRITICAL_SECTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DebugInfo = v_ptr32()
        self.LockCount = v_uint32()
        self.RecursionCount = v_uint32()
        self.OwningThread = v_ptr32()
        self.LockSemaphore = v_ptr32()
        self.SpinCount = v_uint32()


class KSYSTEM_TIME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.High1Time = v_uint32()
        self.High2Time = v_uint32()


class PROC_IDLE_STATE_BUCKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalTime = v_uint64()
        self.MinTime = v_uint64()
        self.MaxTime = v_uint64()
        self.Count = v_uint32()


class RTL_STD_LIST_HEAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Lock = RTL_STACK_DATABASE_LOCK()


class FLOATING_SAVE_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint32()
        self.StatusWord = v_uint32()
        self.TagWord = v_uint32()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint32()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint32()
        self.RegisterArea = v_bytes(size=80) # FIXME Unknown Array Type
        self.Cr0NpxState = v_uint32()


class DPH_HEAP_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.pNextAlloc = v_ptr32()
        self._pad0010 = v_bytes(size=12)
        self.pUserAllocation = v_ptr32()
        self.pVirtualBlock = v_ptr32()
        self.nVirtualBlockSize = v_uint32()
        self.nVirtualAccessSize = v_uint32()
        self.nUserRequestedSize = v_uint32()
        self.nUserActualSize = v_uint32()
        self.UserValue = v_ptr32()
        self.UserFlags = v_uint32()
        self.StackTrace = v_ptr32()
        self.AdjacencyEntry = LIST_ENTRY()
        self.pVirtualRegion = v_ptr32()


class KQUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.EntryListHead = LIST_ENTRY()
        self.CurrentCount = v_uint32()
        self.MaximumCount = v_uint32()
        self.ThreadListHead = LIST_ENTRY()


class _unnamed_8017(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_ptr32()
        self.Key = v_uint32()
        self.ByteOffset = LARGE_INTEGER()


class LUID_AND_ATTRIBUTES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Luid = LUID()
        self.Attributes = v_uint32()


class _unnamed_8012(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self.InputBufferLength = v_uint32()
        self.FsControlCode = v_uint32()
        self.Type3InputBuffer = v_ptr32()


class HEAP_BUCKET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BlockUnits = v_uint16()
        self.SizeIndex = v_uint8()
        self.UseAffinity = v_uint8()


class CM_PARTIAL_RESOURCE_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint16()
        self.Revision = v_uint16()
        self.Count = v_uint32()
        self.PartialDescriptors = v_uint32()


class KTHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.CycleTime = v_uint64()
        self.HighCycleTime = v_uint32()
        self._pad0020 = v_bytes(size=4)
        self.QuantumTarget = v_uint64()
        self.InitialStack = v_ptr32()
        self.StackLimit = v_ptr32()
        self.KernelStack = v_ptr32()
        self.ThreadLock = v_uint32()
        self.WaitRegister = KWAIT_STATUS_REGISTER()
        self.Running = v_uint8()
        self.Alerted = v_bytes(size=2) # FIXME Unknown Array Type
        self.KernelStackResident = v_uint32()
        self.ApcState = KAPC_STATE()
        self.NextProcessor = v_uint32()
        self.DeferredProcessor = v_uint32()
        self.ApcQueueLock = v_uint32()
        self.ContextSwitches = v_uint32()
        self.State = v_uint8()
        self.NpxState = v_uint8()
        self.WaitIrql = v_uint8()
        self.WaitMode = v_uint8()
        self.WaitStatus = v_uint32()
        self.WaitBlockList = v_ptr32()
        self.WaitListEntry = LIST_ENTRY()
        self.Queue = v_ptr32()
        self.WaitTime = v_uint32()
        self.KernelApcDisable = v_uint16()
        self.SpecialApcDisable = v_uint16()
        self.Teb = v_ptr32()
        self._pad0090 = v_bytes(size=4)
        self.Timer = KTIMER()
        self.AutoAlignment = v_uint32()
        self.ServiceTable = v_ptr32()
        self.WaitBlock = v_ptr32()
        self.QueueListEntry = LIST_ENTRY()
        self.TrapFrame = v_ptr32()
        self.FirstArgument = v_ptr32()
        self.CallbackStack = v_ptr32()
        self.ApcStateIndex = v_uint8()
        self.BasePriority = v_uint8()
        self.PriorityDecrement = v_uint8()
        self.Preempted = v_uint8()
        self.AdjustReason = v_uint8()
        self.AdjustIncrement = v_uint8()
        self.PreviousMode = v_uint8()
        self.Saturation = v_uint8()
        self.SystemCallNumber = v_uint32()
        self.FreezeCount = v_uint32()
        self.UserAffinity = GROUP_AFFINITY()
        self.Process = v_ptr32()
        self.Affinity = GROUP_AFFINITY()
        self.IdealProcessor = v_uint32()
        self.UserIdealProcessor = v_uint32()
        self.ApcStatePointer = v_bytes(size=8) # FIXME Unknown Array Type
        self.SavedApcState = KAPC_STATE()
        self.SuspendCount = v_uint8()
        self.Spare1 = v_uint8()
        self.OtherPlatformFill = v_uint8()
        self._pad018c = v_bytes(size=1)
        self.Win32Thread = v_ptr32()
        self.StackBase = v_ptr32()
        self.SuspendApc = KAPC()
        self.UserTime = v_uint32()
        self.SuspendSemaphore = KSEMAPHORE()
        self.SListFaultCount = v_uint32()
        self.ThreadListEntry = LIST_ENTRY()
        self.MutantListHead = LIST_ENTRY()
        self.SListFaultAddress = v_ptr32()
        self.ThreadCounters = v_ptr32()
        self.XStateSave = v_ptr32()


class CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFlags = v_uint32()
        self.Dr0 = v_uint32()
        self.Dr1 = v_uint32()
        self.Dr2 = v_uint32()
        self.Dr3 = v_uint32()
        self.Dr6 = v_uint32()
        self.Dr7 = v_uint32()
        self.FloatSave = FLOATING_SAVE_AREA()
        self.SegGs = v_uint32()
        self.SegFs = v_uint32()
        self.SegEs = v_uint32()
        self.SegDs = v_uint32()
        self.Edi = v_uint32()
        self.Esi = v_uint32()
        self.Ebx = v_uint32()
        self.Edx = v_uint32()
        self.Ecx = v_uint32()
        self.Eax = v_uint32()
        self.Ebp = v_uint32()
        self.Eip = v_uint32()
        self.SegCs = v_uint32()
        self.EFlags = v_uint32()
        self.Esp = v_uint32()
        self.SegSs = v_uint32()
        self.ExtendedRegisters = v_bytes(size=512) # FIXME Unknown Array Type


class MCI_STATS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MciStats = _unnamed_9074()


class _unnamed_9793(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DataSize = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class _unnamed_9797(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length40 = v_uint32()


class PROC_PERF_LOAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BusyPercentage = v_uint8()
        self.FrequencyPercentage = v_uint8()


class AUX_ACCESS_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegesUsed = v_ptr32()
        self.GenericMapping = GENERIC_MAPPING()
        self.AccessesToAudit = v_uint32()
        self.MaximumAuditMask = v_uint32()
        self.TransactionId = GUID()
        self.NewSecurityDescriptor = v_ptr32()
        self.ExistingSecurityDescriptor = v_ptr32()
        self.ParentSecurityDescriptor = v_ptr32()
        self.DeRefSecurityDescriptor = v_ptr32()
        self.SDLock = v_ptr32()
        self.AccessReasons = ACCESS_REASONS()


class _unnamed_10337(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length64 = v_uint32()
        self.Alignment64 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class HEAP_LOCAL_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeletedSubSegments = SLIST_HEADER()
        self.CrtZone = v_ptr32()
        self.LowFragHeap = v_ptr32()
        self.Sequence = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.SegmentInfo = v_uint32()


class _unnamed_8680(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CriticalSection = RTL_CRITICAL_SECTION()


class DPH_BLOCK_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StartStamp = v_uint32()
        self.Heap = v_ptr32()
        self.RequestedSize = v_uint32()
        self.ActualSize = v_uint32()
        self.FreeQueue = LIST_ENTRY()
        self.StackTrace = v_ptr32()
        self.EndStamp = v_uint32()


class _unnamed_10308(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumVector = v_uint32()
        self.MaximumVector = v_uint32()
        self.AffinityPolicy = v_uint16()
        self.Group = v_uint16()
        self.PriorityPolicy = v_uint32()
        self.TargetedProcessors = v_uint32()


class PF_KERNEL_GLOBALS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AccessBufferAgeThreshold = v_uint64()
        self.AccessBufferRef = EX_RUNDOWN_REF()
        self.AccessBufferExistsEvent = KEVENT()
        self.AccessBufferMax = v_uint32()
        self.AccessBufferList = SLIST_HEADER()
        self.StreamSequenceNumber = v_uint32()
        self.Flags = v_uint32()
        self.ScenarioPrefetchCount = v_uint32()


class _unnamed_9086(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Address = v_uint64()
        self.Type = v_uint64()


class _unnamed_7851(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.Thread = v_ptr32()
        self.AuxiliaryBuffer = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.CurrentStackLocation = v_ptr32()
        self.OriginalFileObject = v_ptr32()


class EVENT_DATA_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Ptr = v_uint64()
        self.Size = v_uint32()
        self.Reserved = v_uint32()


class IO_DRIVER_CREATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self._pad0004 = v_bytes(size=2)
        self.ExtraCreateParameter = v_ptr32()
        self.DeviceObjectHint = v_ptr32()
        self.TxnParameters = v_ptr32()


class EJOB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Event = KEVENT()
        self.JobLinks = LIST_ENTRY()
        self.ProcessListHead = LIST_ENTRY()
        self.JobLock = ERESOURCE()
        self.TotalUserTime = LARGE_INTEGER()
        self.TotalKernelTime = LARGE_INTEGER()
        self.ThisPeriodTotalUserTime = LARGE_INTEGER()
        self.ThisPeriodTotalKernelTime = LARGE_INTEGER()
        self.TotalPageFaultCount = v_uint32()
        self.TotalProcesses = v_uint32()
        self.ActiveProcesses = v_uint32()
        self.TotalTerminatedProcesses = v_uint32()
        self.PerProcessUserTimeLimit = LARGE_INTEGER()
        self.PerJobUserTimeLimit = LARGE_INTEGER()
        self.MinimumWorkingSetSize = v_uint32()
        self.MaximumWorkingSetSize = v_uint32()
        self.LimitFlags = v_uint32()
        self.ActiveProcessLimit = v_uint32()
        self.Affinity = KAFFINITY_EX()
        self.PriorityClass = v_uint8()
        self._pad00c4 = v_bytes(size=3)
        self.AccessState = v_ptr32()
        self.UIRestrictionsClass = v_uint32()
        self.EndOfJobTimeAction = v_uint32()
        self.CompletionPort = v_ptr32()
        self.CompletionKey = v_ptr32()
        self.SessionId = v_uint32()
        self.SchedulingClass = v_uint32()
        self.ReadOperationCount = v_uint64()
        self.WriteOperationCount = v_uint64()
        self.OtherOperationCount = v_uint64()
        self.ReadTransferCount = v_uint64()
        self.WriteTransferCount = v_uint64()
        self.OtherTransferCount = v_uint64()
        self.ProcessMemoryLimit = v_uint32()
        self.JobMemoryLimit = v_uint32()
        self.PeakProcessMemoryUsed = v_uint32()
        self.PeakJobMemoryUsed = v_uint32()
        self.CurrentJobMemoryUsed = v_uint64()
        self.MemoryLimitsLock = EX_PUSH_LOCK()
        self.JobSetLinks = LIST_ENTRY()
        self.MemberLevel = v_uint32()
        self.JobFlags = v_uint32()


class HANDLE_TRACE_DEBUG_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.RefCount = v_uint32()
        self.TableSize = v_uint32()
        self.BitMaskFlags = v_uint32()
        self.CloseCompactionLock = FAST_MUTEX()
        self.CurrentStackIndex = v_uint32()
        self.TraceDb = v_uint32()


class KPROCESSOR_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ContextFrame = CONTEXT()
        self.SpecialRegisters = KSPECIAL_REGISTERS()


class KiIoAccessMap(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DirectionMap = v_bytes(size=32) # FIXME Unknown Array Type
        self.IoMap = v_bytes(size=8196) # FIXME Unknown Array Type


class _unnamed_8209(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemContext = v_uint32()
        self.Type = v_uint32()
        self.State = POWER_STATE()
        self.ShutdownType = v_uint32()


class KAPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.SpareByte0 = v_uint8()
        self.Size = v_uint8()
        self.SpareByte1 = v_uint8()
        self.SpareLong0 = v_uint32()
        self.Thread = v_ptr32()
        self.ApcListEntry = LIST_ENTRY()
        self.KernelRoutine = v_ptr32()
        self.RundownRoutine = v_ptr32()
        self.NormalRoutine = v_ptr32()
        self.NormalContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.ApcStateIndex = v_uint8()
        self.ApcMode = v_uint8()
        self.Inserted = v_uint8()


class _unnamed_6579(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Bytes = _unnamed_9134()


class RTL_STACK_DATABASE_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = RTL_SRWLOCK()


class SID_IDENTIFIER_AUTHORITY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Value = v_bytes(size=6) # FIXME Unknown Array Type


class XSTATE_FEATURE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint32()
        self.Size = v_uint32()


class WHEA_TIMESTAMP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Seconds = v_uint64()


class ACTIVATION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class RTL_CRITICAL_SECTION_DEBUG(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self.CriticalSection = v_ptr32()
        self.ProcessLocksList = LIST_ENTRY()
        self.EntryCount = v_uint32()
        self.ContentionCount = v_uint32()
        self.Flags = v_uint32()
        self.CreatorBackTraceIndexHigh = v_uint16()
        self.SpareUSHORT = v_uint16()


class DISPATCHER_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.TimerControlFlags = v_uint8()
        self.ThreadControlFlags = v_uint8()
        self.TimerMiscFlags = v_uint8()
        self.SignalState = v_uint32()
        self.WaitListHead = LIST_ENTRY()


class ASSEMBLY_STORAGE_MAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_9134(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMid = v_uint8()
        self.Flags1 = v_uint8()
        self.Flags2 = v_uint8()
        self.BaseHi = v_uint8()


class PROCESSOR_POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdleStates = v_ptr32()
        self._pad0008 = v_bytes(size=4)
        self.IdleTimeLast = v_uint64()
        self.IdleTimeTotal = v_uint64()
        self.IdleTimeEntry = v_uint64()
        self.IdleAccounting = v_ptr32()
        self.Hypervisor = v_uint32()
        self.PerfHistoryTotal = v_uint32()
        self.ThermalConstraint = v_uint8()
        self.PerfHistoryCount = v_uint8()
        self.PerfHistorySlot = v_uint8()
        self.Reserved = v_uint8()
        self.LastSysTime = v_uint32()
        self.WmiDispatchPtr = v_uint32()
        self.WmiInterfaceEnabled = v_uint32()
        self._pad0040 = v_bytes(size=4)
        self.FFHThrottleStateInfo = PPM_FFH_THROTTLE_STATE_INFO()
        self.PerfActionDpc = KDPC()
        self.PerfActionMask = v_uint32()
        self._pad0088 = v_bytes(size=4)
        self.IdleCheck = PROC_IDLE_SNAP()
        self.PerfCheck = PROC_IDLE_SNAP()
        self.Domain = v_ptr32()
        self.PerfConstraint = v_ptr32()
        self.Load = v_ptr32()
        self.PerfHistory = v_ptr32()
        self.Utility = v_uint32()
        self.OverUtilizedHistory = v_uint32()
        self.AffinityCount = v_uint32()
        self.AffinityHistory = v_uint32()


class _unnamed_8055(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.StartSid = v_ptr32()
        self.SidList = v_ptr32()
        self.SidListLength = v_uint32()


class POWER_SEQUENCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SequenceD1 = v_uint32()
        self.SequenceD2 = v_uint32()
        self.SequenceD3 = v_uint32()


class DPH_HEAP_ROOT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.HeapFlags = v_uint32()
        self.HeapCritSect = v_ptr32()
        self.nRemoteLockAcquired = v_uint32()
        self.pVirtualStorageListHead = v_ptr32()
        self.pVirtualStorageListTail = v_ptr32()
        self.nVirtualStorageRanges = v_uint32()
        self.nVirtualStorageBytes = v_uint32()
        self.BusyNodesTable = RTL_AVL_TABLE()
        self.NodeToAllocate = v_ptr32()
        self.nBusyAllocations = v_uint32()
        self.nBusyAllocationBytesCommitted = v_uint32()
        self.pFreeAllocationListHead = v_ptr32()
        self.pFreeAllocationListTail = v_ptr32()
        self.nFreeAllocations = v_uint32()
        self.nFreeAllocationBytesCommitted = v_uint32()
        self.AvailableAllocationHead = LIST_ENTRY()
        self.nAvailableAllocations = v_uint32()
        self.nAvailableAllocationBytesCommitted = v_uint32()
        self.pUnusedNodeListHead = v_ptr32()
        self.pUnusedNodeListTail = v_ptr32()
        self.nUnusedNodes = v_uint32()
        self.nBusyAllocationBytesAccessible = v_uint32()
        self.pNodePoolListHead = v_ptr32()
        self.pNodePoolListTail = v_ptr32()
        self.nNodePools = v_uint32()
        self.nNodePoolBytes = v_uint32()
        self.NextHeap = LIST_ENTRY()
        self.ExtraFlags = v_uint32()
        self.Seed = v_uint32()
        self.NormalHeap = v_ptr32()
        self.CreateStackTrace = v_ptr32()
        self.FirstThread = v_ptr32()


class JOB_ACCESS_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class SECURITY_QUALITY_OF_SERVICE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.ImpersonationLevel = v_uint32()
        self.ContextTrackingMode = v_uint8()
        self.EffectiveOnly = v_uint8()


class COMPRESSED_DATA_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CompressionFormatAndEngine = v_uint16()
        self.CompressionUnitShift = v_uint8()
        self.ChunkShift = v_uint8()
        self.ClusterShift = v_uint8()
        self.Reserved = v_uint8()
        self.NumberOfChunks = v_uint16()
        self.CompressedChunkSizes = v_bytes(size=4) # FIXME Unknown Array Type


class WHEA_ERROR_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = WHEA_ERROR_RECORD_HEADER()
        self.SectionDescriptor = WHEA_ERROR_RECORD_HEADER()


class PS_PER_CPU_QUOTA_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SortedListEntry = LIST_ENTRY()
        self.IdleOnlyListHead = LIST_ENTRY()
        self.CycleBaseAllowance = v_uint64()
        self.CyclesRemaining = v_uint64()
        self.CurrentGeneration = v_uint32()


class PROC_PERF_CONSTRAINT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Prcb = v_ptr32()
        self.PerfContext = v_uint32()
        self.PercentageCap = v_uint32()
        self.ThermalCap = v_uint32()
        self.TargetFrequency = v_uint32()
        self.AcumulatedFullFrequency = v_uint32()
        self.AcumulatedZeroFrequency = v_uint32()
        self.FrequencyHistoryTotal = v_uint32()
        self.AverageFrequency = v_uint32()


class LUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class CLIENT_ID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UniqueProcess = v_ptr32()
        self.UniqueThread = v_ptr32()


class RTL_STACK_TRACE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashChain = RTL_STD_LIST_ENTRY()
        self.TraceCount = v_uint16()
        self.IndexHigh = v_uint16()
        self.Index = v_uint16()
        self.Depth = v_uint16()
        self.BackTrace = v_bytes(size=128) # FIXME Unknown Array Type


class OBJECT_DUMP_CONTROL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Stream = v_ptr32()
        self.Detail = v_uint32()


class HANDLE_TRACE_DB_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientId = CLIENT_ID()
        self.Handle = v_ptr32()
        self.Type = v_uint32()
        self.StackTrace = v_bytes(size=64) # FIXME Unknown Array Type


class GENERAL_LOOKASIDE_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr32()
        self.FreeEx = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = v_bytes(size=8) # FIXME Unknown Array Type


class HARDWARE_PTE_X86(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Valid = v_uint32()


class RTL_SRWLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint32()


class HEAP_TAG_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Allocs = v_uint32()
        self.Frees = v_uint32()
        self.Size = v_uint32()
        self.TagIndex = v_uint16()
        self.CreatorBackTraceIndex = v_uint16()
        self.TagName = v_bytes(size=48) # FIXME Unknown Array Type


class STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class TP_POOL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class LIST_ENTRY32(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint32()
        self.Blink = v_uint32()


class SINGLE_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()


class _unnamed_7812(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Create = _unnamed_7874()


class PPM_FFH_THROTTLE_STATE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnableLogging = v_uint8()
        self._pad0004 = v_bytes(size=3)
        self.MismatchCount = v_uint32()
        self.Initialized = v_uint8()
        self._pad0010 = v_bytes(size=7)
        self.LastValue = v_uint64()
        self.LastLogTickCount = LARGE_INTEGER()


class KDEVICE_QUEUE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceListEntry = LIST_ENTRY()
        self.SortKey = v_uint32()
        self.Inserted = v_uint8()


class _unnamed_8027(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self.Length = v_uint32()


class CACHED_KSTACK_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SListHead = SLIST_HEADER()
        self.MinimumFree = v_uint32()
        self.Misses = v_uint32()
        self.MissesLast = v_uint32()
        self.Pad0 = v_uint32()


class HEAP_FAILURE_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Version = v_uint32()
        self.StructureSize = v_uint32()
        self.FailureType = v_uint32()
        self.HeapAddress = v_ptr32()
        self.Address = v_ptr32()
        self.Param1 = v_ptr32()
        self.Param2 = v_ptr32()
        self.Param3 = v_ptr32()
        self.PreviousBlock = v_ptr32()
        self.NextBlock = v_ptr32()
        self.ExpectedEncodedEntry = HEAP_ENTRY()
        self.ExpectedDecodedEntry = HEAP_ENTRY()
        self.StackTrace = v_bytes(size=128) # FIXME Unknown Array Type


class _unnamed_9370(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsULONG = v_uint32()


class EX_FAST_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Object = v_ptr32()


class INTERLOCK_SEQ(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Depth = v_uint16()
        self.FreeEntryOffset = v_uint16()
        self.Sequence = v_uint32()


class KSPIN_LOCK_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Lock = v_ptr32()


class WHEA_ERROR_PACKET_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PreviousError = v_uint32()


class FS_FILTER_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SizeOfFsFilterCallbacks = v_uint32()
        self.Reserved = v_uint32()
        self.PreAcquireForSectionSynchronization = v_ptr32()
        self.PostAcquireForSectionSynchronization = v_ptr32()
        self.PreReleaseForSectionSynchronization = v_ptr32()
        self.PostReleaseForSectionSynchronization = v_ptr32()
        self.PreAcquireForCcFlush = v_ptr32()
        self.PostAcquireForCcFlush = v_ptr32()
        self.PreReleaseForCcFlush = v_ptr32()
        self.PostReleaseForCcFlush = v_ptr32()
        self.PreAcquireForModifiedPageWriter = v_ptr32()
        self.PostAcquireForModifiedPageWriter = v_ptr32()
        self.PreReleaseForModifiedPageWriter = v_ptr32()
        self.PostReleaseForModifiedPageWriter = v_ptr32()


class _unnamed_10298(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Alignment = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class MM_DRIVER_VERIFIER_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint32()
        self.RaiseIrqls = v_uint32()
        self.AcquireSpinLocks = v_uint32()
        self.SynchronizeExecutions = v_uint32()
        self.AllocationsAttempted = v_uint32()
        self.AllocationsSucceeded = v_uint32()
        self.AllocationsSucceededSpecialPool = v_uint32()
        self.AllocationsWithNoTag = v_uint32()
        self.TrimRequests = v_uint32()
        self.Trims = v_uint32()
        self.AllocationsFailed = v_uint32()
        self.AllocationsFailedDeliberately = v_uint32()
        self.Loads = v_uint32()
        self.Unloads = v_uint32()
        self.UnTrackedPool = v_uint32()
        self.UserTrims = v_uint32()
        self.CurrentPagedPoolAllocations = v_uint32()
        self.CurrentNonPagedPoolAllocations = v_uint32()
        self.PeakPagedPoolAllocations = v_uint32()
        self.PeakNonPagedPoolAllocations = v_uint32()
        self.PagedBytes = v_uint32()
        self.NonPagedBytes = v_uint32()
        self.PeakPagedBytes = v_uint32()
        self.PeakNonPagedBytes = v_uint32()
        self.BurstAllocationsFailedDeliberately = v_uint32()
        self.SessionTrims = v_uint32()
        self.OptionChanges = v_uint32()
        self.VerifyMode = v_uint32()
        self.PreviousBucketName = UNICODE_STRING()
        self.ActivityCounter = v_uint32()
        self.PreviousActivityCounter = v_uint32()
        self.WorkerTrimRequests = v_uint32()


class IO_RESOURCE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Option = v_uint8()
        self.Type = v_uint8()
        self.ShareDisposition = v_uint8()
        self.Spare1 = v_uint8()
        self.Flags = v_uint16()
        self.Spare2 = v_uint16()
        self.u = _unnamed_9722()


class EX_PUSH_LOCK_CACHE_AWARE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locks = v_bytes(size=128) # FIXME Unknown Array Type


class RTL_TRACE_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint32()
        self.Count = v_uint32()
        self.Size = v_uint32()
        self.UserCount = v_uint32()
        self.UserSize = v_uint32()
        self.UserContext = v_ptr32()
        self.Next = v_ptr32()
        self.Trace = v_ptr32()


class IMAGE_OPTIONAL_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Magic = v_uint16()
        self.MajorLinkerVersion = v_uint8()
        self.MinorLinkerVersion = v_uint8()
        self.SizeOfCode = v_uint32()
        self.SizeOfInitializedData = v_uint32()
        self.SizeOfUninitializedData = v_uint32()
        self.AddressOfEntryPoint = v_uint32()
        self.BaseOfCode = v_uint32()
        self.BaseOfData = v_uint32()
        self.ImageBase = v_uint32()
        self.SectionAlignment = v_uint32()
        self.FileAlignment = v_uint32()
        self.MajorOperatingSystemVersion = v_uint16()
        self.MinorOperatingSystemVersion = v_uint16()
        self.MajorImageVersion = v_uint16()
        self.MinorImageVersion = v_uint16()
        self.MajorSubsystemVersion = v_uint16()
        self.MinorSubsystemVersion = v_uint16()
        self.Win32VersionValue = v_uint32()
        self.SizeOfImage = v_uint32()
        self.SizeOfHeaders = v_uint32()
        self.CheckSum = v_uint32()
        self.Subsystem = v_uint16()
        self.DllCharacteristics = v_uint16()
        self.SizeOfStackReserve = v_uint32()
        self.SizeOfStackCommit = v_uint32()
        self.SizeOfHeapReserve = v_uint32()
        self.SizeOfHeapCommit = v_uint32()
        self.LoaderFlags = v_uint32()
        self.NumberOfRvaAndSizes = v_uint32()
        self.DataDirectory = v_uint32()


class SCSI_REQUEST_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ETHREAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Tcb = KTHREAD()
        self.CreateTime = LARGE_INTEGER()
        self.ExitTime = LARGE_INTEGER()
        self.ExitStatus = v_uint32()
        self.PostBlockList = LIST_ENTRY()
        self.TerminationPort = v_ptr32()
        self.ActiveTimerListLock = v_uint32()
        self.ActiveTimerListHead = LIST_ENTRY()
        self.Cid = CLIENT_ID()
        self.KeyedWaitSemaphore = KSEMAPHORE()
        self.ClientSecurity = PS_CLIENT_SECURITY_CONTEXT()
        self.IrpList = LIST_ENTRY()
        self.TopLevelIrp = v_uint32()
        self.DeviceToVerify = v_ptr32()
        self.CpuQuotaApc = v_ptr32()
        self.Win32StartAddress = v_ptr32()
        self.LegacyPowerObject = v_ptr32()
        self.ThreadListEntry = LIST_ENTRY()
        self.RundownProtect = EX_RUNDOWN_REF()
        self.ThreadLock = EX_PUSH_LOCK()
        self.ReadClusterSize = v_uint32()
        self.MmLockOrdering = v_uint32()
        self.CrossThreadFlags = v_uint32()
        self.SameThreadPassiveFlags = v_uint32()
        self.SameThreadApcFlags = v_uint32()
        self.CacheManagerActive = v_uint8()
        self.DisablePageFaultClustering = v_uint8()
        self.ActiveFaultCount = v_uint8()
        self.LockOrderState = v_uint8()
        self.AlpcMessageId = v_uint32()
        self.AlpcMessage = v_ptr32()
        self.AlpcWaitListEntry = LIST_ENTRY()
        self.CacheManagerCount = v_uint32()
        self.IoBoostCount = v_uint32()
        self.IrpListLock = v_uint32()
        self.ReservedForSynchTracking = v_ptr32()
        self.CmCallbackListHead = SINGLE_LIST_ENTRY()


class FAST_MUTEX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Owner = v_ptr32()
        self.Contention = v_uint32()
        self.Event = KEVENT()
        self.OldIrql = v_uint32()


class WHEA_ERROR_RECORD_HEADER_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PlatformId = v_uint32()


class KDEVICE_QUEUE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceListHead = LIST_ENTRY()
        self.Lock = v_uint32()
        self.Busy = v_uint8()


class _unnamed_8156(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DeviceTextType = v_uint32()
        self.LocaleId = v_uint32()


class _unnamed_8151(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IdType = v_uint32()


class IO_SECURITY_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityQos = v_ptr32()
        self.AccessState = v_ptr32()
        self.DesiredAccess = v_uint32()
        self.FullCreateOptions = v_uint32()


class TERMINATION_PORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Port = v_ptr32()


class PROC_HISTORY_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Utility = v_uint16()
        self.Frequency = v_uint8()
        self.Reserved = v_uint8()


class IO_CLIENT_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextExtension = v_ptr32()
        self.ClientIdentificationAddress = v_ptr32()


class INITIAL_PRIVILEGE_SET(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PrivilegeCount = v_uint32()
        self.Control = v_uint32()
        self.Privilege = v_uint32()


class WHEA_ERROR_RECORD_HEADER_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Recovered = v_uint32()


class XSTATE_CONFIGURATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EnabledFeatures = v_uint64()
        self.Size = v_uint32()
        self.OptimizedSave = v_uint32()
        self.Features = v_uint32()


class KWAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitListEntry = LIST_ENTRY()
        self.Thread = v_ptr32()
        self.Object = v_ptr32()
        self.NextWaitBlock = v_ptr32()
        self.WaitKey = v_uint16()
        self.WaitType = v_uint8()
        self.BlockState = v_uint8()


class ACTIVATION_CONTEXT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class FILE_NETWORK_OPEN_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.FileAttributes = v_uint32()


class DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Pad = v_uint16()
        self.Limit = v_uint16()
        self.Base = v_uint32()


class _unnamed_8022(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.OutputBufferLength = v_uint32()
        self.InputBufferLength = v_uint32()
        self.IoControlCode = v_uint32()
        self.Type3InputBuffer = v_ptr32()


class HEAP_USERDATA_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SFreeListEntry = SINGLE_LIST_ENTRY()
        self.Reserved = v_ptr32()
        self.SizeIndex = v_uint32()
        self.Signature = v_uint32()


class RTL_DRIVE_LETTER_CURDIR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint16()
        self.Length = v_uint16()
        self.TimeStamp = v_uint32()
        self.DosPath = STRING()


class CACHE_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Level = v_uint8()
        self.Associativity = v_uint8()
        self.LineSize = v_uint16()
        self.Size = v_uint32()
        self.Type = v_uint32()


class ULARGE_INTEGER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class TEB_ACTIVE_FRAME(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.Previous = v_ptr32()
        self.Context = v_ptr32()


class GENERAL_LOOKASIDE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListHead = SLIST_HEADER()
        self.Depth = v_uint16()
        self.MaximumDepth = v_uint16()
        self.TotalAllocates = v_uint32()
        self.AllocateMisses = v_uint32()
        self.TotalFrees = v_uint32()
        self.FreeMisses = v_uint32()
        self.Type = v_uint32()
        self.Tag = v_uint32()
        self.Size = v_uint32()
        self.AllocateEx = v_ptr32()
        self.FreeEx = v_ptr32()
        self.ListEntry = LIST_ENTRY()
        self.LastTotalAllocates = v_uint32()
        self.LastAllocateMisses = v_uint32()
        self.Future = v_bytes(size=8) # FIXME Unknown Array Type


class _unnamed_7775(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AsynchronousParameters = _unnamed_7790()


class KWAIT_STATUS_REGISTER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint8()


class KGDTENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LimitLow = v_uint16()
        self.BaseLow = v_uint16()
        self.HighWord = _unnamed_6579()


class NAMED_PIPE_CREATE_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NamedPipeType = v_uint32()
        self.ReadMode = v_uint32()
        self.CompletionMode = v_uint32()
        self.MaximumInstances = v_uint32()
        self.InboundQuota = v_uint32()
        self.OutboundQuota = v_uint32()
        self.DefaultTimeout = LARGE_INTEGER()
        self.TimeoutSpecified = v_uint8()


class NT_TIB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionList = v_ptr32()
        self.StackBase = v_ptr32()
        self.StackLimit = v_ptr32()
        self.SubSystemTib = v_ptr32()
        self.FiberData = v_ptr32()
        self.ArbitraryUserPointer = v_ptr32()
        self.Self = v_ptr32()


class _unnamed_10315(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinimumChannel = v_uint32()
        self.MaximumChannel = v_uint32()


class RTL_STD_LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()


class POWER_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemState = v_uint32()


class UNICODE_STRING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.MaximumLength = v_uint16()
        self.Buffer = v_ptr32()


class HEAP_LIST_LOOKUP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExtendedLookup = v_ptr32()
        self.ArraySize = v_uint32()
        self.ExtraItem = v_uint32()
        self.ItemCount = v_uint32()
        self.OutOfRangeItems = v_uint32()
        self.BaseIndex = v_uint32()
        self.ListHead = v_ptr32()
        self.ListsInUseUlong = v_ptr32()
        self.ListHints = v_ptr32()


class _unnamed_5755(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class EPROCESS_QUOTA_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class _unnamed_10318(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.MinBusNumber = v_uint32()
        self.MaxBusNumber = v_uint32()
        self.Reserved = v_uint32()


class HEAP_DEBUGGING_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterceptorFunction = v_ptr32()
        self.InterceptorValue = v_uint16()
        self._pad0008 = v_bytes(size=2)
        self.ExtendedOptions = v_uint32()
        self.StackTraceDepth = v_uint32()
        self.MinTotalBlockSize = v_uint32()
        self.MaxTotalBlockSize = v_uint32()
        self.HeapLeakEnumerationRoutine = v_ptr32()


class ACCESS_REASONS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data = v_bytes(size=128) # FIXME Unknown Array Type


class STACK_TRACE_DATABASE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Reserved = v_bytes(size=56) # FIXME Unknown Array Type
        self.Reserved2 = v_ptr32()
        self.PeakHashCollisionListLength = v_uint32()
        self.LowerMemoryStart = v_ptr32()
        self.PreCommitted = v_uint8()
        self.DumpInProgress = v_uint8()
        self._pad0048 = v_bytes(size=2)
        self.CommitBase = v_ptr32()
        self.CurrentLowerCommitLimit = v_ptr32()
        self.CurrentUpperCommitLimit = v_ptr32()
        self.NextFreeLowerMemory = v_ptr32()
        self.NextFreeUpperMemory = v_ptr32()
        self.NumberOfEntriesLookedUp = v_uint32()
        self.NumberOfEntriesAdded = v_uint32()
        self.EntryIndexArray = v_ptr32()
        self.NumberOfEntriesAllocated = v_uint32()
        self.NumberOfEntriesAvailable = v_uint32()
        self.NumberOfAllocationFailures = v_uint32()
        self._pad0078 = v_bytes(size=4)
        self.FreeLists = v_uint32()
        self.NumberOfBuckets = v_uint32()
        self.Buckets = v_uint32()


class _unnamed_9139(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BaseMid = v_uint32()


class KDPC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint8()
        self.Importance = v_uint8()
        self.Number = v_uint16()
        self.DpcListEntry = LIST_ENTRY()
        self.DeferredRoutine = v_ptr32()
        self.DeferredContext = v_ptr32()
        self.SystemArgument1 = v_ptr32()
        self.SystemArgument2 = v_ptr32()
        self.DpcData = v_ptr32()


class KEVENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class KSEMAPHORE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()
        self.Limit = v_uint32()


class MM_PAGE_ACCESS_INFO_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Link = SINGLE_LIST_ENTRY()
        self.Type = v_uint32()
        self.EmptySequenceNumber = v_uint32()
        self._pad0010 = v_bytes(size=4)
        self.CreateTime = v_uint64()
        self.EmptyTime = v_uint64()
        self.PageEntry = v_ptr32()
        self.FileEntry = v_ptr32()
        self.FirstFileEntry = v_ptr32()
        self.Process = v_ptr32()
        self.SessionId = v_uint32()


class OBJECT_TYPE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TypeList = LIST_ENTRY()
        self.Name = UNICODE_STRING()
        self.DefaultObject = v_ptr32()
        self.Index = v_uint8()
        self._pad0018 = v_bytes(size=3)
        self.TotalNumberOfObjects = v_uint32()
        self.TotalNumberOfHandles = v_uint32()
        self.HighWaterNumberOfObjects = v_uint32()
        self.HighWaterNumberOfHandles = v_uint32()
        self.TypeInfo = OBJECT_TYPE_INITIALIZER()
        self.TypeLock = EX_PUSH_LOCK()
        self.Key = v_uint32()
        self.CallbackList = LIST_ENTRY()


class HANDLE_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TableCode = v_uint32()
        self.QuotaProcess = v_ptr32()
        self.UniqueProcessId = v_ptr32()
        self.HandleLock = EX_PUSH_LOCK()
        self.HandleTableList = LIST_ENTRY()
        self.HandleContentionEvent = EX_PUSH_LOCK()
        self.DebugInfo = v_ptr32()
        self.ExtraInfoPages = v_uint32()
        self.Flags = v_uint32()
        self.FirstFreeHandle = v_uint32()
        self.LastFreeHandleEntry = v_ptr32()
        self.HandleCount = v_uint32()
        self.NextHandleNeedingPool = v_uint32()
        self.HandleCountHighWatermark = v_uint32()


class MMSUPPORT_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkingSetType = v_uint8()
        self.SessionMaster = v_uint8()
        self.MemoryPriority = v_uint8()
        self.WsleDeleted = v_uint8()


class HEAP_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = _unnamed_8680()


class EXCEPTION_REGISTRATION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Handler = v_ptr32()


class FILE_BASIC_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CreationTime = LARGE_INTEGER()
        self.LastAccessTime = LARGE_INTEGER()
        self.LastWriteTime = LARGE_INTEGER()
        self.ChangeTime = LARGE_INTEGER()
        self.FileAttributes = v_uint32()


class LIST_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_ptr32()
        self.Blink = v_ptr32()


class M128A(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Low = v_uint64()
        self.High = v_uint64()


class _unnamed_5801(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LongFunction = v_uint32()


class RTL_DYNAMIC_HASH_TABLE_ENUMERATOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.HashEntry = RTL_DYNAMIC_HASH_TABLE_ENTRY()
        self.ChainHead = v_ptr32()
        self.BucketIndex = v_uint32()


class _unnamed_8069(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()


class GUID(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Data1 = v_uint32()
        self.Data2 = v_uint16()
        self.Data3 = v_uint16()
        self.Data4 = v_bytes(size=8) # FIXME Unknown Array Type


class HEAP_UCR_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.SegmentEntry = LIST_ENTRY()
        self.Address = v_ptr32()
        self.Size = v_uint32()


class MCA_EXCEPTION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VersionNumber = v_uint32()
        self.ExceptionType = v_uint32()
        self.TimeStamp = LARGE_INTEGER()
        self.ProcessorNumber = v_uint32()
        self.Reserved1 = v_uint32()
        self.u = _unnamed_9067()
        self.ExtCnt = v_uint32()
        self.Reserved3 = v_uint32()
        self.ExtReg = v_bytes(size=192) # FIXME Unknown Array Type


class PSP_CPU_QUOTA_APC(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class KAPC_STATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ApcListHead = v_bytes(size=192) # FIXME Unknown Array Type
        self.Process = v_ptr32()
        self.KernelApcInProgress = v_uint8()
        self.KernelApcPending = v_uint8()
        self.UserApcPending = v_uint8()


class COUNTER_READING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint32()
        self.Index = v_uint32()
        self.Start = v_uint64()
        self.Total = v_uint64()


class KDPC_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DpcListHead = LIST_ENTRY()
        self.DpcLock = v_uint32()
        self.DpcQueueDepth = v_uint32()
        self.DpcCount = v_uint32()


class KIDTENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Offset = v_uint16()
        self.Selector = v_uint16()
        self.Access = v_uint16()
        self.ExtendedOffset = v_uint16()


class XSAVE_AREA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LegacyState = XSAVE_FORMAT()
        self.Header = XSAVE_AREA_HEADER()


class GENERIC_MAPPING(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GenericRead = v_uint32()
        self.GenericWrite = v_uint32()
        self.GenericExecute = v_uint32()
        self.GenericAll = v_uint32()


class IRP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.MdlAddress = v_ptr32()
        self.Flags = v_uint32()
        self.AssociatedIrp = _unnamed_7772()
        self.ThreadListEntry = LIST_ENTRY()
        self.IoStatus = IO_STATUS_BLOCK()
        self.RequestorMode = v_uint8()
        self.PendingReturned = v_uint8()
        self.StackCount = v_uint8()
        self.CurrentLocation = v_uint8()
        self.Cancel = v_uint8()
        self.CancelIrql = v_uint8()
        self.ApcEnvironment = v_uint8()
        self.AllocationFlags = v_uint8()
        self.UserIosb = v_ptr32()
        self.UserEvent = v_ptr32()
        self.Overlay = _unnamed_7775()
        self.CancelRoutine = v_ptr32()
        self.UserBuffer = v_ptr32()
        self.Tail = _unnamed_7778()


class KTHREAD_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitReasonBitMap = v_uint64()
        self.UserData = v_ptr32()
        self.Flags = v_uint32()
        self.ContextSwitches = v_uint32()
        self._pad0018 = v_bytes(size=4)
        self.CycleTimeBias = v_uint64()
        self.HardwareCounters = v_uint64()
        self.HwCounter = v_uint64()


class _unnamed_9767(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Start = LARGE_INTEGER()
        self.Length = v_uint32()


class DRIVER_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Flags = v_uint32()
        self.DriverStart = v_ptr32()
        self.DriverSize = v_uint32()
        self.DriverSection = v_ptr32()
        self.DriverExtension = v_ptr32()
        self.DriverName = UNICODE_STRING()
        self.HardwareDatabase = v_ptr32()
        self.FastIoDispatch = v_ptr32()
        self.DriverInit = v_ptr32()
        self.DriverStartIo = v_ptr32()
        self.DriverUnload = v_ptr32()
        self.MajorFunction = v_bytes(size=112) # FIXME Unknown Array Type


class FILE_GET_QUOTA_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NextEntryOffset = v_uint32()
        self.SidLength = v_uint32()
        self.Sid = SID()


class KGATE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Header = DISPATCHER_HEADER()


class IO_COMPLETION_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = v_ptr32()
        self.Key = v_ptr32()


class DRIVER_EXTENSION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.DriverObject = v_ptr32()
        self.AddDevice = v_ptr32()
        self.Count = v_uint32()
        self.ServiceKeyName = UNICODE_STRING()
        self.ClientDriverExtension = v_ptr32()
        self.FsFilterCallbacks = v_ptr32()


class TP_NBQ_GUARD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.GuardLinks = LIST_ENTRY()
        self.Guards = v_bytes(size=8) # FIXME Unknown Array Type


class flags(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Removable = v_uint8()


class MM_AVL_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.BalancedRoot = MMADDRESS_NODE()
        self.DepthOfTree = v_uint32()
        self.NodeHint = v_ptr32()
        self.NodeFreeHint = v_ptr32()


class WHEA_PERSISTENCE_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint64()


class _unnamed_9547(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Generic = _unnamed_9767()


class WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FRUId = v_uint8()


class EXCEPTION_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExceptionCode = v_uint32()
        self.ExceptionFlags = v_uint32()
        self.ExceptionRecord = v_ptr32()
        self.ExceptionAddress = v_ptr32()
        self.NumberParameters = v_uint32()
        self.ExceptionInformation = v_bytes(size=60) # FIXME Unknown Array Type


class PROCESSOR_NUMBER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Group = v_uint16()
        self.Number = v_uint8()
        self.Reserved = v_uint8()


class MM_PAGE_ACCESS_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = MM_PAGE_ACCESS_INFO_FLAGS()
        self.PointerProtoPte = v_ptr32()


class _unnamed_7772(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MasterIrp = v_ptr32()


class KPCR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.SelfPcr = v_ptr32()
        self.Prcb = v_ptr32()
        self.Irql = v_uint8()
        self._pad0028 = v_bytes(size=3)
        self.IRR = v_uint32()
        self.IrrActive = v_uint32()
        self.IDR = v_uint32()
        self.KdVersionBlock = v_ptr32()
        self.IDT = v_ptr32()
        self.GDT = v_ptr32()
        self.TSS = v_ptr32()
        self.MajorVersion = v_uint16()
        self.MinorVersion = v_uint16()
        self.SetMember = v_uint32()
        self.StallScaleFactor = v_uint32()
        self.SpareUnused = v_uint8()
        self.Number = v_uint8()
        self.Spare0 = v_uint8()
        self.SecondLevelCacheAssociativity = v_uint8()
        self.VdmAlert = v_uint32()
        self.KernelReserved = v_bytes(size=56) # FIXME Unknown Array Type
        self.SecondLevelCacheSize = v_uint32()
        self.HalReserved = v_bytes(size=64) # FIXME Unknown Array Type
        self.InterruptMode = v_uint32()
        self.Spare1 = v_uint8()
        self._pad00dc = v_bytes(size=3)
        self.KernelReserved2 = v_bytes(size=68) # FIXME Unknown Array Type
        self.PrcbData = KPRCB()


class IMAGE_FILE_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Machine = v_uint16()
        self.NumberOfSections = v_uint16()
        self.TimeDateStamp = v_uint32()
        self.PointerToSymbolTable = v_uint32()
        self.NumberOfSymbols = v_uint32()
        self.SizeOfOptionalHeader = v_uint16()
        self.Characteristics = v_uint16()


class LFH_BLOCK_ZONE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()
        self.FreePointer = v_ptr32()
        self.Limit = v_ptr32()


class _unnamed_7778(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Overlay = _unnamed_7851()


class FILE_STANDARD_INFORMATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocationSize = LARGE_INTEGER()
        self.EndOfFile = LARGE_INTEGER()
        self.NumberOfLinks = v_uint32()
        self.DeletePending = v_uint8()
        self.Directory = v_uint8()


class LFH_HEAP(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = RTL_CRITICAL_SECTION()
        self.SubSegmentZones = LIST_ENTRY()
        self.ZoneBlockSize = v_uint32()
        self.Heap = v_ptr32()
        self.SegmentChange = v_uint32()
        self.SegmentCreate = v_uint32()
        self.SegmentInsertInFree = v_uint32()
        self.SegmentDelete = v_uint32()
        self.CacheAllocs = v_uint32()
        self.CacheFrees = v_uint32()
        self.SizeInCache = v_uint32()
        self._pad0048 = v_bytes(size=4)
        self.RunInfo = HEAP_BUCKET_RUN_INFO()
        self.UserBlockCache = HEAP_BUCKET_RUN_INFO()
        self.Buckets = HEAP_BUCKET_RUN_INFO()
        self.LocalData = HEAP_BUCKET_RUN_INFO()


class _unnamed_7982(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileInformationClass = v_uint32()
        self.FileObject = v_ptr32()
        self.ReplaceIfExists = v_uint8()
        self.AdvanceOnly = v_uint8()


class HEAP_BUCKET_RUN_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Bucket = v_uint32()
        self.RunLength = v_uint32()


class PEB_LDR_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.Initialized = v_uint8()
        self._pad0008 = v_bytes(size=3)
        self.SsHandle = v_ptr32()
        self.InLoadOrderModuleList = LIST_ENTRY()
        self.InMemoryOrderModuleList = LIST_ENTRY()
        self.InInitializationOrderModuleList = LIST_ENTRY()
        self.EntryInProgress = v_ptr32()
        self.ShutdownInProgress = v_uint8()
        self._pad002c = v_bytes(size=3)
        self.ShutdownThreadId = v_ptr32()


class _unnamed_5768(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LowPart = v_uint32()
        self.HighPart = v_uint32()


class HEAP_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Flags = v_uint8()
        self.SmallTagIndex = v_uint8()
        self.PreviousSize = v_uint16()
        self.SegmentOffset = v_uint8()
        self.UnusedBytes = v_uint8()


class MM_PAGE_ACCESS_INFO_FLAGS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.File = _unnamed_8980()


class SECURITY_SUBJECT_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ClientToken = v_ptr32()
        self.ImpersonationLevel = v_uint32()
        self.PrimaryToken = v_ptr32()
        self.ProcessAuditId = v_ptr32()


class _unnamed_7979(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileInformationClass = v_uint32()


class _unnamed_10323(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Priority = v_uint32()
        self.Reserved1 = v_uint32()
        self.Reserved2 = v_uint32()


class _unnamed_10327(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length40 = v_uint32()
        self.Alignment40 = v_uint32()
        self.MinimumAddress = LARGE_INTEGER()
        self.MaximumAddress = LARGE_INTEGER()


class _unnamed_7976(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.CompletionFilter = v_uint32()


class _unnamed_7970(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint32()
        self.FileName = v_ptr32()
        self.FileInformationClass = v_uint32()
        self.FileIndex = v_uint32()


class _unnamed_7874(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityContext = v_ptr32()
        self.Options = v_uint32()
        self.FileAttributes = v_uint16()
        self.ShareAccess = v_uint16()
        self.EaLength = v_uint32()


class INTERFACE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Context = v_ptr32()
        self.InterfaceReference = v_ptr32()
        self.InterfaceDereference = v_ptr32()


class SLIST_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Alignment = v_uint64()


class _unnamed_5798(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()


class IMAGE_DATA_DIRECTORY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.VirtualAddress = v_uint32()
        self.Size = v_uint32()


class FILE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.DeviceObject = v_ptr32()
        self.Vpb = v_ptr32()
        self.FsContext = v_ptr32()
        self.FsContext2 = v_ptr32()
        self.SectionObjectPointer = v_ptr32()
        self.PrivateCacheMap = v_ptr32()
        self.FinalStatus = v_uint32()
        self.RelatedFileObject = v_ptr32()
        self.LockOperation = v_uint8()
        self.DeletePending = v_uint8()
        self.ReadAccess = v_uint8()
        self.WriteAccess = v_uint8()
        self.DeleteAccess = v_uint8()
        self.SharedRead = v_uint8()
        self.SharedWrite = v_uint8()
        self.SharedDelete = v_uint8()
        self.Flags = v_uint32()
        self.FileName = UNICODE_STRING()
        self.CurrentByteOffset = LARGE_INTEGER()
        self.Waiters = v_uint32()
        self.Busy = v_uint32()
        self.LastLock = v_ptr32()
        self.Lock = KEVENT()
        self.Event = KEVENT()
        self.CompletionContext = v_ptr32()
        self.IrpListLock = v_uint32()
        self.IrpList = LIST_ENTRY()
        self.FileObjectExtension = v_ptr32()


class PPM_IDLE_STATES(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()
        self.Flags = _unnamed_9370()
        self.TargetState = v_uint32()
        self.ActualState = v_uint32()
        self.OldState = v_uint32()
        self.NewlyUnparked = v_uint8()
        self._pad0018 = v_bytes(size=3)
        self.TargetProcessors = KAFFINITY_EX()
        self.State = KAFFINITY_EX()


class _unnamed_8142(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Lock = v_uint8()


class HEAP_SUBSEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.LocalInfo = v_ptr32()
        self.UserBlocks = v_ptr32()
        self.AggregateExchg = INTERLOCK_SEQ()
        self.BlockSize = v_uint16()
        self.Flags = v_uint16()
        self.BlockCount = v_uint16()
        self.SizeIndex = v_uint8()
        self.AffinityIndex = v_uint8()
        self.SFreeListEntry = SINGLE_LIST_ENTRY()
        self.Lock = v_uint32()


class ERESOURCE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SystemResourcesList = LIST_ENTRY()
        self.OwnerTable = v_ptr32()
        self.ActiveCount = v_uint16()
        self.Flag = v_uint16()
        self.SharedWaiters = v_ptr32()
        self.ExclusiveWaiters = v_ptr32()
        self.OwnerEntry = OWNER_ENTRY()
        self.ActiveEntries = v_uint32()
        self.ContentionCount = v_uint32()
        self.NumberOfSharedWaiters = v_uint32()
        self.NumberOfExclusiveWaiters = v_uint32()
        self.Address = v_ptr32()
        self.SpinLock = v_uint32()


class _unnamed_8220(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AllocatedResources = v_ptr32()
        self.AllocatedResourcesTranslated = v_ptr32()


class _unnamed_8224(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ProviderId = v_uint32()
        self.DataPath = v_ptr32()
        self.BufferSize = v_uint32()
        self.Buffer = v_ptr32()


class _unnamed_8229(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr32()
        self.Argument2 = v_ptr32()
        self.Argument3 = v_ptr32()
        self.Argument4 = v_ptr32()


class PEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InheritedAddressSpace = v_uint8()
        self.ReadImageFileExecOptions = v_uint8()
        self.BeingDebugged = v_uint8()
        self.BitField = v_uint8()
        self.Mutant = v_ptr32()
        self.ImageBaseAddress = v_ptr32()
        self.Ldr = v_ptr32()
        self.ProcessParameters = v_ptr32()
        self.SubSystemData = v_ptr32()
        self.ProcessHeap = v_ptr32()
        self.FastPebLock = v_ptr32()
        self.AtlThunkSListPtr = v_ptr32()
        self.IFEOKey = v_ptr32()
        self.CrossProcessFlags = v_uint32()
        self.KernelCallbackTable = v_ptr32()
        self.SystemReserved = v_bytes(size=4) # FIXME Unknown Array Type
        self.AtlThunkSListPtr32 = v_uint32()
        self.ApiSetMap = v_ptr32()
        self.TlsExpansionCounter = v_uint32()
        self.TlsBitmap = v_ptr32()
        self.TlsBitmapBits = v_bytes(size=8) # FIXME Unknown Array Type
        self.ReadOnlySharedMemoryBase = v_ptr32()
        self.HotpatchInformation = v_ptr32()
        self.ReadOnlyStaticServerData = v_ptr32()
        self.AnsiCodePageData = v_ptr32()
        self.OemCodePageData = v_ptr32()
        self.UnicodeCaseTableData = v_ptr32()
        self.NumberOfProcessors = v_uint32()
        self.NtGlobalFlag = v_uint32()
        self._pad0070 = v_bytes(size=4)
        self.CriticalSectionTimeout = LARGE_INTEGER()
        self.HeapSegmentReserve = v_uint32()
        self.HeapSegmentCommit = v_uint32()
        self.HeapDeCommitTotalFreeThreshold = v_uint32()
        self.HeapDeCommitFreeBlockThreshold = v_uint32()
        self.NumberOfHeaps = v_uint32()
        self.MaximumNumberOfHeaps = v_uint32()
        self.ProcessHeaps = v_ptr32()
        self.GdiSharedHandleTable = v_ptr32()
        self.ProcessStarterHelper = v_ptr32()
        self.GdiDCAttributeList = v_uint32()
        self.LoaderLock = v_ptr32()
        self.OSMajorVersion = v_uint32()
        self.OSMinorVersion = v_uint32()
        self.OSBuildNumber = v_uint16()
        self.OSCSDVersion = v_uint16()
        self.OSPlatformId = v_uint32()
        self.ImageSubsystem = v_uint32()
        self.ImageSubsystemMajorVersion = v_uint32()
        self.ImageSubsystemMinorVersion = v_uint32()
        self.ActiveProcessAffinityMask = v_uint32()
        self.GdiHandleBuffer = v_bytes(size=136) # FIXME Unknown Array Type
        self.PostProcessInitRoutine = v_ptr32()
        self.TlsExpansionBitmap = v_ptr32()
        self.TlsExpansionBitmapBits = v_bytes(size=128) # FIXME Unknown Array Type
        self.SessionId = v_uint32()
        self.AppCompatFlags = ULARGE_INTEGER()
        self.AppCompatFlagsUser = ULARGE_INTEGER()
        self.pShimData = v_ptr32()
        self.AppCompatInfo = v_ptr32()
        self.CSDVersion = UNICODE_STRING()
        self.ActivationContextData = v_ptr32()
        self.ProcessAssemblyStorageMap = v_ptr32()
        self.SystemDefaultActivationContextData = v_ptr32()
        self.SystemAssemblyStorageMap = v_ptr32()
        self.MinimumStackCommit = v_uint32()
        self.FlsCallback = v_ptr32()
        self.FlsListHead = LIST_ENTRY()
        self.FlsBitmap = v_ptr32()
        self.FlsBitmapBits = v_bytes(size=16) # FIXME Unknown Array Type
        self.FlsHighIndex = v_uint32()
        self.WerRegistrationData = v_ptr32()
        self.WerShipAssertPtr = v_ptr32()
        self.pContextData = v_ptr32()
        self.pImageHeaderHash = v_ptr32()
        self.TracingFlags = v_uint32()


class TP_TASK_CALLBACKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ExecuteCallback = v_ptr32()
        self.Unposted = v_ptr32()


class RTL_BALANCED_LINKS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Parent = v_ptr32()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.Balance = v_uint8()
        self.Reserved = v_bytes(size=3) # FIXME Unknown Array Type


class _unnamed_9722(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Port = _unnamed_10298()


class EX_PUSH_LOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Locked = v_uint32()


class XSTATE_CONTEXT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint64()
        self.Length = v_uint32()
        self.Reserved1 = v_uint32()
        self.Area = v_ptr32()
        self.Reserved2 = v_uint32()
        self.Buffer = v_ptr32()
        self.Reserved3 = v_uint32()


class HEAP_FREE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Size = v_uint16()
        self.Flags = v_uint8()
        self.SmallTagIndex = v_uint8()
        self.PreviousSize = v_uint16()
        self.SegmentOffset = v_uint8()
        self.UnusedBytes = v_uint8()
        self.FreeList = LIST_ENTRY()


class KSTACK_COUNT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Value = v_uint32()


class _unnamed_8030(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.SecurityInformation = v_uint32()
        self.SecurityDescriptor = v_ptr32()


class MDL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Next = v_ptr32()
        self.Size = v_uint16()
        self.MdlFlags = v_uint16()
        self.Process = v_ptr32()
        self.MappedSystemVa = v_ptr32()
        self.StartVa = v_ptr32()
        self.ByteCount = v_uint32()
        self.ByteOffset = v_uint32()


class _unnamed_8134(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.IoResourceRequirementList = v_ptr32()


class _unnamed_8137(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WhichSpace = v_uint32()
        self.Buffer = v_ptr32()
        self.Offset = v_uint32()
        self.Length = v_uint32()


class HEAP_SEGMENT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Entry = HEAP_ENTRY()
        self.SegmentSignature = v_uint32()
        self.SegmentFlags = v_uint32()
        self.SegmentListEntry = LIST_ENTRY()
        self.Heap = v_ptr32()
        self.BaseAddress = v_ptr32()
        self.NumberOfPages = v_uint32()
        self.FirstEntry = v_ptr32()
        self.LastValidEntry = v_ptr32()
        self.NumberOfUnCommittedPages = v_uint32()
        self.NumberOfUnCommittedRanges = v_uint32()
        self.SegmentAllocatorBackTraceIndex = v_uint16()
        self.Reserved = v_uint16()
        self.UCRSegmentList = LIST_ENTRY()


class WHEA_ERROR_RECORD_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.Revision = WHEA_REVISION()
        self.SignatureEnd = v_uint32()
        self.SectionCount = v_uint16()
        self.Severity = v_uint32()
        self.ValidBits = WHEA_ERROR_RECORD_HEADER_VALIDBITS()
        self.Length = v_uint32()
        self.Timestamp = WHEA_TIMESTAMP()
        self.PlatformId = GUID()
        self.PartitionId = GUID()
        self.CreatorId = GUID()
        self.NotifyType = GUID()
        self.RecordId = v_uint64()
        self.Flags = WHEA_ERROR_RECORD_HEADER_FLAGS()
        self.PersistenceInfo = WHEA_PERSISTENCE_INFO()
        self.Reserved = v_bytes(size=12) # FIXME Unknown Array Type


class EVENT_DESCRIPTOR(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Id = v_uint16()
        self.Version = v_uint8()
        self.Channel = v_uint8()
        self.Level = v_uint8()
        self.Opcode = v_uint8()
        self.Task = v_uint16()
        self.Keyword = v_uint64()


class _unnamed_9855(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ResourceToRelease = v_ptr32()


class _unnamed_9854(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.EndingOffset = v_ptr32()
        self.ResourceToRelease = v_ptr32()


class _unnamed_9857(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NotificationType = v_uint32()
        self.SafeToRecurse = v_uint8()


class MMSUPPORT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WorkingSetMutex = EX_PUSH_LOCK()
        self.ExitGate = v_ptr32()
        self.AccessLog = v_ptr32()
        self.WorkingSetExpansionLinks = LIST_ENTRY()
        self.AgeDistribution = v_bytes(size=28) # FIXME Unknown Array Type
        self.MinimumWorkingSetSize = v_uint32()
        self.WorkingSetSize = v_uint32()
        self.WorkingSetPrivateSize = v_uint32()
        self.MaximumWorkingSetSize = v_uint32()
        self.ChargedWslePages = v_uint32()
        self.ActualWslePages = v_uint32()
        self.WorkingSetSizeOverhead = v_uint32()
        self.PeakWorkingSetSize = v_uint32()
        self.HardFaultCount = v_uint32()
        self.VmWorkingSetList = v_ptr32()
        self.NextPageColor = v_uint16()
        self.LastTrimStamp = v_uint16()
        self.PageFaultCount = v_uint32()
        self.RepurposeCount = v_uint32()
        self.Spare = v_bytes(size=4) # FIXME Unknown Array Type
        self.Flags = MMSUPPORT_FLAGS()


class _unnamed_9858(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Argument1 = v_ptr32()
        self.Argument2 = v_ptr32()
        self.Argument3 = v_ptr32()
        self.Argument4 = v_ptr32()
        self.Argument5 = v_ptr32()


class FLS_CALLBACK_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)


class ACL(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.AclRevision = v_uint8()
        self.Sbz1 = v_uint8()
        self.AclSize = v_uint16()
        self.AceCount = v_uint16()
        self.Sbz2 = v_uint16()


class LIST_ENTRY64(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flink = v_uint64()
        self.Blink = v_uint64()


class WAIT_CONTEXT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WaitQueueEntry = KDEVICE_QUEUE_ENTRY()
        self.DeviceRoutine = v_ptr32()
        self.DeviceContext = v_ptr32()
        self.NumberOfMapRegisters = v_uint32()
        self.DeviceObject = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.BufferChainingDpc = v_ptr32()


class SE_AUDIT_PROCESS_CREATION_INFO(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ImageFileName = v_ptr32()


class ACTIVATION_CONTEXT_STACK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ActiveFrame = v_ptr32()
        self.FrameListCache = LIST_ENTRY()
        self.Flags = v_uint32()
        self.NextCookieSequenceNumber = v_uint32()
        self.StackId = v_uint32()


class LDR_DATA_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InLoadOrderLinks = LIST_ENTRY()
        self.InMemoryOrderLinks = LIST_ENTRY()
        self.InInitializationOrderLinks = LIST_ENTRY()
        self.DllBase = v_ptr32()
        self.EntryPoint = v_ptr32()
        self.SizeOfImage = v_uint32()
        self.FullDllName = UNICODE_STRING()
        self.BaseDllName = UNICODE_STRING()
        self.Flags = v_uint32()
        self.LoadCount = v_uint16()
        self.TlsIndex = v_uint16()
        self.HashLinks = LIST_ENTRY()
        self.TimeDateStamp = v_uint32()
        self.EntryPointActivationContext = v_ptr32()
        self.PatchInformation = v_ptr32()
        self.ForwarderLinks = LIST_ENTRY()
        self.ServiceTagLinks = LIST_ENTRY()
        self.StaticLinks = LIST_ENTRY()
        self.ContextInformation = v_ptr32()
        self.OriginalBase = v_uint32()
        self.LoadTime = LARGE_INTEGER()


class LOOKASIDE_LIST_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.L = GENERAL_LOOKASIDE_POOL()


class TEB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.NtTib = NT_TIB()
        self.EnvironmentPointer = v_ptr32()
        self.ClientId = CLIENT_ID()
        self.ActiveRpcHandle = v_ptr32()
        self.ThreadLocalStoragePointer = v_ptr32()
        self.ProcessEnvironmentBlock = v_ptr32()
        self.LastErrorValue = v_uint32()
        self.CountOfOwnedCriticalSections = v_uint32()
        self.CsrClientThread = v_ptr32()
        self.Win32ThreadInfo = v_ptr32()
        self.User32Reserved = v_bytes(size=104) # FIXME Unknown Array Type
        self.UserReserved = v_bytes(size=20) # FIXME Unknown Array Type
        self.WOW32Reserved = v_ptr32()
        self.CurrentLocale = v_uint32()
        self.FpSoftwareStatusRegister = v_uint32()
        self.SystemReserved1 = v_bytes(size=216) # FIXME Unknown Array Type
        self.ExceptionCode = v_uint32()
        self.ActivationContextStackPointer = v_ptr32()
        self.SpareBytes = v_bytes(size=36) # FIXME Unknown Array Type
        self.TxFsContext = v_uint32()
        self.GdiTebBatch = GDI_TEB_BATCH()
        self.RealClientId = CLIENT_ID()
        self.GdiCachedProcessHandle = v_ptr32()
        self.GdiClientPID = v_uint32()
        self.GdiClientTID = v_uint32()
        self.GdiThreadLocalInfo = v_ptr32()
        self.Win32ClientInfo = v_bytes(size=248) # FIXME Unknown Array Type
        self.glDispatchTable = v_bytes(size=932) # FIXME Unknown Array Type
        self.glReserved1 = v_bytes(size=116) # FIXME Unknown Array Type
        self.glReserved2 = v_ptr32()
        self.glSectionInfo = v_ptr32()
        self.glSection = v_ptr32()
        self.glTable = v_ptr32()
        self.glCurrentRC = v_ptr32()
        self.glContext = v_ptr32()
        self.LastStatusValue = v_uint32()
        self.StaticUnicodeString = UNICODE_STRING()
        self.StaticUnicodeBuffer = v_bytes(size=522) # FIXME Unknown Array Type
        self._pad0e0c = v_bytes(size=2)
        self.DeallocationStack = v_ptr32()
        self.TlsSlots = v_bytes(size=256) # FIXME Unknown Array Type
        self.TlsLinks = LIST_ENTRY()
        self.Vdm = v_ptr32()
        self.ReservedForNtRpc = v_ptr32()
        self.DbgSsReserved = v_bytes(size=8) # FIXME Unknown Array Type
        self.HardErrorMode = v_uint32()
        self.Instrumentation = v_bytes(size=36) # FIXME Unknown Array Type
        self.ActivityId = GUID()
        self.SubProcessTag = v_ptr32()
        self.EtwLocalData = v_ptr32()
        self.EtwTraceData = v_ptr32()
        self.WinSockData = v_ptr32()
        self.GdiBatchCount = v_uint32()
        self.CurrentIdealProcessor = PROCESSOR_NUMBER()
        self.GuaranteedStackBytes = v_uint32()
        self.ReservedForPerf = v_ptr32()
        self.ReservedForOle = v_ptr32()
        self.WaitingOnLoaderLock = v_uint32()
        self.SavedPriorityState = v_ptr32()
        self.SoftPatchPtr1 = v_uint32()
        self.ThreadPoolData = v_ptr32()
        self.TlsExpansionSlots = v_ptr32()
        self.MuiGeneration = v_uint32()
        self.IsImpersonating = v_uint32()
        self.NlsCache = v_ptr32()
        self.pShimData = v_ptr32()
        self.HeapVirtualAffinity = v_uint32()
        self.CurrentTransactionHandle = v_ptr32()
        self.ActiveFrame = v_ptr32()
        self.FlsData = v_ptr32()
        self.PreferredLanguages = v_ptr32()
        self.UserPrefLanguages = v_ptr32()
        self.MergedPrefLanguages = v_ptr32()
        self.MuiImpersonation = v_uint32()
        self.CrossTebFlags = v_uint16()
        self.SameTebFlags = v_uint16()
        self.TxnScopeEnterCallback = v_ptr32()
        self.TxnScopeExitCallback = v_ptr32()
        self.TxnScopeContext = v_ptr32()
        self.LockCount = v_uint32()
        self.SpareUlong0 = v_uint32()
        self.ResourceRetValue = v_ptr32()


class EX_RUNDOWN_REF(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint32()


class XSAVE_FORMAT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ControlWord = v_uint16()
        self.StatusWord = v_uint16()
        self.TagWord = v_uint8()
        self.Reserved1 = v_uint8()
        self.ErrorOpcode = v_uint16()
        self.ErrorOffset = v_uint32()
        self.ErrorSelector = v_uint16()
        self.Reserved2 = v_uint16()
        self.DataOffset = v_uint32()
        self.DataSelector = v_uint16()
        self.Reserved3 = v_uint16()
        self.MxCsr = v_uint32()
        self.MxCsr_Mask = v_uint32()
        self.FloatRegisters = v_uint32()
        self.XmmRegisters = v_uint32()
        self.Reserved4 = v_bytes(size=192) # FIXME Unknown Array Type
        self.StackControl = v_bytes(size=28) # FIXME Unknown Array Type
        self.Cr0NpxState = v_uint32()


class PO_DIAG_STACK_RECORD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.StackDepth = v_uint32()
        self.Stack = v_bytes(size=4) # FIXME Unknown Array Type


class IMAGE_DOS_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.e_magic = v_uint16()
        self.e_cblp = v_uint16()
        self.e_cp = v_uint16()
        self.e_crlc = v_uint16()
        self.e_cparhdr = v_uint16()
        self.e_minalloc = v_uint16()
        self.e_maxalloc = v_uint16()
        self.e_ss = v_uint16()
        self.e_sp = v_uint16()
        self.e_csum = v_uint16()
        self.e_ip = v_uint16()
        self.e_cs = v_uint16()
        self.e_lfarlc = v_uint16()
        self.e_ovno = v_uint16()
        self.e_res = v_bytes(size=8) # FIXME Unknown Array Type
        self.e_oemid = v_uint16()
        self.e_oeminfo = v_uint16()
        self.e_res2 = v_bytes(size=20) # FIXME Unknown Array Type
        self.e_lfanew = v_uint32()


class RTL_DYNAMIC_HASH_TABLE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Linkage = LIST_ENTRY()
        self.Signature = v_uint32()


class MMADDRESS_NODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.u1 = _unnamed_9563()
        self.LeftChild = v_ptr32()
        self.RightChild = v_ptr32()
        self.StartingVpn = v_uint32()
        self.EndingVpn = v_uint32()


class _unnamed_7372(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListEntry = LIST_ENTRY()


class TXN_PARAMETER_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Length = v_uint16()
        self.TxFsContext = v_uint16()
        self.TransactionObject = v_ptr32()


class _unnamed_8980(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FilePointerIndex = v_uint32()


class _unnamed_8981(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.FilePointerIndex = v_uint32()


class QUAD(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UseThisFieldToCopy = v_uint64()


class HEAP_TUNING_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CommittThresholdShift = v_uint32()
        self.MaxPreCommittThreshold = v_uint32()


class KPRCB(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MinorVersion = v_uint16()
        self.MajorVersion = v_uint16()
        self.CurrentThread = v_ptr32()
        self.NextThread = v_ptr32()
        self.IdleThread = v_ptr32()
        self.LegacyNumber = v_uint8()
        self.NestingLevel = v_uint8()
        self.BuildType = v_uint16()
        self.CpuType = v_uint8()
        self.CpuID = v_uint8()
        self.CpuStep = v_uint16()
        self.ProcessorState = KPROCESSOR_STATE()
        self.KernelReserved = v_bytes(size=64) # FIXME Unknown Array Type
        self.HalReserved = v_bytes(size=64) # FIXME Unknown Array Type
        self.CFlushSize = v_uint32()
        self.CoresPerPhysicalProcessor = v_uint8()
        self.LogicalProcessorsPerCore = v_uint8()
        self.PrcbPad0 = v_bytes(size=2) # FIXME Unknown Array Type
        self.MHz = v_uint32()
        self.CpuVendor = v_uint8()
        self.GroupIndex = v_uint8()
        self.Group = v_uint16()
        self.GroupSetMember = v_uint32()
        self.Number = v_uint32()
        self.PrcbPad1 = v_bytes(size=72) # FIXME Unknown Array Type
        self.LockQueue = v_bytes(size=72) # FIXME Unknown Array Type
        self.NpxThread = v_ptr32()
        self.InterruptCount = v_uint32()
        self.KernelTime = v_uint32()
        self.UserTime = v_uint32()
        self.DpcTime = v_uint32()
        self.DpcTimeCount = v_uint32()
        self.InterruptTime = v_uint32()
        self.AdjustDpcThreshold = v_uint32()
        self.PageColor = v_uint32()
        self.DebuggerSavedIRQL = v_uint8()
        self.NodeColor = v_uint8()
        self.PrcbPad20 = v_bytes(size=2) # FIXME Unknown Array Type
        self.NodeShiftedColor = v_uint32()
        self.ParentNode = v_ptr32()
        self.SecondaryColorMask = v_uint32()
        self.DpcTimeLimit = v_uint32()
        self.PrcbPad21 = v_bytes(size=8) # FIXME Unknown Array Type
        self.CcFastReadNoWait = v_uint32()
        self.CcFastReadWait = v_uint32()
        self.CcFastReadNotPossible = v_uint32()
        self.CcCopyReadNoWait = v_uint32()
        self.CcCopyReadWait = v_uint32()
        self.CcCopyReadNoWaitMiss = v_uint32()
        self.MmSpinLockOrdering = v_uint32()
        self.IoReadOperationCount = v_uint32()
        self.IoWriteOperationCount = v_uint32()
        self.IoOtherOperationCount = v_uint32()
        self.IoReadTransferCount = LARGE_INTEGER()
        self.IoWriteTransferCount = LARGE_INTEGER()
        self.IoOtherTransferCount = LARGE_INTEGER()
        self.CcFastMdlReadNoWait = v_uint32()
        self.CcFastMdlReadWait = v_uint32()
        self.CcFastMdlReadNotPossible = v_uint32()
        self.CcMapDataNoWait = v_uint32()
        self.CcMapDataWait = v_uint32()
        self.CcPinMappedDataCount = v_uint32()
        self.CcPinReadNoWait = v_uint32()
        self.CcPinReadWait = v_uint32()
        self.CcMdlReadNoWait = v_uint32()
        self.CcMdlReadWait = v_uint32()
        self.CcLazyWriteHotSpots = v_uint32()
        self.CcLazyWriteIos = v_uint32()
        self.CcLazyWritePages = v_uint32()
        self.CcDataFlushes = v_uint32()
        self.CcDataPages = v_uint32()
        self.CcLostDelayedWrites = v_uint32()
        self.CcFastReadResourceMiss = v_uint32()
        self.CcCopyReadWaitMiss = v_uint32()
        self.CcFastMdlReadResourceMiss = v_uint32()
        self.CcMapDataNoWaitMiss = v_uint32()
        self.CcMapDataWaitMiss = v_uint32()
        self.CcPinReadNoWaitMiss = v_uint32()
        self.CcPinReadWaitMiss = v_uint32()
        self.CcMdlReadNoWaitMiss = v_uint32()
        self.CcMdlReadWaitMiss = v_uint32()
        self.CcReadAheadIos = v_uint32()
        self.KeAlignmentFixupCount = v_uint32()
        self.KeExceptionDispatchCount = v_uint32()
        self.KeSystemCalls = v_uint32()
        self.AvailableTime = v_uint32()
        self.PrcbPad22 = v_bytes(size=8) # FIXME Unknown Array Type
        self.PPLookasideList = v_bytes(size=8) # FIXME Unknown Array Type
        self.PPNPagedLookasideList = v_bytes(size=8) # FIXME Unknown Array Type
        self.PPPagedLookasideList = v_bytes(size=8) # FIXME Unknown Array Type
        self.PacketBarrier = v_uint32()
        self.ReverseStall = v_uint32()
        self.IpiFrame = v_ptr32()
        self.PrcbPad3 = v_bytes(size=52) # FIXME Unknown Array Type
        self.CurrentPacket = v_bytes(size=12) # FIXME Unknown Array Type
        self.TargetSet = v_uint32()
        self.WorkerRoutine = v_ptr32()
        self.IpiFrozen = v_uint32()
        self.PrcbPad4 = v_bytes(size=40) # FIXME Unknown Array Type
        self.RequestSummary = v_uint32()
        self.SignalDone = v_ptr32()
        self.PrcbPad50 = v_bytes(size=56) # FIXME Unknown Array Type
        self.DpcData = v_bytes(size=56) # FIXME Unknown Array Type
        self.DpcStack = v_ptr32()
        self.MaximumDpcQueueDepth = v_uint32()
        self.DpcRequestRate = v_uint32()
        self.MinimumDpcRate = v_uint32()
        self.DpcLastCount = v_uint32()
        self.PrcbLock = v_uint32()
        self.DpcGate = KGATE()
        self.ThreadDpcEnable = v_uint8()
        self.QuantumEnd = v_uint8()
        self.DpcRoutineActive = v_uint8()
        self.IdleSchedule = v_uint8()
        self.DpcRequestSummary = v_uint32()
        self.TimerHand = v_uint32()
        self.LastTick = v_uint32()
        self.MasterOffset = v_uint32()
        self.PrcbPad41 = v_bytes(size=8) # FIXME Unknown Array Type
        self.PeriodicCount = v_uint32()
        self.PeriodicBias = v_uint32()
        self._pad1958 = v_bytes(size=4)
        self.TickOffset = v_uint64()
        self.TimerTable = KTIMER_TABLE()
        self.CallDpc = KDPC()
        self.ClockKeepAlive = v_uint32()
        self.ClockCheckSlot = v_uint8()
        self.ClockPollCycle = v_uint8()
        self.PrcbPad6 = v_bytes(size=2) # FIXME Unknown Array Type
        self.DpcWatchdogPeriod = v_uint32()
        self.DpcWatchdogCount = v_uint32()
        self.ThreadWatchdogPeriod = v_uint32()
        self.ThreadWatchdogCount = v_uint32()
        self.KeSpinLockOrdering = v_uint32()
        self.PrcbPad70 = v_bytes(size=4) # FIXME Unknown Array Type
        self.WaitListHead = LIST_ENTRY()
        self.WaitLock = v_uint32()
        self.ReadySummary = v_uint32()
        self.QueueIndex = v_uint32()
        self.DeferredReadyListHead = SINGLE_LIST_ENTRY()
        self.StartCycles = v_uint64()
        self.CycleTime = v_uint64()
        self.HighCycleTime = v_uint32()
        self.PrcbPad71 = v_uint32()
        self.PrcbPad72 = v_bytes(size=16) # FIXME Unknown Array Type
        self.DispatcherReadyListHead = v_bytes(size=16) # FIXME Unknown Array Type
        self.ChainedInterruptList = v_ptr32()
        self.LookasideIrpFloat = v_uint32()
        self.MmPageFaultCount = v_uint32()
        self.MmCopyOnWriteCount = v_uint32()
        self.MmTransitionCount = v_uint32()
        self.MmCacheTransitionCount = v_uint32()
        self.MmDemandZeroCount = v_uint32()
        self.MmPageReadCount = v_uint32()
        self.MmPageReadIoCount = v_uint32()
        self.MmCacheReadCount = v_uint32()
        self.MmCacheIoCount = v_uint32()
        self.MmDirtyPagesWriteCount = v_uint32()
        self.MmDirtyWriteIoCount = v_uint32()
        self.MmMappedPagesWriteCount = v_uint32()
        self.MmMappedWriteIoCount = v_uint32()
        self.CachedCommit = v_uint32()
        self.CachedResidentAvailable = v_uint32()
        self.HyperPte = v_ptr32()
        self.PrcbPad8 = v_bytes(size=4) # FIXME Unknown Array Type
        self.VendorString = v_bytes(size=13) # FIXME Unknown Array Type
        self.InitialApicId = v_uint8()
        self.LogicalProcessorsPerPhysicalProcessor = v_uint8()
        self.PrcbPad9 = v_bytes(size=5) # FIXME Unknown Array Type
        self.FeatureBits = v_uint32()
        self._pad3388 = v_bytes(size=4)
        self.UpdateSignature = LARGE_INTEGER()
        self.IsrTime = v_uint64()
        self.RuntimeAccumulation = v_uint64()
        self.PowerState = PROCESSOR_POWER_STATE()
        self.DpcWatchdogDpc = KDPC()
        self.DpcWatchdogTimer = KTIMER()
        self.WheaInfo = v_ptr32()
        self.EtwSupport = v_ptr32()
        self.InterruptObjectPool = SLIST_HEADER()
        self.HypercallPageList = SLIST_HEADER()
        self.HypercallPageVirtual = v_ptr32()
        self.VirtualApicAssist = v_ptr32()
        self.StatisticsPage = v_ptr32()
        self.RateControl = v_ptr32()
        self.Cache = v_ptr32()
        self.CacheCount = v_uint32()
        self.CacheProcessorMask = v_bytes(size=20) # FIXME Unknown Array Type
        self.PackageProcessorSet = KAFFINITY_EX()
        self.PrcbPad91 = v_bytes(size=56) # FIXME Unknown Array Type
        self.CoreProcessorSet = v_uint32()
        self.TimerExpirationDpc = KDPC()
        self.SpinLockAcquireCount = v_uint32()
        self.SpinLockContentionCount = v_uint32()
        self.SpinLockSpinCount = v_uint32()
        self.IpiSendRequestBroadcastCount = v_uint32()
        self.IpiSendRequestRoutineCount = v_uint32()
        self.IpiSendSoftwareInterruptCount = v_uint32()
        self.ExInitializeResourceCount = v_uint32()
        self.ExReInitializeResourceCount = v_uint32()
        self.ExDeleteResourceCount = v_uint32()
        self.ExecutiveResourceAcquiresCount = v_uint32()
        self.ExecutiveResourceContentionsCount = v_uint32()
        self.ExecutiveResourceReleaseExclusiveCount = v_uint32()
        self.ExecutiveResourceReleaseSharedCount = v_uint32()
        self.ExecutiveResourceConvertsCount = v_uint32()
        self.ExAcqResExclusiveAttempts = v_uint32()
        self.ExAcqResExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResExclusiveAcquiresExclusiveRecursive = v_uint32()
        self.ExAcqResExclusiveWaits = v_uint32()
        self.ExAcqResExclusiveNotAcquires = v_uint32()
        self.ExAcqResSharedAttempts = v_uint32()
        self.ExAcqResSharedAcquiresExclusive = v_uint32()
        self.ExAcqResSharedAcquiresShared = v_uint32()
        self.ExAcqResSharedAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedWaits = v_uint32()
        self.ExAcqResSharedNotAcquires = v_uint32()
        self.ExAcqResSharedStarveExclusiveAttempts = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresShared = v_uint32()
        self.ExAcqResSharedStarveExclusiveAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedStarveExclusiveWaits = v_uint32()
        self.ExAcqResSharedStarveExclusiveNotAcquires = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAttempts = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresExclusive = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresShared = v_uint32()
        self.ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive = v_uint32()
        self.ExAcqResSharedWaitForExclusiveWaits = v_uint32()
        self.ExAcqResSharedWaitForExclusiveNotAcquires = v_uint32()
        self.ExSetResOwnerPointerExclusive = v_uint32()
        self.ExSetResOwnerPointerSharedNew = v_uint32()
        self.ExSetResOwnerPointerSharedOld = v_uint32()
        self.ExTryToAcqExclusiveAttempts = v_uint32()
        self.ExTryToAcqExclusiveAcquires = v_uint32()
        self.ExBoostExclusiveOwner = v_uint32()
        self.ExBoostSharedOwners = v_uint32()
        self.ExEtwSynchTrackingNotificationsCount = v_uint32()
        self.ExEtwSynchTrackingNotificationsAccountedCount = v_uint32()
        self.Context = v_ptr32()
        self.ContextFlags = v_uint32()
        self.ExtendedState = v_ptr32()


class RTL_DYNAMIC_HASH_TABLE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Flags = v_uint32()
        self.Shift = v_uint32()
        self.TableSize = v_uint32()
        self.Pivot = v_uint32()
        self.DivisorMask = v_uint32()
        self.NumEntries = v_uint32()
        self.NonEmptyBuckets = v_uint32()
        self.NumEnumerators = v_uint32()
        self.Directory = v_ptr32()


class KAFFINITY_EX(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Count = v_uint16()
        self.Size = v_uint16()
        self.Reserved = v_uint32()
        self.Bitmap = v_bytes(size=16) # FIXME Unknown Array Type


class DEVICE_OBJECT(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Type = v_uint16()
        self.Size = v_uint16()
        self.ReferenceCount = v_uint32()
        self.DriverObject = v_ptr32()
        self.NextDevice = v_ptr32()
        self.AttachedDevice = v_ptr32()
        self.CurrentIrp = v_ptr32()
        self.Timer = v_ptr32()
        self.Flags = v_uint32()
        self.Characteristics = v_uint32()
        self.Vpb = v_ptr32()
        self.DeviceExtension = v_ptr32()
        self.DeviceType = v_uint32()
        self.StackSize = v_uint8()
        self._pad0034 = v_bytes(size=3)
        self.Queue = _unnamed_7372()
        self.AlignmentRequirement = v_uint32()
        self.DeviceQueue = KDEVICE_QUEUE()
        self.Dpc = KDPC()
        self.ActiveThreadCount = v_uint32()
        self.SecurityDescriptor = v_ptr32()
        self.DeviceLock = KEVENT()
        self.SectorSize = v_uint16()
        self.Spare1 = v_uint16()
        self.DeviceObjectExtension = v_ptr32()
        self.Reserved = v_ptr32()


class USER_MEMORY_CACHE_ENTRY(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.UserBlocks = SLIST_HEADER()
        self.AvailableBlocks = v_uint32()


class EX_PUSH_LOCK_WAIT_BLOCK(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.WakeEvent = KEVENT()
        self.Next = v_ptr32()
        self.Last = v_ptr32()
        self.Previous = v_ptr32()
        self.ShareCount = v_uint32()
        self.Flags = v_uint32()


class _unnamed_8182(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerSequence = v_ptr32()


class _unnamed_9780(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Raw = _unnamed_9775()


class IMAGE_NT_HEADERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Signature = v_uint32()
        self.FileHeader = IMAGE_FILE_HEADER()
        self.OptionalHeader = IMAGE_OPTIONAL_HEADER()


class IO_STACK_LOCATION(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MajorFunction = v_uint8()
        self.MinorFunction = v_uint8()
        self.Flags = v_uint8()
        self.Control = v_uint8()
        self.Parameters = _unnamed_7812()
        self.DeviceObject = v_ptr32()
        self.FileObject = v_ptr32()
        self.CompletionRoutine = v_ptr32()
        self.Context = v_ptr32()


class KNODE(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PagedPoolSListHead = SLIST_HEADER()
        self.NonPagedPoolSListHead = SLIST_HEADER()
        self.Affinity = GROUP_AFFINITY()
        self.ProximityId = v_uint32()
        self.NodeNumber = v_uint16()
        self.PrimaryNodeNumber = v_uint16()
        self.MaximumProcessors = v_uint8()
        self.Color = v_uint8()
        self.Flags = flags()
        self.NodePad0 = v_uint8()
        self.Seed = v_uint32()
        self.MmShiftedColor = v_uint32()
        self.FreeCount = v_bytes(size=8) # FIXME Unknown Array Type
        self.CachedKernelStacks = CACHED_KSTACK_LIST()
        self.ParkLock = v_uint32()
        self.NodePad1 = v_uint32()


class _unnamed_8078(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.InterfaceType = v_ptr32()
        self.Size = v_uint16()
        self.Version = v_uint16()
        self.Interface = v_ptr32()
        self.InterfaceSpecificData = v_ptr32()


class XSAVE_AREA_HEADER(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.Mask = v_uint64()
        self.Reserved = v_bytes(size=56) # FIXME Unknown Array Type


class PSP_CPU_SHARE_CAPTURED_WEIGHT_DATA(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.CapturedCpuShareWeight = v_uint32()
        self.CapturedTotalWeight = v_uint32()


class RTL_USER_PROCESS_PARAMETERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.MaximumLength = v_uint32()
        self.Length = v_uint32()
        self.Flags = v_uint32()
        self.DebugFlags = v_uint32()
        self.ConsoleHandle = v_ptr32()
        self.ConsoleFlags = v_uint32()
        self.StandardInput = v_ptr32()
        self.StandardOutput = v_ptr32()
        self.StandardError = v_ptr32()
        self.CurrentDirectory = CURDIR()
        self.DllPath = UNICODE_STRING()
        self.ImagePathName = UNICODE_STRING()
        self.CommandLine = UNICODE_STRING()
        self.Environment = v_ptr32()
        self.StartingX = v_uint32()
        self.StartingY = v_uint32()
        self.CountX = v_uint32()
        self.CountY = v_uint32()
        self.CountCharsX = v_uint32()
        self.CountCharsY = v_uint32()
        self.FillAttribute = v_uint32()
        self.WindowFlags = v_uint32()
        self.ShowWindowFlags = v_uint32()
        self.WindowTitle = UNICODE_STRING()
        self.DesktopInfo = UNICODE_STRING()
        self.ShellInfo = UNICODE_STRING()
        self.RuntimeData = UNICODE_STRING()
        self.CurrentDirectores = UNICODE_STRING()
        self.EnvironmentSize = v_uint32()
        self.EnvironmentVersion = v_uint32()


class _unnamed_8176(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.PowerState = v_uint32()


class IO_RESOURCE_REQUIREMENTS_LIST(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.ListSize = v_uint32()
        self.InterfaceType = v_uint32()
        self.BusNumber = v_uint32()
        self.SlotNumber = v_uint32()
        self.Reserved = v_bytes(size=12) # FIXME Unknown Array Type
        self.AlternativeLists = v_uint32()
        self.List = v_uint32()


class HEAP_BUCKET_COUNTERS(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.TotalBlocks = v_uint32()
        self.SubSegmentCounts = v_uint32()




########NEW FILE########
__FILENAME__ = primitives

import struct

class v_enum: pass

class v_base(object):
    def __init__(self):
        self._vs_meta = {}

    def vsGetMeta(self, name, defval=None):
        return self._vs_meta.get(name, defval)

    def vsSetMeta(self, name, value):
        self._vs_meta[name] = value

    # Sub-classes (primitive base, or VStruct must have these
    def vsParse(self, bytes): return NotImplemented
    def vsCalculate(self): pass
    def vsIsPrim(self): return NotImplemented
    def vsGetTypeName(self): return NotImplemented

class v_prim(v_base):

    def __init__(self):
        v_base.__init__(self)
        # Used by base len(),vsGetFormat, etc...
        self._vs_value = None
        self._vs_length = None
        self._vs_fmt = None

    def vsIsPrim(self):
        return True

    def vsGetTypeName(self):
        return self.__class__.__name__

    def vsParse(self, bytes, offset=0):
        """
        Parser for primitives which assumes we are
        calling parse directly.
        """
        return NotImplemented

    def vsParseFd(self, fd):
        # Most primitives should be able to simply use this...
        fbytes = fd.read(self._vs_length)
        if len(fbytes) != self._vs_length:
            raise Excetpion('Not enough data in fd!')

        self.vsParse(fbytes)

    def vsEmit(self):
        '''
        Return the actual bytes which represent this field
        '''
        return NotImplemented

    def vsGetValue(self):
        """
        Get the type specific value for this field.
        (Used by the structure dereference method to return
        a python native for the field by name)
        """
        return self._vs_value

    def vsSetValue(self, value):
        """
        Set the type specific value for this field.
        """
        self._vs_value = value

    def vsSetLength(self, size):
        '''
        Set the length of this primitive type.  This may be used to
        dynamically update the length of string fields, etc...
        '''
        return NotImplemented

    def __repr__(self):
        return repr(self.vsGetValue())

    def __len__(self):
        return self._vs_length

    def __str__(self):
        return str(self.vsGetValue())

num_fmts = {
    (True,1):'>B',
    (True,2):'>H',
    (True,4):'>I',
    (True,8):'>Q',
    (False,1):'<B',
    (False,2):'<H',
    (False,4):'<I',
    (False,8):'<Q',
}

class v_number(v_prim):

    _vs_length = 1

    def __init__(self, value=0, bigend=False):
        v_prim.__init__(self)
        self._vs_bigend = bigend
        self._vs_value = value
        self._vs_length = self.__class__._vs_length
        self._vs_fmt = num_fmts.get( (bigend, self._vs_length) )

    def vsGetValue(self):
        return self._vs_value

    def vsParse(self, fbytes, offset=0):
        '''
        Parse the given numeric type from the given bytes...
        '''
        sizeoff = offset + self._vs_length

        if self._vs_fmt != None:
            b = fbytes[ offset : sizeoff ]
            self._vs_value = struct.unpack(self._vs_fmt, b)[0]

        else:
            r = []
            for i in range(self._vs_length):
                r.append( ord( fbytes[ offset + i ] ) )

            if not self._vs_bigend:
                r.reverse()

            self._vs_value = 0
            for x in r:
                self._vs_value = (self._vs_value << 8) + x

        return sizeoff

    def vsEmit(self):
        '''
        Emit the bytes for this numeric type...
        '''
        if self._vs_fmt != None:
            return struct.pack(self._vs_fmt, self._vs_value)

        r = []
        for i in range(self._vs_length):
            r.append( chr( (self._vs_value >> (i*8)) & 0xff) )

        if self._vs_bigend:
            r.reverse()

        return ''.join(r)


    def vsSetValue(self, value):
        """
        Assure that the value is long() able for all numeric types.
        """
        self._vs_value = long(value)

    def __int__(self):
        return int(self._vs_value)

    def __long__(self):
        return long(self._vs_value)

    ##################################################################
    # Implement the number API

    def __add__(self, other): return long(self) + long(other)
    def __sub__(self, other): return long(self) - long(other)
    def __mul__(self, other): return long(self) * long(other)
    def __div__(self, other): return long(self) / long(other)
    def __floordiv__(self, other): return long(self) // long(other)
    def __mod__(self, other): return long(self) % long(other)
    def __divmod__(self, other): return divmod(long(self), long(other))
    def __pow__(self, other, modulo=None): return pow(long(self), long(other), modulo)
    def __lshift__(self, other): return long(self) << long(other)
    def __rshift__(self, other): return long(self) >> long(other)
    def __and__(self, other): return long(self) & long(other)
    def __xor__(self, other): return long(self) ^ long(other)
    def __or__(self, other): return long(self) | long(other)

    # Operator swapped variants
    def __radd__(self, other): return long(other) + long(self)
    def __rsub__(self, other): return long(other) - long(self)
    def __rmul__(self, other): return long(other) * long(self)
    def __rdiv__(self, other): return long(other) / long(self)
    def __rfloordiv__(self, other): return long(other) // long(self)
    def __rmod__(self, other): return long(other) % long(self)
    def __rdivmod__(self, other): return divmod(long(other), long(self))
    def __rpow__(self, other, modulo=None): return pow(long(other), long(self), modulo)
    def __rlshift__(self, other): return long(other) << long(self)
    def __rrshift__(self, other): return long(other) >> long(self)
    def __rand__(self, other): return long(other) & long(self)
    def __rxor__(self, other): return long(other) ^ long(self)
    def __ror__(self, other): return long(other) | long(self)

    # Inplace variants
    def __iadd__(self, other): self.vsSetValue(self+other); return self
    def __isub__(self, other): self.vsSetValue(self - other); return self
    def __imul__(self, other): self.vsSetValue(self*other); return self
    def __idiv__(self, other): self.vsSetValue(self/other); return self
    def __ifloordiv__(self, other): self.vsSetValue(self // other); return self
    def __imod__(self, other): self.vsSetValue(self % other); return self
    def __ipow__(self, other, modulo=None): self.vsSetValue(pow(self, other, modulo)); return self
    def __ilshift__(self, other): self.vsSetValue(self << other); return self
    def __irshift__(self, other): self.vsSetValue(self >> other); return self
    def __iand__(self, other): self.vsSetValue(self & other); return self
    def __ixor__(self, other): self.vsSetValue(self ^ other); return self
    def __ior__(self, other): self.vsSetValue(self | other); return self

    # operator helpers
    def __neg__(self): return -(long(self))
    def __pos__(self): return +(long(self))
    def __abs__(self): return abs(long(self))
    def __invert__(self): return ~(long(self))

    # index use helper
    def __index__(self): return long(self)

    def __coerce__(self, other):
        try:
            return long(self),long(other)
        except Exception, e:
            return NotImplemented

    # Print helpers
    def __hex__(self): return hex(long(self))
    def __oct__(self): return oct(long(self))

class v_uint8(v_number):
    _vs_builder = True
    _vs_length = 1

class v_uint16(v_number):
    _vs_builder = True
    _vs_length = 2

class v_uint24(v_number):
    _vs_builder = True
    _vs_length = 3

class v_uint32(v_number):
    _vs_builder = True
    _vs_length = 4

class v_uint64(v_number):
    _vs_builder = True
    _vs_length = 8

class v_int8(v_number):
    _vs_builder = True
    _vs_length = 1

class v_int16(v_number):
    _vs_builder = True
    _vs_length = 2

class v_int24(v_number):
    _vs_builder = True
    _vs_length = 3

class v_int32(v_number):
    _vs_builder = True
    _vs_length = 4

class v_int64(v_number):
    _vs_builder = True
    _vs_length = 8

pointersize = struct.calcsize("P")

class v_size_t(v_number):
    _vs_builder = True
    _vs_length = pointersize

    def __repr__(self):
        return "0x%.8x" % self._vs_value

class v_ptr(v_size_t):
    pass

class v_ptr32(v_ptr):
    _vs_builder = True
    _vs_length = 4

class v_ptr64(v_ptr):
    _vs_builder = True
    _vs_length = 8

class v_bytes(v_prim):

    '''
    v_bytes is used for fixed width byte fields.
    '''

    _vs_builder = True

    def __init__(self, size=0, vbytes=None):
        v_prim.__init__(self)
        if vbytes == None:
            vbytes = '\x00' * size
        self._vs_length = len(vbytes)
        self._vs_value = vbytes

    def vsSetValue(self, val):
        if len(val) != self._vs_length:
            raise Exception('v_bytes field set to wrong length!')
        self._vs_value = val

    def vsParse(self, fbytes, offset=0):
        offend = offset + self._vs_length
        self._vs_value = fbytes[offset : offend]
        return offend

    def vsEmit(self):
        return self._vs_value

    def vsSetLength(self, size):
        size = int(size)
        self._vs_length = size
        # Either chop or expand my string...
        b = self._vs_value[:size]
        self._vs_value = b.ljust(size, '\x00')

    def __repr__(self):
        return self._vs_value.encode('hex')

class v_str(v_prim):
    '''
    A string placeholder class which will automagically return
    up to a null terminator (and will keep it's size by null
    padding when assigned to)
    '''

    _vs_builder = True

    def __init__(self, size=4, val=''):
        v_prim.__init__(self)
        self._vs_length = size
        self._vs_value = val.ljust(size, '\x00')

    def vsParse(self, fbytes, offset=0):
        offend = offset + self._vs_length
        self._vs_value = fbytes[offset : offend]
        return offend

    def vsEmit(self):
        return self._vs_value

    def vsGetValue(self):
        s = self._vs_value.split("\x00")[0]
        return s

    def vsSetValue(self, val):
        self._vs_value = val.ljust(self._vs_length, '\x00')

    def vsSetLength(self, size):
        size = int(size)
        self._vs_length = size
        # Either chop or expand my string...
        b = self._vs_value[:size]
        self._vs_value = b.ljust(size, '\x00')

class v_wstr(v_str):
    '''
    Unicode variant of the above string class

    NOTE: the size paramater is in WCHARs!
    '''

    _vs_builder = True

    def __init__(self, size=4, encode='utf-16le', val=''):
        v_prim.__init__(self)
        b = val.ljust(size, '\x00').encode(encode)
        self._vs_length = len(b)
        self._vs_value = b
        self._vs_encode = encode

    def vsParse(self, fbytes, offset=0):
        offend = offset + self._vs_length
        self._vs_value = fbytes[offset : offend]
        return offend

    def vsEmit(self):
        return self._vs_value

    def vsGetValue(self):
        cstr = self._vs_value.decode(self._vs_encode)
        return cstr.split('\x00')[0]

    def vsSetValue(self, val):
        rbytes = val.encode(self._vs_encode)
        self._vs_value = rbytes.ljust(len(self), '\x00')

    def vsGetValue(self):
        s = self._vs_value.decode(self._vs_encode)
        s = s.split("\x00")[0]
        return s

class GUID(v_prim):

    _vs_builder = True

    def __init__(self, guidstr=None):
        """
        Construct a new GUID primitive.  You may specify a GUID string in the
        constructor to populate initial values.
        """
        v_prim.__init__(self)
        self._vs_length = 16
        self._vs_value = "\x00" * 16
        self._vs_fmt = "16s"
        self._guid_fields = (0,0,0,0,0,0,0,0,0,0,0)
        if guidstr != None:
            self._parseGuidStr(guidstr)

    def vsParse(self, fbytes, offset=0):
        offend = offset + self._vs_length
        self._guid_fields = struct.unpack("<IHH8B", bytes[offset:offend])
        return offend

    def vsEmit(self):
        return struck.pack("<IHH8B", *self._guid_fields)

    def _parseGuidStr(self, gstr):
        gstr = gstr.replace("{","")
        gstr = gstr.replace("}","")
        gstr = gstr.replace("-","")
        bytes = gstr.decode("hex")
        # Totally cheating... ;)
        self._guid_fields = struct.unpack(">IHH8B", bytes)

    def vsSetValue(self, guidstr):
        self._parseGuidStr(guidstr)

    def vsGetValue(self):
        return repr(self)

    def __repr__(self):
        base = "{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}"
        return base  % self._guid_fields


########NEW FILE########
__FILENAME__ = unittest

import vstruct

from cStringIO import StringIO

from vstruct.primitives import *

def test(vs, hexstr):
    vshex = vs.vsEmit().encode('hex')
    if vshex != hexstr:
        raise Exception('FAIL')
    print 'PASS!'

v = vstruct.VStruct()
v.uint8 = v_uint8(1)
v.uint16 = v_uint16(2)
v.uint24 = v_uint24(3)
v.uint32 = v_uint32(4)
v.uint64 = v_uint64(5)
v.vbytes = v_bytes(vbytes='ABCD')

test(v,'01020003000004000000050000000000000041424344')
print v.tree()


v.uint8 = 99
v.uint16 = 100
v.uint24 = 101
v.uint32 = 102
v.uint64 = 103
v.vbytes = '\x00\x00\x00\x00'

test(v,'63640065000066000000670000000000000000000000')
print v.tree()


# =================================================================
v = vstruct.VStruct()
v._vs_field_align = True
v.uint8 = v_uint8(0x42, bigend=True)
v.uint16 = v_uint16(0x4243, bigend=True)
v.uint24 = v_uint24(0x424344, bigend=True)
v.uint32 = v_uint32(0x42434445, bigend=True)
v.uint64 = v_uint64(0x4243444546474849, bigend=True)

test(v, '420042430000424344000000424344454243444546474849')
print v.tree()


# ===============================================================

v = vstruct.VStruct()
v.strfield = v_str(size=30)
v.unifield = v_wstr(size=30)

v.strfield = 'wootwoot!'
v.unifield = 'bazbaz'

test(v, '776f6f74776f6f7421000000000000000000000000000000000000000000620061007a00620061007a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000')
print v.tree()

v.vsParse('B'*90)

# ===============================================================
def updatelen(vs):
    vs.vsGetField('strfield').vsSetLength(vs.lenfield)

v = vstruct.VStruct()
v.lenfield = v_uint8(0x30)
v.strfield = v_str(size=30)
v.vsAddParseCallback('lenfield', updatelen)

v.vsParse('\x01' + 'A' * 30)
test(v, '0141')
print v.tree()


# ==============================================================

class woot(vstruct.VStruct):
    def __init__(self):
        vstruct.VStruct.__init__(self)
        self.lenfield = v_uint8()
        self.strfield = v_str(size=0x20)

    def pcb_lenfield(self):
        self.vsGetField('strfield').vsSetLength(self.lenfield)

v = woot()
v.vsParse('\x01' + 'A'*30)
test(v, '0141')
print v.tree()

# ==============================================================

v = woot()
sio = StringIO('\x01' + 'A' * 30)
v.vsParseFd(sio)
test(v, '0141')
print v.tree()



########NEW FILE########
__FILENAME__ = amd64
"""
Amd64 Support Module
"""
# Copyright (C) 2007 Invisigoth - See LICENSE file for details
import struct

import envi.archs.amd64 as e_amd64
import vtrace.archs.i386 as vt_i386

class Amd64Mixin(
        e_amd64.Amd64Module,
        e_amd64.Amd64RegisterContext,
        vt_i386.i386WatchMixin):
    """
    Do what we need to for the lucious amd64
    """
    def __init__(self):
        e_amd64.Amd64Module.__init__(self)
        e_amd64.Amd64RegisterContext.__init__(self)
        vt_i386.i386WatchMixin.__init__(self)

        self.setMeta('Architecture','amd64')

    def archGetStackTrace(self):
        self.requireAttached()
        current = 0
        sanity = 1000
        frames = []
        rbp = self.getRegisterByName("rbp")
        rip = self.getRegisterByName("rip")
        frames.append((rip,rbp))

        while rbp != 0 and current < sanity:
            try:
                rbp,rip = self.readMemoryFormat(rbp, "<QQ")
            except:
                break
            frames.append((rip,rbp))
            current += 1

        return frames


########NEW FILE########
__FILENAME__ = i386
"""
x86 Support Module
"""
# Copyright (C) 2007 Invisigoth - See LICENSE file for details
import vtrace
import struct
import traceback
import types
import vtrace.breakpoints as breakpoints

import envi.archs.i386 as e_i386

# Pre-populating these saves a little processing
# time (important in tight watchpoint loops)
drnames = ["debug%d" % d for d in range(8)]

dbg_status = "debug6"
dbg_ctrl = "debug7"

dbg_execute    = 0
dbg_write      = 1
dbg_read_write = 3

dbg_types = {
    "x":dbg_execute,
    "w":dbg_write,
    "rw":dbg_read_write,
}

class i386WatchMixin:
    def __init__(self):
        # Which ones are in use / enabled.
        self.hwdebug = [0, 0, 0, 0]
        # FIXME change this to storing debug0 index and using setRegister()

    def archAddWatchpoint(self, address, size=4, perms="rw"):

        idx = None
        for i in range(4):
            if not self.hwdebug[i]:
                idx = i
                break

        if idx == None:
            raise Exception("ERROR: there...  are... 4... debug registers!")

        pbits = dbg_types.get(perms)
        if pbits == None:
            raise Exception("Unsupported watchpoint perms %s (x86 supports x,w,rw)" % perms)

        if pbits == dbg_execute and size != 1:
            raise Exception("Watchpoint for execute *must* be 1 byte long!")

        if size not in [1,2,4]:
            raise Exception("Unsupported watchpoint size %d (x86 supports 1,2,4)" % size)

        ctrl = 0

        self.hwdebug[idx] = address

        ctrl |= 1 << (2*idx)           # Enabled
        mask = ((size-1) << 2) + pbits # perms and size
        ctrl |= (mask << (16+(4*idx)))
        #ctrl |= 0x100 # Local exact (ignored by p6+ for read)

        for tid in self.getThreads().keys():
            ctx = self.getRegisterContext(tid)
            ctrl_orig = ctx.getRegister(e_i386.REG_DEBUG7)
            #print "debug%d: %.8x debug7: %.8x" % (idx,address,ctrl|ctrl_orig)
            ctx.setRegister(e_i386.REG_DEBUG7, ctrl_orig | ctrl)
            ctx.setRegister(e_i386.REG_DEBUG0 + idx, address)
        return

    def archRemWatchpoint(self, address):
        idx = None
        for i in range(4):
            if self.hwdebug[i] == address:
                idx = i
                break

        if idx == None:
            raise Exception("Watchpoint not found at 0x%.8x" % address)

        self.hwdebug[idx] = 0

        ctrl_disable = ~(1 << (2*idx))      # we are not enabled
        ctrl_disperm = ~(0xf << (16+(4*idx))) # mask off the rwx stuff
        ctrl_mask = ctrl_disable & ctrl_disperm

        for tid in self.getThreads().keys():
            ctx = self.getRegisterContext(tid)
            ctrl = ctx.getRegister(e_i386.REG_DEBUG7)
            ctrl &= ctrl_mask
            #print "debug%d: %.8x debug7: %.8x" % (idx,address,ctrl|ctrl_orig)
            ctx.setRegister(e_i386.REG_DEBUG7, ctrl)
            ctx.setRegister(e_i386.REG_DEBUG0 + idx, 0)
        return

    def archCheckWatchpoints(self):
        regs = self.getRegisters()
        status = regs.get(dbg_status)
        #print "STATUS %.8x" % status
        if status == None:
            return None
        x = status & 0x0f
        if not x:
            return None

        for i in range(4):
            if (x >> i) & 1:
                return self.hwdebug[i]
        return None


class i386Mixin(e_i386.i386Module, e_i386.i386RegisterContext, i386WatchMixin):

    def __init__(self):
        # Mixin our i386 envi architecture module and register context
        e_i386.i386Module.__init__(self)
        # FIXME tracer base should inherit from RegisterContext and we should
        # just have to load a register definition!
        e_i386.i386RegisterContext.__init__(self)
        i386WatchMixin.__init__(self)

        self.setMeta('Architecture', 'i386')

    def archGetStackTrace(self):
        self.requireAttached()
        current = 0
        sanity = 1000
        frames = []

        #FIXME make these by register index
        #FIXME make these GPREG stuff! (then both are the same)
        ebp = self.getRegisterByName("ebp")
        eip = self.getRegisterByName("eip")
        frames.append((eip,ebp))

        while ebp != 0 and current < sanity:
            try:
                buf = self.readMemory(ebp, 8)
                ebp,eip = struct.unpack("<LL",buf)
                frames.append((eip,ebp))
                current += 1
            except:
                break

        return frames

    def platformCall(self, address, args, convention=None):
        buf = ""
        finalargs = []
        saved_regs = self.getRegisters()
        sp = self.getStackCounter()
        pc = self.getProgramCounter()

        for arg in args:
            if type(arg) == types.StringType: # Nicly map strings into mem
                buf = arg+"\x00\x00"+buf    # Pad with a null for convenience
                finalargs.append(sp - len(buf))
            else:
                finalargs.append(arg)

        m = len(buf) % 4
        if m:
            buf = ("\x00" * (4-m)) + buf

        # Args are 
        #finalargs.reverse()
        buf = struct.pack("<%dL" % len(finalargs), *finalargs) + buf

        # Saved EIP is target addr so when we hit the break...
        buf = struct.pack("<L", address) + buf
        # Calc the new stack pointer
        newsp = sp-len(buf)
        # Write the stack buffer in
        self.writeMemory(newsp, buf)
        # Setup the stack pointer
        self.setStackCounter(newsp)
        # Setup the instruction pointer
        self.setProgramCounter(address)
        # Add the magical call-break
        callbreak = breakpoints.CallBreak(address, saved_regs)
        self.addBreakpoint(callbreak)
        # Continue until the CallBreak has been hit
        while not callbreak.endregs:
            self.run()
        return callbreak.endregs


########NEW FILE########
__FILENAME__ = ppc
"""
PPC Support Module (not done)
"""
# Copyright (C) 2007 Invisigoth - See LICENSE file for details
class PpcMixin:
    def archAddWatchpoint(self, address):
        pass

    def archRemWatchpoint(self, address):
        pass

    def archCheckWatchpoint(self, address):
        pass

    def getStackTrace(self):
        self.requireAttached()
        return []

    def getBreakInstruction(self):
        # twi 0x14, r0, 0 
        # trap if r0 is (>=:unsigned) 0
        return "\x0e\x80\x00\x00"

    def archGetPcName(self):
        return "r0"

    def archGetSpName(self):
        return "r1"

    def platformCall(self, address, args, convention=None):
        pass

########NEW FILE########
__FILENAME__ = audit
"""
Test for platform functionality (for internal use).
"""
# Copyright (C) 2007 Invisigoth - See LICENSE file for details
import vtrace
import vtrace.platforms.base as v_base

############################################
#
# FIXME this is dorked for now based on the new platforms/archs design
#
############################################

def auditTracer(trace):
    """
    Print out a list of platform requirements and weather
    a particular tracer meets them.  This is mostly a
    development tool to determin what's left to do on a 
    tracer implementation.
    """
    for mname in dir(v_base.BasePlatformMixin):
        if "__" in mname:
            continue
        if getattr(trace.__class__, mname) == getattr(v_base.BasePlatformMixin, mname):
            print "LACKS:",mname
        else:
            print "HAS:",mname

if __name__ == "__main__":
    trace = vtrace.getTrace()
    auditTracer(trace)

########NEW FILE########
__FILENAME__ = breakpoints

"""
Breakpoint Objects
"""

# Copyright (C) 2007 Invisigoth - See LICENSE file for details

import time

import vtrace

class Breakpoint:
    """
    Breakpoints in Vtrace are platform independant objects that
    use the underlying trace objects to get things like the
    program counter and the break instruction.  As long as
    platfforms are completely implemented, all breakpoint
    objects should be portable.
    """

    bpcodeobj = {} # Cache compiled code objects on the class def

    def __init__(self, address, expression=None):
        self.saved = None
        self.resonce = False
        self.address = address
        self.breakinst = None
        self.enabled = True
        self.active = False
        self.fastbreak = False
        self.id = -1
        self.vte = None
        self.bpcode = None
        if expression:
            self.vte = expression

    def getAddress(self):
        """
        This will return the address for this breakpoint.  If the return'd
        address is None, this is a deferred breakpoint which needs to have
        resolveAddress() called to attempt to set the address.
        """
        return self.address

    def getId(self):
        return self.id

    def getName(self):
        if self.vte:
            return str(self.vte)
        return "0x%.8x" % self.address

    def __repr__(self):
        if self.address == None:
            addr = "unresolved"
        else:
            addr = "0x%.8x" % self.address
        return "[%d] %s %s: %s" % (self.id, addr, self.__class__.__name__, self.getName())

    def inittrace(self, trace):
        '''
        A callback to do housekeeping at the time the breakpoint is
        added to the tracer object.  This should be used instead of activate
        for initialization time infoz to save on time per activate call...
        '''
        self.breakinst = trace.archGetBreakInstr()

    def resolvedaddr(self, trace, addr):
        '''
        An initialization callback which will be executed when the
        actual address for this breakpoint has been resolved.
        '''
        self.saved = trace.readMemory(addr, len(self.breakinst))

    def activate(self, trace):
        """
        Actually store off and replace memory for this process.  This
        is caried out by the trace object itself when it begins
        running or stops.  You probably never need to call this
        (see isEnabled() setEnabled() for boolean enable/disablle)
        """
        trace.requireAttached()
        if not self.active:
            if self.address != None:
                trace.writeMemory(self.address, self.breakinst)
                self.active = True
        return self.active

    def deactivate(self, trace):
        """
        Repair the process for continued execution.  this does NOT
        make a breakpoint *inactive*, but removes it's "0xcc" from mem
        (see isEnabled() setEnabled() for boolean enable/dissable)
        """
        trace.requireAttached()
        if self.active:
            self.active = False
            trace.writeMemory(self.address, self.saved)
        return self.active

    def resolveAddress(self, trace):
        """
        Try to resolve the address for this break.  If this is a statically
        addressed break, just return the address.  If it has an "expression"
        use that to resolve the address...
        """
        if self.address == None and self.vte:
            try:
                self.address = trace.parseExpression(self.vte)
            except Exception, e:
                self.address == None

        # If we resolved, lets get our saved code...
        if self.address != None and not self.resonce:
            self.resonce = True
            self.resolvedaddr(trace, self.address)

        return self.address

    def isEnabled(self):
        """
        Is this breakpoint "enabled"?
        """
        return self.enabled

    def setEnabled(self, enabled=True):
        """
        Set this breakpoints "enabled" status
        """
        self.enabled = enabled

    def setBreakpointCode(self, pystr):
        """
        Use this method to set custom python code to run when this
        breakpoint gets hit.  The code will have the following objects
        mapped into it's namespace when run:
            trace - the tracer
            vtrace - the vtrace module
            bp - the breakpoint
        """
        self.bpcode = pystr
        Breakpoint.bpcodeobj.pop(self.id, None)

    def getBreakpointCode(self):
        """
        Return the current python string that will be run when this break is hit.
        """
        return self.bpcode

    def notify(self, event, trace):
        """
        Breakpoints may also extend and implement "notify" which will be
        called whenever they are hit.  If you want to continue the ability
        for this breakpoint to have bpcode, you must call this method from
        your override.
        """
        if self.bpcode != None:
            cobj = Breakpoint.bpcodeobj.get(self.id, None)
            if cobj == None:
                fname = "BP:%d (0x%.8x)" % (self.id, self.address)
                cobj = compile(self.bpcode, fname, "exec")
                Breakpoint.bpcodeobj[self.id] = cobj

            d = vtrace.VtraceExpressionLocals(trace)
            d['bp'] = self
            exec(cobj, None, d)

class TrackerBreak(Breakpoint):
    """
    A breakpoint which will record how many times it was hit
    (by the address it was at) as metadata for the tracer.
    """
    def notify(self, event, trace):
        tb = trace.getMeta("TrackerBreak", None)
        if tb == None:
            tb = {}
        trace.setMeta("TrackerBreak", tb)
        tb[self.address] = (tb.get(self.address,0) + 1)
        Breakpoint.notify(self, event, trace)

class OneTimeBreak(Breakpoint):
    """
    This type of breakpoint is exclusivly for marking
    and code-coverage stuff.  It removes itself.
    (most frequently used with a continued trace)
    """
    def notify(self, event, trace):
        trace.removeBreakpoint(self.id)
        Breakpoint.notify(self, event, trace)

class StopRunForeverBreak(Breakpoint):
    """
    This breakpoint will turn off RunForever mode
    on the tracer object when hit.  it's a good way
    to let things run on and on processing exceptions
    but stop when you get to this one thing.
    """
    def notify(self, event, trace):
        trace.setMode("RunForever", False)
        Breakpoint.notify(self, event, trace)

class StopAndRemoveBreak(Breakpoint):
    """
    When hit, take the tracer out of run-forever mode and
    remove this breakpoint.
    """
    def notify(self, event, trace):
        trace.setMode("RunForever", False)
        trace.removeBreakpoint(self.id)
        Breakpoint.notify(self, event, trace)

class CallBreak(Breakpoint):
    """
    A special breakpoint which will restore process
    state (registers in particular) when it gets hit.
    This is primarily used by the call method inside
    the trace object to restore original state
    after a successful "call" method call.

    Additionally, the endregs dict will be filled in
    with the regs at the time it was hit and kept until
    we get garbage collected...
    """
    def __init__(self, address, saved_regs):
        Breakpoint.__init__(self, address)
        self.endregs = None # Filled in when we get hit
        self.saved_regs = saved_regs

    def notify(self, event, trace):
        self.endregs = trace.getRegisters()
        trace.removeBreakpoint(self.id)
        trace.setRegisters(self.saved_regs)
        trace.setMeta("PendingSignal", None)

class SnapshotBreak(Breakpoint):
    """
    A special breakpoint type which will produce vtrace snapshots
    for the target process when hit.  The snapshots will be saved
    to a default name of <exename>-<timestamp>.vsnap.  This is not
    recommended for use in heavily hit breakpoints as taking a
    snapshot is processor intensive.
    """
    def notify(self, event, trace):
        exe = trace.getExe()
        snap = trace.takeSnapshot()
        snap.saveToFile("%s-%d.vsnap" % (exe,time.time()))
        Breakpoint.notify(self, event, trace)


########NEW FILE########
__FILENAME__ = envitools

"""
Some tools that require the envi framework to be installed
"""

import sys
import traceback

import envi
import envi.archs.i386 as e_i386 # FIXME This should NOT have to be here

class RegisterException(Exception):
    pass

def cmpRegs(emu, trace):
    for idx,name in reg_map:
        er = emu.getRegister(idx)
        tr = trace.getRegisterByName(name)
        if er != tr:
            raise RegisterException("REGISTER MISMATCH: %s 0x%.8x 0x%.8x" % (name, tr, er))
    return True

reg_map = [
    (e_i386.REG_EAX, "eax"),
    (e_i386.REG_ECX, "ecx"),
    (e_i386.REG_EDX, "edx"),
    (e_i386.REG_EBX, "ebx"),
    (e_i386.REG_ESP, "esp"),
    (e_i386.REG_EBP, "ebp"),
    (e_i386.REG_ESI, "esi"),
    (e_i386.REG_EDI, "edi"),
    (e_i386.REG_EIP, "eip"),
    (e_i386.REG_EFLAGS, "eflags")
    ]

#FIXME intel specific
def setRegs(emu, trace):
    for idx,name in reg_map:
        tr = trace.getRegisterByName(name)
        emu.setRegister(idx, tr)

def emulatorFromTrace(trace):
    """
    Produce an envi emulator for this tracer object.  Use the trace's arch
    info to get the emulator so this can be done on the client side of a remote
    vtrace session.
    """
    arch = trace.getMeta("Architecture")
    amod = envi.getArchModule(arch)
    emu = amod.getEmulator()

    if trace.getMeta("Platform") == "Windows":
        emu.setSegmentInfo(e_i386.SEG_FS, trace.getThreads()[trace.getMeta("ThreadId")], 0xffffffff)

    emu.setMemoryObject(trace)
    setRegs(emu, trace)
    return emu

def lockStepEmulator(emu, trace):
    while True:
        print "Lockstep: 0x%.8x" % emu.getProgramCounter()
        try:
            pc = emu.getProgramCounter()
            op = emu.makeOpcode(pc)
            trace.stepi()
            emu.stepi()
            cmpRegs(emu, trace)
        except RegisterException, msg:
            print "Lockstep Error: %s: %s" % (repr(op),msg)
            setRegs(emu, trace)
            sys.stdin.readline()
        except Exception, msg:
            traceback.print_exc()
            print "Lockstep Error: %s" % msg
            return

import vtrace
import vtrace.platforms.base as v_base

class TraceEmulator(vtrace.Trace, v_base.TracerBase):
    """
    Wrap an arbitrary emulator in a Tracer compatible API.
    """
    def __init__(self, emu):
        self.emu = emu
        vtrace.Trace.__init__(self)
        v_base.TracerBase.__init__(self)

        # Fake out being attached
        self.attached = True
        self.pid = 0x56

        self.setRegisterInfo(emu.getRegisterInfo())

    def getPointerSize(self):
        return self.emu.getPointerSize()

    def platformStepi(self):
        self.emu.stepi()

    def platformWait(self):
        # We only support single step events now
        return True

    def archGetRegCtx(self):
        return self.emu

    def platformGetRegCtx(self, threadid):
        return self.emu

    def platformSetRegCtx(self, threadid, ctx):
        self.setRegisterSnap(ctx.getRegisterSnap())

    def platformProcessEvent(self, event):
        self.fireNotifiers(vtrace.NOTIFY_STEP)

    def platformReadMemory(self, va, size):
        return self.emu.readMemory(va, size)

    def platformWriteMemory(self, va, bytes):
        return self.emu.writeMemory(va, bytes)

    def platformGetMaps(self):
        return self.emu.getMemoryMaps()

    def platformGetThreads(self):
        return {1:0xffff0000,}

    def platformGetFds(self):
        return [] #FIXME perhaps tie this into magic?

    def getStackTrace(self):
        # FIXME i386...
        return [(self.emu.getProgramCounter(), 0), (0,0)]

    def platformDetach(self):
        pass

def main():
    import vtrace
    sym = sys.argv[1]
    pid = int(sys.argv[2])
    t = vtrace.getTrace()
    t.attach(pid)
    symaddr = t.parseExpression(sym)
    t.addBreakpoint(vtrace.Breakpoint(symaddr))
    while t.getProgramCounter() != symaddr:
        t.run()
    snap = t.takeSnapshot()
    #snap.saveToFile("woot.snap") # You may open in vdb to follow along
    emu = emulatorFromTrace(snap)
    lockStepEmulator(emu, t)

if __name__ == "__main__":
    # Copy this file out to the vtrace dir for testing and run as main
    main()


########NEW FILE########
__FILENAME__ = notifiers
"""
Vtrace notitifers base classes and examples

Vtrace supports the idea of callback notifiers which
get called whenever particular events occur in the target
process.  Notifiers may be registered to recieve a callback
on any of the vtrace.NOTIFY_FOO events from vtrace.  One notifier
*may* be registered with more than one trace, as the "notify"
method is passed a reference to the trace for which an event
has occured...

"""
# Copyright (C) 2007 Invisigoth - See LICENSE file for details

import vtrace
import traceback

class Notifier(object):
    """
    The top level example notifier...  Anything which registers
    itself for trace events or tracegroup events should implement
    the notify method as shown here.
    """

    def __init__(self):
        """
        All extenders *must* call this.  Mostly because all the
        goop necissary for the remote debugging stuff...
        (if notifier is instantiated on server, all is well, if it's
        on the client it needs a proxy...)
        """
        pass

    def handleEvent(self, event, trace):
        """
        An "internal" handler so if we need to do something
        from an API perspective before calling the notify method
        we can have a good "all at once" hook
        """
        self.notify(event, trace)

    def notify(self, event, trace):
        print "Got event: %d from pid %d" % (event, trace.getPid())

class VerboseNotifier(Notifier):
    def notify(self, event, trace):
        print "PID %d thread(%d) got" % (trace.getPid(), trace.getMeta("ThreadId")),
        if event == vtrace.NOTIFY_ALL:
            print "WTF, how did we get a vtrace.NOTIFY_ALL event?!?!"
        elif event == vtrace.NOTIFY_SIGNAL:
            signo = trace.getCurrentSignal()
            print "vtrace.NOTIFY_SIGNAL %d (0x%.8x)" % (signo, signo)
            if trace.getMeta("Platform") == "Windows":
                print repr(trace.getMeta("Win32Event"))
        elif event == vtrace.NOTIFY_BREAK:
            print "vtrace.NOTIFY_BREAK"
        elif event == vtrace.NOTIFY_SYSCALL:
            print "vtrace.NOTIFY_SYSCALL"
        elif event == vtrace.NOTIFY_CONTINUE:
            print "vtrace.NOTIFY_CONTINUE"
        elif event == vtrace.NOTIFY_EXIT:
            print "vtrace.NOTIFY_EXIT"
            print "ExitCode",trace.getMeta("ExitCode")
        elif event == vtrace.NOTIFY_ATTACH:
            print "vtrace.NOTIFY_ATTACH"
        elif event == vtrace.NOTIFY_DETACH:
            print "vtrace.NOTIFY_DETACH"
        elif event == vtrace.NOTIFY_LOAD_LIBRARY:
            print "vtrace.NOTIFY_LOAD_LIBRARY"
        elif event == vtrace.NOTIFY_UNLOAD_LIBRARY:
            print "vtrace.NOTIFY_UNLOAD_LIBRARY"
        elif event == vtrace.NOTIFY_CREATE_THREAD:
            print "vtrace.NOTIFY_CREATE_THREAD"
        elif event == vtrace.NOTIFY_EXIT_THREAD:
            print "vtrace.NOTIFY_EXIT_THREAD"
            print "ExitThread",trace.getMeta("ExitThread", -1)
        elif event == vtrace.NOTIFY_STEP:
            print "vtrace.NOTIFY_STEP"
        else:
            print "vtrace.NOTIFY_WTF_HUH?"

class DistributedNotifier(Notifier):
    """
    A notifier which will distributed notifications out to
    locally registered notifiers so that remote tracer's notifier
    callbacks only require once across the wire.
    """
    # NOTE: once you turn on vtrace.NOTIFY_ALL it can't be turned back off yet.
    def __init__(self):
        Notifier.__init__(self)
        self.shared = False
        self.events = []
        self.notifiers = {}
        for i in range(vtrace.NOTIFY_MAX):
            self.notifiers[i] = []

    def getProxy(self, trace):
        host,nothing = cobra.getCobraSocket(trace).getLocalName()

    def notify(self, event, trace):
        self.fireNotifiers(event, trace)

    def fireNotifiers(self, event, trace):
        """
        Fire all our registerd local-notifiers
        """
        nlist = self.notifiers.get(vtrace.NOTIFY_ALL, [])
        for notifier in nlist:
            try:
                notifier.handleEvent(event, trace)
            except:
                print "ERROR - Exception in notifier:",traceback.format_exc()

        nlist = self.notifiers.get(event, [])
        for notifier in nlist:
            try:
                notifier.handleEvent(event, trace)
            except:
                print "ERROR - Exception in notifier:",traceback.format_exc()

    def registerNotifier(self, event, notif):
        """
        Register a sub-notifier to get the remote callback's via
        our local delivery.
        """
        nlist = self.notifiers.get(event)
        nlist.append(notif)

    def deregisterNotifier(self, event, notif):
        nlist = self.notifiers.get(event)
        nlist.remove(notif)


########NEW FILE########
__FILENAME__ = base
"""
Tracer Platform Base
"""
# Copyright (C) 2007 Invisigoth - See LICENSE file for details
import os
import struct
import vtrace
import traceback
import platform

from Queue import Queue
from threading import Thread,currentThread,Lock

import envi
import envi.memory as e_mem
import envi.threads as e_threads
import envi.resolver as e_resolv

import vstruct.builder as vs_builder

class TracerBase(vtrace.Notifier):
    """
    The basis for a tracer's internals.  All platformFoo/archFoo
    functions are defaulted, and internal state is initialized.
    Additionally, a number of internal utilities are housed here.
    """
    def __init__(self):
        """
        The routine to initialize a tracer's initial internal state.  This
        is used by the initial creation routines, AND on attaches/executes
        to re-fresh the state of the tracer.
        WARNING: This will erase all metadata/symbols (modes/notifiers are kept)
        """
        vtrace.Notifier.__init__(self)

        self.pid = 0 # Attached pid (also used to know if attached)
        self.exited = False
        self.breakpoints = {}
        self.newbreaks = []
        self.bpbyid = {}
        self.bpid = 0
        self.curbp = None
        self.bplock = Lock()
        self.deferred = []
        self.running = False
        self.runagain = False
        self.attached = False
        # A cache for memory maps and fd listings
        self.mapcache = None
        self.thread = None # our proxy thread...
        self.threadcache = None
        self.fds = None
        self.signal_ignores = []
        self.localvars = {}

        # Set if we are RunForever until a thread exit...
        self._join_thread = None

        self.vsbuilder = vs_builder.VStructBuilder()

        self.psize = self.getPointerSize() # From the envi arch mod...

        # Track which libraries are parsed, and their
        # normame to full path mappings
        self.libloaded = {} # True if the library has been loaded already
        self.libpaths = {}  # normname->filename and filename->normname lookup

        # Set up some globally expected metadata
        self.setMeta('PendingSignal', None)
        self.setMeta('SignalInfo', None)
        self.setMeta("IgnoredSignals",[])
        self.setMeta("LibraryBases", {}) # name -> base address mappings for binaries
        self.setMeta("LibraryPaths", {}) # base -> path mappings for binaries
        self.setMeta("ThreadId", 0) # If you *can* have a thread id put it here
        plat = platform.system()
        rel  = platform.release()
        self.setMeta("Platform", plat)
        self.setMeta("Release", rel)

        # Use this if we are *expecting* a break
        # which is caused by us (so we remove the
        # SIGBREAK from pending_signal
        self.setMeta("ShouldBreak", False)

    def nextBpId(self):
        self.bplock.acquire()
        x = self.bpid
        self.bpid += 1
        self.bplock.release()
        return x

    def justAttached(self, pid):
        """
        platformAttach() function should call this
        immediately after a successful attach.  This does
        any necessary initialization for a tracer to be
        back in a clean state.
        """
        self.pid = pid
        self.attached = True
        self.breakpoints = {}
        self.bpbyid = {}
        self.setMeta("PendingSignal", None)
        self.setMeta("ExitCode", 0)
        self.exited = False

    def getResolverForFile(self, filename):
        res = self.resbynorm.get(filename, None)
        if res: return res
        res = self.resbyfile.get(filename, None)
        if res: return res
        return None

    def steploop(self):
        """
        Continue stepi'ing in a loop until shouldRunAgain()
        returns false (like RunForever mode or something)
        """
        if self.getMode("NonBlocking", False):
            e_threads.firethread(self.doStepLoop)()
        else:
            self.doStepLoop()

    def doStepLoop(self):
        go = True
        while go:
            self.stepi()
            go = self.shouldRunAgain()

    def _doRun(self):
        # Exists to avoid recursion from loop in doWait
        self.requireAttached()
        self.requireNotRunning()
        self.requireNotExited()

        fastbreak = False
        if self.curbp:
            fastbreak = self.curbp.fastbreak

        # If we are on a breakpoint, and it's a fastbreak
        # we don't want to fire a "continue" event.
        if not fastbreak:
            self.fireNotifiers(vtrace.NOTIFY_CONTINUE)

        # Step past a breakpoint if we are on one.
        self._checkForBreak()

        # Throw down and activate breakpoints...
        if not fastbreak:
            self._throwdownBreaks()

        self.running = True
        self.runagain = False
        self._syncRegs()    # Must be basically last...
        self.platformContinue()
        self.setMeta("PendingSignal", None)

    def wait(self):
        """
        Wait for the trace target to have
        something happen...   If the trace is in
        NonBlocking mode, this will fire a thread
        to wait for you and return control immediately.
        """
        if self.getMode("NonBlocking"):
            e_threads.firethread(self._doWait)()
        else:
            self._doWait()

    def _doWait(self):
        doit = True
        while doit:
        # A wrapper method for  wait() and the wait thread to use
            self.setMeta('SignalInfo', None)
            self.setMeta('PendingSignal', None)
            event = self.platformWait()
            self.running = False
            self.platformProcessEvent(event)
            doit = self.shouldRunAgain()
            if doit:
                self._doRun()

    def _fireSignal(self, signo, siginfo=None):
        self.setMeta('PendingSignal', signo)
        self.setMeta('SignalInfo', siginfo)
        self.fireNotifiers(vtrace.NOTIFY_SIGNAL)

    def _fireExit(self, ecode):
        self.setMeta('ExitCode', ecode)
        self.fireNotifiers(vtrace.NOTIFY_EXIT)

    def _fireExitThread(self, threadid, ecode):
        self.setMeta('ExitThread', threadid)
        self.setMeta('ExitCode', ecode)
        self.fireNotifiers(vtrace.NOTIFY_EXIT_THREAD)

    def _activateBreak(self, bp):
        # NOTE: This is special cased by hardware debuggers etc...
        if bp.isEnabled():
            try:
                bp.activate(self)
            except Exception, e:
                traceback.print_exc()
                print "WARNING: bpid %d activate failed (deferring): %s" % (bp.id, e)
                self.deferred.append(bp)

    def _throwdownBreaks(self):
        """
        Run through the breakpoints and setup
        the ones that are enabled.

        NOTE: This should *not* get called when continuing
        from a fastbreak...
        """

        # Resolve deferred breaks
        for bp in self.deferred:
            addr = bp.resolveAddress(self)
            if addr != None:
                self.deferred.remove(bp)
                self.breakpoints[addr] = bp

        for bp in self.breakpoints.values():
            self._activateBreak(bp)

    def _syncRegs(self):
        """
        Sync the reg-cache into the target process
        """
        if self.regcache != None:
            for tid, ctx in self.regcache.items():
                if ctx.isDirty():
                    self.platformSetRegCtx(tid, ctx)
        self.regcache = None

    def _cacheRegs(self, threadid):
        """
        Make sure the reg-cache is populated
        """
        if self.regcache == None:
            self.regcache = {}
        ret = self.regcache.get(threadid)
        if ret == None:
            ret = self.platformGetRegCtx(threadid)
            ret.setIsDirty(False)
            self.regcache[threadid] = ret
        return ret

    def _checkForBreak(self):
        """
        Check to see if we've landed on a breakpoint, and if so
        deactivate and step us past it.

        WARNING: Unfortunatly, cause this is used immidiatly before
        a call to run/wait, we must block briefly even for the GUI
        """
        # Steal a reference because the step should
        # clear curbp...
        bp = self.curbp
        if bp != None and bp.isEnabled():
            if bp.active:
                bp.deactivate(self)
            orig = self.getMode("FastStep")
            self.setMode("FastStep", True)
            self.stepi()
            self.setMode("FastStep", orig)
            bp.activate(self)
        self.curbp = None

    def shouldRunAgain(self):
        """
        A unified place for the test as to weather this trace
        should be told to run again after reaching some stopping
        condition.
        """
        if not self.attached:
            return False

        if self.exited:
            return False

        if self.getMode("RunForever"):
            return True

        if self.runagain:
            return True

        return False

    def __repr__(self):
        run = "stopped"
        exe = "None"
        if self.isRunning():
            run = "running"
        elif self.exited:
            run = "exited"
        exe = self.getMeta("ExeName")
        return "[%d]\t- %s <%s>" % (self.pid, exe, run)

    def initMode(self, name, value, descr):
        """
        Initialize a mode, this should ONLY be called
        during setup routines for the trace!  It determines
        the available mode setings.
        """
        self.modes[name] = bool(value)
        self.modedocs[name] = descr

    def release(self):
        """
        Do cleanup when we're done.  This is mostly necissary
        because of the thread proxy holding a reference to this
        tracer...  We need to let him die off and try to get
        garbage collected.
        """
        if self.thread:
            self.thread.go = False

    def _cleanupResources(self):
        self._tellThreadExit()

    def _tellThreadExit(self):
        if self.thread != None:
            self.thread.queue.put(None)
            self.thread.join(timeout=2)
            self.thread = None

    def __del__(self):
        if not self._released:
            print 'Warning! tracer del w/o release()!'

    def fireTracerThread(self):
        # Fire the threadwrap proxy thread for this tracer
        # (if it hasnt been fired...)
        if self.thread == None:
            self.thread = TracerThread()

    def fireNotifiers(self, event):
        """
        Fire the registered notifiers for the NOTIFY_* event.
        """
        if event == vtrace.NOTIFY_SIGNAL:
            signo = self.getCurrentSignal()
            if signo in self.getMeta("IgnoredSignals", []):
                if vtrace.verbose: print "Ignoring",signo
                self.runAgain()
                return

        alllist = self.getNotifiers(vtrace.NOTIFY_ALL)
        nlist = self.getNotifiers(event)

        trace = self
        # if the trace has a proxy it's notifiers
        # need that, cause we can't be pickled ;)
        if self.proxy:
            trace = self.proxy

        # First we notify ourself....
        self.handleEvent(event, self)

        # The "NOTIFY_ALL" guys get priority
        for notifier in alllist:
            try:
                notifier.handleEvent(event,trace)
            except:
                print "WARNING: Notifier exception for",repr(notifier)
                traceback.print_exc()

        for notifier in nlist:
            try:
                notifier.handleEvent(event,trace)
            except:
                print "WARNING: Notifier exception for",repr(notifier)
                traceback.print_exc()

    def _cleanupBreakpoints(self):
        '''
        Cleanup all breakpoints (if the current bp is "fastbreak" this routine
        will not be called...
        '''
        for bp in self.breakpoints.itervalues():
            bp.deactivate(self)

    def _fireStep(self):
        if self.getMode('FastStep', False):
            return
        self.fireNotifiers(vtrace.NOTIFY_STEP)

    def _fireBreakpoint(self, bp):

        self.curbp = bp

        # A breakpoint should be inactive when fired
        # (even fastbreaks, we'll need to deactivate for stepi anyway)
        bp.deactivate(self)

        try:
            bp.notify(vtrace.NOTIFY_BREAK, self)
        except Exception, msg:
            print "Breakpoint Exception 0x%.8x : %s" % (bp.address,msg)

        if not bp.fastbreak:
            self.fireNotifiers(vtrace.NOTIFY_BREAK)

        else:
            # fastbreak's are basically always "run again"
            self.runagain = True

    def checkPageWatchpoints(self):
        """
        Check if the given memory fault was part of a valid
        MapWatchpoint.
        """
        faultaddr,faultperm = self.platformGetMemFault()

        #FIXME this is some AWESOME but intel specific nonsense
        if faultaddr == None: return False
        faultpage = faultaddr & 0xfffff000

        wp = self.breakpoints.get(faultpage, None)
        if wp == None:
            return False

        self._fireBreakpoint(wp)

        return True

    def checkWatchpoints(self):
        # Check for hardware watchpoints
        waddr = self.archCheckWatchpoints()
        if waddr != None:
            wp = self.breakpoints.get(waddr, None)
            self._fireBreakpoint(wp)
            return True

    def checkBreakpoints(self):
        """
        This is mostly for systems (like linux) where you can't tell
        the difference between some SIGSTOP/SIGBREAK conditions and
        an actual breakpoint instruction.

        This method will return true if either the breakpoint
        subsystem or the sendBreak (via ShouldBreak meta) is true
        (and it will have handled firing events for the bp)
        """
        pc = self.getProgramCounter()
        bi = self.archGetBreakInstr()
        bl = pc - len(bi)
        bp = self.breakpoints.get(bl, None)

        if bp:
            addr = bp.getAddress()
            # Step back one instruction to account break
            self.setProgramCounter(addr)
            self._fireBreakpoint(bp)
            return True

        if self.getMeta("ShouldBreak"):
            self.setMeta("ShouldBreak", False)
            self.fireNotifiers(vtrace.NOTIFY_BREAK)
            return True

        return False

    def notify(self, event, trace):
        """
        We are frequently a notifier for ourselves, so we can do things
        like handle events on attach and on break in a unified fashion.
        """
        self.threadcache = None
        self.mapcache = None
        self.fds = None
        self.running = False

        if event in self.auto_continue:
            self.runAgain()

        # For thread exits, make sure the tid
        # isn't in 
        if event == vtrace.NOTIFY_EXIT_THREAD:
            tid = self.getMeta("ThreadId")
            self.sus_threads.pop(tid, None)
            # Check if this is a thread we were waiting on.
            if tid == self._join_thread:
                self._join_thread = None
                # Turn off the RunForever in joinThread()
                self.setMode('RunForever', False)
                # Either way, we don't want to run again...
                self.runAgain(False)

        # Do the stuff we do for detach/exit or
        # cleanup breaks etc...
        if event == vtrace.NOTIFY_ATTACH:
            pass

        elif event == vtrace.NOTIFY_DETACH:
            for tid in self.sus_threads.keys():
                self.resumeThread(tid)
            self._cleanupBreakpoints()

        elif event == vtrace.NOTIFY_EXIT:
            self.setMode("RunForever", False)
            self.exited = True
            self.attached = False

        elif event == vtrace.NOTIFY_CONTINUE:
            self.runagain = False

        else:
            self._cleanupBreakpoints()

    def delLibraryBase(self, baseaddr):

        libname = self.getMeta("LibraryPaths").get(baseaddr, "unknown")
        normname = self.normFileName(libname)

        sym = self.getSymByName(normname)

        self.setMeta("LatestLibrary", libname)
        self.setMeta("LatestLibraryNorm", normname)

        self.fireNotifiers(vtrace.NOTIFY_UNLOAD_LIBRARY)

        self.getMeta("LibraryBases").pop(normname, None)
        self.getMeta("LibraryPaths").pop(baseaddr, None)
        if sym != None:
            self.delSymbol(sym)

    def addLibraryBase(self, libname, address, always=False):
        """
        This should be used *at load time* to setup the library
        event metadata.

        This *must* be called from a context where it's safe to
        fire notifiers, because it will fire a notifier to alert
        about a LOAD_LIBRARY. (This means *not* from inside another
        notifer)
        """

        self.setMeta("LatestLibrary", None)
        self.setMeta("LatestLibraryNorm", None)

        normname = self.normFileName(libname)
        if self.getSymByName(normname) != None:
            normname = "%s_%.8x" % (normname,address)

        # Only actually do library work with a file or force
        if os.path.exists(libname) or always:

            self.getMeta("LibraryPaths")[address] = libname
            self.getMeta("LibraryBases")[normname] = address
            self.setMeta("LatestLibrary", libname)
            self.setMeta("LatestLibraryNorm", normname)

            width = self.arch.getPointerSize()
            sym = e_resolv.FileSymbol(normname, address, 0, width=width)
            sym.casesens = self.casesens
            self.addSymbol(sym)

            self.libpaths[normname] = libname

            self.fireNotifiers(vtrace.NOTIFY_LOAD_LIBRARY)

    def normFileName(self, libname):
        basename = os.path.basename(libname)
        return basename.split(".")[0].split("-")[0].lower()

    def _loadBinaryNorm(self, normname):
        if not self.libloaded.get(normname, False):
            fname = self.libpaths.get(normname)
            if fname != None:
                self._loadBinary(fname)
                return True
        return False

    def _loadBinary(self, filename):
        """
        Check if a filename has yet to be parsed.  If it has NOT
        been parsed, parse it and return True, otherwise, return False
        """
        normname = self.normFileName(filename)
        if not self.libloaded.get(normname, False):
            address = self.getMeta("LibraryBases").get(normname)
            if address != None:
                self.platformParseBinary(filename, address, normname)
                self.libloaded[normname] = True
                return True
        return False

#######################################################################
#
# NOTE: all platform/arch defaults are populated here.
#
    def platformGetThreads(self):
        """
        Return a dictionary of <threadid>:<tinfo> pairs where tinfo is either
        the stack top, or the teb for win32
        """
        raise Exception("Platform must implement platformGetThreads()")

    def platformSelectThread(self, thrid):
        """
        Platform implementers are encouraged to use the metadata field "ThreadId"
        as the identifier (int) for which thread has "focus".  Additionally, the
        field "StoppedThreadId" should be used in instances (like win32) where you
        must specify the ORIGINALLY STOPPED thread-id in the continue.
        """
        self.setMeta("ThreadId",thrid)

    def platformSuspendThread(self, thrid):
        raise Exception("Platform must implement platformSuspendThread()")

    def platformResumeThread(self, thrid):
        raise Exception("Platform must implement platformResumeThread()")

    def platformInjectThread(self, pc, arg=0):
        raise Exception("Platform must implement platformInjectThread()")

    def platformKill(self):
        raise Exception("Platform must implement platformKill()")

    def platformExec(self, cmdline):
        """
        Platform exec will execute the process specified in cmdline
        and return the PID
        """
        raise Exception("Platmform must implement platformExec")

    def platformInjectSo(self, filename):
        raise Exception("Platform must implement injectso()")

    def platformGetFds(self):
        """
        Return what getFds() wants for this particular platform
        """
        raise Exception("Platform must implement platformGetFds()")

    def platformGetSignal(self):
        '''
        Return the currently posted exception/signal....
        '''
        # Default to the thing they all should do...
        return self.getMeta('PendingSignal', None)

    def platformSetSignal(self, sig=None):
        '''
        Set the current signal to deliver to the process on cont.
        (Use None for no signal delivery.
        '''
        self.setMeta('PendingSignal', sig)

    def platformGetMaps(self):
        """
        Return a list of the memory maps where each element has
        the following structure:
        (address, length, perms, file="")
        NOTE: By Default this list is available as Trace.maps
        because the default implementation attempts to populate
        them on every break/stop/etc...
        """
        raise Exception("Platform must implement GetMaps")

    def platformPs(self):
        """
        Actually return a list of tuples in the format
        (pid, name) for this platform
        """
        raise Exception("Platform must implement Ps")

    def archGetStackTrace(self):
        raise Exception("Architecure must implement argGetStackTrace()!")

    def archAddWatchpoint(self, address, size=4, perms="rw"):
        """
        Add a watchpoint for the given address.  Raise if the platform
        doesn't support, or too many are active...
        """
        raise Exception("Architecture doesn't implement watchpoints!")

    def archRemWatchpoint(self, address):
        raise Exception("Architecture doesn't implement watchpoints!")

    def archCheckWatchpoints(self):
        """
        If the current register state indicates that a watchpoint was hit, 
        return the address of the watchpoint and clear the event.  Otherwise
        return None
        """
        pass

    def archGetRegCtx(self):
        """
        Return a new empty envi.registers.RegisterContext object for this
        trace.
        """
        raise Exception("Platform must implement archGetRegCtx()")

    def getStackTrace(self):
        """
        Return a list of the stack frames for this process
        (currently Intel/ebp based only).  Each element of the
        "frames list" consists of another list which is (eip,ebp)
        """
        raise Exception("Platform must implement getStackTrace()")

    def getExe(self):
        """
        Get the full path to the main executable for this
        *attached* Trace
        """
        return self.getMeta("ExeName","Unknown")

    def platformAttach(self, pid):
        """
        Actually carry out attaching to a target process.  Like
        platformStepi this is expected to be ATOMIC and not return
        until a complete attach.
        """
        raise Exception("Platform must implement platformAttach()")

    def platformContinue(self):
        raise Exception("Platform must implement platformContinue()")

    def platformDetach(self):
        """
        Actually perform the detach for this type
        """
        raise Exception("Platform must implement platformDetach()")

    def platformStepi(self):
        """
        PlatformStepi should be ATOMIC, meaning it gets called, and
        by the time it returns, you're one step further.  This is completely
        regardless of blocking/nonblocking/whatever.
        """
        raise Exception("Platform must implement platformStepi!")

    def platformCall(self, address, args, convention=None):
        """
        Platform call takes an address, and an array of args
        (string types will be mapped and located for you)

        platformCall is expected to return a dicionary of the
        current register values at the point where the call
        has returned...
        """
        raise Exception("Platform must implement platformCall")

    def platformGetRegCtx(self, threadid):
        raise Exception("Platform must implement platformGetRegCtx!")

    def platformSetRegCtx(self, threadid, ctx):
        raise Exception("Platform must implement platformSetRegCtx!")

    def platformProtectMemory(self, va, size, perms):
        raise Exception("Plaform does not implement protect memory")
        
    def platformAllocateMemory(self, size, perms=e_mem.MM_RWX, suggestaddr=0):
        raise Exception("Plaform does not implement allocate memory")
        
    def platformReadMemory(self, address, size):
        raise Exception("Platform must implement platformReadMemory!")
        
    def platformWriteMemory(self, address, bytes):
        raise Exception("Platform must implement platformWriteMemory!")

    def platformGetMemFault(self):
        """
        Return the addr of the current memory fault
        or None
        """
        #NOTE: This is used by the PageWatchpoint subsystem
        # (and is still considered experimental)
        return None,None

    def platformWait(self):
        """
        Wait for something interesting to occur and return a
        *platform specific* representation of what happened.

        This will then be passed to the platformProcessEvent()
        method which will be responsible for doing things like
        firing notifiers.  Because the platformWait() method needs
        to be commonly @threadwrap and you can't fire notifiers
        from within a threadwrapped function...
        """
        raise Exception("Platform must implement platformWait!")

    def platformProcessEvent(self, event):
        """
        This method processes the event data provided by platformWait()

        This method is responsible for firing ALL notifiers *except*:

        vtrace.NOTIFY_CONTINUE - This is handled by the run api (and isn't the result of an event)
        """
        raise Exception("Platform must implement platformProcessEvent")

    def platformParseBinary(self, filename, baseaddr, normname):
        """
        Platforms must parse the given binary file and load any symbols
        into the internal SymbolResolver using self.addSymbol()
        """
        raise Exception("Platform must implement platformParseBinary")

import threading
def threadwrap(func):
    def trfunc(self, *args, **kwargs):
        if threading.currentThread().__class__ == TracerThread:
            return func(self, *args, **kwargs)
        # Proxy the call through a single thread
        q = Queue()
        # FIXME change calling convention!
        args = (self, ) + args
        self.thread.queue.put((func, args, kwargs, q))
        ret = q.get()
        if issubclass(ret.__class__, Exception):
            raise ret
        return ret
    return trfunc

class TracerThread(Thread):
    """
    Ok... so here's the catch... most debug APIs do *not* allow
    one thread to do the attach and another to do continue and another
    to do wait... they just dont.  So there.  I have to make a thread
    per-tracer (on most platforms) and proxy requests (for *some* trace
    API methods) to it for actual execution.  SUCK!

    However, this lets async things like GUIs and threaded things like
    cobra not have to be aware of which one is allowed and not allowed
    to make particular calls and on what platforms...  YAY!
    """
    def __init__(self):
        Thread.__init__(self)
        self.queue = Queue()
        self.setDaemon(True)
        self.start()

    def run(self):
        """
        Run in a circle getting requests from our queue and
        executing them based on the thread.
        """
        while True:
            try:
                qobj = self.queue.get()
                if qobj == None:
                    break
                meth, args, kwargs, queue = qobj
                try:
                    queue.put(meth(*args, **kwargs))
                except Exception,e:
                    queue.put(e)
                    if vtrace.verbose:
                        traceback.print_exc()
                    continue
            except:
                if vtrace.verbose:
                    traceback.print_exc()

########NEW FILE########
__FILENAME__ = freebsd
"""
FreeBSD support...
"""

import os
import ctypes
import ctypes.util as cutil

import envi.memory as e_mem
import envi.cli as e_cli

import vtrace
import vtrace.archs.i386 as v_i386
import vtrace.archs.amd64 as v_amd64
import vtrace.platforms.base as v_base
import vtrace.platforms.posix as v_posix
import vtrace.util as v_util

libkvm = ctypes.CDLL(cutil.find_library("kvm"))

# kvm_getprocs cmds
KERN_PROC_ALL           = 0       # everything
KERN_PROC_PID           = 1       # by process id
KERN_PROC_PGRP          = 2       # by process group id
KERN_PROC_SESSION       = 3       # by session of pid
KERN_PROC_TTY           = 4       # by controlling tty
KERN_PROC_UID           = 5       # by effective uid
KERN_PROC_RUID          = 6       # by real uid
KERN_PROC_ARGS          = 7       # get/set arguments/proctitle
KERN_PROC_PROC          = 8       # only return procs
KERN_PROC_SV_NAME       = 9       # get syscall vector name
KERN_PROC_RGID          = 10      # by real group id
KERN_PROC_GID           = 11      # by effective group id
KERN_PROC_PATHNAME      = 12      # path to executable
KERN_PROC_INC_THREAD    = 0x10    # Include threads in filtered results

pid_t = ctypes.c_int32
lwpid_t = ctypes.c_int32
void_p = ctypes.c_void_p
dev_t = ctypes.c_uint32
sigset_t = ctypes.c_uint32*4
uid_t = ctypes.c_uint32
gid_t = ctypes.c_uint32
fixpt_t = ctypes.c_uint32
caddr_t = ctypes.c_void_p
vm_size_t = ctypes.c_ulong
segsz_t = ctypes.c_ulong

# Could go crazy and grep headers for this stuff ;)
KI_NGROUPS = 16
OCOMMLEN = 16
WMESGLEN = 8
LOGNAMELEN = 17
LOCKNAMELEN = 8
COMMLEN = 19
KI_EMULNAMELEN = 16
KI_NSPARE_INT = 10
KI_NSPARE_PTR = 7
KI_NSPARE_LONG = 12


def c_buf(size):
    return ctypes.c_char * size

class PRIORITY(ctypes.Structure):
    _fields_ = (
        ("pri_class", ctypes.c_ubyte),
        ("pri_level", ctypes.c_ubyte),
        ("pri_native", ctypes.c_ubyte),
        ("pri_user", ctypes.c_ubyte)
    )

class TIMEVAL(ctypes.Structure):
    _fields_ = (
        ("tv_sec", ctypes.c_long),
        ("tv_usec", ctypes.c_long)
    )

class RUSAGE(ctypes.Structure):
    _fields_ = (
        ("ru_utime", TIMEVAL),          # user time used
        ("ru_stime", TIMEVAL),          # system time used
        ("ru_maxrss", ctypes.c_long),   #
        ("ru_ixrss", ctypes.c_long),    # (j) integral shared memory size
        ("ru_idrss", ctypes.c_long),    # (j) integral unshared data
        ("ru_isrss", ctypes.c_long),    # (j) integral unshared stack
        ("ru_minflt", ctypes.c_long),   # (c) page reclaims
        ("ru_majflt", ctypes.c_long),   # (c) page faults
        ("ru_nswap", ctypes.c_long),    # (c + j) swaps
        ("ru_inblock", ctypes.c_long),  # (n) block input operations
        ("ru_oublock", ctypes.c_long),  # (n) block output operations
        ("ru_msgsnd", ctypes.c_long),   # (n) messages sent
        ("ru_msgrcv", ctypes.c_long),   # (n) messages received
        ("ru_nsignals", ctypes.c_long), # (c) signals received
        ("ru_nvcsw", ctypes.c_long),    # (j) voluntary context switches
        ("ru_nivcsw", ctypes.c_long),   # (j) involuntary
    )


class KINFO_PROC(ctypes.Structure):
    _fields_ = (
        ("ki_structsize", ctypes.c_int),# size of this structure
        ("ki_layout", ctypes.c_int),    # reserved: layout identifier
        ("ki_args", void_p),            # address of command arguments (struct pargs*)
        ("ki_paddr", void_p),           # address of proc (struct proc*)
        ("ki_addr", void_p),            # kernel virtual addr of u-area (struct user*)
        ("ki_tracep", void_p),          # pointer to trace file (struct vnode *)
        ("ki_textvp", void_p),          # pointer to executable file (struct vnode *)
        ("ki_fd", void_p),              # pointer to open file info (struct filedesc  *)
        ("ki_vmspace", void_p),         # pointer to kernel vmspace struct (struct vmspace *)
        ("ki_wchan", void_p),           # sleep address (void*)
        ("ki_pid", pid_t),              # Process identifier
        ("ki_ppid", pid_t),             # parent process id
        ("ki_pgid", pid_t),             # process group id
        ("ki_tpgid", pid_t),            # tty process group id
        ("ki_sid", pid_t),              # Process session ID
        ("ki_tsid", pid_t),             # Terminal session ID
        ("ki_jobc", ctypes.c_short),    # job control counter
        ("ki_spare_short1", ctypes.c_short), #
        ("ki_tdev", dev_t),             # controlling tty dev
        ("ki_siglist", sigset_t),       # Signals arrived but not delivered
        ("ki_sigmask", sigset_t),       # Current signal mask
        ("ki_sigignore", sigset_t),     # Signals being ignored
        ("ki_sigcatch", sigset_t),      # Signals being caught by user
        ("ki_uid", uid_t),              # effective user id
        ("ki_ruid", uid_t),             # Real user id
        ("ki_svuid", uid_t),            # Saved effective user id
        ("ki_rgid", gid_t),             # Real group id
        ("ki_svgid", gid_t),            # Saved effective group id
        ("ki_ngroups", ctypes.c_short), # number of groups
        ("ki_spare_short2", ctypes.c_short),
        ("ki_groups", gid_t * KI_NGROUPS), # groups
        ("ki_size", vm_size_t),         # virtual size
        ("ki_rssize", segsz_t),         # current resident set size in pages
        ("ki_swrss", segsz_t),          # resident set size before last swap
        ("ki_tsize", segsz_t),          # text size (pages) XXX
        ("ki_dsize", segsz_t),          # data size (pages) XXX
        ("ki_ssize", segsz_t),          # stack size (pages)
        ("ki_xstat", ctypes.c_ushort),  # Exit status for wait and stop signal
        ("ki_acflag", ctypes.c_ushort), # Accounting flags
        ("ki_pctcpu", fixpt_t),         # %cpu for process during ki_swtime
        ("ki_estcpu", ctypes.c_uint),   # Time averaged value of ki_cpticks
        ("ki_slptime", ctypes.c_uint),  # Time since last blocked
        ("ki_swtime", ctypes.c_uint),   # Time swapped in or out
        ("ki_spareint1", ctypes.c_int), # unused (just here for alignment)
        ("ki_runtime", ctypes.c_uint64),# Real time in microsec
        ("ki_start", TIMEVAL),          # starting time
        ("ki_childtime", TIMEVAL),      # time used by process children
        ("ki_flag", ctypes.c_long),     # P_* flags
        ("ki_kiflag", ctypes.c_long),   # KI_* flags
        ("ki_traceflag", ctypes.c_int), # kernel trace points
        ("ki_stat", ctypes.c_char),     # S* process status
        ("ki_nice", ctypes.c_ubyte),    # Process "nice" value
        ("ki_lock", ctypes.c_char),     # Process lock (prevent swap) count
        ("ki_rqindex", ctypes.c_char),  # Run queue index
        ("ki_oncpu", ctypes.c_char),    # Which cpu we are on
        ("ki_lastcpu", ctypes.c_char),  # Last cpu we were on
        ("ki_ocomm", c_buf(OCOMMLEN+1)),      # command name
        ("ki_wmesg", c_buf(WMESGLEN+1)),      # wchan message
        ("ki_login", c_buf(LOGNAMELEN+1)),    # setlogin name
        ("ki_lockname", c_buf(LOCKNAMELEN+1)),# lock name
        ("ki_comm", c_buf(COMMLEN+1)),        # command name
        ("ki_emul", c_buf(KI_EMULNAMELEN+1)), # emulation name
        ("ki_sparestrings",c_buf(68)),   # spare string space
        ("ki_spareints", ctypes.c_int*KI_NSPARE_INT),
        ("ki_jid", ctypes.c_int),       # Process jail ID
        ("ki_numthreads", ctypes.c_int),# KSE number of total threads
        ("ki_tid", lwpid_t),            # thread id
        ("ki_pri", PRIORITY),           # process priority
        ("ki_rusage", RUSAGE),          # process rusage statistics
        # XXX - most fields in ki_rusage_ch are not (yet) filled in
        ("ki_rusage_ch", RUSAGE),       # rusage of children processes
        ("ki_pcb", void_p),             # kernel virtual addr of pcb
        ("ki_kstack", void_p),          # kernel virtual addr of stack
        ("ki_udata", void_p),           # User convenience pointer
        ("ki_spareptrs", void_p*KI_NSPARE_PTR),
        ("ki_sparelongs", ctypes.c_long*KI_NSPARE_LONG),
        ("ki_sflag", ctypes.c_long),    # PS_* flags
        ("ki_tdflags", ctypes.c_long),  # KSE kthread flag
    )

libkvm.kvm_getprocs.argtypes = [caddr_t, ctypes.c_int, ctypes.c_int, caddr_t]
libkvm.kvm_getprocs.restype = ctypes.POINTER(KINFO_PROC)

libkvm.kvm_open.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int, ctypes.c_char_p]
libkvm.kvm_open.restype = caddr_t

# All the FreeBSD ptrace defines
PT_TRACE_ME     = 0       #/* child declares it's being traced */
PT_READ_I       = 1       #/* read word in child's I space */
PT_READ_D       = 2       #/* read word in child's D space */
PT_WRITE_I      = 4       #/* write word in child's I space */
PT_WRITE_D      = 5       #/* write word in child's D space */
PT_CONTINUE     = 7       #/* continue the child */
PT_KILL         = 8       #/* kill the child process */
PT_STEP         = 9       #/* single step the child */
PT_ATTACH       = 10      #/* trace some running process */
PT_DETACH       = 11      #/* stop tracing a process */
PT_IO           = 12      #/* do I/O to/from stopped process. */
PT_LWPINFO      = 13      #/* Info about the LWP that stopped. */
PT_GETNUMLWPS   = 14      #/* get total number of threads */
PT_GETLWPLIST   = 15      #/* get thread list */
PT_CLEARSTEP    = 16      #/* turn off single step */
PT_SETSTEP      = 17      #/* turn on single step */
PT_SUSPEND      = 18      #/* suspend a thread */
PT_RESUME       = 19      #/* resume a thread */
PT_TO_SCE       = 20      # Stop on syscall entry
PT_TO_SCX       = 21      # Stop on syscall exit
PT_SYSCALL      = 22      # Stop on syscall entry and exit
PT_GETREGS      = 33      #/* get general-purpose registers */
PT_SETREGS      = 34      #/* set general-purpose registers */
PT_GETFPREGS    = 35      #/* get floating-point registers */
PT_SETFPREGS    = 36      #/* set floating-point registers */
PT_GETDBREGS    = 37      #/* get debugging registers */
PT_SETDBREGS    = 38      #/* set debugging registers */
#PT_FIRSTMACH    = 64      #/* for machine-specific requests */

# On PT_IO addr is a pointer to a struct

class PTRACE_IO_DESC(ctypes.Structure):
    _fields_ = [
        ("piod_op", ctypes.c_int),      # I/O operation
        ("piod_offs", ctypes.c_void_p), # Child offset
        ("piod_addr", ctypes.c_void_p), # Parent Offset
        ("piod_len", ctypes.c_uint)     # Size
    ]

# Operations in piod_op.
PIOD_READ_D     = 1       # Read from D space
PIOD_WRITE_D    = 2       # Write to D space
PIOD_READ_I     = 3       # Read from I space
PIOD_WRITE_I    = 4       # Write to I space

class PTRACE_LWPINFO(ctypes.Structure):
    _fields_ = (
        ("pl_lwpid", lwpid_t),
        ("pl_event", ctypes.c_int),
        ("pl_flags", ctypes.c_int),
        ("pl_sigmask", sigset_t),
        ("pl_siglist", sigset_t),
    )

PL_EVENT_NONE   = 0
PL_EVENT_SIGNAL = 1

PL_FLAGS_SA    = 0
PL_FLAGS_BOUND = 1

class FreeBSDMixin:

    def __init__(self):
        self.initMode("Syscall", False, "Break on Syscalls")
        self.kvmh = libkvm.kvm_open(None, None, None, 0, "vtrace")
        if not os.path.exists('/proc/curproc/file'):
            raise Exception("VDB needs /proc! (use: mount -t procfs procfs /proc)")

    def finiMixin(self):
        print "FIXME I DON'T THINK THIS IS BEING CALLED"
        if self.kvmh != None:
            libkvm.kvm_close(self.kvmh)

    def platformReadMemory(self, address, size):
        #FIXME optimize for speed!
        iod = PTRACE_IO_DESC()
        buf = ctypes.create_string_buffer(size)

        iod.piod_op = PIOD_READ_D
        iod.piod_addr = ctypes.addressof(buf)
        iod.piod_offs = address
        iod.piod_len = size

        if v_posix.ptrace(PT_IO, self.pid, ctypes.addressof(iod), 0) != 0:
            raise Exception("ptrace PT_IO failed to read 0x%.8x" % address)

        return buf.raw

    def platformWriteMemory(self, address, buf):
        #FIXME optimize for speed!
        iod = PTRACE_IO_DESC()

        cbuf = ctypes.create_string_buffer(buf)

        iod.piod_op = PIOD_WRITE_D
        iod.piod_addr = ctypes.addressof(cbuf)
        iod.piod_offs = address
        iod.piod_len = len(buf)

        if v_posix.ptrace(PT_IO, self.pid, ctypes.addressof(iod), 0) != 0:
            raise Exception("ptrace PT_IO failed to read 0x%.8x" % address)

    @v_base.threadwrap
    def platformAttach(self, pid):
        if v_posix.ptrace(PT_ATTACH, pid, 0, 0) != 0:
            raise Exception("Ptrace Attach Failed")

    def _getExeName(self, pid):
        return os.readlink('/proc/%d/file' % pid)

    #@v_base.threadwrap
    def platformExec(self, cmdline):
        # Basically just like the one in the Ptrace mixin...
        self.execing = True
        cmdlist = e_cli.splitargs(cmdline)
        os.stat(cmdlist[0])
        pid = os.fork()
        if pid == 0:
            v_posix.ptrace(PT_TRACE_ME, 0, 0, 0)
            os.execv(cmdlist[0], cmdlist)
            sys.exit(-1)
        return pid

    def handleAttach(self):
        self.setMeta('ExeName', self._getExeName(self.pid))
        return v_posix.PosixMixin.handleAttach(self)

    @v_base.threadwrap
    def platformWait(self):
        status = v_posix.PosixMixin.platformWait(self)
        # Get the thread id from the ptrace interface

        info = PTRACE_LWPINFO()
        size = ctypes.sizeof(info)
        if v_posix.ptrace(PT_LWPINFO, self.pid, ctypes.addressof(info), size) == 0:
            self.setMeta("ThreadId", info.pl_lwpid)
        else:
            #FIXME this is because posix wait is linux specific and broke
            self.setMeta("ThreadId", self.pid)

        return status

    @v_base.threadwrap
    def platformStepi(self):
        self.stepping = True
        if v_posix.ptrace(PT_STEP, self.pid, 1, 0) != 0:
            raise Exception("ptrace PT_STEP failed!")

    @v_base.threadwrap
    def platformContinue(self):
        cmd = PT_CONTINUE
        if self.getMode("Syscall"):
            cmd = PT_SYSCALL

        sig = self.getCurrentSignal()
        if sig == None:
            sig = 0
        # In freebsd address is the place to continue from
        # but 1 means use existing EIP
        if v_posix.ptrace(cmd, self.pid, 1, sig) != 0:
            raise Exception("ptrace PT_CONTINUE/PT_SYSCALL failed")

    @v_base.threadwrap
    def platformDetach(self):
        if v_posix.ptrace(PT_DETACH, self.pid, 1, 0) != 0:
            raise Exception("Ptrace Detach Failed")

    @v_base.threadwrap
    def platformGetThreads(self):
        ret = {}
        cnt = self._getThreadCount()
        buf = (ctypes.c_int * cnt)()
        if v_posix.ptrace(PT_GETLWPLIST, self.pid, ctypes.addressof(buf), cnt) != cnt:
            raise Exception("ptrace PW_GETLWPLIST failed")
        for x in buf:
            ret[x] = x
        return ret

    @v_base.threadwrap
    def platformSuspendThread(self, tid):
        if v_posix.ptrace(PT_SUSPEND, tid, 0, 0) != 0:
            raise Exception("ptrace PT_SUSPEND failed!")

    @v_base.threadwrap
    def platformResumeThread(self, tid):
        if v_posix.ptrace(PT_RESUME, tid, 0, 0) != 0:
            raise Exception("ptrace PT_RESUME failed!")

    def _getThreadCount(self):
        return v_posix.ptrace(PT_GETNUMLWPS, self.pid, 0, 0)

    def platformGetFds(self):
        return []

    def platformGetMaps(self):
        # FIXME make this not need proc
        ret = []
        mpath = "/proc/%d/map" % self.pid

        mapfile = file(mpath, "rb")
        for line in mapfile:
            perms = 0
            fname = ""
            maptup = line.split(None)
            base = int(maptup[0], 16)
            max  = int(maptup[1], 16)
            permstr = maptup[5]

            if maptup[11] == "vnode":
                fname = maptup[12].strip()

            if permstr[0] == 'r':
                perms |= e_mem.MM_READ

            if permstr[1] == 'w':
                perms |= e_mem.MM_WRITE

            if permstr[2] == 'x':
                perms |= e_mem.MM_EXEC

            ret.append((base, max-base, perms, fname))

        return ret

    def platformPs(self):
        ret = []
        cnt = ctypes.c_uint(0)

        p = libkvm.kvm_getprocs(self.kvmh, KERN_PROC_PROC, 0, ctypes.addressof(cnt))
        for i in xrange(cnt.value):
            kinfo = p[i]
            if kinfo.ki_structsize != ctypes.sizeof(KINFO_PROC):
                print "WARNING: KINFO_PROC CHANGED SIZE, Trying to account for it... good luck"
            ret.append((kinfo.ki_pid, kinfo.ki_comm))

        ret.reverse()
        return ret

class bsd_regs_i386(ctypes.Structure):
    _fields_ = (
        ("fs",  ctypes.c_ulong),
        ("es",  ctypes.c_ulong),
        ("ds",  ctypes.c_ulong),
        ("edi",  ctypes.c_ulong),
        ("esi",  ctypes.c_ulong),
        ("ebp",  ctypes.c_ulong),
        ("isp",  ctypes.c_ulong),
        ("ebx",  ctypes.c_ulong),
        ("edx",  ctypes.c_ulong),
        ("ecx",  ctypes.c_ulong),
        ("eax",  ctypes.c_ulong),
        ("trapno",  ctypes.c_ulong),
        ("err",  ctypes.c_ulong),
        ("eip",  ctypes.c_ulong),
        ("cs",  ctypes.c_ulong),
        ("eflags",  ctypes.c_ulong),
        ("esp",  ctypes.c_ulong),
        ("ss",  ctypes.c_ulong),
        ("gs",  ctypes.c_ulong),
        ("debug0",  ctypes.c_ulong),
        ("debug1",  ctypes.c_ulong),
        ("debug2",  ctypes.c_ulong),
        ("debug3",  ctypes.c_ulong),
        ("debug4",  ctypes.c_ulong),
        ("debug5",  ctypes.c_ulong),
        ("debug6",  ctypes.c_ulong),
        ("debug7",  ctypes.c_ulong),
    )

i386_DBG_OFF = (19*4)

class bsd_regs_amd64(ctypes.Structure):
    _fields_ = (
        ("r15", ctypes.c_ulonglong),
        ("r14", ctypes.c_ulonglong),
        ("r13", ctypes.c_ulonglong),
        ("r12", ctypes.c_ulonglong),
        ("r11", ctypes.c_ulonglong),
        ("r10", ctypes.c_ulonglong),
        ("r9", ctypes.c_ulonglong),
        ("r8", ctypes.c_ulonglong),
        ("rdi", ctypes.c_ulonglong),
        ("rsi", ctypes.c_ulonglong),
        ("rbp", ctypes.c_ulonglong),
        ("rbx", ctypes.c_ulonglong),
        ("rdx", ctypes.c_ulonglong),
        ("rcx", ctypes.c_ulonglong),
        ("rax", ctypes.c_ulonglong),
        ("trapno", ctypes.c_ulonglong),
        ("err", ctypes.c_ulonglong),
        ("rip", ctypes.c_ulonglong),
        ("cs", ctypes.c_ulonglong),
        ("rflags", ctypes.c_ulonglong),
        ("rsp", ctypes.c_ulonglong),
        ("ss", ctypes.c_ulonglong),
        ("debug0", ctypes.c_ulonglong),
        ("debug1", ctypes.c_ulonglong),
        ("debug2", ctypes.c_ulonglong),
        ("debug3", ctypes.c_ulonglong),
        ("debug4", ctypes.c_ulonglong),
        ("debug5", ctypes.c_ulonglong),
        ("debug6", ctypes.c_ulonglong),
        ("debug7", ctypes.c_ulonglong),
        ("debug8", ctypes.c_ulonglong),
        ("debug9", ctypes.c_ulonglong),
        ("debug10", ctypes.c_ulonglong),
        ("debug11", ctypes.c_ulonglong),
        ("debug12", ctypes.c_ulonglong),
        ("debug13", ctypes.c_ulonglong),
        ("debug14", ctypes.c_ulonglong),
        ("debug15", ctypes.c_ulonglong),
    )

amd64_DBG_OFF = (22*ctypes.sizeof(ctypes.c_uint64))

class FreeBSDi386Trace(
    vtrace.Trace,
    FreeBSDMixin,
    v_i386.i386Mixin,
    v_posix.ElfMixin,
    v_posix.PosixMixin,
    v_base.TracerBase):

    def __init__(self):
        vtrace.Trace.__init__(self)
        v_base.TracerBase.__init__(self)
        v_posix.ElfMixin.__init__(self)
        v_posix.PosixMixin.__init__(self)
        v_i386.i386Mixin.__init__(self)
        FreeBSDMixin.__init__(self)

    @v_base.threadwrap
    def platformGetRegCtx(self, tid):
        ctx = self.archGetRegCtx()
        u = bsd_regs_i386()

        addr = ctypes.addressof(u)
        if v_posix.ptrace(PT_GETREGS, tid, addr, 0) != 0:
            raise Exception("ptrace PT_GETREGS failed!")
        if v_posix.ptrace(PT_GETDBREGS, tid, addr+i386_DBG_OFF, 0) != 0:
            raise Exception("ptrace PT_GETDBREGS failed!")

        ctx._rctx_Import(u)

        return ctx

    @v_base.threadwrap
    def platformSetRegCtx(self, tid, ctx):
        u = bsd_regs_i386()
        ctx._rctx_Export(u)
        addr = ctypes.addressof(u)
        if v_posix.ptrace(PT_SETREGS, self.pid, addr, 0) != 0:
            raise Exception("ptrace PT_SETREGS failed!")
        if v_posix.ptrace(PT_SETDBREGS, self.pid, addr+i386_DBG_OFF, 0) != 0:
            raise Exception("ptrace PT_SETDBREGS failed!")


class FreeBSDAmd64Trace(
    vtrace.Trace,
    FreeBSDMixin,
    v_amd64.Amd64Mixin,
    v_posix.ElfMixin,
    v_posix.PosixMixin,
    v_base.TracerBase):

    def __init__(self):
        vtrace.Trace.__init__(self)
        v_base.TracerBase.__init__(self)
        v_posix.ElfMixin.__init__(self)
        v_posix.PosixMixin.__init__(self)
        v_amd64.Amd64Mixin.__init__(self)
        FreeBSDMixin.__init__(self)

    def _getAmdRegsStruct(self, tid):
        '''
        Get (and populate) a register structure
        (even set regs needs to get it first...)
        '''
        u = bsd_regs_amd64()
        addr = ctypes.addressof(u)
        if v_posix.ptrace(PT_GETREGS, tid, addr, 0) != 0:
            raise Exception("ptrace PT_GETREGS failed!")
        if v_posix.ptrace(PT_GETDBREGS, tid, addr+amd64_DBG_OFF, 0) != 0:
            raise Exception("ptrace PT_GETDBREGS failed!")
        return u

    @v_base.threadwrap
    def platformGetRegCtx(self, tid):
        ctx = self.archGetRegCtx()
        u = self._getAmdRegsStruct(tid)
        ctx._rctx_Import(u)
        return ctx

    @v_base.threadwrap
    def platformSetRegCtx(self, tid, ctx):
        u = self._getAmdRegsStruct(tid)
        ctx._rctx_Export(u)
        addr = ctypes.addressof(u)
        if v_posix.ptrace(PT_SETREGS, tid, addr, 0) != 0:
            raise Exception("ptrace PT_SETREGS failed!")
        if v_posix.ptrace(PT_SETDBREGS, tid, addr+amd64_DBG_OFF, 0) != 0:
            raise Exception("ptrace PT_SETDBREGS failed!")



########NEW FILE########
__FILENAME__ = gdbstub

import os
import re
import code
import time
import socket
import struct
import platform
import tempfile

import PE
import vdb
import envi
import envi.resolver as e_resolv
import vtrace

import envi.registers as e_registers
import vtrace.platforms.base as v_base

'''
VMWare config options...
debugStub.listen.guest64 = "TRUE" # ends up on port 8864 (or next avail)
debugStub.listen.guest32 = "TRUE" # ....            8832

debugStub.listen.guest32.remote = "TRUE"

debugStub.hideBreakpoints = "TRUE" # Enable breakpoints

From GDB stuff...  
===== i386 
src/gdb/i386-tdep.c
src/gdb/regformats/reg-i386.dat
===== amd64
src/gdb/amd64-tdep.c
src/gdb/regformats/reg-x86-64.dat
===== arm
name:arm
expedite:r11,sp,pc
32:r0
32:r1
32:r2
32:r3
32:r4
32:r5
32:r6
32:r7
32:r8
32:r9
32:r10
32:r11
32:r12
32:sp
32:lr
32:pc
96:f0
96:f1
96:f2
96:f3
96:f4
96:f5
96:f6
96:f7
32:fps
32:cpsr
'''

gdb_reg_defs = {
    'i386': (
        ['eax','ecx','edx','ebx','esp','ebp','esi','edi','eip','eflags','cs','ss','ds','es','fs','gs'
        ],
        '<16I'
    ),

    'amd64': (
        ['rax','rbx','rcx','rdx','rsi','rdi','rbp','rsp',
         'r8','r9','r10','r11','r12','r13','r14','r15','rip',
         'eflags','cs','ss','ds','es','fs','gs',
         #'st0','st1','st2','st3','st4','st5','st6','st7',
         #'fctrl','fstat','ftag','fiseg','fioff','foseg','fooff','fop'
        ],

        #'<17Q7L' + ('10s' * 8) + '8L'
        '<17Q7L'
    ),

    # FIXME we will need arm flavors...
    'arm': (
        ["r0","r1","r2","r3","r4","r5","r6","r7","r8","r9","sl","fp","ip","sp",
         "lr","pc", None, "cpsr"],
        '<16I96sI'
    ),
}

exit_types = ('X', 'W')

def pkt(cmd):
    return '$%s#%.2x' % (cmd, csum(cmd))

def csum(bytes):
    sum = 0
    for b in bytes:
        sum += ord(b)
    return sum & 0xff

SIGINT  = 2
SIGTRAP = 5

trap_sigs = (SIGINT, SIGTRAP)

class GdbServerDisconnected(Exception):
    pass

class KeBugCheckBreak(vtrace.Breakpoint):
    def __init__(self, symname):
        vtrace.Breakpoint.__init__(self, None, expression=symname)
        self.fastbreak = True

    def notify(self, event, trace):
        sp = trace.getStackCounter()
        savedpc, exccode = trace.readMemoryFormat(sp, '<PP')
        trace._fireSignal(exccode)

bigmask = 0xffffffffffffffff

class GdbStubMixin(e_registers.RegisterContext):

    def __init__(self):

        self.sock = None
        self.stepping = False
        self.attaching = False
        self.breaking = False

        aname = self.getMeta('Architecture')
        self._addArchNamespace(aname)

        self.setMeta('Platform', 'gdbstub')

        self.setMeta('GdbServerHost', 'localhost')
        self.setMeta('GdbServerPort', 0)
        self.setMeta('GdbPlatform', 'Unknown')
        self.setMeta('GdbTargetPlatform', 'Unknown')

        self.setMeta('BinaryFormat', None)

        arch_reg_info = gdb_reg_defs.get(aname)
        if arch_reg_info == None:
            raise Exception('We dont know the GDB register definition for arch: %s' % name)

        self._arch_regnames, self._arch_regfmt = arch_reg_info
        self._arch_regsize = struct.calcsize(self._arch_regfmt)

        self._arch_rctx = self.arch.archGetRegCtx()
        self._arch_reg_xlat = []
        for i,name in enumerate(self._arch_regnames):
            if name == None: # So we can skip parts of the gdb definition...
                continue
            j = self._arch_rctx.getRegisterIndex(name)
            if j != None:
                self._arch_reg_xlat.append((i,j))

        # Load up our register definition!
        e_registers.RegisterContext.__init__(self)
        rinfo = self._arch_rctx.getRegisterInfo(meta=True)
        self.setRegisterInfo(rinfo)

    def _addArchNamespace(self, aname):
        if aname == 'arm':
            import vstruct.defs.arm7 as vs_arm7
            self.vsbuilder.addVStructNamespace('arm7', vs_arm7)

    def normFileName(self, fname):
        # We don't know if it's / or \ ...   do both!
        basename = fname.split('/')[-1].split('\\')[-1]
        return basename.split(".")[0].split("-")[0].lower()

    def platformParseBinary(self, filename, baseaddr, normname):
        print 'platformParseBinary: 0x%.8x %s' % (baseaddr, normname)

    def platformParseBinaryPe(self, filename, baseaddr, normname):

        # If we're on windows, fake out the PE header and use dbghelp
        #if platform.system() in ['Microsoft', 'Windows']:
        if False:
            # FIXME this code is stolen and should be a function!
            import vtrace.platforms.win32 as vt_win32
            fakepe = self.readMemory(baseaddr, 1024)
            tfile = tempfile.NamedTemporaryFile(delete=False)
            tfilename = tfile.name
            import ctypes
            pebuf = ctypes.create_string_buffer(fakepe)
            try:
                try:
                    tfile.write(fakepe)
                    tfile.close()
                    #parser = vt_win32.Win32SymbolParser(-1, tfilename, baseaddr)
                    parser = vt_win32.Win32SymbolParser(-1, None, ctypes.addressof(pebuf))
                    parser.parse()
                    parser.loadSymsIntoTrace(self, normname)
                finally:
                    os.unlink(tfilename)
            except Exception, e:
                print e

        else:
            pe = PE.peFromMemoryObject(self, baseaddr)
            for rva, ord, name in pe.getExports():
                self.addSymbol(e_resolv.Symbol(name, baseaddr+rva, 0, normname))

    def _connectSocket(self):
        if self.sock != None:
            self.sock.shutdown(2)

        tries = 0
        while tries < 10:
            self.sock = socket.socket()
            try:
                self.sock.connect((self.getMeta('GdbServerHost'), self.getMeta('GdbServerPort')))
                # Some gdb stubs seem to send/expect an initial '+'
                try:
                    self.sock.settimeout(1)
                    self.sock.recv(1)
                    self.sock.sendall('+')
                except socket.timeout, t:
                    pass
                self.sock.settimeout(None)
                break
            except Exception, e:
                time.sleep(0.2)
                tries += 1

    def platformPs(self):
        return [ (1, 'SystemProcess'), ]

    def platformAttach(self, pid):
        self._connectSocket()
        self.attaching = True
        # Wait for the debug stub to stop the target
        while True:
            pkt = self._cmdTransact('?')
            if len(pkt) == 0:
                raise Exception('Attach Response Error!')
            if int(pkt[1:3], 16) == 0:
                import time
                time.sleep(0.1)
                self.platformSendBreak()
                pkt = self._cmdTransact('?')
            break
        self._sendPkt('?')

    def platformContinue(self):
        sig = self.getCurrentSignal()
        cmd = 'c'
        if sig != None:
            cmd = 'C%.2x' % sig
        self._sendPkt(cmd)
        #self._cmdTransact(cmd)

    def platformStepi(self):
        # FIXME by selected thread? and address?
        #self._cmdTransact('s')
        self._sendPkt('s')
        self.stepping = True

    def platformDetach(self):
        if not self.running:
            self.platformContinue()
        self.sock.shutdown(2)
        self.sock = None

    def platformSendBreak(self):
        '''
        For now, the only way I know how to re-break the target
        is to disconnect and re-connect...  TOTALLY GHETTO HACK!
        '''
        # If this isn't a break during attach, tell everybody we are
        # breaking...
        if not self.attaching:
            self.breaking = True
        self.sock.sendall('\x03')

    def platformWait(self):
        while True:
            pkt = self._recvPkt()
            if pkt.startswith('O'):
                print 'GDBSTUB SAID: %s' % pkt[1:].decode('hex')
                continue
            break
        return pkt

    def _getVmwareReg(self, rname):
        '''
        Use VMWare's monitor extension to get a register we wouldn't
        normally have...
        '''
        #fs 0x30 base 0xffdff000 limit 0x00001fff type 0x3 s 1 dpl 0 p 1 db 1
        fsstr = self._monitorCommand('r %s' % rname)
        fsparts = fsstr.split()
        return int(fsparts[3], 16)

    def _getVmwareIdtr(self):
        istr = self._monitorCommand('r idtr')
        m = re.match('.* base=(0x\w+) .*', istr)
        idtr = long(m.groups()[0], 0)
        return idtr

    def _getNtOsKrnl(self, idtr):
        x1, kptr, x2 = self.readMemoryFormat(idtr, '<IQI')
        try:
            kptr -= kptr & 0xfff
            while not self.readMemory(kptr, 16).startswith('MZ\x90\x00'):
                kptr -= 4096
            return kptr
        except Exception, e:
            return None

    def _enumGdbTarget(self):
        psize = self.getPointerSize()
        vercmd = self._monitorCommand('version')

        if self._monitorCommand('help').find('linuxoffsets') != -1:

            self.setMeta('GdbPlatform', 'VMware%d' % (psize * 8))

            if psize == 4: # Use the fs register to get KPCR
                fsbase = self._getVmwareReg('fs')
                self.setVariable('fsbase', fsbase)

                fs_fields = self.readMemoryFormat(fsbase, '<8I')

                # Windows has a self reference in the KPCR...
                if fs_fields[7] == fsbase:

                    # Use KPCR from XP for now...
                    import vstruct.defs.windows.win_5_1_i386.ntoskrnl as vs_w_ntoskrnl
                    self.vsbuilder.addVStructNamespace('nt', vs_w_ntoskrnl)

                    self.setMeta('GdbTargetPlatform', 'Windows')
                    self.casesens = False

                    kpcr = self.getStruct('nt.KPCR', fsbase)
                    kver = self.getStruct('nt.DBGKD_GET_VERSION64', kpcr.KdVersionBlock)

                    kernbase = kver.KernBase & bigmask
                    modlist = kver.PsLoadedModuleList & bigmask

                    self.setVariable('PsLoadedModuleList', modlist)
                    self.setVariable('KernelBase', kernbase)

                    self.platformParseBinary = self.platformParseBinaryPe

                    self.fireNotifiers(vtrace.NOTIFY_ATTACH)

                    self.addLibraryBase('nt', kernbase, always=True)
                    ldr_entry = self.readMemoryFormat(modlist, '<I')[0]
                    while ldr_entry != modlist:
                        ldte = self.getStruct('nt.LDR_DATA_TABLE_ENTRY', ldr_entry)
                        dllname = self.readMemory(ldte.FullDllName.Buffer, ldte.FullDllName.Length).decode('utf-16le')
                        dllbase = ldte.DllBase & bigmask
                        self.addLibraryBase(dllname, dllbase, always=True)
                        ldr_entry = ldte.InLoadOrderLinks.Flink & bigmask

                    try:
                        self.addBreakpoint(KeBugCheckBreak('nt.KeBugCheck'))
                    except Exception, e:
                        print 'Error Seting KeBugCheck Bp: %s' % e

                    try:
                        self.addBreakpoint(KeBugCheckBreak('nt.KeBugCheckEx'))
                    except Exception, e:
                        print 'Error Seting KeBugCheck Bp: %s' % e

                else:
                    # FIXME enumerate non-windows OSs!
                    self.fireNotifiers(vtrace.NOTIFY_ATTACH)

            else: # FIXME 64bit vmware!

                idtr = self._getVmwareIdtr()
                self.setVariable('idtr', idtr)

                win_kpcr = 0x07fffffde000

                fields = [-1,]
                try:
                    fields = self.readMemoryFormat(win_kpcr, '<7Q')
                except Exception, e:
                    print 'Exception:',e

                # FIXME other heuristics for linux/bsd/etc...
                if fields[-1] == win_kpcr:
                    self._initWin64(win_kpcr)
                else:
                    self.fireNotifiers(vtrace.NOTIFY_ATTACH)

                #fsbase = self._getVmwareReg('fs')
                #self.setVariable('fsbase', fsbase)

                #fs_fields = self.readMemoryFormat(fsbase, '<8I')

                #nt = self._getNtOsKrnl(idtr)
                #if nt != None:
                    # We are 64bit windows!
                    #import vstruct.defs.windows.win_6_1_amd64.ntoskrnl as vs_w_ntoskrnl
                    #self.vsbuilder.addVStructNamespace('nt', vs_w_ntoskrnl)
                    #self.setMeta('GdbTargetPlatform', 'Windows')
                    #self.setVariable('KernelBase', nt)
                    #self.platformParseBinary = self.platformParseBinaryPe
                    #self.fireNotifiers(vtrace.NOTIFY_ATTACH)
                    #self.addLibraryBase('nt', nt, always=True)

                #else:

        elif vercmd.lower().find('open on-chip debugger') != -1:

            self.setMeta('GdbPlatform', 'OpenOCD')
            self.fireNotifiers(vtrace.NOTIFY_ATTACH)

        else:
            print 'Unidentified gdbstub: %s' % vercmd
            self.fireNotifiers(vtrace.NOTIFY_ATTACH)


    # FIXME implement getRegister(idx) and steal get/set for regs which are not part of the whole...
    def _initWin64(self, kpcr):

        import vstrct.defs.windows.win_6_1_amd64.ntoskrnl as vs_w_ntoskrnl
        self.vsbuilder.addVStructNamespace('nt', vs_w_ntoskrnl)
        self._initWinBase()
                #nt = self._getNtOsKrnl(idtr)
                #if nt != None:
                    # We are 64bit windows!
                    #import vstruct.defs.windows.win_6_1_amd64.ntoskrnl as vs_w_ntoskrnl
                    #self.vsbuilder.addVStructNamespace('nt', vs_w_ntoskrnl)
                    #self.setMeta('GdbTargetPlatform', 'Windows')
                    #self.setVariable('KernelBase', nt)
                    #self.platformParseBinary = self.platformParseBinaryPe
                    #self.fireNotifiers(vtrace.NOTIFY_ATTACH)
                    #self.addLibraryBase('nt', nt, always=True)

    def _initWinBase(self, kpcr):
        self.setMeta('GdbTargetPlatform', 'Windows')
        self.casesens = False

        kpcr = self.getStruct('nt.KPCR', kpcr)
        kver = self.getStruct('nt.DBGKD_GET_VERSION64', kpcr.KdVersionBlock)

        kernbase = kver.KernBase & bigmask
        modlist = kver.PsLoadedModuleList & bigmask

        self.setVariable('PsLoadedModuleList', modlist)
        self.setVariable('KernelBase', kernbase)

        self.platformParseBinary = self.platformParseBinaryPe

        self.fireNotifiers(vtrace.NOTIFY_ATTACH)

        self.addLibraryBase('nt', kernbase, always=True)
        ldr_entry = self.readMemoryFormat(modlist, '<P')[0]
        while ldr_entry != modlist:
            ldte = self.getStruct('nt.LDR_DATA_TABLE_ENTRY', ldr_entry)
            dllname = self.readMemory(ldte.FullDllName.Buffer, ldte.FullDllName.Length).decode('utf-16le')
            dllbase = ldte.DllBase & bigmask
            self.addLibraryBase(dllname, dllbase, always=True)
            ldr_entry = ldte.InLoadOrderLinks.Flink & bigmask

        try:
            self.addBreakpoint(KeBugCheckBreak('nt.KeBugCheck'))
        except Exception, e:
            print 'Error Seting KeBugCheck Bp: %s' % e

        try:
            self.addBreakpoint(KeBugCheckBreak('nt.KeBugCheckEx'))
        except Exception, e:
            print 'Error Seting KeBugCheck Bp: %s' % e

    def platformProcessEvent(self, event):
        #print 'EVENT ->%s<-' % event

        if len(event) == 0:
            self.setMeta('ExitCode', 0xffffffff)
            self.fireNotifiers(vtrace.NOTIFY_EXIT)
            self.sock.shutdown(2)
            self.sock = None
            return

        atype = event[0]
        signo = int(event[1:3], 16)

        # Is this a thread specific signal?
        if atype == 'T':

            #print 'SIGNAL',sig

            dictbytes = event[3:]

            evdict = {}
            for kvstr in dictbytes.split(';'):
                if not kvstr: break
                #print 'KVSTR ->%s<-' % kvstr
                key, value = kvstr.split(':', 1)
                evdict[key.lower()] = value

            # Did we get a specific thread?
            tidstr = evdict.get('thread')
            if tidstr != None:
                tid = int(tidstr, 16)
                self.setMeta('ThreadId', tid)
            #else:
                #print "WE SHOULD ASK FOR THE CURRENT THREAD HERE!"

        elif atype == 'S':
            pass

        elif atype in exit_types:

            # Fire an exit event and GTFO!
            self._fireExit(signo)
            return

        else:
            print 'Unhandled Gdb Server Event: %s' % event

        #if self.attaching and signo in trap_sigs:
        if self.attaching:
            #if signo == 0:
                #We are attached, but he is still running! (no signal)
                #lets send a break, and process the event!
                #self.platformSendBreak()
                #evt = self.platformWait()
                #self.platformProcessEvent(evt)
                #return

            self.attaching = False
            self._enumGdbTarget()
            self.runAgain(False) # Clear this, if they want BREAK to run, it will
            self.fireNotifiers(vtrace.NOTIFY_BREAK)

        elif self.breaking and signo in trap_sigs:
            self.breaking = False
            self.fireNotifiers(vtrace.NOTIFY_BREAK)

        # Process the signal and decide what to do...
        elif signo == SIGTRAP:

            # Traps on posix systems are a little complicated
            if self.stepping:
                #FIXME try out was single step thing for intel
                self.stepping = False
                self.fireNotifiers(vtrace.NOTIFY_STEP)

            elif self.checkBreakpoints():
                return

            #elif self.checkWatchpoints():
                #return

            #elif self.checkBreakpoints():
                # It was either a known BP or a sendBreak()
                #return

            #elif self.execing:
                ##self.execing = False
                #self.handleAttach()

            else:
                self._fireSignal(signo)

        #elif signo == signal.SIGSTOP:
            #self.handleAttach()

        else:
            self._fireSignal(signo)

    def platformGetRegCtx(self, tid):
        '''
        Get an envi register context from the target stub.
        '''
        # FIXME tid!
        regbytes = self._cmdTransact('g').decode('hex')
        rvals = struct.unpack(self._arch_regfmt, regbytes[:self._arch_regsize])
        ctx = self.arch.archGetRegCtx()
        for myidx, enviidx in self._arch_reg_xlat:
            ctx.setRegister(enviidx, rvals[myidx])
        return ctx
        
    def platformSetRegCtx(self, tid, ctx):
        '''
        Set the target stub's register context from the envi register context
        '''
        # FIXME tid!
        regbytes = self._cmdTransact('g').decode('hex')
        regremain = regbytes[self._arch_regsize:]
        rvals = struct.unpack(self._arch_regfmt, regbytes[:self._arch_regsize])
        rvals = list(rvals) # So we can assign to them...
        for myidx, enviidx in self._arch_reg_xlat:
            rvals[myidx] = ctx.getRegister(enviidx)
        newbytes = struct.pack(self._arch_regfmt, rvals) + regremain
        return self._cmdTransact('G'+newbytes.encode('hex'))

    def _recvUntil(self, c):
        ret = ''
        while not ret.endswith(c):
            x = self.sock.recv(1)
            if len(x) == 0:
                raise Exception('socket closed prematurely!')
            ret += x
        return ret

    def _recvPkt(self):
        b = self.sock.recv(1)
        if len(b) == 0:
            raise GdbServerDisconnected()
        if b != '$':
            raise Exception('Invalid Pkt Beginning! ->%s<-' % b)

        bytes = self._recvUntil('#')
        bytes = bytes[:-1]

        isum = int(self.sock.recv(2), 16)
        ssum = csum(bytes)
        if isum != ssum:
            raise Exception('Invalid Checksum! his: 0x%.2x ours: 0x%.2x' % (isum, ssum))

        self.sock.sendall('+')

        #print 'RECV: ->%s<-' % bytes
        return bytes

    def _cmdTransact(self, cmd):
        self._sendPkt(cmd)
        return self._recvPkt()


    def _sendPkt(self, cmd):
        #print 'SEND: ->%s<-' % cmd
        self.sock.sendall(pkt(cmd))
        b = self.sock.recv(1)
        if b != '+':
            raise Exception('Retrans! ->%s<-' % b)

    def platformGetThreads(self):

        ret = {}

        self._sendPkt('qfThreadInfo')
        tbytes = self._recvPkt()

        while tbytes.startswith('m'):

            if tbytes.find(','):
                for bval in tbytes[1:].split(','):
                    ret[int(bval)] = 0
            else:
                ret[int(tbytes[1:])] = 0

            self._sendPkt('qsThreadInfo')
            tbytes = self._recvPkt()

        return ret

    def _raiseIfError(self, msg):
        if msg.startswith('E'):
            raise Exception('Error: %s' % msg)

    def platformReadMemory(self, addr, size):
        mbytes = ''
        offset = 0
        while len(mbytes) < size:
            # FIXME is this 256 problem just in the VMWare gdb stub?
            cmd = 'm%x,%x' % (addr + offset, min(256, size-offset))
            pkt = self._cmdTransact(cmd)
            self._raiseIfError(pkt)
            #print 'GOT SOME AT',pkt
            pbytes = pkt.decode('hex')
            offset += len(pbytes)
            mbytes += pbytes
        return mbytes

    def platformWriteMemory(self, addr, mbytes):
        cmd = 'M%x,%x:%s' % (addr, len(mbytes), mbytes.encode('hex'))
        pkt = self._cmdTransact(cmd)
        self._raiseIfError(pkt)

    def platformGetMaps(self):
        return []

    def _monitorCommand(self, cmd):
        resp = ''
        cmd = 'qRcmd,%s' % cmd.encode('hex')
        pkt = self._cmdTransact(cmd)
        while not pkt.startswith('OK'):
            self._raiseIfError(pkt)
            if not pkt.startswith('O'):
                return pkt.decode('hex')
            resp += pkt[1:].decode('hex')
            pkt = self._recvPkt()
        return resp

GDB_BP_SOFTWARE     = 0
GDB_BP_HARDWARE     = 1
GDB_BP_WATCH_WRITE  = 2
GDB_BP_WATCH_READ   = 3
GDB_BP_WATCH_ACCESS = 4

class GdbStubTrace(
        vtrace.Trace,
        GdbStubMixin,
        v_base.TracerBase):

    def __init__(self, archname):

        # First things first, lets steal ourself an arch!
        envi.stealArchMethods(self, archname)
        vtrace.Trace.__init__(self, archname=archname)
        v_base.TracerBase.__init__(self)
        GdbStubMixin.__init__(self)

    # FIXME this should have a cleaner abstraction to allow for stuff...
    # platformActivateBreak / Watch!
    # platformDeactivateBreak / Watch!

    # FIXME we also need cleaner abstraction for checkBreakpoints
    # (some platforms stop *on* break and some stop *after...)

    def _activateBreak(self, bp):
        # For now, we don't support watchpoints...
        addr = bp.resolveAddress(self)
        self._cmdTransact('Z%d,%x,%x' % (GDB_BP_SOFTWARE,addr,1))

    def _cleanupBreakpoints(self, force=False):
        '''
        Cleanup any non-fastbreak breakpoints.  This routine doesn't even get
        called in the event of mode FastBreak=True.
        '''
        self.fb_bp_done = False
        for bp in self.breakpoints.itervalues():
            # No harm in calling deactivate on
            # an inactive bp
            if force or not bp.fastbreak:
                self._cmdTransact('z%d,%x,%x' % (GDB_BP_SOFTWARE,bp.getAddress(),1))
                #bp.deactivate(self)

    def checkBreakpoints(self):
        pc = self.getProgramCounter()
        bp = self.breakpoints.get(pc, None)

        if bp:
            self._fireBreakpoint(bp)
            return True

        if self.getMeta("ShouldBreak"):
            self.setMeta("ShouldBreak", False)
            self.fireNotifiers(vtrace.NOTIFY_BREAK)
            return True

        return False

    def _checkForBreak(self):
        """
        Check to see if we've landed on a breakpoint, and if so
        deactivate and step us past it.

        WARNING: Unfortunatly, cause this is used immidiatly before
        a call to run/wait, we must block briefly even for the GUI
        """
        # Steal a reference because the step should
        # clear curbp...
        bp = self.curbp
        if bp != None and bp.isEnabled():
            orig = self.getMode("FastStep")
            self.setMode("FastStep", True)
            self.stepi()
            self.setMode("FastStep", orig)
            self._activateBreak(bp)

    def buildNewTrace(self):
        arch = self.getMeta('Architecture')
        newt = GdbStubTrace(arch)
        newt.setMeta('GdbServerHost', self.getMeta('GdbServerHost'))
        newt.setMeta('GdbServerPort', self.getMeta('GdbServerPort'))
        return newt


########NEW FILE########
__FILENAME__ = linux
"""
Linux Platform Module
"""
# Copyright (C) 2007 Invisigoth - See LICENSE file for details
import os
import struct
import signal
import traceback
import platform

import envi.memory as e_mem
import envi.registers as e_reg

import vtrace
import vtrace.archs.i386 as v_i386
import vtrace.archs.amd64 as v_amd64
import vtrace.platforms.base as v_base
import vtrace.platforms.posix as v_posix

from ctypes import *
import ctypes.util as cutil

libc = CDLL(cutil.find_library("c"))

libc.lseek64.restype = c_ulonglong
libc.lseek64.argtypes = [c_uint, c_ulonglong, c_uint]
libc.read.restype = c_long
libc.read.argtypes = [c_uint, c_void_p, c_long]
libc.write.restype = c_long
libc.write.argtypes = [c_uint, c_void_p, c_long]

O_RDWR = 2
O_LARGEFILE = 0x8000

MAP_ANONYMOUS = 0x20
MAP_PRIVATE = 0x02

# Linux specific ptrace extensions
PT_GETREGS = 12
PT_SETREGS = 13
PT_GETFPREGS = 14
PT_SETFPREGS = 15
PT_ATTACH = 16
PT_DETACH = 17
PT_GETFPXREGS = 18
PT_SETFPXREGS = 19
PT_SYSCALL = 24
PT_SETOPTIONS = 0x4200
PT_GETEVENTMSG = 0x4201
PT_GETSIGINFO = 0x4202
PT_SETSIGINFO = 0x4203
# PT set options stuff.  ONLY TRACESYSGOOD may be used in 2.4...
PT_O_TRACESYSGOOD   = 0x00000001 # add 0x80 to TRAP when generated by syscall
# For each of the options below, the stop signal is (TRAP | PT_EVENT_FOO << 8)
PT_O_TRACEFORK      = 0x00000002 # Cause a trap at fork
PT_O_TRACEVFORK     = 0x00000004 # Cause a trap at vfork
PT_O_TRACECLONE     = 0x00000008 # Cause a trap at clone
PT_O_TRACEEXEC      = 0x00000010 # Cause a trap at exec
PT_O_TRACEVFORKDONE = 0x00000020 # Cause a trap when vfork done
PT_O_TRACEEXIT      = 0x00000040 # Cause a trap on exit
PT_O_MASK           = 0x0000007f
# Ptrace event types (TRAP | PT_EVENT_FOO << 8) means that type
# when using GETEVENTMSG for most of these, the new pid is the data
PT_EVENT_FORK       = 1
PT_EVENT_VFORK      = 2
PT_EVENT_CLONE      = 3
PT_EVENT_EXEC       = 4
PT_EVENT_VFORK_DONE = 5
PT_EVENT_EXIT       = 6

# Used to tell some of the additional events apart
SIG_LINUX_SYSCALL = signal.SIGTRAP | 0x80
SIG_LINUX_CLONE = signal.SIGTRAP | (PT_EVENT_CLONE << 8)

class user_regs_i386(Structure):
    _fields_ = (
        ("ebx",  c_ulong),
        ("ecx",  c_ulong),
        ("edx",  c_ulong),
        ("esi",  c_ulong),
        ("edi",  c_ulong),
        ("ebp",  c_ulong),
        ("eax",  c_ulong),
        ("ds",   c_ushort),
        ("__ds", c_ushort),
        ("es",   c_ushort),
        ("__es", c_ushort),
        ("fs",   c_ushort),
        ("__fs", c_ushort),
        ("gs",   c_ushort),
        ("__gs", c_ushort),
        ("orig_eax", c_ulong),
        ("eip",  c_ulong),
        ("cs",   c_ushort),
        ("__cs", c_ushort),
        ("eflags", c_ulong),
        ("esp",  c_ulong),
        ("ss",   c_ushort),
        ("__ss", c_ushort),
    )


class USER_i386(Structure):
    _fields_ = (
        # NOTE: Expand out the user regs struct so
        #       we can make one call to _rctx_Import
        ("regs",       user_regs_i386),
        ("u_fpvalid",  c_ulong),
        ("u_tsize",    c_ulong),
        ("u_dsize",    c_ulong),
        ("u_ssize",    c_ulong),
        ("start_code", c_ulong),
        ("start_stack",c_ulong),
        ("signal",     c_ulong),
        ("reserved",   c_ulong),
        ("u_ar0",      c_void_p),
        ("u_fpstate",  c_void_p),
        ("magic",      c_ulong),
        ("u_comm",     c_char*32),
        ("debug0",     c_ulong),
        ("debug1",     c_ulong),
        ("debug2",     c_ulong),
        ("debug3",     c_ulong),
        ("debug4",     c_ulong),
        ("debug5",     c_ulong),
        ("debug6",     c_ulong),
        ("debug7",     c_ulong),
    )

class user_regs_amd64(Structure):
    _fields_ = [
        ('r15',      c_uint64),
        ('r14',      c_uint64),
        ('r13',      c_uint64),
        ('r12',      c_uint64),
        ('rbp',      c_uint64),
        ('rbx',      c_uint64),
        ('r11',      c_uint64),
        ('r10',      c_uint64),
        ('r9',       c_uint64),
        ('r8',       c_uint64),
        ('rax',      c_uint64),
        ('rcx',      c_uint64),
        ('rdx',      c_uint64),
        ('rsi',      c_uint64),
        ('rdi',      c_uint64),
        ('orig_rax', c_uint64),
        ('rip',      c_uint64),
        ('cs',       c_uint64),
        ('eflags',   c_uint64),
        ('rsp',      c_uint64),
        ('ss',       c_uint64),
        ('fs_base',  c_uint64),
        ('gs_base',  c_uint64),
        ('ds',       c_uint64),
        ('es',       c_uint64),
        ('fs',       c_uint64),
        ('gs',       c_uint64),
    ]

# Modern linux only lets us write to these...
dbgregs = (0,1,2,3,6,7)

class LinuxMixin(v_posix.PtraceMixin, v_posix.PosixMixin):
    """
    The mixin to take care of linux specific platform traits.
    (mostly proc)
    """

    def __init__(self):
        # Wrap reads from proc in our worker thread
        v_posix.PtraceMixin.__init__(self)
        v_posix.PosixMixin.__init__(self)
        self.nptlinit = False
        self.memfd = None

        self.fireTracerThread()

        self.initMode("Syscall", False, "Break On Syscalls")

    @v_base.threadwrap
    def platformExec(self, cmdline):
        print 'FIXME: known bug with thread create events from execd linux trace!'
        pid = v_posix.PtraceMixin.platformExec(self, cmdline)
        self.pthreads = [pid,]
        self.setMeta("ExeName",self._findExe(pid))
        return pid

    def setupMemFile(self, offset):
        """
        A utility to open (if necissary) and seek the memfile
        """
        if self.memfd == None:
            self.memfd = libc.open("/proc/%d/mem" % self.pid, O_RDWR | O_LARGEFILE, 0755)

        x = libc.lseek64(self.memfd, offset, 0)

    @v_base.threadwrap
    def platformAllocateMemory(self, size, perms=e_mem.MM_RWX, suggestaddr=0):
        #FIXME this is intel specific and should probably go in with the regs
        sp = self.getStackCounter()
        pc = self.getProgramCounter()

        # Xlate perms (mmap is backward)
        realperm = 0
        if perms & e_mem.MM_READ:
            realperm |= 1
        if perms & e_mem.MM_WRITE:
            realperm |= 2
        if perms & e_mem.MM_EXEC:
            realperm |= 4

        #mma is struct of mmap args for linux syscall
        mma = struct.pack("<6L", suggestaddr, size, realperm, MAP_ANONYMOUS|MAP_PRIVATE, 0, 0)

        regsave = self.getRegisters()

        stacksave = self.readMemory(sp, len(mma))
        ipsave = self.readMemory(pc, 2)

        SYS_mmap = 90

        self.writeMemory(sp, mma)
        self.writeMemory(pc, "\xcd\x80")
        self.setRegisterByName("eax", SYS_mmap)
        self.setRegisterByName("ebx", sp)
        self._syncRegs()

        try:
            # Step over our syscall instruction
            tid = self.getMeta("ThreadId", 0)
            self.platformStepi()
            os.waitpid(tid, 0)
            eax = self.getRegisterByName("eax")
            if eax & 0x80000000:
                raise Exception("Linux mmap syscall error: %d" % eax)
            return eax

        finally:
            # Clean up all our fux0ring
            self.writeMemory(sp, stacksave)
            self.writeMemory(pc, ipsave)
            self.setRegisters(regsave)

    def posixCreateThreadHack(self):
        for tid in self.threadsForPid(self.pid):
            if tid == self.pid:
                continue
            self.attachThread(tid)
        v_posix.PosixMixin.posixCreateThreadHack(self)

    @v_base.threadwrap
    def platformReadMemory(self, address, size):
        """
        A *much* faster way of reading memory that the 4 bytes
        per syscall allowed by ptrace
        """
        self.setupMemFile(address)
        # Use ctypes cause python implementation is teh ghey
        buf = create_string_buffer(size)
        x = libc.read(self.memfd, addressof(buf), size)
        if x != size:
            #libc.perror('libc.read %d (size: %d)' % (x,size))
            raise Exception("reading from invalid memory %s (%d returned)" % (hex(address), x))
        # We have to slice cause ctypes "helps" us by adding a null byte...
        return buf.raw

    @v_base.threadwrap
    def whynot_platformWriteMemory(self, address, data):
        """
        A *much* faster way of writting memory that the 4 bytes
        per syscall allowed by ptrace
        """
        self.setupMemFile(address)
        buf = create_string_buffer(data)
        size = len(data)
        x = libc.write(self.memfd, addressof(buf), size)
        if x != size:
            libc.perror('write mem failed: 0x%.8x (%d)' % (address, size))
            raise Exception("write memory failed: %d" % x)
        return x

    def _findExe(self, pid):
        exe = os.readlink("/proc/%d/exe" % pid)
        if "(deleted)" in exe:
            if "#prelink#" in exe:
                exe = exe.split(".#prelink#")[0]
            elif ";" in exe:
                exe = exe.split(";")[0]
            else:
                exe = exe.split("(deleted)")[0].strip()
        return exe

    @v_base.threadwrap
    def platformAttach(self, pid):
        self.pthreads = [pid,]
        self.setMeta("ThreadId", pid)
        if v_posix.ptrace(PT_ATTACH, pid, 0, 0) != 0:
            raise Exception("PT_ATTACH failed!")
        self.setupPtraceOptions(pid)
        self.setMeta("ExeName", self._findExe(pid))

    def platformPs(self):
        pslist = []
        for dname in os.listdir("/proc/"):
            try:
                if not dname.isdigit():
                    continue
                cmdline = file("/proc/%s/cmdline" % dname).read()
                cmdline = cmdline.replace("\x00"," ")
                if len(cmdline) > 0:
                    pslist.append((int(dname),cmdline))
            except:
                pass # Permissions...  quick process... whatev.
        return pslist

    def attachThread(self, tid, attached=False):
        self.doAttachThread(tid,attached=attached)
        self.setMeta("ThreadId", tid)
        self.fireNotifiers(vtrace.NOTIFY_CREATE_THREAD)

    @v_base.threadwrap
    def platformWait(self):
        # Blocking wait once...
        pid, status = os.waitpid(-1, 0x40000002)
        self.setMeta("ThreadId", pid)
        # Stop the rest of the threads... 
        # why is linux debugging so Ghetto?!?!
        if not self.stepping: # If we're stepping, only do the one
            for tid in self.pthreads:
                if tid == pid:
                    continue
                try:
                    # We use SIGSTOP here because they can't mask it.
                    os.kill(tid, signal.SIGSTOP)
                    os.waitpid(tid, 0x40000002)
                except Exception, e:
                    print "WARNING TID is invalid %d %s" % (tid,e)
        return status

    # If it's linux 2.4 we must threadwrap wait...
    if platform.release().startswith("2.4"):
        platformWait = v_base.threadwrap(platformWait)

    @v_base.threadwrap
    def platformContinue(self):
        cmd = v_posix.PT_CONTINUE
        if self.getMode("Syscall", False):
            cmd = PT_SYSCALL
        pid = self.getPid()
        sig = self.getCurrentSignal()
        if sig == None:
            sig = 0
        # Only deliver signals to the main thread
        if v_posix.ptrace(cmd, pid, 0, sig) != 0:
            raise Exception("ERROR ptrace failed for tid %d" % pid)

        for tid in self.pthreads:
            if tid == pid:
                continue
            if v_posix.ptrace(cmd, tid, 0, 0) != 0:
                pass

    @v_base.threadwrap
    def platformStepi(self):
        self.stepping = True
        tid = self.getMeta("ThreadId", 0)
        if v_posix.ptrace(v_posix.PT_STEP, tid, 0, 0) != 0:
            raise Exception("ERROR ptrace failed!")

    @v_base.threadwrap
    def platformDetach(self):
        libc.close(self.memfd)
        for tid in self.pthreads:
            tid,v_posix.ptrace(PT_DETACH, tid, 0, 0)

    @v_base.threadwrap
    def doAttachThread(self, tid, attached=False):
        """
        Do the work for attaching a thread.  This must be *under*
        attachThread() so callers in notifiers may call it (because
        it's also gotta be thread wrapped).
        """
        if not attached:
            if v_posix.ptrace(PT_ATTACH, tid, 0, 0) != 0:
                raise Exception("ERROR ptrace attach failed for thread %d" % tid)
        os.waitpid(tid, 0x40000002)
        self.setupPtraceOptions(tid)
        self.pthreads.append(tid)

    def setupPtraceOptions(self, tid):
        """
        Called by doAttachThread to setup ptrace related options.
        """
        opts = PT_O_TRACESYSGOOD
        if platform.release().startswith("2.6"):
            opts |= PT_O_TRACECLONE
        x = v_posix.ptrace(PT_SETOPTIONS, tid, 0, opts)
        if x != 0:
            libc.perror('ptrace PT_SETOPTION failed for thread %d' % tid)
            #print "WARNING ptrace SETOPTIONS failed for thread %d (%d)" % (tid,x)

    def threadsForPid(self, pid):
        ret = []
        tpath = "/proc/%s/task" % pid
        if os.path.exists(tpath):
            for pidstr in os.listdir(tpath):
                ret.append(int(pidstr))
        return ret

    def platformProcessEvent(self, status):
        # Skim some linux specific events before passing to posix
        tid = self.getMeta("ThreadId", -1)
        if os.WIFSTOPPED(status):
            sig = status >> 8
            if sig == SIG_LINUX_SYSCALL:
                self.fireNotifiers(vtrace.NOTIFY_SYSCALL)

            elif sig == SIG_LINUX_CLONE:
                # Handle a new thread here!
                newtid = self.getPtraceEvent()
                self.attachThread(newtid, attached=True)

            #FIXME eventually implement child catching!
            else:
                self.handlePosixSignal(sig)

            return

        v_posix.PosixMixin.platformProcessEvent(self, status)

    @v_base.threadwrap
    def getPtraceEvent(self):
        """
        This *thread wrapped* function will get any pending GETEVENTMSG
        msgs.
        """
        p = c_ulong(0)
        tid = self.getMeta("ThreadId", -1)
        if v_posix.ptrace(PT_GETEVENTMSG, tid, 0, addressof(p)) != 0:
            raise Exception('ptrace PT_GETEVENTMSG failed!')
        return p.value

    def platformGetThreads(self):
        ret = {}
        for tid in self.pthreads:
            ret[tid] = tid #FIXME make this pthread struct or stackbase soon
        return ret

    def platformGetMaps(self):
        maps = []
        mapfile = file("/proc/%d/maps" % self.pid)
        for line in mapfile:

            perms = 0
            sline = line.split(" ")
            addrs = sline[0]
            permstr = sline[1]
            fname = sline[-1].strip()
            addrs = addrs.split("-")
            base = long(addrs[0],16)
            max = long(addrs[1],16)
            mlen = max-base

            if "r" in permstr:
                perms |= e_mem.MM_READ
            if "w" in permstr:
                perms |= e_mem.MM_WRITE
            if "x" in permstr:
                perms |= e_mem.MM_EXEC
            #if "p" in permstr:
                #pass

            maps.append((base,mlen,perms,fname))
        return maps

    def platformGetFds(self):
        fds = []
        for name in os.listdir("/proc/%d/fd/" % self.pid):
            try:
                fdnum = int(name)
                fdtype = vtrace.FD_UNKNOWN
                link = os.readlink("/proc/%d/fd/%s" % (self.pid,name))
                if "socket:" in link:
                    fdtype = vtrace.FD_SOCKET
                elif "pipe:" in link:
                    fdtype = vtrace.FD_PIPE
                elif "/" in link:
                    fdtype = vtrace.FD_FILE

                fds.append((fdnum,fdtype,link))
            except:
                traceback.print_exc()

        return fds

############################################################################
#
# NOTE: Both of these use class locals set by the i386/amd64 variants
#
    @v_base.threadwrap
    def platformGetRegCtx(self, tid):
        ctx = self.archGetRegCtx()
        u = self.user_reg_struct()
        if v_posix.ptrace(PT_GETREGS, tid, 0, addressof(u)) == -1:
            raise Exception("Error: ptrace(PT_GETREGS...) failed!")

        ctx._rctx_Import(u)

        for i in dbgregs:
            offset = self.user_dbg_offset + (self.psize * i)
            r = v_posix.ptrace(v_posix.PT_READ_U, tid, offset, 0)
            ctx.setRegister(self.dbgidx+i, r & self.reg_val_mask)

        return ctx

    @v_base.threadwrap
    def platformSetRegCtx(self, tid, ctx):
        u = self.user_reg_struct()
        # Populate the reg struct with the current values (to allow for
        # any regs in that struct that we don't track... *fs_base*ahem*
        if v_posix.ptrace(PT_GETREGS, tid, 0, addressof(u)) == -1:
            raise Exception("Error: ptrace(PT_GETREGS...) failed!")

        ctx._rctx_Export(u)
        if v_posix.ptrace(PT_SETREGS, tid, 0, addressof(u)) == -1:
            raise Exception("Error: ptrace(PT_SETREGS...) failed!")

        for i in dbgregs:
            val = ctx.getRegister(self.dbgidx + i)
            offset = self.user_dbg_offset + (self.psize * i)
            if v_posix.ptrace(v_posix.PT_WRITE_U, tid, offset, val) != 0:
                libc.perror('PT_WRITE_U failed for debug%d' % i)
                #raise Exception("PT_WRITE_U for debug%d failed!" % i)

class Linuxi386Trace(
        vtrace.Trace,
        LinuxMixin,
        v_i386.i386Mixin,
        v_posix.ElfMixin,
        v_base.TracerBase):


    user_reg_struct = user_regs_i386
    user_dbg_offset = 252
    reg_val_mask = 0xffffffff

    def __init__(self):
        vtrace.Trace.__init__(self)
        v_base.TracerBase.__init__(self)
        v_posix.ElfMixin.__init__(self)
        v_i386.i386Mixin.__init__(self)
        LinuxMixin.__init__(self)

        # Pre-calc the index of the debug regs
        self.dbgidx = self.archGetRegCtx().getRegisterIndex("debug0")

class LinuxAmd64Trace(
        vtrace.Trace,
        LinuxMixin,
        v_amd64.Amd64Mixin,
        v_posix.ElfMixin,
        v_base.TracerBase):

    user_reg_struct = user_regs_amd64
    user_dbg_offset = 848
    reg_val_mask = 0xffffffffffffffff

    def __init__(self):
        vtrace.Trace.__init__(self)
        v_base.TracerBase.__init__(self)
        v_posix.ElfMixin.__init__(self)
        v_amd64.Amd64Mixin.__init__(self)
        LinuxMixin.__init__(self)

        self.dbgidx = self.archGetRegCtx().getRegisterIndex("debug0")


########NEW FILE########
__FILENAME__ = posix
"""
Posix Signaling Module
"""
# Copyright (C) 2007 Invisigoth - See LICENSE file for details
import sys
import os
import struct
import signal
import platform


import vtrace
import vtrace.util as v_util
import vtrace.platforms.base as v_base

import Elf
from ctypes import *
import ctypes.util as cutil

import envi.resolver as e_resolv
import envi.memory as e_mem
import envi.cli as e_cli


libc = None

class PosixMixin:

    """
    A mixin for systems which use POSIX signals and
    things like wait()
    """

    def __init__(self):
        """
        Setup for the fact that we support signal driven
        debugging on posix platforms
        """
        self.stepping = False # Set this on stepi to diff the TRAP
        self.execing  = False # Set this on exec to diff the TRAP
        self.pthreads = [] # Some platforms make a pthread list

        self.fireTracerThread()

    def platformKill(self):
        self.sendSignal(signal.SIGKILL)

    def sendSignal(self, signo):
        self.requireAttached()
        os.kill(self.pid, signo)

    def platformSendBreak(self):
        self.sendSignal(signal.SIGTRAP) # FIXME maybe change to SIGSTOP

    def posixLibraryLoadHack(self):
        """
        Posix systems don't have library load events, so
        fake it out here... (including pre-populating the
        entire known library bases metadata
        """
        # GHETTO: just look for magic based on binary
        magix = ["\x7fELF",]
        done = []
        for addr,size,perms,fname in self.getMemoryMaps():
            if fname in done:
                continue
            done.append(fname)
            if perms & e_mem.MM_READ:
                try:
                    buf = self.readMemory(addr, 20)
                    for m in magix:
                        if buf.find(m) == 0:
                            self.addLibraryBase(fname, addr)
                            break
                except: #FIXME why can't i read all maps?
                    pass

    def platformWait(self):
        pid, status = os.waitpid(self.pid,0)
        return status

    def posixCreateThreadHack(self):
        '''
        For systems which don't use their debug APIs to
        generate thread creation events on startup, 
        '''
        initid = self.getMeta('ThreadId')
        for tid in self.platformGetThreads().keys():
            self.setMeta('ThreadId', tid)
            self.fireNotifiers(vtrace.NOTIFY_CREATE_THREAD)
        self.setMeta('ThreadId', initid)

    def handleAttach(self):
        self.fireNotifiers(vtrace.NOTIFY_ATTACH)
        self.posixLibraryLoadHack()
        self.posixCreateThreadHack()
        # We'll emulate windows here and send an additional
        # break after our library load events to make things easy
        self.runAgain(False) # Clear this, if they want BREAK to run, it will
        self.fireNotifiers(vtrace.NOTIFY_BREAK)

    def platformProcessEvent(self, status):

        if os.WIFEXITED(status):
            tid = self.getMeta("ThreadId", -1)
            if tid != self.getPid():
                # Set the selected thread ID to the pid cause
                # the old one's invalid
                if tid in self.pthreads:
                    self.pthreads.remove(tid)
                self.setMeta("ThreadId", self.getPid())
                self._fireExitThread(tid, os.WEXITSTATUS(status))
            else:
                self._fireExit(os.WEXITSTATUS(status))

        elif os.WIFSIGNALED(status):
            self.setMeta("ExitCode", os.WTERMSIG(status))
            self.fireNotifiers(vtrace.NOTIFY_EXIT)

        elif os.WIFSTOPPED(status):
            sig = os.WSTOPSIG(status)
            self.handlePosixSignal(sig)

        else:
            print "OMG WTF JUST HAPPENED??!?11/!?1?>!"

    def handlePosixSignal(self, sig):
        """
        Handle a basic posix signal for this trace.  This was seperated from
        platformProcessEvent so extenders could skim events and still use this logic.
        """
        if sig == signal.SIGTRAP:

            # Traps on posix systems are a little complicated
            if self.stepping:
                #FIXME try out was single step thing for intel
                self.stepping = False
                self._fireStep()

            elif self.checkWatchpoints():
                return

            elif self.checkBreakpoints():
                # It was either a known BP or a sendBreak()
                return

            elif self.execing:
                self.execing = False
                self.handleAttach()

            else:
                self._fireSignal(sig)

        elif sig == signal.SIGSTOP:
            #FIXME only on attaching..
            self.handleAttach()

        else:
            self._fireSignal(sig)


class ElfMixin:
    """
    A platform mixin to parse Elf binaries
    """
    def __init__(self):
        self.setMeta('Format','elf')

    def platformParseBinary(self, filename, baseaddr, normname):
        typemap = {
            Elf.STT_FUNC:e_resolv.FunctionSymbol,
            Elf.STT_SECTION:e_resolv.SectionSymbol,
        }

        fd = file(filename,'rb')
        elf = Elf.Elf(fd)
        addbase = 0
        if not elf.isPreLinked() and elf.isSharedObject():
            addbase = baseaddr

        for sec in elf.sections:
            sym = e_resolv.SectionSymbol(sec.name, sec.sh_addr+addbase, sec.sh_size, normname)
            self.addSymbol(sym)

        for sym in elf.symbols:
            symclass = typemap.get((sym.st_info & 0xf), e_resolv.Symbol)
            sym = symclass(sym.name, sym.st_value+addbase, sym.st_size, normname)
            self.addSymbol(sym)

        for sym in elf.dynamic_symbols:
            symclass = typemap.get((sym.st_info & 0xf), e_resolv.Symbol)
            sym = symclass(sym.name, sym.st_value+addbase, sym.st_size, normname)
            self.addSymbol(sym)

# As much as I would *love* if all the ptrace defines were the same all the time,
# there seem to be small platform differences...
# These are the ones upon which most agree
PT_TRACE_ME     = 0   # child declares it's being traced */
PT_READ_I       = 1   # read word in child's I space */
PT_READ_D       = 2   # read word in child's D space */
PT_READ_U       = 3   # read word in child's user structure */
PT_WRITE_I      = 4   # write word in child's I space */
PT_WRITE_D      = 5   # write word in child's D space */
PT_WRITE_U      = 6   # write word in child's user structure */
PT_CONTINUE     = 7   # continue the child */
PT_KILL         = 8   # kill the child process */
PT_STEP         = 9   # single step the child */

def ptrace(code, pid, addr, data):
    """
    The contents of this call are basically cleanly
    passed to the libc implementation of ptrace.
    """
    global libc
    if not libc:
        cloc = cutil.find_library("c")
        if not cloc:
            raise Exception("ERROR: can't find C library on posix system!")
        libc = CDLL(cloc)
        libc.ptrace.restype = c_size_t
        libc.ptrace.argtypes = [c_int, c_uint32, c_size_t, c_size_t]
    return libc.ptrace(code, pid, c_size_t(addr), c_size_t(data))

class PtraceMixin:
    """
    A platform mixin for using the ptrace functions
    to attach/detach/continue/stepi etc. Many *nix systems
    will probably use this...

    NOTE: if you get a PT_FOO undefined, it *probably* means that
    the PT_FOO macro isn't defined for that platform (which means
    it need to be done another way like PT_GETREGS on darwin doesn't
    exist... but the darwin mixin over-rides platformGetRegs)
    """

    def __init__(self):
        """
        Setup supported modes
        """

        self.conthack = 0
        if sys.platform == "darwin":
            self.conthack = 1

        self.fireTracerThread()

    @v_base.threadwrap
    def platformExec(self, cmdline):
        self.execing = True
        cmdlist = e_cli.splitargs(cmdline)
        os.stat(cmdlist[0])
        pid = os.fork()
        if pid == 0:
            ptrace(PT_TRACE_ME, 0, 0, 0)
            os.execv(cmdlist[0], cmdlist)
            sys.exit(-1)
        return pid

    @v_base.threadwrap
    def platformWriteMemory(self, address, bytes):
        wordsize = len(struct.pack("P",0))
        remainder = len(bytes) % wordsize

        if remainder:
            pad = self.readMemory(address+(len(bytes)-remainder), wordsize)
            bytes += pad[remainder:]

        for i in range(len(bytes)/wordsize):
            offset = wordsize*i
            dword = struct.unpack("L",bytes[offset:offset+wordsize])[0]
            if ptrace(PT_WRITE_D, self.pid, long(address+offset), long(dword)) != 0:
                raise Exception("ERROR ptrace PT_WRITE_D failed!")



########NEW FILE########
__FILENAME__ = solaris
"""
Solaris Platform Module (Incomplete)
"""
# Copyright (C) 2007 Invisigoth - See LICENSE file for details
import os
import struct
import array

# Control codes (long values) for messages written to ctl and lwpctl files.
PCNULL   = 0L# null request, advance to next message */
PCSTOP   = 1L# direct process or lwp to stop and wait for stop */
PCDSTOP  = 2L# direct process or lwp to stop */
PCWSTOP  = 3L# wait for process or lwp to stop, no timeout */
PCTWSTOP = 4L# wait for stop, with long millisecond timeout arg */
PCRUN    = 5L# make process/lwp runnable, w/ long flags argument */
PCCSIG   = 6L# clear current signal from lwp */
PCCFAULT = 7L# clear current fault from lwp */
PCSSIG   = 8L# set current signal from siginfo_t argument */
PCKILL   = 9L# post a signal to process/lwp, long argument */
PCUNKILL = 10L# delete a pending signal from process/lwp, long arg */
PCSHOLD  = 11L# set lwp signal mask from sigset_t argument */
PCSTRACE = 12L# set traced signal set from sigset_t argument */
PCSFAULT = 13L# set traced fault set from fltset_t argument */
PCSENTRY = 14L# set traced syscall entry set from sysset_t arg */
PCSEXIT  = 15L# set traced syscall exit set from sysset_t arg */
PCSET    = 16L# set modes from long argument */
PCUNSET  = 17L# unset modes from long argument */
PCSREG   = 18L# set lwp general registers from prgregset_t arg */
PCSFPREG = 19L# set lwp floating-point registers from prfpregset_t */
PCSXREG  = 20L# set lwp extra registers from prxregset_t arg */
PCNICE   = 21L# set nice priority from long argument */
PCSVADDR = 22L# set %pc virtual address from long argument */
PCWATCH  = 23L# set/unset watched memory area from prwatch_t arg */
PCAGENT  = 24L# create agent lwp with regs from prgregset_t arg */
PCREAD   = 25L# read from the address space via priovec_t arg */
PCWRITE  = 26L# write to the address space via priovec_t arg */
PCSCRED  = 27L# set process credentials from prcred_t argument */
PCSASRS  = 28L# set ancillary state registers from asrset_t arg */
PCSPRIV  = 29L# set process privileges from prpriv_t argument */
PCSZONE  = 30L# set zoneid from zoneid_t argument */
PCSCREDX = 31L# as PCSCRED but with supplemental groups */

# PCRUN long operand flags.
PRCSIG   = 0x01# clear current signal, if any */
PRCFAULT = 0x02# clear current fault, if any */
PRSTEP   = 0x04# direct the lwp to single-step */
PRSABORT = 0x08# abort syscall, if in syscall */
PRSTOP   = 0x10# set directed stop request */

# Status flags
PR_STOPPED  = 0x00000001# lwp is stopped */
PR_ISTOP    = 0x00000002# lwp is stopped on an event of interest */
PR_DSTOP    = 0x00000004# lwp has a stop directive in effect */
PR_STEP     = 0x00000008# lwp has a single-step directive in effect */
PR_ASLEEP   = 0x00000010# lwp is sleeping in a system call */
PR_PCINVAL  = 0x00000020# contents of pr_instr undefined */
PR_ASLWP    = 0x00000040# obsolete flag; never set */
PR_AGENT    = 0x00000080# this lwp is the /proc agent lwp */
PR_DETACH   = 0x00000100# this is a detached lwp */
PR_DAEMON   = 0x00000200# this is a daemon lwp */
# The following flags apply to the process, not to an individual lwp */
PR_ISSYS    = 0x00001000# this is a system process */
PR_VFORKP   = 0x00002000# process is the parent of a vfork()d child */
PR_ORPHAN   = 0x00004000# process's process group is orphaned */
# The following process flags are modes settable by PCSET/PCUNSET */
PR_FORK     = 0x00100000# inherit-on-fork is in effect */
PR_RLC      = 0x00200000# run-on-last-close is in effect */
PR_KLC      = 0x00400000# kill-on-last-close is in effect */
PR_ASYNC    = 0x00800000# asynchronous-stop is in effect */
PR_MSACCT   = 0x01000000# micro-state usage accounting is in effect */
PR_BPTADJ   = 0x02000000# breakpoint trap pc adjustment is in effect */
PR_PTRACE   = 0x04000000# ptrace-compatibility mode is in effect */
PR_MSFORK   = 0x08000000# micro-state accounting inherited on fork */
PR_IDLE     = 0x10000000# lwp is a cpu's idle thread */


# Permissions...
MA_READ    = 0x04# readable by the traced process */
MA_WRITE   = 0x02# writable by the traced process */
MA_EXEC    = 0x01# executable by the traced process */
MA_SHARED  = 0x08# changes are shared by mapped object */
MA_ANON    = 0x40# anonymous memory (e.g. /dev/zero) */
MA_ISM     = 0x80# intimate shared mem (shared MMU resources) */
MA_NORESERVE = 0x100# mapped with MAP_NORESERVE */
MA_SHM     = 0x200# System V shared memory */
MA_RESERVED1 = 0x400# reserved for future use */

class SolarisMixin:

    def initMixin(self):
        #import sunprocfs
        self.ctl = None

    def platformGetRegs(self):
        pid = self.getPid()

    #def platformGetThreads(self):
        #ret = []
        #for name in os.listdir("/proc/%d/lwp" % self.pid):
            #ret.append(int(name))
        #return ret

    def platformAttach(self, pid):
        self.ctl = file("/proc/%d/ctl" % pid, "ab")
        self.ctl.write(struct.pack("<L", PRSTOP))

    def platformContinue(self):
        """
        Tell the process to continue running
        """
        self.writeCtl(struct.pack("<LL", PCRUN, 0))

    def platformWait(self):
        """
        wait for the process to do someting "interesting"
        """
        self.writeCtl(struct.pack("<L", PCWSTOP))
        bytes = file("/proc/%d/psinfo" % self.pid, "rb").read()
        return bytes

    def writeCtl(self, bytes):
        os.write(self.ctl.fileno(), bytes)

    def platformDetach(self):
        print "SOLARIS DETACH"
        self.ctl.close()
        self.ctl = None

class SolarisIntelMixin:
    """
    Handle register formats for the intel solaris stuff
    """
    def getRegisterFormat(self):
        return ""

    def getRegisterNames(self):
        return []

    def platformReadMemory(self, addr, size):
        a = array.array('c',"\x00" * size)
        baddr, blen = a.buffer_info()
        priovec = struct.pack("<4L",PCREAD, baddr, blen, addr)
        print repr(priovec)
        self.writeCtl(priovec)
        return a.tostring()

    def platformWriteMemory(self, addr, bytes):
        a = array.array('c',bytes)
        baddr,blen = a.buffer_info()
        priovec = struct.pack("<LLLL", PCWRITE, baddr, blen, addr)
        self.writeCtl(priovec)

    def platformGetMaps(self):
        ret = []
        pid = self.getPid()
        mapdata = file("/proc/%d/map" % pid, "rb").read()
        while mapdata:
            addr,size = struct.unpack("<LL", mapdata[:8])
            perms, = struct.unpack("<L", mapdata[80:84])
            perms = perms & 0x7
            ret.append((addr,size, perms, ""))
            mapdata = mapdata[96:]
        return ret


########NEW FILE########
__FILENAME__ = win32
"""
Win32 Platform Module
"""
# Copyright (C) 2007 Invisigoth - See LICENSE file for details
import os
import sys
import struct
import traceback
import platform

import PE

import vstruct
import vstruct.builder as vs_builder
import vstruct.defs.win32 as vs_win32
import vstruct.defs.windows as vs_windows

import vtrace
import vtrace.archs.i386 as v_i386
import vtrace.archs.amd64 as v_amd64
import vtrace.platforms.base as v_base

import envi
import envi.bits as e_bits
import envi.memory as e_mem
import envi.resolver as e_resolv
import envi.archs.i386 as e_i386
import envi.archs.amd64 as e_amd64

from ctypes import *
#from ctypes.wintypes import *

platdir = os.path.dirname(__file__)

kernel32 = None
dbghelp = None
psapi = None
ntdll = None
advapi32 = None

IsWow64Process = None

# Setup some ctypes helpers:
# NOTE: we don't use LPVOID because it can return None.
#       c_size_t is the designated platform word width int.
LPVOID = c_size_t
HANDLE  = LPVOID
SIZE_T  = LPVOID
QWORD   = c_ulonglong
DWORD   = c_ulong
WORD    = c_ushort
BOOL    = c_ulong
BYTE    = c_ubyte
NULL    = 0

INFINITE = 0xffffffff
EXCEPTION_MAXIMUM_PARAMETERS = 15

# Debug Event Types
EXCEPTION_DEBUG_EVENT       =1
CREATE_THREAD_DEBUG_EVENT   =2
CREATE_PROCESS_DEBUG_EVENT  =3
EXIT_THREAD_DEBUG_EVENT     =4
EXIT_PROCESS_DEBUG_EVENT    =5
LOAD_DLL_DEBUG_EVENT        =6
UNLOAD_DLL_DEBUG_EVENT      =7
OUTPUT_DEBUG_STRING_EVENT   =8
RIP_EVENT                   =9

# Symbol Flags
SYMFLAG_VALUEPRESENT     = 0x00000001
SYMFLAG_REGISTER         = 0x00000008
SYMFLAG_REGREL           = 0x00000010
SYMFLAG_FRAMEREL         = 0x00000020
SYMFLAG_PARAMETER        = 0x00000040
SYMFLAG_LOCAL            = 0x00000080
SYMFLAG_CONSTANT         = 0x00000100
SYMFLAG_EXPORT           = 0x00000200
SYMFLAG_FORWARDER        = 0x00000400
SYMFLAG_FUNCTION         = 0x00000800
SYMFLAG_VIRTUAL          = 0x00001000
SYMFLAG_THUNK            = 0x00002000
SYMFLAG_TLSREL           = 0x00004000

# Symbol Resolution Options
SYMOPT_CASE_INSENSITIVE         = 0x00000001
SYMOPT_UNDNAME                  = 0x00000002
SYMOPT_DEFERRED_LOADS           = 0x00000004
SYMOPT_NO_CPP                   = 0x00000008
SYMOPT_LOAD_LINES               = 0x00000010
SYMOPT_OMAP_FIND_NEAREST        = 0x00000020
SYMOPT_LOAD_ANYTHING            = 0x00000040
SYMOPT_IGNORE_CVREC             = 0x00000080
SYMOPT_NO_UNQUALIFIED_LOADS     = 0x00000100
SYMOPT_FAIL_CRITICAL_ERRORS     = 0x00000200
SYMOPT_EXACT_SYMBOLS            = 0x00000400
SYMOPT_ALLOW_ABSOLUTE_SYMBOLS   = 0x00000800
SYMOPT_IGNORE_NT_SYMPATH        = 0x00001000
SYMOPT_INCLUDE_32BIT_MODULES    = 0x00002000
SYMOPT_PUBLICS_ONLY             = 0x00004000
SYMOPT_NO_PUBLICS               = 0x00008000
SYMOPT_AUTO_PUBLICS             = 0x00010000
SYMOPT_NO_IMAGE_SEARCH          = 0x00020000
SYMOPT_SECURE                   = 0x00040000
SYMOPT_NO_PROMPTS               = 0x00080000
SYMOPT_OVERWRITE                = 0x00100000
SYMOPT_DEBUG                    = 0x80000000

# Exception Types
EXCEPTION_WAIT_0                     = 0x00000000L    
EXCEPTION_ABANDONED_WAIT_0           = 0x00000080L    
EXCEPTION_USER_APC                   = 0x000000C0L    
EXCEPTION_TIMEOUT                    = 0x00000102L    
EXCEPTION_PENDING                    = 0x00000103L    
DBG_EXCEPTION_HANDLED             = 0x00010001L    
DBG_CONTINUE                      = 0x00010002L    
EXCEPTION_SEGMENT_NOTIFICATION       = 0x40000005L    
DBG_TERMINATE_THREAD              = 0x40010003L    
DBG_TERMINATE_PROCESS             = 0x40010004L    
DBG_CONTROL_C                     = 0x40010005L    
DBG_CONTROL_BREAK                 = 0x40010008L    
DBG_COMMAND_EXCEPTION             = 0x40010009L    
EXCEPTION_GUARD_PAGE_VIOLATION       = 0x80000001L    
EXCEPTION_DATATYPE_MISALIGNMENT      = 0x80000002L    
EXCEPTION_BREAKPOINT                 = 0x80000003L    
EXCEPTION_SINGLE_STEP                = 0x80000004L    
DBG_EXCEPTION_NOT_HANDLED         = 0x80010001L    
EXCEPTION_ACCESS_VIOLATION           = 0xC0000005L    
EXCEPTION_IN_PAGE_ERROR              = 0xC0000006L    
EXCEPTION_INVALID_HANDLE             = 0xC0000008L    
EXCEPTION_NO_MEMORY                  = 0xC0000017L    
EXCEPTION_ILLEGAL_INSTRUCTION        = 0xC000001DL    
EXCEPTION_NONCONTINUABLE_EXCEPTION   = 0xC0000025L    
EXCEPTION_INVALID_DISPOSITION        = 0xC0000026L    
EXCEPTION_ARRAY_BOUNDS_EXCEEDED      = 0xC000008CL    
EXCEPTION_FLOAT_DENORMAL_OPERAND     = 0xC000008DL    
EXCEPTION_FLOAT_DIVIDE_BY_ZERO       = 0xC000008EL    
EXCEPTION_FLOAT_INEXACT_RESULT       = 0xC000008FL    
EXCEPTION_FLOAT_INVALID_OPERATION    = 0xC0000090L    
EXCEPTION_FLOAT_OVERFLOW             = 0xC0000091L    
EXCEPTION_FLOAT_STACK_CHECK          = 0xC0000092L    
EXCEPTION_FLOAT_UNDERFLOW            = 0xC0000093L    
EXCEPTION_INTEGER_DIVIDE_BY_ZERO     = 0xC0000094L    
EXCEPTION_INTEGER_OVERFLOW           = 0xC0000095L    
EXCEPTION_PRIVILEGED_INSTRUCTION     = 0xC0000096L    
EXCEPTION_STACK_OVERFLOW             = 0xC00000FDL    
EXCEPTION_CONTROL_C_EXIT             = 0xC000013AL    
EXCEPTION_FLOAT_MULTIPLE_FAULTS      = 0xC00002B4L    
EXCEPTION_FLOAT_MULTIPLE_TRAPS       = 0xC00002B5L    
EXCEPTION_REG_NAT_CONSUMPTION        = 0xC00002C9L    

# Context Info
CONTEXT_i386    = 0x00010000    # this assumes that i386 and
CONTEXT_i486    = 0x00010000    # i486 have identical context records
CONTEXT_AMD64   = 0x00100000    # For amd x64...

CONTEXT_CONTROL         = 0x00000001L # SS:SP, CS:IP, FLAGS, BP
CONTEXT_INTEGER         = 0x00000002L # AX, BX, CX, DX, SI, DI
CONTEXT_SEGMENTS        = 0x00000004L # DS, ES, FS, GS
CONTEXT_FLOATING_POINT  = 0x00000008L # 387 state
CONTEXT_DEBUG_REGISTERS = 0x00000010L # DB 0-3,6,7
CONTEXT_EXTENDED_REGISTERS  = 0x00000020L # cpu specific extensions
CONTEXT_FULL = (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS)
CONTEXT_ALL = (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS | CONTEXT_EXTENDED_REGISTERS)


# Thread Permissions
THREAD_ALL_ACCESS = 0x001f03ff
PROCESS_ALL_ACCESS = 0x001f0fff

# Memory Permissions
PAGE_NOACCESS = 0x01
PAGE_READONLY = 0x02
PAGE_READWRITE = 0x04
PAGE_WRITECOPY = 0x08
PAGE_EXECUTE = 0x10
PAGE_EXECUTE_READ = 0x20
PAGE_EXECUTE_READWRITE = 0x40
PAGE_EXECUTE_WRITECOPY = 0x80
PAGE_GUARD = 0x100
PAGE_NOCACHE = 0x200
PAGE_WRITECOMBINE = 0x400

# Map win32 permissions to envi permissions
perm_lookup = {
    PAGE_NOACCESS:0,
    PAGE_READONLY:e_mem.MM_READ,
    PAGE_READWRITE: e_mem.MM_READ | e_mem.MM_WRITE,
    PAGE_WRITECOPY: e_mem.MM_READ | e_mem.MM_WRITE,
    PAGE_EXECUTE: e_mem.MM_EXEC,
    PAGE_EXECUTE_READ: e_mem.MM_EXEC | e_mem.MM_READ,
    PAGE_EXECUTE_READWRITE: e_mem.MM_EXEC | e_mem.MM_READ | e_mem.MM_WRITE,
    PAGE_EXECUTE_WRITECOPY: e_mem.MM_EXEC | e_mem.MM_READ | e_mem.MM_WRITE,
}

# To get win32 permssions from envi permissions
perm_rev_lookup = {
    0:PAGE_NOACCESS,
    e_mem.MM_READ:PAGE_READONLY,
    e_mem.MM_READ|e_mem.MM_WRITE:PAGE_READWRITE,
    e_mem.MM_EXEC:PAGE_EXECUTE,
    e_mem.MM_EXEC|e_mem.MM_READ:PAGE_EXECUTE_READ,
    e_mem.MM_EXEC|e_mem.MM_READ|e_mem.MM_WRITE:PAGE_EXECUTE_READWRITE,
}

# Memory States
MEM_COMMIT = 0x1000
MEM_FREE = 0x10000
MEM_RESERVE = 0x2000

# Memory Types
MEM_IMAGE = 0x1000000
MEM_MAPPED = 0x40000
MEM_PRIVATE = 0x20000

# Process Creation Flags
DEBUG_ONLY_THIS_PROCESS = 0x02

MAX_PATH=260

class MSR(Structure):
    _fields_ = [
        ('msr', DWORD),
        ('value', QWORD),
    ]

# The enum of NtSystemDebugControl operations
SysDbgQueryModuleInformation = 0
SysDbgQueryTraceInformation = 1
SysDbgSetTracepoint = 2
SysDbgSetSpecialCall = 3
SysDbgClearSpecialCalls = 4
SysDbgQuerySpecialCalls = 5
SysDbgBreakPoint = 6
SysDbgQueryVersion = 7
SysDbgReadVirtual = 8
SysDbgWriteVirtual = 9
SysDbgReadPhysical = 10
SysDbgWritePhysical = 11
SysDbgReadControlSpace = 12
SysDbgWriteControlSpace = 13
SysDbgReadIoSpace = 14
SysDbgWriteIoSpace = 15
SysDbgReadMsr = 16
SysDbgWriteMsr = 17
SysDbgReadBusData = 18
SysDbgWriteBusData = 19
SysDbgCheckLowMemory = 20
SysDbgEnableKernelDebugger = 21
SysDbgDisableKernelDebugger = 22
SysDbgGetAutoKdEnable = 23
SysDbgSetAutoKdEnable = 24
SysDbgGetPrintBufferSize = 25
SysDbgSetPrintBufferSize = 26
SysDbgGetKdUmExceptionEnable = 27
SysDbgSetKdUmExceptionEnable = 28
SysDbgGetTriageDump = 29
SysDbgGetKdBlockEnable = 30
SysDbgSetKdBlockEnable = 31
SysDbgRegisterForUmBreakInfo = 32
SysDbgGetUmBreakPid = 33
SysDbgClearUmBreakPid = 34
SysDbgGetUmAttachPid = 35
SysDbgClearUmAttachPid = 36

def wrmsr(msrid, value):
    m = MSR()
    m.msr = msrid
    m.value = value
    mptr = addressof(m)
    x = ntdll.NtSystemDebugControl(SysDbgWriteMsr, mptr, sizeof(m), 0, 0, 0)
    if x != 0:
        raise vtrace.PlatformException('NtSystemDebugControl Failed: 0x%.8x' % kernel32.GetLastError())
    return 0

def rdmsr(msrid):
    m = MSR()
    m.msr = msrid
    m.value = 0

    mptr = addressof(m)
    msize = sizeof(m)

    x = ntdll.NtSystemDebugControl(SysDbgReadMsr, mptr, msize, mptr, msize, 0)
    if x != 0:
        raise vtrace.PlatformException('NtSystemDebugControl Failed: 0x%.8x' % kernel32.GetLastError())
    return m.value

SC_MANAGER_ALL_ACCESS           = 0xF003F
SC_MANAGER_CREATE_SERVICE       = 0x0002
SC_MANAGER_CONNECT              = 0x0001
SC_MANAGER_ENUMERATE_SERVICE    = 0x0004
SC_MANAGER_LOCK                 = 0x0008
SC_MANAGER_MODIFY_BOOT_CONFIG   = 0x0020
SC_MANAGER_QUERY_LOCK_STATUS    = 0x0010

SC_ENUM_PROCESS_INFO = 0

SERVICE_WIN32       = 0x30

SERVICE_ACTIVE      = 0x01
SERVICE_INNACTIVE   = 0x02
SERVICE_STATE_ALL   = 0x03

class SERVICE_STATUS_PROCESS(Structure):
    _fields_ = [
            ('dwServiceType', DWORD),
            ('dwCurrentState', DWORD),
            ('dwControlsAccepted', DWORD),
            ('dwWin32ExitCode', DWORD),
            ('dwServiceSpecificExitCode',DWORD),
            ('dwCheckPoint', DWORD),
            ('dwWaitHint', DWORD),
            ('dwProcessId', DWORD),
            ('dwServiceFlags', DWORD)
    ]
            
class ENUM_SERVICE_STATUS_PROCESS(Structure):
    _fields_ = [
            ('lpServiceName', c_wchar_p),
            ('lpDisplayName', c_wchar_p),
            ('ServiceStatusProcess', SERVICE_STATUS_PROCESS),
    ]

class EXCEPTION_RECORD(Structure):
    _fields_ = [
            ("ExceptionCode", DWORD),
            ("ExceptionFlags", DWORD),
            ("ExceptionRecord", LPVOID),
            ("ExceptionAddress", LPVOID),
            ("NumberParameters", c_ulong),
            ("ExceptionInformation", LPVOID * EXCEPTION_MAXIMUM_PARAMETERS)
            ]

class EXCEPTION_DEBUG_INFO(Structure):
    _fields_ = [
            ("ExceptionRecord", EXCEPTION_RECORD),
            ("FirstChance", c_ulong)
            ]

class CREATE_THREAD_DEBUG_INFO(Structure):
    _fields_ = [
            ("Thread", HANDLE),
            ("ThreadLocalBase", LPVOID),
            ("StartAddress", LPVOID)
            ]

class CREATE_PROCESS_DEBUG_INFO(Structure):
    _fields_ = [
            ("File", HANDLE),
            ("Process", HANDLE),
            ("Thread", HANDLE),
            ("BaseOfImage", LPVOID),
            ("DebugInfoFileOffset", c_ulong),
            ("DebugInfoSize", c_ulong),
            ("ThreadLocalBase", LPVOID),
            ("StartAddress", LPVOID),
            ("ImageName", LPVOID),
            ("Unicode", c_short),
            ]

class EXIT_THREAD_DEBUG_INFO(Structure):
    _fields_ = [("ExitCode", c_ulong),]

class EXIT_PROCESS_DEBUG_INFO(Structure):
    _fields_ = [("ExitCode", c_ulong),]

class LOAD_DLL_DEBUG_INFO(Structure):
    _fields_ = [
            ("File", HANDLE),
            ("BaseOfDll", LPVOID),
            ("DebugInfoFileOffset", c_ulong),
            ("DebugInfoSize", c_ulong),
            ("ImageName", LPVOID),
            ("Unicode", c_ushort),
            ]
class UNLOAD_DLL_DEBUG_INFO(Structure):
    _fields_ = [
            ("BaseOfDll", LPVOID),
            ]
class OUTPUT_DEBUG_STRING_INFO(Structure):
    _fields_ = [
            ("DebugStringData", LPVOID),
            ("Unicode", c_ushort),
            ("DebugStringLength", c_ushort),
            ]
class RIP_INFO(Structure):
    _fields_ = [
            ("Error", c_ulong),
            ("Type", c_ulong),
            ]

class DBG_EVENT_UNION(Union):
    _fields_ = [ ("Exception",EXCEPTION_DEBUG_INFO),
                 ("CreateThread", CREATE_THREAD_DEBUG_INFO),
                 ("CreateProcessInfo", CREATE_PROCESS_DEBUG_INFO),
                 ("ExitThread", EXIT_THREAD_DEBUG_INFO),
                 ("ExitProcess", EXIT_PROCESS_DEBUG_INFO),
                 ("LoadDll", LOAD_DLL_DEBUG_INFO),
                 ("UnloadDll", UNLOAD_DLL_DEBUG_INFO),
                 ("DebugString", OUTPUT_DEBUG_STRING_INFO),
                 ("RipInfo", RIP_INFO)]

class DEBUG_EVENT(Structure):
    _fields_ = [
            ("DebugEventCode", c_ulong),
            ("ProcessId", c_ulong),
            ("ThreadId", c_ulong),
            ("u", DBG_EVENT_UNION),
            ]

class FloatSavex86(Structure):
    _fields_ = [("ControlWord", c_ulong),
                  ("StatusWord", c_ulong),
                  ("TagWord", c_ulong),
                  ("ErrorOffset", c_ulong),
                  ("ErrorSelector", c_ulong),
                  ("DataOffset", c_ulong),
                  ("DataSelector", c_ulong),
                  ("RegisterSave", c_byte*80),
                  ("Cr0NpxState", c_ulong),
                  ]

class CONTEXTx64(Structure):
    _fields_ = [

        ("P1Home",c_ulonglong),
        ("P2Home",c_ulonglong),
        ("P3Home",c_ulonglong),
        ("P4Home",c_ulonglong),
        ("P5Home",c_ulonglong),
        ("P6Home",c_ulonglong),

        ("ContextFlags", DWORD),
        ("MxCsr",DWORD),

        ("cs",WORD),
        ("ds",WORD),
        ("es",WORD),
        ("fs", WORD),
        ("gs",WORD),
        ("ss",WORD),
        ("eflags",DWORD),

        ("debug0",c_ulonglong),
        ("debug1",c_ulonglong),
        ("debug2",c_ulonglong),
        ("debug3",c_ulonglong),
        ("debug6",c_ulonglong),
        ("debug7",c_ulonglong),

        ("rax",c_ulonglong),
        ("rcx",c_ulonglong),
        ("rdx",c_ulonglong),
        ("rbx",c_ulonglong),
        ("rsp",c_ulonglong),
        ("rbp",c_ulonglong),
        ("rsi",c_ulonglong),
        ("rdi",c_ulonglong),
        ("r8",c_ulonglong),
        ("r9",c_ulonglong),
        ("r10",c_ulonglong),
        ("r11",c_ulonglong),
        ("r12",c_ulonglong),
        ("r13",c_ulonglong),
        ("r14",c_ulonglong),
        ("r15",c_ulonglong),
        ("rip",c_ulonglong),

        ("foo",c_ulonglong*200),

        #union {
            #XMM_SAVE_AREA32 FltSave,
            #struct {
                #M128A Header[2],
                #M128A Legacy[8],
                #M128A Xmm0,
                #M128A Xmm1,
                #M128A Xmm2,
                #M128A Xmm3,
                #M128A Xmm4,
                #M128A Xmm5,
                #M128A Xmm6,
                #M128A Xmm7,
                #M128A Xmm8,
                #M128A Xmm9,
                #M128A Xmm10,
                #M128A Xmm11,
                #M128A Xmm12,
                #M128A Xmm13,
                #M128A Xmm14,
                #M128A Xmm15,
            #},
        #},

        #M128A VectorRegister[26],
        #(VectorControl,c_ulonglong),

        #(DebugControl,c_ulonglong),
        #(LastBranchToRip,c_ulonglong),
        #(LastBranchFromRip,c_ulonglong),
        #(LastExceptionToRip,c_ulonglong),
        #(LastExceptionFromRip,c_ulonglong),
    ]

    def regPostProcess(self):
        pass

# Used for xmm registers
class M128A(Structure):
    _fields_ = [
            ('Low', c_ulonglong),
            ('High', c_ulonglong),
    ]

class ExtendedXmmx86(Structure):
    _fields_ = [
            ('Header', M128A * 2),
            ('Legacy', M128A * 8),
            ('_xmm0',   M128A),
            ('_xmm1',   M128A),
            ('_xmm2',   M128A),
            ('_xmm3',   M128A),
            ('_xmm4',   M128A),
            ('_xmm5',   M128A),
            ('_xmm6',   M128A),
            ('_xmm7',   M128A),
            ("Pad", c_byte * 224),
    ]

class CONTEXTx86(Structure):
    _fields_ = [   ("ContextFlags", c_ulong),
                   ("debug0", c_ulong),
                   ("debug1", c_ulong),
                   ("debug2", c_ulong),
                   ("debug3", c_ulong),
                   ("debug6", c_ulong),
                   ("debug7", c_ulong),
                   ("FloatSave", FloatSavex86),
                   ("gs", c_ulong),
                   ("fs", c_ulong),
                   ("es", c_ulong),
                   ("ds", c_ulong),
                   ("edi", c_ulong),
                   ("esi", c_ulong),
                   ("ebx", c_ulong),
                   ("edx", c_ulong),
                   ("ecx", c_ulong),
                   ("eax", c_ulong),
                   ("ebp", c_ulong),
                   ("eip", c_ulong),
                   ("cs", c_ulong),
                   ("eflags", c_ulong),
                   ("esp", c_ulong),
                   ("ss", c_ulong),

                   #("Extension", c_byte * 512),
                   ('Extension', ExtendedXmmx86),

                    #M128A Header[2],
                    #M128A Legacy[8],
                    #M128A Xmm0,
                    #M128A Xmm1,
                    #M128A Xmm2,
                    #M128A Xmm3,
                    #M128A Xmm4,
                    #M128A Xmm5,
                    #M128A Xmm6,
                    #M128A Xmm7,
                   ]

    def regPostProcess(self):
        self.xmm0 = (self.Extension._xmm0.High << 8) + self.Extension._xmm0.Low
        self.xmm1 = (self.Extension._xmm1.High << 8) + self.Extension._xmm1.Low
        self.xmm2 = (self.Extension._xmm2.High << 8) + self.Extension._xmm2.Low
        self.xmm3 = (self.Extension._xmm3.High << 8) + self.Extension._xmm3.Low
        self.xmm4 = (self.Extension._xmm4.High << 8) + self.Extension._xmm4.Low
        self.xmm5 = (self.Extension._xmm5.High << 8) + self.Extension._xmm5.Low
        self.xmm6 = (self.Extension._xmm6.High << 8) + self.Extension._xmm6.Low
        self.xmm7 = (self.Extension._xmm7.High << 8) + self.Extension._xmm7.Low

class MEMORY_BASIC_INFORMATION(Structure):
    _fields_ = [
        ("BaseAddress", SIZE_T),
        ("AllocationBase", SIZE_T),
        ("AllocationProtect", DWORD),
        ("RegionSize", SIZE_T),
        ("State", DWORD),
        ("Protect", DWORD),
        ("Type", DWORD),
        ]

class STARTUPINFO(Structure):
    """
    Passed into CreateProcess
    """
    _fields_ = [
            ("db", c_ulong),
            ("Reserved", c_char_p),
            ("Desktop", c_char_p),
            ("Title", c_char_p),
            ("X", c_ulong),
            ("Y", c_ulong),
            ("XSize", c_ulong),
            ("YSize", c_ulong),
            ("XCountChars", c_ulong),
            ("YCountChars", c_ulong),
            ("FillAttribute", c_ulong),
            ("Flags", c_ulong),
            ("ShowWindow", c_ushort),
            ("Reserved2", c_ushort),
            ("Reserved3", LPVOID),
            ("StdInput", c_ulong),
            ("StdOutput", c_ulong),
            ("StdError", c_ulong),
            ]

class PROCESS_INFORMATION(Structure):
    _fields_ = [
            ("Process", HANDLE),
            ("Thread", HANDLE),
            ("ProcessId", c_ulong),
            ("ThreadId", c_ulong),
            ]

class SYMBOL_INFO(Structure):
    _fields_ = [
                ("SizeOfStruct", c_ulong),
                ("TypeIndex", c_ulong),
                ("Reserved1", c_ulonglong),
                ("Reserved2", c_ulonglong),
                ("Index", c_ulong),
                ("Size", c_ulong),
                ("ModBase", c_ulonglong),
                ("Flags", c_ulong),
                ("Value", c_ulonglong),
                ("Address", c_ulonglong),
                ("Register", c_ulong),
                ("Scope", c_ulong),
                ("Tag", c_ulong),
                ("NameLen", c_ulong),
                ("MaxNameLen", c_ulong),
                ("Name", c_char * 2000), # MAX_SYM_NAME
                ]

class IMAGEHLP_MODULE64(Structure):
    _fields_ = [
            ("SizeOfStruct", c_ulong),
            ("BaseOfImage", c_ulonglong),
            ("ImageSize", c_ulong),
            ("TimeDateStamp", c_ulong),
            ("CheckSum", c_ulong),
            ("NumSyms", c_ulong),
            ("SymType", c_ulong),
            ("ModuleName", c_char*32),
            ("ImageName", c_char*256),
            ("LoadedImageName", c_char*256),
            ("LoadedPdbName", c_char*256),
            ("CvSig", c_ulong),
            ("CvData", c_char*(MAX_PATH*3)),
            ("PdbSig", c_ulong),
            ("PdbSig70", c_char * 16), #GUID
            ("PdbAge", c_ulong),
            ("PdbUnmatched", c_ulong),
            ("DbgUnmatched", c_ulong),
            ("LineNumbers", c_ulong),
            ("GlobalSymbols", c_ulong),
            ("TypeInfo", c_ulong),
            ]

class IMAGEHLP_STACK_FRAME(Structure):
    _fields_ = [
        ('InstructionOffset',     QWORD),
        ('ReturnOffset',          QWORD),
        ('FrameOffset',           QWORD),
        ('StackOffset',           QWORD),
        ('BackingStoreOffset',    QWORD),
        ('FuncTableEntry',        QWORD),
        ('Params',                QWORD*4),
        ('Reserved',              QWORD*5),
        ('Virtual',               BOOL),
        ('Reserved2',             DWORD),
    ]

IMAGE_DIRECTORY_ENTRY_EXPORT          =0   # Export Directory
IMAGE_DIRECTORY_ENTRY_IMPORT          =1   # Import Directory
IMAGE_DIRECTORY_ENTRY_RESOURCE        =2   # Resource Directory
IMAGE_DIRECTORY_ENTRY_EXCEPTION       =3   # Exception Directory
IMAGE_DIRECTORY_ENTRY_SECURITY        =4   # Security Directory
IMAGE_DIRECTORY_ENTRY_BASERELOC       =5   # Base Relocation Table
IMAGE_DIRECTORY_ENTRY_DEBUG           =6   # Debug Directory
IMAGE_DIRECTORY_ENTRY_COPYRIGHT       =7   # (X86 usage)
IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    =7   # Architecture Specific Data
IMAGE_DIRECTORY_ENTRY_GLOBALPTR       =8   # RVA of GP
IMAGE_DIRECTORY_ENTRY_TLS             =9   # TLS Directory
IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    =10   # Load Configuration Directory
IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   =11   # Bound Import Directory in headers
IMAGE_DIRECTORY_ENTRY_IAT            =12   # Import Address Table
IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   =13   # Delay Load Import Descriptors
IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR =14   # COM Runtime descriptor

IMAGE_DEBUG_TYPE_UNKNOWN          =0
IMAGE_DEBUG_TYPE_COFF             =1
IMAGE_DEBUG_TYPE_CODEVIEW         =2
IMAGE_DEBUG_TYPE_FPO              =3
IMAGE_DEBUG_TYPE_MISC             =4
IMAGE_DEBUG_TYPE_EXCEPTION        =5
IMAGE_DEBUG_TYPE_FIXUP            =6
IMAGE_DEBUG_TYPE_OMAP_TO_SRC      =7
IMAGE_DEBUG_TYPE_OMAP_FROM_SRC    =8
IMAGE_DEBUG_TYPE_BORLAND          =9
IMAGE_DEBUG_TYPE_RESERVED10       =10
IMAGE_DEBUG_TYPE_CLSID            =11

SSRVOPT_CALLBACK            = 0x0001
SSRVOPT_DWORD               = 0x0002
SSRVOPT_DWORDPTR            = 0x0004
SSRVOPT_GUIDPTR             = 0x0008
SSRVOPT_OLDGUIDPTR          = 0x0010
SSRVOPT_UNATTENDED          = 0x0020
SSRVOPT_NOCOPY              = 0x0040
SSRVOPT_PARENTWIN           = 0x0080
SSRVOPT_PARAMTYPE           = 0x0100
SSRVOPT_SECURE              = 0x0200
SSRVOPT_TRACE               = 0x0400
SSRVOPT_SETCONTEXT          = 0x0800
SSRVOPT_PROXY               = 0x1000
SSRVOPT_DOWNSTREAM_STORE    = 0x2000

TI_GET_SYMTAG                   = 0
TI_GET_SYMNAME                  = 1
TI_GET_LENGTH                   = 2
TI_GET_TYPE                     = 3
TI_GET_TYPEID                   = 4
TI_GET_BASETYPE                 = 5
TI_GET_ARRAYINDEXTYPEID         = 6
TI_FINDCHILDREN                 = 7
TI_GET_DATAKIND                 = 8
TI_GET_ADDRESSOFFSET            = 9
TI_GET_OFFSET                   = 10
TI_GET_VALUE                    = 11
TI_GET_COUNT                    = 12
TI_GET_CHILDRENCOUNT            = 13
TI_GET_BITPOSITION              = 14
TI_GET_VIRTUALBASECLASS         = 15
TI_GET_VIRTUALTABLESHAPEID      = 16
TI_GET_VIRTUALBASEPOINTEROFFSET = 17
TI_GET_CLASSPARENTID            = 18
TI_GET_NESTED                   = 19
TI_GET_SYMINDEX                 = 20
TI_GET_LEXICALPARENT            = 21
TI_GET_ADDRESS                  = 22
TI_GET_THISADJUST               = 23
TI_GET_UDTKIND                  = 24
TI_IS_EQUIV_TO                  = 25
TI_GET_CALLING_CONVENTION       = 26

SymTagNull              = 0
SymTagExe               = 1
SymTagCompiland         = 2
SymTagCompilandDetails  = 3
SymTagCompilandEnv      = 4
SymTagFunction          = 5
SymTagBlock             = 6
SymTagData              = 7
SymTagAnnotation        = 8
SymTagLabel             = 9
SymTagPublicSymbol      = 10
SymTagUDT               = 11
SymTagEnum              = 12
SymTagFunctionType      = 13
SymTagPointerType       = 14
SymTagArrayType         = 15
SymTagBaseType          = 16
SymTagTypedef           = 17
SymTagBaseClass         = 18
SymTagFriend            = 19
SymTagFunctionArgType   = 20
SymTagFuncDebugStart    = 21
SymTagFuncDebugEnd      = 22
SymTagUsingNamespace    = 23
SymTagVTableShape       = 24
SymTagVTable            = 25
SymTagCustom            = 26
SymTagThunk             = 27
SymTagCustomType        = 28
SymTagManagedType       = 29
SymTagDimension         = 30
SymTagMax               = 31

class IMAGE_DEBUG_DIRECTORY(Structure):
    _fields_ = [
            ("Characteristics", c_ulong),
            ("TimeDateStamp", c_ulong),
            ("MajorVersion", c_ushort),
            ("MinorVersion", c_ushort),
            ("Type", c_ulong),
            ("SizeOfData", c_ulong),
            ("AddressOfRawData", c_ulong),
            ("PointerToRawData", c_ulong),
            ]

NT_LIST_HANDLES = 16

ACCESS_MASK = DWORD
class SYSTEM_HANDLE(Structure):
    _fields_ = [
    ('ProcessID'        , c_ulong),
    ('HandleType'       , c_byte),
    ('Flags'            , c_byte),
    ('HandleNumber' , c_ushort),
    ('KernelAddress'    , LPVOID),
    ('GrantedAccess'    , ACCESS_MASK),
    ]
PSYSTEM_HANDLE = POINTER(SYSTEM_HANDLE)

# OBJECT_INFORMATION_CLASS
ObjectBasicInformation      = 0
ObjectNameInformation       = 1
ObjectTypeInformation       = 2
ObjectAllTypesInformation   = 3
ObjectHandleInformation     = 4

# ProcessInformationClass
ProcessBasicInformation = 0  # Get pointer to PEB
ProcessDebugPort        = 7  # Get DWORD_PTR to debug port number
ProcessWow64Information = 26 # Get WOW64 status
# FIXME may be more reliable to use this! \|/
ProcessImageFileName    = 27 # Get a UNICODE_STRING of the filename
ProcessExecuteFlags     = 34 # Get DWORD of execute status (including DEP) (bug: your process only)

class UNICODE_STRING(Structure):
    _fields_ = (
        ("Length",c_ushort),
        ("MaximumLength", c_ushort),
        ("Buffer", c_wchar_p)
    )
PUNICODE_STRING = POINTER(UNICODE_STRING)

class OBJECT_TYPE_INFORMATION(Structure):
    _fields_ = (
        ("String",UNICODE_STRING),
        ("reserved", c_uint * 22)
    )

object_type_map = {
    "File":vtrace.FD_FILE,
    "Directory":vtrace.FD_FILE,
    "Event":vtrace.FD_EVENT,
    "KeyedEvent":vtrace.FD_EVENT,
    "Mutant":vtrace.FD_LOCK,
    "Semaphore":vtrace.FD_LOCK,
    "Key":vtrace.FD_REGKEY,
    "Port":vtrace.FD_UNKNOWN,
    "Section":vtrace.FD_UNKNOWN,
    "IoCompletion":vtrace.FD_UNKNOWN,
    "Desktop":vtrace.FD_UNKNOWN,
    "WindowStation":vtrace.FD_UNKNOWN,
}

class LUID(Structure):
    _fields_ = (
        ("LowPart", c_ulong),
        ("HighPart", c_ulong)
    )

class TOKEN_PRIVILEGES(Structure):
    # This isn't really universal, more just for one priv use
    _fields_ = (
        ("PrivilegeCount", c_ulong), # Always one
        ("Privilege", LUID),
        ("PrivilegeAttribute", c_ulong)
    )

# All platforms must be able to import this module (for exceptions etc..)
# (do this stuff *after* we define some types...)
if sys.platform == "win32":

    kernel32 = windll.kernel32
    # We need to inform some of the APIs about their args
    kernel32.OpenProcess.argtypes = [DWORD, BOOL, DWORD]
    kernel32.OpenProcess.restype = HANDLE
    kernel32.CreateProcessA.argtypes = [LPVOID, c_char_p, LPVOID, LPVOID, c_uint, DWORD, LPVOID, LPVOID, LPVOID, LPVOID]
    kernel32.ReadProcessMemory.argtypes = [HANDLE, LPVOID, LPVOID, SIZE_T, LPVOID]
    kernel32.WriteProcessMemory.argtypes = [HANDLE, LPVOID, c_char_p, SIZE_T, LPVOID]
    kernel32.GetThreadContext.argtypes = [HANDLE, LPVOID]
    kernel32.SetThreadContext.argtypes = [HANDLE, LPVOID]
    kernel32.CreateRemoteThread.argtypes = [HANDLE, LPVOID, SIZE_T, LPVOID, LPVOID, DWORD, LPVOID]
    kernel32.SuspendThread.argtypes = [HANDLE,]
    kernel32.ResumeThread.argtypes = [HANDLE,]
    kernel32.VirtualQueryEx.argtypes = [HANDLE, LPVOID, LPVOID, SIZE_T]
    kernel32.DebugBreakProcess.argtypes = [HANDLE,]
    kernel32.CloseHandle.argtypes = [HANDLE,]
    kernel32.GetLogicalDriveStringsA.argtypes = [DWORD, LPVOID]
    kernel32.TerminateProcess.argtypes = [HANDLE, DWORD]
    kernel32.VirtualProtectEx.argtypes = [HANDLE, LPVOID, SIZE_T, DWORD, LPVOID]
    kernel32.VirtualAllocEx.argtypes = [HANDLE, LPVOID, SIZE_T, DWORD, DWORD]
    kernel32.VirtualFreeEx.argtypes = [HANDLE, LPVOID, SIZE_T, DWORD]
    kernel32.DuplicateHandle.argtypes = [HANDLE, HANDLE, HANDLE, LPVOID, DWORD, DWORD, DWORD]
    kernel32.SetEvent.argtypes = [HANDLE, ]

    IsWow64Process = getattr(kernel32, 'IsWow64Process', None)
    if IsWow64Process != None:
        IsWow64Process.argtypes = [HANDLE, LPVOID]



    psapi = windll.psapi
    psapi.GetModuleFileNameExW.argtypes = [HANDLE, HANDLE, LPVOID, DWORD]
    psapi.GetMappedFileNameW.argtypes = [HANDLE, LPVOID, LPVOID, DWORD]

    ntdll = windll.ntdll
    ntdll.NtQuerySystemInformation.argtypes = [DWORD, LPVOID, DWORD, LPVOID]
    ntdll.NtQueryObject.argtypes = [HANDLE, DWORD, c_void_p, DWORD, LPVOID]
    ntdll.NtQueryInformationProcess.argtypes = [HANDLE, DWORD, c_void_p, DWORD, LPVOID]
    ntdll.NtSystemDebugControl.restype = SIZE_T


    try:

        SYMCALLBACK = WINFUNCTYPE(BOOL, POINTER(SYMBOL_INFO), c_ulong, LPVOID)
        PDBCALLBACK = WINFUNCTYPE(BOOL, c_char_p, LPVOID)

        arch_name = envi.getCurrentArch()
        symsrv = windll.LoadLibrary(os.path.join(platdir, "windll", arch_name, "symsrv.dll"))
        dbghelp = windll.LoadLibrary(os.path.join(platdir, "windll", arch_name, "dbghelp.dll"))
        dbghelp.SymInitialize.argtypes = [HANDLE, c_char_p, BOOL]
        dbghelp.SymInitialize.restype = BOOL
        dbghelp.SymSetOptions.argtypes = [DWORD]
        dbghelp.SymSetOptions.restype = DWORD
        dbghelp.SymCleanup.argtypes = [HANDLE]
        dbghelp.SymCleanup.restype = BOOL
        dbghelp.SymLoadModule64.argtypes = [HANDLE, HANDLE, c_char_p, c_char_p, QWORD, DWORD]
        dbghelp.SymLoadModule64.restype = QWORD
        dbghelp.SymGetModuleInfo64.argtypes = [HANDLE, QWORD, POINTER(IMAGEHLP_MODULE64)]
        dbghelp.SymSetContext.restype = BOOL
        dbghelp.SymSetContext.argtypes = [ HANDLE, POINTER(IMAGEHLP_STACK_FRAME), LPVOID ]
        dbghelp.SymGetModuleInfo64.restype = BOOL
        dbghelp.SymEnumSymbols.argtypes = [HANDLE, QWORD, c_char_p, SYMCALLBACK, LPVOID]
        dbghelp.SymEnumSymbols.restype = BOOL
        dbghelp.SymEnumTypes.argtypes = [HANDLE, QWORD, SYMCALLBACK, LPVOID]
        dbghelp.SymEnumTypes.restype = BOOL
        dbghelp.SymGetTypeInfo.argtypes = [HANDLE, QWORD, DWORD, DWORD, c_void_p]
        dbghelp.SymGetTypeInfo.restype = BOOL
        dbghelp.SymFromAddr.argtypes = [HANDLE, QWORD, POINTER(QWORD), POINTER(SYMBOL_INFO) ]

    except Exception, e:
        print "WARNING: Failed to import dbghelp/symsrv: %s" % e

    advapi32 = windll.advapi32
    advapi32.LookupPrivilegeValueA.argtypes = [LPVOID, c_char_p, LPVOID]
    advapi32.OpenProcessToken.argtypes = [HANDLE, DWORD, HANDLE]
    advapi32.AdjustTokenPrivileges.argtypes = [HANDLE, DWORD, LPVOID, DWORD, LPVOID, LPVOID]
    advapi32.OpenSCManagerA.argtypes = [ LPVOID, LPVOID, DWORD ]
    advapi32.OpenSCManagerA.restype = HANDLE
    advapi32.EnumServicesStatusExW.argtypes = [ HANDLE,
                                                LPVOID,
                                                DWORD,
                                                DWORD,
                                                LPVOID,
                                                DWORD,
                                                LPVOID,
                                                LPVOID,
                                                LPVOID,
                                                LPVOID ]
    advapi32.EnumServicesStatusExW.restype = BOOL
    advapi32.CloseServiceHandle.argtypes = [ HANDLE, ]
    advapi32.CloseServiceHandle.restype = BOOL
    advapi32.GetTokenInformation.argtypes = [HANDLE, DWORD, LPVOID, DWORD, LPVOID]
    advapi32.GetTokenInformation.restype = BOOL


def getServicesList():
    '''
    Get a list of (pid, servicename, displayname) tuples for the
    currently running services.
    '''

    ret = []
    scmh = advapi32.OpenSCManagerA(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE)

    try:
        dwSvcSize  = DWORD(0)
        dwSvcCount = DWORD(0)

        advapi32.EnumServicesStatusExW( scmh,
                                        SC_ENUM_PROCESS_INFO,
                                        SERVICE_WIN32,
                                        SERVICE_ACTIVE,
                                        NULL,
                                        0,
                                        addressof(dwSvcSize),
                                        addressof(dwSvcCount),
                                        NULL,
                                        NULL)

        buf = create_string_buffer(dwSvcSize.value)

        #print 'NEEDED',dwSvcSize
        #print 'COUNT',dwSvcCount

        advapi32.EnumServicesStatusExW( scmh,
                                        SC_ENUM_PROCESS_INFO,
                                        SERVICE_WIN32,
                                        SERVICE_ACTIVE,
                                        addressof(buf),
                                        dwSvcSize.value,
                                        addressof(dwSvcSize),
                                        addressof(dwSvcCount),
                                        NULL,
                                        NULL)

        #p = POINTER(ENUM_SERVICE_STATUS_PROCESS)(addressof(buf))
        p = cast(buf, POINTER(ENUM_SERVICE_STATUS_PROCESS))

        for i in xrange(dwSvcCount.value):
            pid = p[i].ServiceStatusProcess.dwProcessId
            name = p[i].lpServiceName
            descr = p[i].lpDisplayName
            ret.append((pid, name, descr))

    finally:
        advapi32.CloseServiceHandle(scmh)

    return ret

x = '''
BOOL WINAPI EnumServicesStatusEx(
  __in         SC_HANDLE hSCManager,
  __in         SC_ENUM_TYPE InfoLevel,
  __in         DWORD dwServiceType,
  __in         DWORD dwServiceState,
  __out_opt    LPBYTE lpServices,
  __in         DWORD cbBufSize,
  __out        LPDWORD pcbBytesNeeded,
  __out        LPDWORD lpServicesReturned,
  __inout_opt  LPDWORD lpResumeHandle,
  __in_opt     LPCTSTR pszGroupName
);
'''

SE_PRIVILEGE_ENABLED    = 0x00000002
TOKEN_ADJUST_PRIVILEGES = 0x00000020
TOKEN_QUERY             = 0x00000008
dbgprivdone = False

# TOKEN_INFORMATION_CLASS
TokenUser                   = 1
TokenGroups                 = 2
TokenPrivileges             = 3
TokenOwner                  = 4
TokenPrimaryGroup           = 5
TokenDefaultDacl            = 6
TokenSource                 = 7
TokenType                   = 8
TokenImpersonationLevel     = 9
TokenStatistics             = 10
TokenRestrictedSids         = 11
TokenSessionId              = 12
TokenGroupsAndPrivileges    = 13
TokenSessionReference       = 14
TokenSandBoxInert           = 15
TokenAuditPolicy            = 16
TokenOrigin                 = 17
TokenElevationType          = 18
TokenLinkedToken            = 19
TokenElevation              = 20
TokenHasRestrictions        = 21
TokenAccessInformation      = 22
TokenVirtualizationAllowed  = 23
TokenVirtualizationEnabled  = 24
TokenIntegrityLevel         = 25
TokenUIAccess               = 26
TokenMandatoryPolicy        = 27
TokenLogonSid               = 28
MaxTokenInfoClass           = 29

# TOKEN_ELEVATION_TYPE
TokenElevationTypeDefault   = 1
TokenElevationTypeFull      = 2
TokenElevationTypeLimited   = 3

def getTokenElevationType(handle=-1):

    token = HANDLE(0)
    etype = DWORD(0)
    outsize = DWORD(0)
    if not advapi32.OpenProcessToken(handle, TOKEN_QUERY, addressof(token)):
        raise Exception('Invalid Process Handle: %d' % handle)

    advapi32.GetTokenInformation(token, TokenElevationType, addressof(etype), 4, addressof(outsize))

    return etype.value

if __name__ == '__main__':
    print getTokenElevationType()

def getDebugPrivileges():
    tokprivs = TOKEN_PRIVILEGES()
    dbgluid = LUID()
    token = HANDLE(0)

    if not advapi32.LookupPrivilegeValueA(0, "seDebugPrivilege", addressof(dbgluid)):
        print "LookupPrivilegeValue Failed: %d" % kernel32.GetLastError()
        return False

    if not advapi32.OpenProcessToken(-1, TOKEN_ADJUST_PRIVILEGES, addressof(token)):
        print "kernel32.OpenProcessToken Failed: %d" % kernel32.GetLastError()
        return False

    tokprivs.PrivilegeCount = 1
    tokprivs.Privilege = dbgluid
    tokprivs.PrivilegeAttribute = SE_PRIVILEGE_ENABLED

    if not advapi32.AdjustTokenPrivileges(token, 0, addressof(tokprivs), 0, 0, 0):
        kernel32.CloseHandle(token)
        print "AdjustTokenPrivileges Failed: %d" % kernel32.GetLastError()
        return False

    kernel32.CloseHandle(token)

def buildSystemHandleInformation(count):
    """
    Dynamically build the structure definition for the
    handle info list.
    """
    class SYSTEM_HANDLE_INFORMATION(Structure):
        _fields_ = [ ('Count', c_ulong), ('Handles', SYSTEM_HANDLE * count), ]
    return SYSTEM_HANDLE_INFORMATION()

def buildFindChildrenParams(count):
    class TI_FINDCHILDREN_PARAMS(Structure):
        _fields_ = [ ('Count', c_ulong), ('Start', c_ulong), ("Children",c_ulong * count),]
    tif = TI_FINDCHILDREN_PARAMS()
    tif.Count = count
    return tif

def raiseWin32Error(name):
    raise vtrace.PlatformException("Win32 Error %s failed: %s" % (name,kernel32.GetLastError()))

def GetModuleFileNameEx(phandle, mhandle):

    buf = create_unicode_buffer(1024)
    psapi.GetModuleFileNameExW(phandle, mhandle, addressof(buf), 1024)
    return buf.value

av_einfo_perms = [e_mem.MM_READ, e_mem.MM_WRITE, None, None, None, None, None, None, e_mem.MM_EXEC]

class WindowsMixin:

    """
    A mixin to handle all non-arch specific win32 stuff.
    """

    def __init__(self):

        self.casesens = False

        self.phandle = None
        self.thandles = {}
        self.win32threads = {}
        self.dosdevs = []
        self.flushcache = False
        self.faultaddr = None
        global dbgprivdone
        if not dbgprivdone:
            dbgprivdone = getDebugPrivileges()

        self._is_wow64 = False  # 64 bit trace uses this...

        # Skip the attach event and plow through to the first
        # injected breakpoint (cause libs are loaded by then)
        self.enableAutoContinue(vtrace.NOTIFY_ATTACH)

        self.setupDosDeviceMaps()

        # Setup our binary format meta
        self.setMeta('Format','pe')

        # Setup some win32_ver info in metadata
        rel,ver,csd,ptype = platform.win32_ver()
        self.setMeta("WindowsRelease",rel)
        self.setMeta("WindowsVersion", ver)
        self.setMeta("WindowsCsd", csd)
        self.setMeta("WindowsProcessorType", ptype)

        # Setup modes which only apply to windows systems
        self.initMode('BlockStep', False, 'Single step to branch entry points')

        # If possible, get a default set of struct definitions
        # for ntdll...
        nt = vs_windows.getCurrentDef('ntdll')
        if nt != None:
            self.vsbuilder.addVStructNamespace('ntdll', nt)

        # Either way, add the fallback "win32" namespace
        self.vsbuilder.addVStructNamespace('win32', vs_win32)

        # We need thread proxying for a few calls...
        self.fireTracerThread()

    def platformGetFds(self):
        ret = []
        hinfo = self.getHandles()
        for x in range(hinfo.Count):
            if hinfo.Handles[x].ProcessID != self.pid:
                continue
            hand = hinfo.Handles[x].HandleNumber
            myhand = self.dupHandle(hand)
            typestr = self.getHandleInfo(myhand, ObjectTypeInformation)
            wait = False
            if typestr == "File":
                wait = True
            namestr = self.getHandleInfo(myhand, ObjectNameInformation, wait=wait)
            kernel32.CloseHandle(myhand)
            htype = object_type_map.get(typestr, vtrace.FD_UNKNOWN)
            ret.append( (hand, htype, "%s: %s" % (typestr,namestr)) )
        return ret

    def _winJitEvent(self, handle):
        kernel32.SetEvent(handle)

    def dupHandle(self, handle):
        """
        Duplicate the handle (who's id is in the currently attached
        target process) and return our own copy.
        """
        hret = c_uint(0)
        kernel32.DuplicateHandle(self.phandle, handle,
                                 kernel32.GetCurrentProcess(), addressof(hret),
                                 0, False, 2) # DUPLICATE_SAME_ACCESS
        return hret.value

    def getHandleInfo(self, handle, itype=ObjectTypeInformation, wait=False):

        retSiz = c_uint(0)
        buf = create_string_buffer(100)

        # Some NtQueryObject calls will hang, lets figgure out which...
        if wait:
            if kernel32.WaitForSingleObject(handle, 150) == EXCEPTION_TIMEOUT:
                return "_TIMEOUT_"

        x = ntdll.NtQueryObject(handle, itype,
                buf, sizeof(buf), addressof(retSiz))
        if x != 0:
            return 'Error 0x%.8x' % (e_bits.unsigned(x, self.psize))

        realbuf = create_string_buffer(retSiz.value)

        if ntdll.NtQueryObject(handle, itype,
                realbuf, sizeof(realbuf), addressof(retSiz)) == 0:

            uString = cast(realbuf, PUNICODE_STRING).contents
            return uString.Buffer
        return "Unknown"

    def getHandles(self):

        hinfo = buildSystemHandleInformation(1)
        hsize = c_ulong(sizeof(hinfo))

        ntdll.NtQuerySystemInformation(NT_LIST_HANDLES, addressof(hinfo), hsize, addressof(hsize))

        count = (hsize.value-4) / sizeof(SYSTEM_HANDLE)
        hinfo = buildSystemHandleInformation(count)
        hsize = c_ulong(sizeof(hinfo))

        ntdll.NtQuerySystemInformation(NT_LIST_HANDLES, addressof(hinfo), hsize, 0)

        return hinfo


    def setupDosDeviceMaps(self):
        self.dosdevs = []
        dname = (c_char * 512)()
        size = kernel32.GetLogicalDriveStringsA(512, addressof(dname))
        devs = dname.raw[:size-1].split("\x00")
        for dev in devs:
            dosname = "%s:" % dev[0]
            kernel32.QueryDosDeviceA("%s:" % dev[0], pointer(dname), 512)
            self.dosdevs.append( (dosname, dname.value) )

    def platformKill(self):
        kernel32.TerminateProcess(self.phandle, 0)

    @v_base.threadwrap
    def platformExec(self, cmdline):
        sinfo = STARTUPINFO()
        pinfo = PROCESS_INFORMATION()
        if not kernel32.CreateProcessA(0, cmdline, 0, 0, 0,
                DEBUG_ONLY_THIS_PROCESS, 0, 0, addressof(sinfo), addressof(pinfo)):
            raise Exception("CreateProcess failed!")

        # When launching an app, we're guaranteed to get a breakpoint
        # Unless we want to fail checkBreakpoints, we'll need to set ShouldBreak
        self.setMeta('ShouldBreak', True)

        kernel32.CloseHandle(pinfo.Process)
        kernel32.CloseHandle(pinfo.Thread)

        return pinfo.ProcessId

    def platformInjectSo(self, filename):
        tid = c_uint32()
        x = self.parseExpression('kernel32.LoadLibraryA')
        memaddr = self.allocateMemory(4096)
        self.writeMemory(memaddr, '%s\x00' % filename)
        t =  kernel32.CreateRemoteThread(self.phandle, 0, 0, x, memaddr, 0, addressof(tid))
        self.joinThread(tid.value)
        kernel32.CloseHandle(t)
        kernel32.VirtualFreeEx(self.phandle, memaddr, 0, 0x8000) # MEM_RELEASE 0x8000  MEM_DECOMMIT 0x4000

    @v_base.threadwrap
    def platformAttach(self, pid):
        if not kernel32.DebugActiveProcess(pid):
            raiseWin32Error("DebugActiveProcess")

    @v_base.threadwrap
    def platformDetach(self):
        # Do the crazy "can't supress exceptions from detach" dance.
        if ((not self.exited) and
            self.getCurrentBreakpoint() != None):
            self._cleanupBreakpoints()
            self.platformContinue()
            self.platformSendBreak()
            self.platformWait()
        if not kernel32.DebugActiveProcessStop(self.pid):
            raiseWin32Error("DebugActiveProcessStop")
        kernel32.CloseHandle(self.phandle)
        self.phandle = None

    def platformProtectMemory(self, va, size, perms):
        pret = c_uint(0)
        pval = perm_rev_lookup.get(perms, PAGE_EXECUTE_READWRITE)
        ret = kernel32.VirtualProtectEx(self.phandle, va, size, pval, addressof(pret))
        if ret == 0:
            raiseWin32Error("kernel32.VirtualProtectEx")

    def platformAllocateMemory(self, size, perms=e_mem.MM_RWX, suggestaddr=0):
        pval = perm_rev_lookup.get(perms, PAGE_EXECUTE_READWRITE)
        ret = kernel32.VirtualAllocEx(self.phandle,
                suggestaddr, size, MEM_COMMIT, pval)
        if ret == 0:
            raiseWin32Error("kernel32.VirtualAllocEx")
        return ret

    def platformReadMemory(self, address, size):
        btype = c_char * size
        buf = btype()
        ret = c_ulong(0)
        if not kernel32.ReadProcessMemory(self.phandle, address, addressof(buf), size, addressof(ret)):
            raiseWin32Error("kernel32.ReadProcessMemory %s" % hex(address))
        return buf.raw

    @v_base.threadwrap
    def platformContinue(self):

        magic = DBG_CONTINUE

        if self.getCurrentSignal() != None:
            magic = DBG_EXCEPTION_NOT_HANDLED

        if self.flushcache:
            self.flushcache = False
            kernel32.FlushInstructionCache(self.phandle, 0, 0)
        if not kernel32.ContinueDebugEvent(self.pid, self.getMeta("StoppedThreadId"), magic):
            raiseWin32Error("ContinueDebugEvent")

    @v_base.threadwrap
    def platformStepi(self):
        # We have some flag fields broken out as meta regs
        self.setRegisterByName("TF", 1)
        if self.getMode('BlockStep'):
            wrmsr(e_i386.MSR_DEBUGCTL, e_i386.MSR_DEBUGCTL_BTF)
        self._syncRegs()
        self.platformContinue()

    def platformWriteMemory(self, address, buf):
        ret = c_ulong(0)
        if not kernel32.WriteProcessMemory(self.phandle, address, buf, len(buf), addressof(ret)):
            raiseWin32Error("kernel32.WriteProcessMemory")
        # If we wrote memory, flush the instruction cache...
        self.flushcache = True
        return ret.value

    def platformSendBreak(self):
        #FIXME make this support windows 2000
        if not kernel32.DebugBreakProcess(self.phandle):
            raiseWin32Error("kernel32.DebugBreakProcess")

    def platformPs(self):
        ret = []
        pcount = 128 # Hardcoded limit of 128 processes... oh well..
        pids = (c_int * pcount)()
        needed = c_int(0)
        hmodule = HANDLE()

        psapi.EnumProcesses(addressof(pids), 4*pcount, addressof(needed))
        for i in range(needed.value/4):
            fname = (c_wchar * 512)()
            phandle = kernel32.OpenProcess(PROCESS_ALL_ACCESS, 0, pids[i])
            if not phandle: # If we get 0, we failed to open it (perms)
                continue
            psapi.EnumProcessModules(phandle, addressof(hmodule), 4, addressof(needed))
            psapi.GetModuleBaseNameW(phandle, hmodule, fname, 512)
            ret.append( (pids[i], fname.value))
            kernel32.CloseHandle(phandle)
            kernel32.CloseHandle(hmodule)
        return ret

    @v_base.threadwrap
    def platformWait(self):
        event = DEBUG_EVENT()
        if not kernel32.WaitForDebugEvent(addressof(event), INFINITE):
            raiseWin32Error("WaitForDebugEvent")
        return event

    def platformGetMemFault(self):
        return self.faultaddr,self.faultperm

    def platformProcessEvent(self, event):

        self.faultaddr = None
        self.faultperm = None

        if event.ProcessId != self.pid:
            raise Exception("event.ProcessId != self.pid (%d != %d)" %
                             (event.ProcessId,self.pid))

        ThreadId = event.ThreadId
        eventdict = {} # Each handler fills this in
        self.setMeta("Win32Event", eventdict)
        self.setMeta("StoppedThreadId", ThreadId)
        self.setMeta("ThreadId", ThreadId)

        if event.DebugEventCode == CREATE_PROCESS_DEBUG_EVENT:
           self.phandle = event.u.CreateProcessInfo.Process
           baseaddr = event.u.CreateProcessInfo.BaseOfImage
           ImageName = GetModuleFileNameEx(self.phandle, 0)
           if not ImageName:
               # If it fails, fall back on getMappedFileName
               ImageName = self.getMappedFileName(baseaddr)
           self.setMeta("ExeName", ImageName)

           teb = event.u.CreateProcessInfo.ThreadLocalBase
           self.win32threads[ThreadId] = teb
           self.thandles[ThreadId] = event.u.CreateProcessInfo.Thread

           tobj = self.getStruct("ntdll.TEB", teb)
           peb = tobj.ProcessEnvironmentBlock

           self.setMeta("PEB", peb)
           self.setVariable("peb", peb)

           eventdict["ImageName"] = ImageName
           eventdict["StartAddress"] = event.u.CreateProcessInfo.StartAddress
           eventdict["ThreadLocalBase"] = teb

           self._is_wow64 = False
           if IsWow64Process != None:
               b = BOOL()
               IsWow64Process(self.phandle, addressof(b))
               if b.value:
                   self._is_wow64 = True

           self.setMeta('IsWow64', self._is_wow64)

           self.fireNotifiers(vtrace.NOTIFY_ATTACH)
           self.addLibraryBase(ImageName, baseaddr)

        elif event.DebugEventCode == CREATE_THREAD_DEBUG_EVENT:
            self.thandles[ThreadId] = event.u.CreateThread.Thread
            teb = event.u.CreateThread.ThreadLocalBase
            startaddr = event.u.CreateThread.StartAddress
            # Setup the event dictionary for notifiers
            eventdict["ThreadLocalBase"] = teb
            eventdict["StartAddress"] = startaddr
            self.win32threads[ThreadId] = teb
            self.fireNotifiers(vtrace.NOTIFY_CREATE_THREAD)

        elif event.DebugEventCode == EXCEPTION_DEBUG_EVENT:
            excode = event.u.Exception.ExceptionRecord.ExceptionCode
            exflags = event.u.Exception.ExceptionRecord.ExceptionFlags
            exaddr = event.u.Exception.ExceptionRecord.ExceptionAddress
            exparam = event.u.Exception.ExceptionRecord.NumberParameters
            firstChance = event.u.Exception.FirstChance

            plist = []
            for i in range(exparam):
                plist.append(long(event.u.Exception.ExceptionRecord.ExceptionInformation[i]))

            eventdict["ExceptionCode"] = excode
            eventdict["ExceptionFlags"] = exflags
            eventdict["ExceptionAddress"] = exaddr
            eventdict["NumberParameters"] = exparam
            eventdict["FirstChance"] = bool(firstChance)
            eventdict["ExceptionInformation"] = plist

            if firstChance:

                if excode == EXCEPTION_BREAKPOINT:

                    if not self.checkBreakpoints():
                        # On first attach, all the library load
                        # events occur, then we hit a CC.  So,
                        # if we don't find a breakpoint, notify
                        # break anyay....
                        self.fireNotifiers(vtrace.NOTIFY_BREAK)

                elif excode == EXCEPTION_SINGLE_STEP:

                    if not self.checkWatchpoints():
                        self._fireStep()

                else:
                    if excode == 0xc0000005:
                        self.faultaddr = plist[1]
                        self.faultperm = av_einfo_perms[plist[0]]

                    # First we check for PageWatchpoint faults
                    if not self.checkPageWatchpoints():
                        self._fireSignal(excode, siginfo=plist)

            else:
                self._fireSignal(excode, siginfo=plist)

        elif event.DebugEventCode == EXIT_PROCESS_DEBUG_EVENT:
            ecode = event.u.ExitProcess.ExitCode
            eventdict["ExitCode"] = ecode
            self._fireExit(ecode)
            self.platformDetach()

        elif event.DebugEventCode == EXIT_THREAD_DEBUG_EVENT:
            self.win32threads.pop(ThreadId, None)
            ecode = event.u.ExitThread.ExitCode
            eventdict["ExitCode"] = ecode
            self._fireExitThread(ThreadId, ecode)

        elif event.DebugEventCode == LOAD_DLL_DEBUG_EVENT:
            baseaddr = event.u.LoadDll.BaseOfDll
            ImageName = GetModuleFileNameEx(self.phandle, baseaddr)
            if not ImageName:
                # If it fails, fall back on getMappedFileName
                ImageName = self.getMappedFileName(baseaddr)
            self.addLibraryBase(ImageName, baseaddr)
            kernel32.CloseHandle(event.u.LoadDll.File)

        elif event.DebugEventCode == UNLOAD_DLL_DEBUG_EVENT:
            baseaddr = event.u.UnloadDll.BaseOfDll
            eventdict["BaseOfDll"] = baseaddr
            self.delLibraryBase(baseaddr)

        elif event.DebugEventCode == OUTPUT_DEBUG_STRING_EVENT:
            # Gotta have a way to continue these...
            d = event.u.DebugString
            sdata = d.DebugStringData
            ssize = d.DebugStringLength

            # FIXME possibly make a gofast option that
            # doesn't get the string
            mem = self.readMemory(sdata, ssize)
            if d.Unicode:
                mem = mem.decode("utf-16-le")
            eventdict["DebugString"] = mem
            self.fireNotifiers(vtrace.NOTIFY_DEBUG_PRINT)

        else:
            print "Currently unhandled event",code

        # NOTE: Not everbody falls through to here


    def getMappedFileName(self, address):
        self.requireAttached()
        fname = (c_wchar * 512)()
        x = psapi.GetMappedFileNameW(self.phandle, address, addressof(fname), 512)
        if not x:
            return ""
        name = fname.value
        for dosname, devname in self.dosdevs:
            if name.startswith(devname):
                return name.replace(devname, dosname)
        return name

    def platformGetMaps(self):
        ret = []
        base = 0

        mbi = MEMORY_BASIC_INFORMATION()

        while kernel32.VirtualQueryEx(self.phandle, base, addressof(mbi), sizeof(mbi)) > 0:
            if mbi.State == MEM_COMMIT:
                prot = mbi.Protect & 0xff
                perm = perm_lookup.get(prot, 0)
                base = mbi.BaseAddress
                mname = self.getMappedFileName(base)
                # If it fails, fall back on getmodulefilename
                if mname == "":
                    mname = GetModuleFileNameEx(self.phandle, base)
                ret.append( (base, mbi.RegionSize, perm, mname) )

            base += mbi.RegionSize

        return ret

    def platformGetThreads(self):
        return self.win32threads

    def platformSuspendThread(self, thrid):
        if kernel32.SuspendThread(thrid) == 0xffffffff:
            raiseWin32Error()

    def platformResumeThread(self, thrid):
        if kernel32.ResumeThread(thrid) == 0xffffffff:
            raiseWin32Error()

    def platformParseBinary(self, filename, baseaddr, normname):
        if dbghelp != None:
            self.parseWithDbgHelp(filename, baseaddr, normname)
        else:
            self.parseWithPE(filename, baseaddr, normname)

    def parseWithDbgHelp(self, filename, baseaddr, normname):
        funcflags = (SYMFLAG_FUNCTION | SYMFLAG_EXPORT)

        sympath = self.getMeta('NtSymbolPath')
        parser = Win32SymbolParser(self.phandle, filename, baseaddr, sympath=sympath)
        parser.parse()
        parser.loadSymsIntoTrace(self, normname)

    def parseWithPE(self, filename, baseaddr, normname):
        pe = PE.peFromMemoryObject(self, baseaddr)
        for rva, ord, name in pe.getExports():
            self.addSymbol(e_resolv.Symbol(name, baseaddr+rva, 0, normname))

    @v_base.threadwrap
    def platformGetRegCtx(self, threadid):
        ctx = self.archGetRegCtx()
        c = self._winGetRegStruct()

        thandle = self.thandles.get(threadid, None)
        if not thandle:
            raise Exception("Getting registers for unknown thread")

        if not kernel32.GetThreadContext(thandle, addressof(c)):
            raiseWin32Error("kernel32.GetThreadContext")

        c.regPostProcess()

        ctx._rctx_Import(c)
        return ctx

    @v_base.threadwrap
    def platformSetRegCtx(self, threadid, ctx):

        c = self._winGetRegStruct()

        thandle = self.thandles.get(threadid, None)
        if not thandle:
            raise Exception("Getting registers for unknown thread: %d" % threadid)

        if not kernel32.GetThreadContext(thandle, addressof(c)):
            raiseWin32Error("kernel32.GetThreadContext (tid: %d)" % threadid)

        ctx._rctx_Export(c)

        if not kernel32.SetThreadContext(thandle, addressof(c)):
            raiseWin32Error("kernel32.SetThreadContext (tid: %d)" % threadid)

    def _getSvcList(self):
        '''
        Expose the getServicesList via the trace for remote...
        '''
        return getServicesList()

    def _getUacStatus(self):
        return getTokenElevationType(self.phandle)

# NOTE: The order of the constructors vs inheritance is very important...

class Windowsi386Trace(
            vtrace.Trace,
            WindowsMixin,
            v_i386.i386Mixin,
            v_base.TracerBase,
            ):

    def __init__(self):
        vtrace.Trace.__init__(self)
        v_base.TracerBase.__init__(self)
        v_i386.i386Mixin.__init__(self)
        WindowsMixin.__init__(self)

    def _winGetRegStruct(self):
        c = CONTEXTx86()
        c.ContextFlags = (CONTEXT_i386 | 
                          CONTEXT_FULL | 
                          CONTEXT_DEBUG_REGISTERS |
                          CONTEXT_EXTENDED_REGISTERS)
        return c

class WindowsAmd64Trace(
            vtrace.Trace,
            WindowsMixin,
            v_amd64.Amd64Mixin,
            v_base.TracerBase,
            ):

    def __init__(self):
        vtrace.Trace.__init__(self)
        v_base.TracerBase.__init__(self)
        WindowsMixin.__init__(self)
        v_amd64.Amd64Mixin.__init__(self)

    def _winGetRegStruct(self):
        c = CONTEXTx64()
        c.ContextFlags = (CONTEXT_AMD64 | CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS)
        return c

reserved = {
    'None': True,
    'True': True,
    'False': True,
}

VT_EMPTY    = 0 
VT_NULL     = 1 
VT_I2       = 2 
VT_I4       = 3 
VT_R4       = 4 
VT_R8       = 5 
VT_CY       = 6 
VT_DATE     = 7 
VT_BSTR     = 8 
VT_DISPATCH = 9 
VT_ERROR    = 10 
VT_BOOL     = 11 
VT_VARIANT  = 12 
VT_UNKNOWN  = 13 
VT_I1       = 16
VT_UI1      = 17 
VT_UI2      = 18
VT_UI4      = 19
VT_INT      = 20
VT_UINT     = 21

class VARIANT_guts(Union):
    _fields_ = [
        ('ui1', c_uint8),
        ('ui2', c_uint16),
        ('ui4', c_uint32),
        ('i1', c_int8),
        ('i2', c_int16),
        ('i4', c_int32),
        ('pad', BYTE*32),
    ]

class VARIANT(Structure):
    _fields_ = [
        ('vt', WORD),
        ('res1', WORD),
        ('res2', WORD),
        ('res3', WORD),
        ('u', VARIANT_guts),
    ]

class Win32SymbolParser:

    def __init__(self, phandle, filename, loadbase, sympath=None):
        self.phandle = phandle
        self.filename = filename
        self.loadbase = loadbase
        self.sympath = sympath
        self.symbols = []
        self.symopts = (SYMOPT_UNDNAME | SYMOPT_NO_PROMPTS | SYMOPT_NO_CPP)
        self._sym_types = {}
        self._sym_enums = {}
        self._sym_locals = {}

    def printSymbolInfo(self, info):
        # Just a helper function for "reversing" how dbghelp works
        for n,t in info.__class__._fields_:
            print n,repr(getattr(info, n))

    def symGetTypeInfo(self, tindex, tinfo, tparam):
        x = dbghelp.SymGetTypeInfo(self.phandle, self.loadbase,
                                   tindex, tinfo, tparam)
        if x == 0:
            return False
        return True

    def symGetTypeName(self, typeid):
        n = c_wchar_p()
        self.symGetTypeInfo(typeid, TI_GET_SYMNAME, pointer(n))
        val = n.value
        # Strip leading / trailing _'s
        if val != None:
            val = val.strip('_')
        if val == '<unnamed-tag>' or val == 'unnamed':
            val = '_unnamed_%d' % typeid
        #print repr(val)
        return val

    def symGetUdtKind(self, typeid):
        offset = c_ulong(0)
        self.symGetTypeInfo(typeid, TI_GET_UDTKIND, pointer(offset))
        return offset.value

    def symGetTypeOffset(self, typeid):
        offset = c_ulong(0)
        self.symGetTypeInfo(typeid, TI_GET_OFFSET, pointer(offset))
        return offset.value

    def symGetTypeLength(self, typeid):
        size = c_ulonglong(0)
        self.symGetTypeInfo(typeid, TI_GET_LENGTH, pointer(size))
        return size.value

    def symGetArrayIndexType(self, typeid):
        offset = c_ulong(0)
        self.symGetTypeInfo(typeid, TI_GET_ARRAYINDEXTYPEID, pointer(offset))
        return offset.value

    def symGetTypeValue(self, typeid):
        #size = c_ulonglong(0)
        v = VARIANT()
        self.symGetTypeInfo(typeid, TI_GET_VALUE, pointer(v))

        vt = v.vt

        # Messy, but gotta do it...
        if vt == VT_I1: return v.u.i1
        if vt == VT_I2: return v.u.i2
        if vt == VT_I4: return v.u.i4
        if vt == VT_UI1: return v.u.ui1
        if vt == VT_UI2: return v.u.ui2
        if vt == VT_UI4: return v.u.ui4

        raise Exception('Unhandled Variant Type: %d' % v.vt)

    def symGetTypeBase(self, typeid):
        btype = c_ulong(typeid)
        # Resolve the deepest base type
        while self.symGetTypeTag(btype.value) == SymTagTypedef:
            self.symGetTypeInfo(btype.value, TI_GET_BASETYPE, pointer(btype))
        return btype.value

    def symGetTypeType(self, child):
        ktype = c_ulong(0)
        self.symGetTypeInfo(child, TI_GET_TYPE, pointer(ktype))
        return ktype.value

    def symGetTypeTag(self, typeid):
        btype = c_ulong(0)
        self.symGetTypeInfo(typeid, TI_GET_SYMTAG, pointer(btype))
        return btype.value

    def _fixKidName(self, kidname):
        if kidname[0].isdigit():
            kidname = '_%s' % kidname

        if reserved.get(kidname):
            kidname = '_%s' % kidname

        return kidname

    def _symTypeEnum(self, name, tidx):
        size = self.symGetTypeLength(tidx)
        kids = []
        for child in self._symGetChildren(tidx):
            kidname = self.symGetTypeName(child)
            kidval = self.symGetTypeValue(child)
            kidname = self._fixKidName(kidname)
            kids.append((kidname, kidval))

        self._sym_enums[name] = (name, size, kids)

    def _symTypeUserDefined(self, name, tidx):
        size = self.symGetTypeLength(tidx)
        kids = []
        for child in self._symGetChildren(tidx):
            kidname = self.symGetTypeName(child)
            kidoff = self.symGetTypeOffset(child)
            ktype = self.symGetTypeType(child)
            ksize = self.symGetTypeLength(ktype)
            ktag = self.symGetTypeTag(ktype)

            kidname = self._fixKidName(kidname)
            kflags = 0
            ktypename = None
            kcount = None

            if ktag == SymTagPointerType:
                kflags |= vs_builder.VSFF_POINTER
                ptype = self.symGetTypeType(ktype)
                ktypename = self.symGetTypeName(ptype)

            elif ktag == SymTagArrayType:
                atype = self.symGetTypeType(ktype)
                asize = self.symGetTypeLength(atype)
                kcount = ksize / asize

                # Now, we setup our *child* to be the type
                ktypename = self.symGetTypeName(atype)
                ksize = asize

                if self.symGetTypeTag(atype) == SymTagPointerType:
                    kflags |= vs_builder.VSFF_POINTER

            elif ktag == SymTagEnum:
                #ktypename = self.symGetTypeName(ktype)
                pass

            elif ktag == SymTagUDT:
                ktypename = self.symGetTypeName(ktype)

            elif ktag == SymTagBaseType:
                pass

            elif ktag == SymTagFunctionType:
                # Function pointer types...
                pass

            elif ktag == SymTagNull:
                pass

            else:
                print '%s:%s Unknown Type Tag: %d' % (name, kidname, ktag)

            kids.append((kidname, kidoff, ksize, ktypename, kflags, kcount))

        self._sym_types[name] = (name, size, kids)

    def _symGetChildren(self, typeIndex):

        s = c_ulong(0)
        self.symGetTypeInfo(typeIndex, TI_GET_CHILDRENCOUNT, pointer(s))
        tif = buildFindChildrenParams(s.value)
        self.symGetTypeInfo(typeIndex, TI_FINDCHILDREN, pointer(tif))
        for i in range(s.value):
            child = tif.Children[i]
            yield child

    def typeEnumCallback(self, psym, size, ctx):
        sym = psym.contents

        myname = self.symGetTypeName(sym.TypeIndex)
        mytag = self.symGetTypeTag(sym.TypeIndex)

        if mytag == SymTagUDT:
            self._symTypeUserDefined(myname, sym.TypeIndex)
            return True

        if mytag == SymTagEnum:
            self._symTypeEnum(myname, sym.TypeIndex)
            return True

        return True

    def symEnumCallback(self, psym, size, ctx):
        sym = psym.contents

        if sym.Tag == SymTagFunction:
            sym.Flags |= SYMFLAG_FUNCTION

        self.symbols.append((sym.Name, int(sym.Address), int(sym.Size), sym.Flags))
        return True

    def symFromAddr(self, address):
        si = SYMBOL_INFO()
        si.SizeOfStruct = sizeof(si) - 2000
        si.MaxNameLen = 2000
        disp = QWORD()
        dbghelp.SymFromAddr(self.phandle, address, pointer(disp), pointer(si))
        return si

    def symInit(self):

            dbghelp.SymInitialize(self.phandle, self.sympath, False)
            dbghelp.SymSetOptions(self.symopts)

            x = dbghelp.SymLoadModule64(self.phandle,
                        0, 
                        self.filename,
                        None,
                        self.loadbase,
                        os.path.getsize(self.filename))


            # This is for debugging which pdb got loaded
            #imghlp = IMAGEHLP_MODULE64()
            #imghlp.SizeOfStruct = sizeof(imghlp)
            #dbghelp.SymGetModuleInfo64(self.phandle, x, pointer(imghlp))
            #print "PDB",repr(imghlp.LoadedPdbName)

    def symCleanup(self):
        dbghelp.SymCleanup(self.phandle)

    def symLocalCallback(self, psym, size, ctx):
        sym = psym.contents
        address = c_int32(sym.Address).value
        self._cur_locs.append( (sym.Name, address, sym.Size, sym.Flags) )

        return True

    def parseArgs(self):

        for name, addr, size, flags in self.symbols:

            si = self.symFromAddr(addr)
            if si.Tag != SymTagFunction:
                continue

            self._cur_locs = []

            sframe = IMAGEHLP_STACK_FRAME()
            sframe.InstructionOffset = addr
            dbghelp.SymSetContext(self.phandle, pointer(sframe), 0)
            dbghelp.SymEnumSymbols(self.phandle,
                        0,
                        None,
                        SYMCALLBACK(self.symLocalCallback),
                        0)

            if len(self._cur_locs):
                self._sym_locals[addr] = self._cur_locs

    def parse(self):
        try:

            self.symInit()

            dbghelp.SymEnumSymbols(self.phandle,
                        self.loadbase,
                        None,
                        SYMCALLBACK(self.symEnumCallback),
                        NULL)

            self.parseTypes()
            #self.parseArgs()

            self.symCleanup()

        except Exception, e:
            traceback.print_exc()
            raise

    def parseTypes(self):
        #self.symInit()
        # This is how you enumerate type information
        dbghelp.SymEnumTypes(self.phandle,
                    self.loadbase,
                    SYMCALLBACK(self.typeEnumCallback),
                    NULL)

        #self.symCleanup()

    def loadSymsIntoTrace(self, trace, normname):

        funcflags = (SYMFLAG_FUNCTION | SYMFLAG_EXPORT)

        for name, addr, size, flags in self.symbols:
            symclass = e_resolv.Symbol
            if flags & funcflags:
                symclass = e_resolv.FunctionSymbol
            sym = symclass(name, addr, size, normname)
            trace.addSymbol(sym)

        t = self._sym_types.values()
        e = self._sym_enums.values()

        # Only add the namespace if we have values...
        if len(t):
            builder = vs_builder.VStructBuilder(defs=t, enums=e)
            trace.vsbuilder.addVStructNamespace(normname, builder)


########NEW FILE########
__FILENAME__ = rmi
"""
Cobra integration for remote debugging
"""
# Copyright (C) 2007 Invisigoth - See LICENSE file for details
import md5
import os
import socket

import vtrace
import cobra

callback_daemon = None

def getTracerFactory():
    """
    Return a TracerFactory proxy object from the remote server
    """
    return cobra.CobraProxy("cobra://%s:%d/TracerFactory" % (vtrace.remote, vtrace.port))

class TraceProxyFactory:
    """
    A "factory" object for creating tracers and
    wrapping them up in a proxy instance to the
    *local* server.  This object is shared out
    via the pyro server for vtrace clients.
    """
    def getTrace(self):
        trace = vtrace.getTrace()
        host,port = cobra.getLocalInfo()
        unique = md5.md5(os.urandom(20)).hexdigest()
        vtrace.cobra_daemon.shareObject(trace, unique)
        trace.proxy = cobra.CobraProxy("cobra://%s:%d/%s" % (host,port,unique))
        return unique

    def releaseTrace(self, proxy):
        """
        When a remote system is done with a trace
        and wants the server to clean him up, hand
        the proxy object to this.
        """
        t = vtrace.cobra_daemon.unshareObject(proxy.__dict__.get("__cobra_name", None))
        if t != None:
            t.release()

class RemoteTrace(cobra.CobraProxy):

    def __init__(self, *args, **kwargs):
        cobra.CobraProxy.__init__(self, *args, **kwargs)
        self.__dict__['_remote_released'] = False

    def isRemote(self):
        return True

    def buildNewTrace(self):
        return getRemoteTrace()

    def release(self):
        self.__dict__['_remote_released'] = True
        getTracerFactory().releaseTrace(self)

    def __del__(self):
        if not self.__dict__['_remote_released']:
            print 'RemoteTrace del w/o release()!'

def getCallbackProxy(trace, notifier):
    """
    Get a proxy object to reference *notifier* from the
    perspective of *trace*.  The trace is specified so
    we may check on our side of the connected socket to
    give him the best possible ip address...
    """
    global callback_daemon
    port = getCallbackPort()
    host, nothing = cobra.getCobraSocket(trace).getSockName()
    unique = callback_daemon.getSharedName(notifier)
    if unique == None:
        unique = md5.md5(os.urandom(20)).hexdigest()
        callback_daemon.shareObject(notifier, unique)
    return cobra.CobraProxy("cobra://%s:%d/%s" % (host, port, unique))

def getCallbackPort():
    """
    If necissary, start a callback daemon.  Return the
    ephemeral port it was bound on.
    """
    global callback_daemon
    if callback_daemon == None:
        callback_daemon = cobra.CobraDaemon(port=0)
        callback_daemon.fireThread()
    return callback_daemon.port

def startCobraDaemon():
    if vtrace.cobra_daemon == None:
        vtrace.cobra_daemon = cobra.CobraDaemon(port=vtrace.port)
        vtrace.cobra_daemon.fireThread()

def getRemoteTrace():
    factory = getTracerFactory()
    unique = factory.getTrace()
    return RemoteTrace("cobra://%s:%d/%s" % (vtrace.remote, vtrace.port, unique))

def releaseRemoteTrace(proxy):
    getTracerFactory().releaseTrace(proxy)

def startVtraceServer():
    """
    Fire up the pyro server and share out our
    "trace factory"
    """
    startCobraDaemon()
    factory = TraceProxyFactory()
    vtrace.cobra_daemon.shareObject(factory, "TracerFactory")

########NEW FILE########
__FILENAME__ = snapshot
"""
All the code related to vtrace process snapshots
and TraceSnapshot classes.
"""

import sys
import copy
import cPickle as pickle

import envi
import envi.memory as e_mem
import envi.resolver as e_resolv

import vtrace
import vtrace.platforms.base as v_base

class TraceSnapshot(
            vtrace.Trace,
            v_base.TracerBase,
        ):
    """
    A tracer snapshot is similar to a traditional "core file" except that
    you may also have memory only snapshots that are never written to disk.

    TraceSnapshots allow you to take a picture of a process from a given point
    in it's execution and manipulate/test from there or save it to disk for later
    analysis...
    """
    def __init__(self, snapdict):

        self.s_snapcache = {}
        self.s_snapdict = snapdict

        # a seperate parser for each version...
        if snapdict['version'] == 1:
            self.s_version = snapdict['version']
            self.s_threads = snapdict['threads']
            self.s_regs = snapdict['regs']
            self.s_maps = snapdict['maps']
            self.s_mem = snapdict['mem']
            self.metadata = snapdict['meta']
            self.s_stacktrace = snapdict['stacktrace']
            self.s_exe = snapdict['exe']
            self.s_fds = snapdict['fds']
            self.localvars = snapdict.get('vars', {})
        else:
            raise Exception("ERROR: Unknown snapshot version!")

        # In the ghetto!
        archname = self.metadata.get('Architecture')
        envi.stealArchMethods(self, archname)

        vtrace.Trace.__init__(self)
        v_base.TracerBase.__init__(self)
        # This will re-init meta... *sigh* set it back...
        self.metadata = snapdict['meta']

        # Steal the reg defs of the first thread
        rinfo = self.s_regs.items()[0][1]
        self.setRegisterInfo(rinfo)

        #FIXME hard-coded page size!
        self.s_map_lookup = {}
        for map in self.s_maps:
            for i in range(map[0],map[0] + map[1], 4096):
                self.s_map_lookup[i] = map

        # Lets get some symbol resolvers created for our libraries
        #for fname in self.getNormalizedLibNames():
            #subres = e_resolv.FileSymbol(fname, 

        self.attached = True
        # So that we pickle
        self.bplock = None
        self.thread = None

    def saveToFd(self, fd):
        '''
        Save this snapshot to the given file like object
        for later reloading...
        '''
        pickle.dump(self.s_snapdict, fd)

    def saveToFile(self, filename):
        """
        Save a snapshot to file for later reading in...
        """
        f = file(filename, "wb")
        self.saveToFd(f)
        f.close()

    def getMemoryMap(self, addr):
        base = addr & 0xfffff000
        return self.s_map_lookup.get(base, None)

    def platformGetFds(self):
        return self.s_fds

    def getExe(self):
        return self.s_exe

    def getStackTrace(self):
        tid = self.getMeta("ThreadId")
        tr = self.s_stacktrace.get(tid, None)
        if tr == None:
            raise Exception("ERROR: Invalid thread id specified")
        return tr

    def platformGetRegCtx(self, thrid):
        rinfo = self.s_regs.get(thrid)
        ctx = self.archGetRegCtx()
        ctx.setRegisterInfo(rinfo)
        return ctx
        
    def platformGetMaps(self):
        return self.s_maps

    def platformGetThreads(self):
        return self.s_threads

    def platformReadMemory(self, address, size):
        map = self.getMemoryMap(address)
        if map == None:
            raise Exception("ERROR: platformReadMemory says no map for 0x%.8x" % address)
        offset = address - map[0] # Base address
        mapbytes = self.s_mem.get(map[0], None)
        if mapbytes == None:
            raise vtrace.PlatformException("ERROR: Memory map at 0x%.8x is not backed!" % map[0])
        if len(mapbytes) == 0:
            raise vtrace.PlatformException("ERROR: Memory Map at 0x%.8x is backed by ''" % map[0])

        ret = mapbytes[offset:offset+size]
        rlen = len(ret)
        # We may have a cross-map read, just recurse for the rest
        if rlen != size:
            ret += self.platformReadMemory(address+rlen, size-rlen)
        return ret

    def platformWriteMemory(self, address, bytes):
        map = self.getMemoryMap(address)
        if map == None:
            raise Exception("ERROR: platformWriteMemory says no map for 0x%.8x" % address)
        offset = address - map[0]
        mapbytes = self.s_mem[map[0]]
        self.s_mem[map[0]] = mapbytes[:offset] + bytes + mapbytes[offset+len(bytes):]

    def platformDetach(self):
        pass

    def platformParseBinary(self, *args):
        print 'FIXME FAKE PLATFORM PARSE BINARY: %s' % repr(args)

    # Over-ride register *caching* subsystem to store/retrieve
    # register information in pure dictionaries
    def cacheRegs(self, threadid):
        pass

    # FIXME regs in snapshots are broke...

    def syncRegs(self):
        pass

def loadSnapshot(filename):
    '''
    Load a vtrace process snapshot from a file
    '''
    sfile = file(filename, "rb")
    snapdict = pickle.load(sfile)
    return TraceSnapshot(snapdict)

def takeSnapshot(trace):
    """
    Take a snapshot of the process from the current state and return
    a reference to a tracer which wraps a "snapshot" or "core file".
    """
    sd = dict()
    orig_thread = trace.getMeta("ThreadId")

    regs = dict()
    stacktrace = dict()

    for thrid,tdata in trace.getThreads().items():
        ctx = trace.getRegisterContext(thrid)
        reginfo = ctx.getRegisterInfo()
        regs[thrid] = reginfo
        try:
            stacktrace[thrid] = trace.getStackTrace()
        except Exception, msg:
            print >> sys.stderr, "WARNING: Failed to get stack trace for thread 0x%.8x" % thrid

    mem = dict()
    maps = []
    for base,size,perms,fname in trace.getMemoryMaps():
        try:
            mem[base] = trace.readMemory(base, size)
            maps.append((base,size,perms,fname))
        except Exception, msg:
            print >> sys.stderr, "WARNING: Can't snapshot memmap at 0x%.8x (%s)" % (base,msg)

    # If the contents here change, change the version...
    sd['version'] = 1
    sd['threads'] = trace.getThreads()
    sd['regs'] = regs
    sd['maps'] = maps
    sd['mem'] = mem
    sd['meta'] = copy.deepcopy(trace.metadata)
    sd['stacktrace'] = stacktrace
    sd['exe'] = trace.getExe()
    sd['fds'] = trace.getFds()
    sd['vars'] = trace.localvars

    return TraceSnapshot(snapdict=sd)


########NEW FILE########
__FILENAME__ = iathook
'''
Code for hooking import address tables by making them invalid
pointers and catching the exceptions...
'''
import PE
import vtrace
import vtrace.watchpoints as vt_watchpoints

class IatHook(vt_watchpoints.Watchpoint):
    '''
    Abuse the PageWatch subsystem to allow function pointers to be
    frob'd to create breakpoint like behavior.
    '''

    newptr = 0xfbfbf000

    def __init__(self, ptraddr, iatname):
        fakeptr = IatHook.newptr
        IatHook.newptr += 4096 # FIXME race... sigh...

        vt_watchpoints.Watchpoint.__init__(self, fakeptr)
        self.ptraddr = ptraddr
        self.fakeptr = fakeptr
        self.iatname = iatname
        self.origptr = None

    def getName(self):
        #bname = Breakpoint.getName(self)
        return self.iatname

    def resolveAddr(self, trace, addr):
        pass

    def activate(self, trace):
        if self.origptr == None:
            self.origptr = trace.readMemoryFormat(self.ptraddr, '<P')[0]
        trace.writeMemoryFormat(self.ptraddr, '<P', self.fakeptr)

    def deactivate(self, trace):
        if self.origptr != None:
            trace.writeMemoryFormat(self.ptraddr, '<P', self.origptr)

    def notify(self, event, trace):
        # We have to fake out the program counter...
        trace.setProgramCounter(self.origptr)
        trace.setCurrentSignal(None)
        return vt_watchpoints.Watchpoint.notify(self, event, trace)


def hookIat(trace, libname, implib='*', impfunc='*', fast=False):
    '''
    Hook the IAT with special "breakpoint" like objects which
    handle the memory access errors and document the calls...
    Set fast=True for them to be "Fastbreak" breakpoints.

    This returns a list of (name, bpid) tuples...

    Example:
        for impname, bpid in hookIat(t, 'ws2_32')
            t.setBreakpointCode(bpid, codestr)
            ...
    '''
    ret = []
    baseaddr = trace.parseExpression(libname)
    pe = PE.peFromMemoryObject(trace, baseaddr)
    origs = {}

    implib = implib.lower()
    impfunc = impfunc.lower()

    for rva, ilib, ifunc in pe.getImports():
        ilib = ilib.lower().replace('.dll', '')

        if ilib != implib and implib != '*':
            continue

        if ifunc.lower() != impfunc and impfunc!='*':
            continue

        iatname = '%s.%s.%s' % (libname, ilib, ifunc)
        wp = IatHook(baseaddr + rva, iatname)
        wp.fastbreak = fast
        bpid = trace.addBreakpoint(wp)
        ret.append( (iatname, bpid) )
    return ret



########NEW FILE########
__FILENAME__ = win32alloc
'''
A module with some cute toys for monitoring allocations.
'''

import vtrace

import envi.archs.i386 as e_i386

class ReturnBreak(vtrace.Breakpoint):
    def __init__(self, addr, chsize, chflags):
        vtrace.Breakpoint.__init__(self, addr)
        self.fastbreak = True
        self._chsize = chsize
        self._chflags = chflags

    def notify(self, event, trace):
        eax = trace.getRegister(e_i386.REG_EAX)
        a = trace.getMeta('HeapAllocs')
        a.append((self.address, eax, self._chsize, self._chflags))
        trace.runAgain()

class RtlAllocateHeapBreak(vtrace.Breakpoint):

    def __init__(self, addr):
        vtrace.Breakpoint.__init__(self, addr)
        self.fastbreak = True

    def notify(self, event, trace):

        sp = trace.getStackCounter()
        ( saved_eip, 
          heap, 
          flags, 
          size ) = trace.readMemoryFormat(sp, '<4P')

        if trace.getBreakpointByAddr(saved_eip) == None:
            bp = ReturnBreak(saved_eip, size, flags)
            trace.addBreakpoint(bp)

        trace.runAgain()

def watchHeapAllocs(trace):
    '''
    Add a breakpoint to ntdll.RtlAllocateHeap to watch for
    allocations and track who made them...
    '''
    clearHeapAllocs(trace)
    addr = trace.parseExpression('ntdll.RtlAllocateHeap')
    bp = RtlAllocateHeapBreak(addr)
    trace.addBreakpoint(bp)

def clearHeapAllocs(trace):
    trace.setMeta('HeapAllocs', [])

def getHeapAllocs(trace):
    '''
    Return a list of (caller_eip, heap_chunk, size, flags) tuples
    '''
    return trace.getMeta('HeapAllocs', [])


########NEW FILE########
__FILENAME__ = win32aslr
'''
Utilities for windows tracer objects.
'''
import PE
import vtrace
import envi.bits as e_bits

def deAslr(trace, va):
    '''
    Given an address in an ASLR'd library, rebase
    it back to the address as it would be if the
    given PE were at it's suggested address...
    '''

    if vtrace.remote:
        raise Exception('deAslr only works for local debuggers!')

    map = trace.getMemoryMap(va)
    if map == None:
        return va

    mapva, mapsize, mapperm, mapfname = map
    if not mapfname:
        return va

    normname = trace.normFileName(mapfname)
    sym = trace.getSymByName(normname)
    if sym == None:
        return va

    membase = long(sym)

    pe = PE.peFromFileName(mapfname)
    filebase = pe.IMAGE_NT_HEADERS.OptionalHeader.ImageBase

    rva = va - membase

    return filebase + rva



########NEW FILE########
__FILENAME__ = win32heap

# Heap Flags
HEAP_NO_SERIALIZE               = 0x00000001
HEAP_GROWABLE                   = 0x00000002
HEAP_GENERATE_EXCEPTIONS        = 0x00000004
HEAP_ZERO_MEMORY                = 0x00000008
HEAP_REALLOC_IN_PLACE_ONLY      = 0x00000010
HEAP_TAIL_CHECKING_ENABLED      = 0x00000020
HEAP_FREE_CHECKING_ENABLED      = 0x00000040
HEAP_DISABLE_COALESCE_ON_FREE   = 0x00000080
HEAP_CREATE_ALIGN_16            = 0x00010000
HEAP_CREATE_ENABLE_TRACING      = 0x00020000
HEAP_CREATE_ENABLE_EXECUTE      = 0x00040000

heap_flag_names = {
HEAP_NO_SERIALIZE:"HEAP_NO_SERIALIZE",
HEAP_GROWABLE:"HEAP_GROWABLE",
HEAP_GENERATE_EXCEPTIONS:"HEAP_GENERATE_EXCEPTIONS",
HEAP_ZERO_MEMORY:"HEAP_ZERO_MEMORY",
HEAP_REALLOC_IN_PLACE_ONLY:"HEAP_REALLOC_IN_PLACE_ONLY",
HEAP_TAIL_CHECKING_ENABLED:"HEAP_TAIL_CHECKING_ENABLED",
HEAP_FREE_CHECKING_ENABLED:"HEAP_FREE_CHECKING_ENABLED",
HEAP_DISABLE_COALESCE_ON_FREE:"HEAP_DISABLE_COALESCE_ON_FREE",
HEAP_CREATE_ALIGN_16:"HEAP_CREATE_ALIGN_16",
HEAP_CREATE_ENABLE_TRACING:"HEAP_CREATE_ENABLE_TRACING",
HEAP_CREATE_ENABLE_EXECUTE:"HEAP_CREATE_ENABLE_EXECUTE",
}

# Heap Chunk Flags
HEAP_ENTRY_BUSY             = 0x01
HEAP_ENTRY_EXTRA_PRESENT    = 0x02
HEAP_ENTRY_FILL_PATTERN     = 0x04
HEAP_ENTRY_VIRTUAL_ALLOC    = 0x08
HEAP_ENTRY_LAST_ENTRY       = 0x10
HEAP_ENTRY_SETTABLE_FLAG1   = 0x20
HEAP_ENTRY_SETTABLE_FLAG2   = 0x40
HEAP_ENTRY_SETTABLE_FLAG3   = 0x80



def reprHeapFlags(flags):
    ret = []
    if flags & HEAP_ENTRY_BUSY:
        ret.append("BUSY")
    if flags & HEAP_ENTRY_FILL_PATTERN:
        ret.append("FILL")
    if flags & HEAP_ENTRY_LAST_ENTRY:
        ret.append("LAST")
    if len(ret):
        return "|".join(ret)
    return "NONE"

class HeapCorruptionException(Exception):
    def __init__(self, heap, segment, prevchunk, badchunk):
        prevaddr = 0
        badaddr = 0
        if prevchunk != None:
            prevaddr = prevchunk.address
        if badchunk != None:
            badaddr = badchunk.address
        Exception.__init__(self, "Prev Chunk: 0x%.8x Bad Chunk: 0x%.8x" % (prevaddr, badaddr))
        self.heap = heap
        self.segment = segment
        self.prevchunk = prevchunk
        self.badchunk = badchunk

class FreeListCorruption(Exception):
    def __init__(self, heap, index, prevchunk, badchunk):
        prevaddr = 0
        badaddr = 0
        if prevchunk != None:
            prevaddr = prevchunk.address
        if badchunk != None:
            badaddr = badchunk.address
        Exception.__init__(self, "Index: %d Prev Chunk: 0x%.8x Bad Chunk: 0x%.8x" % (index, prevaddr, badaddr))
        self.heap = heap
        self.index = index
        self.prevchunk = prevchunk
        self.badchunk = badchunk

class ChunkNotFound(Exception):
    pass

def getHeapSegChunk(trace, address):
    """
    Find and return the heap, segment, and chunk for the given addres
    (or exception).
    """
    for heap in getHeaps(trace):

        for seg in heap.getSegments():

            segstart = seg.address
            segend = seg.getSegmentEnd()

            if address < segstart or address > segend:
                continue

            for chunk in seg.getChunks():
                a = chunk.address
                b = chunk.address + len(chunk)
                if address >= a and address < b:
                    return heap,seg,chunk

    raise ChunkNotFound("No Chunk Found for 0x%.8x" % address)

def getHeaps(trace):
    """
    Get the win32 heaps (returns a list of Win32Heap objects)
    """
    ret = []
    pebaddr = trace.getMeta("PEB")
    peb = trace.getStruct("ntdll.PEB", pebaddr)
    heapcount = int(peb.NumberOfHeaps)
    hlist = trace.readMemoryFormat(long(peb.ProcessHeaps), "<"+('P'*heapcount))
    for haddr in hlist:
        ret.append(Win32Heap(trace, haddr))
    return ret

class Win32Heap:

    def __init__(self, trace, address):
        self.address = address
        self.trace = trace
        self.heap = trace.getStruct("ntdll.HEAP", address)
        self._win7_heap = False
        self.heapenc = None
        if self.heap.vsHasField('Encoding'):
            self.heapenc = self.heap.Encoding
            self._win7_heap = True
        self.seglist = None
        self.ucrdict = None

    def hasLookAside(self):
        """
        Does this heap have a lookaside?
        """
        if not self.heap.Flags & HEAP_GROWABLE:
            return False
        if self.heap.Flags & HEAP_NO_SERIALIZE:
            return False
        return True

    def getUCRDict(self):
        '''
        Retrieve a dictionary of <ucr_address>:<ucr_size> items.

        (If this windows version doesn't support UCRs, the dict will be empty)
        '''
        if self.ucrdict == None:
            self.ucrdict = {}
            if self.heap.vsHasField('UCRList'):
                listhead_va = self.address + self.heap.vsGetOffset('UCRList')
                for lva in self._getListEntries(listhead_va):
                    ucrent = self.trace.getStruct('ntdll.HEAP_UCR_DESCRIPTOR', lva)
                    if ucrent.Size != 0:
                        self.ucrdict[ucrent.Address] = ucrent.Size

        return self.ucrdict

    def _win7ParseSegments(self):
        # Address doesn't matter for the below call
        heapseg = self.trace.getStruct('ntdll.HEAP_SEGMENT', self.address)

        listhead = self.address + self.heap.vsGetOffset('SegmentList')
        # Negative offset from segment list entry to segment
        segoff = heapseg.vsGetOffset('SegmentListEntry')
        entry = self.heap.SegmentList.Flink
        while entry != listhead:
            seg = Win32Segment(self.trace, self, entry - segoff)
            self.seglist.append(seg)
            entry = self.trace.readMemoryFormat(entry, '<P')[0]

    def getSegments(self):
        """
        Return a list of Win32Segment objects.
        """
        if self.seglist == None:
            self.seglist = []

            # Windows 7 style heap segment list
            if self.heap.vsHasField('SegmentList'):
                self._win7ParseSegments()

            else:
                for i in range(long(self.heap.LastSegmentIndex)+1):
                    sa = self.heap.Segments[i]
                    self.seglist.append(Win32Segment(self.trace, self, long(sa)))

        return self.seglist

    def getLookAsideLists(self):
        """
        Return a list of the lookaside list for this heap
        """
        if not self.hasLookAside():
            raise Exception("Heap at 0x%.8x has no lookaside!" % (self.address))
        # Look aside lists are 128 pointer slots in a chunk pointed
        # to by the FrontEndHeap field in the heap structure.
        #fetype = self.heap.FrontEndHeapType

        laside = self.heap.FrontEndHeap
        ret = []
        for i in range(128):
            slot = laside + (i * 0x30)
            bucket = []
            base = self.trace.readMemoryFormat(slot, "<I")[0]
            while base != 0:
                chunk = Win32Chunk(self.trace, self, base-8)
                bucket.append(chunk)
                base,blink = chunk.getFlinkBlink()
            ret.append(bucket)
        return ret

    def _getListEntries(self, addr, listhead=True):
        ret = []
        if not listhead:
            ret.append(addr)
        le = self.trace.getStruct('ntdll.LIST_ENTRY', addr)
        while le.Flink != addr:
            ret.append(le.Flink)
            le = self.trace.getStruct('ntdll.LIST_ENTRY', le.Flink)
        return ret

    def _win7FreeLists(self):
        #print 'Windows 7 Free List Parsing Fixme!'
        return []

    def getFreeLists(self):
        """
        Return a list of the free lists in this heap.
        (Not including look-aside)
        """
        ret = []
        foff = self.heap.vsGetOffset("FreeLists")
        if self._win7_heap:
            return self._win7FreeLists()

        for i in range(128):
            le = self.heap.FreeLists[i]
            bucket = []
            base = self.address + foff + (i*8)

            addr = le.Flink

            while addr != base:

                # If we die here, the guy before us was dorked.
                try:
                    chunk = Win32Chunk(self.trace, self, addr-8)
                except Exception, e:
                    chunk = bucket[-1]
                    pchunk = None
                    if len(bucket) >= 2:
                        pchunk = bucket[-2]
                    raise FreeListCorruption(self, i, pchunk, chunk)

                # Check our back pointer
                flink,blink = chunk.getFlinkBlink()
                if len(bucket):
                    pchunk = bucket[-1]
                    if blink != pchunk.getDataAddress():
                        raise FreeListCorruption(self, i, pchunk, chunk)

                addr = flink
                bucket.append(chunk)

            ret.append(bucket)
        return ret

    def getFlagNames(self):
        ret = []
        for k,v in heap_flag_names.items():
            if self.heap.Flags & k:
                ret.append(v)
        return ret

    def __repr__(self):
        fnames = "|".join(self.getFlagNames())
        return "heap: 0x%.8x flags:%s" % (self.address, fnames)

class Win32Segment:
    def __init__(self, trace, heap, address):
        self.trace = trace
        self.heap = heap
        self.address = address
        self.seg = trace.getStruct("ntdll.HEAP_SEGMENT", address)
        #FIXME segments can specify chunk Size granularity
        self.chunks = None
        self.segend = self.address + (self.seg.NumberOfPages * 4096)

    def getSegmentEnd(self):
        return self.segend

    def getChunks(self):
        if self.chunks == None:
            self.chunks = []
            addr = self.address
            lastchunk = None
            ucrdict = self.heap.getUCRDict()

            while True:

                # Skip any uncommited ranges...
                usize = ucrdict.get(addr)
                if usize != None:
                    lastchunk = None
                    addr += usize
                    continue

                # Since an un-commited range may put us past the
                # lastblock (segend) we must double check...
                if addr >= self.segend:
                    break

                chunk = Win32Chunk(self.trace, self.heap, addr)

                self.chunks.append(chunk)
                #if lastchunk != None:
                    #if lastchunk.chunk.Size != chunk.chunk.PreviousSize:
                        #print 'last size:',lastchunk.chunk.Size,'prev',chunk.chunk.PreviousSize
                        #raise HeapCorruptionException(self.heap, self, lastchunk, chunk)

                if chunk.isLast():
                    break

                lastchunk = chunk
                addr += len(chunk)
        return self.chunks

    def getLastChunk(self):
        va = self.seg.LastEntryInSegment
        return Win32Chunk(self.trace, self.heap, va)

class Win32Chunk:
    def __init__(self, trace, heap, address):
        self.trace = trace
        self.heap = heap
        self.address = address
        self.chunk = trace.getStruct("ntdll.HEAP_ENTRY", address)

        # Decode the heap chunk if needed...
        if self.heap.heapenc:
            self.chunk ^= self.heap.heapenc

    def __repr__(self):
        return "HeapChunk: 0x%.8x (%d) %s" % (self.address, len(self),self.reprFlags())

    def __len__(self):
        return int(self.chunk.Size) * 8

    def isLast(self):
        return bool(int(self.chunk.Flags) & HEAP_ENTRY_LAST_ENTRY)

    def isBusy(self):
        return bool(int(self.chunk.Flags) & HEAP_ENTRY_BUSY)

    def getDataAddress(self):
        return self.address + len(self.chunk)

    def getDataSize(self):
        return len(self) - len(self.chunk)

    def getDataBytes(self, maxsize=None):
        size = self.getDataSize()
        if maxsize != None:
            size = min(size, maxsize)
        return self.trace.readMemory(self.getDataAddress(), size)

    def getFlinkBlink(self):
        return self.trace.readMemoryFormat(self.getDataAddress(), "<PP")

    def reprFlags(self):
        return reprHeapFlags(int(self.chunk.Flags))


########NEW FILE########
__FILENAME__ = win32stealth
import vtrace
import vstruct

class StealthBreak(vtrace.Breakpoint):
    """
    A breakpoint to fake out CheckRemoteDebuggerPresent.
    """
    def notify(self, event, trace):
        sp = trace.getStackCounter()
        eip, handle, outbool = trace.readMemoryFormat(sp, "<LLL")
        trace.setRegisterByName("eax", 1)
        trace.writeMemoryFormat(outbool, "<L", 0)
        trace.setProgramCounter(eip)
        trace.setStackCounter(sp+12)
        trace.runAgain()

def writeBeingDebugged(trace, val):
    peb = trace.parseExpression("peb")
    ps = vstruct.getStructure("win32.PEB")
    off = ps.vsGetOffset("BeingDebugged")
    trace.writeMemoryFormat(peb+off, "<B", val)

def stealthify(trace):

    writeBeingDebugged(trace, 0)
    sym = trace.getSymByName("kernel32").getSymByName("CheckRemoteDebuggerPresent")
    if sym != None:
        addr = long(sym)
        bp = StealthBreak(addr)
        bpid = trace.addBreakpoint(bp)
        trace.setMeta("Win32Stealth", bpid)

def unstealthify(trace):
    writeBeingDebugged(trace, 1)
    bp = trace.getMeta("Win32Stealth")
    if bp != None:
        trace.setMeta("Win32Stealth", None)
        trace.removeBreakpoint(bp)


########NEW FILE########
__FILENAME__ = util
# Copyright (C) 2007 Invisigoth - See LICENSE file for details

import vtrace
import vtrace.notifiers as v_notifiers
import vtrace.rmi as v_rmi

class TraceManager:
    """
    A trace-manager is a utility class to extend from when you may be dealing
    with multiple tracer objects.  It allows for persistant mode settings and
    persistent metadata as well as bundling a DistributedNotifier.  You may also
    extend from this to get auto-magic remote stuff for your managed traces.
    """
    def __init__(self, trace=None):
        self.trace = trace
        self.dnotif = v_notifiers.DistributedNotifier()
        self.modes = {} # See docs for trace modes
        self.metadata = {} # Like traces, but persistant

    def manageTrace(self, trace):
        """
        Set all the modes/meta/notifiers in this trace for management
        by this TraceManager.
        """
        self.trace = trace
        if vtrace.remote:
            trace.registerNotifier(vtrace.NOTIFY_ALL, v_rmi.getCallbackProxy(trace, self.dnotif))
        else:
            trace.registerNotifier(vtrace.NOTIFY_ALL, self.dnotif)

        for name,val in self.modes.items():
            trace.setMode(name, val)

        for name,val in self.metadata.items():
            trace.setMeta(name, val)

    def unManageTrace(self, trace):
        """
        Untie this trace manager from the trace.
        """
        if vtrace.remote:
            trace.deregisterNotifier(vtrace.NOTIFY_ALL, v_rmi.getCallbackProxy(trace, self.dnotif))
        else:
            trace.deregisterNotifier(vtrace.NOTIFY_ALL, self.dnotif)

    def setMode(self, name, value):
        if self.trace != None:
            self.trace.setMode(name, value)
        self.modes[name] = value

    def getMode(self, name, default=False):
        if self.trace != None:
            return self.trace.getMode(name, default)
        return self.modes.get(name, default)

    def setMeta(self, name, value):
        if self.trace != None:
            self.trace.setMeta(name, value)
        self.metadata[name] = value

    def getMeta(self, name, default=None):
        if self.trace != None:
            return self.trace.getMeta(name, default)
        return self.metadata.get(name, default)

    def registerNotifier(self, event, notif):
        self.dnotif.registerNotifier(event, notif)

    def deregisterNotifier(self, event, notif):
        self.dnotif.deregisterNotifier(event, notif)

    def fireLocalNotifiers(self, event, trace):
        """
        Deliver a local event to the DistributedNotifier managing
        the traces. (used to locally bump notifiers)
        """
        self.dnotif.notify(event, trace)


########NEW FILE########
__FILENAME__ = watchpoints
"""
Watchpoint Objects
"""
# Copyright (C) 2007 Invisigoth - See LICENSE file for details
from vtrace import *
from vtrace.breakpoints import *

class Watchpoint(Breakpoint):
    """
    The basic "break on access" watchpoint.  Extended from 
    Breakpoints and handled almost exactly the same way...
    """
    def __init__(self, addr, expression=None, size=4, perms="rw"):
        Breakpoint.__init__(self, addr, expression=expression)
        self.wpsize = size
        self.wpperms = perms

    def inittrace(self, trace):
        # No need to get a breakinstr
        pass

    def resolvedaddr(self, trace, addr):
        # We needn't save the memory at our addr...
        pass

    def getName(self):
        bname = Breakpoint.getName(self)
        return "%s (%s %d bytes)" % (bname, self.wpperms, self.wpsize)

    def activate(self, trace):
        trace.requireAttached()
        if not self.active:
            if self.address != None:
                trace.archAddWatchpoint(self.address, size=self.wpsize, perms=self.wpperms)
                self.active = True
        return self.active

    def deactivate(self, trace):
        trace.requireAttached()
        if self.active:
            trace.archRemWatchpoint(self.address)
            self.active = False
        return self.active

class PageWatchpoint(Watchpoint):
    """
    A special "watchpoint" that uses memory permissions to
    watch for accesses to whole memory maps.  This *requires* OS
    help and only works on platforms which support:
    * platformProtectMemory()
    * signal/exceptions which denote the fault address on SEGV

    NOTE: These *must* be added page aligned
    """
    def __init__(self, addr, expression=None, size=4, watchread=False):
        Watchpoint.__init__(self, addr, expression=expression, size=size, perms='rw')
        self._orig_perms = None
        self._new_perms = e_mem.MM_READ
        if watchread:
            self._new_perms = e_mem.MM_NONE

    def resolvedaddr(self, trace, addr):
        self._orig_perms = trace.getMemoryMap(addr)[2]

    def notify(self, event, trace):
        pw = trace.getMeta('pagewatch')
        pc = trace.getProgramCounter()
        vaddr,vperm = trace.platformGetMemFault()
        pw.append((pc, vaddr, vperm))
        # Change to/from fastbreak on pagerun...
        self.fastbreak = trace.getMeta('pagerun')

    def getName(self):
        bname = Breakpoint.getName(self)
        return "%s (%s %d bytes)" % (bname, e_mem.reprPerms(self._new_perms), self.wpsize)

    def activate(self, trace):
        #trace.requireNotRunning()
        if not self.active:
            trace.protectMemory(self.address, self.wpsize, self._new_perms)
            self.active = True
        return self.active

    def deactivate(self, trace):
        #trace.requireNotRunning()
        if self.active:
            trace.protectMemory(self.address, self.wpsize, self._orig_perms)
            self.active = False
        return self.active


########NEW FILE########
__FILENAME__ = cluster
"""
A module for GUI management of cobra.cluster clients
calling into a server.
"""

import gtk

import cobra
import cobra.cluster as c_cluster

import vwidget.util as vw_util
import vwidget.views as vw_views

from vwidget.main import idlethread

class ClusterServerView(vw_views.VTreeView,
                        c_cluster.ClusterCallback):
    """
    A cluster server status GUI.
    """
    __cols__ = (
        ("Id", 0, int),
        ("Client",1,str),
        ("Status",2,str),
        ("Percent",3,int)
    )

    def __init__(self):
        vw_views.VTreeView.__init__(self)
        # Hook all the GUI callbacks in the server.
        #FIXME make this a callback object in the server
        self.id_iter = {}
        # Setup a progress bar renderer
        self.treeview.remove_column(self.treeview.get_column(3))
        col = vw_util.makeColumn("Percent", 3, cell=gtk.CellRendererProgress(), links={"value":3})
        self.treeview.append_column(col)

    # Mirror the server interfaces so it's easy to keep things straight
    def workGotten(self, server, work):
        ip,port = cobra.getCallerInfo()
        self._dispWorkGotten(work, ip, port)

    @idlethread
    def _dispWorkGotten(self, work, ip, port):
            iter = self.model.append((work.id, ip, "Starting", 0))
            self.id_iter[work.id] = iter

    @idlethread
    def workDone(self, server, work):
        iter = self.id_iter.pop(work.id, None)
        if iter != None:
            self.vwRemove(iter)

    def workTimeout(self, server, work):
        self.workDone(server, work)

    def workCanceled(self, server, work):
        self.workDone(server, work)

    def workFailed(self, server, work):
        self.workDone(server, work)

    @idlethread
    def workStatus(self, server, workid, status):
        iter = self.id_iter.get(workid)
        self.model.set_value(iter, 2, status)

    @idlethread
    def workCompletion(self, server, workid, percent):
        iter = self.id_iter.get(workid)
        self.model.set_value(iter, 3, percent)


########NEW FILE########
__FILENAME__ = config

import os

import gtk
import vwidget
import vwidget.util as vw_util
import vwidget.windows as vw_windows

class ConfigDialog(vw_windows.VWindow):

    def __init__(self, cfg, cfgname=None):
        """
        A dialog for editing config options.  If you specify "cfgname",
        all changes will be saved out to the specified file
        as they happen.
        """
        dname = os.path.dirname(vwidget.__file__)
        fname = os.path.join(dname, "config.glade")
        vw_windows.VWindow.__init__(self, fname, (0,0,500,300))

        self.setGeometry((0,0,500,300))

        self.cfg = cfg
        self.cfgname = cfgname

        tree = self.getWidget("ConfigTree")
        tree.append_column(vw_util.makeColumn("Section",1))
        tree.append_column(vw_util.makeColumn("Option",2))
        tree.append_column(vw_util.makeColumn("Value", 3, self.OptionEdited))

        model = gtk.TreeStore(str,str,str,str)
        tree.set_model(model)

        secs = cfg.sections()
        secs.sort()
        for sec in secs:
            i = model.append(None, (None, sec, None, None))
            opts = cfg.options(sec)
            opts.sort()
            for opt in opts:
                model.append(i, ("%s|%s" % (sec,opt), None, opt, cfg.get(sec, opt)))

    def OptionEdited(self, renderer, path, value):
        model = self.getWidget("ConfigTree").get_model()
        iter = model.get_iter(path)
        model.set_value(iter, 3, value)
        sec, opt = model.get_value(iter, 0).split("|", 1)
        self.cfg.set(sec, opt, value)
        if self.cfgname != None:
            self.cfg.write(file(self.cfgname, "wb"))
        return True


########NEW FILE########
__FILENAME__ = bezier

def splitline(pt1, pt2, percent=0.5):
    '''
    Return a point which splits the given line at the
    given percentag...

    Example: splitline( (0,0), (20, 30), 0.1)
    '''

    pt1_x, pt1_y = pt1
    pt2_x, pt2_y = pt2

    deltax = (pt2_x - pt1_x) * percent
    deltay = (pt2_y - pt1_y) * percent

    return int(pt1_x + deltax), int(pt1_y + deltay)

def calculate_bezier(points, steps = 30):
    '''
    Arbitrary depth and arbitrary precision bezier implementation.  Takes
    a list of (x,y) point tuples and returnes the points to draw for the
    bezier curve.
    '''
    ret = []
    points = [ (float(x),float(y)) for x,y in points ]

    for i in xrange(steps+1):

        pcent = i / float(steps)

        layers = [ points, ]
        while len(layers[-1]) != 1:
            l_points = layers[-1]
            newpoints = [ splitline( l_points[i], l_points[i+1], pcent) for i in xrange(len(l_points)-1) ]
            layers.append(newpoints)

        ret.append(layers[-1][0])

    return ret

if __name__ == '__main__':
    print calculate_bezier( [ (0,0), (3, 20), (20, 23), (20, 20)] )

    print calculate_bezier( [ (0,0), (10,10) ], 10)


########NEW FILE########
__FILENAME__ = catmullrom

def spline4p(t, p_1, p0, p1, p2):
    x_1a = t * ((2-t) * t - 1) * p_1[0]
    x_1b = t * ((2-t) * t - 1) * p_1[1]

    x0a  = (t * t * (3 * t - 5) + 2) * p0[0]
    x0b  = (t * t * (3 * t - 5) + 2) * p0[1]

    x1a  = t * ((4 - 3 * t) * t + 1) * p1[0]
    x1b  = t * ((4 - 3 * t) * t + 1) * p1[1]

    x2a  = (t - 1) * t * t * p2[0]
    x2b  = (t - 1) * t * t * p2[1]

    final = ( (x_1a + x0a + x1a + x2a) / 2,
              (x_1b + x0b + x1b + x2b) / 2)

    return final

def calculate_catmullrom(points, steps = 30):
    ret = []
    percents = [ step / float(steps) for step in range(steps) ]
    for i in xrange(1, len(points) - 2):
        for t in percents:
            ret.append(spline4p(t, points[i-1], points[i], points[i+1], points[i+2]))
    return ret
            


########NEW FILE########
__FILENAME__ = layout
"""
A layout manager for gtk windows.
"""

import gtk
import cPickle as pickle

class LayoutWindow(gtk.Window):

    lyt_restore = True

    def getWindowName(self):
        return self.__class__.__name__

    def getWindowState(self):
        return None

    def setWindowState(self, state):
        return None

    def getGeometry(self):
        """
        Returns a tuple of (x, y, xsize, ysize) for later use in setGeometry()
        """
        x, y = self.get_position()
        xsize, ysize = self.get_size()
        return (x, y, xsize, ysize)

    def setGeometry(self, geom):
        self.move(geom[0], geom[1])
        self.resize(geom[2], geom[3])

class LayoutManager:

    def __init__(self):
        self.windows = []
        self.winclasses = {}
        self.defaultgeom = {}

    def addWindowClass(self, cls, args=(), defgeom=None, clsname=None):
        if clsname == None:
            clsname = cls.__name__
        self.winclasses[clsname] = (cls,args)
        self.defaultgeom[clsname] = defgeom

    def getWindowClass(self, name):
        return self.winclasses.get(name)[0]

    def createWindow(self, clsname):
        clstup = self.winclasses.get(clsname)
        if clstup == None:
            raise Exception("Layout manager doesn't know how to make %s" % clsname)
        cls, args = clstup
        win = cls(*args)
        self.manageWindow(win)
        return win

    def getOrCreateWindow(self, name):
        '''
        Get an existing instance of the given window type.  If one does not
        exist, make one instead.
        '''
        for win in self.getManagedWindows():
            if win.getWindowName() == name:
                return win
        return self.createWindow(name)

    def loadLayoutFile(self, fd):
        try:
            for line in fd.readlines():

                clsname, geom, state = line.split(':', 2)

                clstup = self.winclasses.get(clsname)
                if clstup == None:
                    print "ERROR: unregistered class in layout: %s" % clsname
                    continue

                cls, args = clstup

                win = cls(*args)
                win.setGeometry(eval(geom))
                try:
                    win.setWindowState(eval(state))
                except Exception, e:
                    print "ERROR: Failed to set window state: %s %s" % (clsname, e)

                self.__trackWindow(win)

            return True

        except Exception, e:
            print 'Layout Error: %s' % e
            return False

    def saveLayoutFile(self, fd):
        """
        You *must* call the save layout routine *before* the gtk teardown.
        """
        wlist = []
        for win in self.windows:
            if win.lyt_restore:
                geom = win.getGeometry()
                state = win.getWindowState()
                wlist.append((win.getWindowName(), geom, state))
                fd.write('%s:%s:%s\n' % (win.getWindowName(), repr(geom), repr(state)))

    def __trackWindow(self, win):
        self.windows.append(win)
        win.connect("delete-event", self._windowDeleted)
        win.show_all()

    def getManagedWindows(self):
        return list(self.windows)

    def manageWindow(self, window):
        self.__trackWindow(window)
        geom = self.defaultgeom.get(window.__class__.__name__)
        if geom != None:
            window.setGeometry(geom)

    def _windowDeleted(self, window, event):
        try:
            self.windows.remove(window)
        except ValueError, e:
            pass

    def deleteAllWindows(self, omit=None):
        for win in self.windows:
            if win == omit:
                continue
            win.emit('delete_event', None)
            win.destroy()


########NEW FILE########
__FILENAME__ = main

import gtk
import time
import gobject
from threading import currentThread

from Queue import Queue

gtk.gdk.threads_init()

def idlethread(func):
    '''
    A decorator which causes the function to be called by the gtk
    main iteration loop rather than synchronously...

    NOTE: This makes the call async handled by the gtk main
    loop code.  you can NOT return anything.
    '''
    def dowork(arginfo):
        args,kwargs = arginfo
        return func(*args, **kwargs)

    def idleadd(*args, **kwargs):
        if currentThread().getName() == 'GtkThread':
            return func(*args, **kwargs)
        gtk.gdk.threads_enter()
        gobject.idle_add(dowork, (args,kwargs))
        gtk.gdk.threads_leave()

    return idleadd

def idlethreadsync(func):
    '''
    Similar to idlethread except that it is synchronous and able
    to return values.
    '''
    q = Queue()
    def dowork(arginfo):
        args,kwargs = arginfo
        try:
            q.put(func(*args, **kwargs))
        except Exception, e:
            q.put(e)

    def idleadd(*args, **kwargs):
        if currentThread().getName() == 'GtkThread':
            return func(*args, **kwargs)
        gtk.gdk.threads_enter()
        gobject.idle_add(dowork, (args,kwargs))
        gtk.gdk.threads_leave()
        return q.get()

    return idleadd

@idlethread
def shutdown():
    gtk.main_quit()

def mainthread():
    currentThread().setName('GtkThread')

def main():
    currentThread().setName('GtkThread')
    gtk.gdk.threads_enter()
    gtk.main()
    gtk.gdk.threads_leave()

def doiterations():
    gtk.gdk.threads_enter()
    while gtk.events_pending():
        gtk.main_iteration(False)
    gtk.gdk.threads_leave()


########NEW FILE########
__FILENAME__ = memview
"""
A unified memory analysis view
"""

import os
import gtk
import gtk.gdk as gdk

import vwidget.views as vw_views
from vwidget.main import idlethread, idlethreadsync

import envi
import envi.memcanvas as e_canvas


moddir = os.path.dirname(__file__)

# All normal key codes are the same as
# ord('K').  Some are here for special esc/FN etc treatment
KEYCODE_esc = 0xff1b

class VaTag(vw_views.VRevTextTag):

    def __init__(self, va):
        tname = '%.8x' % va
        vw_views.VRevTextTag.__init__(self, '%.8x' % va)
        self.va = va

class MemoryView(vw_views.VTextView, e_canvas.MemoryCanvas):
    """
    A MemoryCanvas compliant GTK TextView.
    """

    def __init__(self, memobj, syms=None):
        vw_views.VTextView.__init__(self)
        self.textview.set_editable(False)
        e_canvas.MemoryCanvas.__init__(self, memobj, syms=syms)
        self.iter = self.vwGetAppendIter()
        self.lastsize = 32

        # Set this to get gui widget updates in a MemoryWindow
        self.memwin = None

        self.vatag = None
        self.selectva = None

        # Keep "marked" va locations
        self.markmap = {}
        self.beginva = None
        self.endva = None

        self.valist = [] # our "history"
        self.histindex = None

        self.colormap = None

        # Anybody who extends this may by default put a file
        # named memview.conf to describe the default tags
        fullpath = os.path.join(moddir,"memview.conf") 
        self.vwLoadTags(fullpath)

        self.hotkeys = {}
        self.textview.connect("key_press_event", self.keyPressed)
        self.textview.connect("move_cursor", self.cursorMoved)

        self.registerHotKey(KEYCODE_esc, self.goback)

    @idlethread
    def setColorMap(self, map):
        oldmap = None
        if self.colormap != None:
            oldmap = self.colormap

        self.colormap = map

        if oldmap:
            for va in oldmap.keys():
                tag = self.getVaTag(va)
                self.vwSetTagColor(tag, "va")

        if self.colormap:
            for va,color in self.colormap.items():
                tag = self.getVaTag(va)
                tag.set_property('background', color)
                tag.set_property('foreground', 'black')

    def registerHotKey(self, keycode, callback, args=(), kwargs={}):
        self.hotkeys[keycode] = (callback,args,kwargs)

    def keyPressed(self, textview, event):
        hkinfo = self.hotkeys.get(event.keyval)
        if hkinfo == None:
            return
        callback,args,kwargs = hkinfo
        callback(*args, **kwargs)

    def cursorMoved(self, textview, stepsize, stepcount, eselect):
        if stepsize == gtk.MOVEMENT_DISPLAY_LINES:
            mark = self.textbuf.get_insert()
            iter = self.textbuf.get_iter_at_mark(mark)
            lineno = iter.get_line()
            self.setVaFromLine(lineno+stepcount)

#############################################################
# The MemoryCanvas API

    def write(self, msg):
        self.addText(msg)

    @idlethreadsync
    def getTag(self, typename):
        # Return a type colored tag that doesn't
        # do highlight on click etc...
        tag = self.vwGetTag(typename)
        if tag == None:
            tag = vw_views.VTextTag(typename)
            self.vwInitTag(tag, typename)
        return tag

    @idlethreadsync
    def getNameTag(self, tname, typename="name"):
        """
        Get a tag for a unique name
        (so they all highlight on highlight one)
        """
        tag = self.vwGetTag(tname)
        if tag == None:
            tag = vw_views.VRevTextTag(tname)
            self.vwInitTag(tag, typename, self.vwNamedTagEvent)
        return tag

    @idlethreadsync
    def getVaTag(self, va):
        tname = "%.8x" % va
        tag = self.vwGetTag(tname)
        if tag == None:
            #tag = gtk.TextTag(tname)
            tag = VaTag(va)
            self.vwInitTag(tag, "va", self.vaTagEvent)
            #tag.va = va
        return tag

    @idlethread
    def addText(self, text, tag=None):
        if tag == None:
            tag = self.vwGetTag("default")
        self.vwInsertText(text, tag=tag, iter=self.iter)

    @idlethread
    def addVaText(self, text, va):
        tag = self.getVaTag(va)
        self.addText(text, tag=tag)

#############################################################

    def appendHistory(self, va, size=None, rend=None):

        if size == None:
            size = self.lastsize

        if rend == None:
            rend = self.currend

        if self.histindex == None:
            self.histindex = -1
        self.histindex += 1
        self.valist = self.valist[:self.histindex]
        self.valist.append((va,size,rend))

    def checkRender(self, va, size=None, rend=None):
        # Check if the given VA is inside the currently rendered
        # space, and if not, make it there.

        if rend == None:
            rend = self.currend

        if size == None:
            size = self.lastsize

        if (  va < self.beginva or 
              va >= self.endva or
              rend != self.currend ):


            self.render(va, size, rend=rend)

    def goto(self, va, size=None, rend=None):
        if size == None:
            size = self.lastsize
        self.appendHistory(va, size=size, rend=rend)
        self.checkRender(va, size, rend=rend)
        self.__goto(va)

    def goforward(self):
        if self.histindex == None:
            return

        newindex = self.histindex + 1
        if newindex < len(self.valist):
            self.histindex = newindex
            va,size,rend = self.valist[self.histindex]
            self.checkRender(va,size,rend)
            self.__goto(va)

    def goback(self):
        if self.histindex == None:
            return
        if self.histindex > 0:
            self.histindex -= 1
            va,size,rend = self.valist[self.histindex]
            self.checkRender(va,size,rend)
            self.__goto(va)

    def godown(self):
        va,size,rend = self.valist[self.histindex]
        va = self.endva
        self.checkRender(va, size, rend)
        self.__goto(va)

    def goup(self):
        va,size,rend = self.valist[self.histindex]
        va = self.beginva - size
        self.checkRender(va, size, rend)
        self.__goto(va)

    def __goto(self, va):
        # Scroll and highlight.
        mark = self.markmap.get(va)
        while mark == None:
            va -= 1
            mark = self.markmap.get(va)
        self.textview.scroll_to_mark(mark, 0, True, 0, 0.3)

        # Select the specified tag
        vatag = self.getVaTag(va)
        self.vaTagSelector(vatag)

        if self.memwin:
            self.memwin.updateHistoryButtons()
            #self.memwin.eentry.set_text(hex(va))

    @idlethreadsync
    def render(self, va, size, rend=None):
        self.vwClearText()
        self.iter = self.vwGetAppendIter()

        self.beginva = va
        self.endva = va + size

        self.render_noclear(va, size, rend=rend)

    @idlethreadsync
    def render_noclear(self, va, size, rend=None):
        # Use this if you've set up your own iter for a partial
        # re-render and don't want your render call to clear the
        # current canvas or set the iter.

        if rend == None:
            rend = self.currend

        self.lastsize = size
        self.currend = rend # we need this for tag events... store it.

        try:
            endva = va + size
            while va < endva:
                mark = self.textbuf.create_mark(None, self.iter, left_gravity=True)
                self.markmap[va] = mark
                va += rend.render(self, va)
        except Exception, e:
            self.addText("\nException At %s: %s\n" % (hex(va),e))

    def refresh(self, va, size):
        if va < self.beginva or va >= self.endva:
            return

        endva = va+size

        # Find the beginning mark for the change.
        mark = self.markmap.get(va)
        if mark == None:
            print "WARNING: va 0x%.8x has no mark for refresh!" % va
            return

        # Get the start iter
        startiter = self.textbuf.get_iter_at_mark(mark)
        startline = startiter.get_line()

        # Search for the end iter
        endmark = None
        endsearch = endva
        enditer = None
        while endsearch < self.endva:
            endmark = self.markmap.get(endsearch, None)
            if endmark != None:
                enditer = self.textbuf.get_iter_at_mark(endmark)
                break
            endsearch += 1

        if enditer == None:
            enditer = self.textbuf.get_end_iter()

        # Delete the old text
        self.textbuf.delete(startiter, enditer)

        for delva in range(va, endsearch):
            mark = self.markmap.pop(delva, None)
            if mark != None:
                # FIXME make sure parents are using vwClear and deleting marks!
                self.textbuf.delete_mark(mark)

        # we're all cleaned up, lets re-render the area
        self.iter = self.textbuf.get_iter_at_line(startline)

        self.render_noclear(va, size)

        # Because the endmark was left gravity, he stayed at the beginning, move him.
        if endmark != None:
            self.textbuf.move_mark(endmark, self.iter)

        return

    def vwClearText(self):
        vw_views.VTextView.vwClearText(self)
        # FIXME delete marks from textview!
        self.markmap = {}

    def vaTagSelector(self, tag):
        # Check if it's already selected
        if self.vatag == tag:
            return
        if self.vatag != None:
            self.vatag.reverse()
        self.vatag = tag
        self.vatag.reverse()

    def vwNamedTagEvent(self, tag, textview, event, iter):
        self.vwTagEvent(tag, textview, event, iter)
        self.vwTagSelector(tag, textview, event, iter)

    def vwTagEvent(self, tag, textview, event, iter):
        # The first tag on a line is *always* the VA tag
        # for the line.  Update our "position" on clicks
        if event.type == gdk.BUTTON_PRESS:
            self.setVaFromIter(iter)

    # A special tag event handler for VA tags.
    def vaTagEvent(self, tag, textview, event, iter):

        if event.type == gdk._2BUTTON_PRESS:
            self.goto(tag.va)

        elif event.type == gdk.BUTTON_PRESS:
            self.selectva = tag.va
            self.vaTagSelector(tag)

    def setVaFromIter(self, iter):
        lineno = iter.get_line()
        self.setVaFromLine(lineno)

    def setVaFromLine(self, lineno):
        lineiter = self.textbuf.get_iter_at_line(lineno)
        linetags = lineiter.get_tags()
        if len(linetags):
            vatag = linetags[0]
            va = getattr(vatag, "va", None)
            if va != None:
                self.selectva = va
                self.vaTagSelector(vatag)

class ScrolledMemoryView(MemoryView):
    """
    Over-ride some of the MemoryView methods to make this a more
    continuous scrolling kind of canvas (like a CLI)
    """

    @idlethreadsync
    def render(self, va, size, rend=None):
        MemoryView.render(self, va, size, rend=rend)
        self.addText("\n")
        self.vwScrollToBottom()

    @idlethread
    def addText(self, text, tag=None):
        MemoryView.addText(self, text, tag=tag)
        if text.find("\n") != -1:
            self.vwScrollToBottom()

    def goto(self, va, size=None, rend=None):
        if size == None:
            size = self.lastsize
        self.render(va, size, rend=rend)

    def vwClearText(self):
        pass

import vwidget.layout as vw_layout

class MemoryWindow(vw_layout.LayoutWindow):
    def __init__(self, canvas):
        self.canvas = canvas
        vw_layout.LayoutWindow.__init__(self)
        self.vbox = gtk.VBox()
        elabel = gtk.Label(" Memory Expression ")
        slabel = gtk.Label(" Memory Size ")

        self.eentry = gtk.Entry()
        self.sentry = gtk.Entry()
        self.sentry.set_text("256")

        self.nextbutton = gtk.Button()
        i = gtk.image_new_from_stock(gtk.STOCK_GO_FORWARD, gtk.ICON_SIZE_BUTTON)
        self.nextbutton.set_image(i)
        self.nextbutton.connect("clicked", self.goforward)

        self.backbutton = gtk.Button()
        i = gtk.image_new_from_stock(gtk.STOCK_GO_BACK, gtk.ICON_SIZE_BUTTON)
        self.backbutton.set_image(i)
        self.backbutton.connect("clicked", self.goback)

        self.downbutton = gtk.Button()
        i = gtk.image_new_from_stock(gtk.STOCK_GO_DOWN, gtk.ICON_SIZE_BUTTON)
        self.downbutton.set_image(i)
        self.downbutton.connect("clicked", self.godown)

        self.upbutton = gtk.Button()
        i = gtk.image_new_from_stock(gtk.STOCK_GO_UP, gtk.ICON_SIZE_BUTTON)
        self.upbutton.set_image(i)
        self.upbutton.connect("clicked", self.goup)

        hbox = gtk.HBox()

        hbox.pack_start(self.backbutton, expand=False)
        hbox.pack_start(self.nextbutton, expand=False)
        hbox.pack_start(self.upbutton, expand=False)
        hbox.pack_start(self.downbutton, expand=False)
        hbox.pack_start(elabel, expand=False)
        hbox.pack_start(self.eentry, expand=True)
        hbox.pack_start(slabel, expand=False)
        hbox.pack_start(self.sentry, expand=True)

        self.cbox = gtk.combo_box_new_text()
        for name in self.canvas.getRendererNames():
            self.canvas.addRenderer(name, self.canvas.getRenderer(name))
            self.cbox.append_text(name)
        self.cbox.set_active(0)
        hbox.pack_start(self.cbox, expand=False)

        self.vbox.pack_start(hbox, expand=False)
        self.vbox.pack_start(self.canvas, expand=True)
        self.add(self.vbox)

        self.eentry.connect("activate", self.entryActivated)
        self.sentry.connect("activate", self.entryActivated)
        self.cbox.connect("changed", self.updateMemoryView)

        self.canvas.memwin = self
        self.updateHistoryButtons()

    def updateHistoryButtons(self):
        hi = self.canvas.histindex
        vl = self.canvas.valist
        self.nextbutton.set_sensitive(False)
        self.backbutton.set_sensitive(False)
        if hi == None:
            return
        if hi > 0:
            self.backbutton.set_sensitive(True)
        if hi < (len(vl)-1):
            self.nextbutton.set_sensitive(True)

    def goto(self, va, size=None, rend=None):
        self.canvas.goto(va, size=size, rend=rend)
        self.updateHistoryButtons()

    def godown(self, *args):
        self.canvas.godown()
        self.updateHistoryButtons()

    def goup(self, *args):
        self.canvas.goup()
        self.updateHistoryButtons()

    def goforward(self, *args):
        self.canvas.goforward()
        self.updateHistoryButtons()

    def goback(self, *args):
        self.canvas.goback()
        self.updateHistoryButtons()

    def setExpression(self, expr, size="1024"):
        self.eentry.set_text(expr)
        self.sentry.set_text(size)
        self.updateMemoryView()

    def entryActivated(self, *args):
        self.updateMemoryView()
        self.set_title("Memory: %s" % self.eentry.get_text())

    def updateMemoryView(self, *args):

        expr, sizestr, rendname = self.getWindowState()

        # If either string is "", return
        if not expr or not sizestr:
            return

        try:
            # FIXME this is a non-api assured assumption
            va = self.canvas.mem.parseExpression(expr)
        except Exception, e:
            self.canvas.addText("Invalid Expression: %s (%s)" % (expr,str(e)))
            return

        try:
            size = self.canvas.mem.parseExpression(sizestr)
        except Exception, e:
            self.canvas.addText("Invalid Expression: %s (%s)" % (expr,str(e)))
            return

        rend = self.canvas.getRenderer(rendname)
        self.goto(va, size=size, rend=rend)

    def setWindowState(self, state):
        e,s,r = state
        self.eentry.set_text(e)
        self.sentry.set_text(s)
        try:
            ridx = self.canvas.getRendererNames().index(r)
            self.cbox.set_active(ridx)
        except ValueError, e:
            pass
        self.entryActivated()

    def getWindowState(self):
        e = self.eentry.get_text()
        s = self.sentry.get_text()
        renditer = self.cbox.get_active_iter()
        r = self.cbox.get_model().get_value(renditer, 0)
        return (e,s,r)


########NEW FILE########
__FILENAME__ = menubuilder

import gtk

class FieldAdder:
    def __init__(self, menu, splitchar='.'):
        self.splitchar = splitchar
        self.menu = menu
        self.menu.idx = 0
        self.menu.kids = {}

    def addField(self, pathstr, callback=None, args=(), stockid=None):
        parent = self.menu
        kid = None
        plist = pathstr.split(self.splitchar)

        for p in plist[:-1]:
            kid = parent.kids.get(p)
            if kid == None:
                item = gtk.MenuItem(p, True)
                item.set_name("vwidget_menu")
                item.show()
                parent.insert(item, parent.idx)
                parent.idx += 1
                kid = Menu()
                kid.idx = 0
                item.set_submenu(kid)
                parent.kids[p] = kid
            parent = kid

        if stockid != None:
            item = gtk.ImageMenuItem(stock_id=stockid)
        else:
            item = gtk.MenuItem(plist[-1], True)
        if callback != None:
            item.connect("activate", callback, *args)

        item.show()
        item.set_name("vwidget_menu")
        parent.insert(item, parent.idx)
        parent.idx += 1
        #parent.append(item)
        return item

class MenuBar(FieldAdder, gtk.MenuBar):
    def __init__(self):
        gtk.MenuBar.__init__(self)
        FieldAdder.__init__(self, self)
        self.set_name("vwidget_menu")

class Menu(FieldAdder, gtk.Menu):
    def __init__(self):
        gtk.Menu.__init__(self)
        FieldAdder.__init__(self, self)
        self.set_name("vwidget_menu")


########NEW FILE########
__FILENAME__ = notebook

"""
A suite of tools for dealing with notebooks...
"""

import gtk

def prepNotebook(notebook=None, group=1):
    """
    Setup a notebook for use in vwindows/vviews.
    """
    if notebook == None:
        notebook = gtk.Notebook()
    if gtk.gtk_version[0] >= 2 and gtk.gtk_version[1] >= 12:
        notebook.connect("create-window", createNotebookWindow)
    notebook.set_group_id(group)
    return notebook

def appendToNotebook(notebook, view, totop=True):
    """
    Add the specified view to the given notebook which has
    been prep'd with prepNotebook.  It gives you a bunch of
    junk for free.
    """
    label = createTabLabel(view, notebook)
    index = notebook.append_page(view, label)
    notebook.set_tab_reorderable(view, True)
    notebook.set_tab_detachable(view, True)
    if totop:
        notebook.set_current_page(index)

def removeFromNotebook(notebook, page):
    notebook.remove_page(notebook.page_num(page))

def createTabLabel(page, notebook):
    label = gtk.Label(page.vwGetDisplayName())

    if not page.vwIsClosable():
        return label

    box = gtk.HBox()
    image = gtk.Image()
    image.set_from_stock(gtk.STOCK_CLOSE, gtk.ICON_SIZE_SMALL_TOOLBAR)

    cbutton = gtk.Button()
    cbutton.connect("clicked", closeTabButton, page, notebook)
    cbutton.set_image(image)
    cbutton.set_relief(gtk.RELIEF_NONE)

    box.pack_start(label, True, True)
    box.pack_end(cbutton, False, False)
    box.show_all()
    return box

def closeTabButton(button, page, notebook):
    removeFromNotebook(notebook, page)

def createNotebookWindow(notebook, page, x=400, y=300):
    """
    Snap the given page out of the notebook and create a new
    window for it...
    """
    notebook.remove_page(notebook.page_num(page))
    createWindowForPage(page, x, y)

def createWindowForPage(page, x=300, y=400):
    """
    x and y are the position for the new window
    """

    win = gtk.Window()
    nb = prepNotebook()
    nb.connect("page-removed", notebookWindowPageRemoved, win)
    appendToNotebook(nb, page)
    win.notebook = nb # NOTE: assume all "page windows" have this...
    win.add(nb)
    win.show_all()
    win.move(x,y)
    return win

def notebookWindowPageRemoved(notebook, child, pagenum, window):
    """
    When a tab is removed from a popped up window, check if it is the last.
    """
    if notebook.get_n_pages() == 0:
        window.destroy()


########NEW FILE########
__FILENAME__ = pydialog

import os

from threading import Thread

import gtk
import vwidget
import vwidget.main as vw_main
import vwidget.windows as vw_windows

class ScriptThread(Thread):
    def __init__(self, cobj, locals):
        Thread.__init__(self)
        self.setDaemon(True)
        self.cobj = cobj
        self.locals = locals

    def run(self):
        try:
            exec(self.cobj, self.locals)
        except Exception, e:
            print "Script Error: ",e

class PyDialog(vw_windows.VWindow):
    def __init__(self, locals=None):
        dname = os.path.dirname(vwidget.__file__)
        fname = os.path.join(dname, "pydialog.glade")
        vw_windows.VWindow.__init__(self, fname, None)
        if locals == None:
            locals = {}
        self.locals = locals

    def PyDialogRun(self, button):
        buffer = self.getWidget("PyDialogText").get_buffer()
        start, end = buffer.get_bounds()
        script = buffer.get_text(start,end)
        self.runPython(script)

    def runPython(self, pystring):
        """
        Extend and over-ride this for any special handling...
        """
        cobj = compile(pystring, "pydialog_exec.py", "exec")
        sthr = ScriptThread(cobj, self.locals)
        sthr.start()
        # FIXME set button insensitive and have ScriptThread take
        # a reference to the dialog and change it back when run is complete


########NEW FILE########
__FILENAME__ = util
"""
Just a place to house some universalish utilities
"""

import gtk

def makeColumn(name, index, onedit=None, cell=None, links=None):
    """
    Return a default "TreeViewColumn" of name "name"
    whose TreeModel index for the renderer is "index"
    """
    if cell == None:
        cell = gtk.CellRendererText()
    if links == None:
        links = {"text":index}
    if onedit:
        cell.set_property("editable", True)
        cell.connect("edited", onedit)
    col = gtk.TreeViewColumn(name,cell,**links)
    col.set_property("clickable", True)
    col.set_property("reorderable", True)
    col.set_property("resizable",True)
    col.set_property("sizing",1)
    col.set_property("sort-indicator", True)
    col.set_sort_column_id(index)
    return col

def getTreeSelected(treeview, colnum):
    """
    Return the object in column *colnum* from the currently
    selected row in the given treeview...
    """
    ret = None
    path,view = treeview.get_cursor()
    model = treeview.get_model()
    if path:
        iter = model.get_iter(path)
        ret = model.get_value(iter, colnum)
    return ret



########NEW FILE########
__FILENAME__ = views

import gtk
import gtk.gdk as gdk
import vwidget.util as vw_util
from ConfigParser import ConfigParser

class VView(gtk.ScrolledWindow):

    __display_name__ = "Stuff!"

    def __init__(self, closable=True):
        gtk.ScrolledWindow.__init__(self)
        self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        self.vwactive = True
        self.vwname = None
        self.closable = closable
        self.connect("destroy", self.vwDestroy)

    def vwDestroy(self, arg):
        pass

    def vwSetSensitive(self, sensitive=True):
        """
        Set this view object as "sensitive" to user input
        """
        if self.vwactive != sensitive:
            self.vwactive = sensitive
            self.set_sensitive(sensitive)

    def vwGetDisplayName(self):
        if self.vwname == None:
            return self.__class__.__display_name__
        return self.vwname

    def vwSetDisplayName(self, name):
        self.vwname = name

    def vwGetViewName(self):
        return self.__class__.__name__

    def vwIsClosable(self):
        return self.closable

    def vwSetClosable(self, closable):
        self.closable = closable

class GladeView(VView):
    """
    Use a glade file to define "views" with the same name as the class
    (
    """
    def __init__(self, gladefile):
        VView.__init__(self)
        self.vwglade = gtk.glade.XML(gladefile)
        self.vwglade.signal_autoconnect(self)
        win = self.vwglade.get_wiget(self.__class__.__name__)
        frame = win.get_child()
        p = view.get_parent()
        if p != None:
            p.remove(frame)
        win.destroy()
        self.add(frame)

    def vwGetWidget(self, name):
        return self.vwglade.get_widget(name)

class VTreeView(VView):

    __model_class__ = gtk.ListStore
    # Some example column definitions
    __cols__ = (
        (None, 0, object),
        ("Address",1, str),
        ("Stuff",2, str)
    )

    __editors__ = {} # 'Address': 'editAddrMethodName'

    def __init__(self):
        VView.__init__(self)
        self.treeview = gtk.TreeView()
        self.treeview.connect("row_activated", self.vwActivated)
        cols = self.vwGetColumns()
        self.vwInitModel(cols, self.__model_class__)
        self.add(self.treeview)
        self.vwLoad()

    def vwGetColumns(self):
        return self.__cols__

    def vwInitModel(self, cols, modelclass):
        # Remove any old columns
        for col in self.treeview.get_columns():
            self.treeview.remove_column(col)

        ftypes = []
        for name,index,ctype in cols:
            ftypes.append(ctype)
            if name == None:
                continue

            onedit = None
            emeth_name = self.__editors__.get(name)
            if emeth_name != None:
                onedit = getattr(self, emeth_name, None)
            col = vw_util.makeColumn(name, index, onedit=onedit)
            self.treeview.append_column(col)

        self.model = modelclass(*ftypes)
        self.treeview.set_model(self.model)

    def vwLoad(self):
        # Over-ride this to cause a load from scratch
        pass

    def vwClear(self):
        # This clears the view
        self.model.clear()

    def vwRemove(self, iter):
        self.model.remove(iter)

    def vwActivated(self, tree, path, column):
        # over-ride this for activation callbacks
        pass

    def vwGetSelected(self, column):
        """
        Get the selected row's column by index
        """
        return vw_util.getTreeSelected(self.treeview, column)

class VTextTag(gtk.TextTag):
    def __init__(self, tname):
        gtk.TextTag.__init__(self, tname)
        self.reversed = False

    def reverse(self):
        pass

class VRevTextTag(VTextTag):

    def reverse(self):
        front = self.get_property("foreground-gdk")
        back = self.get_property("background-gdk")
        self.set_property("foreground-gdk", back)
        self.set_property("background-gdk", front)
        self.reversed = not self.reversed

class VTextView(VView):

    def __init__(self, tagtable=None):
        VView.__init__(self)
        self.textview = gtk.TextView()
        self.textview.connect("populate_popup", self.vwGetPopup)
        self.add(self.textview)

        if tagtable == None:
            tagtable = gtk.TextTagTable()

        self.vwSetTagTable(tagtable)

        style = gtk.Style()

        style.base[gtk.STATE_NORMAL] = gdk.Color(0,0,0)
        style.text[gtk.STATE_NORMAL] = gdk.Color(0,0,0xff)

        style.base[gtk.STATE_INSENSITIVE] = gdk.Color(0,0,0)
        style.text[gtk.STATE_INSENSITIVE] = gdk.Color(20,20,20)

        self.textview.set_style(style)

        self.tagcfg = ConfigParser()

        self.curtag = None # Is a current tag selected?
        #self.deftag = 
        self.vwInitTag(VTextTag("default"))

        start,end = self.textbuf.get_bounds()
        self.textbuf.create_mark("insertend", end)

    def vwSetTagTable(self, tagtable):
        self.tagtable = tagtable
        self.textbuf = gtk.TextBuffer(self.tagtable)
        self.textview.set_buffer(self.textbuf)

    def vwGetTagTable(self):
        return self.tagtable

    def vwInitTag(self, tag, typename="default", handler=None, *handleargs):
        """
        Initialize a tag for event processing and properties from
        the tag config.
        """
        if handler != None:
            tag.connect("event", handler, *handleargs)
        self.tagtable.add(tag)
        self.vwSetTagColor(tag, typename=typename)

    def vwSetTagColor(self, tag, typename="default"):
        if self.tagcfg.has_section(typename):
            for name in self.tagcfg.options(typename):
                tag.set_property(name, self.tagcfg.get(typename,name))
        else:
            tag.set_property("font", "Monospace 10")
            tag.set_property("foreground", "green")
            tag.set_property("background", "black")

    def vwTagSelector(self, tag, textview, event, iter):
        """
        Use this as the event handler for tag events on exclusivly
        selectable tags.
        """
        if event.type == gdk.BUTTON_PRESS:
            if tag.get_property("name") != "default":
                if self.curtag != None:
                    self.curtag.reverse()
                tag.reverse()
                self.curtag = tag
                return True

    def vwLoadTags(self, tagfile):
        self.tagcfg.read(tagfile)
        for sec in self.tagcfg.sections():
            tag = self.vwGetTag(sec)
            if tag == None:
                tag = VTextTag(sec)
                self.tagtable.add(tag)

            tag.connect("event",self.vwTagEvent)
            for name in self.tagcfg.options(sec):
                val = self.tagcfg.get(sec,name)
                if val.isdigit():
                    val = int(val)
                tag.set_property(name, val)

    def vwGetTag(self, name=None):
        if name == None:
            name = "default"
        return self.tagtable.lookup(name)

    def vwTagEvent(self, tag, textview, event, iter):
        #print "OVERRIDE ME FOR TAG EVENT PROCESSING!"
        pass

    def vwGetPopup(self, textview, menu, vwfaddr=None):
        """
        Over-ride this to add elements to the right click menu on click.
        """
        #mn = gtk.MenuItem("Example!")
        #mn.connect("activate", self.doexample)
        #mn.show()
        #menu.prepend(mn)
        pass

    def vwInsertText(self, text, iter=None, tagname=None, tag=None):
        if iter == None:
            iter = self.textbuf.get_end_iter()
        if tagname == None and tag == None:
            self.textbuf.insert(iter, text)
        else:
            if tagname != None:
                tag = self.tagtable.lookup(tagname)
            self.textbuf.insert_with_tags(iter, text, tag)
        self.textbuf.move_mark_by_name("insertend", iter)

    def vwScrollToBottom(self):
        mark = self.textbuf.get_mark("insertend")
        self.textview.scroll_to_mark(mark,0)

    def vwScrollToTop(self):
        start,end = self.textbuf.get_bounds()
        self.textview.scroll_to_iter(start, 0)

    def vwClearText(self):
        start,end = self.textbuf.get_bounds()
        self.textbuf.delete(start, end)
    
    def vwGetAppendIter(self):
        return self.textbuf.get_end_iter()


########NEW FILE########
__FILENAME__ = vwvstruct

"""
GUI widgets for use in vstruct enabled applications
"""

import gtk
import inspect
import vstruct
import vstruct.builder as vs_builder
import vstruct.primitives as vs_prims

import vwidget.main as vw_main
import vwidget.util as vw_util
import vwidget.views as vw_views

target_entries = [('example', gtk.TARGET_SAME_APP, 0)]

def selectStructure(vsbuilder, parent=None):
    dia = SelectStructureDialog(vsbuilder, parent=parent)
    return dia.selectStructure()

def selectNamespace(parent=None):
    dia = SelectNamespaceDialog(parent=parent)
    return dia.selectNamespace()

class SelectStructureDialog(gtk.Dialog):
    def __init__(self, vsbuilder, parent=None):
        buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OPEN,gtk.RESPONSE_OK)
        gtk.Dialog.__init__(self, "Select a structure...", buttons=buttons, parent=parent)
        self.selector = VStructBuilderView(vsbuilder)
        self.vbox.pack_start(self.selector, expand=True)
        self.selector.treeview.connect("row_activated", self.nsActivated)
        self.selector.treeview.connect("cursor_changed", self.nsSelected)
        self.modinfo = None
        self.resize(400, 600)

    def nsActivated(self, *args):
        self.response(gtk.RESPONSE_OK)

    def nsSelected(self, *args):
        self.modinfo = self.selector.vwGetSelected(0)

    def selectStructure(self):
        self.show_all()
        resp = self.run()
        self.hide()
        if resp == gtk.RESPONSE_OK:
            return self.modinfo
        return None

class SelectNamespaceDialog(gtk.Dialog):
    def __init__(self, parent=None):
        buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OPEN,gtk.RESPONSE_OK)
        gtk.Dialog.__init__(self, "Select a structure namespace...", buttons=buttons, parent=parent)
        self.selector = VStructNamespaceSelector()
        self.vbox.pack_start(self.selector, expand=True)
        self.selector.treeview.connect("row_activated", self.nsActivated)
        self.selector.treeview.connect("cursor_changed", self.nsSelected)
        self.modinfo = None
        self.resize(400, 600)

    def nsActivated(self, *args):
        self.response(gtk.RESPONSE_OK)

    def nsSelected(self, *args):
        nspace = self.selector.vwGetSelected(2)
        modname = self.selector.vwGetSelected(0)
        if modname:
            self.modinfo = (nspace, modname)

    def selectNamespace(self):
        self.show_all()
        resp = self.run()
        self.hide()
        if resp == gtk.RESPONSE_OK:
            return self.modinfo
        return None

class VStructNamespaceSelector(vw_views.VTreeView):
    __model_class__ = gtk.TreeStore
    __cols__ = (
        (None, 0, object),
        ('Subsystem', 1, str),
        ('Module Name', 2, str),
    )

    def __init__(self):
        vw_views.VTreeView.__init__(self)

    def vwLoad(self):
        self.model.clear()

        win = self.model.append(None, (None, 'windows', ''))
        xp_i386_user = self.model.append(win, (None, 'Windows XP i386 Userland', ''))
        self.model.append(xp_i386_user, ('vstruct.defs.windows.win_5_1_i386.ntdll','', 'ntdll'))

        xp_i386_kern = self.model.append(win, (None, 'Windows XP i386 Kernel', ''))
        self.model.append(xp_i386_kern, ('vstruct.defs.windows.win_5_1_i386.ntoskrnl','', 'nt'))
        self.model.append(xp_i386_kern, ('vstruct.defs.windows.win_5_1_i386.win32k','', 'win32k'))

        win7_amd64_user = self.model.append(win, (None, 'Windows 7 amd64 Userland', ''))
        self.model.append(win7_amd64_user, ('vstruct.defs.windows.win_6_1_amd64.ntdll','', 'ntdll'))

        pos = self.model.append(None, (None, 'posix', ''))
        self.model.append(pos, ('vstruct.defs.elf', '', 'Elf'))

        arm = self.model.append(None, (None, 'arm', ''))
        self.model.append(arm, (None, '', 'arm7'))

    def __vwActivated(self, tree, path, column):
        x = self.vwGetSelected(0)
        if x == None:
            return

        print 'WOOT',x

        import sys
        import gtk
        __import__(x)
        mod = sys.modules[x]

        b = vs_builder.VStructBuilder()
        b.addVStructNamespace(self.vwGetSelected(2), mod)

        bv = VStructBuilderView(b)

        w = gtk.Window()
        w.add(bv)

        w.show_all()


class VStructBuilderView(vw_views.VTreeView):
    __model_class__ = gtk.TreeStore
    __cols__ = (
        (None,        0, object),
        ('Namespace', 1, str),
        ('Structure', 2, str),
    )

    def __init__(self, vsbuilder):
        self.vsbuilder = vsbuilder
        vw_views.VTreeView.__init__(self)

    def vwLoad(self):
        for nsname in self.vsbuilder.getVStructNamespaceNames():
            nm = self.model.append(None, (None, nsname, ''))
            for sname in self.vsbuilder.getVStructNames(namespace=nsname):
                self.model.append(nm, ('%s.%s' % (nsname, sname), '', sname))

    # FIXME make a structure selector for a builder namespace!

class VStructView(vw_views.VTreeView):
    __model_class__ = gtk.TreeStore
    __cols__ = (
        (None, 0, object),
        #FIXME offset and use vsGetPrintInfo
        ("Offset", 1, str),
        ("Name", 2, str),
        ("Type", 3, str),
    )

    def __init__(self, vs, editable=False):
        self.mystruct = vs
        vw_views.VTreeView.__init__(self)

        if editable:
            self.treeview.enable_model_drag_dest(target_entries, gtk.gdk.ACTION_MOVE)
            self.treeview.connect('drag-data-received', self.vwDragRecv)

    def vwDragRecv(self, treeview, dcontext, x, y, sdata, info, etime):
        print "DROP!",sdata.data
        drow = treeview.get_dest_row_at_pos(x, y)
        print repr(self.treeview),repr(treeview)
        if drow == None:
            titer = None
            dpos = gtk.TREE_VIEW_DROP_AFTER
        else:
            tpath, dpos = drow
            titer = self.model.get_iter(tpath)

        #if dpos == gtk.TREE_VIEW_DROP_INTO_OR_BEFORE:
            #new = self.model.prepend(parent=target, row=source_row)
        #elif dpos == gtk.TREE_VIEW_DROP_INTO_OR_AFTER:
            #new = self.model.append(parent=target, row=source_row)
        #elif dpos == gtk.TREE_VIEW_DROP_BEFORE:
            #new = self.model.insert_before(parent=None, sibling=target, row=source_row)
        #elif dpos == gtk.TREE_VIEW_DROP_AFTER:
            #new = self.model.insert_after(parent=None, sibling=target, row=source_row)

        dcontext.finish(success=False, del_=False, time=etime)

    def vwLoad(self):
        self.model.clear()
        i = self.model.append(None, (self.mystruct, "00000000", self.mystruct._vs_name, self.mystruct.vsGetClassPath()))
        todo = [(self.mystruct, i, 0),]
        while len(todo):
            d,iter,baseoff = todo.pop()
            for name,field in d: # FIXME unify iter for vstruct w/o name?
                if isinstance(field, vstruct.VStruct):
                    off = d.vsGetOffset(name)
                    i = self.model.append(iter, (d, "%.8x" % (baseoff+off), name, ""))
                    todo.append((field, i, baseoff+off))

                elif isinstance(field, vstruct.VArray):
                    pass

                else:
                    off = d.vsGetOffset(name)
                    self.model.append(iter, (field, "%.8x" % (baseoff+off), name, field.vsGetTypeName()))

    def vwActivated(self, tree, path, column):
        print "WOOT"
        pass

class VStructBrowser(vw_views.VTreeView):
    __model_class__ = gtk.TreeStore
    __cols__ = (
        (None, 0, object),
        ("Name", 1, str),
    )

    def __init__(self):
        vw_views.VTreeView.__init__(self)
        self.treeview.enable_model_drag_source(
            gtk.gdk.BUTTON1_MASK,
            target_entries,
            gtk.gdk.ACTION_MOVE)
        self.treeview.connect("drag-data-get", self.vwDragGet)

    def vwDragGet(self, treeview, dcontext, sdata, info, etime):
        treesel = treeview.get_selection()
        model, iter = treesel.get_selected()
        text = model.get_value(iter, 1)
        sdata.set('example', 8, text)
        return

    def vwLoad(self):
        self.model.clear()
        # Start with just the primitives.
        piter = self.model.append(None, (vs_prims, "primitives"))
        for name in dir(vs_prims):
            c = getattr(vs_prims, name)

            if inspect.isclass(c):

                if issubclass(c, vs_prims.v_prim):
                    self.model.append(piter, (c, c.__name__))

class VStructAttrs(vw_views.VTreeView):
    pass


########NEW FILE########
__FILENAME__ = vwvtrace
import envi.memory as e_mem
import vtrace
import gtk
import vwidget.views as vw_views

from envi.threads import firethread
from vwidget.main import idlethread, idlethreadsync

class VtraceView:
    def __init__(self, trace):
        self.trace = trace

    def setTrace(self, trace):
        self.trace = trace

    def traceIsReady(self):
        if self.trace.isAttached() and not self.trace.isRunning():
            return True
        return False

class ProcessListView(VtraceView, vw_views.VTreeView):
    __cols__ = (
        (None, 0, object),
        ("Pid", 1, int),
        ("Name", 2, str),
    )

    def __init__(self, trace):
        VtraceView.__init__(self, trace)
        vw_views.VTreeView.__init__(self)

    def vwLoad(self):
        self.vwClear()
        for pid,name in self.trace.ps():
            self.model.append((None,pid,name))

class SelectProcessDialog(gtk.Dialog):
    def __init__(self, trace):
        buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OPEN,gtk.RESPONSE_OK)
        gtk.Dialog.__init__(self, "Select a process...", buttons=buttons)
        self.proclist = ProcessListView(trace)
        self.vbox.pack_start(self.proclist, expand=True)
        self.proclist.treeview.connect("row_activated", self.procListActivated)
        self.proclist.treeview.connect("cursor_changed", self.procListSelected)
        self.pid = None
        self.resize(300, 600)

    def procListActivated(self, *args):
        self.response(gtk.RESPONSE_OK)

    def procListSelected(self, *args):
        self.pid = self.proclist.vwGetSelected(1)

    def selectProcess(self):
        self.show_all()
        resp = self.run()
        self.hide()
        if resp == gtk.RESPONSE_OK:
            return self.pid
        return None

class TraceToolBar(gtk.Toolbar, vtrace.Notifier):
    def __init__(self, trace):
        gtk.Toolbar.__init__(self)
        vtrace.Notifier.__init__(self)
        self.trace = trace
        self.battach = gtk.ToolButton(gtk.STOCK_ADD)
        self.bdetach = gtk.ToolButton(gtk.STOCK_REMOVE)
        self.bcontin = gtk.ToolButton(gtk.STOCK_MEDIA_PLAY)
        self.bbreak  = gtk.ToolButton(gtk.STOCK_MEDIA_PAUSE)
        self.bstep   = gtk.ToolButton(gtk.STOCK_GO_FORWARD)
        #self.bstepo  = gtk.ToolButton(gtk.STOCK_GOTO_LAST)

        self.battach.connect("clicked", self.attach)
        self.battach.set_property("label", "Attach")
        self.bdetach.connect("clicked", self.detach)
        self.bdetach.set_property("label", "Detach")
        self.bcontin.connect("clicked", self.tcontinue)
        self.bcontin.set_property("label", "Continue")
        self.bbreak.connect("clicked", self.tbreak)
        self.bbreak.set_property("label", "Break")
        self.bstep.connect("clicked", self.tstep)
        self.bstep.set_property("label", "Step")
        #self.bstepo.connect("clicked", self.tstep)
        #self.bstepo.set_property("label", "Step Over")

        self.insert(self.battach, -1)
        self.insert(self.bdetach, -1)
        self.insert(self.bcontin, -1)
        self.insert(self.bbreak,  -1)
        self.insert(self.bstep,  -1)

        self.wantsnotattached = [self.battach,]
        self.wantsrunning = [self.bbreak,]
        self.wantsnotrunning = [self.bdetach,self.bcontin, self.bstep]

        trace.registerNotifier(vtrace.NOTIFY_ALL, self)

        self.updateButtons(trace.isAttached(), trace.isRunning())

        self.activateList(self.wantsrunning, True)
        self.activateList(self.wantsnotrunning, True)
        self.activateList(self.wantsnotattached, True)

    @idlethread
    def updateButtons(self, attached, running):
        self.activateList(self.wantsnotattached, not attached)
        if attached:
            self.activateList(self.wantsrunning, running)
            self.activateList(self.wantsnotrunning, not running)
        else:
            self.activateList(self.wantsrunning, False)
            self.activateList(self.wantsnotrunning, False)
            
    def activateList(self, objs, sens):
        for o in objs:
            o.set_sensitive(sens)

    @firethread
    def tstep(self, button):
        self.trace.stepi()

    @firethread
    def tbreak(self, button):
        if self.trace.getMeta('PendingBreak'):
            return
        self.trace.setMeta('PendingBreak', True)
        self.trace.sendBreak()

    @firethread
    def tcontinue(self, button):
        self.trace.run()

    def attach(self, button):
        dia = SelectProcessDialog(self.trace)
        pid = dia.selectProcess()
        if pid != None:
            self._doattach(pid)

    @firethread
    def _doattach(self, pid):
        self.trace.attach(pid)

    @firethread
    def detach(self, button):
        if self.trace.isAttached():
            self.trace.detach()

    def notify(self, event, trace):
        if event == vtrace.NOTIFY_DETACH:
            self.updateButtons(False, False)

        elif event == vtrace.NOTIFY_CONTINUE:
            self.updateButtons(True, True)

        else:
            self.updateButtons(trace.isAttached(), trace.shouldRunAgain())

class MemoryMapView(VtraceView, vw_views.VTreeView):
    __cols__ = (
        (None, 0, int),
        ("Base", 1, str),
        ("Size", 2, int),
        ("Perms", 3, str),
        ("File", 4, str),
    )

    def __init__(self, trace):
        VtraceView.__init__(self, trace)
        vw_views.VTreeView.__init__(self)

    def vwLoad(self):
        if self.traceIsReady():
            self.vwClear()
            maps = self.trace.getMemoryMaps()
            for base,size,perms,fname in maps:
                pname = e_mem.reprPerms(perms)
                self.model.append((base, "0x%.8x" % base, size, pname, fname))

class FileDescView(VtraceView, vw_views.VTreeView):
    __cols__ = (
        (None, 0, object),
        ("Fd", 1, str),
        ("Type", 2, int),
        ("Name", 3, str),
    )

    def __init__(self, trace):
        VtraceView.__init__(self, trace)
        vw_views.VTreeView.__init__(self)

    def vwLoad(self):
        if self.traceIsReady():
            self.vwClear()
            for fd,fdtype,bestname in self.trace.getFds():
                self.model.append((None, fd, fdtype, bestname))


########NEW FILE########
__FILENAME__ = windows

import gtk
import gtk.glade

import envi.cli as e_cli

import vwidget.layout as vw_layout
import vwidget.menubuilder as vw_menu
import vwidget.memview as vw_memview

from envi.threads import firethread
from vwidget.main import idlethread

class MainWindow(vw_layout.LayoutWindow):
    """
    A nice main text window with a CLI input and history etc...
    """
    def __init__(self, cli, memobj, syms=None):
        vw_layout.LayoutWindow.__init__(self)
        self.cli = cli
        self.connect("key-press-event", self.keypressed)

        self.vbox = gtk.VBox()
        self.menubar = vw_menu.MenuBar()

        self.add(self.vbox)
        self.vbox.pack_start(self.menubar, expand=False)
        toolbar = self.getMainToolbar()
        if toolbar != None:
            self.vbox.pack_start(toolbar, expand=False)

        self.canvas = vw_memview.ScrolledMemoryView(memobj, syms=syms)
        self.canvas.textview.set_property("wrap_mode", gtk.WRAP_WORD)
        self.vbox.pack_start(self.canvas, expand=True)

        # If it's an EnviCli, let's over-ride the canvas right away.
        if isinstance(cli, e_cli.EnviCli):
            cli.setCanvas(self.canvas)

        entry = gtk.Entry()
        entry.connect("activate", self.cli_activate)
        entry.connect("key-press-event", self.entrykeypressed)
        self.vbox.pack_start(entry, expand=False)
        self.entry = entry

        self.history = []
        self.histidx = 0
        entry.grab_focus()

    @idlethread
    def _sensitive_entry(self, sensitive):
        # For the fired thread
        self.entry.set_sensitive(sensitive)
        if sensitive:
            self.entry.grab_focus()

    def getMainToolbar(self):
        return None

    def useHistory(self, entry, delta):
        if delta < 0 and self.histidx == 0:
            return

        if delta > 0 and len(self.history) <= self.histidx+delta:
            self.histidx = len(self.history)
            entry.set_text("")
            return

        self.histidx += delta
        htext = self.history[self.histidx]
        entry.set_text(htext)
        entry.set_position(-1)

    def entrykeypressed(self, entry, event):
        if event.keyval == 65362:
            self.useHistory(entry, -1)
            return True
        elif event.keyval == 65364:
            self.useHistory(entry, 1)
            return True
        return False

    @firethread
    def onecmd(self, cmd):
        '''
        Issue a single command with proper history tracking etc...
        (fires a thread to do it...)
        '''
        self._sensitive_entry(False)
        try:
            cmd = self.cli.precmd(cmd)
            self.canvas.write("%s %s\n" % (self.cli.prompt,cmd))
            self.cli.onecmd(cmd)
            self.addHistory(cmd)
        finally:
            self._sensitive_entry(True)

    def keypressed(self, window, event):
        fkbase = 65469
        fkey = event.keyval - fkbase
        if fkey >= 1 and fkey < 13:
            self.onecmd("<f%d>" % fkey)

        elif event.keyval == 65299:
            self.onecmd("break")

    def addHistory(self, histcmd):
        self.history.append(histcmd)
        self.histidx = len(self.history)

    def cli_activate(self, entry):
        cmd = entry.get_text()
        entry.set_text("")
        self.onecmd(cmd)

#FIXME is anything even using this one still?
class VWindow:
    """
    A class for all vdb/vivisect windows to inherit from.  Full of
    little utilities that make GUI writing slightly less painful.

    When inheriting from this class, you *must* make your classname
    the same as the top level window object in your glade project.
    """

    def __init__(self, fname, layout):
        self.glade = gtk.glade.XML(fname)
        self.glade.signal_autoconnect(self)
        self.getWidget(self.__class__.__name__).connect("delete_event", self.delete)
        self.notebook_groups = {}
        self.vwlayout = layout

    def delete(self, window, event):
        print "ENDING GEOM:",repr(self.getGeometry())
        return False

    def getGeometry(self):
        """
        Returns a tuple of (x, y, xsize, ysize) for later use in setGeometry()
        """
        win = self.getWidget(self.__class__.__name__)
        x, y = win.get_position()
        xsize, ysize = win.get_size()
        return (x, y, xsize, ysize)

    def setGeometry(self, geom):
        win = self.getWidget(self.__class__.__name__)
        win.move(geom[0], geom[1])
        win.resize(geom[2], geom[3])

    def setTitle(self, title):
        widget = self.getWidget(self.__class__.__name__)
        if widget:
            widget.set_title(title)

    def setSensitive(self, widgetname, sensitive):
        wid = self.getWidget(widgetname)
        wid.set_sensitive(sensitive)

    def textFromWidget(self, wName):
        wid = self.glade.get_widget(wName)
        if not wid:
            raise Exception("ERROR - Can't find widget %s" % wName)
        return wid.get_text()

    def getWidget(self, name):
        return self.glade.get_widget(name)

    def show(self):
        self.getWidget(self.__class__.__name__).show()

    def hide(self):
        self.getWidget(self.__class__.__name__).hide()


########NEW FILE########
__FILENAME__ = fauxida
#!/usr/bin/env python
#
#
import os
import sys
import socket
import struct
import binascii
import toolbagcomm
from multiprocessing import Process

def waitfordata(host):
    while 1:
        print "+ waiting for data..."
        data = host.recv()
        pkt = toolbagcomm.ToolbagPacket(data)
        print "+ %s:%i[%s] sent us %s %s" % (pkt.ip, pkt.port, pkt.key, pkt.opcode, pkt.filename)

# main function
if __name__ == "__main__":
    argc = len(sys.argv)

    ip = sys.argv[1]
    port = sys.argv[2]
    key = sys.argv[3]

    host = toolbagcomm.ToolbagHost(None, "server.py", ip, port, key)
    p = Process(target=waitfordata, args=(host,))
    p.start() 

    print "+ add agent as ip.ip.ip.ip port key"
    print "+ add agent> "
    
    agentinput = sys.stdin.readline().split()
    agentip = agentinput[0]
    agentport = agentinput[1]
    agentkey = agentinput[2]
    host.addAgent(agentip, agentport, agentkey)
    
    # exit
    sys.exit(0)

########NEW FILE########
__FILENAME__ = server
# server.py
#
# for public release, 2012
#
# Brandon Edwards



# Standard Libraries
import os
import sys
import time
import socket
import signal
import struct
import binascii

#
import toolbagcomm


# we had a promise made 
def usage(s):
    print "+ usage %s <ip> <port> <key>" % s

# main function
if __name__ == "__main__":

    argc = len(sys.argv)

    ip = sys.argv[1] 
    port = int(sys.argv[2])
    key = sys.argv[3]

#    sys.stdout = open("c:\\log2.txt", "w")
#    sys.stderr = sys.stdout

    print "[*] Setting up Toolbag Queue Server"
    myserv = toolbagcomm.QueueServer(ip, port, key)
        

########NEW FILE########
__FILENAME__ = agentmanager
#!/usr/bin/env python
# 
#
from multiprocessing.managers import BaseManager

class Illusion:
    def __init__(self, name, agent):
        self.name = name
        self.agent = agent
        self.localattrs = dict()

    def __getattr__(self, item):
#        print "illusion __getattr__ %s" % item
        thetype = self.agent.get(self.name, item)._getvalue()
#        print "the type: %s" % thetype
        accepted = list()
        accepted.append("<type 'instancemethod'>")
        accepted.append("<type 'classobj'>")
        accepted.append("<type 'function'>")
        fullname=self.name+"_"+item

        if thetype in accepted:
#            print "found accepted type..."
            AgentManager.register(str(fullname))
            return getattr(self.agent, fullname)

        else:
#            print "returning an illusion"
            return Illusion(fullname, self.agent)
        
# AganetBase: extends BaseManager 
# this is test out using disconnect with the built-in connect
# the idea is to avoid connection timeouts, and instead of 
# changing the default timeout value, to just connect/disconnect
# before/after each use of the networked manager
class AgentManager(BaseManager):
    def __init__(self, address, authkey):
        BaseManager.__init__(self, address, authkey)
        self.agentData = address[0], address[1], authkey

        self.srvAddr = address
        self.srvKey = authkey

        # remoteTask is task object remotely instantiated in the agent
        self.remoteTask = None

        # toolbagTask is toolbag's local copy
        self.toolbagTask = None

        AgentManager.register("get")
        AgentManager.register("load")
        AgentManager.register("readFile")
        AgentManager.register("writeFile")
        AgentManager.register("printmsg")

        self.localattrs = dict()

    # USE THIS FROM TOOLBAG, NOT AGENT.LOAD
    def loadmodule(self, modulename):
        print "[*] loading module %s" % modulename
        self.load(modulename)
        self.localattrs[modulename] = Illusion(modulename, self)

    def addTask(self, task):
        self.task = task
        
    def __getattr__(self, item):
        if item in self.localattrs.keys():
            return self.localattrs[item]

    # disconnect
    def disconnect(self):
        # this is sort of ghetto..
        # pulls the _Client sd to call close on
        # not sure if this works...
        conn = self._Client(self.srvAddr, self.srvKey)
        conn.close()


########NEW FILE########
__FILENAME__ = ToolbagTask
# ToolbagTask.py
#
# for public release, 2012
#
# Brandon Edwards


import os
import sys
import socket
import struct
import binascii
import toolbagcomm

#  
# ToolbagTask Class
# this is used by both the server and agent
# A task is created by deriving from this class
# please see Agent and Server documentation below

# For Agents:
# this class should be derived and have the run() method overridden 
# the run method should call sendResults (if/)when results are available
# once complete run should return

# For Server:
# a file containing the derived class is sent to the agent as a PYFILE opcode
# the agent will execute the run() method (which should always call sendResults)
# Upon receiving the results, processing/handling of the results is done with
# process()

# 
class ToolbagTask:
    # agentdata is our data as a tuple (ip, port, key)
    def __init__(self, fname, agentdata, serverdata):
        self.fname = fname
        self.agentdata = agentdata
        self.serverdata = serverdata
        #self.agentdata = agentdata
        #ToolbagTask.ToolbagTask.__init__(self, agentdata, serverdata)

    # process()
    # process the results: this called by the toolbag server on the results
    # received in the queue from the agent (opcode: AGENTRESULTS)
    #
    # results are passed in from the msg from the packet received for RESULTS
    def process(self, results=None):
        if results == None:
            pass

    # sendResults()
    # this sends results back to the server: called by the agentside task
    #
    # results are the results
    # this sends results back to the server
    # with opcode being "agentresults" 
    # and filename echoing the task(file)name we were issued
    # 
    def sendResults(self, results):
        # subscribe to the server queue
        serverqueue = toolbagcomm.QueueClient(self.pkt.ip, self.pkt.port, self.pkt.key) 

        # build the packet
        packet = toolbagcomm.ToolbagPacket()

        # build out the header pieces
        packet.setPiece(ip=self.agentdata[0], port=self.agentdata[1], key=self.agentdata[2])

        resultsfilename = self.pkt.filename.split()[0] + ".results"
        packet.setPiece(opcode="agentresults", filename=resultsfilename)

        # add the results
        packet.setPiece(msg=results)

        # get the packet data
        rawpacket = packet.getPacket()
         
        # send it to the server 
        serverqueue.send(rawpacket)

        # done
        return

    # run()
    #
    def run(self):
        pass
        # send results to server
        # self.sendResults()
        return

    # this is preparation blah FIXME
    def prep(self):
        pass
########NEW FILE########
__FILENAME__ = analysis
# analysis.py
#
# for public release, 2012
#
# Kelly Lum

import idautils
import idaapi
import idc

class properties():

	def __init__(self, addr):
		self.addr = addr

	def funcProps(self): #build a dictionary using all the functions we've got
		props = {}
		props['isLeaf'] 	 = self.isLeaf()		
		props['numArgs'] 	 = self.argCount()
		props['xrefsTo'] 	 = self.countXrefsTo()
		props['isExport'] 	 = self.isExport()
		props['funcSize'] 	 = self.functionSize()	
		props['hasCookie'] 	 = self.hasCookie()	
		props['xrefsFrom'] 	 = self.countXrefsFrom()
		props['numBlocks'] 	 = self.countBlocks()
		props['numChunks'] 	 = self.countChunks()
		props['isRecursive'] = self.isRecursive()
		
		return props

	# needs some finesse, but... it's a steak...
	def hasCookie(self):
		end   = idc.GetFunctionAttr(self.addr, idc.FUNCATTR_END)
		start = idc.GetFunctionAttr(self.addr, idc.FUNCATTR_START)

		count = 0
		while((start != end) and (start != idc.BADADDR)):
			line = idc.GetDisasm(start)
			if line.startswith('xor'):
				if 'ebp' in line: 
					return True
			start = idc.NextAddr(start)
			count += 1
			# security cookie check is usually at beginning of function (unless some crazy-ass prologue)
			if (count > 20): return False
		return False


	def argCount(self): 
		end       = idc.GetFunctionAttr(self.addr, idc.FUNCATTR_END)
		start     = idc.GetFunctionAttr(self.addr, idc.FUNCATTR_START)
		frame     = idc.GetFrame(start)
		localv    = idc.GetFunctionAttr(self.addr, idc.FUNCATTR_FRSIZE)	
		frameSize = idc.GetFrameSize(start) #idc.GetStrucSize(frame)


		reg_off = 0
		local_count = 0
		arg_count = 0
		sid = idc.GetFrame(self.addr)
		if sid:
			firstM = idc.GetFirstMember(sid)
			lastM = idc.GetLastMember(sid)
			arg_count = 0

			if lastM - firstM > 0x1000:
				return
			if lastM >= 4294967295 or firstM >= 4294967295:
				return

			for i in xrange(firstM, lastM):
				mName = idc.GetMemberName(sid, i)
				mSize = idc.GetMemberSize(sid, i)
				mFlag = idc.GetMemberFlag(sid, i)
				off = idc.GetMemberOffset(sid, mName)
				#print "%s: %d, %x, off=%x" % (mName, mSize, mFlag, off)

				if mName == " r":
					reg_off = off

			# XXX: just store the data, dont loop twice.
			for i in xrange(firstM, lastM):
				mName = idc.GetMemberName(sid, i)
				mSize = idc.GetMemberSize(sid, i)
				mFlag = idc.GetMemberFlag(sid, i)
				off = idc.GetMemberOffset(sid, mName)

				if off <= reg_off:
					local_count += 1
				elif off > reg_off and reg_off != 0:
					arg_count += 1


			if arg_count > 0:
				return arg_count / 4
			elif arg_count == 0:
				return 0

		# offset to return
		try: 
			ret = idc.GetMemberOffset(frame, " r") 
		except:
			if frameSize > localv:
				return (frameSize - localv) / 4
			# error getting function frame (or none exists)
			return -1 
 
		if (ret < 0): 
			if frameSize > localv:
				return (frameSize - localv) / 4
			return -1 

		firstArg = ret + 4 
		args  = frameSize - firstArg	
		numArgs = args / 4

		return numArgs

	def functionSize(self):
		return idc.GetFunctionAttr(self.addr, idc.FUNCATTR_END) - idc.GetFunctionAttr(self.addr, idc.FUNCATTR_START)

	def isExport(self):
		entries = idautils.Entries()

		for entry in entries:
			if self.addr in entry: return True
			
	 	return False

	def isLeaf(self):
		if (self.countXrefsFrom() == 0):	return True
		return False

	def isRecursive(self):
		return (self.addr in list(idautils.XrefsFrom(self.addr)))

	def countBlocks(self):
		try:
			res = len(list(idaapi.FlowChart(idaapi.get_func(self.addr))))
			return res
		except:
			return 0

	def countXrefsTo(self):
		return len(list(idautils.XrefsFrom(self.addr)))

	def countXrefsFrom(self):
		return len(list(idautils.XrefsTo(self.addr)))

	def countChunks(self): 
		return len(list(idautils.Chunks(self.addr)))

class search():
	def __init__(self, engine):
		#engine is a user-provided function that performs matching
		self.engine = engine  

	def matches(self, func_data):
		#return a subset of func_data that satisfies the matching engine
		matches = {}
		for func, func_info in func_data.iteritems():
			if func_info['attr']:
				exec(self.engine)
				res = myengine(func_info['attr'])
				if res: 
					matches[func] = func_info
		return matches	

		







########NEW FILE########
__FILENAME__ = config
# config.py
#
# for public release, 2012
#
# Aaron Portnoy

import os

import idc
import idaapi

user = False
try:
    import userconfig
    user = True
except Exception as detail:
    print '[!] Failed to load userconfig.py. Resorting to default toolbag options, %s' % detail


# for colors, see: # http://www.w3.org/TR/SVG/types.html#ColorKeywords
options = { 
                # Supported options: disk (remote only in private release)
                'db_location'            : 'disk',

                # python
                'pypath_win32'           : 'C:\\Python26\\python.exe',
                # XXX: not tested
                'pypath_linux'           : '/usr/bin/env python',

                # default tabs enabled
                'enabled_tabs'           : ["File System", "Pathfinding", "Scripts"],

                # local comments or marks
                # valid values: 'marks' or 'comments'
                'localview'              : 'comments',

                # show splash boolean
                'show_splash'            : True,

                # architecture
                'architecture'           : (lambda: idc.__EA64__ and "64" or "32")(),

                # filesystem options
                # valid options are 'netnode' or 'segment'
                'file_system_type'       : 'netnode',
                'netnode_num'            : 0xBEEFFACE,

                'segment_size'           : 0x200000,
                'segment_name'           : '.zip',
                'file_name'              : idaapi.get_root_filename()[:-4] + ".DB",
                'full_file_name'         : (lambda x: "." in x and x.split(".")[0] + ".DB" or x + ".DB")(idaapi.get_root_filename()),
    
                'ida_user_dir'           : idaapi.get_user_idadir(),
                'user_scripts_dir'       : idaapi.get_user_idadir() + os.sep + "user" + os.sep + "bin",
                'vtrace_scripts_dir'     : idaapi.get_user_idadir() + os.sep + "user" + os.sep + "bin" + os.sep + "vtrace",
                'toolbag_dir'            : idaapi.get_user_idadir() + os.sep + "toolbag",
                    
                # hotkeys     
                'history_hotkey'         : 'Ctrl-Space',
                'undo_history'           : 'Ctrl-Z', 
                'create_mark_hotkey'     : 'Alt-M',
                'jump_mark_hotkey'       : 'Ctrl-M',
                'path_start'             : 'Ctrl-S',
                'path_end'               : 'Ctrl-E', 
                'add_edge_src'           : 'Ctrl-[',
                'add_edge_dst'           : 'Ctrl-]',

                # these two are currently deprecated, ScreenEA() is used
                'bb_path_start'          : 'Ctrl-Shift-S',
                'bb_path_end'            : 'Ctrl-Shift-E',
                    
                # aesthetics    
                'font_name'              : 'Courier',
                'font_size'              : 8,
                'font_color'             : 'black',
                'background_color'       : 'gainsboro',

                # for use with the 'Query DB' searching functionality
                'highlighted_background' : 'darkgreen',
                'highlighted_foreground' : 'white',
    
                # IDA only accepts RGB values
                'history_color'          : 0x005500,
                'coloring_enabled'       : False,
    
                # path finding colors (RGB again)  
                'path_coloring_enabled'  : False,
                'func_path_color'        : 0xFF00FF,
                'bb_path_color'          : 0x0000FF,
    
                'editor'                 : 'C:\\windows\\system32\\notepad.exe',
                #'editor'                : '/usr/bin/vim'

                # not currently used
                'remote_host'            : '192.168.1.100',

                # milliseconds to poll queue
                'queue_interval'         : 1500,

                # queue_interval * this = how often you'll get reminded about pending data
                'queue_reminder'         : 6,
    
                # dev-mode    
                'dev_mode'               : False,

                # 1,2,3
                'verbosity'              : 2
          }
    


if user == True: 
    try:
        for k,v in userconfig.options.iteritems():
            options[k] = v
    except AttributeError as detail:
        print '[!] Error overriding global options with userconfig options, %s' % detail

########NEW FILE########
__FILENAME__ = fs
# fs.py
#
# for public release, 2012
#
# Aaron Portnoy

# Standard Libraries
import sys
import copy
from zipfile import *
from StringIO import StringIO

# IDA
import idaapi
import idautils

#
import segment

# IDA provider
from providers import ida

class FS:
    '''
    File system object
        - default size of ~2MB
    '''

    def __init__(self, options):
        self.segname = options['segment_name']
        self.size    = options['segment_size'] 
        self.provider = ida.IDA()
        self.memhandle = StringIO()

        done = False
        # (name, start, end)
        segs = segment.getSegsInfo()
        for s in segs:

            # if our segment is already present, use it
            if self.segname == s[0]:
                print "[*] fs.py: found an existing segment, using it."

                # start address
                self.addr = s[1]

                eof = self.get_eof()

                if eof == 0:
                    done = True
                    break

                # the EOF is the first 4 bytes
                # seek to the actual data
                ea = self.addr + 4

                # get the data
                bytes = ""
                for i in xrange(0, eof):
                    bytes += chr(self.provider.getByte(ea))
                    ea += 1

                
                self.memhandle.write(bytes)
                self.memhandle.seek(0)

                # save the new size
                self.EOF = len(bytes)
                self.save_eof()
                done = True
                break

        # otherwise, make a new one
        if done == False:
            print "[*] fs.py: didn't find an existing segment, making a new one."
            self.addr = segment.alloc(self.size, self.segname)
            self.EOF = 0
            self.save_eof()
            

        zipfs = ZipFile(self.memhandle, mode='w')
        zipfs.close()
        self.memhandle.seek(0)


    def list_files(self):
        zipfs = ZipFile(self.memhandle, mode='r')
        names = zipfs.namelist()
        zipfs.close()

        return names


    def get_fh(self):
        fh = StringIO()

        return fh

    def store_fh(self, fh, name):
        fh.seek(0)
        self.store(name, fh.read())
        
        return True
    

    def get_current_size(self):
        '''Returns the amount of bytes currently stored in the fs segment'''
        size = 0
        ea = self.addr

        return self.get_eof()


    def store(self, k, v):
        '''Stores a file (named k) with value (v) in the segment. Directory paths are allowed.'''

        try:
            names = self.list_files()
        except BadZipfile:
            names = []
            pass

        if k in names:
            print '[!] fs.py: Found file with name %s, replacing it as requested' % k 
            self.delete(k)

        zipfs = ZipFile(self.memhandle, mode='a')

        current_size = self.get_current_size()
        len_data = len(v)

        total_size = current_size + len_data
        
        # need to check if our current segment can contain total_size

        our_seg = self.provider.segByName(self.segname)

        # this is because IDA doesnt delete segments properly (selectors are gay)
        segs = list(self.provider.getSegments())
        for s in segs:
            name = self.provider.segName(s)
            if name == self.segname:
                our_seg = s
                break

        if our_seg == 0xFFFFFFFF:
            raise SyntaxError("Hrm, segment is BADADDR")

        our_seg_size = self.provider.segEnd(our_seg) - self.provider.segStart(our_seg)

        if total_size > our_seg_size:
            raise
            # we need to resize our segment
            new_seg = segment.realloc(our_seg, total_size)
            self.addr = new_seg
        
        print '[*] Adding file %s to keystore (len:%d)' % (k, len(v))
        zipfs.writestr(k, v)
        zipfs.close()
        self.memhandle.seek(0)
        self.commit()

        return True


    def load(self, k):
        '''Retrieves the contents of a file (named k) from the segment file system.'''
        try:
            zipfs = ZipFile(self.memhandle, mode='r')
        except:
            return False

        try:
            zfile = zipfs.open(k)
            res = zfile.read()
        except KeyError:
            #print "[!] File with name '%s' does not exist in the keystore." % k
            return False

        self.memhandle.seek(0)

        return res


    def delete(self, k):
        tmphandle = StringIO()
        try:
            zin = ZipFile(self.memhandle, mode='r')
        except:
            print self.memhandle.read()

        zout = ZipFile(tmphandle, mode='w')

        deleted = False
        for item in zin.infolist():
            if item.filename != k:
                buffer = zin.read(item.filename)
                zout.writestr(item, buffer)
            else:
                print "[*] Deleting file '%s' from keystore." % k
                deleted = True

        if deleted == False:
            print "[*] File '%s' does not exist within keystore." % k
        
        zin.close()
        zout.close()    
        self.memhandle = copy.deepcopy(tmphandle)
        self.memhandle.seek(0)
        self.commit()


    def save_eof(self):
        #print "[*] Saving EOF at address 0x%08x" % self.addr
        ea = self.addr
        self.provider.patchDword(ea, self.EOF)

        return


    def get_eof(self):
        ea = self.addr

        return self.provider.getDword(ea)


    def commit(self):
        '''Commits any changes made to the in-memory buffer to the segment. This is automatically invoked on any store() or delete() operation.'''
        bytes = self.memhandle.read()
        self.memhandle.seek(0)

        ea = self.addr

        # write the EOF
        self.EOF = len(bytes)
        self.save_eof()

        ea = ea+4

        for byte in bytes:
            self.provider.patchByte(ea, ord(byte))
            ea = ea + 1


    def gimme_zip(self):
        '''This is a utility function for testing purposes. It returns all the data currently stored in the segment (it should be a zip file)'''
        eof = self.get_eof()
        self.memhandle.seek(0)

        res = ""

        # seek past EOF
        ea = self.addr+4

        for i in xrange(0, eof):
            res += chr(self.provider.getByte(ea))
            ea = ea + 1

        return res
########NEW FILE########
__FILENAME__ = fs_nn
# fs.py
#
# for public release, 2012
#
# Aaron Portnoy

# Standard Libraries
import sys
import copy
import pickle
from zipfile import *
from StringIO import StringIO

# IDA
import idc
import idaapi
import idautils

#
import segment


class FS:
    '''
    File system object

    I'm pretty sure I'm not using netnodes the proper way. 
    I'm pretty sure I'm limited to 255 files because of this.

    I'll read the hpp sometime...
    '''

    def __init__(self, options):
        # self.files is a dict() mapping {filename: tag}
        self.num = options['netnode_num']
        self.nnode = idaapi.netnode(self.num)

        # check if we already have an existing files dict() defined
        if self.nnode.getblob(0, "\x01"):
            # if we do, set self.files to it
            self.files = pickle.loads(self.nnode.getblob(0, "\x01"))            
        else:
            # otherwise set it to a dict containing just the \x01 tag reserved
            self.files = {"__internal__" : "\x01"}
            self.nnode.setblob(pickle.dumps(self.files), 0, "\x01")

        self.used = self.files.values()

        return


    def list_files(self):
        files = pickle.loads(self.nnode.getblob(0, "\x01"))
        return files.keys()
        

    def next_index(self):

        possible_vals = []
        for i in xrange(2, 256):
            possible_vals.append(chr(i))

        for x in possible_vals:
            if x not in self.used:
                return x

        raise Exception, "WTFMATE"


    def store(self, k, v):
        '''Stores a file (named k) with value (v) in the netnode.'''

        files = pickle.loads(self.nnode.getblob(0, "\x01"))

        names = files.keys()[1:]

        if k in names:
            print '[!] Found file with name %s, replacing it as requested' % k 
            self.delete(k)

        print '[*] Adding file %s to keystore (len:%d)' % (k, len(v))

        next_idx = self.next_index()
       
        files[k] = next_idx

        self.nnode.setblob(v, 0, next_idx)
        self.used.append(next_idx)
        self.nnode.setblob(pickle.dumps(files), 0, "\x01")

        return True


    def store_fh(self, fh, name):
        fh.seek(0)
        self.store(name, fh.read())

        return True


    def load(self, k):
        '''Retrieves the contents of a file (named k) from the netnodesphere.'''
        
        files = pickle.loads(self.nnode.getblob(0, "\x01"))

        try:
            return self.nnode.getblob(0, files[k])
        except KeyError:
            #print "[!] File with name '%s' does not exist in the netnodesphere." % k
            return False


    def delete(self, k):
        files = pickle.loads(self.nnode.getblob(0, "\x01"))        
        
        idx = files[k]
        
        res = self.nnode.delblob(0, idx)
        
        if res:
            print "[*] Deleting file '%s' from keystore." % k
            del files[k]
            self.nnode.setblob(pickle.dumps(files), 0, "\x01")
        else:
            print "[*] File '%s' does not exist within keystore." % k
        

########NEW FILE########
__FILENAME__ = graphing
# graphing.py
#
# for public release, 2012
#
# Aaron Portnoy
# Peter Vreugdenhil


# IDA
from idc import *
from idaapi import *
from idautils import *

# removed from public release
# networkx
#import networkx as nx

#
import database


# deprecated in favor of Peter's BlockPathGraph
class BBPathFinder(object):
    def __init__(self, start, end, options):
        self.start = start
        self.end = end
        self.options = options


    def get_blocks(self):
        func = idaapi.get_func(self.start)
        b = database.blocks(func.startEA, func.endEA)
        res = set()
        for item in b:
            res.add(item[0])
        
        return list(res)


    def gen_dict(self):
        a = self.get_blocks()

        addrs = set()
        graphygraph = {}
        
        for head in a:

            instr = head
            while True:

                if instr == idaapi.BADADDR:
                    #print "Hit BADADDR, breaking"
                    break

                mnem = GetMnem(instr) 
          
                if mnem.startswith("ret"):
                    #print "Hit return, breaking"
                    graphygraph[head] = []
                    break

                # if jump
                if mnem.startswith("j"):

                    # now we need to get the code references
                    coderefs = list(set(CodeRefsFrom(instr, 1)))

                    if graphygraph.has_key(head):
                        graphygraph[head].extend(coderefs)
                    else:
                        graphygraph[head] = coderefs

                    # break out, get the next basic block head
                    break

                else:
                    instr = idc.NextHead(instr, idaapi.get_func(instr).endEA)

        return graphygraph


    def plot_path(self):
        graph_dict = self.gen_dict()

        G = nx.DiGraph()

        for k, values in graph_dict.iteritems():
            G.add_node(k)
            for v in values:
                G.add_node(v)
                G.add_edge(k,v)

        path = nx.shortest_path(G, self.start, self.end)

        if self.options['path_coloring_enabled']:
            print 'enabled coloring'
            for addy in path:
                idc.SetColor(addy, idc.CIC_ITEM, self.options['bb_path_color'])

        return path
        
########NEW FILE########
__FILENAME__ = pathfinder
# pathfinder.py
#
# for public release, 2012
#
# Peter Vreugdenhil
# Aaron Portnoy


# IDA
import idc
import idaapi
import idautils

#
import function


class FunctionPathFinder(object):    
    def __init__(self, master):

        self.startFunctions = set([])
        self.master = master

        
    def getParents(self, addy):
        return self.master.function_data[addy]['parents']

    def addStartFunction(self, addy):
        self.startFunctions.add(addy)


    def findPaths(self, addy, pathBlocks = set([]), currentPath = set([]), depth = 0, maxdepth = 9999):
        if(addy in self.startFunctions):
            pathBlocks.add(addy)
            return True
        if(depth > maxdepth):
            return False
        FoundPath = False
        for p in self.getParents(addy):
            if(p in pathBlocks):
                pathBlocks.add(addy)
                FoundPath = True
            elif(p in currentPath):
                #Check for looping
                continue
            else:
                p_found = self.findPaths(p, pathBlocks, currentPath | set([p]), depth + 1, maxdepth)
                FoundPath = FoundPath or p_found
        #print 'done looping'
        if(FoundPath):
            pathBlocks.add(addy)
        return FoundPath


class PathGraph(idaapi.GraphViewer):
    def __init__(self, funcname, affected, edges, ui_obj):
        #Lets make sure we dont open the same graph twice. (it can crash IDA ... )
        AlreadyOpenGraph = idaapi.find_tform("call graph of 0x%08x" % funcname)
        
        if(AlreadyOpenGraph != None):
            idaapi.close_tform(AlreadyOpenGraph, 0)
            

        idaapi.GraphViewer.__init__(self, "call graph of 0x%08x" % funcname)

        self.funcname = funcname
        self.affected = affected
        self.edges = edges
        self.f_to_id = {}
        self.id_to_f = {}
        self.ui_obj = ui_obj


    def OnRefresh(self):

        self.Clear()
        self.f_to_id = {}
        self.id_to_f = {}
        for f in self.affected:
            try:
                f_id = self.AddNode(self.getText(f))
            except Exception as detail:
                print detail
            self.f_to_id[f] = f_id
            self.id_to_f[f_id] = f
        for child in self.edges:
            for parent in self.edges[child]:
                self.AddEdge(self.f_to_id[parent], self.f_to_id[child])
        return True


    def OnGetText(self, node_id):
        return self.getText(self.id_to_f[node_id])


    def OnCommand(self, cmd_id):
        """
        Triggered when a menu command is selected through the menu or its hotkey
        @return: None
        """
        if self.cmd_close == cmd_id:
            self.Close()
            return

        elif self.cmd_add_history == cmd_id:
            for func in self.f_to_id.keys():
                self.ui_obj.addToHistory(userEA=func)

            #self.ui_obj.addToHistory(add=False)




        #if self.cmd_generate == cmd_id:
        #    self.caller.generateHTML(self.blocks)
        #if self.cmd_select_all == cmd_id:
        #    self.selectAll()
        #if self.cmd_invert_selection == cmd_id:
        #    self.invertSelection()


    def Show(self):
        if not idaapi.GraphViewer.Show(self):
            return False
        self.cmd_close = self.AddCommand("Close", "F2")
        if self.cmd_close == 0:
            pass

        self.cmd_add_history = self.AddCommand("Add to History", "F4")
        if self.cmd_add_history == 0:
            print "[!] Failed to add popup menu item to basic block graph!"


            #print "Failed to add popup menu item!"
        #self.cmd_generate = self.AddCommand("Generate HTML", "F3")
        #if self.cmd_generate == 0:
        #    print "Failed to add Generate HTML menu item!"
        #self.cmd_select_all = self.AddCommand("Select All", "")
        #if self.cmd_select_all == 0:
        #    print "Failed to add Select All menu item!"
        #self.cmd_invert_selection = self.AddCommand("Invert Selection", "")
        #if self.cmd_invert_selection == 0:
        #    print "Failed to add Invert Selection menu item!"

        return True


    def OnDblClick(self, node_id):
        f_addy = self.id_to_f[node_id]
        #print "Jumping to " + hex(f_addy)
        idc.Jump(f_addy)

    
    def getText(self, addy):
        func = idaapi.get_func(addy)
        if(func):
            FName = idc.GetFunctionName(func.startEA)
            Demangled = None
            color = idc.GetColor(func.startEA, idc.CIC_ITEM)

            if color == 0xFFFFFFFF:
                color = idaapi.SCOLOR_INV
            else:
                color = idaapi.SCOLOR_STRING


            try:
                Demangled = idc.Demangle(FName,8)
            except:
                pass
            if(Demangled):
                FName = Demangled
            return idaapi.COLSTR(" " + FName + " ", color)
            return " " + FName + " "

        return " " + idc.GetDisasm(addy) + " "


###############################################################################

class BlockPathFinder(object):    

    def __init__(self):
        self.function = None
        self.startLocs = {}
        self.parents = {}
        self.blockInfo = {}
        self.loops = {}
        self.children = {}


    def analyseFunction(self, address = None):
        if(address == None):
            address = idc.ScreenEA()
        self.setFunction(address)
        if(not self.function):
            print "I have no idea what function you are talking about"
        self.fillBlockData()
        self.getAllRefs()


    def fillBlockData(self):
        func = idaapi.get_func(self.function)
        flow = idaapi.FlowChart(func)        
        for block in flow:
            self.blockInfo[block.startEA] = {'StartEA' : block.startEA, 'EndEA' : idc.PrevHead(block.endEA, block.startEA), 'OfficialEndEA' : block.endEA}        
        

    def setFunction(self, addy):
        func = idaapi.get_func(addy)
        if(not func):
            return
        self.function = func.startEA
        #for now:
        self.startLocs[self.function] = True


    def getAllRefs(self):
        start = self.function
        if(not start):
            return 
        self.fillParents(start, None, [])


    def fillParents(self, blockID, parent, walked_blocks):
        if(blockID in walked_blocks):
            #print "Found loop from %08x to %08x" % (parent, blockID)
            #We have a loop. Add Loop data + parent, and stop.
            if(not parent in self.loops):
                self.loops[parent] = set([blockID])
            else:
                self.loops[parent].add(blockID)
        else:
            if(blockID in self.parents):
                self.parents[blockID].add(parent)            
            else:
                self.parents[blockID] = set([parent])
            #loop all XRefs from ?
                childeren = self.getChildren(blockID)
                for c in childeren:
                    self.fillParents(c, blockID, walked_blocks + [blockID])   


    def getChildren(self, blockID):
        if(blockID in self.children):
            return self.children[blockID]
        else:
            children = set([])
            for x in idautils.XrefsFrom(self.blockInfo[blockID]['EndEA']):
                if(x.type == 21 or x.type == 19):
                    children.add(x.to)
                else:
                    func_x = idaapi.get_func(x.to)
                    if(func_x and func_x.startEA == self.function):
                        children.add(x.to)
            self.children[blockID] = children
        return self.children[blockID]         


    def getParents(self, addy):
        if(not addy in self.parents):
            return []
        return self.parents[addy]
    

    def findPathBlocks(self, addy, pathBlocks = set([])):
        if addy not in self.blockInfo:
            done = False
            # aaron: XXX, ghetto fix in case their current screen EA isn't at the head of a bb
            try:
                for head,vals in self.blockInfo.iteritems():
                    start_ea = vals['StartEA']
                    end_ea = vals['OfficialEndEA']
                    if addy > start_ea and addy <= end_ea:
                        addy = start_ea
                        done = True
                        break
            except Exception as detail:
                print detail

            if not done:
                print "Given BAD basic block address!"
                return False

        if(addy in self.startLocs):
            pathBlocks.add(addy)
            return True
        FoundPath = False        
        for p in self.getParents(addy):
            if(p in pathBlocks):
                pathBlocks.add(addy)
                FoundPath = True
            else:
                p_found = self.findPathBlocks(p, pathBlocks)
                FoundPath = FoundPath or p_found
        #print 'done looping'
        if(FoundPath):
            pathBlocks.add(addy)
        return FoundPath


class BlockPathGraph(idaapi.GraphViewer):
    def __init__(self, funcname, blocks, edges, blockInfo, options):
        #Lets make sure we dont open the same graph twice. (it can crash IDA ... )     
        self.options = options   
        
        AlreadyOpenGraph = idaapi.find_tform("basic block graph to " + funcname)
        if(AlreadyOpenGraph != None):
            idaapi.close_tform(AlreadyOpenGraph, 0)
        
        idaapi.GraphViewer.__init__(self, "basic block graph to " + funcname)
        self.funcname = funcname
        self.blocks = blocks
        self.blockInfo = blockInfo
        self.edges = edges
        self.block_to_id = {}
        self.id_to_block = {}


    def OnRefresh(self):
        self.Clear()
        self.block_to_id = {}
        self.id_to_block = {}
        #print 'onrefresh: self.blocks is %s' % repr(self.blocks)
        for block in self.blocks:
            try:
                b_id = self.AddNode(self.getText(block))
            except Exception as detail:
                print detail
            self.block_to_id[block] = b_id
            self.id_to_block[b_id] = block
        for parent in self.edges:
            for child in self.edges[parent]:
                self.AddEdge(self.block_to_id[parent], self.block_to_id[child])
        return True


    def OnGetText(self, node_id):
        return self.getText(self.id_to_block[node_id])


    def getBounds(self, ea):
        for head, vals in self.blockInfo.iteritems():
            start_ea = vals['StartEA']
            end_ea = vals['EndEA']
            if ea >= start_ea and ea <= end_ea:
                if ea == end_ea:
                    return (start_ea, end_ea)
                else:
                    # ghetto, but idautils.Heads skips the branch
                    proper_end = idc.NextHead(end_ea, end_ea+0x10)
                    return (start_ea, proper_end)

    def OnCommand(self, cmd_id):
        """
        Triggered when a menu command is selected through the menu or its hotkey
        @return: None
        """
        #print "command:", cmd_id
        if self.cmd_close == cmd_id:
            self.Close()
            return
        elif self.cmd_color == cmd_id:

            func_item = idaapi.get_func(idc.ScreenEA())


            # get the default color
            idc.Jump(func_item.startEA)
            idautils.ProcessUiActions("GraphDefaultColor", 0)            
            defaultcolor = idc.GetColor(func_item.startEA, idc.CIC_ITEM)

            # reset colors to default
            idc.SetColor(func_item.startEA, idc.CIC_FUNC, defaultcolor)

            # RGB
            for block in self.blocks:
                start,end = self.getBounds(block)
               # color all basic blocks
                for head in idautils.Heads(start, end):
                    idc.SetColor(head, idc.CIC_ITEM, self.options['bb_path_color'])

                #branch_insn = idc.NextHead(end, func_item.endEA)
                #print "branch instruction is at 0x%08x" % branch_insn
                #idc.SetColor(branch_insn, idc.CIC_ITEM, self.options['bb_path_color'])
            
        idaapi.refresh_idaview_anyway()
        
        #if self.cmd_generate == cmd_id:
        #    self.caller.generateHTML(self.blocks)
        #if self.cmd_select_all == cmd_id:
        #    self.selectAll()
        #if self.cmd_invert_selection == cmd_id:
        #    self.invertSelection()


    def Show(self):
        if not idaapi.GraphViewer.Show(self):
            return False
        self.cmd_close = self.AddCommand("Close", "F2")
        if self.cmd_close == 0:
            print "Failed to add popup menu to basic block graph!"


        self.cmd_color = self.AddCommand("Color", "F3")
        if self.cmd_color == 0:
            print "[!] Failed to add popup menu item to basic block graph!"
        #self.cmd_generate = self.AddCommand("Generate HTML", "F3")
        #if self.cmd_generate == 0:
        #    print "Failed to add Generate HTML menu item!"
        #self.cmd_select_all = self.AddCommand("Select All", "")
        #if self.cmd_select_all == 0:
        #    print "Failed to add Select All menu item!"
        #self.cmd_invert_selection = self.AddCommand("Invert Selection", "")
        #if self.cmd_invert_selection == 0:
        #    print "Failed to add Invert Selection menu item!"

        return True
        

    def OnDblClick(self, node_id):
        f_addy = self.id_to_block[node_id]
        #print "Jumping to " + hex(f_addy)
        idc.Jump(f_addy)

    
    def getText(self, addy):
        #print "Fetching text for %08x" % addy
        color = idaapi.SCOLOR_STRING

        if addy == function.top(addy):
            name = idc.NameEx(addy, addy)
            try:
                name = idc.Demangle(name, idc.GetLongPrm(idc.INF_SHORT_DN))
            except:
                pass
        else:
            name = idc.NameEx(addy, addy)

        if name:
            return idaapi.COLSTR(" %s " % name, color)
        else:
            return idaapi.COLSTR(" 0x%08x " % addy, color)
            

########NEW FILE########
__FILENAME__ = base
# base.py
#
# for public release, 2012
#
# Aaron Portnoy

class Driver(object):
    def currentEA(self):
        raise NotImplementedError

    def getComment(self, ea, **kwargs):
        raise NotImplementedError

    def getRptComment(self, ea, **kwargs):
        raise NotImplementedError        

    def makeComment(self, ea, comment, **kwargs):
        raise NotImplementedError

    def makeRptComment(self, ea, comment, **kwargs):
        raise NotImplementedError

    def getDisasm(self, ea, **kwargs):
        raise NotImplementedError

    def addHotkey(self, key, handler, **kwargs):
        raise NotImplementedError

    def demangleName(self, ea, **kwargs):
        raise NotImplementedError

    # XXX: not even sure what this should be called, just wrapping it
    def getLongPrm(self, type, **kwargs):
        raise NotImplementedError

    def setColor(self, ea, color, **kwargs):
        raise NotImplementedError

    def getName(self, ea, **kwargs):
        raise NotImplementedError

    def iterInstructions(self, start, end, **kwargs):
        raise NotImplementedError

    # XXX: idaapi.get_func
    def funcStart(self, ea, **kwargs):
        raise NotImplementedError

    def funcEnd(self, ea, **kwargs):
        raise NotImplementedError








########NEW FILE########
__FILENAME__ = ida
# ida.py
#
# for public release, 2012
#
# Aaron Portnoy

import idc
import idaapi
import idautils

import base

import database
import function


form = idaapi.PluginForm

class IDA(base.Driver):


    # constants
    FUNC_FLAG = idc.FF_FUNC
    UI_Hooks = idaapi.UI_Hooks

    def currentEA(self):
        return idc.ScreenEA()

    def cxUp(self, ea):
        return database.cxup(ea)

    def cxDown(self, ea):
        return database.cxdown(ea)

    def getComment(self, ea):
        res = idc.GetCommentEx(ea, False)
        if not res:
            return ""
        else:
            return res

    def getRptComment(self, ea):
        return idc.GetCommentEx(ea, True)

    def addHotkey(self, key, handler):
        return idc.AddHotkey(key, handler)

    def demangleName(self, name):
        return idc.Demangle(name, idc.GetLongPrm(idc.INF_SHORT_DN))

    def setColor(self, ea, color):
        return idc.SetColor(ea, idc.CIC_ITEM, color)    

    def getName(self, ea):
        return idc.Name(ea)

    def makeComment(self, ea, comment):
        return idc.MakeComm(ea, comment)

    def makeRptComment(self, ea, comment):
        return idc.MakeRptCmt(ea, comment)

    def getDisasm(self, ea):
        return idc.GetDisasm(ea)

    def getMnem(self, ea):
        return idc.GetMnem(ea)

    def iterInstructions(self, start, end):
        return idautils.Heads(start, end)

    def iterData(self, start, end):
        return idautils.Heads(start, end)

    def iterFuncChunks(self, ea):
        start = self.funcStart(ea)
        end   = self.funcEnd(ea)

        if not start or not end:
            return []

        current = idc.FirstFuncFchunk(start)
        chunks  = [current]

        while True:
            next = idc.NextFuncFchunk(start, current)
            
            if next != idc.BADADDR:
                current = next
                chunks.append(next)
            else:
                break

        res = []
        for chunk in chunks:
            chunk_end = idc.GetFchunkAttr(chunk, idc.FUNCATTR_END)
            res.extend(list(self.iterInstructions(chunk, chunk_end)))

        return res

    def funcStart(self, ea):
        try:
            func_item = idaapi.get_func(ea)
            if func_item:
                return func_item.startEA
            else: 
                return None
        except TypeError:
            return None

    def funcEnd(self, ea):
        func_item = idaapi.get_func(ea)
        if func_item:
            return func_item.endEA
        else:
            return None

    def registerTimer(self, interval, obj):
        return idaapi.register_timer(interval, obj)

    def unregisterTimer(self, obj):
        return idaapi.unregister_timer(obj)

    def compile(self, statement):
        return idaapi.CompileLine(statement)

    def segStart(self, ea):
        return idc.SegStart(ea)

    def getArch(self):
        return idaapi.get_idp_name()

    def isCode(self, ea):
        return idc.isCode(ea)

    def getFlags(self, ea):
        return idc.GetFlags(ea)

    def segEnd(self, selector):
        return idc.SegEnd(selector)

    def segByName(self, name):
        return idc.SegByName(name)

    def segByBase(self, selector):
        return idc.SegByBase(selector)

    def segName(self, selector):
        return idc.SegName(selector)

    def getSegments(self):
        return idautils.Segments()

    def nextItem(self, ea, bounds):
        return idc.NextHead(ea, bounds)

    def prevItem(self, ea, bounds):
        return idc.PrevHead(ea, bounds)

    def makeFunc(self, ea):
        return idc.MakeFunction(ea, idc.BADADDR)

    def getByte(self, ea):
        return idc.Byte(ea)

    def getWord(self, ea):
        return idc.Word(ea)

    def getDword(self, ea):
        return idc.Dword(ea)

    def getString(self, ea):
        stype = idc.GetStringType(ea)
        #if idaapi.is_unicode(stype):
        #    res = idc.GetString(ea, )
        return idc.GetString(ea, strtype=stype)

    def patchByte(self, ea, val):
        return idaapi.patch_byte(ea, val)

    def patchDword(self, ea, val):
        return idaapi.patch_long(ea, val)

    def isString(self, reference):
        return idc.isASCII(self.getFlags(reference))

    def refreshView(self):
        idaapi.refresh_idaview_anyway()

    # netnode crap
    def netnode(self, ident):
        return idaapi.netnode(ident)

    def numImports(self):
        return idaapi.get_import_module_qty()

    def importName(self, idx):
        return idaapi.get_import_module_name(idx)

    def basicBlockBoundaries(self, ea):
        func = idaapi.get_func(ea)
        flow = idaapi.FlowChart(func)        
        for block in flow:
            start = block.startEA
            end   = block.endEA

            if (ea < end) and (ea >= start):
                return (start, end)

    def enumImportNames(self, idx, func):
        return idaapi.enum_import_names(idx, func)

    def dataRefs(self, ea):
        return idautils.DataRefsFrom(ea)

    def scriptTimeout(self, timeout):
        return idaapi.set_script_timeout(timeout)

    def jumpto(self, addr):
        return idaapi.jumpto(addr)
########NEW FILE########
__FILENAME__ = RefTree
# RefTree.py
#
# for public release, 2012
#
# Peter Vreugdenhil
# Aaron Portnoy


import database
import analysis

from providers import ida


class RefTree(object):    

    def __init__(self, masterGraph, function_data={}):

        self.provider    = ida.IDA()
        self.masterGraph = masterGraph

        if function_data == {}:
            self.function_data = {}
        else:
            self.function_data = function_data
 

    def xrefs_to(self, addy):
        if self.masterGraph.function_data.has_key(addy):
            return self.masterGraph.function_data[addy]['parents']
        else:
            return []


    def xrefs_from(self, addy):
        if self.masterGraph.function_data.has_key(addy):
            return self.masterGraph.function_data[addy]['children']
        else:
            return []


    def del_func(self, addy):
        try:
            del(self.function_data[addy])
        except Exception as detail:
            print "[!] Failed to delete address 0x%08x from reftree." % addy
        return

    def add_func(self, addy, attrs={}):
        #get some function info
        func = self.provider.funcStart(addy)

        if attrs == {}:
            props = analysis.properties(addy)
            attrs = props.funcProps()

        addy_info = {'attr' : attrs, 'parents' : [], 'children' : []}

        if(not func):
            # probably an import
            #print "[I] Dealing with a likely import (0x%08x) in RefTree.py" % addy 
            pass
        else:
            addy = func

        for p in self.xrefs_to(addy):
            #print "xrefs_to includes 0x%08x" % p
            #Only add parent if parent already in dict
            if p in self.function_data:
                if(not p in addy_info['parents']):
                    addy_info['parents'].append(p)
                if(not addy in self.function_data[p]['children']):
                    self.function_data[p]['children'].append(addy)
            #else:
                #print "p is NOT in our self.function_data"

        for c in self.xrefs_from(addy):

            #Check to see if child is in function_data
            if c in self.function_data:
                #update child info
                if(not addy in self.function_data[c]['parents']):
                    self.function_data[c]['parents'].append(addy)

                if(not c in addy_info['children']):
                    addy_info['children'].append(c)

        if not self.function_data.has_key(addy):
            self.function_data[addy] = addy_info


    def makeTrees(self):
        #First find all root nodes:
        root_nodes = []
        for f, data in self.function_data.iteritems():
            if(len(data['parents']) == 0):
                root_nodes.append(f)
        #Make sure we end up using all available functions:
        all_funcs = set(self.function_data.keys())
        tree = []
        for r in root_nodes:
            tree.append(self.makeTree(r, set([r]), all_funcs))
        while(len(all_funcs) > 0):
            #just pop one and make a tree based on that.
            r = all_funcs.pop()
            tree.append(self.makeTree(r, set([r]), all_funcs))
        return tree

    
    def makeTree(self, addy, path = set([]), all_funcs = set([])):
        children = []
        all_funcs.discard(addy)
        if(addy in self.function_data):
            for c in self.function_data[addy]['children']:
                if(not c in path):
                    children.append(self.makeTree(c, path | set([c]),
               all_funcs))
        return (addy, children)


    def listChildren(self, tree):
        children = set([tree[0]])
        for branch in tree[1]:
            children.update(self.listChildren(branch))
        
        return children

    def addEdge(self, src, dst):
        src_func = self.provider.funcStart(src)

        if not self.function_data.has_key(dst):
            self.provider.makeFunc(dst)
            self.add_func(dst)

        parents = set(self.function_data[dst]['parents'])
        parents.add(src_func)
        self.function_data[dst]['parents'] = list(parents)

        # reftree
        try:
            children = set(self.function_data[src_func]['children'])
        except KeyError:
            self.add_func(src_func)
            children = set(self.function_data[src_func]['children'])

        children.add(dst)
        self.function_data[src_func]['children'] = list(children)

        parents = set(self.function_data[dst]['parents'])
        parents.add(src_func)
        self.function_data[dst]['parents'] = list(parents)
        




###############################################################################

class MasterRefTree(RefTree):

    def __init__(self, options):
        self.options       = options
        self.provider      = ida.IDA()
        self.function_data = {}

        self.proc = self.provider.getArch()

        self.jmp_mnem = ""

        if self.proc == "pc":
            self.call_mnem = "call"
            self.jmp_mnem = "jmp"
        elif self.proc == "arm" or self.proc == "ppc":
            self.call_mnem = "bl"
        elif self.proc == "mips":
            self.call_mnem = "jalr"

        all_funcs = database.functions()

        if self.proc == "pc":
            # XXX: hackish way to fix a crap ton of stuff...
            start = self.provider.segByBase(self.provider.segByName(".text"))
            end = self.provider.segEnd(self.provider.segByBase(self.provider.segByName(".text")))

            succeeded = 0
            for instr in self.provider.iterInstructions(start, end):
                disasm = self.provider.getDisasm(instr)
                tokens = disasm.split(" ")

                res = []
                for t in tokens:
                    if len(t) != 0:
                        res.append(t)

                prologues = [['mov', 'edi,', 'edi'], ['push', 'ebp'], ['push', 'rbp']]

                if res in prologues and instr not in all_funcs:
                    try:
                        prev_ea = self.provider.prevItem(instr, instr-0x20)
                        if prev_ea not in all_funcs:
                            if options['verbosity'] > 2:
                                print "[!] Attempting to create a function at 0x%08x" % instr
                            ret = self.provider.makeFunc(instr)
                        else:
                            continue

                        if ret:
                            if options['verbosity'] > 2:
                                print "[*] Successfully made new function at 0x%08x" % instr
                            succeeded += 1

                    except Exception as detail:
                        pass

                elif "dup(90h)" in disasm:
                    if options['verbosity'] > 2:
                        print "Found dup at 0x%08x" % instr
                    try:
                        next_ea = self.provider.nextItem(instr, instr+0x20)

                        if next_ea not in all_funcs:
                            ret = self.provider.nextItem(next_ea, 0xFFFFFFFF)
                        else:
                            continue

                        if not ret and (next_ea in database.functions()) :
                            if options['verbosity'] > 2:
                                print "[*] Successfully made new function at 0x%08x" % next_ea
                            succeeded += 1
                    except:
                        pass
               
            if succeeded != 0:
                print "[*] Successfully created %d new functions" % succeeded

        print "[*] There are %d functions to process" % len(all_funcs)

        failed = 0
        succeeded = 0

        for i in xrange(0, len(all_funcs)):

            i_actual = i+1
            ea = all_funcs[i]
            if ((i_actual % 250 == 0) or (i == len(all_funcs)-1)):
                print "[*] RefTree.py: Processing 0x%08x (%d of %d)" % (ea, i_actual, len(all_funcs))
            
            props = analysis.properties(ea)
            func_props = props.funcProps()

            try:
                self.add_func(ea, func_props)
                succeeded += 1
            except Exception as detail:
                raise
       
            except ValueError as detail:
                failed += 1
                if options['verbosity'] > 2:
                    print "0x%08x - failed to process node, %s" % (ea, detail)     
        
        print "[*] Failed to process %d functions" % failed
        print "[*] Successfully processed %d functions" % succeeded

        # now loop imports
        segs = list(self.provider.getSegments())

        if self.proc in ["arm", "ppc", "mips"]:
            idata = "extern"
        elif self.proc == "pc":
            idata = ".idata"

        for s in segs:
            if self.provider.segName(s) == idata:
                start = s
                end = self.provider.segEnd(s)

                for head in self.provider.iterData(start, end):
                    try:
                        self.add_func(head)
                    except Exception:
                        raise
                    

    def xrefs_to(self, addy):
        # we must get the xrefs to this function
        # then retrieve the EA of the top of each xref
        # return those
        res = []
        up = self.provider.cxUp(addy)
        for call_addy in up:
            func_top = self.provider.funcStart(call_addy)

            if func_top:
                res.append(func_top)

        return res


    def xrefs_from(self, addy):
        # we need to crawl the function that contains addy
        # and find every external code transfer
        # and return all the destinations
        res   = []
        start = self.provider.funcStart(addy)
        end   = self.provider.funcEnd(addy)

        if (start != None) and (end != None):

            to_process = list(self.provider.iterInstructions(start, end))
            to_process.extend(self.provider.iterFuncChunks(addy))
            
            for instr in to_process:
                # XXX gotta add support for jmps that go outside a function
                if self.call_mnem in self.provider.getMnem(instr).lower():
                    xrefs_from = self.provider.cxDown(instr)
                    res.extend(xrefs_from)
                elif self.jmp_mnem in self.provider.getMnem(instr).lower():

                    xref = self.provider.cxDown(instr)
                    if xref == []:
                        continue
                    else:
                        xref = xref[0]

                    dst_func_start = self.provider.funcStart(xref)
                    if dst_func_start != None:
                        if dst_func_start != start:
                            res.append(xref)

        res = list(set(res))
        return res


    def queryDepth(self, address, depth, direction):
        res = list()

        if direction == "down":
            # getting children
            if depth > 0:
                children = self.function_data[address]['children']

                if children == []:
                    return res

                res.extend(children)

                for child in children:
                    ret = self.queryDepth(child, depth-1, 'down')
                    if ret != []:
                        res.extend(ret)
                return res

            elif depth == 0:
                return list(set(res))
           
        elif direction == "up":
            # getting parents
            if depth > 0:
                parents = self.function_data[address]['parents']

                if parents == []:
                    return res

                res.extend(parents)

                for parent in parents:
                    ret = self.queryDepth(parent, depth-1, 'up')
                    if ret != []:
                        res.extend(ret)
                    return res
            elif depth == 0:
                return list(set(res))


    def addAttributes(self, func_top, addy, attributes):
        if not self.function_data.has_key(func_top):
            self.provider.makeFunc(func_top)
            self.add_func(func_top)

        if self.function_data[func_top]['attr'].has_key(addy):
            self.function_data[func_top]['attr'][addy].update(attributes)
        else:
            self.function_data[func_top]['attr'][addy] = attributes


    def tag(self, ea, tag, data):
        func_top = self.provider.funcStart(ea)
        if func_top == None:
            func_top = ea

        taginfo = {tag : data}

        self.addAttributes(func_top, ea, taginfo)


    def deleteTag(self, address, tag):
        for func, addy_info in self.function_data.iteritems():
            attributes = addy_info['attr']

            try:
                if tag in attributes[address]:
                    del(attributes[address][tag])
            except KeyError:
                pass


    def getAttribute(self, attr):
        res = {}
        for func, addy_info in self.function_data.iteritems():
            attributes = addy_info['attr']
            
            for k, vals in attributes.iteritems():

                # if its an address
                if isinstance(k, int) or isinstance(k, long):
                    for address_k, address_val in vals.iteritems():
                        if address_k == attr:
                            res[k] = vals
        return res


########NEW FILE########
__FILENAME__ = createdb
# createdb.py
#
# for public release, 2012
#
# Aaron Portnoy
#
# C:\>"C:\Program Files (x86)\ida\idaw.exe" -A -OIDAPython:createdb.py calc.exe
#


# Standard Libraries
import os
import sys

# IDA
import idc
import idaapi


sys.path.append(os.environ['USERPROFILE'] + "\\AppData\\Roaming\\Hex-Rays\\IDA Pro\\toolbag")

from config import *
import RefTree

# 
from db import DB

idaapi.autoWait()
dbobj = DB(options, create=True)
idc.Exit(0)

########NEW FILE########
__FILENAME__ = server
# server.py
#
# for public release, 2012
#
# Brandon Edwards


# Standard Libraries
import os
import sys
import time
import socket
import signal
import struct
import binascii

# ghetto
for x in sys.path:
    if "toolbag" in x:
        sys.path.append("%s%sagent" % (x, os.sep))
        break

import toolbagcomm


# we had a promise made 
def usage(s):
    print "+ usage %s <ip> <port> <key>" % s

# main function
if __name__ == "__main__":

    argc = len(sys.argv)

    ip = sys.argv[1] 
    port = int(sys.argv[2])
    key = sys.argv[3]

#    sys.stdout = open("c:\\log2.txt", "w")
#    sys.stderr = sys.stdout

    print "[*] Setting up Toolbag Queue Server"
    myserv = toolbagcomm.QueueServer(ip, port, key)
        

########NEW FILE########
__FILENAME__ = ui
# ui.py
#
# for public release, 2012
#
# Aaron Portnoy


# Standard Libraries
import os
import re
import sys
import time
import copy
import pickle
import atexit
import socket
import signal
import getpass
import tempfile
import traceback
import subprocess
import types

# PySide
from PySide import QtCore, QtGui

# Toolbag stuff
import segment
import RefTree
import database
import function
import pathfinder
import analysis

# Remote communication
#import toolbagcomm
#import ToolbagTask

# IDA provider
from providers import ida
from providers.ida import form as PluginForm


class PeerDataQueue:
    def __init__(self):
        self.stack = []
        self.current_id = 0


    def add(self, ip, objname, objtype, data, id_):
        self.stack.append((ip, objname, objtype, data, id_))
        self.current_id += 1


    def remove(self, data):
        tmp = []
        for item in self.stack:

            x = self.fetchattr(item, 'data')
            
            if x == data:
                print "[*] Removed item from the peer data queue"
            else:
                tmp.append(item)

        self.stack = tmp


    def fetchitem(self, id_):
        for i in self.stack:
            attr = self.fetchattr(i, "id")
            if id_ == attr:
                return i


    def fetchattr(self, item, param):
        if param == 'ip':
            return item[0]
        elif param == "objname":
            return item[1]
        elif param == "objtype":
            return item[2]
        elif param == "data":
            return item[3]
        elif param == "id":
            return item[4]
        else:
            print "[!] PeerDataQueue::fetchattr failed..."
        

    def newid(self):
        return self.current_id+1


###############################################################################
class Applier(PluginForm):
    def __init__(self, ui_obj, selected, op):
        self.op = op
        self.selected = selected
        self.ui_obj = ui_obj

        self.provider = ida.IDA()

        super(Applier, self).__init__()


    def OnCreate(self, form):
        self.myform = form
        self.parent = self.FormToPySideWidget(form)
        self.PopulateForm()


    def PopulateForm(self):

        layout = QtGui.QVBoxLayout()

        if self.op == "cmts" or self.op == "rcmts":
            cmts = pickle.loads(self.ui_obj.fs.load(self.selected))

            # they came out of the trees man... the trees!
            cmts_tree_widget = QtGui.QTreeWidget()
            cmts_tree_widget.setHeaderLabels(("Address", "Old", "New", "Conflicted"))
            cmts_tree_widget.setColumnCount(4)
            cmts_tree_widget.setColumnWidth(0, 110)
            cmts_tree_widget.setColumnWidth(1, 250)
            cmts_tree_widget.setColumnWidth(2, 250)
            cmts_tree_widget.setColumnWidth(3, 20)
            cmts_tree_widget.setSortingEnabled(True)
            cmts_tree_widget.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
            self.cmts_tree_widget = cmts_tree_widget

            button_group     = QtGui.QWidget()
            button_container = QtGui.QHBoxLayout()
            button_container.addStretch(1)
            button_group.setLayout(button_container)

            select_all = QtGui.QPushButton("Select All")
            select_all.clicked.connect(self.selectAll)

            clear = QtGui.QPushButton("Clear Selection")
            clear.clicked.connect(self.clearSelection)

            apply_selected = QtGui.QPushButton("Apply Selected")
            apply_selected.clicked.connect(self.applySelected)

            button_container.addWidget(select_all)
            button_container.addWidget(clear)
            button_container.addWidget(apply_selected)
            button_container.addStretch(1)

            optional_group     = QtGui.QWidget()
            optional_container = QtGui.QHBoxLayout()
            optional_container.addStretch(1)
            optional_group.setLayout(optional_container)

            prefix_label = QtGui.QLabel()
            prefix_label.setText("Prefix:")

            prefix_input = QtGui.QLineEdit()
            prefix_input.setPlaceholderText("optional")

            self.prefix_input = prefix_input

            optional_container.addWidget(prefix_label)
            optional_container.addWidget(prefix_input)

            layout.addWidget(cmts_tree_widget)
            layout.addWidget(optional_group)
            layout.addWidget(button_group)
            self.parent.setLayout(layout)

            for k, v in cmts.iteritems():
                self.processCmt(k, v)
        
        elif self.op == "names":
            # XXX: to dev later
            pass


    def processCmt(self, address, comment):
        # test if there exists a comment at the address
        current = ""
        if self.op == "cmts":
            current = self.provider.getComment(address)

        elif self.op == "rcmts":
            current = self.provider.getRptComment(address)
        
        if current != comment and current != None:
            item = QtGui.QTreeWidgetItem(self.cmts_tree_widget)
            if self.ui_obj.options['architecture'] == "32":
                item.setText(0, "0x%08x" % address)
            else:
                item.setText(0, "0x%016x" % address)
            item.setText(1, current)
            item.setText(2, comment)
            item.setText(3, "YES")
            return

        # no conflict
        if current == None or current == comment:
            item = QtGui.QTreeWidgetItem(self.cmts_tree_widget)
            if self.ui_obj.options['architecture'] == "32":
                item.setText(0, "0x%08x" % address)
            else:
                item.setText(0, "0x%016x" % address)

            if current == comment:
                item.setText(1, current)
            else:
                item.setText(1, "")

            item.setText(2, comment)
            item.setText(3, "NO")
            return


    def selectAll(self):
        if self.op == "cmts" or self.op == "rcmts":
            count = self.cmts_tree_widget.topLevelItemCount()

            for i in xrange(0, count):
                item = self.cmts_tree_widget.topLevelItem(i)
                item.setSelected(True)


    def clearSelection(self):
        if self.op == "cmts" or self.op == "rcmts":
            count = self.cmts_tree_widget.topLevelItemCount()

            for i in xrange(0, count):
                item = self.cmts_tree_widget.topLevelItem(i)
                item.setSelected(False)


    def applySelected(self):
        if self.op == "cmts" or self.op == "rcmts":
            items = self.cmts_tree_widget.selectedItems()
            for i in items:
                address = int(i.text(0), 16)

                # unicode -> str
                comm = str(i.text(2))

                prefix = str(self.prefix_input.text())
                comm = prefix + " " + comm

                if self.op == "cmts":
                    self.provider.makeComment(address, comm)
                else:
                    self.provider.makeRptComment(address, comm)


    def OnClose(self, form):
        pass


###############################################################################

class Analysis(PluginForm):
    def __init__(self, ui_obj):
        self.ui_obj = ui_obj
        self.provider = ida.IDA()
        self.font    = QtGui.QFont(self.ui_obj.options['font_name'], int(self.ui_obj.options['font_size']))
        self.bgbrush = QtGui.QBrush(QtGui.QColor(self.ui_obj.options['background_color']))
        self.fgbrush = QtGui.QBrush(QtGui.QColor(self.ui_obj.options['font_color']))
        
        # order matters so using two lists instead of a dict
        self.labels = \
        ['Name', 'Address', 'Args', 'Size', 'Xrefs To', 'Xrefs From', 'Blocks', 'Chunks', 'Cookie' , 'Recursive', 'Export', 'Leaf']
        self.keynames = \
        ['numArgs', 'funcSize', 'xrefsTo', 'xrefsFrom', 'numBlocks', 'numChunks', 'hasCookie', 'isRecursive', 'isExport', 'isLeaf']

        self.default_engine_str = \
'''
### Provide a 'matching engine' myengine(attr) that will return True for functions with desirable attributes.
### Attributes are stored in the 'attr' dictionary. The keys and the respective data types returned are:
# numArgs, funcSize, xrefsFrom, xrefsTo, numBlocks, numChunks: <int>
# hasCookie, isRecursive, isExport, isLeaf: <boolean>
### An example query is below which return non-recursive functions with more than 2 arguments

def myengine(attr): 
    return ((attr['numArgs'] > 2) and (attr['isRecursive'] == False))
'''
        self.engine_str = self.default_engine_str

        super(Analysis, self).__init__()


    def OnCreate(self, form):
        self.parent = self.FormToPySideWidget(form)
        self.PopulateForm()

    def PopulateForm(self):
        layout = QtGui.QVBoxLayout()
        self.layout = layout

        self.textbox = QtGui.QPlainTextEdit()
        p = self.textbox.palette()
        p.setColor(QtGui.QPalette.Base, self.ui_obj.options['background_color'])
        p.setColor(QtGui.QPalette.WindowText, self.ui_obj.options['font_color'])

        self.textbox.setPalette(p)
        self.textbox.setFont(self.font)
        self.textbox.setPlainText(self.engine_str)

        button_container = QtGui.QHBoxLayout()
        button_group     = QtGui.QWidget()
        button_group.setLayout(button_container)

        execbutton = QtGui.QPushButton("Execute")
        execbutton.clicked.connect(self.setEngine)
        button_container.addStretch(1)
        button_container.addWidget(execbutton)
        button_container.addStretch(1)

        export_container = QtGui.QHBoxLayout()
        export_group     = QtGui.QWidget()
        export_group.setLayout(export_container)

        export_button = QtGui.QPushButton("Export")
        export_button.clicked.connect(self.exportData)
        export_container.addStretch(1)
        export_container.addWidget(export_button)
        export_container.addStretch(1)

        # populate the table
        self.makeTable(isNew=True)

        layout.addWidget(self.textbox)
        layout.addWidget(button_group)
        layout.addWidget(self.table)
        layout.addWidget(export_group)

        self.parent.setLayout(layout)


    def clearTable(self):
        rows = self.table.rowCount() 
        cols = self.table.columnCount()

        for i in reversed(xrange(0, rows)):
            print self.table.removeRow(i)

        for i in reversed(xrange(0, cols)):
            self.table.removeColumn(i)

    def pretty(self, val):
        # construct user-friendly strings
        if type(val) is types.BooleanType:
            if val: return "Y"
            return "N"
        
        if val == -1:
            return "?"

        return str(val)

    def setEngine(self):
        engine_str = self.textbox.document().toPlainText()
        self.engine_str = engine_str
        self.textbox.setPlainText(self.engine_str)
        self.clearTable()
        self.makeTable()


    def makeTable(self, isNew=False):
        # turn our user-supplied string into an exec-able function
        code_obj = compile(self.engine_str, '<string>', 'exec')
        self.engine = code_obj
 
        # get the function data from inside this nightmarish hellscape
        func_data = self.ui_obj.master.function_data
        search_data = analysis.search(self.engine)
        try:
            hits = search_data.matches(func_data)
            # for the export
            self.lasthits = hits
        except Exception as detail:

            self.engine_str = "# What the hell was that? Not a valid matching engine!\n"
            self.engine_str += "\n" + self.default_engine_str
            self.textbox.setPlainText(self.engine_str)
            
            if not isNew:
                self.setEngine()
            return

        num_rows = len(hits)
        num_cols = len(self.labels)
        
        if(isNew):
            self.table = QtGui.QTableWidget(num_rows, num_cols)
        else:
            self.table.setColumnCount(num_cols)
            self.table.setRowCount(num_rows)    

        row = 0
        for func, func_info in hits.iteritems():
            col = 0
            attrs = func_info['attr']
            if attrs:
                func_name = self.provider.getName(func)
                func_name = self.provider.demangleName(func_name)

                if not func_name:
                    func_name = self.provider.getName(func)
                
                item = self.makeItem(func_name)
                item.setTextAlignment(QtCore.Qt.AlignLeft) 
                item.setTextAlignment(QtCore.Qt.AlignVCenter)
                self.table.setItem(row, col, item)
                col += 1
                
                func = self.pretty(hex(func))
                item = self.makeItem(func)
                self.table.setItem(row, col, item)
                col += 1

                for k in self.keynames:
                    val = self.pretty(attrs[k])
                    item = self.makeItem(val)
                    self.table.setItem(row, col, item)
                    col += 1
                row += 1
       
        self.table.itemDoubleClicked.connect(self.itemDoubleClicked)
        self.table.setHorizontalHeaderLabels(self.labels)
        self.table.setSortingEnabled(True)
    
    def itemDoubleClicked(self, item):
        # in function address column
        if item.column() == 1:
            self.provider.jumpto(int(item.text(), 16))

    def makeItem(self, itemStr):
        item = QtGui.QTableWidgetItem(itemStr)
        item.setFont(self.font)
        item.setForeground(self.fgbrush)
        item.setBackground(self.bgbrush)
        # center
        item.setTextAlignment(QtCore.Qt.AlignCenter)

        return item

    def exportData(self):
        # do somethin' britney spears muthafucka
        text = QtGui.QInputDialog().getText(None, "Export Results", "Enter filename:")
        filename = str(text[0])
        tmp = tempfile.TemporaryFile(mode='wb')
        tmpname = tmp.name
        tmp.close()

        lasthits_tree = RefTree.RefTree(masterGraph=self.ui_obj.master, function_data=self.lasthits)

        pickled_file = open(tmpname, "wb")
        pickle.dump(lasthits_tree, pickled_file)
        pickled_file.close()

        fh = open(tmpname, "rb")
        tablehit_data = fh.read()
        fh.close()

        self.ui_obj.fs.store(filename, tablehit_data)
        self.ui_obj.refreshFilesystem()
        return

    def onClose(self, form):
        #um wat
        return

###############################################################################


class Query(PluginForm):
    def __init__(self, ui_obj, start, depth):
        self.ui_obj = ui_obj

        if depth < 0:
            depth = abs(depth)
            results = self.ui_obj.master.queryDepth(start, depth, direction='up')
        else:
            results = self.ui_obj.master.queryDepth(start, depth, direction='down')

        if results == []:
            self.addrs = [start]
        else:
            self.addrs = [start]
            self.addrs.extend(results)

        self.provider = ida.IDA()

        super(Query, self).__init__()


    def OnCreate(self, form):
        self.myform = form
        self.parent = self.FormToPySideWidget(form)
        self.PopulateForm()


    def PopulateForm(self):
        addrs           = self.addrs
        layout          = QtGui.QVBoxLayout()
        query_tree      = RefTree.RefTree(self.ui_obj.master)
        self.query_tree = query_tree

        for a in addrs:
            query_tree.add_func(a)
        
        query_tree_widget = QtGui.QTreeWidget()
        query_tree_widget.setHeaderLabels(("Name", "Address"))
        query_tree_widget.setColumnCount(2)
        query_tree_widget.setColumnWidth(0, 500)
        query_tree_widget.setColumnWidth(1, 40)
        query_tree_widget.setSortingEnabled(True)
        self.query_tree_widget = query_tree_widget

        query_tree_widget.itemClicked.connect(self.itemClicked)

        try:
            for graph in query_tree.makeTrees():
                self.ui_obj.createChildrenItems(graph, query_tree_widget)
        except RuntimeError as detail:
            print "[!] Error creating graph object: %s" % detail
            return

        self.query_tree = query_tree

        bgbrush = QtGui.QBrush(QtGui.QColor(self.ui_obj.options['background_color']))
        palette = QtGui.QPalette()

        v = query_tree_widget.viewport()
        palette.setBrush(v.backgroundRole(), bgbrush)
        v.setPalette(palette)

        search_group     = QtGui.QWidget()
        search_container = QtGui.QHBoxLayout()
        search_group.setLayout(search_container)

        search = QtGui.QLabel()
        search.setText("Search Disassembly:")
        search_container.addWidget(search)

        search_input      = QtGui.QLineEdit()
        self.search_input = search_input
        search_input.setPlaceholderText("enter search term, things like: 'movsx', 'malloc', '[eax+'")
        search_input.returnPressed.connect(self.doSearch)
        search_container.addWidget(search_input)

        search_button = QtGui.QPushButton("Search")
        search_button.clicked.connect(self.doSearch)
        search_container.addWidget(search_button)

        clear_button = QtGui.QPushButton("Clear")
        clear_button.clicked.connect(self.clearSearch)
        search_container.addWidget(clear_button)

        save_button = QtGui.QPushButton("Save")
        save_button.clicked.connect(self.saveAsSess)
        search_container.addWidget(save_button)

        #freeform_radio = QtGui.QRadioButton()
        #freeform_radio.setText("Free Form")
        regex_checkbox = QtGui.QCheckBox()
        regex_checkbox.setText("Regex?")
        search_container.addWidget(regex_checkbox)

        self.reCheck = regex_checkbox

        self.treewidget = query_tree_widget

        layout.addWidget(search_group)
        layout.addWidget(query_tree_widget)
        self.parent.setLayout(layout)       


    def OnClose(self, form):
        del(self.query_tree)


    def itemClicked(self, item, column):

        col2_data = item.data(1,0)
        try:
            addr = int(col2_data, 16)
            database.go(addr)
            #self.refreshMarks(self.db, local=True)

            if self.ui_obj.show_imports == True:
                self.ui_obj.refreshImports()
            if self.ui_obj.show_strings == True:
                self.ui_obj.refreshStrings()

        except Exception as detail:
            print '[!] Failed to jump to address clicked in query tree, %s' % detail
            pass


    def match(self, widgetitem, param):

        # fuckin' rainbows, man
        bgbrush = QtGui.QBrush(QtGui.QColor('darkgreen'))
        fgbrush = QtGui.QBrush(QtGui.QColor('white'))

        if widgetitem.text(1) == param:
            widgetitem.setForeground(0, fgbrush)
            widgetitem.setForeground(1, fgbrush)
            widgetitem.setBackground(0, bgbrush)
            widgetitem.setBackground(1, bgbrush)

        for childidx in xrange(0, widgetitem.childCount()):
            self.match(widgetitem.child(childidx), param)      


    def clearSearch(self):
        treewidget = self.treewidget
        query_tree = self.query_tree

        treewidget.clear()

        try:
            for graph in query_tree.makeTrees():
                self.ui_obj.createChildrenItems(graph, treewidget)
        except RuntimeError as detail:
            print "[!] Error creating graph object: %s" % detail
            return

        bgbrush = QtGui.QBrush(QtGui.QColor(self.ui_obj.options['background_color']))
        palette = QtGui.QPalette()

        v = treewidget.viewport()
        palette.setBrush(v.backgroundRole(), bgbrush)
        v.setPalette(palette)


    def doSearch(self):
        self.clearSearch()

        params     = self.search_input.text()
        treewidget = self.treewidget
        query_tree = self.query_tree

        if self.reCheck.isChecked():
            re_obj = re.compile(params, re.IGNORECASE)
        
        addrs = query_tree.function_data.keys()

        bgbrush = QtGui.QBrush(QtGui.QColor(self.ui_obj.options['highlighted_background']))
        fgbrush = QtGui.QBrush(QtGui.QColor(self.ui_obj.options['highlighted_foreground']))

        RE = False
        if self.reCheck.isChecked():
            RE = True

        found = False
        for a in addrs:
            startEA = self.provider.funcStart(a)
            endEA = self.provider.funcEnd(a)
            
            for h in self.provider.iterInstructions(startEA, endEA):
                disasm = self.provider.getDisasm(h)
            
                if RE:
                    matches = re.match(re_obj, disasm)
                    if matches:
                        matches = matches.group()
                    if matches != None:
                        found = True
                    else:
                        continue
                try:
                    if found or (params in disasm):

                        # find it in the treewidget and color it
                        toplevelcount = treewidget.topLevelItemCount()
                        for i in xrange(0, toplevelcount):
                            toplevelitem = treewidget.topLevelItem(i)
                            addy = toplevelitem.text(1)
                            
                            if startEA == None:
                                continue

                            if self.ui_obj.options['architecture'] == "32":
                                
                                if addy == "0x%08x" % startEA:
                                    toplevelitem.setForeground(0, fgbrush)
                                    toplevelitem.setForeground(1, fgbrush)
                                    toplevelitem.setBackground(0, bgbrush)
                                    toplevelitem.setBackground(1, bgbrush)

                                self.match(toplevelitem, "0x%08x" % startEA)

                            else:
                                if addy == "0x%016x" % startEA:
                                    toplevelitem.setForeground(0, fgbrush)
                                    toplevelitem.setForeground(1, fgbrush)
                                    toplevelitem.setBackground(0, bgbrush)
                                    toplevelitem.setBackground(1, bgbrush)

                                self.match(toplevelitem, "0x%016x" % startEA)


                        # done with this function if we found at least one match
                        found = False
                        break
                except UnicodeDecodeError:
                    continue


    def saveAsSess(self):
        self.ui_obj.saveHistory(userRefTree=self.query_tree)
        
        
###############################################################################

class UI(PluginForm):
    """
    Main class responsible for the Toolbag UI
    """

    def __init__(self, tree, fs, master, options):
        """
        Initializes the UI

        @type   tree:       object
        @param  tree:       RefTree used to generate trees in PySide QTreeView widgets

        @type   fs:         object
        @param  fs:         toolbag.FS file system object

        @type   master:     object
        @param  master:     toolbag.RefTree.MasterReftree object

        @type   options:    dict
        @param  options:    Dictionary containing the options read from config.py and userconfig.py
        
        """
        
        self.fs                 = fs
        self.peers              = []
        self.agent              = None
        self.master             = master
        self.reftree            = tree
        self.options            = options
        self.peerdata           = PeerDataQueue()
        self.last_history_added = None

        print self.reftree


        # using this as a locking mechanism
        # so that if a user tries to use something from
        # a right-click context menu, none of the timers 
        # will re-draw widgets while this is True, thus
        # they won't deselect the item the user selected
        self.rightClickMenuActive = False

        self.provider = ida.IDA()

        super(UI, self).__init__()


    def setupHotkeys(self):

        # thx peter v for CompileLine suggestion
        modulename = type(self).__module__

        # history hotkey
        history_hotkey = self.options['history_hotkey']
        self.provider.compile('static _keypress() { RunPythonStatement("toolbag.%s.addToHistory()");}' % modulename)
        self.provider.addHotkey(history_hotkey, "_keypress")

        # undo history add
        undo_history_hotkey = self.options['undo_history']
        self.provider.compile('static _undo_history() { RunPythonStatement("toolbag.%s.undoHistory()");}' % modulename)
        self.provider.addHotkey(undo_history_hotkey, "_undo_history")

        # marks
        create_mark_hotkey = self.options['create_mark_hotkey']
        self.provider.compile('static _create_mark() { RunPythonStatement("toolbag.%s.CreateMark()");}' % modulename)
        self.provider.addHotkey(create_mark_hotkey, "_create_mark")

        jump_mark_hotkey = self.options['jump_mark_hotkey']
        self.provider.compile('static _jump_mark() { RunPythonStatement("toolbag.%s.JumpMark()");}' % modulename)
        self.provider.addHotkey(jump_mark_hotkey, "_jump_mark")    

        # pathfinding
        self.provider.compile('static _path_start() { RunPythonStatement("toolbag.%s.PathStart()");}' % modulename)
        self.provider.addHotkey(self.options['path_start'], "_path_start")        

        self.provider.compile('static _path_end() { RunPythonStatement("toolbag.%s.PathEnd()");}' % modulename)
        self.provider.addHotkey(self.options['path_end'], "_path_end")  

        # adding edges
        self.provider.compile('static _edge_source() { RunPythonStatement("toolbag.%s.addEdgeSource()");}' % modulename)
        self.provider.addHotkey(self.options['add_edge_src'], "_edge_source")        
        self.provider.compile('static _edge_dest() { RunPythonStatement("toolbag.%s.addEdgeDest()");}' % modulename)
        self.provider.addHotkey(self.options['add_edge_dst'], "_edge_dest")

        # XXX: deprecated
        #idaapi.CompileLine('static _bbpath_start() { RunPythonStatement("toolbag.%s.BBPathStart()");}' % modulename)
        #idc.AddHotkey(self.options['bb_path_start'], "_bbpath_start")        

        #idaapi.CompileLine('static _bbpath_end() { RunPythonStatement("toolbag.%s.BBPathEnd()");}' % modulename)
        #idc.AddHotkey(self.options['bb_path_end'], "_bbpath_end")  


    # MakeComment hook
    def tbMakeComment(self):
        if self.options['dev_mode']:
            print "[D] tbMakeComment: printing stack:"
            traceback.print_stack()

        # grab the current EA
        ea = self.provider.currentEA()

        # retrieve our dictionary
        comment_dict = pickle.loads(self.fs.load("default.cmts"))

        # grab the comment
        text = self.provider.getComment(ea)

        # set 
        comment_dict[ea] = text

        # save it back to the FS
        self.fs.store("default.cmts", pickle.dumps(comment_dict))

        # refresh the FS tab
        self.refreshFilesystem()

        # refresh comments
        self.refreshCmts()

    # MakeFunction
    def tbMakeFunction(self):
        if self.options['dev_mode']:
            print "[D] tbMakeFunction: printing stack:"
            traceback.print_stack()
        self.master.add_func(self.provider.currentEA())
        self.reftree.add_func(self.provider.currentEA())
        #self.global_hook.reanalyze()


    # MakeRptCmt hook
    def tbMakeRptCmt(self):
        if self.options['dev_mode']:
            print "[D] tbMakeRptCmt: printing stack:"
            traceback.print_stack()

        # grab the current EA
        ea = self.provider.currentEA()

        # retrieve our dictionary
        rcomment_dict = pickle.loads(self.fs.load("default.rcmts"))

        # grab the rcomment 
        text = self.provider.getRptComment(ea)

        # set
        rcomment_dict[ea] = text

        # save it back to the FS
        self.fs.store("default.rcmts", pickle.dumps(rcomment_dict))

        # refresh the FS tab
        self.refreshFilesystem()

        # refresh comments
        self.refreshCmts()


    # MakeName hook
    def tbMakeName(self):
        if self.options['dev_mode']:
            print "[D] tbMakeName: printing stack:"
            traceback.print_stack()
        # XXX
        # this can be hit when stack args/vars, structs, enums are renamed
       
    def OnCreate(self, form):
        self.parent = self.FormToPySideWidget(form)
        self.new_windows = []
        self.dyn_imports = dict()

        self.edge_dest   = None
        self.edge_source = None

        # set up hotkeys
        self.setupHotkeys()

        # store initial comment/repeatable dictionaries, if they aren't present
        try:
            comment_dict = pickle.loads(self.fs.load("default.cmts"))
        except TypeError:
            comment_dict = {}

        self.fs.store("default.cmts", pickle.dumps(comment_dict))

        try:
            rcomment_dict = pickle.loads(self.fs.load("default.rcmts"))
        except TypeError:
            rcomment_dict = {}

        self.fs.store("default.rcmts", pickle.dumps(rcomment_dict))

        # store initial name dictionary, if it isn't present
        try:
            name_dict = pickle.loads(self.fs.load("default.names"))
        except:
            name_dict = {}
            self.fs.store("default.names", pickle.dumps(name_dict))

        self.PopulateForm()


    def createTabAndContainer(self, title, layout):
        if self.options['dev_mode']:
            print "[D] createTabAndContainer: printing stack:"
            traceback.print_stack()

        t = QtGui.QWidget()
        t.setWindowTitle(title)
        c = layout()
        t.setLayout(c)
        return (t, c)


    def initHistoryTree(self):
        if self.options['dev_mode']:
            print "[D] initHistoryTree: printing stack:"
            traceback.print_stack()

        history_obj      = QtGui.QTreeWidget()
        self.history_obj = history_obj
        history_obj.setHeaderLabels(("Name","Address"))
        history_obj.setColumnCount(2)
        history_obj.setColumnWidth(0, 300)
        history_obj.setColumnWidth(1, 40)
        history_obj.itemClicked.connect(self.historyClicked)

        class rightclicka(QtCore.QObject):
            def eventFilter(self, obj, event):
                if event.type() == QtCore.QEvent.Type.ContextMenu:

                    menu = QtGui.QMenu()

                    push_action     = menu.addAction("Push to peers")
                    query_action    = menu.addAction("Query DB")
                    remove_action   = menu.addAction("Remove Node")
                    strings_action  = menu.addAction("Gather Strings")

                    obj.connect(query_action, QtCore.SIGNAL("triggered()"), self.ui.queryGraph)
                    obj.connect(push_action, QtCore.SIGNAL("triggered()"), self.ui.invokeQueues)
                    obj.connect(remove_action, QtCore.SIGNAL("triggered()"), self.ui.removeNode)
                    obj.connect(strings_action, QtCore.SIGNAL("triggered()"), self.ui.gatherStrings)
                    
                    menu.popup(obj.mapToGlobal(event.pos()))
                    self.ui.rightClickMenuActive = True
                    menu.exec_()
                    self.ui.rightClickMenuActive = False
                    return True
                    
                return False

        eventFilter = rightclicka(history_obj)
        rightclicka.ui = self
        history_obj.installEventFilter(eventFilter)


    def initLocalCmts(self):
        if self.options['dev_mode']:
            print "[D] initLocalCmts: printing stack:"
            traceback.print_stack()

        local_cmts      = QtGui.QTreeWidget()
        self.local_cmts = local_cmts
        local_cmts.setHeaderLabels(("Description", "Location", "Address"))
        local_cmts.setColumnCount(3)
        local_cmts.setColumnWidth(0, 120)
        local_cmts.setColumnWidth(1, 100)
        local_cmts.setColumnWidth(2, 50)
        local_cmts.setSortingEnabled(True)
        local_cmts.itemClicked.connect(self.localCmtClicked)


        local_cmts_label      = QtGui.QLabel()
        self.local_cmts_label = local_cmts_label
        local_cmts_label.setText("Local comments:")

    def initLocalMarks(self):
        if self.options['dev_mode']:
            print "[D] initLocalMarks: printing stack:"
            traceback.print_stack()
            
        local_marks      = QtGui.QTreeWidget()
        self.local_marks = local_marks
        local_marks.setHeaderLabels(("Description", "Location", "Group", "Address"))
        local_marks.setColumnCount(4)
        local_marks.setColumnWidth(0, 120)
        local_marks.setColumnWidth(1, 100)
        local_marks.setColumnWidth(2, 50)
        local_marks.setColumnWidth(3, 20)
        local_marks.setSortingEnabled(True)
        local_marks.itemClicked.connect(self.localMarkClicked)

        # install the right-click context menu
        class rightclicka(QtCore.QObject):
            def eventFilter(self, obj, event):
                if event.type() == QtCore.QEvent.Type.ContextMenu:

                    menu = QtGui.QMenu()

                    delete_action = menu.addAction("Delete")
                    push_action   = menu.addAction("Push to peers")
                    
                    obj.connect(delete_action, QtCore.SIGNAL("triggered()"), self.ui.deleteLocalMark)
                    obj.connect(push_action, QtCore.SIGNAL("triggered()"), self.ui.pushMarksToPeers)
                    
                    menu.popup(obj.mapToGlobal(event.pos()))
                    self.ui.rightClickMenuActive = True
                    menu.exec_()
                    self.ui.rightClickMenuActive = False
                    return True
                    
                return False

        eventFilter = rightclicka(local_marks)
        rightclicka.ui = self
        local_marks.installEventFilter(eventFilter)


        local_marks_label      = QtGui.QLabel()
        self.local_marks_label = local_marks_label
        local_marks_label.setText("Local marks:")


    def initShowImports(self):
        if self.options['dev_mode']:
            print "[D] initShowImports: printing stack:"
            traceback.print_stack()
            
        self.show_imports = False
        import_calls      = QtGui.QTreeWidget()
        self.import_calls = import_calls
        import_calls.setHeaderLabels(("Import Name", "Caller", "Address"))
        import_calls.setColumnCount(3)
        import_calls.setSortingEnabled(True)
        import_calls.itemClicked.connect(self.importCallClicked)
        self.import_calls.setVisible(False)

        import_calls_label = QtGui.QLabel()
        import_calls_label.setText("")
        self.import_calls_label = import_calls_label


    def initShowStrings(self):
        if self.options['dev_mode']:
            print "[D] initShowStrings: printing stack:"
            traceback.print_stack()
            
        self.show_strings = False
        string_refs = QtGui.QTreeWidget()
        self.string_refs = string_refs
        string_refs.setHeaderLabels(("String", "Caller", "Address"))
        string_refs.setColumnCount(3)
        string_refs.setSortingEnabled(True)
        string_refs.itemClicked.connect(self.importCallClicked)
        string_refs.setVisible(False)

        string_refs_label = QtGui.QLabel()
        string_refs_label.setText("")
        self.string_refs_label = string_refs_label


    def initToolbarButtons(self, name, tooltip, callback):
        if self.options['dev_mode']:
            print "[D] initToolbarButtons: printing stack:"
            traceback.print_stack()
            

        obj = getattr(self, name)
        obj.setToolTip(tooltip)
        obj.clicked.connect(callback)
        return 


    def addItemsToContainer(self, container, items):
        if self.options['dev_mode']:
            print "[D] addItemsToContainer: printing stack:"
            traceback.print_stack()
            
        for i in items:
            container.addWidget(i)


    def initFileSystem(self):
        if self.options['dev_mode']:
            print "[D] initFileSystem: printing stack:"
            traceback.print_stack()
            
        fs_tree = QtGui.QTreeWidget()
        fs_tree.setHeaderLabels(("Filename", "Size", "ext"))
        fs_tree.setColumnCount(3)
        fs_tree.setColumnWidth(0, 200)
        fs_tree.setColumnWidth(1, 100)
        fs_tree.setColumnWidth(2, 20)

        # XXX: this has to be a custom sort, based on extension
        # or we can add an 'ext' column like i just did 'cause we're lazy
        fs_tree.setSortingEnabled(True)
        fs_tree.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)


        class rightclicka(QtCore.QObject):
            def eventFilter(self, obj, event):
                if event.type() == QtCore.QEvent.Type.ContextMenu:

                    # i'm really trying hard not to re-organize this into a 
                    # more aesthetically pleasing cascade of code
                    menu = QtGui.QMenu()

                    load_action            = menu.addAction("Load in History")
                    merge_action           = menu.addAction("Merge Sessions")
                    export_action          = menu.addAction("Export")
                    delete_action          = menu.addAction("Delete")
                    add_file_action        = menu.addAction("Add File")
                    apply_action           = menu.addAction("Apply")
                    push_peers_action      = menu.addAction("Push to Peers")
                    save_to_retvals_action = menu.addAction("Save as variable...")

                    obj.connect(apply_action, QtCore.SIGNAL("triggered()"), self.ui.applyFile)
                    obj.connect(add_file_action, QtCore.SIGNAL("triggered()"), self.ui.addFile)
                    obj.connect(load_action, QtCore.SIGNAL("triggered()"), self.ui.loadSessFile)
                    obj.connect(export_action, QtCore.SIGNAL("triggered()"), self.ui.exportFile)
                    obj.connect(delete_action, QtCore.SIGNAL("triggered()"), self.ui.deleteFile)
                    obj.connect(merge_action, QtCore.SIGNAL("triggered()"), self.ui.mergeSessFiles)
                    obj.connect(push_peers_action, QtCore.SIGNAL("triggered()"), self.ui.pushPeers)
                    obj.connect(save_to_retvals_action, QtCore.SIGNAL("triggered()"), self.ui.saveToRetVals)
                    
                    menu.popup(obj.mapToGlobal(event.pos()))
                    self.ui.rightClickMenuActive = True
                    menu.exec_()
                    self.ui.rightClickMenuActive = False
                    return True
                    
                return False

        eventFilter = rightclicka(fs_tree)
        rightclicka.ui = self
        fs_tree.installEventFilter(eventFilter)

        self.fsTree = fs_tree
        self.refreshFilesystem()


    def initGlobalMarks(self):
        if self.options['dev_mode']:
            print "[D] initGlobalMarks: printing stack:"
            traceback.print_stack()
            
        mark_list = QtGui.QTreeWidget()
        mark_list.setHeaderLabels(("Description", "Location", "Group", "Address"))
        mark_list.setColumnCount(4)
        mark_list.setColumnWidth(0, 120)
        mark_list.setColumnWidth(1, 100)
        mark_list.setColumnWidth(2, 50)
        mark_list.setColumnWidth(3, 20)
        mark_list.setSortingEnabled(True)
        mark_list.itemClicked.connect(self.markClicked)

        # install the right-click context menu
        class rightclicka(QtCore.QObject):
            def eventFilter(self, obj, event):
                if event.type() == QtCore.QEvent.Type.ContextMenu:

                    menu = QtGui.QMenu()

                    delete_action = menu.addAction("Delete")
                    push_action   = menu.addAction("Push to peers")
                    
                    obj.connect(delete_action, QtCore.SIGNAL("triggered()"), self.ui.deleteGlobalMark)
                    obj.connect(push_action, QtCore.SIGNAL("triggered()"), self.ui.pushMarksToPeers)

                    menu.popup(obj.mapToGlobal(event.pos()))
                    self.ui.rightClickMenuActive = True
                    menu.exec_()
                    self.ui.rightClickMenuActive = False
                    return True
                    
                return False

        eventFilter = rightclicka(mark_list)
        rightclicka.ui = self
        mark_list.installEventFilter(eventFilter)

        self.markList = mark_list
        self.refreshMarks()


    def initUserScripts(self):
        if self.options['dev_mode']:
            print "[D] initUserScripts: printing stack:"
            traceback.print_stack()
            
        fileSystemModel = QtGui.QFileSystemModel()
        fileSystemModel.setFilter(QtCore.QDir.Files)
        fileSystemModel.setNameFilters(["*.py"])
        fileSystemModel.setNameFilterDisables(False)
        
        rootPath = self.options['user_scripts_dir']
        
        fileSystemModel.setRootPath(rootPath)
        view = QtGui.QListView()
        view.setModel(fileSystemModel)
        view.setRootIndex(fileSystemModel.index(rootPath))
        view.activated.connect(self.userScriptsActivated)
        self.userScripts      = view
        self.userScriptsModel = fileSystemModel

        self.user_scripts_label = QtGui.QLabel()
        self.user_scripts_label.setText("User Scripts\n--\nDouble click to execute:")

        fileSystemModel2 = QtGui.QFileSystemModel()
        fileSystemModel2.setFilter(QtCore.QDir.Files)
        fileSystemModel2.setNameFilters(["*.py"])
        fileSystemModel2.setNameFilterDisables(False)
        rootPath = self.options['vtrace_scripts_dir']
        
        fileSystemModel2.setRootPath(rootPath)
        view = QtGui.QListView()
        view.setModel(fileSystemModel2)
        view.setRootIndex(fileSystemModel2.index(rootPath))
        #view.activated.connect(self.vtraceScriptsActivated)
        self.vtraceScripts      = view
        self.vtraceScriptsModel = fileSystemModel2

        self.vtrace_scripts_label = QtGui.QLabel()
        self.vtrace_scripts_label.setText("VTrace scripts\n--\nRight-click to invoke:")


        # right clicker for vtrace scripts
        class rightclicka_vtrace(QtCore.QObject):
            def eventFilter(self, obj, event):
                if event.type() == QtCore.QEvent.Type.ContextMenu:

                    menu = QtGui.QMenu()

                    edit_action    = menu.addAction("Edit...")
                    prep_action = menu.addAction("Prepare ...")
                    run_action    = menu.addAction("Run on Agent ...")
                    process_action = menu.addAction("Process Results...")

                    obj.connect(edit_action, QtCore.SIGNAL("triggered()"), self.ui.editVtraceScript)
                    obj.connect(run_action, QtCore.SIGNAL("triggered()"), self.ui.runVtraceScript)
                    obj.connect(process_action, QtCore.SIGNAL("triggered()"), self.ui.processVTraceScript)
                    obj.connect(prep_action, QtCore.SIGNAL("triggered()"), self.ui.prepVtraceScript)
                    
                    menu.popup(obj.mapToGlobal(event.pos()))
                    self.ui.rightClickMenuActive = True
                    menu.exec_()
                    self.ui.rightClickMenuActive = False
                    return True
                    
                return False

        eventFilter = rightclicka_vtrace(self.vtraceScripts)
        rightclicka_vtrace.ui = self
        self.vtraceScripts.installEventFilter(eventFilter)

        class rightclicka_user(QtCore.QObject):
            def eventFilter(self, obj, event):
                if event.type() == QtCore.QEvent.Type.ContextMenu:

                    menu = QtGui.QMenu()
                    edit_action = menu.addAction("Edit...")

                    obj.connect(edit_action, QtCore.SIGNAL("triggered()"), self.ui.editUserScript)

                    menu.popup(obj.mapToGlobal(event.pos()))
                    menu.exec_()
                    return True
                    
                return False

        eventFilter = rightclicka_user(self.userScripts)
        rightclicka_user.ui = self
        self.userScripts.installEventFilter(eventFilter)


        self.refreshScripts()
        self.refreshVTraceScripts()


    def initPathfinding(self):
        if self.options['dev_mode']:
            print "[D] initPathfinding: printing stack:"
            traceback.print_stack()

        pathfinding_group     = QtGui.QWidget()
        pathfinding_container = QtGui.QVBoxLayout()
        pathfinding_group.setLayout(pathfinding_container)

        function_group     = QtGui.QWidget()
        function_container = QtGui.QVBoxLayout()
        function_group.setLayout(function_container)

        function_label = QtGui.QLabel()
        function_label.setText("Function:")

        f_start_end_container = QtGui.QVBoxLayout()
        f_start_end_group     = QtGui.QWidget()
        f_start_end_group.setLayout(f_start_end_container)
        
        path_start     = QtGui.QLabel() 
        self.pathStart = path_start
        path_start.setText("Start address:")

        path_end     = QtGui.QLabel()
        self.pathEnd = path_end
        path_end.setText("End address:")

        button_container = QtGui.QHBoxLayout()
        button_group     = QtGui.QWidget()
        button_group.setLayout(button_container)

        plot_fpath = QtGui.QPushButton("Plot Function Path")
        plot_fpath.clicked.connect(self.plot_path)

        button_container.addStretch(1)
        button_container.addWidget(plot_fpath)
        button_container.addStretch(1)

        #f_start_end_container.addStretch(1)
        f_start_end_container.addWidget(path_start)
        #f_start_end_container.addStretch(1)
        f_start_end_container.addWidget(path_end)
        #f_start_end_container.addStretch(1)

        pathfinding_container.addWidget(f_start_end_group)
        pathfinding_container.addWidget(button_group)

        bb_group     = QtGui.QWidget()
        bb_container = QtGui.QVBoxLayout()
        bb_group.setLayout(bb_container)

        b_start_end_container = QtGui.QVBoxLayout()
        b_start_end_group     = QtGui.QWidget()
        b_start_end_group.setLayout(b_start_end_container)


        button2_container = QtGui.QHBoxLayout()
        button2_group     = QtGui.QWidget()
        button2_group.setLayout(button2_container)

        plot_bpath = QtGui.QPushButton("Plot Basic Block Path to Current EA")
        plot_bpath.clicked.connect(self.plot_bb_path)

        button2_container.addStretch(1)
        button2_container.addWidget(plot_bpath)
        button2_container.addStretch(1)

        pathfinding_container.addWidget(b_start_end_group)
        pathfinding_container.addWidget(button2_group)

        self.pathfinding_group = pathfinding_group
    

    def initOptions(self):
        if self.options['dev_mode']:
            print "[D] initOptions: printing stack:"
            traceback.print_stack()
            
        options_group = QtGui.QWidget()
        options_container = QtGui.QVBoxLayout()
        options_group.setLayout(options_container)

        label = QtGui.QLabel()
        label.setText("Super ghetto way to edit your options on the fly\n--\n(apologies for formatting)\n")

        # this is so ghetto
        output = "options = {\n"
        for k, v in self.options.iteritems():

            if type(v) == type(True):
                if v:
                    output += "\t'%s'\t:\tTrue,\n" % k
                else:
                    output += "\t'%s'\t:\tFalse,\n" % k

            elif type(v) == type(""):
                output += "\t'%s'\t:\t'%s',\n" % (k, v)                

            elif type(v) == type(0):
                output += "\t'%s'\t:\t%d,\n" % (k, v)

            elif type(v) == type([]):
                output += "\t'%s'\t:\t%s\n," % (k,v)

        output += "}\n"

        wow = QtGui.QTextEdit()
        wow.setText(output)

        self.dynamicOptions = wow

        apply_button = QtGui.QPushButton()
        apply_button.setText("Apply")
        apply_button.clicked.connect(self.applyOptions)

        options_container.addWidget(label) 
        options_container.addWidget(wow) 
        options_container.addWidget(apply_button) 
        self.options_group = options_group


    def initQueues(self):
        if self.options['dev_mode']:
            print "[D] initQueues: printing stack:"
            traceback.print_stack()
            
        host_group     = QtGui.QWidget()
        host_container = QtGui.QHBoxLayout()
        host_group.setLayout(host_container)

        port_group     = QtGui.QWidget()
        port_container = QtGui.QHBoxLayout()
        port_group.setLayout(port_container)

        key_group     = QtGui.QWidget()
        key_container = QtGui.QHBoxLayout()
        key_group.setLayout(key_container)


        add_item_group     = QtGui.QWidget()
        add_item_container = QtGui.QHBoxLayout()
        add_item_group.setLayout(add_item_container)

        radio_group     = QtGui.QWidget()
        radio_container = QtGui.QVBoxLayout()
        radio_group.setLayout(radio_container)


        # host
        host = QtGui.QLabel()
        host.setText("Host:")
        host_container.addWidget(host)

        host_input        = QtGui.QLineEdit()
        self.queueHostObj = host_input
        #if self.options.has_key('host'):
        #    self.queueHost = self.options['server_host']
        #    server_host_input.setPlaceholderText(self.options['server_host'])
        #else:
        host_input.setPlaceholderText("<enter ip or hostname>")
        host_container.addWidget(host_input)

        # port
        port = QtGui.QLabel()
        port.setText("Port:")
        port_container.addWidget(port)

        port_input        = QtGui.QLineEdit()
        self.queuePortObj = port_input
        port_input.setPlaceholderText("<enter port number>")
        port_container.addWidget(port_input)

        # key
        key = QtGui.QLabel()
        key.setText("Key:")
        key_container.addWidget(key)

        key_input        = QtGui.QLineEdit()
        self.queueKeyObj = key_input
        key_input.setPlaceholderText("<enter key>")
        key_container.addWidget(key_input)

        # add button and radio buttons
        add_queue = QtGui.QPushButton()
        add_queue.setText("Add")
        add_queue.clicked.connect(self.addQueue)
        add_item_container.addWidget(add_queue)

        peerRadio      = QtGui.QRadioButton(radio_group)
        self.peerRadio = peerRadio
        peerRadio.setText("Peer")

        serverRadio      = QtGui.QRadioButton(radio_group)
        self.serverRadio = serverRadio
        serverRadio.setText("Server")
        
        
        agentRadio      = QtGui.QRadioButton(radio_group)
        self.agentRadio = agentRadio
        agentRadio.setText("Agent")
        

        self.queueRadioGroup = radio_group

        add_item_container.addWidget(serverRadio)
        add_item_container.addWidget(peerRadio)
        add_item_container.addWidget(agentRadio)

        # input group
        queue_input_group = QtGui.QWidget()
        input_container   = QtGui.QVBoxLayout()
        queue_input_group.setLayout(input_container)

        input_container.addWidget(host_group)
        input_container.addWidget(port_group)
        input_container.addWidget(key_group)
        input_container.addWidget(add_item_group, alignment=QtCore.Qt.AlignLeft)
        
        self.queueInput = queue_input_group

        # Queue List
        queue_list = QtGui.QTreeWidget()
        queue_list.setHeaderLabels(("Host", "", "Type", ""))
        queue_list.setColumnCount(4)
        self.queueList = queue_list
        #path_list.itemClicked.connect(self.pathClicked)


        # right click context
        class rightclicka(QtCore.QObject):
            def eventFilter(self, obj, event):
                if event.type() == QtCore.QEvent.Type.ContextMenu:

                    menu = QtGui.QMenu()

                    store_action  = menu.addAction("Store...")
                    reject_action = menu.addAction("Reject")
                    delete_action = menu.addAction("Delete")

                    obj.connect(delete_action, QtCore.SIGNAL("triggered()"), self.ui.deleteQueue)
                    obj.connect(store_action, QtCore.SIGNAL("triggered()"), self.ui.saveQueueData)
                    obj.connect(reject_action, QtCore.SIGNAL("triggered()"), self.ui.rejectQueueData)

                    menu.popup(obj.mapToGlobal(event.pos()))
                    self.ui.rightClickMenuActive = True
                    menu.exec_()
                    self.ui.rightClickMenuActive = False
                    return True
                    
                return False

        eventFilter = rightclicka(queue_list)
        rightclicka.ui = self
        queue_list.installEventFilter(eventFilter)

        self.refreshQueueList()


    def PopulateForm(self):
        if self.options['dev_mode']:
            print "[D] PopulateForm: printing stack:"
            traceback.print_stack()
            

        layout = QtGui.QVBoxLayout()

        tabs = QtGui.QTabWidget()
        tabs.setMovable(True)
        self.tabs = tabs

        # Tab #1 - History Tree
        tab1, tab1_container = self.createTabAndContainer("History", QtGui.QVBoxLayout)
        self.historyTab = tab1

        # Create history tree
        self.initHistoryTree()

        #if self.options['localview'] == 'marks':
        # Create local marks
        self.initLocalMarks()
        #else:
        # Create local comments
        self.initLocalCmts()

        # Create show imports view
        self.initShowImports()

        # Create the show strings view
        self.initShowStrings()

        stupid = QtGui.QWidget()
        stupid_container = QtGui.QVBoxLayout()
        #stupid_container.setSizeConstraint(QtGui.QLayout.SetFixedSize)
        stupid_container.setSpacing(0)
        stupid.setLayout(stupid_container)
        history_toolbar = QtGui.QToolBar()
        rsrc_dir = self.options['ida_user_dir'] + os.sep + "rsrc"
        
        save_icon = QtGui.QIcon(rsrc_dir + os.sep + "save.png")
        clear_icon = QtGui.QIcon(rsrc_dir + os.sep + "clear.png")
        import_icon = QtGui.QIcon(rsrc_dir + os.sep + "imports.png")
        strings_icon = QtGui.QIcon(rsrc_dir + os.sep + "strings.png")
        add_edge_icon = QtGui.QIcon(rsrc_dir + os.sep + "addedge.png")
        query_db_icon = QtGui.QIcon(rsrc_dir + os.sep + "querydb.png")
        push_peers_icon = QtGui.QIcon(rsrc_dir + os.sep + "pushpeers.png")
        
        self.save_button = QtGui.QToolButton()
        self.save_button.setIcon(save_icon)

        self.clear_button = QtGui.QToolButton()
        self.clear_button.setIcon(clear_icon)
        
        self.show_imports_button = QtGui.QToolButton()
        self.show_imports_button.setIcon(import_icon)
        
        self.show_strings_button = QtGui.QToolButton()
        self.show_strings_button.setIcon(strings_icon)
        
        self.add_edge_button = QtGui.QToolButton()
        self.add_edge_button.setIcon(add_edge_icon)

        self.query_db_button = QtGui.QToolButton()
        self.query_db_button.setIcon(query_db_icon)

        self.push_peers_button = QtGui.QToolButton()
        self.push_peers_button.setIcon(push_peers_icon)
        
        history_toolbar.addWidget(self.save_button)
        history_toolbar.addWidget(self.clear_button)
        history_toolbar.addWidget(self.show_imports_button)
        history_toolbar.addWidget(self.show_strings_button)
        history_toolbar.addWidget(self.add_edge_button)
        history_toolbar.addWidget(self.query_db_button)
        history_toolbar.addWidget(self.push_peers_button)

        history_toolbar.setIconSize(QtCore.QSize(18, 18))

        stupid_container.addWidget(history_toolbar)
        tab1_container.addWidget(stupid)
        
        history_buttons = [ \
            ("clear_button", "Clear the current history view", self.clearHistory),
            ("save_button", "Save current history as a .sess file in the Filesystem", self.saveHistory),
            ("show_imports_button", "Toggle the display of the calls to imported funtions pane", self.importToggle),
            ("show_strings_button", "Toggle the display of the strings referenced pane", self.stringsToggle),
            ("add_edge_button", "Manually add edges to the ToolBag database", self.addEdge),
            ("query_db_button", "Perform a custom query against the Toolbag database", self.queryGraph),
            ("push_peers_button", "Push the current history tree to registered peers", self.pushPeers)
        ]
        for b in history_buttons:
            self.initToolbarButtons(b[0], b[1], b[2])

        stupid2 = QtGui.QWidget()
        stupid2_container = QtGui.QVBoxLayout()
        #stupid2_container.setSizeConstraint(QtGui.QLayout.SetFixedSize)
        stupid2_container.setSpacing(0)
        stupid2.setLayout(stupid2_container)

        if self.options['localview'] == 'marks':
            local_marks_toolbar = QtGui.QToolBar()
        
            delete_local_mark_icon = QtGui.QIcon(rsrc_dir + os.sep + "clear.png")
        
            self.delete_local_mark_button = QtGui.QToolButton()
            self.delete_local_mark_button.setIcon(delete_local_mark_icon)
        
            local_marks_toolbar.addWidget(self.delete_local_mark_button)

            local_marks_toolbar.setIconSize(QtCore.QSize(18, 18))

            stupid2_container.addWidget(local_marks_toolbar)
        
            local_mark_buttons = [ \
                ("delete_local_mark_button", "Delete the currently selected mark", self.deleteLocalMark)
            ]
            for b in local_mark_buttons:
                self.initToolbarButtons(b[0], b[1], b[2])
        else:
            # no toolbar
            pass

        split_thing = QtGui.QWidget()
        split_thing_container = QtGui.QVBoxLayout()
        split_thing.setLayout(split_thing_container)

        splitter = QtGui.QSplitter()
        splitter.setOrientation(QtCore.Qt.Vertical)
        splitter.addWidget(self.history_obj)
        splitter.addWidget(stupid2)

        if self.options['localview'] == 'marks':
            self.localview = self.local_marks
            splitter.addWidget(self.local_marks_label)
            splitter.addWidget(self.local_marks)
        else:
            self.localview = self.local_cmts
            splitter.addWidget(self.local_cmts_label)
            splitter.addWidget(self.local_cmts)

        split_thing_container.addWidget(splitter)

        # add stuff to tab1
        tab1_items = [ \
            splitter,
            self.import_calls_label,
            self.import_calls,
            self.string_refs_label,
            self.string_refs
        ]

        self.addItemsToContainer(tab1_container, tab1_items)

        # Tab #2 - File System View
        tab2, tab2_container = self.createTabAndContainer("File System", QtGui.QVBoxLayout)
        self.fsTab = tab2

        # Create file system widget
        self.initFileSystem()
        
        stupid = QtGui.QWidget()
        stupid_container = QtGui.QVBoxLayout()
        #stupid_container.setSizeConstraint(QtGui.QLayout.SetFixedSize)
        stupid_container.setSpacing(0)
        stupid.setLayout(stupid_container)
        filesystem_toolbar = QtGui.QToolBar()
        
        addfile_icon = QtGui.QIcon(rsrc_dir + os.sep + "addfile.png")
        removefile_icon = QtGui.QIcon(rsrc_dir + os.sep + "removefile.png")
        mergefile_icon = QtGui.QIcon(rsrc_dir + os.sep + "mergefile.png")
        exportfile_icon = QtGui.QIcon(rsrc_dir + os.sep + "exportfile.png")
        loadinhistory_icon = QtGui.QIcon(rsrc_dir + os.sep + "loadinhistory.png")
        apply_icon = QtGui.QIcon(rsrc_dir + os.sep + "apply.png")
        saveasvar_icon = QtGui.QIcon(rsrc_dir + os.sep + "save.png")
        
        
        self.addfile_button = QtGui.QToolButton()
        self.addfile_button.setIcon(addfile_icon)

        self.removefile_button = QtGui.QToolButton()
        self.removefile_button.setIcon(removefile_icon)

        self.mergefile_button = QtGui.QToolButton()
        self.mergefile_button.setIcon(mergefile_icon)

        self.exportfile_button = QtGui.QToolButton()
        self.exportfile_button.setIcon(exportfile_icon)

        self.loadinhistory_button = QtGui.QToolButton()
        self.loadinhistory_button.setIcon(loadinhistory_icon)

        self.apply_button = QtGui.QToolButton()
        self.apply_button.setIcon(apply_icon)

        self.saveasvar_button = QtGui.QToolButton()
        self.saveasvar_button.setIcon(saveasvar_icon)
        
        filesystem_toolbar.addWidget(self.addfile_button)
        filesystem_toolbar.addWidget(self.removefile_button)
        filesystem_toolbar.addWidget(self.exportfile_button)
        filesystem_toolbar.addWidget(self.mergefile_button)
        filesystem_toolbar.addWidget(self.loadinhistory_button)
        filesystem_toolbar.addWidget(self.apply_button)
        filesystem_toolbar.addWidget(self.saveasvar_button)


        filesystem_toolbar.setIconSize(QtCore.QSize(18, 18))

        stupid_container.addWidget(filesystem_toolbar)
        tab2_container.addWidget(stupid)
        
        filesystem_buttons = [ \
            ("addfile_button", "Add a file from the host filesystem to the pseudo filesystem", self.addFile),
            ("removefile_button", "Delete the currently selected file", self.deleteFile),
            ("exportfile_button", "Exports a file from the pseudo filesystem to the host filesystem", self.exportFile),
            ("mergefile_button", "Merge two .sess files and load them in the History view", self.mergeSessFiles),
            ("loadinhistory_button", "Load the currently selected .sess file in the History view", self.loadSessFile),
            ("apply_button", "Applies the currently selected (r)comments, marks, or names", self.applyFile),
            ("saveasvar_button", "Saves the currently selected item as a variable for programmatic access", self.saveToRetVals)
        ]
        for b in filesystem_buttons:
            self.initToolbarButtons(b[0], b[1], b[2])

        self.addItemsToContainer(tab2_container, [self.fsTree])
 
        # Tab #3 - Marks
        tab3, tab3_container = self.createTabAndContainer("Global Marks", QtGui.QVBoxLayout)
        self.markTab = tab3        

        stupid3 = QtGui.QWidget()
        stupid3_container = QtGui.QVBoxLayout()
        #stupid_container.setSizeConstraint(QtGui.QLayout.SetFixedSize)
        stupid3_container.setSpacing(0)
        stupid3.setLayout(stupid3_container)
        global_marks_toolbar = QtGui.QToolBar()
        
        delete_global_mark_icon = QtGui.QIcon(rsrc_dir + os.sep + "clear.png")
        
        self.delete_global_mark_button = QtGui.QToolButton()
        self.delete_global_mark_button.setIcon(delete_global_mark_icon)

        global_marks_toolbar.addWidget(self.delete_global_mark_button)

        global_marks_toolbar.setIconSize(QtCore.QSize(18, 18))

        stupid3_container.addWidget(global_marks_toolbar)
        
        
        global_marks_buttons = [ \
            ("delete_global_mark_button", "Deletes the currently selected mark", self.deleteGlobalMark)
        ]

        for b in global_marks_buttons:
            self.initToolbarButtons(b[0], b[1], b[2])

        # Create global mark widget
        self.initGlobalMarks()

        self.addItemsToContainer(tab3_container, [stupid3, self.markList])
     
        # Tab #4 - Scripts
        tab4, tab4_container = self.createTabAndContainer("Scripts", QtGui.QVBoxLayout)
        self.userScriptsTab = tab4

        # Create user scripts widget
        self.initUserScripts()
     
        self.addItemsToContainer(tab4_container, [self.user_scripts_label, self.userScripts, self.vtrace_scripts_label, self.vtraceScripts])

        # Tab #5 - Pathfinding
        tab5, tab5_container = self.createTabAndContainer("Pathfinding", QtGui.QVBoxLayout)
        self.pathFindingTab = tab5

        # create pathfinding widget
        self.initPathfinding()

        self.addItemsToContainer(tab5_container, [self.pathfinding_group])

        # Tab #6 - Queues
        tab6, tab6_container = self.createTabAndContainer("Queues", QtGui.QVBoxLayout)
        self.queueTab = tab6

        self.initQueues()

        # XXX
        tab6_container.addWidget(self.queueInput)
        tab6_container.addWidget(self.queueList)

        # Tab #7 - Options
        tab7, tab7_container = self.createTabAndContainer("Options", QtGui.QVBoxLayout)
        self.optionsTab = tab7
        self.initOptions()
        self.addItemsToContainer(tab7_container, [self.options_group])

        mainMenu = QtGui.QMenuBar()

        view_menu = QtGui.QMenu("View")
        mainMenu.addMenu(view_menu)
        self.view_menu = view_menu

        #options_menu = QtGui.QMenu("Options")
        #mainMenu.addMenu(options_menu)

        res = view_menu.addAction("Scripts", self.toggleUserScriptsTab)
        res.setCheckable(True)
        if "Scripts" in self.options['enabled_tabs']:
            res.setChecked(True)
            tabs.addTab(tab4, "Scripts")
        else:
             res.setChecked(False)

        res = view_menu.addAction("Pathfinding", self.togglePathfindingTab)
        res.setCheckable(True)
        if "Pathfinding" in self.options['enabled_tabs']:
            tabs.addTab(tab5, "Pathfinding")
            res.setChecked(True)
        else:
            res.setChecked(False)

        res = view_menu.addAction("Queues", self.toggleQueueTab)
        res.setCheckable(True)
        if "Queues" in self.options['enabled_tabs']:
            tabs.addTab(tab6, "Queues")
            res.setChecked(True)
        else:
            res.setChecked(False)

        res = view_menu.addAction("Options", self.toggleOptionsTab)
        res.setCheckable(True)
        if "Options" in self.options['enabled_tabs']:
            tabs.addTab(tab7, "Options")
            res.setChecked(True)
        else:
            res.setChecked(False)

        res = view_menu.addAction("File System", self.toggleFileSystemTab)
        res.setCheckable(True)
        if "File System" in self.options['enabled_tabs']:
            tabs.addTab(tab2, "File System")
            res.setChecked(True)
        else:
            res.setChecked(False)

        # add ability to launch function analysis
        res = view_menu.addAction("Function Analysis", self.launch_Analysis)

        # add the ability to launch the splash screen
        res = view_menu.addAction("Welcome Screen", self.viewSplash)

        # enabled, all the time
        tabs.addTab(tab1, "History")
        tabs.addTab(tab3, "Global Marks")
        
        # refresh marks every second or so
        self.timerthing()

        # load the default session if its available
        try:
            self.loadSessFile(default=True)
        except Exception as detail:
            print "[!] Failed to load default session: %s" % detail
            self.clearHistory()

        # http://www.rainbowpuke.com/pics/newpukes/nickburns-rainbowpuke.gif
        bgbrush = QtGui.QBrush(QtGui.QColor(self.options['background_color']))
        palette = QtGui.QPalette()

        for w in [self.history_obj, self.fsTree, self.markList, self.localview, self.import_calls, self.string_refs]:
            v = w.viewport()
            palette.setBrush(v.backgroundRole(), bgbrush)
            v.setPalette(palette)

        layout.addWidget(mainMenu)

        layout.addWidget(tabs)

        self.parent.setLayout(layout)

        class MyUiHook(self.provider.UI_Hooks):
            def __init__(self, ui_obj):
                self.ui_obj = ui_obj
                self.ui_obj.provider.UI_Hooks.__init__(self)
                self.cmdname = "<no command>"
                self.handlers = {}

            def preprocess(self, name):
                #print("IDA preprocessing command: %s" % name)
                self.cmdname = name
                return 0

            def postprocess(self):
                #print("IDA finished processing command: %s" % self.cmdname)
                try:
                    #print "[*] Trying to call handler for %s" % self.cmdname
                    self.handlers[self.cmdname]()
                except KeyError:
                    pass
                return 0

            # slick like astro 
            def register_handler(self, action, func):
                self.handlers[action] = func
                return 0

            #def term(self):
            #    self.unhook()

        uihook = MyUiHook(self)
        uihook.hook()
        self.ui_hook = uihook

        atexit.register(uihook.unhook)

        # ui hooks
        self.ui_hook.register_handler("MakeName", self.tbMakeName)
        self.ui_hook.register_handler("MakeComment", self.tbMakeComment)
        self.ui_hook.register_handler("MakeRptCmt", self.tbMakeRptCmt)
        self.ui_hook.register_handler("MakeFunction", self.tbMakeFunction)



    def importToggle(self):
        if self.options['dev_mode']:
            print "[D] importToggle: printing stack:"
            traceback.print_stack()
            
        if self.show_imports != True:
            self.show_imports = True
            self.show_imports_button.setText("Hide Import Calls")
            self.import_calls_label.setText("Calls to imported functions:")
        else:
            self.show_imports_button.setText("Show Import Calls")
            self.show_imports = False
            self.import_calls_label.setText("")

        self.refreshImports()

    def stringsToggle(self):
        if self.options['dev_mode']:
            print "[D] stringsToggle: printing stack:"
            traceback.print_stack()
            
        if self.show_strings != True:
            self.show_strings = True
            self.show_strings_button.setText("Hide Strings")
            self.string_refs_label.setText("String references:")
        else:
            self.show_strings_button.setText("Show String References")
            self.show_strings = False
            self.string_refs_label.setText("")

        self.refreshStrings()


    def createChildrenItems(self, tree, parentWidget):
        if self.options['dev_mode']:
            print "[D] createChildrenItems: printing stack:"
            traceback.print_stack()
            
        root       = tree[0]        
        children   = tree[1]
        rootWidget = QtGui.QTreeWidgetItem(parentWidget)
       
        name = self.provider.demangleName(self.provider.getName(root))
        if name == None:
            name = self.provider.getName(root)

        font = QtGui.QFont(self.options['font_name'], int(self.options['font_size']))

        rootWidget.setFont(0, font)
        rootWidget.setFont(1, font)

        rootWidget.setText(0, name)

        if self.options['architecture'] == "32":
            rootWidget.setText(1, "0x%08x" % root)
        else:
            rootWidget.setText(1, "0x%016x" % root)
        rootWidget.setExpanded(True)

        bgbrush = QtGui.QBrush(QtGui.QColor(self.options['background_color']))
        fgbrush = QtGui.QBrush(QtGui.QColor(self.options['font_color']))

        rootWidget.setForeground(0, fgbrush)
        rootWidget.setForeground(1, fgbrush)
        rootWidget.setBackground(0, bgbrush)
        rootWidget.setBackground(1, bgbrush)
        
        for child in children:
            self.createChildrenItems(child, rootWidget)


    def refreshQueueList(self):
         pass

    def refreshVTraceScripts(self):
        pass

    def refreshScripts(self):
        pass


    def prepVtraceScript(self):
        if self.options['dev_mode']:
            print "[D] prepVtraceScript: printing stack:"
            traceback.print_stack()
            
        #FIXME add a check to ensure agent is present
        #
        try:
            selected = self.vtraceScripts.currentIndex().data()
        except:
            print "[!] No file selected"
            self.rightClickMenuActive = False
            return 

        sys.path.append(self.options['vtrace_scripts_dir'])
        
        fname = selected
        modulename = fname.split(".py")[0]

        #FIXME check to see if myhost exists, complain if it doesnt
        agent = self.myhost.agent

        try:
            _script = __import__(modulename)
        except Exception as detail:

            print detail
            self.rightClickMenuActive = False
            return

        print "[*] Invoking %s.ToolbagTask.prep()" % (modulename)
        agent.toolbagTask = _script.ToolbagTask(fname, self.myhost.agentData, self.myhost.serverData)

        # 'self' is the ui_obj, used by prep()
        agent.toolbagTask.prep(self)
        self.rightClickMenuActive = False
        return

    def runVtraceScript(self):
        self.myhost.agent.toolbagTask.run(self)

    def processVTraceScript(self):
        self.myhost.agent.toolbagTask.process(self)

    def highlightAddressList(self, addresses, color=0xFF):
        for addr in addresses:
            self.provider.setColor(addr, color)
        
    def editUserScript(self):
        if self.options['dev_mode']:
            print "[D] editUserScript: printing stack:"
            traceback.print_stack()
            
        try:
            selected = self.userScripts.currentIndex().data()
            edit_me  = self.options['user_scripts_dir'] + os.sep + selected
        except Exception as detail:
            if selected != None:
                print "[!] No file selected", detail
                self.rightClickMenuActive = False
                return 

        print "[*] Running user's editor on %s" % selected

        # lolololz
        subprocess.call([self.options['editor'], edit_me])

        self.rightClickMenuActive = False

    def editVtraceScript(self):
        if self.options['dev_mode']:
            print "[D] editVtraceScript: printing stack:"
            traceback.print_stack()
            
        try:
            selected = self.vtraceScripts.currentIndex().data()
            edit_me  = self.options['vtrace_scripts_dir'] + os.sep + selected
        except Exception as detail:
            if selected != None:
                print "[!] No file selected", detail
                self.rightClickMenuActive = False
                return 

        
        print "[*] Running user's editor on %s" % selected

        # lolololz
        subprocess.call([self.options['editor'], edit_me])

        self.rightClickMenuActive = False


    def userScriptsActivated(self, index):
        if self.options['dev_mode']:
            print "[D] userScriptsActivated: printing stack:"
            traceback.print_stack()
            
        fileInfo = self.userScriptsModel.fileInfo(index)
        abs_path = fileInfo.absoluteFilePath()
        module   = os.path.split(abs_path)[1]
        module   = os.path.splitext(module)[0]

        sys.path.append(os.path.split(abs_path)[0])

        # sweet, i know.
        if module:

            # check for lack of imports
            if len(self.dyn_imports) == 0:
                
                # try importing the .py
                try:
                    x = __import__(module)
                    try:
                        setattr(x, "ui_obj", self)
                        x.init()
                    except Exception as detail:
                        print detail
                        pass
                    
                except Exception as detail:
                    print detail
                    return

                # update our dict
                self.dyn_imports[module] = x

            else:
                # if it is in our namespace already, reload it
                if self.dyn_imports.has_key(module):
                    x = reload(self.dyn_imports[module])
                    try:
                        setattr(x, "ui_obj", self)
                        x.init()
                    except Exception as detail:
                        print detail
                        pass
                else:
                    # otherwise, import it and update dict
                    try:
                        x = __import__(module)

                        try:
                            setattr(x, "ui_obj", self)
                            x.init()
                        except Exception as detail:
                            print detail
                            pass

                        self.dyn_imports[module] = x
                    except Exception as detail:
                        print detail

        return


    def vtraceScriptsActivated(self, index):
        if self.options['dev_mode']:
            print "[D] vtraceScriptsActivated: printing stack:"
            traceback.print_stack()
            
        fileInfo = self.vtraceScriptsModel.fileInfo(index)
        abs_path = fileInfo.absoluteFilePath()
        module   = os.path.split(abs_path)[1]
        module   = os.path.splitext(module)[0]

        sys.path.append(os.path.split(abs_path)[0])

        # sweet, i know.
        if module:

            # check for lack of imports
            if len(self.dyn_imports) == 0:
                
                # try importing the .py
                try:
                    x = __import__(module)
                except Exception as detail:
                    print detail
                    return

                # update our dict
                self.dyn_imports[module] = x

            else:
                # if it is in our namespace already, reload it
                if self.dyn_imports.has_key(module):
                    reload(self.dyn_imports[module])
                else:
                    # otherwise, import it and update dict
                    try:
                        x = __import__(module)
                        self.dyn_imports[module] = x
                    except Exception as detail:
                        print detail
        return


    def undoHistory(self):
        if self.options['dev_mode']:
            print "[D] undoHistory: printing stack:"
            traceback.print_stack()
            
        if self.reftree == None:
            return

        self.reftree.del_func(self.last_history_added)
        self.history_obj.clear()
        self.addToHistory(add=False)


    def addToHistory(self, add=True, userEA=False):
        if self.options['dev_mode']:
            print "[D] addToHistory: printing stack:"
            traceback.print_stack()
            
        treewidget = self.history_obj

        if userEA == False:
            ea = self.provider.currentEA()
        else:
            ea = userEA

        try:
            top = function.top(ea)
        except ValueError:
            # likely an import
            top = ea

        if self.reftree == None:
            if self.options['dev_mode']:
                print 'DEBUG> self.reftree is None, making a new one'
            self.reftree = RefTree.RefTree(masterGraph=self.master)

        is_import = False
        if not database.isCode(ea):
            # check for import!
            if self.provider.segName(ea) != ".idata":
                print "[!] Attempted to add an EA that wasn't code."
                add = False
            else:
                is_import = True

        if add != False:
            treewidget.clear()            
            if self.options['coloring_enabled'] == True:    

                if is_import:
                    self.provider.setColor(ea, self.options['history_color'])

                else:
                    block = self.provider.basicBlockBoundaries(ea)

                    for i in self.provider.iterInstructions(block[0], block[1]):
                        self.provider.setColor(i, self.options['history_color'])
            
            if self.options['dev_mode']:
                print "[D] Trying to add the function to the reftree...."
            
            try:
                self.reftree.add_func(ea)
            except Exception as detail:
                print detail

            if self.options['dev_mode']:
                print "[D] Succeeded adding function to reftree"
            
            # for undo operation
            if userEA == False:
                if self.options['dev_mode']:
                    print "DEBUG> setting last_history_added to 0x%08x" % top
                self.last_history_added = top

            if self.options['verbosity'] > 5:
                print "[*] ui.py: added 0x%08x to history" % ea

        if add == False:
            if self.options['dev_mode']:
                print "DEBUG> add is false, treewidget.clear()'ing"
                treewidget.clear()
        
        for graph in self.reftree.makeTrees():
            self.createChildrenItems(graph, treewidget)        

        if self.options['dev_mode']:
            print 'addtohistory: about to call refreshstrings/marks/imports'

        self.refreshStrings()
        self.refreshMarks(local=True)
        self.refreshCmts()
        self.refreshImports()


    def JumpMark(self):
        if self.options['dev_mode']:
            print "[D] JumpMark: printing stack:"
            traceback.print_stack()
            
        try:
            self.tabs.setCurrentWidget(self.markTab)
        except Exception as detail:
            print detail


    def CreateMark(self):
        if self.options['dev_mode']:
            print "[D] CreateMark: printing stack:"
            traceback.print_stack()
            
        class MarkDialog(QtGui.QDialog):
            def __init__(self, ui_obj, parent=None):
                super(MarkDialog, self).__init__(parent)

                self.ui_obj = ui_obj
                self.field1 = QtGui.QInputDialog()
                self.field2 = QtGui.QInputDialog()
                self.field1.setOption(QtGui.QInputDialog.NoButtons)
                self.field2.setOption(QtGui.QInputDialog.NoButtons)
                self.field1.setLabelText("Description:")
                self.field2.setLabelText("Optional Group:")

                self.field1.keyPressEvent = self.keyPressEvent
                self.field2.keyPressEvent = self.keyPressEvent
                
                confirm = QtGui.QPushButton("Add Mark")
                confirm.clicked.connect(self.add_mark)

                layout = QtGui.QVBoxLayout()
                layout.addWidget(self.field2)
                layout.addWidget(self.field1)
                
                layout.addWidget(confirm)
                
                self.setLayout(layout)
                self.setWindowTitle("Create Mark")
                self.setWindowModality(QtCore.Qt.ApplicationModal)
                self.show()


            def add_mark(self):
                ea = self.ui_obj.provider.currentEA()
                if self.ui_obj.options['architecture'] == "32":
                    print "[*] Adding a mark at 0x%08x" % ea
                else:
                    print "[*] Adding a mark at 0x%016x" % ea

                description = self.field1.textValue()
                group = self.field2.textValue()

                funcaddr = self.ui_obj.provider.funcStart(ea)
                if funcaddr == None:
                    funcaddr = ea

                if len(group) == 0:
                    self.ui_obj.master.tag(ea, 'mark', description)

                else:
                    self.ui_obj.master.tag(ea, 'mark', description)
                    self.ui_obj.master.tag(ea, 'group', group)
                
                
                self.done(1)
                self.hide()
                self.ui_obj.refreshMarks()
                self.ui_obj.refreshMarks(local=True)


            def keyPressEvent(self, event):
                if event.key() == QtCore.Qt.Key_Return:
                    self.done(1)
                    self.add_mark()

        mark = MarkDialog(self)
        self.refreshMarks()
        self.refreshMarks(local=True)

    def launch_Analysis(self):
        x = Analysis(self)
        x.Show("Function Queries")

    def PathStart(self):
        if self.options['dev_mode']:
            print "[D] PathStart: printing stack:"
            traceback.print_stack()
            
        ea         = self.provider.currentEA()
        func_name2 = None
        try:
            func_top  = function.top(ea)
            func_name = database.name(func_top)
            offset = ea - func_top
            try:
                func_name2 = self.provider.demangleName(func_name)
            except Exception as detail:
                if self.options['verbosity'] > 2:
                    print detail
                pass
        except Exception as detail:
            if self.options['architecture'] == "32":
                print "Problem setting path start to 0x%08x" % ea
            else:
                print "Problem setting path start to 0x%016x" % ea
            func_name = ""

        if func_name2 != None:
            func_name = func_name2

        if self.options['architecture'] == "32":
            self.pathStart.setText("Start address: 0x%08x, %s+0x%x" % (self.provider.currentEA(), func_name, offset))
        else:
            self.pathStart.setText("Start address: 0x%016x, %s+0x%x" % (self.provider.currentEA(), func_name, offset))

        self.pathStartAddress = func_top
        self.tabs.setCurrentWidget(self.pathfindingTab)


    def PathEnd(self):
        if self.options['dev_mode']:
            print "[D] PathEnd: printing stack:"
            traceback.print_stack()
            
        ea         = self.provider.currentEA()
        func_name2 = None
        try:
            func_top  = function.top(ea)
            func_name = database.name(func_top)
            offset    = ea - func_top
            
            try:
                func_name2 = self.provider.demangleName(func_name)
            except:
                pass
        
        except Exception as detail:
            if self.options['architecture'] == "32":
                print "Problem setting path end to 0x%08x" % ea
            else:
                print "Problem setting path end to 0x%016x" % ea
            func_name = ""

        if func_name2 != None:
            func_name = func_name2

        if self.options['architecture'] == "32":
            self.pathEnd.setText("End address: 0x%08x, %s+0x%x" % (self.provider.currentEA(), func_name, offset))
        else:
            self.pathEnd.setText("End address: 0x%016x, %s+0x%x" % (self.provider.currentEA(), func_name, offset))

        self.pathEndAddress = ea
        self.tabs.setCurrentWidget(self.pathfindingTab)


    def BBPathStart(self):
        if self.options['dev_mode']:
            print "[D] BBPathStart: printing stack:"
            traceback.print_stack()
            
        ea = self.provider.currentEA()
        try:
            func_top = function.top(ea)
            func_name = database.name(func_top)
            offset = ea - func_top
            try:
                func_name = self.provider.demangleName(func_name)
            except:
                pass
        except Exception as detail:
            if self.options['architecture'] == "32":
                print "Problem setting path start to 0x%08x" % ea
            else:
                print "Problem setting path start to 0x%016x" % ea
            func_name = ""

        if self.options['architecture'] == "32":
            self.bbpathStart.setText("Start address: 0x%08x, %s+0x%x" % (self.provider.currentEA(), func_name, offset))
        else:
            self.bbpathStart.setText("Start address: 0x%016x, %s+0x%x" % (self.provider.currentEA(), func_name, offset))
        self.bbpathStartAddress = ea
        self.tabs.setCurrentWidget(self.pathfindingTab)


    def BBPathEnd(self):
        if self.options['dev_mode']:
            print "[D] BBPathEnd: printing stack:"
            traceback.print_stack()
            
        ea = self.provider.currentEA()
        try:
            func_top = function.top(ea)
            func_name = database.name(func_top)
            offset = ea - func_top
            try:
                func_name = self.provider.demangleName(func_name)
            except:
                pass
        except Exception as detail:
            if self.options['architecture'] == "32":
                print "Problem setting path end to 0x%08x" % ea
            else:
                print "Problem setting path end to 0x%016x" % ea
            func_name = ""

        if self.options['architecture'] == "32":
            self.bbpathEnd.setText("End address: 0x%08x, %s+0x%x" % (self.provider.currentEA(), func_name, offset))
        else:
            self.bbpathEnd.setText("End address: 0x%016x, %s+0x%x" % (self.provider.currentEA(), func_name, offset))

        self.bbpathEndAddress = ea
        self.tabs.setCurrentWidget(self.pathfindingTab)


    def plot_bb_path(self):
        if self.options['dev_mode']:
            print "[D] plot_bb_path: printing stack:"
            traceback.print_stack()
        
        pf = pathfinder.BlockPathFinder()

        # XXX should cache this in a dict
        pf.analyseFunction()
        print "[*] BlockPathFinder: finished analyzing the current function" 

        ea = self.provider.currentEA()
        affected = set([])
        found_path = pf.findPathBlocks(ea, affected)
        
        if found_path:
            print "[*] BlockPathFinder: finished finding paths, bb count=%d" % len(affected)
        else:
            if self.options['architecture'] == "32":
                print "[!] BlockPathFinder: couldn't find any paths to 0x%08x" % ea
            else:
                print "[!] BlockPathFinder: couldn't find any paths to 0x%016x" % ea
            return

        edges = {}
        for b in affected:
            edges[b] = pf.children[b] & affected
        pg = pathfinder.BlockPathGraph(hex(ea), affected, edges, pf.blockInfo, self.options)
        pg.Show()


    def plot_path(self):
        if self.options['dev_mode']:
            print "[D] plot_path: printing stack:"
            traceback.print_stack()
            
        if not hasattr(self, 'pathStartAddress') or not hasattr(self, 'pathEndAddress'):
            print "[!] Cannot plot a path without both a start and an end address defined"
            return
        starttime = time.time()
        pf = pathfinder.FunctionPathFinder(self.master)
        pf.addStartFunction(self.pathStartAddress)
        affected = set([])
        found_path = pf.findPaths(self.pathEndAddress, affected, set([self.pathEndAddress]), 0, 9999)
        if found_path:
            edges = {}
            for c in affected:
                edges[c] = set(self.master.function_data[c]['parents']) & affected
                #edges[c] = set(self.master.xrefs_to(c)) & affected
            pg = pathfinder.PathGraph(self.pathEndAddress, affected, edges, self)
            pg.Show()
        else:
            if self.options['architecture'] == "32":
                print "[!] No paths found from 0x%08x => 0x%08x" % (self.pathStartAddress, self.pathEndAddress)
            else:
                print "[!] No paths found from 0x%016x => 0x%016x" % (self.pathStartAddress, self.pathEndAddress)
        print "Total run time in seconds: %d" % (time.time() - starttime)


    def deleteLocalMark(self):
        if self.options['dev_mode']:
            print "[D] deleteLocalMark: printing stack:"
            traceback.print_stack()
            
        selected = self.local_marks.selectedItems()

        for s in selected:
            address = int(s.text(3), 16)
            
            self.master.deleteTag(address, 'mark')
            try:
                #group = s.text(2)
                self.master.deleteTag(address, 'group')
            except Exception as detail:
                print detail

        self.rightClickMenuActive = False

        self.refreshMarks()
        self.refreshMarks(local=True)


    def deleteGlobalMark(self):
        if self.options['dev_mode']:
            print "[D] deleteGlobalMark: printing stack:"
            traceback.print_stack()
            
        selected = self.markList.selectedItems()
        
        for s in selected:
            address = int(s.text(3), 16)

            self.master.deleteTag(address, 'mark')
            try:
                #group = s.text(2)
                self.master.deleteTag(address, 'group')
            except Exception as detail:
                print detail

        self.rightClickMenuActive = False

        self.refreshMarks()
        self.refreshMarks(local=True)



    def matchHistoryItem(self, widgetitem, param):

        bgbrush = QtGui.QBrush(QtGui.QColor(self.options['background_color']))
        fgbrush = QtGui.QBrush(QtGui.QColor(self.options['font_color']))

        bgbrush_highlight = QtGui.QBrush(QtGui.QColor(self.options['highlighted_background']))
        fgbrush_highlight = QtGui.QBrush(QtGui.QColor(self.options['highlighted_foreground']))
        
        text = widgetitem.text(1)
        address = int(str(text), 16)
       
        if address == param:
            widgetitem.setForeground(0, fgbrush_highlight)
            widgetitem.setForeground(1, fgbrush_highlight)
            widgetitem.setBackground(0, bgbrush_highlight)
            widgetitem.setBackground(1, bgbrush_highlight)
        else:
            widgetitem.setForeground(0, fgbrush)
            widgetitem.setForeground(1, fgbrush)
            widgetitem.setBackground(0, bgbrush)
            widgetitem.setBackground(1, bgbrush)


        for childidx in xrange(0, widgetitem.childCount()):
            self.matchHistoryItem(widgetitem.child(childidx), param) 


    def refreshHistory(self, local=False):

        currentEA = self.provider.currentEA()
        func_top = self.provider.funcStart(currentEA)
        
        # XXX this seems like a stupid thing to do, self. removing.
        #if not func_top:
        #    return

        bgbrush = QtGui.QBrush(QtGui.QColor('darkgreen'))
        fgbrush = QtGui.QBrush(QtGui.QColor('white'))

        toplevelcount = self.history_obj.topLevelItemCount()

        for i in xrange(0, toplevelcount):
            toplevelitem = self.history_obj.topLevelItem(i)

            text = toplevelitem.text(1)
            address = int(str(text), 16)

            if address == func_top:
                toplevelitem.setForeground(0, fgbrush)
                toplevelitem.setForeground(1, fgbrush)
                toplevelitem.setBackground(0, bgbrush)
                toplevelitem.setBackground(1, bgbrush)
                self.matchHistoryItem(toplevelitem, func_top)
            else:
                toplevelitem.setForeground(0, QtGui.QBrush(QtGui.QColor(self.options['font_color'])))
                toplevelitem.setForeground(1, QtGui.QBrush(QtGui.QColor(self.options['font_color'])))
                toplevelitem.setBackground(0, QtGui.QBrush(QtGui.QColor(self.options['background_color'])))
                toplevelitem.setBackground(1, QtGui.QBrush(QtGui.QColor(self.options['background_color'])))
                self.matchHistoryItem(toplevelitem, func_top)

    def refreshCmts(self):
        if self.options['dev_mode']:
            print "[D] refreshCmts: printing stack:"
            traceback.print_stack()

        self.localview.clear()
        comment_dict  = pickle.loads(self.fs.load("default.cmts"))
        rcomment_dict = pickle.loads(self.fs.load("default.rcmts"))

        current_ea = self.provider.currentEA()
        dicts = [comment_dict, rcomment_dict]
        for d in dicts:
            for addy, comm in d.iteritems():

                is_import = False
                try:
                    function.top(addy)
                except ValueError:
                    is_import = True

                try:
                    if not function.contains(current_ea, addy):
                        continue
                except ValueError as detail:
                    # likely import
                    is_import = True
                    if current_ea != addy:
                        continue
            
                cmt_item = QtGui.QTreeWidgetItem(self.localview)

                if is_import:
                    func_top = addy
                else:
                    func_top = function.top(addy)

                offset = addy - func_top
                func_name  = self.provider.getName(func_top)
                func_name2 = self.provider.demangleName(func_name)
                
                # in case Demangle returns None
                if func_name2: 
                    func_name = func_name2

                if len(func_name) == 0:
                    symbol = hex(addy)
                else:
                    symbol = func_name + "+" + "0x%x" % offset

                font = QtGui.QFont(self.options['font_name'], int(self.options['font_size']))
                cmt_item.setFont(0, font)
                cmt_item.setFont(1, font)
                cmt_item.setFont(2, font)

                cmt_item.setText(0, comm)
                cmt_item.setText(1, "%s" % symbol)
            

                if self.options['architecture'] == "32":
                    cmt_item.setText(2, "0x%08x" % addy)
                else:
                    cmt_item.setText(2, "0x%016x" % addy)

                cmt_item.setExpanded(True)


    def refreshMarks(self, local=False):
        if self.options['dev_mode']:
            print "[D] refreshMarks: printing stack:"
            traceback.print_stack()
            
        # ensure we aren't accidentally de-selecting something via a refresh while a context menu is active
        if self.rightClickMenuActive:
            return

        if local:
            mark_obj = self.local_marks
        else:
            mark_obj = self.markList

        selected_address = None
        selected = mark_obj.selectedItems()
        if selected != []:
            selected_address = selected[0].text(3)

        marks = self.master.getAttribute('mark')
        groups = self.master.getAttribute('group')

        mark_obj.clear()
        for mark_ea, data in marks.iteritems():

            is_import = False
            # skip marks not in code
            try:
                function.top(mark_ea)
            except ValueError:
                is_import = True

            if local:
                current_ea = self.provider.currentEA()
                try:
                    if not function.contains(current_ea, mark_ea):
                        continue
                except ValueError as detail:
                    # likely import
                    is_import = True
                    if current_ea != mark_ea:
                        continue


            # check if its part of a group
            if groups.has_key(mark_ea):

                # XXX: we need to ensure we don't have it already in the list
                mark_item = QtGui.QTreeWidgetItem(mark_obj)
                mark_description = data['mark']           

                if is_import:
                    func_top = mark_ea
                else:
                    func_top = function.top(mark_ea)

                offset = mark_ea - func_top
                func_name = self.provider.getName(func_top)

                func_name2 = self.provider.demangleName(func_name)
                
                # in case Demangle returns None
                if func_name2: 
                    func_name = func_name2

                if len(func_name) == 0:
                    symbol = hex(mark_ea)
                else:
                    symbol = func_name + "+" + "0x%x" % offset

                group_text = groups[mark_ea]['group']

                font = QtGui.QFont(self.options['font_name'], int(self.options['font_size']))
                mark_item.setFont(0, font)
                mark_item.setFont(1, font)
                mark_item.setFont(2, font)
                mark_item.setFont(3, font)

                mark_item.setText(0, mark_description)
                mark_item.setText(1, "%s" % symbol)
                mark_item.setText(2, group_text)

                if self.options['architecture'] == "32":
                    mark_item.setText(3, "0x%08x" % mark_ea)
                else:
                    mark_item.setText(3, "0x%016x" % mark_ea)

                mark_item.setExpanded(True)
                del(font)
  
            else:
                mark_item = QtGui.QTreeWidgetItem(mark_obj)
                mark_description = data['mark']           

                if is_import:
                    func_top = mark_ea
                else:
                    func_top = function.top(mark_ea)
                
                offset = mark_ea - func_top
                func_name = self.provider.getName(func_top)
                func_name2 = self.provider.demangleName(func_name)
                
                # in case Demangle returns None
                if func_name2: 
                    func_name = func_name2
                
                if len(func_name) == 0:
                    symbol = hex(mark_ea)
                else:
                    symbol = func_name + "+" + "0x%x" % offset

                group_text = ''

                font = QtGui.QFont(self.options['font_name'], int(self.options['font_size']))
                mark_item.setFont(0, font)
                mark_item.setFont(1, font)
                mark_item.setFont(2, font)
                mark_item.setFont(3, font)

                mark_item.setText(0, mark_description)
                mark_item.setText(1, "%s" % symbol)
                mark_item.setText(2, group_text)

                if self.options['architecture'] == "32":
                    mark_item.setText(3, "0x%08x" % mark_ea)
                else:
                    mark_item.setText(3, "0x%016x" % mark_ea)

                mark_item.setExpanded(True)
                del(font)

            # reset anything that was selected prior to the timer de-selecting it
            x = mark_obj.findItems(selected_address, QtCore.Qt.MatchExactly, column=3)
            if x != []:
                x[0].setSelected(True)


    
    def markClicked(self, item, column):
        if self.options['dev_mode']:
            print "[D] markClicked: printing stack:"
            traceback.print_stack()
            
        # get the address from the column
        address_line = item.data(3, 0)
        address = int(address_line, 16)
        database.go(address)

    def localCmtClicked(self, item, column):
        if self.options['dev_mode']:
            print "[D] localCmtClicked: printing stack:"
            traceback.print_stack()
            
        address_line = item.data(2, 0)
        address = int(address_line, 16)
        database.go(address)

    def localMarkClicked(self, item, column):
        if self.options['dev_mode']:
            print "[D] localMarkClicked: printing stack:"
            traceback.print_stack()
            
        address_line = item.data(3, 0)
        address = int(address_line, 16)
        database.go(address)
        

    def historyClicked(self, item, column):
        if self.options['dev_mode']:
            print "[D] historyClicked: printing stack:"
            traceback.print_stack()
            
        col2_data = item.data(1,0)
        try:
            addr = int(col2_data, 16)
            database.go(addr)
            self.refreshMarks(local=True)
            self.refreshCmts()

            if self.show_imports == True:
                self.refreshImports()
            if self.show_strings == True:
                self.refreshStrings()

        except Exception as detail:
            print '[!] Failed to jump to address clicked in history tree, %s' % detail
            pass

        

    def saveHistory(self, default=False, userRefTree=None):
        if self.options['dev_mode']:
            print "[D] saveHistory: printing stack:"
            traceback.print_stack()
            
        if default:
            filename = "default.sess"

        else:
            text = QtGui.QInputDialog().getText(None, "Save History", "Enter filename:")
            filename = str(text[0])

        if filename == "":
            return

        if not filename.endswith(".sess"):
            filename += ".sess"

        print "[+] Saving history object as %s" % filename

        tmp = tempfile.TemporaryFile(mode='wb')
        tmpname = tmp.name
        tmp.close()

        if not userRefTree:
            tree = self.reftree
        else:
            tree = userRefTree

        pickled_file = open(tmpname, "wb")
        pickle.dump(tree, pickled_file)
        pickled_file.close()

        fh = open(tmpname, "rb")
        graphObj_data = fh.read()
        fh.close()

        self.fs.store(filename, graphObj_data)
        self.refreshFilesystem()


    def clearHistory(self):
        if self.options['dev_mode']:
            print "[D] clearHistory: printing stack:"
            traceback.print_stack()
            
        treewidget = self.history_obj
        treewidget.clear()
        self.reftree = RefTree.RefTree(self.master, function_data={})
        self.localview.clear()


    def deleteFile(self):
        if self.options['dev_mode']:
            print "[D] deleteFile: printing stack:"
            traceback.print_stack()
            
        try:
            selected = self.fsTree.selectedItems()[0]
        except:
            print "[!] No file selected"
            self.rightClickMenuActive = False
            return 
        
        delete_me = selected.text(0)

        self.fs.delete(delete_me)

        self.rightClickMenuActive = False

        self.refreshFilesystem()


    def refreshFilesystem(self):
        if self.options['dev_mode']:
            print "[D] refreshFilesystem: printing stack:"
            traceback.print_stack()
            
        names = self.fs.list_files()
        
        self.fsTree.clear()
        
        for n in names:
            if n == '__internal__': continue

            size = len(self.fs.load(n))
            rootWidget = QtGui.QTreeWidgetItem(self.fsTree)
            font = QtGui.QFont(self.options['font_name'], int(self.options['font_size']))
            rootWidget.setFont(0, font)
            rootWidget.setFont(1, font)          
            rootWidget.setText(0, n)
            rootWidget.setText(1, "%d" % size)

            ext = n.split(".")[-1]
            rootWidget.setText(2, "%s" % ext)
            rootWidget.setExpanded(True)


    def applyFile(self):
        if self.options['dev_mode']:
            print "[D] applyFile: printing stack:"
            traceback.print_stack()
            
        try:
            selected = self.fsTree.selectedItems()[0].text(0)
        except:
            print '[!] No file selected'
            self.rightClickMenuActive = False
            return

        if ".marks" in selected[-6:]:
            obj_data = self.fs.load(selected)
            marks,groups = pickle.loads(obj_data)
            
            for mark_ea, mark in marks.iteritems():
                self.master.tag(mark_ea, 'mark', mark['mark'])

            self.refreshMarks()
            
        elif ".cmts" in selected[-5:]:
            obj_data = self.fs.load(selected)
            x = Applier(self, selected, "cmts")
            x.Show("Comments")

        elif ".rcmts" in selected[-6:]:
            obj_data = self.fs.load(selected)
            x = Applier(self, selected, "rcmts")
            x.Show("Repeatable Comments")

        else:
            print "[!] You can only 'Apply' comments, names, or marks"
            self.rightClickMenuActive = False
            return

        self.rightClickMenuActive = False

    def addFile(self):  
        if self.options['dev_mode']:
            print "[D] addFile: printing stack:"
            traceback.print_stack()
            
        filename = str(QtGui.QFileDialog.getOpenFileName(self.fsTree, "Add File", os.sep, "All Files (*.*)")[0])
        
        print "[*] Adding file '%s' from disk to the filesystem." % filename
        try:
            fh = open(filename, 'rb')
        except:
            print "[!] Error loading file %s" % filename
            self.rightClickMenuActive = False
            return
        filename = filename.split("/")[-1]
        self.fs.store_fh(fh, filename)

        self.rightClickMenuActive = False

        self.refreshFilesystem()


    def pushPeers(self):
        if self.options['dev_mode']:
            print "[D] pushPeers: printing stack:"
            traceback.print_stack()
            
        try:
            selected = self.fsTree.selectedItems()[0].text(0)
        except:
            print '[!] No file selected'
            self.rightClickMenuActive = False
            return

        obj_data = self.fs.load(selected)

        for peer in self.peers:
            self.myhost.sendPeer(obj_data, "generic", selected, params=None, idx=peer)

        self.rightClickMenuActive = False


    def mergeSessFiles(self):
        if self.options['dev_mode']:
            print "[D] mergeSessFiles: printing stack:"
            traceback.print_stack()
            
        selected = self.fsTree.selectedItems()
        if len(selected) < 2:
            print "[!] You must have at least 2 session files selected to merge"
            self.rightClickMenuActive = False
            return

        fnames = []
        to_merge = []
        for s in selected:

            txt = str(s.text(0))
            fnames.append(txt)
            if not txt.endswith(".sess"):
                print "[!] You can only merge .sess files"
                self.rightClickMenuActive = False
                return
            try:
                obj_data = self.fs.load(txt)
            except:
                print "[!] Error loading session file %s from filesystem" % txt
                self.rightClickMenuActive = False
                return

            try:
                obj_des = pickle.loads(obj_data)
            except:
                print "[!] Error deserializing session file %s" % txt
                self.rightClickMenuActive = False
                return

            if obj_des != None:
                to_merge.append(obj_des)

        treewidget = self.history_obj
        treewidget.clear()

        self.reftree = RefTree.RefTree(masterGraph=self.master)

        eas = set()
        for obj in to_merge:
            for func in obj.function_data.keys():
                eas.add(func)

        eas = list(eas)

        print "[*] Merging %s, total function count=%d" % (repr(fnames), len(eas))

        for ea in eas:
            self.addToHistory(userEA=ea)
 
        self.tabs.setCurrentWidget(self.historyTab)

        self.rightClickMenuActive = False


    def loadSessFile(self, default=False):
        if self.options['dev_mode']:
            print "[D] loadSessFile: printing stack:"
            traceback.print_stack()
            
        if default:
            selected = "default.sess"

        else:
            try:
                selected = self.fsTree.selectedItems()[0].text(0)
            except:
                print '[!] No file selected'
                self.rightClickMenuActive = False
                return

            
        if selected.endswith(".sess"):

            obj_data = self.fs.load(selected)
            try:
                obj = pickle.loads(obj_data)
            except TypeError:
                print "[!] Tried to load a file %s that may not exist" % selected
                self.addToHistory(add=False)
                self.rightClickMenuActive = False
                return False

            print '[*] Loading session file %s' % selected
            treewidget = self.history_obj
            treewidget.clear()
            self.reftree = RefTree.RefTree(self.master, function_data=obj.function_data)
            self.addToHistory(add=False)
            self.refreshMarks(local=True)
            self.refreshCmts()
            self.tabs.setCurrentWidget(self.historyTab)


        self.rightClickMenuActive = False


    def applyOptions(self):
        if self.options['dev_mode']:
            print "[D] applyOptions: printing stack:"
            traceback.print_stack()
            
        # yeah, we're really doing this
        x = self.dynamicOptions
        txt = "self."
        txt += str(x.toPlainText())
        try:
            y = compile(txt, '<string>', 'exec')
            eval(y)

        # It says on your chart that you're fucked up. Uh, you talk like a fag, and your shit's all retarded.
        except Exception as detail:
            print "[!] Tried setting our options on the fly, but failed: %s" % detail

        print "[*] Successfully updated options"


    def saveToRetVals(self):
        if self.options['dev_mode']:
            print "[D] saveToRetVals: printing stack:"
            traceback.print_stack()
            
        try:
            selected = self.fsTree.selectedItems()[0].text(0)
        except:
            print '[!] No file selected'
            self.rightClickMenuActive = False
            return

        obj_data = self.fs.load(selected)
        try:
            obj = pickle.loads(obj_data)
        except TypeError:
            print "[!] Tried to load a file %s that may not exist" % selected
            self.rightClickMenuActive = False
            return False
        except KeyError:
            obj = obj_data

        fname, ok = QtGui.QInputDialog().getText(None, "Save to variable", "Enter variable name:", QtGui.QLineEdit.Normal, "")

        try:
            print "[*] Saving file %s into global variable dictionary toolbag.toolbag.retvals with key '%s'" % (selected, fname)
            self.global_hook.retvals[fname] = obj
        except Exception as detail:
            print "[!] Failed to set toolbag.toolbag.retvals[%s] to the object data in %s" % (fname, selected)
            if self.options['verbosity'] > 2:
                print detail

        self.rightClickMenuActive = False

    def exportFile(self):
        if self.options['dev_mode']:
            print "[D] exportFile: printing stack:"
            traceback.print_stack()
            
        try:
            selected = self.fsTree.selectedItems()[0].text(0)
        except:
            print '[!] No file selected'
            self.rightClickMenuActive = False
            return

        filename = str(QtGui.QFileDialog.getSaveFileName(self.fsTree, "Export File", os.sep, "All Files (*.*)")[0])
        
        print "[*] Exporting file '%s' to disk as '%s'" % (selected, filename)
        try:
                fh = open(filename, 'wb')
        except:
                print "[!] Error saving file %s" % filename
                self.rightClickMenuActive = False
                return
        data = self.fs.load(selected)
        fh.write(data)
        fh.close()

        self.rightClickMenuActive = False

        self.refreshFilesystem()


    def importCallClicked(self, item, column):
        if self.options['dev_mode']:
            print "[D] importCallClicked: printing stack:"
            traceback.print_stack()
            
        address_line = item.data(2, 0)
        address = int(address_line, 16)
        database.go(address)
        self.refreshImports()


    def refreshImports(self, local=True):
        if self.options['dev_mode']:
            print "[D] refreshImports: printing stack:"
            traceback.print_stack()
            
        self.import_calls.clear()

        if self.show_imports == True:
            self.import_calls.setVisible(True)
        else:
            self.import_calls.setVisible(False)

        # ripped from http://code.google.com/p/idapython/source/browse/trunk/examples/ex_imports.py

        # this should really be a class variable instead of being dynamically generated so often...
        import_dict = {}

        def imp_cb(ea, name, ord):

            if name:
                dname = self.provider.demangleName(name)
                if dname == None:
                    dname = name
                import_dict[iname][dname] = ea
                
            return True

        nimps = self.provider.numImports()
        for i in xrange(0, nimps):
            iname = self.provider.importName(i)
            if not iname: continue
            import_dict[iname] = {}
            self.provider.enumImportNames(i, imp_cb)

        try:
            # this is pretty terrible, fyi. 
            # such attributes should be stored in the database
            # as our schema affords it.
            # 
            # we do so with our analyzers/collectors in the priv8 version 
            addy = self.provider.currentEA()
            funcs = list(self.reftree.listChildren(self.reftree.makeTree(addy)))
        
            proc = self.provider.getArch()

            if proc in ["arm", "ppc", "mips"]:
                idata = "extern"
            elif proc == "pc":
                idata = ".idata"

            try:
                idata = segment.get(idata)
            except KeyError:
                if self.options['verbosity'] > 2:
                    print "[!] Failure looking up import section (%s)" % idata
                return

            idata_bounds = (segment.top(idata), segment.bottom(idata))
            for f in funcs:
                startEA = self.provider.funcStart(f)
                endEA = self.provider.funcEnd(f)

                if startEA == None or endEA == None: 
                    continue

                # loop the obvious instructions *and* function chunks
                all_addresses = list(self.provider.iterInstructions(startEA, endEA))
                all_addresses.extend(self.provider.iterFuncChunks(startEA))
                all_addresses = list(set(all_addresses))

                for instr in all_addresses:

                    disasm = self.provider.getDisasm(instr)
                    if not (disasm.startswith("call") or disasm.startswith("j")):
                        continue
                        
                    unique = set()
                    try:
                        ref = database.down(instr)
                        if ref == []:
                            continue
                        else:
                            for r in ref:
                                # check for .idata section
                                if r >= idata_bounds[0] and r <= idata_bounds[1]:

                                    # check the set
                                    if instr in unique:
                                        continue
                                    else:
                                        unique.add(instr)

                                    # add it
                                    name = self.provider.demangleName(self.provider.getName(r))
                                    if name == None:
                                        name = self.provider.getName(r)

                                    modname = ""
                                    for module, vals in import_dict.iteritems():

                                        for func, addy in vals.iteritems():
                                            if addy == r:
                                                modname = module
                                                break

                                    item = QtGui.QTreeWidgetItem(self.import_calls)
                                    item.setText(0, "%s!%s" % (modname,name))
                                    caller_name = self.provider.demangleName(self.provider.getName(startEA))
                                    if caller_name == None:
                                        caller_name = self.provider.getName(startEA)  
                                    item.setText(1, "%s" % caller_name)

                                    if self.options['architecture'] == "32":
                                        item.setText(2, "0x%08x" % instr)
                                    else:
                                        item.setText(2, "0x%016x" % instr)

                    except Exception as detail:
                        print '[!] Fail1, %s' % detail

        except IndexError:
            pass
        except Exception as detail:
            print '[!] refreshImports, %s' % detail
            raise


    def refreshStrings(self, local=True):
        if self.options['dev_mode']:
            print "[D] refreshStrings: printing stack:"
            traceback.print_stack()
            
        if self.show_strings == True:
            self.string_refs.setVisible(True)
        else:
            self.string_refs.setVisible(False)
        self.string_refs.clear()

        try:
            # this is pretty terrible, fyi. 
            # such attributes should be stored in the database
            # as our schema affords it.
            # 
            # we do so with our analyzers/collectors in the priv8 version 
            addy = self.provider.currentEA()
            funcs = list(self.reftree.listChildren(self.reftree.makeTree(addy)))
            
            self.string_refs.clear()

            for f in funcs:
                startEA = self.provider.funcStart(f)
                endEA = self.provider.funcEnd(f)

                # loop the obvious instructions *and* function chunks
                all_addresses = list(self.provider.iterInstructions(startEA, endEA))
                all_addresses.extend(self.provider.iterFuncChunks(startEA))
                all_addresses = list(set(all_addresses))

                for instr in all_addresses:
                    unique = set()
                    try:
                        ref = database.down(instr)
                        if ref == []:
                            continue
                        else:
                            for r in ref:
                                # check flags
                                res = self.provider.isString(r)
                                if res:
                                    if instr in unique:
                                        continue
                                    else:
                                        unique.add(instr)

                                    value = self.provider.getString(r)
                                    value = value.replace("\n", "\\n ")
                                    
                                    item = QtGui.QTreeWidgetItem(self.string_refs)
                                    item.setText(0, "%s" % value)
                                    caller_name = self.provider.demangleName(self.provider.getName(startEA))
                                    if caller_name == None:
                                        caller_name = self.provider.getName(startEA)  
                                    item.setText(1, "%s" % caller_name)

                                    if self.options['architecture'] == "32":
                                        item.setText(2, "0x%08x" % instr)
                                    else:
                                        item.setText(2, "0x%016x" % instr)

                    except Exception as detail:
                        print '[!] Failed adding a string reference (refreshStrings), %s' % detail

        #except IndexError:
        #    print "INDEXERROR"
        #    pass
        except Exception as detail:
            pass
            #print '[!] refreshStrings, %s' % detail


    def removeNode(self):
        try:
            selected = self.history_obj.selectedItems()[0].text(1)
        except Exception as detail:
            print "[!] You must select a node to perform a query!"
            return

        addy = int(selected, 16)
        try:
            # find addy in self.reftree and remove it
            x = self.reftree.function_data
            self.reftree.function_data = {key: value for key, value in x.items() if key != addy}

            # find addy in the PySide QTreeWidget and remove it
            if self.options['architecture'] == '32':
                occs = self.history_obj.findItems("0x%08x" % addy, QtCore.Qt.MatchExactly, column=1)
            elif self.options['architecture'] == '64':
                occs = self.history_obj.findItems("0x%016x" % addy, QtCore.Qt.MatchExactly, column=1)
            else:
                print "[!] Unknown architecture %s!" % self.options['architecture']
                return

            print "[*] Found %d occurrences of requested node" % len(occs)

            for occ in occs:
                idx = self.history_obj.indexOfTopLevelItem(occ)
                self.history_obj.takeTopLevelItem(idx)

            print "[*] Done removing nodes, refreshing history view"
            self.refreshHistory()

        except Exception as detail:
            print "[!] Error trying to remove node from history: %s" % detail


    def queryGraph(self):
        if self.options['dev_mode']:
            print "[D] queryGraph: printing stack:"
            traceback.print_stack()
            
        try:
            selected = self.history_obj.selectedItems()[0].text(1)
        except Exception as detail:
            print "[!] You must select a node to perform a query!"
            return

        addy = int(selected, 16)

        depth_val = QtGui.QInputDialog().getInt(None, "Query DB", "Depth (positive or negative):")[0]

        # hawt
        new_window = Query(self, addy, depth_val)

        self.new_windows.append(new_window)

        try:
            name = self.provider.demangleName(self.provider.getName(addy))
            if name == None:
                name = database.name(addy)

            if name == None or len(name) == 0:
                if self.options['architecture'] == "32":
                    name = "0x%08x" % addy
                else:
                    name = "0x%016x" % addy

            if self.options['architecture'] == "32":
                new_window.Show("Custom Query - Depth %d from %s (0x%08x)" % (depth_val, name, addy))
            else:
                new_window.Show("Custom Query - Depth %d from %s (0x%016x)" % (depth_val, name, addy))

        except Exception as detail:
            print detail


    def pushMarksToPeers(self):
        if self.options['dev_mode']:
            print "[D] pushMarksToPeers: printing stack:"
            traceback.print_stack()
            
        # XXX: disabled right now? or did i do this w/ 'generic'? ... hmm.
        pass
        marks = self.master.getAttribute('mark')
        groups = self.master.getAttribute('group')

        data = pickle.dumps((marks, groups))

        for peer in self.peers:
            self.myhost.sendPeer(data, "marks", "marks.marks", params=None, idx=peer)
        #mark_obj.clear()
        #for mark_ea, data in marks.iteritems():
        #    self.sendPeer((marks, group), "marks", "marks.marks")
        #    pass

        self.rightClickMenuActive = False


    def gatherStrings(self):
        funcs_uniq = list(set(self.reftree.function_data.keys()))

        # gather all addresses
        all_addresses = []
        for f in funcs_uniq:
            startEA = self.provider.funcStart(f)
            endEA = self.provider.funcEnd(f)

            if startEA == None or endEA == None:
                continue

            # loop the obvious instructions *and* function chunks
            all_addresses.extend(self.provider.iterInstructions(startEA, endEA))
            all_addresses.extend(self.provider.iterFuncChunks(startEA))
            all_addresses = list(set(all_addresses))


        print "[*] Gathering strings across %d functions (%d instructions)" % (len(funcs_uniq), len(all_addresses))

        found = {}
        for instr in all_addresses:
            try:
                ref = database.down(instr)
                if ref == []:
                    continue
                else:
                    for r in ref:
                        # check flags
                        res = self.provider.isString(r)
                        if res:
                            value = self.provider.getString(r)
                            value = value.replace("\n", "\\n ")

                            if found.has_key(instr):
                                continue
                            else:
                                found[instr] = value

                            
            except Exception as detail:
                print '[!] Failed gathering strings: %s' % detail

        print "[*] Gathered %d strings from current history, result:" % len(found.keys())

        for address, stringvalue in found.iteritems():
            if self.options['architecture'] == "32":
                print "[*] 0x%08x: %s" % (address, stringvalue)
            elif self.options['architecture'] == "64":
                print "[*] 0x%016x: %s" % (address, stringvalue)
            else:
                print "[!] Unknown architecture!"

        


    def invokeQueues(self):
        if self.options['dev_mode']:
            print "[D] invokeQueues: printing stack:"
            traceback.print_stack()
            
        try:
            addresses = copy.deepcopy(self.reftree.function_data)
            data = pickle.dumps(addresses)
            for peer in self.peers:
                self.myhost.sendPeer(data, "reftree", "reftree.sess", params=None, idx=peer)
        except Exception as detail:
            print detail
            print '[!] Failed to send data to the queue'
        

    def addEdgeSource(self, userEA=False):
        if self.options['dev_mode']:
            print "[D] addEdgeSource: printing stack:"
            traceback.print_stack()
        
        if not userEA:
            self.edge_source = self.provider.currentEA()
        else:
            self.edge_source = userEA
        
        if self.options['architecture'] == "32":
            print "[*] Set 0x%08x as source of an edge" % self.edge_source
        else:
            print "[*] Set 0x%016x as source of an edge" % self.edge_source

    def addEdgeDest(self, userEA=False):
        if self.options['dev_mode']:
            print "[D] addEdgeDest: printing stack:"
            traceback.print_stack()
        
        if not userEA:
            self.edge_dest = self.provider.currentEA()
        else:
            self.edge_dest = userEA

        if self.options['architecture'] == "32":
            print "[*] Set 0x%08x as destination of an edge" % self.edge_dest
        else:
            print "[*] Set 0x%016x as destination of an edge" % self.edge_dest

        ea_type = self.provider.getFlags(self.edge_dest)

        if self.provider.isCode(ea_type):
            if self.edge_source:
                if self.options['architecture'] == "32":
                    print "[*] Adding an edge from 0x%08x to 0x%08x" % (self.edge_source, self.edge_dest)
                else:
                    print "[*] Adding an edge from 0x%016x to 0x%016x" % (self.edge_source, self.edge_dest)

                # add the edge to both the master and the current reftree
                self.master.addEdge(self.edge_source, self.edge_dest)
                self.reftree.addEdge(self.edge_source, self.edge_dest)
                
                # append a comment (dst) at the src
                cur = self.provider.getComment(self.edge_source)

                com = ""
                if (len(cur) > 0):
                    if self.options['architecture'] == "32":
                        com = cur + "\n" + "0x%08x" % self.edge_dest
                    else:
                        com = cur + "\n" + "0x%016x" % self.edge_dest
                else:
                    if self.options['architecture'] == "32":
                        com = "0x%08x" % self.edge_dest
                    else:
                        com = "0x%016x" % self.edge_dest
                
                self.provider.makeComment(self.edge_source, com)
                self.provider.refreshView()
                
                # add both to history view
                self.addToHistory(userEA=self.edge_dest)
                self.addToHistory(userEA=self.edge_source)

        else:
            print "[*] Asked to add an edge to something in non-code, looking for function pointers..."

            code_addys = []

            # iterate up to 100 dwords
            for head in self.provider.iterInstructions(self.edge_dest, self.edge_dest+(4*100)):
                dref = list(self.provider.dataRefs(head))
 
                if dref == []:
                    break
                    
                else:
                    addy_flags = self.provider.getFlags(dref[0])

                    if (addy_flags & self.provider.FUNC_FLAG) != 0:
                        code_addys.append(dref[0])

                    else:
                        break

            if len(code_addys) > 1:
                print "[*] Found %d code pointers to add as destinations" % len(code_addys)

            if self.edge_source:
                self.addToHistory(userEA=self.edge_source)

                comment = ""

                for addy in code_addys:
                    self.master.addEdge(self.edge_source, addy)
                    self.addToHistory(userEA=addy)
                    
                    name = self.provider.getName(addy)
                    demangled_name = self.provider.demangleName(name)

                    if demangled_name:
                        comment += "%s\n" % demangled_name
                    else:
                        comment += "%s\n" % name

                self.provider.makeComment(self.edge_source, comment)

        return


    def addEdge(self):
        if self.options['dev_mode']:
            print "[D] addEdge: printing stack:"
            traceback.print_stack()
            
        src = QtGui.QInputDialog().getText(None, "Add Edge", "Enter source address:")
        try:
            src = int(src[0], 16)
        except ValueError:
            return
        
        self.addToHistory(userEA=src)

        dst = QtGui.QInputDialog().getText(None, "Add Edge(s)", "Enter destination address(es), optionally separated by commas:")

        try:
            if "," in dst[0]:
                addys = dst[0].split(",")
            else:
                addys = [dst[0]]
            
            for addy in addys:
                dst = int(addy, 16)
                self.master.addEdge(src, dst)
                self.addToHistory(userEA=dst)

            print '[*] Added %d edges' % len(addys)

        except Exception as detail:
            print "[!] You gone dun brokes it, %s" % detail

        self.addToHistory()


    def toggleFileSystemTab(self):
        if self.options['dev_mode']:
            print "[D] toggleFileSystemTab: printing stack:"
            traceback.print_stack()
            
        done = False
        for i in xrange(0, self.tabs.count()):
            t = self.tabs.widget(i)
            if t:
                if t.windowTitle() == "File System":
                        self.tabs.removeTab(i)
                        done = True

        if not done:
            self.tabs.addTab(self.fsTab, "File System")


    def toggleUserScriptsTab(self):
        if self.options['dev_mode']:
            print "[D] toggleUserScriptsTab: printing stack:"
            traceback.print_stack()
            
        done = False
        for i in xrange(0, self.tabs.count()):
            t = self.tabs.widget(i)
            if t:
                if t.windowTitle() == "Scripts":
                        #self.view_menu.activeAction().setChecked(False)
                        self.tabs.removeTab(i)
                        done = True

        if not done:
            self.tabs.addTab(self.userScriptsTab, "Scripts")


    def togglePathfindingTab(self):
        if self.options['dev_mode']:
            print "[D] togglePathfindingTab: printing stack:"
            traceback.print_stack()
            
        done = False
        for i in xrange(0, self.tabs.count()):
            t = self.tabs.widget(i)
            if t:
                if t.windowTitle() == "Pathfinding":
                        #self.view_menu.activeAction().setChecked(False)
                        self.tabs.removeTab(i)
                        done = True

        if not done:
            self.tabs.addTab(self.pathFindingTab, "Pathfinding")


    def toggleOptionsTab(self):
        if self.options['dev_mode']:
            print "[D] toggleOptionsTab: printing stack:"
            traceback.print_stack()
            
        done = False
        for i in xrange(0, self.tabs.count()):
            t = self.tabs.widget(i)
            if t:
                if t.windowTitle() == "Options":
                        #self.view_menu.activeAction().setChecked(False)
                        self.tabs.removeTab(i)
                        done = True

        if not done:
            self.tabs.addTab(self.optionsTab, "Options")


    def viewSplash(self):
        if self.options['dev_mode']:
            print "[D] viewSplash: printing stack:"
            traceback.print_stack()
            
        # fuckin' python
        x = __import__("utils")
        reload(x)
        return


    def toggleQueueTab(self):
        if self.options['dev_mode']:
            print "[D] toggleQueueTab: printing stack:"
            traceback.print_stack()
            
        done = False
        for i in xrange(0, self.tabs.count()):
            t = self.tabs.widget(i)
            if t:
                if t.windowTitle() == "Queues":
                    self.tabs.removeTab(i)
                    done = True

        if not done:
            self.tabs.addTab(self.queueTab, "Queues")


    def addQueue(self):   
        if self.options['dev_mode']:
            print "[D] addQueue: printing stack:"
            traceback.print_stack()

        if not self.peerRadio.isChecked() and not self.serverRadio.isChecked() and not self.agentRadio.isChecked():
            print "[!] You must select either Server, Agent, or Peer when adding...stuff."
            return False

        key  = self.queueKeyObj.text()
        host = self.queueHostObj.text()
        port = int(self.queuePortObj.text())

        if port <= 1024 or port >= 65535:
            print "[!] Port number is invalid. Must be >= 1024 and <= 65535."
            return False

        if self.serverRadio.isChecked():

            # check if there's already a server
            count = self.queueList.topLevelItemCount()
            for i in xrange(0, count):
                item = self.queueList.topLevelItem(i)
                queue_type = item.text(2)

                if not item.isHidden():
                    if queue_type == "SERVER":
                        print "[!] There already exists a server object, delete it to add a new one."
                        return 

	    #If this isn't windows32, this will fail. So let's initialize pypath
	    pypath = ''
            if sys.platform == 'win32':
                pypath = self.options['pypath_win32']
            elif sys.platform == 'darwin' or sys.platform == 'linux':
                # XXX: not tested
                pypath = self.options['pypath_linux']

            server = self.options['toolbag_dir'] + os.sep + "server.py"
            print "[*] Setting up Server queue"
            try:
                # i am 12 and what is this?
                self.myhost = toolbagcomm.ToolbagHost(pypath, server, host, port, key)
            except Exception as detail:
                print detail
                return

            item = QtGui.QTreeWidgetItem(self.queueList)
            item.setText(0, "%s" % host)
            item.setText(1, "")
            item.setText(2, "SERVER")
            item.setText(3, "")

            self.queueServer = item

            self.timer2 = timercallback_t2(self)

        elif self.peerRadio.isChecked():

            try:
                xxx = self.myhost.proc
            except:
                print "[!] You must add a server before adding a peer!"
                return

            try:
                peer_id = self.myhost.addPeer(host, port, key)

                # send a greeting to the peer
                user = getpass.getuser()
                self.myhost.sendPeer("User '%s' subscribed to your queue." % user, "greeting", "greetz.txt", params=None, idx=peer_id)

                self.peers.append(peer_id)
            except Exception as detail:
                print detail
                return

            item = QtGui.QTreeWidgetItem(self.queueList)
            item.setText(0, "%s" % host)
            item.setText(1, "%d" % port)
            item.setText(2, "PEER")
            item.setText(3, "")

            print "[*] Added a peer at %s" % host

        elif self.agentRadio.isChecked():
            try:
                xxx = self.myhost.proc
            except:
                print "[!] You must add a server before adding an agent!"
                return

            try:
                #socket.setdefaulttimeout(2)
                socket.setdefaulttimeout(None)
                self.myhost.addAgent(host, port, key)
                print "[*] Sending agent a greeting"
                self.myhost.agent.connect()
                self.myhost.agent.printmsg("Toolbag Connected")

            except Exception as detail:
                print detail
                socket.setdefaulttimeout(None)
                return

            item = QtGui.QTreeWidgetItem(self.queueList)
            item.setText(0, "%s" % host)
            item.setText(1, "%d" % port)
            item.setText(2, "AGENT")
            item.setText(3, "")

            print "[*] Added an agent at %s" % host


    def OnClose(self, form):
        if self.options['dev_mode']:
            print "[D] OnClose: printing stack:"
            traceback.print_stack()
            
        try:
            comment_dict = pickle.loads(self.fs.load("default.cmts"))
        except:
            comment_dict = {}

        self.fs.store("default.cmts", pickle.dumps(comment_dict))

        try:
            rcomment_dict = pickle.loads(self.fs.load("default.rcmts"))
        except:
            rcomment_dict = {}

        self.fs.store("default.rcmts", pickle.dumps(rcomment_dict))

        # store the master graph
        fh = open(self.options['full_file_name'], 'wb')
        pickle.dump(self.master, fh)
        fh.close()

        try:
            if self.provider.__module__ == "toolbag.providers.ida":
                self.provider.unregisterTimer(self.timer1.obj)
                self.provider.unregisterTimer(self.timer2.obj)
                del self.timer1
        except AttributeError:
            pass

        print "[*] Timer objects deleted"

        socket.setdefaulttimeout(0.5)

        try:
            self.myhost.end()
            print "[*] Server object deleted"
        except Exception as detail:
            pass

        try:
            del self.myhost
        except:
            pass

        # save the default.sess
        self.saveHistory(default=True)

        # close the database
        #self.db.close()

        # delete objects that could cause IDA to crash
        #del(self.db)
        del(self.fs)
        del(self.reftree)

        # delete any Query objects we created
        # prevents IDA from crashing due to a dangling reference
        '''
        for c in self.new_windows:
            try:
                del(c)
            except:
                pass
        '''
        # remove the UI hooks
        self.ui_hook.unhook()
        #del self.ui_hook

        print "[*] Toolbag has been shut down"


    def timerthing(self):
        if self.options['dev_mode']:
            print "[D] timerthing: printing stack:"
            traceback.print_stack()
            
        self.timer1 = timercallback_t([self.refreshMarks, self.refreshStrings, self.refreshImports, self.refreshHistory])


    def deleteQueue(self):
        if self.options['dev_mode']:
            print "[D] deleteQueue: printing stack:"
            traceback.print_stack()
            
        selected = self.queueList.selectedItems()[0]

        # "SERVER" or "AGENT"
        queue_type = selected.text(2)

        # if we were asked to delete a server, but there's a peer, deny it
        if queue_type == "SERVER":

            count = self.queueList.topLevelItemCount()
            for i in xrange(0, count):
                item = self.queueList.topLevelItem(i)
                queue_type = item.text(2)

                if not item.isHidden():
                    if queue_type == "PEER":
                        print "[!] There exists a peer object, delete it before deleting the server."
                        self.rightClickMenuActive = False
                        return 
            try:
                socket.setdefaulttimeout(1)
                self.myhost.end()
                print "[*] Server object deleted"
            except Exception as detail:
                pass
            if self.options['verbosity'] > 2:
                print detail

            try:
                del self.myhost
            except:
                pass

            socket.setdefaulttimeout(None)


        elif queue_type == "AGENT":
           self.myhost.delAgent()

           # except Exception as detail:
           #     print "[!] Failed to delete agent: %s" % detail
           #     return

        # XXX the shadow knows
        selected.setHidden(True)

        self.rightClickMenuActive = False

        return


    def rejectQueueData(self):
        if self.options['dev_mode']:
            print "[D] rejectQueueData: printing stack:"
            traceback.print_stack()
            
        try:
            selected_id = self.queueList.selectedItems()[0].text(3)
        except:
            print "[!] No file selected"
            self.rightClickMenuActive = False
            return 

        item = self.peerdata.fetchitem(int(selected_id))
        objname = self.peerdata.fetchattr(item, "objname")
        objtype = self.peerdata.fetchattr(item, "objtype")
        msg = self.peerdata.fetchattr(item, "data")

        self.queueList.selectedItems()[0].setHidden(True)
        #self.queueList.removeItemWidget(self.queueList.selectedItems()[0], 0)

        self.rightClickMenuActive = False

        self.refreshFilesystem()
        
        self.peerdata.remove(msg)


    def saveQueueData(self):
        if self.options['dev_mode']:
            print "[D] saveQueueData: printing stack:"
            traceback.print_stack()
            
        try:
            selected_id = self.queueList.selectedItems()[0].text(3)
        except:
            print "[!] No file selected"
            self.rightClickMenuActive = False
            return 

        item = self.peerdata.fetchitem(int(selected_id))
        objname = self.peerdata.fetchattr(item, "objname")
        objtype = self.peerdata.fetchattr(item, "objtype")
        msg = self.peerdata.fetchattr(item, "data")

        fname, ok = QtGui.QInputDialog().getText(None, "Store Object", "Enter filename:", QtGui.QLineEdit.Normal, objname)

        if fname == None or not ok:
            self.rightClickMenuActive = False
            return

        print "[*] Storing %s of type %s" % (objname, objtype)

        if objtype == "reftree":
            addys = pickle.loads(msg)
            to_pickle = RefTree.RefTree(masterGraph=self.master, function_data=addys)
            print "[*] Created RefTree from queue data"

            tmp = tempfile.TemporaryFile(mode='wb')
            tmpname = tmp.name
            tmp.close()

            pickled_file = open(tmpname, "wb")
            pickle.dump(to_pickle, pickled_file)
            pickled_file.close()

            fh = open(tmpname, "rb")
            obj_data = fh.read()
            fh.close()

        elif objtype == "marks":
            #self.sendPeer((marks, group), "marks", "marks.marks")
            marks,groups = pickle.loads(msg)

            '''
            for mark_ea, mark in marks.iteritems():
                self.db.tag(mark_ea, 'mark', mark['mark'])

            self.refreshMarks(self.db)
            '''

            obj_data = msg

            '''
            if len(groups) == 0:
                self.db_obj.tag(ea, 'mark', description)
            else:
                self.db_obj.tag(ea, 'mark', description)
                self.db_obj.tag(ea, 'group', group)
            '''

        elif objtype == "agentresults":
           obj_data = msg 

        # otherwise just pickle the object to disk
        else:
            obj_data = msg

        self.queueList.selectedItems()[0].setHidden(True)
        #self.queueList.removeItemWidget(self.queueList.selectedItems()[0], 0)

        self.fs.store(fname, obj_data)

        self.rightClickMenuActive = False

        self.refreshFilesystem()

        self.peerdata.remove(msg)


    def pullQueueData(self, shiftfocus=True):
        if self.options['dev_mode']:
            print "[D] pullQueueData: printing stack:"
            traceback.print_stack()
            
        print "[*] Pulling data from the queue"
    
        if shiftfocus:
            try:
                self.tabs.setCurrentWidget(self.queueTab)
            except Exception as detail:
                print detail
        

        try:
            socket.setdefaulttimeout(3)
            networkdata = self.myhost.recv()
            pkt = toolbagcomm.ToolbagPacket(networkdata)
            socket.setdefaulttimeout(None)
            
            if pkt.opcode == "greeting":
                self.showBalloon("%s (%s)" % (pkt.msg, pkt.ip), clickable=False)
                return

            #racksonracksonracks
            elif pkt.opcode == "agentresults":
                self.showBalloon("Agent results for %s" % pkt.filename, clickable=False)
                self.global_hook.retvals[pkt.filename]=pickle.loads(pkt.msg)
                return

            # IP : objname, objtype, data
            new_id = self.peerdata.newid()
            self.peerdata.add(pkt.ip, pkt.filename, pkt.opcode, pkt.msg, new_id)

            peer_data_widget = QtGui.QTreeWidgetItem(self.queueServer)
            peer_data_widget.setExpanded(True)
            self.queueServer.setExpanded(True)
            peer_data_widget.setText(0, "%s" % pkt.ip)
            peer_data_widget.setText(1, "%s" % pkt.filename)
            peer_data_widget.setText(2, "%s" % pkt.opcode)
            peer_data_widget.setText(3, "%d" % new_id)

        except Exception as detail:
            print detail
            raise
            return


    def showBalloon(self, msg, clickable=True):
        if self.options['dev_mode']:
            print "[D] showBalloon: printing stack:"
            traceback.print_stack()
            
        self.message = QtGui.QSystemTrayIcon()
        self.message.show()
        self.message.showMessage("IDA Pro - Toolbag", msg, msecs=5000)
        if clickable:
            self.pullQueueData(shiftfocus=False)
            # removing the need to click the balloon
            #self.message.messageClicked.connect(self.pullQueueData)


    def get_refcounts(self):
        if self.options['dev_mode']:
            print "[D] get_refcounts: printing stack:"
            traceback.print_stack()
            
        import types
        d = {}
        sys.modules
        # collect all classes
        for m in sys.modules.values():
            for sym in dir(m):
                o = getattr (m, sym)
                if type(o) is types.ClassType:
                    d[o] = sys.getrefcount (o)

                    for sym in dir(o):
                        ox = getattr(o, sym)
                        if type(ox) is types.ClassType:
                            d[ox] = sys.getrefcount(ox)
        # sort by refcount
        pairs = map (lambda x: (x[1],x[0]), d.items())
        pairs.sort()
        pairs.reverse()
        return pairs


###############################################################################

class timercallback_t(object):
    def __init__(self, funcptrs):
        self.funcptrs = funcptrs
        self.provider = ida.IDA()
        
        self.interval = 1000

        if self.provider.__module__ == "toolbag.providers.ida":
            self.obj = self.provider.registerTimer(self.interval, self)
        
        if self.obj is None:
            raise RuntimeError, "Failed to register timer"

    def __call__(self):

        # removing, because if you have enough global marks to necessitate a scrollbar, 
        # when this fires it will scroll that back to the top, which is annoying
        for ptr in self.funcptrs:
            ptr(local=True)
        return self.interval

    def __del__(self):
        print("Timer object disposed %s" % id(self))


class timercallback_t2(object):
    def __init__(self, ui_obj):
        self.ui_obj = ui_obj
        self.provider = ida.IDA()

        self.msgshown = 0
        self.interval = self.ui_obj.options['queue_interval']

        if self.provider.__module__ == "toolbag.providers.ida":
            self.obj = self.provider.registerTimer(self.interval, self)

        if self.obj is None:
            raise RuntimeError, "Failed to register timer"

    def __call__(self):
        try:
            x = None
            try:
                x = self.ui_obj.myhost.poll()
            except Exception as detail:
                print "[!] It appears a server went down, %s" % detail
                socket.setdefaulttimeout(1)
                self.ui_obj.myhost = None
                return 0

                # XXX: remove it from the UI

            if x != None and x != False:
                socket.setdefaulttimeout(None)

                # only show the message every 10*interval
                if self.msgshown % self.ui_obj.options['queue_reminder'] == 0:

                    print "[*] Data in the queue"

                    try:
                        if self.msgshown != 0:
                            self.ui_obj.showBalloon("There is still pending data in the queue")
                        else:
                            self.ui_obj.showBalloon("Received data in the queue")
                    except Exception as detail:
                        print "Failed showing balloon: %s" % detail

                self.msgshown += 1
                
            else:
                self.msgshown = 0

        except Exception as detail:
            print detail
            #raise Exception

        return self.interval

    def __del__(self):
        print("Timer object disposed %s" % id(self))

########NEW FILE########
__FILENAME__ = userconfig
# userconfig.py
#
# for public release, 2012
#
# Aaron Portnoy

# use this to override config.py settings

# for colors, see: # http://www.w3.org/TR/SVG/types.html#ColorKeywords
options = { 
               'example'          : True,
               'dev_mode'		  : False,
               'coloring_enabled' : True,
               'enabled_tabs'           : ["Scripts"],
          }    
########NEW FILE########
__FILENAME__ = utils
from PySide import QtGui

from config import *

splash_image = options['ida_user_dir'] + os.sep + "rsrc" + os.sep + "splash.png"
pixmap = QtGui.QPixmap(splash_image)
splash = QtGui.QSplashScreen(pixmap)
splash.show()
########NEW FILE########
__FILENAME__ = color_all_basicblocks
# colors yay

import idc
import idaapi
import idautils

from PySide import QtGui


diag = QtGui.QColorDialog()

x = diag.getColor()
r,g,b,a = x.getRgb()

# ida does BGR instead of RGB
rgb = int("%02x%02x%02x" % (b, g, r), 16)

func_item = idaapi.get_func(idc.ScreenEA())

for head in idautils.Heads(func_item.startEA, func_item.endEA):
    idc.SetColor(head, idc.CIC_ITEM, rgb)

idaapi.refresh_idaview_anyway()
########NEW FILE########
__FILENAME__ = CopyEA
# CopeEA.py
#
# for public release, 2012
#
# Peter Vreugdenhil


import idaapi
import idc
import ctypes
import re

print "Importing CopyEA"

def Paste( data ):
  strcpy = ctypes.cdll.msvcrt.strcpy
  ocb = ctypes.windll.user32.OpenClipboard    #Basic Clipboard functions
  ecb = ctypes.windll.user32.EmptyClipboard
  gcd = ctypes.windll.user32.GetClipboardData
  scd = ctypes.windll.user32.SetClipboardData
  ccb = ctypes.windll.user32.CloseClipboard
  ga = ctypes.windll.kernel32.GlobalAlloc    # Global Memory allocation
  gl = ctypes.windll.kernel32.GlobalLock     # Global Memory Locking
  gul = ctypes.windll.kernel32.GlobalUnlock
  GMEM_DDESHARE = 0x2000   
  ocb(None) # Open Clip, Default task
  ecb()
  hCd = ga( GMEM_DDESHARE, len(data)+1 )
  pchData = gl(hCd)
  strcpy(ctypes.c_char_p(pchData),data)
  gul(hCd)
  scd(1,hCd)
  ccb()


def CopyEA():
  myModuleName = idc.GetInputFile()
  MyModuleShortName = re.sub(r'\.[^.]*$','',myModuleName)
  myModuleBase = idaapi.get_imagebase()
  myOffset = idc.ScreenEA() - myModuleBase
  pasteStr = "bp !%s + 0x%x" % (MyModuleShortName, myOffset)
  print pasteStr
  Paste(pasteStr)


def start_up():
  print "CopyEA Start_up is started..."
  COPYHOTKEY = 'z'

  print "Press '%s' to copy location of effective address to clipboard()"%COPYHOTKEY
  idaapi.CompileLine('static _copy_ea() { RunPythonStatement("CopyEA()"); }')
  idaapi.add_hotkey(COPYHOTKEY,CopyEA)

start_up()

########NEW FILE########
__FILENAME__ = highlight_calls
# highlight_calls.py
#
# for public release, 2012
#
# Aaron Portnoy

from idautils import XrefsFrom
from idaapi import fl_CN as call_near, fl_CF as call_far
from providers import ida

provider = ida.IDA()

startEA = provider.funcStart(provider.currentEA())
endEA = provider.funcEnd(provider.currentEA())

all_addresses = list(provider.iterInstructions(startEA, endEA))
all_addresses.extend(provider.iterFuncChunks(startEA))
all_addresses = list(set(all_addresses))

for head in all_addresses:
  for xref in XrefsFrom(head):
    if xref.type == call_near or xref.type == call_far:
      provider.setColor(head, 0x0000FF)

provider.refreshView()
########NEW FILE########
__FILENAME__ = sample
# sample.py
#
# for public release, 2012
#
# Aaron Portnoy


print '[*] Hello from sample.py'

########NEW FILE########
__FILENAME__ = simple_dynamic_edges
# simple_dynamic_edges.py
#
# for public release, 2012
#
# Aaron Portnoy




from idautils import XrefsFrom
from idaapi import fl_CN as call_near, fl_CF as call_far

from PySide import QtGui, QtCore
from providers import ida

provider = ida.IDA()

def init():
    DynamicCallDiag(ui_obj)
	

class DynamicCallDiag(QtGui.QDialog):
    def __init__(self, ui_obj, parent=None):
        super(DynamicCallDiag, self).__init__(parent)

        self.ui_obj = ui_obj
        self.field1 = QtGui.QInputDialog()
        #self.field2 = QtGui.QInputDialog()
        self.field1.setOption(QtGui.QInputDialog.NoButtons)
        #self.field2.setOption(QtGui.QInputDialog.NoButtons)
        self.field1.setLabelText("Properties of destination initialization:")
        #self.field2.setLabelText("Optional Group:")

        self.field1.keyPressEvent = self.keyPressEvent
        #self.field2.keyPressEvent = self.keyPressEvent
        
        confirm = QtGui.QPushButton("Go")
        confirm.clicked.connect(self.add_dyn_edges)

        layout = QtGui.QVBoxLayout()
        #layout.addWidget(self.field2)
        layout.addWidget(self.field1)
        
        layout.addWidget(confirm)
        
        self.setLayout(layout)
        self.setWindowTitle("Dynamic Edges")
        self.setWindowModality(QtCore.Qt.ApplicationModal)
        self.show()


    def add_dyn_edges(self):
       
        properties = filter(lambda x: len(x) > 0 and x or None, self.field1.textValue().strip(",").encode('UTF-8').split(" "))

        currentEA = provider.currentEA()
        startEA   = provider.funcStart(currentEA)
        endEA     = provider.funcEnd(currentEA)
        
        all_addresses = list(provider.iterInstructions(startEA, endEA))
        all_addresses.extend(provider.iterFuncChunks(startEA))
        all_addresses = list(set(all_addresses))

        res = {}
        for head in all_addresses:
            disasm = filter(lambda z: z != None and z, map(lambda y: len(y) > 0 and y.strip(",") or None, provider.getDisasm(head).split(" ")))

            success = True
            for i in xrange(0, len(properties)):
                token = properties[i]

                if len(token) > 0:
                    if token != disasm[i]:
                        success = False
                        break


            if success:
            	sub_xref = None
            	xrefs = list(XrefsFrom(head))
            	for x in xrefs:
            		if x.type == 1:
            			sub_xref = x.to
            			break
                if len(xrefs) > 0 and sub_xref != None:
                    res[head] = sub_xref

        for address, dest in res.iteritems():
            try:
                provider.makeFunc(dest)
            except Exception as detail:
                if self.ui_obj.options['architecture'] == '32':
                    print "[!] Unable to MakeFunction at 0x%08x" % dest
                elif self.ui_obj.options['architecture'] == '64':
                    print "[!] Unable to MakeFunction at 0x%016x" % dest
                break

            if self.ui_obj.options['architecture'] == '32':
                print "[*] Found: 0x%08x %s with a cross-reference to 0x%08x" % (address, provider.getDisasm(address), dest)
            elif self.ui_obj.options['architecture'] == '64':
                print "[*] Found: 0x%08x %s with a cross-reference to 0x%016x" % (address, provider.getDisasm(address), dest)

            self.ui_obj.addEdgeSource(userEA=currentEA)
            self.ui_obj.addEdgeDest(userEA=dest)
        
        self.done(1)
        self.hide()

        return res

########NEW FILE########
__FILENAME__ = switchViewer
import idautils
import idaapi
import idc

switches = []

for f in idautils.Functions():
    func = idaapi.get_func(f)

    for h in idautils.Heads(func.startEA, func.endEA):
        res = idaapi.get_switch_info_ex(h)
        if res != None:
            # number of cases
            num_cases = res.get_jtable_size()
        else:
            continue

        print '0x%08x: switch (%d cases)' % (h, num_cases)

        # get cases
        xrefs = idautils.CodeRefsFrom(h, 1)


        interesting_calls = []
            
        switches.append((h, num_cases, interesting_calls))




# http://dvlabs.tippingpoint.com/blog/2011/05/11/mindshare-extending-ida-custviews
class SwitchViewer(idaapi.simplecustviewer_t):

    def __init__(self, data):

        # data should be a 3-tuple
        #
        # (address, number of cases, list of interesting calls)
        self.switches = data

        # we define a dictionary, keyed by address
        # values will be the interesting calls
        self.calls = {}
        self.Create()
        print "Launching Switch subview..."
        self.Show()

    def Create(self):
        title = "Switches"

        idaapi.simplecustviewer_t.Create(self, title)
        comment = idaapi.COLSTR("; Double-click to follow", idaapi.SCOLOR_BINPREF)

        self.AddLine(comment)

        #comment = idaapi.COLSTR("; Hover for preview", idaapi.SCOLOR_BINPREF)
        comment = ""

        self.AddLine(comment)

        for item in self.switches:
            addy = item[0]
            cases = item[1]
            interesting_calls = item[2]
            self.calls[addy] = interesting_calls

            address_element = idaapi.COLSTR("0x%08x: " % addy, idaapi.SCOLOR_REG)
            value_element = idaapi.COLSTR("%s" % cases, idaapi.SCOLOR_STRING)
            line = address_element + value_element

            self.AddLine(line)

        return True

    def OnDblClick(self, shift):
        line = self.GetCurrentLine()
        if "0x" not in line: return False

        # skip COLSTR formatting, find address

        addy = int(line[2:line.find(":")], 16)

        idc.Jump(addy)
        return True 

    def OnHint(self, lineno):
        if lineno < 2: return False
        else: lineno -= 2

        line = self.GetCurrentLine()

        if "0x" not in line: return False

        # skip COLSTR formatting, find address

        addy = int(line[2:line.find(":")], 16)

        calls = self.calls[addy]

        res = ""
        for line in calls:
            res += idaapi.COLSTR(line + "\n", idaapi.SCOLOR_DREF) 

        return (1, res)

SwitchViewer(switches)

########NEW FILE########
__FILENAME__ = vtable2structs
# vtable2structs.py
#
# for public release, 2012
#
# Aaron Portnoy


import idc
import idaapi
import idautils

from providers import ida

provider = ida.IDA()

text_start   = provider.segByBase(provider.segByName(".text"))
text_end     = provider.segEnd(provider.segByBase(provider.segByName(".text")))
vtable_start = 0


def myDemangle(addy):
    # XXX edit here for your custom demangling
    return idc.Name(addy)


jumpahead      = None
vtable_entries = []

vtables = {}

for head in idautils.Heads(text_start, text_end):

    if jumpahead != None:
        if head < jumpahead: 
            continue

    name = idc.Demangle(idc.Name(head), 0)

    if not name: continue

    if "vftable" in name:
        vtable_start = head

        # ghetto way to strip the "const foo::bar::`vftable`"
        name = name.split(" ")[1].split("::")[0]
        vtables[name] = []
    else:
        continue

    vtable_entries = []

    # XXX: max delta of 100 vtable entries, should be enough?
    for xhead in idautils.Heads(vtable_start, vtable_start+(4*100)):
        dref = list(idautils.DataRefsFrom(xhead))

        if dref == []:
            pass
        else:
            addy_flags = idc.GetFlags(dref[0])
            
            if (addy_flags & idc.FF_FUNC) != 0:
                vtable_entries.append(dref[0])

            else:
                vtable_start = 0
                jumpahead = xhead
                break

    if len(vtable_entries) > 1:
        vtables[name] = map(lambda x: myDemangle(x), vtable_entries)
  

###################################
# now create the structures
vcount = 0
ecount = 0
for k, vals in vtables.iteritems():
    struct_id = idc.AddStrucEx(-1, k, 0)
    vcount += 1
    tcount = 0 # help fix collisions
    for v in vals:
        ecount += 1
        ret = idc.AddStrucMember(struct_id, v, -1, idc.FF_DWRD|idc.FF_1OFF, -1, 4, -1, 0, idc.REF_OFF32)
        if ret == -1:    #IF we were unable to create the member due to a pre-existing same name, add a counter
            tcount += 1  # to the end and try again
            idc.AddStrucMember(struct_id, v+str(tcount), -1, idc.FF_DWRD|idc.FF_1OFF, -1, 4, -1, 0, idc.REF_OFF32)
        elif ret != 0:
            print "failed to create this member: %s"%v

print "[*] Created %d structures with a total of %d members" % (vcount, ecount)
########NEW FILE########
__FILENAME__ = netcat-hit-trace
# testTask.py
#
# for public release, 2012
#
# Brandon Edwards


import os
import sys
import socket
import struct
import binascii
import time
import pickle
import toolbagcomm
from multiprocessing import Process

sys.path.append(os.getcwd()+os.sep+"dbg")


class RemoteTask:
    def __init__(self, fname, agentdata, serverdata):
        self.fname = fname
        self.agentdata = agentdata
        self.serverdata = serverdata

        self.ip = agentdata[0]
        self.port = agentdata[1]
        self.key = agentdata[2]

        self.serverip = serverdata[0]
        self.serverport = serverdata[1]
        self.serverkey = serverdata[2]

        self.arguments = None
        #self.agentdata = agentdata
        #ToolbagTask.ToolbagTask.__init__(self, agentdata, serverdata)

    def setArguments(self, arguments):
        self.arguments = arguments
        print "[*] Arguments are", self.arguments

    def runProcess(self, targetfunc, arguments):
        print "[*] args:", arguments

        runproc = Process(target=targetfunc, args=arguments)
        runproc.start()
        #llofthethings["trace_process"]=runproc
    
    def executeTrace(self, cmdline, startVA):
        import vtrace
        import vdb.stalker as stalker
        print "[*] executeTrace: %s %s" % (cmdline, startVA)
        self.trace = vtrace.getTrace()
        self.trace.execute(cmdline)
        self.trace.setMode("RunForever", True)
#        stalker.addStalkerEntry(self.trace, 0x00403047)
        stalker.addStalkerEntry(self.trace, int(startVA, 16))

        while self.trace.isAttached():
            self.trace.run()

        hits = stalker.getStalkerHits(self.trace)

        for hit in hits:
            print "[*] hit: %08x" % hit

        data = pickle.dumps(hits)
        self.sendResults(data)

    def sendResults(self, results):
        queue = toolbagcomm.QueueClient(self.serverip, self.serverport, self.serverkey)
        header = (self.ip, self.port, self.key, "agentresults", "trackrecv", None)
        packet = (header, results)
        queue.send(packet)

    # override run() to do something
    def run(self):
       self.runProcess(self.executeTrace, self.arguments) 


class ToolbagTask:
    def __init__(self, fname, agentdata, serverdata):
        self.fname = fname
        self.agentdata = agentdata
        self.serverdata = serverdata

        self.ip = agentdata[0]
        self.port = agentdata[1]
        self.key = agentdata[2]

        self.serverip = serverdata[0]
        self.serverport = serverdata[1]
        self.serverkey = serverdata[2]

        self.arguments = None
        #self.agentdata = agentdata
        #ToolbagTask.ToolbagTask.__init__(self, agentdata, serverdata)

    def setArguments(self, arguments):
        self.arguments = arguments
        print "[*] Arguments are", self.arguments

    def process(self, ui_obj):
        hits = ui_obj.global_hook.retvals["trackrecv"]
        print "[*] size of hits is: %i" % len(hits)
        for hit in hits:
            print "[*] Hit Address: 0x%x" % hit
            
        ui_obj.highlightAddressList(hits)

    def run(self, ui_obj):
        agent=ui_obj.myhost.agent
        # send file to agent
        # get file data 

        fd = open(ui_obj.options['vtrace_scripts_dir'] + os.sep + self.fname, "rb")
        fdata = fd.read()
        fd.close()
        print "[*] Sending script to Agent"
        agent.connect()
        agent.writeFile(self.fname, fdata)

        # load module remotely
        print "[*] Remotely loading module"
        modulename = self.fname.split(".py")[0]
        agent.loadmodule(modulename)

        print "[*] Instantiating remote task"
        agentmodule = agent.__getattr__(modulename)
        agent.remoteTask = agentmodule.RemoteTask(self.fname, agent.agentData, ui_obj.myhost.serverData)
        agent.remoteTask.setArguments(agent.toolbagTask.arguments)

        print "[*] Running task on Agent"
        agent.remoteTask.run()
    
    def prep(self, ui_obj):
        # test QtGui
        from PySide import QtCore, QtGui

        class PrepDialog(QtGui.QDialog):
            def __init__(self, ui_obj, fname, parent=None):
                super(PrepDialog, self).__init__(parent)

                self.fname = fname
                self.ui_obj = ui_obj
                self.field1 = QtGui.QInputDialog()
                self.field2 = QtGui.QInputDialog()
                self.field1.setOption(QtGui.QInputDialog.NoButtons)
                self.field2.setOption(QtGui.QInputDialog.NoButtons)
                self.field1.setLabelText("Command Line:")
                self.field2.setLabelText("Start Address:")
                self.field1.setTextValue("")
                self.field2.setTextValue(hex(ui_obj.provider.currentEA()))

                self.field1.keyPressEvent = self.keyPressEvent
                self.field2.keyPressEvent = self.keyPressEvent
                
                confirm = QtGui.QPushButton("Prepare")
                confirm.clicked.connect(self.prepareTask)

                layout = QtGui.QVBoxLayout()
                layout.addWidget(self.field2)
                layout.addWidget(self.field1)
                
                layout.addWidget(confirm)
                
                self.setLayout(layout)
                self.setWindowTitle("Prepare Script")
                self.setWindowModality(QtCore.Qt.ApplicationModal)
                self.show()

            def prepareTask(self):
                self.command = self.field1.textValue()
                self.startVA = self.field2.textValue()
                print "[*] using args: %s & %s" % (self.command, self.startVA)
                agent = self.ui_obj.myhost.agent
                agent.toolbagTask.setArguments((self.command, self.startVA))

                self.done(1)
                self.hide()

        prepinfo = PrepDialog(ui_obj, self.fname)


########NEW FILE########
__FILENAME__ = __root__
# __root__.py
#
# for public release, 2012
#
########NEW FILE########
