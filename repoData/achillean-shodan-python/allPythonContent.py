__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# shodan-python documentation build configuration file, created by
# sphinx-quickstart on Thu Jan 23 00:56:29 2014.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.todo',
    'sphinx.ext.viewcode',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'shodan-python'
copyright = u'2014, achillean'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = '1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'shodan-pythondoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'shodan-python.tex', u'shodan-python Documentation',
   u'achillean', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'shodan-python', u'shodan-python Documentation',
     [u'achillean'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'shodan-python', u'shodan-python Documentation',
   u'achillean', 'shodan-python', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = api
# The simplejson library has better JSON-parsing than the standard library and is more often updated
from simplejson import dumps, loads

try:
    # Python 2
    from urllib2    import urlopen
    from urllib     import urlencode
except:
    # Python 3
    from urllib.request     import urlopen
    from urllib.parse       import urlencode

__all__ = ['WebAPI']

class WebAPIError(Exception):
    def __init__(self, value):
        self.value = value
    
    def __str__(self):
        return self.value


class WebAPI:
    """Wrapper around the SHODAN webservices API"""
    
    class Exploits:
        
        def __init__(self, parent):
            self.parent = parent
            
        def search(self, query, sources=[], cve=None, osvdb=None, msb=None, bid=None):
            """Search the entire Shodan Exploits archive using the same query syntax
            as the website.
            
            Arguments:
            query    -- exploit search query; same syntax as website
            
            Optional arguments:
            sources  -- metasploit, cve, osvdb, exploitdb
            cve      -- CVE identifier (ex. 2010-0432)
            osvdb    -- OSVDB identifier (ex. 11666)
            msb      -- Microsoft Security Bulletin ID (ex. MS05-030)
            bid      -- Bugtraq identifier (ex. 13951)
            
            """
            if sources:
                query += ' source:' + ','.join(sources)
            if cve:
                query += ' cve:%s' % (str(cve).strip())
            if osvdb:
                query += ' osvdb:%s' % (str(osvdb).strip())
            if msb:
                query += ' msb:%s' % (str(msb).strip())
            if bid:
                query += ' bid:%s' % (str(bid).strip())
            return self.parent._request('api', {'q': query}, service='exploits')
    
    class ExploitDb:
        
        def __init__(self, parent):
            self.parent = parent
        
        def download(self, id):
            """DEPRECATED
            Download the exploit code from the ExploitDB archive.
    
            Arguments:
            id    -- ID of the ExploitDB entry
            """
            query = '_id:%s' % id
            return self.parent.search(query, sources=['exploitdb'])
        
        def search(self, query, **kwargs):
            """Search the ExploitDB archive.
    
            Arguments:
            query     -- Search terms
    
            Returns:
            A dictionary with 2 main items: matches (list) and total (int).
            """
            return self.parent.search(query, sources=['exploitdb'])
    
    class Msf:
        
        def __init__(self, parent):
            self.parent = parent
            
        def download(self, id):
            """Download a metasploit module given the fullname (id) of it.
            
            Arguments:
            id        -- fullname of the module (ex. auxiliary/admin/backupexec/dump)
            
            Returns:
            A dictionary with the following fields:
            filename        -- Name of the file
            content-type    -- Mimetype
            data            -- File content
            """
            query = '_id:%s' % id
            return self.parent.search(query, sources=['metasploit'])
        
        def search(self, query, **kwargs):
            """Search for a Metasploit module.
            """
            return self.parent.search(query, sources=['metasploit'])
    
    def __init__(self, key):
        """Initializes the API object.
        
        Arguments:
        key -- your API key
        
        """
        self.api_key = key
        self.base_url = 'http://www.shodanhq.com/api/'
        self.base_exploits_url = 'https://exploits.shodan.io/'
        self.exploits = self.Exploits(self)
        self.exploitdb = self.ExploitDb(self.exploits)
        self.msf = self.Msf(self.exploits)
    
    def _request(self, function, params, service='shodan'):
        """General-purpose function to create web requests to SHODAN.
        
        Arguments:
        function  -- name of the function you want to execute
        params      -- dictionary of parameters for the function
        
        Returns
        A JSON string containing the function's results.
        
        """
        # Add the API key parameter automatically
        params['key'] = self.api_key
        
        # Determine the base_url based on which service we're interacting with
        base_url = {
            'shodan': self.base_url,
            'exploits': self.base_exploits_url,
        }.get(service, 'shodan')

        # Send the request
        try:
            data = urlopen(base_url + function + '?' + urlencode(params)).read().decode('utf-8')
        except:
            raise WebAPIError('Unable to connect to Shodan')
        
        # Parse the text into JSON
        data = loads(data)
        
        # Raise an exception if an error occurred
        if data.get('error', None):
            raise WebAPIError(data['error'])
        
        # Return the data
        return data
    
    def count(self, query):
        """Returns the total number of search results for the query.
        """
        return self._request('count', {'q': query})
    
    def locations(self, query):
        """Return a break-down of all the countries and cities that the results for
        the given search are located in.
        """
        return self._request('locations', {'q': query})
    
    def fingerprint(self, banner):
        """Determine the software based on the banner.
        
        Arguments:
        banner  - HTTP banner
        
        Returns:
        A list of software that matched the given banner.
        """
        return self._request('fingerprint', {'banner': banner})
    
    def host(self, ip):
        """Get all available information on an IP.

        Arguments:
        ip    -- IP of the computer

        Returns:
        All available information SHODAN has on the given IP,
        subject to API key restrictions.

        """
        return self._request('host', {'ip': ip})
    
    def info(self):
        """Returns information about the current API key, such as a list of add-ons
        and other features that are enabled for the current user's API plan.
        """
        return self._request('info', {})
    
    def search(self, query, page=1, limit=None, offset=None):
        """Search the SHODAN database.
        
        Arguments:
        query    -- search query; identical syntax to the website
        
        Optional arguments:
        page     -- page number of the search results 
        limit    -- number of results to return
        offset   -- search offset to begin getting results from
        
        Returns:
        A dictionary with 3 main items: matches, countries and total.
        Visit the website for more detailed information.
        
        """
        args = {
            'q': query,
            'p': page,
        }
        if limit:
            args['l'] = limit
            if offset:
                args['o'] = offset
        
        return self._request('search', args)

########NEW FILE########
__FILENAME__ = client
# -*- coding: utf-8 -*-

"""
shodan.client
~~~~~~~~~~~~~

This module implements the Shodan API.

:copyright: (c) 2014 by John Matherly
"""

import requests
import simplejson


class APIError(Exception):
    """This exception gets raised whenever a non-200 status code was returned by the Shodan API."""
    def __init__(self, value):
        self.value = value
    
    def __str__(self):
        return self.value


class Shodan:
    """Wrapper around the Shodan REST and Streaming APIs

    :param key: The Shodan API key that can be obtained from your account page (https://account.shodan.io)
    :type key: str
    :ivar exploits: An instance of `shodan.Shodan.Exploits` that provides access to the Exploits REST API.
    :ivar stream: An instance of `shodan.Shodan.Stream` that provides access to the Streaming API.
    """
    
    class Exploits:

        def __init__(self, parent):
            self.parent = parent
            
        def search(self, query, page=1, facets=None):
            """Search the entire Shodan Exploits archive using the same query syntax
            as the website.
            
            :param query: The exploit search query; same syntax as website.
            :type query: str
            :param facets: A list of strings or tuples to get summary information on.
            :type facets: str
            :param page: The page number to access.
            :type page: int
            :returns: dict -- a dictionary containing the results of the search.
            """
            query_args = {
                'query': query,
                'page': page,
            }
            if facets:
                facet_str = self.parent._create_facet_string(facets)
                query_args['facets'] = facet_str

            return self.parent._request('/api/search', query_args, service='exploits')
            
        def count(self, query, facets=None):
            """Search the entire Shodan Exploits archive but only return the total # of results,
            not the actual exploits.
            
            :param query: The exploit search query; same syntax as website.
            :type query: str
            :param facets: A list of strings or tuples to get summary information on.
            :type facets: str
            :returns: dict -- a dictionary containing the results of the search.
            
            """
            query_args = {
                'query': query,
            }
            if facets:
                facet_str = self.parent._create_facet_string(facets)
                query_args['facets'] = facet_str

            return self.parent._request('/api/count', query_args, service='exploits')

    class Stream:

        base_url = 'https://stream.shodan.io'

        def __init__(self, parent):
            self.parent = parent

        def _create_stream(self, name):
            try:
                req = requests.get(self.base_url + name, params={'key': self.parent.api_key}, stream=True)
            except:
                raise APIError('Unable to contact the Shodan Streaming API')

            if req.status_code != 200:
                try:
                    raise APIError(data.json()['error'])
                except:
                    pass
                raise APIError('Invalid API key or you do not have access to the Streaming API')
            return req

        def banners(self):
            """A real-time feed of the data that Shodan is currently collecting. Note that this is only available to
            API subscription plans and for those it only returns a fraction of the data.
            """
            stream = self._create_stream('/shodan/banners')
            for line in stream.iter_lines():
                if line:
                    banner = simplejson.loads(line)
                    yield banner

        def ports(self, ports):
            """
            A filtered version of the "banners" stream to only return banners that match the ports of interest.

            :param ports: A list of ports to return banner data on.
            :type ports: int[]
            """
            stream = self._create_stream('/shodan/ports/%s' % ','.join([str(port) for port in ports]))
            for line in stream.iter_lines():
                if line:
                    banner = simplejson.loads(line)
                    yield banner

        def geo(self):
            """
            A stream of geolocation information for the banners. This is a stripped-down version of the "banners" stream
            in case you only care about the geolocation information.
            """
            stream = self._create_stream('/shodan/geo')
            for line in stream.iter_lines():
                if line:
                    banner = simplejson.loads(line)
                    yield banner
    
    def __init__(self, key):
        """Initializes the API object.
        
        :param key: The Shodan API key.
        :type key: str
        """
        self.api_key = key
        self.base_url = 'https://api.shodan.io'
        self.base_exploits_url = 'https://exploits.shodan.io'
        self.exploits = self.Exploits(self)
        self.stream = self.Stream(self)
    
    def _request(self, function, params, service='shodan'):
        """General-purpose function to create web requests to SHODAN.
        
        Arguments:
            function  -- name of the function you want to execute
            params    -- dictionary of parameters for the function
        
        Returns
            A dictionary containing the function's results.
        
        """
        # Add the API key parameter automatically
        params['key'] = self.api_key
        
        # Determine the base_url based on which service we're interacting with
        base_url = {
            'shodan': self.base_url,
            'exploits': self.base_exploits_url,
        }.get(service, 'shodan')

        # Send the request
        try:
            data = requests.get(base_url + function, params=params)
        except:
            raise APIError('Unable to connect to Shodan')

        # Check that the API key wasn't rejected
        if data.status_code == 401:
            try:
                raise APIError(data.json()['error'])
            except:
                pass
            raise APIError('Invalid API key')
        
        # Parse the text into JSON
        try:
            data = data.json()
        except:
            raise APIError('Unable to parse JSON response')
        
        # Raise an exception if an error occurred
        if data.get('error', None):
            raise APIError(data['error'])
        
        # Return the data
        return data

    def _create_facet_string(self, facets):
        """Converts a Python list of facets into a comma-separated string that can be understood by
        the Shodan API.
        """
        facet_str = ''
        for facet in facets:
            if isinstance(facet, basestring):
                facet_str += facet
            else:
                facet_str += '%s:%s'  % (facet[0], facet[1])
            facet_str += ','
        return facet_str[:-1]
    
    def count(self, query, facets=None):
        """Returns the total number of search results for the query.

        :param query: Search query; identical syntax to the website
        :type query: str
        :param facets: (optional) A list of properties to get summary information on
        :type facets: str
        
        :returns: A dictionary with 1 main property: total. If facets have been provided then another property called "facets" will be available at the top-level of the dictionary. Visit the website for more detailed information.
        """
        query_args = {
            'query': query,
        }
        if facets:
            facet_str = self._create_facet_string(facets)
            query_args['facets'] = facet_str
        return self._request('/shodan/host/count', query_args)
    
    def host(self, ip, history=False):
        """Get all available information on an IP.

        :param ip: IP of the computer
        :type ip: str
        :param history: (optional) True if you want to grab the historical (non-current) banners for the host, False otherwise.
        :type history: bool
        """
        params = {}
        if history:
            params['history'] = history
        return self._request('/shodan/host/%s' % ip, params)
    
    def info(self):
        """Returns information about the current API key, such as a list of add-ons
        and other features that are enabled for the current user's API plan.
        """
        return self._request('/api-info', {})
    
    def search(self, query, page=1, limit=None, offset=None, facets=None, minify=True):
        """Search the SHODAN database.

        :param query: Search query; identical syntax to the website
        :type query: str
        :param page: (optional) Page number of the search results
        :type page: int
        :param limit: (optional) Number of results to return
        :type limit: int
        :param offset: (optional) Search offset to begin getting results from
        :type offset: int
        :param facets: (optional) A list of properties to get summary information on
        :type facets: str
        :param minify: (optional) Whether to minify the banner and only return the important data
        :type minify: bool
        
        :returns: A dictionary with 2 main items: matches and total. If facets have been provided then another property called "facets" will be available at the top-level of the dictionary. Visit the website for more detailed information.        
        """
        args = {
            'query': query,
            'minify': minify,
        }
        if limit:
            args['limit'] = limit
            if offset:
                args['offset'] = offset
        else:
            args['page'] = page

        if facets:
            facet_str = self._create_facet_string(facets)
            args['facets'] = facet_str
        
        return self._request('/shodan/host/search', args)
    
    def search_cursor(self, query, minify=True):
        """Search the SHODAN database.

        This method returns an iterator that can directly be in a loop. Use it when you want to loop over
        all of the results of a search query. But this method doesn't return a "matches" array or the "total"
        information. And it also can't be used with facets, it's only use is to iterate over results more
        easily.

        :param query: Search query; identical syntax to the website
        :type query: str
        :param minify: (optional) Whether to minify the banner and only return the important data
        :type minify: bool
        
        :returns: A search cursor that can be used as an iterator/ generator.
        """
        args = {
            'query': query,
            'minify': minify,
        }

        page = 1

        # Get the first page of results
        results = self.search(query, minify=minify, page=page)

        while results['matches']:
            for banner in results['matches']:
                yield banner
            page += 1
            results = self.search(query, minify=minify, page=page)
    
    def search_tokens(self, query):
        """Returns information about the search query itself (filters used etc.)

        :param query: Search query; identical syntax to the website
        :type query: str
        
        :returns: A dictionary with 4 main properties: filters, errors, attributes and string.
        """
        query_args = {
            'query': query,
        }
        return self._request('/shodan/host/search/tokens', query_args)

    def services(self):
        """Get a list of services that Shodan crawls

        :returns: A dictionary containing the ports/ services that Shodan crawls for. The key is the port number and the value is the name of the service.
        """
        return self._request('/shodan/services', {})

########NEW FILE########
__FILENAME__ = wps
"""
WiFi Positioning System

Wrappers around the SkyHook and Google Locations APIs to resolve
wireless routers' MAC addresses (BSSID) to physical locations.
"""
try:
    from json       import dumps, loads
except:
    from simplejson import dumps, loads

try:
    from urllib2    import Request, urlopen
    from urllib     import urlencode
except:
    from urllib.request     import Request, urlopen
    from urllib.parse       import urlencode

class Skyhook:
    
    """Not yet ready for production, use the GoogleLocation class instead."""
    
    def __init__(self, username='api', realm='shodan'):
        self.username = username
        self.realm = realm
        self.url = 'https://api.skyhookwireless.com/wps2/location'
    
    def locate(self, mac):
        # Remove the ':'
        mac = mac.replace(':', '')
        data = """<?xml version='1.0'?>  
        <LocationRQ xmlns='http://skyhookwireless.com/wps/2005' version='2.6' street-address-lookup='full'>  
          <authentication version='2.0'>  
            <simple>  
              <username>%s</username>  
              <realm>%s</realm>  
            </simple>  
          </authentication>  
          <access-point>  
            <mac>%s</mac>  
            <signal-strength>-50</signal-strength>  
          </access-point>  
        </LocationRQ>""" % (self.username, self.realm, mac)
        request = Request(url=self.url, data=data, headers={'Content-type': 'text/xml'})
        response = urlopen(request)
        result = response.read()
        return result

class GoogleLocation:
    
    def __init__(self):
        self.url = 'http://www.google.com/loc/json'
    
    def locate(self, mac):
        data = {
            'version': '1.1.0',
            'request_address': True,
            'wifi_towers': [{
                'mac_address': mac,
                'ssid': 'g',
                'signal_strength': -72
            }]
        }
        response = urlopen(self.url, dumps(data))
        data = response.read()
        return loads(data)

########NEW FILE########
__FILENAME__ = test_shodan
import unittest
import shodan

class ShodanTests(unittest.TestCase):

	api = None
	FACETS = [
		'port',
		('domain', 1)
	]
	QUERIES = {
		'simple': 'cisco-ios',
		'minify': 'apache',
		'advanced': 'apache port:443',
		'empty': 'asdasdasdasdasdasdasdasdasdhjihjkjk',
	}

	def setUp(self):
		self.api = shodan.Shodan(open('SHODAN-API-KEY').read().strip())

	def test_search_simple(self):
		results = self.api.search(self.QUERIES['simple'])

		# Make sure the properties exist
		self.assertIn('matches', results)
		self.assertIn('total', results)

		# Make sure no error occurred
		self.assertNotIn('error', results)

		# Make sure some values were returned
		self.assertTrue(results['matches'])
		self.assertTrue(results['total'])

		# A regular search shouldn't have the optional info
		self.assertNotIn('opts', results['matches'][0])

	def test_search_empty(self):
		results = self.api.search(self.QUERIES['empty'])
		self.assertTrue(len(results['matches']) == 0)
		self.assertEqual(results['total'], 0)

	def test_search_facets(self):
		results = self.api.search(self.QUERIES['simple'], facets=self.FACETS)

		self.assertTrue(results['facets']['port'])
		self.assertEqual(len(results['facets']['domain']), 1)

	def test_count_simple(self):
		results = self.api.count(self.QUERIES['simple'])

		# Make sure the properties exist
		self.assertIn('matches', results)
		self.assertIn('total', results)

		# Make sure no error occurred
		self.assertNotIn('error', results)

		# Make sure no values were returned
		self.assertFalse(results['matches'])
		self.assertTrue(results['total'])

	def test_count_facets(self):
		results = self.api.count(self.QUERIES['simple'], facets=self.FACETS)

		self.assertTrue(results['facets']['port'])
		self.assertEqual(len(results['facets']['domain']), 1)

	def test_host_details(self):
		host = self.api.host('147.228.101.7')

		self.assertEqual('147.228.101.7', host['ip_str'])
		self.assertFalse(isinstance(host['ip'], basestring))

	def test_search_minify(self):
		results = self.api.search(self.QUERIES['minify'], minify=False)
		self.assertIn('opts', results['matches'][0])

	def test_exploits_search(self):
		results = self.api.exploits.search('apache')
		self.assertIn('matches', results)
		self.assertIn('total', results)
		self.assertTrue(results['matches'])

	def test_exploits_search_paging(self):
		results = self.api.exploits.search('apache', page=1)
		match1 = results['matches'][0]
		results = self.api.exploits.search('apache', page=2)
		match2 = results['matches'][0]

		self.assertNotEqual(match1['_id'], match2['_id'])

	def test_exploits_search_facets(self):
		results = self.api.exploits.search('apache', facets=['source', ('author', 1)])
		self.assertIn('facets', results)
		self.assertTrue(results['facets']['source'])
		self.assertTrue(len(results['facets']['author']) == 1)

	def test_exploits_count(self):
		results = self.api.exploits.count('apache')
		self.assertIn('matches', results)
		self.assertIn('total', results)
		self.assertTrue(len(results['matches']) == 0)

	def test_exploits_count_facets(self):
		results = self.api.exploits.count('apache', facets=['source', ('author', 1)])
		self.assertEqual(len(results['matches']), 0)
		self.assertIn('facets', results)
		self.assertTrue(results['facets']['source'])
		self.assertTrue(len(results['facets']['author']) == 1)

	# Test error responses
	def test_invalid_key(self):
		api = shodan.Shodan('garbage')
		raised = False
		try:
			api.search('something')
		except shodan.APIError, e:
			raised = True

		self.assertTrue(raised)

	def test_invalid_host_ip(self):
		raised = False
		try:
			host = self.api.host('test')
		except shodan.APIError, e:
			raised = True

		self.assertTrue(raised)

	def test_search_empty_query(self):
		raised = False
		try:
			self.api.search('')
		except shodan.APIError, e:
			raised = True
		self.assertTrue(raised)

	def test_search_advanced_query(self):
		# The free API plan can't use filters
		raised = False
		try:
			self.api.search(self.QUERIES['advanced'])
		except shodan.APIError, e:
			raised = True
		self.assertTrue(raised)

########NEW FILE########
