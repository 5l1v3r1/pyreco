__FILENAME__ = settings
# Django settings for adl_lrs project.
from unipath import Path

# Root of LRS
SETTINGS_PATH = Path(__file__)
PROJECT_ROOT = SETTINGS_PATH.ancestor(3)

# If you want to debug
DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)
MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'lrs',
        'USER': 'root',
        'PASSWORD': 'password',
        'HOST': 'localhost',
        'PORT': '',
    }    
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/New_York'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-US'

# The ID, as an integer, of the current site in the django_site database table.
# This is used so that application data can hook into specific sites and a single database can manage
# content for multiple sites.
SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = PROJECT_ROOT.child('media')

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# Where to be redirected after logging in
LOGIN_REDIRECT_URL = '/XAPI/me'

# Me view has a tab of user's statements
STMTS_PER_PAGE = 10

# Whether HTTP auth or OAuth is enabled
HTTP_AUTH_ENABLED = True
OAUTH_ENABLED = False

# OAuth callback views
OAUTH_AUTHORIZE_VIEW = 'oauth_provider.views.authorize_client'
OAUTH_CALLBACK_VIEW = 'oauth_provider.views.callback_view'
OAUTH_SIGNATURE_METHODS = ['plaintext','hmac-sha1','rsa-sha1']
OAUTH_REALM_KEY_NAME = 'http://localhost:8000/XAPI'

# Limit on number of statements the server will return
SERVER_STMT_LIMIT = 100

# ActivityID resolve timeout (seconds)
ACTIVITY_ID_RESOLVE_TIMEOUT = .2

# Caches for /more endpoint and attachments
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
        'LOCATION': 'cache_statement_list',
        'TIMEOUT': 86400,
    },
    'attachment_cache':{
        'BACKEND':'django.core.cache.backends.db.DatabaseCache',
        'LOCATION':'attachment_cache',
    },
}

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'v+m%^r0x)$_x8i3trn*duc6vd-yju0kx2b#9lk0sn2k^7cgyp5'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "django.core.context_processors.static",
    "django.core.context_processors.tz",
    "django.contrib.messages.context_processors.messages"
)


MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'lrs.util.AllowOriginMiddleware.AllowOriginMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

# Main url router
ROOT_URLCONF = 'adl_lrs.urls'

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'adl_lrs.wsgi.application'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'lrs',
    'gunicorn',
    'oauth_provider',
    'django.contrib.admin',
    'django_extensions'
)

REQUEST_HANDLER_LOG_DIR = SETTINGS_PATH.ancestor(3) + '/logs/lrs.log'
DEFAULT_LOG_DIR = SETTINGS_PATH.ancestor(3) + '/logs/django_request.log'

# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': True,
    'formatters': {
        'verbose': {
            'format': u'%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s'
        },
        'standard': {
            'format': u'%(asctime)s [%(levelname)s] %(name)s: %(message)s'
        },
        'simple': {
            'format': u'%(levelname)s %(message)s'
        },
    },
    'handlers': {
        'default': {
            'level':'DEBUG',
            'class':'logging.handlers.RotatingFileHandler',
            'filename': DEFAULT_LOG_DIR,
            'maxBytes': 1024*1024*5, # 5 MB
            'backupCount': 5,
            'formatter':'standard',
        },  
        'request_handler': {
                'level':'DEBUG',
                'class':'logging.handlers.RotatingFileHandler',
                'filename': REQUEST_HANDLER_LOG_DIR,
                'maxBytes': 1024*1024*5, # 5 MB
                'backupCount': 5,
                'formatter':'standard',
        },
    },
    'loggers': {
        'lrs': {
            'handlers': ['default'],
            'level': 'DEBUG',
            'propagate': True
        },
        'django.request': {
            'handlers': ['request_handler'],
            'level': 'DEBUG',
            'propagate': False
        },
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from django.views.generic import RedirectView

# Uncomment the next two lines to enable the admin:
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
	url(r'^$', RedirectView.as_view(url='/xAPI/')),
    url(r'^XAPI/', include('lrs.urls')),
    url(r'^xapi/', include('lrs.urls')),
    url(r'^xAPI/', include('lrs.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    url(r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for adl_lrs project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "adl_lrs.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

########NEW FILE########
__FILENAME__ = fabfile
import os
import sys
from fabric.api import local,run

def setup_env():
    INSTALL_STEPS = ['virtualenv ../env;. ../env/bin/activate;pip install -r requirements.txt;deactivate']
    for step in INSTALL_STEPS:
        local(step)

def setup_lrs():
    # Media folder names
    agent_profile = 'agent_profile'
    activity_profile = 'activity_profile'
    activity_state = 'activity_state'
    statement_attachments = 'attachment_payloads'
    
    # Add env packages and project to the path
    cwd = os.path.dirname(os.path.abspath(__file__))
    
    if not cwd in sys.path:
        sys.path.append(cwd)
    
    env_dir = os.path.join(cwd, '../env/lib/python2.7/site-packages')
    if not env_dir in sys.path:
        sys.path.append(env_dir)

    log_dir = os.path.join(cwd, '../logs')
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)

    # Add settings module so fab file can see it
    os.environ['DJANGO_SETTINGS_MODULE'] = "adl_lrs.settings"
    from django.conf import settings
    adldir = settings.MEDIA_ROOT

    # Create media directories
    if not os.path.exists(os.path.join(adldir,activity_profile)):
        os.makedirs(os.path.join(adldir,activity_profile))

    if not os.path.exists(os.path.join(adldir,activity_state)):
        os.makedirs(os.path.join(adldir,activity_state))

    if not os.path.exists(os.path.join(adldir,agent_profile)):
        os.makedirs(os.path.join(adldir,agent_profile))

    if not os.path.exists(os.path.join(adldir,statement_attachments)):
        os.makedirs(os.path.join(adldir,statement_attachments))

    # Create cache tables and sync the db
    local('./manage.py createcachetable cache_statement_list')
    local('./manage.py createcachetable attachment_cache')
    local('./manage.py syncdb')

def test_lrs():
    local('./manage.py test lrs')
########NEW FILE########
__FILENAME__ = admin
from lrs.util import autoregister

autoregister('lrs')
########NEW FILE########
__FILENAME__ = exceptions
class BadRequest(Exception):
    pass

class ParamError(BadRequest):
    pass

class Unauthorized(Exception):
    pass

class Forbidden(Exception):
    pass

class NotFound(Exception):
    pass

class IDNotFoundError(NotFound):
    pass


class Conflict(Exception):
    pass

class ParamConflict(Conflict):
    pass

class PreconditionFail(Exception):
    pass

class OauthUnauthorized(Exception):
    def __init__(self, response):
        self.response = response

########NEW FILE########
__FILENAME__ = forms
from itertools import chain
from django import forms
from django.utils.html import conditional_escape
from django.utils.encoding import force_unicode
from django.utils.safestring import mark_safe
from lrs.models import Token

SCOPES = (('all', 'all'),
          ('all/read', 'all/read'),
          ('statements/write', 'statements/write'),
          ('statements/read', 'statements/read'),
          ('statements/read/mine', 'statements/read/mine'),
          ('state', 'state'),
          ('define', 'define'),
          ('profile', 'profile'))

class ValidatorForm(forms.Form):
    jsondata = forms.CharField(label='Data', required=True, 
        widget=forms.Textarea(attrs={'cols':100, 'rows':20}))
    
class RegisterForm(forms.Form):
    username = forms.CharField(max_length=200, label='Name')
    email = forms.EmailField(max_length=200, label='Email')
    password = forms.CharField(label='Password', 
                                widget=forms.PasswordInput(render_value=False))
    password2 = forms.CharField(label='Password Again', 
                                widget=forms.PasswordInput(render_value=False))

    def clean(self):
        cleaned = super(RegisterForm, self).clean()
        p1 = cleaned.get("password")
        p2 = cleaned.get("password2")
        if p1 and p2:
            if p1 == p2:
                return cleaned

        raise forms.ValidationError("Passwords did not match")

class RegClientForm(forms.Form):
    name = forms.CharField(max_length=200, label='Name')
    description = forms.CharField(label='Description', required=False, 
        widget=forms.Textarea())
    scopes = forms.MultipleChoiceField(required=False, initial=[SCOPES[2][0],SCOPES[4][0]],
        widget=forms.CheckboxSelectMultiple, choices=SCOPES)

class MyCheckboxSelectMultiple(forms.CheckboxSelectMultiple):
    def render(self, name, value, attrs=None, choices=()):
        if value is None: value = []
        has_id = attrs and 'id' in attrs
        final_attrs = self.build_attrs(attrs, name=name)
        output = [u'<p class="checkboxes">']
        # Normalize to strings
        str_values = set([force_unicode(v) for v in value])
        for i, (option_value, option_label) in enumerate(chain(self.choices, choices)):
            # If an ID attribute was given, add a numeric index as a suffix,
            # so that the checkboxes don't all have the same ID attribute.
            if has_id:
                final_attrs = dict(final_attrs, id='%s_%s' % (attrs['id'], i))
                label_for = u' for="%s"' % final_attrs['id']
            else:
                label_for = ''

            cb = forms.CheckboxInput(final_attrs, check_test=lambda value: value in str_values)
            option_value = force_unicode(option_value)
            rendered_cb = cb.render(name, option_value)
            option_label = conditional_escape(force_unicode(option_label))
            output.append(u'<label%s>%s %s</label><br />' % (label_for, rendered_cb, option_label))
        output.append(u'</p>')
        return mark_safe(u'\n'.join(output))

class AuthClientForm(forms.Form):
    scopes = forms.MultipleChoiceField(required=False, initial=SCOPES[0],
        widget=MyCheckboxSelectMultiple(), choices=SCOPES)
    authorize_access = forms.IntegerField(widget=forms.HiddenInput, initial=1)        
    obj_id = forms.IntegerField(widget=forms.HiddenInput, initial=0)        
    

    def clean(self):
        cleaned = super(AuthClientForm, self).clean()
        t = Token.objects.get(id=cleaned.get('obj_id'))
        default_scopes = t.consumer.default_scopes.split(',')
        scopes = cleaned.get('scopes')
        if not scopes:
            raise forms.ValidationError("you need to select permissions for the client")

        if "statements/read/mine" in scopes and "statements/read" in scopes:
            raise forms.ValidationError("'statements/read/mine' and 'statements/read' are conflicting scope values. choose one.")
        
        # if all is in defaults scopes, any changes must just be limiting scope
        if "all" in default_scopes:
            return cleaned
        elif "all" in scopes: 
            # if all wasn't in default_scopes but it's in scopes, error
            raise forms.ValidationError("Can't raise permissions beyond what the consumer registered.")
        
        # if scope and default aren't the same, see if any scope raises permissions
        if set(scopes) != set(default_scopes):
            # now we know all isn't in default scope and something changed from defaults
            # see if the change is ok
            nomatch = [k for k in scopes if k not in default_scopes]

            if not ("all/read" in nomatch or 
                    ("statements/read" in nomatch and "all/read" in default_scopes) or 
                    ("statements/read/mine" in nomatch and ("all/read" in default_scopes or "statements/read" in default_scopes))):
                raise forms.ValidationError("Can't raise permissions beyond what the consumer registered.")
            
        return cleaned
########NEW FILE########
__FILENAME__ = models
import json
import urllib
import urlparse
import datetime as dt
from datetime import datetime
from time import time
from jsonfield import JSONField
from django_extensions.db.fields import UUIDField
from django.db import models
from django.db import transaction
from django.conf import settings
from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
from django.utils.timezone import utc
from .exceptions import IDNotFoundError, ParamError
from oauth_provider.managers import TokenManager, ConsumerManager
from oauth_provider.consts import KEY_SIZE, SECRET_SIZE, CONSUMER_KEY_SIZE, CONSUMER_STATES,\
                   PENDING, VERIFIER_SIZE, MAX_URL_LENGTH

ADL_LRS_STRING_KEY = 'ADL_LRS_STRING_KEY'

gen_pwd = User.objects.make_random_password
generate_random = User.objects.make_random_password

class Nonce(models.Model):
    token_key = models.CharField(max_length=KEY_SIZE)
    consumer_key = models.CharField(max_length=CONSUMER_KEY_SIZE)
    key = models.CharField(max_length=50)
    
    def __unicode__(self):
        return u"Nonce %s for %s" % (self.key, self.consumer_key)

class Consumer(models.Model):
    name = models.CharField(max_length=50)
    description = models.TextField()

    default_scopes = models.CharField(max_length=100, default="statements/write,statements/read/mine")
    
    key = UUIDField(version=1)
    secret = models.CharField(max_length=SECRET_SIZE, default=gen_pwd)

    status = models.SmallIntegerField(choices=CONSUMER_STATES, default=PENDING)
    user = models.ForeignKey(User, null=True, blank=True, related_name="consumer_user", db_index=True)

    objects = ConsumerManager()
        
    def __unicode__(self):
        return u"Consumer %s with key %s" % (self.name, self.key)

    def generate_random_codes(self):
        """
        Used to generate random key/secret pairings.
        Use this after you've added the other data in place of save().
        """
        key = generate_random(length=KEY_SIZE)
        secret = generate_random(length=SECRET_SIZE)
        while Consumer.objects.filter(models.Q(key__exact=key) | models.Q(secret__exact=secret)).count():
            key = generate_random(length=KEY_SIZE)
            secret = generate_random(length=SECRET_SIZE)
        self.key = key
        self.secret = secret
        self.save()


class Token(models.Model):
    REQUEST = 1
    ACCESS = 2
    TOKEN_TYPES = ((REQUEST, u'Request'), (ACCESS, u'Access'))
    
    key = models.CharField(max_length=KEY_SIZE, null=True, blank=True)
    secret = models.CharField(max_length=SECRET_SIZE, null=True, blank=True)
    token_type = models.SmallIntegerField(choices=TOKEN_TYPES, db_index=True)
    timestamp = models.IntegerField(default=long(time()))
    is_approved = models.BooleanField(default=False)
    lrs_auth_id = models.CharField(max_length=50, null=True)

    user = models.ForeignKey(User, null=True, blank=True, related_name='tokens', db_index=True)
    consumer = models.ForeignKey(Consumer)
    scope = models.CharField(max_length=100, default="statements/write,statements/read/mine")
    
    ## OAuth 1.0a stuff
    verifier = models.CharField(max_length=VERIFIER_SIZE)
    callback = models.CharField(max_length=MAX_URL_LENGTH, null=True, blank=True)
    callback_confirmed = models.BooleanField(default=False)
    
    objects = TokenManager()
    
    def __unicode__(self):
        return u"%s Token %s for %s" % (self.get_token_type_display(), self.key, self.consumer)

    def scope_to_list(self):
        return self.scope.split(",")

    def timestamp_asdatetime(self):
        return datetime.fromtimestamp(self.timestamp)

    def key_partial(self):
        return self.key[:10]

    def to_string(self, only_key=False):
        token_dict = {
            'oauth_token': self.key, 
            'oauth_token_secret': self.secret,
            'oauth_callback_confirmed': self.callback_confirmed and 'true' or 'error'
        }
        if self.verifier:
            token_dict['oauth_verifier'] = self.verifier

        if only_key:
            del token_dict['oauth_token_secret']
            del token_dict['oauth_callback_confirmed']

        return urllib.urlencode(token_dict)

    def generate_random_codes(self):
        """
        Used to generate random key/secret pairings. 
        Use this after you've added the other data in place of save(). 
        """
        key = generate_random(length=KEY_SIZE)
        secret = generate_random(length=SECRET_SIZE)
        while Token.objects.filter(models.Q(key__exact=key) | models.Q(secret__exact=secret)).count():
            key = generate_random(length=KEY_SIZE)
            secret = generate_random(length=SECRET_SIZE)
        self.key = key
        self.secret = secret
        self.save()

    def get_callback_url(self):
        """
        OAuth 1.0a, append the oauth_verifier.
        """
        if self.callback and self.verifier:
            parts = urlparse.urlparse(self.callback)
            scheme, netloc, path, params, query, fragment = parts[:6]
            if query:
                query = '%s&oauth_verifier=%s' % (query, self.verifier)
            else:
                query = 'oauth_verifier=%s' % self.verifier
            return urlparse.urlunparse((scheme, netloc, path, params,
                query, fragment))
        return self.callback

class Verb(models.Model):
    verb_id = models.CharField(max_length=MAX_URL_LENGTH, db_index=True, unique=True)
    display = JSONField(blank=True)

    def object_return(self, lang=None):
        ret = {}
        ret['id'] = self.verb_id
        if self.display:
            ret['display'] = {}
            if lang:
                # Return display where key = lang
                ret['display'] = {lang:self.display[lang]}
            else:
                ret['display'] = self.display             
        return ret

    # Just return one value for human-readable
    def get_display(self, lang=None):
        if not self.display:
            return self.verb_id
        if lang:
            return self.display[lang]
        try:    
            return self.display['en-US']
        except:
            try:
                return self.display['en']
            except:
                pass
        return self.display.values()[0]

    def __unicode__(self):
        return json.dumps(self.object_return())

agent_ifps_can_only_be_one = ['mbox', 'mbox_sha1sum', 'openID', 'account', 'openid']
class AgentMgr(models.Manager):
 
    @transaction.commit_on_success
    def retrieve_or_create(self, **kwargs):
        ifp_sent = [a for a in agent_ifps_can_only_be_one if kwargs.get(a, None) != None]        
        is_group = kwargs.get('objectType', None) == "Group"
        
        if is_group:
            member = kwargs.pop('member')
            if isinstance(member, basestring):
                member = json.loads(member)

        if ifp_sent:
            # Canonical is defaulted to true
            canonical_version = kwargs.get('canonical_version', True)

            ifp = ifp_sent[0]
            ifp_dict = {'canonical_version': canonical_version}

            if not 'account' == ifp:
                ifp_dict[ifp] = kwargs[ifp]
            else:
                if not isinstance(kwargs['account'], dict):
                    account = json.loads(kwargs['account'])
                else:
                    account = kwargs['account']

                ifp_dict['account_homePage'] = account['homePage']
                kwargs['account_homePage'] = account['homePage']

                ifp_dict['account_name'] = account['name']
                kwargs['account_name'] = account['name']

                del kwargs['account']

            try:
                if not 'account' == ifp:
                    agent = Agent.objects.filter(**ifp_dict)[0]
                else:
                    agent = Agent.objects.filter(**ifp_dict)[0]
                created = False
            except IndexError:
                agent = Agent.objects.create(**kwargs)
                created = True

            # For identified groups
            if is_group:
                members = [self.retrieve_or_create(**a) for a in member]

                # If newly created identified group add all of the incoming members
                if created:
                    agent.member.add(*(a for a, c in members))

                # If retrieving existing canonical identified group, update members if necessary
                if not created and canonical_version:
                    for mem in members:
                        member_agent = mem[0]
                        if not member_agent in agent.member.all():
                            agent.member.add(member_agent)
                            agent.save()

            # If retreived agent or identified group is canonical version and name is different then update the name
            if 'name' in kwargs and kwargs['name'] != agent.name and canonical_version and not created:
                agent.name = kwargs['name']
                agent.save()

        # Only way it doesn't have IFP is if anonymous group
        else:
            agent, created = self.retrieve_or_create_anonymous_group(member, kwargs)
        return agent, created

    def retrieve_or_create_anonymous_group(self, member, kwargs):
        canonical_version = False
        # Narrow oauth down to 2 members and one member having an account
        if len(member) == 2 and ('account' in member[0] or 'account' in member[1]):
            # If oauth account is in first member
            if 'account' in member[0] and 'OAuth' in member[0]['account']['homePage']:
                created_oauth_identifier = "anongroup:%s-%s" % (member[0]['account']['name'], member[1]['mbox'])
                try:
                    agent = Agent.objects.get(oauth_identifier=created_oauth_identifier)
                    created = False
                except Agent.DoesNotExist:
                    agent = Agent.objects.create(**kwargs)
                    created = True
            # If oauth account is in second member
            elif 'account' in member[1] and 'OAuth' in member[1]['account']['homePage']:
                created_oauth_identifier = "anongroup:%s-%s" % (member[1]['account']['name'], member[0]['mbox'])
                try:
                    agent = Agent.objects.get(oauth_identifier=created_oauth_identifier)
                    created = False
                except Agent.DoesNotExist:
                    agent = Agent.objects.create(**kwargs)
                    created = True
            # Non-oauth anonymous group that has 2 members, one having an account
            else:
                agent = Agent.objects.create(**kwargs)
                created = True
        # Normal non-oauth anonymous group
        else:
            agent = Agent.objects.create(**kwargs)
            created = True

        # If it is a newly created anonymous group, add the members
        if created:
            members = [self.retrieve_or_create(**a) for a in member]
            agent.member.add(*(a for a, c in members))        
        return agent, created

    def oauth_group(self, **kwargs):
        try:
            g = Agent.objects.get(oauth_identifier=kwargs['oauth_identifier'])
            return g, False
        except Agent.DoesNotExist:
            return Agent.objects.retrieve_or_create(**kwargs)


class Agent(models.Model):
    objectType = models.CharField(max_length=6, blank=True, default="Agent")
    name = models.CharField(max_length=100, blank=True)
    mbox = models.CharField(max_length=128, db_index=True, null=True)
    mbox_sha1sum = models.CharField(max_length=40, db_index=True, null=True)
    openID = models.CharField(max_length=MAX_URL_LENGTH, db_index=True, null=True)
    oauth_identifier = models.CharField(max_length=192, db_index=True, null=True)
    member = models.ManyToManyField('self', related_name="agents", null=True)
    canonical_version = models.BooleanField(default=True)
    account_homePage = models.CharField(max_length=MAX_URL_LENGTH, null=True)
    account_name = models.CharField(max_length=50, null=True)
    objects = AgentMgr()

    class Meta:
        unique_together = (("mbox", "canonical_version"), ("mbox_sha1sum", "canonical_version"),
            ("openID", "canonical_version"),("oauth_identifier", "canonical_version"), ("account_homePage", "account_name", "canonical_version"))

    def get_agent_json(self, format='exact', as_object=False):
        just_id = format == 'ids'
        ret = {}
        # add object type if format isn't id,
        # or if it is a group,
        # or if it's an object
        if not just_id or self.objectType == 'Group' or as_object:
            ret['objectType'] = self.objectType
        if self.name and not just_id:
            ret['name'] = self.name
        if self.mbox:
            ret['mbox'] = self.mbox
        if self.mbox_sha1sum:
            ret['mbox_sha1sum'] = self.mbox_sha1sum
        if self.openID:
            ret['openID'] = self.openID
        
        ret['account'] = {}
        if self.account_name:
            ret['account']['name'] = self.account_name

        if self.account_homePage:
            ret['account']['homePage'] = self.account_homePage

        # If not account, delete it
        if not ret['account']:
            del ret['account']

        if self.objectType == 'Group':
            # show members for groups if format isn't 'ids'
            # show members' ids for anon groups if format is 'ids'
            if not just_id or not (set(['mbox','mbox_sha1sum','openID','account']) & set(ret.keys())):
                ret['member'] = [a.get_agent_json(format) for a in self.member.all()]
        return ret

    # Used only for /agent GET endpoint (check spec)
    def get_person_json(self):
        ret = {}
        ret['objectType'] = "Person"
        if self.name:
            ret['name'] = [self.name]
        if self.mbox:
            ret['mbox'] = [self.mbox]
        if self.mbox_sha1sum:
            ret['mbox_sha1sum'] = [self.mbox_sha1sum]
        if self.openID:
            ret['openID'] = [self.openID]

        ret['account'] = {}
        if self.account_name:
            ret['account']['name'] = self.account_name

        if self.account_homePage:
            ret['account']['homePage'] = self.account_homePage

        if not ret['account']:
            del ret['account']

        return ret

    def get_a_name(self):
        if self.name:
            return self.name
        if self.mbox:
            return self.mbox
        if self.mbox_sha1sum:
            return self.mbox_sha1sum
        if self.openID:
            return self.openID
        try:
            return self.account_name
        except:
            if self.objectType == 'Agent':
                return "unknown"
            else:
                return "anonymous group"

    def __unicode__(self):
        return json.dumps(self.get_agent_json())

class AgentProfile(models.Model):
    profileId = models.CharField(max_length=MAX_URL_LENGTH, db_index=True)
    updated = models.DateTimeField(auto_now_add=True, blank=True)
    agent = models.ForeignKey(Agent)
    profile = models.FileField(upload_to="agent_profile", null=True)
    json_profile = models.TextField(blank=True)
    content_type = models.CharField(max_length=255,blank=True)
    etag = models.CharField(max_length=50,blank=True)

    def delete(self, *args, **kwargs):
        if self.profile:
            self.profile.delete()
        super(AgentProfile, self).delete(*args, **kwargs)

class Activity(models.Model):
    activity_id = models.CharField(max_length=MAX_URL_LENGTH, db_index=True)
    objectType = models.CharField(max_length=8,blank=True, default="Activity")
    activity_definition_name = JSONField(blank=True)
    activity_definition_description = JSONField(blank=True)
    activity_definition_type = models.CharField(max_length=MAX_URL_LENGTH, blank=True)
    activity_definition_moreInfo = models.CharField(max_length=MAX_URL_LENGTH, blank=True)
    activity_definition_interactionType = models.CharField(max_length=25, blank=True)    
    activity_definition_extensions = JSONField(blank=True)
    activity_definition_crpanswers = JSONField(blank=True)
    activity_definition_choices = JSONField(blank=True)
    activity_definition_scales = JSONField(blank=True)
    activity_definition_sources = JSONField(blank=True)
    activity_definition_targets = JSONField(blank=True)
    activity_definition_steps = JSONField(blank=True)            
    authoritative = models.CharField(max_length=100, blank=True)
    canonical_version = models.BooleanField(default=True)

    class Meta:
        unique_together = ("activity_id", "canonical_version")

    def object_return(self, lang=None, format='exact'):
        ret = {}
        ret['id'] = self.activity_id
        if format != 'ids':
            ret['objectType'] = self.objectType
            
            ret['definition'] = {}
            if self.activity_definition_name:
                if lang:
                    ret['definition']['name'] = {lang:self.activity_definition_name[lang]}
                else:
                    ret['definition']['name'] = self.activity_definition_name

            if self.activity_definition_description:
                if lang:
                    ret['definition']['description'] = {lang:self.activity_definition_description[lang]}
                else:
                    ret['definition']['description'] = self.activity_definition_description

            if self.activity_definition_type:
                ret['definition']['type'] = self.activity_definition_type
            
            if self.activity_definition_moreInfo != '':
                ret['definition']['moreInfo'] = self.activity_definition_moreInfo

            if self.activity_definition_interactionType != '':
                ret['definition']['interactionType'] = self.activity_definition_interactionType

            # Get answers
            if self.activity_definition_crpanswers:
                ret['definition']['correctResponsesPattern'] = self.activity_definition_crpanswers
            
            if self.activity_definition_scales:
                ret['definition']['scale'] = []
                if lang:
                    for s in self.activity_definition_scales:
                        holder = {'id': s['id']}
                        holder.update({lang:self.activity_definition_scales[lang]})
                        ret['definition']['scale'].append(holder)
                else:
                    ret['definition']['scale'] = self.activity_definition_scales

            if self.activity_definition_choices:
                if lang:
                    for c in self.activity_definition_choices:
                        holder = {'id': c['id']}
                        holder.update({lang:self.activity_definition_choices[lang]})
                        ret['definition']['choices'].append(holder)
                else:
                    ret['definition']['choices'] = self.activity_definition_choices

            if self.activity_definition_steps:
                if lang:
                    for s in self.activity_definition_steps:
                        holder = {'id': s['id']}
                        holder.update({lang:self.activity_definition_steps[lang]})
                        ret['definition']['steps'].append(holder)
                else:
                    ret['definition']['steps'] = self.activity_definition_steps

            if self.activity_definition_sources:
                if lang:
                    for s in self.activity_definition_sources:
                        holder = {'id': s['id']}
                        holder.update({lang:self.activity_definition_sources[lang]})
                        ret['definition']['source'].append(holder)
                else:
                    ret['definition']['source'] = self.activity_definition_sources

            if self.activity_definition_targets:
                if lang:
                    for t in self.activity_definition_target:
                        holder = {'id': t['id']}
                        holder.update({lang:self.activity_definition_targets[lang]})
                        ret['definition']['target'].append(holder)
                else:
                    ret['definition']['target'] = self.activity_definition_targets

            if self.activity_definition_extensions:
                ret['definition']['extensions'] = self.activity_definition_extensions

            if not ret['definition']:
                del ret['definition']

        return ret

    def get_a_name(self):
        try:
            return self.activity_definition_name.get('en-US')
        except:
            return self.activity_id

    def __unicode__(self):
        return json.dumps(self.object_return())

class StatementRef(models.Model):
    object_type = models.CharField(max_length=12, default="StatementRef")
    ref_id = models.CharField(max_length=40)

    def object_return(self):
        ret = {}
        ret['objectType'] = "StatementRef"
        ret['id'] = self.ref_id
        return ret

    def get_a_name(self):
        s = Statement.objects.get(statement_id=self.ref_id)
        o, f = s.get_object()
        return " ".join([s.actor.get_a_name(),s.verb.get_display(),o.get_a_name()])
class SubStatementContextActivity(models.Model):
    key = models.CharField(max_length=8)
    context_activity = models.ManyToManyField(Activity)
    substatement = models.ForeignKey('SubStatement')

    def object_return(self, lang=None, format='exact'):
        ret = {}
        ret[self.key] = {}
        ret[self.key] = [a.object_return(lang, format) for a in self.context_activity.all()]
        return ret

class StatementContextActivity(models.Model):
    key = models.CharField(max_length=8)
    context_activity = models.ManyToManyField(Activity)
    statement = models.ForeignKey('Statement')

    def object_return(self, lang=None, format='exact'):
        ret = {}
        ret[self.key] = {}
        ret[self.key] = [a.object_return(lang, format) for a in self.context_activity.all()]
        return ret

class ActivityState(models.Model):
    state_id = models.CharField(max_length=MAX_URL_LENGTH)
    updated = models.DateTimeField(auto_now_add=True, blank=True, db_index=True)
    state = models.FileField(upload_to="activity_state", null=True)
    json_state = models.TextField(blank=True)
    agent = models.ForeignKey(Agent, db_index=True)
    activity_id = models.CharField(max_length=MAX_URL_LENGTH, db_index=True)
    registration_id = models.CharField(max_length=40)
    content_type = models.CharField(max_length=255,blank=True)
    etag = models.CharField(max_length=50,blank=True)

    def delete(self, *args, **kwargs):
        if self.state:
            self.state.delete()
        super(ActivityState, self).delete(*args, **kwargs)

class ActivityProfile(models.Model):
    profileId = models.CharField(max_length=MAX_URL_LENGTH, db_index=True)
    updated = models.DateTimeField(auto_now_add=True, blank=True, db_index=True)
    activityId = models.CharField(max_length=MAX_URL_LENGTH, db_index=True)
    profile = models.FileField(upload_to="activity_profile", null=True)
    json_profile = models.TextField(blank=True)
    content_type = models.CharField(max_length=255,blank=True)
    etag = models.CharField(max_length=50,blank=True)

    def delete(self, *args, **kwargs):
        if self.profile:
            self.profile.delete()
        super(ActivityProfile, self).delete(*args, **kwargs)

class SubStatement(models.Model):
    object_agent = models.ForeignKey(Agent, related_name="object_of_substatement", on_delete=models.SET_NULL, null=True, db_index=True)
    object_activity = models.ForeignKey(Activity, related_name="object_of_substatement", on_delete=models.SET_NULL, null=True, db_index=True)
    object_statementref = models.ForeignKey(StatementRef, related_name="object_of_substatement", on_delete=models.SET_NULL, null=True, db_index=True)    
    actor = models.ForeignKey(Agent,related_name="actor_of_substatement", null=True, on_delete=models.SET_NULL)
    verb = models.ForeignKey(Verb, null=True, on_delete=models.SET_NULL)
    result_success = models.NullBooleanField()
    result_completion = models.NullBooleanField()
    result_response = models.TextField(blank=True)
    # Made charfield since it would be stored in ISO8601 duration format
    result_duration = models.CharField(max_length=40, blank=True)
    result_score_scaled = models.FloatField(blank=True, null=True)
    result_score_raw = models.FloatField(blank=True, null=True)
    result_score_min = models.FloatField(blank=True, null=True)
    result_score_max = models.FloatField(blank=True, null=True)
    result_extensions = JSONField(blank=True)
    timestamp = models.DateTimeField(blank=True,null=True,
        default=lambda: datetime.utcnow().replace(tzinfo=utc).isoformat())
    context_registration = models.CharField(max_length=40, blank=True, db_index=True)
    context_instructor = models.ForeignKey(Agent,blank=True, null=True, on_delete=models.SET_NULL,
        db_index=True, related_name='substatement_context_instructor')
    context_team = models.ForeignKey(Agent,blank=True, null=True, on_delete=models.SET_NULL,
        related_name="substatement_context_team")
    context_revision = models.TextField(blank=True)
    context_platform = models.CharField(max_length=50,blank=True)
    context_language = models.CharField(max_length=50,blank=True)
    context_extensions = JSONField(blank=True)
    # context also has a stmt field which is a statementref
    context_statement = models.CharField(max_length=40, blank=True)
    
    def object_return(self, lang=None, format='exact'):
        activity_object = True
        ret = {}
        ret['actor'] = self.actor.get_agent_json(format)
        ret['verb'] = self.verb.object_return()

        if self.object_agent:
            ret['object'] = self.object_agent.get_agent_json(format, as_object=True)
        elif self.object_activity:
            ret['object'] = self.object_activity.object_return(lang, format)
        else:
            ret['object'] = self.object_statementref.object_return()

        ret['result'] = {}
        if self.result_success != None:
            ret['result']['success'] = self.result_success

        if self.result_completion != None:
            ret['result']['completion'] = self.result_completion

        if self.result_response:
            ret['result']['response'] = self.result_response

        if self.result_duration:
            ret['result']['duration'] = self.result_duration

        ret['result']['score'] = {}
        if not self.result_score_scaled is None:
            ret['result']['score']['scaled'] = self.result_score_scaled

        if not self.result_score_raw is None:
            ret['result']['score']['raw'] = self.result_score_raw

        if not self.result_score_min is None:
            ret['result']['score']['min'] = self.result_score_min

        if not self.result_score_max is None:
            ret['result']['score']['max'] = self.result_score_max

        # If there is no score, delete from dict
        if not ret['result']['score']:
            del ret['result']['score']

        if self.result_extensions:
            ret['result']['extensions'] = self.result_extensions

        # If no result, delete from dict
        if not ret['result']:
            del ret['result']

        ret['context'] = {}
        if self.context_registration:
            ret['context']['registration'] = self.context_registration

        if self.context_instructor:
            ret['context']['instructor'] = self.context_instructor.get_agent_json(format)

        if self.context_team:
            ret['context']['team'] = self.context_team.get_agent_json(format)

        if self.context_revision:
            ret['context']['revision'] = self.context_revision

        if self.context_platform:
            ret['context']['platform'] = self.context_platform

        if self.context_language:
            ret['context']['language'] = self.context_language

        if self.context_statement:
            ret['context']['statement'] = {'id': self.context_statement, 'objectType': 'StatementRef'}

        if self.substatementcontextactivity_set.all():
            ret['context']['contextActivities'] = {}
            for con_act in self.substatementcontextactivity_set.all():
                ret['context']['contextActivities'].update(con_act.object_return(lang, format))

        if self.context_extensions:
            ret['context']['extensions'] = self.context_extensions

        if not ret['context']:
            del ret['context']

        ret['timestamp'] = str(self.timestamp)
        ret['objectType'] = "SubStatement"
        return ret

    def get_a_name(self):
        return self.stmt_object.statement_id

    def get_object(self):
        if self.object_activity:
            stmt_object = self.object_activity
        elif self.object_agent:
            stmt_object = self.object_agent
        else:
            stmt_object = self.object_statementref
        return stmt_object

    def delete(self, *args, **kwargs):
        if self.object_statementref:
            self.object_statementref.delete()
        
        super(SubStatement, self).delete(*args, **kwargs)

class StatementAttachment(models.Model):
    usageType = models.CharField(max_length=MAX_URL_LENGTH)
    contentType = models.CharField(max_length=128)
    length = models.PositiveIntegerField()
    sha2 = models.CharField(max_length=128, blank=True)
    fileUrl = models.CharField(max_length=MAX_URL_LENGTH, blank=True)
    payload = models.FileField(upload_to="attachment_payloads", null=True)
    display = JSONField(blank=True)
    description = JSONField(blank=True)

    def object_return(self, lang=None):
        ret = {}
        ret['usageType'] = self.usageType

        if self.display:
            if lang:
                ret['display'] = {lang:self.display[lang]}
            else:
                ret['display'] = self.display

        if self.description:
            if lang:
                ret['description'] = {lang:self.description[lang]}
            else:
                ret['description'] = self.description

        ret['contentType'] = self.contentType
        ret['length'] = self.length

        if self.sha2:
            ret['sha2'] = self.sha2

        if self.fileUrl:
            ret['fileUrl'] = self.fileUrl
        return ret

class Statement(models.Model):
    # If no statement_id is given, will create one automatically
    statement_id = UUIDField(version=1, db_index=True, unique=True)
    object_agent = models.ForeignKey(Agent, related_name="object_of_statement", null=True, on_delete=models.SET_NULL, db_index=True)
    object_activity = models.ForeignKey(Activity, related_name="object_of_statement", null=True, on_delete=models.SET_NULL, db_index=True)
    object_substatement = models.ForeignKey(SubStatement, related_name="object_of_statement", null=True, on_delete=models.SET_NULL, db_index=True)
    object_statementref = models.ForeignKey(StatementRef, related_name="object_of_statement", null=True, on_delete=models.SET_NULL, db_index=True)    
    actor = models.ForeignKey(Agent,related_name="actor_statement", db_index=True, null=True,
        on_delete=models.SET_NULL)
    verb = models.ForeignKey(Verb, null=True, on_delete=models.SET_NULL)
    result_success = models.NullBooleanField()
    result_completion = models.NullBooleanField()
    result_response = models.TextField(blank=True)
    # Made charfield since it would be stored in ISO8601 duration format
    result_duration = models.CharField(max_length=40, blank=True)
    result_score_scaled = models.FloatField(blank=True, null=True)
    result_score_raw = models.FloatField(blank=True, null=True)
    result_score_min = models.FloatField(blank=True, null=True)
    result_score_max = models.FloatField(blank=True, null=True)
    result_extensions = JSONField(blank=True)
    # If no stored or timestamp given - will create automatically (only happens if using StatementManager directly)
    stored = models.DateTimeField(default=datetime.utcnow().replace(tzinfo=utc).isoformat(), db_index=True)
    timestamp = models.DateTimeField(default=datetime.utcnow().replace(tzinfo=utc).isoformat(), db_index=True)
    authority = models.ForeignKey(Agent, blank=True,null=True,related_name="authority_statement", db_index=True,
        on_delete=models.SET_NULL)
    voided = models.NullBooleanField(default=False)
    context_registration = models.CharField(max_length=40, blank=True, db_index=True)
    context_instructor = models.ForeignKey(Agent,blank=True, null=True, on_delete=models.SET_NULL,
        db_index=True, related_name='statement_context_instructor')
    context_team = models.ForeignKey(Agent,blank=True, null=True, on_delete=models.SET_NULL,
        related_name="statement_context_team")
    context_revision = models.TextField(blank=True)
    context_platform = models.CharField(max_length=50,blank=True)
    context_language = models.CharField(max_length=50,blank=True)
    context_extensions = JSONField(blank=True)
    # context also has a stmt field which is a statementref
    context_statement = models.CharField(max_length=40, blank=True)
    version = models.CharField(max_length=7, default="1.0.0")
    attachments = models.ManyToManyField(StatementAttachment)
    # Used in views
    user = models.ForeignKey(User, null=True, blank=True, db_index=True, on_delete=models.SET_NULL)
    full_statement = JSONField()
    def object_return(self, lang=None, format='exact'):
        if format == 'exact':
            return self.full_statement
        ret = {}
        ret['id'] = self.statement_id
        ret['actor'] = self.actor.get_agent_json(format)
        ret['verb'] = self.verb.object_return()

        if self.object_agent:
            ret['object'] = self.object_agent.get_agent_json(format, as_object=True)            
        elif self.object_activity:
            ret['object'] = self.object_activity.object_return(lang, format)
        elif self.object_substatement:
            ret['object'] = self.object_substatement.object_return(lang, format)
        else:
            ret['object'] = self.object_statementref.object_return()

        ret['result'] = {}
        if self.result_success != None:
            ret['result']['success'] = self.result_success

        if self.result_completion != None:
            ret['result']['completion'] = self.result_completion

        if self.result_response:
            ret['result']['response'] = self.result_response

        if self.result_duration:
            ret['result']['duration'] = self.result_duration

        ret['result']['score'] = {}
        if not self.result_score_scaled is None:
            ret['result']['score']['scaled'] = self.result_score_scaled

        if not self.result_score_raw is None:
            ret['result']['score']['raw'] = self.result_score_raw

        if not self.result_score_min is None:
            ret['result']['score']['min'] = self.result_score_min

        if not self.result_score_max is None:
            ret['result']['score']['max'] = self.result_score_max

        # If there is no score, delete from dict
        if not ret['result']['score']:
            del ret['result']['score']

        if self.result_extensions:
            ret['result']['extensions'] = self.result_extensions

        if not ret['result']:
            del ret['result']

        ret['context'] = {}
        if self.context_registration:
            ret['context']['registration'] = self.context_registration

        if self.context_instructor:
            ret['context']['instructor'] = self.context_instructor.get_agent_json(format)

        if self.context_team:
            ret['context']['team'] = self.context_team.get_agent_json(format)

        if self.context_revision:
            ret['context']['revision'] = self.context_revision

        if self.context_platform:
            ret['context']['platform'] = self.context_platform

        if self.context_language:
            ret['context']['language'] = self.context_language

        if self.context_statement:
            ret['context']['statement'] = {'id': self.context_statement, 'objectType': 'StatementRef'}

        if self.statementcontextactivity_set.all():
            ret['context']['contextActivities'] = {}
            for con_act in self.statementcontextactivity_set.all():
                ret['context']['contextActivities'].update(con_act.object_return(lang, format))

        if self.context_extensions:
            ret['context']['extensions'] = self.context_extensions

        if not ret['context']:
            del ret['context']

        ret['timestamp'] = self.timestamp.isoformat()
        ret['stored'] = self.stored.isoformat()
        
        if not self.authority is None:
            ret['authority'] = self.authority.get_agent_json(format)
        
        ret['version'] = self.version

        if self.attachments.all():
            ret['attachments'] = [a.object_return(lang) for a in self.attachments.all()]
        return ret

    def unvoid_statement(self):
        Statement.objects.filter(statement_id=self.object_statementref.ref_id).update(voided=False)        

    def get_a_name(self):
        return self.statement_id

    def get_object(self):
        if self.object_activity:
            stmt_object = self.object_activity
        elif self.object_agent:
            stmt_object = self.object_agent
        elif self.object_substatement:
            stmt_object = self.object_substatement
        else:
            stmt_object = self.object_statementref
        return stmt_object

    def delete(self, *args, **kwargs):        
        # Unvoid stmt if verb is voided
        if self.verb.verb_id == 'http://adlnet.gov/expapi/verbs/voided':
            self.unvoid_statement()
        
        # If sub or ref, FK will be set to null, then call delete
        if self.verb.verb_id != 'http://adlnet.gov/expapi/verbs/voided':
            if self.object_substatement:
                self.object_substatement.delete()
            elif self.object_statementref:
                self.object_statementref.delete()

        super(Statement, self).delete(*args, **kwargs)

########NEW FILE########
__FILENAME__ = ActivityManager
import json
from StringIO import StringIO
from django.core.exceptions import ValidationError
from django.core.validators import URLValidator
from lrs import models, exceptions
from lrs.util import uri

class ActivityManager():
    def __init__(self, data, auth=None, define=True):
        if auth:
            if auth.__class__.__name__ == 'Agent':
                self.auth = auth.name
            else:
                self.auth = auth.username
        else:
            self.auth = None
        self.define = define
        self.populate(data)

    #Save activity definition to DB
    def save_activity_definition_to_db(self, act_def_type, int_type, more_info, name, desc, crp, ext):
        created = True        
        # Have to check if the activity already has an activity definition. Can only update name and
        # description in definition, so no matter what the user's scope is, if the activity def already
        # exists you can't create another one
        if (self.Activity.activity_definition_type or self.Activity.activity_definition_moreInfo or
                self.Activity.activity_definition_interactionType):
            created = False
        else:
            self.Activity.activity_definition_name = name
            self.Activity.activity_definition_description = desc
            self.Activity.activity_definition_type = act_def_type
            self.Activity.activity_definition_moreInfo = more_info
            self.Activity.activity_definition_interactionType = int_type
            self.Activity.activity_definition_crpanswers = crp
            self.Activity.activity_definition_extensions = ext
            self.Activity.save()
        return created

    def check_activity_definition_value(self, new_name_value, existing_name_value):
        return new_name_value == existing_name_value

    #Once JSON is verified, populate the activity objects
    def populate(self, the_object):        
        activity_id = the_object['id']

        # If allowed to define activities-create or get the global version
        if self.define:
            self.Activity, act_created = models.Activity.objects.get_or_create(activity_id=activity_id,
                canonical_version=True)
        else:
            # Not allowed to create global version b/c don't have define permissions
            self.Activity = models.Activity.objects.create(activity_id=activity_id, canonical_version=False)
            act_created = False

        if act_created:
            if self.auth:
                self.Activity.authoritative = self.auth
                self.Activity.save()

        activity_definition = the_object.get('definition', None)

        # If there is a definition-populate the definition
        if activity_definition and (act_created or self.act_def_changed(activity_definition)):
            self.populate_definition(activity_definition, act_created)

    def validate_cmi_interaction(self, act_def, act_created):
        interaction_flag = None

        return interaction_flag

    def act_def_changed(self, act_def):
        return act_def != self.Activity.object_return().get('definition', {})

    #Populate definition either from JSON or validated XML
    def populate_definition(self, act_def, act_created):
        # return t/f if you can create the def from type, interactionType and moreInfo if the activity already
        # doesn't have a definition
        act_def_created = self.save_activity_definition_to_db(act_def.get('type', ''), act_def.get('interactionType', ''),
            act_def.get('moreInfo', ''), act_def.get('name', ''), act_def.get('description', ''),
            act_def.get('correctResponsesPattern', ''), act_def.get('extensions', ''))

        # If the activity had already existed and lrs auth is off or user has authority to update it
        if not act_created: 
            if self.Activity.authoritative == '' or self.Activity.authoritative == self.auth:
                # Update name and desc if needed
                if 'name' in act_def:
                    if self.Activity.activity_definition_name:
                        self.Activity.activity_definition_name = dict(self.Activity.activity_definition_name.items() + act_def['name'].items())
                    else:
                        self.Activity.activity_definition_name = act_def['name']
                    self.Activity.save()

                if 'description' in act_def:
                    if self.Activity.activity_definition_description:
                        self.Activity.activity_definition_description = dict(self.Activity.activity_definition_description.items() + act_def['description'].items())
                    else:
                        self.Activity.activity_definition_description = act_def['description']
                    self.Activity.save()

        # If the activity definition was just created (can't update the CRP or extensions of a def if already existed)
        #If there is a correctResponsesPattern then save the pattern
        if act_def_created and self.Activity.activity_definition_crpanswers:
            self.populate_correct_responses_pattern(act_def)

    def populate_correct_responses_pattern(self, act_def):
        #Multiple choice and sequencing must have choices
        if act_def['interactionType'] == 'choice' or \
            act_def['interactionType'] == 'sequencing':
            self.Activity.activity_definition_choices = act_def['choices']
        #Matching must have both source and target
        elif act_def['interactionType'] == 'matching':
            self.Activity.activity_definition_sources = act_def['source'] 
            self.Activity.activity_definition_targets = act_def['target']
        #Performance must have steps
        elif act_def['interactionType'] == 'performance':
            self.Activity.activity_definition_steps = act_def['steps']
        #Likert must have scale
        elif act_def['interactionType'] == 'likert':
            self.Activity.activity_definition_scales = act_def['scale']
        self.Activity.save()
########NEW FILE########
__FILENAME__ = ActivityProfileManager
import ast
import datetime
import json
from django.core.files.base import ContentFile
from django.core.exceptions import ValidationError
from django.db import transaction
from django.utils.timezone import utc
from lrs import models
from lrs.exceptions import IDNotFoundError, ParamError
from lrs.util import etag, get_user_from_auth, uri

class ActivityProfileManager():
    @transaction.commit_on_success
    def post_profile(self, request_dict):
        post_profile = request_dict['profile']
        
        profile_id = request_dict['params']['profileId']

        # get / create  profile
        p, created = models.ActivityProfile.objects.get_or_create(activityId=request_dict['params']['activityId'],  profileId=request_dict['params']['profileId'])
        
        if created:
            p.json_profile = post_profile
            p.content_type = request_dict['headers']['CONTENT_TYPE']
            p.etag = etag.create_tag(post_profile)
            
            #Set updated
            if 'headers' in request_dict and ('updated' in request_dict['headers'] and request_dict['headers']['updated']):
                p.updated = request_dict['headers']['updated']
            else:
                p.updated = datetime.datetime.utcnow().replace(tzinfo=utc)
        else:
            etag.check_preconditions(request_dict,p, required=True)
            orig_prof = json.loads(p.json_profile)
            post_profile = json.loads(post_profile)
            if not isinstance(post_profile, dict):
                raise ParamError("The document was not able to be parsed into a JSON object.")
            else:
                # json.dumps changes the format of the string rep of the dict
                merged = json.dumps(dict(orig_prof.items() + post_profile.items()))
            p.json_profile = merged
            p.etag = etag.create_tag(merged)
            p.updated = datetime.datetime.utcnow().replace(tzinfo=utc)

        p.save()

    @transaction.commit_on_success
	#Save profile to desired activity
    def put_profile(self, request_dict):
        #Parse out profile from request_dict
        profile_id = request_dict['params']['profileId']

        #Get the profile, or if not already created, create one
        p,created = models.ActivityProfile.objects.get_or_create(profileId=profile_id,activityId=request_dict['params']['activityId'])
        
        if "application/json" not in request_dict['headers']['CONTENT_TYPE']:
            try:
                profile = ContentFile(request_dict['profile'].read())
            except:
                try:
                    profile = ContentFile(request_dict['profile'])
                except:
                    profile = ContentFile(str(request_dict['profile']))

            if not created:
                #If it already exists delete it
                etag.check_preconditions(request_dict,p, required=True)
                if p.profile:
                    try:
                        p.profile.delete()
                    except OSError:
                        # probably was json before
                        p.json_profile = {}
            
            self.save_profile(p, created, profile, request_dict)
        else:
            if not created:
                etag.check_preconditions(request_dict, p, required=True)
            the_profile = request_dict['profile']
            p.json_profile = the_profile
            p.content_type = request_dict['headers']['CONTENT_TYPE']
            p.etag = etag.create_tag(the_profile)
            
            #Set updated
            if 'headers' in request_dict and ('updated' in request_dict['headers'] and request_dict['headers']['updated']):
                p.updated = request_dict['headers']['updated']
            else:
                p.updated = datetime.datetime.utcnow().replace(tzinfo=utc)
            p.save()

    def save_profile(self, p, created, profile, request_dict):
        #Save profile content type based on incoming content type header and create etag
        p.content_type = request_dict['headers']['CONTENT_TYPE']
        p.etag = etag.create_tag(profile.read())
        
        #Set updated
        if 'headers' in request_dict and ('updated' in request_dict['headers'] and request_dict['headers']['updated']):
            p.updated = request_dict['headers']['updated']
        else:
            p.updated = datetime.datetime.utcnow().replace(tzinfo=utc)

        #Go to beginning of file
        profile.seek(0)
        
        #If it didn't exist, save it
        if created:
            p.save()

        #Set filename with the activityID and profileID and save
        fn = "%s_%s" % (p.activityId,request_dict.get('filename', p.id))
        p.profile.save(fn, profile)

    def get_profile(self, profileId, activityId):
        #Retrieve the profile with the given profileId and activity
        try:
            return models.ActivityProfile.objects.get(profileId=profileId, activityId=activityId)
        except models.ActivityProfile.DoesNotExist:
            err_msg = 'There is no profile associated with the id: %s' % profileId
            raise IDNotFoundError(err_msg)

    def get_profile_ids(self, activityId, since=None):
        ids = []

        #If there is a since param return all profileIds since then
        if since:
            try:
                # this expects iso6801 date/time format "2013-02-15T12:00:00+00:00"
                profs = models.ActivityProfile.objects.filter(updated__gte=since, activityId=activityId)
            except ValidationError:
                err_msg = 'Since field is not in correct format for retrieval of activity profile IDs'
                raise ParamError(err_msg) 
            ids = [p.profileId for p in profs]
        else:
            #Return all IDs of profiles associated with this activity b/c there is no since param
            ids = models.ActivityProfile.objects.filter(activityId=activityId).values_list('profileId', flat=True)
        return ids

    def delete_profile(self, request_dict):
        #Get profile and delete it
        try:
            prof = self.get_profile(request_dict['params']['profileId'], request_dict['params']['activityId'])
            prof.delete()
        except models.ActivityProfile.DoesNotExist:
            pass #we don't want it anyway
        except IDNotFoundError:
            pass

########NEW FILE########
__FILENAME__ = ActivityStateManager
import ast
import datetime
import json
from django.core.files.base import ContentFile
from django.db import transaction
from django.utils.timezone import utc
from lrs import models
from .AgentManager import AgentManager
from lrs.exceptions import IDNotFoundError, ParamError
from lrs.util import etag, get_user_from_auth, uri, get_agent_ifp

class ActivityStateManager():
    def __init__(self, request_dict, log_dict=None):        
        if not uri.validate_uri(request_dict['params']['activityId']):
            err_msg = 'Activity ID %s is not a valid URI' % request_dict['params']['activityId']       
            raise ParamError(err_msg)

        self.req_dict = request_dict
        self.agent = request_dict['params']['agent']
        self.activity_id = request_dict['params']['activityId']
        self.registration = request_dict['params'].get('registration', None)
        self.stateId = request_dict['params'].get('stateId', None)
        self.updated = request_dict['headers'].get('updated', None)
        self.content_type = request_dict['headers'].get('CONTENT_TYPE', None)
        self.state = request_dict.get('state', None)
        self.etag = request_dict.get('ETAG', None)
        self.since = request_dict['params'].get('since', None)

    def __get_agent(self):
        return AgentManager(self.agent).Agent

    @transaction.commit_on_success
    def post(self):
        agent = self.__get_agent()
        post_state = self.state

        if self.registration:
            p,created = models.ActivityState.objects.get_or_create(state_id=self.stateId,agent=agent,activity_id=self.activity_id,registration_id=self.registration)
        else:
            p,created = models.ActivityState.objects.get_or_create(state_id=self.stateId,agent=agent,activity_id=self.activity_id)
        
        if created:
            p.json_state = post_state
            p.content_type = self.content_type
            p.etag = etag.create_tag(post_state)

            if self.updated:
                p.updated = self.updated
        else:
            orig_state = json.loads(p.json_state)
            post_state = json.loads(post_state)
            if not isinstance(post_state, dict):
                raise ParamError("The document was not able to be parsed into a JSON object.")
            else:
                merged = json.dumps(dict(orig_state.items() + post_state.items()))
            p.json_state = merged
            p.etag = etag.create_tag(merged)
            p.updated = datetime.datetime.utcnow().replace(tzinfo=utc)

        p.save()
        
    @transaction.commit_on_success
    def put(self):
        agent = self.__get_agent()
        if self.registration:
            p,created = models.ActivityState.objects.get_or_create(state_id=self.stateId,agent=agent,activity_id=self.activity_id,registration_id=self.registration)
        else:
            p,created = models.ActivityState.objects.get_or_create(state_id=self.stateId,agent=agent,activity_id=self.activity_id)
        
        if "application/json" not in self.content_type:
            try:
                state = ContentFile(self.state.read())
            except:
                try:
                    state = ContentFile(self.state)
                except:
                    state = ContentFile(str(self.state))

            if not created:
                etag.check_preconditions(self.req_dict,p)
                p.state.delete() # remove old state file
            p.content_type = self.content_type
            self.save_state(p, created, state)
        else:
            if not created:
                etag.check_preconditions(self.req_dict, p)
            the_state = self.state
            p.json_state = the_state
            p.content_type = self.content_type
            p.etag = etag.create_tag(the_state)
            if self.updated:
                p.updated = self.updated
            else:
                p.updated = datetime.datetime.utcnow().replace(tzinfo=utc)
            p.save()

    def save_state(self, p, created, state):
        p.content_type = self.content_type
        p.etag = etag.create_tag(state.read())
        if self.updated:
            p.updated = self.updated
        else:
            p.updated = datetime.datetime.utcnow().replace(tzinfo=utc)
        state.seek(0)
        if created:
            p.save()

        fn = "%s_%s_%s" % (p.agent_id,p.activity_id, self.req_dict.get('filename', p.id))
        p.state.save(fn, state)

    def get(self):
        ifp = get_agent_ifp(json.loads(self.agent))
        agent = models.Agent.objects.get(**ifp)

        try:
            if self.registration:
                return models.ActivityState.objects.get(state_id=self.stateId, agent=agent, activity_id=self.activity_id, registration_id=self.registration)
            return models.ActivityState.objects.get(state_id=self.stateId, agent=agent, activity_id=self.activity_id)
        except models.ActivityState.DoesNotExist:
            err_msg = 'There is no activity state associated with the id: %s' % self.stateId
            raise IDNotFoundError(err_msg)

    def get_set(self,**kwargs):
        ifp = get_agent_ifp(json.loads(self.agent))
        agent = models.Agent.objects.get(**ifp)

        if self.registration:
            state_set = models.ActivityState.objects.filter(agent=agent, activity_id=self.activity_id, registration_id=self.registration)
        else:
            state_set = models.ActivityState.objects.filter(agent=agent, activity_id=self.activity_id)
        return state_set

    def get_ids(self):
        try:
            state_set = self.get_set()
        except models.ActivityState.DoesNotExist:
            err_msg = 'There is no activity state associated with the ID: %s' % self.stateId
            raise IDNotFoundError(err_msg)
        if self.since:
            try:
                # this expects iso6801 date/time format "2013-02-15T12:00:00+00:00"
                state_set = state_set.filter(updated__gte=self.since)
            except ValidationError:
                err_msg = 'Since field is not in correct format for retrieval of state IDs'
                raise ParamError(err_msg) 
        return state_set.values_list('state_id', flat=True)

    def delete(self):
        try:
            if not self.stateId:
                state = self.get_set()
                for s in state:
                    s.delete() # bulk delete skips the custom delete function
            else:
                state = self.get()
                state.delete()
        except models.ActivityState.DoesNotExist:
            pass
        except IDNotFoundError:
            pass
            
########NEW FILE########
__FILENAME__ = AgentManager
import json
from lrs.models import Agent

class AgentManager():
    def __init__(self, params, define=True):
        # This parsing is kept for profile/state/agents endpoints
        if not isinstance(params, dict):
            try:
                params = json.loads(params)
            except Exception, e:
                err_msg = "Error parsing the Agent object. Expecting json. Received: %s which is %s" % (params,
                    type(params))
                raise ParamError(err_msg) 
        
        # Define determines if the user submitting the statement with the agent in it has the ability
        # to make canonical agents and/or update canonical agents
        params['canonical_version'] = define
        self.Agent, self.created = Agent.objects.retrieve_or_create(**params)
########NEW FILE########
__FILENAME__ = AgentProfileManager
import ast
import json
import datetime
import copy
from django.core.files.base import ContentFile
from django.db import transaction
from django.utils.timezone import utc
from lrs.models import AgentProfile
from lrs.models import Agent as ag
from lrs.exceptions import IDNotFoundError, ParamError
from lrs.util import etag, get_user_from_auth

class AgentProfileManager():
    def __init__(self, agent):
    	self.Agent = agent

    @transaction.commit_on_success        
    def post_profile(self, request_dict):
        post_profile = request_dict['profile']
        profile_id = request_dict['params']['profileId']

        p, created = AgentProfile.objects.get_or_create(profileId=profile_id,agent=self.Agent)
        
        if created:
            p.json_profile = post_profile
            p.content_type = request_dict['headers']['CONTENT_TYPE']
            p.etag = etag.create_tag(post_profile)

            if 'headers' in request_dict and ('updated' in request_dict['headers'] and request_dict['headers']['updated']):
                p.updated = request_dict['headers']['updated']
            else:
                p.updated = datetime.datetime.utcnow().replace(tzinfo=utc)
        else:
            etag.check_preconditions(request_dict,p, required=True)
            orig_prof = json.loads(p.json_profile)
            post_profile = json.loads(post_profile)
            if not isinstance(post_profile, dict):
                raise ParamError("The document was not able to be parsed into a JSON object.")
            else:
                merged = json.dumps(dict(orig_prof.items() + post_profile.items()))
            p.json_profile = merged
            p.etag = etag.create_tag(merged)
            p.updated = datetime.datetime.utcnow().replace(tzinfo=utc)

        p.save()

    @transaction.commit_on_success
    def put_profile(self, request_dict):
        profile_id = request_dict['params']['profileId']
        p,created = AgentProfile.objects.get_or_create(profileId=profile_id,agent=self.Agent)

        if "application/json" not in request_dict['headers']['CONTENT_TYPE']:
            try:
                profile = ContentFile(request_dict['profile'].read())
            except:
                try:
                    profile = ContentFile(request_dict['profile'])
                except:
                    profile = ContentFile(str(request_dict['profile']))
        

            if not created:
                etag.check_preconditions(request_dict,p, required=True)
                try:
                    p.profile.delete()
                except OSError:
                    # p was probably json before.. gotta clear that field
                    p.json_profile = {}
            self.save_profile(p, created, profile, request_dict)
        else:
            if not created:
                etag.check_preconditions(request_dict, p, required=True)
            the_profile = request_dict['profile']
            p.json_profile = the_profile
            p.content_type = request_dict['headers']['CONTENT_TYPE']
            p.etag = etag.create_tag(the_profile)

            if 'headers' in request_dict and ('updated' in request_dict['headers'] and request_dict['headers']['updated']):
                p.updated = request_dict['headers']['updated']
            else:
                p.updated = datetime.datetime.utcnow().replace(tzinfo=utc)
            p.save()

    def save_profile(self, p, created, profile, request_dict):
        p.content_type = request_dict['headers']['CONTENT_TYPE']
        p.etag = etag.create_tag(profile.read())
        if 'headers' in request_dict and ('updated' in request_dict['headers'] and request_dict['headers']['updated']):
            p.updated = request_dict['headers']['updated']
        else:
            p.updated = datetime.datetime.utcnow().replace(tzinfo=utc)
        profile.seek(0)
        if created:
            p.save()

        fn = "%s_%s" % (p.agent_id,request_dict.get('filename', p.id))
        p.profile.save(fn, profile)
    
    def get_profile(self, profileId):
        try:
            return self.Agent.agentprofile_set.get(profileId=profileId)
        except:
            err_msg = 'There is no profile associated with the id: %s' % profileId
            raise IDNotFoundError(err_msg)

    def get_profile_ids(self, since=None):
        ids = []
        if since:
            try:
                # this expects iso6801 date/time format "2013-02-15T12:00:00+00:00"
                profs = self.Agent.agentprofile_set.filter(updated__gte=since)
            except ValidationError:
                err_msg = 'Since field is not in correct format for retrieval of agent profiles'
                raise ParamError(err_msg) 
            except:
                err_msg = 'There are no profiles associated with the id: %s' % profileId
                raise IDNotFoundError(err_msg) 

            ids = [p.profileId for p in profs]
        else:
            ids = self.Agent.agentprofile_set.values_list('profileId', flat=True)
        return ids

    def delete_profile(self, profileId):
        try:
            prof = self.get_profile(profileId)
            prof.delete()
        except AgentProfile.DoesNotExist:
            pass #we don't want it anyway
        except IDNotFoundError:
            pass
        except OSError:
            pass # this is ok,too
########NEW FILE########
__FILENAME__ = StatementManager
import json
import re
from django.core.exceptions import ValidationError
from django.db import transaction
from django.core.files.base import ContentFile
from django.core.cache import get_cache
from functools import wraps
from isodate.isoduration import parse_duration
from isodate.isoerror import ISO8601Error
from lrs import models, exceptions
from lrs.util import get_user_from_auth, uri, convert_to_utc
from AgentManager import AgentManager
from ActivityManager import ActivityManager

att_cache = get_cache('attachment_cache')

class default_on_exception(object):
    def __init__(self,default):
        self.default = default
    def __call__(self,f):
        @wraps(f)
        def closure(obj,*args,**kwargs):
            try:
                return f(obj,*args,**kwargs)
            except:
                return self.default
        return closure

class StatementManager():
    def __init__(self, data, auth=None, define=True, stmt_json=''):
        self.auth = auth
        self.define = define
        self.data = data
        if self.__class__.__name__ == 'StatementManager':
            self.data['full_statement'] = stmt_json
        self.populate()

    @transaction.commit_on_success
    def void_statement(self,stmt_id):
        stmt = models.Statement.objects.get(statement_id=stmt_id)
        stmt.voided = True
        stmt.save()

        # Create statement ref
        stmt_ref = models.StatementRef.objects.create(ref_id=stmt_id)
        return stmt_ref

    @transaction.commit_on_success
    # Save sub to DB
    def save_substatement_to_db(self):
        context_activity_types = ['parent', 'grouping', 'category', 'other']

        # Pop off any context activities
        con_act_data = self.data.pop('context_contextActivities',{})

        # Try to create SubStatement            
        # Delete objectType since it is not a field in the model
        del self.data['objectType']
        sub = models.SubStatement.objects.create(**self.data)
        
        # Save context activities
        # Can have multiple groupings
        for con_act_group in con_act_data.items():
            ca = models.SubStatementContextActivity.objects.create(key=con_act_group[0], substatement=sub)
            # Incoming contextActivities can either be a list or dict
            if isinstance(con_act_group[1], list):
                for con_act in con_act_group[1]:
                    act = ActivityManager(con_act, auth=self.auth, define=self.define).Activity
                    ca.context_activity.add(act)
            else:
                act = ActivityManager(con_act_group[1], auth=self.auth, define=self.define).Activity
                ca.context_activity.add(act)
            ca.save()

        return sub

    @transaction.commit_on_success
    # Save statement to DB
    def save_statement_to_db(self):
        context_activity_types = ['parent', 'grouping', 'category', 'other']

        # Pop off any context activities
        con_act_data = self.data.pop('context_contextActivities',{})

        self.data['user'] = get_user_from_auth(self.auth)

        # Name of id field in models is statement_id
        if 'id' in self.data:
            self.data['statement_id'] = self.data['id']
            del self.data['id']

        # Try to create statement
        stmt = models.Statement.objects.create(**self.data)
    
        # Save context activities
        # Can have multiple groupings
        for con_act_group in con_act_data.items():
            ca = models.StatementContextActivity.objects.create(key=con_act_group[0], statement=stmt)
            # Incoming contextActivities can either be a list or dict
            if isinstance(con_act_group[1], list):
                for con_act in con_act_group[1]:
                    act = ActivityManager(con_act, auth=self.auth, define=self.define).Activity
                    ca.context_activity.add(act)
            else:
                act = ActivityManager(con_act_group[1], auth=self.auth, define=self.define).Activity
                ca.context_activity.add(act)
            ca.save()
        
        return stmt

    def populate_result(self):
        if 'result' in self.data:
            result = self.data['result']

            for k,v in result.iteritems():
                self.data['result_' + k] = v

            if 'result_score' in self.data:
                for k,v in self.data['result_score'].iteritems():
                    self.data['result_score_' + k] = v
                del self.data['result']['score']
                del self.data['result_score']

            del self.data['result']

    def save_attachment(self, attach):
        sha2 = attach['sha2']
        try:
            attachment = models.StatementAttachment.objects.get(sha2=sha2)
            created = False
        except models.StatementAttachment.DoesNotExist:
            attachment = models.StatementAttachment.objects.create(**attach)                
            created = True

            # Since there is a sha2, there must be a payload cached
            # Decode payload from msg object saved in cache and create ContentFile from raw data
            msg = att_cache.get(sha2)
            raw_payload = msg.get_payload(decode=True)
            try:
                payload = ContentFile(raw_payload)
            except:
                try:
                    payload = ContentFile(raw_payload.read())
                except Exception, e:
                    raise e    
            # Save ContentFile payload to attachment model object
            attachment.payload.save(sha2, payload)
        return attachment, created 

    @transaction.commit_on_success
    def populate_attachments(self, attachment_data, attachment_payloads):
        if attachment_data:
            # Iterate through each attachment
            for attach in attachment_data:
                # Get or create based on sha2
                if 'sha2' in attach:
                    attachment, created = self.save_attachment(attach)
                # If no sha2 there must be a fileUrl which is unique
                else:
                    try:
                        attachment = models.StatementAttachment.objects.get(fileUrl=attach['fileUrl'])
                        created = False
                    except Exception, e:
                        attachment = models.StatementAttachment.objects.create(**attach)
                        created = True

                # If have define permission and attachment already has existed
                if self.define and not created:
                    if attachment.display:
                        existing_displays = attachment.display
                    else:
                        existing_displays = {}

                    if attachment.description:
                        existing_descriptions = attachment.description
                    else:
                        existing_descriptions = {}

                    # Save displays
                    if 'display' in attach:
                        attachment.display = dict(existing_displays.items() + attach['display'].items())

                    if 'description' in attach:
                        attachment.description = dict(existing_descriptions.items() + attach['description'].items())
                    attachment.save()

                # Add each attach to the stmt
                self.model_object.attachments.add(attachment)

                # Delete everything in cache for this statement
                if attachment_payloads:
                    att_cache.delete_many(attachment_payloads)
            self.model_object.save()

    def populate_context(self):
        if 'context' in self.data:
            context = self.data['context']

            for k,v in context.iteritems():
                self.data['context_' + k] = v

            if 'context_instructor' in self.data:
                self.data['context_instructor'] = AgentManager(params=self.data['context_instructor'],
                    define=self.define).Agent
                
            if 'context_team' in self.data:
                self.data['context_team'] = AgentManager(params=self.data['context_team'],
                    define=self.define).Agent

            if 'context_statement' in self.data:
                self.data['context_statement'] = self.data['context_statement']['id']

            del self.data['context']
    
    @transaction.commit_on_success
    def build_verb_object(self):
        incoming_verb = self.data['verb']
        verb_id = incoming_verb['id']

        # Get or create the verb
        verb_object, created = models.Verb.objects.get_or_create(verb_id=verb_id)

        # If existing, get existing keys
        if not created:
            if verb_object.display:
                existing_lang_maps = verb_object.display    
            else:
                existing_lang_maps = {}
        else:
            existing_lang_maps = {}

        # Save verb displays
        if 'display' in incoming_verb:
            verb_object.display = dict(existing_lang_maps.items() + incoming_verb['display'].items())
            verb_object.save()
        self.data['verb'] = verb_object

    def build_statement_object(self):
        statement_object_data = self.data['object']

        # If not specified, the object is assumed to be an activity
        if not 'objectType' in statement_object_data:
            statement_object_data['objectType'] = 'Activity'

        valid_agent_objects = ['Agent', 'Group']
        # Check to see if voiding statement
        if self.data['verb'].verb_id == 'http://adlnet.gov/expapi/verbs/voided':
            self.data['object_statementref'] = self.void_statement(statement_object_data['id'])
        else:
            # Check objectType, get object based on type
            if statement_object_data['objectType'] == 'Activity':
                self.data['object_activity'] = ActivityManager(statement_object_data,auth=self.auth, define=self.define).Activity
            elif statement_object_data['objectType'] in valid_agent_objects:
                self.data['object_agent'] = AgentManager(params=statement_object_data, define=self.define).Agent
            elif statement_object_data['objectType'] == 'SubStatement':
                self.data['object_substatement'] = SubStatementManager(statement_object_data, self.auth).model_object
            elif statement_object_data['objectType'] == 'StatementRef':
                self.data['object_statementref'] = models.StatementRef.objects.create(ref_id=statement_object_data['id'])
        del self.data['object']

    def build_authority_object(self):
        # Could still have no authority in stmt if HTTP_AUTH and OAUTH are disabled
        if 'authority' in self.data:
            self.data['authority'] = AgentManager(params=self.data['authority'], define=self.define).Agent

    #Once JSON is verified, populate the statement object
    def populate(self):
        if self.__class__.__name__ == 'StatementManager':
            # If non oauth group won't be sent with the authority key, so if it's a group it's a non
            # oauth group which isn't allowed to be the authority
            self.build_authority_object()
            self.data['voided'] = False
        
        self.build_verb_object()
        self.build_statement_object()

        self.data['actor'] = AgentManager(params=self.data['actor'], define=self.define).Agent

        self.populate_context()
        self.populate_result()

        attachment_data = self.data.pop('attachments', None)
        attachment_payloads = self.data.pop('attachment_payloads', None)
        
        if self.__class__.__name__ == 'StatementManager':
            #Save statement/substatement
            self.model_object = self.save_statement_to_db()
        else:
            self.model_object = self.save_substatement_to_db()

        self.populate_attachments(attachment_data, attachment_payloads)

class SubStatementManager(StatementManager):
    def __init__(self, data, auth):        
        StatementManager.__init__(self, data, auth)
########NEW FILE########
__FILENAME__ = ActivityManagerTests
import base64
import json
from django.test import TestCase
from lrs import models, views
from django.core.urlresolvers import reverse
from django.conf import settings

class ActivityManagerTests(TestCase):
    @classmethod
    def setUpClass(cls):
        print "\n%s" % __name__

    def setUp(self):
        if not settings.HTTP_AUTH_ENABLED:
            settings.HTTP_AUTH_ENABLED = True
        
        self.username = "tester1"
        self.email = "test1@tester.com"
        self.password = "test"
        self.auth = "Basic %s" % base64.b64encode("%s:%s" % (self.username, self.password))
        form = {"username":self.username, "email":self.email,"password":self.password,"password2":self.password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")

        if settings.HTTP_AUTH_ENABLED:
            response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")           

    #Called on all activity django models to see if they were created with the correct fields    
    def do_activity_model(self,realid,act_id, objType):
        self.assertEqual(models.Activity.objects.filter(id=realid)[0].objectType, objType)
        self.assertEqual(models.Activity.objects.filter(id=realid)[0].activity_id, act_id)

    #Called on all activity django models with definitions to see if they were created with the correct 
    # fields
    def do_activity_definition_model(self, act, course, intType, moreInfo=""):
        self.assertEqual(act.activity_definition_type, course)
        self.assertEqual(act.activity_definition_interactionType, intType)
        self.assertEqual(act.activity_definition_moreInfo, moreInfo)

    # Called on all activity django models with extensions to see if they were created with the correct 
    # fields and values. All extensions are created with the same three values and keys
    def do_activity_definition_extensions_model(self, act, key1, key2, key3, value1, value2, value3):
        #Create list comprehesions to easier assess keys and values
        ext_keys = act.activity_definition_extensions.keys()
        ext_vals = act.activity_definition_extensions.values()

        self.assertIn(key1, ext_keys)
        self.assertIn(key2, ext_keys)
        self.assertIn(key3, ext_keys)
        self.assertIn(value1, ext_vals)
        self.assertIn(value2, ext_vals)
        self.assertIn(value3, ext_vals)

    #Called on all activity django models with a correctResponsePattern because of http://adlnet.gov/expapi/activities/cmi.interaction type
    def do_activity_definition_correctResponsePattern_model(self, act, answers):        
        for answer in answers:
            self.assertIn(answer,act.activity_definition_crpanswers)

    #Called on all activity django models with choices because of sequence and choice interactionType
    def do_actvity_definition_choices_model(self, act, clist, dlist):
        # Grab all lang map IDs in act def
        choice_ids = [v['id'] for v in act.activity_definition_choices]
        choice_descs = [v['description'] for v in act.activity_definition_choices]
        
        for c in clist:
            self.assertIn(c,choice_ids)

        for d in dlist:
            self.assertIn(d, choice_descs)

    #Called on all activity django models with scale because of likert interactionType
    def do_actvity_definition_likert_model(self, act, clist, dlist):
        scale_ids = [v['id'] for v in act.activity_definition_scales]        
        scale_descs = [v['description'] for v in act.activity_definition_scales]

        for c in clist:
            self.assertIn(c,scale_ids)

        for d in dlist:
            self.assertIn(d, scale_descs)

    #Called on all activity django models with steps because of performance interactionType
    def do_actvity_definition_performance_model(self, act, slist, dlist):
        step_ids = [v['id'] for v in act.activity_definition_steps]
        step_descs = [v['description'] for v in act.activity_definition_steps]

        for s in slist:
            self.assertIn(s,step_ids)

        for d in dlist:
            self.assertIn(d, step_descs)

    #Called on all activity django models with source and target because of matching interactionType
    def do_actvity_definition_matching_model(self, act, source_id_list, source_desc_list,
                                             target_id_list, target_desc_list):

        source_ids = [v['id'] for v in act.activity_definition_sources]
        source_descs = [v['description'] for v in act.activity_definition_sources]
        
        target_ids = [v['id'] for v in act.activity_definition_targets]
        target_descs = [v['description'] for v in act.activity_definition_targets]

        for s_id in source_id_list:
            self.assertIn(s_id,source_ids)

        for s_desc in source_desc_list:
            self.assertIn(s_desc, source_descs)

        for t_id in target_id_list:
            self.assertIn(t_id,target_ids)

        for t_desc in target_desc_list:
            self.assertIn(t_desc, target_descs)            


    # Test activity that doesn't have a def (populates everything from JSON)
    def test_activity_no_def_json_conform(self):
        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'http://localhost:8000/XAPI/actexample/'}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)
        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        # wrap first assertion around try to see if LRS is started
        try:
            self.assertEqual(name_set.keys()[0], 'en-FR')
        except Exception, e:
            raise Exception("Be sure to have the LRS started for this test " + e.message)
    
        self.assertEqual(name_set.values()[0], 'Example Name')
        self.assertEqual(name_set.keys()[1], 'en-CH')
        self.assertEqual(name_set.values()[1], 'Alt Name')

        self.assertEqual(desc_set.keys()[0], 'en-US')
        self.assertEqual(desc_set.values()[0], 'Example Desc')
        self.assertEqual(desc_set.keys()[1], 'en-CH')
        self.assertEqual(desc_set.values()[1], 'Alt Desc')

        self.do_activity_model(act.id, 'http://localhost:8000/XAPI/actexample/', 'Activity')        
        self.do_activity_definition_model(act, 'type:module','other')

    # Test that passing in the same info gets the same activity
    def test_activity_no_def_not_link_schema_conform1(self):
        st_list = []

        stmt1 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'http://localhost:8000/XAPI/actexample/'}}
        
        stmt2 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'http://localhost:8000/XAPI/actexample/'}}

        st_list.append(stmt1)
        st_list.append(stmt2)

        response = self.client.post(reverse(views.statements), json.dumps(st_list), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_ids = json.loads(response.content)
        st1 = models.Statement.objects.get(statement_id=st_ids[0])
        st2 = models.Statement.objects.get(statement_id=st_ids[1])
        act1 = models.Activity.objects.get(id=st1.object_activity.id)
        act2 = models.Activity.objects.get(id=st2.object_activity.id)
        self.assertEqual(act2.id, act1.id)

    # Test activity that doesn't have a def with extensions (populates everything from XML)
    def test_activity_no_def_schema_conform_extensions(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'http://localhost:8000/XAPI/actexample2/'}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description
        
        # wrap first assertion around try to see if LRS is started
        try:
            self.assertEqual(name_set.keys()[0], 'en-US')
        except Exception, e:
            raise Exception("Be sure to have the LRS started for this test " + e.message)

        self.assertEqual(name_set.values()[0], 'Example Name')

        self.assertEqual(desc_set.keys()[0], 'en-US')
        self.assertEqual(desc_set.values()[0], 'Example Desc')

        self.do_activity_model(act.id, 'http://localhost:8000/XAPI/actexample2/', 'Activity')        
        self.do_activity_definition_model(act, 'type:module','other')

        self.do_activity_definition_extensions_model(act, 'ext:keya', 'ext:keyb', 'ext:keyc','first value',
            'second value', 'third value')

    # Test an activity that has a def, and the provided ID doesn't resolve
    # (should still use values from JSON)
    def test_activity_no_resolve(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity',
            'id':'act://var/www/adllrs/activity/example.json','definition': {'name': {'en-CH':'testname'},
            'description': {'en-US':'testdesc'}, 'type': 'type:course','interactionType': 'other'}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-CH')
        self.assertEqual(name_set.values()[0], 'testname')

        self.assertEqual(desc_set.keys()[0], 'en-US')
        self.assertEqual(desc_set.values()[0], 'testdesc')

        self.do_activity_model(act.id, 'act://var/www/adllrs/activity/example.json', 'Activity')        
        self.do_activity_definition_model(act, 'type:course', 'other')

    # Test an activity that has a def (should use values from payload and override JSON from ID)
    def test_activity_from_id(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity',
                'id':'http://localhost:8000/XAPI/actexample4/','definition': {'name': {'en-FR': 'name'},
                'description': {'en-FR':'desc'}, 'type': 'type:course','interactionType': 'other'}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)[0]
        st = models.Statement.objects.get(statement_id=st_id)
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-FR')
        self.assertEqual(name_set.values()[0], 'name')

        self.assertEqual(desc_set.keys()[0], 'en-FR')
        self.assertEqual(desc_set.values()[0], 'desc')

        self.do_activity_model(act.id, 'http://localhost:8000/XAPI/actexample4/', 'Activity')        
        self.do_activity_definition_model(act, 'type:course','other')

    # Test an activity that has a def and the ID resolves (should use values from payload)
    def test_activity_id_resolve(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id': 'http://localhost:8000/XAPI/',
                'definition': {'name': {'en-GB':'testname'},'description': {'en-GB':'testdesc1'},
                'type': 'type:link','interactionType': 'other'}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description
        
        self.assertEqual(name_set.keys()[0], 'en-GB')
        self.assertEqual(name_set.values()[0], 'testname')

        self.assertEqual(desc_set.keys()[0], 'en-GB')
        self.assertEqual(desc_set.values()[0], 'testdesc1')

        self.do_activity_model(act.id, 'http://localhost:8000/XAPI/', 'Activity')        
        self.do_activity_definition_model(act, 'type:link', 'other')

    # Throws exception because incoming data is not JSON
    def test_activity_not_json(self):
        stmt1 = "This string should throw exception since it's not JSON"

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, "Cannot evaluate data into dictionary to parse -- Error: This string should throw exception since it's not JSON")

    #Test activity where given URL isn't URI
    def test_activity_invalid_activity_id(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'id': 'foo',
                'objectType':'Activity','definition': {'name': {'en-GB':'testname'},
                'description': {'en-GB':'testdesc'}, 'type': 'type:link','interactionType': 'other'}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Activity id with value foo was not a valid URI')

    #Test activity with definition - must retrieve activity object in order to test definition from DB
    def test_activity_definition(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'id':'act:fooc',
                'definition': {'name': {'en-GB':'testname'},'description': {'en-US':'testdesc'}, 
                'type': 'type:course','interactionType': 'other'}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")       
        self.assertEqual(response.status_code, 200)

        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description
        
        self.assertEqual(name_set.keys()[0], 'en-GB')
        self.assertEqual(name_set.values()[0], 'testname')

        self.assertEqual(desc_set.keys()[0], 'en-US')
        self.assertEqual(desc_set.values()[0], 'testdesc')

        self.do_activity_model(act.id,'act:fooc', 'Activity')        
        self.do_activity_definition_model(act, 'type:course', 'other')

    # Test activity with definition that contains extensions - need to retrieve activity and activity definition objects
    # in order to test extenstions
    def test_activity_definition_extensions(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id':'act:food',
                'definition': {'name': {'en-FR':'testname2'},'description': {'en-CH':'testdesc2'},
                'type': 'type:course','interactionType': 'other', 'extensions': {'ext:key1': 'value1',
                'ext:key2': 'value2','ext:key3': 'value3'}}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-FR')
        self.assertEqual(name_set.values()[0], 'testname2')

        self.assertEqual(desc_set.keys()[0], 'en-CH')
        self.assertEqual(desc_set.values()[0], 'testdesc2')

        self.do_activity_model(act.id,'act:food', 'Activity')        
        self.do_activity_definition_model(act, 'type:course','other')

        self.do_activity_definition_extensions_model(act, 'ext:key1', 'ext:key2', 'ext:key3',
            'value1', 'value2', 'value3')

    def test_multiple_names_and_descs(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id':'act:food',
                'definition': {'name': {'en-FR':'testname2','en-US': 'testnameEN'},'description': {'en-CH':'testdesc2',
                'en-GB': 'testdescGB'},'type': 'type:course','interactionType': 'other', 'extensions': {'ext:key1': 'value1',
                'ext:key2': 'value2','ext:key3': 'value3'}}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)
        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-US')
        self.assertEqual(name_set.values()[0], 'testnameEN')
        self.assertEqual(name_set.keys()[1], 'en-FR')
        self.assertEqual(name_set.values()[1], 'testname2')

        self.assertEqual(desc_set.keys()[0], 'en-GB')
        self.assertEqual(desc_set.values()[0], 'testdescGB')
        self.assertEqual(desc_set.keys()[1], 'en-CH')
        self.assertEqual(desc_set.values()[1], 'testdesc2')

        self.do_activity_model(act.id,'act:food', 'Activity')        
        self.do_activity_definition_model(act, 'type:course', 'other')

        self.do_activity_definition_extensions_model(act, 'ext:key1', 'ext:key2', 'ext:key3',
            'value1', 'value2','value3')


    #Test activity with definition given wrong interactionType (won't create one)
    def test_activity_definition_wrong_interactionType(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 
                'id':'http://facebook.com','definition': {'name': {'en-US':'testname2'},
                'description': {'en-GB':'testdesc2'}, 'type': 'http://adlnet.gov/expapi/activities/cmi.interaction',
                'interactionType': 'intType2', 'correctResponsesPattern': 'response',
                'extensions': {'ext:key1': 'value1', 'ext:key2': 'value2','ext:key3': 'value3'}}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Activity definition interactionType intType2 is not valid')
     
    #Test activity with definition that is http://adlnet.gov/expapi/activities/cmi.interaction and true-false interactionType
    def test_activity_definition_cmiInteraction_true_false(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id':'act:fooe',
                'definition': {'name': {'en-FR':'testname2'},'description': {'en-US':'testdesc2'}, 
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'true-false',
                'correctResponsesPattern': ['true'] ,'extensions': {'ext:key1': 'value1', 'ext:key2': 'value2',
                'ext:key3': 'value3'}}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-FR')
        self.assertEqual(name_set.values()[0], 'testname2')

        self.assertEqual(desc_set.keys()[0], 'en-US')
        self.assertEqual(desc_set.values()[0], 'testdesc2')        

        self.do_activity_model(act.id,'act:fooe', 'Activity')                
        self.do_activity_definition_model(act, 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'true-false')

        self.do_activity_definition_extensions_model(act, 'ext:key1', 'ext:key2', 'ext:key3',
            'value1','value2', 'value3')

        self.do_activity_definition_correctResponsePattern_model(act, ['true'])
    
    #Test activity with definition that is http://adlnet.gov/expapi/activities/cmi.interaction and multiple choice interactionType
    def test_activity_definition_cmiInteraction_multiple_choice(self):    
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id':'act:foof',
                'definition': {'name': {'en-US':'testname1'},'description': {'en-US':'testdesc1'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'choice',
                'correctResponsesPattern': ['golf', 'tetris'],'choices':[{'id': 'golf', 
                'description': {'en-US':'Golf Example', 'en-GB': 'GOLF'}},{'id': 'tetris',
                'description':{'en-US': 'Tetris Example', 'en-GB': 'TETRIS'}}, {'id':'facebook', 
                'description':{'en-US':'Facebook App', 'en-GB': 'FACEBOOK'}},{'id':'scrabble', 
                'description': {'en-US': 'Scrabble Example', 'en-GB': 'SCRABBLE'}}],'extensions': {'ext:key1': 'value1',
                'ext:key2': 'value2','ext:key3': 'value3'}}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-US')
        self.assertEqual(name_set.values()[0], 'testname1')

        self.assertEqual(desc_set.keys()[0], 'en-US')
        self.assertEqual(desc_set.values()[0], 'testdesc1')

        self.do_activity_model(act.id,'act:foof', 'Activity')
        self.do_activity_definition_model(act, 'http://adlnet.gov/expapi/activities/cmi.interaction', 'choice')

        self.do_activity_definition_extensions_model(act, 'ext:key1', 'ext:key2', 'ext:key3',
            'value1', 'value2', 'value3')

        self.do_activity_definition_correctResponsePattern_model(act, ['golf', 'tetris'])
        
        #Check model choice values
        clist = ['golf', 'tetris', 'facebook', 'scrabble']
        dlist = [{'en-GB': 'GOLF', 'en-US': 'Golf Example'}, {'en-GB': 'TETRIS', 'en-US': 'Tetris Example'},
        {'en-GB': 'FACEBOOK', 'en-US': 'Facebook App'}, {'en-GB': 'SCRABBLE', 'en-US': 'Scrabble Example'}]

        self.do_actvity_definition_choices_model(act, clist, dlist)        
        
    #Test activity with definition that is http://adlnet.gov/expapi/activities/cmi.interaction and multiple choice but missing choices (won't create it)
    def test_activity_definition_cmiInteraction_multiple_choice_no_choices(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 
                'id':'http://wikipedia.org','definition': {'name': {'en-US':'testname2'},
                'description': {'en-US':'testdesc2'},'type': 'http://adlnet.gov/expapi/activities/cmi.interaction',
                'interactionType': 'choice','correctResponsesPattern': ['golf', 'tetris'],
                'extensions': {'ext:key1': 'value1', 'ext:key2': 'value2','ext:key3': 'value3'}}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Activity definition is missing choices')

    #Test activity with definition that is http://adlnet.gov/expapi/activities/cmi.interaction and fill in interactionType
    def test_activity_definition_cmiInteraction_fill_in(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id':'act:foog',
                'definition': {'name': {'en-FR':'testname2'},'description': {'en-FR':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'fill-in',
                'correctResponsesPattern': ['Fill in answer'],'extensions': {'ext:key1': 'value1',
                'ext:key2': 'value2', 'ext:key3': 'value3'}}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-FR')
        self.assertEqual(name_set.values()[0], 'testname2')

        self.assertEqual(desc_set.keys()[0], 'en-FR')
        self.assertEqual(desc_set.values()[0], 'testdesc2')

        self.do_activity_model(act.id,'act:foog', 'Activity')

        self.do_activity_definition_model(act, 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'fill-in')

        self.do_activity_definition_extensions_model(act, 'ext:key1', 'ext:key2', 'ext:key3',
            'value1', 'value2', 'value3')

        self.do_activity_definition_correctResponsePattern_model(act, ['Fill in answer'])

    #Test activity with definition that is http://adlnet.gov/expapi/activities/cmi.interaction and long fill in interactionType
    def test_activity_definition_cmiInteraction_long_fill_in(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id':'act:fooh',
                'definition': {'name': {'en-FR':'testname2'},'description': {'en-FR':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'fill-in',
                'correctResponsesPattern': ['Long fill in answer'],'extensions': {'ext:key1': 'value1',
                'ext:key2': 'value2','ext:key3': 'value3'}}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-FR')
        self.assertEqual(name_set.values()[0], 'testname2')

        self.assertEqual(desc_set.keys()[0], 'en-FR')
        self.assertEqual(desc_set.values()[0], 'testdesc2')

        self.do_activity_model(act.id, 'act:fooh', 'Activity')

        self.do_activity_definition_model(act, 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'fill-in')

        self.do_activity_definition_extensions_model(act, 'ext:key1', 'ext:key2', 'ext:key3',
            'value1', 'value2', 'value3')

        self.do_activity_definition_correctResponsePattern_model(act, ['Long fill in answer'])

    #Test activity with definition that is http://adlnet.gov/expapi/activities/cmi.interaction and likert interactionType
    def test_activity_definition_cmiInteraction_likert(self):    
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id':'act:fooi',
                'definition': {'name': {'en-CH':'testname2'},'description': {'en-CH':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'likert',
                'correctResponsesPattern': ['likert_3'],'scale':[{'id': 'likert_0',
                'description': {'en-US':'Its OK', 'en-GB': 'Tis OK'}},{'id': 'likert_1',
                'description':{'en-US': 'Its Pretty Cool', 'en-GB':'Tis Pretty Cool'}}, {'id':'likert_2',
                'description':{'en-US':'Its Cool Cool', 'en-GB':'Tis Cool Cool'}},
                {'id':'likert_3', 'description': {'en-US': 'Its Gonna Change the World'}}]}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-CH')
        self.assertEqual(name_set.values()[0], 'testname2')

        self.assertEqual(desc_set.keys()[0], 'en-CH')
        self.assertEqual(desc_set.values()[0], 'testdesc2')

        self.do_activity_model(act.id, 'act:fooi', 'Activity')

        self.do_activity_definition_model(act, 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'likert')

        self.do_activity_definition_correctResponsePattern_model(act, ['likert_3'])

        #Check model choice values
        clist = ['likert_0', 'likert_1', 'likert_2', 'likert_3']
        dlist = [{'en-GB': 'Tis OK', 'en-US': 'Its OK'},{'en-GB': 'Tis Pretty Cool', 'en-US': 'Its Pretty Cool'},
                 {'en-GB': 'Tis Cool Cool', 'en-US': 'Its Cool Cool'}, {'en-US': 'Its Gonna Change the World'}]
        
        self.do_actvity_definition_likert_model(act, clist, dlist)

    #Test activity with definition that is http://adlnet.gov/expapi/activities/cmi.interaction and matching interactionType
    def test_activity_definition_cmiInteraction_matching(self):    
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id':'act:fooj',
                'definition': {'name': {'en-CH':'testname2'},'description': {'en-CH':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'matching',
                'correctResponsesPattern': ['lou.3,tom.2,andy.1'],'source':[{'id': 'lou',
                'description': {'en-US':'Lou', 'it': 'Luigi'}},{'id': 'tom','description':{'en-US': 'Tom', 'it':'Tim'}},
                {'id':'andy', 'description':{'en-US':'Andy'}}],'target':[{'id':'1',
                'description':{'en-US': 'SCORM Engine'}},{'id':'2','description':{'en-US': 'Pure-sewage'}},
                {'id':'3', 'description':{'en-US': 'SCORM Cloud', 'en-CH': 'cloud'}}]}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-CH')
        self.assertEqual(name_set.values()[0], 'testname2')

        self.assertEqual(desc_set.keys()[0], 'en-CH')
        self.assertEqual(desc_set.values()[0], 'testdesc2')

        self.do_activity_model(act.id, 'act:fooj', 'Activity')

        self.do_activity_definition_model(act, 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'matching')

        self.do_activity_definition_correctResponsePattern_model(act, ['lou.3,tom.2,andy.1'])

        #Check model choice values
        source_id_list = ['lou', 'tom', 'andy']
        source_desc_list = [{'en-US': 'Lou', 'it': 'Luigi'}, {'en-US': 'Tom', 'it': 'Tim'}, {'en-US': 'Andy'}]
        target_id_list = ['1','2','3']
        target_desc_list = [{"en-US": "SCORM Engine"},{"en-US": "Pure-sewage"},
                            {'en-US': 'SCORM Cloud', 'en-CH': 'cloud'}]

        self.do_actvity_definition_matching_model(act, source_id_list, source_desc_list,
                                                  target_id_list, target_desc_list)

    #Test activity with definition that is http://adlnet.gov/expapi/activities/cmi.interaction and performance interactionType
    def test_activity_definition_cmiInteraction_performance(self):    
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id':'act:fook',
                'definition': {'name': {'en-us':'testname2'},'description': {'en-us':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'performance',
                'correctResponsesPattern': ['pong.1,dg.10,lunch.4'],'steps':[{'id': 'pong',
                'description': {'en-US':'Net pong matches won', 'en-GB': 'won'}},{'id': 'dg',
                'description':{'en-US': 'Strokes over par in disc golf at Liberty'}},
                {'id':'lunch', 'description':{'en-US':'Lunch having been eaten'}}]}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description
        
        self.assertEqual(name_set.keys()[0], 'en-us')
        self.assertEqual(name_set.values()[0], 'testname2')

        self.assertEqual(desc_set.keys()[0], 'en-us')
        self.assertEqual(desc_set.values()[0], 'testdesc2')        

        self.do_activity_model(act.id, 'act:fook', 'Activity')

        self.do_activity_definition_model(act, 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'performance')

        self.do_activity_definition_correctResponsePattern_model(act, ['pong.1,dg.10,lunch.4'])

        #Check model choice values
        slist = ['pong', 'dg', 'lunch']
        dlist = [{'en-GB': 'won', 'en-US': 'Net pong matches won'}, {'en-US': 'Strokes over par in disc golf at Liberty'},
                    {'en-US': 'Lunch having been eaten'}]
        
        self.do_actvity_definition_performance_model(act, slist, dlist)

    # Test activity with definition that is http://adlnet.gov/expapi/activities/cmi.interaction and sequencing interactionType
    def test_activity_definition_cmiInteraction_sequencing(self):    
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id':'act:fool',
                'definition': {'name': {'en-GB':'testname2'},'description': {'en-GB':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'sequencing',
                'correctResponsesPattern': ['lou,tom,andy,aaron'],'choices':[{'id': 'lou',
                'description': {'en-US':'Lou'}},{'id': 'tom','description':{'en-US': 'Tom'}},
                {'id':'andy', 'description':{'en-US':'Andy'}},{'id':'aaron',
                'description':{'en-US':'Aaron', 'en-GB': 'Erin'}}]}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-GB')
        self.assertEqual(name_set.values()[0], 'testname2')

        self.assertEqual(desc_set.keys()[0], 'en-GB')
        self.assertEqual(desc_set.values()[0], 'testdesc2')

        self.do_activity_model(act.id, 'act:fool', 'Activity')

        self.do_activity_definition_model(act, 'http://adlnet.gov/expapi/activities/cmi.interaction', 'sequencing')

        self.do_activity_definition_correctResponsePattern_model(act, ['lou,tom,andy,aaron'])
        #Check model choice values
        clist = ['lou', 'tom', 'andy', 'aaron']
        dlist = [{"en-US": "Lou"},{"en-US": "Tom"},{"en-US": "Andy"}, {'en-GB': 'Erin', 'en-US': 'Aaron'}]
        self.do_actvity_definition_choices_model(act, clist, dlist)

    #Test activity with definition that is http://adlnet.gov/expapi/activities/cmi.interaction and numeric interactionType
    def test_activity_definition_cmiInteraction_numeric(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id':'act:foom',
                'definition': {'name': {'en-CH':'testname2'},'description': {'en-CH':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'numeric','correctResponsesPattern': ['4'],
                'extensions': {'ext:key1': 'value1', 'ext:key2': 'value2','ext:key3': 'value3'}}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-CH')
        self.assertEqual(name_set.values()[0], 'testname2')

        self.assertEqual(desc_set.keys()[0], 'en-CH')
        self.assertEqual(desc_set.values()[0], 'testdesc2')

        self.do_activity_model(act.id, 'act:foom', 'Activity')

        self.do_activity_definition_model(act, 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'numeric')

        self.do_activity_definition_extensions_model(act, 'ext:key1', 'ext:key2', 'ext:key3',
            'value1', 'value2', 'value3')

        self.do_activity_definition_correctResponsePattern_model(act, ['4'])

    #Test activity with definition that is http://adlnet.gov/expapi/activities/cmi.interaction and other interactionType
    def test_activity_definition_cmiInteraction_other(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id': 'act:foon',
                'definition': {'name': {'en-FR':'testname2'},'description': {'en-FR':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'other',
                'correctResponsesPattern': ['(35.937432,-86.868896)'],'extensions': {'ext:key1': 'value1',
                'ext:key2': 'value2','ext:key3': 'value3'}}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-FR')
        self.assertEqual(name_set.values()[0], 'testname2')

        self.assertEqual(desc_set.keys()[0], 'en-FR')
        self.assertEqual(desc_set.values()[0], 'testdesc2')

        self.do_activity_model(act.id, 'act:foon', 'Activity')

        self.do_activity_definition_model(act, 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'other')

        self.do_activity_definition_extensions_model(act, 'ext:key1', 'ext:key2', 'ext:key3',
            'value1', 'value2', 'value3')

        self.do_activity_definition_correctResponsePattern_model(act, ['(35.937432,-86.868896)'])

    # Should be the same, no auth required
    def test_multiple_activities(self):
        stmt_list = []
        stmt1 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'act:foob'}}

        stmt2 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'act:foob'}}

        stmt3 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'act:foob'}}

        stmt4 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'act:foon'}}
        stmt_list.append(stmt1)
        stmt_list.append(stmt2)
        stmt_list.append(stmt3)
        stmt_list.append(stmt4)

        response = self.client.post(reverse(views.statements), json.dumps(stmt_list), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(response.status_code, 200)
        st_ids = json.loads(response.content)
        st1 = models.Statement.objects.get(statement_id=st_ids[0])
        st2 = models.Statement.objects.get(statement_id=st_ids[1])
        st3 = models.Statement.objects.get(statement_id=st_ids[2])
        st4 = models.Statement.objects.get(statement_id=st_ids[3])
        act1 = models.Activity.objects.get(id=st1.object_activity.id)
        act2 = models.Activity.objects.get(id=st2.object_activity.id)
        act3 = models.Activity.objects.get(id=st3.object_activity.id)
        act4 = models.Activity.objects.get(id=st4.object_activity.id)

        self.assertEqual(act1.id, act2.id)
        self.assertEqual(act1.id, act3.id)
        self.assertEqual(act2.id, act3.id)
        self.assertNotEqual(act1.id, act4.id)

    def test_language_map_description_name(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id': 'act:foz',
                'definition': {'name': {'en-US':'actname'},'description': {'en-us':'actdesc'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'other',
                    'correctResponsesPattern': ['(35,-86)']}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[0], 'en-US')
        self.assertEqual(name_set.values()[0], 'actname')

        self.assertEqual(desc_set.keys()[0], 'en-us')
        self.assertEqual(desc_set.values()[0], 'actdesc')
        self.do_activity_model(act.id, 'act:foz', 'Activity')

        self.do_activity_definition_model(act, 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'other')

    def test_multiple_activities_update_name(self):
        stmt_list = []
        stmt1 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'act:foob',
            'definition':{'name': {'en-US':'actname'},'description': {'en-us':'actdesc'}, 
            'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'other','correctResponsesPattern': ['(35,-86)']}}}

        stmt2 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'act:foob',
            'definition':{'name': {'en-US':'actname2'},'description': {'en-us':'actdesc'}, 
            'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'other','correctResponsesPattern': ['(35,-86)']}}}

        stmt_list.append(stmt1)
        stmt_list.append(stmt2)

        response = self.client.post(reverse(views.statements), json.dumps(stmt_list), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_ids = json.loads(response.content)
        st1 = models.Statement.objects.get(statement_id=st_ids[0])
        st2 = models.Statement.objects.get(statement_id=st_ids[1])        
        act1 = models.Activity.objects.get(id=st1.object_activity.id)
        act2 = models.Activity.objects.get(id=st2.object_activity.id)

        self.do_activity_model(act1.id, 'act:foob', 'Activity')

        name_set1 = act1.activity_definition_name
        desc_set1 = act1.activity_definition_description
        
        self.assertEqual(name_set1.keys()[0], 'en-US')
        self.assertEqual(name_set1.values()[0], 'actname2')

        self.assertEqual(desc_set1.keys()[0], 'en-us')
        self.assertEqual(desc_set1.values()[0], 'actdesc')        


        self.do_activity_definition_model(act1, 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'other')

        self.do_activity_model(act2.id, 'act:foob', 'Activity')

        name_set2 = act2.activity_definition_name
        desc_set2 = act2.activity_definition_description
        
        self.assertEqual(name_set2.keys()[0], 'en-US')
        self.assertEqual(name_set2.values()[0], 'actname2')

        self.assertEqual(desc_set2.keys()[0], 'en-us')
        self.assertEqual(desc_set2.values()[0], 'actdesc')        

        self.do_activity_definition_model(act2, 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'other')

        self.assertEqual(act1, act2)
        
    def test_multiple_activities_update_desc(self):
        stmt_list = []
        stmt1 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'act:foobe',
            'definition':{'name': {'en-US':'actname'},'description': {'en-us':'actdesc'}, 
            'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'other','correctResponsesPattern': ['(35,-86)']}}}

        stmt2 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'act:foobe',
            'definition':{'name': {'en-US':'actname'},'description': {'en-us':'actdesc2'}, 
            'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'other','correctResponsesPattern': ['(35,-86)']}}}

        stmt_list.append(stmt1)
        stmt_list.append(stmt2)

        response = self.client.post(reverse(views.statements), json.dumps(stmt_list), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_ids = json.loads(response.content)
        st1 = models.Statement.objects.get(statement_id=st_ids[0])
        st2 = models.Statement.objects.get(statement_id=st_ids[1])        
        act1 = models.Activity.objects.get(id=st1.object_activity.id)
        act2 = models.Activity.objects.get(id=st2.object_activity.id)

        self.do_activity_model(act1.id, 'act:foobe', 'Activity')

        name_set1 = act1.activity_definition_name
        desc_set1 = act1.activity_definition_description
        
        self.assertEqual(name_set1.keys()[0], 'en-US')
        self.assertEqual(name_set1.values()[0], 'actname')

        self.assertEqual(desc_set1.keys()[0], 'en-us')
        self.assertEqual(desc_set1.values()[0], 'actdesc2')
        self.do_activity_definition_model(act1, 'http://adlnet.gov/expapi/activities/cmi.interaction', 'other')

        self.do_activity_model(act2.id, 'act:foobe', 'Activity')

        name_set2 = act2.activity_definition_name
        desc_set2 = act2.activity_definition_description

        self.assertEqual(name_set2.keys()[0], 'en-US')
        self.assertEqual(name_set2.values()[0], 'actname')

        self.assertEqual(desc_set2.keys()[0], 'en-us')
        self.assertEqual(desc_set2.values()[0], 'actdesc2')        
        self.do_activity_definition_model(act2, 'http://adlnet.gov/expapi/activities/cmi.interaction', 'other')

        self.assertEqual(act1, act2)

    def test_multiple_activities_update_both(self):
        stmt_list = []
        stmt1 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'act:foob',
            'definition':{'name': {'en-CH':'actname'},'description': {'en-FR':'actdesc'}, 
            'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'other','correctResponsesPattern': ['(35,-86)']}}}

        stmt2 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'act:foob',
            'definition':{'name': {'en-CH':'actname2'},'description': {'en-FR':'actdesc2'}, 
            'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'other','correctResponsesPattern': ['(35,-86)']}}}

        stmt_list.append(stmt1)
        stmt_list.append(stmt2)

        response = self.client.post(reverse(views.statements), json.dumps(stmt_list), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_ids = json.loads(response.content)
        st1 = models.Statement.objects.get(statement_id=st_ids[0])
        st2 = models.Statement.objects.get(statement_id=st_ids[1])        
        act1 = models.Activity.objects.get(id=st1.object_activity.id)
        act2 = models.Activity.objects.get(id=st2.object_activity.id)

        self.do_activity_model(act1.id, 'act:foob', 'Activity')

        name_set1 = act1.activity_definition_name
        desc_set1 = act1.activity_definition_description
        
        self.assertEqual(name_set1.keys()[0], 'en-CH')
        self.assertEqual(name_set1.values()[0], 'actname2')

        self.assertEqual(desc_set1.keys()[0], 'en-FR')
        self.assertEqual(desc_set1.values()[0], 'actdesc2')

        self.do_activity_definition_model(act1, 'http://adlnet.gov/expapi/activities/cmi.interaction', 'other')

        self.do_activity_model(act2.id, 'act:foob', 'Activity')

        name_set2 = act2.activity_definition_name
        desc_set2 = act2.activity_definition_description
        
        self.assertEqual(name_set2.keys()[0], 'en-CH')
        self.assertEqual(name_set2.values()[0], 'actname2')

        self.assertEqual(desc_set2.keys()[0], 'en-FR')
        self.assertEqual(desc_set2.values()[0], 'actdesc2')         
        self.do_activity_definition_model(act2,'http://adlnet.gov/expapi/activities/cmi.interaction',
            'other')

        self.assertEqual(act1, act2)

    def test_multiple_activities_update_both_and_add(self):
        stmt_list = []
        stmt1 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'act:foob',
            'definition':{'name': {'en-CH':'actname'},'description': {'en-FR':'actdesc'}, 
            'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'other','correctResponsesPattern': ['(35,-86)']}}}

        stmt2 = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'act:foob',
            'definition':{'name': {'en-CH':'actname2', 'en-US': 'altname'},'description': {'en-FR':'actdesc2', 'en-GB': 'altdesc'}, 
            'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'other','correctResponsesPattern': ['(35,-86)']}}}

        stmt_list.append(stmt1)
        stmt_list.append(stmt2)

        response = self.client.post(reverse(views.statements), json.dumps(stmt_list), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_ids = json.loads(response.content)
        st1 = models.Statement.objects.get(statement_id=st_ids[0])
        st2 = models.Statement.objects.get(statement_id=st_ids[1])        
        act1 = models.Activity.objects.get(id=st1.object_activity.id)
        act2 = models.Activity.objects.get(id=st2.object_activity.id)

        self.do_activity_model(act1.id, 'act:foob', 'Activity')

        name_set1 = act1.activity_definition_name
        desc_set1 = act1.activity_definition_description
        
        self.assertEqual(name_set1.keys()[1], 'en-CH')
        self.assertEqual(name_set1.values()[1], 'actname2')
        self.assertEqual(name_set1.keys()[0], 'en-US')
        self.assertEqual(name_set1.values()[0], 'altname')

        self.assertEqual(desc_set1.keys()[1], 'en-FR')
        self.assertEqual(desc_set1.values()[1], 'actdesc2')
        self.assertEqual(desc_set1.keys()[0], 'en-GB')
        self.assertEqual(desc_set1.values()[0], 'altdesc')

        self.do_activity_definition_model(act1, 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'other')

        self.do_activity_model(act2.id, 'act:foob', 'Activity')

        name_set2 = act2.activity_definition_name
        desc_set2 = act2.activity_definition_description

        self.assertEqual(name_set2.keys()[1], 'en-CH')
        self.assertEqual(name_set2.values()[1], 'actname2')
        self.assertEqual(name_set2.keys()[0], 'en-US')
        self.assertEqual(name_set2.values()[0], 'altname')

        self.assertEqual(desc_set2.keys()[1], 'en-FR')
        self.assertEqual(desc_set2.values()[1], 'actdesc2')
        self.assertEqual(desc_set2.keys()[0], 'en-GB')
        self.assertEqual(desc_set2.values()[0], 'altdesc')

        self.do_activity_definition_model(act2,'http://adlnet.gov/expapi/activities/cmi.interaction',
            'other')

        self.assertEqual(act1, act2)
        
    def test_del_act(self):
        stmt1 = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType':'Activity', 'id': 'act:foob',
            'definition':{'name': {'en-CH':'actname'},'description': {'en-FR':'actdesc'}, 
            'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'other',
            'correctResponsesPattern': ['(35,-86)']}}})

        response = self.client.post(reverse(views.statements), stmt1, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)
        st = models.Statement.objects.get(statement_id=st_id[0])
        act = models.Activity.objects.get(id=st.object_activity.id)

        self.assertEqual(1, len(models.Activity.objects.all()))
        act.delete()
        self.assertEqual(0, len(models.Activity.objects.all()))

########NEW FILE########
__FILENAME__ = ActivityProfileTests
import ast
import json
import time
import hashlib
import urllib
from os import path
import base64
from django.test import TestCase
from django.conf import settings
from django.core.urlresolvers import reverse
from lrs import models, views
from lrs.objects.ActivityManager import ActivityManager

class ActivityProfileTests(TestCase):
    test_activityId1 = 'act:act-1'
    test_activityId2 = 'act:act-2'
    test_activityId3 = 'act:act-3'
    other_activityId = 'act:act-other'
    content_type = "application/json"
    testprofileId1 = "http://profile.test.id/test/1"
    testprofileId2 = "http://profile.test.id/test/2"
    testprofileId3 = "http://profile.test.id/test/3"
    otherprofileId1 = "http://profile.test.id/other/1"

    @classmethod
    def setUpClass(cls):
        print "\n%s" % __name__

    def setUp(self):
        self.username = "tester"
        self.email = "test@tester.com"
        self.password = "test"
        self.auth = "Basic %s" % base64.b64encode("%s:%s" % (self.username, self.password))
        form = {'username':self.username, 'email': self.email,'password':self.password,'password2':self.password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")

        self.testparams1 = {"profileId": self.testprofileId1, "activityId": self.test_activityId1}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(self.testparams1))
        self.testprofile1 = {"test":"put profile 1","obj":{"activity":"test"}}
        self.put1 = self.client.put(path, json.dumps(self.testprofile1), content_type=self.content_type, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        
        self.testparams2 = {"profileId": self.testprofileId2, "activityId": self.test_activityId2}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(self.testparams2))
        self.testprofile2 = {"test":"put profile 2","obj":{"activity":"test"}}
        self.put2 = self.client.put(path, json.dumps(self.testprofile2), content_type=self.content_type, Authorization=self.auth,  X_Experience_API_Version="1.0.0")

        self.testparams3 = {"profileId": self.testprofileId3, "activityId": self.test_activityId3}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(self.testparams3))
        self.testprofile3 = {"test":"put profile 3","obj":{"activity":"test"}}
        self.put3 = self.client.put(path, json.dumps(self.testprofile3), content_type=self.content_type, Authorization=self.auth,  X_Experience_API_Version="1.0.0")

        self.testparams4 = {"profileId": self.otherprofileId1, "activityId": self.other_activityId}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(self.testparams4))
        self.otherprofile1 = {"test":"put profile other","obj":{"activity":"other"}}
        self.put4 = self.client.put(path, json.dumps(self.otherprofile1), content_type=self.content_type, Authorization=self.auth,  X_Experience_API_Version="1.0.0")

        self.testparams5 = {"profileId": self.otherprofileId1, "activityId": self.test_activityId1}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(self.testparams5))
        self.anotherprofile1 = {"test":"put another profile 1","obj":{"activity":"other"}}
        self.put5 = self.client.put(path, json.dumps(self.anotherprofile1), content_type=self.content_type, Authorization=self.auth,  X_Experience_API_Version="1.0.0")

        
    def tearDown(self):
        self.client.delete(reverse(views.activity_profile), self.testparams1, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.client.delete(reverse(views.activity_profile), self.testparams2, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.client.delete(reverse(views.activity_profile), self.testparams3, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.client.delete(reverse(views.activity_profile), self.testparams4, Authorization=self.auth, X_Experience_API_Version="1.0.0")    
        self.client.delete(reverse(views.activity_profile), self.testparams5, Authorization=self.auth, X_Experience_API_Version="1.0.0")    
    
    def test_put(self):
        #Test the puts
        self.assertEqual(self.put1.status_code, 204)

        self.assertEqual(self.put2.status_code, 204)
        
        self.assertEqual(self.put3.status_code, 204)
        
        self.assertEqual(self.put4.status_code, 204)
        
        self.assertEqual(self.put5.status_code, 204)

        #Make sure profiles have correct activities
        self.assertEqual(models.ActivityProfile.objects.filter(profileId=self.testprofileId1)[0].activityId, self.test_activityId1)
        self.assertEqual(models.ActivityProfile.objects.filter(profileId=self.testprofileId2)[0].activityId, self.test_activityId2)
        self.assertEqual(models.ActivityProfile.objects.filter(profileId=self.testprofileId3)[0].activityId, self.test_activityId3)

    def test_put_no_params(self):
        put = self.client.put(reverse(views.activity_profile) ,content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEquals(put.content, 'Error -- activity_profile - method = PUT, but activityId parameter missing..')

    def test_put_no_activityId(self):
        put = self.client.put(reverse(views.activity_profile), {'profileId':'10'},content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEquals(put.content, 'Error -- activity_profile - method = PUT, but activityId parameter missing..')

    def test_put_no_profileId(self):
        testparams = {'activityId':'act:act:act'}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(testparams))
        put = self.client.put(path, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEquals(put.content, 'Error -- activity_profile - method = PUT, but profileId parameter missing..')

    def test_put_etag_missing_on_change(self):
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(self.testparams1))
        profile = {"test":"error - trying to put new profile w/o etag header","obj":{"activity":"test"}}
        response = self.client.put(path, profile, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 409)
        self.assertIn('If-Match and If-None-Match headers were missing', response.content)
        
        r = self.client.get(reverse(views.activity_profile), self.testparams1, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], self.testprofile1['test'])
        self.assertEqual(robj['obj']['activity'], self.testprofile1['obj']['activity'])

    def test_put_etag_right_on_change(self):
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(self.testparams1))
        profile = {"test":"good - trying to put new profile w/ etag header","obj":{"activity":"act:test"}}
        thehash = '"%s"' % hashlib.sha1(json.dumps(self.testprofile1)).hexdigest()
        response = self.client.put(path, json.dumps(profile), content_type=self.content_type, If_Match=thehash, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 204)
        r = self.client.get(reverse(views.activity_profile), self.testparams1, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.content, json.dumps(profile))

    def test_put_etag_wrong_on_change(self):
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(self.testparams1))
        profile = {"test":"error - trying to put new profile w/ wrong etag value","obj":{"activity":"act:test"}}
        thehash = '"%s"' % hashlib.sha1('%s' % 'wrong hash').hexdigest()
        response = self.client.put(path, profile, content_type=self.content_type, If_Match=thehash, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 412)
        self.assertIn('No resources matched', response.content)

        r = self.client.get(reverse(views.activity_profile), self.testparams1, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], self.testprofile1['test'])
        self.assertEqual(robj['obj']['activity'], self.testprofile1['obj']['activity'])

    def test_put_etag_if_none_match_good(self):
        params = {"profileId": 'http://etag.nomatch.good', "activityId": self.test_activityId1}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(params))
        profile = {"test":"good - trying to put new profile w/ if none match etag header","obj":{"activity":"act:test"}}
        response = self.client.put(path, json.dumps(profile), content_type=self.content_type, if_none_match='*', Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 204)
        r = self.client.get(reverse(views.activity_profile), params, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], profile['test'])
        self.assertEqual(robj['obj']['activity'], profile['obj']['activity'])

        r = self.client.delete(reverse(views.activity_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_put_etag_if_none_match_bad(self):
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(self.testparams1))
        profile = {"test":"error - trying to put new profile w/ if none match etag but one exists","obj":{"activity":"act:test"}}
        response = self.client.put(path, profile, content_type=self.content_type, If_None_Match='*', Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 412)
        self.assertEqual(response.content, 'Resource detected')

        r = self.client.get(reverse(views.activity_profile), self.testparams1, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], self.testprofile1['test'])
        self.assertEqual(robj['obj']['activity'], self.testprofile1['obj']['activity'])
  
    def test_get_activity_only(self):
        response = self.client.get(reverse(views.activity_profile), {'activityId':self.test_activityId2}, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, self.testprofileId2)

        params = {'activityId': self.test_activityId2, 'profileId': self.testprofileId2}

        self.client.delete(reverse(views.activity_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_get_activity_profileId(self):
        response = self.client.get(reverse(views.activity_profile), {'activityId':self.test_activityId1,'profileId':self.testprofileId1}, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(response.status_code, 200)
        robj = ast.literal_eval(response.content)
        self.assertEqual(robj['test'], self.testprofile1['test'])
        self.assertEqual(robj['obj']['activity'], self.testprofile1['obj']['activity'])
        resp_hash = hashlib.sha1(response.content).hexdigest()
        self.assertEqual(response['etag'], '"%s"' % resp_hash)    
        params = {'activityId': self.test_activityId1, 'profileId': self.testprofileId1}

        self.client.delete(reverse(views.activity_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")
    
    def test_get_activity_profileId_no_auth(self):
        # Will return 200 if HTTP_AUTH is not enabled
        response = self.client.get(reverse(views.activity_profile), {'activityId':self.test_activityId1,'profileId':self.testprofileId1}, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 401)

    def test_get_activity_profileId_activity_dne(self):
        response = self.client.get(reverse(views.activity_profile), {'activityId':'http://actID','profileId':self.testprofileId1}, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(response.status_code, 404)
        
    def test_get_activity_since_tz(self):
        actid = "test:activity"
        profid = "test://test/tz"
        act = ActivityManager({'objectType':'Activity', 'id': actid})
        params = {"profileId": profid, "activityId": actid}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(params))
        prof = {"test":"timezone since","obj":{"activity":"other"}}
        r = self.client.put(path, json.dumps(prof), content_type=self.content_type, updated="2012-11-11T12:00:00+00:00", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 204)

        since = "2012-11-11T12:00:00-02:00"
        response = self.client.get(reverse(views.activity_profile), {'activityId': actid,'since':since}, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(response.status_code, 200)
        self.assertNotIn(profid, response.content)
        
        params = {"activityId": actid, "profileId": profid}
        self.client.delete(reverse(views.activity_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_get_no_activity_profileId(self):
        response = self.client.get(reverse(views.activity_profile), {'profileId': self.testprofileId3}, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Error -- activity_profile - method = GET, but no activityId parameter.. the activityId parameter is required')

    def test_get_no_activity_since(self):
        since = str(time.time())
        response = self.client.get(reverse(views.activity_profile), {'since':since}, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Error -- activity_profile - method = GET, but no activityId parameter.. the activityId parameter is required')
    
    def test_delete(self):
        response = self.client.delete(reverse(views.activity_profile), {'activityId':self.other_activityId, 'profileId':self.otherprofileId1}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 204)
        self.assertEqual(response.content, '')        

    def test_cors_put(self):
        profileid = 'http://test.cors.put'
        activityid = 'act:test_cors_put-activity'
        
        testparams1 = {"profileId": profileid, "activityId": activityid}
        content = {"test":"put profile 1","obj":{"activity":"act:test"}}
        params = "profileId=%s&activityId=%s&Authorization=%s&content=%s&X-Experience-API-Version=1.0" % (profileid, activityid,self.auth,content)
         
        path = path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode({"method":"PUT"}))
        the_act = ActivityManager({'objectType':'Activity', 'id': activityid})
        thedata = urllib.quote_plus(params)
        put1 = self.client.post(path, thedata, content_type="application/x-www-form-urlencoded")
        self.assertEqual(put1.status_code, 204)
        get1 = self.client.get(reverse(views.activity_profile), testparams1, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(get1.status_code, 200)
        
        import ast
        c = ast.literal_eval(get1.content)
        self.assertEqual(c['test'], content['test'])
        self.client.delete(reverse(views.activity_profile), testparams1, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_cors_put_etag(self):
        pid = 'http://ie.cors.etag/test'
        aid = 'act:ie.cors.etag/test'

        actaid = ActivityManager({'objectType':'Activity', 'id': aid})
        
        params = {"profileId": pid, "activityId": aid}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(self.testparams1))
        tp = {"test":"put example profile for test_cors_put_etag","obj":{"activity":"this should be replaced -- ie cors post/put"}}
        put1 = self.client.put(path, tp, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode({"method":"PUT"}))
        
        content = {"test":"good - trying to put new profile w/ etag header - IE cors","obj":{"activity":"test IE cors etag"}}
        thehash = '"%s"' % hashlib.sha1('%s' % tp).hexdigest()
        thedata = "profileId=%s&activityId=%s&If-Match=%s&Authorization=%s&Content-Type=application/x-www-form-urlencoded&content=%s&X-Experience-API-Version=1.0.0" % (pid, aid, thehash, self.auth, content)

        response = self.client.post(path, thedata, content_type="application/x-www-form-urlencoded")
        
        self.assertEqual(response.status_code, 204)
        r = self.client.get(reverse(views.activity_profile), {'activityId': aid, 'profileId': pid}, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        import ast
        c = ast.literal_eval(r.content)
        self.assertEqual(c['test'], content['test'])

        self.client.delete(reverse(views.activity_profile), {'activityId': aid, 'profileId': pid}, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_tetris_snafu(self):
        params = {"profileId": "http://test.tetris/", "activityId": "act:tetris.snafu"}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(params))
        profile = {"test":"put profile 1","obj":{"activity":"test"}}
        the_act = ActivityManager({'objectType':'Activity', 'id': "act:tetris.snafu"})
        p_r = self.client.put(path, json.dumps(profile), content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(p_r.status_code, 204)
        r = self.client.get(reverse(views.activity_profile), {'activityId': "act:tetris.snafu", 'profileId': "http://test.tetris/"}, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r['Content-Type'], self.content_type)
        self.assertIn("\"", r.content)
        
        self.client.delete(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")

    def test_post_new_profile(self):
        params = {"profileId": "prof:test_post_new_profile", "activityId": "act:test.post.new.prof"}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(params))
        prof = {"test":"post new profile","obj":{"activity":"act:test.post.new.prof"}}
        
        post = self.client.post(path, json.dumps(prof), content_type="application/json", Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 204)
        
        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        self.assertEqual(ast.literal_eval(get.content), prof)
        self.assertEqual(get.get('etag'), '"%s"' % hashlib.sha1(get.content).hexdigest())
        self.client.delete(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")

    def test_post_blank_profile(self):
        params = {"profileId": "prof:test_post_new_profile", "activityId": "act:test.post.new.prof"}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(params))
        prof = ""
        
        post = self.client.post(path, prof, content_type="application/json", Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        
        self.assertEqual(post.status_code, 400)
        self.assertEqual(post.content, 'No body in request')

    def test_post_update_profile(self):
        params = {"profileId": "prof:test_post_update_profile", "activityId": "act:test.post.update.prof"}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(params))
        prof = {"test":"post updated profile","obj":{"activity":"act:test.post.update.prof"}}
        
        post = self.client.post(path, json.dumps(prof), content_type="application/json", Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 204)
        
        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        what = ast.literal_eval(get.content)
        self.assertEqual(what, prof)
        etag = '"%s"' % hashlib.sha1(get.content).hexdigest()
        self.assertEqual(get.get('etag'), etag)

        params = {"profileId": "prof:test_post_update_profile", "activityId": "act:test.post.update.prof"}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(params))
        prof = {"obj":{"activity":"act:test.post.update.prof_changed", "new":"thing"}, "added":"yes"}
        
        post = self.client.post(path, json.dumps(prof), content_type="application/json", Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 409)

        post = self.client.post(path, json.dumps(prof), content_type="application/json", If_Match=etag, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 204)

        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        ret_json = ast.literal_eval(get.content)
        self.assertEqual(ret_json['added'], prof['added'])
        self.assertEqual(ret_json['test'], "post updated profile")
        self.assertEqual(ret_json['obj']['activity'], prof['obj']['activity'])
        self.assertEqual(ret_json['obj']['new'], prof['obj']['new'])
        self.assertEqual(get.get('etag'), '"%s"' % hashlib.sha1(get.content).hexdigest())

        self.client.delete(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")

    def test_post_and_put_profile(self):
        params = {"profileId": "prof:test_post_and_put_profile", "activityId": "act:test.post.put.prof"}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(params))
        prof = {"test":"post and put profile","obj":{"activity":"act:test.post.put.prof"}}
        
        post = self.client.post(path, json.dumps(prof), content_type="application/json", Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 204)
        
        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        self.assertEqual(ast.literal_eval(get.content), prof)
        self.assertEqual(get.get('etag'), '"%s"' % hashlib.sha1(get.content).hexdigest())

        params = {"profileId": "prof:test_post_and_put_profile", "activityId": "act:test.post.put.prof"}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(params))
        prof = {"wipe":"new data"}
        thehash = get.get('etag')
        
        put = self.client.put(path, json.dumps(prof), content_type="application/json", If_Match=thehash, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(put.status_code, 204)
        
        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        self.assertEqual(ast.literal_eval(get.content), prof)
        etag = '"%s"' % hashlib.sha1(get.content).hexdigest()
        self.assertEqual(get.get('etag'), etag)

        params = {"profileId": "prof:test_post_and_put_profile", "activityId": "act:test.post.put.prof"}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(params))
        prof = {"test":"post updated profile","obj":{"activity":"act:test.post.update.prof_changed", "new":"thing"}, "added":"yes"}
        
        post = self.client.post(path, json.dumps(prof), content_type="application/json", Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 409)

        post = self.client.post(path, json.dumps(prof), content_type="application/json", If_Match=etag, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 204)

        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        ret_json = ast.literal_eval(get.content)
        self.assertEqual(ret_json['wipe'], "new data")
        self.assertEqual(ret_json['added'], prof['added'])
        self.assertEqual(ret_json['test'], prof['test'])
        self.assertEqual(ret_json['obj']['activity'], prof['obj']['activity'])
        self.assertEqual(ret_json['obj']['new'], prof['obj']['new'])
        self.assertEqual(get.get('etag'), '"%s"' % hashlib.sha1(get.content).hexdigest())

        self.client.delete(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")

    def test_current_tetris(self):
        params = {"profileId":"profile:highscores","activityId":"act:adlnet.gov/JsTetris_TCAPI"}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(params))
        
        put = self.client.put(path, '[{"actor":{"name":"tom","mbox":"mailto:tom@tom.com"},"score":802335,"date":"2013-07-26T13:42:13.465Z"},{"actor":{"name":"tom","mbox":"mailto:tom@tom.com"},"score":159482,"date":"2013-07-26T13:49:14.011Z"},{"actor":{"name":"lou","mbox":"mailto:l@l.com"},"score":86690,"date":"2013-07-26T13:27:29.083Z"},{"actor":{"name":"tom","mbox":"mailto:tom@tom.com"},"score":15504,"date":"2013-07-26T13:27:30.763Z"},{"actor":{"name":"tom","mbox":"mailto:tom@tom.com"},"score":1982,"date":"2013-07-26T13:29:46.067Z"},{"actor":{"name":"unknown","mbox":"mailto:unknown@example.com"},"score":348,"date":"2013-07-26T13:51:08.043Z"}]', content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(put.status_code, 204)
        
        theget = self.client.get(path, Authorization=self.auth, X_Experience_API_Version="1.0")
        self.assertEqual(theget['ETag'], '"d4827d99a5cc3510d3847baa341ba5a3b477fdfc"')

    def test_json_merge(self):
        prof = '{"test": { "goal": "ensure proper json parse", "attempt": 1, "result": null } }'

        params = {"profileId": "prof:test_json_merge", "activityId": "act:test.json.merge.prof"}
        path = '%s?%s' % (reverse(views.activity_profile), urllib.urlencode(params))
        
        post = self.client.post(path, prof, content_type="application/json", If_None_Match='*', Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 204)
        
        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        returned = json.loads(get.content)
        sent = json.loads(prof)
        self.assertEqual(returned['test']['goal'], sent['test']['goal'])
        self.assertEqual(returned['test']['attempt'], sent['test']['attempt'])
        self.assertEqual(returned['test']['result'], sent['test']['result'])
        etag = '"%s"' % hashlib.sha1(get.content).hexdigest()
        self.assertEqual(get.get('etag'), etag)

        sent['test']['result'] = True
        sent['test']['attempt'] = sent['test']['attempt'] + 1
        prof = json.dumps(sent)
        post = self.client.post(path, prof, content_type="application/json", If_Match=etag, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 204)

        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        returned = json.loads(get.content)
        sent = json.loads(prof)
        self.assertEqual(returned['test']['goal'], sent['test']['goal'])
        self.assertEqual(returned['test']['attempt'], sent['test']['attempt'])
        self.assertEqual(returned['test']['result'], sent['test']['result'])
        etag = '"%s"' % hashlib.sha1(get.content).hexdigest()
        self.assertEqual(get.get('etag'), etag)

########NEW FILE########
__FILENAME__ = ActivityStateTests
from django.test import TestCase
from django.conf import settings
from django.core.urlresolvers import reverse
from lrs import models, views
import datetime
from django.utils.timezone import utc
from django.utils import timezone
import hashlib
import urllib
import os
import json
import base64
import ast
import uuid

class ActivityStateTests(TestCase):
    url = reverse(views.activity_state)
    testagent = '{"name":"test","mbox":"mailto:test@example.com"}'
    otheragent = '{"name":"other","mbox":"mailto:other@example.com"}'
    activityId = "http://www.iana.org/domains/example/"
    activityId2 = "http://www.google.com"
    stateId = "the_state_id"
    stateId2 = "state_id_2"
    stateId3 = "third_state_id"
    stateId4 = "4th.id"
    registration = str(uuid.uuid1())
    content_type = "application/json"

    @classmethod
    def setUpClass(cls):
        print "\n%s" % __name__

    def setUp(self):
        self.username = "test"
        self.email = "test@example.com"        
        self.password = "test"
        self.auth = "Basic %s" % base64.b64encode("%s:%s" % (self.username, self.password))
        form = {'username':self.username,'email': self.email,'password':self.password,'password2':self.password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")


        self.testparams1 = {"stateId": self.stateId, "activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(self.testparams1))
        self.teststate1 = {"test":"put activity state 1","obj":{"agent":"test"}}
        self.put1 = self.client.put(path, json.dumps(self.teststate1), content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.testparams2 = {"stateId": self.stateId2, "activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(self.testparams2))
        self.teststate2 = {"test":"put activity state 2","obj":{"agent":"test"}}
        self.put2 = self.client.put(path, json.dumps(self.teststate2), content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.testparams3 = {"stateId": self.stateId3, "activityId": self.activityId2, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(self.testparams3))
        self.teststate3 = {"test":"put activity state 3","obj":{"agent":"test"}}
        self.put3 = self.client.put(path, json.dumps(self.teststate3), content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.testparams4 = {"stateId": self.stateId4, "activityId": self.activityId2, "agent": self.otheragent}
        path = '%s?%s' % (self.url, urllib.urlencode(self.testparams4))
        self.teststate4 = {"test":"put activity state 4","obj":{"agent":"other"}}
        self.put4 = self.client.put(path, json.dumps(self.teststate4), content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def tearDown(self):
        self.client.delete(self.url, self.testparams1, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.client.delete(self.url, self.testparams2, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.client.delete(self.url, self.testparams3, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.client.delete(self.url, self.testparams4, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        attach_folder_path = os.path.join(settings.MEDIA_ROOT, "activity_state")
        for the_file in os.listdir(attach_folder_path):
            file_path = os.path.join(attach_folder_path, the_file)
            try:
                os.unlink(file_path)
            except Exception, e:
                raise e

    def test_put(self):
        self.assertEqual(self.put1.status_code, 204)
        self.assertEqual(self.put1.content, '')

        self.assertEqual(self.put2.status_code, 204)
        self.assertEqual(self.put2.content, '')

        self.assertEqual(self.put3.status_code, 204)
        self.assertEqual(self.put3.content, '')

        self.assertEqual(self.put4.status_code, 204)
        self.assertEqual(self.put4.content, '')
     
    def test_put_no_existing_activity(self):
        testparams = {"stateId": self.stateId3, "activityId": "http://foobar", "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparams))
        teststate = {"test":"put activity state","obj":{"agent":"test"}}
        put = self.client.put(path, teststate, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put.status_code, 204)
        self.client.delete(path, Authorization=self.auth, X_Experience_API_Version="1.0.0")


    def test_put_with_registration(self):
        testparamsregid = {"registration": "not-uuid", "stateId": self.stateId, "activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamsregid))
        teststateregid = {"test":"put activity state w/ registration","obj":{"agent":"test"}}
        put1 = self.client.put(path, teststateregid, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 400)

        testparamsregid = {"registration": self.registration, "stateId": self.stateId, "activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamsregid))
        teststateregid = {"test":"put activity state w/ registration","obj":{"agent":"test"}}
        put1 = self.client.put(path, teststateregid, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 204)
        self.assertEqual(put1.content, '')
        
        # also testing get w/ registration id
        r = self.client.get(self.url, testparamsregid, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], teststateregid['test'])
        self.assertEqual(robj['obj']['agent'], teststateregid['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1(r.content).hexdigest())
        
        # and tests delete w/ registration id
        del_r = self.client.delete(self.url, testparamsregid, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(del_r.status_code, 204)

    def test_put_without_auth(self):
        # Will return 200 if HTTP_AUTH is not enabled
        testparamsregid = {"registration": self.registration, "stateId": self.stateId, "activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamsregid))
        teststateregid = {"test":"put activity state w/ registration","obj":{"agent":"test"}}
        put1 = self.client.put(path, teststateregid, content_type=self.content_type, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 401)

    def test_put_etag_conflict_if_none_match(self):
        teststateetaginm = {"test":"etag conflict - if none match *","obj":{"agent":"test"}}
        path = '%s?%s' % (self.url, urllib.urlencode(self.testparams1))
        r = self.client.put(path, teststateetaginm, content_type=self.content_type, If_None_Match='*', Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 412)
        self.assertEqual(r.content, 'Resource detected')

        r = self.client.get(self.url, self.testparams1, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], self.teststate1['test'])
        self.assertEqual(robj['obj']['agent'], self.teststate1['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1(r.content).hexdigest())

    def test_put_etag_conflict_if_match(self):
        teststateetagim = {"test":"etag conflict - if match wrong hash","obj":{"agent":"test"}}
        new_etag = '"%s"' % hashlib.sha1('wrong etag value').hexdigest()
        path = '%s?%s' % (self.url, urllib.urlencode(self.testparams1))
        r = self.client.put(path, teststateetagim, content_type=self.content_type, If_Match=new_etag, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 412)
        self.assertIn('No resources matched', r.content)

        r = self.client.get(self.url, self.testparams1, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], self.teststate1['test'])
        self.assertEqual(robj['obj']['agent'], self.teststate1['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1(r.content).hexdigest())

    def test_put_etag_no_conflict_if_match(self):
        teststateetagim = {"test":"etag no conflict - if match good hash","obj":{"agent":"test"}}
        new_etag = '"%s"' % hashlib.sha1(json.dumps(self.teststate1)).hexdigest()
        path = '%s?%s' % (self.url, urllib.urlencode(self.testparams1))
        r = self.client.put(path, teststateetagim, content_type=self.content_type, If_Match=new_etag, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 204)
        self.assertEqual(r.content, '')

        r = self.client.get(self.url, self.testparams1, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], teststateetagim['test'])
        self.assertEqual(robj['obj']['agent'], teststateetagim['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1(r.content).hexdigest())   

    def test_put_etag_missing_on_change(self):
        teststateetagim = {'test': 'etag no need for etag', 'obj': {'agent': 'test'}}
        path = '%s?%s' % (self.url, urllib.urlencode(self.testparams1))
        r = self.client.put(path, teststateetagim, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 204)
        
        r = self.client.get(self.url, self.testparams1, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], teststateetagim['test'])
        self.assertEqual(robj['obj']['agent'], self.teststate1['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1('%s' % teststateetagim).hexdigest())

    def test_put_without_activityid(self):
        testparamsbad = {"stateId": "bad_state", "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamsbad))
        teststatebad = {"test":"put activity state BAD no activity id","obj":{"agent":"test"}}
        put1 = self.client.put(path, teststatebad, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 400)
        self.assertIn('activityId parameter is missing', put1.content)

    
    def test_put_without_agent(self):
        testparamsbad = {"stateId": "bad_state", "activityId": self.activityId}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamsbad))
        teststatebad = {"test":"put activity state BAD no agent","obj":{"agent":"none"}}
        put1 = self.client.put(path, teststatebad, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 400)
        self.assertIn('agent parameter is missing', put1.content)

    
    def test_put_without_stateid(self):
        testparamsbad = {"activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamsbad))
        teststatebad = {"test":"put activity state BAD no state id","obj":{"agent":"test"}}
        put1 = self.client.put(path, teststatebad, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 400)
        self.assertIn('stateId parameter is missing', put1.content)

    # Also tests 403 forbidden status
    def test_get(self):
        username = "other"
        email = "other@example.com"
        password = "test"
        auth = "Basic %s" % base64.b64encode("%s:%s" % (username, password))
        form = {'username':username,'email': email,'password':password,'password2':password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")        

        r = self.client.get(self.url, self.testparams1, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], self.teststate1['test'])
        self.assertEqual(robj['obj']['agent'], self.teststate1['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1(r.content).hexdigest())

        r2 = self.client.get(self.url, self.testparams2, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r2.status_code, 200)
        robj2 = ast.literal_eval(r2.content)
        self.assertEqual(robj2['test'], self.teststate2['test'])
        self.assertEqual(robj2['obj']['agent'], self.teststate2['obj']['agent'])
        self.assertEqual(r2['etag'], '"%s"' % hashlib.sha1(r2.content).hexdigest())
        
        r3 = self.client.get(self.url, self.testparams3, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r3.status_code, 200)
        robj3 = ast.literal_eval(r3.content)
        self.assertEqual(robj3['test'], self.teststate3['test'])
        self.assertEqual(robj3['obj']['agent'], self.teststate3['obj']['agent'])
        self.assertEqual(r3['etag'], '"%s"' % hashlib.sha1(r3.content).hexdigest())

        r4 = self.client.get(self.url, self.testparams4, X_Experience_API_Version="1.0.0", Authorization=auth)
        self.assertEqual(r4.status_code, 200)
        robj4 = ast.literal_eval(r4.content)
        self.assertEqual(robj4['test'], self.teststate4['test'])
        self.assertEqual(robj4['obj']['agent'], self.teststate4['obj']['agent'])
        self.assertEqual(r4['etag'], '"%s"' % hashlib.sha1(r4.content).hexdigest())

        # r5 = self.client.get(self.url, self.testparams3, X_Experience_API_Version="1.0.0", Authorization=auth)
        # self.assertEqual(r5.status_code, 403)

    def test_get_no_existing_id(self):
        testparams = {"stateId": "testID", "activityId": self.activityId, "agent": self.testagent}
        r = self.client.get(self.url, testparams, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 404)


    def test_get_ids(self):
        params = {"activityId": self.activityId, "agent": self.testagent}
        r = self.client.get(self.url, params, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertIn(self.stateId, r.content)
        self.assertIn(self.stateId2, r.content)
        self.assertNotIn(self.stateId3, r.content)
        self.assertNotIn(self.stateId4, r.content)

     
    def test_get_with_since(self):
        state_id = "old_state_test"
        testparamssince = {"stateId": state_id, "activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamssince))
        teststatesince = {"test":"get w/ since","obj":{"agent":"test"}}
        updated =  datetime.datetime(2012, 6, 12, 12, 00).replace(tzinfo=timezone.get_default_timezone())
        put1 = self.client.put(path, teststatesince, content_type=self.content_type, updated=updated.isoformat(), Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 204)
        self.assertEqual(put1.content, '')
        
        r = self.client.get(self.url, testparamssince, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], teststatesince['test'])
        self.assertEqual(robj['obj']['agent'], teststatesince['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1(r.content).hexdigest())

        since = datetime.datetime(2012, 7, 1, 12, 00).replace(tzinfo=utc)
        params2 = {"activityId": self.activityId, "agent": self.testagent, "since": since}
        r = self.client.get(self.url, params2, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertIn(self.stateId, r.content)
        self.assertIn(self.stateId2, r.content)
        self.assertNotIn(state_id, r.content)
        self.assertNotIn(self.stateId3, r.content)
        self.assertNotIn(self.stateId4, r.content)

        del_r = self.client.delete(self.url, testparamssince, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
    def test_get_with_since_tz(self):
        state_id = "old_state_test"
        testparamssince = {"stateId": state_id, "activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamssince))
        teststatesince = {"test":"get w/ since","obj":{"agent":"test"}}
        updated =  datetime.datetime(2012, 6, 12, 12, 00).replace(tzinfo=timezone.get_default_timezone())
        put1 = self.client.put(path, teststatesince, content_type=self.content_type, updated=updated.isoformat(), Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 204)
        self.assertEqual(put1.content, '')
        
        r = self.client.get(self.url, testparamssince, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], teststatesince['test'])
        self.assertEqual(robj['obj']['agent'], teststatesince['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1(r.content).hexdigest())

        state_id2 = "new_tz_state_test"
        testparamssince2 = {"stateId": state_id2, "activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamssince2))
        teststatesince2 = {"test":"get w/ since TZ","obj":{"agent":"test"}}
        updated_tz =  "2012-7-1T13:30:00+04:00"
        put2 = self.client.put(path, teststatesince2, content_type=self.content_type, updated=updated_tz, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put2.status_code, 204)
        self.assertEqual(put2.content, '')
        
        r2 = self.client.get(self.url, testparamssince2, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r2.status_code, 200)
        
        robj2 = ast.literal_eval(r2.content)
        self.assertEqual(robj2['test'], teststatesince2['test'])
        self.assertEqual(robj2['obj']['agent'], teststatesince2['obj']['agent'])
        self.assertEqual(r2['etag'], '"%s"' % hashlib.sha1(r2.content).hexdigest())

        since = datetime.datetime(2012, 7, 1, 12, 00).replace(tzinfo=utc)
        params2 = {"activityId": self.activityId, "agent": self.testagent, "since": since}
        r = self.client.get(self.url, params2, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertIn(self.stateId, r.content)
        self.assertIn(self.stateId2, r.content)
        self.assertNotIn(state_id, r.content)
        self.assertNotIn(state_id2, r.content)
        self.assertNotIn(self.stateId3, r.content)
        self.assertNotIn(self.stateId4, r.content)

        del_r = self.client.delete(self.url, testparamssince, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        del_r = self.client.delete(self.url, testparamssince2, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_get_with_since_and_regid(self):
        # create old state w/ no registration id
        state_id = "old_state_test_no_reg"
        testparamssince = {"stateId": state_id, "activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamssince))
        teststatesince = {"test":"get w/ since","obj":{"agent":"test","stateId":state_id}}
        updated =  datetime.datetime(2012, 6, 12, 12, 00).replace(tzinfo=utc)
        put1 = self.client.put(path, teststatesince, content_type=self.content_type, updated=updated.isoformat(), Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 204)
        self.assertEqual(put1.content, '')
        
        r = self.client.get(self.url, testparamssince, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], teststatesince['test'])
        self.assertEqual(robj['obj']['agent'], teststatesince['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1(r.content).hexdigest())

        # create old state w/ registration id
        regid = str(uuid.uuid1())
        state_id2 = "old_state_test_w_reg"
        testparamssince2 = {"registration": regid, "activityId": self.activityId, "agent": self.testagent, "stateId":state_id2}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamssince2))
        teststatesince2 = {"test":"get w/ since and registration","obj":{"agent":"test","stateId":state_id2}}
        put2 = self.client.put(path, teststatesince2, content_type=self.content_type, updated=updated.isoformat(), Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put2.status_code, 204)
        self.assertEqual(put2.content, '')

        r2 = self.client.get(self.url, testparamssince2, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r2.status_code, 200)
        
        robj2 = ast.literal_eval(r2.content)
        self.assertEqual(robj2['test'], teststatesince2['test'])
        self.assertEqual(robj2['obj']['agent'], teststatesince2['obj']['agent'])
        self.assertEqual(r2['etag'], '"%s"' % hashlib.sha1(r2.content).hexdigest())

        # create new state w/ registration id
        state_id3 = "old_state_test_w_new_reg"
        testparamssince3 = {"registration": regid, "activityId": self.activityId, "agent": self.testagent, "stateId":state_id3}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamssince3))
        teststatesince3 = {"test":"get w/ since and registration","obj":{"agent":"test","stateId":state_id3}}
        put3 = self.client.put(path, teststatesince3, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put3.status_code, 204)
        self.assertEqual(put3.content, '')

        r3 = self.client.get(self.url, testparamssince3, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r3.status_code, 200)
        
        robj3 = ast.literal_eval(r3.content)
        self.assertEqual(robj3['test'], teststatesince3['test'])
        self.assertEqual(robj3['obj']['agent'], teststatesince3['obj']['agent'])
        self.assertEqual(r3['etag'], '"%s"' % hashlib.sha1(r3.content).hexdigest())

        # get no reg ids set w/o old state
        since1 = datetime.datetime(2012, 7, 1, 12, 00).replace(tzinfo=utc)
        params = {"activityId": self.activityId, "agent": self.testagent, "since": since1}
        r = self.client.get(self.url, params, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertIn(self.stateId, r.content)
        self.assertIn(self.stateId2, r.content)
        self.assertNotIn(state_id, r.content)
        self.assertNotIn(self.stateId3, r.content)
        self.assertNotIn(self.stateId4, r.content)

        # get reg id set w/o old state
        since2 = datetime.datetime(2012, 7, 1, 12, 00).replace(tzinfo=utc)
        params2 = {"registration": regid, "activityId": self.activityId, "agent": self.testagent, "since": since2}
        r = self.client.get(self.url, params2, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertIn(state_id3, r.content)
        self.assertNotIn(state_id2, r.content)
        self.assertNotIn(self.stateId, r.content)
        self.assertNotIn(self.stateId2, r.content)
        self.assertNotIn(self.stateId3, r.content)
        self.assertNotIn(self.stateId4, r.content)
        
        self.client.delete(self.url, testparamssince, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.client.delete(self.url, testparamssince2, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.client.delete(self.url, testparamssince3, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        
    def test_get_without_activityid(self):
        params = {"stateId": self.stateId, "agent": self.testagent}
        r = self.client.get(self.url, params, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 400)
        self.assertIn('activityId parameter is missing', r.content)

    
    def test_get_without_agent(self):
        params = {"stateId": self.stateId, "activityId": self.activityId}
        r = self.client.get(self.url, params, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 400)
        self.assertIn('agent parameter is missing', r.content)

    
    def test_delete_without_activityid(self):
        testparamsregid = {"registration": self.registration, "stateId": self.stateId, "activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamsregid))
        teststateregid = {"test":"delete activity state w/o activityid","obj":{"agent":"test"}}
        put1 = self.client.put(path, teststateregid, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 204)
        self.assertEqual(put1.content, '')
        
        r = self.client.get(self.url, testparamsregid, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], teststateregid['test'])
        self.assertEqual(robj['obj']['agent'], teststateregid['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1(r.content).hexdigest())

        f_r = self.client.delete(self.url, {"registration": self.registration, "stateId": self.stateId, "agent": self.testagent}, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(f_r.status_code, 400)
        self.assertIn('activityId parameter is missing', f_r.content)

        del_r = self.client.delete(self.url, testparamsregid, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(del_r.status_code, 204)

    
    def test_delete_without_agent(self):
        testparamsregid = {"registration": self.registration, "stateId": self.stateId, "activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamsregid))
        teststateregid = {"test":"delete activity state w/o agent","obj":{"agent":"test"}}
        put1 = self.client.put(path, teststateregid, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 204)
        self.assertEqual(put1.content, '')
        
        r = self.client.get(self.url, testparamsregid, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], teststateregid['test'])
        self.assertEqual(robj['obj']['agent'], teststateregid['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1(r.content).hexdigest())

        f_r = self.client.delete(self.url, {"registration": self.registration, "stateId": self.stateId, "activityId": self.activityId}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(f_r.status_code, 400)
        self.assertIn('agent parameter is missing', f_r.content)

        del_r = self.client.delete(self.url, testparamsregid, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(del_r.status_code, 204)

    
    def test_delete_set(self):
        testparamsdelset1 = {"registration": self.registration, "stateId": "del_state_set_1", "activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamsdelset1))
        teststatedelset1 = {"test":"delete set #1","obj":{"agent":"test"}}
        put1 = self.client.put(path, teststatedelset1, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 204)
        self.assertEqual(put1.content, '')
        
        r = self.client.get(self.url, testparamsdelset1, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], teststatedelset1['test'])
        self.assertEqual(robj['obj']['agent'], teststatedelset1['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1(r.content).hexdigest())

        testparamsdelset2 = {"registration": self.registration, "stateId": "del_state_set_2", "activityId": self.activityId, "agent": self.testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparamsdelset2))
        teststatedelset2 = {"test":"delete set #2","obj":{"agent":"test"}}
        put1 = self.client.put(path, teststatedelset2, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 204)
        self.assertEqual(put1.content, '')
        
        r = self.client.get(self.url, testparamsdelset2, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        
        robj2 = ast.literal_eval(r.content)
        self.assertEqual(robj2['test'], teststatedelset2['test'])
        self.assertEqual(robj2['obj']['agent'], teststatedelset2['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1(r.content).hexdigest())

        f_r = self.client.delete(self.url, {"registration": self.registration, "agent": self.testagent, "activityId": self.activityId}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(f_r.status_code, 204)

        r = self.client.get(self.url, testparamsdelset1, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 404)
        self.assertIn('no activity', r.content)

        r = self.client.get(self.url, testparamsdelset2, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 404)
        self.assertIn('no activity', r.content)

    def test_ie_cors_put_delete(self):
        username = "another test"
        email = "anothertest@example.com"
        password = "test"
        auth = "Basic %s" % base64.b64encode("%s:%s" % (username, password))
        form = {'username':username,'email': email,'password':password,'password2':password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")

        testagent = '{"name":"another test","mbox":"mailto:anothertest@example.com"}'
        sid = "test_ie_cors_put_delete_set_1"
        sparam1 = {"stateId": sid, "activityId": self.activityId, "agent": testagent}
        path = '%s?%s' % (self.url, urllib.urlencode({"method":"PUT"}))
        
        content = {"test":"test_ie_cors_put_delete","obj":{"actor":"another test"}}
        param = "stateId=%s&activityId=%s&agent=%s&content=%s&Content-Type=application/x-www-form-urlencoded&Authorization=%s&X-Experience-API-Version=1.0.0" % (sid, self.activityId, testagent, content, auth)
        put1 = self.client.post(path, param, content_type='application/x-www-form-urlencoded')
 
        self.assertEqual(put1.status_code, 204)
        self.assertEqual(put1.content, '')
        
        r = self.client.get(self.url, {"stateId": sid, "activityId": self.activityId, "agent": testagent}, X_Experience_API_Version="1.0.0", Authorization=auth)
        self.assertEqual(r.status_code, 200)
        import ast
        c = ast.literal_eval(r.content)

        self.assertEqual(c['test'], content['test'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1('%s' % content).hexdigest())
 
        dparam = "agent=%s&activityId=%s&Authorization=%s&Content-Type=application/x-www-form-urlencoded&X-Experience-API-Version=1.0.0" % (testagent,self.activityId,auth)
        path = '%s?%s' % (self.url, urllib.urlencode({"method":"DELETE"}))
        f_r = self.client.post(path, dparam, content_type='application/x-www-form-urlencoded')
        self.assertEqual(f_r.status_code, 204)

    def test_agent_is_group(self):
        username = "the group"
        email = "the.group@example.com"
        password = "test"
        auth = "Basic %s" % base64.b64encode("%s:%s" % (username, password))
        form = {'username':username,'email': email,'password':password,'password2':password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")

        ot = "Group"
        name = "the group"
        mbox = "mailto:the.group@example.com"
        members = [{"name":"agent1","mbox":"mailto:agent1@example.com"},
                    {"name":"agent2","mbox":"mailto:agent2@example.com"}]
        testagent = json.dumps({"objectType":ot, "name":name, "mbox":mbox,"member":members})
        testparams1 = {"stateId": "group.state.id", "activityId": self.activityId, "agent": testagent}
        path = '%s?%s' % (self.url, urllib.urlencode(testparams1))
        teststate1 = {"test":"put activity state using group as agent","obj":{"agent":"group of 2 agents"}}
        put1 = self.client.put(path, teststate1, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 204)

        get1 = self.client.get(self.url, {"stateId":"group.state.id", "activityId": self.activityId, "agent":testagent}, X_Experience_API_Version="1.0.0", Authorization=auth)
        self.assertEqual(get1.status_code, 200)
        robj = ast.literal_eval(get1.content)
        self.assertEqual(robj['test'], teststate1['test'])
        self.assertEqual(robj['obj']['agent'], teststate1['obj']['agent'])
        self.assertEqual(get1['etag'], '"%s"' % hashlib.sha1(get1.content).hexdigest())

        delr = self.client.delete(self.url, testparams1, Authorization=auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(delr.status_code, 204)     

    def test_post_new_state(self):
        param = {"stateId": "test:postnewstate", "activityId": "act:test/post.new.state", "agent": '{"mbox":"mailto:testagent@example.com"}'}
        path = '%s?%s' % (self.url, urllib.urlencode(param))
        state = {"post":"testing new state", "obj":{"f1":"v1","f2":"v2"}}

        r = self.client.post(path, json.dumps(state), content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 204)

        r = self.client.get(path, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        self.assertEqual(ast.literal_eval(r.content), state)

        self.client.delete(path, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_post_blank_state(self):
        param = {"stateId": "test:postnewblankstate", "activityId": "act:test/post.new.blank.state", "agent": '{"mbox":"mailto:testagent@example.com"}'}
        path = '%s?%s' % (self.url, urllib.urlencode(param))
        state = ""

        r = self.client.post(path, state, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 400)
        self.assertEqual(r.content, 'No body in request')

    def test_post_update_state(self):
        param = {"stateId": "test:postupdatestate", "activityId": "act:test/post.update.state", "agent": '{"mbox":"mailto:test@example.com"}'}
        path = '%s?%s' % (self.url, urllib.urlencode(param))
        state = {"field1":"value1", "obj":{"ofield1":"oval1","ofield2":"oval2"}}

        r = self.client.post(path, json.dumps(state), content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 204)

        r = self.client.get(path, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        self.assertEqual(ast.literal_eval(r.content), state)

        state2 = {"field_xtra":"xtra val", "obj":"ha, not a obj"}
        r = self.client.post(path, json.dumps(state2), content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 204)

        r = self.client.get(path, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        retstate = ast.literal_eval(r.content)
        self.assertEqual(retstate['field1'], state['field1'])
        self.assertEqual(retstate['field_xtra'], state2['field_xtra'])
        self.assertEqual(retstate['obj'], state2['obj'])

        self.client.delete(path, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_nonjson_put_state(self):
        param = {"stateId": "thisisnotjson", "activityId": "act:test/non.json.accepted", "agent": '{"mbox":"mailto:test@example.com"}'}
        path = '%s?%s' % (self.url, urllib.urlencode(param))
        state = "this is not json"

        r = self.client.put(path, state, content_type="text/plain", Authorization=self.auth, X_Experience_API_Version="1.0.1")
        self.assertEqual(r.status_code, 204)

        r = self.client.get(path, Authorization=self.auth, X_Experience_API_Version="1.0.1")
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r['Content-Type'], "text/plain")
        self.assertEqual(r.content, state)

########NEW FILE########
__FILENAME__ = ActivityTests
import base64
import json
from django.test import TestCase
from django.core.urlresolvers import reverse
from lrs import views
from lrs.objects.ActivityManager import ActivityManager


class ActivityTests(TestCase):
    @classmethod
    def setUpClass(cls):
        print "\n%s" % __name__

    def setUp(self):
        self.username = "tester"
        self.email = "test@tester.com"
        self.password = "test"
        self.auth = "Basic %s" % base64.b64encode("%s:%s" % (self.username, self.password))
        form = {'username':self.username, 'email': self.email,'password':self.password,'password2':self.password}
        response = self.client.post(reverse(views.register),form, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_get(self):
        act = ActivityManager({'objectType':'Activity', 'id':'act:foobar'})
        response = self.client.get(reverse(views.activities), {'activityId':'act:foobar'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        rsp = response.content
        self.assertEqual(response.status_code, 200)
        self.assertIn('act:foobar', rsp)
        self.assertIn('Activity', rsp)
        self.assertIn('objectType', rsp)        
        self.assertIn('content-length', response._headers)

    def test_get_not_exist(self):
        activity_id = "this:does_not_exist"
        response = self.client.get(reverse(views.activities), {'activityId':activity_id}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.content, 'No activity found with ID this:does_not_exist')

    def test_get_not_array(self):
        act = ActivityManager({'objectType':'Activity', 'id':'act:foobar'})
        response = self.client.get(reverse(views.activities), {'activityId':'act:foobar'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        rsp = response.content
        self.assertEqual(response.status_code, 200)
        self.assertIn('content-length', response._headers)

        rsp_obj = json.loads(rsp)
        self.assertEqual('act:foobar', rsp_obj['id'])

    def test_head(self):
        act = ActivityManager({'objectType':'Activity', 'id':'act:foobar'})
        response = self.client.head(reverse(views.activities), {'activityId':'act:foobar'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content, '')
        self.assertIn('content-length', response._headers)

    def test_get_def(self):
        act = ActivityManager({'objectType': 'Activity', 'id':'act:foobar1',
                'definition': {'name': {'en-US':'testname', 'en-GB': 'altname'},
                'description': {'en-US':'testdesc', 'en-GB': 'altdesc'},
                'type': 'type:course','interactionType': 'intType'}})
        response = self.client.get(reverse(views.activities), {'activityId':'act:foobar1'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        rsp = response.content
        self.assertEqual(response.status_code, 200)
        self.assertIn('act:foobar1', rsp)
        self.assertIn('type:course', rsp)
        self.assertIn('intType', rsp)
        self.assertIn('en-US', rsp)
        self.assertIn('testname', rsp)
        self.assertIn('testdesc', rsp)
        self.assertIn('en-GB', rsp)
        self.assertIn('altdesc', rsp)
        self.assertIn('altname', rsp)
        
    def test_get_ext(self):
        act = ActivityManager({'objectType': 'Activity', 'id':'act:foobar2',
                'definition': {'name': {'en-FR':'testname2'},'description': {'en-FR':'testdesc2'},
                'type': 'type:course','interactionType': 'intType2', 
                'extensions': {'ext:key1': 'value1', 'ext:key2': 'value2'}}})

        response = self.client.get(reverse(views.activities), {'activityId':'act:foobar2'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        rsp = response.content
        self.assertEqual(response.status_code, 200)
        self.assertIn('act:foobar2', rsp)
        self.assertIn('type:course', rsp)
        self.assertIn('intType2', rsp)
        self.assertIn('en-FR', rsp)
        self.assertIn('testname2', rsp)
        self.assertIn('testdesc2', rsp)
        self.assertIn('key1', rsp)
        self.assertIn('key2', rsp)
        self.assertIn('value1', rsp)
        self.assertIn('value2', rsp)

    def test_get_crp_multiple_choice(self):
        act = ActivityManager({'objectType': 'Activity', 'id':'act:foobar3',
                'definition': {'name': {'en-FR':'testname2'},
                'description': {'en-FR':'testdesc2', 'en-CH': 'altdesc'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'choice',
                'correctResponsesPattern': ['golf', 'tetris'],'choices':[{'id': 'golf',
                'description': {'en-US':'Golf Example', 'en-GB':'alt golf'}},{'id': 'tetris',
                'description':{'en-US': 'Tetris Example'}}, {'id':'facebook',
                'description':{'en-US':'Facebook App'}},{'id':'scrabble', 
                'description': {'en-US': 'Scrabble Example'}}]}})
        
        response = self.client.get(reverse(views.activities), {'activityId':'act:foobar3'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        rsp = response.content
        self.assertEqual(response.status_code, 200)
        self.assertIn('act:foobar3', rsp)
        self.assertIn('http://adlnet.gov/expapi/activities/cmi.interaction', rsp)
        self.assertIn('choice', rsp)
        self.assertIn('en-FR', rsp)
        self.assertIn('testname2', rsp)
        self.assertIn('testdesc2', rsp)
        self.assertIn('golf', rsp)
        self.assertIn('tetris', rsp)
        self.assertIn('Golf Example', rsp)
        self.assertIn('Tetris Example', rsp)
        self.assertIn('Facebook App', rsp)
        self.assertIn('Scrabble Example', rsp)
        self.assertIn('scrabble', rsp)
        self.assertIn('facebook', rsp)
        self.assertIn('en-GB', rsp)
        self.assertIn('alt golf', rsp)
        self.assertIn('en-CH', rsp)
        self.assertIn('altdesc', rsp)

    def test_get_crp_true_false(self):
        act = ActivityManager({'objectType': 'Activity', 'id':'act:foobar4',
        'definition': {'name': {'en-US':'testname2'},'description': {'en-US':'testdesc2'},
        'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'true-false','correctResponsesPattern': ['true']}})
        
        response = self.client.get(reverse(views.activities), {'activityId': 'act:foobar4'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        rsp = response.content
        self.assertEqual(response.status_code, 200)
        self.assertIn('act:foobar4', rsp)
        self.assertIn('http://adlnet.gov/expapi/activities/cmi.interaction', rsp)
        self.assertIn('true-false', rsp)
        self.assertIn('en-US', rsp)
        self.assertIn('testname2', rsp)
        self.assertIn('testdesc2', rsp)
        self.assertIn('correctResponsesPattern', rsp)
        self.assertIn('true', rsp)

    def test_get_crp_fill_in(self):
        act = ActivityManager({'objectType': 'Activity', 'id':'act:foobar5',
                'definition': {'name': {'en-US':'testname2'},'description': {'en-US':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'fill-in',
                'correctResponsesPattern': ['Fill in answer']}})

        response = self.client.get(reverse(views.activities), {'activityId': 'act:foobar5'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")       

        rsp = response.content
        self.assertEqual(response.status_code, 200)
        self.assertIn('act:foobar5', rsp)
        self.assertIn('http://adlnet.gov/expapi/activities/cmi.interaction', rsp)
        self.assertIn('fill-in', rsp)
        self.assertIn('en-US', rsp)
        self.assertIn('testname2', rsp)
        self.assertIn('testdesc2', rsp)
        self.assertIn('correctResponsesPattern', rsp)
        self.assertIn('Fill in answer', rsp)

    def test_get_crp_long_fill_in(self):
        act = ActivityManager({'objectType': 'Activity', 'id':'act:foobar6',
                'definition': {'name': {'en-FR':'testname2'},'description': {'en-FR':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'fill-in',
                'correctResponsesPattern': ['Long fill in answer']}})       

        response = self.client.get(reverse(views.activities), {'activityId': 'act:foobar6'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")       

        rsp = response.content

        self.assertEqual(response.status_code, 200)
        self.assertIn('act:foobar6', rsp)
        self.assertIn('http://adlnet.gov/expapi/activities/cmi.interaction', rsp)
        self.assertIn('fill-in', rsp)
        self.assertIn('en-FR', rsp)
        self.assertIn('testname2', rsp)
        self.assertIn('testdesc2', rsp)
        self.assertIn('correctResponsesPattern', rsp)
        self.assertIn('Long fill in answer', rsp)

    def test_get_crp_likert(self):
        act = ActivityManager({'objectType': 'Still gonna be activity', 'id':'act:foobar7',
                'definition': {'name': {'en-US':'testname2'},'description': {'en-US':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'likert','correctResponsesPattern': ['likert_3'],
                'scale':[{'id': 'likert_0', 'description': {'en-US':'Its OK'}},{'id': 'likert_1',
                'description':{'en-US': 'Its Pretty Cool'}}, {'id':'likert_2',
                'description':{'en-US':'Its Cool Cool'}},{'id':'likert_3',
                'description': {'en-US': 'Its Gonna Change the World'}}]}})

        response = self.client.get(reverse(views.activities), {'activityId': 'act:foobar7'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")       

        rsp = response.content
        self.assertEqual(response.status_code, 200)
        self.assertIn('act:foobar7', rsp)
        self.assertIn('http://adlnet.gov/expapi/activities/cmi.interaction', rsp)
        self.assertIn('likert', rsp)
        self.assertIn('en-US', rsp)
        self.assertIn('testname2', rsp)
        self.assertIn('testdesc2', rsp)
        self.assertIn('correctResponsesPattern', rsp)
        self.assertIn('likert_3', rsp)
        self.assertIn('likert_2', rsp)
        self.assertIn('likert_1', rsp)

    def test_get_crp_matching(self):
        act = ActivityManager({'objectType': 'Still gonna be activity', 'id':'act:foobar8',
                'definition': {'name': {'en-US':'testname2'},'description': {'en-FR':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'matching',
                'correctResponsesPattern': ['lou.3,tom.2,andy.1'],'source':[{'id': 'lou',
                'description': {'en-US':'Lou'}},{'id': 'tom','description':{'en-US': 'Tom'}},
                {'id':'andy', 'description':{'en-US':'Andy'}}],'target':[{'id':'1',
                'description':{'en-US': 'SCORM Engine'}},{'id':'2','description':{'en-US': 'Pure-sewage'}},
                {'id':'3', 'description':{'en-US': 'SCORM Cloud'}}]}})    
        
        response = self.client.get(reverse(views.activities), {'activityId': 'act:foobar8'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")       
        rsp = response.content
        self.assertEqual(response.status_code, 200)
        self.assertIn('act:foobar8', rsp)
        self.assertIn('http://adlnet.gov/expapi/activities/cmi.interaction', rsp)
        self.assertIn('matching', rsp)
        self.assertIn('en-FR', rsp)
        self.assertIn('en-US', rsp)        
        self.assertIn('testname2', rsp)
        self.assertIn('testdesc2', rsp)
        self.assertIn('correctResponsesPattern', rsp)
        self.assertIn('lou.3,tom.2,andy.1', rsp)
        self.assertIn('source', rsp)
        self.assertIn('target', rsp)

    def test_get_crp_performance(self):
        act = ActivityManager({'objectType': 'activity', 'id':'act:foobar9',
                'definition': {'name': {'en-US':'testname2', 'en-GB': 'altname'},
                'description': {'en-US':'testdesc2'},'type': 'http://adlnet.gov/expapi/activities/cmi.interaction',
                'interactionType': 'performance',
                'correctResponsesPattern': ['pong.1,dg.10,lunch.4'],'steps':[{'id': 'pong',
                'description': {'en-US':'Net pong matches won'}},{'id': 'dg',
                'description':{'en-US': 'Strokes over par in disc golf at Liberty'}},
                {'id':'lunch', 'description':{'en-US':'Lunch having been eaten', 
                'en-FR': 'altlunch'}}]}})
        
        response = self.client.get(reverse(views.activities), {'activityId': 'act:foobar9'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")       
        rsp = response.content
        self.assertEqual(response.status_code, 200)
        self.assertIn('act:foobar9', rsp)
        self.assertIn('http://adlnet.gov/expapi/activities/cmi.interaction', rsp)
        self.assertIn('performance', rsp)
        self.assertIn('steps', rsp)
        self.assertIn('en-US', rsp)        
        self.assertIn('testname2', rsp)
        self.assertIn('testdesc2', rsp)
        self.assertIn('correctResponsesPattern', rsp)
        self.assertIn('pong.1,dg.10,lunch.4', rsp)
        self.assertIn('Strokes over par in disc golf at Liberty', rsp)
        self.assertIn('Lunch having been eaten', rsp)
        self.assertIn('en-GB', rsp)
        self.assertIn('en-FR', rsp)
        self.assertIn('altlunch', rsp)

    def test_get_crp_sequencing(self):
        act = ActivityManager({'objectType': 'activity', 'id':'act:foobar10',
                'definition': {'name': {'en-US':'testname2'},'description': {'en-US':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'sequencing',
                'correctResponsesPattern': ['lou,tom,andy,aaron'],'choices':[{'id': 'lou',
                'description': {'en-US':'Lou'}},{'id': 'tom','description':{'en-US': 'Tom'}},
                {'id':'andy', 'description':{'en-US':'Andy'}},{'id':'aaron', 'description':{'en-US':'Aaron'}}]}})        
        
        response = self.client.get(reverse(views.activities), {'activityId': 'act:foobar10'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")       
        rsp = response.content

        self.assertEqual(response.status_code, 200)
        self.assertIn('act:foobar10', rsp)
        self.assertIn('http://adlnet.gov/expapi/activities/cmi.interaction', rsp)
        self.assertIn('sequencing', rsp)
        self.assertIn('choices', rsp)
        self.assertIn('en-US', rsp)        
        self.assertIn('testname2', rsp)
        self.assertIn('testdesc2', rsp)
        self.assertIn('correctResponsesPattern', rsp)
        self.assertIn('lou,tom,andy,aaron', rsp)

    def test_get_crp_numeric(self):
        act = ActivityManager({'objectType': 'Activity', 'id':'act:foobar11',
                'definition': {'name': {'en-US':'testname2'},'description': {'en-US':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'numeric','correctResponsesPattern': ['4'],
                'extensions': {'ext:key1': 'value1', 'ext:key2': 'value2','ext:key3': 'value3'}}})    

        response = self.client.get(reverse(views.activities), {'activityId': 'act:foobar11'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")       
        rsp = response.content

        self.assertEqual(response.status_code, 200)
        self.assertIn('act:foobar11', rsp)
        self.assertIn('http://adlnet.gov/expapi/activities/cmi.interaction', rsp)
        self.assertIn('numeric', rsp)
        self.assertIn('4', rsp)
        self.assertIn('en-US', rsp)        
        self.assertIn('testname2', rsp)
        self.assertIn('testdesc2', rsp)
        self.assertIn('correctResponsesPattern', rsp)
        self.assertIn('extensions', rsp)
        self.assertIn('key1', rsp)
        self.assertIn('value1', rsp)
        self.assertIn('key2', rsp)
        self.assertIn('value2', rsp)
        self.assertIn('key3', rsp)
        self.assertIn('value3', rsp)                                

    def test_get_crp_other(self):
        act = ActivityManager({'objectType': 'Activity', 'id': 'act:foobar12',
                'definition': {'name': {'en-US':'testname2'},'description': {'en-US':'testdesc2'},
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'other',
                'correctResponsesPattern': ['(35.937432,-86.868896)']}})     
        
        response = self.client.get(reverse(views.activities), {'activityId': 'act:foobar12'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")       
        rsp = response.content

        self.assertEqual(response.status_code, 200)
        self.assertIn('act:foobar12', rsp)
        self.assertIn('http://adlnet.gov/expapi/activities/cmi.interaction', rsp)
        self.assertIn('other', rsp)
        self.assertIn('(35.937432,-86.868896)', rsp)
        self.assertIn('en-US', rsp)        
        self.assertIn('testname2', rsp)
        self.assertIn('testdesc2', rsp)
        self.assertIn('correctResponsesPattern', rsp)


    def test_get_wrong_activity(self):
        response = self.client.get(reverse(views.activities), {'activityId': 'act:act:foo'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        rsp = response.content

        self.assertEqual(response.status_code, 404)

    def test_head_wrong_activity(self):
        response = self.client.head(reverse(views.activities), {'activityId': 'act:act:foo'}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 404)

    def test_get_no_activity(self):
        response = self.client.get(reverse(views.activities), Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
    
    def test_post(self):
        response = self.client.post(reverse(views.activities), {'activityId':'act:my_activity'},
            content_type='application/x-www-form-urlencoded', Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 405)

    def test_delete(self):
        response = self.client.delete(reverse(views.activities), {'activityId':'act:my_activity'},
            content_type='application/x-www-form-urlencoded', Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 405)

    def test_put(self):
        response = self.client.put(reverse(views.activities), {'activityId':'act:my_activity'},
            content_type='application/x-www-form-urlencoded', Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 405)


########NEW FILE########
__FILENAME__ = AgentManagerTests
from django.test import TestCase
from lrs.exceptions import ParamError
from lrs.models import Agent
import hashlib
import json
import base64
from lrs import models, views
from lrs.objects.AgentManager import AgentManager
from django.core.urlresolvers import reverse
from django.conf import settings

class AgentManagerTests(TestCase):
    @classmethod
    def setUpClass(cls):
        print "\n%s" % __name__

    def setUp(self):
        if not settings.HTTP_AUTH_ENABLED:
            settings.HTTP_AUTH_ENABLED = True
        
        self.username = "tester1"
        self.email = "test1@tester.com"
        self.password = "test"
        self.auth = "Basic %s" % base64.b64encode("%s:%s" % (self.username, self.password))
        form = {"username":self.username, "email":self.email,"password":self.password,"password2":self.password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")

        if settings.HTTP_AUTH_ENABLED:
            response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")           

    def test_agent_mbox_create(self):
        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:bob@example.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed"},
            "object": {'id': 'act://blah.com'}})

        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)        
        st = models.Statement.objects.get(statement_id=st_id[0])
        bob = st.actor
        self.assertEquals(bob.objectType, "Agent")
        self.assertFalse(bob.name)

    def test_agent_mbox_sha1sum_create(self):
        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox_sha1sum":hashlib.sha1("mailto:bob@example.com").hexdigest()},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed"},
            "object": {'id': 'act://blah.com'}})

        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)        
        st = models.Statement.objects.get(statement_id=st_id[0])
        bob = st.actor

        self.assertEquals(bob.mbox_sha1sum, hashlib.sha1("mailto:bob@example.com").hexdigest())
        self.assertEquals(bob.objectType, "Agent")
        self.assertFalse(bob.name)
        self.assertFalse(bob.mbox)

    def test_agent_openID_create(self):
        stmt = json.dumps({"actor":{"objectType": "Agent", "openID":"http://bob.openID.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed"},
            "object": {'id': 'act://blah.com'}})

        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)        
        st = models.Statement.objects.get(statement_id=st_id[0])
        bob = st.actor

        self.assertEquals(bob.openID, "http://bob.openID.com")
        self.assertEquals(bob.objectType, "Agent")
        self.assertFalse(bob.name)
        self.assertFalse(bob.mbox)
        self.assertFalse(bob.mbox_sha1sum)

    def test_agent_account_create(self):
        stmt = json.dumps({"actor":{"objectType": "Agent", "account":{"homePage": "http://www.adlnet.gov", "name":"freakshow"}},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed"},
            "object": {'id': 'act://blah.com'}})

        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)        
        st = models.Statement.objects.get(statement_id=st_id[0])
        bob = st.actor

        self.assertEquals(bob.account_name, "freakshow")
        self.assertEquals(bob.account_homePage, "http://www.adlnet.gov")
        self.assertFalse(bob.name)
        self.assertFalse(bob.mbox)
        self.assertFalse(bob.mbox_sha1sum)
        self.assertFalse(bob.openID)

    def test_agent_kwargs_basic(self):
        ot = "Agent"
        name = "bob bobson"
        mbox = "mailto:bobbobson@example.com"
        kwargs = {"objectType":ot,"name":name,"mbox":mbox}
        bob, created = Agent.objects.retrieve_or_create(**kwargs)
        self.assertTrue(created)
        bob.save()
        self.assertEquals(bob.objectType, ot)
        self.assertEquals(bob.name, name)
        self.assertEquals(bob.mbox, mbox)

        bob2, created = Agent.objects.retrieve_or_create(**kwargs)
        self.assertFalse(created)
        self.assertEquals(bob.pk, bob2.pk)
        self.assertEquals(bob, bob2)

        kwargs['mbox'] = "mailto:bob.secret@example.com"
        bob3, created = Agent.objects.retrieve_or_create(**kwargs)
        self.assertTrue(created)
        bob3.save()
        self.assertNotEqual(bob.pk, bob3.pk)

    def test_agent_kwargs_basic_account(self):        
        ot = "Agent"
        name = "bob bobson"
        account = json.dumps({"homePage":"http://www.adlnet.gov","name":"freakshow"})
        kwargs = {"objectType":ot,"name":name,"account":account}
        bob, created = Agent.objects.retrieve_or_create(**kwargs)
        self.assertTrue(created)
        self.assertEquals(bob.objectType, ot)
        self.assertEquals(bob.name, name)
        self.assertEquals(bob.account_homePage, "http://www.adlnet.gov")
        self.assertEquals(bob.account_name, "freakshow")

    def test_group_kwargs(self):
        ot = "Agent"
        name = "bob bobson"
        kwargs = {"objectType":ot,"name":name, "mbox": "mailto:bob@example.com"}
        bob, created = Agent.objects.retrieve_or_create(**kwargs)

        ot = "Agent"
        name = "john johnson"
        kwargs = {"objectType":ot,"name":name, "mbox": "mailto:john@example.com"}
        john, created = Agent.objects.retrieve_or_create(**kwargs)
        
        ot = "Group"
        members = [{"name":"bob bobson","mbox":"mailto:bob@example.com"},
                    {"name":"john johnson","mbox":"mailto:john@example.com"}]
        
        kwargs = {"objectType":ot, "member": members}
        gr, created = Agent.objects.retrieve_or_create(**kwargs)
        # Already created from above
        self.assertTrue(created)

        kwargs1 = {"objectType":ot, "member": members, "name": "my group"}
        gr1, created = Agent.objects.retrieve_or_create(**kwargs1)
        # creates another one b/c of adding a name
        self.assertTrue(created)
        self.assertEquals(gr1.name, "my group")
        agents = Agent.objects.all()
        self.assertEquals(len(agents), 4)
        obj_types = agents.values_list('objectType', flat=True)
        self.assertEquals(len(agents.filter(objectType='Group')), 2)
        self.assertEquals(len(agents.filter(objectType='Agent')), 2)

    def test_agent_update_kwargs(self):
        ot = "Agent"
        name = "bill billson"
        kwargs = {"objectType":ot, "mbox": "mailto:bill@example.com"}
        bill, created = Agent.objects.retrieve_or_create(**kwargs)
        self.assertTrue(created)

        kwargs1 = {"objectType":ot, "mbox": "mailto:bill@example.com", "name": name}
        bill2, created = Agent.objects.retrieve_or_create(**kwargs1)
        
        self.assertFalse(created)
        self.assertEquals(bill2.name, name)
        self.assertEquals(bill.id, bill2.id)
        self.assertEquals(len(Agent.objects.all()), 1)

    def test_agent_update_kwargs_with_account(self):
        ot = "Agent"
        name = "bill billson"
        account = json.dumps({"homePage":"http://www.adlnet.gov","name":"freakshow"})
        kwargs = {"objectType":ot,"account":account}
        
        bill, created = Agent.objects.retrieve_or_create(**kwargs)
        self.assertTrue(created)

        kwargs1 = {"objectType":ot, "name": name, "account":account}
        bill2, created = Agent.objects.retrieve_or_create(**kwargs1)
        
        self.assertFalse(created)
        self.assertEquals(bill2.name, name)
        self.assertEquals(bill.id, bill2.id)
        self.assertEquals(len(Agent.objects.all()), 1)

    def test_group_update_kwargs_with_account(self):
        ot = "Group"
        name = "the group"
        account = json.dumps({"homePage":"http://www.adlnet.gov","name":"freakshow-group"})
        members = [{"name":"agent1","mbox":"mailto:agent1@example.com"},
                    {"name":"agent2","mbox":"mailto:agent2@example.com"}]

        kwargs = {"objectType":ot,"member":members, "account":account}
        
        g, created = Agent.objects.retrieve_or_create(**kwargs)
        self.assertTrue(created)

        kwargs1 = {"objectType":ot,"member":members, "name": name, "account":account}
        g1, created = Agent.objects.retrieve_or_create(**kwargs1)
        
        self.assertFalse(created)
        self.assertEquals(g1.name, name)
        self.assertEquals(g.id, g1.id)
        self.assertEquals(len(Agent.objects.all()), 3)
        self.assertEquals(g1.account_name, "freakshow-group")
        self.assertEquals(g.account_name, "freakshow-group")
        self.assertEquals(g1.account_homePage, "http://www.adlnet.gov")
        self.assertEquals(g.account_homePage, "http://www.adlnet.gov")

    def test_group_update_kwargs(self):
        ot = "Group"
        name = "the group"
        mbox = "mailto:the.group@example.com"
        members = [{"name":"agent1","mbox":"mailto:agent1@example.com"},
                    {"name":"agent2","mbox":"mailto:agent2@example.com"}]
        kwargs = {"objectType":ot, "mbox":mbox,"member":members}
        g, created = Agent.objects.retrieve_or_create(**kwargs)
        self.assertTrue(created)

        kwargs1 = {"objectType":ot, "name":name, "mbox":mbox,"member":members}
        g1, created = Agent.objects.retrieve_or_create(**kwargs1)
        self.assertFalse(created)

        self.assertEquals(g1.name, name)
        self.assertEquals(g.id, g1.id)
        # 2 agents 1 group
        self.assertEquals(len(Agent.objects.all()), 3)

    def test_group_update_members(self):
        ot = "Group"
        name = "the group"
        mbox = "mailto:the.group@example.com"
        members = [{"name":"agent1","mbox":"mailto:agent1@example.com"},
                    {"name":"agent2","mbox":"mailto:agent2@example.com"}]
        kwargs = {"objectType":ot, "mbox":mbox,"member":members}
        g, created = Agent.objects.retrieve_or_create(**kwargs)
        self.assertTrue(created)

        members = [{"name":"agent1","mbox":"mailto:agent1@example.com"},
                    {"name":"agent2","mbox":"mailto:agent2@example.com"},
                    {"name":"agent3","mbox":"mailto:agent3@example.com"}]

        kwargs1 = {"objectType":ot, "mbox":mbox,"member":members}
        g1, created = Agent.objects.retrieve_or_create(**kwargs1)
        self.assertFalse(created)

        ags = Agent.objects.filter(objectType='Agent')
        mems = g1.member.all()
        self.assertEquals(len(ags), len(mems))
        self.assertTrue(set(ags) == set(mems))
        self.assertEquals(g.id, g1.id)
        # 3 agents 1 group
        self.assertEquals(len(Agent.objects.all()), 4)

    def test_group_update_members_with_account(self):
        ot = "Group"
        name = "the group"
        account = json.dumps({"homePage":"http://www.adlnet.gov","name":"freakshow-group"})
        members = [{"name":"agent1","mbox":"mailto:agent1@example.com"},
                    {"name":"agent2","mbox":"mailto:agent2@example.com"}]

        kwargs = {"objectType":ot,"member":members,"name":name ,"account":account}
        g, created = Agent.objects.retrieve_or_create(**kwargs)
        self.assertTrue(created)

        members = [{"name":"agent1","mbox":"mailto:agent1@example.com"},
                    {"name":"agent2","mbox":"mailto:agent2@example.com"},
                    {"name":"agent3","mbox":"mailto:agent3@example.com"}]

        kwargs1 = {"objectType":ot, "account":account,"name":name,"member":members}
        g1, created = Agent.objects.retrieve_or_create(**kwargs1)
        self.assertFalse(created)

        ags = Agent.objects.filter(objectType='Agent')
        mems = g1.member.all()
        self.assertEquals(len(ags), len(mems))
        self.assertTrue(set(ags) == set(mems))
        self.assertEquals(g.id, g1.id)
        # 3 agents 1 group
        self.assertEquals(len(Agent.objects.all()), 4)
        self.assertEquals(g1.account_name, "freakshow-group")
        self.assertEquals(g.account_name, "freakshow-group")
        self.assertEquals(g1.account_homePage, "http://www.adlnet.gov")
        self.assertEquals(g.account_homePage, "http://www.adlnet.gov")
        self.assertEquals(g1.name, "the group")
        self.assertEquals(g.name, "the group")


    def test_agent_json_no_ids(self):
        stmt = json.dumps({"actor":{"objectType": "Agent", "name":"freakshow"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed"},
            "object": {'id': 'act://blah.com'}})

        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'One and only one of mbox, mbox_sha1sum, openID, account, openid may be supplied with an Agent')

    def test_agent_json_many_ids(self):
        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:bob@example.com", "openid":"bob.bobson.openID.org"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed"},
            "object": {'id': 'act://blah.com'}})

        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'One and only one of mbox, mbox_sha1sum, openID, account, openid may be supplied with an Agent')

    def test_group(self):
        ot = "Group"
        name = "the group"
        mbox = "mailto:the.group@example.com"
        members = [{"name":"agent1","mbox":"mailto:agent1@example.com"},
                    {"name":"agent2","mbox":"mailto:agent2@example.com"}]
        kwargs = {"objectType":ot, "name":name, "mbox":mbox,"member":members}
        g, created = Agent.objects.retrieve_or_create(**kwargs)
        self.assertTrue(created)
        self.assertEquals(g.name, name)
        self.assertEquals(g.mbox, mbox)
        mems = g.member.values_list('name', flat=True)
        self.assertEquals(len(mems), 2)
        self.assertIn('agent1', mems)
        self.assertIn('agent2', mems)
        gr_dict = g.get_agent_json()
        self.assertEquals(gr_dict['objectType'],'Group')
        
        for member in gr_dict['member']:
            self.assertEquals(member['objectType'], 'Agent')
            if member['name'] == 'agent1':
                self.assertEquals(member['mbox'], 'mailto:agent1@example.com')
            elif member['name'] == 'agent2':
                self.assertEquals(member['mbox'], 'mailto:agent2@example.com')

    def test_group_from_agent_object(self):
        ot = "Group"
        name = "the group"
        mbox = "mailto:the.group@example.com"
        members = [{"name":"agent1","mbox":"mailto:agent1@example.com"},
                    {"name":"agent2","mbox":"mailto:agent2@example.com"}]
        kwargs = {"objectType":ot, "name":name, "mbox":mbox,"member":members}
        g = AgentManager(params=kwargs).Agent
        self.assertEquals(g.name, name)
        self.assertEquals(g.mbox, mbox)
        mems = g.member.values_list('name', flat=True)
        self.assertEquals(len(mems), 2)
        self.assertIn('agent1', mems)
        self.assertIn('agent2', mems)

    def test_group_from_agent_string(self):
        ot = "Group"
        name = "the group"
        mbox = "mailto:the.group@example.com"
        members = [{"name":"agent1","mbox":"mailto:agent1@example.com"},
                    {"name":"agent2","mbox":"mailto:agent2@example.com"}]
        kwargs = {"objectType":ot, "name":name, "mbox":mbox,"member":members}
        g = AgentManager(params=kwargs).Agent
        self.assertEquals(g.name, name)
        self.assertEquals(g.mbox, mbox)
        mems = g.member.values_list('name', flat=True)
        self.assertEquals(len(mems), 2)
        self.assertIn('agent1', mems)
        self.assertIn('agent2', mems)

    def test_agent_del(self):
        ag = Agent(name="the agent", account_homePage="http://adlnet.gov/agent/1",
            account_name="agent 1 account")
        ag.save()

        self.assertEquals(ag.name, "the agent")
        self.assertEquals(ag.account_name, "agent 1 account")
        self.assertEquals(ag.account_homePage, "http://adlnet.gov/agent/1")
        self.assertEquals(1, len(Agent.objects.all()))

        ag.delete()

        self.assertEquals(0, len(Agent.objects.all()))

    def test_agent_format(self):
        ot_s = "Agent"
        name_s = "superman"
        mbox_s = "mailto:superman@example.com"
        kwargs_s = {"objectType":ot_s,"name":name_s,"mbox":mbox_s}
        clark, created = Agent.objects.retrieve_or_create(**kwargs_s)
        self.assertTrue(created)
        clark.save()
        self.assertEquals(clark.objectType, ot_s)
        self.assertEquals(clark.name, name_s)
        self.assertEquals(clark.mbox, mbox_s)

        clark_exact = clark.get_agent_json()
        self.assertEquals(clark_exact['objectType'], ot_s)
        self.assertEquals(clark_exact['name'], name_s)
        self.assertEquals(clark_exact['mbox'], mbox_s)

        clark_ids = clark.get_agent_json(format='ids')
        self.assertFalse('objectType' in str(clark_ids), "object type was found in agent json")
        self.assertFalse('name' in str(clark_ids), "name was found in agent json")
        self.assertEquals(clark_ids['mbox'], mbox_s)

        ot_ww = "Agent"
        name_ww = "wonder woman"
        mbox_sha1sum_ww = hashlib.sha1("mailto:wonderwoman@example.com").hexdigest()
        kwargs_ww = {"objectType":ot_ww,"name":name_ww,"mbox_sha1sum":mbox_sha1sum_ww}
        diana, created = Agent.objects.retrieve_or_create(**kwargs_ww)
        self.assertTrue(created)
        diana.save()
        self.assertEquals(diana.objectType, ot_ww)
        self.assertEquals(diana.name, name_ww)
        self.assertEquals(diana.mbox_sha1sum, mbox_sha1sum_ww)

        diana_exact = diana.get_agent_json()
        self.assertEquals(diana_exact['objectType'], ot_ww)
        self.assertEquals(diana_exact['name'], name_ww)
        self.assertEquals(diana_exact['mbox_sha1sum'], mbox_sha1sum_ww)

        diana_ids = diana.get_agent_json(format='ids')
        self.assertFalse('objectType' in str(diana_ids), "object type was found in agent json")
        self.assertFalse('name' in str(diana_ids), "name was found in agent json")
        self.assertFalse('mbox' in diana_ids.items(), "mbox was found in agent json")
        self.assertEquals(diana_ids['mbox_sha1sum'], mbox_sha1sum_ww)

        ot_b = "Agent"
        name_b = "batman"
        openID_b = "id:batman"
        kwargs_b = {"objectType":ot_b,"name":name_b,"openID":openID_b}
        bruce, created = Agent.objects.retrieve_or_create(**kwargs_b)
        self.assertTrue(created)
        bruce.save()
        self.assertEquals(bruce.objectType, ot_b)
        self.assertEquals(bruce.name, name_b)
        self.assertEquals(bruce.openID, openID_b)

        bruce_exact = bruce.get_agent_json()
        self.assertEquals(bruce_exact['objectType'], ot_b)
        self.assertEquals(bruce_exact['name'], name_b)
        self.assertEquals(bruce_exact['openID'], openID_b)

        bruce_ids = bruce.get_agent_json(format='ids')
        self.assertFalse('objectType' in str(bruce_ids), "object type was found in agent json")
        self.assertFalse('name' in str(bruce_ids), "name was found in agent json")
        self.assertFalse('mbox' in str(bruce_ids), "mbox was found in agent json")
        self.assertFalse('mbox_sha1sum' in str(bruce_ids), "mbox_sha1sum was found in agent json")
        self.assertEquals(bruce_ids['openID'], openID_b)

        ot_f = "Agent"
        name_f = "the flash"
        account_f = {"homePage":"http://ultrasecret.justiceleague.com/accounts/", "name":"theflash"}
        kwargs_f = {"objectType":ot_f,"name":name_f,"account":account_f}
        barry, created = Agent.objects.retrieve_or_create(**kwargs_f)
        self.assertTrue(created)
        barry.save()
        self.assertEquals(barry.objectType, ot_f)
        self.assertEquals(barry.name, name_f)
        self.assertEquals(barry.account_homePage, account_f['homePage'])
        self.assertEquals(barry.account_name, account_f['name'])

        barry_exact = barry.get_agent_json()
        self.assertEquals(barry_exact['objectType'], ot_f)
        self.assertEquals(barry_exact['name'], name_f)
        self.assertEquals(barry_exact['account']['homePage'], account_f['homePage'])
        self.assertEquals(barry_exact['account']['name'], account_f['name'])

        barry_ids = barry.get_agent_json(format='ids')
        self.assertFalse('objectType' in str(barry_ids), "object type was found in agent json")
        self.assertFalse('name' in barry_ids.items(), "name was found in agent json")
        self.assertFalse('mbox' in barry_ids.items(), "mbox was found in agent json")
        self.assertFalse('mbox_sha1sum' in str(barry_ids), "mbox_sha1sum was found in agent json")
        self.assertFalse('openID' in str(barry_ids), "openID was found in agent json")
        self.assertEquals(barry_ids['account']['homePage'], account_f['homePage'])
        self.assertEquals(barry_ids['account']['name'], account_f['name'])

        ot_j = "Group"
        name_j = "Justice League"
        mbox_j = "mailto:justiceleague@example.com"
        kwargs_j = {"objectType":ot_j,"name":name_j,"mbox":mbox_j, "member":[kwargs_s,kwargs_ww,kwargs_f,kwargs_b]}
        justiceleague, created = Agent.objects.retrieve_or_create(**kwargs_j)
        self.assertTrue(created)
        justiceleague.save()
        self.assertEquals(justiceleague.objectType, ot_j)
        self.assertEquals(justiceleague.name, name_j)
        self.assertEquals(justiceleague.mbox, mbox_j)

        justiceleague_exact = justiceleague.get_agent_json()
        self.assertEquals(justiceleague_exact['objectType'], ot_j)
        self.assertEquals(justiceleague_exact['name'], name_j)
        self.assertEquals(justiceleague_exact['mbox'], mbox_j)

        justiceleague_ids = justiceleague.get_agent_json(format='ids')
        self.assertTrue('objectType' in str(justiceleague_ids), "object type was not found in group json")
        self.assertFalse('name' in str(justiceleague_ids), "name was found in agent json")
        self.assertEquals(justiceleague_ids['mbox'], mbox_j)

        badguy_ds = {"objectType":"Agent", "mbox":"mailto:darkseid@example.com", "name":"Darkseid"}
        badguy_m = {"objectType":"Agent", "mbox":"mailto:mantis@example.com", "name":"Mantis"}

        ot_bg = "Group"
        members_bg = [badguy_ds, badguy_m]
        kwargs_bg = {"objectType":ot_bg,"member":members_bg}
        badguys, created = Agent.objects.retrieve_or_create(**kwargs_bg)
        self.assertTrue(created)
        badguys.save()
        self.assertEquals(badguys.objectType, ot_bg)
        bg_members = badguys.member.all()
        self.assertEquals(len(bg_members), 2)
        for bg in bg_members:
            self.assertTrue(bg.name in str(kwargs_bg['member']))

        badguys_exact = badguys.get_agent_json()
        self.assertEquals(badguys_exact['objectType'], ot_bg)
        for m in badguys_exact['member']:
            if m['name'] == badguy_ds['name']:
                self.assertEquals(m['objectType'], badguy_ds['objectType'])
                self.assertEquals(m['mbox'], badguy_ds['mbox'])
            elif m['name'] == badguy_m['name']:
                self.assertEquals(m['objectType'], badguy_m['objectType'])
                self.assertEquals(m['mbox'], badguy_m['mbox'])
            else:
                self.fail("got an unexpected name: " % m['name'])

        badguys_ids = badguys.get_agent_json(format='ids')
        self.assertTrue('objectType' in str(badguys_ids), "object type was not found in group json")
        for m in badguys_ids['member']:
            self.assertFalse('objectType' in str(m), "object type was found in member agent")
            self.assertFalse('name' in str(m), "name was found in member agent")
            if m['mbox'] == badguy_ds['mbox']:
                self.assertEquals(m['mbox'], badguy_ds['mbox'])
            elif m['mbox'] == badguy_m['mbox']:
                self.assertEquals(m['mbox'], badguy_m['mbox'])
            else:
                self.fail("got an unexpected mbox: " % m['mbox'])

########NEW FILE########
__FILENAME__ = AgentProfileTests
from django.test import TestCase
from django.core.urlresolvers import reverse
from lrs import views
import datetime
from django.utils.timezone import utc
import hashlib
import urllib
import base64
import json
import ast

class AgentProfileTests(TestCase):
    testagent = '{"mbox":"mailto:test@example.com"}'
    otheragent = '{"mbox":"mailto:other@example.com"}'
    content_type = "application/json"
    testprofileId1 = "http://profile.test.id/test/1"
    testprofileId2 = "http://profile.test.id/test/2"
    testprofileId3 = "http://profile.test.id/test/3"
    otherprofileId1 = "http://profile.test.id/other/1"

    @classmethod
    def setUpClass(cls):
        print "\n%s" % __name__

    def setUp(self):
        self.username = "tester"
        self.email = "test@tester.com"
        self.password = "test"
        self.auth = "Basic %s" % base64.b64encode("%s:%s" % (self.username, self.password))
        form = {'username':self.username, 'email': self.email,'password':self.password,'password2':self.password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")
        
        self.testparams1 = {"profileId": self.testprofileId1, "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(self.testparams1))
        self.testprofile1 = {"test":"put profile 1","obj":{"agent":"test"}}
        self.put1 = self.client.put(path, self.testprofile1, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.testparams2 = {"profileId": self.testprofileId2, "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(self.testparams2))
        self.testprofile2 = {"test":"put profile 2","obj":{"agent":"test"}}
        self.put2 = self.client.put(path, self.testprofile2, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.testparams3 = {"profileId": self.testprofileId3, "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(self.testparams3))
        self.testprofile3 = {"test":"put profile 3","obj":{"agent":"test"}}
        self.put3 = self.client.put(path, self.testprofile3, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.testparams4 = {"profileId": self.otherprofileId1, "agent": self.otheragent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(self.testparams4))
        self.otherprofile1 = {"test":"put profile 1","obj":{"agent":"other"}}
        self.put4 = self.client.put(path, self.otherprofile1, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def tearDown(self):
        self.client.delete(reverse(views.agent_profile), self.testparams1, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.client.delete(reverse(views.agent_profile), self.testparams2, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.client.delete(reverse(views.agent_profile), self.testparams3, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.client.delete(reverse(views.agent_profile), self.testparams4, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_get_agent_not_found(self):
        a = '{"mbox":["mailto:notfound@example.com"]}'
        p = 'http://agent.not.found'
        param = {"profileId": p, "agent": a}
        r = self.client.get(reverse(views.agent_profile), param, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 404)

    def test_put(self):
        self.assertEqual(self.put1.status_code, 204)
        self.assertEqual(self.put1.content, '')

        self.assertEqual(self.put2.status_code, 204)
        self.assertEqual(self.put2.content, '')

        self.assertEqual(self.put3.status_code, 204)
        self.assertEqual(self.put3.content, '')

        self.assertEqual(self.put4.status_code, 204)
        self.assertEqual(self.put4.content, '')

    def test_put_etag_missing_on_change(self):
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(self.testparams1))
        profile = {"test":"error - trying to put new profile w/o etag header","obj":{"agent":"test"}}
        response = self.client.put(path, profile, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(response.status_code, 409)
        self.assertIn('If-Match and If-None-Match headers were missing', response.content)
        
        r = self.client.get(reverse(views.agent_profile), self.testparams1, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], self.testprofile1['test'])
        self.assertEqual(robj['obj']['agent'], self.testprofile1['obj']['agent'])

    def test_put_etag_right_on_change(self):
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(self.testparams1))
        profile = {"test":"good - trying to put new profile w/ etag header","obj":{"agent":"test"}}
        thehash = '"%s"' % hashlib.sha1('%s' % self.testprofile1).hexdigest()
        response = self.client.put(path, profile, content_type=self.content_type, If_Match=thehash, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 204)
        self.assertEqual(response.content, '')

        r = self.client.get(reverse(views.agent_profile), self.testparams1, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], profile['test'])
        self.assertEqual(robj['obj']['agent'], profile['obj']['agent'])

    def test_put_etag_wrong_on_change(self):
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(self.testparams1))
        profile = {"test":"error - trying to put new profile w/ wrong etag value","obj":{"agent":"test"}}
        thehash = '"%s"' % hashlib.sha1('%s' % 'wrong hash').hexdigest()
        response = self.client.put(path, profile, content_type=self.content_type, If_Match=thehash, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 412)
        self.assertIn('No resources matched', response.content)

        r = self.client.get(reverse(views.agent_profile), self.testparams1, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], self.testprofile1['test'])
        self.assertEqual(robj['obj']['agent'], self.testprofile1['obj']['agent'])

    def test_put_etag_if_none_match_good(self):
        params = {"profileId": 'http://etag.nomatch.good', "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(params))
        profile = {"test":"good - trying to put new profile w/ if none match etag header","obj":{"agent":"test"}}
        response = self.client.put(path, profile, content_type=self.content_type, If_None_Match='*', Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(response.status_code, 204)
        self.assertEqual(response.content, '')

        r = self.client.get(reverse(views.agent_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], profile['test'])
        self.assertEqual(robj['obj']['agent'], profile['obj']['agent'])

        r = self.client.delete(reverse(views.agent_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_put_etag_if_none_match_bad(self):
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(self.testparams1))
        profile = {"test":"error - trying to put new profile w/ if none match etag but one exists","obj":{"agent":"test"}}
        response = self.client.put(path, profile, content_type=self.content_type, If_None_Match='*', Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(response.status_code, 412)
        self.assertEqual(response.content, 'Resource detected')

        r = self.client.get(reverse(views.agent_profile), self.testparams1, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], self.testprofile1['test'])
        self.assertEqual(robj['obj']['agent'], self.testprofile1['obj']['agent'])

    def test_get(self):
        r = self.client.get(reverse(views.agent_profile), self.testparams1, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], self.testprofile1['test'])
        self.assertEqual(robj['obj']['agent'], self.testprofile1['obj']['agent'])
        self.assertEqual(r['etag'], '"%s"' % hashlib.sha1('%s' % self.testprofile1).hexdigest())

        r2 = self.client.get(reverse(views.agent_profile), self.testparams2, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r2.status_code, 200)
        robj2 = ast.literal_eval(r2.content)
        self.assertEqual(robj2['test'], self.testprofile2['test'])
        self.assertEqual(robj2['obj']['agent'], self.testprofile2['obj']['agent'])
        self.assertEqual(r2['etag'], '"%s"' % hashlib.sha1('%s' % self.testprofile2).hexdigest())
        
        r3 = self.client.get(reverse(views.agent_profile), self.testparams3, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r3.status_code, 200)
        robj3 = ast.literal_eval(r3.content)
        self.assertEqual(robj3['test'], self.testprofile3['test'])
        self.assertEqual(robj3['obj']['agent'], self.testprofile3['obj']['agent'])
        self.assertEqual(r3['etag'], '"%s"' % hashlib.sha1('%s' % self.testprofile3).hexdigest())

        r4 = self.client.get(reverse(views.agent_profile), self.testparams4, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r4.status_code, 200)
        robj4 = ast.literal_eval(r4.content)
        self.assertEqual(robj4['test'], self.otherprofile1['test'])
        self.assertEqual(robj4['obj']['agent'], self.otherprofile1['obj']['agent'])
        self.assertEqual(r4['etag'], '"%s"' % hashlib.sha1('%s' % self.otherprofile1).hexdigest())

    def test_get_no_params(self):
        r = self.client.get(reverse(views.agent_profile), Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 400)
        self.assertIn('agent parameter missing', r.content)
    
    def test_get_no_agent(self):
        params = {"profileId": self.testprofileId1}
        r = self.client.get(reverse(views.agent_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 400)
        self.assertIn('agent parameter missing', r.content)

    def test_get_no_profileId(self):
        params = {"agent": self.testagent}
        r = self.client.get(reverse(views.agent_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
    
    def test_delete(self):
        prof_id = "http://deleteme"
        params = {"profileId": prof_id, "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(params))
        profile = {"test":"delete profile","obj":{"agent":"test"}}
        response = self.client.put(path, profile, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        r = self.client.get(reverse(views.agent_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test'], profile['test'])
        self.assertEqual(robj['obj']['agent'], profile['obj']['agent'])

        r = self.client.delete(reverse(views.agent_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 204)

        r = self.client.get(reverse(views.agent_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 404)

    def test_get_agent_since(self):
        prof_id = "http://oldprofile/time"
        updated =  datetime.datetime(2012, 6, 12, 12, 00).replace(tzinfo=utc)

        params = {"profileId": prof_id, "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(params))

        profile = {"test1":"agent profile since time: %s" % updated,"obj":{"agent":"test"}}
        response = self.client.put(path, profile, content_type=self.content_type, updated=updated.isoformat(), Authorization=self.auth, X_Experience_API_Version="1.0.0")

        r = self.client.get(reverse(views.agent_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test1'], profile['test1'])
        self.assertEqual(robj['obj']['agent'], profile['obj']['agent'])

        since = datetime.datetime(2012, 7, 1, 12, 00).replace(tzinfo=utc)
        params2 = {"agent": self.testagent, "since":since.isoformat()}
        r2 = self.client.get(reverse(views.agent_profile), params2, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertNotIn(prof_id, r2.content)

        self.client.delete(reverse(views.agent_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_get_agent_since_tz(self):
        prof_id = "http://oldprofile/time"
        updated =  datetime.datetime(2012, 6, 12, 12, 00).replace(tzinfo=utc)

        params = {"profileId": prof_id, "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(params))

        profile = {"test2":"agent profile since time: %s" % updated,"obj":{"agent":"test"}}
        response = self.client.put(path, profile, content_type=self.content_type, updated=updated.isoformat(), Authorization=self.auth, X_Experience_API_Version="1.0.0")

        r = self.client.get(reverse(views.agent_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        robj = ast.literal_eval(r.content)
        self.assertEqual(robj['test2'], profile['test2'])
        self.assertEqual(robj['obj']['agent'], profile['obj']['agent'])

        prof_id2 = "http://newprofile/timezone"
        updated2 =  "2012-7-1T08:30:00-04:00"

        params2 = {"profileId": prof_id2, "agent": self.testagent}
        path2 = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(params2))

        profile2 = {"test3":"agent profile since time: %s" % updated2,"obj":{"agent":"test"}}
        response = self.client.put(path2, profile2, content_type=self.content_type, updated=updated2, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        r2 = self.client.get(reverse(views.agent_profile), params2, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r2.status_code, 200)
        robj2 = ast.literal_eval(r2.content)
        self.assertEqual(robj2['test3'], profile2['test3'])
        self.assertEqual(robj2['obj']['agent'], profile2['obj']['agent'])

        since = datetime.datetime(2012, 7, 1, 12, 00).replace(tzinfo=utc)

        par = {"agent": self.testagent, "since":since.isoformat()}
        r = self.client.get(reverse(views.agent_profile), par, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertNotIn(prof_id, r.content)
        self.assertIn(prof_id2, r.content)

        self.client.delete(reverse(views.agent_profile), params, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.client.delete(reverse(views.agent_profile), params2, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_post_put_delete(self):
        prof_id = "http://deleteme.too"
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode({"method":"PUT"}))
        content = {"test":"delete profile","obj":{"actor":"test", "testcase":"ie cors post for put and delete"}}
        thedata = "profileId=%s&agent=%s&content=%s&Authorization=%s&Content-Type=application/json&X-Experience-API-Version=1.0.0" % (prof_id, self.testagent, content, self.auth)
        response = self.client.post(path, thedata, content_type="application/x-www-form-urlencoded")
        self.assertEqual(response.status_code, 204)
        r = self.client.get(reverse(views.agent_profile), {"profileId": prof_id, "agent": self.testagent}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        import ast
        c = ast.literal_eval(r.content)
        self.assertEqual(c['test'], content['test'])
 
        thedata = "profileId=%s&agent=%s&Authorization=%s&X-Experience-API-Version=1.0" % (prof_id, self.testagent, self.auth)
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode({"method":"DELETE"}))
        r = self.client.post(path, thedata, content_type="application/x-www-form-urlencoded", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 204)

        r = self.client.get(reverse(views.agent_profile), {"profileId": prof_id, "agent": self.testagent}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 404)

    def test_group_as_agent(self):
        ot = "Group"
        name = "the group APT"
        mbox = "mailto:the.groupAPT@example.com"
        members = [{"name":"agentA","mbox":"mailto:agentA@example.com"},
                    {"name":"agentB","mbox":"mailto:agentB@example.com"}]
        testagent = json.dumps({"objectType":ot, "name":name, "mbox":mbox,"member":members})
        testprofileId = "http://profile.test.id/group.as.agent/"
        testparams1 = {"profileId": testprofileId, "agent": testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(testparams1))
        testprofile = {"test":"put profile - group as agent","obj":{"agent":"group"}}
        put1 = self.client.put(path, testprofile, content_type=self.content_type, Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(put1.status_code, 204)

        getr = self.client.get(reverse(views.agent_profile), testparams1, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(getr.status_code, 200)
        robj = ast.literal_eval(getr.content)
        self.assertEqual(robj['test'], testprofile['test'])
        self.assertEqual(robj['obj']['agent'], testprofile['obj']['agent'])

        self.client.delete(reverse(views.agent_profile), testparams1, Authorization=self.auth, X_Experience_API_Version="1.0.0")

    def test_post_new_profile(self):
        params = {"profileId": "prof:test_post_new_profile", "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(params))
        prof = {"test":"post new profile","obj":{"agent":"mailto:test@example.com"}}
        
        post = self.client.post(path, prof, content_type="application/json", Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 204)
        
        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        self.assertEqual(ast.literal_eval(get.content), prof)
        self.assertEqual(get.get('etag'), '"%s"' % hashlib.sha1(get.content).hexdigest())
        self.client.delete(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")

    def test_post_blank_profile(self):
        params = {"profileId": "prof:test_post_new_profile", "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(params))
        prof = ""
        
        post = self.client.post(path, prof, content_type="application/json", Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        
        self.assertEqual(post.status_code, 400)
        self.assertEqual(post.content, 'No body in request')

    def test_post_update_profile(self):
        params = {"profileId": "prof:test_post_update_profile", "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(params))
        prof = {"test":"post updated profile","obj":{"agent":"mailto:test@example.com"}}
        
        post = self.client.post(path, json.dumps(prof), content_type="application/json", Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 204)
        
        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        self.assertEqual(json.loads(get.content), prof)
        etag = '"%s"' % hashlib.sha1(get.content).hexdigest()
        self.assertEqual(get.get('etag'), etag)

        params = {"profileId": "prof:test_post_update_profile", "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(params))
        prof = {"obj":{"agent":"mailto:test@example.com", "new":"thing"}, "added":"yes"}

        post = self.client.post(path, json.dumps(prof), content_type="application/json", Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 409)
        
        post = self.client.post(path, json.dumps(prof), content_type="application/json",If_Match=etag, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 204)

        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        ret_json = json.loads(get.content)
        self.assertEqual(ret_json['added'], prof['added'])
        self.assertEqual(ret_json['test'], "post updated profile")
        self.assertEqual(ret_json['obj']['agent'], prof['obj']['agent'])
        self.assertEqual(ret_json['obj']['new'], prof['obj']['new'])
        self.assertEqual(get.get('etag'), '"%s"' % hashlib.sha1(get.content).hexdigest())

        self.client.delete(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")

    def test_post_and_put_profile(self):
        params = {"profileId": "prof:test_post_and_put_profile", "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(params))
        prof = {"test":"post and put profile","obj":{"agent":"mailto:test@example.com"}}
        
        post = self.client.post(path, json.dumps(prof), content_type="application/json", Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 204)
        
        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        self.assertEqual(json.loads(get.content), prof)
        self.assertEqual(get.get('etag'), '"%s"' % hashlib.sha1(get.content).hexdigest())

        params = {"profileId": "prof:test_post_and_put_profile", "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(params))
        prof = {"wipe":"new data"}
        thehash = get.get('etag')
        
        put = self.client.put(path, json.dumps(prof), content_type="application/json", If_Match=thehash, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(put.status_code, 204)
        
        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        self.assertEqual(json.loads(get.content), prof)
        etag = '"%s"' % hashlib.sha1(get.content).hexdigest()
        self.assertEqual(get.get('etag'), etag)

        params = {"profileId": "prof:test_post_and_put_profile", "agent": self.testagent}
        path = '%s?%s' % (reverse(views.agent_profile), urllib.urlencode(params))
        prof = {"test":"post updated profile","obj":{"agent":"mailto:test@example.com", "new":"thing"}, "added":"yes"}
        
        post = self.client.post(path, json.dumps(prof), content_type="application/json", Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 409)

        post = self.client.post(path, json.dumps(prof), content_type="application/json", If_Match=etag, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 204)

        get = self.client.get(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")
        self.assertEqual(get.status_code, 200)
        ret_json = json.loads(get.content)
        self.assertEqual(ret_json['wipe'], "new data")
        self.assertEqual(ret_json['added'], prof['added'])
        self.assertEqual(ret_json['test'], prof['test'])
        self.assertEqual(ret_json['obj']['agent'], prof['obj']['agent'])
        self.assertEqual(ret_json['obj']['new'], prof['obj']['new'])
        self.assertEqual(get.get('etag'), '"%s"' % hashlib.sha1(get.content).hexdigest())

        self.client.delete(path, Authorization=self.auth,  X_Experience_API_Version="1.0.0")

########NEW FILE########
__FILENAME__ = AgentsTests
from django.test import TestCase
from django.test.utils import setup_test_environment
from django.core.urlresolvers import reverse
from lrs import views
import json
from os import path
import sys
import base64
from lrs.models import Agent

class AgentsTests(TestCase):
    @classmethod
    def setUpClass(cls):
        print "\n%s" % __name__

    def setUp(self):
        self.username = "tester"
        self.password = "test"
        self.email = "test@example.com"
        self.auth = "Basic %s" % base64.b64encode("%s:%s" % (self.username, self.password))
        form = {'username':self.username,'password':self.password,'password2':self.password, 'email':self.email}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")

    def test_get_no_agents(self):
        agent = json.dumps({"name":"me","mbox":"mailto:me@example.com"})
        response = self.client.get(reverse(views.agents), {'agent':agent}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.content, "Error with Agent. The agent partial did not match any agents on record")

    def test_get(self):
        a = json.dumps({"name":"me","mbox":"mailto:me@example.com"})
        me = Agent.objects.retrieve_or_create(**json.loads(a))
        response = self.client.get(reverse(views.agents), {'agent':a}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        r_data = json.loads(response.content)
        self.assertTrue(isinstance(r_data['mbox'], list))
        self.assertTrue(isinstance(r_data['name'], list))
        self.assertEqual(r_data['mbox'], ['mailto:me@example.com'])
        self.assertEqual(r_data['name'], ['me'])
        self.assertEqual(r_data['objectType'], 'Person')
        self.assertIn('content-length', response._headers)

    def test_get_no_existing_agent(self):
        a = json.dumps({"mbox":"mailto:fail@fail.com"})
        response = self.client.get(reverse(views.agents), {'agent':a}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.content, 'Error with Agent. The agent partial did not match any agents on record')
        self.assertEqual(response.status_code, 404)

    def test_head(self):
        a = json.dumps({"name":"me","mbox":"mailto:me@example.com"})
        me = Agent.objects.retrieve_or_create(**json.loads(a))
        response = self.client.head(reverse(views.agents), {'agent':a}, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.content, '')
        self.assertIn('content-length', response._headers)

    def test_get_no_agent(self):
        response = self.client.get(reverse(views.agents), Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
    
    def test_post(self):
        agent = json.dumps({"name":"me","mbox":"mailto:me@example.com"})
        response = self.client.post(reverse(views.agents), {'agent':agent},content_type='application/x-www-form-urlencoded', Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 405)

########NEW FILE########
__FILENAME__ = AuthTests
from django.test import TestCase
from django.test.utils import setup_test_environment
from django.core.urlresolvers import reverse
from lrs import views, models
from os import path
from django.conf import settings
import sys
import json
import base64
import uuid
from datetime import datetime, timedelta
from django.utils.timezone import utc
from lrs.objects.StatementManager import StatementManager
import time
import urllib
from lrs.util import retrieve_statement
import hashlib

class AuthTests(TestCase):
    # Want to test no auth, so have to disable both auths
    @classmethod
    def setUpClass(cls):
        print "\n%s" % __name__

    def setUp(self):
        if settings.HTTP_AUTH_ENABLED:
            settings.HTTP_AUTH_ENABLED = False

        if settings.OAUTH_ENABLED:
            settings.OAUTH_ENABLED = False
        
        self.guid1 = str(uuid.uuid1())
        self.guid2 = str(uuid.uuid1())
        self.guid3 = str(uuid.uuid1())    
        self.guid4 = str(uuid.uuid1())
        self.guid5 = str(uuid.uuid1())
        self.guid6 = str(uuid.uuid1())
        self.guid7 = str(uuid.uuid1())
        self.guid8 = str(uuid.uuid1())
        self.guid9 = str(uuid.uuid1())        
        self.guid10 = str(uuid.uuid1())
        self.cguid1 = str(uuid.uuid1())
        self.cguid2 = str(uuid.uuid1())    
        self.cguid3 = str(uuid.uuid1())
        self.cguid4 = str(uuid.uuid1())
        self.cguid5 = str(uuid.uuid1())
        self.cguid6 = str(uuid.uuid1())
        self.cguid7 = str(uuid.uuid1())
        self.cguid8 = str(uuid.uuid1())

        stmt = {"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
            "display": {"en-US":"created"}}, "object": {"id":"act:activity"},
            "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"}}
        self.existStmt = StatementManager(stmt, stmt_json=json.dumps(stmt))
        
        self.exist_stmt_id = self.existStmt.model_object.statement_id

        self.firstTime = str(datetime.utcnow().replace(tzinfo=utc).isoformat())

        self.existStmt1 = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
            "display": {"en-US":"created"}},"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object": {"objectType": "Activity", "id":"act:foogie",
            "definition": {"name": {"en-US":"testname2", "en-GB": "altname"},
            "description": {"en-US":"testdesc2", "en-GB": "altdesc"}, "type": "http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "fill-in","correctResponsesPattern": ["answer"],
            "extensions": {"ext:key1": "value1", "ext:key2": "value2","ext:key3": "value3"}}}, 
            "result": {"score":{"scaled":.85}, "completion": True, "success": True, "response": "kicked",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:key1": "value1", "ext:key2":"value2"}},
            "context":{"registration": self.cguid1, "contextActivities": {"other": {"id": "act:NewActivityID2"}},
            "revision": "food", "platform":"bard","language": "en-US", "extensions":{"ext:ckey1": "cval1",
            "ext:ckey2": "cval2"}}})        

        self.existStmt2 = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
            "display": {"en-US":"created"}},"actor":{"objectType":"Agent","mbox":"mailto:s@t.com"},
            "object": {"objectType": "Activity", "id":"act:foogie",
            "definition": {"name": {"en-US":"testname3", "en-GB": "altname"},
            "description": {"en-US":"testdesc3","en-GB":"altdesc"}, "type": "http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "fill-in","correctResponsesPattern": ["answers"],
            "extensions": {"ext:key11": "value11", "ext:key22": "value22","ext:key33": "value33"}}}, 
            "result": {"score":{"scaled":.75}, "completion": True, "success": True, "response": "shouted",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:dkey1": "dvalue1", "ext:dkey2":"dvalue2"}},
            "context":{"registration": self.cguid2, "contextActivities": {"other": {"id": "act:NewActivityID22"}},
            "revision": "food", "platform":"bard","language": "en-US", "extensions":{"ext:ckey11": "cval11",
            "ext:ckey22": "cval22"}}})        

        self.existStmt3 = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
            "display": {"en-US":"created"}},"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object": {"objectType": "Activity", "id":"act:act:foogals",
            "definition": {"name": {"en-US":"testname3"},"description": {"en-US":"testdesc3"}, "type": "http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "fill-in","correctResponsesPattern": ["answers"],
            "extensions": {"ext:key111": "value111", "ext:key222": "value222","ext:key333": "value333"}}}, 
            "result": {"score":{"scaled":.79}, "completion": True, "success": True, "response": "shouted",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:dkey1": "dvalue1", "ext:dkey2":"dvalue2"}},
            "context":{"registration": self.cguid3, "contextActivities": {"other": {"id": "act:NewActivityID22"}},
            "revision": "food", "platform":"bard","language": "en-US",
            "instructor":{"objectType": "Agent", "name":"bob", "mbox":"mailto:bob@bob.com"}, 
            "extensions":{"ext:ckey111": "cval111","ext:ckey222": "cval222"}}})        

        self.existStmt4 = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
            "display": {"en-US":"created"}},"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object": {"objectType": "Activity", "id":"act:foogal",
            "definition": {"name": {"en-US":"testname3"},"description": {"en-US":"testdesc3"}, "type": "http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "fill-in","correctResponsesPattern": ["answers"],
            "extensions": {"ext:key111": "value111", "ext:key222": "value222","ext:key333": "value333"}}}, 
            "result": {"score":{"scaled":.79}, "completion": True, "success": True, "response": "shouted",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:dkey1": "dvalue1", "ext:dkey2":"dvalue2"}},
            "context":{"registration": self.cguid4, "contextActivities": {"other": {"id": "act:NewActivityID22"}},
            "revision": "food", "platform":"bard","language": "en-US","instructor":{"name":"bill", "mbox":"mailto:bill@bill.com"},
            "extensions":{"ext:ckey111": "cval111","ext:ckey222": "cval222"}}})

        self.existStmt5 = json.dumps({"object":{"objectType":"Agent","name":"jon","mbox":"mailto:jon@jon.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/created","display": {"en-US":"created"}},
            "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"}})

        self.existStmt6 = json.dumps({"actor": {"objectType":"Agent","name":"max","mbox":"mailto:max@max.com"}, 
                                      "object":{"id": "act:test_activity"},"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
                                      "display": {"en-US":"created"}}})

        self.existStmt7 = json.dumps({"object": {"objectType":"Agent","name":"max","mbox":"mailto:max@max.com"},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/created","display": {"en-US":"created"}},
            "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"}})

        self.existStmt8 = json.dumps({"object": {"objectType":"Agent","name":"john","mbox":"mailto:john@john.com"},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/missed","display": {"en-US":"missed"}},
            "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"}})

        self.existStmt9 = json.dumps({"actor":{"objectType":"Agent","mbox":"mailto:sub@sub.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/missed"},"object":{"objectType":"SubStatement",
            "actor":{"objectType":"Agent","mbox":"mailto:ss@ss.com"},"verb": {"id":"nested:verb/url/nested"},
            "object": {"objectType":"Activity", "id":"act:testex.com"}, "result":{"completion": True, "success": True,
            "response": "kicked"}, "context":{"registration": self.cguid6,
            "contextActivities": {"other": {"id": "act:NewActivityID"}},"revision": "foo", "platform":"bar",
            "language": "en-US", "extensions":{"ext:k1": "v1", "ext:k2": "v2"}}}})

        self.existStmt10 = json.dumps({"actor":{"objectType":"Agent","mbox":"mailto:ref@ref.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/missed"},"object":{"objectType":"StatementRef",
            "id":str(self.exist_stmt_id)}})

        # Put statements
        param = {"statementId":self.guid1}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt1
        self.putresponse1 = self.client.put(path, stmt_payload, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse1.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=2)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid1).update(stored=time)


        param = {"statementId":self.guid3}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt3
        self.putresponse3 = self.client.put(path, stmt_payload, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse3.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=3)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid3).update(stored=time)

        
        param = {"statementId":self.guid4}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt4
        self.putresponse4 = self.client.put(path, stmt_payload, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse4.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=4)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid4).update(stored=time)

        self.secondTime = str((datetime.utcnow()+timedelta(seconds=4)).replace(tzinfo=utc).isoformat())
        
        param = {"statementId":self.guid2}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt2
        self.putresponse2 = self.client.put(path, stmt_payload, content_type="application/json",  X_Experience_API_Version="1.0.0")       
        self.assertEqual(self.putresponse2.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=6)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid2).update(stored=time)


        param = {"statementId":self.guid5}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt5
        self.putresponse5 = self.client.put(path, stmt_payload, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse5.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=7)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid5).update(stored=time)
        

        param = {"statementId":self.guid6}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt6
        self.putresponse6 = self.client.put(path, stmt_payload, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse6.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=8)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid6).update(stored=time)

        
        param = {"statementId":self.guid7}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt7        
        self.putresponse7 = self.client.put(path, stmt_payload,  content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse7.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=9)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid7).update(stored=time)
        

        param = {"statementId":self.guid8}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt8        
        self.putresponse8 = self.client.put(path, stmt_payload, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse8.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=10)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid8).update(stored=time)
        
        param = {"statementId": self.guid9}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt9        
        self.putresponse9 = self.client.put(path, stmt_payload, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse9.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=11)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid9).update(stored=time)

        param = {"statementId": self.guid10}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt10        
        self.putresponse10 = self.client.put(path, stmt_payload, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse10.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=11)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid10).update(stored=time)

    def tearDown(self):
        if not settings.HTTP_AUTH_ENABLED:
            settings.HTTP_AUTH_ENABLED = True
        if not settings.OAUTH_ENABLED:
            settings.OAUTH_ENABLED = True

    def test_send_http_auth_not_enabled(self):
        username = "tester1"
        email = "test1@tester.com"
        password = "test"
        auth = "Basic %s" % base64.b64encode("%s:%s" % (username, password))
        form = {"username":username, "email":email,"password":password,"password2":password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")        

        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/authwithnoauth","display": {"en-US":"passed"}},
            "object": {"id":"act:test_post"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
             X_Experience_API_Version="1.0.0", Authorization=auth)

        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, "HTTP authorization is not enabled. To enable, set the HTTP_AUTH_ENABLED flag to true in settings")

    def test_post_with_no_valid_params(self):
        # Error will be thrown in statements class
        resp = self.client.post(reverse(views.statements), {"feet":"yes","hands": {"id":"http://example.com/test_post"}},
            content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 400)

    def test_post(self):
        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_post"}})

        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
             X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        act = models.Activity.objects.get(activity_id="act:test_post")
        self.assertEqual(act.activity_id, "act:test_post")
        agent = models.Agent.objects.get(mbox="mailto:t@t.com")
        self.assertEqual(agent.name, "bob")

    def test_post_stmt_ref_no_existing_stmt(self):
        stmt = json.dumps({"actor":{"objectType":"Agent","mbox":"mailto:ref@ref.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/missed"},"object":{"objectType":"StatementRef",
            "id":"12345678-1234-5678-1234-567812345678"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
             X_Experience_API_Version="1.0.0")        

        self.assertEqual(response.status_code, 404)


    def test_post_with_actor(self):
        stmt = json.dumps({"actor":{"mbox":"mailto:mr.t@example.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:i.pity.the.fool"}})
        
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)
        agent = models.Agent.objects.get(mbox="mailto:mr.t@example.com")

    def test_list_post(self):
        stmts = json.dumps([{"verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_list_post"}, "actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/failed","display": {"en-GB":"failed"}},
            "object": {"id":"act:test_list_post1"}, "actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}}])
        
        response = self.client.post(reverse(views.statements), stmts,  content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)
        activity1 = models.Activity.objects.get(activity_id="act:test_list_post")
        activity2 = models.Activity.objects.get(activity_id="act:test_list_post1")
        stmt1 = models.Statement.objects.get(object_activity=activity1)
        stmt2 = models.Statement.objects.get(object_activity=activity2)
        verb1 = models.Verb.objects.get(id=stmt1.verb.id)
        verb2 = models.Verb.objects.get(id=stmt2.verb.id)
        lang_map1 = verb1.display
        lang_map2 = verb2.display

        self.assertEqual(response.status_code, 200)
        self.assertEqual(stmt1.verb.verb_id, "http://adlnet.gov/expapi/verbs/passed")
        self.assertEqual(stmt2.verb.verb_id, "http://adlnet.gov/expapi/verbs/failed")
        
        self.assertEqual(lang_map1.keys()[0], "en-US")
        self.assertEqual(lang_map1.values()[0], "passed")
        self.assertEqual(lang_map2.keys()[0], "en-GB")
        self.assertEqual(lang_map2.values()[0], "failed")


    def test_put(self):
        guid = str(uuid.uuid1())

        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_put"},"actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}})

        putResponse = self.client.put(path, stmt, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(putResponse.status_code, 204)
        stmt = models.Statement.objects.get(statement_id=guid)

        act = models.Activity.objects.get(activity_id="act:test_put")
        self.assertEqual(act.activity_id, "act:test_put")

        self.assertEqual(stmt.actor.mbox, "mailto:t@t.com")
        
        self.assertEqual(stmt.verb.verb_id, "http://adlnet.gov/expapi/verbs/passed")

    def test_put_with_substatement(self):
        con_guid = str(uuid.uuid1())
        st_guid = str(uuid.uuid1())

        param = {"statementId": st_guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt = json.dumps({"actor":{"objectType":"Agent","mbox":"mailto:sass@sass.com"},
            "verb": {"id":"verb:verb/url/tested"}, "object":{"objectType":"SubStatement",
            "actor":{"objectType":"Agent","mbox":"mailto:ss@ss.com"},"verb": {"id":"verb:verb/url/nested"},
            "object": {"objectType":"Activity", "id":"act:testex.com"}, "result":{"completion": True, "success": True,
            "response": "kicked"}, "context":{"registration": con_guid,
            "contextActivities": {"other": {"id": "act:NewActivityID"}},"revision": "foo", "platform":"bar",
            "language": "en-US", "extensions":{"ext:k1": "v1", "ext:k2": "v2"}}}})
        
        response = self.client.put(path, stmt, content_type="application/json",
             X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 204)

        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        get_response = self.client.get(path, X_Experience_API_Version="1.0.0", )
        self.assertEqual(get_response.status_code, 200)
        rsp = get_response.content
        self.assertIn("objectType",rsp)
        self.assertIn("SubStatement", rsp)
        self.assertIn("actor",rsp)
        self.assertIn("mailto:ss@ss.com",rsp)
        self.assertIn("verb",rsp)
        self.assertIn("verb:verb/url/nested", rsp)
        self.assertIn("Activity", rsp)
        self.assertIn("act:testex.com", rsp)
        self.assertIn("result", rsp)
        self.assertIn("completion",rsp)
        self.assertIn("success", rsp)
        self.assertIn("response", rsp)
        self.assertIn("kicked", rsp)
        self.assertIn("context", rsp)
        self.assertIn(con_guid, rsp)
        self.assertIn("contextActivities", rsp)
        self.assertIn("other", rsp)
        self.assertIn("revision", rsp)
        self.assertIn("foo", rsp)
        self.assertIn("platform", rsp)
        self.assertIn("bar", rsp)
        self.assertIn("language", rsp)
        self.assertIn("en-US", rsp)
        self.assertIn("extensions", rsp)
        self.assertIn("ext:k1", rsp)
        self.assertIn("v1", rsp)
        self.assertIn("ext:k2", rsp)
        self.assertIn("v2", rsp)                                                                                                                                                                                                                

    def test_no_content_put(self):
        guid = str(uuid.uuid1())
        
        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        stmt = json.dumps({})

        putResponse = self.client.put(path, stmt, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(putResponse.status_code, 400)

    def test_existing_stmtID_put(self):
        guid = str(uuid.uuid1())

        existStmt = StatementManager({"statement_id":guid,
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:activity"},"actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}})

        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        stmt = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object":{"id":"act:test_existing_put"}, "actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}})

        putResponse = self.client.put(path, stmt, content_type="application/json",  X_Experience_API_Version="1.0.0")
        
        self.assertEqual(putResponse.status_code, 409)        

    def test_missing_stmtID_put(self):        
        stmt = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:act:test_put"},"actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}})
        response = self.client.put(reverse(views.statements), stmt, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn(response.content, "Error -- statements - method = PUT, but no statementId parameter or ID given in statement")

    def test_get(self):
        param = {"statementId":self.guid1}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        getResponse = self.client.get(path, X_Experience_API_Version="1.0.0", )
        self.assertEqual(getResponse.status_code, 200)
        rsp = getResponse.content
        self.assertIn(self.guid1, rsp)

    def test_get_no_existing_ID(self):
        param = {"statementId":"aaaaaa"}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        getResponse = self.client.get(path, X_Experience_API_Version="1.0.0", )
        self.assertEqual(getResponse.status_code, 404)

    def test_get_no_statementid(self):
        getResponse = self.client.get(reverse(views.statements), X_Experience_API_Version="1.0.0", )
        self.assertEqual(getResponse.status_code, 200)
        jsn = json.loads(getResponse.content)
        self.assertEqual(len(jsn["statements"]), 11)
       

    # Sever activities are PUT-contextActivites create 3 more
    def test_number_of_activities(self):
        acts = len(models.Activity.objects.all())
        self.assertEqual(9, acts)

    def test_update_activity_correct_auth(self):
        stmt = json.dumps({"verb": {"id":"verb:verb/url/changed-act"},"actor":{"objectType":"Agent", "mbox":"mailto:l@l.com"},
            "object": {"objectType": "Activity", "id":"act:foogie",
            "definition": {"name": {"en-US":"testname3"},"description": {"en-US":"testdesc3"},
            "type": "http://adlnet.gov/expapi/activities/cmi.interaction","interactionType": "fill-in","correctResponsesPattern": ["answer"],
            "extensions": {"ext:key1": "value1", "ext:key2": "value2","ext:key3": "value3"}}}, 
            "result": {"score":{"scaled":.85}, "completion": True, "success": True, "response": "kicked",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:key1": "value1", "ext:key2":"value2"}},
            "context":{"registration": self.cguid8, "contextActivities": {"other": {"id": "act:NewActivityID2"}},
            "revision": "food", "platform":"bard","language": "en-US", "extensions":{"ext:ckey1": "cval1",
            "ext:ckey2": "cval2"}}})

        post_response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
             X_Experience_API_Version="1.0.0")
        
        act = models.Activity.objects.get(activity_id="act:foogie")

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[1], "en-US")
        self.assertEqual(name_set.values()[1], "testname3")
        self.assertEqual(name_set.keys()[0], "en-GB")
        self.assertEqual(name_set.values()[0], "altname")

        self.assertEqual(desc_set.keys()[1], "en-US")
        self.assertEqual(desc_set.values()[1], "testdesc3")
        self.assertEqual(desc_set.keys()[0], "en-GB")
        self.assertEqual(desc_set.values()[0], "altdesc")

    def test_cors_post_put(self):
        st_id = str(uuid.uuid1())
        content = {"verb":{"id":"verb:verb/url"}, "actor":{"objectType":"Agent", "mbox": "mailto:r@r.com"},
            "object": {"id":"act:test_cors_post_put"}}
        
        bdy = "statementId=%s&content=%s&Content-Type=application/json&X-Experience-API-Version=1.0.0" % (st_id, content)
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode({"method":"PUT"}))
        response = self.client.post(path, bdy, content_type="application/x-www-form-urlencoded")
        self.assertEqual(response.status_code, 204)

        act = models.Activity.objects.get(activity_id="act:test_cors_post_put")
        self.assertEqual(act.activity_id, "act:test_cors_post_put")

    def test_issue_put(self):
        stmt_id = "33f60b35-e1b2-4ddc-9c6f-7b3f65244430" 
        stmt = json.dumps({"verb":{"id":"verb:verb/uri"},"object":{"id":"act:scorm.com/JsTetris_TCAPI","definition":{"type":"type:media",
            "name":{"en-US":"Js Tetris - Tin Can Prototype"},"description":{"en-US":"A game of tetris."}}},
            "context":{"contextActivities":{"grouping":{"id":"act:scorm.com/JsTetris_TCAPI"}},
            "registration":"6b1091be-2833-4886-b4a6-59e5e0b3c3f4"},
            "actor":{"mbox":"mailto:tom.creighton.ctr@adlnet.gov","name":"Tom Creighton"}})

        path = "%s?%s" % (reverse(views.statements), urllib.urlencode({"statementId":stmt_id}))
        put_stmt = self.client.put(path, stmt, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(put_stmt.status_code, 204) 

    def test_post_with_group(self):
        ot = "Group"
        name = "the group ST"
        mbox = "mailto:the.groupST@example.com"

        stmt = json.dumps({"actor":{"objectType":ot, "name":name, "mbox":mbox,"member":[{"name":"agentA","mbox":"mailto:agentA@example.com"},
            {"name":"agentB","mbox":"mailto:agentB@example.com"}]},"verb":{"id": "http://verb/uri/created", "display":{"en-US":"created"}},
            "object": {"id":"act:i.pity.the.fool"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)
        g = models.Agent.objects.get(mbox="mailto:the.groupST@example.com")
        self.assertEquals(g.name, name)
        self.assertEquals(g.mbox, mbox)
        mems = g.member.values_list("name", flat=True)
        self.assertEquals(len(mems), 2)
        self.assertIn("agentA", mems)
        self.assertIn("agentB", mems)


    def test_issue_put_no_version_header(self):
        stmt_id = '33f60b35-e1b2-4ddc-9c6f-7b3f65244431'
        stmt = json.dumps({"verb":"verb:completed","object":{"id":"act:scorm.com/JsTetris_TCAPI/level2",
            "definition":{"type":"media","name":{"en-US":"Js Tetris Level2"},
            "description":{"en-US":"Starting at 1, the higher the level, the harder the game."}}},
            "result":{"extensions":{"ext:time":104,"ext:apm":229,"ext:lines":5},"score":{"raw":9911,"min":0}},
            "context":{"contextActivities":{"grouping":{"id":"act:scorm.com/JsTetris_TCAPI"}},
            "registration":"b7be7d9d-bfe2-4917-8ccd-41a0d18dd953"},
            "actor":{"name":"tom creighton","mbox":"mailto:tom@example.com"}})

        path = '%s?%s' % (reverse(views.statements), urllib.urlencode({"statementId":stmt_id}))
        put_stmt = self.client.put(path, stmt, content_type="application/json", )
        self.assertEqual(put_stmt.status_code, 400)

    def test_issue_put_wrong_version_header(self):
        stmt_id = '33f60b35-e1b2-4ddc-9c6f-7b3f65244432'
        stmt = json.dumps({"verb":"verb:completed","object":{"id":"act:scorm.com/JsTetris_TCAPI/level2",
            "definition":{"type":"media","name":{"en-US":"Js Tetris Level2"},
            "description":{"en-US":"Starting at 1, the higher the level, the harder the game."}}},
            "result":{"extensions":{"ext:time":104,"ext:apm":229,"ext:lines":5},"score":{"raw":9911,"min":0}},
            "context":{"contextActivities":{"grouping":{"id":"act:scorm.com/JsTetris_TCAPI"}},
            "registration":"b7be7d9d-bfe2-4917-8ccd-41a0d18dd953"},
            "actor":{"name":"tom creighton","mbox":"mailto:tom@example.com"}})

        path = '%s?%s' % (reverse(views.statements), urllib.urlencode({"statementId":stmt_id}))
        put_stmt = self.client.put(path, stmt, content_type="application/json",  X_Experience_API_Version="0.90")
        self.assertEqual(put_stmt.status_code, 400)


    # Use this test to make sure stmts are being returned correctly with all data - doesn't check timestamp and stored fields
    def test_all_fields_activity_as_object(self):
        nested_st_id = str(uuid.uuid1())
        nest_param = {"statementId":nested_st_id}
        nest_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(nest_param))
        nested_stmt = json.dumps({"actor":{"objectType":"Agent","mbox": "mailto:tincan@adlnet.gov"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/assess","display": {"en-US":"assessed"}},
            "object":{"id":"http://example.adlnet.gov/tincan/example/simplestatement"}})
        put_sub_stmt = self.client.put(nest_path, nested_stmt, content_type="application/json", X_Experience_API_Version="1.0.0")
        self.assertEqual(put_sub_stmt.status_code, 204)        

        stmt_id = str(uuid.uuid1())
        context_id= str(uuid.uuid1())
        param = {"statementId":stmt_id} 
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt = json.dumps({"actor":{"objectType":"Agent","name": "Lou Wolford","account":{"homePage":"http://example.com", "name":"uniqueName"}},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/created","display": {"en-US":"created", "en-GB":"made"}},
            "object": {"objectType": "Activity", "id":"http:adlnet.gov/my/Activity/URL",
            "definition": {"name": {"en-US":"actName", "en-GB": "anotherActName"},
            "description": {"en-US":"This is my activity description.", "en-GB": "This is another activity description."},
            "type": "http://www.adlnet.gov/experienceapi/activity-types/http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "choice",
            "correctResponsesPattern": ["golf", "tetris"],
            "choices":[{"id": "golf", "description": {"en-US":"Golf Example", "en-GB": "GOLF"}},
            {"id": "tetris","description":{"en-US": "Tetris Example", "en-GB": "TETRIS"}},
            {"id":"facebook", "description":{"en-US":"Facebook App", "en-GB": "FACEBOOK"}},
            {"id":"scrabble", "description": {"en-US": "Scrabble Example", "en-GB": "SCRABBLE"}}],
            "extensions": {"ext:key1": "value1", "ext:key2": "value2","ext:key3": "value3"}}}, 
            "result": {"score":{"scaled":.85, "raw": 85, "min":0, "max":100}, "completion": True, "success": True, "response": "Well done",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:resultKey1": "resultValue1", "ext:resultKey2":"resultValue2"}},
            "context":{"registration": context_id, "contextActivities": {"other": {"id": "http://example.adlnet.gov/tincan/example/test"},
            "grouping":{"id":"http://groupingID"} },
            "revision": "Spelling error in choices.", "platform":"Platform is web browser.","language": "en-US",
            "statement":{"objectType":"StatementRef", "id":str(nested_st_id)},
            "extensions":{"ext:contextKey1": "contextVal1","ext:contextKey2": "contextVal2"}},
            "timestamp":self.firstTime})

        put_stmt = self.client.put(path, stmt, content_type="application/json", X_Experience_API_Version="1.0.0")
        self.assertEqual(put_stmt.status_code, 204)
        param = {"statementId":stmt_id}
        get_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        get_response = self.client.get(path, X_Experience_API_Version="1.0.0")
        
        the_returned = json.loads(get_response.content)
        self.assertEqual(the_returned['id'], stmt_id)
        self.assertEqual(the_returned['actor']['objectType'], 'Agent')
        self.assertEqual(the_returned['actor']['name'], 'Lou Wolford')
        self.assertEqual(the_returned['actor']['account']['name'], 'uniqueName')
        self.assertEqual(the_returned['actor']['account']['homePage'], 'http://example.com')

        self.assertEqual(the_returned['verb']['id'], 'http://adlnet.gov/expapi/verbs/created')
        self.assertEqual(the_returned['verb']['display']['en-GB'], 'made')
        self.assertEqual(the_returned['verb']['display']['en-US'], 'created')

        self.assertEqual(the_returned['result']['completion'], True)
        self.assertEqual(the_returned['result']['duration'], 'P3Y6M4DT12H30M5S')
        self.assertEqual(the_returned['result']['extensions']['ext:resultKey1'], 'resultValue1')
        self.assertEqual(the_returned['result']['extensions']['ext:resultKey2'], 'resultValue2')
        self.assertEqual(the_returned['result']['response'], 'Well done')
        self.assertEqual(the_returned['result']['score']['max'], 100)
        self.assertEqual(the_returned['result']['score']['min'], 0)
        self.assertEqual(the_returned['result']['score']['raw'], 85)
        self.assertEqual(the_returned['result']['score']['scaled'], 0.85)
        self.assertEqual(the_returned['result']['success'], True)

        self.assertEqual(the_returned['context']['contextActivities']['other'][0]['id'], 'http://example.adlnet.gov/tincan/example/test')
        self.assertEqual(the_returned['context']['extensions']['ext:contextKey1'], 'contextVal1')
        self.assertEqual(the_returned['context']['extensions']['ext:contextKey2'], 'contextVal2')
        self.assertEqual(the_returned['context']['language'], 'en-US')
        self.assertEqual(the_returned['context']['platform'], 'Platform is web browser.')
        self.assertEqual(the_returned['context']['registration'], context_id)
        self.assertEqual(the_returned['context']['revision'], 'Spelling error in choices.')
        self.assertEqual(the_returned['context']['statement']['id'], str(nested_st_id))
        self.assertEqual(the_returned['context']['statement']['objectType'], 'StatementRef')

    # Use this test to make sure stmts are being returned correctly with all data - doesn't check timestamp, stored fields
    def test_all_fields_agent_as_object(self):
        nested_st_id = str(uuid.uuid1())
        nest_param = {"statementId":nested_st_id}
        nest_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(nest_param))
        nested_stmt = json.dumps({"actor":{"objectType":"Agent","mbox": "mailto:tincan@adlnet.gov"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/assess","display": {"en-US":"assessed"}},
            "object":{"id":"http://example.adlnet.gov/tincan/example/simplestatement"}})
        put_sub_stmt = self.client.put(nest_path, nested_stmt, content_type="application/json", X_Experience_API_Version="1.0.0")
        self.assertEqual(put_sub_stmt.status_code, 204)        


        stmt_id = str(uuid.uuid1())
        context_id= str(uuid.uuid1())
        param = {"statementId":stmt_id} 
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        msha = hashlib.sha1("tom@example.com").hexdigest()                
        stmt = json.dumps({"actor":{"objectType":"Agent","name": "Lou Wolford","account":{"homePage":"http://example.com", "name":"louUniqueName"}},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/helped","display": {"en-US":"helped", "en-GB":"assisted"}},
            "object": {"objectType":"Agent","name": "Tom Creighton","mbox_sha1sum":msha}, 
            "result": {"score":{"scaled":.85, "raw": 85, "min":0, "max":100}, "completion": True, "success": True, "response": "Well done",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:resultKey1": "resultValue1", "ext:resultKey2":"resultValue2"}},
            "context":{"registration": context_id, "contextActivities": {"other": {"id": "http://example.adlnet.gov/tincan/example/test"}},
            "language": "en-US",
            "statement":{"objectType":"StatementRef", "id":str(nested_st_id)},
            "extensions":{"ext:contextKey1": "contextVal1","ext:contextKey2": "contextVal2"}},
            "timestamp":self.firstTime})
        
        put_stmt = self.client.put(path, stmt, content_type="application/json", X_Experience_API_Version="1.0.0")
        self.assertEqual(put_stmt.status_code, 204)
        param = {"statementId":stmt_id}
        get_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        get_response = self.client.get(path, X_Experience_API_Version="1.0.0")
        
        the_returned = json.loads(get_response.content)
        self.assertEqual(the_returned['id'], stmt_id)
        self.assertEqual(the_returned['actor']['objectType'], 'Agent')
        self.assertEqual(the_returned['actor']['name'], 'Lou Wolford')
        self.assertEqual(the_returned['actor']['account']['name'], 'louUniqueName')
        self.assertEqual(the_returned['actor']['account']['homePage'], 'http://example.com')

        self.assertEqual(the_returned['verb']['id'], 'http://adlnet.gov/expapi/verbs/helped')
        self.assertEqual(the_returned['verb']['display']['en-GB'], 'assisted')
        self.assertEqual(the_returned['verb']['display']['en-US'], 'helped')

        self.assertEqual(the_returned['result']['completion'], True)
        self.assertEqual(the_returned['result']['duration'], 'P3Y6M4DT12H30M5S')
        self.assertEqual(the_returned['result']['extensions']['ext:resultKey1'], 'resultValue1')
        self.assertEqual(the_returned['result']['extensions']['ext:resultKey2'], 'resultValue2')
        self.assertEqual(the_returned['result']['response'], 'Well done')
        self.assertEqual(the_returned['result']['score']['max'], 100)
        self.assertEqual(the_returned['result']['score']['min'], 0)
        self.assertEqual(the_returned['result']['score']['raw'], 85)
        self.assertEqual(the_returned['result']['score']['scaled'], 0.85)
        self.assertEqual(the_returned['result']['success'], True)

        self.assertEqual(the_returned['context']['contextActivities']['other'][0]['id'], 'http://example.adlnet.gov/tincan/example/test')
        self.assertEqual(the_returned['context']['extensions']['ext:contextKey1'], 'contextVal1')
        self.assertEqual(the_returned['context']['extensions']['ext:contextKey2'], 'contextVal2')
        self.assertEqual(the_returned['context']['language'], 'en-US')
        self.assertEqual(the_returned['context']['registration'], context_id)
        self.assertEqual(the_returned['context']['statement']['id'], str(nested_st_id))
        self.assertEqual(the_returned['context']['statement']['objectType'], 'StatementRef')
        self.assertEqual(the_returned['object']['objectType'], 'Agent')
        self.assertEqual(the_returned['object']['name'], 'Tom Creighton')
        self.assertEqual(the_returned['object']['mbox_sha1sum'], 'edb97c2848fc47bdd2091028de8a3b1b24933752')

    # Use this test to make sure stmts are being returned correctly with all data - doesn't check timestamps or stored fields
    def test_all_fields_substatement_as_object(self):
        nested_st_id = str(uuid.uuid1())
        nest_param = {"statementId":nested_st_id}
        nest_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(nest_param))
        nested_stmt = json.dumps({"actor":{"objectType":"Agent","mbox": "mailto:tincannest@adlnet.gov"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/assess","display": {"en-US":"assessed", "en-GB":"graded"}},
            "object":{"id":"http://example.adlnet.gov/tincan/example/simplestatement"}})
        put_sub_stmt = self.client.put(nest_path, nested_stmt, content_type="application/json", X_Experience_API_Version="1.0.0")
        self.assertEqual(put_sub_stmt.status_code, 204)        


        nested_sub_st_id = str(uuid.uuid1())
        nest_sub_param = {"statementId":nested_sub_st_id}
        nest_sub_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(nest_sub_param))        
        nested_sub_stmt = json.dumps({"actor":{"objectType":"Agent","mbox": "mailto:tincannestsub@adlnet.gov"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/verb","display": {"en-US":"verb", "en-GB":"altVerb"}},
            "object":{"id":"http://example.adlnet.gov/tincan/example/simplenestedsubstatement"}})
        put_nest_sub_stmt = self.client.put(nest_sub_path, nested_sub_stmt, content_type="application/json", X_Experience_API_Version="1.0.0")
        self.assertEqual(put_nest_sub_stmt.status_code, 204)


        stmt_id = str(uuid.uuid1())
        context_id= str(uuid.uuid1())
        sub_context_id= str(uuid.uuid1())        
        param = {"statementId":stmt_id} 
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        msha = hashlib.sha1("tom@example.com").hexdigest()        
        
        stmt = json.dumps({"actor":{"objectType":"Agent","name": "Lou Wolford","account":{"homePage":"http://example.com", "name":"louUniqueName"}},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/said","display": {"en-US":"said", "en-GB":"talked"}},
            "object": {"objectType": "SubStatement", "actor":{"objectType":"Agent","name":"Tom Creighton","mbox": "mailto:tom@adlnet.gov"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/assess","display": {"en-US":"assessed", "en-GB": "Graded"}},
            "object":{"id":"http://example.adlnet.gov/tincan/example/simplestatement",
            'definition': {'name': {'en-US':'SubStatement name'},
            'description': {'en-US':'SubStatement description'},
            'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'matching',
            'correctResponsesPattern': ['lou.3,tom.2,andy.1'],'source':[{'id': 'lou',
            'description': {'en-US':'Lou', 'it': 'Luigi'}},{'id': 'tom','description':{'en-US': 'Tom', 'it':'Tim'}},
            {'id':'andy', 'description':{'en-US':'Andy'}}],'target':[{'id':'1',
            'description':{'en-US': 'ADL LRS'}},{'id':'2','description':{'en-US': 'lrs'}},
            {'id':'3', 'description':{'en-US': 'the adl lrs', 'en-CH': 'the lrs'}}]}},
            "result": {"score":{"scaled":.50, "raw": 50, "min":1, "max":51}, "completion": True,
            "success": True, "response": "Poorly done",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:resultKey11": "resultValue11", "ext:resultKey22":"resultValue22"}},
            "context":{"registration": sub_context_id,
            "contextActivities": {"other": {"id": "http://example.adlnet.gov/tincan/example/test/nest"}},
            "revision": "Spelling error in target.", "platform":"Ipad.","language": "en-US",
            "statement":{"objectType":"StatementRef", "id":str(nested_sub_st_id)},
            "extensions":{"ext:contextKey11": "contextVal11","ext:contextKey22": "contextVal22"}}}, 
            "result": {"score":{"scaled":.85, "raw": 85, "min":0, "max":100}, "completion": True, "success": True, "response": "Well done",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:resultKey1": "resultValue1", "ext:resultKey2":"resultValue2"}},
            "context":{"registration": context_id, "contextActivities": {"other": {"id": "http://example.adlnet.gov/tincan/example/test"}},
            "revision": "Spelling error in choices.", "platform":"Platform is web browser.","language": "en-US",
            "statement":{"objectType":"StatementRef", "id":str(nested_st_id)},
            "extensions":{"ext:contextKey1": "contextVal1","ext:contextKey2": "contextVal2"}},
            "timestamp":self.firstTime})
        put_stmt = self.client.put(path, stmt, content_type="application/json", X_Experience_API_Version="1.0.0")
        self.assertEqual(put_stmt.status_code, 204)
        param = {"statementId":stmt_id}
        get_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        get_response = self.client.get(path, X_Experience_API_Version="1.0.0")
        
        the_returned = json.loads(get_response.content)
        self.assertEqual(the_returned['id'], stmt_id)
        self.assertEqual(the_returned['actor']['objectType'], 'Agent')
        self.assertEqual(the_returned['actor']['name'], 'Lou Wolford')
        self.assertEqual(the_returned['actor']['account']['name'], 'louUniqueName')
        self.assertEqual(the_returned['actor']['account']['homePage'], 'http://example.com')

        self.assertEqual(the_returned['verb']['id'], 'http://adlnet.gov/expapi/verbs/said')
        self.assertEqual(the_returned['verb']['display']['en-GB'], 'talked')
        self.assertEqual(the_returned['verb']['display']['en-US'], 'said')
        
        self.assertEqual(the_returned['object']['actor']['objectType'], 'Agent')
        self.assertEqual(the_returned['object']['actor']['name'], 'Tom Creighton')
        self.assertEqual(the_returned['object']['actor']['mbox'], 'mailto:tom@adlnet.gov')
        
        self.assertEqual(the_returned['object']['context']['registration'], sub_context_id)
        self.assertEqual(the_returned['object']['context']['language'], 'en-US')
        self.assertEqual(the_returned['object']['context']['platform'], 'Ipad.')
        self.assertEqual(the_returned['object']['context']['revision'], 'Spelling error in target.')
        self.assertEqual(the_returned['object']['context']['statement']['id'], str(nested_sub_st_id))
        self.assertEqual(the_returned['object']['context']['statement']['objectType'], 'StatementRef')
        self.assertEqual(the_returned['object']['context']['contextActivities']['other'][0]['id'], 'http://example.adlnet.gov/tincan/example/test/nest')
        self.assertEqual(the_returned['object']['context']['extensions']['ext:contextKey11'], 'contextVal11')
        self.assertEqual(the_returned['object']['context']['extensions']['ext:contextKey22'], 'contextVal22')
        self.assertEqual(the_returned['object']['object']['id'], 'http://example.adlnet.gov/tincan/example/simplestatement')
        self.assertEqual(the_returned['object']['object']['definition']['type'], 'http://adlnet.gov/expapi/activities/cmi.interaction')
        self.assertEqual(the_returned['object']['object']['definition']['description']['en-US'], 'SubStatement description')
        self.assertEqual(the_returned['object']['object']['definition']['interactionType'], 'matching')
        self.assertEqual(the_returned['object']['object']['definition']['name']['en-US'], 'SubStatement name')
        # arrays.. testing slightly differently
        source_str = json.dumps(the_returned['object']['object']['definition']['source'])
        self.assertIn('description', source_str)
        self.assertIn('id', source_str)
        self.assertIn('Lou', source_str)
        self.assertIn('Luigi', source_str)
        self.assertIn('lou', source_str)
        self.assertIn('Tom', source_str)
        self.assertIn('Tim', source_str)
        self.assertIn('tom', source_str)
        self.assertIn('Andy', source_str)
        self.assertIn('andy', source_str)

        target_str = json.dumps(the_returned['object']['object']['definition']['target'])
        self.assertIn('description', target_str)
        self.assertIn('id', target_str)
        self.assertIn('ADL LRS', target_str)
        self.assertIn('1', target_str)
        self.assertIn('lrs', target_str)
        self.assertIn('2', target_str)
        self.assertIn('the lrs', target_str)
        self.assertIn('the adl lrs', target_str)
        self.assertIn('3', target_str)
        
        self.assertEqual(the_returned['object']['objectType'], 'SubStatement')

        self.assertEqual(the_returned['object']['result']['completion'], True)
        self.assertEqual(the_returned['object']['result']['duration'], 'P3Y6M4DT12H30M5S')
        self.assertEqual(the_returned['object']['result']['extensions']['ext:resultKey11'], 'resultValue11')
        self.assertEqual(the_returned['object']['result']['extensions']['ext:resultKey22'], 'resultValue22')
        self.assertEqual(the_returned['object']['result']['response'], 'Poorly done')
        self.assertEqual(the_returned['object']['result']['score']['max'], 51)
        self.assertEqual(the_returned['object']['result']['score']['min'], 1)
        self.assertEqual(the_returned['object']['result']['score']['raw'], 50)
        self.assertEqual(the_returned['object']['result']['score']['scaled'], 0.5)
        self.assertEqual(the_returned['object']['result']['success'], True)
        
        self.assertEqual(the_returned['object']['verb']['id'], 'http://adlnet.gov/expapi/verbs/assess')
        self.assertEqual(the_returned['object']['verb']['display']['en-GB'], 'Graded')
        self.assertEqual(the_returned['object']['verb']['display']['en-US'], 'assessed')

        self.assertEqual(the_returned['result']['completion'], True)
        self.assertEqual(the_returned['result']['duration'], 'P3Y6M4DT12H30M5S')
        self.assertEqual(the_returned['result']['extensions']['ext:resultKey1'], 'resultValue1')
        self.assertEqual(the_returned['result']['extensions']['ext:resultKey2'], 'resultValue2')
        self.assertEqual(the_returned['result']['response'], 'Well done')
        self.assertEqual(the_returned['result']['score']['max'], 100)
        self.assertEqual(the_returned['result']['score']['min'], 0)
        self.assertEqual(the_returned['result']['score']['raw'], 85)
        self.assertEqual(the_returned['result']['score']['scaled'], 0.85)
        self.assertEqual(the_returned['result']['success'], True)

        self.assertEqual(the_returned['context']['contextActivities']['other'][0]['id'], 'http://example.adlnet.gov/tincan/example/test')
        self.assertEqual(the_returned['context']['extensions']['ext:contextKey1'], 'contextVal1')
        self.assertEqual(the_returned['context']['extensions']['ext:contextKey2'], 'contextVal2')
        self.assertEqual(the_returned['context']['language'], 'en-US')
        self.assertEqual(the_returned['context']['platform'], 'Platform is web browser.')
        self.assertEqual(the_returned['context']['registration'], context_id)
        self.assertEqual(the_returned['context']['revision'], 'Spelling error in choices.')
        self.assertEqual(the_returned['context']['statement']['id'], nested_st_id)
        self.assertEqual(the_returned['context']['statement']['objectType'], 'StatementRef')
    # Third stmt in list is missing actor - should throw error and perform cascading delete on first three statements
    def test_post_list_rollback(self):
        cguid1 = str(uuid.uuid1())

        stmts = json.dumps([{"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-failed","display": {"en-US":"wrong-failed"}},"object": {"id":"act:test_wrong_list_post2"},
            "actor":{"objectType":"Agent", "mbox":"mailto:wrong-t@t.com"},"result": {"score":{"scaled":.99}, "completion": True, "success": True, "response": "wrong",
            "extensions":{"ext:resultwrongkey1": "value1", "ext:resultwrongkey2":"value2"}}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-kicked","display": {"en-US":"wrong-kicked"}},
            "object": {"objectType": "Activity", "id":"act:test_wrong_list_post",
            "definition": {"name": {"en-US":"wrongactName", "en-GB": "anotherActName"},
            "description": {"en-US":"This is my activity description.", "en-GB": "This is another activity description."},
            "type": "http://adlnet.gov/expapi/activities/http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "choice",
            "correctResponsesPattern": ["wronggolf", "wrongtetris"],
            "choices":[{"id": "wronggolf", "description": {"en-US":"Golf Example", "en-GB": "GOLF"}},
            {"id": "wrongtetris","description":{"en-US": "Tetris Example", "en-GB": "TETRIS"}},
            {"id":"wrongfacebook", "description":{"en-US":"Facebook App", "en-GB": "FACEBOOK"}},
            {"id":"wrongscrabble", "description": {"en-US": "Scrabble Example", "en-GB": "SCRABBLE"}}],
            "extensions": {"ext:wrongkey1": "wrongvalue1", "ext:wrongkey2": "wrongvalue2","ext:wrongkey3": "wrongvalue3"}}},
            "actor":{"objectType":"Agent", "mbox":"mailto:wrong-t@t.com"}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-passed","display": {"en-US":"wrong-passed"}},"object": {"id":"act:test_wrong_list_post1"},
            "actor":{"objectType":"Agent", "mbox":"mailto:wrong-t@t.com"},"context":{"registration": cguid1, "contextActivities": {"other": {"id": "act:wrongActivityID2"}},
            "revision": "wrong", "platform":"wrong","language": "en-US", "extensions":{"ext:wrongkey1": "wrongval1",
            "ext:wrongkey2": "wrongval2"}}},            
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-kicked","display": {"en-US":"wrong-kicked"}},"object": {"id":"act:test_wrong_list_post2"}},            
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-kicked","display": {"en-US":"wrong-kicked"}},"object": {"id":"act:test_wrong_list_post4"}, "actor":{"objectType":"Agent", "mbox":"wrong-t@t.com"}}])
        
        response = self.client.post(reverse(views.statements), stmts,  content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('actor is missing in Statement', response.content)
        
        verbs = models.Verb.objects.filter(verb_id__contains='wrong')
        
        activities = models.Activity.objects.filter(activity_id__contains='test_wrong_list_post')

        statements = models.Statement.objects.all()

        # 11 statements from setup
        self.assertEqual(len(statements), 11)

        self.assertEqual(len(verbs), 0)
        self.assertEqual(len(activities), 0)

    def test_post_list_rollback_part_2(self):
        stmts = json.dumps([{"object": {"objectType":"Agent","name":"john","mbox":"mailto:john@john.com"},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/wrong","display": {"wrong-en-US":"wrong"}},
            "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/created"},
            "object": {"objectType": "Activity", "id":"act:foogie",
            "definition": {"name": {"en-US":"testname2", "en-GB": "altname"},
            "description": {"en-US":"testdesc2", "en-GB": "altdesc"}, "type": "http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "fill-in","correctResponsesPattern": ["answer"]}},
            "actor":{"objectType":"Agent", "mbox":"mailto:wrong-t@t.com"}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-kicked"},"object": {"id":"act:test_wrong_list_post2"}}])

        response = self.client.post(reverse(views.statements), stmts,  content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('actor is missing in Statement', response.content)
        created_verbs = models.Verb.objects.filter(verb_id__contains='http://adlnet.gov/expapi/verbs/created')
        wrong_verbs = models.Verb.objects.filter(verb_id__contains='http://adlnet.gov/expapi/verbs/wrong')
        
        activities = models.Activity.objects.filter(activity_id='act:foogie')
        
        statements = models.Statement.objects.all()

        wrong_agent = models.Agent.objects.filter(mbox='mailto:wrong-t@t.com')
        john_agent = models.Agent.objects.filter(mbox='mailto:john@john.com')
        s_agent = models.Agent.objects.filter(mbox='mailto:s@s.com')
        auth_agent = models.Agent.objects.filter(mbox='mailto:test1@tester.com')

        self.assertEqual(len(created_verbs), 1)
        # Both verbs from the first and last stmts in the list would still be there
        self.assertEqual(len(wrong_verbs), 0)

        self.assertEqual(len(activities), 1)
        
        self.assertEqual(len(statements), 11)

        self.assertEqual(len(wrong_agent), 0)
        self.assertEqual(len(john_agent), 1)
        self.assertEqual(len(s_agent), 1)

    def test_post_list_rollback_with_void(self):
        stmts = json.dumps([{"actor":{"objectType":"Agent","mbox":"mailto:only-s@s.com"},
            "object": {"objectType":"StatementRef","id":str(self.exist_stmt_id)},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/voided","display": {"en-US":"voided"}}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-kicked"},"object": {"id":"act:test_wrong_list_post2"}}])

        response = self.client.post(reverse(views.statements), stmts,  content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('actor is missing in Statement', response.content)

        voided_st = models.Statement.objects.get(statement_id=str(self.exist_stmt_id))
        voided_verb = models.Verb.objects.filter(verb_id__contains='voided')
        only_actor = models.Agent.objects.filter(mbox="mailto:only-s@s.com")
        statements = models.Statement.objects.all()

        self.assertEqual(len(statements), 11)
        self.assertEqual(voided_st.voided, False)
        self.assertEqual(len(voided_verb), 0)
        self.assertEqual(len(only_actor), 0)

    def test_post_list_rollback_with_subs(self):
        sub_context_id = str(uuid.uuid1())
        stmts = json.dumps([{"actor":{"objectType":"Agent","mbox":"mailto:wrong-s@s.com"},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/wrong","display": {"wrong-en-US":"wrong"}},
            "object": {"objectType":"Agent","name":"john","mbox":"mailto:john@john.com"}},
            {"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/wrong-next","display": {"wrong-en-US":"wrong-next"}},
            "object":{"objectType":"SubStatement",
            "actor":{"objectType":"Agent","mbox":"mailto:wrong-ss@ss.com"},"verb": {"id":"http://adlnet.gov/expapi/verbs/wrong-sub"},
            "object": {"objectType":"Activity", "id":"act:wrong-testex.com"}, "result":{"completion": True, "success": True,
            "response": "sub-wrong-kicked"}, "context":{"registration": sub_context_id,
            "contextActivities": {"other": {"id": "act:sub-wrong-ActivityID"}},"revision": "foo", "platform":"bar",
            "language": "en-US", "extensions":{"ext:wrong-k1": "v1", "ext:wrong-k2": "v2"}}}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-kicked"},"object": {"id":"act:test_wrong_list_post2"}}])

        response = self.client.post(reverse(views.statements), stmts,  content_type="application/json",  X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('actor is missing in Statement', response.content)

        s_agent = models.Agent.objects.filter(mbox="mailto:wrong-s@s.com")
        ss_agent = models.Agent.objects.filter(mbox="mailto:wrong-ss@ss.com")
        john_agent  = models.Agent.objects.filter(mbox="mailto:john@john.com")
        subs = models.SubStatement.objects.all()
        wrong_verb = models.Verb.objects.filter(verb_id__contains="wrong")
        activities = models.Activity.objects.filter(activity_id__contains="wrong")
        statements = models.Statement.objects.all()

        self.assertEqual(len(statements), 11)
        self.assertEqual(len(s_agent), 0)
        self.assertEqual(len(ss_agent), 0)
        self.assertEqual(len(john_agent), 1)
        # Only 1 sub from setup
        self.assertEqual(len(subs), 1)
        self.assertEqual(len(wrong_verb), 0)
        self.assertEqual(len(activities), 0)

########NEW FILE########
__FILENAME__ = OAuthTests
from django.test import TestCase
from django.core.urlresolvers import reverse
from lrs import views, models
from oauth_provider.oauth.oauth import OAuthRequest, OAuthSignatureMethod_HMAC_SHA1
from django.test.utils import setup_test_environment
from django.contrib.auth.models import User
from lrs.objects.StatementManager import StatementManager
import time
from django.conf import settings
import uuid
import json
import urllib
import ast
import os
import hashlib
import base64
import re

class OAuthTests(TestCase):
    @classmethod
    def setUpClass(cls):
        print "\n%s" % __name__

    def setUp(self):
        if not settings.OAUTH_ENABLED:
            settings.OAUTH_ENABLED = True

        # Create a user
        self.user = User.objects.create_user('jane', 'jane@example.com', 'toto')
        user = self.client.login(username='jane', password='toto')

        #Register a client
        self.name = "test client"
        self.desc = "test desc"
        form = {"name":self.name, "description":self.desc, "scopes":"all"}
        response = self.client.post(reverse(views.reg_client),form, X_Experience_API_Version="1.0.0")
        self.consumer = models.Consumer.objects.get(name=self.name)
        self.client.logout()

        # Create a user
        self.user2 = User.objects.create_user('dick', 'dick@example.com', 'lassie')
        user2 = self.client.login(username='dick', password='lassie')

        #Register a client
        self.name2 = "test client2"
        self.desc2 = "test desc2"
        form2 = {"name":self.name2, "description":self.desc2, "scopes":"all"}
        response2 = self.client.post(reverse(views.reg_client),form2, X_Experience_API_Version="1.0.0")
        self.consumer2 = models.Consumer.objects.get(name=self.name2)
        self.client.logout()
    
    
    def perform_oauth_handshake(self, scope=True, scope_type=None, request_nonce=None,
        access_nonce=None, resource_nonce=None):
        # TEST REQUEST TOKEN
        oauth_header_request_params = "OAuth realm=\"test\","\
               "oauth_consumer_key=\"%s\","\
               "oauth_signature_method=\"PLAINTEXT\","\
               "oauth_signature=\"%s&\","\
               "oauth_timestamp=\"%s\","\
               "oauth_nonce=\"requestnonce\","\
               "oauth_version=\"1.0\","\
               "oauth_callback=\"http://example.com/request_token_ready\"" % (self.consumer.key,self.consumer.secret,str(int(time.time())))
        
        if scope:
            if scope_type:
                # Test sending in scope as query param with REQUEST_TOKEN
                param = {
                            "scope":scope_type
                        }
            else:
                # Test sending in scope as query param with REQUEST_TOKEN
                param = {
                            "scope":"all"
                        }
            path = "%s?%s" % ("/XAPI/OAuth/initiate", urllib.urlencode(param))                  
        else:
            path = "/XAPI/OAuth/initiate"

        request_resp = self.client.get(path, Authorization=oauth_header_request_params, X_Experience_API_Version="1.0.0")        

        self.assertEqual(request_resp.status_code, 200)
        self.assertIn('oauth_token_secret=', request_resp.content)
        self.assertIn('oauth_token=', request_resp.content)
        self.assertIn('&oauth_callback_confirmed=true', request_resp.content)
        token = models.Token.objects.get(consumer=self.consumer)
        self.assertIn(token.key, request_resp.content)
        self.assertIn(token.secret, request_resp.content)
        self.assertEqual(token.callback, 'http://example.com/request_token_ready')
        self.assertEqual(token.callback_confirmed, True)

        # Test AUTHORIZE
        oauth_auth_params = {'oauth_token': token.key}
        auth_resp = self.client.get("/XAPI/OAuth/authorize", oauth_auth_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(auth_resp.status_code, 302)
        self.assertIn('http://testserver/XAPI/accounts/login?next=/XAPI/OAuth/authorize%3F', auth_resp['Location'])
        self.assertIn(token.key, auth_resp['Location'])    
        self.client.login(username='jane', password='toto')
        self.assertEqual(token.is_approved, False)
        auth_resp = self.client.get("/XAPI/OAuth/authorize/", oauth_auth_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(auth_resp.status_code, 200) # Show return/display OAuth authorized view
        
        html = auth_resp.content
        cap = re.search('name="obj_id"\Wvalue="(.*?)"', html)
        oauth_auth_params['obj_id'] = cap.group(1)

        caps = re.findall('checked="checked".*?value="(.*?)"', html)
        oauth_auth_params['scopes'] = [c for c in caps]

        oauth_auth_params['authorize_access'] = 1
        auth_post = self.client.post("/XAPI/OAuth/authorize/", oauth_auth_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(auth_post.status_code, 302)
        self.assertIn('http://example.com/request_token_ready?oauth_verifier=', auth_post['Location'])
        token = models.Token.objects.get(consumer=self.consumer)
        self.assertIn(token.key, auth_post['Location'])
        self.assertEqual(token.is_approved, True)


        # Test ACCESS TOKEN
        oauth_header_access_params = "OAuth realm=\"test\","\
            "oauth_consumer_key=\"%s\","\
            "oauth_token=\"%s\","\
            "oauth_signature_method=\"PLAINTEXT\","\
            "oauth_signature=\"%s&%s\","\
            "oauth_timestamp=\"%s\","\
            "oauth_nonce=\"accessnonce\","\
            "oauth_version=\"1.0\","\
            "oauth_verifier=\"%s\"" % (self.consumer.key,token.key,self.consumer.secret,token.secret,str(int(time.time())),token.verifier)

        access_resp = self.client.get("/XAPI/OAuth/token/", Authorization=oauth_header_access_params,
            X_Experience_API_Version="1.0.0")

        self.assertEqual(access_resp.status_code, 200)
        access_token = models.Token.objects.filter(token_type=models.Token.ACCESS, consumer=self.consumer)[0]
        self.assertIn(access_token.key, access_resp.content)
        self.assertEqual(access_token.user.username, u'jane')

        # Test ACCESS RESOURCE
        oauth_header_resource_params = "OAuth realm=\"test\", "\
            "oauth_consumer_key=\"%s\","\
            "oauth_token=\"%s\","\
            "oauth_signature_method=\"HMAC-SHA1\","\
            "oauth_timestamp=\"%s\","\
            "oauth_nonce=\"accessresourcenonce\","\
            "oauth_version=\"1.0\"" % (self.consumer.key, access_token.key, str(int(time.time())))

        return oauth_header_resource_params, access_token

    def perform_oauth_handshake2(self, scope=True, scope_type=None, request_nonce=None,
        access_nonce=None, resource_nonce=None):
        # TEST REQUEST TOKEN
        oauth_header_request_params = "OAuth realm=\"test\","\
               "oauth_consumer_key=\"%s\","\
               "oauth_signature_method=\"PLAINTEXT\","\
               "oauth_signature=\"%s&\","\
               "oauth_timestamp=\"%s\","\
               "oauth_nonce=\"requestnonc2e\","\
               "oauth_version=\"1.0\","\
               "oauth_callback=\"http://example2.com/request_token_ready\"" % (self.consumer2.key,self.consumer2.secret,str(int(time.time())))
        
        if scope:
            if scope_type:
                # Test sending in scope as query param with REQUEST_TOKEN
                param = {
                            "scope":scope_type
                        }
            else:
                # Test sending in scope as query param with REQUEST_TOKEN
                param = {
                            "scope":"all"
                        }
            path = "%s?%s" % ("/XAPI/OAuth/initiate", urllib.urlencode(param))                  
        else:
            path = "/XAPI/OAuth/initiate"

        request_resp = self.client.get(path, Authorization=oauth_header_request_params, X_Experience_API_Version="1.0.0")        

        self.assertEqual(request_resp.status_code, 200)
        self.assertIn('oauth_token_secret=', request_resp.content)
        self.assertIn('oauth_token=', request_resp.content)
        self.assertIn('&oauth_callback_confirmed=true', request_resp.content)
        token = models.Token.objects.get(consumer=self.consumer2)
        self.assertIn(token.key, request_resp.content)
        self.assertIn(token.secret, request_resp.content)
        self.assertEqual(token.callback, 'http://example2.com/request_token_ready')
        self.assertEqual(token.callback_confirmed, True)

        # Test AUTHORIZE
        oauth_auth_params = {'oauth_token': token.key}
        auth_resp = self.client.get("/XAPI/OAuth/authorize", oauth_auth_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(auth_resp.status_code, 302)
        self.assertIn('http://testserver/XAPI/accounts/login?next=/XAPI/OAuth/authorize%3F', auth_resp['Location'])
        self.assertIn(token.key, auth_resp['Location'])    
        self.client.login(username='dick', password='lassie')
        self.assertEqual(token.is_approved, False)
        auth_resp = self.client.get("/XAPI/OAuth/authorize/", oauth_auth_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(auth_resp.status_code, 200) # Show return/display OAuth authorized view
        
        html = auth_resp.content
        cap = re.search('name="obj_id"\Wvalue="(.*?)"', html)
        oauth_auth_params['obj_id'] = cap.group(1)

        caps = re.findall('checked="checked".*?value="(.*?)"', html)
        oauth_auth_params['scopes'] = [c for c in caps]

        oauth_auth_params['authorize_access'] = 1
        auth_post = self.client.post("/XAPI/OAuth/authorize/", oauth_auth_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(auth_post.status_code, 302)
        self.assertIn('http://example2.com/request_token_ready?oauth_verifier=', auth_post['Location'])
        token = models.Token.objects.get(consumer=self.consumer2)
        self.assertIn(token.key, auth_post['Location'])
        self.assertEqual(token.is_approved, True)


        # Test ACCESS TOKEN
        oauth_header_access_params = "OAuth realm=\"test\","\
            "oauth_consumer_key=\"%s\","\
            "oauth_token=\"%s\","\
            "oauth_signature_method=\"PLAINTEXT\","\
            "oauth_signature=\"%s&%s\","\
            "oauth_timestamp=\"%s\","\
            "oauth_nonce=\"accessnonce2\","\
            "oauth_version=\"1.0\","\
            "oauth_verifier=\"%s\"" % (self.consumer2.key,token.key,self.consumer2.secret,token.secret,str(int(time.time())),token.verifier)

        access_resp = self.client.get("/XAPI/OAuth/token/", Authorization=oauth_header_access_params,
            X_Experience_API_Version="1.0.0")

        self.assertEqual(access_resp.status_code, 200)
        access_token = models.Token.objects.filter(token_type=models.Token.ACCESS, consumer=self.consumer2)[0]
        self.assertIn(access_token.key, access_resp.content)
        self.assertEqual(access_token.user.username, u'dick')

        # Test ACCESS RESOURCE
        oauth_header_resource_params = "OAuth realm=\"test\", "\
            "oauth_consumer_key=\"%s\","\
            "oauth_token=\"%s\","\
            "oauth_signature_method=\"HMAC-SHA1\","\
            "oauth_timestamp=\"%s\","\
            "oauth_nonce=\"accessresourcenonce2\","\
            "oauth_version=\"1.0\"" % (self.consumer2.key, access_token.key, str(int(time.time())))

        return oauth_header_resource_params, access_token



    def tearDown(self):
        if settings.OAUTH_ENABLED:
            settings.OAUTH_ENABLED = False
        # Delete everything
        models.Token.objects.all().delete()
        models.Consumer.objects.all().delete()
        models.Nonce.objects.all().delete()
        User.objects.all().delete()

        attach_folder_path = os.path.join(settings.MEDIA_ROOT, "activity_state")
        for the_file in os.listdir(attach_folder_path):
            file_path = os.path.join(attach_folder_path, the_file)
            try:
                os.unlink(file_path)
            except Exception, e:
                raise e

    def test_all_error_flows(self):
        # Test request_token without appropriate headers
        resp = self.client.get("/XAPI/OAuth/initiate/", X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 401)
        self.assertIn('WWW-Authenticate', resp._headers['www-authenticate'])
        self.assertIn('OAuth realm="http://localhost:8000/XAPI"', resp._headers['www-authenticate'])
        self.assertEqual(resp.content, 'Invalid request parameters.')

        oauth_header_request_params = "OAuth realm=\"test\","\
               "oauth_consumer_key=\"%s\","\
               "oauth_signature_method=\"PLAINTEXT\","\
               "oauth_signature=\"%s&\","\
               "oauth_timestamp=\"%s\","\
               "oauth_nonce=\"requestnonce\","\
               "oauth_version=\"1.0\","\
               "oauth_callback=\"http://example.com/request_token_ready\"" % (self.consumer.key,self.consumer.secret,str(int(time.time())))

        # Test passing scope as form param
        form_data = {
            'scope':'all',
        }               
        request_resp = self.client.get("/XAPI/OAuth/initiate/", Authorization=oauth_header_request_params, data=form_data, X_Experience_API_Version="1.0.0")
        self.assertEqual(request_resp.status_code, 200)
        self.assertIn('oauth_token_secret=', request_resp.content)
        self.assertIn('oauth_token=', request_resp.content)
        self.assertIn('&oauth_callback_confirmed=true', request_resp.content)
        token = models.Token.objects.get(consumer=self.consumer)
        self.assertIn(token.key, request_resp.content)
        self.assertIn(token.secret, request_resp.content)
        self.assertEqual(token.callback, 'http://example.com/request_token_ready')
        self.assertEqual(token.callback_confirmed, True)

        # Test wrong scope
        form_data['scope'] = 'videos'
        scope_resp = self.client.get("/XAPI/OAuth/initiate/", Authorization=oauth_header_request_params, data=form_data, X_Experience_API_Version="1.0.0")
        self.assertEqual(scope_resp.status_code, 401)
        self.assertEqual(scope_resp.content, 'Resource videos is not allowed.')
        form_data['scope'] = 'all'

        # Test wrong callback
        oauth_header_request_params += ',oauth_callback="wrongcallback"'
        call_resp = self.client.get("/XAPI/OAuth/initiate/", Authorization=oauth_header_request_params, data=form_data, X_Experience_API_Version="1.0.0")
        self.assertEqual(call_resp.status_code, 401)
        self.assertEqual(call_resp.content, 'Invalid callback URL.')

        # Test AUTHORIZE
        oauth_auth_params = {'oauth_token': token.key}
        auth_resp = self.client.get("/XAPI/OAuth/authorize/", oauth_auth_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(auth_resp.status_code, 302)
        self.assertIn('http://testserver/XAPI/accounts/login?next=/XAPI/OAuth/authorize/%3F', auth_resp['Location'])
        self.assertIn(token.key, auth_resp['Location'])
        self.client.login(username='jane', password='toto')
        self.assertEqual(token.is_approved, False)
        auth_resp = self.client.get("/XAPI/OAuth/authorize/", oauth_auth_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(auth_resp.status_code, 200) # Show return/display OAuth authorized view
        html = auth_resp.content
        # <input type="hidden" name="obj_id" value="38" id="id_obj_id">
        # hidden.*name="obj_id"\Wvalue="(.*?)"
        cap = re.search('name="obj_id"\Wvalue="(.*?)"', html)
        oauth_auth_params['obj_id'] = cap.group(1)

        # <input checked="checked" type="checkbox" name="scopes" value="statements/write">
        # input\Wchecked="checked".*?value="(.*?)"
        caps = re.findall('checked="checked".*?value="(.*?)"', html)
        oauth_auth_params['scopes'] = [c for c in caps]

        oauth_auth_params['authorize_access'] = 1

        oauth_auth_params['authorize_access'] = 1
        auth_post = self.client.post("/XAPI/OAuth/authorize/", oauth_auth_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(auth_post.status_code, 302)
        self.assertIn('http://example.com/request_token_ready?oauth_verifier=', auth_post['Location'])
        token = models.Token.objects.get(consumer=self.consumer)
        self.assertIn(token.key, auth_post['Location'])
        self.assertEqual(token.is_approved, True)

        # Test without session param (previous POST removed it)
        auth_post = self.client.post("/XAPI/OAuth/authorize/", oauth_auth_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(auth_post.status_code, 401)
        self.assertEqual(auth_post.content, 'Action not allowed.')

        # Test fake access
        auth_resp = self.client.get("/XAPI/OAuth/authorize/", oauth_auth_params, X_Experience_API_Version="1.0.0")
        oauth_auth_params['authorize_access'] = 0
        auth_resp = self.client.post("/XAPI/OAuth/authorize/", oauth_auth_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(auth_resp.status_code, 302)
        self.assertEqual(auth_resp['Location'], 'http://example.com/request_token_ready?error=Access%20not%20granted%20by%20user.')
        self.client.logout()

        # Test ACCESS TOKEN
        oauth_header_access_params = "OAuth realm=\"test\","\
            "oauth_consumer_key=\"%s\","\
            "oauth_token=\"%s\","\
            "oauth_signature_method=\"PLAINTEXT\","\
            "oauth_signature=\"%s&%s\","\
            "oauth_timestamp=\"%s\","\
            "oauth_nonce=\"accessnonce\","\
            "oauth_version=\"1.0\","\
            "oauth_verifier=\"%s\"" % (self.consumer.key,token.key,self.consumer.secret,token.secret,str(int(time.time())),token.verifier)

        access_resp = self.client.get("/XAPI/OAuth/token/", Authorization=oauth_header_access_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(access_resp.status_code, 200)
        access_token = models.Token.objects.filter(token_type=models.Token.ACCESS, consumer=self.consumer)[0]
        self.assertIn(access_token.key, access_resp.content)
        self.assertEqual(access_token.user.username, u'jane')

        # Test same Nonce
        access_resp = self.client.get("/XAPI/OAuth/token/", Authorization=oauth_header_access_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(access_resp.status_code, 401)
        self.assertEqual(access_resp.content, 'Nonce already used: accessnonce')

        # Test missing/invalid verifier
        oauth_header_access_params += ',oauth_nonce="yetanotheraccessnonce"'
        oauth_header_access_params += ',oauth_verifier="invalidverifier"'
        access_resp = self.client.get("/XAPI/OAuth/token/", Authorization=oauth_header_access_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(access_resp.status_code, 401)
        self.assertEqual(access_resp.content, 'Consumer key or token key does not match. Make sure your request token is approved. Check your verifier too if you use OAuth 1.0a.')     
        oauth_header_access_params += ',oauth_verifier="token.verifier"'

        # Test token not approved
        oauth_header_access_params += ',oauth_nonce="anotheraccessnonce"'
        token.is_approved = False
        token.save()
        access_resp = self.client.get("/XAPI/OAuth/token/", Authorization=oauth_header_access_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(access_resp.status_code, 401)
        self.assertEqual(access_resp.content, 'Consumer key or token key does not match. Make sure your request token is approved. Check your verifier too if you use OAuth 1.0a.')

        # Test ACCESS RESOURCE
        oauth_header_resource_params = "OAuth realm=\"test\", "\
            "oauth_consumer_key=\"%s\","\
            "oauth_token=\"%s\","\
            "oauth_signature_method=\"HMAC-SHA1\","\
            "oauth_timestamp=\"%s\","\
            "oauth_nonce=\"accessresourcenonce\","\
            "oauth_version=\"1.0\"" % (self.consumer.key, access_token.key, str(int(time.time())))

        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']

        oauth_request = OAuthRequest.from_token_and_callback(access_token,
            http_url='http://testserver/XAPI/statements/', parameters=oauth_header_resource_params_dict)
        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature
        resp = self.client.get("/XAPI/statements/", Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(resp.content, '{"statements": [], "more": ""}')

        # Test wrong signature
        oauth_header_resource_params += ',oauth_signature="wrongsignature"'
        oauth_header_resource_params += ',oauth_nonce="anotheraccessresourcenonce"'
        resp = self.client.get("/XAPI/statements/", Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 401)
        self.assertIn('Invalid signature.', resp.content)

        # Test wrong params - will not return 'Invalid request parameters.' like oauth example states
        # because there is no Authorization header. With no auth header the lrs reads as no auth supplied at all
        resp = self.client.get("/XAPI/statements/", X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 401)
        self.assertEqual(resp.content, 'Auth is enabled but no authentication was sent with the request.')

        # Test revoke access
        access_token.delete()
        oauth_header_resource_params += ',oauth_signature="%s"' % signature
        oauth_header_resource_params += ',oauth_nonce="yetanotheraccessresourcenonce"'
        resp = self.client.get("/XAPI/statements/", Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 401)
        self.assertIn('Invalid access token', resp.content)

    def test_oauth_disabled(self):
        # Disable oauth
        if settings.OAUTH_ENABLED:
            settings.OAUTH_ENABLED = False

        # TEST REQUEST TOKEN
        oauth_header_request_params = {
            'oauth_consumer_key': self.consumer.key,
            'oauth_signature_method': 'PLAINTEXT',
            'oauth_signature':'%s&' % self.consumer.secret,
            'oauth_timestamp': str(int(time.time())),
            'oauth_nonce': 'requestnonce',
            'oauth_version': '1.0',
            'oauth_callback':'http://example.com/request_token_ready'
        }
        # Test sending in scope as query param with REQUEST_TOKEN
        param = {
                    "scope":"all"
                }
        path = "%s?%s" % ("/XAPI/OAuth/initiate", urllib.urlencode(param))                  
        request_resp = self.client.get(path, Authorization=oauth_header_request_params, X_Experience_API_Version="1.0.0")        
        self.assertEqual(request_resp.status_code, 400)
        self.assertEqual(request_resp.content,'OAuth is not enabled. To enable, set the OAUTH_ENABLED flag to true in settings' )

    def test_stmt_put(self):
        # build stmt data and path
        put_guid = str(uuid.uuid1())
        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bill"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/accessed","display": {"en-US":"accessed"}},
            "object": {"id":"act:test_put"}})
        param = {"statementId":put_guid}
        path = "%s?%s" % ('http://testserver/XAPI/statements', urllib.urlencode(param))
        
        oauth_header_resource_params, access_token = self.perform_oauth_handshake(request_nonce='stmtputrequestnonce',
            access_nonce='stmtputaccessnonce', resource_nonce='stmtputresourcenonce')
        
        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']
        # add put data
        oauth_header_resource_params_dict.update(param)

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='PUT',
            http_url=path, parameters=oauth_header_resource_params_dict)
        
        # build signature and add to the params
        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature

        # Put statements
        resp = self.client.put(path, data=stmt, content_type="application/json",
            Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 204)

    def test_stmt_post_no_scope(self):

        stmt = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_post"}}
        stmt_json = json.dumps(stmt)

        oauth_header_resource_params, access_token = self.perform_oauth_handshake(scope=False,
            request_nonce='stmtpostrequestnonce', access_nonce='stmtpostaccessnonce',
            resource_nonce='stmtpostresourcenonce')

        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='POST',
            http_url='http://testserver/XAPI/statements/', parameters=oauth_header_resource_params_dict)

        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature  

        post = self.client.post('/XAPI/statements/', data=stmt_json, content_type="application/json",
            Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 200)

    def test_stmt_simple_get(self):
        guid = str(uuid.uuid1())
        stmt_data = {"id":guid,"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_simple_get"}}
        stmt = StatementManager(stmt_data, stmt_json=json.dumps(stmt_data))
        param = {"statementId":guid}
        path = "%s?%s" % ('http://testserver/XAPI/statements', urllib.urlencode(param))

        oauth_header_resource_params, access_token = self.perform_oauth_handshake(request_nonce='stmtgetrequestnonce',
            access_nonce='stmtgetaccessnonce', resource_nonce='stmtgetresourcenonce')

        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']
        # add get data
        oauth_header_resource_params_dict.update(param)

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url=path, parameters=oauth_header_resource_params_dict)

        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature

        resp = self.client.get(path,Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 200)
        rsp = resp.content
        self.assertIn(guid, rsp)

    def test_stmt_complex_get(self):
        stmt_data = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_complex_get"}}
        stmt = StatementManager(stmt_data, stmt_json=json.dumps(stmt_data))
        param = {"activity":"act:test_complex_get"}
        path = "%s?%s" % ('http://testserver/XAPI/statements', urllib.urlencode(param))

        oauth_header_resource_params, access_token = self.perform_oauth_handshake(request_nonce='stmtcomplexrequestnonce',
            access_nonce='stmtcomplexaccessnonce', resource_nonce='stmtcomplexresourcenonce')

        # from_token_and_callback takes a dictionary 
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']
        # add get data
        oauth_header_resource_params_dict.update(param)

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url=path, parameters=oauth_header_resource_params_dict)

        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature

        resp = self.client.get(path,Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")        
        self.assertEqual(resp.status_code, 200)

    def test_stmt_get_then_wrong_scope(self):
        guid = str(uuid.uuid1())
        stmt_data = {"id":guid,"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_simple_get"}}
        stmt = StatementManager(stmt_data, stmt_json=json.dumps(stmt_data))
        param = {"statementId":guid}
        path = "%s?%s" % ('http://testserver/XAPI/statements', urllib.urlencode(param))

        oauth_header_resource_params, access_token = self.perform_oauth_handshake(scope_type="statements/read,profile",
            request_nonce='stmtgetrequestnonce',access_nonce='stmtgetaccessnonce',
            resource_nonce='stmtgetresourcenonce')

        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']
        # add get data
        oauth_header_resource_params_dict.update(param)

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url=path, parameters=oauth_header_resource_params_dict)

        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature

        resp = self.client.get(path,Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 200)
        rsp = resp.content
        self.assertIn(guid, rsp)

        # Test POST (not allowed)
        post_stmt = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_post"}}
        post_stmt_json = json.dumps(post_stmt)

        # change nonce
        oauth_header_resource_params_dict['oauth_nonce'] = 'wrongpostnonce'
        # delete statementId from get
        del oauth_header_resource_params_dict['statementId']

        # create another oauth request
        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='POST',
            http_url='http://testserver/XAPI/statements/', parameters=oauth_header_resource_params_dict)
        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature
        # replace headers with the nonce you added in dict
        new_oauth_headers = oauth_header_resource_params.replace('oauth_nonce="accessresourcenonce"','oauth_nonce="wrongpostnonce"')        

        post = self.client.post('/XAPI/statements/', data=post_stmt_json, content_type="application/json",
            Authorization=new_oauth_headers, X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 403)
        self.assertEqual(post.content, 'Incorrect permissions to POST at /statements')

    def test_activity_state_put_then_wrong_scope(self):
        url = 'http://testserver/XAPI/activities/state'
        testagent = '{"name":"jane","mbox":"mailto:jane@example.com"}'
        activityId = "http://www.iana.org/domains/example/"
        stateId = "id:the_state_id"
        activity = models.Activity(activity_id=activityId)
        activity.save()
        testparams = {"stateId": stateId, "activityId": activityId, "agent": testagent}
        teststate = {"test":"put activity state 1"}
        path = '%s?%s' % (url, urllib.urlencode(testparams))

        oauth_header_resource_params, access_token = self.perform_oauth_handshake(scope_type='state',
            request_nonce='stateforbiddenrequestnonce', access_nonce='stateforbiddenaccessnonce',
            resource_nonce='stateforbiddenresourcenonce')

        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']
        # add put data
        oauth_header_resource_params_dict.update(testparams)

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='PUT',
            http_url=path, parameters=oauth_header_resource_params_dict)
        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature

        put = self.client.put(path, data=teststate, content_type="application/json",
            Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(put.status_code, 204)
        
        # Set up for Get
        guid = str(uuid.uuid1())
        stmt_data = {"id":guid,"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_simple_get"}}
        stmt = StatementManager(stmt_data, stmt_json=json.dumps(stmt_data))
        param = {"statementId":guid}
        path = "%s?%s" % ('http://testserver/XAPI/statements', urllib.urlencode(param))

        # change nonce
        oauth_header_resource_params_dict['oauth_nonce'] = 'differnonce'
        # delete statementId from get
        del oauth_header_resource_params_dict['stateId']
        del oauth_header_resource_params_dict['activityId']
        del oauth_header_resource_params_dict['agent']                
        # update dict with stmt data
        oauth_header_resource_params_dict.update(param)

        # create another oauth request
        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url=path, parameters=oauth_header_resource_params_dict)
        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature2 = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params_new = oauth_header_resource_params.replace('"%s"' % signature, '"%s"' % signature2) 
        # replace headers with the nonce you added in dict
        new_oauth_headers = oauth_header_resource_params_new.replace('oauth_nonce="accessresourcenonce"','oauth_nonce="differnonce"')        
        get = self.client.get(path, content_type="application/json",
            Authorization=new_oauth_headers, X_Experience_API_Version="1.0.0")

        self.assertEqual(get.status_code, 403)
        self.assertEqual(get.content, 'Incorrect permissions to GET at /statements')



    def stmt_get_then_wrong_profile_scope(self):
        guid = str(uuid.uuid1())
        stmt_data = {"id":guid,"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_simple_get"}}
        stmt = StatementManager(stmt_data, stmt_json=json.dumps(stmt_data))
        param = {"statementId":guid}
        path = "%s?%s" % ('http://testserver/XAPI/statements', urllib.urlencode(param))

        oauth_header_resource_params, access_token = self.perform_oauth_handshake(scope_type="statements/read",
            request_nonce='stmtgetrequestnonce',access_nonce='stmtgetaccessnonce',
            resource_nonce='stmtgetresourcenonce')

        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']
        # add get data
        oauth_header_resource_params_dict.update(param)

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url=path, parameters=oauth_header_resource_params_dict)

        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature

        resp = self.client.get(path,Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 200)
        rsp = resp.content
        self.assertIn(guid, rsp)

        url = 'http://testserver/XAPI/agents/profile'
        params = {"agent": {"mbox":"mailto:test@example.com"}}
        path = "%s?%s" %(url, urllib.urlencode(params))

        oauth_header_resource_params_dict['oauth_nonce'] = 'differnonce'
        del oauth_header_resource_params_dict['statementId']
        oauth_header_resource_params_dict.update(params)
        # create another oauth request
        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url=path, parameters=oauth_header_resource_params_dict)

        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature2 = signature_method.build_signature(oauth_request, self.consumer, access_token)
        
        new_sig_params = oauth_header_resource_params.replace('"%s"' % signature, '"%s"' % signature2 )
        # replace headers with the nonce you added in dict
        new_oauth_headers = new_sig_params.replace('oauth_nonce="accessresourcenonce"','oauth_nonce="differnonce"')        
        r = self.client.get(path, Authorization=new_oauth_headers, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)


    def test_consumer_state(self):
        stmt_data = {"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_complex_get"}}
        stmt = StatementManager(stmt_data, stmt_json=json.dumps(stmt_data))
        param = {"object":{"objectType": "Activity", "id":"act:test_complex_get"}}
        path = "%s?%s" % ('http://testserver/XAPI/statements', urllib.urlencode(param))

        oauth_header_resource_params, access_token = self.perform_oauth_handshake(request_nonce='consumerstaterequestnonce',
            access_nonce='consumerstateaccessnonce', resource_nonce='consumerstateresourcenonce')

        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']
        # add get data
        oauth_header_resource_params_dict.update(param)

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url=path, parameters=oauth_header_resource_params_dict)
        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature

        consumer = access_token.consumer
        consumer.status = 4
        consumer.save()
        resp = self.client.get(path,Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")        
        self.assertEqual(resp.status_code, 401)
        self.assertEqual(resp.content, 'test client has not been authorized')

    def test_simple_stmt_get_mine_only(self):
        guid = str(uuid.uuid1())

        username = "tester1"
        email = "test1@tester.com"
        password = "test"
        auth = "Basic %s" % base64.b64encode("%s:%s" % (username, password))
        form = {"username":username, "email":email,"password":password,"password2":password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")

        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_put"},"actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}})

        putResponse = self.client.put(path, stmt, content_type="application/json", Authorization=auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(putResponse.status_code, 204)
        
        param = {"statementId":guid}
        path = "%s?%s" % ('http://testserver/XAPI/statements', urllib.urlencode(param))

        oauth_header_resource_params, access_token = self.perform_oauth_handshake(scope_type="statements/read/mine",
            request_nonce='stmtgetrequestnonce',access_nonce='stmtgetaccessnonce', resource_nonce='stmtgetresourcenonce')

        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']
        # add get data
        oauth_header_resource_params_dict.update(param)

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url=path, parameters=oauth_header_resource_params_dict)

        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature

        resp = self.client.get(path,Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 403)

        # build stmt data and path
        oauth_agent1 = models.Agent.objects.get(account_name=self.consumer.key)
        oauth_agent2 = models.Agent.objects.get(mbox="mailto:test1@tester.com")
        oauth_group = models.Agent.objects.get(member__in=[oauth_agent1, oauth_agent2])
        guid = str(uuid.uuid1())

        stmt_data = {"id":guid,"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bill"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/accessed","display": {"en-US":"accessed"}},
            "object": {"id":"act:test_put"}, "authority":oauth_group.get_agent_json()}
        stmt = StatementManager(stmt_data, stmt_json=json.dumps(stmt_data))
        param = {"statementId":guid}
        path = "%s?%s" % ('http://testserver/XAPI/statements', urllib.urlencode(param))
        
        # add put data
        oauth_header_resource_params_dict['statementId'] = guid
        oauth_header_resource_params_dict['oauth_nonce'] = 'getdiffernonce'

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url=path, parameters=oauth_header_resource_params_dict)
        
        # build signature and add to the params
        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        get_signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        replace_sig = oauth_header_resource_params.replace('"%s"' % signature, '"%s"' % get_signature)
        new_oauth_headers = replace_sig.replace('oauth_nonce="accessresourcenonce"','oauth_nonce="getdiffernonce"')        

        get = self.client.get(path, content_type="application/json",
            Authorization=new_oauth_headers, X_Experience_API_Version="1.0.0")

        self.assertEqual(get.status_code, 200)

    def test_complex_stmt_get_mine_only(self):
        guid = str(uuid.uuid1())
        username = "tester1"
        email = "test1@tester.com"
        password = "test"
        auth = "Basic %s" % base64.b64encode("%s:%s" % (username, password))
        form = {"username":username, "email":email,"password":password,"password2":password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")

        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_put"},"actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}})

        putResponse = self.client.put(path, stmt, content_type="application/json", Authorization=auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(putResponse.status_code, 204)

        param = {"statementId":guid}
        path = "%s?%s" % ('http://testserver/XAPI/statements', urllib.urlencode(param))

        oauth_header_resource_params, access_token = self.perform_oauth_handshake(scope_type="statements/read/mine",
            request_nonce='stmtgetrequestnonce',access_nonce='stmtgetaccessnonce', resource_nonce='stmtgetresourcenonce')

        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']
        # add get data
        oauth_header_resource_params_dict.update(param)

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url=path, parameters=oauth_header_resource_params_dict)

        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature

        resp = self.client.get(path,Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 403)

        # build stmt data and path
        oauth_agent1 = models.Agent.objects.get(account_name=self.consumer.key)
        oauth_agent2 = models.Agent.objects.get(mbox="mailto:test1@tester.com")
        oauth_group = models.Agent.objects.get(member__in=[oauth_agent1, oauth_agent2])
        guid = str(uuid.uuid1())

        stmt_data = {"id":guid,"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bill"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/accessed","display": {"en-US":"accessed"}},
            "object": {"id":"act:test_put"}, "authority":oauth_group.get_agent_json()}
        stmt = StatementManager(stmt_data, stmt_json=json.dumps(stmt_data))
        
        # add put data
        oauth_header_resource_params_dict['oauth_nonce'] = 'getdiffernonce'
        del oauth_header_resource_params_dict['statementId']
        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url='http://testserver/XAPI/statements', parameters=oauth_header_resource_params_dict)
        
        # build signature and add to the params
        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        get_signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        replace_sig = oauth_header_resource_params.replace('"%s"' % signature, '"%s"' % get_signature)
        new_oauth_headers = replace_sig.replace('oauth_nonce="accessresourcenonce"','oauth_nonce="getdiffernonce"')        

        # Put statements
        get = self.client.get('http://testserver/XAPI/statements', content_type="application/json",
            Authorization=new_oauth_headers, X_Experience_API_Version="1.0.0")
        get_content = json.loads(get.content)

        self.assertEqual(get.status_code, 200)
        self.assertEqual(get_content['statements'][0]['actor']['name'], 'bill')
        self.assertEqual(len(get_content['statements']), 1)

    def test_state_wrong_auth(self):
        url = 'http://testserver/XAPI/activities/state'
        testagent = '{"name":"joe","mbox":"mailto:joe@example.com"}'
        activityId = "http://www.iana.org/domains/example/"
        stateId = "id:the_state_id"
        activity = models.Activity(activity_id=activityId)
        activity.save()
        testparams = {"stateId": stateId, "activityId": activityId, "agent": testagent}
        teststate = {"test":"put activity state 1"}
        path = '%s?%s' % (url, urllib.urlencode(testparams))

        oauth_header_resource_params, access_token = self.perform_oauth_handshake(scope_type='state',
            request_nonce='stateforbiddenrequestnonce', access_nonce='stateforbiddenaccessnonce',
            resource_nonce='stateforbiddenresourcenonce')

        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']
        # add put data
        oauth_header_resource_params_dict.update(testparams)

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='PUT',
            http_url=path, parameters=oauth_header_resource_params_dict)
        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature

        put = self.client.put(path, data=teststate, content_type="application/json",
            Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")

        self.assertEqual(put.status_code, 404)        
        self.assertEqual(put.content, "Agent in state cannot be found to match user in authorization")

    def test_profile_wrong_auth(self):
        agent = models.Agent(name="joe", mbox="mailto:joe@example.com")
        agent.save()

        url = 'http://testserver/XAPI/agents/profile'
        testparams = {"agent": '{"name":"joe","mbox":"mailto:joe@example.com"}'}
        path = '%s?%s' % (url, urllib.urlencode(testparams))

        oauth_header_resource_params, access_token = self.perform_oauth_handshake(scope_type='profile',
            request_nonce='profileforbiddenrequestnonce', access_nonce='profileforbiddenaccessnonce',
            resource_nonce='profileforbiddenresourcenonce')

        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']
        # add put data
        oauth_header_resource_params_dict.update(testparams)
        
        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url=path, parameters=oauth_header_resource_params_dict)

        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature

        get = self.client.get(path, content_type="application/json",
            Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")

        self.assertEqual(get.status_code, 403)
        self.assertEqual(get.content, "Authorization doesn't match agent in profile")

    def test_define_scope_activity(self):
        url = 'http://testserver/XAPI/statements'
        guid = str(uuid.uuid1())
        stmt_data = {"id":guid,"actor":{"objectType": "Agent",
            "mbox":"mailto:bob@bob.com", "name":"bob"},"verb":{"id": "http://adlnet.gov/expapi/verbs/passed",
            "display": {"en-US":"passed"}},"object": {"id":"test://test/define/scope"}}
        existing_stmt = StatementManager(stmt_data, stmt_json=json.dumps(stmt_data))

        # build stmt data and path
        put_guid = str(uuid.uuid1())
        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:bill@bill.com", "name":"bill"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/accessed","display": {"en-US":"accessed"}},
            "object": {"id":"test://test/define/scope",
            'definition': {'name': {'en-US':'testname', 'en-GB': 'altname'},
            'description': {'en-US':'testdesc', 'en-GB': 'altdesc'},'type': 'type:course',
            'interactionType': 'other'}}})

        param = {"statementId":put_guid}
        path = "%s?%s" % (url, urllib.urlencode(param))
        
        # START PUT STMT
        oauth_header_resource_params, access_token = self.perform_oauth_handshake(scope_type='statements/write,statements/read',
            request_nonce='anotherstmtputrequestnonce',access_nonce='anotherstmtputaccessnonce',
            resource_nonce='anotherstmtputresourcenonce')
        
        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']
        # add put data
        oauth_header_resource_params_dict.update(param)

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='PUT',
            http_url=path, parameters=oauth_header_resource_params_dict)
        
        # build signature and add to the params
        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature
        # Put statements - does not have define scope, therefore it creates another activity with 
        # canonical_version as false
        resp = self.client.put(path, data=stmt, content_type="application/json",
            Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")

        self.assertEqual(resp.status_code, 204)
        acts = models.Activity.objects.all()
        self.assertEqual(len(acts), 2)
        self.assertEqual(acts[0].activity_id, acts[1].activity_id)

        # START GET STMT
        get_params = {"activity":"test://test/define/scope"}
        path = "%s?%s" % (url, urllib.urlencode(get_params)) 

        del oauth_header_resource_params_dict['statementId']
        oauth_header_resource_params_dict.update(get_params)
        oauth_header_resource_params_dict['oauth_nonce'] = 'getdiffernonce'

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url=path, parameters=oauth_header_resource_params_dict)
        
        # build signature and add to the params
        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        get_signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        replace_sig = oauth_header_resource_params.replace('"%s"' % signature, '"%s"' % get_signature)
        new_oauth_headers = replace_sig.replace('oauth_nonce="accessresourcenonce"','oauth_nonce="getdiffernonce"')        

        get_resp = self.client.get(path, X_Experience_API_Version="1.0.0",
            Authorization=new_oauth_headers)
        self.assertEqual(get_resp.status_code, 200)
        content = json.loads(get_resp.content)
        self.assertEqual(len(content['statements']), 2)
        self.client.logout()

        # START OF POST WITH ANOTHER HANDSHAKE
        post_stmt = {"actor":{"objectType": "Agent", "mbox":"mailto:dom@dom.com", "name":"dom"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/tested","display": {"en-US":"tested"}},
            "object": {"id":"test://test/define/scope",
            'definition': {'name': {'en-US':'definename', 'en-GB': 'definealtname'},
            'description': {'en-US':'definedesc', 'en-GB': 'definealtdesc'},'type': 'type:course',
            'interactionType': 'other'}}}
        stmt_json = json.dumps(post_stmt)

        post_oauth_header_resource_params, post_access_token = self.perform_oauth_handshake2(scope_type='define,statements/write',
            request_nonce='stmtpostrequestnonce', access_nonce='stmtpostaccessnonce',
            resource_nonce='stmtpostresourcenonce')

        # from_token_and_callback takes a dictionary        
        post_param_list = post_oauth_header_resource_params.split(",")
        post_oauth_header_resource_params_dict = {}
        for p in post_param_list:
            item = p.split("=")
            post_oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del post_oauth_header_resource_params_dict['OAuth realm']
        
        post_oauth_request = OAuthRequest.from_token_and_callback(post_access_token, http_method='POST',
            http_url='http://testserver/XAPI/statements/',
            parameters=post_oauth_header_resource_params_dict)

        post_signature_method = OAuthSignatureMethod_HMAC_SHA1()
        post_signature = signature_method.build_signature(post_oauth_request, self.consumer2,
            post_access_token)

        post_oauth_header_resource_params += ',oauth_signature="%s"' % post_signature  
        # This adds the act_def to the very first activity created in this test sine this has define scope
        post = self.client.post('/XAPI/statements/', data=stmt_json, content_type="application/json",
            Authorization=post_oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 200)
        acts = models.Activity.objects.all()
        self.assertEqual(len(acts), 2)

        global_act = models.Activity.objects.get(canonical_version=True)        
        global_name_list = global_act.activity_definition_name.values()
        self.assertIn('definename', global_name_list)
        self.assertIn('definealtname', global_name_list)
        global_desc_list = global_act.activity_definition_description.values()
        self.assertIn('definedesc', global_desc_list)
        self.assertIn('definealtdesc', global_desc_list)

        non_global_act = models.Activity.objects.get(canonical_version=False)        
        non_global_name_list = non_global_act.activity_definition_name.values()
        self.assertIn('testname', non_global_name_list)
        self.assertIn('altname', non_global_name_list)
        non_global_desc_list = non_global_act.activity_definition_description.values()
        self.assertIn('testdesc', non_global_desc_list)
        self.assertIn('altdesc', non_global_desc_list)

    def test_define_scope_agent(self):
        url = 'http://testserver/XAPI/statements'
        guid = str(uuid.uuid1())
        stmt_data = {"id":guid,"actor":{"objectType": "Agent",
            "mbox":"mailto:bob@bob.com", "name":"bob"},"verb":{"id": "http://adlnet.gov/expapi/verbs/helped",
            "display": {"en-US":"helped"}},"object": {"objectType":"Agent", "mbox":"mailto:tim@tim.com",
            "name":"tim"}}
        existing_stmt = StatementManager(stmt_data, stmt_json=json.dumps(stmt_data))

        # build stmt data and path
        put_guid = str(uuid.uuid1())
        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:bill@bill.com", "name":"bill"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/talked","display": {"en-US":"talked"}},
            "object": {"objectType":"Agent", "mbox":"mailto:tim@tim.com","name":"tim timson"}})

        param = {"statementId":put_guid}
        path = "%s?%s" % (url, urllib.urlencode(param))
        
        # START PUT STMT
        oauth_header_resource_params, access_token = self.perform_oauth_handshake(scope_type='statements/write,statements/read',
            request_nonce='anotherstmtputrequestnonce',access_nonce='anotherstmtputaccessnonce',
            resource_nonce='anotherstmtputresourcenonce')
        
        # from_token_and_callback takes a dictionary        
        param_list = oauth_header_resource_params.split(",")
        oauth_header_resource_params_dict = {}
        for p in param_list:
            item = p.split("=")
            oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del oauth_header_resource_params_dict['OAuth realm']
        # add put data
        oauth_header_resource_params_dict.update(param)

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='PUT',
            http_url=path, parameters=oauth_header_resource_params_dict)
        
        # build signature and add to the params
        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        oauth_header_resource_params += ',oauth_signature="%s"' % signature

        # Put statements
        resp = self.client.put(path, data=stmt, content_type="application/json",
            Authorization=oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 204)
        agents = models.Agent.objects.all().values_list('name', flat=True)
        # Jane, Anonymous agent for account, Group for jane and account, bill, bob, tim, tim timson
        self.assertEqual(len(agents), 7)
        self.assertIn('tim', agents)
        self.assertIn('tim timson', agents)
        tim = models.Agent.objects.get(name='tim timson')
        self.assertFalse(tim.canonical_version)
        tim = models.Agent.objects.get(name='tim')
        self.assertTrue(tim.canonical_version)

        # START GET STMT
        get_params = {"agent":{"objectType": "Agent", "mbox":"mailto:tim@tim.com"}, "related_agents":True}
        path = "%s?%s" % (url, urllib.urlencode(get_params)) 

        del oauth_header_resource_params_dict['statementId']
        oauth_header_resource_params_dict.update(get_params)
        oauth_header_resource_params_dict['oauth_nonce'] = 'getdiffernonce'

        oauth_request = OAuthRequest.from_token_and_callback(access_token, http_method='GET',
            http_url=path, parameters=oauth_header_resource_params_dict)
        
        # build signature and add to the params
        signature_method = OAuthSignatureMethod_HMAC_SHA1()
        get_signature = signature_method.build_signature(oauth_request, self.consumer, access_token)
        replace_sig = oauth_header_resource_params.replace('"%s"' % signature, '"%s"' % get_signature)
        new_oauth_headers = replace_sig.replace('oauth_nonce="accessresourcenonce"','oauth_nonce="getdiffernonce"')        

        get_resp = self.client.get(path, X_Experience_API_Version="1.0.0",
            Authorization=new_oauth_headers)
        self.assertEqual(get_resp.status_code, 200)
        content = json.loads(get_resp.content)
        # Should only be one since querying by tim email. Will only pick up global tim object
        self.assertEqual(len(content['statements']), 1)
        self.client.logout()
        
        # START OF POST WITH ANOTHER HANDSHAKE
        # Anonymous group that will make 2 canonical agents
        ot = "Group"
        members = [{"name":"john doe","mbox":"mailto:jd@example.com"},
                    {"name":"jan doe","mbox":"mailto:jandoe@example.com"}]
        kwargs = {"objectType":ot, "member": members, "name": "doe group"}
        global_group, created = models.Agent.objects.retrieve_or_create(**kwargs)

        # Anonymous group that will retrieve two agents and create one more canonical agents
        members = [{"name":"john doe","mbox":"mailto:jd@example.com"},
                    {"name":"jan doe","mbox":"mailto:jandoe@example.com"},
                    {"name":"dave doe", "mbox":"mailto:dd@example.com"}]
        kwargs1 = {"objectType":ot, "member": members, "name": "doe group"}

        post_stmt = {"actor":{"objectType": "Agent", "mbox":"mailto:dom@dom.com", "name":"dom"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/assisted","display": {"en-US":"assisted"}},
            "object": kwargs1}
        stmt_json = json.dumps(post_stmt)

        post_oauth_header_resource_params, post_access_token = self.perform_oauth_handshake2(scope_type='statements/write,statements/read',
            request_nonce='stmtpostrequestnonce', access_nonce='stmtpostaccessnonce',
            resource_nonce='stmtpostresourcenonce')

        # from_token_and_callback takes a dictionary        
        post_param_list = post_oauth_header_resource_params.split(",")
        post_oauth_header_resource_params_dict = {}
        for p in post_param_list:
            item = p.split("=")
            post_oauth_header_resource_params_dict[str(item[0]).strip()] = str(item[1]).strip('"')
        
        # from_request ignores realm, must remove so not input to from_token_and_callback
        del post_oauth_header_resource_params_dict['OAuth realm']
        
        post_oauth_request = OAuthRequest.from_token_and_callback(post_access_token, http_method='POST',
            http_url='http://testserver/XAPI/statements/',
            parameters=post_oauth_header_resource_params_dict)

        post_signature_method = OAuthSignatureMethod_HMAC_SHA1()
        post_signature = signature_method.build_signature(post_oauth_request, self.consumer2,
            post_access_token)

        post_oauth_header_resource_params += ',oauth_signature="%s"' % post_signature  
        
        post = self.client.post('/XAPI/statements/', data=stmt_json, content_type="application/json",
            Authorization=post_oauth_header_resource_params, X_Experience_API_Version="1.0.0")
        self.assertEqual(post.status_code, 200)
        agents = models.Agent.objects.all()

        # These 5 agents are all non-global since created w/o define scope
        non_globals = models.Agent.objects.filter(canonical_version=False).values_list('name', flat=True)

        self.assertEqual(len(non_globals), 4)
        self.assertIn('bill', non_globals)
        self.assertIn('tim timson', non_globals)
        self.assertIn('dom', non_globals)
        self.assertIn('doe group', non_globals)
        # 2 oauth group objects, all of these agents since created with member or manually and 2 anon
        # account agents for the accounts in the oauth groups
        global_agents = models.Agent.objects.filter(canonical_version=True).values_list('name', flat=True)
        self.assertEqual(len(global_agents), 12)
        self.assertIn('bob', global_agents)
        self.assertIn('tim', global_agents)
        self.assertIn('jan doe', global_agents)
        self.assertIn('john doe', global_agents)
        self.assertIn('dave doe', global_agents)        
        self.assertIn('jane', global_agents)
        self.assertIn('dick', global_agents)
        self.assertIn('doe group', global_agents)

########NEW FILE########
__FILENAME__ = StatementFilterTests
# coding=utf-8
from email import message_from_string
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from email.mime.text import MIMEText
from django.test import TestCase
from django.core.urlresolvers import reverse
from lrs import views
from lrs.models import Statement
from lrs.objects.StatementManager import StatementManager as StMan
from django.conf import settings
import json
import base64
import os
import uuid
import math
import urllib
import hashlib
from lrs.util import convert_to_utc

class StatementFilterTests(TestCase):

    @classmethod
    def setUpClass(cls):
        print "\n%s" % __name__

    def setUp(self):
        self.saved_stmt_limit=settings.SERVER_STMT_LIMIT
        settings.SERVER_STMT_LIMIT=100
        self.username = "tom"
        self.email = "tom@example.com"
        self.password = "1234"
        self.auth = "Basic %s" % base64.b64encode("%s:%s" % (self.username, self.password))

        form = {"username":self.username, "email":self.email,"password":self.password,"password2":self.password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0")
    
    def tearDown(self):
        settings.SERVER_STMT_LIMIT = 100
        attach_folder_path = os.path.join(settings.MEDIA_ROOT, "attachment_payloads")
        for the_file in os.listdir(attach_folder_path):
            file_path = os.path.join(attach_folder_path, the_file)
            try:
                os.unlink(file_path)
            except Exception, e:
                raise e
    
    def test_limit_filter(self):
        # Test limit
        for i in range(1,4):
            stmt = {"actor":{"mbox":"mailto:test%s" % i},"verb":{"id":"http://tom.com/tested"},"object":{"id":"act:activity%s" %i}}
            StMan(stmt, stmt_json=json.dumps(stmt))
        limitGetResponse = self.client.post(reverse(views.statements),{"limit":2}, content_type="application/x-www-form-urlencoded", X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(limitGetResponse.status_code, 200)
        rsp = limitGetResponse.content
        respList = json.loads(rsp)
        stmts = respList["statements"]
        self.assertEqual(len(stmts), 2)    

    def test_get_id(self):
        stmt = {
            "timestamp": "2013-04-08 21:07:11.459000+00:00", 
            "object": { 
                "id": "act:adlnet.gov/JsTetris_TCAPI/level18"
            }, 
            "actor": {
                "mbox": "mailto:tom@example.com", 
                "name": "tom"
            },
            "verb": {
                "id": "http://adlnet.gov/xapi/verbs/passed(to_go_beyond)", 
                "display": {
                    "en-US": "passed"
                }
            }, 
            "result": {
                "score": {
                    "raw": 1918560.0, 
                    "min": 0.0
                }, 
                "extensions": {
                    "ext:apm": "241", 
                    "ext:lines": "165", 
                    "ext:time": "1119"
                }
            }, 
            "context": {
                "contextActivities": {
                    "grouping": {
                        "id": "act:adlnet.gov/JsTetris_TCAPI"
                    }
                }
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        sid = Statement.objects.get(verb__verb_id="http://adlnet.gov/xapi/verbs/passed(to_go_beyond)").statement_id
        param = {"statementId":sid}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        self.assertEqual(obj['result']['score']['raw'], 1918560.0)

    def test_agent_filter_does_not_exist(self):
        param = {"agent":{"mbox":"mailto:fail@faile.com"}}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0.1", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        self.assertEqual(len(obj['statements']), 0)

    def test_agent_filter(self):
        stmt = {
            "verb": {
                "id": "http://special.adlnet.gov/xapi/verbs/stopped", 
                "display": {
                    "en-US": "nixed"
                }
            }, 
            "timestamp": "2013-04-11 23:24:03.603184+00:00", 
            "object": {
                "timestamp": "2013-04-11 23:24:03.578795+00:00", 
                "object": {
                    "id": "act:adlnet.gov/website", 
                    "objectType": "Activity"
                }, 
                "actor": {
                    "mbox": "mailto:louo@example.com", 
                    "name": "louo", 
                    "objectType": "Agent"
                }, 
                "verb": {
                    "id": "http://special.adlnet.gov/xapi/verbs/hacked", 
                    "display": {
                        "en-US": "hax0r5"
                    }
                }, 
                "objectType": "SubStatement"
            }, 
            "actor": {
                "mbox": "mailto:timmy@example.com", 
                "name": "timmy", 
                "objectType": "Agent"
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        stmt = {
            "timestamp": "2013-04-08 21:07:20.392000+00:00", 
            "object": { 
                "id": "act:adlnet.gov/JsTetris_TCAPI", 
                "objectType": "Activity"
            }, 
            "actor": {
                "mbox": "mailto:tom@example.com", 
                "name": "tom", 
                "objectType": "Agent"
            }, 
            "verb": {
                "id": "http://adlnet.gov/xapi/verbs/completed", 
                "display": {
                    "en-US": "finished"
                }
            }, 
            "result": {
                "score": {
                    "raw": 1918560.0, 
                    "min": 0.0
                }, 
                "extensions": {
                    "ext:level": "19", 
                    "ext:apm": "241", 
                    "ext:lines": "165", 
                    "ext:time": "1128"
                }
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))

        param = {"agent":{"mbox":"mailto:tom@example.com"}}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        for s in stmts:
            if param['agent']['mbox'] not in str(s['actor']):
                self.assertEqual(s['object']['objectType'], "StatementRef")
                self.assertTrue(param['agent']['mbox'] in str(Statement.objects.get(statement_id=s['object']['id']).actor.get_agent_json()))
            else:
                self.assertTrue(param['agent']['mbox'] in str(s['actor']))

    def test_group_as_agent_filter(self):
        stmt = {
            "verb": {
                "id": "http://special.adlnet.gov/xapi/verbs/started", 
                "display": {
                    "en-US": "started"
                }
            },
            "timestamp": "2013-04-11 14:49:25.376782+00:00", 
            "object": {
                "id": "act:github.com/adlnet/ADL_LRS/tree/1.0dev", 
                "objectType": "Activity"
            }, 
            "actor": {
                "member": [
                    {
                        "mbox": "mailto:louo@example.com", 
                        "name": "louo", 
                        "objectType": "Agent"
                    }, 
                    {
                        "mbox": "mailto:tom@example.com", 
                        "name": "tom", 
                        "objectType": "Agent"
                    }
                ], 
                "mbox": "mailto:adllrsdevs@example.com", 
                "name": "adl lrs developers", 
                "objectType": "Group"
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        stmt = {
            "timestamp": "2013-04-10 21:25:59.583000+00:00", 
            "object": {
                "mbox": "mailto:louo@example.com", 
                "name": "louo", 
                "objectType": "Agent"
            }, 
            "actor": {
                "member": [
                    {
                        "mbox": "mailto:blobby@example.com", 
                        "name": "blobby", 
                        "objectType": "Agent"
                    }, 
                    {
                        "mbox": "mailto:timmy@example.com", 
                        "name": "timmy", 
                        "objectType": "Agent"
                    }, 
                    {
                        "mbox": "mailto:tom@example.com", 
                        "name": "tom", 
                        "objectType": "Agent"
                    }
                ], 
                "name": "the tourists", 
                "objectType": "Group"
            },
            "verb": {
                "id": "http://imaginarium.adlnet.org/xapi/verbs/sighted", 
                "display": {
                    "en-US": "sighted"
                }
            },
            "context": {
                "contextActivities": {
                    "parent": {
                        "id": "act:imaginarium.adlnet.org/xapi/imaginarium"
                    }
                }
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        param = {"agent":{"mbox":"mailto:adllrsdevs@example.com"}}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        count = len(Statement.objects.filter(actor__mbox=param['agent']['mbox']))
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertEqual(len(stmts), count)
        for s in stmts:
            self.assertEqual(s['actor']['mbox'], param['agent']['mbox'])

    def test_related_agents_filter(self):
        stmt = {
            "timestamp": "2013-04-10 21:25:59.583000+00:00", 
            "object": {
                "mbox": "mailto:louo@example.com", 
                "name": "louo", 
                "objectType": "Agent"
            }, 
            "actor": {
                "member": [
                    {
                        "mbox": "mailto:blobby@example.com", 
                        "name": "blobby"
                    }, 
                    {
                        "mbox": "mailto:timmy@example.com", 
                        "name": "timmy"
                    }, 
                    {
                        "mbox": "mailto:tom@example.com", 
                        "name": "tom"
                    }
                ], 
                "name": "the tourists", 
                "objectType": "Group"
            },
            "verb": {
                "id": "http://imaginarium.adlnet.org/xapi/verbs/sighted", 
                "display": {
                    "en-US": "sighted"
                }
            },
            "context": {
                "contextActivities": {
                    "parent": {
                        "id": "act:imaginarium.adlnet.org/xapi/imaginarium"
                    }
                }
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        stmt = {
            "verb": {
                "id": "http://special.adlnet.gov/xapi/verbs/started", 
                "display": {
                    "en-US": "started"
                }
            }, 
            "timestamp": "2013-04-11 14:49:25.376782+00:00", 
            "object": {
                "id": "act:github.com/adlnet/ADL_LRS/tree/1.0dev"
            }, 
            "actor": {
                "member": [
                    {
                        "mbox": "mailto:louo@example.com", 
                        "name": "louo"
                    }, 
                    {
                        "mbox": "mailto:tom@example.com", 
                        "name": "tom"
                    }
                ], 
                "mbox": "mailto:adllrsdevs@example.com", 
                "name": "adl lrs developers", 
                "objectType": "Group"
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        stmt = {
            "verb": {
                "id": "http://special.adlnet.gov/xapi/verbs/stopped", 
                "display": {
                    "en-US": "nixed"
                }
            },
            "timestamp": "2013-04-11 23:24:03.603184+00:00", 
            "object": {
                "timestamp": "2013-04-11 23:24:03.578795+00:00", 
                "object": {
                    "id": "act:adlnet.gov/website"
                }, 
                "actor": {
                    "mbox": "mailto:louo@example.com", 
                    "name": "louo"
                }, 
                "verb": {
                    "id": "http://special.adlnet.gov/xapi/verbs/hacked", 
                    "display": {
                        "en-US": "hax0r5"
                    }
                }, 
                "objectType": "SubStatement"
            }, 
            "actor": {
                "mbox": "mailto:timmy@example.com", 
                "name": "timmy"
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        param = {"agent":{"mbox":"mailto:louo@example.com"}}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertEqual(len(stmts), 1)

        param = {"agent":{"mbox":"mailto:louo@example.com"}, "related_agents":True}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertEqual(len(stmts), 3)

    def test_agent_filter_since_and_until(self):
        batch = [
        {
            "timestamp": "2013-04-08 17:51:38.118000+00:00", 
            "object": {
                "id": "act:adlnet.gov/JsTetris_TCAPI"
            }, 
            "actor": {
                "mbox": "mailto:tom@example.com", 
                "name": "tom"
            }, 
            "verb": {
                "id": "http://adlnet.gov/xapi/verbs/attempted", 
                "display": {"en-US": "started"}
            }
        }, 
        {
            "timestamp": "2013-04-08 17:52:31.209000+00:00", 
            "object": {
                "id": "act:adlnet.gov/JsTetris_TCAPI"
            }, 
            "actor": {
                "mbox": "mailto:tom@example.com", 
                "name": "tom"
            }, 
            "verb": {
                "id": "http://adlnet.gov/xapi/verbs/attempted", 
                "display": {"en-US": "started"}
            }
        }, 
        {
            "timestamp": "2013-04-08 20:47:08.626000+00:00", 
            "object": {
                "id": "act:adlnet.gov/JsTetris_TCAPI"
            }, 
            "actor": {
                "mbox": "mailto:tom@example.com", 
                "name": "tom"
            }, 
            "verb": {
                "id": "http://adlnet.gov/xapi/verbs/attempted", 
                "display": {"en-US": "started"}
            }
        }, 
        {
            "timestamp": "2013-04-08 20:47:36.129000+00:00", 
            "object": {
                "id": "act:adlnet.gov/JsTetris_TCAPI/level1"
            }, 
            "actor": {
                "mbox": "mailto:tom@example.com", 
                "name": "tom"
            }, 
            "verb": {
                "id": "http://adlnet.gov/xapi/verbs/passed(to_go_beyond)", 
                "display": {"en-US": "passed"}
            }
        }, 
        {
            "timestamp": "2013-04-08 20:48:50.090000+00:00", 
            "object": {
                "id": "act:adlnet.gov/JsTetris_TCAPI/level2"
            }, 
            "actor": {
                "mbox": "mailto:tom@example.com", 
                "name": "tom"
            },
            "verb": {
                "id": "http://adlnet.gov/xapi/verbs/passed(to_go_beyond)", 
                "display": {"en-US": "passed"}
            }
        }, 
        {
            "timestamp": "2013-04-08 20:49:27.109000+00:00", 
            "object": {
                "id": "act:adlnet.gov/JsTetris_TCAPI/level3"
            }, 
            "actor": {
                "mbox": "mailto:tom@example.com", 
                "name": "tom"
            },
            "verb": {
                "id": "http://adlnet.gov/xapi/verbs/passed(to_go_beyond)", 
                "display": {"en-US": "passed"}
            }
        }]

        response = self.client.post(reverse(views.statements), json.dumps(batch), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        param = {"agent":{"mbox":"mailto:tom@example.com"}}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        # get some time points for since and until
        for s in stmts:
            if param['agent']['mbox'] not in str(s['actor']):
                self.assertEqual(s['object']['objectType'], "StatementRef")
                self.assertTrue(param['agent']['mbox'] in str(Statement.objects.get(statement_id=s['object']['id']).actor.get_agent_json()))
            else:
                self.assertTrue(param['agent']['mbox'] in str(s['actor']))

        cnt_all = len(stmts)
        since = stmts[int(math.floor(len(stmts)/1.5))]['stored']
        until = stmts[int(math.ceil(len(stmts)/3))]['stored']
        since_cnt = int(math.floor(len(stmts)/1.5))
        until_cnt = cnt_all - int(math.ceil(len(stmts)/3))
        since_until_cnt = int(math.floor(len(stmts)/1.5)) - int(math.ceil(len(stmts)/3))
        
        param = {"agent":{"mbox":"mailto:tom@example.com"}, "since": since}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertEqual(len(stmts), since_cnt)
        since_ids=[]
        for s in stmts:
            since_ids.append(s['id'])
            if param['agent']['mbox'] not in str(s['actor']):
                self.assertEqual(s['object']['objectType'], "StatementRef")
                self.assertTrue(param['agent']['mbox'] in str(Statement.objects.get(statement_id=s['object']['id']).actor.get_agent_json()))
            else:
                self.assertTrue(param['agent']['mbox'] in str(s['actor']))

        param = {"agent":{"mbox":"mailto:tom@example.com"}, "until": until}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertEqual(len(stmts), until_cnt)
        until_ids=[]
        for s in stmts:
            until_ids.append(s['id'])
            if param['agent']['mbox'] not in str(s['actor']):
                self.assertEqual(s['object']['objectType'], "StatementRef")
                self.assertTrue(param['agent']['mbox'] in str(Statement.objects.get(statement_id=s['object']['id']).actor.get_agent_json()))
            else:
                self.assertTrue(param['agent']['mbox'] in str(s['actor']))
        same = [x for x in since_ids if x in until_ids]
        self.assertEqual(len(same), since_until_cnt)

        param = {"agent":{"mbox":"mailto:tom@example.com"}, "since": since, "until": until}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertTrue(len(stmts) < cnt_all)
        self.assertEqual(len(stmts), since_until_cnt)
        slice_ids=[]
        for s in stmts:
            slice_ids.append(s['id'])
            if param['agent']['mbox'] not in str(s['actor']):
                self.assertEqual(s['object']['objectType'], "StatementRef")
                self.assertTrue(param['agent']['mbox'] in str(Statement.objects.get(statement_id=s['object']['id']).actor.get_agent_json()))
            else:
                self.assertTrue(param['agent']['mbox'] in str(s['actor']))
        self.assertItemsEqual(slice_ids, same)

    def test_related_agents_filter_until(self):
        stmt = {
            "timestamp": "2013-04-10 21:25:59.583000+00:00", 
            "object": {
                "mbox": "mailto:louo@example.com", 
                "name": "louo", 
                "objectType": "Agent"
            }, 
            "actor": {
                "member": [
                    {
                        "mbox": "mailto:blobby@example.com", 
                        "name": "blobby"
                    }, 
                    {
                        "mbox": "mailto:timmy@example.com", 
                        "name": "timmy"
                    }, 
                    {
                        "mbox": "mailto:tom@example.com", 
                        "name": "tom"
                    }
                ], 
                "name": "the tourists", 
                "objectType": "Group"
            },
            "verb": {
                "id": "http://imaginarium.adlnet.org/xapi/verbs/sighted", 
                "display": {
                    "en-US": "sighted"
                }
            },
            "context": {
                "contextActivities": {
                    "parent": {
                        "id": "act:imaginarium.adlnet.org/xapi/imaginarium"
                    }
                }
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        stmt = {
            "verb": {
                "id": "http://special.adlnet.gov/xapi/verbs/started", 
                "display": {
                    "en-US": "started"
                }
            }, 
            "timestamp": "2013-04-11 14:49:25.376782+00:00", 
            "object": {
                "id": "act:github.com/adlnet/ADL_LRS/tree/1.0dev"
            }, 
            "actor": {
                "member": [
                    {
                        "mbox": "mailto:louo@example.com", 
                        "name": "louo"
                    }, 
                    {
                        "mbox": "mailto:tom@example.com", 
                        "name": "tom"
                    }
                ], 
                "mbox": "mailto:adllrsdevs@example.com", 
                "name": "adl lrs developers", 
                "objectType": "Group"
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        stmt = {
            "verb": {
                "id": "http://special.adlnet.gov/xapi/verbs/stopped", 
                "display": {
                    "en-US": "nixed"
                }
            },
            "timestamp": "2013-04-11 23:24:03.603184+00:00", 
            "object": {
                "timestamp": "2013-04-11 23:24:03.578795+00:00", 
                "object": {
                    "id": "act:adlnet.gov/website"
                }, 
                "actor": {
                    "mbox": "mailto:louo@example.com", 
                    "name": "louo"
                }, 
                "verb": {
                    "id": "http://special.adlnet.gov/xapi/verbs/hacked", 
                    "display": {
                        "en-US": "hax0r5"
                    }
                }, 
                "objectType": "SubStatement"
            }, 
            "actor": {
                "mbox": "mailto:timmy@example.com", 
                "name": "timmy"
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        param = {"agent":{"mbox":"mailto:louo@example.com"}, "related_agents":True}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        for s in stmts:
            if param['agent']['mbox'] not in str(s['actor']):
                if s['object']['objectType'] != "StatementRef":
                    self.assertTrue(param['agent']['mbox'] in str(s))
                else:
                    self.assertEqual(s['object']['objectType'], "StatementRef")
                    refd = Statement.objects.get(statement_id=s['object']['id']).object_return()
                    self.assertTrue(param['agent']['mbox'] in str(refd))
            else:
                self.assertTrue(param['agent']['mbox'] in str(s['actor']))

        cnt_all = len(stmts)

        param = {"agent":{"mbox":"mailto:louo@example.com"}, "related_agents": True, "until": "2013-04-10T00:00Z"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertTrue(len(stmts) < cnt_all)
        until = convert_to_utc(param['until'])
        for s in stmts:
            if param['agent']['mbox'] not in str(s['actor']):
                if s['object']['objectType'] != "StatementRef":
                    self.assertTrue(param['agent']['mbox'] in str(s))
                else:
                    self.assertEqual(s['object']['objectType'], "StatementRef")
                    refd = Statement.objects.get(statement_id=s['object']['id']).object_return()
                    self.assertTrue(param['agent']['mbox'] in str(refd))
            else:
                self.assertTrue(param['agent']['mbox'] in str(s['actor']))
            self.assertTrue(convert_to_utc(s['stored']) < until)

    def test_related_agents_filter_since(self):
        stmts = [{
            "timestamp": "2013-04-10 21:25:59.583000+00:00", 
            "object": {
                "mbox": "mailto:louo@example.com", 
                "name": "louo", 
                "objectType": "Agent"
            }, 
            "actor": {
                "member": [
                    {
                        "mbox": "mailto:blobby@example.com", 
                        "name": "blobby"
                    }, 
                    {
                        "mbox": "mailto:timmy@example.com", 
                        "name": "timmy"
                    }, 
                    {
                        "mbox": "mailto:tom@example.com", 
                        "name": "tom"
                    }
                ], 
                "name": "the tourists", 
                "objectType": "Group"
            },
            "verb": {
                "id": "http://imaginarium.adlnet.org/xapi/verbs/sighted", 
                "display": {
                    "en-US": "sighted"
                }
            },
            "context": {
                "contextActivities": {
                    "parent": {
                        "id": "act:imaginarium.adlnet.org/xapi/imaginarium"
                    }
                }
            }
        },
        {
            "verb": {
                "id": "http://special.adlnet.gov/xapi/verbs/started", 
                "display": {
                    "en-US": "started"
                }
            }, 
            "timestamp": "2013-04-11 14:49:25.376782+00:00", 
            "object": {
                "id": "act:github.com/adlnet/ADL_LRS/tree/1.0dev"
            }, 
            "actor": {
                "member": [
                    {
                        "mbox": "mailto:louo@example.com", 
                        "name": "louo"
                    }, 
                    {
                        "mbox": "mailto:tom@example.com", 
                        "name": "tom"
                    }
                ], 
                "mbox": "mailto:adllrsdevs@example.com", 
                "name": "adl lrs developers", 
                "objectType": "Group"
            }
        },
        {
            "verb": {
                "id": "http://special.adlnet.gov/xapi/verbs/stopped", 
                "display": {
                    "en-US": "nixed"
                }
            },
            "timestamp": "2013-04-11 23:24:03.603184+00:00", 
            "object": {
                "timestamp": "2013-04-11 23:24:03.578795+00:00", 
                "object": {
                    "id": "act:adlnet.gov/website"
                }, 
                "actor": {
                    "mbox": "mailto:louo@example.com", 
                    "name": "louo"
                }, 
                "verb": {
                    "id": "http://special.adlnet.gov/xapi/verbs/hacked", 
                    "display": {
                        "en-US": "hax0r5"
                    }
                }, 
                "objectType": "SubStatement"
            }, 
            "actor": {
                "mbox": "mailto:timmy@example.com", 
                "name": "timmy"
            }
        }]
        response = self.client.post(reverse(views.statements), json.dumps(stmts), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")

        param = {"agent":{"mbox":"mailto:louo@example.com"}, "related_agents":True}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        for s in stmts:
            if param['agent']['mbox'] not in str(s['actor']):
                if s['object']['objectType'] != "StatementRef":
                    self.assertTrue(param['agent']['mbox'] in str(s))
                else:
                    self.assertEqual(s['object']['objectType'], "StatementRef")
                    refd = Statement.objects.get(statement_id=s['object']['id']).object_return()
                    self.assertTrue(param['agent']['mbox'] in str(refd))
            else:
                self.assertTrue(param['agent']['mbox'] in str(s['actor']))

        cnt_all = len(stmts)
        since = stmts[int(math.floor(cnt_all/2))]['stored']
        since_cnt = int(math.floor(cnt_all/2))

        param = {"agent":{"mbox":"mailto:louo@example.com"}, "related_agents": True, "since": since}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertEqual(len(stmts), since_cnt)
        since = convert_to_utc(param['since'])
        for s in stmts:
            if param['agent']['mbox'] not in str(s['actor']):
                if s['object']['objectType'] != "StatementRef":
                    self.assertTrue(param['agent']['mbox'] in str(s))
                else:
                    self.assertEqual(s['object']['objectType'], "StatementRef")
                    refd = Statement.objects.get(statement_id=s['object']['id']).object_return()
                    self.assertTrue(param['agent']['mbox'] in str(refd))
            else:
                self.assertTrue(param['agent']['mbox'] in str(s['actor']))
            self.assertTrue(convert_to_utc(s['stored']) > since)


    def test_since_filter_tz(self):
        stmt1_guid = str(uuid.uuid1())
        stmt1 = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
                "display": {"en-US":"created"}}, "object": {"id":"act:activity"},
                "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"}, "timestamp":"2013-02-02T12:00:00-05:00"})

        param = {"statementId":stmt1_guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = stmt1
        resp = self.client.put(path, stmt_payload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0")
        self.assertEqual(resp.status_code, 204)
        time = "2013-02-02T12:00:32-05:00"
        stmt = Statement.objects.filter(statement_id=stmt1_guid).update(stored=time)

        stmt2_guid = str(uuid.uuid1())
        stmt2 = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
                "display": {"en-US":"created"}}, "object": {"id":"act:activity2"},
                "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"}, "timestamp":"2013-02-02T20:00:00+05:00"})

        param = {"statementId":stmt2_guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = stmt2
        resp = self.client.put(path, stmt_payload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0")
        self.assertEqual(resp.status_code, 204)
        time = "2013-02-02T10:00:32-05:00"
        stmt = Statement.objects.filter(statement_id=stmt2_guid).update(stored=time)

        param = {"since": "2013-02-02T14:00Z"}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))      
        sinceGetResponse = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)

        self.assertEqual(sinceGetResponse.status_code, 200)
        rsp = sinceGetResponse.content
        self.assertIn(stmt1_guid, rsp)
        self.assertIn(stmt2_guid, rsp)

        param2 = {"since": "2013-02-02T16:00Z"}
        path2 = "%s?%s" % (reverse(views.statements), urllib.urlencode(param2))      
        sinceGetResponse2 = self.client.get(path2, X_Experience_API_Version="1.0", Authorization=self.auth)

        self.assertEqual(sinceGetResponse2.status_code, 200)
        rsp2 = sinceGetResponse2.content
        self.assertIn(stmt1_guid, rsp2)
        self.assertNotIn(stmt2_guid, rsp2)

    def test_verb_filter(self):
        theid = str(uuid.uuid1())
        stmt = {
        "id":theid,
        "timestamp": "2013-04-10 21:27:15.613000+00:00", 
        "object": {
            "mbox": "mailto:louo@example.com", 
            "name": "louo",
            "objectType":"Agent"
        }, 
        "actor": {
            "member": [
                {
                    "mbox": "mailto:blobby@example.com", 
                    "name": "blobby"
                }, 
                {
                    "mbox": "mailto:timmy@example.com", 
                    "name": "timmy"
                }, 
                {
                    "mbox": "mailto:tom@example.com", 
                    "name": "tom"
                }
            ], 
            "name": "the tourists", 
            "objectType": "Group"
        }, 
        "verb": {
            "id": "http://special.adlnet.gov/xapi/verbs/high-fived", 
            "display": {"en-US": "high-fived"}
        },
        "context": {
            "contextActivities": {
                "parent": {
                    "id": "act:imaginarium.adlnet.org/xapi/imaginarium"
                }
            }
        }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        stman_id = str(uuid.uuid1())
        stmt = {"id": stman_id,
        "verb": {
            "id": "http://special.adlnet.gov/xapi/verbs/frowned", 
            "display": {
                "en-US": "frowned upon"
            }
        }, 
        
        "timestamp": "2013-04-10 21:28:33.870000+00:00", 
        "object": {
            "id": theid, 
            "objectType": "StatementRef"
        }, 
        "actor": {
            "member": [
                {
                    "mbox": "mailto:mrx@example.com", 
                    "name": "mr x", 
                    "objectType": "Agent"
                }, 
                {
                    "mbox": "mailto:msy@example.com", 
                    "name": "ms y", 
                    "objectType": "Agent"
                }, 
                {
                    "mbox": "mailto:drdre@example.com", 
                    "name": "dr dre", 
                    "objectType": "Agent"
                }
            ], 
            "name": "Managers", 
            "objectType": "Group"
        }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        param = {"verb":"http://special.adlnet.gov/xapi/verbs/high-fived"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertEqual(len(stmts), 2)

        stmt_ref_stmt_ids = [k['object']['id'] for k in stmts if k['object']['objectType']=='StatementRef']
        stmt_ids = [k['id'] for k in stmts if k['object']['objectType']!='StatementRef']
        diffs = set(stmt_ref_stmt_ids) ^ set(stmt_ids)
        self.assertFalse(diffs)

        param = {"agent":{"mbox":"mailto:drdre@example.com"},"verb":"http://special.adlnet.gov/xapi/verbs/high-fived"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertEqual(len(stmts), 0)

    def test_registration_filter(self):
        theid = str(uuid.uuid1())
        stmt = {
        "id":theid,
        "timestamp": "2013-04-10 21:27:15.613000+00:00", 
        "object": {
            "mbox": "mailto:louo@example.com", 
            "name": "louo",
            "objectType":"Agent"
        }, 
        "actor": {
            "member": [
                {
                    "mbox": "mailto:blobby@example.com", 
                    "name": "blobby"
                }, 
                {
                    "mbox": "mailto:timmy@example.com", 
                    "name": "timmy"
                }, 
                {
                    "mbox": "mailto:tom@example.com", 
                    "name": "tom"
                }
            ], 
            "name": "the tourists", 
            "objectType": "Group"
        }, 
        "verb": {
            "id": "http://special.adlnet.gov/xapi/verbs/high-fived", 
            "display": {"en-US": "high-fived"}
        },
        "context": {
            "contextActivities": {
                "parent": {
                    "id": "act:imaginarium.adlnet.org/xapi/imaginarium"
                }
            },
            "registration":"05bb4c1a-9ddb-44a0-ba4f-52ff77811a92"
        }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        stmt = {
            "timestamp": "2013-04-08 17:51:38.118000+00:00", 
            "object": {
                "id": "act:adlnet.gov/JsTetris_TCAPI"
            }, 
            "actor": {
                "mbox": "mailto:tom@example.com", 
                "name": "tom"
            }, 
            "verb": {
                "id": "http://adlnet.gov/xapi/verbs/attempted", 
                "display": {"en-US": "started"}
            },
            "context": {
                "registration":"05bb4c1a-9ddb-44a0-ba4f-52ff77811a91"
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        stmt =         {
        "timestamp": "2013-04-08 21:07:20.392000+00:00", 
        "object": { 
            "id": "act:adlnet.gov/JsTetris_TCAPI", 
            "objectType": "Activity"
        }, 
        "actor": {
            "mbox": "mailto:tom@example.com", 
            "name": "tom"
        }, 
        "verb": {
            "id": "http://adlnet.gov/xapi/verbs/completed", 
            "display": {"en-US": "finished"}
        }, 
        "result": {
            "score": {
                "raw": 1918560.0, 
                "min": 0.0
            }, 
            "extensions": {
                "ext:level": "19", 
                "ext:apm": "241", 
                "ext:lines": "165", 
                "ext:time": "1128"
            }
        },
        "context": {
            "registration":"05bb4c1a-9ddb-44a0-ba4f-52ff77811a91"
        }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        param = {"registration":"05bb4c1a-9ddb-44a0-ba4f-52ff77811a91"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertEqual(len(stmts), 2)

        param = {"registration":"05bb4c1a-9ddb-44a0-ba4f-52ff77811a91","verb":"http://special.adlnet.gov/xapi/verbs/high-fived"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertEqual(len(stmts), 0)

        param = {"registration":"05bb4c1a-9ddb-44a0-ba4f-52ff77811a91","verb":"http://adlnet.gov/xapi/verbs/completed"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertEqual(len(stmts), 1)

        param = {"agent":{"mbox":"mailto:tom@example.com"}, "registration":"05bb4c1a-9ddb-44a0-ba4f-52ff77811a91","verb":"http://adlnet.gov/xapi/verbs/completed"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertEqual(len(stmts), 1)

        param = {"agent":{"mbox":"mailto:louo@example.com"}, "registration":"05bb4c1a-9ddb-44a0-ba4f-52ff77811a91","verb":"http://adlnet.gov/xapi/verbs/completed"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        self.assertEqual(len(stmts), 0)

    def test_activity_filter(self):
        stmt = {
        "timestamp": "2013-04-08 21:05:48.869000+00:00", 
        "object": {
            "id": "act:adlnet.gov/JsTetris_TCAPI/level17", 
            "objectType": "Activity"
        }, 
        "actor": {
            "mbox": "mailto:tom@example.com", 
            "name": "tom",
        }, 
        "verb": {
            "id": "http://adlnet.gov/xapi/verbs/passed(to_go_beyond)", 
            "display": {"en-US": "passed"}
        }, 
        "context": {
            "contextActivities": {
                "grouping": {
                    "id": "act:adlnet.gov/JsTetris_TCAPI"
                }
            }
        }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        stmt = {
            "timestamp": "2013-04-08 21:07:11.459000+00:00", 
            "object": {
                "id": "act:adlnet.gov/JsTetris_TCAPI/level18"
            }, 
            "actor": {
                "mbox": "mailto:tom@example.com", 
                "name": "tom"
            }, 
            "verb": {
                "id": "http://adlnet.gov/xapi/verbs/passed(to_go_beyond)", 
                "display": {"en-US": "passed"}
            }, 
            "result": {
                "score": {
                    "raw": 1918560.0, 
                    "min": 0.0
                }
            }, 
            "context": {
                "contextActivities": {
                    "grouping": {
                        "id": "act:adlnet.gov/JsTetris_TCAPI"
                    }
                }
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        stmt = {
        "timestamp": "2013-04-08 21:07:20.392000+00:00", 
        "object": {
            "definition": {
                "type": "type:media", 
                "name": {
                    "en-US": "Js Tetris - Tin Can Prototype"
                }, 
                "description": {
                    "en-US": "A game of tetris."
                }
            }, 
            "id": "act:adlnet.gov/JsTetris_TCAPI"
        }, 
        "actor": {
            "mbox": "mailto:tom@example.com", 
            "name": "tom"
        }, 
        "verb": {
            "id": "http://adlnet.gov/xapi/verbs/completed", 
            "display": {"en-US": "finished"}
        }, 
        "result": {
            "score": {
                "raw": 1918560.0, 
                "min": 0.0
            }, 
            "extensions": {
                "ext:level": "19", 
                "ext:apm": "241", 
                "ext:lines": "165", 
                "ext:time": "1128"
            }
        }, 
        "context": {
            "contextActivities": {
                "grouping": {
                    "id": "act:adlnet.gov/JsTetris_TCAPI"
                }
            }
        }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        param = {"activity":"act:adlnet.gov/JsTetris_TCAPI"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        for s in stmts:
            if param['activity'] not in str(s['object']['id']):
                self.assertEqual(s['object']['objectType'], "StatementRef")
                self.assertTrue(param['activity'] in str(Statement.objects.get(statement_id=s['object']['id']).object_return()))
            else:
                self.assertEqual(s['object']['id'], param['activity'])

        actcnt = len(stmts)
        self.assertEqual(actcnt, 1)

        param = {"activity":"act:adlnet.gov/JsTetris_TCAPI", "related_activities":True}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']
        for s in stmts:
            if param['activity'] not in str(s):
                self.assertEqual(s['object']['objectType'], "StatementRef")
                self.assertTrue(param['activity'] in str(Statement.objects.get(statement_id=s['object']['id']).object_return()))
            else:
                self.assertIn(param['activity'], str(s))

        self.assertTrue(len(stmts) > actcnt, "stmts(%s) was not greater than actcnt(%s)" % (len(stmts), actcnt))

    def test_no_activity_filter(self):
        stmt = {
        "timestamp": "2013-04-08 21:05:48.869000+00:00", 
        "object": {
            "id": "act:adlnet.gov/JsTetris_TCAPI/level17", 
            "objectType": "Activity"
        }, 
        "actor": {
            "mbox": "mailto:tom@example.com", 
            "name": "tom",
        }, 
        "verb": {
            "id": "http://adlnet.gov/xapi/verbs/passed(to_go_beyond)", 
            "display": {"en-US": "passed"}
        }, 
        "context": {
            "contextActivities": {
                "grouping": {
                    "id": "act:adlnet.gov/JsTetris_TCAPI"
                }
            }
        }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        stmt = {
            "timestamp": "2013-04-08 21:07:11.459000+00:00", 
            "object": {
                "id": "act:adlnet.gov/JsTetris_TCAPI/level18"
            }, 
            "actor": {
                "mbox": "mailto:tom@example.com", 
                "name": "tom"
            }, 
            "verb": {
                "id": "http://adlnet.gov/xapi/verbs/passed(to_go_beyond)", 
                "display": {"en-US": "passed"}
            }, 
            "result": {
                "score": {
                    "raw": 1918560.0, 
                    "min": 0.0
                }
            }, 
            "context": {
                "contextActivities": {
                    "grouping": {
                        "id": "act:adlnet.gov/JsTetris_TCAPI"
                    }
                }
            }
        }
        StMan(stmt, stmt_json=json.dumps(stmt))
        actorGetResponse = self.client.post(reverse(views.statements), 
            {"activity":"http://notarealactivity.com"},
             content_type="application/x-www-form-urlencoded", X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(actorGetResponse.status_code, 200)
        rsp = json.loads(actorGetResponse.content)
        stmts = rsp['statements']
        self.assertEqual(len(stmts), 0)

    def test_format_agent_filter(self):
        stmt = json.dumps({"actor":{"name":"lou wolford", "mbox":"mailto:louwolford@example.com"},
                          "verb":{"id":"http://special.adlnet.gov/xapi/verb/created",
                                  "display":{"en-US":"made"}},
                          "object":{"objectType":"Group","name":"androids","mbox":"mailto:androids@example.com",
                                    "member":[{"name":"Adam Link", "mbox":"mailto:alink@example.com"},
                                              {"name":"Andrew Martin", "mbox":"mailto:amartin@example.com"},
                                              {"name":"Astro Boy", "mbox":"mailto:astroboy@example.com"},
                                              {"name":"C-3PO", "mbox":"mailto:c3po@example.com"},
                                              {"name":"R2 D2", "mbox":"mailto:r2d2@example.com"},
                                              {"name":"Marvin", "mbox":"mailto:marvin@example.com"},
                                              {"name":"Data", "mbox":"mailto:data@example.com"},
                                              {"name":"Mr. Roboto", "mbox":"mailto:mrroboto@example.com"}
                                             ]
                                   },
                          "context":{"instructor":{"name":"Isaac Asimov", "mbox":"mailto:asimov@example.com"},
                                     "team":{"objectType":"Group", "name":"team kick***", 
                                             "member":[{"name":"lou wolford","mbox":"mailto:louwolford@example.com"},
                                                       {"name":"tom creighton", "mbox":"mailto:tomcreighton@example.com"}
                                                      ]
                                             }
                                     }
                         })
        guid = str(uuid.uuid1())
        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        resp = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0")
        self.assertEqual(resp.status_code, 204)
        
        agent_params = ['name', 'mbox', 'objectType']

        param = {"agent":{"mbox":"mailto:louwolford@example.com"}}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)

        stmts = obj['statements']
        # only expecting the one made at the beginning of this test
        stmt_r = stmts[0]
        # remove the stuff the LRS adds
        stmt_r.pop('stored')
        stmt_r.pop('timestamp')
        stmt_r.pop('version')
        stmt_r.pop('id')
        stmt_r.pop('authority')
        orig_stmt = json.loads(stmt)

        self.assertItemsEqual(orig_stmt.keys(), stmt_r.keys())
        self.assertItemsEqual(agent_params, stmt_r['actor'].keys())
        self.assertItemsEqual(orig_stmt['object'].keys(), stmt_r['object'].keys())
        for m in stmt_r['object']['member']:
            self.assertItemsEqual(m.keys(), agent_params)
        self.assertItemsEqual(orig_stmt['context'].keys(), stmt_r['context'].keys())
        self.assertItemsEqual(agent_params, stmt_r['context']['instructor'].keys())
        self.assertItemsEqual(orig_stmt['context']['team'].keys(), stmt_r['context']['team'].keys())
        for m in stmt_r['context']['team']['member']:
            self.assertItemsEqual(m.keys(), agent_params)

        param = {"agent":{"mbox":"mailto:louwolford@example.com"}, "format":"ids"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        stmts = obj['statements']

        agent_id_param = ['mbox']
        group_id_params = ['objectType', "mbox"]
        anon_id_params = ['objectType', "member"]

        # only expecting the one made at the beginning of this test
        stmt_r = stmts[0]
        # remove the stuff the LRS adds
        stmt_r.pop('stored')
        stmt_r.pop('timestamp')
        stmt_r.pop('version')
        stmt_r.pop('id')
        stmt_r.pop('authority')
        orig_stmt = json.loads(stmt)

        self.assertItemsEqual(orig_stmt.keys(), stmt_r.keys())
        self.assertItemsEqual(agent_id_param, stmt_r['actor'].keys())
        self.assertItemsEqual(group_id_params, stmt_r['object'].keys())
        self.assertItemsEqual(orig_stmt['context'].keys(), stmt_r['context'].keys())
        self.assertItemsEqual(agent_id_param, stmt_r['context']['instructor'].keys())
        self.assertItemsEqual(anon_id_params, stmt_r['context']['team'].keys())
        for m in stmt_r['context']['team']['member']:
            self.assertItemsEqual(m.keys(), agent_id_param)

    def test_agent_account(self):
        account = {"homePage":"http://www.adlnet.gov","name":"freakshow"}
        stmt = json.dumps({"actor": {"name": "freakshow", "account":account},
                           "verb":{"id":"http://tom.com/tested"},
                           "object":{"id":"act:tom.com/accountid"}})

        guid = str(uuid.uuid1())
        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        resp = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0")
        self.assertEqual(resp.status_code, 204)

        param = {"agent":{"account":account}}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        ss = obj['statements']
        self.assertEqual(len(ss), 1)
        s = ss[0]
        self.assertEqual(s['id'], guid)
        self.assertEqual(s['actor']['account']['name'], account['name'])
        self.assertEqual(s['actor']['account']['homePage'], account['homePage'])

        
    
    def test_activity_format(self):
        stmt = {"actor":{"name":"chair", "mbox":"mailto:chair@example.com"},
                "verb": {"id": "http://tom.com/tested","display":{"en-US":"tested","es-US":"probado", "fr":"testé"}},
                "object": {"objectType":"Activity", "id":"act:format", 
                           "definition":{"name":{"en-US":"format", "es-US":"formato", "fr":"format"},
                                         "description":{"en-US":"format used to return statement",
                                                        "es-US":"formato utilizado en este statement",
                                                        "fr":"format utilisé pour cette statement"
                                                        },
                                         "type":"type:thing"
                                        }
                          },
                "context": {"contextActivities":{"parent":[{"id":"act:statementfiltertests",
                                                            "definition":{"name":{"en-US":"statement filter", "fr":"statement filter"},
                                                                         "description":{"en-US":"unit tests","fr":"unit tests"},
                                                                         "type":"type:parent-thing"}
                                                          }]
                                                }

                            }
        }

        guid = str(uuid.uuid1())
        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        resp = self.client.put(path, json.dumps(stmt), content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0")
        self.assertEqual(resp.status_code, 204)

        param = {"agent":{"mbox":"mailto:chair@example.com"}, "format":"exact"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)

        exact = obj['statements'][0]
        self.assertEqual(exact['actor']['name'], stmt['actor']['name'])
        self.assertEqual(exact['actor']['mbox'], stmt['actor']['mbox'])
        self.assertEqual(exact['verb']['id'], stmt['verb']['id'])
        self.assertItemsEqual(exact['verb']['display'].keys(), stmt['verb']['display'].keys())
        self.assertEqual(exact['object']['objectType'], stmt['object']['objectType'])
        self.assertEqual(exact['object']['id'], stmt['object']['id'])
        self.assertItemsEqual(exact['object']['definition']['name'].keys(), stmt['object']['definition']['name'].keys())
        self.assertItemsEqual(exact['object']['definition']['description'].keys(), stmt['object']['definition']['description'].keys())
        self.assertEqual(exact['context']['contextActivities']['parent'][0]['id'], stmt['context']['contextActivities']['parent'][0]['id'])
        self.assertItemsEqual(exact['context']['contextActivities']['parent'][0]['definition']['name'].keys(), stmt['context']['contextActivities']['parent'][0]['definition']['name'].keys())
        self.assertItemsEqual(exact['context']['contextActivities']['parent'][0]['definition']['description'].keys(), stmt['context']['contextActivities']['parent'][0]['definition']['description'].keys())
        self.assertEqual(exact['context']['contextActivities']['parent'][0]['definition']['type'], stmt['context']['contextActivities']['parent'][0]['definition']['type'])

        param = {"agent":{"mbox":"mailto:chair@example.com"}, "format":"ids"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        
        ids = obj['statements'][0]
        self.assertNotIn('name', ids['actor'])
        self.assertEqual(ids['actor']['mbox'], stmt['actor']['mbox'])
        self.assertEqual(ids['verb']['id'], stmt['verb']['id'])
        self.assertItemsEqual(ids['verb']['display'].keys(), stmt['verb']['display'].keys())
        self.assertNotIn('objectType', ids['object'])
        self.assertEqual(ids['object']['id'], stmt['object']['id'])
        self.assertNotIn('definition', ids['object'])
        self.assertEqual(ids['context']['contextActivities']['parent'][0]['id'], stmt['context']['contextActivities']['parent'][0]['id'])
        self.assertNotIn('definition', ids['context']['contextActivities']['parent'][0])
        
        param = {"agent":{"mbox":"mailto:chair@example.com"}, "format":"canonical"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        
        canon_enus = obj['statements'][0]
        self.assertEqual(canon_enus['actor']['name'], stmt['actor']['name'])
        self.assertEqual(canon_enus['actor']['mbox'], stmt['actor']['mbox'])
        self.assertEqual(canon_enus['verb']['id'], stmt['verb']['id'])
        self.assertItemsEqual(canon_enus['verb']['display'].keys(), stmt['verb']['display'].keys())
        self.assertEqual(canon_enus['object']['objectType'], stmt['object']['objectType'])
        self.assertEqual(canon_enus['object']['id'], stmt['object']['id'])
        self.assertEqual(len(canon_enus['object']['definition']['name'].keys()), 1)
        self.assertIn(canon_enus['object']['definition']['name'].keys()[0], stmt['object']['definition']['name'].keys())
        self.assertEqual(len(canon_enus['object']['definition']['description'].keys()), 1)
        self.assertIn(canon_enus['object']['definition']['description'].keys()[0], stmt['object']['definition']['description'].keys())
        self.assertEqual(canon_enus['context']['contextActivities']['parent'][0]['id'], stmt['context']['contextActivities']['parent'][0]['id'])
        self.assertEqual(len(canon_enus['context']['contextActivities']['parent'][0]['definition']['name'].keys()), 1)
        self.assertIn(canon_enus['context']['contextActivities']['parent'][0]['definition']['name'].keys()[0], stmt['context']['contextActivities']['parent'][0]['definition']['name'].keys())
        self.assertEqual(len(canon_enus['context']['contextActivities']['parent'][0]['definition']['description'].keys()), 1)
        self.assertIn(canon_enus['context']['contextActivities']['parent'][0]['definition']['description'].keys()[0], stmt['context']['contextActivities']['parent'][0]['definition']['description'].keys())
        self.assertEqual(canon_enus['context']['contextActivities']['parent'][0]['definition']['type'], stmt['context']['contextActivities']['parent'][0]['definition']['type'])

        param = {"agent":{"mbox":"mailto:chair@example.com"}, "format":"canonical"}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, Accept_Language="fr", X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        
        canon_fr = obj['statements'][0]
        self.assertEqual(canon_fr['actor']['name'], stmt['actor']['name'])
        self.assertEqual(canon_fr['actor']['mbox'], stmt['actor']['mbox'])
        self.assertEqual(canon_fr['verb']['id'], stmt['verb']['id'])
        self.assertItemsEqual(canon_fr['verb']['display'].keys(), stmt['verb']['display'].keys())
        self.assertEqual(canon_fr['object']['objectType'], stmt['object']['objectType'])
        self.assertEqual(canon_fr['object']['id'], stmt['object']['id'])
        self.assertEqual(len(canon_fr['object']['definition']['name'].keys()), 1)
        self.assertIn(canon_fr['object']['definition']['name'].keys()[0], stmt['object']['definition']['name'].keys())
        self.assertEqual(len(canon_fr['object']['definition']['description'].keys()), 1)
        self.assertIn(canon_fr['object']['definition']['description'].keys()[0], stmt['object']['definition']['description'].keys())
        self.assertEqual(canon_fr['context']['contextActivities']['parent'][0]['id'], stmt['context']['contextActivities']['parent'][0]['id'])
        self.assertEqual(len(canon_fr['context']['contextActivities']['parent'][0]['definition']['name'].keys()), 1)
        self.assertIn(canon_fr['context']['contextActivities']['parent'][0]['definition']['name'].keys()[0], stmt['context']['contextActivities']['parent'][0]['definition']['name'].keys())
        self.assertEqual(len(canon_fr['context']['contextActivities']['parent'][0]['definition']['description'].keys()), 1)
        self.assertIn(canon_fr['context']['contextActivities']['parent'][0]['definition']['description'].keys()[0], stmt['context']['contextActivities']['parent'][0]['definition']['description'].keys())
        self.assertEqual(canon_fr['context']['contextActivities']['parent'][0]['definition']['type'], stmt['context']['contextActivities']['parent'][0]['definition']['type'])

        self.assertNotEqual(canon_enus['object']['definition']['name'].keys()[0],canon_fr['object']['definition']['name'].keys()[0])
        self.assertNotEqual(canon_enus['object']['definition']['description'].keys()[0],canon_fr['object']['definition']['description'].keys()[0])
        self.assertNotEqual(canon_enus['context']['contextActivities']['parent'][0]['definition']['name'].keys()[0], canon_fr['context']['contextActivities']['parent'][0]['definition']['name'].keys()[0])
        self.assertNotEqual(canon_enus['context']['contextActivities']['parent'][0]['definition']['description'].keys()[0], canon_fr['context']['contextActivities']['parent'][0]['definition']['description'].keys()[0])
        
    def test_voidedStatementId(self):
        stmt = {"actor":{"mbox":"mailto:dog@example.com"},
                "verb":{"id":"http://tom.com/verb/ate"},
                "object":{"id":"act:my/homework"}
        }
        guid = str(uuid.uuid1())
        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        resp = self.client.put(path, json.dumps(stmt), content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0")
        self.assertEqual(resp.status_code, 204)

        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        
        obj = json.loads(r.content)
        self.assertEqual(obj['actor']['mbox'], stmt['actor']['mbox'])
        self.assertEqual(obj['verb']['id'], stmt['verb']['id'])
        self.assertEqual(obj['object']['id'], stmt['object']['id'])
        
        stmtv = {"actor":{"mbox":"mailto:darnhonestparents@example.com"},
                 "verb":{"id":"http://adlnet.gov/expapi/verbs/voided"},
                 "object":{"objectType":"StatementRef","id":guid}
        }
        guidv = str(uuid.uuid1())
        paramv = {"statementId":guidv}
        pathv = "%s?%s" % (reverse(views.statements), urllib.urlencode(paramv))
        respv = self.client.put(pathv, json.dumps(stmtv), content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0")
        self.assertEqual(respv.status_code, 204)

        paramv = {"statementId":guidv}
        pathv = "%s?%s" % (reverse(views.statements),urllib.urlencode(paramv))
        r = self.client.get(pathv, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        objv = json.loads(r.content)
        self.assertEqual(objv['actor']['mbox'], stmtv['actor']['mbox'])
        self.assertEqual(objv['verb']['id'], stmtv['verb']['id'])
        self.assertEqual(objv['object']['id'], stmtv['object']['id'])

        # first statement is voided now... should get a 404 if we try to request it
        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 404)

        # but we can get it using the voidedStatementId param
        param = {"voidedStatementId":guid}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        
        obj = json.loads(r.content)
        self.assertEqual(obj['actor']['mbox'], stmt['actor']['mbox'])
        self.assertEqual(obj['verb']['id'], stmt['verb']['id'])
        self.assertEqual(obj['object']['id'], stmt['object']['id'])

    def test_attachments(self):
        stmt = [{"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test11",
                "display": {"en-US": "A test attachment11"},
                "description": {"en-US": "A test attachment (description)11"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "sha2":""},
                {"usageType": "http://example.com/attachment-usage/test12",
                "display": {"en-US": "A test attachment12"},
                "description": {"en-US": "A test attachment (description)12"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "sha2":""}]},
            {"actor":{"mbox":"mailto:tom2@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads2"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test21",
                "display": {"en-US": "A test attachment21"},
                "description": {"en-US": "A test attachment (description)21"},
                "contentType": "text/plain; charset=utf-8",
                "length": 23,
                "sha2":""},
                {"usageType": "http://example.com/attachment-usage/test22",
                "display": {"en-US": "A test attachment22"},
                "description": {"en-US": "A test attachment (description)22"},
                "contentType": "text/plain; charset=utf-8",
                "length": 23,
                "sha2":""}]}
            ]

        message = MIMEMultipart(boundary="myboundary")
        txt11 = u"This is a text attachment11"
        txtsha11 = hashlib.sha256(txt11).hexdigest()
        stmt[0]['attachments'][0]["sha2"] = str(txtsha11)
        
        txt12 = u"This is a text attachment12"
        txtsha12 = hashlib.sha256(txt12).hexdigest()
        stmt[0]['attachments'][1]['sha2'] = str(txtsha12)

        txt21 = u"This is a text attachment21"
        txtsha21 = hashlib.sha256(txt21).hexdigest()
        stmt[1]['attachments'][0]['sha2'] = str(txtsha21)

        txt22 = u"This is a text attachment22"
        txtsha22 = hashlib.sha256(txt22).hexdigest()
        stmt[1]['attachments'][1]['sha2'] = str(txtsha22)

        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        textdata11 = MIMEText(txt11, 'plain', 'utf-8')
        textdata12 = MIMEText(txt12, 'plain', 'utf-8')
        textdata21 = MIMEText(txt21, 'plain', 'utf-8')
        textdata22 = MIMEText(txt22, 'plain', 'utf-8')
 
        textdata11.add_header('X-Experience-API-Hash', txtsha11)
        textdata12.add_header('X-Experience-API-Hash', txtsha12)
        textdata21.add_header('X-Experience-API-Hash', txtsha21)
        textdata22.add_header('X-Experience-API-Hash', txtsha22)

        message.attach(stmtdata)
        message.attach(textdata11)
        message.attach(textdata12)
        message.attach(textdata21)
        message.attach(textdata22)
        
        r = self.client.post(reverse(views.statements), message.as_string(), content_type="multipart/mixed",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)

        param = {"attachments": True}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r['Content-Type'], 'multipart/mixed')

    def test_attachments_no_payload(self):
        stmt = {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "fileUrl": "http://my/file/url"}]}
        
        response = self.client.post(reverse(views.statements), json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)

        param = {"attachments": True}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r['Content-Type'], 'application/json')
        obj_from_json = json.loads(r.content)
        self.assertIn('statements', obj_from_json.keys())
        self.assertIn('more', obj_from_json.keys())
        self.assertIn('attachments', obj_from_json['statements'][0])

    def test_attachments_no_payload_no_attach_param(self):
        stmt = {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "fileUrl": "http://my/file/url"}]}
        
        response = self.client.post(reverse(views.statements), json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)

        r = self.client.get(reverse(views.statements), X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r['Content-Type'], 'application/json')
        obj_from_json = json.loads(r.content)
        self.assertIn('statements', obj_from_json.keys())
        self.assertIn('more', obj_from_json.keys())
        self.assertIn('attachments', obj_from_json['statements'][0])

    def test_attachments_no_payload_single_stmt_get(self):
        stmt_id = str(uuid.uuid1())
        stmt = {"id": stmt_id,
            "actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "fileUrl": "http://my/file/url"}]}
        
        param = {"statementId": stmt_id}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        response = self.client.put(path, json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 204)

        param["attachments"] = True
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r['Content-Type'], 'application/json')
        obj_from_json = json.loads(r.content)
        self.assertIn('attachments', obj_from_json.keys())

    def test_more_attachments(self):
        settings.SERVER_STMT_LIMIT=2
        stmts =[
            {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads1"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test11",
                "display": {"en-US": "A test attachment11"},
                "description": {"en-US": "A test attachment (description)11"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "fileUrl":"http://my/test/url11"},
                {"usageType": "http://example.com/attachment-usage/test12",
                "display": {"en-US": "A test attachment12"},
                "description": {"en-US": "A test attachment (description)12"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "fileUrl":"http://my/test/url12"}]},
            {"actor":{"mbox":"mailto:tom2@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads2"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test21",
                "display": {"en-US": "A test attachment21"},
                "description": {"en-US": "A test attachment (description)21"},
                "contentType": "text/plain; charset=utf-8",
                "length": 23,
                "fileUrl":"http://my/test/url21"},
                {"usageType": "http://example.com/attachment-usage/test22",
                "display": {"en-US": "A test attachment22"},
                "description": {"en-US": "A test attachment (description)22"},
                "contentType": "text/plain; charset=utf-8",
                "length": 23,
                "fileUrl":"http://my/test/url22"}]},
            {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads3"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test31",
                "display": {"en-US": "A test attachment31"},
                "description": {"en-US": "A test attachment (description)31"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "fileUrl":"http://my/test/url31"},
                {"usageType": "http://example.com/attachment-usage/test32",
                "display": {"en-US": "A test attachment32"},
                "description": {"en-US": "A test attachment (description)32"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "fileUrl":"http://my/test/url32"}]},
            {"actor":{"mbox":"mailto:tom2@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads4"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test41",
                "display": {"en-US": "A test attachment41"},
                "description": {"en-US": "A test attachment (description)41"},
                "contentType": "text/plain; charset=utf-8",
                "length": 23,
                "fileUrl":"http://my/test/url41"},
                {"usageType": "http://example.com/attachment-usage/test42",
                "display": {"en-US": "A test attachment42"},
                "description": {"en-US": "A test attachment (description)42"},
                "contentType": "text/plain; charset=utf-8",
                "length": 23,
                "fileUrl":"http://my/test/url42"}]}
        ]
        response = self.client.post(reverse(views.statements), json.dumps(stmts), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)

        param= {"attachments":True}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r['Content-Type'], 'application/json')
        obj_from_json = json.loads(r.content)
        self.assertEqual(len(obj_from_json['statements']), 2)
        self.assertIn('attachments', obj_from_json['statements'][0].keys())
        self.assertIn('attachments', obj_from_json['statements'][1].keys())        

        resp_url = obj_from_json['more']
        resp_id = resp_url[-32:]

        more_get = self.client.get(reverse(views.statements_more,kwargs={'more_id':resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(more_get.status_code, 200)
        self.assertEqual(more_get['Content-Type'], 'application/json')
        more_obj = json.loads(more_get.content)
        self.assertEqual(len(more_obj['statements']), 2)
        self.assertIn('attachments', more_obj['statements'][0].keys())
        self.assertIn('attachments', more_obj['statements'][1].keys())        

    def test_more_attachments_with_payloads(self):
        settings.SERVER_STMT_LIMIT=2
        stmts =[
            {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads1"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test1",
                "display": {"en-US": "A test attachment11"},
                "description": {"en-US": "A test attachment (description)1"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "sha2":""}]},
            {"actor":{"mbox":"mailto:tom2@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads2"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test2",
                "display": {"en-US": "A test attachment21"},
                "description": {"en-US": "A test attachment (description)2"},
                "contentType": "text/plain; charset=utf-8",
                "length": 23,
                "sha2":""}]},
            {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads3"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test3",
                "display": {"en-US": "A test attachment3"},
                "description": {"en-US": "A test attachment (description)3"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "sha2":""}]},
            {"actor":{"mbox":"mailto:tom2@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads4"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test4",
                "display": {"en-US": "A test attachment4"},
                "description": {"en-US": "A test attachment (description)4"},
                "contentType": "text/plain; charset=utf-8",
                "length": 23,
                "sha2":""}]}
        ]
        message = MIMEMultipart(boundary="myboundary")
        txt1 = u"This is a text attachment1"
        txtsha1 = hashlib.sha256(txt1).hexdigest()
        stmts[0]['attachments'][0]["sha2"] = str(txtsha1)
        
        txt2 = u"This is a text attachment2"
        txtsha2 = hashlib.sha256(txt2).hexdigest()
        stmts[1]['attachments'][0]['sha2'] = str(txtsha2)

        txt3 = u"This is a text attachment3"
        txtsha3 = hashlib.sha256(txt3).hexdigest()
        stmts[2]['attachments'][0]['sha2'] = str(txtsha3)

        txt4 = u"This is a text attachment4"
        txtsha4 = hashlib.sha256(txt4).hexdigest()
        stmts[3]['attachments'][0]['sha2'] = str(txtsha4)

        stmtdata = MIMEApplication(json.dumps(stmts), _subtype="json", _encoder=json.JSONEncoder)
        textdata1 = MIMEText(txt1, 'plain', 'utf-8')
        textdata2 = MIMEText(txt2, 'plain', 'utf-8')
        textdata3 = MIMEText(txt3, 'plain', 'utf-8')
        textdata4 = MIMEText(txt4, 'plain', 'utf-8')
 
        textdata1.add_header('X-Experience-API-Hash', txtsha1)
        textdata2.add_header('X-Experience-API-Hash', txtsha2)
        textdata3.add_header('X-Experience-API-Hash', txtsha3)
        textdata4.add_header('X-Experience-API-Hash', txtsha4)

        message.attach(stmtdata)
        message.attach(textdata1)
        message.attach(textdata2)
        message.attach(textdata3)
        message.attach(textdata4)

        r = self.client.post(reverse(views.statements), message.as_string(), content_type="multipart/mixed",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)

        param= {"attachments":True}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r['Content-Type'], 'multipart/mixed')
        headers_list= [txtsha1, txtsha2, txtsha3,txtsha4]
        payload_list = [u"This is a text attachment1",u"This is a text attachment2",u"This is a text attachment3",u"This is a text attachment4"]
        msg = message_from_string(r.content)
        parts = []

        for part in msg.walk():
            parts.append(part)

        self.assertEqual(parts[0].get('Content-Type'), 'multipart/mixed; boundary="ADL_LRS---------"')
        self.assertEqual(parts[1].get('Content-Type'), 'application/json')
        returned_json = json.loads(parts[1].get_payload())
        self.assertEqual(len(returned_json['statements']), 2)
        resp_url = returned_json['more']
        resp_id = resp_url[-32:]        

        for part in parts[2:]:
            self.assertIn(part._payload, payload_list)
            self.assertIn(part.get("X-Experience-API-Hash"), headers_list)
            self.assertEqual(part.get('Content-Type'), "application/octet-stream")
            self.assertEqual(part.get('Content-Transfer-Encoding'), 'binary')

        more_get = self.client.get(reverse(views.statements_more,kwargs={'more_id':resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(more_get.status_code, 200)
        msg = message_from_string(more_get.content)
        parts = []

        for part in msg.walk():
            parts.append(part)

        self.assertEqual(parts[0].get('Content-Type'), 'multipart/mixed; boundary="ADL_LRS---------"')
        self.assertEqual(parts[1].get('Content-Type'), 'application/json')
        returned_json = json.loads(parts[1].get_payload())
        self.assertEqual(len(returned_json['statements']), 2)

        for part in parts[2:]:
            self.assertIn(part._payload, payload_list)
            self.assertIn(part.get("X-Experience-API-Hash"), headers_list)
            self.assertEqual(part.get('Content-Type'), "application/octet-stream")
            self.assertEqual(part.get('Content-Transfer-Encoding'), 'binary')


    def test_more_attachments_with_payloads_no_attach_param(self):
        settings.SERVER_STMT_LIMIT=2
        stmts =[
            {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads1"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test1",
                "display": {"en-US": "A test attachment11"},
                "description": {"en-US": "A test attachment (description)1"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "sha2":""}]},
            {"actor":{"mbox":"mailto:tom2@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads2"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test2",
                "display": {"en-US": "A test attachment21"},
                "description": {"en-US": "A test attachment (description)2"},
                "contentType": "text/plain; charset=utf-8",
                "length": 23,
                "sha2":""}]},
            {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads3"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test3",
                "display": {"en-US": "A test attachment3"},
                "description": {"en-US": "A test attachment (description)3"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "sha2":""}]},
            {"actor":{"mbox":"mailto:tom2@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads4"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test4",
                "display": {"en-US": "A test attachment4"},
                "description": {"en-US": "A test attachment (description)4"},
                "contentType": "text/plain; charset=utf-8",
                "length": 23,
                "sha2":""}]}
        ]
        message = MIMEMultipart(boundary="myboundary")
        txt1 = u"This is a text attachment1"
        txtsha1 = hashlib.sha256(txt1).hexdigest()
        stmts[0]['attachments'][0]["sha2"] = str(txtsha1)
        
        txt2 = u"This is a text attachment2"
        txtsha2 = hashlib.sha256(txt2).hexdigest()
        stmts[1]['attachments'][0]['sha2'] = str(txtsha2)

        txt3 = u"This is a text attachment3"
        txtsha3 = hashlib.sha256(txt3).hexdigest()
        stmts[2]['attachments'][0]['sha2'] = str(txtsha3)

        txt4 = u"This is a text attachment4"
        txtsha4 = hashlib.sha256(txt4).hexdigest()
        stmts[3]['attachments'][0]['sha2'] = str(txtsha4)

        stmtdata = MIMEApplication(json.dumps(stmts), _subtype="json", _encoder=json.JSONEncoder)
        textdata1 = MIMEText(txt1, 'plain', 'utf-8')
        textdata2 = MIMEText(txt2, 'plain', 'utf-8')
        textdata3 = MIMEText(txt3, 'plain', 'utf-8')
        textdata4 = MIMEText(txt4, 'plain', 'utf-8')
 
        textdata1.add_header('X-Experience-API-Hash', txtsha1)
        textdata2.add_header('X-Experience-API-Hash', txtsha2)
        textdata3.add_header('X-Experience-API-Hash', txtsha3)
        textdata4.add_header('X-Experience-API-Hash', txtsha4)

        message.attach(stmtdata)
        message.attach(textdata1)
        message.attach(textdata2)
        message.attach(textdata3)
        message.attach(textdata4)

        r = self.client.post(reverse(views.statements), message.as_string(), content_type="multipart/mixed",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)

        param= {"attachments":False}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r['Content-Type'], 'application/json')
        obj_from_json = json.loads(r.content)

        resp_url = obj_from_json['more']
        resp_id = resp_url[-32:]

        more_get = self.client.get(reverse(views.statements_more,kwargs={'more_id':resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(more_get.status_code, 200)
        self.assertEqual(more_get['Content-Type'], 'application/json')
         
########NEW FILE########
__FILENAME__ = StatementManagerTests
import uuid
import json
from datetime import datetime
from django.test import TestCase
from lrs import models, views
from lrs.exceptions import ParamError, Forbidden, ParamConflict, IDNotFoundError
from lrs.objects.ActivityManager import ActivityManager
from lrs.objects.StatementManager import StatementManager
from django.core.urlresolvers import reverse
from django.conf import settings
import base64

class StatementManagerTests(TestCase):
    
    @classmethod
    def setUpClass(cls):
        print "\n%s" % __name__

    def setUp(self):
        if not settings.HTTP_AUTH_ENABLED:
            settings.HTTP_AUTH_ENABLED = True
        
        self.username = "tester1"
        self.email = "test1@tester.com"
        self.password = "test"
        self.auth = "Basic %s" % base64.b64encode("%s:%s" % (self.username, self.password))
        form = {"username":self.username, "email":self.email,"password":self.password,"password2":self.password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")

        if settings.HTTP_AUTH_ENABLED:
            response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")

    def test_minimum_stmt(self):
        stmt = StatementManager({"actor":{"objectType":"Agent","mbox": "mailto:tincan@adlnet.gov"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/created","display": {"en-US":"created"}},
            "object":{"id":"http://example.adlnet.gov/tincan/example/simplestatement"}})

        activity = models.Activity.objects.get(id=stmt.model_object.object_activity.id)
        verb = models.Verb.objects.get(id=stmt.model_object.verb.id)
        actor = models.Agent.objects.get(id=stmt.model_object.actor.id)

        self.assertEqual(activity.activity_id, "http://example.adlnet.gov/tincan/example/simplestatement")
        self.assertEqual(actor.mbox, "mailto:tincan@adlnet.gov")
        self.assertEqual(verb.verb_id, "http://adlnet.gov/expapi/verbs/created")


    def test_given_stmtID_stmt(self):
        st_id = str(uuid.uuid1())
        stmt = StatementManager({"statement_id":st_id,
            "actor":{"objectType":"Agent","mbox": "mailto:tincan@adlnet.gov"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/created","display": {"en-US":"created", "en-GB":"made"}},
            "object":{"id":"http://example.adlnet.gov/tincan/example/simplestatement"}})
        activity = models.Activity.objects.get(id=stmt.model_object.object_activity.id)
        verb = models.Verb.objects.get(id=stmt.model_object.verb.id)
        actor = models.Agent.objects.get(id=stmt.model_object.actor.id)
        lang_maps = verb.display

        for k, v in lang_maps.iteritems():
            if k == 'en-GB':
                self.assertEqual(v, 'made')
            elif k == 'en-US':
                self.assertEqual(v, 'created')
        
        self.assertEqual(activity.activity_id, "http://example.adlnet.gov/tincan/example/simplestatement")
        self.assertEqual(actor.mbox, "mailto:tincan@adlnet.gov")
        self.assertEqual(verb.verb_id, "http://adlnet.gov/expapi/verbs/created")
        
        st = models.Statement.objects.get(statement_id=st_id)
        self.assertEqual(st.object_activity.id, activity.id)
        self.assertEqual(st.verb.id, verb.id)

    def test_stmt_ref_as_object(self):
        st_id = str(uuid.uuid1())

        stmt = StatementManager({"actor":{"objectType":"Agent","mbox": "mailto:tincan@adlnet.gov"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/created","display": {"en-US":"created"}},
            "object":{"id":"http://example.adlnet.gov/tincan/example/simplestatement"},
            "statement_id":st_id})

        stmt2 = StatementManager({"actor":{"name":"Example Admin", "mbox":"mailto:admin@example.com"},
            'verb': {"id":"http://adlnet.gov/expapi/verbs/attempted"}, 'object': {'objectType':'StatementRef',
            'id': st_id}})

        stmts = models.Statement.objects.all()
        stmt_refs = models.StatementRef.objects.filter(ref_id=st_id)
        self.assertEqual(len(stmt_refs), 1)
        self.assertEqual(stmt_refs[0].ref_id, st_id)
        self.assertEqual(len(stmts), 2)

    def test_voided_wrong_type(self):
        stmt = json.dumps({"actor":{"name":"Example Admin", "mbox":"mailto:admin@example.com"},
            'verb': {"id":"http://adlnet.gov/expapi/verbs/voided"}, 'object': {'objectType':'Statement', 'id': "12345678-1234-5678-1234-567812345678"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, "The objectType in the statement's object is not valid - Statement")

    def test_no_verb_stmt(self):
        stmt = json.dumps({"actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}, "object": {'id':'act:activity2'}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Statement is missing actor, verb, or object')

    def test_no_object_stmt(self):
        stmt = json.dumps({"actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}, "verb": {"id":"verb:verb/url"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Statement is missing actor, verb, or object')       

    def test_no_actor_stmt(self):
        stmt = json.dumps({"object":{"id":"act:activity_test"}, "verb": {"id":"verb:verb/url"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Statement is missing actor, verb, or object')

    def test_voided_true_stmt(self):
        stmt = json.dumps({'actor':{'objectType':'Agent', 'mbox':'mailto:l@l.com'}, 'verb': {"id":'verb:verb/url/kicked'},'voided': True, 'object': {'id':'act:activity3'}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Invalid field(s) found in Statement - voided')

    def test_result_stmt(self):
        time = "P0Y0M0DT1H311M01S"
        stmt = StatementManager({'actor':{'objectType':'Agent','mbox':'mailto:s@s.com'}, 
            'verb': {"id":"verb:verb/url"},"object": {'id':'act:activity12'},
            "result": {'completion': True, 'success': True, 'response': 'kicked', 'duration': time}})
        activity = models.Activity.objects.get(id=stmt.model_object.object_activity.id)

        self.assertEqual(stmt.model_object.verb.verb_id, "verb:verb/url")
        self.assertEqual(stmt.model_object.object_activity.id, activity.id)

        st = models.Statement.objects.get(id=stmt.model_object.id)
        self.assertEqual(st.object_activity.id, activity.id)

        self.assertEqual(st.result_completion, True)
        self.assertEqual(st.result_success, True)
        self.assertEqual(st.result_response, 'kicked')
        self.assertEqual(st.result_duration, time)

    def test_result_ext_stmt(self):
        time = "P0Y0M0DT1H311M01S"
        stmt = StatementManager({"actor":{'name':'jon',
            'mbox':'mailto:jon@example.com'},'verb': {"id":"verb:verb/url"},"object": {'id':'act:activity13'}, 
            "result": {'completion': True, 'success': True, 'response': 'yes', 'duration': time,
            'extensions':{'ext:key1': 'value1', 'ext:key2':'value2'}}})
        activity = models.Activity.objects.get(id=stmt.model_object.object_activity.id)
        actor = models.Agent.objects.get(id=stmt.model_object.actor.id)
        extKeys = stmt.model_object.result_extensions.keys()
        extVals = stmt.model_object.result_extensions.values()

        self.assertEqual(stmt.model_object.verb.verb_id, "verb:verb/url")
        self.assertEqual(stmt.model_object.object_activity.id, activity.id)
        self.assertEqual(stmt.model_object.actor.id, actor.id)

        st = models.Statement.objects.get(id=stmt.model_object.id)
        self.assertEqual(st.object_activity.id, activity.id)
        self.assertEqual(st.actor.id, actor.id)

        self.assertEqual(st.result_completion, True)
        self.assertEqual(st.result_success, True)
        self.assertEqual(st.result_response, 'yes')
        self.assertEqual(st.result_duration, time)

        self.assertEqual(actor.name, 'jon')
        self.assertEqual(actor.mbox, 'mailto:jon@example.com')
        self.assertEqual(actor.objectType, 'Agent')

        self.assertIn('ext:key1', extKeys)
        self.assertIn('ext:key2', extKeys)
        self.assertIn('value1', extVals)
        self.assertIn('value2', extVals)

    def test_result_score_scaled_up_good(self):
        stmt = json.dumps({"actor":{'objectType':'Agent',
            'name':'jon','mbox':'mailto:jon@example.com'},'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity14'}, "result": {'score':{'scaled':1.0},'completion': True,
            'success': True, 'response': 'yes'}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)

    def test_result_score_scaled_down_good(self):
        stmt = json.dumps({"actor":{'objectType':'Agent',
            'name':'jon','mbox':'mailto:jon@example.com'},'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity14'}, "result": {'score':{'scaled':00.000},'completion': True,
            'success': True, 'response': 'yes'}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)

    def test_result_score_scaled_up_bad(self):
        stmt = json.dumps({"actor":{'objectType':'Agent',
            'name':'jon','mbox':'mailto:jon@example.com'},'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity14'}, "result": {'score':{'scaled':1.01},'completion': True,
            'success': True, 'response': 'yes'}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
                
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Score scaled value in statement result must be between -1 and 1')

    def test_result_score_scaled(self):
        stmt = json.dumps({"actor":{'objectType':'Agent',
            'name':'jon','mbox':'mailto:jon@example.com'},'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity14'}, "result": {'score':{'scaled':-1.00001},'completion': True,
            'success': True, 'response': 'yes'}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
                
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Score scaled value in statement result must be between -1 and 1')

    def test_result_score_raw_up_good(self):
        stmt = json.dumps({"actor":{'objectType':'Agent',
            'name':'jon','mbox':'mailto:jon@example.com'},'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity14'}, "result": {'score':{'raw':1.01,'min':-2.0, 'max':1.01},
            'completion': True,'success': True, 'response': 'yes'}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)

    def test_result_score_raw_down_good(self):
        stmt = json.dumps({"actor":{'objectType':'Agent',
            'name':'jon','mbox':'mailto:jon@example.com'},'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity14'}, "result": {'score':{'raw':-20.0,'min':-20.0, 'max':1.01},
            'completion': True,'success': True, 'response': 'yes'}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)

    def test_result_score_raw_up_bad(self):
        stmt = json.dumps({"actor":{'objectType':'Agent',
            'name':'jon','mbox':'mailto:jon@example.com'},'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity14'}, "result": {'score':{'raw':1.02,'min':-2.0, 'max':1.01},
            'completion': True,'success': True, 'response': 'yes'}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
                
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Score raw value in statement result must be between minimum and maximum')

    def test_result_score_raw_down_bad(self):
        stmt = json.dumps({"actor":{'objectType':'Agent',
            'name':'jon','mbox':'mailto:jon@example.com'},'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity14'}, "result": {'score':{'raw':-2.00001,'min':-2.0, 'max':1.01},
            'completion': True,'success': True, 'response': 'yes'}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
               
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Score raw value in statement result must be between minimum and maximum')

    def test_result_score_min_max_bad(self):
        stmt = json.dumps({"actor":{'objectType':'Agent',
            'name':'jon','mbox':'mailto:jon@example.com'},'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity14'}, "result": {'score':{'raw':1.5,'min':2.0, 'max':1.01},
            'completion': True,'success': True, 'response': 'yes'}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
               
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Score minimum in statement result must be less than the maximum')

    def test_result_score_stmt(self):
        time = "P0Y0M0DT1H311M01S"
        stmt = StatementManager({"actor":{'objectType':'Agent','name':'jon','mbox':'mailto:jon@example.com'},
            'verb': {"id":"verb:verb/url"},"object": {'id':'act:activity14'}, "result": {'score':{'scaled':.95},
            'completion': True, 'success': True, 'response': 'yes', 'duration': time,
            'extensions':{'ext:key1': 'value1', 'ext:key2':'value2'}}})

        activity = models.Activity.objects.get(id=stmt.model_object.object_activity.id)
        actor = models.Agent.objects.get(id=stmt.model_object.actor.id)
        extKeys = stmt.model_object.result_extensions.keys()
        extVals = stmt.model_object.result_extensions.values()

        self.assertEqual(stmt.model_object.verb.verb_id, "verb:verb/url")
        self.assertEqual(stmt.model_object.object_activity.id, activity.id)
        self.assertEqual(stmt.model_object.actor.id, actor.id)

        st = models.Statement.objects.get(id=stmt.model_object.id)
        self.assertEqual(st.object_activity.id, activity.id)
        self.assertEqual(st.actor.id, actor.id)

        self.assertEqual(st.result_completion, True)
        self.assertEqual(st.result_success, True)
        self.assertEqual(st.result_response, 'yes')
        self.assertEqual(st.result_duration, time)

        self.assertEqual(st.result_score_scaled, .95)

        self.assertEqual(activity.activity_id, 'act:activity14')

        self.assertEqual(actor.name, 'jon')
        self.assertEqual(actor.mbox, 'mailto:jon@example.com')

        self.assertIn('ext:key1', extKeys)
        self.assertIn('ext:key2', extKeys)
        self.assertIn('value1', extVals)
        self.assertIn('value2', extVals)


    def test_no_registration_context_stmt(self):
        # expect the LRS to assign a context registration uuid
        stmt = StatementManager({'actor':{'objectType':'Agent','mbox':'mailto:s@s.com'},"verb":{"id":"verb:verb/url"},"object": {'id':'act:activity14'},
                         'context': {'contextActivities': {'other': {'id': 'act:NewActivityID'}}}}).model_object
        self.assertIsNotNone(stmt.context_registration)   

    def test_wrong_statement_type_in_context(self):
        stmt = json.dumps({'actor':{'objectType':'Agent',
            'mbox':'mailto:s@s.com'},'verb': {"id":"verb:verb/url"},"object": {'id':'act:activity16'},
            'context':{'contextActivities': {'other': {'id': 'act:NewActivityID'}},
            'revision': 'foo', 'platform':'bar','language': 'en-US',
            'statement': {'objectType': 'Activity','id': "act:some/act"}}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
                
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, "StatementRef objectType must be set to 'StatementRef'")

    def test_invalid_context_registration(self):
        stmt = json.dumps({'actor':{'objectType':'Agent','mbox':'mailto:s@s.com'},
                'verb': {"id":"verb:verb/url"},"object": {'id':'act:activity15'},
                'context':{'registration': "bbb", 'contextActivities': {'other': {'id': 'act:NewActivityID'}, 'grouping':{'id':'act:GroupID'}},
                'revision': 'foo', 'platform':'bar',
                'language': 'en-US'}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
                
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Context registration - bbb is not a valid UUID')

    def test_context_stmt(self):
        guid = str(uuid.uuid1())
        stmt = StatementManager({'actor':{'objectType':'Agent','mbox':'mailto:s@s.com'},
                'verb': {"id":"verb:verb/url"},"object": {'id':'act:activity15'},
                'context':{'registration': guid, 'contextActivities': {'other': {'id': 'act:NewActivityID'},
                'grouping':{'id':'act:GroupID'}},'revision': 'foo', 'platform':'bar','language': 'en-US'}})

        activity = models.Activity.objects.get(id=stmt.model_object.object_activity.id)
        context_activities = stmt.model_object.statementcontextactivity_set.all()

        self.assertEqual(stmt.model_object.verb.verb_id, "verb:verb/url")
        self.assertEqual(stmt.model_object.object_activity.id, activity.id)

        st = models.Statement.objects.get(id=stmt.model_object.id)
        self.assertEqual(st.object_activity.id, activity.id)
        
        for ca in context_activities:
            if ca.key == 'grouping':
                self.assertEqual(ca.context_activity.all()[0].activity_id, 'act:GroupID')
            elif ca.key == 'other':
                self.assertEqual(ca.context_activity.all()[0].activity_id, 'act:NewActivityID')

        self.assertEqual(st.context_registration, guid)        
        self.assertEqual(st.context_revision, 'foo')
        self.assertEqual(st.context_platform, 'bar')
        self.assertEqual(st.context_language, 'en-US')

    def test_context_activity_list(self):
        guid = str(uuid.uuid1())
        stmt = StatementManager({'actor':{'objectType':'Agent','mbox':'mailto:s@s.com'},
                'verb': {"id":"verb:verb/url"},"object": {'id':'act:activity15'},
                'context':{'registration': guid,
                'contextActivities': {'other': [{'id': 'act:NewActivityID'},{'id':'act:anotherActID'}],
                'grouping':{'id':'act:GroupID'}},
                'revision': 'foo', 'platform':'bar',
                'language': 'en-US'}})
        
        activity = models.Activity.objects.get(id=stmt.model_object.object_activity.id)

        context_activities = models.StatementContextActivity.objects.filter(statement=stmt.model_object)
        self.assertEqual(len(context_activities), 2)
        
        context_activity_keys = [ca.key for ca in context_activities]
        self.assertEqual(len(context_activity_keys), 2)
        self.assertIn('grouping', context_activity_keys)
        self.assertIn('other', context_activity_keys)

        context_activity_activities = []        
        for ca in context_activities:
            for c in ca.context_activity.all():
                context_activity_activities.append(c.activity_id)

        self.assertEqual(len(context_activity_activities), 3)

        self.assertIn('act:NewActivityID', context_activity_activities)
        self.assertIn('act:anotherActID', context_activity_activities)
        self.assertIn('act:GroupID', context_activity_activities)

        self.assertEqual(stmt.model_object.verb.verb_id, "verb:verb/url")
        self.assertEqual(stmt.model_object.object_activity.id, activity.id)

        st = models.Statement.objects.get(id=stmt.model_object.id)
        self.assertEqual(st.object_activity.id, activity.id)

        self.assertEqual(st.context_registration, guid)        
        self.assertEqual(st.context_revision, 'foo')
        self.assertEqual(st.context_platform, 'bar')
        self.assertEqual(st.context_language, 'en-US')

    def test_context_ext_stmt(self):
        guid = str(uuid.uuid1())
        stmt = StatementManager({'actor':{'objectType':'Agent','mbox':'mailto:s@s.com'},
                'verb': {"id":"verb:verb/url"},"object": {'id':'act:activity16'},
                'context':{'registration': guid, 'contextActivities': {'other': {'id': 'act:NewActivityID'}},
                'revision': 'foo', 'platform':'bar','language': 'en-US', 'extensions':{'ext:k1': 'v1', 'ext:k2': 'v2'}}})

        activity = models.Activity.objects.get(id=stmt.model_object.object_activity.id)
        extKeys = stmt.model_object.context_extensions.keys()
        extVals = stmt.model_object.context_extensions.values()
        context_activities = stmt.model_object.statementcontextactivity_set.all()

        self.assertEqual(stmt.model_object.verb.verb_id, "verb:verb/url")
        self.assertEqual(stmt.model_object.object_activity.id, activity.id)

        st = models.Statement.objects.get(id=stmt.model_object.id)
        self.assertEqual(st.object_activity.id, activity.id)

        self.assertEqual(st.context_registration, guid)
        self.assertEqual(context_activities[0].key, 'other')
        self.assertEqual(context_activities[0].context_activity.all()[0].activity_id, 'act:NewActivityID')
        self.assertEqual(st.context_revision, 'foo')
        self.assertEqual(st.context_platform, 'bar')
        self.assertEqual(st.context_language, 'en-US')

        self.assertIn('ext:k1', extKeys)
        self.assertIn('ext:k2', extKeys)
        self.assertIn('v1', extVals)
        self.assertIn('v2', extVals)


    def test_stmtref_in_context_stmt(self):
        stmt_guid = str(uuid.uuid1())

        existing_stmt = StatementManager({'statement_id':stmt_guid, 'actor':{'objectType':'Agent','mbox':'mailto:s@s.com'},
            'verb': {"id":"verb:verb/url/outer"},"object": {'id':'act:activityy16'}})

        guid = str(uuid.uuid1())
        stmt = StatementManager({'actor':{'objectType':'Agent','mbox':'mailto:s@s.com'},
                'verb': {"id":"verb:verb/url"},"object": {'id':'act:activity16'},
                'context':{'registration': guid, 'contextActivities': {'other': {'id': 'act:NewActivityID'}},
                'revision': 'foo', 'platform':'bar','language': 'en-US',
                'statement': {'objectType': 'StatementRef','id': stmt_guid}}})

        activity = models.Activity.objects.get(id=stmt.model_object.object_activity.id)
        stmt_ref = models.StatementRef(ref_id=stmt_guid)
        neststmt = models.Statement.objects.get(statement_id=stmt_ref.ref_id)

        st = models.Statement.objects.get(id=stmt.model_object.id)

        self.assertEqual(st.object_activity.id, activity.id)

        self.assertEqual(st.context_registration, guid)

        self.assertEqual(st.context_revision, 'foo')
        self.assertEqual(st.context_platform, 'bar')
        self.assertEqual(st.context_language, 'en-US')
        self.assertEqual(stmt_ref.ref_id, stmt_guid)
        self.assertEqual(neststmt.verb.verb_id, "verb:verb/url/outer")

    def test_substmt_in_context_stmt(self):
        stmt = json.dumps({'actor':{'objectType':'Agent','mbox':'mailto:s@s.com'},
                'verb': {"id":"verb:verb/url"},"object": {'id':'act:activity16'},
                'context':{'contextActivities': {'other': {'id': 'act:NewActivityID'}},
                'revision': 'foo', 'platform':'bar','language': 'en-US',
                'statement': {'objectType':'SubStatement', 'actor':{'objectType':'Agent',
                'mbox':'mailto:sss@sss.com'},'verb':{'id':'verb:verb/url/nest/nest'},
                'object':{'id':'act://activity/url'}}}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, "StatementRef objectType must be set to 'StatementRef'")

    def test_instructor_in_context_stmt(self):
        stmt_guid = str(uuid.uuid1())
        existing_stmt = StatementManager({'statement_id':stmt_guid, 'actor':{'objectType':'Agent',
            'mbox':'mailto:s@s.com'},'verb': {"id":"verb:verb/url/outer"},"object": {'id':'act:activityy16'}})

        guid = str(uuid.uuid1())
        stmt = StatementManager({'actor':{'objectType':'Agent','mbox':'mailto:jon@example.com', 
            'name':'jon'},'verb': {"id":"verb:verb/url"},"object": {'id':'act:activity17'},
            'context':{'registration': guid, 'instructor': {'objectType':'Agent','name':'jon',
            'mbox':'mailto:jon@example.com'},'contextActivities': {'other': {'id': 'act:NewActivityID'}},
            'revision': 'foo', 'platform':'bar','language': 'en-US', 'statement': {'id': stmt_guid,
            'objectType':'StatementRef'}}})

        activity = models.Activity.objects.get(id=stmt.model_object.object_activity.id)
        stmt_ref = models.StatementRef(ref_id=stmt_guid)
        neststmt = models.Statement.objects.get(statement_id=stmt_ref.ref_id)
        context_activities = stmt.model_object.statementcontextactivity_set.all()

        st = models.Statement.objects.get(id=stmt.model_object.id)

        self.assertEqual(st.object_activity.id, activity.id)

        self.assertEqual(st.context_registration, guid)
        self.assertEqual(context_activities[0].key, 'other')
        self.assertEqual(context_activities[0].context_activity.all()[0].activity_id, 'act:NewActivityID')
        self.assertEqual(st.context_revision, 'foo')
        self.assertEqual(st.context_platform, 'bar')
        self.assertEqual(st.context_language, 'en-US')
        
        self.assertEqual(neststmt.verb.verb_id, "verb:verb/url/outer")
        
        self.assertEqual(st.context_instructor.objectType, 'Agent')
        
        self.assertEqual(st.context_instructor.name, 'jon')
        self.assertEqual(st.context_instructor.mbox, 'mailto:jon@example.com') 


    def test_actor_with_context_stmt(self):
        stmt_guid = str(uuid.uuid1())
        existing_stmt = StatementManager({'statement_id':stmt_guid, 'actor':{'objectType':'Agent',
            'mbox':'mailto:s@s.com'},'verb': {"id":"verb:verb/url/outer"},"object": {'id':'act:activityy16'}})

        guid = str(uuid.uuid1())
        stmt = StatementManager({'actor':{'objectType':'Agent', 'name': 'steve',
            'mbox':'mailto:mailto:s@s.com'},'verb': {"id":"verb:verb/url"},"object": {'id':'act:activity18'},
            'context':{'registration': guid, 'instructor': {'objectType':'Agent','name':'jon',
            'mbox':'mailto:jon@example.com'},'contextActivities': {'other': {'id': 'act:NewActivityID1'}},
            'revision': 'foob', 'platform':'bard','language': 'en-US', 'statement': {'id':stmt_guid,
            "objectType":"StatementRef"}}})

        activity = models.Activity.objects.get(id=stmt.model_object.object_activity.id)
        stmt_ref = models.StatementRef(ref_id=stmt_guid)
        neststmt = models.Statement.objects.get(statement_id=stmt_ref.ref_id)
        st = models.Statement.objects.get(id=stmt.model_object.id)
        context_activities = stmt.model_object.statementcontextactivity_set.all()

        self.assertEqual(st.object_activity.id, activity.id)
        self.assertEqual(st.verb.verb_id, "verb:verb/url" )

        self.assertEqual(st.context_registration, guid)
        self.assertEqual(context_activities[0].key, 'other')
        self.assertEqual(context_activities[0].context_activity.all()[0].activity_id, 'act:NewActivityID1')
        self.assertEqual(st.context_revision, 'foob')
        self.assertEqual(st.context_platform, 'bard')
        self.assertEqual(st.context_language, 'en-US')
        
        self.assertEqual(neststmt.verb.verb_id, "verb:verb/url/outer")
        
        self.assertEqual(st.context_instructor.objectType, 'Agent')
        
        self.assertEqual(st.context_instructor.name, 'jon')
        self.assertEqual(st.context_instructor.mbox, 'mailto:jon@example.com') 


    def test_agent_as_object_with_context_stmt(self):
        stmt_guid = str(uuid.uuid1())
        existing_stmt = StatementManager({'statement_id':stmt_guid, 'actor':{'objectType':'Agent',
            'mbox':'mailto:mailto:s@s.com'},'verb': {"id":"verb:verb/url/outer"},"object": {'id':'act:activityy16'}})

        guid = str(uuid.uuid1())
        stmt = StatementManager(
                {'actor':{
                'objectType':'Agent',
                'mbox':'mailto:l@l.com',
                'name':'lou'
                },
                'object':{
                    'objectType':'Agent', 
                    'name': 'lou', 
                    'mbox':'mailto:l@l.com'
                 }, 
                 'verb': {"id":"verb:verb/url"},
                 'context':{
                    'registration': guid, 
                    'instructor': {
                        'objectType':'Agent',
                        'name':'jon',
                        'mbox':'mailto:jon@example.com'
                    },
                    'contextActivities': {
                        'other': {'id': 'act:NewActivityID1'}
                    }, 
                    'revision': 'foob', 
                    'platform':'bard',
                    'language': 'en-US', 
                    'statement': {
                        'id': stmt_guid,
                        'objectType': 'StatementRef'
                    }
                 }
                }
        )

        stmt_ref = models.StatementRef(ref_id=stmt_guid)
        neststmt = models.Statement.objects.get(statement_id=stmt_ref.ref_id)
        context_activities = stmt.model_object.statementcontextactivity_set.all()

        st = models.Statement.objects.get(id=stmt.model_object.id)

        self.assertEqual(st.verb.verb_id, "verb:verb/url")

        self.assertEqual(st.context_registration, guid)
        self.assertEqual(context_activities[0].key, 'other')
        self.assertEqual(context_activities[0].context_activity.all()[0].activity_id, 'act:NewActivityID1')
        self.assertEqual(st.context_language, 'en-US')
        
        self.assertEqual(neststmt.verb.verb_id, "verb:verb/url/outer")
        
        self.assertEqual(st.context_instructor.objectType, 'Agent')
        
        # Should be jon
        self.assertEqual(st.context_instructor.name, 'jon')
        self.assertEqual(st.context_instructor.mbox, 'mailto:jon@example.com') 


    def test_agent_as_object(self):
        guid = str(uuid.uuid1())
        stmt = StatementManager({'object':{'objectType':'Agent', 'name': 'lulu', 'openID':'id:luluid'}, 
            'verb': {"id":"verb:verb/url"},'actor':{'objectType':'Agent','mbox':'mailto:t@t.com'}})

        st = models.Statement.objects.get(id=stmt.model_object.id)
        agent = models.Agent.objects.get(id=stmt.model_object.object_agent.id)

        self.assertEqual(agent.name, 'lulu')
        self.assertEqual(agent.openID, 'id:luluid')


    def test_unallowed_substmt_field(self):
        stmt = json.dumps({'actor':{'objectType':'Agent','mbox':'mailto:s@s.com'},
            'verb': {"id":"verb:verb/url"}, 'object':{'objectType':'SubStatement',
            'actor':{'objectType':'Agent','mbox':'mailto:ss@ss.com'},'verb': {"id":"verb:verb/url/nest"},
            'object': {'objectType':'activity', 'id':'act:testex.com'},
            'authority':{'objectType':'Agent','mbox':'mailto:s@s.com'}}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Invalid field(s) found in SubStatement - authority')

    def test_nested_substatement(self):
        stmt = json.dumps({'actor':{'objectType':'Agent','mbox':'mailto:s@s.com'},
            'verb': {"id":"verb:verb/url"}, 'object':{'objectType':'SubStatement',
            'actor':{'objectType':'Agent','mbox':'mailto:ss@ss.com'},'verb': {"id":"verb:verb/url/nest"},
            'object': {'objectType':'SubStatement', 'actor':{'objectType':'Agent','mbox':'mailto:sss@sss.com'},
            'verb':{'id':'verb:verb/url/nest/nest'}, 'object':{'id':'act://activity/url'}}}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Cannot nest a SubStatement inside of another SubStatement')        

    def test_substatement_as_object(self):
        guid = str(uuid.uuid1())
        stmt = StatementManager({'actor':{'objectType':'Agent','mbox':'mailto:s@s.com'},
            'verb': {"id":"verb:verb/url"}, 'object':{'objectType':'SubStatement',
            'actor':{'objectType':'Agent','mbox':'mailto:ss@ss.com'},'verb': {"id":"verb:verb/url/nest"},
            'object': {'objectType':'Activity', 'id':'act:testex.com'}, 'result':{'completion': True, 'success': True,
            'response': 'kicked'}, 'context':{'registration': guid,
            'contextActivities': {'other': {'id': 'act:NewActivityID'}},'revision': 'foo', 'platform':'bar',
            'language': 'en-US', 'extensions':{'ext:k1': 'v1', 'ext:k2': 'v2'}}}})

        outer_stmt = models.Statement.objects.get(id=stmt.model_object.id)
        sub_stmt = models.SubStatement.objects.get(id=outer_stmt.object_substatement.id)
        sub_obj = models.Activity.objects.get(id=sub_stmt.object_activity.id)
        sub_act = models.Agent.objects.get(id=sub_stmt.actor.id)

        self.assertEqual(outer_stmt.verb.verb_id, "verb:verb/url")
        self.assertEqual(outer_stmt.actor.mbox, 'mailto:s@s.com')        
        self.assertEqual(sub_stmt.verb.verb_id, "verb:verb/url/nest")
        self.assertEqual(sub_obj.activity_id, 'act:testex.com')
        self.assertEqual(sub_act.mbox, 'mailto:ss@ss.com')
        self.assertEqual(sub_stmt.context_registration, guid)
        self.assertEqual(sub_stmt.result_response, 'kicked')


    def test_group_stmt(self):
        ot = "Group"
        name = "the group SMT"
        mbox = "mailto:the.groupSMT@example.com"
        members = [{"name":"agentA","mbox":"mailto:agentA@example.com"},
                    {"name":"agentB","mbox":"mailto:agentB@example.com"}]
        testagent = {"objectType":ot, "name":name, "mbox":mbox,"member":members}
        
        stmt = StatementManager({"actor":testagent, 'verb': {"id":"verb:verb/url"},"object": {"id":"act:activity5",
            "objectType": "Activity"}})
        activity = models.Activity.objects.get(id=stmt.model_object.object_activity.id)
        actor = models.Agent.objects.get(id=stmt.model_object.actor.id)

        self.assertEqual(stmt.model_object.verb.verb_id, "verb:verb/url")
        self.assertEqual(stmt.model_object.object_activity.id, activity.id)
        self.assertEqual(stmt.model_object.actor.id, actor.id)

        st = models.Statement.objects.get(id=stmt.model_object.id)
        self.assertEqual(st.object_activity.id, activity.id)
        self.assertEqual(st.actor.id, actor.id)

        self.assertEqual(actor.name, name)
        self.assertEqual(actor.mbox, mbox)

    def test_activity_correctresponsepattern(self):
        act1 = ActivityManager({
            'objectType': 'Activity', 'id':'act:foo',
            'definition': {'name': {'en-US':'testname'},'description': {'en-US':'testdesc'}, 
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction',
                'interactionType': 'true-false','correctResponsesPattern': ['true'],
                'extensions': {'ext:key1': 'value1'}}})

        act2 = ActivityManager({
            'objectType': 'Activity', 'id':'act:baz',
            'definition': {'name': {'en-US':'testname2'},'description': {'en-US':'testdesc2'}, 
                'type': 'http://adlnet.gov/expapi/activities/cmi.interaction',
                'interactionType': 'true-false','correctResponsesPattern': ['true'],
                'extensions': {'ext2:key1': 'value1'}}})


        acts = len(models.Activity.objects.all())
        self.assertEqual(acts, 2)
        self.assertIn('true', act1.Activity.activity_definition_crpanswers)
        self.assertIn('true', act2.Activity.activity_definition_crpanswers)

    # Tests if an act from context already exists in a different stmt, if an act from context is the object in the
    # same stmt, and if an act from context doesn't exist anywhere
    def test_context_statement_delete(self):
        guid = str(uuid.uuid1())
        stmt1 = StatementManager({
            'actor':{'objectType':'Agent','mbox':'mailto:a@a.com'},
            'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity'}})
        
        st1_id = str(stmt1.model_object.statement_id)
        stmt2 = StatementManager({
            'actor':{'objectType':'Agent','mbox':'mailto:a@a.com'},
            'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity1'},
            'context':{'registration': guid, 'instructor':{'objectType':'Agent', 'mbox':'mailto:inst@inst.com'},
                'team':{'objectType': 'Group', 'name':'mygroup',
                    'member':[{"name":"agent_in_group","mbox":"mailto:agentingroup@example.com"}]},
                'contextActivities': {'other': [{'id': 'act:activity'},{'id':'act:activity1'}],
                'grouping':{'id':'act:activity2'}},'revision': 'foo', 'platform':'bar','language': 'en-US',
                'extensions':{'ext:key1': 'value1'},
                'statement':{'objectType': 'StatementRef','id':st1_id}}})

        self.assertEqual(len(models.Statement.objects.all()), 2)
        # Team creates a group object and the agent inside of itself
        self.assertEqual(len(models.Agent.objects.all()), 4)
        self.assertEqual(len(models.Verb.objects.all()), 1)
        self.assertEqual(len(models.Activity.objects.all()), 3)

        models.Statement.objects.get(id=stmt2.model_object.id).delete()
        self.assertEqual(len(models.Statement.objects.all()), 1)
        # Agents/activities/verbs are not deleted
        self.assertEqual(len(models.Agent.objects.all()), 4)
        self.assertEqual(len(models.Verb.objects.all()), 1)
        self.assertEqual(len(models.Activity.objects.all()), 3)
        self.assertIn('act:activity', models.Activity.objects.values_list('activity_id', flat=True))

    def test_context_in_another_context_statement_delete(self):
        stmt1 = StatementManager({
            'actor':{'objectType':'Agent','mbox':'mailto:a@a.com'},
            'verb': {"id":"verb:verb/url1"},
            "object": {'id':'act:activity1'},
            'context':{'instructor':{'objectType':'Agent', 'mbox':'mailto:inst@inst.com'},
                'team':{'objectType': 'Group', 'name':'mygroup',
                    'member':[{"name":"agent_in_group","mbox":"mailto:agentingroup@example.com"}]},
                'contextActivities': {'other': [{'id': 'act:activity1'},{'id':'act:activity2'}],
                'grouping':{'id':'act:activity3'}},'revision': 'foo', 'platform':'bar','language': 'en-US',
                'extensions':{'ext:key1': 'value1'}}})
        
        stmt2 = StatementManager({
            'actor':{'objectType':'Agent','mbox':'mailto:a@a.com'},
            'verb': {"id":"verb:verb/url2"},
            "object": {'id':'act:activity4'},
            'context':{'instructor':{'objectType':'Agent', 'mbox':'mailto:inst@inst.com'},
                'team':{'objectType': 'Group', 'name':'mygroup',
                    'member':[{"name":"agent_in_group","mbox":"mailto:agentingroup@example.com"}]},
                'contextActivities': {'other': [{'id': 'act:activity2'},{'id':'act:activity3'}],
                'grouping':{'id':'act:activity5'}},'revision': 'foo', 'platform':'bar','language': 'en-US'}})

        stmt3 = StatementManager({
            'actor':{'objectType':'Agent','mbox':'mailto:a@a.com'},
            'verb': {"id":"verb:verb/url3"},
            "object": {'id':'act:activity1'},
            'context':{'instructor':{'objectType':'Agent', 'mbox':'mailto:three@inst.com'},
                'team':{'objectType': 'Group', 'name':'mygroup',
                    'member':[{"name":"agent_in_group","mbox":"mailto:agentingroup@example.com"}]},
                'contextActivities': {'other': [{'id': 'act:activity6'},{'id':'act:activity5'}],
                'grouping':{'id':'act:activity2'}},'revision': 'three', 'platform':'bar','language': 'en-US'}})

        self.assertEqual(len(models.Activity.objects.all()), 6)
        self.assertEqual(len(models.Agent.objects.all()), 7)
        self.assertEqual(len(models.Verb.objects.all()), 3)
        self.assertEqual(len(models.StatementContextActivity.objects.all()), 6)
        self.assertEqual(len(models.Statement.objects.all()), 3)

        models.Statement.objects.get(id=stmt3.model_object.id).delete()
        # Agents/activities/verbs are not deleted
        self.assertEqual(len(models.Activity.objects.all()), 6)
        self.assertEqual(len(models.Agent.objects.all()), 7)        
        self.assertEqual(len(models.Verb.objects.all()), 3)
        self.assertEqual(len(models.StatementContextActivity.objects.all()), 4)
        self.assertEqual(len(models.Statement.objects.all()), 2)

        models.Statement.objects.get(id=stmt2.model_object.id).delete()
        self.assertEqual(len(models.Activity.objects.all()), 6)
        self.assertEqual(len(models.Agent.objects.all()), 7)        
        self.assertEqual(len(models.Verb.objects.all()), 3)
        self.assertEqual(len(models.StatementContextActivity.objects.all()), 2)
        self.assertEqual(len(models.Statement.objects.all()), 1)

        models.Statement.objects.get(id=stmt1.model_object.id).delete()
        self.assertEqual(len(models.Activity.objects.all()), 6)
        self.assertEqual(len(models.Agent.objects.all()), 7)        
        self.assertEqual(len(models.Verb.objects.all()), 3)
        self.assertEqual(len(models.StatementContextActivity.objects.all()), 0)
        self.assertEqual(len(models.Statement.objects.all()), 0)

    def test_simple_statement_delete(self):
        stmt1 = StatementManager({
            'actor':{'objectType':'Agent','mbox':'mailto:a@a.com'},
            'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity1'}})
        
        stmt2 = StatementManager({
            'actor':{'objectType':'Agent','mbox':'mailto:b@b.com'},
            'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity1'}})

        self.assertEqual(len(models.Agent.objects.all()), 2)
        self.assertEqual(len(models.Activity.objects.all()), 1)
        self.assertEqual(len(models.Verb.objects.all()), 1)
        self.assertEqual(len(models.Statement.objects.all()), 2)

        models.Statement.objects.get(id=stmt2.model_object.id).delete()

        self.assertEqual(len(models.Agent.objects.all()), 2)
        self.assertEqual(len(models.Activity.objects.all()), 1)
        self.assertEqual(len(models.Verb.objects.all()), 1)
        self.assertEqual(len(models.Statement.objects.all()), 1)
        self.assertEqual(models.Statement.objects.all()[0].id, stmt1.model_object.id)

    def test_more_conacts_delete(self):
        stmt1 = StatementManager({
            'actor':{'objectType':'Agent','mbox':'mailto:a@a.com'},
            'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity1'}})

        stmt2 = StatementManager({
            'actor':{'objectType':'Agent','mbox':'mailto:a@a.com'},
            'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity2'},
            'context':{'instructor':{'objectType':'Agent', 'mbox':'mailto:inst@inst.com'},
                'contextActivities': {'other': {'id': 'act:activity1'}},'revision': 'foo', 'platform':'bar',
                'language': 'en-US'}})

        self.assertEqual(len(models.Agent.objects.all()), 2)
        self.assertEqual(len(models.Activity.objects.all()), 2)
        self.assertEqual(len(models.Verb.objects.all()), 1)
        self.assertEqual(len(models.Statement.objects.all()), 2)

        models.Statement.objects.get(id=stmt2.model_object.id).delete()

        self.assertEqual(len(models.Agent.objects.all()), 2)
        self.assertEqual(len(models.Activity.objects.all()), 2)
        self.assertEqual(len(models.Verb.objects.all()), 1)
        self.assertEqual(len(models.Statement.objects.all()), 1)

    def test_activity_also_in_conact(self):
        stmt1 = StatementManager({
            'actor':{'objectType':'Agent','mbox':'mailto:a@a.com'},
            'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity1'},
            'context':{'instructor':{'objectType':'Agent', 'mbox':'mailto:inst@inst.com'},
                'contextActivities': {'other': {'id': 'act:activity2'}},'revision': 'foo', 'platform':'bar',
                'language': 'en-US'}})

        stmt2 = StatementManager({
            'actor':{'objectType':'Agent','mbox':'mailto:a@a.com'},
            'verb': {"id":"verb:verb/url"},
            "object": {'id':'act:activity2'}})

        self.assertEqual(len(models.Agent.objects.all()), 2)
        self.assertEqual(len(models.Activity.objects.all()), 2)
        self.assertEqual(len(models.Verb.objects.all()), 1)
        self.assertEqual(len(models.Statement.objects.all()), 2)

        models.Statement.objects.get(id=stmt2.model_object.id).delete()

        self.assertEqual(len(models.Agent.objects.all()), 2)
        self.assertEqual(len(models.Activity.objects.all()), 2)
        self.assertEqual(len(models.Verb.objects.all()), 1)
        self.assertEqual(len(models.Statement.objects.all()), 1)


        agents = models.Agent.objects.values_list('mbox', flat=True)
        self.assertIn('mailto:a@a.com', agents)
        self.assertIn('mailto:inst@inst.com', agents)
        
        acts = models.Activity.objects.values_list('activity_id', flat=True)
        self.assertIn('act:activity1', acts)
        self.assertIn('act:activity2', acts)
        self.assertEqual(models.Verb.objects.all()[0].verb_id, 'verb:verb/url')
        self.assertEqual(models.Statement.objects.all()[0].id, stmt1.model_object.id)

    def test_sub_delete(self):
        stmt1 = StatementManager(
            {"actor":{"objectType":"Agent","mbox":"mailto:out@out.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/1"},
            "object":{"objectType":"SubStatement",
                "actor":{"objectType":"Agent","mbox":"mailto:sub@sub.com"},
                "verb": {"id":"verb:verb/url/nest1"},
                "object": {"objectType":"Activity", "id":"act:subactivity1"},
                "result":{"completion": True, "success": True,"response": "kicked"},
                "context":{"contextActivities": {"other": {"id": "act:subconactivity1"}},
                    'team':{'objectType': 'Group', 'name':'conteamgroup',
                    'member':[{"name":"agent_in_conteamgroup","mbox":"mailto:actg@actg.com"}]},"revision": "foo",
                    "platform":"bar","language": "en-US","extensions":{"ext:k1": "v1", "ext:k2": "v2"}}}})

        stmt2 = StatementManager(
            {"actor": {"objectType": "Agent", "mbox": "mailto:ref@ref.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/2"},
            "object":{"objectType": "StatementRef", "id":str(stmt1.model_object.statement_id)}})

        stmt3 = StatementManager(
            {"actor": {"objectType": "Agent", "mbox": "mailto:norm@norm.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/3"},
            "object":{"objectType": "Activity", "id":"act:activity1"}})

        stmt4 = StatementManager({
            'actor':{'objectType':'Agent','mbox':'mailto:a@a.com'},
            'verb': {"id":"http://adlnet.gov/expapi/verbs/4"},
            "object": {'id':'act:activity2'},
            'context':{'instructor':{'objectType':'Agent', 'mbox':'mailto:inst@inst.com'},
                'contextActivities': {'other': {'id': 'act:conactivity1'}},'revision': 'foo', 'platform':'bar',
                'language': 'en-US', 'statement':{'objectType': 'StatementRef',
                'id':str(stmt3.model_object.statement_id)}}})


        self.assertEqual(len(models.Statement.objects.all()), 4)
        self.assertEqual(len(models.Agent.objects.all()), 8)
        self.assertEqual(len(models.Activity.objects.all()), 5)
        self.assertEqual(len(models.Verb.objects.all()), 5)
        self.assertEqual(len(models.SubStatement.objects.all()), 1)
        self.assertEqual(len(models.StatementRef.objects.all()), 1)
        self.assertEqual(len(models.StatementContextActivity.objects.all()), 1)
        self.assertEqual(len(models.SubStatementContextActivity.objects.all()), 1)
        models.Statement.objects.get(id=stmt4.model_object.id).delete()

        self.assertEqual(len(models.Statement.objects.all()), 3)
        self.assertEqual(len(models.Agent.objects.all()), 8)
        self.assertEqual(len(models.Activity.objects.all()), 5)
        self.assertEqual(len(models.Verb.objects.all()), 5)
        self.assertEqual(len(models.SubStatement.objects.all()), 1)
        self.assertEqual(len(models.StatementRef.objects.all()), 1)
        self.assertEqual(len(models.StatementContextActivity.objects.all()), 0)
        self.assertEqual(len(models.SubStatementContextActivity.objects.all()), 1)
        models.Statement.objects.get(id=stmt3.model_object.id).delete()

        self.assertEqual(len(models.Statement.objects.all()), 2)
        self.assertEqual(len(models.Agent.objects.all()), 8)
        self.assertEqual(len(models.Activity.objects.all()), 5)
        self.assertEqual(len(models.Verb.objects.all()), 5)
        self.assertEqual(len(models.SubStatement.objects.all()), 1)
        self.assertEqual(len(models.StatementRef.objects.all()), 1)
        self.assertEqual(len(models.StatementContextActivity.objects.all()), 0)
        self.assertEqual(len(models.SubStatementContextActivity.objects.all()), 1)
        models.Statement.objects.get(id=stmt2.model_object.id).delete()

        self.assertEqual(len(models.Statement.objects.all()), 1)
        self.assertEqual(len(models.Agent.objects.all()), 8)
        self.assertEqual(len(models.Activity.objects.all()), 5)
        self.assertEqual(len(models.Verb.objects.all()), 5)
        self.assertEqual(len(models.SubStatement.objects.all()), 1)
        self.assertEqual(len(models.StatementRef.objects.all()), 0)
        self.assertEqual(len(models.StatementContextActivity.objects.all()), 0)
        self.assertEqual(len(models.SubStatementContextActivity.objects.all()), 1)
        models.Statement.objects.get(id=stmt1.model_object.id).delete()

        self.assertEqual(len(models.Statement.objects.all()), 0)
        self.assertEqual(len(models.Agent.objects.all()), 8)
        self.assertEqual(len(models.Activity.objects.all()), 5)
        self.assertEqual(len(models.Verb.objects.all()), 5)
        self.assertEqual(len(models.SubStatement.objects.all()), 0)
        self.assertEqual(len(models.StatementRef.objects.all()), 0)
        self.assertEqual(len(models.StatementContextActivity.objects.all()), 0)
        self.assertEqual(len(models.SubStatementContextActivity.objects.all()), 0)

########NEW FILE########
__FILENAME__ = StatementsMoreTests
import os
from django.test import TestCase
from django.core.urlresolvers import reverse
from lrs import views, models
import json
import base64
import uuid
from datetime import datetime, timedelta
from django.utils.timezone import utc
import time
from lrs.util import retrieve_statement
from django.conf import settings

class StatementsMoreTests(TestCase):

    @classmethod
    def setUpClass(cls):
        print "\n%s" % __name__

    def setUp(self):
        settings.SERVER_STMT_LIMIT=10
        if not settings.HTTP_AUTH_ENABLED:
            settings.HTTP_AUTH_ENABLED = True        
        
        self.username = "auth1"
        self.email = "auth1@example.com"
        self.password = "test"
        self.auth = "Basic %s" % base64.b64encode("%s:%s" % (self.username, self.password))
        form = {'username':self.username, 'email':self.email,'password':self.password,'password2':self.password}
        response = self.client.post(reverse(views.register),form)

        self.guid1 = str(uuid.uuid1())
        self.guid2 = str(uuid.uuid1())
        self.guid3 = str(uuid.uuid1())    
        self.guid4 = str(uuid.uuid1())
        self.guid5 = str(uuid.uuid1())
        self.guid6 = str(uuid.uuid1())
        self.guid7 = str(uuid.uuid1())
        self.guid8 = str(uuid.uuid1())    
        self.guid9 = str(uuid.uuid1())
        self.guid10 = str(uuid.uuid1())
        self.guid11 = str(uuid.uuid1())
        self.guid12 = str(uuid.uuid1())
        self.guid13 = str(uuid.uuid1())    
        self.guid14 = str(uuid.uuid1())
        self.guid15 = str(uuid.uuid1())
        self.guid16 = str(uuid.uuid1())
        self.guid17 = str(uuid.uuid1())
        self.guid18 = str(uuid.uuid1())    
        self.guid19 = str(uuid.uuid1())
        self.guid20 = str(uuid.uuid1())
        self.guid21 = str(uuid.uuid1())
        self.guid22 = str(uuid.uuid1())
        self.guid23 = str(uuid.uuid1())    
        self.guid24 = str(uuid.uuid1())
        self.guid25 = str(uuid.uuid1())
        # Context guids
        self.cguid1 = str(uuid.uuid1())
        self.cguid2 = str(uuid.uuid1())    
        self.cguid3 = str(uuid.uuid1())
        self.cguid4 = str(uuid.uuid1())
        self.cguid5 = str(uuid.uuid1())
        self.mytime = str(datetime.utcnow().replace(tzinfo=utc).isoformat())
        stmt_list = []

        self.existStmt1 = {"id":self.guid1,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "verb":{"id":"verb:attempted",
            "display":{"en-US":"attempted", 'en-GB':"altattempted"}},"object": {'objectType': 'Activity',
            'id':'act:foogie','definition': {'name': {'en-US':'testname2', 'en-GB':'altname'},
            'description': {'en-US':'testdesc2','en-GB':'altdesc'}, 'type': 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'interactionType': 'fill-in','correctResponsesPattern': ['answer'],'extensions': {'ext:key1': 'value1',
            'ext:key2': 'value2','ext:key3': 'value3'}}}, "result": {'score':{'scaled':.85}, 'completion': True, 'success': True,
            'response': 'kicked','duration': "P3Y6M4DT12H30M5S", 'extensions':{'ext:key1': 'value1', 'ext:key2':'value2'}},
            'context':{'registration': self.cguid1, 'contextActivities': {'other': {'id': 'act:NewActivityID2'}},
            'revision': 'food', 'platform':'bard','language': 'en-US', 'extensions':{'ext:ckey1': 'cval1',
            'ext:ckey2': 'cval2'}}, 'authority':{'objectType':'Agent','name':'auth1','mbox':'mailto:auth1@example.com'}}  
        stmt_list.append(self.existStmt1)

        self.existStmt2 = {"id":self.guid2,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "verb":{"id":"verb:verb/created",
            "display":{"en-US":"created", 'en-GB':"altcreated"}}, "object": {'objectType': 'Activity',
            'id':'act:foogie','definition': {'name': {'en-US':'testname3'},'description': {'en-US':'testdesc3'},
            'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'fill-in','correctResponsesPattern': ['answers'],
            'extensions': {'ext:key11': 'value11', 'ext:key22': 'value22','ext:key33': 'value33'}}}, 
            "result": {'score':{'scaled':.75}, 'completion': True, 'success': True, 'response': 'shouted',
            'duration': "P3Y6M4DT12H30M5S", 'extensions':{'ext:dkey1': 'dvalue1', 'ext:dkey2':'dvalue2'}},
            'context':{'registration': self.cguid2, 'contextActivities': {'other': {'id': 'act:NewActivityID24'}},
            'revision': 'food', 'platform':'bard','language': 'en-US', 'extensions':{'ext:ckey11': 'cval11',
            'ext:ckey22': 'cval22'}}, 'authority':{'objectType':'Agent','name':'auth1','mbox':'mailto:auth1@example.com'}}      
        stmt_list.append(self.existStmt2)

        self.existStmt3 = {"id":self.guid3,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "verb":{"id":"verb:created",
            "display":{"en-US":"created", 'en-GB':"altcreated"}}, "object": {'objectType': 'Activity',
            'id':'act:foogals','definition': {'name': {'en-US':'testname3'},'description': {'en-US':'testdesc3'},
            'type': 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'interactionType': 'fill-in','correctResponsesPattern': ['answers'],
            'extensions': {'ext:key111': 'value111', 'ext:key222': 'value222','ext:key333': 'value333'}}}, 
            "result": {'score':{'scaled':.79}, 'completion': True, 'success': True, 'response': 'shouted',
            'duration': "P3Y6M4DT12H30M5S", 'extensions':{'ext:dkey1': 'dvalue1', 'ext:dkey2':'dvalue2'}},
            'context':{'registration': self.cguid3, 'contextActivities': {'other': {'id': 'act:NewActivityID23'}},
            'revision': 'food', 'platform':'bard','language': 'en-US','instructor':{'name':'bill',
            'mbox':'mailto:bill@bill.com'} , 'extensions':{'ext:ckey111': 'cval111',
            'ext:ckey222': 'cval222'}}, 'authority':{'objectType':'Agent','name':'auth1','mbox':'mailto:auth1@example.com'}}     
        stmt_list.append(self.existStmt3)

        self.existStmt4 = {"id":self.guid4,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "verb":{"id":"verb:verb/created",
            "display":{"en-US":"created", 'en-GB':"altcreated"}}, "object": {'objectType': 'Activity', 'id':'act:foogal',
            'definition': {'name': {'en-US':'testname3'},'description': {'en-US':'testdesc3'}, 'type': 'http://adlnet.gov/expapi/activities/cmi.interaction',
            'interactionType': 'fill-in','correctResponsesPattern': ['answers'],
            'extensions': {'ext:key111': 'value111', 'ext:key222': 'value222','ext:key333': 'value333'}}}, 
            "result": {'score':{'scaled':.79}, 'completion': True, 'success': True, 'response': 'shouted',
            'duration': "P3Y6M4DT12H30M5S", 'extensions':{'ext:dkey1': 'dvalue1', 'ext:dkey2':'dvalue2'}},
            'context':{'registration': self.cguid4, 'contextActivities': {'other': {'id': 'act:NewActivityID22'}},
            'revision': 'food', 'platform':'bard','language': 'en-US','instructor':{'name':'bill',
            'mbox':'mailto:bill@bill.com'}, 'extensions':{'ext:ckey111': 'cval111',
            'ext:ckey222': 'cval222'}}, 'authority':{'objectType':'Agent','name':'auth1','mbox':'mailto:auth1@example.com'}}
        stmt_list.append(self.existStmt4)

        self.existStmt5 = {"id":self.guid5,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon1',
            'mbox':'mailto:jon1@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt5)

        self.existStmt6 = {"id":self.guid6,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon2',
            'mbox':'mailto:jon2@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt6)

        self.existStmt7 = {"id":self.guid7,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon3',
            'mbox':'mailto:jon3@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt7)

        self.existStmt8 = {"id":self.guid8,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon4',
            'mbox':'mailto:jon4@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt8)

        self.existStmt9 = {"id":self.guid9,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon5',
            'mbox':'mailto:jon5@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt9)

        self.existStmt10 = {"id":self.guid10,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon33',
            'mbox':'mailto:jon33@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}   
        stmt_list.append(self.existStmt10)

        self.existStmt11 = {"id":self.guid11,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon6',
            'mbox':'mailto:jon6@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt11)

        self.existStmt12 = {"id":self.guid12,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon7',
            'mbox':'mailto:jon7@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt12)

        self.existStmt13 = {"id":self.guid13,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon8',
            'mbox':'mailto:jon8@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt13)

        self.existStmt14 = {"id":self.guid14,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon9',
            'mbox':'mailto:jon9@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt14)

        self.existStmt15 = {"id":self.guid15,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon10',
            'mbox':'mailto:jon10@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt15)

        self.existStmt16 = {"id":self.guid16,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon11',
            'mbox':'mailto:jon11@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt16)

        self.existStmt17 = {"id":self.guid17,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon12',
            'mbox':'mailto:jon12@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt17)

        self.existStmt18 = {"id":self.guid18,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon13',
            'mbox':'mailto:jon13@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt18)

        self.existStmt19 = {"id":self.guid19,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon14',
            'mbox':'mailto:jon14@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt19)

        self.existStmt20 = {"id":self.guid20,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon15',
            'mbox':'mailto:jon15@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt20)

        self.existStmt21 = {"id":self.guid21,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon16',
            'mbox':'mailto:jon16@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt21)

        self.existStmt22 = {"id":self.guid22,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon17',
            'mbox':'mailto:jon17@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt22)

        self.existStmt23 = {"id":self.guid23,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon18',
            'mbox':'mailto:jon18@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt23)

        self.existStmt24 = {"id":self.guid24,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon19',
            'mbox':'mailto:jon19@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt24)

        self.existStmt25 = {"id":self.guid25,"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object":{'objectType':'Agent','name':'jon20',
            'mbox':'mailto:jon20@jon.com'},"verb":{"id":"verb:verb/passed",
            "display":{"en-US":"passed", 'en-GB':"altpassed"}}}
        stmt_list.append(self.existStmt25)

        # Post statements
        post_statements = self.client.post(reverse(views.statements), json.dumps(stmt_list),
            content_type="application/json",HTTP_AUTHORIZATION=self.auth, X_Experience_API_Version="1.0.0")

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=1)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid1).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=2)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid2).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=3)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid3).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=4)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid4).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=5)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid5).update(stored=time)

        self.secondTime = str((datetime.utcnow()+timedelta(seconds=6)).replace(tzinfo=utc).isoformat())

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=7)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid6).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=8)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid7).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=9)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid8).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=10)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid9).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=11)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid10).update(stored=time)

        self.thirdTime = str((datetime.utcnow()+timedelta(seconds=12)).replace(tzinfo=utc).isoformat())

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=13)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid11).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=14)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid12).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=15)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid13).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=16)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid14).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=17)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid15).update(stored=time)

        self.fourthTime = str((datetime.utcnow()+timedelta(seconds=18)).replace(tzinfo=utc).isoformat())

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=19)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid16).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=20)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid17).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=21)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid18).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=22)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid19).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=23)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid20).update(stored=time)

        self.fifthTime = str((datetime.utcnow()+timedelta(seconds=24)).replace(tzinfo=utc).isoformat())
 
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=25)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid21).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=26)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid22).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=27)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid23).update(stored=time)

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=28)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid24).update(stored=time)

        self.sixthTime = str((datetime.utcnow()+timedelta(seconds=29)).replace(tzinfo=utc).isoformat())

        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=30)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid25).update(stored=time)

    def tearDown(self):
        settings.SERVER_STMT_LIMIT=100
        attach_folder_path = os.path.join(settings.MEDIA_ROOT, "attachment_payloads")
        for the_file in os.listdir(attach_folder_path):
            file_path = os.path.join(attach_folder_path, the_file)
            try:
                os.unlink(file_path)
            except Exception, e:
                raise e

    def test_unknown_more_id_url(self):
        moreURLGet = self.client.get(reverse(views.statements_more,kwargs={'more_id':'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth )
        self.assertEqual(moreURLGet.status_code, 404)

    def test_not_full_page_stmts(self):
        sincePostResponse = self.client.post(reverse(views.statements), {"until":self.secondTime},
            content_type="application/x-www-form-urlencoded", X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        
        self.assertEqual(sincePostResponse.status_code, 200)
        rsp = sincePostResponse.content
        self.assertIn(self.guid5, rsp)
        self.assertIn(self.guid4, rsp)
        self.assertIn(self.guid3, rsp)
        self.assertIn(self.guid2, rsp)
        self.assertIn(self.guid1, rsp)

        self.assertNotIn(self.guid25, rsp)
        self.assertNotIn(self.guid24, rsp)
        self.assertNotIn(self.guid23, rsp)
        self.assertNotIn(self.guid22, rsp)
        self.assertNotIn(self.guid21, rsp)
        self.assertNotIn(self.guid20, rsp)
        self.assertNotIn(self.guid19, rsp)
        self.assertNotIn(self.guid18, rsp)
        self.assertNotIn(self.guid17, rsp)
        self.assertNotIn(self.guid16, rsp)
        self.assertNotIn(self.guid15, rsp)
        self.assertNotIn(self.guid14, rsp)
        self.assertNotIn(self.guid13, rsp)
        self.assertNotIn(self.guid12, rsp)
        self.assertNotIn(self.guid11, rsp)
        self.assertNotIn(self.guid10, rsp)
        self.assertNotIn(self.guid9, rsp)
        self.assertNotIn(self.guid7, rsp)
        self.assertNotIn(self.guid8, rsp)
        self.assertNotIn(self.guid6, rsp)

    def test_single_full_page_stmts(self):
        sincePostResponse = self.client.post(reverse(views.statements),
            {"until":self.thirdTime},
            content_type="application/x-www-form-urlencoded", X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(sincePostResponse.status_code, 200)
        rsp = sincePostResponse.content
        self.assertIn(self.guid10, rsp)
        self.assertIn(self.guid9, rsp)
        self.assertIn(self.guid8, rsp)
        self.assertIn(self.guid7, rsp)
        self.assertIn(self.guid6, rsp)
        self.assertIn(self.guid5, rsp)
        self.assertIn(self.guid4, rsp)
        self.assertIn(self.guid3, rsp)
        self.assertIn(self.guid2, rsp)
        self.assertIn(self.guid1, rsp)

        self.assertNotIn(self.guid25, rsp)
        self.assertNotIn(self.guid24, rsp)
        self.assertNotIn(self.guid23, rsp)
        self.assertNotIn(self.guid22, rsp)
        self.assertNotIn(self.guid21, rsp)
        self.assertNotIn(self.guid20, rsp)
        self.assertNotIn(self.guid19, rsp)
        self.assertNotIn(self.guid18, rsp)
        self.assertNotIn(self.guid17, rsp)
        self.assertNotIn(self.guid16, rsp)
        self.assertNotIn(self.guid15, rsp)
        self.assertNotIn(self.guid14, rsp)
        self.assertNotIn(self.guid13, rsp)
        self.assertNotIn(self.guid12, rsp)
        self.assertNotIn(self.guid11, rsp)

    def test_single_full_second_not_full_more_stmts_url(self):
        sincePostResponse = self.client.post(reverse(views.statements), {"until":self.fourthTime},
            content_type="application/x-www-form-urlencoded", X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(sincePostResponse.status_code, 200)
        rsp = sincePostResponse.content
        resp_json = json.loads(rsp)
        resp_url = resp_json['more']
        resp_id = resp_url[-32:]

        self.assertIn(self.guid15, rsp)
        self.assertIn(self.guid14, rsp)
        self.assertIn(self.guid13, rsp)
        self.assertIn(self.guid12, rsp)
        self.assertIn(self.guid11, rsp)
        self.assertIn(self.guid10, rsp)
        self.assertIn(self.guid9, rsp)
        self.assertIn(self.guid8, rsp)
        self.assertIn(self.guid7, rsp)
        self.assertIn(self.guid6, rsp)

        self.assertNotIn(self.guid25, rsp)
        self.assertNotIn(self.guid24, rsp)
        self.assertNotIn(self.guid23, rsp)
        self.assertNotIn(self.guid22, rsp)
        self.assertNotIn(self.guid21, rsp)        
        self.assertNotIn(self.guid20, rsp)
        self.assertNotIn(self.guid19, rsp)
        self.assertNotIn(self.guid18, rsp)
        self.assertNotIn(self.guid17, rsp)
        self.assertNotIn(self.guid16, rsp)
        self.assertNotIn(self.guid5, rsp)
        self.assertNotIn(self.guid4, rsp)
        self.assertNotIn(self.guid3, rsp)
        self.assertNotIn(self.guid2, rsp)
        self.assertNotIn(self.guid1, rsp)

        # Simulate user clicking returned 'more' URL
        moreURLGet = self.client.get(reverse(views.statements_more,kwargs={'more_id':resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)

        self.assertEqual(moreURLGet.status_code, 200)
        more_rsp = moreURLGet.content
        self.assertIn(self.guid5, more_rsp)
        self.assertIn(self.guid4, more_rsp)
        self.assertIn(self.guid3, more_rsp)
        self.assertIn(self.guid2, more_rsp)
        self.assertIn(self.guid1, more_rsp)

        self.assertNotIn(self.guid24, more_rsp)
        self.assertNotIn(self.guid23, more_rsp)
        self.assertNotIn(self.guid22, more_rsp)
        self.assertNotIn(self.guid21, more_rsp)
        self.assertNotIn(self.guid20, more_rsp)
        self.assertNotIn(self.guid19, more_rsp)
        self.assertNotIn(self.guid18, more_rsp)
        self.assertNotIn(self.guid17, more_rsp)
        self.assertNotIn(self.guid16, more_rsp)
        self.assertNotIn(self.guid15, more_rsp)
        self.assertNotIn(self.guid14, more_rsp)
        self.assertNotIn(self.guid13, more_rsp)
        self.assertNotIn(self.guid12, more_rsp)
        self.assertNotIn(self.guid11, more_rsp)
        self.assertNotIn(self.guid10, more_rsp)
        self.assertNotIn(self.guid9, more_rsp)
        self.assertNotIn(self.guid8, more_rsp)
        self.assertNotIn(self.guid7, more_rsp)
        self.assertNotIn(self.guid6, more_rsp)        
        self.assertNotIn(self.guid25, more_rsp)

    def test_two_pages_full_more_stmts_url(self):
        sincePostResponse = self.client.post(reverse(views.statements), {"until":self.fifthTime},
            content_type="application/x-www-form-urlencoded", X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(sincePostResponse.status_code, 200)
        rsp = sincePostResponse.content
        resp_json = json.loads(rsp)
        resp_url = resp_json['more']
        resp_id = resp_url[-32:]

        self.assertIn(self.guid20, rsp)
        self.assertIn(self.guid19, rsp)
        self.assertIn(self.guid18, rsp)
        self.assertIn(self.guid17, rsp)
        self.assertIn(self.guid16, rsp)
        self.assertIn(self.guid15, rsp)
        self.assertIn(self.guid14, rsp)
        self.assertIn(self.guid13, rsp)
        self.assertIn(self.guid12, rsp)
        self.assertIn(self.guid11, rsp)

        self.assertNotIn(self.guid25, rsp)
        self.assertNotIn(self.guid24, rsp)
        self.assertNotIn(self.guid23, rsp)
        self.assertNotIn(self.guid22, rsp)
        self.assertNotIn(self.guid21, rsp)        
        self.assertNotIn(self.guid10, rsp)
        self.assertNotIn(self.guid9, rsp)
        self.assertNotIn(self.guid8, rsp)
        self.assertNotIn(self.guid7, rsp)
        self.assertNotIn(self.guid6, rsp)
        self.assertNotIn(self.guid5, rsp)
        self.assertNotIn(self.guid4, rsp)
        self.assertNotIn(self.guid3, rsp)
        self.assertNotIn(self.guid2, rsp)
        self.assertNotIn(self.guid1, rsp)

        # Simulate user clicking returned 'more' URL
        moreURLGet = self.client.get(reverse(views.statements_more,kwargs={'more_id':resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)

        self.assertEqual(moreURLGet.status_code, 200)
        more_rsp = moreURLGet.content
        self.assertIn(self.guid10, more_rsp)
        self.assertIn(self.guid9, more_rsp)
        self.assertIn(self.guid8, more_rsp)
        self.assertIn(self.guid7, more_rsp)
        self.assertIn(self.guid6, more_rsp)
        self.assertIn(self.guid5, more_rsp)
        self.assertIn(self.guid4, more_rsp)
        self.assertIn(self.guid3, more_rsp)
        self.assertIn(self.guid2, more_rsp)
        self.assertIn(self.guid1, more_rsp)

        self.assertNotIn(self.guid24, more_rsp)
        self.assertNotIn(self.guid23, more_rsp)
        self.assertNotIn(self.guid22, more_rsp)
        self.assertNotIn(self.guid21, more_rsp)
        self.assertNotIn(self.guid20, more_rsp)
        self.assertNotIn(self.guid19, more_rsp)
        self.assertNotIn(self.guid18, more_rsp)
        self.assertNotIn(self.guid17, more_rsp)
        self.assertNotIn(self.guid16, more_rsp)
        self.assertNotIn(self.guid15, more_rsp)
        self.assertNotIn(self.guid14, more_rsp)
        self.assertNotIn(self.guid13, more_rsp)
        self.assertNotIn(self.guid12, more_rsp)
        self.assertNotIn(self.guid11, more_rsp)       
        self.assertNotIn(self.guid25, more_rsp)

    def test_two_pages_full_third_not_full_more_stmts_url(self):
        sinceGetResponse = self.client.get(reverse(views.statements), {"until":self.sixthTime, "limit":10},
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(sinceGetResponse.status_code, 200)
        rsp = sinceGetResponse.content
        resp_json = json.loads(rsp)
        resp_url = resp_json['more']
        resp_id = resp_url[-32:]

        self.assertEqual(len(resp_json['statements']), 10)

        self.assertIn(self.guid24, rsp)
        self.assertIn(self.guid23, rsp)
        self.assertIn(self.guid22, rsp)
        self.assertIn(self.guid21, rsp)
        self.assertIn(self.guid20, rsp)
        self.assertIn(self.guid19, rsp)
        self.assertIn(self.guid18, rsp)
        self.assertIn(self.guid17, rsp)
        self.assertIn(self.guid16, rsp)
        self.assertIn(self.guid15, rsp)

        self.assertNotIn(self.guid14, rsp)
        self.assertNotIn(self.guid13, rsp)
        self.assertNotIn(self.guid12, rsp)
        self.assertNotIn(self.guid11, rsp)
        self.assertNotIn(self.guid10, rsp)
        self.assertNotIn(self.guid9, rsp)
        self.assertNotIn(self.guid8, rsp)
        self.assertNotIn(self.guid7, rsp)
        self.assertNotIn(self.guid6, rsp)
        self.assertNotIn(self.guid5, rsp)
        self.assertNotIn(self.guid4, rsp)
        self.assertNotIn(self.guid3, rsp)
        self.assertNotIn(self.guid2, rsp)
        self.assertNotIn(self.guid1, rsp)                
        self.assertNotIn(self.guid25, rsp)

        moreURLGet = self.client.get(reverse(views.statements_more,kwargs={'more_id':resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(moreURLGet.status_code, 200)
        more_rsp = moreURLGet.content
        more_json = json.loads(more_rsp)
        more_resp_url = more_json['more']
        more_resp_id = more_resp_url[-32:]

        self.assertIn(self.guid14, more_rsp)
        self.assertIn(self.guid13, more_rsp)
        self.assertIn(self.guid12, more_rsp)
        self.assertIn(self.guid11, more_rsp)
        self.assertIn(self.guid10, more_rsp)
        self.assertIn(self.guid9, more_rsp)
        self.assertIn(self.guid8, more_rsp)
        self.assertIn(self.guid7, more_rsp)
        self.assertIn(self.guid6, more_rsp)
        self.assertIn(self.guid5, more_rsp)

        self.assertNotIn(self.guid24, more_rsp)
        self.assertNotIn(self.guid23, more_rsp)
        self.assertNotIn(self.guid22, more_rsp)
        self.assertNotIn(self.guid21, more_rsp)
        self.assertNotIn(self.guid20, more_rsp)
        self.assertNotIn(self.guid19, more_rsp)
        self.assertNotIn(self.guid18, more_rsp)
        self.assertNotIn(self.guid17, more_rsp)
        self.assertNotIn(self.guid16, more_rsp)
        self.assertNotIn(self.guid15, more_rsp)
        self.assertNotIn(self.guid4, more_rsp)
        self.assertNotIn(self.guid3, more_rsp)
        self.assertNotIn(self.guid2, more_rsp)
        self.assertNotIn(self.guid1, more_rsp)                
        self.assertNotIn(self.guid25, more_rsp)

        anotherURLGet = self.client.get(reverse(views.statements_more,kwargs={'more_id':more_resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(anotherURLGet.status_code, 200)
        another_rsp = anotherURLGet.content

        self.assertIn(self.guid4, another_rsp)
        self.assertIn(self.guid3, another_rsp)
        self.assertIn(self.guid2, another_rsp)
        self.assertIn(self.guid1, another_rsp)

        self.assertNotIn(self.guid24, another_rsp)
        self.assertNotIn(self.guid23, another_rsp)
        self.assertNotIn(self.guid22, another_rsp)
        self.assertNotIn(self.guid21, another_rsp)
        self.assertNotIn(self.guid20, another_rsp)
        self.assertNotIn(self.guid19, another_rsp)
        self.assertNotIn(self.guid18, another_rsp)
        self.assertNotIn(self.guid17, another_rsp)
        self.assertNotIn(self.guid16, another_rsp)
        self.assertNotIn(self.guid15, another_rsp)
        self.assertNotIn(self.guid14, another_rsp)
        self.assertNotIn(self.guid13, another_rsp)
        self.assertNotIn(self.guid12, another_rsp)
        self.assertNotIn(self.guid11, another_rsp)
        self.assertNotIn(self.guid10, another_rsp)
        self.assertNotIn(self.guid9, another_rsp)                
        self.assertNotIn(self.guid8, another_rsp)
        self.assertNotIn(self.guid7, another_rsp)
        self.assertNotIn(self.guid6, another_rsp)
        self.assertNotIn(self.guid5, another_rsp)
        self.assertNotIn(self.guid25, another_rsp)    
                

    def test_limit_less_than_server_limit(self):
        sinceGetResponse = self.client.get(reverse(views.statements), {"until":self.sixthTime, "limit":8},
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(sinceGetResponse.status_code, 200)
        rsp = sinceGetResponse.content
        resp_json = json.loads(rsp)
        resp_url = resp_json['more']
        resp_id = resp_url[-32:]

        self.assertEqual(len(resp_json['statements']), 8)

        self.assertIn(self.guid24, rsp)
        self.assertIn(self.guid23, rsp)                
        self.assertIn(self.guid22, rsp)
        self.assertIn(self.guid21, rsp)
        self.assertIn(self.guid20, rsp)                
        self.assertIn(self.guid19, rsp)        
        self.assertIn(self.guid18, rsp)
        self.assertIn(self.guid17, rsp)    

        self.assertNotIn(self.guid16, rsp)
        self.assertNotIn(self.guid15, rsp)
        self.assertNotIn(self.guid14, rsp)
        self.assertNotIn(self.guid13, rsp)
        self.assertNotIn(self.guid12, rsp)
        self.assertNotIn(self.guid11, rsp)
        self.assertNotIn(self.guid10, rsp)
        self.assertNotIn(self.guid9, rsp)
        self.assertNotIn(self.guid8, rsp)
        self.assertNotIn(self.guid7, rsp)
        self.assertNotIn(self.guid6, rsp)
        self.assertNotIn(self.guid5, rsp)
        self.assertNotIn(self.guid4, rsp)
        self.assertNotIn(self.guid3, rsp)
        self.assertNotIn(self.guid2, rsp)
        self.assertNotIn(self.guid1, rsp)                
        self.assertNotIn(self.guid25, rsp)

        moreURLGet = self.client.get(reverse(views.statements_more,kwargs={'more_id':resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(moreURLGet.status_code, 200)
        more_rsp = moreURLGet.content
        more_json = json.loads(more_rsp)
        more_resp_url = more_json['more']
        more_resp_id = more_resp_url[-32:]

        self.assertIn(self.guid16, more_rsp)
        self.assertIn(self.guid15, more_rsp)
        self.assertIn(self.guid14, more_rsp)
        self.assertIn(self.guid13, more_rsp)
        self.assertIn(self.guid12, more_rsp)
        self.assertIn(self.guid11, more_rsp)
        self.assertIn(self.guid10, more_rsp)
        self.assertIn(self.guid9, more_rsp)

        self.assertNotIn(self.guid24, more_rsp)
        self.assertNotIn(self.guid23, more_rsp)
        self.assertNotIn(self.guid22, more_rsp)
        self.assertNotIn(self.guid21, more_rsp)
        self.assertNotIn(self.guid20, more_rsp)
        self.assertNotIn(self.guid19, more_rsp)
        self.assertNotIn(self.guid18, more_rsp)
        self.assertNotIn(self.guid17, more_rsp)
        self.assertNotIn(self.guid8, more_rsp)
        self.assertNotIn(self.guid7, more_rsp)
        self.assertNotIn(self.guid6, more_rsp)
        self.assertNotIn(self.guid5, more_rsp)
        self.assertNotIn(self.guid4, more_rsp)
        self.assertNotIn(self.guid3, more_rsp)
        self.assertNotIn(self.guid2, more_rsp)
        self.assertNotIn(self.guid1, more_rsp)                
        self.assertNotIn(self.guid25, more_rsp)

        anotherURLGet = self.client.get(reverse(views.statements_more,kwargs={'more_id':more_resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(anotherURLGet.status_code, 200)
        another_rsp = anotherURLGet.content

        self.assertIn(self.guid8, another_rsp)
        self.assertIn(self.guid7, another_rsp)
        self.assertIn(self.guid6, another_rsp)
        self.assertIn(self.guid5, another_rsp)
        self.assertIn(self.guid4, another_rsp)
        self.assertIn(self.guid3, another_rsp)
        self.assertIn(self.guid2, another_rsp)
        self.assertIn(self.guid1, another_rsp)

        self.assertNotIn(self.guid24, another_rsp)
        self.assertNotIn(self.guid23, another_rsp)
        self.assertNotIn(self.guid22, another_rsp)
        self.assertNotIn(self.guid21, another_rsp)
        self.assertNotIn(self.guid20, another_rsp)
        self.assertNotIn(self.guid19, another_rsp)
        self.assertNotIn(self.guid18, another_rsp)
        self.assertNotIn(self.guid17, another_rsp)
        self.assertNotIn(self.guid16, another_rsp)
        self.assertNotIn(self.guid15, another_rsp)
        self.assertNotIn(self.guid14, another_rsp)
        self.assertNotIn(self.guid13, another_rsp)
        self.assertNotIn(self.guid12, another_rsp)
        self.assertNotIn(self.guid11, another_rsp)
        self.assertNotIn(self.guid10, another_rsp)
        self.assertNotIn(self.guid9, another_rsp)                
        self.assertNotIn(self.guid25, another_rsp)


    def test_limit_same_as_server_limit(self):
        sinceGetResponse = self.client.get(reverse(views.statements), {"until":self.sixthTime, "limit":10},
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)

        self.assertEqual(sinceGetResponse.status_code, 200)
        rsp = sinceGetResponse.content
        resp_json = json.loads(rsp)
        resp_url = resp_json['more']
        resp_id = resp_url[-32:]

        self.assertEqual(len(resp_json['statements']), 10)

        self.assertIn(self.guid24, rsp)
        self.assertIn(self.guid23, rsp)
        self.assertIn(self.guid22, rsp)
        self.assertIn(self.guid21, rsp)
        self.assertIn(self.guid20, rsp)
        self.assertIn(self.guid19, rsp)
        self.assertIn(self.guid18, rsp)
        self.assertIn(self.guid17, rsp)
        self.assertIn(self.guid16, rsp)
        self.assertIn(self.guid15, rsp)

        self.assertNotIn(self.guid14, rsp)
        self.assertNotIn(self.guid13, rsp)
        self.assertNotIn(self.guid12, rsp)
        self.assertNotIn(self.guid11, rsp)
        self.assertNotIn(self.guid10, rsp)
        self.assertNotIn(self.guid9, rsp)
        self.assertNotIn(self.guid8, rsp)
        self.assertNotIn(self.guid7, rsp)
        self.assertNotIn(self.guid6, rsp)
        self.assertNotIn(self.guid5, rsp)
        self.assertNotIn(self.guid4, rsp)
        self.assertNotIn(self.guid3, rsp)
        self.assertNotIn(self.guid2, rsp)
        self.assertNotIn(self.guid1, rsp)                
        self.assertNotIn(self.guid25, rsp)

        moreURLGet = self.client.get(reverse(views.statements_more,kwargs={'more_id':resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(moreURLGet.status_code, 200)
        more_rsp = moreURLGet.content
        more_json = json.loads(more_rsp)
        more_resp_url = more_json['more']
        more_resp_id = more_resp_url[-32:]

        self.assertIn(self.guid14, more_rsp)
        self.assertIn(self.guid13, more_rsp)
        self.assertIn(self.guid12, more_rsp)
        self.assertIn(self.guid11, more_rsp)
        self.assertIn(self.guid10, more_rsp)
        self.assertIn(self.guid9, more_rsp)
        self.assertIn(self.guid8, more_rsp)
        self.assertIn(self.guid7, more_rsp)
        self.assertIn(self.guid6, more_rsp)
        self.assertIn(self.guid5, more_rsp)

        self.assertNotIn(self.guid24, more_rsp)
        self.assertNotIn(self.guid23, more_rsp)
        self.assertNotIn(self.guid22, more_rsp)
        self.assertNotIn(self.guid21, more_rsp)
        self.assertNotIn(self.guid20, more_rsp)
        self.assertNotIn(self.guid19, more_rsp)
        self.assertNotIn(self.guid18, more_rsp)
        self.assertNotIn(self.guid17, more_rsp)
        self.assertNotIn(self.guid16, more_rsp)
        self.assertNotIn(self.guid15, more_rsp)
        self.assertNotIn(self.guid4, more_rsp)
        self.assertNotIn(self.guid3, more_rsp)
        self.assertNotIn(self.guid2, more_rsp)
        self.assertNotIn(self.guid1, more_rsp)                
        self.assertNotIn(self.guid25, more_rsp)

        anotherURLGet = self.client.get(reverse(views.statements_more,kwargs={'more_id':more_resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(anotherURLGet.status_code, 200)
        another_rsp = anotherURLGet.content

        self.assertIn(self.guid4, another_rsp)
        self.assertIn(self.guid3, another_rsp)
        self.assertIn(self.guid2, another_rsp)
        self.assertIn(self.guid1, another_rsp)

        self.assertNotIn(self.guid24, another_rsp)
        self.assertNotIn(self.guid23, another_rsp)
        self.assertNotIn(self.guid22, another_rsp)
        self.assertNotIn(self.guid21, another_rsp)
        self.assertNotIn(self.guid20, another_rsp)
        self.assertNotIn(self.guid19, another_rsp)
        self.assertNotIn(self.guid18, another_rsp)
        self.assertNotIn(self.guid17, another_rsp)
        self.assertNotIn(self.guid16, another_rsp)
        self.assertNotIn(self.guid15, another_rsp)
        self.assertNotIn(self.guid14, another_rsp)
        self.assertNotIn(self.guid13, another_rsp)
        self.assertNotIn(self.guid12, another_rsp)
        self.assertNotIn(self.guid11, another_rsp)
        self.assertNotIn(self.guid10, another_rsp)
        self.assertNotIn(self.guid9, another_rsp)                
        self.assertNotIn(self.guid8, another_rsp)
        self.assertNotIn(self.guid7, another_rsp)
        self.assertNotIn(self.guid6, another_rsp)
        self.assertNotIn(self.guid5, another_rsp)
        self.assertNotIn(self.guid25, another_rsp)    

    def test_limit_more_than_server_limit(self):
        sinceGetResponse = self.client.get(reverse(views.statements), {"until":self.sixthTime, "limit":12},
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(sinceGetResponse.status_code, 200)
        rsp = sinceGetResponse.content
        resp_json = json.loads(rsp)
        resp_url = resp_json['more']
        resp_id = resp_url[-32:]

        self.assertEqual(len(resp_json['statements']), 10)        
        self.assertIn(self.guid24, rsp)
        self.assertIn(self.guid23, rsp)
        self.assertIn(self.guid22, rsp)
        self.assertIn(self.guid21, rsp)
        self.assertIn(self.guid20, rsp)
        self.assertIn(self.guid19, rsp)
        self.assertIn(self.guid18, rsp)
        self.assertIn(self.guid17, rsp)
        self.assertIn(self.guid16, rsp)
        self.assertIn(self.guid15, rsp)

        self.assertNotIn(self.guid14, rsp)
        self.assertNotIn(self.guid13, rsp)
        self.assertNotIn(self.guid12, rsp)
        self.assertNotIn(self.guid11, rsp)
        self.assertNotIn(self.guid10, rsp)
        self.assertNotIn(self.guid9, rsp)
        self.assertNotIn(self.guid8, rsp)
        self.assertNotIn(self.guid7, rsp)
        self.assertNotIn(self.guid6, rsp)
        self.assertNotIn(self.guid5, rsp)
        self.assertNotIn(self.guid4, rsp)
        self.assertNotIn(self.guid3, rsp)
        self.assertNotIn(self.guid2, rsp)
        self.assertNotIn(self.guid1, rsp)                
        self.assertNotIn(self.guid25, rsp)

        moreURLGet = self.client.get(reverse(views.statements_more,kwargs={'more_id':resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(moreURLGet.status_code, 200)
        more_rsp = moreURLGet.content
        more_json = json.loads(more_rsp)
        more_resp_url = more_json['more']
        more_resp_id = more_resp_url[-32:]

        self.assertIn(self.guid14, more_rsp)
        self.assertIn(self.guid13, more_rsp)
        self.assertIn(self.guid12, more_rsp)
        self.assertIn(self.guid11, more_rsp)
        self.assertIn(self.guid10, more_rsp)
        self.assertIn(self.guid9, more_rsp)
        self.assertIn(self.guid8, more_rsp)
        self.assertIn(self.guid7, more_rsp)
        self.assertIn(self.guid6, more_rsp)
        self.assertIn(self.guid5, more_rsp)

        self.assertNotIn(self.guid24, more_rsp)
        self.assertNotIn(self.guid23, more_rsp)
        self.assertNotIn(self.guid22, more_rsp)
        self.assertNotIn(self.guid21, more_rsp)
        self.assertNotIn(self.guid20, more_rsp)
        self.assertNotIn(self.guid19, more_rsp)
        self.assertNotIn(self.guid18, more_rsp)
        self.assertNotIn(self.guid17, more_rsp)
        self.assertNotIn(self.guid16, more_rsp)
        self.assertNotIn(self.guid15, more_rsp)
        self.assertNotIn(self.guid4, more_rsp)
        self.assertNotIn(self.guid3, more_rsp)
        self.assertNotIn(self.guid2, more_rsp)
        self.assertNotIn(self.guid1, more_rsp)        
        self.assertNotIn(self.guid25, more_rsp)


        anotherURLGet = self.client.get(reverse(views.statements_more,kwargs={'more_id':more_resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(anotherURLGet.status_code, 200)
        another_rsp = anotherURLGet.content

        self.assertIn(self.guid4, another_rsp)
        self.assertIn(self.guid3, another_rsp)
        self.assertIn(self.guid2, another_rsp)
        self.assertIn(self.guid1, another_rsp)

        self.assertNotIn(self.guid24, another_rsp)
        self.assertNotIn(self.guid23, another_rsp)
        self.assertNotIn(self.guid22, another_rsp)
        self.assertNotIn(self.guid21, another_rsp)
        self.assertNotIn(self.guid20, another_rsp)
        self.assertNotIn(self.guid19, another_rsp)
        self.assertNotIn(self.guid18, another_rsp)
        self.assertNotIn(self.guid17, another_rsp)
        self.assertNotIn(self.guid16, another_rsp)
        self.assertNotIn(self.guid15, another_rsp)
        self.assertNotIn(self.guid14, another_rsp)
        self.assertNotIn(self.guid13, another_rsp)
        self.assertNotIn(self.guid12, another_rsp)
        self.assertNotIn(self.guid11, another_rsp)
        self.assertNotIn(self.guid10, another_rsp)
        self.assertNotIn(self.guid9, another_rsp)                
        self.assertNotIn(self.guid8, another_rsp)
        self.assertNotIn(self.guid7, another_rsp)
        self.assertNotIn(self.guid6, another_rsp)
        self.assertNotIn(self.guid5, another_rsp)
        self.assertNotIn(self.guid25, another_rsp)

    def test_two_pages_full_third_not_full_more_stmts_multiple_hits(self):
        # Make initial complex get so 'more' will be required
        sinceGetResponse = self.client.get(reverse(views.statements), {"until":self.sixthTime},
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(sinceGetResponse.status_code, 200)
        rsp = sinceGetResponse.content        
        resp_json = json.loads(rsp)
        resp_url = resp_json['more']
        resp_id = resp_url[-32:]

        self.assertIn(self.guid24, rsp)
        self.assertIn(self.guid23, rsp)
        self.assertIn(self.guid22, rsp)
        self.assertIn(self.guid21, rsp)
        self.assertIn(self.guid20, rsp)
        self.assertIn(self.guid19, rsp)
        self.assertIn(self.guid18, rsp)
        self.assertIn(self.guid17, rsp)
        self.assertIn(self.guid16, rsp)
        self.assertIn(self.guid15, rsp)

        self.assertNotIn(self.guid14, rsp)
        self.assertNotIn(self.guid13, rsp)
        self.assertNotIn(self.guid12, rsp)
        self.assertNotIn(self.guid11, rsp)
        self.assertNotIn(self.guid10, rsp)
        self.assertNotIn(self.guid9, rsp)
        self.assertNotIn(self.guid8, rsp)
        self.assertNotIn(self.guid7, rsp)
        self.assertNotIn(self.guid6, rsp)
        self.assertNotIn(self.guid5, rsp)
        self.assertNotIn(self.guid4, rsp)
        self.assertNotIn(self.guid3, rsp)
        self.assertNotIn(self.guid2, rsp)
        self.assertNotIn(self.guid1, rsp)        
        self.assertNotIn(self.guid25, rsp)

        # Simulate user clicking returned 'more' URL
        moreURLGet = self.client.get(reverse(views.statements_more,kwargs={'more_id':resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        more_rsp = moreURLGet.content
        more_json = json.loads(more_rsp)
        more_resp_url = more_json['more']
        more_resp_id = more_resp_url[-32:]

        self.assertEqual(moreURLGet.status_code, 200)
        self.assertIn(self.guid14, more_rsp)
        self.assertIn(self.guid13, more_rsp)
        self.assertIn(self.guid12, more_rsp)
        self.assertIn(self.guid11, more_rsp)
        self.assertIn(self.guid10, more_rsp)
        self.assertIn(self.guid9, more_rsp)
        self.assertIn(self.guid8, more_rsp)
        self.assertIn(self.guid7, more_rsp)
        self.assertIn(self.guid6, more_rsp)
        self.assertIn(self.guid5, more_rsp)

        self.assertNotIn(self.guid24, more_rsp)
        self.assertNotIn(self.guid23, more_rsp)
        self.assertNotIn(self.guid22, more_rsp)
        self.assertNotIn(self.guid21, more_rsp)
        self.assertNotIn(self.guid20, more_rsp)
        self.assertNotIn(self.guid19, more_rsp)
        self.assertNotIn(self.guid18, more_rsp)
        self.assertNotIn(self.guid17, more_rsp)
        self.assertNotIn(self.guid16, more_rsp)
        self.assertNotIn(self.guid15, more_rsp)
        self.assertNotIn(self.guid4, more_rsp)
        self.assertNotIn(self.guid3, more_rsp)
        self.assertNotIn(self.guid2, more_rsp)
        self.assertNotIn(self.guid1, more_rsp)        
        self.assertNotIn(self.guid25, more_rsp)


        more2URLGet = self.client.get(reverse(views.statements_more, kwargs={'more_id':more_resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(more2URLGet.status_code, 200)
        more2_rsp = more2URLGet.content
        self.assertIn(self.guid4, more2_rsp)
        self.assertIn(self.guid3, more2_rsp)
        self.assertIn(self.guid2, more2_rsp)
        self.assertIn(self.guid1, more2_rsp)

        self.assertNotIn(self.guid25, more2_rsp)
        self.assertNotIn(self.guid24, more2_rsp)
        self.assertNotIn(self.guid23, more2_rsp)
        self.assertNotIn(self.guid22, more2_rsp)
        self.assertNotIn(self.guid21, more2_rsp)
        self.assertNotIn(self.guid20, more2_rsp)
        self.assertNotIn(self.guid19, more2_rsp)
        self.assertNotIn(self.guid18, more2_rsp)
        self.assertNotIn(self.guid17, more2_rsp)
        self.assertNotIn(self.guid16, more2_rsp)
        self.assertNotIn(self.guid15, more2_rsp)
        self.assertNotIn(self.guid14, more2_rsp)
        self.assertNotIn(self.guid13, more2_rsp)
        self.assertNotIn(self.guid12, more2_rsp)
        self.assertNotIn(self.guid11, more2_rsp)        
        self.assertNotIn(self.guid10, more2_rsp)
        self.assertNotIn(self.guid9, more2_rsp)
        self.assertNotIn(self.guid8, more2_rsp)
        self.assertNotIn(self.guid7, more2_rsp)
        self.assertNotIn(self.guid6, more2_rsp)
        self.assertNotIn(self.guid5, more2_rsp)        

        # Simulate user clicking returned 'more' URL
        anotherMoreURLGet = self.client.get(reverse(views.statements_more,kwargs={'more_id':resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        another_more_rsp = anotherMoreURLGet.content
        another_more_json = json.loads(another_more_rsp)
        another_more_resp_url = another_more_json['more']
        another_more_resp_id = another_more_resp_url[-32:]

        self.assertEqual(anotherMoreURLGet.status_code, 200)
        self.assertIn(self.guid14, another_more_rsp)
        self.assertIn(self.guid13, another_more_rsp)
        self.assertIn(self.guid12, another_more_rsp)
        self.assertIn(self.guid11, another_more_rsp)
        self.assertIn(self.guid10, another_more_rsp)
        self.assertIn(self.guid9, another_more_rsp)
        self.assertIn(self.guid8, another_more_rsp)
        self.assertIn(self.guid7, another_more_rsp)
        self.assertIn(self.guid6, another_more_rsp)
        self.assertIn(self.guid5, another_more_rsp)

        self.assertNotIn(self.guid24, another_more_rsp)
        self.assertNotIn(self.guid23, another_more_rsp)
        self.assertNotIn(self.guid22, another_more_rsp)
        self.assertNotIn(self.guid21, another_more_rsp)
        self.assertNotIn(self.guid20, another_more_rsp)
        self.assertNotIn(self.guid19, another_more_rsp)
        self.assertNotIn(self.guid18, another_more_rsp)
        self.assertNotIn(self.guid17, another_more_rsp)
        self.assertNotIn(self.guid16, another_more_rsp)
        self.assertNotIn(self.guid15, another_more_rsp)
        self.assertNotIn(self.guid4, another_more_rsp)
        self.assertNotIn(self.guid3, another_more_rsp)
        self.assertNotIn(self.guid2, another_more_rsp)
        self.assertNotIn(self.guid1, another_more_rsp)        
        self.assertNotIn(self.guid25, another_more_rsp)

        # Simulate user clicking returned 'more' URL
        anotherMore2URLGet = self.client.get(reverse(views.statements_more, kwargs={'more_id':another_more_resp_id}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(anotherMore2URLGet.status_code, 200)
        another_more2_rsp = anotherMore2URLGet.content
        self.assertIn(self.guid4, another_more2_rsp)
        self.assertIn(self.guid3, another_more2_rsp)
        self.assertIn(self.guid2, another_more2_rsp)
        self.assertIn(self.guid1, another_more2_rsp)

        self.assertNotIn(self.guid25, another_more2_rsp)
        self.assertNotIn(self.guid24, another_more2_rsp)
        self.assertNotIn(self.guid23, another_more2_rsp)
        self.assertNotIn(self.guid22, another_more2_rsp)
        self.assertNotIn(self.guid21, another_more2_rsp)
        self.assertNotIn(self.guid20, another_more2_rsp)
        self.assertNotIn(self.guid19, another_more2_rsp)
        self.assertNotIn(self.guid18, another_more2_rsp)
        self.assertNotIn(self.guid17, another_more2_rsp)
        self.assertNotIn(self.guid16, another_more2_rsp)
        self.assertNotIn(self.guid15, another_more2_rsp)
        self.assertNotIn(self.guid14, another_more2_rsp)
        self.assertNotIn(self.guid13, another_more2_rsp)
        self.assertNotIn(self.guid12, another_more2_rsp)
        self.assertNotIn(self.guid11, another_more2_rsp)        
        self.assertNotIn(self.guid10, another_more2_rsp)
        self.assertNotIn(self.guid9, another_more2_rsp)
        self.assertNotIn(self.guid8, another_more2_rsp)
        self.assertNotIn(self.guid7, another_more2_rsp)
        self.assertNotIn(self.guid6, another_more2_rsp)
        self.assertNotIn(self.guid5, another_more2_rsp)

    def test_get_order(self):
        r = self.client.get(reverse(views.statements), {"limit":10},
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(r.status_code, 200)
        c = r.content        
        sresults = json.loads(c)
        more = sresults['more'][-32:]
        stmts = sresults['statements']

        self.assertEqual(len(stmts), 10)
        self.assertEqual(stmts[0]['id'], self.guid25)
        self.assertEqual(stmts[1]['id'], self.guid24)
        self.assertEqual(stmts[2]['id'], self.guid23)
        self.assertEqual(stmts[3]['id'], self.guid22)
        self.assertEqual(stmts[4]['id'], self.guid21)
        self.assertEqual(stmts[5]['id'], self.guid20)
        self.assertEqual(stmts[6]['id'], self.guid19)
        self.assertEqual(stmts[7]['id'], self.guid18)
        self.assertEqual(stmts[8]['id'], self.guid17)
        self.assertEqual(stmts[9]['id'], self.guid16)

        r = self.client.get(reverse(views.statements_more,kwargs={'more_id':more}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(r.status_code, 200)
        c = r.content        
        sresults = json.loads(c)
        more = sresults['more'][-32:]
        stmts = sresults['statements']

        self.assertEqual(len(stmts), 10)
        self.assertEqual(stmts[0]['id'], self.guid15)
        self.assertEqual(stmts[1]['id'], self.guid14)
        self.assertEqual(stmts[2]['id'], self.guid13)
        self.assertEqual(stmts[3]['id'], self.guid12)
        self.assertEqual(stmts[4]['id'], self.guid11)
        self.assertEqual(stmts[5]['id'], self.guid10)
        self.assertEqual(stmts[6]['id'], self.guid9)
        self.assertEqual(stmts[7]['id'], self.guid8)
        self.assertEqual(stmts[8]['id'], self.guid7)
        self.assertEqual(stmts[9]['id'], self.guid6)

        r = self.client.get(reverse(views.statements_more,kwargs={'more_id':more}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(r.status_code, 200)
        c = r.content        
        sresults = json.loads(c)
        stmts = sresults['statements']

        self.assertEqual(len(stmts), 5)
        self.assertEqual(stmts[0]['id'], self.guid5)
        self.assertEqual(stmts[1]['id'], self.guid4)
        self.assertEqual(stmts[2]['id'], self.guid3)
        self.assertEqual(stmts[3]['id'], self.guid2)
        self.assertEqual(stmts[4]['id'], self.guid1)

    def test_get_rev_order(self):
        r = self.client.get(reverse(views.statements), {"limit":10, "ascending":True},
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(r.status_code, 200)
        c = r.content        
        sresults = json.loads(c)
        more = sresults['more'][-32:]
        stmts = sresults['statements']

        self.assertEqual(len(stmts), 10)
        self.assertEqual(stmts[0]['id'], self.guid1)
        self.assertEqual(stmts[1]['id'], self.guid2)
        self.assertEqual(stmts[2]['id'], self.guid3)
        self.assertEqual(stmts[3]['id'], self.guid4)
        self.assertEqual(stmts[4]['id'], self.guid5)
        self.assertEqual(stmts[5]['id'], self.guid6)
        self.assertEqual(stmts[6]['id'], self.guid7)
        self.assertEqual(stmts[7]['id'], self.guid8)
        self.assertEqual(stmts[8]['id'], self.guid9)
        self.assertEqual(stmts[9]['id'], self.guid10)

        r = self.client.get(reverse(views.statements_more,kwargs={'more_id':more}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(r.status_code, 200)
        c = r.content        
        sresults = json.loads(c)
        more = sresults['more'][-32:]
        stmts = sresults['statements']

        self.assertEqual(len(stmts), 10)
        self.assertEqual(stmts[0]['id'], self.guid11)
        self.assertEqual(stmts[1]['id'], self.guid12)
        self.assertEqual(stmts[2]['id'], self.guid13)
        self.assertEqual(stmts[3]['id'], self.guid14)
        self.assertEqual(stmts[4]['id'], self.guid15)
        self.assertEqual(stmts[5]['id'], self.guid16)
        self.assertEqual(stmts[6]['id'], self.guid17)
        self.assertEqual(stmts[7]['id'], self.guid18)
        self.assertEqual(stmts[8]['id'], self.guid19)
        self.assertEqual(stmts[9]['id'], self.guid20)

        r = self.client.get(reverse(views.statements_more,kwargs={'more_id':more}),
            X_Experience_API_Version="1.0.0",HTTP_AUTHORIZATION=self.auth)
        self.assertEqual(r.status_code, 200)
        c = r.content        
        sresults = json.loads(c)
        stmts = sresults['statements']

        self.assertEqual(len(stmts), 5)
        self.assertEqual(stmts[0]['id'], self.guid21)
        self.assertEqual(stmts[1]['id'], self.guid22)
        self.assertEqual(stmts[2]['id'], self.guid23)
        self.assertEqual(stmts[3]['id'], self.guid24)
        self.assertEqual(stmts[4]['id'], self.guid25)

########NEW FILE########
__FILENAME__ = StatementsTests
# -*- coding: utf-8 -*-
from email import message_from_string
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
from django.test import TestCase
from django.test.utils import setup_test_environment
from django.core.urlresolvers import reverse
from django.utils.timezone import utc
from django.conf import settings
from lrs import views, models
from lrs.util import retrieve_statement
from lrs.util.jws import JWS, JWSException
from lrs.objects.StatementManager import StatementManager
import os
from datetime import datetime, timedelta
import sys
import json
import base64
import uuid
import time
import urllib
import hashlib

class StatementsTests(TestCase):
    @classmethod
    def setUpClass(cls):
        print "\n%s" % __name__

    def setUp(self):
        if not settings.HTTP_AUTH_ENABLED:
            settings.HTTP_AUTH_ENABLED = True
        
        self.username = "tester1"
        self.email = "test1@tester.com"
        self.password = "test"
        self.auth = "Basic %s" % base64.b64encode("%s:%s" % (self.username, self.password))
        form = {"username":self.username, "email":self.email,"password":self.password,"password2":self.password}
        response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")

        self.username2 = "tester2"
        self.email2 = "test2@tester.com"
        self.password2 = "test2"
        self.auth2 = "Basic %s" % base64.b64encode("%s:%s" % (self.username2, self.password2))
        form2 = {"username":self.username2, "email":self.email2,"password":self.password2,"password2":self.password2}
        response = self.client.post(reverse(views.register),form2, X_Experience_API_Version="1.0.0")

        self.firstTime = str(datetime.utcnow().replace(tzinfo=utc).isoformat())
        self.guid1 = str(uuid.uuid1())
       
    def tearDown(self):
        attach_folder_path = os.path.join(settings.MEDIA_ROOT, "attachment_payloads")
        for the_file in os.listdir(attach_folder_path):
            file_path = os.path.join(attach_folder_path, the_file)
            try:
                os.unlink(file_path)
            except Exception, e:
                raise e

    def bunchostmts(self):
        self.guid2 = str(uuid.uuid1())
        self.guid3 = str(uuid.uuid1())    
        self.guid4 = str(uuid.uuid1())
        self.guid5 = str(uuid.uuid1())
        self.guid6 = str(uuid.uuid1())
        self.guid7 = str(uuid.uuid1())
        self.guid8 = str(uuid.uuid1())
        self.guid9 = str(uuid.uuid1())        
        self.guid10 = str(uuid.uuid1())
        self.cguid1 = str(uuid.uuid1())
        self.cguid2 = str(uuid.uuid1())    
        self.cguid3 = str(uuid.uuid1())
        self.cguid4 = str(uuid.uuid1())
        self.cguid5 = str(uuid.uuid1())
        self.cguid6 = str(uuid.uuid1())
        self.cguid7 = str(uuid.uuid1())
        self.cguid8 = str(uuid.uuid1())

        if settings.HTTP_AUTH_ENABLED:
            stmt = {"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
                "display": {"en-US":"created"}}, "object": {"id":"act:activity"},
                "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
                "authority":{"objectType":"Agent","name":"tester1","mbox":"mailto:test1@tester.com"}}

            self.existStmt = StatementManager(stmt, stmt_json=json.dumps(stmt))
        else:
            stmt = {"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
                "display": {"en-US":"created"}}, "object": {"id":"act:activity"},
                "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"}}

            self.existStmt = StatementManager(stmt, stmt_json=json.dumps(stmt))
        
        self.exist_stmt_id = self.existStmt.model_object.statement_id


        self.existStmt1 = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
            "display": {"en-US":"created"}},"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object": {"objectType": "Activity", "id":"act:foogie",
            "definition": {"name": {"en-US":"testname2", "en-GB": "altname"},
            "description": {"en-US":"testdesc2", "en-GB": "altdesc"}, "type": "http://www.adlnet.gov/experienceapi/activity-types/http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "fill-in","correctResponsesPattern": ["answer"],
            "extensions": {"ext:key1": "value1", "ext:key2": "value2","ext:key3": "value3"}}}, 
            "result": {"score":{"scaled":.85}, "completion": True, "success": True, "response": "kicked",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:key1": "value1", "ext:key2":"value2"}},
            "context":{"registration": self.cguid1, "contextActivities": {"other": {"id": "act:NewActivityID2"}},
            "revision": "food", "platform":"bard","language": "en-US", "extensions":{"ext:ckey1": "cval1",
            "ext:ckey2": "cval2"}}})        

        self.existStmt2 = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
            "display": {"en-US":"created"}},"actor":{"objectType":"Agent","mbox":"mailto:s@t.com"},
            "object": {"objectType": "Activity", "id":"act:foogie",
            "definition": {"name": {"en-US":"testname3", "en-GB": "altname"},
            "description": {"en-US":"testdesc3","en-GB":"altdesc"}, "type": "http://www.adlnet.gov/experienceapi/activity-types/http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "fill-in","correctResponsesPattern": ["answers"],
            "extensions": {"ext:key11": "value11", "ext:key22": "value22","ext:key33": "value33"}}}, 
            "result": {"score":{"scaled":.75}, "completion": True, "success": True, "response": "shouted",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:dkey1": "dvalue1", "ext:dkey2":"dvalue2"}},
            "context":{"registration": self.cguid2, "contextActivities": {"other": {"id": "act:NewActivityID22"}},
            "revision": "food", "platform":"bard","language": "en-US", "extensions":{"ext:ckey11": "cval11",
            "ext:ckey22": "cval22"}}})        

        self.existStmt3 = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
            "display": {"en-US":"created"}},"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object": {"objectType": "Activity", "id":"act:foogals",
            "definition": {"name": {"en-US":"testname3"},"description": {"en-US":"testdesc3"}, "type": "http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "fill-in","correctResponsesPattern": ["answers"],
            "extensions": {"ext:key111": "value111", "ext:key222": "value222","ext:key333": "value333"}}}, 
            "result": {"score":{"scaled":.79}, "completion": True, "success": True, "response": "shouted",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:dkey1": "dvalue1", "ext:dkey2":"dvalue2"}},
            "context":{"registration": self.cguid3, "contextActivities": {"other": {"id": "act:NewActivityID22"}},
            "revision": "food", "platform":"bard","language": "en-US",
            "instructor":{"objectType": "Agent", "name":"bob", "mbox":"mailto:bob@bob.com"}, 
            "extensions":{"ext:ckey111": "cval111","ext:ckey222": "cval222"}}})        

        self.existStmt4 = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
            "display": {"en-US":"created"}},"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object": {"objectType": "Activity", "id":"act:foogal",
            "definition": {"name": {"en-US":"testname3"},"description": {"en-US":"testdesc3"}, "type": "http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "fill-in","correctResponsesPattern": ["answers"],
            "extensions": {"ext:key111": "value111", "ext:key222": "value222","ext:key333": "value333"}}}, 
            "result": {"score":{"scaled":.79}, "completion": True, "success": True, "response": "shouted",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:dkey1": "dvalue1", "ext:dkey2":"dvalue2"}},
            "context":{"registration": self.cguid4, "contextActivities": {"other": {"id": "act:NewActivityID22"}},
            "revision": "food", "platform":"bard","language": "en-US","instructor":{"name":"bill", "mbox":"mailto:bill@bill.com"},
            "extensions":{"ext:ckey111": "cval111","ext:ckey222": "cval222"}}})

        self.existStmt5 = json.dumps({"object":{"objectType":"Agent","name":"jon","mbox":"mailto:jon@jon.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/created","display": {"en-US":"created"}},
            "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"}})

        self.existStmt6 = json.dumps({"actor": {"objectType":"Agent","name":"max","mbox":"mailto:max@max.com"}, 
                                      "object":{"id": "act:test_activity"},"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
                                      "display": {"en-US":"created"}}})

        self.existStmt7 = json.dumps({"object": {"objectType":"Agent","name":"max","mbox":"mailto:max@max.com"},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/created","display": {"en-US":"created"}},
            "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"}})

        self.existStmt8 = json.dumps({"object": {"objectType":"Agent","name":"john","mbox":"mailto:john@john.com"},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/missed","display": {"en-US":"missed"}},
            "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"}})

        self.existStmt9 = json.dumps({"actor":{"objectType":"Agent","mbox":"mailto:sub@sub.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/missed"},"object":{"objectType":"SubStatement",
            "actor":{"objectType":"Agent","mbox":"mailto:ss@ss.com"},"verb": {"id":"verb:verb/url/nested"},
            "object": {"objectType":"Activity", "id":"act:testex.com"}, "result":{"completion": True, "success": True,
            "response": "kicked"}, "context":{"registration": self.cguid6,
            "contextActivities": {"other": {"id": "act:NewActivityID"}},"revision": "foo", "platform":"bar",
            "language": "en-US", "extensions":{"ext:k1": "v1", "ext:k2": "v2"}}}})

        self.existStmt10 = json.dumps({"actor":{"objectType":"Agent","mbox":"mailto:ref@ref.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/missed"},"object":{"objectType":"StatementRef",
            "id":str(self.exist_stmt_id)}})

        # Put statements
        param = {"statementId":self.guid1}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt1
        self.putresponse1 = self.client.put(path, stmt_payload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse1.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=2)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid1).update(stored=time)


        param = {"statementId":self.guid3}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt3
        self.putresponse3 = self.client.put(path, stmt_payload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse3.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=3)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid3).update(stored=time)

        
        param = {"statementId":self.guid4}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt4
        self.putresponse4 = self.client.put(path, stmt_payload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse4.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=4)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid4).update(stored=time)

        self.secondTime = str((datetime.utcnow()+timedelta(seconds=4)).replace(tzinfo=utc).isoformat())
        
        param = {"statementId":self.guid2}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt2
        self.putresponse2 = self.client.put(path, stmt_payload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")       
        self.assertEqual(self.putresponse2.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=6)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid2).update(stored=time)


        param = {"statementId":self.guid5}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt5
        self.putresponse5 = self.client.put(path, stmt_payload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse5.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=7)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid5).update(stored=time)
        

        param = {"statementId":self.guid6}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt6
        self.putresponse6 = self.client.put(path, stmt_payload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse6.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=8)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid6).update(stored=time)

        
        param = {"statementId":self.guid7}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt7        
        self.putresponse7 = self.client.put(path, stmt_payload,  content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse7.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=9)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid7).update(stored=time)
        

        param = {"statementId":self.guid8}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt8        
        self.putresponse8 = self.client.put(path, stmt_payload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse8.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=10)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid8).update(stored=time)
        
        param = {"statementId": self.guid9}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt9        
        self.putresponse9 = self.client.put(path, stmt_payload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse9.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=11)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid9).update(stored=time)

        param = {"statementId": self.guid10}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt_payload = self.existStmt10        
        self.putresponse10 = self.client.put(path, stmt_payload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(self.putresponse10.status_code, 204)
        time = retrieve_statement.convert_to_utc(str((datetime.utcnow()+timedelta(seconds=11)).replace(tzinfo=utc).isoformat()))
        stmt = models.Statement.objects.filter(statement_id=self.guid10).update(stored=time)

    def test_invalid_result_fields(self):
        stmt = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
            "display": {"en-US":"created"}},"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object": {"objectType": "Activity", "id":"act:foogie"}, 
            "result": {"bad":"fields","foo":"bar","score":{"scaled":.85}, "completion": True, "success": True,
            "response": "kicked","duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:key1": "value1",
            "ext:key2":"value2"}}})        

        resp = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(resp.status_code, 400)
        self.assertEqual(resp.content, 'Invalid field(s) found in Result - bad, foo')


    def test_invalid_context_fields(self):
        stmt = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
            "display": {"en-US":"created"}},"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "object": {"objectType": "Activity", "id":"act:foogals",
            "definition": {"name": {"en-US":"testname3"},"description": {"en-US":"testdesc3"}, "type": "http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "fill-in","correctResponsesPattern": ["answers"],
            "extensions": {"ext:key111": "value111", "ext:key222": "value222","ext:key333": "value333"}}}, 
            "result": {"score":{"scaled":.79}, "completion": True, "success": True, "response": "shouted",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:dkey1": "dvalue1", "ext:dkey2":"dvalue2"}},
            "context":{"contextActivities": {"other": {"id": "act:NewActivityID22"}},
            "revision": "food", "bad":"foo","platform":"bard","language": "en-US",
            "instructor":{"objectType": "Agent", "name":"bob", "mbox":"mailto:bob@bob.com"}, 
            "extensions":{"ext:ckey111": "cval111","ext:ckey222": "cval222"}}})        

        resp = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(resp.status_code, 400)
        self.assertEqual(resp.content, 'Invalid field(s) found in Context - bad')
    

    def test_post_with_no_valid_params(self):
        # Error will be thrown in statements class
        resp = self.client.post(reverse(views.statements), {"feet":"yes","hands": {"id":"http://example.com/test_post"}},
            content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(resp.status_code, 400)

    def test_post(self):
        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_post"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        act = models.Activity.objects.get(activity_id="act:test_post")
        self.assertEqual(act.activity_id, "act:test_post")
        agent = models.Agent.objects.get(mbox="mailto:t@t.com")
        self.assertEqual(agent.name, "bob")

    def test_post_wrong_crp_type(self):
        stmt = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created"},
            "object": {"objectType": "Activity", "id":"act:foogie",
            "definition": {"name": {"en-US":"testname2", "en-GB": "altname"},
            "description": {"en-US":"testdesc2", "en-GB": "altdesc"}, "type": "http://www.adlnet.gov/experienceapi/activity-types/http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "fill-in","correctResponsesPattern": "wrong"}},
            "actor":{"objectType":"Agent", "mbox":"mailto:wrong-t@t.com"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Activity definition correctResponsesPattern is not a properly formatted array')

    def test_post_wrong_choice_type(self):
        stmt = json.dumps(
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/created"},
            "object": {"objectType": "Activity", "id":"act:foogie",
                "definition": {"name": {"en-US":"testname2", "en-GB": "altname"},
                    "description": {"en-US":"testdesc2", "en-GB": "altdesc"},
                    "type": "http://adlnet.gov/expapi/activities/cmi.interaction",
                    "interactionType": "choice","correctResponsesPattern": ["a1[,]a3[,]a6[,]a7"],
                    "choices":"wrong"}},
            "actor":{"objectType":"Agent", "mbox":"mailto:wrong-t@t.com"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Activity definition choices is not a properly formatted array')

    def test_openid(self):
        guid = str(uuid.uuid1())
        stmt = json.dumps({'object':{'objectType':'Agent', 'name': 'lulu', 'openID':'id:luluid'}, 
            'verb': {"id":"verb:verb/url"},'actor':{'objectType':'Agent','mbox':'mailto:t@t.com'}})

        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        agent = models.Agent.objects.get(name='lulu')
        self.assertEqual(agent.openID, 'id:luluid')

    def test_invalid_actor_fields(self):
        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob", "bad": "blah",
            "foo":"bar"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_post"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Invalid field(s) found in Agent/Group - bad, foo')

    def test_invalid_activity_fields(self):
        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_post", "bad":"foo", "foo":"bar"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, "Invalid field(s) found in Activity - bad, foo")

    def test_invalid_activity_def_fields(self):
        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:t@t.com", "name":"bob"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {'objectType': 'Activity', 'id':'act:food',
                'definition': {'bad':'foo','name': {'en-FR':'testname2','en-US': 'testnameEN'},'description': {'en-CH':'testdesc2',
                'en-GB': 'testdescGB'},'type': 'type:course','interactionType': 'intType2', 'extensions': {'ext:key1': 'value1',
                'ext:key2': 'value2','ext:key3': 'value3'}}}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Invalid field(s) found in Activity definition - bad')


    def test_post_wrong_duration(self):
        stmt = json.dumps({"actor":{'name':'jon',
            'mbox':'mailto:jon@example.com'},'verb': {"id":"verb:verb/url"},"object": {'id':'act:activity13'}, 
            "result": {'completion': True, 'success': True, 'response': 'yes', 'duration': 'wrongduration',
            'extensions':{'ext:key1': 'value1', 'ext:key2':'value2'}}})

        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, "Error with result duration - Unable to parse duration string u'wrongduration'")


    def test_post_stmt_ref_no_existing_stmt(self):
        stmt = json.dumps({"actor":{"objectType":"Agent","mbox":"mailto:ref@ref.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/missed"},"object":{"objectType":"StatementRef",
            "id":"12345678-1234-5678-1234-567812345678"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 404)


    def test_post_with_actor(self):
        stmt = json.dumps({"actor":{"mbox":"mailto:mr.t@example.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:i.pity.the.fool"}})
        
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)
        agent = models.Agent.objects.get(mbox="mailto:mr.t@example.com")

    def test_list_post(self):
        stmts = json.dumps([{"verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_list_post"}, "actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/failed","display": {"en-GB":"failed"}},
            "object": {"id":"act:test_list_post1"}, "actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}}])
        
        response = self.client.post(reverse(views.statements), stmts,  content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)
        activity1 = models.Activity.objects.get(activity_id="act:test_list_post")
        activity2 = models.Activity.objects.get(activity_id="act:test_list_post1")
        stmt1 = models.Statement.objects.get(object_activity=activity1)
        stmt2 = models.Statement.objects.get(object_activity=activity2)
        verb1 = models.Verb.objects.get(id=stmt1.verb.id)
        verb2 = models.Verb.objects.get(id=stmt2.verb.id)
        lang_map1 = verb1.display
        lang_map2 = verb2.display

        self.assertEqual(response.status_code, 200)
        self.assertEqual(stmt1.verb.verb_id, "http://adlnet.gov/expapi/verbs/passed")
        self.assertEqual(stmt2.verb.verb_id, "http://adlnet.gov/expapi/verbs/failed")
        
        self.assertEqual(lang_map1.keys()[0], "en-US")
        self.assertEqual(lang_map1.values()[0], "passed")
        self.assertEqual(lang_map2.keys()[0], "en-GB")
        self.assertEqual(lang_map2.values()[0], "failed")

    def test_put(self):
        guid = str(uuid.uuid1())

        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_put"},"actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}})

        putResponse = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(putResponse.status_code, 204)
        stmt = models.Statement.objects.get(statement_id=guid)

        act = models.Activity.objects.get(activity_id="act:test_put")
        self.assertEqual(act.activity_id, "act:test_put")

        self.assertEqual(stmt.actor.mbox, "mailto:t@t.com")

        if settings.HTTP_AUTH_ENABLED:
            self.assertEqual(stmt.authority.name, "tester1")
            self.assertEqual(stmt.authority.mbox, "mailto:test1@tester.com")
        
        self.assertEqual(stmt.version, "1.0.0")
        self.assertEqual(stmt.verb.verb_id, "http://adlnet.gov/expapi/verbs/passed")

    def test_put_id_in_stmt(self):
        guid = str(uuid.uuid1())

        stmt = json.dumps({"id": guid, "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_put"},"actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}})

        putResponse = self.client.put(reverse(views.statements), stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(putResponse.status_code, 400)

    def test_put_id_in_both_same(self):
        guid = str(uuid.uuid1())

        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt = json.dumps({"id": guid, "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_put"},"actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}})

        putResponse = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(putResponse.status_code, 204)
        stmt = models.Statement.objects.get(statement_id=guid)

        act = models.Activity.objects.get(activity_id="act:test_put")
        self.assertEqual(act.activity_id, "act:test_put")

        self.assertEqual(stmt.actor.mbox, "mailto:t@t.com")

        if settings.HTTP_AUTH_ENABLED:
            self.assertEqual(stmt.authority.name, "tester1")
            self.assertEqual(stmt.authority.mbox, "mailto:test1@tester.com")
        
        self.assertEqual(stmt.version, "1.0.0")
        self.assertEqual(stmt.verb.verb_id, "http://adlnet.gov/expapi/verbs/passed")

    def test_put_id_in_both_different(self):
        guid1 = str(uuid.uuid1())
        guid2 = str(uuid.uuid1())
        
        param = {"statementId":guid1}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt = json.dumps({"id": guid2, "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_put"},"actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}})

        putResponse = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(putResponse.status_code, 400)
        self.assertEqual(putResponse.content, "Error -- statements - method = PUT, param and body ID both given, but do not match")

    def test_put_with_substatement(self):
        con_guid = str(uuid.uuid1())
        st_guid = str(uuid.uuid1())

        param = {"statementId": st_guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt = json.dumps({"actor":{"objectType":"Agent","mbox":"mailto:sass@sass.com"},
            "verb": {"id":"verb:verb/url/tested"}, "object":{"objectType":"SubStatement",
            "actor":{"objectType":"Agent","mbox":"mailto:ss@ss.com"},"verb": {"id":"verb:verb/url/nested"},
            "object": {"objectType":"Activity", "id":"act:testex.com"}, "result":{"completion": True, "success": True,
            "response": "kicked"}, "context":{"registration": con_guid,
            "contextActivities": {"other": {"id": "act:NewActivityID"}},"revision": "foo", "platform":"bar",
            "language": "en-US", "extensions":{"ext:k1": "v1", "ext:k2": "v2"}}}})
        
        response = self.client.put(path, stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 204)

        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        get_response = self.client.get(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(get_response.status_code, 200)
        rsp = get_response.content
        self.assertIn("objectType",rsp)
        self.assertIn("SubStatement", rsp)
        self.assertIn("actor",rsp)
        self.assertIn("ss@ss.com",rsp)
        self.assertIn("verb",rsp)
        self.assertIn("verb:verb/url/nested", rsp)
        self.assertIn("Activity", rsp)
        self.assertIn("act:testex.com", rsp)
        self.assertIn("result", rsp)
        self.assertIn("completion",rsp)
        self.assertIn("success", rsp)
        self.assertIn("response", rsp)
        self.assertIn("kicked", rsp)
        self.assertIn("context", rsp)
        self.assertIn(con_guid, rsp)
        self.assertIn("contextActivities", rsp)
        self.assertIn("other", rsp)
        self.assertIn("revision", rsp)
        self.assertIn("foo", rsp)
        self.assertIn("platform", rsp)
        self.assertIn("bar", rsp)
        self.assertIn("language", rsp)
        self.assertIn("en-US", rsp)
        self.assertIn("extensions", rsp)
        self.assertIn("ext:k1", rsp)
        self.assertIn("v1", rsp)
        self.assertIn("ext:k2", rsp)
        self.assertIn("v2", rsp)                                                                                                                                                                                                                

    def test_no_content_put(self):
        guid = str(uuid.uuid1())
        
        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        stmt = json.dumps({})

        putResponse = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(putResponse.status_code, 400)

    def test_existing_stmtID_put(self):
        guid = str(uuid.uuid1())

        existStmt = StatementManager({"statement_id":guid,
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:activity"},"actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}})

        param = {"statementId":guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        stmt = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object":{"id":"act:test_existing_put"}, "actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}})

        putResponse = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(putResponse.status_code, 409)        

    def test_missing_stmtID_put(self):        
        stmt = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_put"},"actor":{"objectType":"Agent", "mbox":"mailto:t@t.com"}})
        response = self.client.put(reverse(views.statements), stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn(response.content, "Error -- statements - method = PUT, but no statementId parameter or ID given in statement")

    def test_get(self):
        self.bunchostmts()
        param = {"statementId":self.guid1}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        getResponse = self.client.get(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(getResponse.status_code, 200)
        rsp = getResponse.content
        self.assertIn(self.guid1, rsp)
        self.assertIn('content-length', getResponse._headers)

    def test_get_no_params(self):
        self.bunchostmts()
        getResponse = self.client.get(reverse(views.statements), X_Experience_API_Version="1.0.0",
            Authorization=self.auth)
        self.assertEqual(getResponse.status_code, 200)
        self.assertIn('content-length', getResponse._headers)

        rsp = json.loads(getResponse.content)
        self.assertEqual(len(rsp['statements']), 11)

    def test_post_no_params(self):
        self.bunchostmts()
        getResponse = self.client.post(reverse(views.statements), X_Experience_API_Version="1.0.0",
            Authorization=self.auth)
        self.assertEqual(getResponse.status_code, 200)
        self.assertIn('content-length', getResponse._headers)

        rsp = json.loads(getResponse.content)
        self.assertEqual(len(rsp['statements']), 11)

    def test_head(self):
        self.bunchostmts()
        param = {"statementId":self.guid1}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        head_resp = self.client.head(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(head_resp.status_code, 200)
        self.assertEqual(head_resp.content, '')
        self.assertIn('content-length', head_resp._headers)

    def test_get_no_existing_ID(self):
        param = {"statementId":"aaaaaa"}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        getResponse = self.client.get(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(getResponse.status_code, 404)

    def test_get_no_auth(self):
        # Will return 200 if HTTP_AUTH_ENABLED is enabled
        if settings.HTTP_AUTH_ENABLED:
            param = {"statementId":self.guid1}
            path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
            getResponse = self.client.get(path, X_Experience_API_Version="1.0.0")
            self.assertEqual(getResponse.status_code, 401)

    def test_get_no_statementid(self):
        self.bunchostmts()
        getResponse = self.client.get(reverse(views.statements), X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(getResponse.status_code, 200)
        jsn = json.loads(getResponse.content)
        # Will only return 10 since that is server limit
        self.assertEqual(len(jsn["statements"]), 11)
        self.assertIn('content-length', getResponse._headers)

    def test_head_no_statementid(self):
        self.bunchostmts()
        head_resp = self.client.head(reverse(views.statements), X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(head_resp.status_code, 200)
        self.assertEqual(head_resp.content, '')
        self.assertIn('content-length', head_resp._headers)

    # Sever activities are PUT - contextActivities create 3 more
    def test_number_of_activities(self):
        self.bunchostmts()
        acts = len(models.Activity.objects.all())
        self.assertEqual(9, acts)

    def test_timeout_snafu(self):
        stmt = json.dumps({
            "timestamp": "2013-11-05T07:33:49.512119+00:00",
            "object": {
                "definition": {
                    "name": {
                        "en-US": "news.google.com",
                        "ja": "news.google.com"
                    },
                    "description": {
                        "en-US": "",
                        "ja": ""
                    }
                },
                "id": "http://garewelswe.com/",
                "objectType": "Activity"
            },
            "authority": {
                "mbox": "mailto:kazutaka_kamiya@test.local",
                "name": "adllrs",
                "objectType": "Agent"
            },
            "verb": {
                "id": "http://adlnet.gov/expapi/verbs/experienced",
                "display": {
                    "en-us": "experienced"
                }
            },
            "actor": {
                "openID": "http://test.local/PEab76617d1d21d725d358a7ad5231bd6e",
                "name": "dev2-001",
                "objectType": "Agent"
            },
            "id": "9cb78e42-45ec-11e3-b8dc-0af904863508"
            })

        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)    

        stmt = json.dumps({
            "timestamp": "2013-11-08T08:41:55.985064+00:00",
            "object": {
                "definition": {
                    "interactionType": "fill-in",
                    "type": "http://adlnet.gov/expapi/activities/cmi.interaction",
                    "name": {
                        "ja": "SCORM20110721_12"
                    },
                    "description": {
                        "ja": ""
                    }
                },
                "id": "http://garewelswe.com/",
                "objectType": "Activity"
            },
            "actor": {
                "openID": "http://test.local/EAGLE/PEab76617d1d21d725d358a7ad5231bd6e",
                "name": "dev2-001",
                "objectType": "Agent"
            },
            "verb": {
                "id": "http://adlnet.gov/expapi/verbs/answered",
                "display": {
                    "en-us": "answered"
                }
            },
            "result": {
                "response": "TEST0",
                "success": True
            },
            "context": {
                "contextActivities": {
                    "parent": [
                        {
                            "id": "http://garewelswe.com/"
                        }
                    ],
                    "grouping": [
                        {
                            "id": "http://garewelswe.com/"
                        }
                    ]
                }
            },
            "id": "9faf143c-4851-11e3-b1a1-000c29bfba11",
            "authority": {
                "mbox": "mailto:kazutaka_kamiya@test.local",
                "name": "adllrs",
                "objectType": "Agent"
            }
            })

        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)    

    def test_amsterdam_snafu(self):
        stmt = json.dumps({
            "timestamp": "2013-05-23T10:46:39+02:00",
            "verb": {"id": "http:\/\/www.adlnet.gov\/expapi\/verbs\/experienced"},
            "context": {
                "contextActivities": {
                    "parent": {
                        "id": "http:\/\/localhost:8080\/portal\/site\/~88a4933d-99d2-4a35-8906-993fdcdf2259"
                    }
                }
            },
            "object": {
                "id": "http:\/\/localhost:8080\/portal\/web\/~88a4933d-99d2-4a35-8906-993fdcdf2259\/id\/c50bf034-0f3e-4055-a1e7-8d1cf92be353\/url\/%2Flibrary%2Fcontent%2Fmyworkspace_info.html",
                "definition": {
                    "type": "http:\/\/adlnet.gov\/expapi\/activities\/view-web-content"
                },
                "objectType": "Activity"
            },
            "actor": {
                "name": "Alan Tester",
                "objectType": "Agent",
                "mbox": "mailto:tester@dev.nl"
            }
        })
        post_response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(post_response.status_code, 200)

    def test_nik_snafu(self):
        stmt = json.dumps({
            "verb": {"id": "http:\/\/www.adlnet.gov\/expapi\/verbs\/experienced"},
            "object": {
                "id": "act:test/nik/issue",
                "definition": {
                    "type": "http:\/\/adlnet.gov\/expapi\/activities\/view-web-content",
                    "description": {"en-US":"just trying to test stuff"}
                },
                "objectType": "Activity"
            },
            "actor": {
                "name": "Alan Tester",
                "objectType": "Agent",
                "mbox": "mailto:tester@dev.nl"
            }
        })
        post_response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(post_response.status_code, 200)

        stmt = json.dumps({
            "verb": {"id": "http:\/\/www.adlnet.gov\/expapi\/verbs\/experienced"},
            "object": {
                "id": "act:test/nik/issue",
                "definition": {
                    "type": "http:\/\/adlnet.gov\/expapi\/activities\/view-web-content",
                    "description": {"en-US":"just trying to test stuff"},
                    "name": {"en-US":"nik test"}
                },
                "objectType": "Activity"
            },
            "actor": {
                "name": "Alan Tester",
                "objectType": "Agent",
                "mbox": "mailto:tester@dev.nl"
            }
        })
        post_response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(post_response.status_code, 200)

    def test_update_activity_wrong_auth(self):
        # Will respond with 200 if HTTP_AUTH_ENABLED is enabled
        if settings.HTTP_AUTH_ENABLED:
            existStmt1 = json.dumps({"verb":{"id": "http://adlnet.gov/expapi/verbs/created",
                "display": {"en-US":"created"}},"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
                "object": {"objectType": "Activity", "id":"act:foogie",
                "definition": {"name": {"en-US":"testname2", "en-GB": "altname"},
                "description": {"en-US":"testdesc2", "en-GB": "altdesc"}, "type": "http://www.adlnet.gov/experienceapi/activity-types/http://adlnet.gov/expapi/activities/cmi.interaction",
                "interactionType": "fill-in","correctResponsesPattern": ["answer"],
                "extensions": {"ext:key1": "value1", "ext:key2": "value2","ext:key3": "value3"}}}, 
                "result": {"score":{"scaled":.85}, "completion": True, "success": True, "response": "kicked",
                "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:key1": "value1", "ext:key2":"value2"}},
                "context":{"registration": str(uuid.uuid1()), "contextActivities": {"other": {"id": "act:NewActivityID2"}},
                "revision": "food", "platform":"bard","language": "en-US", "extensions":{"ext:ckey1": "cval1",
                "ext:ckey2": "cval2"}}})
            param = {"statementId":self.guid1}
            path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
            stmt_payload = existStmt1

            putresponse1 = self.client.put(path, stmt_payload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
            
            wrong_username = "tester2"
            wrong_email = "test2@tester.com"
            wrong_password = "test2"
            wrong_auth = "Basic %s" % base64.b64encode("%s:%s" % (wrong_username, wrong_password))
            form = {"username":wrong_username, "email":wrong_email,"password":wrong_password,
                "password2":wrong_password}
            response = self.client.post(reverse(views.register),form, X_Experience_API_Version="1.0.0")

            stmt = json.dumps({"verb":{"id":"verb:verb/uri/attempted"},"actor":{"objectType":"Agent", "mbox":"mailto:r@r.com"},
                "object": {"objectType": "Activity", "id":"act:foogie",
                "definition": {"name": {"en-US":"testname3"},"description": {"en-US":"testdesc3"},
                "type": "http://www.adlnet.gov/experienceapi/activity-types/http://adlnet.gov/expapi/activities/cmi.interaction","interactionType": "fill-in","correctResponsesPattern": ["answer"],
                "extensions": {"ext:key1": "value1", "ext:key2": "value2","ext:key3": "value3"}}}, 
                "result": {"score":{"scaled":.85}, "completion": True, "success": True, "response": "kicked",
                "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:key1": "value1", "ext:key2":"value2"}},
                "context":{"registration": str(uuid.uuid1()), "contextActivities": {"other": {"id": "act:NewActivityID2"}},
                "revision": "food", "platform":"bard","language": "en-US", "extensions":{"ext:ckey1": "cval1",
                "ext:ckey2": "cval2"}}, "authority":{"objectType":"Agent","name":"auth","mbox":"mailto:auth@example.com"}})

            post_response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
                Authorization=wrong_auth, X_Experience_API_Version="1.0.0")
            self.assertEqual(post_response.status_code, 403)
            self.assertEqual(post_response.content, "This ActivityID already exists, and you do not have" + 
                            " the correct authority to create or update it.")

    def test_update_activity_correct_auth(self):
        self.bunchostmts()
        stmt = json.dumps({"verb": {"id":"verb:verb/url/changed-act"},"actor":{"objectType":"Agent", "mbox":"mailto:l@l.com"},
            "object": {"objectType": "Activity", "id":"act:foogie",
            "definition": {"name": {"en-US":"testname3"},"description": {"en-US":"testdesc3"},
            "type": "http://www.adlnet.gov/experienceapi/activity-types/http://adlnet.gov/expapi/activities/cmi.interaction","interactionType": "fill-in","correctResponsesPattern": ["answer"],
            "extensions": {"ext:key1": "value1", "ext:key2": "value2","ext:key3": "value3"}}}, 
            "result": {"score":{"scaled":.85}, "completion": True, "success": True, "response": "kicked",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:key1": "value1", "ext:key2":"value2"}},
            "context":{"registration": self.cguid8, "contextActivities": {"other": {"id": "act:NewActivityID2"}},
            "revision": "food", "platform":"bard","language": "en-US", "extensions":{"ext:ckey1": "cval1",
            "ext:ckey2": "cval2"}}, "authority":{"objectType":"Agent","name":"auth","mbox":"mailto:auth@example.com"}})

        post_response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        act = models.Activity.objects.get(activity_id="act:foogie")

        name_set = act.activity_definition_name
        desc_set = act.activity_definition_description

        self.assertEqual(name_set.keys()[1], "en-US")
        self.assertEqual(name_set.values()[1], "testname3")
        self.assertEqual(name_set.keys()[0], "en-GB")
        self.assertEqual(name_set.values()[0], "altname")

        self.assertEqual(desc_set.keys()[1], "en-US")
        self.assertEqual(desc_set.values()[1], "testdesc3")
        self.assertEqual(desc_set.keys()[0], "en-GB")
        self.assertEqual(desc_set.values()[0], "altdesc")

    def test_cors_post_put(self):
        content = {"verb":{"id":"verb:verb/url"}, "actor":{"objectType":"Agent", "mbox": "mailto:r@r.com"},
            "object": {"id":"act:test_cors_post_put"}}
        
        bdy = "statementId=886313e1-3b8a-5372-9b90-0c9aee199e5d&content=%s&Authorization=%s&Content-Type=application/json&X-Experience-API-Version=1.0.0" % (content, self.auth)
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode({"method":"PUT"}))
        response = self.client.post(path, bdy, content_type="application/x-www-form-urlencoded")
        self.assertEqual(response.status_code, 204)

        act = models.Activity.objects.get(activity_id="act:test_cors_post_put")
        self.assertEqual(act.activity_id, "act:test_cors_post_put")

        # This agent is created from registering an auth user, so won't be created if no HTTP_AUTH_ENABLED
        if settings.HTTP_AUTH_ENABLED:
            agent = models.Agent.objects.get(mbox="mailto:test1@tester.com")
            self.assertEqual(agent.name, "tester1")
            self.assertEqual(agent.mbox, "mailto:test1@tester.com")

    def test_issue_put(self):
        stmt_id = "33f60b35-e1b2-4ddc-9c6f-7b3f65244430" 
        stmt = json.dumps({"verb":{"id":"verb:verb/uri"},"object":{"id":"act:scorm.com/JsTetris_TCAPI","definition":{"type":"type:media",
            "name":{"en-US":"Js Tetris - Tin Can Prototype"},"description":{"en-US":"A game of tetris."}}},
            "context":{"contextActivities":{"grouping":{"id":"act:scorm.com/JsTetris_TCAPI"}},
            "registration":"6b1091be-2833-4886-b4a6-59e5e0b3c3f4"},
            "actor":{"mbox":"mailto:tom.creighton.ctr@adlnet.gov","name":"Tom Creighton"}})

        path = "%s?%s" % (reverse(views.statements), urllib.urlencode({"statementId":stmt_id}))
        put_stmt = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(put_stmt.status_code, 204) 

    def test_post_with_group(self):
        ot = "Group"
        name = "the group ST"
        mbox = "mailto:the.groupST@example.com"
        stmt = json.dumps({"actor":{"objectType":ot, "name":name, "mbox":mbox,"member":[{"name":"agentA","mbox":"mailto:agentA@example.com"}, {"name":"agentB","mbox":"mailto:agentB@example.com"}]},"verb":{"id": "http://verb/uri/created", "display":{"en-US":"created"}},
            "object": {"id":"act:i.pity.the.fool"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)
        g = models.Agent.objects.get(mbox="mailto:the.groupST@example.com")
        self.assertEquals(g.name, name)
        self.assertEquals(g.mbox, mbox)
        mems = g.member.values_list("name", flat=True)
        self.assertEquals(len(mems), 2)
        self.assertIn("agentA", mems)
        self.assertIn("agentB", mems)

    def test_post_with_group_member_not_array(self):
        ot = "Group"
        name = "the group ST"
        mbox = "mailto:the.groupST@example.com"
        members = "wrong"
        stmt = json.dumps({"actor":{"objectType":ot, "name":name, "mbox":mbox,"member":members},"verb":{"id": "http://verb/uri/created", "display":{"en-US":"created"}},
            "object": {"id":"act:i.pity.the.fool"}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Members is not a properly formatted array')


    def test_post_with_non_oauth_not_existing_group(self):
        ot = "Group"
        name = "the group ST"
        mbox = "mailto:the.groupST@example.com"
        stmt = json.dumps({"actor":{"name":"agentA","mbox":"mailto:agentA@example.com"},"verb":{"id": "http://verb/uri/joined", "display":{"en-US":"joined"}},
            "object": {"id":"act:i.pity.the.fool"}, "authority": {"objectType":ot, "name":name, "mbox":mbox,"member":[{"name":"agentA","mbox":"mailto:agentA@example.com"},{"name":"agentB","mbox":"mailto:agentB@example.com"}]}})
        
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(response.status_code, 400)
        self.assertIn("Statements cannot have a non-Oauth group as the authority", response.content)

    def test_post_with_non_oauth_existing_group(self):
        ot = "Group"
        name = "the group ST"
        mbox = "mailto:the.groupST@example.com"
        group = {"objectType":ot, "name":name, "mbox":mbox,"member":[{"name":"agentA","mbox":"mailto:agentA@example.com"},{"name":"agentB","mbox":"mailto:agentB@example.com"}]}
        gr_object = models.Agent.objects.retrieve_or_create(**group)

        stmt = json.dumps({"actor":{"name":"agentA","mbox":"mailto:agentA@example.com"},"verb":{"id": "http://verb/uri/joined", "display":{"en-US":"joined"}},
            "object": {"id":"act:i.pity.the.fool"}, "authority": {"objectType":ot, "name":name, "mbox":mbox,"member":[{"name":"agentA","mbox":"mailto:agentA@example.com"},{"name":"agentB","mbox":"mailto:agentB@example.com"}]}})
        
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, "Statements cannot have a non-Oauth group as the authority")

    def test_issue_put_no_version_header(self):
        stmt_id = '33f60b35-e1b2-4ddc-9c6f-7b3f65244431'
        stmt = json.dumps({"verb":"verb:completed","object":{"id":"act:scorm.com/JsTetris_TCAPI/level2",
            "definition":{"type":"media","name":{"en-US":"Js Tetris Level2"},
            "description":{"en-US":"Starting at 1, the higher the level, the harder the game."}}},
            "result":{"extensions":{"ext:time":104,"ext:apm":229,"ext:lines":5},"score":{"raw":9911,"min":0}},
            "context":{"contextActivities":{"grouping":{"id":"act:scorm.com/JsTetris_TCAPI"}},
            "registration":"b7be7d9d-bfe2-4917-8ccd-41a0d18dd953"},
            "actor":{"name":"tom creighton","mbox":"mailto:tom@example.com"}})

        path = '%s?%s' % (reverse(views.statements), urllib.urlencode({"statementId":stmt_id}))
        put_stmt = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth)
        self.assertEqual(put_stmt.status_code, 400)

    def test_issue_put_wrong_version_header(self):
        stmt_id = '33f60b35-e1b2-4ddc-9c6f-7b3f65244432'
        stmt = json.dumps({"verb": {"id":"verb:completed"},"object":{"id":"act:scorm.com/JsTetris_TCAPI/level2",
            "definition":{"type":"media","name":{"en-US":"Js Tetris Level2"},
            "description":{"en-US":"Starting at 1, the higher the level, the harder the game."}}},
            "result":{"extensions":{"ext:time":104,"ext:apm":229,"ext:lines":5},"score":{"raw":9911,"min":0}},
            "context":{"contextActivities":{"grouping":{"id":"act:scorm.com/JsTetris_TCAPI"}},
            "registration":"b7be7d9d-bfe2-4917-8ccd-41a0d18dd953"},
            "actor":{"name":"tom creighton","mbox":"mailto:tom@example.com"}})

        path = '%s?%s' % (reverse(views.statements), urllib.urlencode({"statementId":stmt_id}))
        put_stmt = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="0.90")
        self.assertEqual(put_stmt.status_code, 400)

    def test_issue_put_wrong_version_header_again(self):
        stmt_id = '33f60b35-e1b2-4ddc-9c6f-7b3f65244432'
        stmt = json.dumps({"verb":{"id":"verb:completed"},"object":{"id":"act:scorm.com/JsTetris_TCAPI/level2",
            "definition":{"type":"media","name":{"en-US":"Js Tetris Level2"},
            "description":{"en-US":"Starting at 1, the higher the level, the harder the game."}}},
            "result":{"extensions":{"ext:time":104,"ext:apm":229,"ext:lines":5},"score":{"raw":9911,"min":0}},
            "context":{"contextActivities":{"grouping":{"id":"act:scorm.com/JsTetris_TCAPI"}},
            "registration":"b7be7d9d-bfe2-4917-8ccd-41a0d18dd953"},
            "actor":{"name":"tom creighton","mbox":"mailto:tom@example.com"}})

        path = '%s?%s' % (reverse(views.statements), urllib.urlencode({"statementId":stmt_id}))
        put_stmt = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.")
        self.assertEqual(put_stmt.status_code, 400)

    def test_issue_put_wrong_version_header_1_1(self):
        stmt_id = '33f60b35-e1b2-4ddc-9c6f-7b3f65244432'
        stmt = json.dumps({"verb":{"id":"verb:completed"},"object":{"id":"act:scorm.com/JsTetris_TCAPI/level2",
            "definition":{"type":"media","name":{"en-US":"Js Tetris Level2"},
            "description":{"en-US":"Starting at 1, the higher the level, the harder the game."}}},
            "result":{"extensions":{"ext:time":104,"ext:apm":229,"ext:lines":5},"score":{"raw":9911,"min":0}},
            "context":{"contextActivities":{"grouping":{"id":"act:scorm.com/JsTetris_TCAPI"}},
            "registration":"b7be7d9d-bfe2-4917-8ccd-41a0d18dd953"},
            "actor":{"name":"tom creighton","mbox":"mailto:tom@example.com"}})

        path = '%s?%s' % (reverse(views.statements), urllib.urlencode({"statementId":stmt_id}))
        put_stmt = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.1.")
        self.assertEqual(put_stmt.status_code, 400)

    # Use this test to make sure stmts are being returned correctly with all data - doesn't check timestamp and stored fields
    def test_all_fields_activity_as_object(self):
        self.bunchostmts()
        nested_st_id = str(uuid.uuid1())
        nest_param = {"statementId":nested_st_id}
        nest_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(nest_param))
        nested_stmt = json.dumps({"actor":{"objectType":"Agent","mbox": "mailto:tincan@adlnet.gov"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/assess","display": {"en-US":"assessed"}},
            "object":{"id":"http://example.adlnet.gov/tincan/example/simplestatement"}})
        put_sub_stmt = self.client.put(nest_path, nested_stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(put_sub_stmt.status_code, 204)        

        stmt_id = str(uuid.uuid1())
        context_id= str(uuid.uuid1())
        param = {"statementId":stmt_id} 
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        stmt = json.dumps({"actor":{"objectType":"Agent","name": "Lou Wolford","account":{"homePage":"http://example.com", "name":"uniqueName"}},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/created","display": {"en-US":"created", "en-GB":"made"}},
            "object": {"objectType": "Activity", "id":"http:adlnet.gov/my/Activity/URL",
            "definition": {"name": {"en-US":"actName", "en-GB": "anotherActName"},
            "description": {"en-US":"This is my activity description.", "en-GB": "This is another activity description."},
            "type": "http://adlnet.gov/expapi/activities/cmi.interaction",
            "moreInfo": "http://some/activity/url",
            "interactionType": "choice",
            "correctResponsesPattern": ["golf", "tetris"],
            "choices":[{"id": "golf", "description": {"en-US":"Golf Example", "en-GB": "GOLF"}},
            {"id": "tetris","description":{"en-US": "Tetris Example", "en-GB": "TETRIS"}},
            {"id":"facebook", "description":{"en-US":"Facebook App", "en-GB": "FACEBOOK"}},
            {"id":"scrabble", "description": {"en-US": "Scrabble Example", "en-GB": "SCRABBLE"}}],
            "extensions": {"ext:key1": "value1", "ext:key2": "value2","ext:key3": "value3"}}}, 
            "result": {"score":{"scaled":.85, "raw": 85, "min":0, "max":100}, "completion": True, "success": False, "response": "Well done",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:resultKey1": "resultValue1", "ext:resultKey2":"resultValue2"}},
            "context":{"registration": context_id, "contextActivities": {"other": {"id": "http://example.adlnet.gov/tincan/example/test"},
            "grouping":{"id":"http://groupingID"} },
            "revision": "Spelling error in choices.", "platform":"Platform is web browser.","language": "en-US",
            "statement":{"objectType":"StatementRef", "id":str(nested_st_id)},
            "extensions":{"ext:contextKey1": "contextVal1","ext:contextKey2": "contextVal2"}},
            "timestamp":self.firstTime})

        put_stmt = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(put_stmt.status_code, 204)
        param = {"statementId":stmt_id}
        get_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        get_response = self.client.get(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        
        the_returned = json.loads(get_response.content)
        self.assertEqual(the_returned['id'], stmt_id)
        self.assertEqual(the_returned['version'], "1.0.0")
        self.assertEqual(the_returned['actor']['objectType'], 'Agent')
        self.assertEqual(the_returned['actor']['name'], 'Lou Wolford')
        self.assertEqual(the_returned['actor']['account']['name'], 'uniqueName')
        self.assertEqual(the_returned['actor']['account']['homePage'], 'http://example.com')

        self.assertEqual(the_returned['verb']['id'], 'http://adlnet.gov/expapi/verbs/created')
        self.assertEqual(the_returned['verb']['display']['en-GB'], 'made')
        self.assertEqual(the_returned['verb']['display']['en-US'], 'created')

        self.assertEqual(the_returned['result']['completion'], True)
        self.assertEqual(the_returned['result']['duration'], 'P3Y6M4DT12H30M5S')
        self.assertEqual(the_returned['result']['extensions']['ext:resultKey1'], 'resultValue1')
        self.assertEqual(the_returned['result']['extensions']['ext:resultKey2'], 'resultValue2')
        self.assertEqual(the_returned['result']['response'], 'Well done')
        self.assertEqual(the_returned['result']['score']['max'], 100)
        self.assertEqual(the_returned['result']['score']['min'], 0)
        self.assertEqual(the_returned['result']['score']['raw'], 85)
        self.assertEqual(the_returned['result']['score']['scaled'], 0.85)
        self.assertEqual(the_returned['result']['success'], False)

        self.assertEqual(the_returned['context']['contextActivities']['other'][0]['id'], 'http://example.adlnet.gov/tincan/example/test')
        self.assertEqual(the_returned['context']['extensions']['ext:contextKey1'], 'contextVal1')
        self.assertEqual(the_returned['context']['extensions']['ext:contextKey2'], 'contextVal2')
        self.assertEqual(the_returned['context']['language'], 'en-US')
        self.assertEqual(the_returned['context']['platform'], 'Platform is web browser.')
        self.assertEqual(the_returned['context']['registration'], context_id)
        self.assertEqual(the_returned['context']['revision'], 'Spelling error in choices.')
        self.assertEqual(the_returned['context']['statement']['id'], str(nested_st_id))
        self.assertEqual(the_returned['context']['statement']['objectType'], 'StatementRef')

        if settings.HTTP_AUTH_ENABLED:
            self.assertEqual(the_returned['authority']['objectType'], 'Agent')
            self.assertEqual(the_returned['authority']['name'], 'tester1')
            self.assertEqual(the_returned['authority']['mbox'], 'mailto:test1@tester.com')

        self.assertEqual(the_returned['object']['id'], 'http:adlnet.gov/my/Activity/URL')
        self.assertEqual(the_returned['object']['objectType'], 'Activity')
        self.assertEqual(the_returned['object']['definition']['description']['en-US'], 'This is my activity description.')
        self.assertEqual(the_returned['object']['definition']['description']['en-GB'], 'This is another activity description.')
        self.assertEqual(the_returned['object']['definition']['interactionType'], 'choice')
        self.assertEqual(the_returned['object']['definition']['name']['en-US'], 'actName')
        self.assertEqual(the_returned['object']['definition']['name']['en-GB'], 'anotherActName')
        self.assertEqual(the_returned['object']['definition']['type'], 'http://adlnet.gov/expapi/activities/cmi.interaction')
        self.assertEqual(the_returned['object']['definition']['moreInfo'], 'http://some/activity/url')
        self.assertEqual(the_returned['object']['definition']['extensions']['ext:key1'], 'value1')
        self.assertEqual(the_returned['object']['definition']['extensions']['ext:key2'], 'value2')
        self.assertEqual(the_returned['object']['definition']['extensions']['ext:key3'], 'value3')
        # arrays.. testing slightly differently
        choices_str = json.dumps(the_returned['object']['definition']['choices'])
        self.assertIn('description', choices_str)
        self.assertIn('id', choices_str)
        self.assertIn('GOLF', choices_str)
        self.assertIn('Golf Example', choices_str)
        self.assertIn('golf', choices_str)
        self.assertIn('TETRIS', choices_str)
        self.assertIn('Tetris Example', choices_str)
        self.assertIn('tetris', choices_str)
        self.assertIn('FACEBOOK', choices_str)
        self.assertIn('Facebook App', choices_str)
        self.assertIn('Facebook', choices_str)
        self.assertIn('SCRABBLE', choices_str)
        self.assertIn('Scrabble Example', choices_str)
        self.assertIn('scrabble', choices_str)

        crp_str = json.dumps(the_returned['object']['definition']['correctResponsesPattern'])
        self.assertIn('golf', crp_str)
        self.assertIn('tetris', crp_str)


    # Use this test to make sure stmts are being returned correctly with all data - doesn't check timestamp, stored fields
    def test_all_fields_agent_as_object(self):
        nested_st_id = str(uuid.uuid1())
        nest_param = {"statementId":nested_st_id}
        nest_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(nest_param))
        nested_stmt = json.dumps({"actor":{"objectType":"Agent","mbox": "mailto:tincan@adlnet.gov"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/assess","display": {"en-US":"assessed"}},
            "object":{"id":"http://example.adlnet.gov/tincan/example/simplestatement"}})
        put_sub_stmt = self.client.put(nest_path, nested_stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(put_sub_stmt.status_code, 204)        

        stmt_id = str(uuid.uuid1())
        context_id= str(uuid.uuid1())
        param = {"statementId":stmt_id} 
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        msha = hashlib.sha1("mailto:tom@example.com").hexdigest()                
        stmt = json.dumps({"actor":{"objectType":"Agent","name": "Lou Wolford","account":{"homePage":"http://example.com", "name":"louUniqueName"}},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/helped","display": {"en-US":"helped", "en-GB":"assisted"}},
            "object": {"objectType":"Agent","name": "Tom Creighton","mbox_sha1sum":msha}, 
            "result": {"score":{"scaled":.85, "raw": 85, "min":0, "max":100}, "completion": True, "success": True, "response": "Well done",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:resultKey1": "resultValue1", "ext:resultKey2":"resultValue2"}},
            "context":{"registration": context_id, "contextActivities": {"other": {"id": "http://example.adlnet.gov/tincan/example/test"}},
            "language": "en-US",
            "statement":{"objectType":"StatementRef", "id":str(nested_st_id)},
            "extensions":{"ext:contextKey1": "contextVal1","ext:contextKey2": "contextVal2"}},
            "timestamp":self.firstTime})
        
        put_stmt = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(put_stmt.status_code, 204)
        param = {"statementId":stmt_id}
        get_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        get_response = self.client.get(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        
        the_returned = json.loads(get_response.content)
        self.assertEqual(the_returned['id'], stmt_id)
        self.assertEqual(the_returned['version'], "1.0.0")
        self.assertEqual(the_returned['actor']['objectType'], 'Agent')
        self.assertEqual(the_returned['actor']['name'], 'Lou Wolford')
        self.assertEqual(the_returned['actor']['account']['name'], 'louUniqueName')
        self.assertEqual(the_returned['actor']['account']['homePage'], 'http://example.com')

        self.assertEqual(the_returned['verb']['id'], 'http://adlnet.gov/expapi/verbs/helped')
        self.assertEqual(the_returned['verb']['display']['en-GB'], 'assisted')
        self.assertEqual(the_returned['verb']['display']['en-US'], 'helped')

        self.assertEqual(the_returned['result']['completion'], True)
        self.assertEqual(the_returned['result']['duration'], 'P3Y6M4DT12H30M5S')
        self.assertEqual(the_returned['result']['extensions']['ext:resultKey1'], 'resultValue1')
        self.assertEqual(the_returned['result']['extensions']['ext:resultKey2'], 'resultValue2')
        self.assertEqual(the_returned['result']['response'], 'Well done')
        self.assertEqual(the_returned['result']['score']['max'], 100)
        self.assertEqual(the_returned['result']['score']['min'], 0)
        self.assertEqual(the_returned['result']['score']['raw'], 85)
        self.assertEqual(the_returned['result']['score']['scaled'], 0.85)
        self.assertEqual(the_returned['result']['success'], True)

        self.assertEqual(the_returned['context']['contextActivities']['other'][0]['id'], 'http://example.adlnet.gov/tincan/example/test')
        self.assertEqual(the_returned['context']['extensions']['ext:contextKey1'], 'contextVal1')
        self.assertEqual(the_returned['context']['extensions']['ext:contextKey2'], 'contextVal2')
        self.assertEqual(the_returned['context']['language'], 'en-US')
        self.assertEqual(the_returned['context']['registration'], context_id)
        self.assertEqual(the_returned['context']['statement']['id'], str(nested_st_id))
        self.assertEqual(the_returned['context']['statement']['objectType'], 'StatementRef')

        if settings.HTTP_AUTH_ENABLED:
            self.assertEqual(the_returned['authority']['objectType'], 'Agent')
            self.assertEqual(the_returned['authority']['name'], 'tester1')
            self.assertEqual(the_returned['authority']['mbox'], 'mailto:test1@tester.com')


        self.assertEqual(the_returned['object']['objectType'], 'Agent')
        self.assertEqual(the_returned['object']['name'], 'Tom Creighton')
        self.assertEqual(the_returned['object']['mbox_sha1sum'], msha)


    # Use this test to make sure stmts are being returned correctly with all data - doesn't check timestamps or stored fields
    def test_all_fields_substatement_as_object(self):
        nested_st_id = str(uuid.uuid1())
        nest_param = {"statementId":nested_st_id}
        nest_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(nest_param))
        nested_stmt = json.dumps({"actor":{"objectType":"Agent","mbox": "mailto:tincannest@adlnet.gov"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/assess","display": {"en-US":"assessed", "en-GB":"graded"}},
            "object":{"id":"http://example.adlnet.gov/tincan/example/simplestatement"}})
        put_sub_stmt = self.client.put(nest_path, nested_stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(put_sub_stmt.status_code, 204)        


        nested_sub_st_id = str(uuid.uuid1())
        nest_sub_param = {"statementId":nested_sub_st_id}
        nest_sub_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(nest_sub_param))        
        nested_sub_stmt = json.dumps({"actor":{"objectType":"Agent","mbox": "mailto:tincannestsub@adlnet.gov"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/verb","display": {"en-US":"verb", "en-GB":"altVerb"}},
            "object":{"id":"http://example.adlnet.gov/tincan/example/simplenestedsubstatement"}})
        put_nest_sub_stmt = self.client.put(nest_sub_path, nested_sub_stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(put_nest_sub_stmt.status_code, 204)


        stmt_id = str(uuid.uuid1())
        context_id= str(uuid.uuid1())
        sub_context_id= str(uuid.uuid1())        
        param = {"statementId":stmt_id} 
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        msha = hashlib.sha1("mailto:tom@example.com").hexdigest()        
        
        stmt = json.dumps({"actor":{"objectType":"Agent","name": "Lou Wolford","account":{"homePage":"http://example.com", "name":"louUniqueName"}},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/said","display": {"en-US":"said", "en-GB":"talked"}},
            "object": {"objectType": "SubStatement", "actor":{"objectType":"Agent","name":"Tom Creighton","mbox": "mailto:tom@adlnet.gov"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/assess","display": {"en-US":"assessed", "en-GB": "Graded"}},
            "object":{"id":"http://example.adlnet.gov/tincan/example/simplestatement",
            'definition': {'name': {'en-US':'SubStatement name'},
            'description': {'en-US':'SubStatement description'},
            'type': 'http://adlnet.gov/expapi/activities/cmi.interaction','interactionType': 'matching',
            'correctResponsesPattern': ['lou.3,tom.2,andy.1'],'source':[{'id': 'lou',
            'description': {'en-US':'Lou', 'it': 'Luigi'}},{'id': 'tom','description':{'en-US': 'Tom', 'it':'Tim'}},
            {'id':'andy', 'description':{'en-US':'Andy'}}],'target':[{'id':'1',
            'description':{'en-US': 'ADL LRS'}},{'id':'2','description':{'en-US': 'lrs'}},
            {'id':'3', 'description':{'en-US': 'the adl lrs', 'en-CH': 'the lrs'}}]}},
            "result": {"score":{"scaled":.50, "raw": 50, "min":1, "max":51}, "completion": True,
            "success": True, "response": "Poorly done",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:resultKey11": "resultValue11", "ext:resultKey22":"resultValue22"}},
            "context":{"registration": sub_context_id,
            "contextActivities": {"other": {"id": "http://example.adlnet.gov/tincan/example/test/nest"}},
            "revision": "Spelling error in target.", "platform":"Ipad.","language": "en-US",
            "statement":{"objectType":"StatementRef", "id":str(nested_sub_st_id)},
            "extensions":{"ext:contextKey11": "contextVal11","ext:contextKey22": "contextVal22"}}}, 
            "result": {"score":{"scaled":.85, "raw": 85, "min":0, "max":100}, "completion": True, "success": True, "response": "Well done",
            "duration": "P3Y6M4DT12H30M5S", "extensions":{"ext:resultKey1": "resultValue1", "ext:resultKey2":"resultValue2"}},
            "context":{"registration": context_id, "contextActivities": {"other": {"id": "http://example.adlnet.gov/tincan/example/test"}},
            "revision": "Spelling error in choices.", "platform":"Platform is web browser.","language": "en-US",
            "statement":{"objectType":"StatementRef", "id":str(nested_st_id)},
            "extensions":{"ext:contextKey1": "contextVal1","ext:contextKey2": "contextVal2"}},
            "timestamp":self.firstTime})

        put_stmt = self.client.put(path, stmt, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(put_stmt.status_code, 204)
        param = {"statementId":stmt_id}
        get_path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        get_response = self.client.get(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        
        the_returned = json.loads(get_response.content)
        self.assertEqual(the_returned['id'], stmt_id)
        self.assertEqual(the_returned['version'], "1.0.0")
        self.assertEqual(the_returned['actor']['objectType'], 'Agent')
        self.assertEqual(the_returned['actor']['name'], 'Lou Wolford')
        self.assertEqual(the_returned['actor']['account']['name'], 'louUniqueName')
        self.assertEqual(the_returned['actor']['account']['homePage'], 'http://example.com')

        self.assertEqual(the_returned['verb']['id'], 'http://adlnet.gov/expapi/verbs/said')
        self.assertEqual(the_returned['verb']['display']['en-GB'], 'talked')
        self.assertEqual(the_returned['verb']['display']['en-US'], 'said')
        
        self.assertEqual(the_returned['object']['actor']['objectType'], 'Agent')
        self.assertEqual(the_returned['object']['actor']['name'], 'Tom Creighton')
        self.assertEqual(the_returned['object']['actor']['mbox'], 'mailto:tom@adlnet.gov')
        
        self.assertEqual(the_returned['object']['context']['registration'], sub_context_id)
        self.assertEqual(the_returned['object']['context']['language'], 'en-US')
        self.assertEqual(the_returned['object']['context']['platform'], 'Ipad.')
        self.assertEqual(the_returned['object']['context']['revision'], 'Spelling error in target.')
        self.assertEqual(the_returned['object']['context']['statement']['id'], str(nested_sub_st_id))
        self.assertEqual(the_returned['object']['context']['statement']['objectType'], 'StatementRef')

        self.assertEqual(the_returned['object']['context']['contextActivities']['other'][0]['id'], 'http://example.adlnet.gov/tincan/example/test/nest')
        self.assertEqual(the_returned['object']['context']['extensions']['ext:contextKey11'], 'contextVal11')
        self.assertEqual(the_returned['object']['context']['extensions']['ext:contextKey22'], 'contextVal22')
        self.assertEqual(the_returned['object']['object']['id'], 'http://example.adlnet.gov/tincan/example/simplestatement')
        self.assertEqual(the_returned['object']['object']['definition']['type'], 'http://adlnet.gov/expapi/activities/cmi.interaction')
        self.assertEqual(the_returned['object']['object']['definition']['description']['en-US'], 'SubStatement description')
        self.assertEqual(the_returned['object']['object']['definition']['interactionType'], 'matching')
        self.assertEqual(the_returned['object']['object']['definition']['name']['en-US'], 'SubStatement name')
        # arrays.. testing slightly differently
        source_str = json.dumps(the_returned['object']['object']['definition']['source'])
        self.assertIn('description', source_str)
        self.assertIn('id', source_str)
        self.assertIn('Lou', source_str)
        self.assertIn('Luigi', source_str)
        self.assertIn('lou', source_str)
        self.assertIn('Tom', source_str)
        self.assertIn('Tim', source_str)
        self.assertIn('tom', source_str)
        self.assertIn('Andy', source_str)
        self.assertIn('andy', source_str)

        target_str = json.dumps(the_returned['object']['object']['definition']['target'])
        self.assertIn('description', target_str)
        self.assertIn('id', target_str)
        self.assertIn('ADL LRS', target_str)
        self.assertIn('1', target_str)
        self.assertIn('lrs', target_str)
        self.assertIn('2', target_str)
        self.assertIn('the lrs', target_str)
        self.assertIn('the adl lrs', target_str)
        self.assertIn('3', target_str)
        
        self.assertEqual(the_returned['object']['objectType'], 'SubStatement')

        self.assertEqual(the_returned['object']['result']['completion'], True)
        self.assertEqual(the_returned['object']['result']['duration'], 'P3Y6M4DT12H30M5S')
        self.assertEqual(the_returned['object']['result']['extensions']['ext:resultKey11'], 'resultValue11')
        self.assertEqual(the_returned['object']['result']['extensions']['ext:resultKey22'], 'resultValue22')
        self.assertEqual(the_returned['object']['result']['response'], 'Poorly done')
        self.assertEqual(the_returned['object']['result']['score']['max'], 51)
        self.assertEqual(the_returned['object']['result']['score']['min'], 1)
        self.assertEqual(the_returned['object']['result']['score']['raw'], 50)
        self.assertEqual(the_returned['object']['result']['score']['scaled'], 0.5)
        self.assertEqual(the_returned['object']['result']['success'], True)
        
        self.assertEqual(the_returned['object']['verb']['id'], 'http://adlnet.gov/expapi/verbs/assess')
        self.assertEqual(the_returned['object']['verb']['display']['en-GB'], 'Graded')
        self.assertEqual(the_returned['object']['verb']['display']['en-US'], 'assessed')

        self.assertEqual(the_returned['result']['completion'], True)
        self.assertEqual(the_returned['result']['duration'], 'P3Y6M4DT12H30M5S')
        self.assertEqual(the_returned['result']['extensions']['ext:resultKey1'], 'resultValue1')
        self.assertEqual(the_returned['result']['extensions']['ext:resultKey2'], 'resultValue2')
        self.assertEqual(the_returned['result']['response'], 'Well done')
        self.assertEqual(the_returned['result']['score']['max'], 100)
        self.assertEqual(the_returned['result']['score']['min'], 0)
        self.assertEqual(the_returned['result']['score']['raw'], 85)
        self.assertEqual(the_returned['result']['score']['scaled'], 0.85)
        self.assertEqual(the_returned['result']['success'], True)

        self.assertEqual(the_returned['context']['contextActivities']['other'][0]['id'], 'http://example.adlnet.gov/tincan/example/test')
        self.assertEqual(the_returned['context']['extensions']['ext:contextKey1'], 'contextVal1')
        self.assertEqual(the_returned['context']['extensions']['ext:contextKey2'], 'contextVal2')
        self.assertEqual(the_returned['context']['language'], 'en-US')
        self.assertEqual(the_returned['context']['platform'], 'Platform is web browser.')
        self.assertEqual(the_returned['context']['registration'], context_id)
        self.assertEqual(the_returned['context']['revision'], 'Spelling error in choices.')
        self.assertEqual(the_returned['context']['statement']['id'], str(nested_st_id))
        self.assertEqual(the_returned['context']['statement']['objectType'], 'StatementRef')

        if settings.HTTP_AUTH_ENABLED:
            self.assertEqual(the_returned['authority']['objectType'], 'Agent')
            self.assertEqual(the_returned['authority']['name'], 'tester1')
            self.assertEqual(the_returned['authority']['mbox'], 'mailto:test1@tester.com')

    # Third stmt in list is missing actor - should throw error and perform cascading delete on first three statements
    def test_post_list_rollback(self):
        self.bunchostmts()
        cguid1 = str(uuid.uuid1())
        stmts = json.dumps([
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-failed","display": {"en-US":"wrong-failed"}},
            "object": {"id":"act:test_wrong_list_post2"},"actor":{"objectType":"Agent",
            "mbox":"mailto:wrong-t@t.com"},"result": {"score":{"scaled":.99}, "completion": True, "success": True,
            "response": "wrong","extensions":{"ext:resultwrongkey1": "value1", "ext:resultwrongkey2":"value2"}}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-kicked","display": {"en-US":"wrong-kicked"}},
            "object": {"objectType": "Activity", "id":"act:test_wrong_list_post",
            "definition": {"name": {"en-US":"wrongactName", "en-GB": "anotherActName"},
            "description": {"en-US":"This is my activity description.", "en-GB": "This is another activity description."},
            "type": "http://www.adlnet.gov/experienceapi/activity-types/http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "choice",
            "correctResponsesPattern": ["wronggolf", "wrongtetris"],
            "choices":[{"id": "wronggolf", "description": {"en-US":"Golf Example", "en-GB": "GOLF"}},
            {"id": "wrongtetris","description":{"en-US": "Tetris Example", "en-GB": "TETRIS"}},
            {"id":"wrongfacebook", "description":{"en-US":"Facebook App", "en-GB": "FACEBOOK"}},
            {"id":"wrongscrabble", "description": {"en-US": "Scrabble Example", "en-GB": "SCRABBLE"}}],
            "extensions": {"ext:wrongkey1": "wrongvalue1", "ext:wrongkey2": "wrongvalue2","ext:wrongkey3": "wrongvalue3"}}},
            "actor":{"objectType":"Agent", "mbox":"mailto:wrong-t@t.com"}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-passed","display": {"en-US":"wrong-passed"}},"object": {"id":"act:test_wrong_list_post1"},
            "actor":{"objectType":"Agent", "mbox":"mailto:wrong-t@t.com"},"context":{"registration": cguid1, "contextActivities": {"other": {"id": "act:wrongActivityID2"}},
            "revision": "wrong", "platform":"wrong","language": "en-US", "extensions":{"ext:wrongkey1": "wrongval1",
            "ext:wrongkey2": "wrongval2"}}},            
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-kicked","display": {"en-US":"wrong-kicked"}},"object": {"id":"act:test_wrong_list_post2"}},            
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-kicked","display": {"en-US":"wrong-kicked"}},"object": {"id":"act:test_wrong_list_post4"}, "actor":{"objectType":"Agent", "mbox":"wrong-t@t.com"}}])
        
        response = self.client.post(reverse(views.statements), stmts,  content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('actor is missing in Statement', response.content)
                
        verbs = models.Verb.objects.filter(verb_id__contains='wrong')
        
        activities = models.Activity.objects.filter(activity_id__contains='test_wrong_list_post')
        
        statements = models.Statement.objects.all()
        # 11 statements from setup
        self.assertEqual(len(statements), 11)

        self.assertEqual(len(verbs), 0)
        self.assertEqual(len(activities), 0)

    def test_post_list_rollback_part_2(self):
        self.bunchostmts()
        stmts = json.dumps([{"object": {"objectType":"Agent","name":"john","mbox":"mailto:john@john.com"},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/wrong","display": {"wrong-en-US":"wrong"}},
            "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/created"},
            "object": {"objectType": "Activity", "id":"act:foogie",
            "definition": {"name": {"en-US":"testname2", "en-GB": "altname"},
            "description": {"en-US":"testdesc2", "en-GB": "altdesc"}, "type": "http://www.adlnet.gov/experienceapi/activity-types/http://adlnet.gov/expapi/activities/cmi.interaction",
            "interactionType": "fill-in","correctResponsesPattern": ["answer"]}},
            "actor":{"objectType":"Agent", "mbox":"mailto:wrong-t@t.com"}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-kicked"},"object": {"id":"act:test_wrong_list_post2"}}])

        response = self.client.post(reverse(views.statements), stmts,  content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('actor is missing in Statement', response.content)

        created_verbs = models.Verb.objects.filter(verb_id__contains='http://adlnet.gov/expapi/verbs/created')
        wrong_verbs = models.Verb.objects.filter(verb_id__contains='http://adlnet.gov/expapi/verbs/wrong')
        
        activities = models.Activity.objects.filter(activity_id='act:foogie')
        
        statements = models.Statement.objects.all()

        wrong_agent = models.Agent.objects.filter(mbox='mailto:wrong-t@t.com')
        john_agent = models.Agent.objects.filter(mbox='mailto:john@john.com')
        s_agent = models.Agent.objects.filter(mbox='mailto:s@s.com')
        auth_agent = models.Agent.objects.filter(mbox='mailto:test1@tester.com')

        self.assertEqual(len(created_verbs), 1)
        self.assertEqual(len(wrong_verbs), 0)

        self.assertEqual(len(activities), 1)
        
        self.assertEqual(len(statements), 11)

        self.assertEqual(len(wrong_agent), 0)
        self.assertEqual(len(john_agent), 1)
        self.assertEqual(len(s_agent), 1)

        if settings.HTTP_AUTH_ENABLED:
            self.assertEqual(len(auth_agent), 1)

    def test_post_list_rollback_with_void(self):
        self.bunchostmts()
        stmts = json.dumps([{"actor":{"objectType":"Agent","mbox":"mailto:only-s@s.com"},
            "object": {"objectType":"StatementRef","id":str(self.exist_stmt_id)},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/voided","display": {"en-US":"voided"}}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-kicked"},"object": {"id":"act:test_wrong_list_post2"}}])

        response = self.client.post(reverse(views.statements), stmts,  content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('actor is missing in Statement', response.content)
        voided_st = models.Statement.objects.get(statement_id=str(self.exist_stmt_id))
        voided_verb = models.Verb.objects.filter(verb_id__contains='voided')
        only_actor = models.Agent.objects.filter(mbox="mailto:only-s@s.com")
        statements = models.Statement.objects.all()

        self.assertEqual(len(statements), 11)
        self.assertEqual(voided_st.voided, False)
        self.assertEqual(len(voided_verb), 0)
        self.assertEqual(len(only_actor), 0)

    def test_post_list_rollback_with_subs(self):
        self.bunchostmts()
        sub_context_id = str(uuid.uuid1())
        stmts = json.dumps([{"actor":{"objectType":"Agent","mbox":"mailto:wrong-s@s.com"},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/wrong","display": {"wrong-en-US":"wrong"}},
            "object": {"objectType":"Agent","name":"john","mbox":"mailto:john@john.com"}},
            {"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/wrong-next","display": {"wrong-en-US":"wrong-next"}},
            "object":{"objectType":"SubStatement",
            "actor":{"objectType":"Agent","mbox":"mailto:wrong-ss@ss.com"},"verb": {"id":"http://adlnet.gov/expapi/verbs/wrong-sub"},
            "object": {"objectType":"Activity", "id":"act:wrong-testex.com"}, "result":{"completion": True, "success": True,
            "response": "sub-wrong-kicked"}, "context":{"registration": sub_context_id,
            "contextActivities": {"other": {"id": "act:sub-wrong-ActivityID"}},"revision": "foo", "platform":"bar",
            "language": "en-US", "extensions":{"ext:wrong-k1": "v1", "ext:wrong-k2": "v2"}}}},
            {"verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-kicked"},"object": {"id":"act:test_wrong_list_post2"}}])
        response = self.client.post(reverse(views.statements), stmts,  content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('actor is missing in Statement', response.content)

        s_agent = models.Agent.objects.filter(mbox="mailto:wrong-s@s.com")
        ss_agent = models.Agent.objects.filter(mbox="mailto:wrong-ss@ss.com")
        john_agent  = models.Agent.objects.filter(mbox="mailto:john@john.com")
        subs = models.SubStatement.objects.all()
        wrong_verb = models.Verb.objects.filter(verb_id__contains="wrong")
        activities = models.Activity.objects.filter(activity_id__contains="wrong")
        statements = models.Statement.objects.all()

        self.assertEqual(len(statements), 11)
        self.assertEqual(len(s_agent), 0)
        self.assertEqual(len(ss_agent), 0)
        self.assertEqual(len(john_agent), 1)
        # Only 1 sub from setup
        self.assertEqual(len(subs), 1)
        self.assertEqual(len(wrong_verb), 0)
        self.assertEqual(len(activities), 0)


    def test_post_list_rollback_context_activities(self):
        self.bunchostmts()
        sub_context_id = str(uuid.uuid1())
        # Will throw error and need to rollback b/c last stmt is missing actor
        stmts = json.dumps([{
            "actor":{"objectType":"Agent","mbox":"mailto:wrong-s@s.com"},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/wrong","display": {"wrong-en-US":"wrong"}},
            "object": {"objectType":"Agent","name":"john","mbox":"mailto:john@john.com"}},
            {
            "actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "verb": {"id": "http://adlnet.gov/expapi/verbs/wrong-next","display": {"wrong-en-US":"wrong-next"}},
            "object":{
                "objectType":"SubStatement",
                    "actor":{"objectType":"Agent","mbox":"mailto:wrong-ss@ss.com"},
                    "verb": {"id":"http://adlnet.gov/expapi/verbs/wrong-sub"},
                    "object": {"objectType":"Activity", "id":"act:wrong-testex.com"},
                    "result":{"completion": True, "success": True,"response": "sub-wrong-kicked"},
                    "context":{
                        "registration": sub_context_id,
                        "contextActivities": {
                            "other": [{"id": "act:subwrongActivityID"},{"id":"act:foogie"}]},
                        "revision": "foo", "platform":"bar","language": "en-US",
                        "extensions":{"ext:wrong-k1": "v1", "ext:wrong-k2": "v2"}}
                    }
            },
            {
            "verb":{"id": "http://adlnet.gov/expapi/verbs/wrong-kicked"},
            "object": {"id":"act:test_wrong_list_post2"}}])
 
        response = self.client.post(reverse(views.statements), stmts,  content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('actor is missing in Statement', response.content)

        s_agent = models.Agent.objects.filter(mbox="mailto:wrong-s@s.com")
        ss_agent = models.Agent.objects.filter(mbox="mailto:wrong-ss@ss.com")
        john_agent  = models.Agent.objects.filter(mbox="mailto:john@john.com")
        subs = models.SubStatement.objects.all()
        wrong_verb = models.Verb.objects.filter(verb_id__contains="wrong")
        wrong_activities = models.Activity.objects.filter(activity_id__contains="wrong")
        foogie_activities = models.Activity.objects.filter(activity_id__exact="act:foogie")
        statements = models.Statement.objects.all()

        self.assertEqual(len(statements), 11)
        self.assertEqual(len(s_agent), 0)
        self.assertEqual(len(ss_agent), 0)
        self.assertEqual(len(john_agent), 1)
        # Only 1 sub from setup
        self.assertEqual(len(subs), 1)
        self.assertEqual(len(wrong_verb), 0)
        self.assertEqual(len(wrong_activities), 0)
        self.assertEqual(len(foogie_activities), 1)
      

    def test_unique_actor_authority(self):
        stmt = json.dumps({"actor":{"objectType": "Agent", "mbox":"mailto:timmay@timmay.com", "name":"timmay"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/passed","display": {"en-US":"passed"}},
            "object": {"id":"act:test_post"}})

        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        act = models.Activity.objects.get(activity_id="act:test_post")
        self.assertEqual(act.activity_id, "act:test_post")
        agent = models.Agent.objects.get(mbox="mailto:timmay@timmay.com")
        self.assertEqual(agent.name, "timmay")

        response2 = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth2, X_Experience_API_Version="1.0.0")

        self.assertEqual(response2.status_code, 200)
        act2 = models.Activity.objects.get(activity_id="act:test_post")
        self.assertEqual(act2.activity_id, "act:test_post")
        agent2 = models.Agent.objects.get(mbox="mailto:timmay@timmay.com")
        self.assertEqual(agent2.name, "timmay")

    def test_stmts_w_same_regid(self):
        stmt1_guid = str(uuid.uuid1())
        stmt2_guid = str(uuid.uuid1())
        reg_guid = str(uuid.uuid1())
        stmt1 = json.dumps({"actor":{"mbox":"mailto:tom@example.com"},
                            "verb":{"id":"http:adlnet.gov/expapi/verbs/tested",
                                    "display":{"en-US":"tested"}},
                            "object":{"id":"test:same.regid"},
                            "context":{"registration":reg_guid}
                            })
        stmt2 = json.dumps({"actor":{"mbox":"mailto:tom@example.com"},
                            "verb":{"id":"http:adlnet.gov/expapi/verbs/tested",
                                    "display":{"en-US":"tested"}},
                            "object":{"id":"test:same.regid.again"},
                            "context":{"registration":reg_guid}
                            })

        param1 = {"statementId":stmt1_guid}
        path1 = "%s?%s" % (reverse(views.statements), urllib.urlencode(param1))
        stmt_payload1 = stmt1
        resp1 = self.client.put(path1, stmt_payload1, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(resp1.status_code, 204)

        param2 = {"statementId":stmt2_guid}
        path2 = "%s?%s" % (reverse(views.statements), urllib.urlencode(param2))
        stmt_payload2 = stmt2
        resp2 = self.client.put(path2, stmt_payload2, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(resp2.status_code, 204)
        
    def test_void(self):
        stmt_guid = str(uuid.uuid1())
        stmt = {"actor":{"mbox":"mailto:tinytom@example.com"},
                "verb":{"id":"http://tommy.com/my-testverbs/danced",
                        "display":{"en-US":"danced"}},
                "object":{"id":"act:the-macarena"}}
        param = {"statementId":stmt_guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        payload = json.dumps(stmt)

        r = self.client.put(path, payload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 204)

        r = self.client.get(reverse(views.statements), Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)

        obj = json.loads(r.content)

        self.assertEqual(len(obj['statements']), 1)
        obj = obj['statements'][0]
        self.assertEqual(obj['id'], stmt_guid)
        self.assertEqual(obj['actor']['mbox'], stmt['actor']['mbox'])
        self.assertEqual(obj['verb'], stmt['verb'])
        self.assertEqual(obj['object']['id'], stmt['object']['id'])

        stmt2_guid = str(uuid.uuid1())
        stmt2 = {"actor":{"mbox":"mailto:louo@example.com"},
                "verb":{"id":"http://tommy.com/my-testverbs/laughed",
                        "display":{"en-US":"laughed at"}},
                "object":{"objectType":"StatementRef","id":stmt_guid}}
        param = {"statementId":stmt2_guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        payload2 = json.dumps(stmt2)

        r = self.client.put(path, payload2, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 204)

        r = self.client.get(reverse(views.statements), Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        self.assertEqual(len(obj['statements']), 2)
        objs = obj['statements']
        for o in objs:
            if o['id'] == stmt_guid:
                self.assertEqual(o['actor']['mbox'],stmt['actor']['mbox'])
                self.assertEqual(o['verb']['id'], stmt['verb']['id'])
                self.assertEqual(o['object']['id'], stmt['object']['id'])
            else:
                self.assertEqual(o['actor']['mbox'],stmt2['actor']['mbox'])
                self.assertEqual(o['verb']['id'], stmt2['verb']['id'])
                self.assertEqual(o['object']['id'], stmt2['object']['id'])

        stmtv = {"actor":{"mbox":"mailto:hulk@example.com"},
                "verb":{"id":"http://adlnet.gov/expapi/verbs/voided",
                        "display":{"en-US":"smash"}},
                "object":{"objectType":"StatementRef",
                          "id":"%s" % stmt_guid}}
        v_guid = str(uuid.uuid1())
        paramv = {"statementId": v_guid}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(paramv))
        vpayload = json.dumps(stmtv)

        r = self.client.put(path, vpayload, content_type="application/json", Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 204)

        r = self.client.get(reverse(views.statements), Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        self.assertEqual(len(obj['statements']), 2)
        objs = obj['statements']
        for o in objs:
            if o['id'] == v_guid:
                self.assertEqual(o['actor']['mbox'],stmtv['actor']['mbox'])
                self.assertEqual(o['verb']['id'], stmtv['verb']['id'])
                self.assertEqual(o['object']['id'], stmtv['object']['id'])
            else:
                self.assertEqual(o['actor']['mbox'],stmt2['actor']['mbox'])
                self.assertEqual(o['verb']['id'], stmt2['verb']['id'])
                self.assertEqual(o['object']['id'], stmt2['object']['id'])

        # get voided statement via voidedStatementId
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode({"voidedStatementId":stmt_guid}))
        r = self.client.get(path, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        obj = json.loads(r.content)
        self.assertEqual(obj['id'], stmt_guid)
        self.assertEqual(obj['actor']['mbox'], stmt['actor']['mbox'])
        self.assertEqual(obj['verb']['id'], stmt['verb']['id'])
        self.assertEqual(obj['object']['id'], stmt['object']['id'])

        # make sure voided statement returns a 404 on get w/ statementId req
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode({"statementId":stmt_guid}))
        r = self.client.get(path, Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 404)
    
    def test_act_id_iri(self):
        act_id = "act:Flügel"
        stmt = json.dumps({"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/created","display": {"en-US":"created"}},
            "object": {"id":act_id}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        stmt_db = models.Statement.objects.get(statement_id=json.loads(response.content)[0])
        act = models.Activity.objects.get(id=stmt_db.object_activity.id)
        self.assertEqual(act.activity_id.encode('utf-8'), act_id)

    def test_invalid_act_id_iri(self):
        act_id = "Flügel"
        stmt = json.dumps({"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/created","display": {"en-US":"created"}},
            "object": {"id":act_id}})
        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('not a valid URI', response.content)

    def test_tag_act_id_uri(self):
        act_id = "tag:adlnet.gov,2013:expapi:0.9:activities"
        stmt = json.dumps({"actor":{"objectType":"Agent","mbox":"mailto:s@s.com"},
            "verb":{"id": "http://adlnet.gov/expapi/verbs/created","display": {"en-US":"created"}},
            "object": {"id":act_id}})

        response = self.client.post(reverse(views.statements), stmt, content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        
        self.assertEqual(response.status_code, 200)
        stmt_db = models.Statement.objects.get(statement_id=json.loads(response.content)[0])
        act = models.Activity.objects.get(id=stmt_db.object_activity.id)
        self.assertEqual(act.activity_id, act_id)

    def test_multipart(self):
        stmt = {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "sha2":""}]}

        message = MIMEMultipart(boundary="myboundary")
        txt = u"howdy.. this is a text attachment"
        txtsha = hashlib.sha256(txt).hexdigest()
        stmt['attachments'][0]["sha2"] = str(txtsha)
        
        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        textdata = MIMEText(txt, 'plain', 'utf-8')
        textdata.add_header('X-Experience-API-Hash', txtsha)
        message.attach(stmtdata)
        message.attach(textdata)
        
        auth = "Basic %s" % base64.b64encode("%s:%s" % ('tester1', 'test'))

        r = self.client.post(reverse(views.statements), message.as_string(),
            content_type='multipart/mixed', Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)

    def test_multiple_stmt_multipart(self):
        stmt = [{"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "sha2":""}]},
            {"actor":{"mbox":"mailto:tom2@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads2"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test2",
            "display": {"en-US": "A test attachment2"},
            "description": {"en-US": "A test attachment (description)2"},
            "contentType": "text/plain; charset=utf-8",
            "length": 23,
            "sha2":""}]}
            ]

        message = MIMEMultipart(boundary="myboundary")
        txt = u"howdy.. this is a text attachment"
        txtsha = hashlib.sha256(txt).hexdigest()
        stmt[0]['attachments'][0]["sha2"] = str(txtsha)
        
        txt2 = u"This is second attachment."
        txtsha2 = hashlib.sha256(txt2).hexdigest()
        stmt[1]['attachments'][0]['sha2'] = str(txtsha2)
        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        textdata = MIMEText(txt, 'plain', 'utf-8')
        textdata2 = MIMEText(txt2, 'plain', 'utf-8')
        
        textdata.add_header('X-Experience-API-Hash', txtsha)
        textdata2.add_header('X-Experience-API-Hash', txtsha2)
        message.attach(stmtdata)
        message.attach(textdata)
        message.attach(textdata2)
        
        r = self.client.post(reverse(views.statements), message.as_string(), content_type="multipart/mixed",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        returned_ids = json.loads(r.content)
        stmt_id1 = returned_ids[0]
        stmt_id2 = returned_ids[1]
        saved_stmt1 = models.Statement.objects.get(statement_id=stmt_id1)
        saved_stmt2 = models.Statement.objects.get(statement_id=stmt_id2)
        statements = models.Statement.objects.all()
        attachments = models.StatementAttachment.objects.all()
        self.assertEqual(len(statements), 2)
        self.assertEqual(len(attachments), 2)

        
        self.assertEqual(saved_stmt1.attachments.all()[0].payload.read(), "howdy.. this is a text attachment")
        self.assertEqual(saved_stmt2.attachments.all()[0].payload.read(), "This is second attachment.")

    def test_multiple_stmt_multipart_same_attachment(self):
        stmt = [{"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "sha2":""}]},
            {"actor":{"mbox":"mailto:tom2@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads2"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "sha2":""}]}
            ]

        message = MIMEMultipart(boundary="myboundary")
        txt = u"howdy.. this is a text attachment"
        txtsha = hashlib.sha256(txt).hexdigest()
        stmt[0]['attachments'][0]["sha2"] = str(txtsha)        
        stmt[1]['attachments'][0]['sha2'] = str(txtsha)
        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        textdata = MIMEText(txt, 'plain', 'utf-8')
        
        textdata.add_header('X-Experience-API-Hash', txtsha)
        message.attach(stmtdata)
        message.attach(textdata)
        
        r = self.client.post(reverse(views.statements), message.as_string(), content_type="multipart/mixed",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        
        returned_ids = json.loads(r.content)
        stmt_id1 = returned_ids[0]
        stmt_id2 = returned_ids[1]
        saved_stmt1 = models.Statement.objects.get(statement_id=stmt_id1)
        saved_stmt2 = models.Statement.objects.get(statement_id=stmt_id2)
        statements = models.Statement.objects.all()
        attachments = models.StatementAttachment.objects.all()
        self.assertEqual(len(statements), 2)
        self.assertEqual(len(attachments), 1)

        self.assertEqual(saved_stmt1.attachments.all()[0].payload.read(), "howdy.. this is a text attachment")
        self.assertEqual(saved_stmt2.attachments.all()[0].payload.read(), "howdy.. this is a text attachment")

    def test_multiple_stmt_multipart_one_attachment_one_fileurl(self):
        stmt = [{"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "sha2":""}]},
            {"actor":{"mbox":"mailto:tom2@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads2"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "fileUrl":"http://my/file/url"}]}]

        message = MIMEMultipart(boundary="myboundary")
        txt = u"howdy.. this is a text attachment"
        txtsha = hashlib.sha256(txt).hexdigest()
        stmt[0]['attachments'][0]["sha2"] = str(txtsha)        
        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        textdata = MIMEText(txt, 'plain', 'utf-8')
        
        textdata.add_header('X-Experience-API-Hash', txtsha)
        message.attach(stmtdata)
        message.attach(textdata)
        
        r = self.client.post(reverse(views.statements), message.as_string(), content_type="multipart/mixed",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        
        returned_ids = json.loads(r.content)
        stmt_id1 = returned_ids[0]
        stmt_id2 = returned_ids[1]
        saved_stmt1 = models.Statement.objects.get(statement_id=stmt_id1)
        saved_stmt2 = models.Statement.objects.get(statement_id=stmt_id2)
        statements = models.Statement.objects.all()
        attachments = models.StatementAttachment.objects.all()
        self.assertEqual(len(statements), 2)
        self.assertEqual(len(attachments), 2)

        self.assertEqual(saved_stmt1.attachments.all()[0].payload.read(), "howdy.. this is a text attachment")
        self.assertEqual(saved_stmt2.attachments.all()[0].fileUrl, "http://my/file/url")

    def test_multiple_stmt_multipart_multiple_attachments_each(self):
        stmt = [{"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test11",
                "display": {"en-US": "A test attachment11"},
                "description": {"en-US": "A test attachment (description)11"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "sha2":""},
                {"usageType": "http://example.com/attachment-usage/test12",
                "display": {"en-US": "A test attachment12"},
                "description": {"en-US": "A test attachment (description)12"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "sha2":""}]},
            {"actor":{"mbox":"mailto:tom2@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads2"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test21",
                "display": {"en-US": "A test attachment21"},
                "description": {"en-US": "A test attachment (description)21"},
                "contentType": "text/plain; charset=utf-8",
                "length": 23,
                "sha2":""},
                {"usageType": "http://example.com/attachment-usage/test22",
                "display": {"en-US": "A test attachment22"},
                "description": {"en-US": "A test attachment (description)22"},
                "contentType": "text/plain; charset=utf-8",
                "length": 23,
                "sha2":""}]}
            ]

        message = MIMEMultipart(boundary="myboundary")
        txt11 = u"This is a text attachment11"
        txtsha11 = hashlib.sha256(txt11).hexdigest()
        stmt[0]['attachments'][0]["sha2"] = str(txtsha11)
        
        txt12 = u"This is a text attachment12"
        txtsha12 = hashlib.sha256(txt12).hexdigest()
        stmt[0]['attachments'][1]['sha2'] = str(txtsha12)

        txt21 = u"This is a text attachment21"
        txtsha21 = hashlib.sha256(txt21).hexdigest()
        stmt[1]['attachments'][0]['sha2'] = str(txtsha21)

        txt22 = u"This is a text attachment22"
        txtsha22 = hashlib.sha256(txt22).hexdigest()
        stmt[1]['attachments'][1]['sha2'] = str(txtsha22)

        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        textdata11 = MIMEText(txt11, 'plain', 'utf-8')
        textdata12 = MIMEText(txt12, 'plain', 'utf-8')
        textdata21 = MIMEText(txt21, 'plain', 'utf-8')
        textdata22 = MIMEText(txt22, 'plain', 'utf-8')
 
        textdata11.add_header('X-Experience-API-Hash', txtsha11)
        textdata12.add_header('X-Experience-API-Hash', txtsha12)
        textdata21.add_header('X-Experience-API-Hash', txtsha21)
        textdata22.add_header('X-Experience-API-Hash', txtsha22)

        message.attach(stmtdata)
        message.attach(textdata11)
        message.attach(textdata12)
        message.attach(textdata21)
        message.attach(textdata22)
        
        r = self.client.post(reverse(views.statements), message.as_string(), content_type="multipart/mixed",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        
        returned_ids = json.loads(r.content)
        stmt_id1 = returned_ids[0]
        stmt_id2 = returned_ids[1]
        saved_stmt1 = models.Statement.objects.get(statement_id=stmt_id1)
        saved_stmt2 = models.Statement.objects.get(statement_id=stmt_id2)

        statements = models.Statement.objects.all()
        attachments = models.StatementAttachment.objects.all()
        self.assertEqual(len(statements), 2)
        self.assertEqual(len(attachments), 4)

        stmt1_contents = ["This is a text attachment11","This is a text attachment12"]
        stmt2_contents = ["This is a text attachment21","This is a text attachment22"]
        self.assertIn(saved_stmt1.attachments.all()[0].payload.read(), stmt1_contents)
        self.assertIn(saved_stmt1.attachments.all()[1].payload.read(), stmt1_contents)
        self.assertIn(saved_stmt2.attachments.all()[0].payload.read(), stmt2_contents)
        self.assertIn(saved_stmt2.attachments.all()[1].payload.read(), stmt2_contents)

    def test_multipart_wrong_sha(self):
        stmt = {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "sha2":""}]}

        message = MIMEMultipart(boundary="myboundary")
        txt = u"howdy.. this is a text attachment"
        txtsha = hashlib.sha256(txt).hexdigest()
        wrongtxt = u"blahblahblah this is wrong"
        wrongsha = hashlib.sha256(wrongtxt).hexdigest()
        stmt['attachments'][0]["sha2"] = str(wrongsha)
        
        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        textdata = MIMEText(txt, 'plain', 'utf-8')
        textdata.add_header('X-Experience-API-Hash', txtsha)
        message.attach(stmtdata)
        message.attach(textdata)
        
        auth = "Basic %s" % base64.b64encode("%s:%s" % ('tester1', 'test'))

        r = self.client.post(reverse(views.statements), message.as_string(), content_type="multipart/mixed",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(r.status_code, 400)
        self.assertIn("Could not find attachment payload with sha", r.content)

    def test_multiple_multipart(self):
        stmt = {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "sha2":""},
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment2"},
            "description": {"en-US": "A test attachment (description)2"},
            "contentType": "text/plain; charset=utf-8",
            "length": 28,
            "sha2":""}]}

        message = MIMEMultipart(boundary="myboundary")
        txt = u"howdy.. this is a text attachment"
        txtsha = hashlib.sha256(txt).hexdigest()
        stmt['attachments'][0]["sha2"] = str(txtsha)
        
        txt2 = u"this is second attachment"
        txtsha2 = hashlib.sha256(txt2).hexdigest()
        stmt['attachments'][1]["sha2"] = str(txtsha2)

        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        textdata = MIMEText(txt, 'plain', 'utf-8')
        textdata.add_header('X-Experience-API-Hash', txtsha)
        textdata2 = MIMEText(txt2, 'plain', 'utf-8')
        textdata2.add_header('X-Experience-API-Hash', txtsha2)
        message.attach(stmtdata)
        message.attach(textdata)
        message.attach(textdata2)

        auth = "Basic %s" % base64.b64encode("%s:%s" % ('tester1', 'test'))

        r = self.client.post(reverse(views.statements), message.as_string(), content_type="multipart/mixed",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)

    def test_multiple_multipart(self):
        stmt = {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "sha2":""},
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment2"},
            "description": {"en-US": "A test attachment (description)2"},
            "contentType": "text/plain; charset=utf-8",
            "length": 28,
            "sha2":""}]}

        message = MIMEMultipart(boundary="myboundary")
        txt = u"howdy.. this is a text attachment"
        txtsha = hashlib.sha256(txt).hexdigest()
        stmt['attachments'][0]["sha2"] = str(txtsha)
        
        txt2 = u"this is second attachment"
        txtsha2 = hashlib.sha256(txt2).hexdigest()
        wrongtxt = u"this is some wrong text"
        wrongsha2 = hashlib.sha256(wrongtxt).hexdigest()
        stmt['attachments'][1]["sha2"] = str(wrongsha2)

        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        textdata = MIMEText(txt, 'plain', 'utf-8')
        textdata.add_header('X-Experience-API-Hash', txtsha)
        textdata2 = MIMEText(txt2, 'plain', 'utf-8')
        textdata2.add_header('X-Experience-API-Hash', txtsha2)
        message.attach(stmtdata)
        message.attach(textdata)
        message.attach(textdata2)

        auth = "Basic %s" % base64.b64encode("%s:%s" % ('tester1', 'test'))

        r = self.client.post(reverse(views.statements), message.as_string(), content_type="multipart/mixed",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 400)
        self.assertIn("Could not find attachment payload with sha", r.content)

    def test_app_json_multipart(self):
        stmt = {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "fileUrl": "http://my/file/url"}]}
        
        response = self.client.post(reverse(views.statements), json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)


    def test_app_json_multipart_wrong_fields(self):
        stmt = {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "bad": "foo",
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "fileUrl": "http://my/file/url"}]}
        
        response = self.client.post(reverse(views.statements), json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Invalid field(s) found in Attachment - bad')

    def test_app_json_multipart_one_fileURL(self):
        stmt = [{"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test",
                "display": {"en-US": "A test attachment"},
                "description": {"en-US": "A test attachment (description)"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "fileUrl": "http://my/file/url"}]},
            {"actor":{"mbox":"mailto:tom1@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads1"},
            "attachments": [
                {"usageType": "http://example.com/attachment-usage/test",
                "display": {"en-US": "A test attachment"},
                "description": {"en-US": "A test attachment (description)"},
                "contentType": "text/plain; charset=utf-8",
                "length": 27,
                "fileUrl": "http://my/file/url"}]}
            ]
        
        response = self.client.post(reverse(views.statements), json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)

        returned_ids = json.loads(response.content)
        stmt_id1 = returned_ids[0]
        stmt_id2 = returned_ids[1]
        saved_stmt1 = models.Statement.objects.get(statement_id=stmt_id1)
        saved_stmt2 = models.Statement.objects.get(statement_id=stmt_id2)
        statements = models.Statement.objects.all()
        attachments = models.StatementAttachment.objects.all()
        self.assertEqual(len(statements), 2)
        self.assertEqual(len(attachments), 1)

        self.assertEqual(saved_stmt1.attachments.all()[0].fileUrl, "http://my/file/url")
        self.assertEqual(saved_stmt2.attachments.all()[0].fileUrl, "http://my/file/url")

    def test_app_json_multipart_no_fileUrl(self):
        stmt = {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27}]}
        
        response = self.client.post(reverse(views.statements), json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('Attachment sha2 is required when no fileUrl is given', response.content)

    def test_multiple_app_json_multipart_no_fileUrl(self):
        stmt = {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "fileUrl":"http://some/url"},
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment2"},
            "description": {"en-US": "A test attachment (description)2"},
            "contentType": "text/plain; charset=utf-8",
            "length": 28,
            "fileUrl":""}]}

        response = self.client.post(reverse(views.statements), json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('Attachments fileUrl with value  was not a valid URI', response.content)

    def test_multipart_put(self):
        stmt_id = str(uuid.uuid1())
        stmt = {"id":stmt_id,
            "actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "sha2":""}]}

        message = MIMEMultipart(boundary="myboundary")
        txt = u"howdy.. this is a text attachment"
        txtsha = hashlib.sha256(txt).hexdigest()
        stmt['attachments'][0]["sha2"] = str(txtsha)
        
        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        textdata = MIMEText(txt, 'plain', 'utf-8')
        textdata.add_header('X-Experience-API-Hash', txtsha)
        message.attach(stmtdata)
        message.attach(textdata)
        
        auth = "Basic %s" % base64.b64encode("%s:%s" % ('tester1', 'test'))

        param = {"statementId":stmt_id}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        r = self.client.put(path, message.as_string(), content_type="multipart/mixed", Authorization=self.auth,
            X_Experience_API_Version="1.0.0")

        self.assertEqual(r.status_code, 204)

    def test_multipart_wrong_sha_put(self):
        stmt_id = str(uuid.uuid1())
        stmt = {"id":stmt_id,
            "actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "sha2":""}]}

        message = MIMEMultipart(boundary="myboundary")
        txt = u"howdy.. this is a text attachment"
        txtsha = hashlib.sha256(txt).hexdigest()
        wrongtxt = u"blahblahblah this is wrong"
        wrongsha = hashlib.sha256(wrongtxt).hexdigest()
        stmt['attachments'][0]["sha2"] = str(wrongsha)
        
        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        textdata = MIMEText(txt, 'plain', 'utf-8')
        textdata.add_header('X-Experience-API-Hash', txtsha)
        message.attach(stmtdata)
        message.attach(textdata)
        
        auth = "Basic %s" % base64.b64encode("%s:%s" % ('tester1', 'test'))

        param = {"statementId":stmt_id}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        r = self.client.put(path, message.as_string(), content_type="multipart/mixed",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")

        self.assertEqual(r.status_code, 400)
        self.assertIn("Could not find attachment payload with sha", r.content)

    def test_multiple_multipart_put(self):
        stmt_id = str(uuid.uuid1())
        stmt = {"id":stmt_id,
            "actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "sha2":""},
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment2"},
            "description": {"en-US": "A test attachment (description)2"},
            "contentType": "text/plain; charset=utf-8",
            "length": 28,
            "sha2":""}]}

        message = MIMEMultipart(boundary="myboundary")
        txt = u"howdy.. this is a text attachment"
        txtsha = hashlib.sha256(txt).hexdigest()
        stmt['attachments'][0]["sha2"] = str(txtsha)
        
        txt2 = u"this is second attachment"
        txtsha2 = hashlib.sha256(txt2).hexdigest()
        stmt['attachments'][1]["sha2"] = str(txtsha2)

        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        textdata = MIMEText(txt, 'plain', 'utf-8')
        textdata.add_header('X-Experience-API-Hash', txtsha)
        textdata2 = MIMEText(txt2, 'plain', 'utf-8')
        textdata2.add_header('X-Experience-API-Hash', txtsha2)
        message.attach(stmtdata)
        message.attach(textdata)
        message.attach(textdata2)

        auth = "Basic %s" % base64.b64encode("%s:%s" % ('tester1', 'test'))

        param = {"statementId":stmt_id}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        r = self.client.put(path, message.as_string(), content_type="multipart/mixed" , Authorization=self.auth,
            X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 204)

    def test_multiple_multipart_put(self):
        stmt_id = str(uuid.uuid1())
        stmt = {"id":stmt_id,
            "actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "sha2":""},
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment2"},
            "description": {"en-US": "A test attachment (description)2"},
            "contentType": "text/plain; charset=utf-8",
            "length": 28,
            "sha2":""}]}

        message = MIMEMultipart(boundary="myboundary")
        txt = u"howdy.. this is a text attachment"
        txtsha = hashlib.sha256(txt).hexdigest()
        stmt['attachments'][0]["sha2"] = str(txtsha)
        
        txt2 = u"this is second attachment"
        txtsha2 = hashlib.sha256(txt2).hexdigest()
        wrongtxt = u"this is some wrong text"
        wrongsha2 = hashlib.sha256(wrongtxt).hexdigest()
        stmt['attachments'][1]["sha2"] = str(wrongsha2)

        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        textdata = MIMEText(txt, 'plain', 'utf-8')
        textdata.add_header('X-Experience-API-Hash', txtsha)
        textdata2 = MIMEText(txt2, 'plain', 'utf-8')
        textdata2.add_header('X-Experience-API-Hash', txtsha2)
        message.attach(stmtdata)
        message.attach(textdata)
        message.attach(textdata2)

        auth = "Basic %s" % base64.b64encode("%s:%s" % ('tester1', 'test'))

        param = {"statementId":stmt_id}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        r = self.client.put(path, message.as_string(), content_type="multipart/mixed",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 400)
        self.assertIn("Could not find attachment payload with sha", r.content)

    def test_app_json_multipart_put(self):
        stmt_id = str(uuid.uuid1())
        stmt = {"id":stmt_id,
            "actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "fileUrl": "http://my/file/url"}]}
        
        param = {"statementId":stmt_id}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        response = self.client.put(path, json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 204)

    def test_app_json_multipart_not_array(self):
        stmt_id = str(uuid.uuid1())
        stmt = {"id":stmt_id,
            "actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": "wrong"}
        
        param = {"statementId":stmt_id}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        response = self.client.put(path, json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.content, 'Attachments is not a properly formatted array')

    def test_app_json_multipart_no_fileUrl_put(self):
        stmt_id = str(uuid.uuid1())
        stmt = {"id":stmt_id,
            "actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27}]}

        param = {"statementId":stmt_id}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        response = self.client.put(path, json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn( 'Attachment sha2 is required when no fileUrl is given', response.content)

    def test_app_json_invalid_fileUrl(self):
        stmt_id = str(uuid.uuid1())
        stmt = {"id":stmt_id,
            "actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "fileUrl": "blah"}]}

        param = {"statementId":stmt_id}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))        
        response = self.client.put(path, json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('Attachments fileUrl with value blah was not a valid URI', response.content)



    def test_multiple_app_json_multipart_no_fileUrl_put(self):
        stmt_id = str(uuid.uuid1())

        stmt = {"id":stmt_id,
            "actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "fileUrl":"http://some/url"},
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment2"},
            "description": {"en-US": "A test attachment (description)2"},
            "contentType": "text/plain; charset=utf-8",
            "length": 28,
            "fileUrl":""}]}

        param = {"statementId":stmt_id}
        path = "%s?%s" % (reverse(views.statements), urllib.urlencode(param))
        response = self.client.put(path, json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 400)
        self.assertIn('Attachments fileUrl with value  was not a valid URI', response.content)

    def test_multipart_non_text_file(self):
        stmt = {"actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test picture"},
            "description": {"en-US": "A test picture (description)"},
            "contentType": "image/png",
            "length": 27,
            "sha2":""}]}

        message = MIMEMultipart(boundary="myboundary")
        img_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'static','img', 'minus_small_white.png'))
        img = open(img_path, 'rb')
        img_data = img.read()
        img.close()
        imgsha = hashlib.sha256(img_data).hexdigest()
        stmt['attachments'][0]["sha2"] = str(imgsha)
        
        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        imgdata = MIMEImage(img_data)

        imgdata.add_header('X-Experience-API-Hash', imgsha)
        message.attach(stmtdata)
        message.attach(imgdata)
        
        r = self.client.post(reverse(views.statements), message.as_string(),
            content_type='multipart/mixed', Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)
        
        param= {"attachments":True}
        path = "%s?%s" % (reverse(views.statements),urllib.urlencode(param))
        r = self.client.get(path, X_Experience_API_Version="1.0.0", Authorization=self.auth)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r['Content-Type'], 'multipart/mixed')

        msg = message_from_string(r.content)
        parts = []
        for part in msg.walk():
            parts.append(part)
  
        for part in parts[2:]:
            self.assertEqual(part.get_payload(), img_data)
            self.assertEqual(part.get("X-Experience-API-Hash"), imgsha)
            self.assertEqual(part.get('Content-Type'), "application/octet-stream")
            self.assertEqual(part.get('Content-Transfer-Encoding'), 'binary')

    def test_app_json_multipart_post_define(self):
        stmt = {
            "actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment"},
            "description": {"en-US": "A test attachment (description)"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "fileUrl": "http://my/file/url"}]}
        
        response = self.client.post(reverse(views.statements), json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)

        stmt = {
            "actor":{"mbox":"mailto:tom@example.com"},
            "verb":{"id":"http://tom.com/verb/butted"},
            "object":{"id":"act:tom.com/objs/heads"},
            "attachments": [
            {"usageType": "http://example.com/attachment-usage/test",
            "display": {"en-US": "A test attachment.", "en-UK": "UK attachment"},
            "description": {"en-US": "A test attachment (description)", "en-UK": "UK attachment"},
            "contentType": "text/plain; charset=utf-8",
            "length": 27,
            "fileUrl": "http://my/file/url"}]}
        
        response = self.client.post(reverse(views.statements), json.dumps(stmt), content_type="application/json",
            Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(response.status_code, 200)
        st_id = json.loads(response.content)[0]
        st = models.Statement.objects.get(statement_id=st_id)
        attach_objs = models.StatementAttachment.objects.all()
        self.assertEqual(len(attach_objs), 1)

        displays = attach_objs[0].display
        descs = attach_objs[0].description

        self.assertEqual(len(displays), 2)
        self.assertEqual(len(descs), 2)

        self.assertIn('en-US', displays.keys())
        self.assertIn('en-UK', displays.keys())
        self.assertIn('A test attachment.', displays.values())
        self.assertIn('UK attachment', displays.values())

        self.assertIn('en-US', descs.keys())
        self.assertIn('en-UK', descs.keys())
        self.assertIn('A test attachment (description)', descs.values())
        self.assertIn('UK attachment', descs.values())

    def test_example_signed_statement(self):
        header = base64.urlsafe_b64decode(fixpad(encodedhead))
        payload = base64.urlsafe_b64decode(fixpad(encodedpayload))

        stmt = json.loads(exstmt)
        
        jwso = JWS(header, payload)
        thejws = jwso.create(privatekey)
        self.assertEqual(thejws,sig)

        message = MIMEMultipart()
        stmt['attachments'][0]["sha2"] = jwso.sha2(thejws)
        
        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        jwsdata = MIMEApplication(thejws, _subtype="octet-stream")

        jwsdata.add_header('X-Experience-API-Hash', jwso.sha2(thejws))
        message.attach(stmtdata)
        message.attach(jwsdata)
        
        r = self.client.post(reverse(views.statements), message.as_string(),
            content_type='multipart/mixed', Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)

    def test_example_signed_statement_bad(self):
        header = base64.urlsafe_b64decode(fixpad(encodedhead))
        payload = base64.urlsafe_b64decode(fixpad(encodedpayload))

        stmt = json.loads(exstmt)
        stmt['actor'] = {"mbox": "mailto:sneaky@example.com", "name": "Cheater", "objectType": "Agent"}
        
        jwso = JWS(header, payload)
        thejws = jwso.create(privatekey)
        self.assertEqual(thejws,sig)

        message = MIMEMultipart()
        stmt['attachments'][0]["sha2"] = jwso.sha2(thejws)
        
        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        jwsdata = MIMEApplication(thejws, _subtype="octet-stream")

        jwsdata.add_header('X-Experience-API-Hash', jwso.sha2(thejws))
        message.attach(stmtdata)
        message.attach(jwsdata)
        
        r = self.client.post(reverse(views.statements), message.as_string(),
            content_type='multipart/mixed', Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 400)
        self.assertEqual(r.content, 'The JSON Web Signature is not valid')

    def test_example_signed_statements(self):
        header = base64.urlsafe_b64decode(fixpad(encodedhead))
        payload = base64.urlsafe_b64decode(fixpad(encodedpayload))

        stmt1 = json.loads(exstmt)

        stmt2 = {"actor": {"mbox" : "mailto:otherguy@example.com"},
                 "verb" : {"id":"http://verbs.com/did"},
                 "object" : {"id":"act:stuff"} }

        stmt = [stmt1, stmt2]
        
        jwso = JWS(header, payload)
        thejws = jwso.create(privatekey)
        self.assertEqual(thejws,sig)

        message = MIMEMultipart()
        stmt1['attachments'][0]["sha2"] = jwso.sha2()
        
        stmtdata = MIMEApplication(json.dumps(stmt), _subtype="json", _encoder=json.JSONEncoder)
        jwsdata = MIMEApplication(thejws, _subtype="octet-stream")

        jwsdata.add_header('X-Experience-API-Hash', jwso.sha2(thejws))
        message.attach(stmtdata)
        message.attach(jwsdata)
        
        r = self.client.post(reverse(views.statements), message.as_string(),
            content_type='multipart/mixed', Authorization=self.auth, X_Experience_API_Version="1.0.0")
        self.assertEqual(r.status_code, 200)

fixpad = lambda s: s if len(s) % 4 == 0 else s + '=' * (4 - (len(s) % 4))

exstmt = """{
    "version": "1.0.0",
    "id": "33cff416-e331-4c9d-969e-5373a1756120",
    "actor": {
        "mbox": "mailto:example@example.com",
        "name": "Example Learner",
        "objectType": "Agent"
    },
    "verb": {
        "id": "http://adlnet.gov/expapi/verbs/experienced",
        "display": {
            "en-US": "experienced"
        }
    },
    "object": {
        "id": "https://www.youtube.com/watch?v=xh4kIiH3Sm8",
        "objectType": "Activity",
        "definition": {
            "name": {
                "en-US": "Tax Tips & Information : How to File a Tax Return "
            },
            "description": {
                "en-US": "Filing a tax return will require filling out either a 1040, 1040A or 1040EZ form"
            }
        }
    },
    "timestamp": "2013-04-01T12:00:00Z",
    "attachments": [
        {
            "usageType": "http://adlnet.gov/expapi/attachments/signature",
            "display": { "en-US": "Signature" },
            "description": { "en-US": "A test signature" },
            "contentType": "application/octet-stream",
            "length": 4235,
            "sha2": "dc9589e454ff375dd5dfd6f556d2583e231e8cafe55ef40102ddd988b79f86f0"
        }
    ]
}"""

sig = "ew0KICAgICJhbGciOiAiUlMyNTYiLA0KICAgICJ4NWMiOiBbDQogICAgICAgICJNSUlEQVRDQ0FtcWdBd0lCQWdJSkFNQjFjc051QTYra01BMEdDU3FHU0liM0RRRUJCUVVBTUhFeEN6QUpCZ05WQkFZVEFsVlRNUkl3RUFZRFZRUUlFd2xVWlc1dVpYTnpaV1V4R0RBV0JnTlZCQW9URDBWNFlXMXdiR1VnUTI5dGNHRnVlVEVRTUE0R0ExVUVBeE1IUlhoaGJYQnNaVEVpTUNBR0NTcUdTSWIzRFFFSkFSWVRaWGhoYlhCc1pVQmxlR0Z0Y0d4bExtTnZiVEFlRncweE16QTBNRFF4TlRJNE16QmFGdzB4TkRBME1EUXhOVEk0TXpCYU1JR1dNUXN3Q1FZRFZRUUdFd0pWVXpFU01CQUdBMVVFQ0JNSlZHVnVibVZ6YzJWbE1SRXdEd1lEVlFRSEV3aEdjbUZ1YTJ4cGJqRVlNQllHQTFVRUNoTVBSWGhoYlhCc1pTQkRiMjF3WVc1NU1SQXdEZ1lEVlFRTEV3ZEZlR0Z0Y0d4bE1SQXdEZ1lEVlFRREV3ZEZlR0Z0Y0d4bE1TSXdJQVlKS29aSWh2Y05BUWtCRmhObGVHRnRjR3hsUUdWNFlXMXdiR1V1WTI5dE1JR2ZNQTBHQ1NxR1NJYjNEUUVCQVFVQUE0R05BRENCaVFLQmdRRGp4dlpYRjMwV0w0b0tqWllYZ1IwWnlhWCt1M3k2K0pxVHFpTmtGYS9WVG5ldDZMeTJPVDZabW1jSkVQbnEzVW5ld3BIb09RK0dmaGhUa1cxM2owNmo1aU5uNG9iY0NWV1RMOXlYTnZKSCtLbyt4dTRZbC95U1BScklQeVRqdEhkRzBNMlh6SWxtbUxxbStDQVMrS0NiSmVINHRmNTQza0lXQzVwQzVwM2NWUUlEQVFBQm8zc3dlVEFKQmdOVkhSTUVBakFBTUN3R0NXQ0dTQUdHK0VJQkRRUWZGaDFQY0dWdVUxTk1JRWRsYm1WeVlYUmxaQ0JEWlhKMGFXWnBZMkYwWlRBZEJnTlZIUTRFRmdRVVZzM3Y1YWZFZE9lb1llVmFqQVFFNHYwV1MxUXdId1lEVlIwakJCZ3dGb0FVeVZJYzN5dnJhNEVCejIwSTRCRjM5SUFpeEJrd0RRWUpLb1pJaHZjTkFRRUZCUUFEZ1lFQWdTL0ZGNUQwSG5qNDRydlQ2a2duM2tKQXZ2MmxqL2Z5anp0S0lyWVMzM2xqWEduNmdHeUE0cXRiWEEyM1ByTzR1Yy93WUNTRElDRHBQb2JoNjJ4VENkOXFPYktoZ3dXT2kwNVBTQkxxVXUzbXdmQWUxNUxKQkpCcVBWWjRLMGtwcGVQQlU4bTZhSVpvSDU3TC85dDRPb2FMOHlLcy9xaktGZUkxT0ZXWnh2QT0iLA0KICAgICAgICAiTUlJRE56Q0NBcUNnQXdJQkFnSUpBTUIxY3NOdUE2K2pNQTBHQ1NxR1NJYjNEUUVCQlFVQU1IRXhDekFKQmdOVkJBWVRBbFZUTVJJd0VBWURWUVFJRXdsVVpXNXVaWE56WldVeEdEQVdCZ05WQkFvVEQwVjRZVzF3YkdVZ1EyOXRjR0Z1ZVRFUU1BNEdBMVVFQXhNSFJYaGhiWEJzWlRFaU1DQUdDU3FHU0liM0RRRUpBUllUWlhoaGJYQnNaVUJsZUdGdGNHeGxMbU52YlRBZUZ3MHhNekEwTURReE5USTFOVE5hRncweU16QTBNREl4TlRJMU5UTmFNSEV4Q3pBSkJnTlZCQVlUQWxWVE1SSXdFQVlEVlFRSUV3bFVaVzV1WlhOelpXVXhHREFXQmdOVkJBb1REMFY0WVcxd2JHVWdRMjl0Y0dGdWVURVFNQTRHQTFVRUF4TUhSWGhoYlhCc1pURWlNQ0FHQ1NxR1NJYjNEUUVKQVJZVFpYaGhiWEJzWlVCbGVHRnRjR3hsTG1OdmJUQ0JuekFOQmdrcWhraUc5dzBCQVFFRkFBT0JqUUF3Z1lrQ2dZRUExc0JuQldQWjBmN1dKVUZUSnk1KzAxU2xTNVo2RERENlV5ZTl2SzlBeWNnVjVCMytXQzhIQzV1NWg5MU11akFDMUFSUFZVT3RzdlBSczQ1cUtORklnSUdSWEtQQXdaamF3RUkyc0NKUlNLVjQ3aTZCOGJEdjRXa3VHdlFhdmVaR0kwcWxtTjVSMUVpbTJnVUl0UmoxaGdjQzlyUWF2amxuRktEWTJybFhHdWtDQXdFQUFhT0IxakNCMHpBZEJnTlZIUTRFRmdRVXlWSWMzeXZyYTRFQnoyMEk0QkYzOUlBaXhCa3dnYU1HQTFVZEl3U0JtekNCbUlBVXlWSWMzeXZyYTRFQnoyMEk0QkYzOUlBaXhCbWhkYVJ6TUhFeEN6QUpCZ05WQkFZVEFsVlRNUkl3RUFZRFZRUUlFd2xVWlc1dVpYTnpaV1V4R0RBV0JnTlZCQW9URDBWNFlXMXdiR1VnUTI5dGNHRnVlVEVRTUE0R0ExVUVBeE1IUlhoaGJYQnNaVEVpTUNBR0NTcUdTSWIzRFFFSkFSWVRaWGhoYlhCc1pVQmxlR0Z0Y0d4bExtTnZiWUlKQU1CMWNzTnVBNitqTUF3R0ExVWRFd1FGTUFNQkFmOHdEUVlKS29aSWh2Y05BUUVGQlFBRGdZRUFEaHdUZWJHazczNXlLaG04RHFDeHZObkVaME54c1lFWU9qZ1JHMXlYVGxXNXBFNjkxZlNINUFaK1Q2ZnB3cFpjV1k1UVlrb042RG53ak94R2tTZlFDMy95R21jVURLQlB3aVo1TzJzOUMrZkUxa1VFbnJYMlhlYTRhZ1ZuZ016UjhEUTZvT2F1TFdxZWhEQitnMkVOV1JMb1ZnUyttYTUvWWNzMEdUeXJFQ1k9Ig0KICAgIF0NCn0.ew0KICAgICJ2ZXJzaW9uIjogIjEuMC4wIiwNCiAgICAiaWQiOiAiMzNjZmY0MTYtZTMzMS00YzlkLTk2OWUtNTM3M2ExNzU2MTIwIiwNCiAgICAiYWN0b3IiOiB7DQogICAgICAgICJtYm94IjogIm1haWx0bzpleGFtcGxlQGV4YW1wbGUuY29tIiwNCiAgICAgICAgIm5hbWUiOiAiRXhhbXBsZSBMZWFybmVyIiwNCiAgICAgICAgIm9iamVjdFR5cGUiOiAiQWdlbnQiDQogICAgfSwNCiAgICAidmVyYiI6IHsNCiAgICAgICAgImlkIjogImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9leHBlcmllbmNlZCIsDQogICAgICAgICJkaXNwbGF5Ijogew0KICAgICAgICAgICAgImVuLVVTIjogImV4cGVyaWVuY2VkIg0KICAgICAgICB9DQogICAgfSwNCiAgICAib2JqZWN0Ijogew0KICAgICAgICAiaWQiOiAiaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g_dj14aDRrSWlIM1NtOCIsDQogICAgICAgICJvYmplY3RUeXBlIjogIkFjdGl2aXR5IiwNCiAgICAgICAgImRlZmluaXRpb24iOiB7DQogICAgICAgICAgICAibmFtZSI6IHsNCiAgICAgICAgICAgICAgICAiZW4tVVMiOiAiVGF4IFRpcHMgJiBJbmZvcm1hdGlvbiA6IEhvdyB0byBGaWxlIGEgVGF4IFJldHVybiAiDQogICAgICAgICAgICB9LA0KICAgICAgICAgICAgImRlc2NyaXB0aW9uIjogew0KICAgICAgICAgICAgICAgICJlbi1VUyI6ICJGaWxpbmcgYSB0YXggcmV0dXJuIHdpbGwgcmVxdWlyZSBmaWxsaW5nIG91dCBlaXRoZXIgYSAxMDQwLCAxMDQwQSBvciAxMDQwRVogZm9ybSINCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgIH0sDQogICAgInRpbWVzdGFtcCI6ICIyMDEzLTA0LTAxVDEyOjAwOjAwWiINCn0.FWuwaPhwUbkk7h9sKW5zSvjsYNugvxJ-TrVaEgt_DCUT0bmKhQScRrjMB6P9O50uznPwT66oF1NnU_G0HVhRzS5voiXE-y7tT3z0M3-8A6YK009Bk_digVUul-HA4Fpd5IjoBBGe3yzaQ2ZvzarvRuipvNEQCI0onpfuZZJQ0d8"

encodedhead = """ew0KICAgICJhbGciOiAiUlMyNTYiLA0KICAgICJ4NWMiOiBbDQogICAgICAgICJNSUlEQVRDQ0FtcWdBd0lCQWdJSkFNQjFjc051QTYra01BMEdDU3FHU0liM0RRRUJCUVVBTUhFeEN6QUpCZ05WQkFZVEFsVlRNUkl3RUFZRFZRUUlFd2xVWlc1dVpYTnpaV1V4R0RBV0JnTlZCQW9URDBWNFlXMXdiR1VnUTI5dGNHRnVlVEVRTUE0R0ExVUVBeE1IUlhoaGJYQnNaVEVpTUNBR0NTcUdTSWIzRFFFSkFSWVRaWGhoYlhCc1pVQmxlR0Z0Y0d4bExtTnZiVEFlRncweE16QTBNRFF4TlRJNE16QmFGdzB4TkRBME1EUXhOVEk0TXpCYU1JR1dNUXN3Q1FZRFZRUUdFd0pWVXpFU01CQUdBMVVFQ0JNSlZHVnVibVZ6YzJWbE1SRXdEd1lEVlFRSEV3aEdjbUZ1YTJ4cGJqRVlNQllHQTFVRUNoTVBSWGhoYlhCc1pTQkRiMjF3WVc1NU1SQXdEZ1lEVlFRTEV3ZEZlR0Z0Y0d4bE1SQXdEZ1lEVlFRREV3ZEZlR0Z0Y0d4bE1TSXdJQVlKS29aSWh2Y05BUWtCRmhObGVHRnRjR3hsUUdWNFlXMXdiR1V1WTI5dE1JR2ZNQTBHQ1NxR1NJYjNEUUVCQVFVQUE0R05BRENCaVFLQmdRRGp4dlpYRjMwV0w0b0tqWllYZ1IwWnlhWCt1M3k2K0pxVHFpTmtGYS9WVG5ldDZMeTJPVDZabW1jSkVQbnEzVW5ld3BIb09RK0dmaGhUa1cxM2owNmo1aU5uNG9iY0NWV1RMOXlYTnZKSCtLbyt4dTRZbC95U1BScklQeVRqdEhkRzBNMlh6SWxtbUxxbStDQVMrS0NiSmVINHRmNTQza0lXQzVwQzVwM2NWUUlEQVFBQm8zc3dlVEFKQmdOVkhSTUVBakFBTUN3R0NXQ0dTQUdHK0VJQkRRUWZGaDFQY0dWdVUxTk1JRWRsYm1WeVlYUmxaQ0JEWlhKMGFXWnBZMkYwWlRBZEJnTlZIUTRFRmdRVVZzM3Y1YWZFZE9lb1llVmFqQVFFNHYwV1MxUXdId1lEVlIwakJCZ3dGb0FVeVZJYzN5dnJhNEVCejIwSTRCRjM5SUFpeEJrd0RRWUpLb1pJaHZjTkFRRUZCUUFEZ1lFQWdTL0ZGNUQwSG5qNDRydlQ2a2duM2tKQXZ2MmxqL2Z5anp0S0lyWVMzM2xqWEduNmdHeUE0cXRiWEEyM1ByTzR1Yy93WUNTRElDRHBQb2JoNjJ4VENkOXFPYktoZ3dXT2kwNVBTQkxxVXUzbXdmQWUxNUxKQkpCcVBWWjRLMGtwcGVQQlU4bTZhSVpvSDU3TC85dDRPb2FMOHlLcy9xaktGZUkxT0ZXWnh2QT0iLA0KICAgICAgICAiTUlJRE56Q0NBcUNnQXdJQkFnSUpBTUIxY3NOdUE2K2pNQTBHQ1NxR1NJYjNEUUVCQlFVQU1IRXhDekFKQmdOVkJBWVRBbFZUTVJJd0VBWURWUVFJRXdsVVpXNXVaWE56WldVeEdEQVdCZ05WQkFvVEQwVjRZVzF3YkdVZ1EyOXRjR0Z1ZVRFUU1BNEdBMVVFQXhNSFJYaGhiWEJzWlRFaU1DQUdDU3FHU0liM0RRRUpBUllUWlhoaGJYQnNaVUJsZUdGdGNHeGxMbU52YlRBZUZ3MHhNekEwTURReE5USTFOVE5hRncweU16QTBNREl4TlRJMU5UTmFNSEV4Q3pBSkJnTlZCQVlUQWxWVE1SSXdFQVlEVlFRSUV3bFVaVzV1WlhOelpXVXhHREFXQmdOVkJBb1REMFY0WVcxd2JHVWdRMjl0Y0dGdWVURVFNQTRHQTFVRUF4TUhSWGhoYlhCc1pURWlNQ0FHQ1NxR1NJYjNEUUVKQVJZVFpYaGhiWEJzWlVCbGVHRnRjR3hsTG1OdmJUQ0JuekFOQmdrcWhraUc5dzBCQVFFRkFBT0JqUUF3Z1lrQ2dZRUExc0JuQldQWjBmN1dKVUZUSnk1KzAxU2xTNVo2RERENlV5ZTl2SzlBeWNnVjVCMytXQzhIQzV1NWg5MU11akFDMUFSUFZVT3RzdlBSczQ1cUtORklnSUdSWEtQQXdaamF3RUkyc0NKUlNLVjQ3aTZCOGJEdjRXa3VHdlFhdmVaR0kwcWxtTjVSMUVpbTJnVUl0UmoxaGdjQzlyUWF2amxuRktEWTJybFhHdWtDQXdFQUFhT0IxakNCMHpBZEJnTlZIUTRFRmdRVXlWSWMzeXZyYTRFQnoyMEk0QkYzOUlBaXhCa3dnYU1HQTFVZEl3U0JtekNCbUlBVXlWSWMzeXZyYTRFQnoyMEk0QkYzOUlBaXhCbWhkYVJ6TUhFeEN6QUpCZ05WQkFZVEFsVlRNUkl3RUFZRFZRUUlFd2xVWlc1dVpYTnpaV1V4R0RBV0JnTlZCQW9URDBWNFlXMXdiR1VnUTI5dGNHRnVlVEVRTUE0R0ExVUVBeE1IUlhoaGJYQnNaVEVpTUNBR0NTcUdTSWIzRFFFSkFSWVRaWGhoYlhCc1pVQmxlR0Z0Y0d4bExtTnZiWUlKQU1CMWNzTnVBNitqTUF3R0ExVWRFd1FGTUFNQkFmOHdEUVlKS29aSWh2Y05BUUVGQlFBRGdZRUFEaHdUZWJHazczNXlLaG04RHFDeHZObkVaME54c1lFWU9qZ1JHMXlYVGxXNXBFNjkxZlNINUFaK1Q2ZnB3cFpjV1k1UVlrb042RG53ak94R2tTZlFDMy95R21jVURLQlB3aVo1TzJzOUMrZkUxa1VFbnJYMlhlYTRhZ1ZuZ016UjhEUTZvT2F1TFdxZWhEQitnMkVOV1JMb1ZnUyttYTUvWWNzMEdUeXJFQ1k9Ig0KICAgIF0NCn0"""
encodedpayload = """ew0KICAgICJ2ZXJzaW9uIjogIjEuMC4wIiwNCiAgICAiaWQiOiAiMzNjZmY0MTYtZTMzMS00YzlkLTk2OWUtNTM3M2ExNzU2MTIwIiwNCiAgICAiYWN0b3IiOiB7DQogICAgICAgICJtYm94IjogIm1haWx0bzpleGFtcGxlQGV4YW1wbGUuY29tIiwNCiAgICAgICAgIm5hbWUiOiAiRXhhbXBsZSBMZWFybmVyIiwNCiAgICAgICAgIm9iamVjdFR5cGUiOiAiQWdlbnQiDQogICAgfSwNCiAgICAidmVyYiI6IHsNCiAgICAgICAgImlkIjogImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9leHBlcmllbmNlZCIsDQogICAgICAgICJkaXNwbGF5Ijogew0KICAgICAgICAgICAgImVuLVVTIjogImV4cGVyaWVuY2VkIg0KICAgICAgICB9DQogICAgfSwNCiAgICAib2JqZWN0Ijogew0KICAgICAgICAiaWQiOiAiaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g_dj14aDRrSWlIM1NtOCIsDQogICAgICAgICJvYmplY3RUeXBlIjogIkFjdGl2aXR5IiwNCiAgICAgICAgImRlZmluaXRpb24iOiB7DQogICAgICAgICAgICAibmFtZSI6IHsNCiAgICAgICAgICAgICAgICAiZW4tVVMiOiAiVGF4IFRpcHMgJiBJbmZvcm1hdGlvbiA6IEhvdyB0byBGaWxlIGEgVGF4IFJldHVybiAiDQogICAgICAgICAgICB9LA0KICAgICAgICAgICAgImRlc2NyaXB0aW9uIjogew0KICAgICAgICAgICAgICAgICJlbi1VUyI6ICJGaWxpbmcgYSB0YXggcmV0dXJuIHdpbGwgcmVxdWlyZSBmaWxsaW5nIG91dCBlaXRoZXIgYSAxMDQwLCAxMDQwQSBvciAxMDQwRVogZm9ybSINCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgIH0sDQogICAgInRpbWVzdGFtcCI6ICIyMDEzLTA0LTAxVDEyOjAwOjAwWiINCn0"""

privatekey = """-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQDjxvZXF30WL4oKjZYXgR0ZyaX+u3y6+JqTqiNkFa/VTnet6Ly2
OT6ZmmcJEPnq3UnewpHoOQ+GfhhTkW13j06j5iNn4obcCVWTL9yXNvJH+Ko+xu4Y
l/ySPRrIPyTjtHdG0M2XzIlmmLqm+CAS+KCbJeH4tf543kIWC5pC5p3cVQIDAQAB
AoGAOejdvGq2XKuddu1kWXl0Aphn4YmdPpPyCNTaxplU6PBYMRjY0aNgLQE6bO2p
/HJiU4Y4PkgzkEgCu0xf/mOq5DnSkX32ICoQS6jChABAe20ErPfm5t8h9YKsTfn9
40lAouuwD9ePRteizd4YvHtiMMwmh5PtUoCbqLefawNApAECQQD1mdBW3zL0okUx
2pc4tttn2qArCG4CsEZMLlGRDd3FwPWJz3ZPNEEgZWXGSpA9F1QTZ6JYXIfejjRo
UuvRMWeBAkEA7WvzDBNcv4N+xeUKvH8ILti/BM58LraTtqJlzjQSovek0srxtmDg
5of+xrxN6IM4p7yvQa+7YOUOukrVXjG+1QJBAI2mBrjzxgm9xTa5odn97JD7UMFA
/WHjlMe/Nx/35V52qaav1sZbluw+TvKMcqApYj5G2SUpSNudHLDGkmd2nQECQFfc
lBRK8g7ZncekbGW3aRLVGVOxClnLLTzwOlamBKOUm8V6XxsMHQ6TE2D+fKJoNUY1
2HGpk+FWwy2D1hRGuoUCQAXfaLSxtaWdPtlZTPVueF7ZikQDsVg+vtTFgpuHloR2
6EVc1RbHHZm32yvGDY8IkcoMfJQqLONDdLfS/05yoNU=
-----END RSA PRIVATE KEY-----"""



########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url

urlpatterns = patterns('lrs.views',
    url(r'^$', 'home'),
    url(r'^statements/more/(?P<more_id>.{32})$', 'statements_more'),
    url(r'^statements', 'statements'),
    url(r'^activities/state', 'activity_state'),
    url(r'^activities/profile', 'activity_profile'),
    url(r'^activities', 'activities'),
    url(r'^agents/profile', 'agent_profile'),
    url(r'^agents', 'agents'),
    url(r'^actexample/$', 'actexample'),
    url(r'^actexample2/$', 'actexample2'),
    url(r'^actexample3/$', 'actexample3'),
    url(r'^actexample4/$', 'actexample4'),
    url(r'^register/$', 'register'),
    url(r'^regclient/$', 'reg_client'),    
    url(r'^OAuth/', include('oauth_provider.urls')),
    # just urls for some user interface... not part of xapi
    url(r'^me/statements/', 'my_statements'),
    url(r'^me/apps/', 'my_app_status'),
    url(r'^me/tokens/', 'delete_token'),
    url(r'^me/', 'me'),
    url(r'^about', 'about'),
    url(r'^statementvalidator', 'stmt_validator')
)
urlpatterns += patterns('',
  url(r'^accounts/login/$', 'django.contrib.auth.views.login', name="login"),
  url(r'^accounts/logout/$', 'lrs.views.logout_view', name="logout"),
)

########NEW FILE########
__FILENAME__ = accept_middleware
from string import lower

def webkit_workaround(bestq, result):
    """The next part is a workaround, to avoid the problem, webkit browsers
    generate, by putting application/xml as the first item in theire 
    accept headers
    
    The algorithm changes the order of the best quality fields, if xml appears
    to be the first entry of best quality and eigther an xhtml or html emtry is,
    found with also best quality, to xml beeing the last entry of best quality.
    
    If only an xhtml entry is found in bestq, but the request contains an html
    entry with lower rating, it rearranges the html entry to be directly
    in front of xml.
    """
    if result[0][0] == "application/xml":
        bestresult = []
        length = 0
        hashtml = False
        hasxhtml = False
        idxhtml = None
        
        i = 0
        for mediatype in result:
            if mediatype[2] == bestq:
                bestresult.append(mediatype)
                length = length + 1
                if not hasxhtml and lower(mediatype[0]) == "application/xhtml+xml":
                    hasxhtml = True
                if not hashtml and lower(mediatype[0]) == "text/html":
                    hashtml = True
            if lower(mediatype[0]) == "text/html":
                idxhtml = i
            i = i+1
        
        if (hashtml or hasxhtml) and length > 1:
                
            newresult = []
            newresult.extend(bestresult[1:])
            
            if not hashtml and idxhtml:
                htmltype = result.pop(idxhtml)
                htmltype = (htmltype[0], htmltype[1], bestq)
                newresult.append(htmltype)
            
            newresult.append(bestresult[0])
            newresult.extend(result[length:])
            
            result = newresult
    return result

def parse_accept_header(accept):
    """Parse the Accept header *accept*, returning a list with pairs of
    (media_type, q_value), ordered by q values.
    """
    bestq = 0.0
    result = []
    for media_range in accept.split(","):
        parts = media_range.split(";")
        media_type = parts.pop(0)
        media_params = []
        q = 1.0
        for part in parts:
            (key, value) = part.lstrip().split("=", 1)
            if key == "q":
                q = float(value)
            else:
                media_params.append((key, value))
        
        if q > bestq:
            bestq = q
        result.append((media_type, tuple(media_params), q))
    result.sort(lambda x, y: -cmp(x[2], y[2]))
    
    result = webkit_workaround(bestq, result)
    
    return result

class AcceptMiddleware(object):
    def process_request(self, request):
        accept = parse_accept_header(request.META.get("HTTP_ACCEPT", ""))
        request.accept = accept
        request.accepted_types = map(lambda (t, p, q): t, accept)
        
########NEW FILE########
__FILENAME__ = AllowOriginMiddleware
from django.http import HttpResponse


class AllowOriginMiddleware(object):
    def process_request(self, request):
        if request.method == 'OPTIONS':
            return HttpResponse()

    def process_response(self, request, response):
        response['Access-Control-Allow-Origin'] = '*'
        response['Access-Control-Allow-Methods'] = 'HEAD, POST, GET, OPTIONS, DELETE, PUT'
        response['Access-Control-Allow-Headers'] = 'Content-Type,Content-Length,Authorization,If-Match,If-None-Match,X-Experience-API-Version, Accept-Language'
        response['Access-Control-Expose-Headers'] = 'ETag,Last-Modified,Cache-Control,Content-Type,Content-Length,WWW-Authenticate,X-Experience-API-Version, Accept-Language'
        return response
########NEW FILE########
__FILENAME__ = Authorization
import base64
from functools import wraps
from django.conf import settings
from django.contrib.auth import authenticate
from lrs.exceptions import Unauthorized, OauthUnauthorized, BadRequest
from lrs.models import Token, Agent
from oauth_provider.utils import send_oauth_error
from oauth_provider.consts import  ACCEPTED

# A decorator, that can be used to authenticate some requests at the site.
def auth(func):
    @wraps(func)
    def inner(request, *args, **kwargs):
        # Note: The cases involving OAUTH_ENABLED are here if OAUTH_ENABLED is switched from true to false
        # after a client has performed the handshake. (Not likely to happen, but could) 
        auth_type = request['auth']['type']
        # There is an http auth_type request and http auth is enabled
        if auth_type == 'http' and settings.HTTP_AUTH_ENABLED:
            http_auth_helper(request)
        # There is an http auth_type request and http auth is not enabled
        elif auth_type == 'http' and not settings.HTTP_AUTH_ENABLED:
            raise BadRequest("HTTP authorization is not enabled. To enable, set the HTTP_AUTH_ENABLED flag to true in settings")
        # There is an oauth auth_type request and oauth is enabled
        elif auth_type == 'oauth' and settings.OAUTH_ENABLED: 
            oauth_helper(request)
        # There is an oauth auth_type request and oauth is not enabled
        elif auth_type == 'oauth' and not settings.OAUTH_ENABLED: 
            raise BadRequest("OAuth is not enabled. To enable, set the OAUTH_ENABLED flag to true in settings")
        # There is no auth_type request and there is some sort of auth enabled
        elif auth_type == 'none' and (settings.HTTP_AUTH_ENABLED or settings.OAUTH_ENABLED):
            raise Unauthorized("Auth is enabled but no authentication was sent with the request.")
        # There is no auth_type request and no auth is enabled
        elif auth_type == 'none' and not (settings.HTTP_AUTH_ENABLED or settings.OAUTH_ENABLED):
            request['auth'] = None
        return func(request, *args, **kwargs)
    return inner

def http_auth_helper(request):
    if request['headers'].has_key('Authorization'):
        auth = request['headers']['Authorization'].split()
        if len(auth) == 2:
            if auth[0].lower() == 'basic':
                # Currently, only basic http auth is used.
                uname, passwd = base64.b64decode(auth[1]).split(':')
                user = authenticate(username=uname, password=passwd)
                if user:
                    # If the user successfully logged in, then add/overwrite
                    # the user object of this request.
                    request['auth']['id'] = user
                else:
                    raise Unauthorized("Authorization failed, please verify your username and password")
    else:
        # The username/password combo was incorrect, or not provided.
        raise Unauthorized("Authorization header missing")

def oauth_helper(request):
    consumer = request['auth']['oauth_consumer']
    token = request['auth']['oauth_token']
    
    # Make sure consumer has been accepted by system
    if consumer.status != ACCEPTED:
        raise OauthUnauthorized(send_oauth_error("%s has not been authorized" % str(consumer.name)))

    # make sure the token is an approved access token
    if token.token_type != Token.ACCESS or not token.is_approved:
        raise OauthUnauthorized(send_oauth_error("The access token is not valid"))
    
    user = token.user
    user_name = user.username
    if user.email.startswith('mailto:'):
        user_email = user.email
    else:
        user_email = 'mailto:%s' % user.email
    consumer = token.consumer                
    members = [
                {
                    "account":{
                                "name":consumer.key,
                                "homePage":"lrs://XAPI/OAuth/token/"
                    },
                    "objectType": "Agent",
                    "oauth_identifier": "anonoauth:%s" % (consumer.key)
                },
                {
                    "name":user_name,
                    "mbox":user_email,
                    "objectType": "Agent"
                }
    ]
    kwargs = {"objectType":"Group", "member":members,"oauth_identifier": "anongroup:%s-%s" % (consumer.key, user_email)}
    # create/get oauth group and set in dictionary
    oauth_group, created = Agent.objects.oauth_group(**kwargs)
    request['auth']['id'] = oauth_group

########NEW FILE########
__FILENAME__ = etag
import hashlib
from lrs.exceptions import Conflict, PreconditionFail

IF_MATCH = "HTTP_IF_MATCH"
IF_NONE_MATCH = "HTTP_IF_NONE_MATCH"

def create_tag(resource):
    return hashlib.sha1(resource).hexdigest()

def get_etag_info(headers, required=True):
    etag = {}
    etag[IF_MATCH] = headers.get(IF_MATCH, None) 
    if not etag[IF_MATCH]:
        etag[IF_MATCH] = headers.get('If_Match', None)
    if not etag[IF_MATCH] and 'If-Match' in headers:
        etag[IF_MATCH] = headers['If-Match']

    etag[IF_NONE_MATCH] = headers.get(IF_NONE_MATCH, None)
    if not etag[IF_NONE_MATCH]:
        etag[IF_NONE_MATCH] = headers.get('If_None_Match', None)
    if not etag[IF_NONE_MATCH] and 'If-None-Match' in headers:
        etag[IF_NONE_MATCH] = headers['If-None-Match']

    if required and not etag[IF_MATCH] and not etag[IF_NONE_MATCH]:
        raise MissingEtagInfo("If-Match and If-None-Match headers were missing. One of these headers is required for this request.")
    return etag

def check_preconditions(request, contents, required=False):
    try:
        request_etag = request['headers']['ETAG']
        if not request_etag[IF_MATCH] and not request_etag[IF_NONE_MATCH]:
            request_etag = None
    except KeyError:
        request_etag = None

    if not request_etag and not required:
        return
    elif not request_etag and required:
        raise MissingEtagInfo("If-Match and If-None-Match headers were missing. One of these headers is required for this request.")

    if request_etag[IF_NONE_MATCH]:
        if request_etag[IF_NONE_MATCH] == "*" and contents:
            raise EtagPreconditionFail("Resource detected")
        elif contents:
            if contents.etag in request_etag[IF_NONE_MATCH]:
                raise EtagPreconditionFail("Resource detected")
    elif request_etag[IF_MATCH]:
        if request_etag[IF_MATCH] != "*":
            if contents.etag in request_etag[IF_MATCH]:
                return
            raise EtagPreconditionFail("No resources matched your etag precondition: %s" % request_etag[IF_MATCH])
    else:
        raise MissingEtagInfo("If-Match and If-None-Match headers were missing. One of these headers is required for this request.")

class MissingEtagInfo(Conflict):
    def __init__(self, msg):
        self.message = msg
    def __str__(self):
        return repr(self.message)

class EtagPreconditionFail(PreconditionFail):
    def __init__(self, msg):
        self.message = msg
    def __str__(self):
        return repr(self.message)
########NEW FILE########
__FILENAME__ = jws
from binascii import a2b_base64
from Crypto.Hash import SHA256, SHA384, SHA512
from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_v1_5, PKCS1_PSS
from Crypto.Util.asn1 import DerSequence
import base64
import json

# https://www.dlitz.net/software/pycrypto/api/current/

fixb64padding = lambda s: s if len(s) % 4 == 0 else s + '=' * (4 - (len(s) % 4))
rmb64padding = lambda s: s.rstrip('=')
algs = {"RS256": SHA256,
        "RS384": SHA384,
        "RS512": SHA512}

class JWS(object):
    """
    Class used to represent a JSON Web Signature (JWS).
    see: http://tools.ietf.org/html/draft-ietf-jose-json-web-signature-08
    Only covers the requirements outlined in the Experience API spec.
    see: https://github.com/adlnet/xAPI-Spec/blob/master/xAPI.md#signature
    """
    def __init__(self, header=None, payload=None, jws=None):
        """
        Init for a JWS object.

        If you want to create a JWS, pass in the header and payload and call 
        :func:`JWS.create`.

        If you want to parse and verify a JWS, pass in the JWS and call 
        :func:`JWS.verify`.

        :param header:
            JWS Header - Optional
        :param payload:
            JWS Payload - Optional
        :param jws:
            JSON Web Signature - Optional
        """
        self.header = header
        if self.header:
            self._parseheader()
        self.payload = payload
        self.jws = jws
        if self.jws:
            self._parsejws()
        
    def verify(self):
        """
        Verifies the JWS Signature can be verified by the public key.
        """
        # free pass for those who don't use x5c
        if not self.should_verify:
            return True
        try:
            pubkey = self._cert_to_key(self.headerobj['x5c'][0])
        except:
            raise JWSException("Error importing public key")
        
        verifier = PKCS1_v1_5.new(pubkey)
        res = verifier.verify(self._hash(), self.jwssignature)
        if not res:
            verifier = PKCS1_PSS.new(pubkey)
            res = verifier.verify(self._hash(), self.jwssignature)
        return res

    def create(self, privatekey):
        """
        Creates a JWS using the privatekey string to sign.

        :param privatekey: 
            String format of the private key to use to sign the JWS Signature Input.
        """
        if not self.jws:
            privkey = RSA.importKey(privatekey)
            # encode header and payload
            self.encheader = rmb64padding(base64.urlsafe_b64encode(self.header))
            self.encpayload = rmb64padding(base64.urlsafe_b64encode(self.payload))
            # hash & sign
            signer = PKCS1_v1_5.new(privkey)
            self.jwssignature = signer.sign(self._hash())
            # encode signature
            self.encjwssignature = rmb64padding(base64.urlsafe_b64encode(self.jwssignature))
            # join 3
            self.jws = '.'.join([self.encheader,self.encpayload,self.encjwssignature])

        return self.jws

    def sha2(self, jwsobj=None, alg=None):
        """
        Hash (SHA256) the JWS according to xAPI attachment rules 
        for the sha2 attribute. Returns the hexdigest value. If 
        a parameter isn't provided, this will use the values provided 
        when creating this jws object.

        :param jwsobj:
            The JWS (header.paylaod.signature) to be hashed (optional)

        :param alg:
            The hashing algorithm to use ['RS256'(default), 'RS384', 'RS512'] (optional)
        """
        thealg = alg if alg else "RS256"
        thejws = jwsobj if jwsobj else self.jws
        return algs[thealg].new(thejws).hexdigest()

    def validate(self, stmt):
        """
        Validate the incoming Statement against the Statement in the JWS payload.

        :param stmt:
            String format of the Statement object to be validated
        """
        # free pass for those who don't use x5c
        if not self.should_verify:
            return True
        if type(stmt) != dict:
            stmtobj = json.loads(stmt)
        else:
            stmtobj = stmt
        atts = stmtobj.pop('attachments', None)
        if atts:
            atts = [a for a in atts if a.get('usageType',None) != "http://adlnet.gov/expapi/attachments/signature"]
            if atts:
                stmtobj['attachments'] = atts

        sortedstmt = json.dumps(stmtobj, sort_keys=True)
        sortedpayload = json.dumps(json.loads(self.payload), sort_keys=True)
        return sortedstmt == sortedpayload

    def _parseheader(self):
        if type(self.header) != dict:
            try:
                self.headerobj = json.loads(self.header)
            except:
                raise JWSException('JWS header was not valid JSON')
        else:
            try:
                self.headerobj = self.header
                self.header = json.dumps(self.header)
            except:
                raise JWSException('JWS header was not valid JSON')
        if 'alg' not in self.headerobj:
            raise JWSException('JWS header did not have an "alg" property')
        self.should_verify = 'x5c' in self.headerobj
        if self.should_verify:
            if type(self.headerobj['x5c']) != list:
                raise JWSException('x5c property was not an array of certificate value strings')

    def _parsejws(self):
        jwsparts = self.jws.split('.')
        if len(jwsparts) != 3:
            raise JWSException('The JWS was not formatted correctly - should be encodedheader.encodedpayload.encodedjwssignature')
        self.encheader = jwsparts[0]
        self.header = base64.urlsafe_b64decode(fixb64padding(self.encheader))
        self._parseheader()
        self.encpayload = jwsparts[1]
        self.payload = base64.urlsafe_b64decode(fixb64padding(self.encpayload))
        self.encjwssignature = jwsparts[2]
        self.jwssignature = base64.urlsafe_b64decode(fixb64padding(jwsparts[2]))

    def _hash(self):
        return algs[self.headerobj['alg']].new('.'.join([self.encheader,self.encpayload]).encode('ascii'))
        
    def _cert_to_key(self, cert):
        # Convert from PEM to DER
        if not cert.startswith('-----BEGIN CERTIFICATE-----') and not cert.endswith('-----END CERTIFICATE-----'):
            cert = "-----BEGIN CERTIFICATE-----\n%s\n-----END CERTIFICATE-----" % cert
        lines = cert.replace(" ",'').split()
        der = a2b_base64(''.join(lines[1:-1]))

        # Extract subjectPublicKeyInfo field from X.509 certificate (see RFC3280)
        cert = DerSequence()
        cert.decode(der)
        tbsCertificate = DerSequence()
        tbsCertificate.decode(cert[0])
        subjectPublicKeyInfo = tbsCertificate[6]

        # Initialize RSA key
        return RSA.importKey(subjectPublicKeyInfo)


class JWSException(Exception):
    """Generic exception class."""
    def __init__(self, message='JWS error occured.'):
        self.message = message

########NEW FILE########
__FILENAME__ = profile_decorator
import os
import datetime

PROFILE_LOG_BASE = '/home/ubuntu/Desktop/profiling/profiles/'

def profile_func(filename):
    """Function/method decorator that will cause only the decorated callable
        to be profiled and saved to the specified file.

        @type  filename: str
        @param filename: The filename to write the profile to."""
    if not os.path.isabs(filename):
        filename = os.path.join(PROFILE_LOG_BASE, filename)
    def proffunc(f):
        def profiled_func(*args, **kwargs):
            import cProfile
            import logging
            import pstats

            (base, ext) = os.path.splitext(filename)
            base = base + "-" + datetime.datetime.now().strftime("%Y%m%dT%HH%MM%SS%f")
            final_log_file = base + ext

            logging.info('Profiling function %s' % (f.__name__))

            try:
                profiler = cProfile.Profile()
                retval = profiler.runcall(f, *args, **kwargs)
                stats = profiler.getstats()
                profiler.dump_stats(final_log_file)
            except IOError:
                logging.exception(_("Could not open profile file '%(filename)s'") % {"filename": final_log_file})

            return retval

        return profiled_func
    return proffunc
########NEW FILE########
__FILENAME__ = req_parse
import StringIO
import email
import json
import urllib
from collections import defaultdict
from django.http import MultiPartParser
from django.utils.translation import ugettext as _
from django.core.cache import get_cache
from lrs.util import etag, convert_to_dict, convert_post_body_to_dict
from lrs.util.jws import JWS, JWSException
from lrs.exceptions import OauthUnauthorized, ParamError, BadRequest
from oauth_provider.oauth.oauth import OAuthError
from oauth_provider.utils import send_oauth_error
from oauth_provider.decorators import CheckOAuth

att_cache = get_cache('attachment_cache')

def parse(request, more_id=None):
    r_dict = {}
    # Build headers from request in request dict
    r_dict['headers'] = get_headers(request.META)
    
    # Traditional authorization should be passed in headers
    r_dict['auth'] = {}
    if 'Authorization' in r_dict['headers']:
        # OAuth will always be dict, not http auth. Set required fields for oauth module and type for authentication
        # module
        set_authorization(r_dict, request)     
    elif 'Authorization' in request.body or 'HTTP_AUTHORIZATION' in request.body:
        # Authorization could be passed into body if cross origin request
        r_dict['auth']['type'] = 'http'
    else:
        r_dict['auth']['type'] = 'none'

    r_dict['params'] = {}
    # lookin for weird IE CORS stuff.. it'll be a post with a 'method' url param
    if request.method == 'POST' and 'method' in request.GET:
        bdy = convert_post_body_to_dict(request.body)
        # 'content' is in body for the IE cors POST
        if 'content' in bdy:
            r_dict['body'] = urllib.unquote(bdy.pop('content'))
        # headers are in the body too for IE CORS, we removes them
        r_dict['headers'].update(get_headers(bdy))
        for h in r_dict['headers']:
            bdy.pop(h, None)

        # remove extras from body
        bdy.pop('X-Experience-API-Version', None)
        bdy.pop('Content-Type', None)
        bdy.pop('If-Match', None)
        bdy.pop('If-None-Match', None)
        
        # all that should be left are params for the request, 
        # we adds them to the params object
        r_dict['params'].update(bdy)
        for k in request.GET:
            if k == 'method': # make sure the method param goes in the special method spot
                r_dict[k] = request.GET[k]
            else:
                r_dict['params'][k] = request.GET[k]
    # Just parse body for all non IE CORS stuff
    else:
        r_dict = parse_body(r_dict, request)
        # Update dict with any GET data
        r_dict['params'].update(request.GET.dict())

    # Method gets set for cors already
    if 'method' not in r_dict:
        # Differentiate GET and POST
        if request.method == "POST" and (request.path[6:] == 'statements' or request.path[6:] == 'statements/'):
            # Can have empty body for POST (acts like GET)
            if 'body' in r_dict:
                # If body is a list, it's a post
                if not isinstance(r_dict['body'], list):
                    if not isinstance(r_dict['body'], dict):
                        raise BadRequest("Cannot evaluate data into dictionary to parse -- Error: %s" % r_dict['body'])
                    # If actor verb and object not in body - means it's a GET or invalid POST
                    if not ('actor' in r_dict['body'] and 'verb' in r_dict['body'] and 'object' in r_dict['body']):
                        # If body keys are in get params - GET - else invalid request
                        if set(r_dict['body'].keys()).issubset(['statementId', 'voidedStatementId', 'agent', 'verb', 'activity', 'registration',
                            'related_activities', 'related_agents', 'since', 'until', 'limit', 'format', 'attachments', 'ascending']):
                            r_dict['method'] = 'GET'
                        else:
                            raise BadRequest("Statement is missing actor, verb, or object")
                    else:
                        r_dict['method'] = 'POST'
                else:
                    r_dict['method'] = 'POST'
            else:
                r_dict['method'] = 'GET'
        else:
            r_dict['method'] = request.method

    # Set if someone is hitting the statements/more endpoint
    if more_id:
        r_dict['more_id'] = more_id
    return r_dict

def set_authorization(r_dict, request):
    auth_params = r_dict['headers']['Authorization']
    if auth_params[:6] == 'OAuth ':
        # Make sure it has the required/valid oauth headers
        if CheckOAuth.is_valid_request(request):
            try:
                consumer, token, parameters = CheckOAuth.validate_token(request)
            except OAuthError, e:
                raise OauthUnauthorized(send_oauth_error(e))
            # Set consumer and token for authentication piece
            r_dict['auth']['oauth_consumer'] = consumer
            r_dict['auth']['oauth_token'] = token
            r_dict['auth']['type'] = 'oauth'
        else:
            raise OauthUnauthorized(send_oauth_error(OAuthError(_('Invalid OAuth request parameters.'))))

        # Used for OAuth scope
        endpoint = request.path[5:]
        # Since we accept with or without / on end
        if endpoint.endswith("/"):
            endpoint = endpoint[:-1]
        r_dict['auth']['endpoint'] = endpoint
    else:
        r_dict['auth']['type'] = 'http'    

def parse_attachment(r, request):
    message = request.body
    # i need boundary to be in the message for email to parse it right
    if 'boundary' not in message[:message.index("--")]:
        if 'boundary' in request.META['CONTENT_TYPE']:
            message = request.META['CONTENT_TYPE'] + message
        else:
            raise BadRequest("Could not find the boundary for the multipart content")
    msg = email.message_from_string(message)
    if msg.is_multipart():
        parts = []
        for part in msg.walk():
            parts.append(part)
        if len(parts) < 1:
            raise ParamError("The content of the multipart request didn't contain a statement")
        # ignore parts[0], it's the whole thing
        # parts[1] better be the statement
        r['body'] = convert_to_dict(parts[1].get_payload())
        if len(parts) > 2:
            r['payload_sha2s'] = []
            for a in parts[2:]:
                # attachments
                thehash = a.get("X-Experience-API-Hash")
                if not thehash:
                    raise BadRequest("X-Experience-API-Hash header was missing from attachment")
                headers = defaultdict(str)
                r['payload_sha2s'].append(thehash)
                # Save msg object to cache
                att_cache.set(thehash, a)
    else:
        raise ParamError("This content was not multipart for the multipart request.")
    # see if the posted statements have attachments
    att_stmts = []
    if isinstance(r['body'], list):
        for s in r['body']:
            if 'attachments' in s:
                att_stmts.append(s)
    elif 'attachments' in r['body']:
        att_stmts.append(r['body'])
    if att_stmts:
        # find if any of those statements with attachments have a signed statement
        signed_stmts = [(s,a) for s in att_stmts for a in s.get('attachments', None) if a['usageType'] == "http://adlnet.gov/expapi/attachments/signature"]
        for ss in signed_stmts:
            attmnt = att_cache.get(ss[1]['sha2']).get_payload(decode=True)
            jws = JWS(jws=attmnt)
            try:
                if not jws.verify() or not jws.validate(ss[0]):
                    raise BadRequest("The JSON Web Signature is not valid")
            except JWSException as jwsx:
                raise BadRequest(jwsx)    

def parse_body(r, request):
    if request.method == 'POST' or request.method == 'PUT':
        # Parse out profiles/states if the POST dict is not empty
        if 'multipart/form-data' in request.META['CONTENT_TYPE']:
            if request.POST.dict().keys():
                r['params'].update(request.POST.dict())
                parser = MultiPartParser(request.META, StringIO.StringIO(request.raw_post_data),request.upload_handlers)
                post, files = parser.parse()
                r['files'] = files
        # If it is multipart/mixed, parse out all data
        elif 'multipart/mixed' in request.META['CONTENT_TYPE']: 
            parse_attachment(r, request)
        # Normal POST/PUT data
        else:
            if request.body:
                # profile uses the request body
                r['raw_body'] = request.body
                # Body will be some type of string, not necessarily JSON
                r['body'] = convert_to_dict(request.body)
            else:
                raise BadRequest("No body in request")
    return r

def get_headers(headers):
    r = {}
    if 'HTTP_UPDATED' in headers:
        r['updated'] = headers['HTTP_UPDATED']
    elif 'updated' in headers:
        r['updated'] = headers['updated']

    r['CONTENT_TYPE'] = headers.get('CONTENT_TYPE', '')
    if r['CONTENT_TYPE'] == '' and 'Content-Type' in headers:
        r['CONTENT_TYPE'] = headers['Content-Type']
    # FireFox automatically adds ;charset=foo to the end of headers. This will strip it out
    if ';' in r['CONTENT_TYPE']:
        r['CONTENT_TYPE'] = r['CONTENT_TYPE'].split(';')[0]

    r['ETAG'] = etag.get_etag_info(headers, required=False)
    if 'HTTP_AUTHORIZATION' in headers:
        r['Authorization'] = headers.get('HTTP_AUTHORIZATION', None)
    elif 'Authorization' in headers:
        r['Authorization'] = headers.get('Authorization', None)

    if 'Accept_Language' in headers:
        r['language'] = headers.get('Accept_Language', None)
    elif 'Accept-Language' in headers:
        r['language'] = headers['Accept-Language']
    return r

########NEW FILE########
__FILENAME__ = req_process
import json
import datetime
import uuid
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from email.mime.base import MIMEBase
from django.http import HttpResponse
from django.conf import settings
from django.utils.timezone import utc
from lrs import models
from lrs.exceptions import IDNotFoundError
from lrs.objects.ActivityProfileManager import ActivityProfileManager
from lrs.objects.ActivityStateManager import ActivityStateManager 
from lrs.objects.AgentManager import AgentManager
from lrs.objects.AgentProfileManager import AgentProfileManager
from lrs.objects.StatementManager import StatementManager
import retrieve_statement

def process_statements(stmts, auth_id, define):
    stmt_responses = []
   # Handle batch POST
    if type(stmts) is list:
        try:
            for st in stmts:
                if not 'id' in st:
                    st['id'] = str(uuid.uuid1())
                
                if not 'version' in st:
                    st['version'] = "1.0.1"
    
                if 'context' in st and 'contextActivities' in st['context']:
                    for k, v in st['context']['contextActivities'].items():
                        if isinstance(v, dict):
                            st['context']['contextActivities'][k] = [v]
                
                if 'objectType' in st['object'] and st['object']['objectType'] == 'SubStatement':
                    if 'context' in st['object'] and 'contextActivities' in st['object']['context']:
                        for k, v in st['object']['context']['contextActivities'].items():
                            if isinstance(v, dict):
                                st['object']['context']['contextActivities'][k] = [v]

                if not 'authority' in st:
                    if auth_id:
                        if auth_id.__class__.__name__ == 'Agent':
                            st['authority'] = auth_id.get_agent_json()
                        else:
                            st['authority'] = {'name':auth_id.username, 'mbox':'mailto:%s' % auth_id.email, 'objectType': 'Agent'}

                st['stored'] = str(datetime.utcnow().replace(tzinfo=utc).isoformat())

                if not 'timestamp' in st:
                    st['timestamp'] = st['stored']

                stmt_json = json.dumps(st)
                stmt = StatementManager(st, auth_id, define, stmt_json).model_object
                stmt_responses.append(str(stmt.statement_id))
        # Catch exceptions being thrown from object classes, delete the statement first then raise 
        except Exception:
            for stmt_id in stmt_responses:
                models.Statement.objects.get(statement_id=stmt_id).delete()
            raise
    else:
        if not 'id' in stmts:
            stmts['id'] = str(uuid.uuid1())

        if not 'version' in stmts:
            stmts['version'] = "1.0.0"

        if 'context' in stmts and 'contextActivities' in stmts['context']:
            for k, v in stmts['context']['contextActivities'].items():
                if isinstance(v, dict):
                    stmts['context']['contextActivities'][k] = [v]

        if 'objectType' in stmts['object'] and stmts['object']['objectType'] == 'SubStatement':
            if 'context' in stmts['object'] and 'contextActivities' in stmts['object']['context']:
                for k, v in stmts['object']['context']['contextActivities'].items():
                    if isinstance(v, dict):
                        stmts['object']['context']['contextActivities'][k] = [v]

        if not 'authority' in stmts:
            if auth_id:
                if auth_id.__class__.__name__ == 'Agent':
                    stmts['authority'] = auth_id.get_agent_json()
                else:
                    stmts['authority'] = {'name':auth_id.username, 'mbox': 'mailto:%s' % auth_id.email, 'objectType': 'Agent'}            
        
        # Handle single POST
        stmts['stored'] = str(datetime.utcnow().replace(tzinfo=utc).isoformat())

        if not 'timestamp' in stmts:
            stmts['timestamp'] = stmts['stored']

        stmt_json = json.dumps(stmts)
        stmt = StatementManager(stmts, auth_id, define, stmt_json).model_object
        stmt_responses.append(stmt.statement_id)
    return stmt_responses

def get_auth(auth):
    define = True
    auth_id = auth['id'] if auth and 'id' in auth else None
    if auth and 'oauth_define' in auth:
        define = auth['oauth_define']
    return auth_id, define

def process_complex_get(req_dict):
    mime_type = "application/json"
    # Parse out params into single dict-GET data not in body
    param_dict = {}
    try:
        param_dict = req_dict['body']
        if not isinstance(param_dict, dict):
            param_dict = convert_to_dict(param_dict)
    except KeyError:
        pass # no params in the body    
    param_dict.update(req_dict['params'])
    format = param_dict['format']
    
    # Set language if one pull from req_dict since language is from a header, not an arg 
    language = None
    if 'headers' in req_dict and ('format' in param_dict and param_dict['format'] == "canonical"):
        if 'language' in req_dict['headers']:
            language = req_dict['headers']['language']
        else:
            language = settings.LANGUAGE_CODE

    # If auth is in req dict, add it to param dict
    if 'auth' in req_dict:
        param_dict['auth'] = req_dict['auth']

    # Get limit if one
    limit = None
    if 'params' in req_dict and 'limit' in req_dict['params']:
        limit = int(req_dict['params']['limit'])
    elif 'body' in req_dict and 'limit' in req_dict['body']:
        limit = int(req_dict['body']['limit'])

    # See if attachments should be included
    try:
        attachments = req_dict['params']['attachments']
    except Exception, e:
        attachments = False

    # Create returned stmt list from the req dict
    stmt_result = retrieve_statement.complex_get(param_dict, limit, language, format, attachments)
    
    if format == 'exact':
        content_length = len(stmt_result)    
    else:
        content_length = len(json.dumps(stmt_result))

    # If attachments=True in req_dict then include the attachment payload and return different mime type
    if attachments:
        stmt_result, mime_type, content_length = build_response(stmt_result, content_length)
        resp = HttpResponse(stmt_result, mimetype=mime_type, status=200)
    # Else attachments are false for the complex get so just dump the stmt_result
    else:
        if format == 'exact':
            result = stmt_result
        else:
            result = json.dumps(stmt_result)
        content_length = len(result)
        resp = HttpResponse(result, mimetype=mime_type, status=200)    
    return resp, content_length

def statements_post(req_dict):
    auth_id, define = get_auth(req_dict.get('auth', None))
    stmt_responses = process_statements(req_dict['body'], auth_id, define)
    return HttpResponse(json.dumps([st for st in stmt_responses]), mimetype="application/json", status=200)

def statements_put(req_dict):
    auth_id, define = get_auth(req_dict.get('auth', None))
    stmt_responses = process_statements(req_dict['body'], auth_id, define)
    return HttpResponse("No Content", status=204)

def statements_more_get(req_dict):
    stmt_result, attachments = retrieve_statement.get_more_statement_request(req_dict['more_id'])     

    if isinstance(stmt_result, dict):
        content_length = len(json.dumps(stmt_result))
    else:
        content_length = len(stmt_result)
    mime_type = "application/json"

    # If there are attachments, include them in the payload
    if attachments:
        stmt_result, mime_type, content_length = build_response(stmt_result, content_length)
        resp = HttpResponse(stmt_result, mimetype=mime_type, status=200)
    # If not, just dump the stmt_result
    else:
        if isinstance(stmt_result, basestring):
            resp = HttpResponse(stmt_result, mimetype=mime_type, status=200)
        else:
            resp = HttpResponse(json.dumps(stmt_result), mimetype=mime_type, status=200)
    
    # Add consistent header and set content-length
    try:
        resp['X-Experience-API-Consistent-Through'] = str(models.Statement.objects.latest('stored').stored)
    except:
        resp['X-Experience-API-Consistent-Through'] = str(datetime.now())
    resp['Content-Length'] = str(content_length)
    return resp

def statements_get(req_dict):
    stmt_result = {}
    mime_type = "application/json"

    # If statementId is in req_dict then it is a single get
    if 'statementId' in req_dict:     
        st = models.Statement.objects.get(statement_id=req_dict['statementId'])        
        
        # return the object, will already be json since format will be exact
        stmt_result = st.object_return()
        resp = HttpResponse(stmt_result, mimetype=mime_type, status=200)
        content_length = len(stmt_result)
    # Complex GET
    else:
        resp, content_length = process_complex_get(req_dict)
        
    # Set consistent through and content length headers for all responses
    try:
        resp['X-Experience-API-Consistent-Through'] = str(models.Statement.objects.latest('stored').stored)
    except:
        resp['X-Experience-API-Consistent-Through'] = str(datetime.now())
    
    resp['Content-Length'] = str(content_length)  
    return resp

def build_response(stmt_result, content_length):
    sha2s = []
    mime_type = "application/json"
    if isinstance(stmt_result, dict):
        statements = stmt_result['statements']
    else:
        statements = json.loads(stmt_result)['statements']

    # Iterate through each attachment in each statement
    for stmt in statements:
        if 'attachments' in stmt:
            for attachment in stmt['attachments']:
                if 'sha2' in attachment:
                    # If there is a sha2-retrieve the StatementAttachment object and add the payload to sha2s
                    att_object = models.StatementAttachment.objects.get(sha2=attachment['sha2'])
                    sha2s.append((attachment['sha2'], att_object.payload))    
    
    # If attachments have payloads
    if sha2s:
        # Create multipart message and attach json message to it
        full_message = MIMEMultipart(boundary="ADL_LRS---------")
        if isinstance(stmt_result, dict):
            stmt_message = MIMEApplication(json.dumps(stmt_result), _subtype="json", _encoder=json.JSONEncoder)
        else:
            stmt_message = MIMEApplication(stmt_result, _subtype="json", _encoder=json.JSONEncoder)
        full_message.attach(stmt_message)
        # For each sha create a binary message, and attach to the multipart message
        for sha2 in sha2s:
            binary_message = MIMEBase('application', 'octet-stream')
            binary_message.add_header('X-Experience-API-Hash', sha2[0])
            binary_message.add_header('Content-Transfer-Encoding', 'binary')

            chunks = []
            for chunk in sha2[1].chunks():
                chunks.append(chunk)
            file_data = "".join(chunks)
            
            binary_message.set_payload(file_data)
            full_message.attach(binary_message)
            # Increment size on content-length and set mime type
            content_length += sha2[1].size
        mime_type = "multipart/mixed"
        return full_message.as_string(), mime_type, content_length 
    # Has attachments but no payloads so just dump the stmt_result
    else:
        if isinstance(stmt_result, dict):
            return json.dumps(stmt_result), mime_type, content_length
        else:
            return stmt_result, mime_type, content_length

def activity_state_post(req_dict):
    # test ETag for concurrency
    actstate = ActivityStateManager(req_dict)
    actstate.post()

    return HttpResponse("", status=204)

def activity_state_put(req_dict):
    # test ETag for concurrency
    actstate = ActivityStateManager(req_dict)
    actstate.put()

    return HttpResponse("", status=204)

def activity_state_get(req_dict):
    # add ETag for concurrency
    actstate = ActivityStateManager(req_dict)
    stateId = req_dict['params'].get('stateId', None) if 'params' in req_dict else None
    if stateId: # state id means we want only 1 item
        resource = actstate.get()
        if resource.state:
            response = HttpResponse(resource.state.read(), content_type=resource.content_type)
        else:
            response = HttpResponse(resource.json_state, content_type=resource.content_type)
        response['ETag'] = '"%s"' %resource.etag
    else: # no state id means we want an array of state ids
        resource = actstate.get_ids()
        response = HttpResponse(json.dumps([k for k in resource]), content_type="application/json")
    return response

def activity_state_delete(req_dict):
    actstate = ActivityStateManager(req_dict)
    # Delete state
    actstate.delete()
    return HttpResponse('', status=204)

def activity_profile_post(req_dict):
    #Instantiate ActivityProfile
    ap = ActivityProfileManager()
    #Put profile and return 204 response
    ap.post_profile(req_dict)
    return HttpResponse('', status=204)

def activity_profile_put(req_dict):
    #Instantiate ActivityProfile
    ap = ActivityProfileManager()
    #Put profile and return 204 response
    ap.put_profile(req_dict)
    return HttpResponse('', status=204)

def activity_profile_get(req_dict):
    # Instantiate ActivityProfile
    ap = ActivityProfileManager()
    # Get profileId and activityId
    profileId = req_dict['params'].get('profileId', None) if 'params' in req_dict else None
    activityId = req_dict['params'].get('activityId', None) if 'params' in req_dict else None
    
    #If the profileId exists, get the profile and return it in the response
    if profileId:
        resource = ap.get_profile(profileId, activityId)
        if resource.profile:
            response = HttpResponse(resource.profile.read(), content_type=resource.content_type)
        else:
            response = HttpResponse(resource.json_profile, content_type=resource.content_type)            
        response['ETag'] = '"%s"' % resource.etag
        return response

    #Return IDs of profiles stored since profileId was not submitted
    since = req_dict['params'].get('since', None) if 'params' in req_dict else None
    resource = ap.get_profile_ids(activityId,since)
    response = HttpResponse(json.dumps([k for k in resource]), content_type="application/json")
    response['since'] = since
    return response

def activity_profile_delete(req_dict):
    #Instantiate activity profile
    ap = ActivityProfileManager()
    # Delete profile and return success
    ap.delete_profile(req_dict)

    return HttpResponse('', status=204)

def activities_get(req_dict):
    activityId = req_dict['params']['activityId']
    act = models.Activity.objects.get(activity_id=activityId, canonical_version=True)    
    return_act = json.dumps(act.object_return())    
    resp = HttpResponse(return_act, mimetype="application/json", status=200)
    resp['Content-Length'] = str(len(return_act))
    return resp

def agent_profile_post(req_dict):
    # test ETag for concurrency
    agent = req_dict['params']['agent']
    a = AgentManager(agent).Agent
    ap = AgentProfileManager(a)
    ap.post_profile(req_dict)

    return HttpResponse("", status=204)

def agent_profile_put(req_dict):
    # test ETag for concurrency
    agent = req_dict['params']['agent']
    a = AgentManager(agent).Agent
    ap = AgentProfileManager(a)
    ap.put_profile(req_dict)

    return HttpResponse("", status=204)

def agent_profile_get(req_dict):
    # add ETag for concurrency
    agent = req_dict['params']['agent']
    a = AgentManager(agent).Agent
    ap = AgentProfileManager(a)

    profileId = req_dict['params'].get('profileId', None) if 'params' in req_dict else None
    if profileId:
        resource = ap.get_profile(profileId)
        if resource.profile:
            response = HttpResponse(resource.profile.read(), content_type=resource.content_type)
        else:
            response = HttpResponse(resource.json_profile, content_type=resource.content_type)            
        response['ETag'] = '"%s"' % resource.etag
        return response

    since = req_dict['params'].get('since', None) if 'params' in req_dict else None
    resource = ap.get_profile_ids(since)
    response = HttpResponse(json.dumps([k for k in resource]), content_type="application/json")
    return response

def agent_profile_delete(req_dict):
    agent = req_dict['params']['agent']
    a = AgentManager(agent).Agent
    profileId = req_dict['params']['profileId']
    ap = AgentProfileManager(a)
    ap.delete_profile(profileId)

    return HttpResponse('', status=204)

def agents_get(req_dict):
    a = models.Agent.objects.get(**req_dict['agent_ifp'])    
    agent_data = json.dumps(a.get_person_json())
    resp = HttpResponse(agent_data, mimetype="application/json")
    resp['Content-Length'] = str(len(agent_data))
    return resp
########NEW FILE########
__FILENAME__ = req_validate
import json
import urllib2
from datetime import datetime
from functools import wraps
from django.utils.timezone import utc
from django.conf import settings
from django.core.cache import get_cache
from lrs import models
from lrs.util import uri, StatementValidator, validate_uuid, convert_to_dict, get_agent_ifp
from lrs.exceptions import ParamConflict, ParamError, Forbidden, NotFound, BadRequest, IDNotFoundError
from Authorization import auth

att_cache = get_cache('attachment_cache')

def check_for_existing_statementId(stmtID):
    return models.Statement.objects.filter(statement_id=stmtID).exists()

def check_for_no_other_params_supplied(query_dict):
    supplied = True
    if len(query_dict) <= 1:
        supplied = False
    return supplied

def check_oauth(func):
    @wraps(func)
    def inner(req_dict, *args, **kwargs):
        auth = req_dict.get('auth', None)
        auth_type = req_dict['auth'].get('type', None) if auth else None
        if auth_type and auth_type == 'oauth':
            validate_oauth_scope(req_dict)    
        return func(req_dict, *args, **kwargs)
    return inner    

def validate_oauth_scope(req_dict):
    method = req_dict['method']
    endpoint = req_dict['auth']['endpoint']
    token = req_dict['auth']['oauth_token']
    scopes = token.scope_to_list()
    err_msg = "Incorrect permissions to %s at %s" % (str(method), str(endpoint))

    validator = {'GET':{"/statements": True if 'all' in scopes or 'all/read' in scopes or 'statements/read' in scopes or 'statements/read/mine' in scopes else False,
                    "/statements/more": True if 'all' in scopes or 'all/read' in scopes or 'statements/read' in scopes or 'statements/read/mine' in scopes else False,
                    "/activities": True if 'all' in scopes or 'all/read' in scopes else False,
                    "/activities/profile": True if 'all' in scopes or 'all/read' in scopes or 'profile' in scopes else False,
                    "/activities/state": True if 'all' in scopes or 'all/read' in scopes or 'state' in scopes else False,
                    "/agents": True if 'all' in scopes or 'all/read' in scopes else False,
                    "/agents/profile": True if 'all' in scopes or 'all/read' in scopes or 'profile' in scopes else False
                },
             'HEAD':{"/statements": True if 'all' in scopes or 'all/read' in scopes or 'statements/read' in scopes or 'statements/read/mine' in scopes else False,
                    "/statements/more": True if 'all' in scopes or 'all/read' in scopes or 'statements/read' in scopes or 'statements/read/mine' in scopes else False,
                    "/activities": True if 'all' in scopes or 'all/read' in scopes else False,
                    "/activities/profile": True if 'all' in scopes or 'all/read' in scopes or 'profile' in scopes else False,
                    "/activities/state": True if 'all' in scopes or 'all/read' in scopes or 'state' in scopes else False,
                    "/agents": True if 'all' in scopes or 'all/read' in scopes else False,
                    "/agents/profile": True if 'all' in scopes or 'all/read' in scopes or 'profile' in scopes else False
                },   
             'PUT':{"/statements": True if 'all' in scopes or 'statements/write' in scopes else False,
                    "/activities": True if 'all' in scopes or 'define' in scopes else False,
                    "/activities/profile": True if 'all' in scopes or 'profile' in scopes else False,
                    "/activities/state": True if 'all' in scopes or 'state' in scopes else False,
                    "/agents": True if 'all' in scopes or 'define' in scopes else False,
                    "/agents/profile": True if 'all' in scopes or 'profile' in scopes else False
                },
             'POST':{"/statements": True if 'all' in scopes or 'statements/write' in scopes else False,
                    "/activities": True if 'all' in scopes or 'define' in scopes else False,
                    "/activities/profile": True if 'all' in scopes or 'profile' in scopes else False,
                    "/activities/state": True if 'all' in scopes or 'state' in scopes else False,
                    "/agents": True if 'all' in scopes or 'define' in scopes else False,
                    "/agents/profile": True if 'all' in scopes or 'profile' in scopes else False
                },
             'DELETE':{"/statements": True if 'all' in scopes or 'statements/write' in scopes else False,
                    "/activities": True if 'all' in scopes or 'define' in scopes else False,
                    "/activities/profile": True if 'all' in scopes or 'profile' in scopes else False,
                    "/activities/state": True if 'all' in scopes or 'state' in scopes else False,
                    "/agents": True if 'all' in scopes or 'define' in scopes else False,
                    "/agents/profile": True if 'all' in scopes or 'profile' in scopes else False
                }
             }

    # Raise forbidden if requesting wrong endpoint or with wrong method than what's in scope
    if not validator[method][endpoint]:
        raise Forbidden(err_msg)

    # Set flag to read only statements owned by user
    if 'statements/read/mine' in scopes:
        req_dict['auth']['statements_mine_only'] = True

    # Set flag for define - allowed to update global representation of activities/agents
    if 'define' in scopes or 'all' in scopes:
        req_dict['auth']['oauth_define'] = True
    else:
        req_dict['auth']['oauth_define'] = False

# Extra agent validation for state and profile
def validate_oauth_state_or_profile_agent(req_dict, endpoint):    
    ag = req_dict['params']['agent']
    token = req_dict['auth']['oauth_token']
    scopes = token.scope_to_list()
    if not 'all' in scopes:
        if not isinstance(ag, dict):
            ag = json.loads(ag)
        try:
            agent = models.Agent.objects.get(**ag)
        except models.Agent.DoesNotExist:
            err_msg = "Agent in %s cannot be found to match user in authorization" % endpoint
            raise NotFound(err_msg)

        if not agent in req_dict['auth']['id'].member.all():
            err_msg = "Authorization doesn't match agent in %s" % endpoint
            raise Forbidden(err_msg)

def validate_void_statement(void_id):
    # Retrieve statement, check if the verb is 'voided' - if not then set the voided flag to true else return error 
    # since you cannot unvoid a statement and should just reissue the statement under a new ID.
    try:
        stmt = models.Statement.objects.get(statement_id=void_id)
    except models.Statement.DoesNotExist:
        err_msg = "Statement with ID %s does not exist" % void_id
        raise IDNotFoundError(err_msg)
        
    if stmt.voided:
        err_msg = "Statement with ID: %s is already voided, cannot unvoid. Please re-issue the statement under a new ID." % void_id
        raise Forbidden(err_msg)

def server_validate_statement_object(stmt_object, auth):
    if stmt_object['objectType'] == 'StatementRef' and not check_for_existing_statementId(stmt_object['id']):
            err_msg = "No statement with ID %s was found" % stmt_object['id']
            raise IDNotFoundError(err_msg)
    elif stmt_object['objectType'] == 'Activity' or 'objectType' not in stmt_object:
        if 'definition' in stmt_object:
            try:
                activity = models.Activity.objects.get(activity_id=stmt_object['id'], canonical_version=True)
            except models.Activity.DoesNotExist:
                pass
            else:
                if auth:
                    if auth['id'].__class__.__name__ == 'Agent':
                        auth_name = auth['id'].name
                    else:
                        auth_name = auth['id'].username
                else:
                    auth_name = None
                if activity.authoritative != '' and activity.authoritative != auth_name:
                    err_msg = "This ActivityID already exists, and you do not have the correct authority to create or update it."
                    raise Forbidden(err_msg)

def validate_stmt_authority(stmt, auth, auth_validated):
    if 'authority' in stmt:
        # If they try using a non-oauth group that already exists-throw error
        if stmt['authority']['objectType'] == 'Group' and not 'oauth_identifier' in stmt['authority']:
            err_msg = "Statements cannot have a non-Oauth group as the authority"
            raise ParamError(err_msg)
        else:
            return True
    else:
        if not auth_validated:
            if auth:
                if auth['id'].__class__.__name__ == 'Agent' and not auth['id'].oauth_identifier:
                    err_msg = "Statements cannot have a non-Oauth group as the authority"
                    raise ParamError(err_msg)
                else:
                    return True
            else:
                return True

# Retrieve JSON data from ID
def get_act_def_data(act_data):
    resolves = True
    act_url = {}
    # See if id resolves
    try:
        req = urllib2.Request(act_data['id'])
        req.add_header('Accept', 'application/json, */*')
        act_resp = urllib2.urlopen(req, timeout=settings.ACTIVITY_ID_RESOLVE_TIMEOUT)
    except Exception, e:
        # Doesn't resolve-hopefully data is in payload
        resolves = False
    else:
        # If it resolves then try parsing JSON from it
        try:
            act_url = json.loads(act_resp.read())
        except Exception, e:
            # Resolves but no data to retrieve - this is OK
            pass

        # If there was data from the URL and a defintion in received JSON already
        if act_url and 'definition' in act_data:
            act_data['definition'] = dict(act_url.items() + act_data['definition'].items())
        # If there was data from the URL and no definition in the JSON
        elif act_url and not 'definition' in act_data:
            act_data['definition'] = act_url

def server_validation(stmt_set, auth, payload_sha2s):
    auth_validated = False    
    if type(stmt_set) is list:
        for stmt in stmt_set:
            server_validation(stmt, auth, payload_sha2s)
    else:
        if 'id' in stmt_set:
            statement_id = stmt_set['id']
            if check_for_existing_statementId(statement_id):
                err_msg = "A statement with ID %s already exists" % statement_id
                raise ParamConflict(err_msg)

        server_validate_statement_object(stmt_set['object'], auth)

        if stmt_set['verb']['id'] == 'http://adlnet.gov/expapi/verbs/voided':
            validate_void_statement(stmt_set['object']['id'])

        if not 'objectType' in stmt_set['object'] or stmt_set['object']['objectType'] == 'Activity':
            get_act_def_data(stmt_set['object'])
            
            try:
                validator = StatementValidator.StatementValidator(None)
                validator.validate_activity(stmt_set['object'])
            except Exception, e:
                raise BadRequest(e.message)
            except ParamError, e:
                raise ParamError(e.message)

        auth_validated = validate_stmt_authority(stmt_set, auth, auth_validated)

        if 'attachments' in stmt_set:
            attachment_data = stmt_set['attachments']
            validate_attachments(attachment_data, payload_sha2s)

@auth
@check_oauth
def statements_post(req_dict):
    if req_dict['params'].keys():
        raise ParamError("The post statements request contained unexpected parameters: %s" % ", ".join(req_dict['params'].keys()))

    payload_sha2s = req_dict.get('payload_sha2s', None)

    if isinstance(req_dict['body'], basestring):
        req_dict['body'] = convert_to_dict(req_dict['body'])

    try:
        validator = StatementValidator.StatementValidator(req_dict['body'])
        msg = validator.validate()
    except Exception, e:
        raise BadRequest(e.message)
    except ParamError, e:
        raise ParamError(e.message)

    server_validation(req_dict['body'], req_dict.get('auth', None), req_dict.get('payload_sha2s', None))

    return req_dict

@auth
@check_oauth
def statements_more_get(req_dict):
    if not 'more_id' in req_dict:
        err_msg = "Missing more_id while trying to hit /more endpoint"
        raise ParamError(err_msg)
    return req_dict

def validate_statementId(req_dict):
    if 'statementId' in req_dict['params'] and 'voidedStatementId' in req_dict['params']:
        err_msg = "Cannot have both statementId and voidedStatementId in a GET request"
        raise ParamError(err_msg)
    elif 'statementId' in req_dict['params']:
        statementId = req_dict['params']['statementId']
        voided = False
    else:
        statementId = req_dict['params']['voidedStatementId']
        voided = True

    not_allowed = ["agent", "verb", "activity", "registration", 
                   "related_activities", "related_agents", "since",
                   "until", "limit", "ascending"]
    bad_keys = set(not_allowed) & set(req_dict['params'].keys())
    if bad_keys:
        err_msg = "Cannot have %s in a GET request only 'format' and/or 'attachments' are allowed with 'statementId' and 'voidedStatementId'" % ', '.join(bad_keys)
        raise ParamError(err_msg)

    # Try to retrieve stmt, if DNE then return empty else return stmt info                
    try:
        st = models.Statement.objects.get(statement_id=statementId)
    except models.Statement.DoesNotExist:
        err_msg = 'There is no statement associated with the id: %s' % statementId
        raise IDNotFoundError(err_msg)

    auth = req_dict.get('auth', None)
    mine_only = auth and 'statements_mine_only' in auth

    if auth:
        if mine_only and st.authority.id != auth['id'].id:
            err_msg = "Incorrect permissions to view statements that do not have auth %s" % str(auth['id'])
            raise Forbidden(err_msg)
    
    if st.voided != voided:
        if st.voided:
            err_msg = 'The requested statement (%s) is voided. Use the "voidedStatementId" parameter to retrieve your statement.' % statementId
        else:
            err_msg = 'The requested statement (%s) is not voided. Use the "statementId" parameter to retrieve your statement.' % statementId
        raise IDNotFoundError(err_msg)

    return statementId

@auth
@check_oauth
def statements_get(req_dict):
    rogueparams = set(req_dict['params']) - set(["statementId","voidedStatementId","agent", "verb", "activity", "registration", 
                       "related_activities", "related_agents", "since",
                       "until", "limit", "format", "attachments", "ascending"])
    if rogueparams:
        raise ParamError("The get statements request contained unexpected parameters: %s" % ", ".join(rogueparams))

    formats = ['exact', 'canonical', 'ids']
    if 'params' in req_dict and 'format' in req_dict['params']:
        if req_dict['params']['format'] not in formats:
            raise ParamError("The format filter value (%s) was not one of the known values: %s" % (req_dict['params']['format'], ','.join(formats)))
    else:
        req_dict['params']['format'] = 'exact'     
    
    # StatementId could be for voided statement as well
    if 'params' in req_dict and ('statementId' in req_dict['params'] or 'voidedStatementId' in req_dict['params']):
        req_dict['statementId'] = validate_statementId(req_dict)

    # Django converts all query values to string - make boolean depending on if client wants attachments or not
    # Only need to do this in GET b/c GET/more will have it saved in pickle information
    if 'params' in req_dict and 'attachments' in req_dict['params']:
        if req_dict['params']['attachments'] == 'True':
            req_dict['params']['attachments'] = True
        else:
            req_dict['params']['attachments'] = False
    else:
        req_dict['params']['attachments'] = False
   
    return req_dict

@auth
@check_oauth
def statements_put(req_dict):
    # Find any unexpected parameters
    rogueparams = set(req_dict['params']) - set(["statementId"])
    if rogueparams:
        raise ParamError("The put statements request contained unexpected parameters: %s" % ", ".join(rogueparams))

    # Statement id can must be supplied in query param. If in the body too, it must be the same
    if not 'statementId' in req_dict['params']:
        raise ParamError("Error -- statements - method = %s, but no statementId parameter or ID given in statement" % req_dict['method'])
    else:
        statement_id = req_dict['params']['statementId']

    # Convert data so it can be parsed
    if isinstance(req_dict['body'], basestring):
        req_dict['body'] = convert_to_dict(req_dict['body'])

    # Try to get id if in body
    try:
        statement_body_id = req_dict['body']['id']
    except Exception, e:
        statement_body_id = None

    # If ids exist in both places, check if they are equal
    if statement_body_id and statement_id != statement_body_id:
        raise ParamError("Error -- statements - method = %s, param and body ID both given, but do not match" % req_dict['method'])

    # If statement with that ID already exists-raise conflict error
    if check_for_existing_statementId(statement_id):
        raise ParamConflict("A statement with ID %s already exists" % statement_id)
    
    # Set id inside of statement with param id
    if not statement_body_id:
        req_dict['body']['id'] = statement_id

    # If there are no other params-raise param error since nothing else is supplied
    if not check_for_no_other_params_supplied(req_dict['body']):
        raise ParamError("No other params are supplied with statementId.")

    # Validate statement in body
    try:
        validator = StatementValidator.StatementValidator(req_dict['body'])
        msg = validator.validate()
    except Exception, e:
        raise BadRequest(e.message)
    except ParamError, e:
        raise ParamError(e.message)
    server_validation(req_dict['body'], req_dict.get('auth', None), req_dict.get('payload_sha2s', None))
    return req_dict

def validate_attachments(attachment_data, payload_sha2s):
    # For each attachment that is in the actual statement
    for attachment in attachment_data:
        # If the attachment data has a sha2 field, must validate it against the payload data
        if 'sha2' in attachment:
            sha2 = attachment['sha2']
            # Check if the sha2 field is a key in the payload dict
            if not sha2 in payload_sha2s:
                err_msg = "Could not find attachment payload with sha: %s" % sha2
                raise ParamError(err_msg)

@auth
@check_oauth
def activity_state_post(req_dict):
    rogueparams = set(req_dict['params']) - set(["activityId", "agent", "stateId", "registration"])
    if rogueparams:
        raise ParamError("The post activity state request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try:
        req_dict['params']['activityId']
    except KeyError:
        err_msg = "Error -- activity_state - method = %s, but activityId parameter is missing.." % req_dict['method']
        raise ParamError(err_msg)
    if not 'activity_state_agent_validated' in req_dict:
        try:
            req_dict['params']['agent']
        except KeyError:
            err_msg = "Error -- activity_state - method = %s, but agent parameter is missing.." % req_dict['method']
            raise ParamError(err_msg)
    try:
        req_dict['params']['stateId']
    except KeyError:
        err_msg = "Error -- activity_state - method = %s, but stateId parameter is missing.." % req_dict['method']
        raise ParamError(err_msg)

    if 'params' in req_dict and 'registration' in req_dict['params']:
        if not validate_uuid(req_dict['params']['registration']):
            raise ParamError("%s is not a valid uuid for the registration parameter")

    if 'headers' not in req_dict or ('CONTENT_TYPE' not in req_dict['headers'] or req_dict['headers']['CONTENT_TYPE'] != "application/json"):
        err_msg = "The content type for activity state POSTs must be application/json"
        raise ParamError(err_msg)
    
    # Must have body included for state
    if 'body' not in req_dict:
        err_msg = "Could not find the state"
        raise ParamError(err_msg)
    
    # Extra validation if oauth
    if req_dict['auth']['type'] == 'oauth':
        validate_oauth_state_or_profile_agent(req_dict, "state")

    # Set state
    req_dict['state'] = req_dict.pop('raw_body', req_dict.pop('body', None))
    return req_dict

@auth
@check_oauth
def activity_state_put(req_dict):
    rogueparams = set(req_dict['params']) - set(["activityId", "agent", "stateId", "registration"])
    if rogueparams:
        raise ParamError("The put activity state request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try:
        req_dict['params']['activityId']
    except KeyError:
        err_msg = "Error -- activity_state - method = %s, but activityId parameter is missing.." % req_dict['method']
        raise ParamError(err_msg)
    if not 'activity_state_agent_validated' in req_dict:
        try:
            req_dict['params']['agent']
        except KeyError:
            err_msg = "Error -- activity_state - method = %s, but agent parameter is missing.." % req_dict['method']
            raise ParamError(err_msg)
    try:
        req_dict['params']['stateId']
    except KeyError:
        err_msg = "Error -- activity_state - method = %s, but stateId parameter is missing.." % req_dict['method']
        raise ParamError(err_msg)

    if 'params' in req_dict and 'registration' in req_dict['params']:
        if not validate_uuid(req_dict['params']['registration']):
            raise ParamError("%s is not a valid uuid for the registration parameter")
    
    # Must have body included for state
    if 'body' not in req_dict:
        err_msg = "Could not find the state"
        raise ParamError(err_msg)
    
    # Extra validation if oauth
    if req_dict['auth']['type'] == 'oauth':
        validate_oauth_state_or_profile_agent(req_dict, "state")

    # Set state
    req_dict['state'] = req_dict.pop('raw_body', req_dict.pop('body', None))
    return req_dict

@auth
@check_oauth
def activity_state_get(req_dict):
    rogueparams = set(req_dict['params']) - set(["activityId", "agent", "stateId", "registration", "since"])
    if rogueparams:
        raise ParamError("The get activity state request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try:
        req_dict['params']['activityId']
    except KeyError:
        err_msg = "Error -- activity_state - method = %s, but activityId parameter is missing.." % req_dict['method']
        raise ParamError(err_msg)
    if not 'activity_state_agent_validated' in req_dict:
        try:
            req_dict['params']['agent']
        except KeyError:
            err_msg = "Error -- activity_state - method = %s, but agent parameter is missing.." % req_dict['method']
            raise ParamError(err_msg)

    if 'params' in req_dict and 'registration' in req_dict['params']:
        if not validate_uuid(req_dict['params']['registration']):
            raise ParamError("%s is not a valid uuid for the registration parameter")

    # Extra validation if oauth
    if req_dict['auth']['type'] == 'oauth':
        validate_oauth_state_or_profile_agent(req_dict, "state")    
    return req_dict

@auth
@check_oauth
def activity_state_delete(req_dict):
    rogueparams = set(req_dict['params']) - set(["activityId", "agent", "stateId", "registration"])
    if rogueparams:
        raise ParamError("The delete activity state request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try:
        req_dict['params']['activityId']
    except KeyError:
        err_msg = "Error -- activity_state - method = %s, but activityId parameter is missing.." % req_dict['method']
        raise ParamError(err_msg)
    if not 'activity_state_agent_validated' in req_dict:
        try:
            req_dict['params']['agent']
        except KeyError:
            err_msg = "Error -- activity_state - method = %s, but agent parameter is missing.." % req_dict['method']
            raise ParamError(err_msg)

    if 'params' in req_dict and 'registration' in req_dict['params']:
        if not validate_uuid(req_dict['params']['registration']):
            raise ParamError("%s is not a valid uuid for the registration parameter")
    
    # Extra validation if oauth
    if req_dict['auth']['type'] == 'oauth':
        validate_oauth_state_or_profile_agent(req_dict, "state")
    return req_dict

@auth
@check_oauth
def activity_profile_post(req_dict):
    rogueparams = set(req_dict['params']) - set(["activityId", "profileId"])
    if rogueparams:
        raise ParamError("The post activity profile request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try:
        req_dict['params']['activityId']
    except KeyError:
        err_msg = "Error -- activity_profile - method = %s, but activityId parameter missing.." % req_dict['method']
        raise ParamError(err_msg)    
    try:
        req_dict['params']['profileId']
    except KeyError:
        err_msg = "Error -- activity_profile - method = %s, but profileId parameter missing.." % req_dict['method']
        raise ParamError(err_msg)

    if 'headers' not in req_dict or ('CONTENT_TYPE' not in req_dict['headers'] or req_dict['headers']['CONTENT_TYPE'] != "application/json"):
        err_msg = "The content type for activity profile POSTs must be application/json"
        raise ParamError(err_msg)
    
    if 'body' not in req_dict:
        err_msg = "Could not find the profile document"
        raise ParamError(err_msg)

    req_dict['profile'] = req_dict.pop('raw_body', req_dict.pop('body', None))
    return req_dict

@auth
@check_oauth
def activity_profile_put(req_dict):
    rogueparams = set(req_dict['params']) - set(["activityId", "profileId"])
    if rogueparams:
        raise ParamError("The put activity profile request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try:
        req_dict['params']['activityId']
    except KeyError:
        err_msg = "Error -- activity_profile - method = %s, but activityId parameter missing.." % req_dict['method']
        raise ParamError(err_msg)    
    try:
        req_dict['params']['profileId']
    except KeyError:
        err_msg = "Error -- activity_profile - method = %s, but profileId parameter missing.." % req_dict['method']
        raise ParamError(err_msg)
    
    if 'body' not in req_dict:
        err_msg = "Could not find the profile document"
        raise ParamError(err_msg)

    # Set profile - req_parse converts all request bodies to dict, act profile needs it as string and need to replace single quotes with double quotes
    # b/c of quotation issue when using javascript with activity profile
    req_dict['profile'] = req_dict.pop('raw_body', req_dict.pop('body', None))
    return req_dict

@auth
@check_oauth
def activity_profile_get(req_dict):
    rogueparams = set(req_dict['params']) - set(["activityId", "profileId", "since"])
    if rogueparams:
        raise ParamError("The get activity profile request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try:
        req_dict['params']['activityId']
    except KeyError:
        err_msg = "Error -- activity_profile - method = %s, but no activityId parameter.. the activityId parameter is required" % req_dict['method']
        raise ParamError(err_msg)
    return req_dict

@auth
@check_oauth
def activity_profile_delete(req_dict):
    rogueparams = set(req_dict['params']) - set(["activityId", "profileId"])
    if rogueparams:
        raise ParamError("The delete activity profile request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try:
        req_dict['params']['activityId']
    except KeyError:
        err_msg = "Error -- activity_profile - method = %s, but no activityId parameter.. the activityId parameter is required" % req_dict['method']
        raise ParamError(err_msg)
    try:
        req_dict['params']['profileId']
    except KeyError:
        err_msg = "Error -- activity_profile - method = %s, but no profileId parameter.. the profileId parameter is required" % req_dict['method']
        raise ParamError(err_msg)
    return req_dict

@auth
@check_oauth
def activities_get(req_dict):
    rogueparams = set(req_dict['params']) - set(["activityId"])
    if rogueparams:
        raise ParamError("The get activities request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try:
        activityId = req_dict['params']['activityId']
    except KeyError:
        err_msg = "Error -- activities - method = %s, but activityId parameter is missing" % req_dict['method']
        raise ParamError(err_msg)

    # Try to retrieve activity, if DNE then return empty else return activity info
    try:
        act = models.Activity.objects.get(activity_id=activityId)
    except models.Activity.DoesNotExist:    
        err_msg = "No activity found with ID %s" % activityId
        raise IDNotFoundError(err_msg)

    return req_dict

@auth
@check_oauth
def agent_profile_post(req_dict):
    rogueparams = set(req_dict['params']) - set(["agent", "profileId"])
    if rogueparams:
        raise ParamError("The post agent profile request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try: 
        req_dict['params']['agent']
    except KeyError:
        err_msg = "Error -- agent_profile - method = %s, but agent parameter missing.." % req_dict['method']
        raise ParamError(err_msg)
    try:
        req_dict['params']['profileId']
    except KeyError:
        err_msg = "Error -- agent_profile - method = %s, but profileId parameter missing.." % req_dict['method']
        raise ParamError(msg)

    if 'headers' not in req_dict or ('CONTENT_TYPE' not in req_dict['headers'] or req_dict['headers']['CONTENT_TYPE'] != "application/json"):
        err_msg = "The content type for agent profile POSTs must be application/json"
        raise ParamError(err_msg)
    
    if 'body' not in req_dict:
        err_msg = "Could not find the profile document"
        raise ParamError(err_msg)

    # Extra validation if oauth
    if req_dict['auth']['type'] == 'oauth':
        validate_oauth_state_or_profile_agent(req_dict, "profile")
    
    # Set profile
    req_dict['profile'] = req_dict.pop('raw_body', req_dict.pop('body', None))

    return req_dict

@auth
@check_oauth
def agent_profile_put(req_dict):
    rogueparams = set(req_dict['params']) - set(["agent", "profileId"])
    if rogueparams:
        raise ParamError("The put agent profile request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try: 
        req_dict['params']['agent']
    except KeyError:
        err_msg = "Error -- agent_profile - method = %s, but agent parameter missing.." % req_dict['method']
        raise ParamError(err_msg)
    try:
        req_dict['params']['profileId']
    except KeyError:
        err_msg = "Error -- agent_profile - method = %s, but profileId parameter missing.." % req_dict['method']
        raise ParamError(err_msg)
    
    if 'body' not in req_dict:
        err_msg = "Could not find the profile document"
        raise ParamError(err_msg)

    # Extra validation if oauth
    if req_dict['auth']['type'] == 'oauth':
        validate_oauth_state_or_profile_agent(req_dict, "profile")
    req_dict['profile'] = req_dict.pop('raw_body', req_dict.pop('body', None))
    return req_dict

@auth
@check_oauth
def agent_profile_get(req_dict):
    rogueparams = set(req_dict['params']) - set(["agent", "profileId", "since"])
    if rogueparams:
        raise ParamError("The get agent profile request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try: 
        req_dict['params']['agent']
    except KeyError:
        err_msg = "Error -- agent_profile - method = %s, but agent parameter missing.. the agent parameter is required" % req_dict['method']
        raise ParamError(err_msg)

    # Extra validation if oauth
    if req_dict['auth']['type'] == 'oauth':
        validate_oauth_state_or_profile_agent(req_dict, "profile")
    return req_dict

@auth
@check_oauth
def agent_profile_delete(req_dict):
    rogueparams = set(req_dict['params']) - set(["agent", "profileId"])
    if rogueparams:
        raise ParamError("The delete agent profile request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try: 
        req_dict['params']['agent']
    except KeyError:
        err_msg = "Error -- agent_profile - method = %s, but no agent parameter.. the agent parameter is required" % req_dict['method']
        raise ParamError(err_msg)
    try:
        req_dict['params']['profileId']
    except KeyError:
        err_msg = "Error -- agent_profile - method = %s, but no profileId parameter.. the profileId parameter is required" % req_dict['method']
        raise ParamError(err_msg)
    
    # Extra validation if oauth
    if req_dict['auth']['type'] == 'oauth':
        validate_oauth_state_or_profile_agent(req_dict, "profile")
    return req_dict

@auth
@check_oauth
def agents_get(req_dict):
    rogueparams = set(req_dict['params']) - set(["agent"])
    if rogueparams:
        raise ParamError("The get agent request contained unexpected parameters: %s" % ", ".join(rogueparams))

    try: 
        req_dict['params']['agent']
    except KeyError:
        err_msg = "Error -- agents url, but no agent parameter.. the agent parameter is required"
        raise ParamError(err_msg)

    agent = json.loads(req_dict['params']['agent'])
    params = get_agent_ifp(agent)

    if not models.Agent.objects.filter(**params).exists():
        raise IDNotFoundError("Error with Agent. The agent partial did not match any agents on record")

    req_dict['agent_ifp'] = params
    return req_dict

########NEW FILE########
__FILENAME__ = retrieve_statement
import bencode
import hashlib
import json
from datetime import datetime
from django.core.cache import cache
from django.conf import settings
from django.core.paginator import Paginator
from django.db.models import Q
from itertools import chain
from lrs.models import Statement, IDNotFoundError
from lrs.objects.AgentManager import AgentManager
from lrs.util import convert_to_utc, convert_to_dict
from lrs.exceptions import NotFound

MORE_ENDPOINT = '/xapi/statements/more/'

def complex_get(param_dict, limit, language, format, attachments):
    # Tests if value is True or "true"
    vq = Q(voided=False)
    # keep track if a filter other than time or sequence is used
    reffilter = False

    sinceq = Q()
    if 'since' in param_dict:
        sinceq = Q(stored__gt=convert_to_utc(param_dict['since']))

    untilq = Q()
    if 'until' in param_dict:
        untilq = Q(stored__lte=convert_to_utc(param_dict['until']))

    # For statements/read/mine oauth scope
    authq = Q()
    if 'auth' in param_dict and (param_dict['auth'] and 'statements_mine_only' in param_dict['auth']):
        authq = Q(authority=param_dict['auth']['id'])

    agentQ = Q()
    if 'agent' in param_dict:
        reffilter = True
        agent = None
        data = param_dict['agent']
        related = 'related_agents' in param_dict and param_dict['related_agents']
        
        if not type(data) is dict:
            data = convert_to_dict(data)
        
        try:
            agent = AgentManager(data).Agent
            if agent.objectType == "Group":
                groups = []
            else:
                groups = agent.member.all()
            agentQ = Q(actor=agent)
            for g in groups:
                agentQ = agentQ | Q(actor=g)
            if related:
                me = chain([agent], groups)
                for a in me:
                    agentQ = agentQ | Q(object_agent=a) | Q(authority=a) \
                          | Q(context_instructor=a) | Q(context_team=a) \
                          | Q(object_substatement__actor=a) \
                          | Q(object_substatement__object_agent=a) \
                          | Q(object_substatement__context_instructor=a) \
                          | Q(object_substatement__context_team=a)       
        except IDNotFoundError:
            return[]     
    
    verbQ = Q()
    if 'verb' in param_dict:
        reffilter = True
        verbQ = Q(verb__verb_id=param_dict['verb'])
        
    # activity
    activityQ = Q()
    if 'activity' in param_dict:
        reffilter = True
        activityQ = Q(object_activity__activity_id=param_dict['activity'])
        if 'related_activities' in param_dict and param_dict['related_activities']:
            activityQ = activityQ | Q(statementcontextactivity__context_activity__activity_id=param_dict['activity']) \
                    | Q(object_substatement__object_activity__activity_id=param_dict['activity']) \
                    | Q(object_substatement__substatementcontextactivity__context_activity__activity_id=param_dict['activity'])

    registrationQ = Q()
    if 'registration' in param_dict:
        reffilter = True
        registrationQ = Q(context_registration=param_dict['registration'])

    # If want ordered by ascending
    stored_param = '-stored'
    if 'ascending' in param_dict and param_dict['ascending']:
            stored_param = 'stored'

    stmtset = Statement.objects.filter(vq & untilq & sinceq & authq & agentQ & verbQ & activityQ & registrationQ)
    
    # only find references when a filter other than
    # since, until, or limit was used 
    if reffilter:
        stmtset = findstmtrefs(stmtset.distinct(), sinceq, untilq)
    
    # Calculate limit of stmts to return
    return_limit = set_limit(limit)
    
    # If there are more stmts than the limit, need to break it up and return more id
    if stmtset.count() > return_limit:
        return initial_cache_return(stmtset, stored_param, return_limit, language, format, attachments)
    else:
        return create_stmt_result(stmtset, stored_param, language, format)

def create_stmt_result(stmt_set, stored, language, format):
    stmt_result = {}
    # blows up if the idlist is empty... so i gotta check for that
    idlist = stmt_set.values_list('id', flat=True)
    if idlist > 0:
        if format == 'exact':
            stmt_result = '{"statements": [%s], "more": ""}' % ",".join([stmt.full_statement for stmt in \
                Statement.objects.filter(id__in=idlist).order_by(stored)])
        else:
            stmt_result['statements'] = [stmt.object_return(language, format) for stmt in \
                Statement.objects.filter(id__in=idlist).order_by(stored)]
            stmt_result['more'] = ""
    else:
        stmt_result['statements'] = []
        stmt_result['more'] = ""
    return stmt_result

def findstmtrefs(stmtset, sinceq, untilq):
    if stmtset.count() == 0:
        return stmtset
    q = Q()
    for s in stmtset:
        q = q | Q(object_statementref__ref_id=s.statement_id)

    if sinceq and untilq:
        q = q & Q(sinceq, untilq)
    elif sinceq:
        q = q & sinceq
    elif untilq:
        q = q & untilq
    # finally weed out voided statements in this lookup
    q = q & Q(voided=False)
    return findstmtrefs(Statement.objects.filter(q).distinct(), sinceq, untilq) | stmtset

def create_cache_key(stmt_list):
    # Create unique hash data to use for the cache key
    hash_data = []
    hash_data.append(str(datetime.now()))
    hash_data.append(str(stmt_list))

    # Create cache key from hashed data (always 32 digits)
    key = hashlib.md5(bencode.bencode(hash_data)).hexdigest()
    return key

def initial_cache_return(stmt_list, stored, limit, language, format, attachments):
    # First time someone queries POST/GET
    result = {}
    cache_list = []
    
    cache_list.append([s for s in stmt_list.order_by(stored).values_list('id', flat=True)])
    stmt_pager = Paginator(cache_list[0], limit)
 
    # Always start on first page
    current_page = 1
    total_pages = stmt_pager.num_pages

    # Create cache key from hashed data (always 32 digits)
    cache_key = create_cache_key(cache_list[0])

    # Add data to cache
    cache_list.append(current_page)
    cache_list.append(total_pages)
    cache_list.append(limit)
    cache_list.append(attachments)
    cache_list.append(language)
    cache_list.append(format)
    cache_list.append(stored)
    
    # Encode data
    encoded_info = json.dumps(cache_list)

    # Save encoded_dict in cache
    cache.set(cache_key,encoded_info)

    # Return first page of results
    if format == 'exact':
        result = '{"statements": [%s], "more": "%s"}' % (",".join([stmt.full_statement for stmt in \
                Statement.objects.filter(id__in=stmt_pager.page(1).object_list).order_by(stored)]), MORE_ENDPOINT + cache_key)
    else:
        result['statements'] = [stmt.object_return(language, format) for stmt in \
                        Statement.objects.filter(id__in=stmt_pager.page(1).object_list).order_by(stored)]
        result['more'] = MORE_ENDPOINT + cache_key    
            
    return result

def set_limit(req_limit):
    if not req_limit or req_limit > settings.SERVER_STMT_LIMIT:
        req_limit = settings.SERVER_STMT_LIMIT
    return req_limit

def get_more_statement_request(req_id):  
    # Retrieve encoded info for statements
    encoded_info = cache.get(req_id)

    # Could have expired or never existed
    if not encoded_info:
        raise NotFound("List does not exist - may have expired after 24 hours")

    # Decode info
    decoded_info = json.loads(encoded_info)

    # Info is always cached as [stmt_list, start_page, total_pages, limit, attachments, language, format]
    stmt_list = decoded_info[0]
    start_page = decoded_info[1]
    total_pages = decoded_info[2]
    limit = decoded_info[3]
    attachments = decoded_info[4]
    language = decoded_info[5]
    format = decoded_info[6]
    stored = decoded_info[7]

    # Build statementResult
    stmt_result = build_statement_result(stmt_list, start_page, total_pages, limit, attachments, language, format, stored, req_id)
    return stmt_result, attachments

# Gets called from req_process after complex_get with list of django objects and also gets called from get_more_statement_request when
# more_id is used so list will be serialized
def build_statement_result(stmt_list, start_page, total_pages, limit, attachments, language, format, stored, more_id):
    result = {}
    current_page = start_page + 1
    # If that was the last page to display then just return the remaining stmts
    if current_page == total_pages:
        stmt_pager = Paginator(stmt_list, limit)       
        # Return first page of results
        if format == 'exact':
            result = '{"statements": [%s], "more": ""}' % ",".join([stmt.object_return(language, format) for stmt in \
                Statement.objects.filter(id__in=stmt_pager.page(current_page).object_list).order_by(stored)])
        else:
            result['statements'] = [stmt.object_return(language, format) for stmt in \
                    Statement.objects.filter(id__in=stmt_pager.page(current_page).object_list).order_by(stored)]
            result['more'] = ""
        # Set current page back for when someone hits the URL again
        current_page -= 1
        # Retrieve list stored in cache
        encoded_list = cache.get(more_id)
        # Decode info to set the current page back then encode again
        decoded_list = json.loads(encoded_list)
        decoded_list[1] = current_page
        encoded_list = json.dumps(decoded_list)
        cache.set(more_id, encoded_list)
    # There are more pages to display
    else:
        stmt_pager = Paginator(stmt_list, limit)
        # Create cache key from hashed data (always 32 digits)
        cache_key = create_cache_key(stmt_list)
        # Return first page of results
        if format == 'exact':
            result = '{"statements": [%s], "more": "%s"}' % (",".join([stmt.object_return(language, format) for stmt in \
                Statement.objects.filter(id__in=stmt_pager.page(current_page).object_list).order_by(stored)]), MORE_ENDPOINT + cache_key)
        else:
            # Set result to have selected page of stmts and more endpoint
            result['statements'] = [stmt.object_return(language, format) for stmt in \
                    Statement.objects.filter(id__in=stmt_pager.page(current_page).object_list).order_by(stored)]
            result['more'] = MORE_ENDPOINT + cache_key
        more_cache_list = []
        # Increment next page
        start_page = current_page
        more_cache_list.append(stmt_list)
        more_cache_list.append(start_page)
        more_cache_list.append(total_pages)
        more_cache_list.append(limit)
        more_cache_list.append(attachments)
        more_cache_list.append(language)
        more_cache_list.append(format)
        more_cache_list.append(stored)
        # Encode info
        encoded_list = json.dumps(more_cache_list)
        cache.set(cache_key, encoded_list)
    return result
########NEW FILE########
__FILENAME__ = StatementValidator
import sys
import argparse
import re
from dateutil import parser as timeparser
from isodate.isoduration import parse_duration
from isodate.isoerror import ISO8601Error
import ast
import json
from lrs.exceptions import ParamError

SCHEME = 2
EMAIL = 5
uri_re = re.compile('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?')

statement_allowed_fields = ['id', 'actor', 'verb', 'object', 'result', 'context', 'timestamp', 'authority', 'version', 'attachments']
statement_required_fields = ['actor', 'verb', 'object']

attachment_allowed_fields = ['usageType', 'display', 'description', 'contentType', 'length', 'sha2', 'fileUrl']
attachment_required_fields = ['usageType', 'display', 'contentType', 'length']

agent_ifis_can_only_be_one = ['mbox', 'mbox_sha1sum', 'openID', 'account', 'openid']
agent_allowed_fields = ['objectType', 'name', 'member', 'mbox', 'mbox_sha1sum', 'openID', 'openid','account']

account_fields = ['homePage', 'name']

verb_allowed_fields = ['id', 'display']

ref_fields = ['id', 'objectType']

activity_allowed_fields = ['objectType', 'id', 'definition']

act_def_allowed_fields = ['name', 'description', 'type', 'moreInfo', 'extensions', 'interactionType', 'correctResponsesPattern', 'choices', 'scale', 'source', 'target', 'steps']

int_act_fields = ['id', 'description']

sub_allowed_fields = ['actor', 'verb', 'object', 'result', 'context', 'timestamp', "objectType"]
sub_required_fields = ['actor', 'verb', 'object']

result_allowed_fields = ['score', 'success', 'completion', 'response', 'duration', 'extensions']

score_allowed_fields = ['scaled', 'raw', 'min', 'max']

context_allowed_fields = ['registration', 'instructor', 'team', 'contextActivities', 'revision', 'platform', 'language', 'statement', 'extensions']

class StatementValidator():
	def __init__(self, data):
		# If incoming is a string, ast eval it (exception will be caught with whatever is calling validator)
		if isinstance(data, basestring):
			try:
				self.stmt = ast.literal_eval(data)
			except Exception, e:
				self.stmt = json.loads(data)
		# If incoming data is already a list 
		elif isinstance(data, list):
			# If each item in list is not a dict, then try to load them as one
			if not all(isinstance(item, dict) for item in data):
				self.stmt = [json.loads(st) for st in data]
			# Else it is a list of all dicts
			else:
				self.stmt = data
		# If incoming data is not a string or list, try loading into dict
		else:
			self.stmt = data
	
	def validate(self):
		# If list, validate each stmt inside
		if isinstance(self.stmt, list):
			for st in self.stmt:
				self.validate_statement(st)
			return "All Statements are valid"
		else:
			self.validate_statement(self.stmt)
			return "Statement is valid"

	def return_error(self, err_msg):
		raise ParamError(err_msg)

	def validate_email(self, email):
		res = uri_re.match(email)
		if res.group(SCHEME) != "mailto" or res.group(EMAIL) == None or res.group(0) != email:
			self.return_error("mbox value [%s] did not start with mailto:" % email)

	def validate_uri(self, uri_value, field):
		 if not uri_re.match(uri_value).group(SCHEME):
		 	self.return_error("%s with value %s was not a valid URI" % (field, uri_value))
		
	def validate_uuid(self, uuid, field):
		id_regex = re.compile("[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}")
		if not id_regex.match(uuid):
			self.return_error("%s - %s is not a valid UUID" % (field, uuid))

	def check_if_dict(self, obj, field):
		if not isinstance(obj, dict):
			self.return_error("%s is not a properly formatted dictionary" % field)

	def check_if_list(self, obj, field):
		if not isinstance(obj, list):
			self.return_error("%s is not a properly formatted array" % field)

	def check_allowed_fields(self, allowed, obj, obj_name):
		# Check for fields that aren't in spec
		failed_list = [x for x in obj.keys() if not x in allowed]
		if failed_list:
			self.return_error("Invalid field(s) found in %s - %s" % (obj_name, ', '.join(failed_list)))

	def check_required_fields(self, required, obj, obj_name):
		for field in required:
			if not field in obj:
				self.return_error("%s is missing in %s" % (field, obj_name))

	def validate_statement(self, stmt):
		# Ensure dict was submitted as stmt and check allowed and required fields
		self.check_if_dict(stmt, "Statement")
		self.check_allowed_fields(statement_allowed_fields, stmt, "Statement")
		self.check_required_fields(statement_required_fields, stmt, "Statement")

		# If version included in stmt (usually in header instead) make sure it is 1.0.0 +
		if 'version' in stmt:
			version_regex = re.compile("^1\.0(\.\d+)?$")
			if not version_regex.match(stmt['version']):
				self.return_error("%s is not a supported version" % stmt['version'])

		# If id included, make sure it is a valid UUID
		if 'id' in stmt:
			self.validate_uuid(stmt['id'], 'Statement id')

		# If timestamp included, make sure a valid date can be parsed from it
		if 'timestamp' in stmt:
			timestamp = stmt['timestamp']
			try:
				timeparser.parse(timestamp)
			except ValueError as e:
				self.return_error("Timestamp error - There was an error while parsing the date from %s -- Error: %s" % (timestamp, e.message))

		# Validate the actor and verb
		self.validate_agent(stmt['actor'], 'actor')
		self.validate_verb(stmt['verb'])

		# Validate the object
		stmt_object = stmt['object']
		self.validate_object(stmt_object)

		# If the object is validated and has no objectType, set to Activity
		if not 'objectType' in stmt_object:
			stmt['object']['objectType'] = 'Activity'

		# If result is included, validate it
		if 'result' in stmt:
			self.validate_result(stmt['result'])

		# If context is included, validate it
		if 'context' in stmt:
			self.validate_context(stmt['context'], stmt_object)

		# If authority is included, validate it
		if 'authority' in stmt:
			self.validate_agent(stmt['authority'], 'authority')

		# If attachments is included, validate it
		if 'attachments' in stmt:
			self.validate_attachments(stmt['attachments'])

	def validate_attachments(self, attachments):
		# Ensure attachments is a list
		self.check_if_list(attachments, "Attachments")

		for attach in attachments:
			# For each attachment, check allowed and required fields
			self.check_allowed_fields(attachment_allowed_fields, attach, "Attachment")
			self.check_required_fields(attachment_required_fields, attach, "Attachment")

			# Validate usageType
			self.validate_uri(attach['usageType'], 'Attachments usageType')

			# If fileUrl included, validate it
			if 'fileUrl' in attach:
				self.validate_uri(attach['fileUrl'], 'Attachments fileUrl')
			else:
				# If fileUrl is not included, sha2 must be - only time sha2 is required
				if not 'sha2' in attach:
					self.return_error("Attachment sha2 is required when no fileUrl is given")

				# Ensure sha2 is submitted as string
				if not isinstance(attach['sha2'], basestring):
					self.return_error("Attachment sha2 must be a string")

			# Ensure length is an int
			if not isinstance(attach['length'], int):
				self.return_error("Attachment length must be an integer")

			# Ensure contentType is submitted as a string
			if not isinstance(attach['contentType'], basestring):
				self.return_error("Attachment contentType must be a string")

			# Ensure display is a dict (language map)
			self.check_if_dict(attach['display'], "Attachment display")
			
			# If description included, ensure it is a dict (language map)
			if 'description' in attach:
				self.check_if_dict(attach['description'], "Attachment description")

	def validate_extensions(self, extensions, field):
		# Ensure incomgin extensions is a dict
		self.check_if_dict(extensions, "%s extensions" % field)
		
		# Ensure each key in extensions is a valid URI
		for k, v in extensions.items():
			self.validate_uri(k, field)

	def validate_agent(self, agent, placement):
		# Ensure incoming agent is a dict and check allowed fields
		self.check_if_dict(agent, "Agent in %s" % placement)
		self.check_allowed_fields(agent_allowed_fields, agent, "Agent/Group")
		# If the agent is the object of a stmt, the objectType must be present
		if placement == 'object' and not 'objectType' in agent:
			self.return_error("objectType must be set when using an Agent as the object of a statement")
		# If the agent is not the object of a stmt and objectType is given, it must be Agent or Group
		elif placement != 'object' and 'objectType' in agent:
			if agent['objectType'] != 'Agent' and agent['objectType'] != 'Group':
				self.return_error("An agent's objectType must be either Agent or Group if given")
		# If the agent is not the object of a stmt and objectType is not given, set it to Agent 
		elif placement != 'object' and not 'objectType' in agent:
			agent['objectType'] = 'Agent'
		# Agent must have only one inverse functionlal identifier (Group may be Anonymous Group where no IFI is
		# required)
		ifis = [a for a in agent_ifis_can_only_be_one if agent.get(a, None) != None]
		if agent['objectType'] == 'Agent' and len(ifis) != 1:
			self.return_error("One and only one of %s may be supplied with an Agent" % ", ".join(agent_ifis_can_only_be_one))

		if agent['objectType'] == 'Agent':
			# If agent, if name given, ensure name is string and validate the IFI
			if 'name' in agent and not isinstance(agent['name'], basestring):
				self.return_error("If name is given in Agent, it must be a string")
			self.validate_ifi(ifis[0], agent[ifis[0]])
		else:
			# If group, if name given, ensure name is string
			if 'name' in agent and not isinstance(agent['name'], basestring):
				self.return_error("If name is given in Group, it must be a string")

			# If no IFIs, it is an anonymous group which must contain the member property 
			if not ifis:
				if not 'member' in agent:
					self.return_error("Anonymous groups must contain member")
			else:
				# IFI given, validate it
				self.validate_ifi(ifis[0], agent[ifis[0]])

			# If member is in group (not required if have IFI)
			if 'member' in agent:
				# Ensure member list is array
				members = agent['member']
				self.check_if_list(members, "Members")				
				# Make sure no member of group is another group
				object_types = [t['objectType'] for t in members if 'objectType' in t]
				if 'Group' in object_types:
					self.return_error('Group member value cannot be other groups')
				# Validate each member in group
				for agent in members:
					self.validate_agent(agent, 'member')

	def validate_ifi(self, ifis, ifi_value):
		# Spec not clear if openid or openID - set to openID just in case
		if ifis == 'openid':
			ifis = 'openID'
		
		# Validate each IFI accordingly
		if ifis == 'mbox':
			self.validate_email(ifi_value)
		elif ifis == 'openID':
			self.validate_uri(ifi_value, 'openID')
		elif ifis == 'account':
			self.validate_account(ifi_value)

	def validate_account(self, account):
		# Ensure incoming account is a dict and check allowed and required fields
		self.check_if_dict(account, "Account")
		self.check_allowed_fields(account_fields, account, "Account")
		self.check_required_fields(account_fields, account, "Account")

		# Ensure homePage is a valid URI
		self.validate_uri(account['homePage'], 'homePage')

		# Ensure name is a string
		if not isinstance(account['name'], basestring):
			self.return_error("account name must be a string")

	def validate_verb(self, verb):
		# Ensure incoming verb is a dict and check allowed fields
		self.check_if_dict(verb, "Verb")
		self.check_allowed_fields(verb_allowed_fields, verb, "Verb")

		# Verb must conatin id - then validate it
		if not 'id' in verb:
			self.return_error('Verb must contain an id')
		self.validate_uri(verb['id'], 'Verb id')

		# If display given, ensure it's a dict (language map)
		if 'display' in verb:
			self.check_if_dict(verb['display'], "Verb display")

	def validate_object(self, stmt_object):
		# Ensure incoming object is a dict
		self.check_if_dict(stmt_object, "Object")

		# If objectType is not given or is Activity it is an Activity
		# Validate the rest accordingly
		if not 'objectType' in stmt_object or stmt_object['objectType'] == 'Activity':
			self.validate_activity(stmt_object)
		elif stmt_object['objectType'] == 'Agent' or stmt_object['objectType'] == 'Group':
			self.validate_agent(stmt_object, 'object')
		elif stmt_object['objectType'] == 'SubStatement':
			self.validate_substatement(stmt_object)
		elif stmt_object['objectType'] == 'StatementRef':
			self.validate_statementref(stmt_object)
		else:
			self.return_error("The objectType in the statement's object is not valid - %s" % stmt_object['objectType'])

	def validate_statementref(self, ref):
		# Ensure incoming StatementRef is a dictionary an check allowed and required fields
		self.check_if_dict(ref, "StatementRef")

		# objectType must be StatementRef
		if ref['objectType'] != "StatementRef":
			self.return_error("StatementRef objectType must be set to 'StatementRef'")

		self.check_allowed_fields(ref_fields, ref, "StatementRef")
		self.check_required_fields(ref_fields, ref, "StatementRef")

		# Ensure id is a valid UUID
		self.validate_uuid(ref['id'], 'StatementRef id')

	def validate_activity(self, activity):
		# Ensure incoming activity is a dict and check allowed fields
		self.check_if_dict(activity, "Activity")
		self.check_allowed_fields(activity_allowed_fields, activity, "Activity")

		# Id must be present
		if not 'id' in activity:
			self.return_error("Id field must be present in an Activity")

		# Id must be valid URI
		self.validate_uri(activity['id'], "Activity id")

		# If definition included, validate it
		if 'definition' in activity:
			self.validate_activity_definition(activity['definition'])

	def validate_activity_definition(self, definition):
		# Ensure incoming def is a dict and check allowed fields
		self.check_if_dict(definition, "Activity definition")
		self.check_allowed_fields(act_def_allowed_fields, definition, "Activity definition")

		# If name or description included, ensure it is a dict (language map)
		if 'name' in definition:
			self.check_if_dict(definition['name'], "Activity definition name")
		if 'description' in definition:
			self.check_if_dict(definition['description'], "Activity definition description")

		# If type or moreInfo included, ensure it is valid URI
		if 'type' in definition:
			self.validate_uri(definition['type'], 'Activity definition type')
		if 'moreInfo' in definition:
			self.validate_uri(definition['moreInfo'], 'Activity definition moreInfo')

		interactionType = None
		# If interactionType included, ensure it is a string
		if 'interactionType' in definition:
			if not isinstance(definition['interactionType'], basestring):
				self.return_error("Activity definition interactionType must be a string")

			scorm_interaction_types = ['true-false', 'choice', 'fill-in','matching', 'performance',
				'sequencing', 'likert', 'numeric', 'other']

			#Check if valid SCORM interactionType
			if definition['interactionType'] not in scorm_interaction_types:
				self.return_error("Activity definition interactionType %s is not valid" % definition['interactionType'])

			interactionType = definition['interactionType']

		# If correctResponsesPatter included, ensure it is an array
		if 'correctResponsesPattern' in definition:
			self.check_if_list(definition['correctResponsesPattern'], "Activity definition correctResponsesPattern")
			for answer in definition['correctResponsesPattern']:
				# For each answer, ensure it is a string
				if not isinstance(answer, basestring):
					self.return_error("Activity definition correctResponsesPattern answer's must all be strings")
		self.validate_interaction_types(interactionType, definition)

		# If extensions, validate it
		if 'extensions' in definition:
			self.validate_extensions(definition['extensions'], 'activity definition')		

	def validate_interaction_types(self, interactionType, definition):
		if interactionType == "choice" or interactionType == "sequencing":
			# If choices included, ensure it is an array and validate it
			if 'choices' in definition:
				choices = definition['choices']
				self.check_if_list(choices, "Activity definition choices")
				self.validate_interaction_activities(choices, 'choices')			
			else:
				self.return_error("Activity definition is missing choices")
		elif interactionType == "likert":
			# If scale included, ensure it is an array and validate it
			if 'scale' in definition:
				scale = definition['scale']
				self.check_if_list(scale, "Activity definition scale")
				self.validate_interaction_activities(scale, 'scale')
			else:
				self.return_error("Activity definition is missing scale")
		elif interactionType == "matching":
			# If scale included, ensure it is an array and validate it
			if 'source' in definition:
				source = definition['source']
				self.check_if_list(source, "Activity definition source")
				self.validate_interaction_activities(source, 'source')
			else:
				self.return_error("Activity definition is missing source")
			# If target included, ensure it is an array and validate it
			if 'target' in definition:
				target = definition['target']
				self.check_if_list(target, "Activity definition target")
				self.validate_interaction_activities(target, 'target')
			else:
				self.return_error("Activity definition is missing target")
		elif interactionType == "performance":
		# If steps included, ensure it is an array and validate it
			if 'steps' in definition:
				steps = definition['steps']
				self.check_if_list(steps, "Activity definition steps")
				self.validate_interaction_activities(steps, 'steps')
			else:
				self.return_error("Activity definition is missing steps")		

	def validate_interaction_activities(self, activities, field):
		for act in activities:
			# Ensure each interaction activity is a dict and check allowed fields
			self.check_if_dict(act, "%s interaction component" % field)
			self.check_allowed_fields(int_act_fields, act, "Activity definition %s" % field)
			self.check_required_fields(int_act_fields, act, "Activity definition %s" % field)

			# Ensure id value is string
			if not isinstance(act['id'], basestring):
				self.return_error("Interaction activity in component %s has an id that is not a string" % field)

			# Ensure description is a dict (language map)
			self.check_if_dict(act['description'], "%s interaction component description" % field)

	def validate_substatement(self, substmt):
		# Ensure incoming substmt is a dict and check allowed and required fields
		self.check_if_dict(substmt, "SubStatement")
		self.check_allowed_fields(sub_allowed_fields, substmt, "SubStatement")
		self.check_required_fields(sub_required_fields, substmt, "SubStatement")

		# If timestamp is included, ensure a valid time can be parsed
		if 'timestamp' in substmt:
			timestamp = substmt['timestamp']
			try:
				timeparser.parse(timestamp)
			except ValueError as e:
				self.return_error("Timestamp error - There was an error while parsing the date from %s -- Error: %s" % (timestamp, e.message))

		# Can't next substmts in other substmts - if not supplied it is an Activity
		if 'objectType' in substmt['object']:
			if substmt['object']['objectType'] == 'SubStatement':
				self.return_error("Cannot nest a SubStatement inside of another SubStatement")
		else:
			substmt['object']['objectType'] = 'Activity'

		# Validate agent, verb, and object
		self.validate_agent(substmt['actor'], 'actor')
		self.validate_verb(substmt['verb'])
		self.validate_object(substmt['object'])

		# If result included, validate it
		if 'result' in substmt:
			self.validate_result(substmt['result'])

		# If context included, validate it
		if 'context' in substmt:
			self.validate_context(substmt['context'], substmt['object'])

	def validate_result(self, result):
		# Ensure incoming result is dict and check allowed fields
		self.check_if_dict(result, "Result")
		self.check_allowed_fields(result_allowed_fields, result, "Result")

		# If duration included, ensure valid duration can be parsed from it
		if 'duration' in result:
			try:
				parse_duration(result['duration'])
			except ISO8601Error as e:
				self.return_error("Error with result duration - %s" % e.message)

		# If success or completion included, ensure they are boolean
		if 'success' in result:
			if not isinstance(result['success'], bool):
				self.return_error("Result success must be a boolean value")
		if 'completion' in result:
			if not isinstance(result['completion'], bool):
				self.return_error("Result completion must be a boolean value")

		# If response in result, ensure it is a string
		if 'response' in result:
			if not isinstance(result['response'], basestring):
				self.return_error("Result response must be a string")

		# If extensions, validate
		if 'extensions' in result:
			self.validate_extensions(result['extensions'], 'result')

		# If score included, validate it
		if 'score' in result:
			self.validate_score(result['score'])

	def validate_score(self, score):
		# Ensure incoming score is a dict and check allowed fields
		self.check_if_dict(score, "Score")
		self.check_allowed_fields(score_allowed_fields, score, "Score")

		if 'raw' in score:
			# If raw included with min and max, ensure it is between min and ax
			raw = score['raw']
			# Check raw type
			if not (isinstance(raw, float) or isinstance(raw, int)):
				self.return_error("Score raw is not a number")
		else:
			raw = None

		# If min and max are included, ensure min <= max
		if 'min' in score and 'max' in score:
			sc_min = score['min']
			sc_max = score['max']

			# Check types of min and max
			if not (isinstance(sc_min, float) or isinstance(sc_min, int)):
				self.return_error("Score minimum is not a decimal")

			if not (isinstance(sc_max, float) or isinstance(sc_max, int)):
				self.return_error("Score maximum is not a decimal")

			if sc_min >= sc_max:
				self.return_error("Score minimum in statement result must be less than the maximum")

			if raw and (raw < sc_min or raw > sc_max):
				self.return_error("Score raw value in statement result must be between minimum and maximum")

		# If scale is included make sure it's between -1 and 1
		if 'scaled' in score:
			scaled = score['scaled']

			# Check scaled type
			if not (isinstance(scaled, float) or isinstance(scaled, int)):
				self.return_error("Score scaled is not a decimal")

			if scaled < -1 or scaled > 1:
				self.return_error("Score scaled value in statement result must be between -1 and 1")

	def validate_context(self, context, stmt_object):
		# Ensure incoming context is a dict and check allowed fields
		self.check_if_dict(context, "Context")
		self.check_allowed_fields(context_allowed_fields, context, "Context")

		# If registration included, ensure it is valid UUID
		if 'registration' in context:
			self.validate_uuid(context['registration'], 'Context registration')

		# If instructor or team included, ensure they are valid agents
		if 'instructor' in context:
			self.validate_agent(context['instructor'], 'Context instructor')
		if 'team' in context:
			self.validate_agent(context['team'], 'Context team')

		# If objectType of object in stmt is Agent/Group, context cannot have revision or platform fields
		object_type = stmt_object['objectType']
		if 'revision' in context:
			if object_type == 'Agent' or object_type == 'Group':
				self.return_error("Revision is not allowed in context if statment object is an Agent or Group")		

			# Check revision is string
			if not isinstance(context['revision'], basestring):
				self.return_error("Context revision must be a string")

		if 'platform' in context:
			if object_type == 'Agent' or object_type == 'Group':
				self.return_error("Platform is not allowed in context if statment object is an Agent or Group")		

			# Check platform is string
			if not isinstance(context['platform'], basestring):
				self.return_error("Context platform must be a string")

		# If language given, ensure it is string
		if 'language' in context:
			if not isinstance(context['language'], basestring):
				self.return_error("Context language must be a string")

		# If statement given, ensure it is a valid StatementRef
		if 'statement' in context:
			self.validate_statementref(context['statement'])

		# If contextActivities given, ensure they are valid contextActivities
		if 'contextActivities' in context:
			self.validate_context_activities(context['contextActivities'])

		# If extensions, validate
		if 'extensions' in context:
			self.validate_extensions(context['extensions'], 'context')

	def validate_context_activities(self, conacts):
		# Ensure incoming conact is dict
		self.check_if_dict(conacts, "Context activity")
		context_activity_types = ['parent', 'grouping', 'category', 'other']
		for conact in conacts.items():
			# Check if conact is a valid type
			if not conact[0] in context_activity_types:
				self.return_error("Context Activity type is not valid")
			# Ensure conact is a list or dict
			if isinstance(conact[1], list):
				for act in conact[1]:
					self.validate_activity(act)
			elif isinstance(conact[1], dict):
				self.validate_activity(conact[1])
			else:
				self.return_error("contextActivities is not formatted correctly")

########NEW FILE########
__FILENAME__ = uri
import re

'''
scheme    = $2
authority = $4
path      = $5
query     = $7
fragment  = $9
'''
SCHEME = 2
EMAIL = 5
uri_re = re.compile('^(([^:/?#\s]+):)?(//([^/?#\s]*))?([^?#\s]*)(\?([^#\s]*))?(#([^\s]*))?')

def validate_uri(s):
	res = uri_re.match(s)
	return res.group(SCHEME) != None and res.group(0) == s

def validate_email(s):
	res = uri_re.match(s)
	return res.group(SCHEME) == "mailto" and res.group(EMAIL) != None and res.group(0) == s
########NEW FILE########
__FILENAME__ = XAPIVersionHeaderMiddleware
import re
from django.http import HttpResponseBadRequest

class XAPIVersionHeader(object):
    def process_request(self, request):
        try:
            version = request.META['X-Experience-API-Version']
        except:
            try:
                version = request.META['HTTP_X_EXPERIENCE_API_VERSION']
            except:
                version = request.META.get('X_Experience_API_Version', None)
                if not version:
                    import urllib
                    bdy = urllib.unquote_plus(request.body)
                    v = re.search('X\WExperience\WAPI\WVersion=(?P<num>[\d\.]*)\&?', bdy)
                    if v:
                        version = v.group('num')
        if version:
            regex = re.compile("^1\.0(\.\d+)?$")
            if regex.match(version):
                return None
            else:
                return HttpResponseBadRequest("X-Experience-API-Version is not supported")
        else:
            return HttpResponseBadRequest("X-Experience-API-Version header missing")


    def process_response(self, request, response):
        response['X-Experience-API-Version'] = "1.0.1"
        return response

########NEW FILE########
__FILENAME__ = views
import json
import logging
from django.conf import settings
from django.contrib.auth import authenticate, logout
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.core.context_processors import csrf
from django.core.exceptions import ValidationError
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.utils.decorators import decorator_from_middleware
from django.views.decorators.csrf import csrf_protect
from django.views.decorators.http import require_http_methods
from lrs import forms, models, exceptions
from lrs.util import req_validate, req_parse, req_process, XAPIVersionHeaderMiddleware, accept_middleware, StatementValidator
from oauth_provider.consts import ACCEPTED, CONSUMER_STATES

logger = logging.getLogger(__name__)
 
@decorator_from_middleware(accept_middleware.AcceptMiddleware)
@csrf_protect
def home(request):
    context = RequestContext(request)
    context.update(csrf(request))

    stats = {}
    stats['usercnt'] = User.objects.all().count()
    stats['stmtcnt'] = models.Statement.objects.all().count()
    stats['verbcnt'] = models.Verb.objects.all().count()
    stats['agentcnt'] = models.Agent.objects.filter().count()
    stats['activitycnt'] = models.Activity.objects.filter().count()
    return render_to_response('home.html', {'stats':stats}, context_instance=context)

@decorator_from_middleware(accept_middleware.AcceptMiddleware)
@csrf_protect
def stmt_validator(request):
    context = RequestContext(request)
    context.update(csrf(request))

    if request.method == 'GET':
        form = forms.ValidatorForm()
        return render_to_response('validator.html', {"form": form}, context_instance=context)
    elif request.method == 'POST':
        form = forms.ValidatorForm(request.POST)
        if form.is_valid():
            # Initialize validator (validates incoming data structure)
            try:
                validator = StatementValidator.StatementValidator(form.cleaned_data['jsondata'])
            except SyntaxError, se:
                return render_to_response('validator.html', {"form": form, "error_message": "Statement is not a properly formatted dictionary"},
                context_instance=context)
            except ValueError, ve:
                return render_to_response('validator.html', {"form": form, "error_message": "Statement is not a properly formatted dictionary"},
                context_instance=context)                
            except Exception, e:
                return render_to_response('validator.html', {"form": form, "error_message": e.message},
                context_instance=context)

            # Once know it's valid JSON, validate keys and fields
            try:
                valid = validator.validate()
            except exceptions.ParamError, e:
                return render_to_response('validator.html', {"form": form,"error_message": e.message},
                    context_instance=context)
            else:
                return render_to_response('validator.html', {"form": form,"valid_message": valid},
                    context_instance=context)
        else:
            return render_to_response('validator.html', {"form": form},
                context_instance=context)

@decorator_from_middleware(accept_middleware.AcceptMiddleware)
def about(request):
    lrs_data = { 
        "version": ["1.0.1"],
        "Extensions":{
            "xapi": {
                "statements":
                {
                    "name": "Statements",
                    "methods": ["GET", "POST", "PUT", "HEAD"],
                    "endpoint": reverse('lrs.views.statements'),
                    "description": "Endpoint to submit and retrieve XAPI statments.",
                },
                "activities":
                {
                    "name": "Activities",
                    "methods": ["GET", "HEAD"],
                    "endpoint": reverse('lrs.views.activities'),
                    "description": "Endpoint to retrieve a complete activity object.",
                },
                "activities_state":
                {
                    "name": "Activities State",
                    "methods": ["PUT","POST","GET","DELETE", "HEAD"],
                    "endpoint": reverse('lrs.views.activity_state'),
                    "description": "Stores, fetches, or deletes the document specified by the given stateId that exists in the context of the specified activity, agent, and registration (if specified).",
                },
                "activities_profile":
                {
                    "name": "Activities Profile",
                    "methods": ["PUT","POST","GET","DELETE", "HEAD"],
                    "endpoint": reverse('lrs.views.activity_profile'),
                    "description": "Saves/retrieves/deletes the specified profile document in the context of the specified activity.",
                },
                "agents":
                {
                    "name": "Agents",
                    "methods": ["GET", "HEAD"],
                    "endpoint": reverse('lrs.views.agents'),
                    "description": "Returns a special, Person object for a specified agent.",
                },
                "agents_profile":
                {
                    "name": "Agent Profile",
                    "methods": ["PUT","POST","GET","DELETE", "HEAD"],
                    "endpoint": reverse('lrs.views.agent_profile'),
                    "description": "Saves/retrieves/deletes the specified profile document in the context of the specified agent.",
                }
            },
            "lrs":{
                "user_register":
                {
                    "name": "User Registration",
                    "methods": ["POST"],
                    "endpoint": reverse('lrs.views.register'),
                    "description": "Registers a user within the LRS.",
                },
                "client_register":
                {
                    "name": "Client Registration",
                    "methods": ["POST"],
                    "endpoint": reverse('lrs.views.reg_client'),
                    "description": "Registers a client applicaton with the LRS.",
                }
            },
            "oauth":
            {
                "initiate":
                {
                    "name": "Oauth Initiate",
                    "methods": ["POST"],
                    "endpoint": reverse('oauth_provider.views.request_token'),
                    "description": "Authorize a client and return temporary credentials.",
                },
                "authorize":
                {
                    "name": "Oauth Authorize",
                    "methods": ["GET"],
                    "endpoint": reverse('oauth_provider.views.user_authorization'),
                    "description": "Authorize a user.",
                },
                "token":
                {
                    "name": "Oauth Token",
                    "methods": ["POST"],
                    "endpoint": reverse('oauth_provider.views.access_token'),
                    "description": "Provides Oauth token to the client.",
                }
            }
        }
    }    
    return HttpResponse(json.dumps(lrs_data), mimetype="application/json", status=200)

def actexample(request):
    return render_to_response('actexample.json', mimetype="application/json")

def actexample2(request):
    return render_to_response('actexample2.json', mimetype="application/json")

def actexample3(request):
    return render_to_response('actexample3.json', mimetype="application/json")

def actexample4(request):
    return render_to_response('actexample4.json', mimetype="application/json")

@csrf_protect
@require_http_methods(["POST", "GET"])
def register(request):
    context = RequestContext(request)
    context.update(csrf(request))
    
    if request.method == 'GET':
        form = forms.RegisterForm()
        return render_to_response('register.html', {"form": form}, context_instance=context)
    elif request.method == 'POST':
        form = forms.RegisterForm(request.POST)
        if form.is_valid():
            name = form.cleaned_data['username']
            pword = form.cleaned_data['password']
            email = form.cleaned_data['email']
            
            try:
                user = User.objects.get(username__exact=name)
            except User.DoesNotExist:
                user = User.objects.create_user(name, email, pword)
            else:
                return render_to_response('register.html', {"form": form, "error_message": "User %s already exists." % name},
                    context_instance=context)                
            
            d = {"info_message": "Thanks for registering. You can now use your name [%s] and password to sign in." % user.username}
            return render_to_response('reg_success.html', d, context_instance=context)
        else:
            return render_to_response('register.html', {"form": form}, context_instance=context)

@login_required(login_url="/XAPI/accounts/login")
@require_http_methods(["POST", "GET"])
def reg_client(request):
    if request.method == 'GET':
        form = forms.RegClientForm()
        return render_to_response('regclient.html', {"form": form}, context_instance=RequestContext(request))
    elif request.method == 'POST':
        form = forms.RegClientForm(request.POST)
        if form.is_valid():
            name = form.cleaned_data['name']
            description = form.cleaned_data['description']
            scopes = form.cleaned_data['scopes']
            
            try:
                client = models.Consumer.objects.get(name__exact=name)
            except models.Consumer.DoesNotExist:
                client = models.Consumer.objects.create(name=name, description=description, user=request.user,
                    status=ACCEPTED, default_scopes=",".join(scopes))
            else:
                return render_to_response('regclient.html', {"form": form, "error_message": "%s alreay exists." % name}, context_instance=RequestContext(request))         
            
            d = {"name":client.name,"app_id":client.key, "secret":client.secret, "info_message": "Your Client Credentials"}
            return render_to_response('reg_success.html', d, context_instance=RequestContext(request))
        else:
            return render_to_response('regclient.html', {"form": form}, context_instance=RequestContext(request))

@login_required(login_url="/XAPI/accounts/login")
def me(request):
    client_apps = models.Consumer.objects.filter(user=request.user)
    access_tokens = models.Token.objects.filter(user=request.user, token_type=models.Token.ACCESS, is_approved=True)
    return render_to_response('me.html', {'client_apps':client_apps, 'access_tokens':access_tokens},
        context_instance=RequestContext(request))

@login_required(login_url="/XAPI/accounts/login")
def my_statements(request):
    if request.method == "DELETE":
        models.Statement.objects.filter(user=request.user).delete()
        stmts = models.Statement.objects.filter(user=request.user)
        if not stmts:
            return HttpResponse(status=204)
        else:
            raise Exception("unable to delete statements")

    stmt_id = request.GET.get("stmt_id", None)
    if stmt_id:
        s = models.Statement.objects.get(statement_id=stmt_id, user=request.user)
        return HttpResponse(s.object_return(),mimetype="application/json",status=200)
    else:
        s = {}
        paginator = Paginator(models.Statement.objects.filter(user=request.user).order_by('-timestamp').values_list('id', flat=True), 
            settings.STMTS_PER_PAGE)

        page_no = request.GET.get('page', 1)
        try:
            page = paginator.page(page_no)
        except PageNotAnInteger:
            # If page is not an integer, deliver first page.
            page = paginator.page(1)
        except EmptyPage:
            # If page is out of range (e.g. 9999), deliver last page of results.
            page = paginator.page(paginator.num_pages)

        idlist = page.object_list
        if idlist.count() > 0:
            stmt_objs = [stmt for stmt in models.Statement.objects.filter(id__in=(idlist)).order_by('-timestamp')]
        else: 
            stmt_objs = []

        slist = []
        for stmt in stmt_objs:
            d = {}
            d['timestamp'] = stmt.timestamp.isoformat()
            d['statement_id'] = stmt.statement_id
            d['actor_name'] = stmt.actor.get_a_name()
            d['verb'] = stmt.verb.get_display()
            d['object'] = stmt.get_object().get_a_name()
            slist.append(d)

        s['stmts'] = slist
        if page.has_previous():
            s['previous'] = "%s?page=%s" % (reverse('lrs.views.my_statements'), page.previous_page_number())
        if page.has_next():
            s['next'] = "%s?page=%s" % (reverse('lrs.views.my_statements'), page.next_page_number())

        return HttpResponse(json.dumps(s), mimetype="application/json", status=200)

@login_required(login_url="/XAPI/accounts/login")
def my_app_status(request):
    try:
        name = request.GET['app_name']
        status = request.GET['status']
        new_status = [s[0] for s in CONSUMER_STATES if s[1] == status][0] #should only be 1
        client = models.Consumer.objects.get(name__exact=name, user=request.user)
        client.status = new_status
        client.save()
        ret = {"app_name":client.name, "status":client.get_status_display()}
        return HttpResponse(json.dumps(ret), mimetype="application/json", status=200)
    except:
        return HttpResponse(json.dumps({"error_message":"unable to fulfill request"}), mimetype="application/json", status=400)

@login_required(login_url="/XAPI/accounts/login")
@require_http_methods(["DELETE"])
def delete_token(request):
    try:
        ids = request.GET['id'].split("-")
        token_key = ids[0]
        consumer_id = ids[1]
        ts = ids[2]
        token = models.Token.objects.get(user=request.user,
                                         key__startswith=token_key,
                                         consumer__id=consumer_id,
                                         timestamp=ts,
                                         token_type=models.Token.ACCESS,
                                         is_approved=True)
        token.is_approved = False
        token.save()
        return HttpResponse("", status=204)
    except:
        return HttpResponse("Unknown token", status=400)

def logout_view(request):
    logout(request)
    # Redirect to a success page.
    return HttpResponseRedirect(reverse('lrs.views.home'))

# Called when user queries GET statement endpoint and returned list is larger than server limit (10)
@decorator_from_middleware(XAPIVersionHeaderMiddleware.XAPIVersionHeader)
@require_http_methods(["GET", "HEAD"])
def statements_more(request, more_id):
    return handle_request(request, more_id)

@require_http_methods(["PUT","GET","POST", "HEAD"])
@decorator_from_middleware(XAPIVersionHeaderMiddleware.XAPIVersionHeader)
def statements(request):
    return handle_request(request)   

@require_http_methods(["PUT","POST","GET","DELETE", "HEAD"])
@decorator_from_middleware(XAPIVersionHeaderMiddleware.XAPIVersionHeader)
def activity_state(request):
    return handle_request(request)  

@require_http_methods(["PUT","POST","GET","DELETE", "HEAD"])
@decorator_from_middleware(XAPIVersionHeaderMiddleware.XAPIVersionHeader)
def activity_profile(request):
    return handle_request(request)

@require_http_methods(["GET", "HEAD"])
@decorator_from_middleware(XAPIVersionHeaderMiddleware.XAPIVersionHeader)
def activities(request):
    return handle_request(request)

@require_http_methods(["PUT","POST","GET","DELETE", "HEAD"])    
@decorator_from_middleware(XAPIVersionHeaderMiddleware.XAPIVersionHeader)
def agent_profile(request):
    return handle_request(request)

# returns a 405 (Method Not Allowed) if not a GET
@require_http_methods(["GET", "HEAD"])
@decorator_from_middleware(XAPIVersionHeaderMiddleware.XAPIVersionHeader)
def agents(request):
    return handle_request(request)

@login_required
def user_profile(request):
    return render_to_response('registration/profile.html')

validators = {
    reverse(statements).lower() : {
        "POST" : req_validate.statements_post,
        "GET" : req_validate.statements_get,
        "PUT" : req_validate.statements_put,
        "HEAD" : req_validate.statements_get
    },
    reverse(activity_state).lower() : {
        "POST": req_validate.activity_state_post,
        "PUT" : req_validate.activity_state_put,
        "GET" : req_validate.activity_state_get,
        "HEAD" : req_validate.activity_state_get,
        "DELETE" : req_validate.activity_state_delete
    },
    reverse(activity_profile).lower() : {
        "POST": req_validate.activity_profile_post,
        "PUT" : req_validate.activity_profile_put,
        "GET" : req_validate.activity_profile_get,
        "HEAD" : req_validate.activity_profile_get,
        "DELETE" : req_validate.activity_profile_delete
    },
    reverse(activities).lower() : {
        "GET" : req_validate.activities_get,
        "HEAD" : req_validate.activities_get
    },
    reverse(agent_profile).lower() : {
        "POST": req_validate.agent_profile_post,
        "PUT" : req_validate.agent_profile_put,
        "GET" : req_validate.agent_profile_get,
        "HEAD" : req_validate.agent_profile_get,
        "DELETE" : req_validate.agent_profile_delete
    },
   reverse(agents).lower() : {
       "GET" : req_validate.agents_get,
       "HEAD" : req_validate.agents_get
   },
   "/xapi/statements/more" : {
        "GET" : req_validate.statements_more_get,
        "HEAD" : req_validate.statements_more_get
   }
}

processors = {
    reverse(statements).lower() : {
        "POST" : req_process.statements_post,
        "GET" : req_process.statements_get,
        "HEAD" : req_process.statements_get,
        "PUT" : req_process.statements_put
    },
    reverse(activity_state).lower() : {
        "POST": req_process.activity_state_post,
        "PUT" : req_process.activity_state_put,
        "GET" : req_process.activity_state_get,
        "HEAD" : req_process.activity_state_get,
        "DELETE" : req_process.activity_state_delete
    },
    reverse(activity_profile).lower() : {
        "POST": req_process.activity_profile_post,
        "PUT" : req_process.activity_profile_put,
        "GET" : req_process.activity_profile_get,
        "HEAD" : req_process.activity_profile_get,
        "DELETE" : req_process.activity_profile_delete
    },
    reverse(activities).lower() : {
        "GET" : req_process.activities_get,
        "HEAD" : req_process.activities_get
    },
    reverse(agent_profile).lower() : {
        "POST": req_process.agent_profile_post,
        "PUT" : req_process.agent_profile_put,
        "GET" : req_process.agent_profile_get,
        "HEAD" : req_process.agent_profile_get,
        "DELETE" : req_process.agent_profile_delete
    },
   reverse(agents).lower() : {
       "GET" : req_process.agents_get,
       "HEAD" : req_process.agents_get
   },
   "/xapi/statements/more" : {
        "GET" : req_process.statements_more_get,
        "HEAD" : req_process.statements_more_get
   }      
}

def handle_request(request, more_id=None):
    try:
        r_dict = req_parse.parse(request, more_id)
        path = request.path.lower()

        if path.endswith('/'):
            path = path.rstrip('/')

        # Cutoff more_id
        if '/xapi/statements/more' in path:
            path = '/xapi/statements/more'

        req_dict = validators[path][r_dict['method']](r_dict)
        return processors[path][req_dict['method']](req_dict)

    except exceptions.BadRequest as err:
        log_exception(request.path, err)
        return HttpResponse(err.message, status=400)
    except ValidationError as ve:
        log_exception(request.path, ve)
        return HttpResponse(ve.messages[0], status=400)
    except exceptions.Unauthorized as autherr:
        log_exception(request.path, autherr)
        r = HttpResponse(autherr, status = 401)
        r['WWW-Authenticate'] = 'Basic realm="ADLLRS"'
        return r
    except exceptions.OauthUnauthorized as oauth_err:
        log_exception(request.path, oauth_err)
        return oauth_err.response
    except exceptions.Forbidden as forb:
        log_exception(request.path, forb)
        return HttpResponse(forb.message, status=403)
    except exceptions.NotFound as nf:
        log_exception(request.path, nf)
        return HttpResponse(nf.message, status=404)
    except exceptions.Conflict as c:
        log_exception(request.path, c)
        return HttpResponse(c.message, status=409)
    except exceptions.PreconditionFail as pf:
        log_exception(request.path, pf)
        return HttpResponse(pf.message, status=412)
    except Exception as err:
        log_exception(request.path, err)
        return HttpResponse(err.message, status=500)

def log_exception(path, ex):
    logger.info("\nException while processing: %s" % path)
    logger.exception(ex)
########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "adl_lrs.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

# lou w - removed any references to Resource and registering Consumer, Nonce, and Token since that is done
# in lrs/admin.py

class ConsumerAdmin(admin.ModelAdmin):
	pass

class TokenAdmin(admin.ModelAdmin):
	pass

class NonceAdmin(admin.ModelAdmin):
	pass

########NEW FILE########
__FILENAME__ = consts
from django.utils.translation import ugettext_lazy as _
from django.conf import settings

KEY_SIZE = getattr(settings, 'OAUTH_PROVIDER_KEY_SIZE', 16)
SECRET_SIZE = getattr(settings, 'OAUTH_PROVIDER_SECRET_SIZE', 64)
VERIFIER_SIZE = getattr(settings, 'OAUTH_PROVIDER_VERIFIER_SIZE', 10)
CONSUMER_KEY_SIZE = getattr(settings, 'OAUTH_PROVIDER_CONSUMER_KEY_SIZE', 64)
MAX_URL_LENGTH = 2083 # http://www.boutell.com/newfaq/misc/urllength.html

PENDING = 1
ACCEPTED = 2
CANCELED = 3
REJECTED = 4

CONSUMER_STATES = (
    (PENDING,  _('Pending')),
    (ACCEPTED, _('Accepted')),
    (CANCELED, _('Canceled')),
    (REJECTED, _('Rejected')),
)

PARAMETERS_NAMES = ('consumer_key', 'token', 'signature',
                    'signature_method', 'timestamp', 'nonce')

OAUTH_PARAMETERS_NAMES = ['oauth_'+s for s in PARAMETERS_NAMES]

OUT_OF_BAND = 'oob'

########NEW FILE########
__FILENAME__ = decorators
from oauth.oauth import OAuthError

try:
    from functools import wraps, update_wrapper
except ImportError:
    from django.utils.functional import wraps, update_wrapper  # Python 2.3, 2.4 fallback.

from django.contrib.auth import REDIRECT_FIELD_NAME
from django.utils.translation import ugettext as _

from utils import initialize_server_request, send_oauth_error
from consts import OAUTH_PARAMETERS_NAMES

def oauth_required(request):
    return CheckOAuth.handle_request(request)

class CheckOAuth(object):
    """
    Class that checks that the OAuth parameters passes the given test, raising
    an OAuth error otherwise. If the test is passed, the view function
    is invoked.

    We use a class here so that we can define __get__. This way, when a
    CheckOAuth object is used as a method decorator, the view function
    is properly bound to its instance.
    """
    def __init__(self, request):
        self.request = request
        self.view_func = view_func
        # lou w - name scope instead of resource
        self.scopes = resource_name
        update_wrapper(self, request)
        
    def __get__(self, obj, cls=None):
        return CheckOAuth(request)
    
    def __call__(self, request):
        if self.is_valid_request(request):
            try:
                consumer, token, parameters = self.validate_token(request)
            except OAuthError, e:
                return send_oauth_error(e)

            # lou w - changed to check token scope and self scope instead of resource
            if self.scopes and token.scope != self.scopes:
                return send_oauth_error(OAuthError(_('You are not allowed to access this resource.')))
            elif consumer and token:
                return self.view_func(request, *args, **kwargs)
        return send_oauth_error(OAuthError(_('Invalid request parameters.')))

    @staticmethod
    def is_valid_request(request):
        """
        Checks whether the required parameters are either in
        the http-authorization header sent by some clients,
        which is by the way the preferred method according to
        OAuth spec, but otherwise fall back to `GET` and `POST`.
        """
        is_in = lambda l: all((p in l) for p in OAUTH_PARAMETERS_NAMES)
        # lou w = all auth params will be in Authorization or HTTP_AUTHORIZATION
        auth_params = request.META.get("HTTP_AUTHORIZATION", request.META.get("Authorization", []))
        return is_in(auth_params) or is_in(request.REQUEST)

    @staticmethod
    def validate_token(request):
        oauth_server, oauth_request = initialize_server_request(request)
        return oauth_server.verify_request(oauth_request)

########NEW FILE########
__FILENAME__ = managers
from django.db import models
from django.contrib.auth.models import User
from consts import KEY_SIZE, SECRET_SIZE

#  lou w - removed any references to Resource

class ConsumerManager(models.Manager):
    def create_consumer(self, name, user=None):
        """Shortcut to create a consumer with random key/secret."""
        consumer, created = self.get_or_create(name=name)
        if user is not None:
            consumer.user = user
        if created:
            consumer.generate_random_codes()
        return consumer
    
    _default_consumer = None
    def get_default_consumer(self, name):
        """Add cache if you use a default consumer."""
        if self._default_consumer is None:
            self._default_consumer = self.get(name=name)
        return self._default_consumer

# lou w -renamed resource to scope        
class TokenManager(models.Manager):
    def create_token(self, consumer, token_type, timestamp, scope, 
            user=None, callback=None, callback_confirmed=False, lrs_auth_id=None):
        """Shortcut to create a token with random key/secret."""
        
        token, created = self.get_or_create(consumer=consumer, 
                                            token_type=token_type, 
                                            timestamp=timestamp,
                                            scope=scope,
                                            user=user,
                                            callback=callback,
                                            callback_confirmed=callback_confirmed,
                                            lrs_auth_id=lrs_auth_id)
        if created:
            token.generate_random_codes()
        return token

########NEW FILE########
__FILENAME__ = oauth
"""
The MIT License

Copyright (c) 2007 Leah Culver

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""

import cgi
import urllib
import time
import random
import urlparse
import hmac
import binascii
import ast

VERSION = '1.0' # Hi Blaine!
HTTP_METHOD = 'GET'
SIGNATURE_METHOD = 'PLAINTEXT'


class OAuthError(RuntimeError):
    """Generic exception class."""
    def __init__(self, message='OAuth error occured.'):
        self.message = message

def build_authenticate_header(realm=''):
    """Optional WWW-Authenticate header (401 error)"""
    return {'WWW-Authenticate': 'OAuth realm="%s"' % realm}

def escape(s):
    """Escape a URL including any /."""
    return urllib.quote(s, safe='~')

def _utf8_str(s):
    """Convert unicode to utf-8."""
    if isinstance(s, unicode):
        return s.encode("utf-8")
    else:
        return str(s)

def generate_timestamp():
    """Get seconds since epoch (UTC)."""
    return int(time.time())

def generate_nonce(length=8):
    """Generate pseudorandom number."""
    return ''.join([str(random.randint(0, 9)) for i in range(length)])

def generate_verifier(length=8):
    """Generate pseudorandom number."""
    return ''.join([str(random.randint(0, 9)) for i in range(length)])


class OAuthConsumer(object):
    """Consumer of OAuth authentication.

    OAuthConsumer is a data type that represents the identity of the Consumer
    via its shared secret with the Service Provider.

    """
    key = None
    secret = None

    def __init__(self, key, secret):
        self.key = key
        self.secret = secret


class OAuthToken(object):
    """OAuthToken is a data type that represents an End User via either an access
    or request token.
    
    key -- the token
    secret -- the token secret

    """
    key = None
    secret = None
    callback = None
    callback_confirmed = None
    verifier = None

    def __init__(self, key, secret):
        self.key = key
        self.secret = secret

    def set_callback(self, callback):
        self.callback = callback
        self.callback_confirmed = 'true'

    def set_verifier(self, verifier=None):
        if verifier is not None:
            self.verifier = verifier
        else:
            self.verifier = generate_verifier()

    def get_callback_url(self):
        if self.callback and self.verifier:
            # Append the oauth_verifier.
            parts = urlparse.urlparse(self.callback)
            scheme, netloc, path, params, query, fragment = parts[:6]
            if query:
                query = '%s&oauth_verifier=%s' % (query, self.verifier)
            else:
                query = 'oauth_verifier=%s' % self.verifier
            return urlparse.urlunparse((scheme, netloc, path, params,
                query, fragment))
        return self.callback

    def to_string(self):
        data = {
            'oauth_token': self.key,
            'oauth_token_secret': self.secret,
        }
        if self.callback_confirmed is not None:
            data['oauth_callback_confirmed'] = self.callback_confirmed
        return urllib.urlencode(data)
 
    def from_string(s):
        """ Returns a token from something like:
        oauth_token_secret=xxx&oauth_token=xxx
        """
        params = cgi.parse_qs(s, keep_blank_values=False)
        key = params['oauth_token'][0]
        secret = params['oauth_token_secret'][0]
        token = OAuthToken(key, secret)
        try:
            token.callback_confirmed = params['oauth_callback_confirmed'][0]
        except KeyError:
            pass # 1.0, no callback confirmed.
        return token
    from_string = staticmethod(from_string)

    def __str__(self):
        return self.to_string()


class OAuthRequest(object):
    """OAuthRequest represents the request and can be serialized.

    OAuth parameters:
        - oauth_consumer_key 
        - oauth_token
        - oauth_signature_method
        - oauth_signature 
        - oauth_timestamp 
        - oauth_nonce
        - oauth_version
        - oauth_verifier
        ... any additional parameters, as defined by the Service Provider.
    """
    parameters = None # OAuth parameters.
    http_method = HTTP_METHOD
    http_url = None
    version = VERSION

    def __init__(self, http_method=HTTP_METHOD, http_url=None, parameters=None):
        self.http_method = http_method
        self.http_url = http_url
        self.parameters = parameters or {}

    def set_parameter(self, parameter, value):
        self.parameters[parameter] = value

    def get_parameter(self, parameter):
        try:
            return self.parameters[parameter]
        except:
            raise OAuthError('Parameter not found: %s' % parameter)

    def _get_timestamp_nonce(self):
        return self.get_parameter('oauth_timestamp'), self.get_parameter(
            'oauth_nonce')

    def get_nonoauth_parameters(self):
        """Get any non-OAuth parameters."""
        parameters = {}
        for k, v in self.parameters.iteritems():
            # Ignore oauth parameters.
            if k.find('oauth_') < 0:
                parameters[k] = v
        return parameters

    def to_header(self, realm=''):
        """Serialize as a header for an HTTPAuth request."""
        auth_header = 'OAuth realm="%s"' % realm
        # Add the oauth parameters.
        if self.parameters:
            for k, v in self.parameters.iteritems():
                if k[:6] == 'oauth_':
                    auth_header += ', %s="%s"' % (k, escape(str(v)))
        return {'Authorization': auth_header}

    def to_postdata(self):
        """Serialize as post data for a POST request."""
        return '&'.join(['%s=%s' % (escape(str(k)), escape(str(v))) \
            for k, v in self.parameters.iteritems()])

    def to_url(self):
        """Serialize as a URL for a GET request."""
        return '%s?%s' % (self.get_normalized_http_url(), self.to_postdata())

    def get_normalized_parameters(self):
        """Return a string that contains the parameters that must be signed."""
        params = self.parameters
        try:
            # Exclude the signature if it exists.
            del params['oauth_signature']
        except:
            pass
        # Escape key values before sorting.
        key_values = [(escape(_utf8_str(k)), escape(_utf8_str(v))) \
            for k,v in params.items()]
        # Sort lexicographically, first after key, then after value.
        key_values.sort()
        # Combine key value pairs into a string.
        return '&'.join(['%s=%s' % (k, v) for k, v in key_values])

    def get_normalized_http_method(self):
        """Uppercases the http method."""
        return self.http_method.upper()

    def get_normalized_http_url(self):
        """Parses the URL and rebuilds it to be scheme://host/path."""
        parts = urlparse.urlparse(self.http_url)
        scheme, netloc, path = parts[:3]
        # Exclude default port numbers.
        if scheme == 'http' and netloc[-3:] == ':80':
            netloc = netloc[:-3]
        elif scheme == 'https' and netloc[-4:] == ':443':
            netloc = netloc[:-4]
        return '%s://%s%s' % (scheme, netloc, path)

    def sign_request(self, signature_method, consumer, token):
        """Set the signature parameter to the result of build_signature."""
        # Set the signature method.
        self.set_parameter('oauth_signature_method',
            signature_method.get_name())
        # Set the signature.
        self.set_parameter('oauth_signature',
            self.build_signature(signature_method, consumer, token))

    def build_signature(self, signature_method, consumer, token):
        """Calls the build signature method within the signature method."""
        return signature_method.build_signature(self, consumer, token)

    def from_request(http_method, http_url, headers=None, parameters=None,
            query_string=None):
        """Combines multiple parameter sources."""
        if parameters is None:
            parameters = {}
        # Headers
        if headers and 'Authorization' in headers:
            auth_header = headers['Authorization']
            # Check that the authorization header is OAuth.
            if auth_header[:6] == 'OAuth ':
                auth_header = auth_header[6:]
                try:
                    # Get the parameters from the header.
                    header_params = OAuthRequest._split_header(auth_header)
                    parameters.update(header_params)
                except:
                    raise OAuthError('Unable to parse OAuth parameters from '
                        'Authorization header.')

        # GET or POST query string.
        if query_string:
            query_params = OAuthRequest._split_url_string(query_string)
            parameters.update(query_params)

        # URL parameters.
        param_str = urlparse.urlparse(http_url)[4] # query
        url_params = OAuthRequest._split_url_string(param_str)
        parameters.update(url_params)
        
        if parameters:
            return OAuthRequest(http_method, http_url, parameters)

        return None
    from_request = staticmethod(from_request)

    def from_consumer_and_token(oauth_consumer, token=None,
            callback=None, verifier=None, http_method=HTTP_METHOD,
            http_url=None, parameters=None):
        if not parameters:
            parameters = {}

        defaults = {
            'oauth_consumer_key': oauth_consumer.key,
            'oauth_timestamp': generate_timestamp(),
            'oauth_nonce': generate_nonce(),
            'oauth_version': OAuthRequest.version,
        }

        defaults.update(parameters)
        parameters = defaults

        if token:
            parameters['oauth_token'] = token.key
            if token.callback:
                parameters['oauth_callback'] = token.callback
            # 1.0a support for verifier.
            if verifier:
                parameters['oauth_verifier'] = verifier
        elif callback:
            # 1.0a support for callback in the request token request.
            parameters['oauth_callback'] = callback
        return OAuthRequest(http_method, http_url, parameters)
    from_consumer_and_token = staticmethod(from_consumer_and_token)

    def from_token_and_callback(token, callback=None, http_method=HTTP_METHOD,
            http_url=None, parameters=None):
        if not parameters:
            parameters = {}


        parameters['oauth_token'] = token.key

        if callback:
            parameters['oauth_callback'] = callback

        return OAuthRequest(http_method, http_url, parameters)
    from_token_and_callback = staticmethod(from_token_and_callback)

    def _split_header(header):
        """Turn Authorization: header into parameters. Changed way to retrieve headers b/c 
        wasn't sending in oauth 'headers' in the header in from_request"""
        params = {}
        parts = header.split(',')
        for param in parts:
            # Ignore realm parameter.
            if param.find('realm') > -1:
                continue
            # Remove whitespace.
            param = param.strip()
            # Split key-value.
            param_parts = param.split('=', 1)
            # Remove quotes and unescape the value.
            params[param_parts[0]] = urllib.unquote(param_parts[1].strip('\"'))
        return params
    _split_header = staticmethod(_split_header)

    def _split_url_string(param_str):
        """Turn URL string into parameters."""
        parameters = cgi.parse_qs(param_str, keep_blank_values=False)
        for k, v in parameters.iteritems():
            parameters[k] = urllib.unquote(v[0])
        return parameters
    _split_url_string = staticmethod(_split_url_string)

class OAuthServer(object):
    """A worker to check the validity of a request against a data store."""
    timestamp_threshold = 600 # In seconds, ten minutes.
    version = VERSION
    signature_methods = None
    data_store = None

    def __init__(self, data_store=None, signature_methods=None):
        self.data_store = data_store
        self.signature_methods = signature_methods or {}

    def set_data_store(self, data_store):
        self.data_store = data_store

    def get_data_store(self):
        return self.data_store

    def add_signature_method(self, signature_method):
        self.signature_methods[signature_method.get_name()] = signature_method
        return self.signature_methods

    def fetch_request_token(self, oauth_request):
        """Processes a request_token request and returns the
        request token on success.
        """
        try:
            # Get the request token for authorization.
            token = self._get_token(oauth_request, 'request')
        except OAuthError:
            # No token required for the initial token request.
            version = self._get_version(oauth_request)
            consumer = self._get_consumer(oauth_request)
            try:
                callback = self.get_callback(oauth_request)
            except OAuthError:
                callback = None # 1.0, no callback specified.
            self._check_signature(oauth_request, consumer, None)
            # Fetch a new token.
            token = self.data_store.fetch_request_token(consumer, callback)
        return token

    def fetch_access_token(self, oauth_request):
        """Processes an access_token request and returns the
        access token on success.
        """
        version = self._get_version(oauth_request)
        consumer = self._get_consumer(oauth_request)
        try:
            verifier = self._get_verifier(oauth_request)
        except OAuthError:
            verifier = None
        # Get the request token.
        token = self._get_token(oauth_request, 'request')
        self._check_signature(oauth_request, consumer, token)
        new_token = self.data_store.fetch_access_token(consumer, token, verifier)
        return new_token

    def verify_request(self, oauth_request):
        """Verifies an api call and checks all the parameters."""
        # -> consumer and token
        version = self._get_version(oauth_request)
        consumer = self._get_consumer(oauth_request)
        # Get the access token.
        token = self._get_token(oauth_request, 'access')
        self._check_signature(oauth_request, consumer, token)
        parameters = oauth_request.get_nonoauth_parameters()
        return consumer, token, parameters

    def authorize_token(self, token, user):
        """Authorize a request token."""
        return self.data_store.authorize_request_token(token, user)

    def get_callback(self, oauth_request):
        """Get the callback URL."""
        return oauth_request.get_parameter('oauth_callback')
 
    def build_authenticate_header(self, realm=''):
        """Optional support for the authenticate header."""
        return {'WWW-Authenticate': 'OAuth realm="%s"' % realm}

    def _get_version(self, oauth_request):
        """Verify the correct version request for this server."""
        try:
            version = oauth_request.get_parameter('oauth_version')
        except:
            version = VERSION
        if version and version != self.version:
            raise OAuthError('OAuth version %s not supported.' % str(version))
        return version

    def _get_signature_method(self, oauth_request):
        """Figure out the signature with some defaults."""
        try:
            signature_method = oauth_request.get_parameter(
                'oauth_signature_method')
        except:
            signature_method = SIGNATURE_METHOD
        try:
            # Get the signature method object.
            signature_method = self.signature_methods[signature_method]
        except:
            signature_method_names = ', '.join(self.signature_methods.keys())
            raise OAuthError('Signature method %s not supported try one of the '
                'following: %s' % (signature_method, signature_method_names))

        return signature_method

    def _get_consumer(self, oauth_request):
        consumer_key = oauth_request.get_parameter('oauth_consumer_key')
        consumer = self.data_store.lookup_consumer(consumer_key)
        if not consumer:
            raise OAuthError('Invalid consumer.')
        return consumer

    def _get_token(self, oauth_request, token_type='access'):
        """Try to find the token for the provided request token key."""
        token_field = oauth_request.get_parameter('oauth_token')
        token = self.data_store.lookup_token(token_type, token_field)
        if not token:
            raise OAuthError('Invalid %s token: %s' % (token_type, token_field))
        return token
    
    def _get_verifier(self, oauth_request):
        return oauth_request.get_parameter('oauth_verifier')

    def _check_signature(self, oauth_request, consumer, token):
        timestamp, nonce = oauth_request._get_timestamp_nonce()
        self._check_timestamp(timestamp)
        self._check_nonce(consumer, token, nonce)
        signature_method = self._get_signature_method(oauth_request)
        try:
            signature = oauth_request.get_parameter('oauth_signature')
        except:
            raise OAuthError('Missing signature.')
        # Validate the signature.
        valid_sig = signature_method.check_signature(oauth_request, consumer,
            token, signature)
        if not valid_sig:
            key, base = signature_method.build_signature_base_string(
                oauth_request, consumer, token)
            raise OAuthError('Invalid signature. Expected signature base '
                'string: %s' % base)
        built = signature_method.build_signature(oauth_request, consumer, token)

    def _check_timestamp(self, timestamp):
        """Verify that timestamp is recentish."""
        timestamp = int(timestamp)
        now = int(time.time())
        lapsed = now - timestamp
        if lapsed > self.timestamp_threshold:
            raise OAuthError('Expired timestamp: given %d and now %s has a '
                'greater difference than threshold %d' %
                (timestamp, now, self.timestamp_threshold))

    def _check_nonce(self, consumer, token, nonce):
        """Verify that the nonce is uniqueish."""
        nonce = self.data_store.lookup_nonce(consumer, token, nonce)
        if nonce:
            raise OAuthError('Nonce already used: %s' % str(nonce))


class OAuthClient(object):
    """OAuthClient is a worker to attempt to execute a request."""
    consumer = None
    token = None

    def __init__(self, oauth_consumer, oauth_token):
        self.consumer = oauth_consumer
        self.token = oauth_token

    def get_consumer(self):
        return self.consumer

    def get_token(self):
        return self.token

    def fetch_request_token(self, oauth_request):
        """-> OAuthToken."""
        raise NotImplementedError

    def fetch_access_token(self, oauth_request):
        """-> OAuthToken."""
        raise NotImplementedError

    def access_resource(self, oauth_request):
        """-> Some protected resource."""
        raise NotImplementedError


class OAuthDataStore(object):
    """A database abstraction used to lookup consumers and tokens."""

    def lookup_consumer(self, key):
        """-> OAuthConsumer."""
        raise NotImplementedError

    def lookup_token(self, oauth_consumer, token_type, token_token):
        """-> OAuthToken."""
        raise NotImplementedError

    def lookup_nonce(self, oauth_consumer, oauth_token, nonce):
        """-> OAuthToken."""
        raise NotImplementedError

    def fetch_request_token(self, oauth_consumer, oauth_callback):
        """-> OAuthToken."""
        raise NotImplementedError

    def fetch_access_token(self, oauth_consumer, oauth_token, oauth_verifier):
        """-> OAuthToken."""
        raise NotImplementedError

    def authorize_request_token(self, oauth_token, user):
        """-> OAuthToken."""
        raise NotImplementedError


class OAuthSignatureMethod(object):
    """A strategy class that implements a signature method."""
    def get_name(self):
        """-> str."""
        raise NotImplementedError

    def build_signature_base_string(self, oauth_request, oauth_consumer, oauth_token):
        """-> str key, str raw."""
        raise NotImplementedError

    def build_signature(self, oauth_request, oauth_consumer, oauth_token):
        """-> str."""
        raise NotImplementedError

    def check_signature(self, oauth_request, consumer, token, signature):
        built = self.build_signature(oauth_request, consumer, token)
        return built == signature


class OAuthSignatureMethod_HMAC_SHA1(OAuthSignatureMethod):

    def get_name(self):
        return 'HMAC-SHA1'
        
    def build_signature_base_string(self, oauth_request, consumer, token):
        sig = (
            escape(oauth_request.get_normalized_http_method()),
            escape(oauth_request.get_normalized_http_url()),
            escape(oauth_request.get_normalized_parameters()),
        )
        key = '%s&' % escape(consumer.secret)
        if token:
            key += escape(token.secret)
        raw = '&'.join(sig)
        return key, raw

    def build_signature(self, oauth_request, consumer, token):
        """Builds the base signature string."""
        key, raw = self.build_signature_base_string(oauth_request, consumer,
            token)

        # HMAC object.
        try:
            import hashlib # 2.5
            hashed = hmac.new(key, raw, hashlib.sha1)
        except:
            import sha # Deprecated
            hashed = hmac.new(key, raw, sha)
        
        # Calculate the digest base 64.
        return binascii.b2a_base64(hashed.digest())[:-1]


class OAuthSignatureMethod_PLAINTEXT(OAuthSignatureMethod):

    def get_name(self):
        return 'PLAINTEXT'

    def build_signature_base_string(self, oauth_request, consumer, token):
        """Concatenates the consumer key and secret."""
        sig = '%s&' % escape(consumer.secret)
        if token:
            sig = sig + escape(token.secret)
        return sig, sig

    def build_signature(self, oauth_request, consumer, token):
        key, raw = self.build_signature_base_string(oauth_request, consumer,
            token)
        return key
########NEW FILE########
__FILENAME__ = routers

class OAuthRouter(object):
    """
    A router to control all database operations on models in the
    oauth application.
    """
    def db_for_read(self, model, **hints):
        """
        Attempts to read auth models go to oauth_db.
        """
        if model._meta.app_label == 'oauth_db':
            return 'oauth_db'
        return None

    def db_for_write(self, model, **hints):
        """
        Attempts to write auth models go to oauth_db.
        """
        if model._meta.app_label == 'oauth_db':
            return 'oauth_db'
        return None

    def allow_relation(self, obj1, obj2, **hints):
        """
        Allow relations if a model in the oauth app is involved.
        """
        if obj1._meta.app_label == 'oauth_db' or \
           obj2._meta.app_label == 'oauth_db':
           return True
        return None

    def allow_syncdb(self, db, model):
        """
        Make sure the lrs app only appears in the oauth_db
        database.
        """
        if db == 'oauth_db':
            print 'model' + str(model)
            print 'label' + str(model._meta.app_label)
            return model._meta.app_label == 'oauth_db'
        elif model._meta.app_label != 'oauth_db':
            return False
        return None
########NEW FILE########
__FILENAME__ = stores
from urlparse import urlparse

from oauth.oauth import OAuthDataStore, OAuthError, escape

from django.conf import settings

from lrs.models import Nonce, Token, Consumer, generate_random
from consts import VERIFIER_SIZE, MAX_URL_LENGTH, OUT_OF_BAND

OAUTH_BLACKLISTED_HOSTNAMES = getattr(settings, 'OAUTH_BLACKLISTED_HOSTNAMES', [])
OAUTH_SCOPES = ["statements/write", "statements/read/mine", "statements/read", "state", "define",
                "profile", "all/read", "all"]

class DataStore(OAuthDataStore):
    """Layer between Python OAuth and Django database."""
    def __init__(self, oauth_request):
        self.signature = oauth_request.parameters.get('oauth_signature', None)
        self.timestamp = oauth_request.parameters.get('oauth_timestamp', None)
        # tom c 
        # changed default scope to s/w & s/r/m
        self.scope = oauth_request.parameters.get('scope', None)

    def lookup_consumer(self, key):
        try:
            self.consumer = Consumer.objects.get(key=key)
            return self.consumer
        except Consumer.DoesNotExist:
            return None

    def lookup_token(self, token_type, token):
        if token_type == 'request':
            token_type = Token.REQUEST
        elif token_type == 'access':
            token_type = Token.ACCESS
        try:
            self.request_token = Token.objects.get(key=token, 
                                                   token_type=token_type)
            return self.request_token
        except Token.DoesNotExist:
            return None

    def lookup_nonce(self, oauth_consumer, oauth_token, nonce):
        if oauth_token is None:
            return None
        nonce, created = Nonce.objects.get_or_create(consumer_key=oauth_consumer.key, 
                                                     token_key=oauth_token.key,
                                                     key=nonce)
        if created:
            return None
        else:
            return nonce.key

    def fetch_request_token(self, oauth_consumer, oauth_callback):
        if oauth_consumer.key != self.consumer.key:
            raise OAuthError('Consumer key does not match.')
        
        # OAuth 1.0a: if there is a callback, check its validity
        callback = None
        # tom c changed... call back confirmed is supposed to be true
        # callback_confirmed = False
        callback_confirmed = True
        
        if oauth_callback:
            if oauth_callback != OUT_OF_BAND:
                if check_valid_callback(oauth_callback):
                    callback = oauth_callback
                else:
                    # tom c
                    callback_confirmed = False
                    raise OAuthError('Invalid callback URL.')

        # tom c - changed... Resource used to represent a specific scope
        # with xapi scopes could be many.. using resource as a holder of
        # many scopes
        if self.scope:
            scope = self.scope
        else:
            scope = self.consumer.default_scopes
                
        # lou w - Make sure a valid scope(s) is supplied
        scope_list = scope.split(",")
        for x in scope_list:
            if not x in OAUTH_SCOPES:
                raise OAuthError('Resource %s is not allowed.' % escape(self.scope))

        # lou w - save as scope instead of resource
        self.request_token = Token.objects.create_token(consumer=self.consumer,
                                                        token_type=Token.REQUEST,
                                                        timestamp=self.timestamp,
                                                        scope=scope,
                                                        callback=callback,
                                                        callback_confirmed=callback_confirmed)
        
        return self.request_token
        

    def fetch_access_token(self, oauth_consumer, oauth_token, oauth_verifier):
        # lou w - save scope from token scope instead of resource
        if oauth_consumer.key == self.consumer.key \
        and oauth_token.key == self.request_token.key \
        and self.request_token.is_approved:
            # OAuth 1.0a: if there is a callback confirmed, check the verifier
            if (self.request_token.callback_confirmed \
            and oauth_verifier == self.request_token.verifier) \
            or not self.request_token.callback_confirmed:
                self.access_token = Token.objects.create_token(consumer=self.consumer,
                                                               token_type=Token.ACCESS,
                                                               timestamp=self.timestamp,
                                                               user=self.request_token.user,
                                                               scope=self.request_token.scope)
                # tom c says access tokens start as approved
                self.access_token.is_approved = True
                self.access_token.save()
                return self.access_token
        raise OAuthError('Consumer key or token key does not match. ' \
                        +'Make sure your request token is approved. ' \
                        +'Check your verifier too if you use OAuth 1.0a.')

    def authorize_request_token(self, oauth_token, user):
        if oauth_token.key == self.request_token.key:
            # authorize the request token in the store
            self.request_token.is_approved = True
            self.request_token.save()
            # OAuth 1.0a: if there is a callback confirmed, we must set a verifier
            if self.request_token.callback_confirmed:
                self.request_token.verifier = generate_random(VERIFIER_SIZE)
            
            self.request_token.user = user
            self.request_token.save()
            return self.request_token
        raise OAuthError('Token key or lrs_auth_id does not match.')


def check_valid_callback(callback):
    """
    Checks the size and nature of the callback.
    """
    callback_url = urlparse(callback)
    return (callback_url.scheme
            and callback_url.hostname not in OAUTH_BLACKLISTED_HOSTNAMES
            and len(callback) < MAX_URL_LENGTH)

########NEW FILE########
__FILENAME__ = tests
"""
=====================
Django OAuth provider
=====================

The `OAuth protocol`_ enables websites or applications (Consumers) to access 
Protected Resources from a web service (Service Provider) via an API, without 
requiring Users to disclose their Service Provider credentials to the 
Consumers. More generally, OAuth creates a freely-implementable and generic 
methodology for API authentication.

.. _`OAuth protocol`: http://oauth.net/core/1.0a


Authenticating with OAuth
=========================

OAuth authentication is the process in which Users grant access to their 
Protected Resources without sharing their credentials with the Consumer. 
OAuth uses Tokens generated by the Service Provider instead of the User's 
credentials in Protected Resources requests. The process uses two Token types:

    * **Request Token:**
      Used by the Consumer to ask the User to authorize access to the 
      Protected Resources. The User-authorized Request Token is exchanged for 
      an Access Token, MUST only be used once, and MUST NOT be used for any 
      other purpose. It is RECOMMENDED that Request Tokens have a limited 
      lifetime.
    * **Access Token:**
      Used by the Consumer to access the Protected Resources on behalf of the 
      User. Access Tokens MAY limit access to certain Protected Resources, and 
      MAY have a limited lifetime. Service Providers SHOULD allow Users to 
      revoke Access Tokens. Only the Access Token SHALL be used to access the 
      Protect Resources.

OAuth Authentication is done in three steps:

    * The Consumer obtains an unauthorized Request Token.
    * The User authorizes the Request Token.
    * The Consumer exchanges the Request Token for an Access Token.

See the `OAuth Authentication Flow`_ if you need visual details.

.. _`OAuth Authentication Flow`: http://oauth.net/core/diagram.png


Django installation
===================

There are a few steps for setting up a proper installation. The `OAuth Python
library`_ is required and must be patched (at least for the moment).

.. _`OAuth Python library`: http://oauth.googlecode.com/svn/code/python/oauth/

You can find a custom version of the module at the root level of django-oauth.

You need to specify the OAuth provider application in your settings and to 
sync your database thanks to the ``syncdb`` command. Then add it to your 
URLs::

    # urls.py
    urlpatterns = patterns('',
        url(r'^oauth/', include('oauth_provider.urls'))
    )

.. note::
    The ``oauth`` prefix is not required, you can specify whatever you want.

As a provider, you probably need to customize the view you display to the user
in order to allow access. The ``OAUTH_AUTHORIZE_VIEW`` setting allow you to
specify this view, for instance::

    # settings.py
    OAUTH_AUTHORIZE_VIEW = 'myapp.views.oauth_authorize'

.. note::
    See example below with a custom callback view (optional), which depends on
    ``OAUTH_CALLBACK_VIEW`` setting.

.. note::
    This implementation set an ``oauth`` flag in session which certify that 
    the validation had been done by the current user. Otherwise, the external 
    service can directly POST the validation argument and validate the token 
    without any action from the user if he is already logged in. Do not delete
    it in your own view.

There is another setting dedicated to OAuth ``OAUTH_REALM_KEY_NAME``, which
allows you to specify a realm which will be used in headers::

    # settings.py
    OAUTH_REALM_KEY_NAME = 'http://photos.example.net'
    
    # response
    WWW-Authenticate: OAuth realm="http://photos.example.net/"

With this setup, your OAuth URLs will be:

    * Request Token URL: /oauth/request_token/
    * User Authorization URL: /oauth/authorize/, using HTTP GET.
    * Access Token URL: /oauth/access_token/

That is the only thing you need to document for external developers.

.. note::
    You can customize the length of your key/secret attributes with 
    constants ``KEY_SIZE``, ``SECRET_SIZE`` and ``CONSUMER_KEY_SIZE`` defined 
    in consts.py. Default is set to 16 characters for ``KEY_SIZE`` and 
    ``SECRET_SIZE`` and 256 characters for ``CONSUMER_KEY_SIZE``.

The ``OAUTH_BLACKLISTED_HOSTNAMES`` setting allows you to restrict callback
URL hostnames, it must be a list of blacklisted ones. For example::

    OAUTH_BLACKLISTED_HOSTNAMES = ['localhost', '127.0.0.1']

Default is an empty list.

The ``OAUTH_SIGNATURE_METHODS`` setting allows you to restrict signatures'
methods you'd like to use. For example if you don't want plaintext signature::

    OAUTH_SIGNATURE_METHODS = ['hmac-sha1',]

Default is ``['plaintext', 'hmac-sha1']``.

A complete example is available in ``oauth_examples/provider/`` folder, you
can run tests from this example with this command::

    $ python manage.py test oauth_provider
    ...
    Ran 1 test in 0.264s
    
    OK
    ...


Protocol Example 1.0
====================

.. warning::
    DUE TO THE SECURITY ISSUE, THIS EXAMPLE IS NOT THE RECOMMENDED WAY ANYMORE.
    SEE BELOW FOR A MORE ROBUST EXAMPLE WHICH IS 1.0a COMPLIANT.

In this example, the Service Provider photos.example.net is a photo sharing 
website, and the Consumer printer.example.com is a photo printing website. 
Jane, the User, would like printer.example.com to print the private photo 
vacation.jpg stored at photos.example.net.

When Jane signs-into photos.example.net using her username and password, she 
can access the photo by going to the URL 
http://photos.example.net/photo?file=vacation.jpg. Other Users cannot access 
that photo, and Jane does not want to share her username and password with 
printer.example.com.

The requests in this example use the URL query method when sending parameters. 
This is done to simplify the example and should not be taken as an endorsement 
of one method over the others.

An account for Jane is necessary::

    >>> from django.contrib.auth.models import User
    >>> jane = User.objects.create_user('jane', 'jane@example.com', 'toto')


Documentation and Registration
------------------------------

The Service Provider documentation explains how to register for a Consumer Key 
and Consumer Secret, and declares the following URLs:

    * Request Token URL:
      http://photos.example.net/request_token, using HTTP POST
    * User Authorization URL:
      http://photos.example.net/authorize, using HTTP GET
    * Access Token URL:
      http://photos.example.net/access_token, using HTTP POST
    * Photo (Protected Resource) URL:
      http://photos.example.net/photo with required parameter file and 
      optional parameter size

The Service Provider declares support for the HMAC-SHA1 signature method for 
all requests, and PLAINTEXT only for secure (HTTPS) requests.

The Consumer printer.example.com already established a Consumer Key and 
Consumer Secret with photos.example.net and advertizes its printing services 
for photos stored on photos.example.net. The Consumer registration is:

    * Consumer Key: dpf43f3p2l4k3l03
    * Consumer Secret: kd94hf93k423kf44

We need to create the Protected Resource and the Consumer first::

    >>> from oauth_provider.models import Resource, Consumer
    >>> resource = Resource(name='photos', url='/oauth/photo/')
    >>> resource.save()
    >>> CONSUMER_KEY = 'dpf43f3p2l4k3l03'
    >>> CONSUMER_SECRET = 'kd94hf93k423kf44'
    >>> consumer = Consumer(key=CONSUMER_KEY, secret=CONSUMER_SECRET, 
    ...                     name='printer.example.com', user=jane)
    >>> consumer.save()


Obtaining a Request Token
-------------------------

After Jane informs printer.example.com that she would like to print her 
vacation photo stored at photos.example.net, the printer website tries to 
access the photo and receives HTTP 401 Unauthorized indicating it is private. 
The Service Provider includes the following header with the response::

    >>> from django.test.client import Client
    >>> c = Client()
    >>> response = c.get("/oauth/request_token/")
    >>> response.status_code
    401
    >>> # depends on REALM_KEY_NAME Django setting
    >>> response._headers['www-authenticate']
    ('WWW-Authenticate', 'OAuth realm=""')
    >>> response.content
    'Invalid request parameters.'

The Consumer sends the following HTTP POST request to the Service Provider::

    >>> import time
    >>> parameters = {
    ...     'oauth_consumer_key': CONSUMER_KEY,
    ...     'oauth_signature_method': 'PLAINTEXT',
    ...     'oauth_signature': '%s&' % CONSUMER_SECRET,
    ...     'oauth_timestamp': str(int(time.time())),
    ...     'oauth_nonce': 'requestnonce',
    ...     'oauth_version': '1.0',
    ...     'scope': 'photos', # custom argument to specify Protected Resource
    ... }
    >>> response = c.get("/oauth/request_token/", parameters)

The Service Provider checks the signature and replies with an unauthorized 
Request Token in the body of the HTTP response::

    >>> response.status_code
    200
    >>> response.content
    'oauth_token_secret=...&oauth_token=...'
    >>> from oauth_provider.models import Token
    >>> token = list(Token.objects.all())[-1]
    >>> token.key in response.content, token.secret in response.content
    (True, True)

If you try to access a resource with a wrong scope, it will return an error::

    >>> parameters['scope'] = 'videos'
    >>> response = c.get("/oauth/request_token/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Resource videos does not exist.'


Requesting User Authorization
-----------------------------

The Consumer redirects Jane's browser to the Service Provider User 
Authorization URL to obtain Jane's approval for accessing her private photos.

The Service Provider asks Jane to sign-in using her username and password::

    >>> parameters = {
    ...     'oauth_token': token.key,
    ...     'oauth_callback': 'http://printer.example.com/request_token_ready',
    ... }
    >>> response = c.get("/oauth/authorize/", parameters)
    >>> response.status_code
    302
    >>> response['Location']
    'http://.../accounts/login/?next=/oauth/authorize/%3Foauth_token%3D...%26oauth_callback%3Dhttp...'
    >>> token.key in response['Location']
    True
    
If successful, asks her if she approves granting printer.example.com access to 
her private photos. If Jane approves the request, the Service Provider 
redirects her back to the Consumer's callback URL::

    >>> c.login(username='jane', password='toto')
    True
    >>> token.is_approved
    0
    >>> response = c.get("/oauth/authorize/", parameters)
    >>> response.status_code
    200
    >>> response.content
    'Fake authorize view for printer.example.com.'
    
    >>> # fake authorization by the user
    >>> parameters['authorize_access'] = 1
    >>> response = c.post("/oauth/authorize/", parameters)#, content_type="application/x-www-form-urlencoded")
    >>> response.status_code
    302
    >>> response['Location']
    'http://printer.example.com/request_token_ready?oauth_token=...'
    >>> token = list(Token.objects.all())[-1]
    >>> token.key in response['Location']
    True
    >>> token.is_approved
    1
    
    >>> # without session parameter (previous POST removed it)
    >>> response = c.post("/oauth/authorize/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Action not allowed.'
    
    >>> # fake access not granted by the user (set session parameter again)
    >>> response = c.get("/oauth/authorize/", parameters)
    >>> parameters['authorize_access'] = 0
    >>> response = c.post("/oauth/authorize/", parameters)
    >>> response.status_code
    302
    >>> response['Location']
    'http://printer.example.com/request_token_ready?error=Access%20not%20granted%20by%20user.'
    >>> c.logout()

The callback argument is optional, you can specify your own default callback
view with ``OAUTH_CALLBACK_VIEW`` setting::

    >>> parameters = {
    ...     'oauth_token': token.key,
    ... }
    >>> c.login(username='jane', password='toto')
    True
    >>> response = c.get("/oauth/authorize/", parameters)
    >>> parameters['authorize_access'] = 0
    >>> response = c.post("/oauth/authorize/", parameters)
    >>> response.status_code
    200
    >>> response.content
    'Fake callback view.'
    >>> c.logout()


Obtaining an Access Token
-------------------------

Now that the Consumer knows Jane approved the Request Token, it asks the 
Service Provider to exchange it for an Access Token::

    >>> c = Client()
    >>> parameters = {
    ...     'oauth_consumer_key': CONSUMER_KEY,
    ...     'oauth_token': token.key,
    ...     'oauth_signature_method': 'PLAINTEXT',
    ...     'oauth_signature': '%s&%s' % (CONSUMER_SECRET, token.secret),
    ...     'oauth_timestamp': str(int(time.time())),
    ...     'oauth_nonce': 'accessnonce',
    ...     'oauth_version': '1.0',
    ... }
    >>> response = c.get("/oauth/access_token/", parameters)

.. note::
    You can use HTTP Authorization header, if you provide both, header will be
    checked before parameters. It depends on your needs.

The Service Provider checks the signature and replies with an Access Token in 
the body of the HTTP response::

    >>> response.status_code
    200
    >>> response.content
    'oauth_token_secret=...&oauth_token=...'
    >>> access_token = list(Token.objects.filter(token_type=Token.ACCESS))[-1]
    >>> access_token.key in response.content
    True
    >>> access_token.secret in response.content
    True
    >>> access_token.user.username
    u'jane'

The Consumer will not be able to request another Access Token with the same
Nonce::

    >>> from oauth_provider.models import Nonce
    >>> Nonce.objects.all()
    [<Nonce: Nonce accessnonce for ...>]
    >>> response = c.get("/oauth/access_token/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Nonce already used: accessnonce'

The Consumer will not be able to request an Access Token if the token is not
approved::

    >>> parameters['oauth_nonce'] = 'anotheraccessnonce'
    >>> token.is_approved = False
    >>> token.save()
    >>> response = c.get("/oauth/access_token/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Consumer key or token key does not match. Make sure your request token is approved. Check your verifier too if you use OAuth 1.0a.'


Accessing Protected Resources
-----------------------------

The Consumer is now ready to request the private photo. Since the photo URL is 
not secure (HTTP), it must use HMAC-SHA1.

Generating Signature Base String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To generate the signature, it first needs to generate the Signature Base 
String. The request contains the following parameters (oauth_signature 
excluded) which are ordered and concatenated into a normalized string::

    >>> parameters = {
    ...     'oauth_consumer_key': CONSUMER_KEY,
    ...     'oauth_token': access_token.key,
    ...     'oauth_signature_method': 'HMAC-SHA1',
    ...     'oauth_timestamp': str(int(time.time())),
    ...     'oauth_nonce': 'accessresourcenonce',
    ...     'oauth_version': '1.0',
    ... }


Calculating Signature Value
~~~~~~~~~~~~~~~~~~~~~~~~~~~

HMAC-SHA1 produces the following digest value as a base64-encoded string 
(using the Signature Base String as text and kd94hf93k423kf44&pfkkdhi9sl3r4s00 
as key)::

    >>> from oauth.oauth import OAuthRequest, OAuthSignatureMethod_HMAC_SHA1
    >>> oauth_request = OAuthRequest.from_token_and_callback(access_token,
    ...     http_url='http://testserver/oauth/photo/', parameters=parameters)
    >>> signature_method = OAuthSignatureMethod_HMAC_SHA1()
    >>> signature = signature_method.build_signature(oauth_request, consumer, 
    ...                                                 access_token)


Requesting Protected Resource
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All together, the Consumer request for the photo is::

    >>> parameters['oauth_signature'] = signature
    >>> response = c.get("/oauth/photo/", parameters)
    >>> response.status_code
    200
    >>> response.content
    'Protected Resource access!'

Otherwise, an explicit error will be raised::

    >>> parameters['oauth_signature'] = 'wrongsignature'
    >>> parameters['oauth_nonce'] = 'anotheraccessresourcenonce'
    >>> response = c.get("/oauth/photo/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Invalid signature. Expected signature base string: GET&http%3A%2F%2F...%2Foauth%2Fphoto%2F&oauth_...'

    >>> response = c.get("/oauth/photo/")
    >>> response.status_code
    401
    >>> response.content
    'Invalid request parameters.'


Revoking Access
---------------

If Jane deletes the Access Token of printer.example.com, the Consumer will not 
be able to access the Protected Resource anymore::

    >>> access_token.delete()
    >>> # Note that an "Invalid signature" error will be raised here if the
    >>> # token is not revoked by Jane because we reuse a previously used one.
    >>> parameters['oauth_signature'] = signature
    >>> parameters['oauth_nonce'] = 'yetanotheraccessresourcenonce'
    >>> response = c.get("/oauth/photo/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Invalid access token: ...'


Clean up
--------

Remove created models' instances to be able to launch 1.0a tests just below::

    >>> Token.objects.all().delete()
    >>> Resource.objects.all().delete()
    >>> Consumer.objects.all().delete()
    >>> Nonce.objects.all().delete()
    >>> User.objects.all().delete()







Protocol Example 1.0a
=====================

.. warning::
    THIS IS THE RECOMMENDED WAY TO USE THIS APPLICATION.

This example is exactly the same as 1.0 except it uses newly introduced
arguments to be 1.0a compatible and fix the security issue.

An account for Jane is necessary::

    >>> from django.contrib.auth.models import User
    >>> jane = User.objects.create_user('jane', 'jane@example.com', 'toto')


Documentation and Registration
------------------------------

The Service Provider documentation explains how to register for a Consumer Key 
and Consumer Secret, and declares the following URLs:

    * Request Token URL:
      http://photos.example.net/request_token, using HTTP POST
    * User Authorization URL:
      http://photos.example.net/authorize, using HTTP GET
    * Access Token URL:
      http://photos.example.net/access_token, using HTTP POST
    * Photo (Protected Resource) URL:
      http://photos.example.net/photo with required parameter file and 
      optional parameter size

The Service Provider declares support for the HMAC-SHA1 signature method for 
all requests, and PLAINTEXT only for secure (HTTPS) requests.

The Consumer printer.example.com already established a Consumer Key and 
Consumer Secret with photos.example.net and advertizes its printing services 
for photos stored on photos.example.net. The Consumer registration is:

    * Consumer Key: dpf43f3p2l4k3l03
    * Consumer Secret: kd94hf93k423kf44

We need to create the Protected Resource and the Consumer first::

    >>> from oauth_provider.models import Resource, Consumer
    >>> resource = Resource(name='photos', url='/oauth/photo/')
    >>> resource.save()
    >>> CONSUMER_KEY = 'dpf43f3p2l4k3l03'
    >>> CONSUMER_SECRET = 'kd94hf93k423kf44'
    >>> consumer = Consumer(key=CONSUMER_KEY, secret=CONSUMER_SECRET, 
    ...                     name='printer.example.com', user=jane)
    >>> consumer.save()


Obtaining a Request Token
-------------------------

After Jane informs printer.example.com that she would like to print her 
vacation photo stored at photos.example.net, the printer website tries to 
access the photo and receives HTTP 401 Unauthorized indicating it is private. 
The Service Provider includes the following header with the response::

    >>> from django.test.client import Client
    >>> c = Client()
    >>> response = c.get("/oauth/request_token/")
    >>> response.status_code
    401
    >>> # depends on REALM_KEY_NAME Django setting
    >>> response._headers['www-authenticate']
    ('WWW-Authenticate', 'OAuth realm=""')
    >>> response.content
    'Invalid request parameters.'

The Consumer sends the following HTTP POST request to the Service Provider::

    >>> import time
    >>> parameters = {
    ...     'oauth_consumer_key': CONSUMER_KEY,
    ...     'oauth_signature_method': 'PLAINTEXT',
    ...     'oauth_signature': '%s&' % CONSUMER_SECRET,
    ...     'oauth_timestamp': str(int(time.time())),
    ...     'oauth_nonce': 'requestnonce',
    ...     'oauth_version': '1.0',
    ...     'oauth_callback': 'http://printer.example.com/request_token_ready',
    ...     'scope': 'photos', # custom argument to specify Protected Resource
    ... }
    >>> response = c.get("/oauth/request_token/", parameters)

The Service Provider checks the signature and replies with an unauthorized 
Request Token in the body of the HTTP response::

    >>> response.status_code
    200
    >>> response.content
    'oauth_token_secret=...&oauth_token=...&oauth_callback_confirmed=true'
    >>> from oauth_provider.models import Token
    >>> token = list(Token.objects.all())[-1]
    >>> token.key in response.content, token.secret in response.content
    (True, True)
    >>> token.callback, token.callback_confirmed
    (u'http://printer.example.com/request_token_ready', True)

If you try to access a resource with a wrong scope, it will return an error::

    >>> parameters['scope'] = 'videos'
    >>> response = c.get("/oauth/request_token/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Resource videos does not exist.'
    >>> parameters['scope'] = 'photos' # restore

If you try to put a wrong callback, it will return an error::

    >>> parameters['oauth_callback'] = 'wrongcallback'
    >>> response = c.get("/oauth/request_token/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Invalid callback URL.'


Requesting User Authorization
-----------------------------

The Consumer redirects Jane's browser to the Service Provider User 
Authorization URL to obtain Jane's approval for accessing her private photos.

The Service Provider asks Jane to sign-in using her username and password::

    >>> parameters = {
    ...     'oauth_token': token.key,
    ... }
    >>> response = c.get("/oauth/authorize/", parameters)
    >>> response.status_code
    302
    >>> response['Location']
    'http://.../accounts/login/?next=/oauth/authorize/%3Foauth_token%3D...'
    >>> token.key in response['Location']
    True

If successful, asks her if she approves granting printer.example.com access to 
her private photos. If Jane approves the request, the Service Provider 
redirects her back to the Consumer's callback URL::

    >>> c.login(username='jane', password='toto')
    True
    >>> token.is_approved
    0
    >>> response = c.get("/oauth/authorize/", parameters)
    >>> response.status_code
    200
    >>> response.content
    'Fake authorize view for printer.example.com.'
    
    >>> # fake authorization by the user
    >>> parameters['authorize_access'] = 1
    >>> response = c.post("/oauth/authorize/", parameters)
    >>> response.status_code
    302
    >>> response['Location']
    'http://printer.example.com/request_token_ready?oauth_verifier=...&oauth_token=...'
    >>> token = list(Token.objects.all())[-1]
    >>> token.key in response['Location']
    True
    >>> token.is_approved
    1

    >>> # without session parameter (previous POST removed it)
    >>> response = c.post("/oauth/authorize/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Action not allowed.'
    
    >>> # fake access not granted by the user (set session parameter again)
    >>> response = c.get("/oauth/authorize/", parameters)
    >>> parameters['authorize_access'] = 0
    >>> response = c.post("/oauth/authorize/", parameters)
    >>> response.status_code
    302
    >>> response['Location']
    'http://printer.example.com/request_token_ready?error=Access%20not%20granted%20by%20user.'
    >>> c.logout()

With OAuth 1.0a, the callback argument can be set to "oob" (out-of-band), 
you can specify your own default callback view with the
``OAUTH_CALLBACK_VIEW`` setting::

    >>> from oauth_provider.consts import OUT_OF_BAND
    >>> token.callback = OUT_OF_BAND
    >>> token.save()
    >>> parameters = {
    ...     'oauth_token': token.key,
    ... }
    >>> c.login(username='jane', password='toto')
    True
    >>> response = c.get("/oauth/authorize/", parameters)
    >>> parameters['authorize_access'] = 0
    >>> response = c.post("/oauth/authorize/", parameters)
    >>> response.status_code
    200
    >>> response.content
    'Fake callback view.'
    >>> c.logout()


Obtaining an Access Token
-------------------------

Now that the Consumer knows Jane approved the Request Token, it asks the 
Service Provider to exchange it for an Access Token::

    >>> c = Client()
    >>> parameters = {
    ...     'oauth_consumer_key': CONSUMER_KEY,
    ...     'oauth_token': token.key,
    ...     'oauth_signature_method': 'PLAINTEXT',
    ...     'oauth_signature': '%s&%s' % (CONSUMER_SECRET, token.secret),
    ...     'oauth_timestamp': str(int(time.time())),
    ...     'oauth_nonce': 'accessnonce',
    ...     'oauth_version': '1.0',
    ...     'oauth_verifier': token.verifier,
    ... }
    >>> response = c.get("/oauth/access_token/", parameters)

.. note::
    You can use HTTP Authorization header, if you provide both, header will be
    checked before parameters. It depends on your needs.

The Service Provider checks the signature and replies with an Access Token in 
the body of the HTTP response::

    >>> response.status_code
    200
    >>> response.content
    'oauth_token_secret=...&oauth_token=...'
    >>> access_token = list(Token.objects.filter(token_type=Token.ACCESS))[-1]
    >>> access_token.key in response.content
    True
    >>> access_token.secret in response.content
    True
    >>> access_token.user.username
    u'jane'

The Consumer will not be able to request another Access Token with the same
Nonce::

    >>> from oauth_provider.models import Nonce
    >>> Nonce.objects.all()
    [<Nonce: Nonce accessnonce for ...>]
    >>> response = c.get("/oauth/access_token/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Nonce already used: accessnonce'

Nor with a missing/invalid verifier::

    >>> parameters['oauth_nonce'] = 'yetanotheraccessnonce'
    >>> parameters['oauth_verifier'] = 'invalidverifier'
    >>> response = c.get("/oauth/access_token/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Consumer key or token key does not match. Make sure your request token is approved. Check your verifier too if you use OAuth 1.0a.'
    >>> parameters['oauth_verifier'] = token.verifier # restore

The Consumer will not be able to request an Access Token if the token is not
approved::

    >>> parameters['oauth_nonce'] = 'anotheraccessnonce'
    >>> token.is_approved = False
    >>> token.save()
    >>> response = c.get("/oauth/access_token/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Consumer key or token key does not match. Make sure your request token is approved. Check your verifier too if you use OAuth 1.0a.'


Accessing Protected Resources
-----------------------------

The Consumer is now ready to request the private photo. Since the photo URL is 
not secure (HTTP), it must use HMAC-SHA1.

Generating Signature Base String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To generate the signature, it first needs to generate the Signature Base 
String. The request contains the following parameters (oauth_signature 
excluded) which are ordered and concatenated into a normalized string::

    >>> parameters = {
    ...     'oauth_consumer_key': CONSUMER_KEY,
    ...     'oauth_token': access_token.key,
    ...     'oauth_signature_method': 'HMAC-SHA1',
    ...     'oauth_timestamp': str(int(time.time())),
    ...     'oauth_nonce': 'accessresourcenonce',
    ...     'oauth_version': '1.0',
    ... }


Calculating Signature Value
~~~~~~~~~~~~~~~~~~~~~~~~~~~

HMAC-SHA1 produces the following digest value as a base64-encoded string 
(using the Signature Base String as text and kd94hf93k423kf44&pfkkdhi9sl3r4s00 
as key)::

    >>> from oauth.oauth import OAuthRequest, OAuthSignatureMethod_HMAC_SHA1
    >>> oauth_request = OAuthRequest.from_token_and_callback(access_token,
    ...     http_url='http://testserver/oauth/photo/', parameters=parameters)
    >>> signature_method = OAuthSignatureMethod_HMAC_SHA1()
    >>> signature = signature_method.build_signature(oauth_request, consumer, 
    ...                                                 access_token)


Requesting Protected Resource
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All together, the Consumer request for the photo is::

    >>> parameters['oauth_signature'] = signature
    >>> response = c.get("/oauth/photo/", parameters)
    >>> response.status_code
    200
    >>> response.content
    'Protected Resource access!'

Otherwise, an explicit error will be raised::

    >>> parameters['oauth_signature'] = 'wrongsignature'
    >>> parameters['oauth_nonce'] = 'anotheraccessresourcenonce'
    >>> response = c.get("/oauth/photo/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Invalid signature. Expected signature base string: GET&http%3A%2F%2F...%2Foauth%2Fphoto%2F&oauth_...'

    >>> response = c.get("/oauth/photo/")
    >>> response.status_code
    401
    >>> response.content
    'Invalid request parameters.'


Revoking Access
---------------

If Jane deletes the Access Token of printer.example.com, the Consumer will not 
be able to access the Protected Resource anymore::

    >>> access_token.delete()
    >>> # Note that an "Invalid signature" error will be raised here if the
    >>> # token is not revoked by Jane because we reuse a previously used one.
    >>> parameters['oauth_signature'] = signature
    >>> parameters['oauth_nonce'] = 'yetanotheraccessresourcenonce'
    >>> response = c.get("/oauth/photo/", parameters)
    >>> response.status_code
    401
    >>> response.content
    'Invalid access token: ...'

"""
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import request_token, user_authorization, access_token, oauth_home

urlpatterns = patterns('',
	url(r'^$', oauth_home, name='oauth_home'),
    url(r'^initiate',    request_token,      name='oauth_request_token'),
    url(r'^authorize',        user_authorization, name='oauth_user_authorization'),
    url(r'^token',     access_token,       name='oauth_access_token'),
)

########NEW FILE########
__FILENAME__ = utils
from oauth.oauth import OAuthRequest, OAuthServer, build_authenticate_header,\
    OAuthSignatureMethod_PLAINTEXT, OAuthSignatureMethod_HMAC_SHA1

from django.conf import settings
from django.http import HttpResponse

from stores import DataStore
import ast

OAUTH_REALM_KEY_NAME = getattr(settings, 'OAUTH_REALM_KEY_NAME', '')
OAUTH_SIGNATURE_METHODS = getattr(settings, 'OAUTH_SIGNATURE_METHODS', ['plaintext', 'hmac-sha1'])

def initialize_server_request(request):
    """Shortcut for initialization."""
    # OAuth change
    # Django converts Authorization header in HTTP_AUTHORIZATION
    # Warning: it doesn't happen in tests but it's useful, do not remove!

    auth_header = {}
    if 'Authorization' in request.META:
        auth_header = {'Authorization': request.META['Authorization']}
    elif 'HTTP_AUTHORIZATION' in request.META:
        auth_header =  {'Authorization': request.META['HTTP_AUTHORIZATION']}
   
    # Don't include extra parameters when request.method is POST and 
    # request.MIME['CONTENT_TYPE'] is "application/x-www-form-urlencoded" 
    # (See http://oauth.net/core/1.0a/#consumer_req_param).
    # But there is an issue with Django's test Client and custom content types
    # so an ugly test is made here, if you find a better solution...
    parameters = {}        
    if request.method == "POST" and request.META.get('CONTENT_TYPE') != "application/json" \
        and (request.META.get('CONTENT_TYPE') == "application/x-www-form-urlencoded" \
            or request.META.get('SERVER_NAME') == 'testserver'):
        # lou -w -When POST statement data, the actual data is a dict key and has a value of ''
        # have to parse it out correctly...
        p = dict(request.REQUEST.items()) 
        if p.values()[0] == '':
            # literal eval is putting them in differnt order
            parameters = ast.literal_eval(p.keys()[0])
        else:
            parameters = p
            
    oauth_request = OAuthRequest.from_request(request.method, 
                                              request.build_absolute_uri(), 
                                              headers=auth_header,
                                              parameters=parameters,
                                              query_string=request.META.get('QUERY_STRING', ''))

    if oauth_request:
        oauth_server = OAuthServer(DataStore(oauth_request))
        if 'plaintext' in OAUTH_SIGNATURE_METHODS:
            oauth_server.add_signature_method(OAuthSignatureMethod_PLAINTEXT())
        if 'hmac-sha1' in OAUTH_SIGNATURE_METHODS:
            oauth_server.add_signature_method(OAuthSignatureMethod_HMAC_SHA1())
    else:
        oauth_server = None
    return oauth_server, oauth_request

def send_oauth_error(err=None):
    """Shortcut for sending an error."""
    # send a 401 error
    # lou w - be able to send plain error messages
    if isinstance(err, str):
        response = HttpResponse(err, mimetype="text/plain")
    else:
        response = HttpResponse(err.message.encode('utf-8'), mimetype="text/plain")
    response.status_code = 401
    # return the authenticate header
    header = build_authenticate_header(realm=OAUTH_REALM_KEY_NAME)
    for k, v in header.iteritems():
        response[k] = v
    return response

########NEW FILE########
__FILENAME__ = views
from oauth.oauth import OAuthError

from django.conf import settings
from django.http import (
    HttpResponse, HttpResponseBadRequest, HttpResponseRedirect, HttpResponseForbidden)
from django.utils.translation import ugettext as _
from django.contrib.auth.decorators import login_required
from django.core.urlresolvers import get_callable, reverse
from django.utils.decorators import decorator_from_middleware
from django.shortcuts import render_to_response

from django.template import RequestContext
from utils import initialize_server_request, send_oauth_error
from decorators import oauth_required
from stores import check_valid_callback
from consts import OUT_OF_BAND
from lrs.forms import AuthClientForm
from lrs.models import Token

OAUTH_AUTHORIZE_VIEW = 'OAUTH_AUTHORIZE_VIEW'
OAUTH_CALLBACK_VIEW = 'OAUTH_CALLBACK_VIEW'
INVALID_PARAMS_RESPONSE = send_oauth_error(OAuthError(
                                            _('Invalid request parameters.')))

def oauth_home(request):
    return HttpResponseRedirect(reverse('lrs.views.reg_client'))

def request_token(request):
    """
    The Consumer obtains an unauthorized Request Token by asking the Service 
    Provider to issue a Token. The Request Token's sole purpose is to receive 
    User approval and can only be used to obtain an Access Token.
    """
    # If oauth is not enabled, don't initiate the handshake
    if settings.OAUTH_ENABLED:
        oauth_server, oauth_request = initialize_server_request(request)
        if oauth_server is None:
            return INVALID_PARAMS_RESPONSE
        try:
            # create a request token
            token = oauth_server.fetch_request_token(oauth_request)
            # return the token
            response = HttpResponse(token.to_string(), mimetype="text/plain")
        except OAuthError, err:
            response = send_oauth_error(err)
        return response
    else:
        return HttpResponseBadRequest("OAuth is not enabled. To enable, set the OAUTH_ENABLED flag to true in settings")

# tom c added login_url
@login_required(login_url="/XAPI/accounts/login")
def user_authorization(request):
    """
    The Consumer cannot use the Request Token until it has been authorized by 
    the User.
    """
    oauth_server, oauth_request = initialize_server_request(request)
    if oauth_request is None:
        return INVALID_PARAMS_RESPONSE
    try:
        # get the request token
        token = oauth_server.fetch_request_token(oauth_request)
        # tom c .. we know user.. save it
        token.user = request.user
        token.save()
    except OAuthError, err:
        return send_oauth_error(err)

    try:
        # get the request callback, though there might not be one
        callback = oauth_server.get_callback(oauth_request)
        
        # OAuth 1.0a: this parameter should not be present on this version
        if token.callback_confirmed:
            return HttpResponseBadRequest("Cannot specify oauth_callback at authorization step for 1.0a protocol")
        if not check_valid_callback(callback):
            return HttpResponseBadRequest("Invalid callback URL")
    except OAuthError:
        callback = None

    # OAuth 1.0a: use the token's callback if confirmed
    if token.callback_confirmed:
        callback = token.callback
        if callback == OUT_OF_BAND:
            callback = None

    # entry point for the user
    if request.method == 'GET':
        # try to get custom authorize view
        authorize_view_str = getattr(settings, OAUTH_AUTHORIZE_VIEW, 
                                    'oauth_provider.views.fake_authorize_view')
        try:
            authorize_view = get_callable(authorize_view_str)
        except AttributeError:
            raise Exception, "%s view doesn't exist." % authorize_view_str
        params = oauth_request.get_normalized_parameters()
        # set the oauth flag
        request.session['oauth'] = token.key
        return authorize_view(request, token, callback, params)
    
    # user grant access to the service
    if request.method == 'POST':
        # verify the oauth flag set in previous GET
        if request.session.get('oauth', '') == token.key:
            request.session['oauth'] = ''
            try:
                form = AuthClientForm(request.POST)
                if form.is_valid():
                    if int(form.cleaned_data.get('authorize_access', 0)):
                        # authorize the token
                        token = oauth_server.authorize_token(token, request.user)
                        # return the token key
                        s = form.cleaned_data.get('scopes', '')
                        if isinstance(s, (list, tuple)):
                            s = ",".join([v.strip() for v in s])
                        # changed scope, gotta save
                        if s:
                            token.scope = s
                            token.save()
                        args = { 'token': token }
                    else:
                        args = { 'error': _('Access not granted by user.') }
                else:
                    # try to get custom authorize view
                    authorize_view_str = getattr(settings, OAUTH_AUTHORIZE_VIEW, 
                                                'oauth_provider.views.fake_authorize_view')
                    try:
                        authorize_view = get_callable(authorize_view_str)
                    except AttributeError:
                        raise Exception, "%s view doesn't exist." % authorize_view_str
                    params = oauth_request.get_normalized_parameters()
                    # set the oauth flag
                    request.session['oauth'] = token.key
                    return authorize_view(request, token, callback, params, form)
            except OAuthError, err:
                response = send_oauth_error(err)
            
            if callback:
                if "?" in callback:
                    url_delimiter = "&"
                else:
                    url_delimiter = "?"
                if 'token' in args:
                    query_args = args['token'].to_string(only_key=True)
                else: # access is not authorized i.e. error
                    query_args = 'error=%s' % args['error']
                response = HttpResponseRedirect('%s%s%s' % (callback, url_delimiter, query_args))
            else:
                # try to get custom callback view
                callback_view_str = getattr(settings, OAUTH_CALLBACK_VIEW, 
                                    'oauth_provider.views.fake_callback_view')
                try:
                    callback_view = get_callable(callback_view_str)
                except AttributeError:
                    raise Exception, "%s view doesn't exist." % callback_view_str
                response = callback_view(request, **args)
        else:
            response = send_oauth_error(OAuthError(_('Action not allowed.')))
        return response

def access_token(request):    
    """
    The Consumer exchanges the Request Token for an Access Token capable of 
    accessing the Protected Resources.
    """
    oauth_server, oauth_request = initialize_server_request(request)
    if oauth_request is None:
        return INVALID_PARAMS_RESPONSE
    try:
        # get the request token
        token = oauth_server.fetch_access_token(oauth_request)
        # return the token
        response = HttpResponse(token.to_string(), mimetype="text/plain")
    except OAuthError, err:
        response = send_oauth_error(err)
    return response

def authorize_client(request, token=None, callback=None, params=None, form=None):
    if not form:
        form = AuthClientForm(initial={'scopes': token.scope_to_list(),
                                      'obj_id': token.pk})
    d = {}
    d['form'] = form
    d['name'] = token.consumer.name
    d['description'] = token.consumer.description
    d['params'] = params
    return render_to_response('oauth_authorize_client.html', d, context_instance=RequestContext(request))

def callback_view(request, **args):
    d = {}
    if 'error' in args:
        d['error'] = args['error']

    d['verifier'] = args['token'].verifier
    return render_to_response('oauth_verifier_pin.html', args, context_instance=RequestContext(request))

########NEW FILE########
