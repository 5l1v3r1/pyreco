__FILENAME__ = conf
# This file is automatically generated via sphinx-me
from sphinx_me import setup_conf; setup_conf(globals())

########NEW FILE########
__FILENAME__ = app
#!/usr/bin/env python
#
# Copyright 2013 Adam Gschwender
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

from __future__ import absolute_import, division, with_statement

import logging
import socket

import tornado.escape
import tornado.gen
import tornado.httpclient
import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web
from tornado.options import define, options, parse_config_file

from pilbox import errors
from pilbox.image import Image
from pilbox.signature import verify_signature

try:
    from urlparse import urlparse, urljoin
except ImportError:
    from urllib.parse import urlparse, urljoin


# general settings
define("config", help="path to configuration file",
       callback=lambda path: parse_config_file(path, final=False))
define("debug", default=False, help="run in debug mode", type=bool)
define("port", default=8888, help="run on the given port", type=int)

# security related settings
define("client_name", help="client name")
define("client_key", help="client key")
define("allowed_hosts", help="list of valid hosts", default=[], multiple=True)

# request related settings
define("max_requests", help="max concurrent requests", type=int, default=40)
define("timeout", help="request timeout in seconds", type=float, default=10)
define("implicit_base_url", help="prepend protocol/host to url paths")
define("validate_cert", help="validate certificates", type=bool, default=True)

# default image option settings
define("background", help="default hexadecimal bg color (RGB or ARGB)")
define("expand", help="default to expand when rotating", type=int)
define("filter", help="default filter to use when resizing")
define("format", help="default format to use when outputting")
define("mode", help="default mode to use when resizing")
define("position", help="default cropping position")
define("quality", help="default jpeg quality, 0-100", type=int)

logger = logging.getLogger("tornado.application")


class PilboxApplication(tornado.web.Application):

    def __init__(self, **kwargs):
        settings = dict(debug=options.debug,
                        client_name=options.client_name,
                        client_key=options.client_key,
                        allowed_hosts=options.allowed_hosts,
                        background=options.background,
                        expand=options.expand,
                        filter=options.filter,
                        format=options.format,
                        mode=options.mode,
                        position=options.position,
                        quality=options.quality,
                        max_requests=options.max_requests,
                        timeout=options.timeout,
                        implicit_base_url=options.implicit_base_url,
                        validate_cert=options.validate_cert)
        settings.update(kwargs)
        tornado.web.Application.__init__(self, self.get_handlers(), **settings)

    def get_handlers(self):
        return [(r"/", ImageHandler)]


class ImageHandler(tornado.web.RequestHandler):
    FORWARD_HEADERS = ['Cache-Control', 'Expires', 'Last-Modified']
    OPERATIONS = ["region", "resize", "rotate", "noop"]

    _FORMAT_TO_MIME = {
        "gif": "image/gif",
        "jpeg": "image/jpeg",
        "jpg": "image/jpeg",
        "png": "image/png",
        "webp": "image/webp"}

    @tornado.gen.coroutine
    def get(self):
        self._validate_request()

        url = self.get_argument("url")
        if self.settings.get("implicit_base_url") \
                and urlparse(url).hostname is None:
            url = urljoin(self.settings.get("implicit_base_url"), url)

        client = tornado.httpclient.AsyncHTTPClient(
            max_clients=self.settings.get("max_requests"),
            validate_cert=self.settings.get("validate_cert"))
        try:
            resp = yield client.fetch(
                url, request_timeout=self.settings.get("timeout"))
        except (socket.gaierror, tornado.httpclient.HTTPError) as e:
            logger.warn("Fetch error for %s: %s"
                        % (self.get_argument("url"), str(e)))
            raise errors.FetchError()

        outfile = self._process_response(resp)
        self._forward_headers(resp.headers)
        for block in iter(lambda: outfile.read(65536), b""):
            self.write(block)
        outfile.close()

        self.finish()

    def get_argument(self, name, default=None):
        return super(ImageHandler, self).get_argument(name, default)

    def write_error(self, status_code, **kwargs):
        err = kwargs["exc_info"][1] if "exc_info" in kwargs else None
        if isinstance(err, errors.PilboxError):
            self.set_header('Content-Type', 'application/json')
            resp = dict(status_code=status_code,
                        error_code=err.get_code(),
                        error=err.log_message)
            self.finish(tornado.escape.json_encode(resp))
        else:
            super(ImageHandler, self).write_error(status_code, **kwargs)

    def _process_response(self, resp):
        ops = self._get_operations()
        if "noop" in ops:
            return resp.buffer

        image = Image(resp.buffer)
        for operation in ops:
            if operation == "resize":
                self._image_resize(image)
            elif operation == "rotate":
                self._image_rotate(image)
            elif operation == "region":
                self._image_region(image)

        return self._image_save(image)

    def _image_region(self, image):
        image.region(self.get_argument("rect").split(","))

    def _image_resize(self, image):
        opts = self._get_resize_options()
        image.resize(self.get_argument("w"), self.get_argument("h"), **opts)

    def _image_rotate(self, image):
        opts = self._get_rotate_options()
        image.rotate(self.get_argument("deg"), **opts)

    def _image_save(self, image):
        opts = self._get_save_options()
        return image.save(**opts)

    def _forward_headers(self, headers):
        mime = self._FORMAT_TO_MIME.get(
            self.get_argument("fmt", self.settings.get("format")),
            headers['Content-Type'])
        self.set_header('Content-Type', mime)
        for k in ImageHandler.FORWARD_HEADERS:
            if k in headers and headers[k]:
                self.set_header(k, headers[k])

    def _get_operations(self):
        return self.get_argument("op", "resize").split(",")

    def _get_resize_options(self):
        return self._get_options(
            dict(mode=self.get_argument("mode"),
                 filter=self.get_argument("filter"),
                 position=self.get_argument("pos"),
                 background=self.get_argument("bg")))

    def _get_rotate_options(self):
        return self._get_options(
            dict(expand=self.get_argument("expand")))

    def _get_save_options(self):
        return self._get_options(
            dict(format=self.get_argument("fmt"),
                 quality=self.get_argument("q")))

    def _get_options(self, opts):
        for k, v in opts.items():
            if v is None:
                opts[k] = self.settings.get(k, None)
        return opts

    def _validate_request(self):
        self._validate_operation()
        self._validate_url()
        self._validate_signature()
        self._validate_client()
        self._validate_host()

        opts = self._get_save_options()
        ops = self._get_operations()
        if "resize" in ops:
            Image.validate_dimensions(
                self.get_argument("w"), self.get_argument("h"))
            opts.update(self._get_resize_options())
        if "rotate" in ops:
            Image.validate_degree(self.get_argument("deg"))
            opts.update(self._get_rotate_options())
        if "region" in ops:
            Image.validate_rectangle(self.get_argument("rect"))

        Image.validate_options(opts)

    def _validate_operation(self):
        operations = set(self._get_operations())
        if not operations.issubset(set(ImageHandler.OPERATIONS)):
            raise errors.OperationError("Unsupported operation")

    def _validate_url(self):
        url = self.get_argument("url")
        if not url:
            raise errors.UrlError("Missing url")
        elif url.startswith("http://") or url.startswith("https://"):
            return
        elif self.settings.get("implicit_base_url") and url.startswith("/"):
            return
        raise errors.UrlError("Unsupported protocol")

    def _validate_client(self):
        client = self.settings.get("client_name")
        if client and self.get_argument("client") != client:
            raise errors.ClientError("Invalid client")

    def _validate_signature(self):
        key = self.settings.get("client_key")
        if key and not verify_signature(key, urlparse(self.request.uri).query):
            raise errors.SignatureError("Invalid signature")

    def _validate_host(self):
        hosts = self.settings.get("allowed_hosts", [])
        if hosts and urlparse(self.get_argument("url")).hostname not in hosts:
            raise errors.HostError("Invalid host")


def main():
    tornado.options.parse_command_line()
    if options.debug:
        logger.setLevel(logging.DEBUG)
    server = tornado.httpserver.HTTPServer(PilboxApplication())
    logger.info("Starting server...")
    try:
        server.bind(options.port)
        server.start(1 if options.debug else 0)
        tornado.ioloop.IOLoop.instance().start()
    except KeyboardInterrupt:
        tornado.ioloop.IOLoop.instance().stop()


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = errors
#!/usr/bin/env python
#
# Copyright 2013 Adam Gschwender
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

from __future__ import absolute_import, division, with_statement

import tornado.web


class PilboxError(tornado.web.HTTPError):
    @staticmethod
    def get_code():
        raise NotImplementedError()


class BadRequestError(PilboxError):
    def __init__(self, msg=None, *args, **kwargs):
        super(BadRequestError, self).__init__(400, msg, *args, **kwargs)


class BackgroundError(BadRequestError):
    @staticmethod
    def get_code():
        return 1


class DimensionsError(BadRequestError):
    @staticmethod
    def get_code():
        return 2


class FilterError(BadRequestError):
    @staticmethod
    def get_code():
        return 3


class FormatError(BadRequestError):
    @staticmethod
    def get_code():
        return 4


class ModeError(BadRequestError):
    @staticmethod
    def get_code():
        return 5


class PositionError(BadRequestError):
    @staticmethod
    def get_code():
        return 6


class QualityError(BadRequestError):
    @staticmethod
    def get_code():
        return 7


class UrlError(BadRequestError):
    @staticmethod
    def get_code():
        return 8


class DegreeError(BadRequestError):
    @staticmethod
    def get_code():
        return 9


class OperationError(BadRequestError):
    @staticmethod
    def get_code():
        return 10


class RectangleError(BadRequestError):
    @staticmethod
    def get_code():
        return 11


class FetchError(PilboxError):
    def __init__(self, msg=None, *args, **kwargs):
        super(FetchError, self).__init__(404, msg, *args, **kwargs)

    @staticmethod
    def get_code():
        return 301


class ForbiddenError(PilboxError):
    def __init__(self, msg=None, *args, **kwargs):
        super(ForbiddenError, self).__init__(403, msg, *args, **kwargs)


class SignatureError(ForbiddenError):
    @staticmethod
    def get_code():
        return 101


class ClientError(ForbiddenError):
    @staticmethod
    def get_code():
        return 102


class HostError(ForbiddenError):
    @staticmethod
    def get_code():
        return 103


class UnsupportedError(PilboxError):
    def __init__(self, msg=None, *args, **kwargs):
        super(UnsupportedError, self).__init__(415, msg, *args, **kwargs)


class ImageFormatError(UnsupportedError):
    @staticmethod
    def get_code():
        return 201

########NEW FILE########
__FILENAME__ = image
#!/usr/bin/env python
#
# Copyright 2013 Adam Gschwender
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

from __future__ import absolute_import, division, print_function, \
    with_statement

import logging
import re
import os.path

import PIL.Image
import PIL.ImageOps

from pilbox import errors

try:
    from io import BytesIO
except ImportError:
    from cStringIO import StringIO as BytesIO

try:
    import cv
except ImportError:
    cv = None

logger = logging.getLogger("tornado.application")

_positions_to_ratios = {
    "top-left": (0.0, 0.0), "top": (0.5, 0.0), "top-right": (1.0, 0.0),
    "left": (0.0, 0.5), "center": (0.5, 0.5), "right": (1.0, 0.5),
    "bottom-left": (0.0, 1.0), "bottom": (0.5, 1.0),
    "bottom-right": (1.0, 1.0), "face": None
    }

_filters_to_pil = {
    "antialias": PIL.Image.ANTIALIAS,
    "bicubic": PIL.Image.BICUBIC,
    "bilinear": PIL.Image.BILINEAR,
    "nearest": PIL.Image.NEAREST
    }

_formats_to_pil = {
    "gif": "GIF",
    "jpg": "JPEG",
    "jpeg": "JPEG",
    "png": "PNG",
    "webp": "WEBP"
}


class Image(object):
    FILTERS = _filters_to_pil.keys()
    FORMATS = _formats_to_pil.keys()
    MODES = ["clip", "crop", "fill", "scale"]
    POSITIONS = _positions_to_ratios.keys()

    _DEFAULTS = dict(background="fff", expand=False, filter="antialias",
                     format=None, mode="crop", position="center", quality=90)
    _CLASSIFIER_PATH = os.path.join(
        os.path.dirname(__file__), "frontalface.xml")

    def __init__(self, stream):
        self.stream = stream

        self.img = PIL.Image.open(self.stream)
        if self.img.format.lower() not in self.FORMATS:
            raise errors.ImageFormatError(
                "Unknown format: %s" % self.img.format)
        self._orig_format = self.img.format

    @staticmethod
    def validate_dimensions(width, height):
        if not width and not height:
            raise errors.DimensionsError("Missing dimensions")
        elif width and not str(width).isdigit():
            raise errors.DimensionsError("Invalid width: %s" % width)
        elif height and not str(height).isdigit():
            raise errors.DimensionsError("Invalid height: %s" % height)

    @staticmethod
    def validate_degree(deg):
        if deg is None or deg == "":
            raise errors.DegreeError("Missing degree")
        elif not Image._isint(deg):
            raise errors.DegreeError("Invalid degree: %s" % deg)
        elif int(deg) < 0 or int(deg) >= 360:
            raise errors.DegreeError("Invalid degree: %s" % deg)

    @staticmethod
    def validate_rectangle(rect):
        if not rect:
            raise errors.RectangleError("Missing rectangle")
        rect = rect.split(",")
        if len(rect) != 4:
            raise errors.RectangleError("Invalid rectangle")
        for a in rect:
            if not Image._isint(a):
                raise errors.RectangleError("Invalid rectangle")
            elif int(a) < 0:
                raise errors.RectangleError("Region out-of-bounds")

    @staticmethod
    def validate_options(opts):
        opts = Image._normalize_options(opts)
        if opts["mode"] not in Image.MODES:
            raise errors.ModeError("Invalid mode: %s" % opts["mode"])
        elif opts["filter"] not in Image.FILTERS:
            raise errors.FilterError("Invalid filter: %s" % opts["filter"])
        elif opts["format"] and opts["format"] not in Image.FORMATS:
            raise errors.FormatError("Invalid format: %s" % opts["format"])
        elif opts["position"] not in Image.POSITIONS \
                and not opts["pil"]["position"]:
            raise errors.PositionError(
                "Invalid position: %s" % opts["position"])
        elif not Image._isint(opts["background"], 16) \
                or len(opts["background"]) not in [3, 4, 6, 8]:
            raise errors.BackgroundError(
                "Invalid background: %s" % opts["background"])
        elif not Image._isint(opts["quality"]) \
                or int(opts["quality"]) > 100 or int(opts["quality"]) < 0:
            raise errors.QualityError(
                "Invalid quality: %s", str(opts["quality"]))

    def region(self, rect):
        """ Selects a sub-region of the image using the supplied rectangle,
            x, y, width, height.
        """
        box = (int(rect[0]), int(rect[1]), int(rect[0]) + int(rect[2]),
               int(rect[1]) + int(rect[3]))
        if box[2] > self.img.size[0] or box[3] > self.img.size[1]:
            raise errors.RectangleError('Region out-of-bounds')
        self.img = self.img.crop(box)
        return self

    def resize(self, width, height, **kwargs):
        """Resizes the image to the supplied width/height. Returns the
        instance. Supports the following optional keyword arguments:

        mode - The resizing mode to use, see Image.MODES
        filter - The filter to use: see Image.FILTERS
        background - The hexadecimal background fill color, RGB or ARGB
        position - The position used to crop: see Image.POSITIONS for
                   pre-defined positions or a custom position ratio
        """
        opts = Image._normalize_options(kwargs)
        size = self._get_size(width, height)
        if opts["mode"] == "clip":
            self._clip(size, opts)
        elif opts["mode"] == "fill":
            self._fill(size, opts)
        elif opts["mode"] == "scale":
            self._scale(size, opts)
        else:
            self._crop(size, opts)
        return self

    def rotate(self, deg, **kwargs):
        """ Rotates the image clockwise around its center.  Returns the
        instance. Supports the following optional keyword arguments:

        expand - Expand the output image to fit rotation
        """
        opts = Image._normalize_options(kwargs)
        expand = False if int(deg) % 90 == 0 else bool(int(opts["expand"]))
        self.img = self.img.rotate(360 - int(deg), expand=expand)
        return self

    def save(self, **kwargs):
        """Returns a buffer to the image for saving, supports the
        following optional keyword arguments:

        format - The format to save as: see Image.FORMATS
        quality - The quality used to save JPEGs: integer from 1 - 100
        """
        opts = Image._normalize_options(kwargs)
        outfile = BytesIO()
        if opts["pil"]["format"]:
            fmt = opts["pil"]["format"]
        else:
            fmt = self._orig_format
        self.img.save(outfile, fmt, quality=int(opts["quality"]))
        outfile.seek(0)

        return outfile

    def _clip(self, size, opts):
        self.img.thumbnail(size, opts["pil"]["filter"])

    def _crop(self, size, opts):
        if opts["position"] == "face":
            if cv is None:
                raise NotImplementedError
            else:
                pos = self._get_face_position()
        else:
            pos = opts["pil"]["position"]
        self.img = PIL.ImageOps.fit(
            self.img, size, opts["pil"]["filter"], 0, pos)

    def _fill(self, size, opts):
        self._clip(size, opts)
        if self.img.size == size:
            return  # No need to fill
        x = max(int((size[0] - self.img.size[0]) / 2.0), 0)
        y = max(int((size[1] - self.img.size[1]) / 2.0), 0)
        color = color_hex_to_dec_tuple(opts["background"])
        mode = "RGBA" if len(color) == 4 else "RGB"
        img = PIL.Image.new(mode=mode, size=size, color=color)
        img.paste(self.img, (x, y))
        self.img = img

    def _scale(self, size, opts):
        self.img = self.img.resize(size, opts["pil"]["filter"])

    def _get_size(self, width, height):
        aspect_ratio = self.img.size[0] / self.img.size[1]
        if not width:
            width = int((int(height) or self.img.size[1]) * aspect_ratio)
        if not height:
            height = int((int(width) or self.img.size[0]) / aspect_ratio)
        return (int(width), int(height))

    def _get_face_rectangles(self):
        cvim = self._pil_to_opencv()
        return cv.HaarDetectObjects(
            cvim,
            self._get_face_classifier(),
            cv.CreateMemStorage(0),
            1.3,  # Scale factor
            4,  # Minimum neighbors
            0,  # HAAR Flags
            (20, 20))

    def _get_face_position(self):
        rects = self._get_face_rectangles()
        if not rects:
            return (0.5, 0.5)
        xt, yt = (0.0, 0.0)
        for rect in rects:
            xt += rect[0][0] + (rect[0][2] / 2.0)
            yt += rect[0][1] + (rect[0][3] / 2.0)

        return (xt / (len(rects) * self.img.size[0]),
                yt / (len(rects) * self.img.size[1]))

    def _get_face_classifier(self):
        if not hasattr(Image, "_classifier"):
            classifier_path = os.path.abspath(Image._CLASSIFIER_PATH)
            Image._classifier = cv.Load(classifier_path)
        return Image._classifier

    def _pil_to_opencv(self):
        mono = self.img.convert("L")
        cvim = cv.CreateImageHeader(mono.size, cv.IPL_DEPTH_8U, 1)
        cv.SetData(cvim, mono.tostring(), mono.size[0])
        cv.EqualizeHist(cvim, cvim)
        return cvim

    @staticmethod
    def _normalize_options(options):
        opts = Image._DEFAULTS.copy()
        for k, v in options.items():
            if v is not None:
                opts[k] = v
        opts["pil"] = dict(
            filter=_filters_to_pil.get(opts["filter"]),
            format=_formats_to_pil.get(opts["format"]),
            position=Image._get_custom_position(opts["position"]))

        if not opts["pil"]["position"]:
            opts["pil"]["position"] = _positions_to_ratios.get(
                opts["position"], None)

        return opts

    @staticmethod
    def _get_custom_position(pos):
        m = re.match(r'^(\d+(\.\d+)?),(\d+(\.\d+)?)$', pos)
        if not m:
            return None
        pos = (float(m.group(1)), float(m.group(3)))
        if pos[0] < 0.0 or pos[0] > 1.0 or pos[1] < 0.0 or pos[1] > 1.0:
            return None
        return pos

    @staticmethod
    def _isint(v, base=10):
        try:
            int(str(v), base)
        except ValueError:
            return False
        return True


def color_hex_to_dec_tuple(color):
    """Converts a color from hexadecimal to decimal tuple, color can be in
    the following formats: 3-digit RGB, 4-digit ARGB, 6-digit RGB and
    8-digit ARGB.
    """
    assert len(color) in [3, 4, 6, 8]
    if len(color) in [3, 4]:
        color = "".join([c*2 for c in color])
    n = int(color, 16)
    t = ((n >> 16) & 255, (n >> 8) & 255, n & 255)
    if len(color) == 8:
        t = t + ((n >> 24) & 255,)
    return t


def main():
    import sys
    import tornado.httpclient
    import tornado.options
    from tornado.options import define, options, parse_command_line

    define("operation", help="the operation to be performed", type=str,
           default="resize", metavar="|".join(["resize", "rotate", "none"]))
    define("width", help="the desired image width", type=int)
    define("height", help="the desired image height", type=int)
    define("mode", help="the resizing mode",
           metavar="|".join(Image.MODES), type=str)
    define("background", help="the hexidecimal fill background color",
           type=str)
    define("position", help="the crop position",
           metavar="|".join(Image.POSITIONS), type=str)
    define("filter", help="default filter to use when resizing",
           metavar="|".join(Image.FILTERS), type=str)
    define("degree", help="the desired rotation degree", type=int)
    define("expand", help="expand image size to accomodate rotation", type=int)
    define("rect", help="rectangle: x,y,w,h", type=str)
    define("format", help="default format to use when saving",
           metavar="|".join(Image.FORMATS), type=str)
    define("quality", help="default jpeg quality, 0-100", type=int)

    args = parse_command_line()
    if not args:
        print("Missing image source url")
        sys.exit()
    elif options.operation == "region":
        if not options.rect:
            tornado.options.print_help()
            sys.exit()
    elif options.operation == "resize":
        if not options.width and not options.height:
            tornado.options.print_help()
            sys.exit()
    elif options.operation == "rotate":
        if not options.degree:
            tornado.options.print_help()
            sys.exit()
    elif options.operation != "noop":
        tornado.options.print_help()
        sys.exit()

    if args[0].startswith("http://") or args[0].startswith("https://"):
        client = tornado.httpclient.HTTPClient()
        resp = client.fetch(args[0])
        image = Image(resp.buffer)
    else:
        image = Image(open(args[0], "r"))

    if options.operation == "resize":
        image.resize(options.width, options.height, mode=options.mode,
                     filter=options.filter, background=options.background,
                     position=options.position)
    elif options.operation == "rotate":
        image.rotate(options.degree, expand=options.expand)
    elif options.operation == "region":
        image.region(options.rect.split(","))

    stream = image.save(format=options.format, quality=options.quality)
    sys.stdout.write(stream.read())
    stream.close()


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = signature
#!/usr/bin/env python
#
# Copyright 2013 Adam Gschwender
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

from __future__ import absolute_import, division, print_function, \
    with_statement

import hashlib
import hmac
import re

try:
    from urllib import urlencode
except ImportError:
    from urllib.parse import urlencode

try:
    import urlparse
except ImportError:
    import urllib.parse as urlparse


def derive_signature(key, qs):
    """Derives the signature from the supplied query string using the key."""
    key, qs = (key or "", qs or "")
    return hmac.new(key.encode(), qs.encode(), hashlib.sha1).hexdigest()


def sign(key, qs):
    """Signs the query string using the key."""
    sig = derive_signature(key, qs)
    return "%s&%s" % (qs, urlencode([("sig", sig)]))


def verify_signature(key, qs):
    """Verifies that the signature in the query string is correct."""
    unsigned_qs = re.sub(r'&?sig=[^&]*', '', qs)
    sig = derive_signature(key, unsigned_qs)
    return urlparse.parse_qs(qs).get("sig", [None])[0] == sig


def main():
    import sys
    import tornado.options
    from tornado.options import define, options, parse_command_line
    define("key", help="the signing key", type=str)
    args = parse_command_line()
    if not options.key:
        tornado.options.print_help()
        sys.exit()

    qs = args[0]
    if qs and qs[0] == "?":
        print("Invalid query string, should not include leading '?'")
        sys.exit()
    print("Query String: %s" % qs)
    print("Signature: %s" % derive_signature(options.key, qs))
    print("Signed Query String: %s" % sign(options.key, qs))


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = app_test
from __future__ import absolute_import, division, with_statement

import logging
import os.path
import time

import tornado.escape
import tornado.gen
import tornado.ioloop
import tornado.web
from tornado.test.util import unittest
from tornado.testing import AsyncHTTPTestCase

from pilbox import errors
from pilbox.app import PilboxApplication
from pilbox.signature import sign
from pilbox.test import image_test

try:
    from urllib import urlencode
except ImportError:
    from urllib.parse import urlencode

try:
    import cv
except ImportError:
    cv = None


logger = logging.getLogger("tornado.application")


class _AppAsyncMixin(object):
    def fetch_error(self, code, *args, **kwargs):
        response = self.fetch(*args, **kwargs)
        self.assertEqual(response.code, code)
        self.assertEqual(response.headers.get("Content-Type", None),
                         "application/json")
        return tornado.escape.json_decode(response.body)

    def fetch_success(self, *args, **kwargs):
        response = self.fetch(*args, **kwargs)
        self.assertEqual(response.code, 200)
        return response

    def get_image_resize_cases(self):
        cases = image_test.get_image_resize_cases()
        m = dict(background="bg", filter="filter", format="fmt",
                 position="pos", quality="q")
        for i, case in enumerate(cases):
            path = "/test/data/%s" % os.path.basename(case["source_path"])
            cases[i]["source_query_params"] = dict(
                url=self.get_url(path),
                w=case["width"] or "",
                h=case["height"] or "",
                mode=case["mode"])
            for k in m.keys():
                if k in case:
                    cases[i]["source_query_params"][m.get(k)] = case[k]
            cases[i]["content_type"] = self._format_to_content_type(
                case.get("format"))
        return cases

    def get_image_rotate_cases(self):
        cases = image_test.get_image_rotate_cases()
        m = dict(expand="expand", format="fmt", quality="q")
        for i, case in enumerate(cases):
            path = "/test/data/%s" % os.path.basename(case["source_path"])
            cases[i]["source_query_params"] = dict(
                op="rotate",
                url=self.get_url(path),
                deg=case["degree"])
            for k in m.keys():
                if k in case:
                    cases[i]["source_query_params"][m.get(k)] = case[k]
            cases[i]["content_type"] = self._format_to_content_type(
                case.get("format"))

        return cases

    def get_image_region_cases(self):
        cases = image_test.get_image_region_cases()
        m = dict(expand="expand", format="fmt", quality="q")
        for i, case in enumerate(cases):
            path = "/test/data/%s" % os.path.basename(case["source_path"])
            cases[i]["source_query_params"] = dict(
                op="region",
                url=self.get_url(path),
                rect=case["rect"])
            for k in m.keys():
                if k in case:
                    cases[i]["source_query_params"][m.get(k)] = case[k]
            cases[i]["content_type"] = self._format_to_content_type(
                case.get("format"))

        return cases

    def get_image_chained_cases(self):
        cases = image_test.get_image_chained_cases()
        for i, case in enumerate(cases):
            path = "/test/data/%s" % os.path.basename(case["source_path"])
            cases[i]["source_query_params"] = dict(
                op=",".join(case["operation"]),
                url=self.get_url(path),
                w=case["width"] or "",
                h=case["height"] or "",
                deg=case.get("degree") or "",
                rect=case.get("rect") or "")
            cases[i]["content_type"] = self._format_to_content_type(
                case.get("format"))

        return cases

    def _format_to_content_type(self, fmt):
        if fmt in ["jpeg", "jpg"]:
            return "image/jpeg"
        elif fmt == "png":
            return "image/png"
        elif fmt == "webp":
            return "image/webp"
        return None


class _PilboxTestApplication(PilboxApplication):
    def get_handlers(self):
        path = os.path.join(os.path.dirname(__file__), "data")
        handlers = [(r"/test/data/test-delayed.jpg", _DelayedHandler),
                    (r"/test/data/(.*)",
                     tornado.web.StaticFileHandler,
                     {"path": path})]
        handlers.extend(super(_PilboxTestApplication, self).get_handlers())
        return handlers


class _DelayedHandler(tornado.web.RequestHandler):

    @tornado.web.asynchronous
    @tornado.gen.engine
    def get(self):
        delay = time.time() + float(self.get_argument("delay", 0.0))
        yield tornado.gen.Task(
            tornado.ioloop.IOLoop.instance().add_timeout, delay)
        self.finish()


class AppTest(AsyncHTTPTestCase, _AppAsyncMixin):
    def get_app(self):
        return _PilboxTestApplication(timeout=10.0)

    def test_missing_url(self):
        qs = urlencode(dict(w=1, h=1))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.UrlError.get_code())

    def test_invalid_operation(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", op="a"))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"),
                         errors.OperationError.get_code())

    def test_missing_dimensions(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg"))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"),
                         errors.DimensionsError.get_code())

    def test_invalid_width(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", w="a", h=1))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"),
                         errors.DimensionsError.get_code())

    def test_invalid_height(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", w=1, h="a"))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"),
                         errors.DimensionsError.get_code())

    def test_invalid_degree(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", op="rotate", deg="a"))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.DegreeError.get_code())

    def test_invalid_rectangle(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", op="region", rect="a"))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"),
                         errors.RectangleError.get_code())

    def test_invalid_mode(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", w=1, h=1, mode="foo"))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.ModeError.get_code())

    def test_invalid_hexadecimal_background(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", w=1, h=1,
                            mode="fill", bg="r"))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"),
                         errors.BackgroundError.get_code())

    def test_invalid_long_background(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", w=1, h=1,
                            mode="fill", bg="0f0f0f0f0"))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"),
                         errors.BackgroundError.get_code())

    def test_invalid_position(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", w=1, h=1, pos="foo"))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"),
                         errors.PositionError.get_code())

    def test_invalid_position_ratio(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", w=1, h=1, pos="1.2,5.6"))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"),
                         errors.PositionError.get_code())

    def test_invalid_filter(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", w=1, h=1, filter="bar"))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.FilterError.get_code())

    def test_invalid_format(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", w=1, h=1, fmt="foo"))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.FormatError.get_code())

    def test_invalid_integer_quality(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", w=1, h=1, q="a"))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.QualityError.get_code())

    def test_outofbounds_quality(self):
        qs = urlencode(dict(url="http://foo.co/x.jpg", w=1, h=1, q=200))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.QualityError.get_code())

    def test_unsupported_image_format(self):
        path = "/test/data/test-bad-format.ico"
        qs = urlencode(dict(url=self.get_url(path), w=1, h=1))
        resp = self.fetch_error(415, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"),
                         errors.ImageFormatError.get_code())

    def test_not_found(self):
        path = "/test/data/test-not-found.jpg"
        qs = urlencode(dict(url=self.get_url(path), w=1, h=1))
        resp = self.fetch_error(404, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.FetchError.get_code())

    def test_not_connect(self):
        qs = urlencode(dict(url="http://a.com/a.jpg", w=1, h=1))
        resp = self.fetch_error(404, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.FetchError.get_code())

    def test_invalid_protocol(self):
        path = os.path.join(os.path.dirname(__file__), "data", "test1.jpg")
        qs = urlencode(dict(url="file://%s" % path, w=1, h=1))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.UrlError.get_code())

    def test_valid_noop(self):
        url = self.get_url("/test/data/test1.jpg")
        qs = urlencode(dict(url=url, op="noop"))
        resp = self.fetch_success("/?%s" % qs)
        expected_path = os.path.join(
            os.path.dirname(__file__), "data", "test1.jpg")
        msg = "/?%s does not match %s" % (qs, expected_path)
        with open(expected_path, "rb") as expected:
            self.assertEqual(resp.buffer.read(), expected.read(), msg)

    def test_valid_resize(self):
        cases = self.get_image_resize_cases()
        for case in cases:
            if case.get("mode") == "crop" and case.get("position") == "face":
                continue
            self._assert_expected_case(case)

    def test_valid_rotate(self):
        cases = self.get_image_rotate_cases()
        for case in cases:
            self._assert_expected_case(case)

    def test_valid_region(self):
        cases = self.get_image_region_cases()
        for case in cases:
            self._assert_expected_case(case)

    def test_valid_chained(self):
        cases = self.get_image_chained_cases()
        for case in cases:
            self._assert_expected_case(case)

    @unittest.skipIf(cv is None, "OpenCV is not installed")
    def test_valid_face(self):
        cases = self.get_image_resize_cases()
        for case in cases:
            if case.get("mode") == "crop" and case.get("position") == "face":
                self._assert_expected_case(case)

    def _assert_expected_case(self, case):
        qs = urlencode(case["source_query_params"])
        resp = self.fetch_success("/?%s" % qs)
        msg = "/?%s does not match %s" \
            % (qs, case["expected_path"])
        if case["content_type"]:
            self.assertEqual(resp.headers.get("Content-Type", None),
                             case["content_type"])
        with open(case["expected_path"], "rb") as expected:
            self.assertEqual(resp.buffer.read(), expected.read(), msg)


class AppImplicitBaseUrlTest(AsyncHTTPTestCase, _AppAsyncMixin):
    def get_app(self):
        return _PilboxTestApplication(
            implicit_base_url=self.get_url("/"))

    def test_missing_url(self):
        qs = urlencode(dict(w=1, h=1))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.UrlError.get_code())

    def test_url(self):
        url = self.get_url("/test/data/test1.jpg")
        qs = urlencode(dict(url=url, op="noop"))
        resp = self.fetch_success("/?%s" % qs)
        expected_path = os.path.join(
            os.path.dirname(__file__), "data", "test1.jpg")
        msg = "/?%s does not match %s" % (qs, expected_path)
        with open(expected_path, "rb") as expected:
            self.assertEqual(resp.buffer.read(), expected.read(), msg)

    def test_path(self):
        url_path = "/test/data/test1.jpg"
        qs = urlencode(dict(url=url_path, op="noop"))
        resp = self.fetch_success("/?%s" % qs)
        expected_path = os.path.join(
            os.path.dirname(__file__), "data", "test1.jpg")
        msg = "/?%s does not match %s" % (qs, expected_path)
        with open(expected_path, "rb") as expected:
            self.assertEqual(resp.buffer.read(), expected.read(), msg)

    def test_invalid_protocol(self):
        path = os.path.join(os.path.dirname(__file__), "data", "test1.jpg")
        qs = urlencode(dict(url="file://%s" % path, w=1, h=1))
        resp = self.fetch_error(400, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.UrlError.get_code())


class AppRestrictedTest(AsyncHTTPTestCase, _AppAsyncMixin):
    KEY = "abcdef"
    NAME = "abc"

    def get_app(self):
        return _PilboxTestApplication(
            client_name=self.NAME,
            client_key=self.KEY,
            allowed_hosts=["foo.co", "bar.io", "localhost"],
            timeout=10.0)

    def test_missing_client_name(self):
        params = dict(url="http://foo.co/x.jpg", w=1, h=1)
        qs = sign(self.KEY, urlencode(params))
        resp = self.fetch_error(403, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.ClientError.get_code())

    def test_bad_client_name(self):
        params = dict(url="http://foo.co/x.jpg", w=1, h=1, client="123")
        qs = sign(self.KEY, urlencode(params))
        resp = self.fetch_error(403, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.ClientError.get_code())

    def test_missing_signature(self):
        params = dict(url="http://foo.co/x.jpg", w=1, h=1, client=self.NAME)
        qs = urlencode(params)
        resp = self.fetch_error(403, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"),
                         errors.SignatureError.get_code())

    def test_bad_signature(self):
        params = dict(url="http://foo.co/x.jpg", w=1, h=1,
                      client=self.NAME, sig="abc123")
        qs = urlencode(params)
        resp = self.fetch_error(403, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"),
                         errors.SignatureError.get_code())

    def test_bad_host(self):
        params = dict(url="http://bar.co/x.jpg", w=1, h=1, client=self.NAME)
        qs = sign(self.KEY, urlencode(params))
        resp = self.fetch_error(403, "/?%s" % qs)
        self.assertEqual(resp.get("error_code"), errors.HostError.get_code())

    def test_valid(self):
        cases = self.get_image_resize_cases()
        for case in cases:
            if case.get("mode") == "crop" and case.get("position") == "face":
                continue
            params = case["source_query_params"]
            params["client"] = self.NAME
            qs = sign(self.KEY, urlencode(params))
            resp = self.fetch_success("/?%s" % qs)
            msg = "/?%s does not match %s" \
                % (qs, case["expected_path"])
            with open(case["expected_path"], "rb") as expected:
                self.assertEqual(resp.buffer.read(), expected.read(), msg)


class AppSlowTest(AsyncHTTPTestCase, _AppAsyncMixin):
    def get_app(self):
        return _PilboxTestApplication(timeout=0.5)

    def test_timeout(self):
        url = self.get_url("/test/data/test-delayed.jpg?delay=1.0")
        qs = urlencode(dict(url=url, w=1, h=1))
        resp = self.fetch_error(404, "/?%s" %qs)
        self.assertEqual(resp.get("error_code"), errors.FetchError.get_code())

########NEW FILE########
__FILENAME__ = errors_test
from __future__ import absolute_import, division, with_statement

from tornado.test.util import unittest

from pilbox.errors import *


class ErrorsTest(unittest.TestCase):

    def test_unique_error_codes(self):
        errors = [SignatureError, ClientError, HostError, BackgroundError,
                  DimensionsError, FilterError, FormatError, ModeError,
                  PositionError, QualityError, UrlError, ImageFormatError,
                  FetchError, DegreeError, OperationError, RectangleError]
        codes = []
        for error in errors:
            code = str(error.get_code())
            if code in codes:
                self.fail("The error code, %s, is repeated" % str(code))
            codes.append(code)

    def test_base_not_implemented(self):
        self.assertRaises(NotImplementedError, PilboxError.get_code)

########NEW FILE########
__FILENAME__ = genexpected
#!/usr/bin/env python
#
# Copyright 2013 Adam Gschwender
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import sys
import textwrap

from . import image_test
from ..image import Image


def main():
    """Generates expected results using the current application libraries. This
    is a convenience program that is intended to regenerate the tests after an
    algorithm or mode change that would alter the expected output."""

    warning = "WARNING: All expected tests will be regenerated, output must" \
        " be verified to ensure future tests are producing accurate results."
    print "\n".join(textwrap.wrap(warning)) + "\n"
    proceed = raw_input("Are you sure you want to proceed? [y/N] ")
    if proceed not in ["y", "Y"]:
        print "Not proceeding, done"
        sys.exit()

    cases = image_test.get_image_resize_cases()
    for case in cases:
        with open(case["source_path"], "rb") as f:

            print "Generating %s" % case["expected_path"]
            img = Image(f).resize(
                case["width"], case["height"], mode=case["mode"],
                background=case.get("background"), filter=case.get("filter"),
                position=case.get("position"))
            rv = img.save(
                format=case.get("format"), quality=case.get("quality"))

            with open(case["expected_path"], "wb") as expected:
                expected.write(rv.read())

    cases = image_test.get_image_rotate_cases()
    for case in cases:
        with open(case["source_path"], "rb") as f:

            print "Generating %s" % case["expected_path"]
            img = Image(f).rotate(
                case["degree"], expand=case.get("expand"),
                filter=case.get("filter"))
            rv = img.save(
                format=case.get("format"), quality=case.get("quality"))

            with open(case["expected_path"], "wb") as expected:
                expected.write(rv.read())


    cases = image_test.get_image_region_cases()
    for case in cases:
        with open(case["source_path"], "rb") as f:

            print "Generating %s" % case["expected_path"]
            img = Image(f).region(case["rect"].split(","))
            rv = img.save(
                format=case.get("format"), quality=case.get("quality"))

            with open(case["expected_path"], "wb") as expected:
                expected.write(rv.read())


    cases = image_test.get_image_chained_cases()
    for case in cases:
        with open(case["source_path"], "rb") as f:

            print "Generating %s" % case["expected_path"]
            img = Image(f)
            for operation in case["operation"]:
                if operation == "resize":
                    img.resize(case["width"], case["height"])
                elif operation == "rotate":
                    img.rotate(case["degree"])
                elif operation == "region":
                    img.region(case["rect"].split(","))

            rv = img.save()
            with open(case["expected_path"], "wb") as expected:
                expected.write(rv.read())


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = image_test
from __future__ import absolute_import, division, with_statement

import itertools
import os
import os.path
import re

import PIL.Image
from tornado.test.util import unittest

from pilbox import errors
from pilbox.image import color_hex_to_dec_tuple, Image

try:
    import cv
except ImportError:
    cv = None


DATADIR = os.path.join(os.path.dirname(__file__), "data")
EXPECTED_DATADIR = os.path.join(DATADIR, "expected")


def get_image_resize_cases():
    """Returns a list of test cases of the form:
    [dict(source_path, expected_path, width, height, mode, ...), ...]
    """
    cases = []
    for filename in os.listdir(DATADIR):
        if not re.match(r"^test\d+\.[^\.]+$", filename):
            continue
        for criteria in _get_simple_criteria_combinations():
            cases.append(_criteria_to_resize_case(filename, criteria))

    for criteria in _get_advanced_criteria_combinations():
        cases.append(_criteria_to_resize_case("test-advanced.jpg", criteria))

    for criteria in _get_example_criteria_combinations():
        cases.append(_criteria_to_resize_case("example.jpg", criteria))

    for criteria in _get_transparent_criteria_combinations():
        cases.append(_criteria_to_resize_case("test2.png", criteria))

    return list(filter(bool, cases))


def get_image_rotate_cases():
    """Returns a list of test cases of the form:
    [dict(source_path, expected_path, degree, expand, ...), ...]
    """
    criteria_combinations = _make_combinations(
        [dict(values=[[90, 180, 315], [1, 0]],
              fields=["degree", "expand"])])

    cases = []
    for criteria in criteria_combinations:
        cases.append(_criteria_to_rotate_case("test1.jpg", criteria))

    return list(filter(bool, cases))


def get_image_region_cases():
    """Returns a list of test cases of the form:
    [dict(source_path, expected_path, rect, ...), ...]
    """
    criteria_combinations = _make_combinations(
        [dict(values=[["150,150,100,100", "200,175,50,50"]],
              fields=["rect"])])

    cases = []
    for criteria in criteria_combinations:
        cases.append(_criteria_to_region_case("test1.jpg", criteria))

    return list(filter(bool, cases))


def get_image_chained_cases():
    """Returns a list of test cases of the form:
    [dict(source_path, expected_path, operation, size, ...), ...]
    """
    criteria_combinations = _make_combinations(
        [dict(values=[[("resize", "rotate"), ("rotate", "resize")],
                      [(150, 75), (75, 150)],
                      [90]],
              fields=["operation", "size", "degree"]),
         dict(values=[[("resize", "region", "rotate")],
                     [(150, 75), (75, 150)],
                     ["5,5,65,65"],
                     [90]],
              fields=["operation", "size", "rect", "degree"]),
         dict(values=[[("region", "resize", "rotate")],
                     [(150, 75), (75, 150)],
                     ["50,50,150,150"],
                     [90]],
              fields=["operation", "size", "rect", "degree"])])

    cases = []
    for criteria in criteria_combinations:
        cases.append(_criteria_to_chained_case("test1.jpg", criteria))

    return list(filter(bool, cases))


class ImageTest(unittest.TestCase):

    def test_resize(self):
        for case in get_image_resize_cases():
            if case.get("mode") == "crop" and case.get("position") == "face":
                continue
            self._assert_expected_resize(case)

    def test_rotate(self):
        for case in get_image_rotate_cases():
            self._assert_expected_rotate(case)

    def test_region(self):
        for case in get_image_region_cases():
            self._assert_expected_region(case)

    def test_chained(self):
        for case in get_image_chained_cases():
            self._assert_expected_chained(case)

    @unittest.skipIf(cv is None, "OpenCV is not installed")
    def test_face_crop_resize(self):
        for case in get_image_resize_cases():
            if case.get("mode") == "crop" and case.get("position") == "face":
                self._assert_expected_resize(case)

    def test_valid_degree(self):
        for deg in [0, 90, "90", 45, "45", 300, 359]:
            Image.validate_degree(deg)

    def test_invalid_degree(self):
        for deg in [None, "a", "", 45.34, "93.20", -2, 360]:
            self.assertRaises(errors.DegreeError, Image.validate_degree, deg)

    def test_valid_dimensions(self):
        Image.validate_dimensions(100, 100)
        Image.validate_dimensions("100", "100")

    def test_invalid_dimensions_none(self):
        self.assertRaises(
            errors.DimensionsError, Image.validate_dimensions, None, None)
        self.assertRaises(
            errors.DimensionsError, Image.validate_dimensions, "", "")

    def test_invalid_dimensions_not_integer(self):
        self.assertRaises(
            errors.DimensionsError, Image.validate_dimensions, "a", 100)
        self.assertRaises(
            errors.DimensionsError, Image.validate_dimensions, 100, "a")

    def test_valid_rectangle(self):
        Image.validate_rectangle("100,100,200,200")
        Image.validate_rectangle("100,200,50,100")

    def test_invalid_rectangle(self):
        invalid_rectangles = ["", None, "100,100,200", "100,200,300,400.5",
                              "0,-1,100,100", "100,100,-100,-100"]
        for rect in invalid_rectangles:
            self.assertRaises(
                errors.RectangleError, Image.validate_rectangle, rect)

    def test_out_of_bounds_rectangle(self):
        path = os.path.join(os.path.dirname(__file__), "data", "test1.jpg")
        invalid_rectangles = ["0,0,10000,10000", "10000,10000,0,0"]
        for rect in invalid_rectangles:
            with open(path, "rb") as f:
                img = Image(f)
                self.assertRaises(
                    errors.RectangleError, img.region, rect.split(","))

    def test_valid_default_options(self):
        Image.validate_options(dict())

    def test_valid_default_options_with_empty_values(self):
        opts = dict(mode=None, filter=None, background=None, position=None,
                    quality=None)
        Image.validate_options(opts)

    def test_bad_image_format(self):
        path = os.path.join(DATADIR, "test-bad-format.ico")
        with open(path, "rb") as f:
            self.assertRaises(errors.ImageFormatError, Image, f)

    def test_bad_mode(self):
        self.assertRaises(
            errors.ModeError, Image.validate_options, dict(mode="foo"))

    def test_bad_filter(self):
        self.assertRaises(
            errors.FilterError, Image.validate_options, dict(filter="foo"))

    def test_bad_format(self):
        self.assertRaises(
            errors.FormatError, Image.validate_options, dict(format="foo"))

    def test_bad_background_invalid_number(self):
        self.assertRaises(errors.BackgroundError,
                          Image.validate_options,
                          dict(background="foo"))

    def test_bad_background_wrong_length(self):
        self.assertRaises(errors.BackgroundError,
                          Image.validate_options,
                          dict(background="0f"))
        self.assertRaises(errors.BackgroundError,
                          Image.validate_options,
                          dict(background="0f0f0"))
        self.assertRaises(errors.BackgroundError,
                          Image.validate_options,
                          dict(background="0f0f0f0f0"))

    def test_bad_position(self):
        self.assertRaises(
            errors.PositionError, Image.validate_options, dict(position="foo"))

    def test_bad_position_ratio(self):
        self.assertRaises(errors.PositionError,
                          Image.validate_options,
                          dict(position="1.2,5.6"))

    def test_valid_position_ratio(self):
        for pos in ["0.0,0.5", "1.0,1.0", "0.111111,0.999999"]:
            Image.validate_options(dict(position=pos))

    def test_bad_quality_invalid_number(self):
        self.assertRaises(
            errors.QualityError, Image.validate_options, dict(quality="foo"))

    def test_bad_quality_invalid_range(self):
        self.assertRaises(
            errors.QualityError, Image.validate_options, dict(quality=101))
        self.assertRaises(
            errors.QualityError, Image.validate_options, dict(quality=-1))

    def test_color_hex_to_dec_tuple(self):
        tests  = [["fff", (255, 255, 255)],
                  ["ccc", (204, 204, 204)],
                  ["abc", (170, 187, 204)],
                  ["ffffff", (255, 255, 255)],
                  ["cccccc", (204, 204, 204)],
                  ["abcdef", (171, 205, 239)],
                  ["fabc", (170, 187, 204, 255)],
                  ["0abc", (170, 187, 204, 0)],
                  ["8abc", (170, 187, 204, 136)],
                  ["80abcdef", (171, 205, 239, 128)],
                  ["ffabcdef", (171, 205, 239, 255)],
                  ["00abcdef", (171, 205, 239, 0)]]
        for test in tests:
            self.assertTupleEqual(color_hex_to_dec_tuple(test[0]), test[1])

    def test_invalid_color_hex_to_dec_tuple(self):
        for color in ["9", "99", "99999", "9999999", "999999999"]:
            self.assertRaises(AssertionError, color_hex_to_dec_tuple, color)

    def _assert_expected_resize(self, case):
        with open(case["source_path"], "rb") as f:
            img = Image(f).resize(
                case["width"], case["height"], mode=case["mode"],
                background=case.get("background"), filter=case.get("filter"),
                position=case.get("position"))
            rv = img.save(
                format=case.get("format"), quality=case.get("quality"))

            with open(case["expected_path"], "rb") as expected:
                msg = "%s does not match %s" \
                    % (case["source_path"], case["expected_path"])
                self.assertEqual(rv.read(), expected.read(), msg)

    def _assert_expected_rotate(self, case):
        with open(case["source_path"], "rb") as f:

            img = Image(f).rotate(
                case["degree"], expand=case.get("expand"),
                filter=case.get("filter"))
            rv = img.save(
                format=case.get("format"), quality=case.get("quality"))

            with open(case["expected_path"], "rb") as expected:
                msg = "%s does not match %s" \
                    % (case["source_path"], case["expected_path"])
                self.assertEqual(rv.read(), expected.read(), msg)


    def _assert_expected_region(self, case):
        with open(case["source_path"], "rb") as f:
            img = Image(f).region(case["rect"].split(","))
            rv = img.save(
                format=case.get("format"), quality=case.get("quality"))

            with open(case["expected_path"], "rb") as expected:
                msg = "%s does not match %s" \
                    % (case["source_path"], case["expected_path"])
                self.assertEqual(rv.read(), expected.read(), msg)


    def _assert_expected_chained(self, case):
        with open(case["source_path"], "rb") as f:

            img = Image(f)
            for operation in case["operation"]:
                if operation == "resize":
                    img.resize(case["width"], case["height"])
                elif operation == "rotate":
                    img.rotate(case["degree"])
                elif operation == "region":
                    img.region(case["rect"].split(","))

            rv = img.save()

            with open(case["expected_path"], "rb") as expected:
                msg = "%s does not match %s" \
                    % (case["source_path"], case["expected_path"])
                self.assertEqual(rv.read(), expected.read(), msg)


def _get_simple_criteria_combinations():
    return _make_combinations(
        [dict(values=[Image.MODES, [(400, 300), (300, 300), (100, 200)]],
              fields=["mode", "size"]),
         dict(values=[["crop"], [(200, 100)], ["center", "face"]],
              fields=["mode", "size", "position"])])


def _get_example_criteria_combinations():
    return [dict(mode="clip", width=500, height=400),
            dict(mode="crop", width=500, height=400),
            dict(mode="fill", width=500, height=400, background="ccc"),
            dict(mode="scale", width=500, height=400)]


def _get_advanced_criteria_combinations():
    return _make_combinations(
        [dict(values=[["fill"], [(125, 75)], ["F00", "cccccc"]],
              fields=["mode", "size", "background"]),
         dict(values=[["crop"], [(125, 75)], Image.POSITIONS],
              fields=["mode", "size", "position"]),
         dict(values=[["crop"], [(125, 75)], ["0.25,0.75", "0.25,0.25"]],
              fields=["mode", "size", "position"]),
         dict(values=[["crop"], [(125, 75)], Image.FILTERS],
              fields=["mode", "size", "filter"]),
         dict(values=[["crop"], [(125, 75)], [50, 75, 90]],
              fields=["mode", "size", "quality"]),
         dict(values=[Image.MODES, [(125, None), (None, 125)]],
              fields=["mode", "size"]),
         dict(values=[["crop"], [(125, 75)], Image.FORMATS],
              fields=["mode", "size", "format"])])


def _get_transparent_criteria_combinations():
    return _make_combinations(
        [dict(values=[["fill"], [(75, 125)], ["1ccc", "a0cccccc"]],
              fields=["mode", "size", "background"])])


def _make_combinations(choices):
    combos = []
    for choice in choices:
        for a in list(itertools.product(*choice["values"])):
            combo = dict(zip(choice["fields"], a))
            if "size" in combo:
                combo["width"] = combo["size"][0]
                combo["height"] = combo["size"][1]
                del combo["size"]
            combos.append(combo)
    return combos


def _criteria_to_resize_case(filename, criteria):
    m = re.match(r"^([^\.]+)\.([^\.]+)$", filename)
    if not m:
        return None
    case = dict(source_path=os.path.join(DATADIR, filename))
    case.update(criteria)
    fields = ["mode", "filter", "quality", "background", "position"]
    opts = filter(bool, [criteria.get(x) for x in fields])
    expected = "%s-%sx%s%s.%s" \
        % (m.group(1),
           criteria.get("width") or "",
           criteria.get("height") or "",
           ("-%s" % "-".join([str(x) for x in opts])) if opts else "",
           criteria.get("format") or m.group(2))
    case["expected_path"] = os.path.join(EXPECTED_DATADIR, expected)
    return case


def _criteria_to_rotate_case(filename, criteria):
    m = re.match(r"^([^\.]+)\.([^\.]+)$", filename)
    if not m:
        return None
    case = dict(source_path=os.path.join(DATADIR, filename))
    case.update(criteria)
    fields = ["degree", "quality", "expand"]
    opts = filter(bool, [criteria.get(x) for x in fields])
    expected = "%s-rotate%s.%s" \
        % (m.group(1),
           ("-%s" % "-".join([str(x) for x in opts])) if opts else "",
           criteria.get("format") or m.group(2))
    case["expected_path"] = os.path.join(EXPECTED_DATADIR, expected)
    return case


def _criteria_to_region_case(filename, criteria):
    m = re.match(r"^([^\.]+)\.([^\.]+)$", filename)
    if not m:
        return None
    case = dict(source_path=os.path.join(DATADIR, filename))
    case.update(criteria)
    fields = ["rect"]
    opts = filter(bool, [criteria.get(x) for x in fields])
    expected = "%s-region%s.%s" \
        % (m.group(1),
           ("-%s" % "-".join([str(x) for x in opts])) if opts else "",
           criteria.get("format") or m.group(2))
    case["expected_path"] = os.path.join(EXPECTED_DATADIR, expected)
    return case


def _criteria_to_chained_case(filename, criteria):
    m = re.match(r"^([^\.]+)\.([^\.]+)$", filename)
    if not m:
        return None
    case = dict(source_path=os.path.join(DATADIR, filename))
    case.update(criteria)
    fields = ["degree", "rect"]
    opts = filter(bool, [criteria.get(x) for x in fields])
    expected = "%s-chained-%s-%sx%s%s.%s" \
        % (m.group(1),
           ",".join(criteria.get("operation", [])),
           criteria.get("width") or "",
           criteria.get("height") or "",
           ("-%s" % "-".join([str(x) for x in opts])) if opts else "",
           m.group(2))
    case["expected_path"] = os.path.join(EXPECTED_DATADIR, expected)
    return case

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python

from __future__ import absolute_import, division, with_statement

import logging
import sys
import textwrap

from tornado.test.util import unittest

TEST_MODULES = [
    'pilbox.test.app_test',
    'pilbox.test.errors_test',
    'pilbox.test.image_test',
    'pilbox.test.signature_test',
]


def all():
    return unittest.defaultTestLoader.loadTestsFromNames(TEST_MODULES)


class PilboxTextTestRunner(unittest.TextTestRunner):
    def run(self, test):
        result = super(PilboxTextTestRunner, self).run(test)
        if result.skipped:
            skip_reasons = set(reason for (test, reason) in result.skipped)
            self.stream.write(textwrap.fill(
                "Some tests were skipped because: %s" %
                ", ".join(sorted(skip_reasons))))
            self.stream.write("\n")
        return result


if __name__ == '__main__':
    import warnings
    # Be strict about most warnings.  This also turns on warnings that are
    # ignored by default, including DeprecationWarnings and
    # python 3.2's ResourceWarnings.
    warnings.filterwarnings("error")
    warnings.filterwarnings("ignore", category=ImportWarning)
    warnings.filterwarnings("ignore", category=DeprecationWarning)
    warnings.filterwarnings("error", category=DeprecationWarning,
                            module=r"tornado\..*")
    # The unittest module is aggressive about deprecating redundant methods,
    # leaving some without non-deprecated spellings that work on both
    # 2.7 and 3.2
    warnings.filterwarnings("ignore", category=DeprecationWarning,
                            message="Please use assert.* instead")

    logging.getLogger("tornado.access").setLevel(logging.CRITICAL)

    import tornado.testing
    kwargs = {}
    if sys.version_info >= (3, 2):
        # HACK:  unittest.main will make its own changes to the warning
        # configuration, which may conflict with the settings above
        # or command-line flags like -bb.  Passing warnings=False
        # suppresses this behavior, although this looks like an implementation
        # detail.  http://bugs.python.org/issue15626
        kwargs['warnings'] = False
    kwargs['testRunner'] = PilboxTextTestRunner
    tornado.testing.main(**kwargs)

########NEW FILE########
__FILENAME__ = signature_test
from __future__ import absolute_import, division, with_statement

import hashlib
import hmac

from tornado.test.util import unittest

from pilbox.signature import derive_signature, sign, verify_signature

try:
    import urlparse
except ImportError:
    import urllib.parse as urlparse


class SignatureTest(unittest.TestCase):
    def test_derive(self):
        key = "abc123"
        qs_list = ["x=1&y=2&z=3", "x=%20%2B%2F!%40%23%24%25%5E%26"]
        for qs in qs_list:
            m = hmac.new(key.encode(), None, hashlib.sha1)
            m.update(qs.encode())
            self.assertEqual(derive_signature(key, qs), m.hexdigest())

    def test_sign(self):
        key = "abc123"
        qs_list = ["x=1&y=2&z=3", "x=%20%2B%2F!%40%23%24%25%5E%26"]
        for qs in qs_list:
            o = urlparse.parse_qs(sign(key, qs))
            self.assertTrue("sig" in o)
            self.assertTrue(o["sig"])

    def test_verify(self):
        key = "abc123"
        qs_list = ["x=1&y=2&z=3", "x=%20%2B%2F!%40%23%24%25%5E%26"]
        for qs in qs_list:
            self.assertTrue(verify_signature(key, sign(key, qs)))

    def test_bad_signature(self):
        key1 = "abc123"
        key2 = "def456"
        qs_list = ["x=1&y=2&z=3", "x=%20%2B%2F!%40%23%24%25%5E%26"]
        for qs in qs_list:
            self.assertFalse(verify_signature(key1, sign(key2, qs)))

########NEW FILE########
