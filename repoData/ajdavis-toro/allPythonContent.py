__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Toro documentation build configuration file, created by
# sphinx-quickstart on Wed Oct 17 19:46:26 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

# Custom: Sphinx doesn't produce a useful "module index" for Toro
html_use_modindex = False

doctest_global_setup = """
import toro
"""

html_theme_options = {'collapsiblesidebar': True}

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path[0:0] = [os.path.abspath('..')]

import toro

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.viewcode', 'sphinx.ext.graphviz']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Toro'
copyright = u'2012, A. Jesse Jiryu Davis'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = toro.version
# The full version, including alpha/beta/rc tags.
release = toro.version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Torodoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Toro.tex', u'Toro Documentation',
   u'A. Jesse Jiryu Davis', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'toro', u'Toro Documentation',
     [u'A. Jesse Jiryu Davis'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Toro', u'Toro Documentation',
   u'A. Jesse Jiryu Davis', 'Toro', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = event_example
"""
An oversimplified caching HTTP proxy - start it, and configure your browser to
use localhost:8888 as the proxy server. It doesn't do cookies or redirects,
nor does it obey cache-control headers.

The point is to demonstrate :class:`~toro.Event`. Imagine a client requests a
page, and while the proxy is downloading the page from the external site, a
second client requests the same page. Since the page is not yet in cache, an
inefficient proxy would launch a second external request.

This proxy instead places an :class:`~toro.Event` in the cache, and the second
client request waits for the event to be set, thus requiring only a single
external request.
"""

# start-file
from tornado import httpclient, gen, ioloop, web
import toro


class CacheEntry(object):
    def __init__(self):
        self.event = toro.Event()
        self.type = self.body = None

cache = {}


class ProxyHandler(web.RequestHandler):
    @web.asynchronous
    @gen.coroutine
    def get(self):
        path = self.request.path
        entry = cache.get(path)
        if entry:
            # Block until the event is set, unless it's set already
            yield entry.event.wait()
        else:
            print path
            cache[path] = entry = CacheEntry()

            # Actually fetch the page
            response = yield httpclient.AsyncHTTPClient().fetch(path)
            entry.type = response.headers.get('Content-Type', 'text/html')
            entry.body = response.body
            entry.event.set()

        self.set_header('Content-Type', entry.type)
        self.write(entry.body)
        self.finish()


if __name__ == '__main__':
    print 'Listening on port 8888'
    print
    print 'Configure your web browser to use localhost:8888 as an HTTP Proxy.'
    print 'Try visiting some web pages and hitting "refresh".'
    web.Application([('.*', ProxyHandler)], debug=True).listen(8888)
    ioloop.IOLoop.instance().start()

########NEW FILE########
__FILENAME__ = lock_example
"""Graceful shutdown, an example use case for :class:`~toro.Lock`.

``poll`` continuously fetches http://tornadoweb.org, and after 5 seconds,
``shutdown`` stops the IOLoop. We want any request that ``poll`` has begun to
complete before the loop stops, so ``poll`` acquires the lock before starting
each HTTP request and releases it when the request completes. ``shutdown`` also
acquires the lock before stopping the IOLoop.

(Inspired by a post_ to the Tornado mailing list.)

.. _post: https://groups.google.com/d/topic/python-tornado/CXg5WwufOvU/discussion
"""

# start-file
import datetime
from tornado import ioloop, gen, httpclient
import toro

lock = toro.Lock()
loop = ioloop.IOLoop.current()


@gen.coroutine
def poll():
    client = httpclient.AsyncHTTPClient()
    while True:
        with (yield lock.acquire()):
            print 'Starting request'
            response = yield client.fetch('http://www.tornadoweb.org/')
            print response.code

        # Wait a tenth of a second before next request
        yield gen.Task(loop.add_timeout, datetime.timedelta(seconds=0.1))


@gen.coroutine
def shutdown():
    # Get the lock: this ensures poll() isn't in a request when we stop the
    # loop
    print 'shutdown() is acquiring the lock'
    yield lock.acquire()
    loop.stop()
    print 'Loop stopped.'


if __name__ == '__main__':
    # Start polling
    poll()

    # Arrange to shutdown cleanly 5 seconds from now
    loop.add_timeout(datetime.timedelta(seconds=5), shutdown)
    loop.start()

########NEW FILE########
__FILENAME__ = producer_consumer_example
"""A classic producer-consumer example for using :class:`~toro.JoinableQueue`.
"""

# start-file
from tornado import ioloop, gen
import toro
q = toro.JoinableQueue(maxsize=3)


@gen.coroutine
def producer():
    for item in range(10):
        print 'Sending', item
        yield q.put(item)


@gen.coroutine
def consumer():
    while True:
        item = yield q.get()
        print '\t\t', 'Got', item
        q.task_done()


if __name__ == '__main__':
    producer()
    consumer()
    loop = ioloop.IOLoop.current()

    def stop(future):
        loop.stop()
        future.result()  # Raise error if there is one

    # block until all tasks are done
    q.join().add_done_callback(stop)
    loop.start()

########NEW FILE########
__FILENAME__ = web_spider_example
"""A simple web-spider that crawls all the pages in http://tornadoweb.org.

``spider()`` downloads the page at `base_url` and any pages it links to,
recursively. It ignores pages that are not beneath `base_url` hierarchically.

This function demos two Toro classes: :class:`~toro.JoinableQueue` and
:class:`~toro.BoundedSemaphore`.
The :class:`~toro.JoinableQueue` is a work queue; it begins containing only
`base_url`, and each discovered URL is added to it. We wait for
:meth:`~toro.JoinableQueue.join` to complete before exiting. This ensures that
the function as a whole ends when all URLs have been downloaded.

The :class:`~toro.BoundedSemaphore` regulates concurrency. We block trying to
decrement the semaphore before each download, and increment it after each
download completes.
"""

# start-file
import HTMLParser
import time
import urlparse
from datetime import timedelta

from tornado import httpclient, gen, ioloop

import toro


@gen.coroutine
def spider(base_url, concurrency):
    q = toro.JoinableQueue()
    sem = toro.BoundedSemaphore(concurrency)

    start = time.time()
    fetching, fetched = set(), set()

    @gen.coroutine
    def fetch_url():
        current_url = yield q.get()
        try:
            if current_url in fetching:
                return

            print 'fetching', current_url
            fetching.add(current_url)
            urls = yield get_links_from_url(current_url)
            fetched.add(current_url)

            for new_url in urls:
                # Only follow links beneath the base URL
                if new_url.startswith(base_url):
                    yield q.put(new_url)

        finally:
            q.task_done()
            sem.release()

    @gen.coroutine
    def worker():
        while True:
            yield sem.acquire()
            # Launch a subtask
            fetch_url()

    q.put(base_url)

    # Start worker, then wait for the work queue to be empty.
    worker()
    yield q.join(deadline=timedelta(seconds=300))
    assert fetching == fetched
    print 'Done in %d seconds, fetched %s URLs.' % (
        time.time() - start, len(fetched))


@gen.coroutine
def get_links_from_url(url):
    """Download the page at `url` and parse it for links. Returned links have
    had the fragment after `#` removed, and have been made absolute so, e.g.
    the URL 'gen.html#tornado.gen.coroutine' becomes
    'http://www.tornadoweb.org/en/stable/gen.html'.
    """
    try:
        response = yield httpclient.AsyncHTTPClient().fetch(url)
        print 'fetched', url
        urls = [urlparse.urljoin(url, remove_fragment(new_url))
                for new_url in get_links(response.body)]
    except Exception, e:
        print e, url
        raise gen.Return([])

    raise gen.Return(urls)


def remove_fragment(url):
    scheme, netloc, url, params, query, fragment = urlparse.urlparse(url)
    return urlparse.urlunparse((scheme, netloc, url, params, query, ''))


def get_links(html):
    class URLSeeker(HTMLParser.HTMLParser):
        def __init__(self):
            HTMLParser.HTMLParser.__init__(self)
            self.urls = []

        def handle_starttag(self, tag, attrs):
            href = dict(attrs).get('href')
            if href and tag == 'a':
                self.urls.append(href)

    url_seeker = URLSeeker()
    url_seeker.feed(html)
    return url_seeker.urls


if __name__ == '__main__':
    import logging
    logging.basicConfig()
    loop = ioloop.IOLoop.current()
    
    def stop(future):
        loop.stop()
        future.result()  # Raise error if there is one
        
    future = spider('http://www.tornadoweb.org/en/stable/', 10)
    future.add_done_callback(stop)
    loop.start()

########NEW FILE########
__FILENAME__ = test_async_result
"""
Test toro.AsyncResult.
"""

from datetime import timedelta
from functools import partial
import time

from tornado.testing import gen_test, AsyncTestCase

import toro
from test import make_callback, assert_raises


class TestAsyncResult(AsyncTestCase):
    def test_str(self):
        result = toro.AsyncResult()
        str(result)
        result.set('fizzle')
        self.assertTrue('fizzle' in str(result))
        self.assertFalse('waiters' in str(result))

        result = toro.AsyncResult()
        result.get()
        self.assertTrue('waiters' in str(result))

    def test_get_nowait(self):
        self.assertRaises(toro.NotReady, toro.AsyncResult().get_nowait)

    @gen_test
    def test_raises_after_timeout(self):
        start = time.time()
        with assert_raises(toro.Timeout):
            async_result = toro.AsyncResult(self.io_loop)
            yield async_result.get(deadline=timedelta(seconds=0.1))

        duration = time.time() - start
        self.assertAlmostEqual(0.1, duration, places=1)

    @gen_test
    def test_set(self):
        result = toro.AsyncResult(io_loop=self.io_loop)
        self.assertFalse(result.ready())
        self.io_loop.add_timeout(
            time.time() + 0.1, partial(result.set, 'hello'))

        start = time.time()
        value = yield result.get()
        duration = time.time() - start
        self.assertAlmostEqual(0.1, duration, places=1)
        self.assertTrue(result.ready())
        self.assertEqual('hello', value)

        # Second and third get()'s work too
        self.assertEqual('hello', (yield result.get()))
        self.assertEqual('hello', (yield result.get()))

        # Non-blocking get() works
        self.assertEqual('hello', result.get_nowait())

        # set() only allowed once
        self.assertRaises(toro.AlreadySet, result.set, 'whatever')

    def test_get_callback(self):
        # Test that callbacks registered with get() run immediately after set()
        result = toro.AsyncResult(io_loop=self.io_loop)
        history = []
        result.get().add_done_callback(make_callback('get1', history))
        result.get().add_done_callback(make_callback('get2', history))
        result.set('foo')
        history.append('set')
        self.assertEqual(['get1', 'get2', 'set'], history)

    @gen_test
    def test_get_timeout(self):
        result = toro.AsyncResult(io_loop=self.io_loop)
        start = time.time()
        with assert_raises(toro.Timeout):
            yield result.get(deadline=timedelta(seconds=0.1))

        duration = time.time() - start
        self.assertAlmostEqual(0.1, duration, places=1)
        self.assertFalse(result.ready())

        # Timed-out waiter doesn't cause error
        result.set('foo')
        self.assertTrue(result.ready())
        value = yield result.get(deadline=timedelta(seconds=.01))
        self.assertEqual('foo', value)

########NEW FILE########
__FILENAME__ = test_condition
"""
Test toro.Condition.
"""

from datetime import timedelta
import time

from tornado import gen
from tornado.testing import gen_test, AsyncTestCase


import toro
from test import make_callback, assert_raises


class TestCondition(AsyncTestCase):
    def test_str(self):
        c = toro.Condition()
        self.assertTrue('Condition' in str(c))
        self.assertFalse('waiters' in str(c))
        c.wait()
        self.assertTrue('waiters' in str(c))

    @gen_test
    def test_notify(self):
        c = toro.Condition(self.io_loop)
        self.io_loop.add_timeout(time.time() + 0.1, c.notify)
        yield c.wait()

    def test_notify_1(self):
        c = toro.Condition()
        history = []
        c.wait().add_done_callback(make_callback('wait1', history))
        c.wait().add_done_callback(make_callback('wait2', history))
        c.notify(1)
        history.append('notify1')
        c.notify(1)
        history.append('notify2')
        self.assertEqual(['wait1', 'notify1', 'wait2', 'notify2'], history)

    def test_notify_n(self):
        c = toro.Condition()
        history = []
        for i in range(6):
            c.wait().add_done_callback(make_callback(i, history))

        c.notify(3)

        # Callbacks execute in the order they were registered
        self.assertEqual(list(range(3)), history)
        c.notify(1)
        self.assertEqual(list(range(4)), history)
        c.notify(2)
        self.assertEqual(list(range(6)), history)

    def test_notify_all(self):
        c = toro.Condition()
        history = []
        for i in range(4):
            c.wait().add_done_callback(make_callback(i, history))

        c.notify_all()
        history.append('notify_all')

        # Callbacks execute in the order they were registered
        self.assertEqual(
            list(range(4)) + ['notify_all'],
            history)

    @gen_test
    def test_wait_timeout(self):
        c = toro.Condition(self.io_loop)
        st = time.time()
        with assert_raises(toro.Timeout):
            yield c.wait(deadline=timedelta(seconds=0.1))

        duration = time.time() - st
        self.assertAlmostEqual(0.1, duration, places=1)

    @gen_test
    def test_wait_timeout_preempted(self):
        c = toro.Condition(self.io_loop)
        st = time.time()

        # This fires before the wait times out
        self.io_loop.add_timeout(st + .1, c.notify)
        yield c.wait(deadline=timedelta(seconds=0.2))
        duration = time.time() - st

        # Verify we were awakened by c.notify(), not by timeout
        self.assertAlmostEqual(0.1, duration, places=1)

    @gen_test
    def test_notify_n_with_timeout(self):
        # Register callbacks 0, 1, 2, and 3. Callback 1 has a timeout.
        # Wait for that timeout to expire, then do notify(2) and make
        # sure everyone runs. Verifies that a timed-out callback does
        # not count against the 'n' argument to notify().
        c = toro.Condition(self.io_loop)
        st = time.time()
        history = []

        c.wait().add_done_callback(make_callback(0, history))
        c.wait(deadline=timedelta(seconds=.1)).add_done_callback(
            make_callback(1, history))

        c.wait().add_done_callback(make_callback(2, history))
        c.wait().add_done_callback(make_callback(3, history))

        # Wait for callback 1 to time out
        yield gen.Task(self.io_loop.add_timeout, st + 0.2)
        self.assertEqual(['Timeout'], history)

        c.notify(2)
        self.assertEqual(['Timeout', 0, 2], history)
        c.notify()
        self.assertEqual(['Timeout', 0, 2, 3], history)

    @gen_test
    def test_notify_all_with_timeout(self):
        c = toro.Condition(self.io_loop)
        st = time.time()
        history = []

        c.wait().add_done_callback(make_callback(0, history))
        c.wait(deadline=timedelta(seconds=.1)).add_done_callback(
            make_callback(1, history))

        c.wait().add_done_callback(make_callback(2, history))

        # Wait for callback 1 to time out
        yield gen.Task(self.io_loop.add_timeout, st + 0.2)
        self.assertEqual(['Timeout'], history)

        c.notify_all()
        self.assertEqual(['Timeout', 0, 2], history)

########NEW FILE########
__FILENAME__ = test_event
"""
Test toro.Event.

Adapted from Gevent's lock_tests.py.
"""

from datetime import timedelta
import time

from tornado import gen
from tornado.testing import gen_test, AsyncTestCase

import toro
from test import assert_raises


class TestEvent(AsyncTestCase):
    def test_str(self):
        event = toro.Event()
        self.assertTrue('clear' in str(event))
        self.assertFalse('set' in str(event))
        event.set()
        self.assertFalse('clear' in str(event))
        self.assertTrue('set' in str(event))

    @gen.coroutine
    def test_event(self, n):
        e = toro.Event()
        futures = []
        for i in range(n):
            futures.append(e.wait())

        e.set()
        e.clear()
        yield futures

    # Not a test - called from test_event_1, etc.
    test_event.__test__ = False

    @gen_test
    def test_event_1(self):
        yield self.test_event(1)

    @gen_test
    def test_event_100(self):
        yield self.test_event(100)

    @gen_test
    def test_event_timeout(self):
        e = toro.Event()
        st = time.time()
        with assert_raises(toro.Timeout):
            yield e.wait(deadline=timedelta(seconds=0.1))

        duration = time.time() - st
        self.assertAlmostEqual(0.1, duration, places=1)

        # After a timed-out waiter, normal operation works
        st = time.time()
        self.io_loop.add_timeout(st + 0.1, e.set)
        result = yield e.wait(deadline=timedelta(seconds=1))
        duration = time.time() - st
        self.assertAlmostEqual(0.1, duration, places=1)
        self.assertEqual(None, result)

    @gen_test
    def test_event_nowait(self):
        e = toro.Event()
        e.set()
        self.assertEqual(True, e.is_set())
        yield e.wait()

########NEW FILE########
__FILENAME__ = test_lock
"""
Test toro.Lock.

Adapted from Gevent's lock_tests.py.
"""

from datetime import timedelta
import time

from tornado import gen
from tornado.testing import gen_test, AsyncTestCase


import toro
from test import make_callback, assert_raises, ContextManagerTestsMixin


# Adapted from Gevent's lock_tests.py.
class LockTests(AsyncTestCase):
    def test_acquire_release(self):
        lock = toro.Lock()
        self.assertFalse(lock.locked())
        self.assertTrue(lock.acquire())
        self.assertTrue(lock.locked())
        lock.release()
        self.assertFalse(lock.locked())

    @gen_test
    def test_acquire_contended(self):
        lock = toro.Lock()
        self.assertTrue(lock.acquire())
        N = 5

        @gen.coroutine
        def f():
            yield lock.acquire()
            lock.release()

        futures = [f() for _ in range(N)]
        lock.release()
        yield futures

    def test_reacquire(self):
        # Lock needs to be released before re-acquiring.
        lock = toro.Lock()
        phase = []

        @gen.coroutine
        def f():
            yield lock.acquire()
            self.assertTrue(lock.locked())
            phase.append(None)
            yield lock.acquire()
            self.assertTrue(lock.locked())
            phase.append(None)

        future = f()

        while len(phase) == 0:
            yield gen.Task(self.io_loop.add_callback)

        self.assertEqual(len(phase), 1)
        lock.release()
        self.assertFalse(lock.locked())
        yield future
        self.assertEqual(len(phase), 2)


# Not adapted from Gevent's tests, written just for Toro
class LockTests2(AsyncTestCase):
    def test_str(self):
        lock = toro.Lock()
        # No errors in various states
        str(lock)
        lock.acquire()
        str(lock)

    @gen_test
    def test_acquire_timeout(self):
        lock = toro.Lock()
        self.assertTrue(lock.acquire())
        self.assertTrue(lock.locked())
        st = time.time()

        with assert_raises(toro.Timeout):
            yield lock.acquire(deadline=timedelta(seconds=0.1))

        duration = time.time() - st
        self.assertAlmostEqual(0.1, duration, places=1)
        self.assertTrue(lock.locked())

    @gen_test
    def test_acquire_callback(self):
        lock = toro.Lock()
        history = []
        lock.acquire().add_done_callback(make_callback('acquire1', history))
        lock.acquire().add_done_callback(make_callback('acquire2', history))
        lock.release()
        history.append('release')
        self.assertEqual(['acquire1', 'acquire2', 'release'], history)

    def test_multi_release(self):
        lock = toro.Lock()
        lock.acquire()
        lock.release()
        self.assertRaises(RuntimeError, lock.release)


class LockContextManagerTest(ContextManagerTestsMixin, AsyncTestCase):

    toro_class = toro.Lock

########NEW FILE########
__FILENAME__ = test_queue
"""
Test toro.Queue.

There are three sections, one each for tests that are
1. adapted from Gevent's test_queue.py, except for FailingQueueTest which
    isn't applicable
2. adapted from Gevent's test__queue.py,
3. written specifically for Toro.
"""

import time
from datetime import timedelta
from Queue import Empty, Full

from tornado import gen
from tornado.ioloop import IOLoop
from tornado.testing import gen_test, AsyncTestCase


import toro
from test import make_callback, assert_raises, pause

# TODO: update from tulip tests

# SECTION 1: Tests adapted from Gevent's test_queue.py (single underscore)

QUEUE_SIZE = 5


class QueueTest1(AsyncTestCase):
    type2test = toro.Queue

    @gen.coroutine
    def simple_queue_test(self, q):
        if not q.empty():
            raise RuntimeError("Call this function with an empty queue")
        # I guess we better check things actually queue correctly a little :)
        q.put_nowait(111)
        q.put_nowait(333)
        q.put_nowait(222)
        target_order = dict(Queue=[111, 333, 222],
                            LifoQueue=[222, 333, 111],
                            PriorityQueue=[111, 222, 333])
        actual_order = [q.get_nowait(), q.get_nowait(), q.get_nowait()]
        self.assertEquals(actual_order, target_order[q.__class__.__name__],
                          "Didn't seem to queue the correct data!")
        for i in range(QUEUE_SIZE-1):
            q.put_nowait(i)
            self.assert_(not q.empty(), "Queue should not be empty")
        self.assert_(not q.full(), "Queue should not be full")
        q.put_nowait(444)
        self.assert_(q.full(), "Queue should be full")
        try:
            q.put_nowait(555)
            self.fail("Didn't appear to block with a full queue")
        except Full:
            pass

        with assert_raises(toro.Timeout):
            yield q.put(555, deadline=timedelta(seconds=0.01))

        self.assertEquals(q.qsize(), QUEUE_SIZE)
        # Empty it
        for i in range(QUEUE_SIZE):
            q.get_nowait()
        self.assert_(q.empty(), "Queue should be empty")
        try:
            q.get_nowait()
            self.fail("Didn't appear to block with an empty queue")
        except Empty:
            pass

        with assert_raises(toro.Timeout):
            yield q.get(deadline=timedelta(seconds=0.01))

    simple_queue_test.__test__ = False  # Hide from nose

    @gen_test
    def test_simple_queue(self):
        # Do it a couple of times on the same queue.
        # Done twice to make sure works with same instance reused.
        q = self.type2test(QUEUE_SIZE)
        yield self.simple_queue_test(q)
        yield self.simple_queue_test(q)


class LifoQueueTest1(QueueTest1):
    type2test = toro.LifoQueue


class PriorityQueueTest1(QueueTest1):
    type2test = toro.PriorityQueue


class TestJoinableQueue1(AsyncTestCase):
    def setUp(self):
        super(TestJoinableQueue1, self).setUp()
        self.cum = 0

    def test_queue_task_done(self):
        # Test to make sure a queue task completed successfully.
        q = toro.JoinableQueue()
        try:
            q.task_done()
        except ValueError:
            pass
        else:
            self.fail("Did not detect task count going negative")

    @gen.coroutine
    def worker(self, q):
        while True:
            x = yield q.get()
            if x is None:
                q.task_done()
                break

            self.cum += x
            q.task_done()

    @gen.coroutine
    def queue_join_test(self, q):
        self.cum = 0
        for i in (0,1):
            self.worker(q)
        for i in xrange(100):
            q.put(i)
        yield q.join()
        self.assertEquals(self.cum, sum(range(100)),
                          "q.join() did not block until all tasks were done")
        for i in (0,1):
            q.put(None)         # instruct the tasks to end
        yield q.join()          # verify that you can join twice

    queue_join_test.__test__ = False # It's a utility, hide it from nosetests

    @gen_test
    def test_queue_join(self):
        # Test that a queue join()s successfully, and before anything else
        # (done twice for insurance).
        q = toro.JoinableQueue()
        yield self.queue_join_test(q)
        yield self.queue_join_test(q)
        try:
            q.task_done()
        except ValueError:
            pass
        else:
            self.fail("Did not detect task count going negative")


# SECTION 2: Tests adapted from Gevent's test__queue.py (double underscore)

class TestQueue2(AsyncTestCase):
    def test_repr(self):
        # No exceptions
        str(toro.Queue())
        repr(toro.Queue())

    @gen_test
    def test_send_first(self):
        q = toro.Queue()
        yield q.put('hi')
        self.assertEqual('hi', (yield q.get()))

    @gen_test
    def test_send_last(self):
        q = toro.Queue()

        @gen.coroutine
        def f():
            val = yield q.get()
            self.assertEqual('hi2', val)
            yield q.put('ok')

        # Start a task; blocks on get() until we do a put()
        f()
        yield q.put('hi2')
        self.assertEqual('ok', (yield q.get()))

    @gen_test
    def test_max_size(self):
        q = toro.Queue(2)
        results = []

        @gen.coroutine
        def putter():
            yield q.put('a')
            results.append('a')
            yield q.put('b')
            results.append('b')
            yield q.put('c')
            results.append('c')

        future = putter()
        yield pause(timedelta(seconds=.01))
        self.assertEquals(results, ['a', 'b'])
        self.assertEquals((yield q.get()), 'a')
        yield pause(timedelta(seconds=.01))
        self.assertEquals(results, ['a', 'b', 'c'])
        self.assertEquals((yield q.get()), 'b')
        self.assertEquals((yield q.get()), 'c')
        yield future

    @gen_test
    def test_multiple_waiters(self):
        # tests that multiple waiters get their results back
        q = toro.Queue()

        @gen.coroutine
        def waiter(q, evt):
            evt.set((yield q.get()))

        sendings = ['1', '2', '3', '4']
        evts = [toro.AsyncResult() for x in sendings]
        for i, x in enumerate(sendings):
            waiter(q, evts[i]) # start task

        @gen.coroutine
        def collect_pending_results():
            results = set()
            for e in evts:
                if e.ready():
                    # Won't block
                    x = yield e.get()
                    results.add(x)
            raise gen.Return(len(results))

        yield q.put(sendings[0])
        yield pause(timedelta(seconds=.01))
        self.assertEquals((yield collect_pending_results()), 1)
        yield q.put(sendings[1])
        yield pause(timedelta(seconds=.01))
        self.assertEquals((yield collect_pending_results()), 2)
        yield q.put(sendings[2])
        yield q.put(sendings[3])
        yield pause(timedelta(seconds=.01))
        self.assertEquals((yield collect_pending_results()), 4)

    @gen_test
    def test_senders_that_die(self):
        q = toro.Queue()

        @gen.coroutine
        def do_send(q):
            yield q.put('sent')

        future = do_send(q)
        self.assertEquals((yield q.get()), 'sent')
        yield future


class TestJoinEmpty2(AsyncTestCase):

    @gen_test
    def test_issue_45(self):
        # Test that join() exits immediately if not jobs were put into the queue
        # From Gevent's test_issue_45()
        self.switch_expected = False
        q = toro.JoinableQueue()
        yield q.join()


# SECTION 3: Tests written specifically for Toro

def bad_get_callback(_):
    raise Exception('Intentional exception in get callback')


def bad_put_callback(_):
    raise Exception('Intentional exception in put callback')


class TestQueue3(AsyncTestCase):
    def test_str(self):
        self.assertTrue('Queue' in str(toro.Queue()))
        self.assertTrue('maxsize=11' in str(toro.Queue(11)))

        q = toro.Queue()
        for i in range(7):
            q.get()
        self.assertTrue('getters[7]' in str(q))

        q = toro.Queue(1)
        for i in range(5):
            q.put('foo')
        self.assertTrue('putters[4]' in str(q))

        q = toro.Queue(1)
        self.assertFalse('queue=' in str(q))
        q.put('foo')
        self.assertTrue('queue=' in str(q))

    def test_maxsize(self):
        self.assertRaises(TypeError, toro.Queue, None)
        self.assertRaises(ValueError, toro.Queue, -1)

    def test_full(self):
        q = toro.Queue()
        self.assertFalse(q.full())
        self.assertEqual(q.maxsize, 0)

        q = toro.Queue(1)
        self.assertEqual(q.maxsize, 1)
        self.assertFalse(q.full())
        q.put('foo')
        self.assertTrue(q.full())

    def test_callback_checking(self):
        self.assertRaises(TypeError, toro.Queue().get, callback='foo')
        self.assertRaises(TypeError, toro.Queue().get, callback=1)

    def test_io_loop(self):
        global_loop = self.io_loop
        custom_loop = IOLoop()
        self.assertNotEqual(global_loop, custom_loop)
        q = toro.Queue(io_loop=custom_loop)

        def callback(future):
            assert future.result() == 'foo'
            custom_loop.stop()

        q.get().add_done_callback(callback)
        q.put('foo')
        custom_loop.start()


class TestQueueTimeouts3(AsyncTestCase):
    @gen_test
    def test_get_timeout(self):
        q = toro.Queue()
        st = time.time()
        with assert_raises(toro.Timeout):
            yield q.get(deadline=timedelta(seconds=0.1))

        duration = time.time() - st
        self.assertAlmostEqual(0.1, duration, places=1)

        # Make sure that putting and getting a value returns Queue to initial
        # state
        q.put(1)
        self.assertEqual(
            1, (yield q.get(deadline=timedelta(seconds=0.1))))

        st = time.time()
        with assert_raises(toro.Timeout):
            yield q.get(deadline=timedelta(seconds=0.1))

        duration = time.time() - st
        self.assertAlmostEqual(0.1, duration, places=1)

    @gen_test
    def test_put_timeout(self):
        q = toro.Queue(1)
        q.put(1)
        st = time.time()
        with assert_raises(toro.Timeout):
            yield q.put(2, deadline=timedelta(seconds=0.1))

        duration = time.time() - st
        self.assertAlmostEqual(0.1, duration, places=1)

        # Make sure that getting and putting a value returns Queue to initial
        # state
        self.assertEqual(1, (yield q.get()))
        yield q.put(1, deadline=timedelta(seconds=0.1))

        st = time.time()
        with assert_raises(toro.Timeout):
            yield q.put(2, deadline=timedelta(seconds=0.1))

        duration = time.time() - st
        self.assertAlmostEqual(0.1, duration, places=1)


class TestJoinableQueue3(AsyncTestCase):
    def test_str(self):
        q = toro.JoinableQueue()
        self.assertTrue('JoinableQueue' in str(q))
        self.assertFalse('tasks' in str(q))
        q.put('foo')
        self.assertTrue('tasks' in str(q))

    @gen_test
    def test_queue_join(self):
        q = toro.JoinableQueue()
        yield q.put('foo')
        yield q.put('bar')
        self.assertEqual(2, q.unfinished_tasks)
        future = q.join()

        q.task_done()
        self.assertEqual(1, q.unfinished_tasks)
        q.task_done()
        self.assertEqual(0, q.unfinished_tasks)
        yield future

    @gen_test
    def test_queue_join_callback(self):
        # Test that callbacks passed to join() run immediately after task_done()
        q = toro.JoinableQueue()
        history = []
        q.put('foo')
        q.put('foo')
        q.join().add_done_callback(make_callback('join', history))
        q.task_done()
        history.append('task_done1')
        q.task_done()
        history.append('task_done2')
        self.assertEqual(['task_done1', 'join', 'task_done2'], history)

    @gen_test
    def test_queue_join_timeout(self):
        q = toro.JoinableQueue()
        q.put(1)
        st = time.time()
        with assert_raises(toro.Timeout):
            yield q.join(deadline=timedelta(seconds=0.1))

        duration = time.time() - st
        self.assertAlmostEqual(0.1, duration, places=1)
        self.assertEqual(1, q.unfinished_tasks)

    def test_io_loop(self):
        global_loop = self.io_loop
        custom_loop = IOLoop()
        self.assertNotEqual(global_loop, custom_loop)
        q = toro.JoinableQueue(io_loop=custom_loop)

        def callback(future):
            assert future.result() == 'foo'
            custom_loop.stop()

        q.get().add_done_callback(callback)
        q.put('foo')
        custom_loop.start()

    @gen_test
    def test_queue_join_clear(self):
        # Verify that join() blocks again after a task is added
        q = toro.JoinableQueue()
        q.put_nowait('foo')
        q.task_done()

        # The _finished Event is set
        yield q.join()
        yield q.join()

        # Unset the event
        q.put_nowait('bar')

        with assert_raises(toro.Timeout):
            yield q.join(deadline=timedelta(seconds=0.1))

        q.task_done()
        yield q.join()  # The Event is set again.

########NEW FILE########
__FILENAME__ = test_semaphore
"""
Test toro.Semaphore.

Adapted from Gevent's lock_tests.py and test__semaphore.py.
"""

from datetime import timedelta
import time
import sys

from tornado import gen
from tornado.testing import gen_test, AsyncTestCase

import toro
from test import make_callback, assert_raises, ContextManagerTestsMixin


# Adapted from Gevent's lock_tests.py
class BaseSemaphoreTests(AsyncTestCase):
    semtype = None

    def test_constructor(self):
        self.assertRaises(ValueError, self.semtype, value = -1)
        self.assertRaises(ValueError, self.semtype, value = -sys.maxint)

    def test_str(self):
        q = self.semtype(5)
        self.assertTrue(self.semtype.__name__ in str(q))
        self.assertTrue('counter=5' in str(q))

    @gen_test
    def test_acquire(self):
        sem = self.semtype(1)
        self.assertFalse(sem.locked())
        result = sem.acquire()
        self.assertTrue(result)
        self.assertTrue(sem.locked())
        # Wait for release()
        future = sem.wait()
        sem.release()
        yield future

        # Now wait() is instant
        yield sem.wait()

        sem = self.semtype(2)
        sem.acquire()
        sem.acquire()
        sem.release()
        sem.release()

    @gen_test
    def test_acquire_contended(self):
        sem = self.semtype(7)
        sem.acquire()
        N = 10
        results1 = []
        results2 = []
        phase_num = 0

        @gen.coroutine
        def f():
            yield sem.acquire()
            results1.append(phase_num)
            yield sem.acquire()
            results2.append(phase_num)

        # Start independent tasks
        for i in range(N):
            f()

        # Let them all run until the counter reaches 0
        while len(results1) + len(results2) < 6:
            yield gen.Task(self.io_loop.add_callback)

        self.assertEqual(results1 + results2, [0] * 6)
        phase_num = 1

        for i in range(7):
            sem.release()

        while len(results1) + len(results2) < 13:
            yield gen.Task(self.io_loop.add_callback)

        self.assertEqual(sorted(results1 + results2), [0] * 6 + [1] * 7)
        phase_num = 2

        for i in range(6):
            sem.release()

        while len(results1) + len(results2) < 19:
            yield gen.Task(self.io_loop.add_callback)

        self.assertEqual(sorted(results1 + results2), [0] * 6 + [1] * 7 + [2] * 6)

        # The semaphore is still locked
        self.assertTrue(sem.locked())
        with assert_raises(toro.Timeout):
            yield sem.acquire(deadline=timedelta(seconds=0.1))

        # Final release, to let the last task finish
        sem.release()

    def test_try_acquire(self):
        sem = self.semtype(2)
        yield sem.acquire()
        yield sem.acquire()
        with assert_raises(toro.Timeout):
            yield sem.acquire(deadline=timedelta(seconds=0.1))

        sem.release()
        yield sem.acquire()

    @gen_test
    def test_default_value(self):
        # The default initial value is 1.
        sem = self.semtype()
        sem.acquire()

        f_finished = [False]

        @gen.coroutine
        def f():
            yield sem.acquire()

            # Allow switching
            yield gen.Task(self.io_loop.add_callback)
            sem.release()
            f_finished[0] = True

        future = f()

        # Let f run
        yield gen.Task(self.io_loop.add_timeout, time.time() + 0.01)
        self.assertFalse(f_finished[0])
        sem.release()
        yield future


# Not a test - called from SemaphoreTests and BoundedSemaphoreTests
BaseSemaphoreTests.__test__ = False


class SemaphoreTests(BaseSemaphoreTests):
    """
    Tests for unbounded semaphores.
    """
    semtype = toro.Semaphore

    def test_release_unacquired(self):
        # Unbounded releases are allowed and increment the semaphore's value
        sem = self.semtype(1)
        sem.release()
        sem.acquire()
        sem.acquire()
        sem.release()

SemaphoreTests.__test__ = True


class BoundedSemaphoreTests(BaseSemaphoreTests):
    """
    Tests for bounded semaphores.
    """
    semtype = toro.BoundedSemaphore

    def test_release_unacquired(self):
        # Cannot go past the initial value
        sem = self.semtype()
        self.assertRaises(ValueError, sem.release)
        sem.acquire()
        sem.release()
        self.assertRaises(ValueError, sem.release)

BoundedSemaphoreTests.__test__ = True


# Adapted from Gevent's test__semaphore.py
class TestTimeoutAcquire(AsyncTestCase):
    @gen_test
    def test_timeout_acquire(self):
        s = toro.Semaphore(value=0)
        with assert_raises(toro.Timeout):
            yield s.acquire(deadline=timedelta(seconds=0.01))

    @gen_test
    def test_release_twice(self):
        s = toro.Semaphore()
        result = []
        s.acquire().add_done_callback(lambda x: result.append('a'))
        s.release()
        s.acquire().add_done_callback(lambda x: result.append('b'))
        s.release()
        yield gen.Task(self.io_loop.add_timeout, time.time() + 0.01)
        self.assertEqual(result, ['a', 'b'])


# Not adapted from Gevent's tests, specific to Toro
class SemaphoreTests2(AsyncTestCase):
    def test_repr(self):
        # No exceptions
        str(toro.Semaphore())
        repr(toro.Semaphore())

    @gen_test
    def test_acquire_callback(self):
        # Test that callbacks passed to acquire() run immediately after
        # release(), and that wait() callbacks aren't run until a release()
        # with no waiters on acquire().
        sem = toro.Semaphore(0)
        history = []
        sem.acquire().add_done_callback(make_callback('acquire1', history))
        sem.acquire().add_done_callback(make_callback('acquire2', history))

        def wait_callback(name):
            def cb(_):
                self.assertFalse(sem.locked())
                history.append(name)
            return cb

        sem.wait().add_done_callback(wait_callback('wait1'))
        sem.wait().add_done_callback(wait_callback('wait2'))
        sem.release()
        history.append('release1')
        sem.release()
        history.append('release2')
        sem.release()
        history.append('release3')
        self.assertEqual([
            # First release wakes first acquire
            'acquire1', 'release1',

            # Second release wakes second acquire
            'acquire2', 'release2',

            # Third release wakes all waits
            'wait1', 'wait2', 'release3'
        ], history)


class SemaphoreContextManagerTest(ContextManagerTestsMixin, AsyncTestCase):

    toro_class = toro.Semaphore

########NEW FILE########
