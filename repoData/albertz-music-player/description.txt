Compare to MPD
==============

[Music Player Daemon (MPD)](http://musicpd.org) is a music player server which doesn't come with its own GUI but defines an API to control it. Thus, it is only a backend. [Many independent clients / frontends](http://mpd.wikia.com/wiki/Clients) exist.

By that definition, MPD can be very much compared to the core of this Music Player which also doesn't really need a GUI and has several interfaces / APIs to control it - although this player also has some additional optional GUIs and it tries to start one of them by default.

There are some notable differences between this player engine and MPD:

* The main feature of this player is the semi-intelligent infinite main queue. If you didn't specified any further songs explicitely, it will automatically select some for you. It will select higher-liked songs more often and tries to select songs which match the current context with a higher probability.

  There is nothing alike in MPD.

* In MPD, you have several playlists and one of it is the current playlist. A playlist is a finite strictly ordered list of songs. One of the songs of the current playlist is the song which is currently played.

  In this player, there is only one main queue which is always an infinite list of songs. The first entry is always the entry which will be played next. Once it is going to be played, it is removed from the queue - the current song is not part of the queue. The list of recently played songs is completely indepdendent.

  There can be multiple implementations of the main queue. Currently there is only one where you can add songs manually and where it will automatically semi-intelligently select further songs.

* MPD has a strictly integraded music database. MPD can also play arbitrary files but most clients only allow you to add songs to a playlist from the database. Many clients also request the full database on connect.

  In this player, the database is completely optional. It was mostly meant to make searching faster / easier and to store some statistics and extra user information (such as rating).

  The idea is that the user does not manage the music inside the player but manages the music directory the way she/he wants.

  Thus, the database is also designed in a way that file moves / renames aren't problematic and even converts to other formats isn't - the database will still find the songs.

  Also, it is designed with the expectation that the music directory / potential database is way to huge to fully copy a list of all songs to a frontend.

* This player has a ReplayGain analyzing algorithm builtin. It is used automatically to normalize the volume loudness.

  MPD does not have that. Although it can read such information from metatags and apply them. But it fails if these information are not present in the metatags. In practice, if you have songs from many different sources and you don't always analyze all the songs manually with some ReplayGain-tagger, you don't have reliable volume loudness normalization in MPD.

* This player comes with a builtin AcoustID fingerprint generator. This is used by some parts of the player, e.g. for the database to identify songs and also for [MusicBrainz](http://musicbrainz.org) lookups.

Note that this player also has a [basic implementation of the MPD backend protocol](https://github.com/albertz/music-player/blob/master/mpdBackend.readme.md), i.e. you can use this player to some degree as a replacement to MPD. But because of the difference of both players, not all functions of this player engine are available for MPD clients.


Development notes
=================

In here are a few notes about how the code is organized, used concepts, etc.

The main code is all pure Python. It is highly modular. The main playing engine is implemented in C/C++ as a Python module ([`ffmpeg.c`](https://github.com/albertz/music-player/blob/master/ffmpeg.c) and related). It uses [FFmpeg](http://ffmpeg.org/) for decoding and [PortAudio](http://www.portaudio.com/) for output.

A basic principle is to keep the code as simple as possible so that it works. I really want to avoid to overcomplicate things.

The main entry point is [`main`](https://github.com/albertz/music-player/blob/master/main.py). It initializes all the modules. The list of modules is defined in [`State.modules`](https://github.com/albertz/music-player/blob/master/State.py). It contains for example `queue`, `tracker`, `mediakeys`, `gui`, etc.


## Module

A module is controlled by the `utils.Module` class. It refers to a Python module (for example `queue`).

When you start a module (`Module.start`), it starts a new thread and executes the `<modulename>Main` function.

A module is supposed to be reloadable. There is the function `Module.reload` and `State.reloadModules` is supposed to reload all modules. This is mostly only used for/while debugging, though and is probably not stable and not well tested.


## Multithreading and multiprocessing

The whole code makes heavy use of multithreading and multiprocessing. Every module already runs in its own thread. But some modules itself spawn also other threads. The GUI module spawns a new thread for most actions. Heavy calculations should be done in a seperate process so that the GUI and the playing engine (which run both in the main process) are always responsive. There is `utils.AsyncTask` and `utils.asyncCall` for an easy and stable way to do something in a seperate process.


## Playing engine

This is all the [Python native-C/C++ module](https://github.com/albertz/music-player-core/).

The `player` module creates the player object as `State.state.player`. It setups the queue as `queue.queue`. `State.state` provides also some functions to control the player state (`playPause`, `nextSong`).


## GUI

The basic idea is that Python objects are directly represented in the GUI. The main window corresponds to the `State.state` object. Attributes of an object which should be shown in the GUI are marked via the `utils.UserAttrib` decorator. There, you can specify some further information to specify more concretely how an attribute should be displayed.

The GUI has its own module [`gui`](https://github.com/albertz/music-player/blob/master/gui.py). At the moment, only an OSX Cocoa interface ([`guiCocoa`](https://github.com/albertz/music-player/blob/master/guiCocoa.py)) is implemented but a PyQt implementation is planned. There is some special handling for this module as it needs to be run in the main thread in most cases. See `main` for further reference.


## Database

This is the module [`songdb`](https://github.com/albertz/music-player/blob/master/songdb.py).

The database is intended to be an optional system which stores some extra data/statistics about a song and also caches some data which is heavy to calculate (e.g. the fingerprint).

It provides several ways to identify a song:

- By the SHA1 of its path name (relative to the users home dir).
- By the SHA1 of its file.
- By the SHA1 of its AcoustId fingerprint.

This is so that the database stays robust in case the user moves a song file around or changes its metadata.

It uses [SQLite](http://www.sqlite.org/) as its backend. (As it is used mostly as a key/value store with optional external indexing, a complex SQL-like DB is not strictly needed. Earlier, I tried other DBs. For a history, see the [comment in the source](https://github.com/albertz/music-player/blob/master/songdb.py).)

It uses [binstruct](https://github.com/albertz/binstruct) for the serialization.


## Song attribute knowledge system

Some of the initial ideas are presented in [`attribs.txt`](https://github.com/albertz/music-player/blob/master/attribs.txt). This is implemented now mostly for the [`Song` class](https://github.com/albertz/music-player/blob/master/Song.py).

There are several sources where we can get some song attribute from:

- The local `song.__dict__`.
- The database.
- The file metadata (e.g. artist, title, duration).
- Calculate it from the file (e.g. duration, fingerprint, ReplayGain).
- Look it up from some Internet service like MusicBrainz.

To have a generic attribute read interface which captures all different cases, there is the function:

    Song.get(self, attrib, timeout, accuracy)

For each attrib, there might be functions:

- `Song._estimate_<attrib>`, which is supposed to be fast. This is called no matter what the `timeout` is, in case we did not get it from the database.
- `Song._calc_<attrib>`, which is supposed to return the exact value but is heavy to call. If this is needed, it will be executed in a seperate process.

See [`Song`](https://github.com/albertz/music-player/blob/master/Song.py) for further reference.


## Playlist queue

The playlist queue is managed by the [`queue`](https://github.com/albertz/music-player/blob/master/queue.py) module. It has the logic to autofill the queue if there are too less songs in it. The algorithm to automatically select a new song uses the random file queue generator. This is a lazy directory unfolder and random picker, implemented in [`RandomFileQueue`](https://github.com/albertz/music-player/blob/master/RandomFileQueue.py). Every time, it looks at a few songs and selects some song based on

- the song rating,
- the current recently played context (mostly the song genre / tag map).


## Debugging

The module [`stdinconsole`](stdinconsole.py), when started with `--shell`, provides a handy IPython shell to the running application (in addition to the GUI which is still loaded). This is quite helpful to play around. In addition, as said earlier, all the modules are reloadable. I made this so I don't need to interrupt my music playing when playing with the code.

+++++++++++++
Fault handler
+++++++++++++

Fault handler for SIGSEGV, SIGFPE, SIGABRT, SIGBUS and SIGILL signals: display
the Python traceback and restore the previous handler. Allocate an alternate
stack for this handler, if sigaltstack() is available, to be able to allocate
memory on the stack, even on stack overflow (not available on Windows).

Import the module and call faulthandler.enable() to enable the fault handler.

The fault handler is called on catastrophic cases and so it can only use
signal-safe functions (eg. it doesn't allocate memory on the heap). That's why
the traceback is limited: it only supports ASCII encoding (use the
backslashreplace error handler for non-ASCII characters) and limits each string
to 100 characters, doesn't print the source code in the traceback (only the
filename, the function name and the line number), is limited to 100 frames and
100 threads.

By default, the Python traceback is written to the standard error stream. Start
your graphical applications in a terminal and run your server in foreground to
see the traceback, or pass a file to faulthandler.enable().

faulthandler is implemented in C using signal handlers to be able to dump a
traceback on a crash or when Python is blocked (eg. deadlock).

Website:
https://github.com/haypo/faulthandler/wiki/

faulthandler is part of Python since Python 3.3:
http://docs.python.org/dev/library/faulthandler.html


Example
=======

Example of a segmentation fault on Linux: ::

    $ python
    >>> import faulthandler
    >>> faulthandler.enable()
    >>> faulthandler._sigsegv()
    Fatal Python error: Segmentation fault

    Traceback (most recent call first):
      File "<stdin>", line 1 in <module>
    Segmentation fault


Installation
============

To install faulthandler module, type the following command: ::

    python setup.py install

Then you can test your setup using the following command: ::

    python tests.py

You need a C compiler (eg. gcc) and Python headers to build the faulthandler
module. Eg. on Fedora, you have to install python-devel package (sudo yum
install python-devel).


faulthandler module API
=======================

There are 4 different ways to display the Python traceback:

 * enable(): on a crash
 * dump_traceback_later(): after a timeout (useful if your program hangs)
 * register(): by sending a signal (eg. SIGUSR1). It doesn't work on Windows.
 * dump_traceback(): explicitly

Fault handler state (disabled by default):

 * enable(file=sys.stderr, all_threads=False): enable the fault handler
 * disable(): disable the fault handler
 * is_enabled(): get the status of the fault handler

Dump the current traceback:

 * dump_traceback(file=sys.stderr, all_threads=False): dump traceback of the
   current thread, or of all threads if all_threads is True, into file
 * dump_traceback_later(timeout, repeat=False, file=sys.stderr,
   exit=False): dump the traceback of all threads in timeout seconds, or each
   timeout seconds if repeat is True. If the function is called twice, the new
   call replaces previous parameters. Exit immediatly if exit is True.
 * cancel_dump_traceback_later(): cancel the previous call to
   dump_traceback_later()

dump_traceback_later() is implemented using the SIGALRM signal and the alarm()
function: if the signal handler is called during a system call, the system call
is interrupted (return EINTR). It it not available on Windows.

enable() and dump_traceback_later() keep an internal reference to the output
file. Use disable() and cancel_dump_traceback_later() to clear this reference.

Dump the traceback on an user signal:

 * register(signum, file=sys.stderr, all_threads=False, chain=False): register
   an handler for the signal 'signum': dump the traceback of the current
   thread, or of all threads if all_threads is True, into file". Call the
   previous handler if chain is ``True``. Not available on Windows.
 * unregister(signum): unregister the handler of the signal 'signum' registered
   by register(). Not available on Windows.

Functions to test the fault handler:

 * _fatal_error(message): Exit Python with a fatal error, call Py_FatalError()
   with message.
 * _read_null(): read from the NULL pointer (raise SIGSEGV or SIGBUS depending
   on the platform)
 * _sigabrt(): raise a SIGABRT signal (Aborted)
 * _sigbus(): raise a SIGBUS signal (Bus error)
 * _sigfpe(): raise a SIGFPE signal (Floating point exception), do a division by
   zero
 * _sigill(): raise a SIGILL signal (Illegal instruction)
 * _sigsegv(): raise a SIGSEGV signal (Segmentation fault), read memory from
   NULL (address 0)
 * _stack_overflow(): raise a stack overflow error. Not available on all
   platforms.

register(), unregister(), sigbus() and sigill() are not available on all
operation systems.

faulthandler.version_info is the module version as a tuple: (major, minor),
faulthandler.__version__ is the module version as a string (e.g. "2.0").


Changelog
=========

Version 2.2 (work in progress)
------------------------------

 * Rename dump_tracebacks_later() to dump_traceback_later()
 * Fix handling of errno variable in the handler of user signals
 * Fix the handler of user signals: chain the previous signal
   handler even if getting the current thread state failed

Version 2.1 (2012-02-05)
------------------------

Major changes:

 * Add an optional chain argument to faulthandler.register()

Minor changes:

 * Fix faulthandler._sigsegv() for Clang 3.0
 * Fix compilation on Visual Studio

Version 2.0 (2011-05-10)
------------------------

Major changes:

 * faulthandler is now part of Python 3.3
 * enable() handles also the SIGABRT signal
 * Add exit option to dump_traceback_later(): if True, exit the program
   on timeout after dumping the traceback

Other changes:

 * Change default value of the all_threads argument: dump all threads by
   default because under some rare conditions, it is not possible to get
   the current thread
 * Save/restore errno in signal handlers
 * dump_traceback_later() always dump all threads: remove all_threads option
 * Add faulthandler.__version__ attribute (module version as a string)
 * faulthandler.version is now a tuple
 * Rename:

   * dump_traceback_later() to dump_traceback_later()
   * cancel_dump_traceback_later() to cancel_dump_traceback_later()
   * sigsegv() to _sigsegv()
   * sigfpe() to _sigfpe()
   * sigbus() to _sigbus()
   * sigill() to _sigill()

 * register() and unregister() are no more available on Windows. They were
   useless: only SIGSEGV, SIGABRT and SIGILL can be handled by the application,
   and these signals can only be handled by enable().
 * Add _fatal_error(), _read_null(), _sigabrt() and _stack_overflow() test
   functions
 * register() uses sigaction() SA_RESTART flag to try to not interrupt the
   current system call
 * The fault handler calls the previous signal handler, using sigaction()
   SA_NODEFER flag to call it immediatly
 * enable() raises an OSError if it was not possible to register a signal
   handler
 * Set module size to 0, instead of -1, to be able to unload the module with
   Python 3
 * Fix a reference leak in dump_traceback_later()
 * Fix register() if it called twice with the same signal
 * Implement m_traverse for Python 3 to help the garbage collector
 * Move code from faulthandler/\*.c to faulthandler.c and traceback.c: the code
   is simpler and it was easier to integrate faulthandler into Python 3.3 using
   one file (traceback.c already existed in Python)
 * register() uses a static list for all signals instead of reallocating memory
   each time a new signal is registered, because the list is shared with the
   signal handler which may be called anytime.

Version 1.5 (2011-03-24)
------------------------

 * Conform to the PEP 8:

   * Rename isenabled() to is_enabled()
   * Rename dumpbacktrace() to dump_traceback()
   * Rename dumpbacktrace_later() to dump_traceback_later()
   * Rename cancel_dumpbacktrace_later() to cancel_dump_traceback_later()

 * Limit strings to 100 characters
 * dump_traceback_later() signal handler doesn't clear its reference to the
   file, because Py_CLEAR() is not signal safe: you have to call explicitly
   cancel_dump_traceback_later()

Version 1.4 (2011-02-14)
------------------------

 * Add register() and unregister() functions
 * Add optional all_threads argument to enable()
 * Limit the backtrace to 100 threads
 * Allocate an alternative stack for the fatal signal handler to be able to
   display a backtrace on a stack overflow (define HAVE_SIGALTSTACK). Not
   available on Windows.

Version 1.3 (2011-01-31)
------------------------

 * Don't compile dumpbacktrace_later() and cancel_dumpbacktrace_later() on
   Windows because alarm() is missing

Version 1.2 (2011-01-31)
------------------------

 * Add dumpbacktrace_later() and cancel_dumpbacktrace_later() function
 * enable() and dumpbacktrace() get an optional file argument
 * Replace dumpbacktrace_threads() function by a new dumpbacktrace() argument:
   dumpbacktrace(all_threads=True)
 * enable() gets the file descriptor of sys.stderr instead of using the file
   descriptor 2

Version 1.1 (2011-01-03)
------------------------

 * Disable the handler by default, because pkgutil may load the module and so
   enable the handler which is unexpected
 * Add dumpbacktrace() and dumpbacktrace_threads() functions
 * sigill() is available on Windows thanks to Martin's patch
 * Fix dump_ascii() for signed char type (eg. on FreeBSD)
 * Fix tests.py for Python 2.5

Version 1.0 (2010-12-24)
------------------------

 * First public release


Status
======

 * 2011-01-31: Version 1.2 tested with Python 2.5, 2.6, 2.7, 3.1 and 3.2 on
   Debian Sid
 * 2010-12-24: Tested with Python 2.6, 3.1 and 3.2 on Debian Sid
 * 2010-12-24: Tested with Python 2.6 and 3.1 on Windows XP


Similar projects
================

Python debuggers:

 * minidumper is a C extension for writing "minidumps" for post-mortem analysis
   of crashes in Python or its extensions:
   https://bitbucket.org/briancurtin/minidumper/
 * tipper: write the traceback of the current thread into a file on SIGUSR1
   signal: http://pypi.python.org/pypi/tipper/
 * crier: write the traceback of the current thread into a file
   (eg. /tmp/dump-<pid>) if a "request" file is created (eg. /tmp/crier-<pid>).
   Implemented using a thread. https://gist.github.com/737056
 * Python WAD (Wrapped Application Debugger), not update since 2001:
   http://www.dabeaz.com/papers/Python2001/python.html

Application fault handlers:

 * The GNU libc has a fault handler in debug/segfault.c
 * XEmacs has a fault handler displaying the Lisp traceback
 * RPy has a fault handler

System-wide fault handlers:

 * Ubuntu uses Apport: https://wiki.ubuntu.com/Apport
 * The Linux kernel logs also segfaults into /var/log/kern.log (and
   /var/log/syslog). /proc/sys/kernel/core_pattern contols how coredumps are
   created.
 * Windows opens a popup on a fatal error asking if the error should be
   reported to Microsoft


See also
========

 * http://bugs.python.org/issue8863 (may 2010):
   Display Python backtrace on SIGSEGV, SIGFPE and fatal error
 * http://bugs.python.org/issue3999 (sept. 2008):
   Real segmentation fault handler


===============
PyObjC Examples
===============

Simple scripts that demo the core modules
-----------------------------------------

The directory `Scripts`__ contains a number of simple command-line scripts
that make use of Cocoa features.

.. __: Scripts

* `autoreadme.py`_

  This script is a daemon that will open the ReadMe file in the root of any
  (removable) volume that is inserted while this script is running.

  The script is part of `Introduction to PyObjC`_, an article at O'Reilly
  `MacDevCenter.com`_.

.. _`autoreadme.py`: Scripts/autoreadme.py
.. _`Introduction to PyObjC`: http://macdevcenter.com/pub/a/mac/2003/01/31/pyobjc_one.html
.. _`MacDevCenter.com`: http://macdevcenter.com/

* `debugging.py`__

  This script shows how to use ``PyObjCTools.Debugging`` to show tracebacks
  of all (Cocoa) exceptions (handled and unhandled).

.. __: Scripts/debugging.py

* `dictionary.py`__

  Demonstrate the usage of an ``NSMutableDictionary`` object with both
  Objective-C and Python dictionary syntax.

.. __: Scripts/dictionary.py

* `exportBook.py`__

  An example of using the ``AddressBook`` framework, this script exports some
  of the information about people in your addressbook to a CSV file.

.. __: Scripts/exportBook.py

* `findPython.py`__

  Demonstrate the usage of ``objc.loadBundleFunctions`` to access
  functionality from the standard C library on Mac OS X (``libSystem``,
  which is also available as the ``System.framework`` bundle).  This
  example uses the dyld runtime to determine which dylib the Python
  runtime came from.

.. __: Scripts/findPython.py

* `HelloWorld.py`__

  Demonstrates a nib-less Cocoa GUI (purely for informational purposes, you
  probably shouldn't make a habit of this)

.. __: Scripts/HelloWorld.py

* `kvo-debugging.py`__

  XXX
  An example script that demonstrates how PyObjC interacts with Key-Value
  Observing (KVO) at the lowest level.  This script was used to debug
  the PyObjC runtime and should not be used as a guideline for writing
  new KVO code.  It may be interesting to some until we ensure that we
  have proper unit tests for KVO and remove this example!

.. __: Scripts/kvo-debugging.py

* `pydict-to-objcdict.py`__

  Shows how ``PyObjCTools.Conversion`` can be used to convert a Python
  collection into an Objective-C property list.  These functions should
  not typically be necessary as the proxies for Python objects are
  compatible with Objective-C plists.

.. __: Scripts/pydict-to-objcdict.py

* `rendezvous.py`__

  Use an NSNetService class to look for servers using rendezvous.

.. __: Scripts/rendezvous.py

* `signal-demo.py`__

  Demonstrates how to get a backtrace when handling a fatal signal using
  ``PyObjCTools.Signals``.

.. __: Scripts/signal-demo.py

* `stdinreader.py`__

  Demonstrates how to write a console runloop based application that uses
  ``NSFileHandle`` to read stdin asynchronously.

.. __: Scripts/stdinreader.py

* `subclassing-objective-c.py`__

  A doctest that demonstrates the subclassing of an Objective-C class from
  Python.  Note that it is typically discouraged to define a ``__del__``
  method.

.. __: Scripts/subclassing-objective-c.py

* `super-call.py`__

  Demonstrates how create a subclass of an Objective-C class that overrides
  a selector, but calls the super implementation using Python syntax
  equivalent to ``[super init]``.

.. __: Scripts/super-call.py

* `wmEnable.py`__

  Another ``objc.loadBundleFunctions`` demonstration that shows how to
  call into a private CoreGraphics SPI and enable full WindowManager
  access from a process that would not otherwise have it due to a
  quirk in the implementation of WindowManager (the reason why ``pythonw``
  should be used instead of ``python``).  Use at your own risk!

.. __: Scripts/wmEnable.py


Cocoa Applications
------------------

The directory `AppKit`__ contains example applications using the Cocoa
Application Framework (aka "AppKit").

.. __: AppKit

Most of the following examples contain a ``setup.py`` script that can
build an application. See `Building applications`_ for details how to invoke
these scripts. Some examples contain an ``Xcode`` or ``Project Builder``
project file; simply double-click it and choose ``Build and Run``, or invoke
``xcodebuild`` or ``pbxbuild`` from the command line depending on which you
have installed.

.. _`Building applications`: ../Doc/intro.html#building-applications

* `ClassBrowser`__

  A simple class browser, demonstrating the use of ``NSBrowser``
  (a "column view" hierarchical widget) and ``NSTableView``.

.. __: AppKit/ClassBrowser

* `CurrencyConverter`_

  A simple NIB based application. Start with this one. Also see the 
  `PyObjC tutorial`_.

.. _`CurrencyConverter`: AppKit/CurrencyConverter
.. _`PyObjC tutorial`: ../Doc/tutorial/tutorial.html

* `DotView`__

  A simple one-window demo showing how to custom drawing in a custom
  ``NSView``. Additionally shows how easy it is to embed a view in an
  ``NSScrollView``, as well as how to use an ``NSColorWell``.

.. __: AppKit/DotView

* `FieldGraph`__
  
  This shows an simple example of an MVC based application, that also
  makes use of ``NSBezierPaths``.  Contains a ``Project Builder`` project,
  as well as a ``setup.py`` script.

  The application calculates the field pattern and RMS field of an antenna 
  array with up to three elements.

.. __: AppKit/FieldGraph

* `HotKeyPython`__

  Demonstrates how to use Carbon global hot keys from a PyObjC application.
  Also demonstrates how to use a ``NSApplication`` subclass.

.. __: AppKit/HotKeyPYthon

* `iClass`__

  A more elaborate class browser; demonstrates ``NSOutlineView`` and
  ``NSTableView``.

.. __: AppKit/iClass

* `PackageManager`__
  
  An implementation of the MacPython PackageManager application using
  Cocoa.

.. __: AppKit/PackageManager

* `PyInterpreter`__

  A full featured embedded Python interpreter.  This demonstrates
  more complicated uses of ``NSTextView``, manual event dispatching,
  and the new text completion feature of OS X 10.3.

.. __: AppKit/PyInterpreter

* `PyObjCLauncher`__

  A reimplementation of the Python script launcher helper application
  in PyObjC.

.. __: AppKit/PyObjCLauncher

* `PythonBrowser`__

  A reusable Python object browser, demonstrating the use of ``NSOutlineView``
  as well as how to use an ``NSWindowController`` subclass to create a window
  from a menu action.

.. __: AppKit/PythonBrowser

* `SimpleService`__

  Shows how to implement entries for the Services menu.

.. __: AppKit/SimpleService

* `TableModel`__

  Basic demo that shows how to use a ``NSTableView``.

.. __: AppKit/TableModel

* `TinyTinyEdit`__

  A minimal Document-based text editor application.

.. __: AppKit/TinyTinyEdit

* `TinyURLService`__

  Another simple service, this one converts URL or strings from the
  pasteboard to tinyurl.com equivalents.

.. __: AppKit/TinyURLService
  
* `Todo`_

  A more complex NIB based applications. This is a document-based application.
  The code is a translation into Python of an example project in 
  `Learning Cocoa`_ from O'Reilly

.. _`Todo`: AppKit/ToDo
.. _`Learning Cocoa`: http://www.oreilly.com/catalog/learncocoa2/

* `WebServicesTool`__

  Queries an XML-RPC enabled web server for the methods that it implements.
  Demonstrates a more advanced use of an ``NSTableView``, how to make a
  toolbar as well as how to use multi-threading.  Contains a
  ``Project Builder`` project as well as a ``setup.py`` script.

.. __: AppKit/WebServicesTool


Cocoa Bindings
--------------

The `CocoaBindings`__ directory contains a number of examples that make use of
Key-Value Coding and Cocoa Bindings. These scripts require Mac OS X 10.3 or
later.

.. __: CocoaBindings

* `Bookmarks`_

  Shows custom array controller that implements table view data
  source methods to support drag and drop, including copying
  objects from one window to another, drop of URLs, and 
  re-ordering of the content array.

  Originally from `Cocoa Bindings Examples and Hints`_,
  converted to PyObjC by u.fiedler.

.. _`Bookmarks`: CocoaBindings/Bookmarks

* `ControlledPreferences`_
  
  Demonstrates how to use Cocoa Bindings to simplify storing and
  retrieving user preferences.  Also demonstrates how to use an
  ``NSValueTransformer`` to archive/unarchive a non-property-list
  type automatically (``NSColor``, in this case).

  Originally from `Cocoa Bindings Examples and Hints`_,
  converted to PyObjC by u.fiedler.

.. _`ControlledPreferences`: CocoaBindings/ControlledPreferences

* `CurrencyConvBinding`_

  A rewrite of `CurrencyConverter`_ using Cocoa Bindings.
    
  Originally from
  `Introduction to Developing Cocoa Applications Using Bindings`_,
  converted to PyObjC by u.fiedler.

.. _`CurrencyConvBinding`: CocoaBindings/CurrencyConvBinding
.. _`Introduction to Developing Cocoa Applications Using Bindings`: http://developer.apple.com/documentation/Cocoa/Conceptual/CurrencyConverterBindings/index.html

* `FilteringController`_

  Demonstrates how to subclass ``NSArrayController`` to implement filtering
  of a ``NSTableView``.  Also demonstrates the use of indexed accessors.
  
  Originally from `Cocoa Bindings Examples and Hints`_,
  converted to PyObjC by u.fiedler.

.. _`FilteringController`: CocoaBindings/FilteringController

* `GraphicsBindings`_

   Shows the use of a custom controller, a value transformer, and two custom
   bindings-enabled views. One view is a control that allows you to set the
   angle and offset of a shadow; the other view observes and displays a
   collection of graphic objects.

  Originally from `Cocoa Bindings Examples and Hints`_,
  converted to PyObjC by u.fiedler.

.. _`GraphicsBindings`: CocoaBindings/GraphicsBindings

* `ManualBindings`_

  A simple example that illustrates establishing bindings
  programmatically, including a number of options such as validation
  and an array operator, and indexed accessor methods. A custom model
  object implements custom validation method.
  
  Originally from `Cocoa Bindings Examples and Hints`_,
  converted to PyObjC by u.fiedler.

.. _`ManualBindings`: CocoaBindings/ManualBindings
.. _`Cocoa Bindings Examples and Hints`: http://homepage.mac.com/mmalc/CocoaExamples/controllers.html

* `TableModel`__

  Shows how to fill an ``NSTableView`` using Key-Value Coding.  Contains
  contains an ``Xcode`` project as well as a ``setup.py`` script.

.. __: CocoaBindings/TableModel
  
* `TableModelWithSearch`__

  A more advanced example of Key-Value Coding. This uses a custom 
  ``NSArrayController``.  Contains contains an ``Xcode`` project
  as well as a ``setup.py`` script.

.. __: CocoaBindings/TableModelWithSearch

* `TemperatureTransformer`_

  An example that uses ``NSValueTransformer`` to convert between Celsius
  and Fahrenheit.

  Based on Apple's `Value Transformers`_ documentation,
  converted to PyObjC by u.fiedler.

.. _`TemperatureTransformer`: CocoaBindings/TemperatureTransformer
.. _`Value Transformers`: http://developer.apple.com/documentation/Cocoa/Conceptual/ValueTransformers/index.html

* `ToDos`_

  Shows two array controllers, one to manage the contents of a table
  view, the other to manage a pop-up menu in a table column. Also 
  shows two value transformers to alter the color of text.

  Originally from `Cocoa Bindings Examples and Hints`_,
  converted to PyObjC by u.fiedler.

.. _`ToDos`: CocoaBindings/ToDos

CoreData
--------

The directory `CoreData`__ contains a number of examples
that use the CoreData framework. This framework is available
in MacOS X 10.4 and later.

.. __: CoreData

* `OutlineEdit`__

  A python version of the OutlineEdit example that's included with
  Xcode 2.0.

.. __: CoreData/OutlineEdit

Foundation
----------

The directory `Foundation`_ contains a number of examples
that use only Foundation facilities.

* `simple-kvo.py`__

  Demonstrates the use of Key-Value Observing from a simple
  script, without a runloop.  Requires Mac OS X 10.3 or later.

.. __: Foundation/simple-kvo.py

Inject
------

The directory `Inject`_ contains a number of examples that use the
``objc.inject`` facility to inject code into another process.  These
examples require Mac OS X 10.3 or later.

.. _`Inject`: Inject

* `IDNSnitch`_

  A proof of concept `IDN spoofing defense`_ for Safari (tested with
  v1.2.4 on Mac OS X 10.3.8).  Demonstrates how to write an application
  that detects the launch of another application by bundle identifier,
  how to use ``objc.inject`` to load code into another application,
  how to override the implementation of an existing class but still
  call back into the original implementation, and how to reduce the
  size of such an application/plugin combination by using symlinks
  to share object files (the PyObjC extensions in this case).

.. _`IDNSnitch`: Inject/IDNSnitch
.. _`IDN spoofing defense`: http://bob.pythonmac.org/archives/2005/02/07/idn-spoofing-defense-for-safari/

* `InjectInterpreter`_:

  Shows how to inject an in-process Python interpreter into another
  process.  Based on the AppKit PyInterpreter example.

.. _`InjectInterpreter`: Inject/InjectInterpreter

* `InjectBrowser`_:

  Shows how to inject an in-process Python class browser into another
  process.  Based on the AppKit ClassBrowser example.

.. _`InjectBrowser`: Inject/ClassBrowser


OpenGL
------

The directory `OpenGL`_ contains a number of examples that use OpenGL with
a Cocoa UI.  These examples also require `PyOpenGL`__.

.. _`OpenGL`: OpenGL
.. __: http://pyopengl.sourceforge.net/

* `OpenGLDemo`__

  A simple program that shows how to use OpenGL in a Cocoa program.  It is a 
  port of Apple's "CocoaGL" example.

.. __: OpenGL/OpenGLDemo


Plugins
-------

The directory `Plugins`__ contains a number of examples that embed a Python
plugin into another application.  Note that due to an implementation detail
of the py2app bundle template, these plugins are only compatible with
Mac OS X 10.3 and later.

.. __: Plugins

* `EnvironmentPrefs`__

  This ``NSPreferencePane`` can be used to edit the default environment
  for the current user. It also is a simple example of a localized application.

.. __: Plugins/EnvironmentPrefs

* `ProgressViewPalette`__

  A simple InterfaceBuilder palette written in Python.

.. __: Plugins/ProgressViewPalette

* `SillyBallsSaver`__

  A simple screensaver written in Python.

.. __: Plugins/SillyBallsSaver

* `WebKitInterpreter`__
  
  Uses the new WebKit Cocoa plugin API available in Safari 1.3
  and later to embed a PyInterpreter in the browser.

.. __: Plugins/WebKitInterpreter

Twisted Integration
-------------------

The directory `Twisted`_ contains a number of examples that use
`Twisted (2.0 or later)`__ with Cocoa.

.. _`Twisted`: Twisted
.. __: http://www.twistedmatrix.com

* `WebServicesTool`__

  This is a refactor of the WebServicesTool example that is made much simpler
  and faster by using Twisted.

.. __: Twisted/WebServicesTool

* `WebServicesTool-ControllerLayer`__

  This is an even simpler refactor of the Twisted WebServicesTool example that
  uses Cocoa Bindings to remove a lot of the UI related code.

.. __: Twisted/WebServicesTool-ControllerLayer


WebKit
------

The directory `WebKit`__ contains a number of examples that use the ``WebKit``
framework, the HTML rendering engine from Safari.

.. __: WebKit

* `PyDocURLProtocol`__

  This example implements a subclass of ``NSURLProtocol`` that can be used
  to load the ``pydoc`` documentation of a module.

  It also includes a simple documentation browser using ``WebKit`` and the 
  ``PyDocURLProtocol`` class.

.. __: WebKit/PyDocURLProtocol 
 

Some work-in-progress examples
------------------------------

The directory `NonFunctional`__ may contain a number of examples that are not working
for one reason or another. The most likely reason is that example relies on features
that have not yet been implemented.

.. __: NonFunctional

This directory contains a number of tests that require full GUI access. These
tests should be integrated in the unittest framework.

RemotePyInterpreter

RemotePyInterpreter is a full featured out of process
Python interpreter in a NSTextView.

The source of this application demonstrates
- Advanced usage of NSTextView
- Text completion (Only in OS X 10.3)
- Asynchronous TCP networking with NSFileHandle
- One crazy repr/eval-based IPC protocol

Bob Ippolito
bob@redivi.com

This directory contains the libffi package, which is not part of GCC but
shipped with GCC as convenience.

Status
======

libffi-2.00 has not been released yet! This is a development snapshot!

libffi-1.20 was released on October 5, 1998. Check the libffi web
page for updates: <URL:http://sources.redhat.com/libffi/>.


What is libffi?
===============

Compilers for high level languages generate code that follow certain
conventions. These conventions are necessary, in part, for separate
compilation to work. One such convention is the "calling
convention". The "calling convention" is essentially a set of
assumptions made by the compiler about where function arguments will
be found on entry to a function. A "calling convention" also specifies
where the return value for a function is found.

Some programs may not know at the time of compilation what arguments
are to be passed to a function. For instance, an interpreter may be
told at run-time about the number and types of arguments used to call
a given function. Libffi can be used in such programs to provide a
bridge from the interpreter program to compiled code.

The libffi library provides a portable, high level programming
interface to various calling conventions. This allows a programmer to
call any function specified by a call interface description at run
time.  

Ffi stands for Foreign Function Interface. A foreign function
interface is the popular name for the interface that allows code
written in one language to call code written in another language. The
libffi library really only provides the lowest, machine dependent
layer of a fully featured foreign function interface. A layer must
exist above libffi that handles type conversions for values passed
between the two languages.


Supported Platforms and Prerequisites
=====================================

Libffi has been ported to:

	SunOS 4.1.3 & Solaris 2.x (SPARC-V8, SPARC-V9)

	Irix 5.3 & 6.2 (System V/o32 & n32)

	Intel x86 - Linux (System V ABI)

	Alpha - Linux and OSF/1

	m68k - Linux (System V ABI)

	PowerPC - Linux (System V ABI, Darwin, AIX)

	ARM - Linux (System V ABI)

Libffi has been tested with the egcs 1.0.2 gcc compiler. Chances are
that other versions will work.  Libffi has also been built and tested
with the SGI compiler tools.

On PowerPC, the tests failed (see the note below).

You must use GNU make to build libffi. SGI's make will not work.
Sun's probably won't either.
	
If you port libffi to another platform, please let me know! I assume
that some will be easy (x86 NetBSD), and others will be more difficult
(HP).


Installing libffi
=================

[Note: before actually performing any of these installation steps,
 you may wish to read the "Platform Specific Notes" below.]

First you must configure the distribution for your particular
system. Go to the directory you wish to build libffi in and run the
"configure" program found in the root directory of the libffi source
distribution.

You may want to tell configure where to install the libffi library and
header files. To do that, use the --prefix configure switch.  Libffi
will install under /usr/local by default. 

If you want to enable extra run-time debugging checks use the the
--enable-debug configure switch. This is useful when your program dies
mysteriously while using libffi. 

Another useful configure switch is --enable-purify-safety. Using this
will add some extra code which will suppress certain warnings when you
are using Purify with libffi. Only use this switch when using 
Purify, as it will slow down the library.

Configure has many other options. Use "configure --help" to see them all.

Once configure has finished, type "make". Note that you must be using
GNU make. SGI's make will not work.  Sun's probably won't either.
You can ftp GNU make from prep.ai.mit.edu:/pub/gnu.

To ensure that libffi is working as advertised, type "make test".

To install the library and header files, type "make install".


Using libffi
============

	The Basics
	----------

Libffi assumes that you have a pointer to the function you wish to
call and that you know the number and types of arguments to pass it,
as well as the return type of the function.

The first thing you must do is create an ffi_cif object that matches
the signature of the function you wish to call. The cif in ffi_cif
stands for Call InterFace. To prepare a call interface object, use the
following function:

ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi,
			unsigned int nargs, 
			ffi_type *rtype, ffi_type **atypes);

	CIF is a pointer to the call interface object you wish
		to initialize.

	ABI is an enum that specifies the calling convention 
		to use for the call. FFI_DEFAULT_ABI defaults
		to the system's native calling convention. Other
		ABI's may be used with care. They are system
		specific.

	NARGS is the number of arguments this function accepts.	
		libffi does not yet support vararg functions.

	RTYPE is a pointer to an ffi_type structure that represents
		the return type of the function. Ffi_type objects
		describe the types of values. libffi provides
		ffi_type objects for many of the native C types:
		signed int, unsigned int, signed char, unsigned char,
		etc. There is also a pointer ffi_type object and
		a void ffi_type. Use &ffi_type_void for functions that 
		don't return values.

	ATYPES is a vector of ffi_type pointers. ARGS must be NARGS long.
		If NARGS is 0, this is ignored.


ffi_prep_cif will return a status code that you are responsible 
for checking. It will be one of the following:

	FFI_OK - All is good.

	FFI_BAD_TYPEDEF - One of the ffi_type objects that ffi_prep_cif
		came across is bad.


Before making the call, the VALUES vector should be initialized 
with pointers to the appropriate argument values.

To call the the function using the initialized ffi_cif, use the
ffi_call function:

void ffi_call(ffi_cif *cif, void *fn, void *rvalue, void **avalues);

	CIF is a pointer to the ffi_cif initialized specifically
		for this function.

	FN is a pointer to the function you want to call.

	RVALUE is a pointer to a chunk of memory that is to hold the
		result of the function call. Currently, it must be
		at least one word in size (except for the n32 version
		under Irix 6.x, which must be a pointer to an 8 byte 
		aligned value (a long long). It must also be at least 
		word aligned (depending on the return type, and the
		system's alignment requirements). If RTYPE is 
		&ffi_type_void, this is ignored. If RVALUE is NULL, 
		the return value is discarded.

	AVALUES is a vector of void* that point to the memory locations
		holding the argument values for a call.
		If NARGS is 0, this is ignored.


If you are expecting a return value from FN it will have been stored
at RVALUE.



	An Example
	----------

Here is a trivial example that calls puts() a few times.

    #include <stdio.h>
    #include <ffi.h>
    
    int main()
    {
      ffi_cif cif;
      ffi_type *args[1];
      void *values[1];
      char *s;
      int rc;
      
      /* Initialize the argument info vectors */    
      args[0] = &ffi_type_uint;
      values[0] = &s;
      
      /* Initialize the cif */
      if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
    		       &ffi_type_uint, args) == FFI_OK)
        {
          s = "Hello World!";
          ffi_call(&cif, puts, &rc, values);
          /* rc now holds the result of the call to puts */
          
          /* values holds a pointer to the function's arg, so to 
	     call puts() again all we need to do is change the 
             value of s */
          s = "This is cool!";
          ffi_call(&cif, puts, &rc, values);
        }
      
      return 0;
    }



	Aggregate Types
	---------------

Although libffi has no special support for unions or bit-fields, it is
perfectly happy passing structures back and forth. You must first
describe the structure to libffi by creating a new ffi_type object
for it. Here is the definition of ffi_type:

    typedef struct _ffi_type
    {
      unsigned size;
      short alignment;
      short type;
      struct _ffi_type **elements;
    } ffi_type;
    
All structures must have type set to FFI_TYPE_STRUCT.  You may set
size and alignment to 0. These will be calculated and reset to the
appropriate values by ffi_prep_cif().

elements is a NULL terminated array of pointers to ffi_type objects
that describe the type of the structure elements. These may, in turn,
be structure elements.

The following example initializes a ffi_type object representing the
tm struct from Linux's time.h:

				    struct tm {
					int tm_sec;
					int tm_min;
					int tm_hour;
					int tm_mday;
					int tm_mon;
					int tm_year;
					int tm_wday;
					int tm_yday;
					int tm_isdst;
					/* Those are for future use. */
					long int __tm_gmtoff__;
					__const char *__tm_zone__;
				    };

    {
      ffi_type tm_type;
      ffi_type *tm_type_elements[12];
      int i;

      tm_type.size = tm_type.alignment = 0;
      tm_type.elements = &tm_type_elements;
    
      for (i = 0; i < 9; i++)
          tm_type_elements[i] = &ffi_type_sint;

      tm_type_elements[9] = &ffi_type_slong;
      tm_type_elements[10] = &ffi_type_pointer;
      tm_type_elements[11] = NULL;

      /* tm_type can now be used to represent tm argument types and
	 return types for ffi_prep_cif() */
    }



Platform Specific Notes
=======================

	Intel x86
	---------

There are no known problems with the x86 port.

	Sun SPARC - SunOS 4.1.3 & Solaris 2.x
	-------------------------------------

You must use GNU Make to build libffi on Sun platforms.

	MIPS - Irix 5.3 & 6.x
	---------------------

Irix 6.2 and better supports three different calling conventions: o32,
n32 and n64. Currently, libffi only supports both o32 and n32 under
Irix 6.x, but only o32 under Irix 5.3. Libffi will automatically be
configured for whichever calling convention it was built for.

By default, the configure script will try to build libffi with the GNU
development tools. To build libffi with the SGI development tools, set
the environment variable CC to either "cc -32" or "cc -n32" before
running configure under Irix 6.x (depending on whether you want an o32
or n32 library), or just "cc" for Irix 5.3.

With the n32 calling convention, when returning structures smaller
than 16 bytes, be sure to provide an RVALUE that is 8 byte aligned.
Here's one way of forcing this:

	double struct_storage[2];
	my_small_struct *s = (my_small_struct *) struct_storage;  
	/* Use s for RVALUE */

If you don't do this you are liable to get spurious bus errors. 

"long long" values are not supported yet.

You must use GNU Make to build libffi on SGI platforms.

	ARM - System V ABI
	------------------

The ARM port was performed on a NetWinder running ARM Linux ELF
(2.0.31) and gcc 2.8.1.



	PowerPC System V ABI
	--------------------

There are two `System V ABI's which libffi implements for PowerPC.
They differ only in how small structures are returned from functions.

In the FFI_SYSV version, structures that are 8 bytes or smaller are
returned in registers.  This is what GCC does when it is configured
for solaris, and is what the System V ABI I have (dated September
1995) says.

In the FFI_GCC_SYSV version, all structures are returned the same way:
by passing a pointer as the first argument to the function.  This is
what GCC does when it is configured for linux or a generic sysv
target.

EGCS 1.0.1 (and probably other versions of EGCS/GCC) also has a
inconsistency with the SysV ABI: When a procedure is called with many
floating-point arguments, some of them get put on the stack.  They are
all supposed to be stored in double-precision format, even if they are
only single-precision, but EGCS stores single-precision arguments as
single-precision anyway.  This causes one test to fail (the `many
arguments' test).


What's With The Crazy Comments?
===============================

You might notice a number of cryptic comments in the code, delimited
by /*@ and @*/. These are annotations read by the program LCLint, a
tool for statically checking C programs. You can read all about it at
<http://larch-www.lcs.mit.edu:8001/larch/lclint/index.html>.


History
=======

1.20 Oct-5-98
	Raffaele Sena produces ARM port.

1.19 Oct-5-98
	Fixed x86 long double and long long return support.
	m68k bug fixes from Andreas Schwab.
	Patch for DU assembler compatibility for the Alpha from Richard
	Henderson.

1.18 Apr-17-98
	Bug fixes and MIPS configuration changes.

1.17 Feb-24-98
	Bug fixes and m68k port from Andreas Schwab. PowerPC port from
	Geoffrey Keating. Various bug x86, Sparc and MIPS bug fixes.

1.16 Feb-11-98
	Richard Henderson produces Alpha port.

1.15 Dec-4-97
	Fixed an n32 ABI bug. New libtool, auto* support.

1.14 May-13-97
	libtool is now used to generate shared and static libraries.
	Fixed a minor portability problem reported by Russ McManus
	<mcmanr@eq.gs.com>.

1.13 Dec-2-96
	Added --enable-purify-safety to keep Purify from complaining
	about certain low level code.
	Sparc fix for calling functions with < 6 args.
	Linux x86 a.out fix.

1.12 Nov-22-96
	Added missing ffi_type_void, needed for supporting void return 
	types. Fixed test case for non MIPS machines. Cygnus Support 
	is now Cygnus Solutions. 

1.11 Oct-30-96
	Added notes about GNU make.

1.10 Oct-29-96
	Added configuration fix for non GNU compilers.

1.09 Oct-29-96
	Added --enable-debug configure switch. Clean-ups based on LCLint 
	feedback. ffi_mips.h is always installed. Many configuration 
	fixes. Fixed ffitest.c for sparc builds.

1.08 Oct-15-96
	Fixed n32 problem. Many clean-ups.

1.07 Oct-14-96
	Gordon Irlam rewrites v8.S again. Bug fixes.

1.06 Oct-14-96
	Gordon Irlam improved the sparc port. 

1.05 Oct-14-96
	Interface changes based on feedback.

1.04 Oct-11-96
	Sparc port complete (modulo struct passing bug).

1.03 Oct-10-96
	Passing struct args, and returning struct values works for
	all architectures/calling conventions. Expanded tests.

1.02 Oct-9-96
	Added SGI n32 support. Fixed bugs in both o32 and Linux support.
	Added "make test".

1.01 Oct-8-96
	Fixed float passing bug in mips version. Restructured some
	of the code. Builds cleanly with SGI tools.

1.00 Oct-7-96
	First release. No public announcement.


Authors & Credits
=================

libffi was written by Anthony Green <green@cygnus.com>.

Portions of libffi were derived from Gianni Mariani's free gencall
library for Silicon Graphics machines.

The closure mechanism was designed and implemented by Kresten Krab
Thorup.

The Sparc port was derived from code contributed by the fine folks at
Visible Decisions Inc <http://www.vdi.com>. Further enhancements were
made by Gordon Irlam at Cygnus Solutions <http://www.cygnus.com>.

The Alpha port was written by Richard Henderson at Cygnus Solutions.

Andreas Schwab ported libffi to m68k Linux and provided a number of
bug fixes.

Geoffrey Keating ported libffi to the PowerPC.

Raffaele Sena ported libffi to the ARM.

Jesper Skov and Andrew Haley both did more than their fair share of
stepping through the code and tracking down bugs.

Thanks also to Tom Tromey for bug fixes and configuration help.

Thanks to Jim Blandy, who provided some useful feedback on the libffi
interface.

If you have a problem, or have found a bug, please send a note to
green@cygnus.com.

This directory contains a slightly modified version of libffi, extracted from
the GCC source-tree.

The only modifications are those that are necessary to compile libffi using 
the Apple provided compiler and outside of the GCC source tree.

#ifndef PyObjC_CLASS_DESCRIPTOR_H
#define PyObjC_CLASS_DESCRIPTOR_H

PyObject* objcclass_descr_get(PyObject* obj, void* closure);
extern char objcclass_descr_doc[];

#define OBJCCLASS_SLOT \
	{ 						\
	"__objc_class__",		/* name */	\
	objcclass_descr_get,		/* get */	\
	0,				/* set */	\
	objcclass_descr_doc,		/* doc */	\
	0,				/* closure */	\
	}

#endif /* PyObjC_CLASS_DESCRIPTOR_H */

=================
Welcome to PyObjC
=================

Leopard branch started from revision 1875 in the main repository.

The PyObjC package provides the glue needed to interface the Python interpreter
with the Objective-C language. At its core is the ``objc`` module makes 
Objective-C objects and classes available as first-class Python citizens. It is 
not only possible to use Objective-C objects but you can also subclass 
Objective-C classes.

To make it easier to use the core ``objc`` module, this package also provides 
a number of modules that are wrappers for the Cocoa frameworks, such as
Foundation and AppKit. These modules not only give you access to the classes in
these frameworks but also to the functions and constants in those modules.

Read `the documentation`_ for more information on how to use this package. The
`installation manual`_ describes how to install this package.

.. _`the documentation`: Doc/index.html

.. _`installation manual`: Install.html

The latest information can always be found at:

    http://pyobjc.sourceforge.net/

For help, please use the pyobjc-dev mailing list:

    http://lists.sourceforge.net/lists/listinfo/pyobjc-dev

b.bum <bbum@codefab.com>, Ronald Oussoren <ronaldoussoren@mac.com>

==================
Currency Converter
==================

Introduction
------------

This is a port of the "Currency Converter" example from the Cocoa tutorial
to Python (via PyObjC).  Development is done in "standalone" mode.  That is,
the setup.py script is used to build an application wrapper that can be
launched like any other Cocoa application.

Building the App
----------------

To build the app, invoke the setup.py script::

   python setup.py py2app

This will build the CurrencyConverter application in the directory *dist*
within the current working directory as *CurrencyConverter.app*.

"DatePicker" is a Cocoa sample application that demonstrates how to use 
``NSDatePicker`` control on Mac OS X.  ``NSDatePicker`` is a subclass of 
``NSControl`` that provides for visually displaying and editing an 
``NSDate`` instance.

This control uses an ``NSDatePickerCell`` to implement much of the 
control’s functionality.

About the Sample
----------------

DatePicker shows how to manipulate the behaviors of ``lNSDatePicker`` in the 
following ways

1. Changing the picker style.

2. Changing the picker font size.

3. Changing the background/text color as well as other appearance aspects.

4. Turning on and off the various date and time element flags.

5. Setting the minimum and maximum dates.

6. Overriding the set date as a delegate.

The sample also shows how to use the various date and time formats using the 
``NSDateFormatter`` class.

=====================
Cocoa Package Manager
=====================

NOTE:

    The Package Manager infrastructure is currently unmaintained.  This
    example is not intended for actual use, but remains to show how such an
    application could be built.

This application is a Cocoa version of the Package Manager application that
is included with MacPython.

This is a first version of the application, using an unmodified ``pimp`` 
module, it does not implement the ideas described on the NewPackageManager
page on the `MacPython wiki`_.

Features w.r.t. the official Package Manager:

- You can have a list of favorite databases

- The scroll-list doesn't scroll back automatically ;-)

Building
--------

Run ``python setup.py py2app`` to create the application.

.. _`MacPython wiki`: http://wiki.python.org/moin/MacPython

PredicateEditorSample
=====================

"PredicateEditorSample" is a Cocoa application that demonstrates how to use 
the ``NSPredicateEditor`` class.  The ``NSPredicateEditor`` class is a 
subclass of ``NSRuleEditor`` that is specialized for editing ``NSPredicate`` 
objects.  This sample is intended to show how to use the many different 
features and aspects of this control and leverages Spotlight to search your 
Address Book.

It shows how to manage this control inside your window along with an 
``NSTableView``, build Spotlight friendly queries based on ``NSPredicate`` and 
``NSCompountPredicate``, build search results based on ``NSMetadataQuery`` object.

Using the Sample
----------------

Simply build the example using the supplied ``setup.py`` file.  Enter 
query information pertaining to your Address Book.  The application will 
display matches in its table view.

Note that this sample uses Interface Builder 3.0 to build the 
``NSPredicateEditorRowTemplates`` that make up the control's interface.

AddressBook searches are achieved by specifically requesting the "kind" of data to search via the ``kMDItemKind`` key constant.  This is the metadata attribute key that tells Spotlight to search for address book data only.  Together along with the other predicates from the ``NSPredicateEditor`` class we form a "compound predicate" and start the query.  The code snippet below found in this sample shows how this is done::

   # always search for items in the Address Book
   addrBookPredicate = NSPredicate.predicateWithFormat_("(kMDItemKind = 'Address Book Person Data')")
   predicate = NSCompoundPredicate.andPredicateWithSubpredicates_([addrBookPredicate, predicate])

   query.setPredicate_(predicate)
   query.startQuery()

PyInterpreter

PyInterpreter is a full featured Python interpreter in a NSTextView.

See:    http://pyobjc.sourceforge.net/
        http://wiki.python.org/moin/MacPython/PyInterpreter

Source for both the pyobjc module and PyInterpreter are
available via the pyobjc sourceforge CVS repository.

The source of this application demonstrates
- Advanced usage of NSTextView
- Manual event dispatching
- Text completion (Only in OS X 10.3)

Bob Ippolito
bob@redivi.com

A module and/or demo program implementing a Python object browser

It can be used in two ways:
1) as a standalone demo app that shows how to use the NSOutlineView class
2) as a module to add an object browser to your app.

For the latter usage, include PythonBrowser.nib in your app bundle,
make sure that PythonBrowser.py and PythonBrowserModel.py can be found
on sys.path, and call

.. ::

    PythonBrowser.PythonBrowserWindowController(aBrowsableObject)

from your app. The object to be browsed can't be a number, a string or
None, any other kind of object is fine.

To build the demo program, run this line in Terminal.app::

   $ python setup.py py2app -A

This creates a directory "dist" containing PythonBrowser.app. (The
-A option causes the files to be symlinked to the .app bundle instead
of copied. This means you don't have to rebuild the app if you edit the
sources or nibs.)


{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\vieww12000\viewh15840\viewkind0
\deftab720
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\pardeftab720\ql\qnatural

\f0\b\fs36 \cf0 SimpleService\
\

\f1\b0\fs24 SimpleService is a little program which shows to to create services for the services menu.  There are two services provided in this example:\
\
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\pardeftab720\li160\fi-160\ql\qnatural
\cf0 \'a5 "Open File" service, which opens the file specified by the provided string. This service has no return value.\
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\pardeftab720\ql\qnatural
\cf0 \
\'a5 "Capitalize" service, which takes a string and returns a capitalized version.\
\
The service information is stored in Info.plist and read by the system during login. Take a look at the "Application Settings" to see how the service information is specified. Details on the various entries can be found in the  documentation, in "Services" under "Programming Topics."\
\
To install SimpleService, copy it into ~/Library/Services, log out and log back in.\
\
There are some tricky issues in creating a service:\
\'a5 The Info.plist needs to specify LSBackgroundOnly = 1, in order to assure the service does not appear in the dock.\
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\pardeftab720\li160\fi-160\ql\qnatural
\cf0 \
\
}
{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\vieww12000\viewh15440\viewkind0
\deftab720
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\pardeftab720\ql\qnatural

\f0\b\fs36 \cf0 TinyURLService\
\

\f1\b0\fs24 TinyURLService is a little program which shows to to create services for the services menu.  There is one services provided in this example:\
\
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\pardeftab720\li160\fi-160\ql\qnatural
\cf0 \'a5 "Shorten URL" service, which takes a URL and returns a tinyurl.com shortened URL.\
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\pardeftab720\ql\qnatural
\cf0 \
The service information is stored in Info.plist and read by the system during login. Take a look at the "Application Settings" to see how the service information is specified. Details on the various entries can be found in the  documentation, in "Services" under "Programming Topics."\
\
To install SimpleService, copy it into ~/Library/Services, log out and log back in.\
\
There are some tricky issues in creating a service:\
\'a5 The Info.plist needs to specify LSBackgroundOnly = 1, in order to assure the service does not appear in the dock.}
Final version of the Todo application from 'Learning Cocoa' (O'reilly),
translated to python.

The nib-file is unchanged from the version in the tar-archive downloaded
from the o'reilly website.

Notes:
- The code doesn't work correctly at the moment. 
  * Loading does not work. The code uses NSCoder and the methods for
    decoding C-types have not been wrapped yet. Adding this is not very 
    hard.
  * The first line in the list ToDo items doesn't show unless the field
    is selected. The objective-C version has the same problem. 

- This is a minimal translation, the application logic has not been
  'pythonified'. 

- There are two blocks of code that are not filled in in the objective-C 
  version (left as an extercise for the reader). I've not yet written those
  pieces.

Web Services Tool

Web Services Tool queries XML-RPC enabled servers via the "standard"
introspection methods and displays a summary of the API.  It is
implemented in Python using the PyObjC module.

To use the application, simply provide the connection window with an URL
to the XML-RPC handler of a web server.  If the server at least
implements the listMethods() method, the app will display a list of
available methods.

See: http://pyobjc.sourceforge.net/

Source for both the pyobjc module and the Web Services Tool are
available via the pyobjc sourceforge CVS repository.

The source of this application demonstrates
- using Python's network libraries inside a Cocoa app
- how to use multi-threading
- how to create an NSToolbar
- how to use an NSTableView

b.bum
bbum@codefab.com

OpenGLDemo

OpenGLDemo is probably the simplest possible demonstration of 
using OpenGL from a PyObjC application.  It is a port of Apple's
"CocoaGL" example.  Note that this requires PyOpenGL to be installed.

See:    /Developer/Examples/OpenGL/Cocoa/CocoaGL
        http://pyopengl.sourceforge.net/

The source of this application demonstrates
- Using PyOpenGL from Cocoa

Bob Ippolito
bob@redivi.com

These are PyObjC examples that require Twisted 1.1 or later to run

Twisted is available from http://twistedmatrix.com/

Web Services Tool

Web Services Tool queries XML-RPC enabled servers via the "standard"
introspection methods and displays a summary of the API.  It is
implemented in Python using the PyObjC module.

To use the application, simply provide the connection window with an URL
to the XML-RPC handler of a web server.  If the server at least
implements the listMethods() method, the app will display a list of
available methods.

See: http://pyobjc.sourceforge.net/

Source for both the pyobjc module and the Web Services Tool are
available via the pyobjc sourceforge CVS repository.

The source of this application demonstrates

* using Python's network libraries inside a Cocoa app


* how to use multi-threading

* how to create an NSToolbar

* how to use an NSTableView

b.bum
bbum@codefab.com

This application has been modified for Twisted.  It demonstrates:

* using Twisted in a Cocoa app with the threadedselectreactor

* how to write responsive single-threaded network applications

* note that you will need Twisted 2.x, where x > 0.  Currently, this
  is only available from svn, at revision 13576 or later.

To run the demo:
python setup.py py2app
open dist/Web\ Services\ Tool.app

bob@redivi.com

Web Services Tool

Web Services Tool queries XML-RPC enabled servers via the "standard"
introspection methods and displays a summary of the API.  It is
implemented in Python using the PyObjC module.

To use the application, simply provide the connection window with an URL
to the XML-RPC handler of a web server.  If the server at least
implements the listMethods() method, the app will display a list of
available methods.

See: http://pyobjc.sourceforge.net/

Source for both the pyobjc module and the Web Services Tool are
available via the pyobjc sourceforge CVS repository.

The source of this application demonstrates
- using Python's network libraries inside a Cocoa app
- how to use multi-threading
- how to create an NSToolbar
- how to use an NSTableView

b.bum
bbum@codefab.com

This application has been modified for Twisted.  It demonstrates:
- using Twisted in a Cocoa app with the cfreactor
- how to write responsive single-threaded network applications
- well, it no longer demonstrates how to use multi-threading

To run the demo:
python setup.py py2app
open dist/Web\ Services\ Tool.app

bob@redivi.com

#if MAC_OS_X_VERSION_10_5 <= MAC_OS_X_VERSION_MAX_ALLOWED

/* Needed when building against the OS X 10.5+ SDK but running on 10.4. */
#pragma weak CFFileDescriptorCreate
#pragma weak CFFileDescriptorGetContext

static void* 
mod_filedescr_retain(void* info) 
{
	PyGILState_STATE state = PyGILState_Ensure();
	Py_INCREF((PyObject*)info);
	PyGILState_Release(state);
	return info;
}

static void
mod_filedescr_release(void* info)
{
	PyGILState_STATE state = PyGILState_Ensure();
	Py_DECREF((PyObject*)info);
	PyGILState_Release(state);
}


static CFFileDescriptorContext mod_CFFileDescriptorContext = {
	0,		
	NULL,
	mod_filedescr_retain,
	mod_filedescr_release,
	NULL
};

static void
mod_CFFileDescriptorCallBack(	
	CFFileDescriptorRef f,
	CFOptionFlags callBackType,
	void* _info)
{
	PyObject* info = (PyObject*)_info;
	PyGILState_STATE state = PyGILState_Ensure();

	PyObject* py_f = PyObjC_ObjCToPython(@encode(CFFileDescriptorRef), &f);
	PyObject* py_callBackType = PyObjC_ObjCToPython(
		@encode(CFOptionFlags), &callBackType);

	PyObject* result = PyObject_CallFunction(
		PyTuple_GetItem(info, 0),
		"NNO", py_f, py_callBackType, PyTuple_GetItem(info, 1));
	if (result == NULL) {
		PyObjCErr_ToObjCWithGILState(&state);
	}
	Py_DECREF(result);
	PyGILState_Release(state);
}

static PyObject*
mod_CFFileDescriptorCreate(
	PyObject* self __attribute__((__unused__)),
	PyObject* args)
{
	PyObject* py_allocator;
	PyObject* py_descriptor;
	PyObject* py_closeOnInvalidate;
	PyObject* callout;
	PyObject* info;
	CFAllocatorRef allocator;
	CFFileDescriptorNativeDescriptor descriptor;
	Boolean closeOnInvalidate;

	if (!PyArg_ParseTuple(args, "OOOOO", &py_allocator, &py_descriptor, &py_closeOnInvalidate, &callout, &info)) {
		return NULL;
	}

	if (PyObjC_PythonToObjC(@encode(CFAllocatorRef), py_allocator, &allocator) < 0) {
		return NULL;
	}
	if (PyObjC_PythonToObjC(@encode(CFFileDescriptorNativeDescriptor), py_descriptor, &descriptor) < 0) {
		return NULL;
	}
	if (PyObjC_PythonToObjC(@encode(bool), py_closeOnInvalidate, &closeOnInvalidate) < 0) {
		return NULL;
	}

	CFFileDescriptorContext context = mod_CFFileDescriptorContext;
	context.info = Py_BuildValue("OO", callout, info);
	if (context.info == NULL) {
		return NULL;
	}

	CFFileDescriptorRef rv = NULL;
	PyObjC_DURING
		rv = CFFileDescriptorCreate(
			allocator, descriptor, closeOnInvalidate,
			mod_CFFileDescriptorCallBack, &context);
		

	PyObjC_HANDLER
		rv = NULL;
		PyObjCErr_FromObjC(localException);

	PyObjC_ENDHANDLER

	Py_DECREF((PyObject*)context.info);
	if (PyErr_Occurred()) {
		return NULL;
	}

	PyObject* result =  PyObjC_ObjCToPython(@encode(CFFileDescriptorRef), &rv);
	if (rv != NULL) {
		CFRelease(rv);
	}
	return result;
}


static PyObject*
mod_CFFileDescriptorGetContext(
	PyObject* self __attribute__((__unused__)),
	PyObject* args)
{
	PyObject* py_f;
	PyObject* py_context;
	CFFileDescriptorRef f;
	CFFileDescriptorContext context;

	if (!PyArg_ParseTuple(args, "OO", &py_f, &py_context)) {
		return NULL;
	}

	if (py_context != Py_None) {
		PyErr_SetString(PyExc_ValueError, "invalid context");
		return NULL;
	}

	if (PyObjC_PythonToObjC(@encode(CFFileDescriptorRef), py_f, &f) < 0) {
		return NULL;
	}

	context.version = 0;

	PyObjC_DURING
		CFFileDescriptorGetContext(f, &context);

	PyObjC_HANDLER
		PyObjCErr_FromObjC(localException);

	PyObjC_ENDHANDLER

	if (PyErr_Occurred()) {
		return NULL;
	}

	if (context.version != 0) {
		PyErr_SetString(PyExc_ValueError, "retrieved context is not valid");
		return NULL;
	}

	if (context.retain != mod_filedescr_retain) {
		PyErr_SetString(PyExc_ValueError, 
			"retrieved context is not supported");
		return NULL;
	}

	Py_INCREF(PyTuple_GetItem((PyObject*)context.info, 1));
	return PyTuple_GetItem((PyObject*)context.info, 1);
}
#endif

#define COREFOUNDATION_FILEDESCRIPTOR_METHODS		\
        {		\
		"CFFileDescriptorCreate",		\
		(PyCFunction)mod_CFFileDescriptorCreate,		\
		METH_VARARGS,		\
		NULL		\
	},		\
        {		\
		"CFFileDescriptorGetContext",		\
		(PyCFunction)mod_CFFileDescriptorGetContext,		\
		METH_VARARGS,		\
		NULL		\
	},

#define COREFOUNDATION_FILEDESCRIPTOR_AFTER_CREATE		\
	if (&CFFileDescriptorCreate == NULL) {  /* weakly linked */		\
		if (PyObject_DelAttrString(m, "CFFileDescriptorCreate") == -1) {		\
			PyObjC_INITERROR();		\
		}		\
	}		\
	if (&CFFileDescriptorGetContext == NULL) {  /* weakly linked */		\
		if (PyObject_DelAttrString(m, "CFFileDescriptorGetContext") == -1) {		\
			PyObjC_INITERROR();		\
		}		\
	}

Wrappers for framework 'Cocoa', that is frameworks 'CoreFoundation', 
'Foundation' and 'AppKit'.

These wrappers don't include documentation, please check Apple's documention
for information on how to use this framework and PyObjC's documentation
for general tips and tricks regarding the translation between Python
and (Objective-)C frameworks

The following examples don't work correctly yet:
	CIBevelSample
	CIMicroPaint

If someone is bored: please port FunHouse as well.

This sample demonstrates the ImageKit ``ImageBrowser`` in a basic Cocoa 
application. It uses IB to create a window an ``ImageBrowser`` and a zoom 
slider. 

This sample should present a reasonably complete correctly formed Cocoa 
application which can be used as a starting point for using the ``ImageBrowser``
in a Cocoa applications. 

Usual steps to use the ImageKit image browser in your application:

1. setup your nib file

   Add a custom view and set its class to IKImageBrowserView.
   Connect an IBOutlet from your controller to your image browser view 
   and connect the ``IKImageBrowserView``'s ``_datasource`` ``IBOutlet`` to 
   your controller (if you want your controller to be the data source)

2. Don't forget to import the Quartz package::

	from Quartz import *

3. Create your own data source representation (here using a ``NSMutableArray``)::

	class MyController (NSWindowController):
	    _myImages = objc.ivar()
	    _myImageView = objc.IBOutlet()

4. implement the required methods of the informal data source protocol 
   (``IKImageBrowserDataSource``)::

	def numberOfItemsInImageBrowser_(self, browser):
		return len(self._images)

	def imageBrowser_itemAtIndex_(self, aBrowser, index):
		return self._images[index]


5.  The returned data source object must implement the 3 required 
    methods from the ``IKImageBrowserItemProtocol`` informal protocol:

	def imageUID(self): pass
	def mageRepresentationType(self): pass
	def imageRepresentation(self): pass

    * the id returned by ``imageUID`` MUST be different for each item 
      displayed in the image-view. Moreover, the image browser build it's 
      own internal cache according to this UID. the ``imageUID`` can be for 
      exemple the absolute path of an image existing on the filesystem or 
      another UID based on your own data structures.

    * ``imageRepresentationType`` return one of the following string constant 
      depending of the client's choice of representation::

	IKImageBrowserPathRepresentationType
	IKImageBrowserNSImageRepresentationType
	IKImageBrowserCGImageRepresentationType
	IKImageBrowserNSDataRepresentationType
	IKImageBrowserNSBitmapImageRepresentationType
	IKImageBrowserQTMovieRepresentationType

      (see IKImageBrowserView.h for complete list)

    * ``imageRepresentation`` return an object depending of the representation 
      type:

      *	a ``NSString`` for ``IKImageBrowserPathRepresentationType``
      * a ``NSImage`` for ``IKImageBrowserNSImageRepresentationType``
      * a ``CGImageRef`` for ``IKImageBrowserCGImageRepresentationType``
      * ...

    Here is a sample code of a simple implementation of a data source item::

      class myItemObject (NSObject, IKImageBrowserItem):
	_path = objc.ivar()

	def mageRepresentationType(self):
	    return IKImageBrowserPathRepresentationType;

	def mageRepresentation(self):
            return self._path

        def imageUID(self):
            return self._path

6. Now to see your data displayed in your instance of the image browser view, 
   you have to tell the browser to read your data using your ``IBOutlet`` 
   connected to the browser and invoke ``reloadData`` on it::

    self._myImageView.reloadData()

   Call ``reloadData`` each time you want the image browser to reflect changes 
   of your data source.

That's all for a very basic use.  Then you may need to add a scroller or a 
scrollview and a slider to your interface to let the user to scroll and zoom 
to browser his images. 

 -> FIXME: Transcribed from ObjC, but not yet tested

The samples in this directory are transcriptions of the 
examples in the book "Programming with Quartz" (ISBN: 978-0-12-369473-7), except for code
that relies on Carbon APIs like HIToolbox.

The APIs in the folder "python" use the pre-Leopard bindings to CoreGraphics, which are deprecated at best.

The original Readme file:

These directories contain the sample source code for the Quartz Book. Note that the source files are formatted
so that the tab indentation looks best in Xcode or BBEdit with 4 spaces per tab. 

CocoaDrawingShell:
Contains source for building the sample application created in Chapter 3.

CarbonDrawingShell:
Contains source for building the sample application created in Chapter 4.

BasicDrawing:
An application that contains the bulk of the sample code presented in the book. The directory BasicDrawing.cocoa contains an Xcode project and Cocoa specific source code for building a Cocoa version of the application. The directory BasicDrawing.carbon contains an Xcode project and Carbon specific source code for building a Carbon version of the application. The directory CommonCode contains the C code that is common to both the Cocoa and Carbon versions of the application.

PDFDraw:
This is a basic application that contains the code from Chapters 13 and 16 for opening and displaying PDF, PostScript, and EPS documents. This example is a Carbon application that uses the QDBeginCGContext/QDEndCGContext routines discussed in Chapter 4 as an alternate to using HIView. The user interface here is rudimentary; the focus of this sample is on the drawing of PDF documents and conversion of PostScript and EPS files into a PDF document that can be displayed like any other PDF file.

CreatePDFDocument:
This contains the sample code from Chapter 14 for creating new PDF documents, including those that contain links. This sample also demonstrates use of the new to Tiger API for creating encrypted PDF documents that have restricted permissions.

ConfidentialStamper:
Contains the source code for a tool that takes an input PDF document and "stamps" a second PDF document onto each page of the input file, creating a new PDF document.

ParsePageContents:
Contains the source code for a tool that takes an input PDF document and "stamps" a second PDF document onto each page of the input file, creating a new PDF document.

PSConverterTool:
Contains source code to a command line tool that uses the CGPSConverter API for converting a PostScript or EPS file into a PDF output file.

python:
Contains the sample Python scripts from Chapter 18. These are:

alpharects.py, which creates a PDF document containing the alpha rectangle drawing from Chapter 2.
pdftojpg.py, which takes an input PDF document and creates a JPEG output file for each page of the input document.
Stamp PDF with "Confidential".py, which is a PDF workflow script that can be installed in the 
	~/Library/PDF Services or /Library/PDF Services directory, adding a workflow item to the 
	workflow menu in the Print dialog. Choosing this workflow item stamps the word 
	"Confidential" onto each page of the PDF document being printed.



Issues with this example:

- Functionality using QuickTime doesn't work at all, the required functionality
  is not wrapped in Python.

- Colorspace handling in Utilities.py isn't the same as in the C version of
  this code.

Wrappers for frameworks 'CoreGraphics', 'ImageIO', 'QuartzCore',
'ImageKit', 'PDFKit', and 'CoreVideo'.

All frameworks can be accessed by importing the 'Quartz' module.

These wrappers don't include documentation, please check Apple's documention
for information on how to use this framework and PyObjC's documentation
for general tips and tricks regarding the translation between Python
and (Objective-)C frameworks

Music-Player-Daemon backend
===========================

The [`mpdBackend`](https://github.com/albertz/music-player/blob/master/mpdBackend.py) module is a basic implementation of the backend of the [MPD protocol](http://www.musicpd.org/doc/protocol/) for this music player. It means that any [MPD client](http://mpd.wikia.com/wiki/Clients) can connect to this music player and control it.

Note that MPD and this music player have a fundamental different design (see [here](https://github.com/albertz/music-player/blob/master/Compare_to_MPD.md)), thus not all MPD functions can perfectly be mapped as functions in this player. But for many basic functions, good mappings exist.

This backend tries to emulate MPD 0.17.0.

Some of the functions supported so far (high-level list):

* browse files (`lsinfo` command)
* status / play / pause / next / seeking / volume / ...
* current playlist maps to the main queue
* adding to current playlist
* deleting from current playlist 
* search 

More details can be found in the [source](https://github.com/albertz/music-player/blob/master/mpdBackend.py).

Tested clients (they work to some degree with certain bugs...):

* [ncmpcpp](http://mpd.wikia.com/wiki/Client:Ncmpcpp)
* [Theremin (Mac)](https://github.com/TheStalwart/Theremin)
* [Groove Basin (web)](https://github.com/superjoe30/groovebasin)



# Other projects

There exists a huge amount of music players. Here is a list of some and other related projects. This list is not meant to be complete - but rather to be interesting in the scope of this project. This means a focus on Open Source, sound quality, platform independence, advanced DJ features, advanced queuing systems, etc.

(I'm open for suggestions but don't expect that I will just add anything here.)



## Music players

### [Amarok](http://amarok.kde.org/)

* Open Source, based on KDE, ports are too limited.
* It was my preferred player on Linux.

### [Clementine](http://www.clementine-player.org/)

* [Open Source](https://code.google.com/p/clementine-player/), forked Amarok, made cross platform.

### XMMS, [Audacious](http://audacious-media-player.org/), [BMP](http://sourceforge.net/projects/beepmp/)

* Open Source, descendant of XMMS

### [XMMS2](https://xmms2.org/)

* Open Source

### [Music Player Daemon (MPD)](http://www.musicpd.org/)

* Open Source
* daemon, lightweight, seperate clients
* Note that this player is compatible to MPD, i.e. it emulates the MPD server interface, thus MPD clients work with this player.

### [Tomahawk player](http://www.tomahawk-player.org/)

* [Open Source](https://github.com/tomahawk-player/tomahawk) (GPL)
* MacOSX, Windows, Linux

### [Songbird](http://getsongbird.com/)

* Open Source, based on Mozilla XULRunner + GStreamer.
* Too slow / bloated. Huge amount of problems.
* Project dead since 2013?

### [Banshee](http://banshee.fm/)

### [Exaile](http://exaile.org/)

* Open Source, GTK+, Python.
* Music manager + player.

### [Rhythmbox](https://projects.gnome.org/rhythmbox/)

* Open Source, Gnome.

### [QMMP](http://qmmp.ylsoftware.com/)

* Open Source, Qt

### [Quod Libet](https://code.google.com/p/quodlibet/)

* Open Source, GTK+, Python.
* Make playlist by regular expressions.

### [Listen](http://www.listen-project.org/)

* [Open Source](http://sourceforge.net/projects/listengnome/), Gnome.
* Project dead?

### [Deepin Music Player](https://github.com/linuxdeepin/deepin-music-player)

* Open Source, Python, GStreamer

### [Foobnix](https://github.com/foobnix/foobnix)

* Open Source, Python
* CUE, wv, iso support
* 10-band equalizer

### [Decibel](http://decibel.silent-blade.org/)

* Open Source, GTK+.
* Interesting small project. I found it because there is a [same-named proprietary player for OSX](http://sbooth.org/Decibel/) from the same [person](https://github.com/sbooth) who also developed [Play](#play).
* Lightweight and fast.

### [Play](http://sbooth.org/Play/)

* [Open Source](https://github.com/sbooth/Play), MacOSX only, ObjC mostly.

### [audirvana](https://code.google.com/p/audirvana/)

* Open Source earlier, source not available anymore. seems abandoned because they have a commercial Plus version now.
* OSX only.
* "HAL I/O using DAC native physical formats 'Integer Mode' (instead of CoreAudio 32bit float)", "Audio Device exclusive access mode", "Direct sound path, directly to the CoreAudio HAL for pure bit perfect sound".

### [Douban FM Daemon (FMD)](http://hzqtc.github.io/fmd/)

* Open Source, C, mpg123, libao
* very simple, no fading, no gapless, ...
* inspired by MPD

### [Cog](http://cogx.org/)

* [Open Source](http://sourceforge.net/projects/cogosx/), MacOSX
* no update since 2008, latest release is 0.07

### [gmusicbrowser](http://gmusicbrowser.org/)

* Open Source, Perl, GTK+, GStreamer

### [Nulloy](http://nulloy.com/)

* [Open Source](https://github.com/sergey-vlasov/nulloy), C++, Qt, cross-platform (Win, Linux, Mac)
* Waveform progress bar

### [minirok](http://chistera.yi.org/~dato/code/minirok/)

* Open Source, written in Python, Qt, GStreamer
* modelled as a mini-version of Amarok

### [Guayadeque](http://guayadeque.org/)

* Open Source, C++, wxWidgets, GStreamer
* Smart play mode = intelligent queue
* Crossfader, Silence detector

### [Pimp: Python Interactive Music Player](http://pimplayer.berlios.de/)

* Open Source, written in Python

### [Python Music Player](http://sourceforge.net/projects/music-player/)

* Open Source, PyGTK, enhanced queueing system
* last update from 2005

### [PyMP: Python Music Player](https://code.google.com/p/python-music-player/)

* Open Source, Python, GStreamer

### [The Python Intelligent MP3 Player](http://sourceforge.net/projects/pimp3/)

* Open Source, Python, song ratings + high-rated songs are played more often
* last update from 2001

### [kwplayer](https://github.com/LiuLang/kwplayer)

* Open Source, Python, GStreamer

### [dacapo](http://sourceforge.net/projects/dacapo-player/)

* Open Source, Python, GStreamer, GTK+

### [Pyrana](https://github.com/jdodds/pyrana)

* Open Source, Python, GStreamer, GTK+
* very minimal


## Web-based streaming players

### [CherryMusic](http://www.fomori.org/cherrymusic/)

* [Open Source](https://github.com/devsnd/cherrymusic) (GPL), Python, [CherryPy](http://www.cherrypy.org/), [jPlayer](http://jplayer.org/)
* no advanced player technics like Gapless playback, mixing, etc. (because of web technology)

### [Democratic Jukebox](https://github.com/lociii/jukebox)

* Open Source (MIT), Python
* web-interface for voting on songs for intelligent queue

### [Groove Basin](https://github.com/andrewrk/groovebasin)

* Open Source, Node.js, based on [libgroove](https://github.com/andrewrk/libgroove)


## Libraries

For comparisons to Python modules which share features of this Python `musicplayer` core module, see at the [homepage of the musicplayer Python module](https://github.com/albertz/music-player-core).

This is a list of some random related libraries.

### [Mutagen](https://code.google.com/p/mutagen/)

* Python module to handle audio metadata.

### [VSXu](http://www.vsxu.com/)

* [Open Source](https://github.com/vovoid/vsxu) (GPL)
* Audio/Music Visualizer
* Embeddable visual programming language, real-time OpenGL graphics

### [sms-tools](https://github.com/MTG/sms-tools)

* Python
* spectral modelling synthesis tools for sound and music applications

### [libao](http://xiph.org/ao/)

* Open Source (GPL; problem for us because we are BSD)
* cross platform audio output library
* supports OSS, ALSA, PulseAudio, esd, MacOSX, Windows, ...
* latest release was 2011

### [PortAudio](http://www.portaudio.com/)

* Open Source (MIT license), cross-platform, input/output library
* currently used by this project


# Technical

## Reduce Python

* Minimize Python modules usage. Write some code to list all used modules (and objects).
* Remove GIL. We will use only some small subset of objects anyway (dict, set, string, int, ...). Make reference counter atomic.
* Support memory snapshot after module loading. Needs some tracking about system state dependency. E.g. should track which files are read and whether they changed.

## Trace Python

* For code that is triggered by a GUI event (e.g. click): Trace all further Python calls. I want to know how long it takes until the GUI becomes responsible again and why it takes so long. Also record any spawned threads / subtasks.

## Exclusive access (hog mode)

* It means to send the raw data exclusively over the line (to the DA converter).
* Some players such as [BitPerfect](http://bitperfectsound.blogspot.de/p/hog-mode.html), [Decible](http://sbooth.org/Decibel/), [Pure Music](http://www.channld.com/puremusic/), [audirvana](https://code.google.com/p/audirvana/) support that. This player should too.
* [Paper: OSX Playback Integer Mode](http://www.amr-audio.co.uk/large_image/MAC%20OSX%20audio%20players%20&%20Integer%20Mode.pdf)



Music player
============

First, if you wonder about what is supposed to be a music player or what makes a music player different from a simple media player, read this: [What is a music player](https://github.com/albertz/music-player/blob/master/WhatIsAMusicPlayer.md)

Annoyed by all existing players because some subset of:

* not open source
* missing sound format ([FLAC](http://flac.sourceforge.net/itunes.html), Ogg, ...)
* bugs ([1](http://bugzilla.songbirdnest.com/show_bug.cgi?id=23640), [2](http://bugzilla.songbirdnest.com/show_bug.cgi?id=25023), [3](http://bugzilla.songbirdnest.com/show_bug.cgi?id=25042), [4](http://bugzilla.songbirdnest.com/show_bug.cgi?id=18503), [5](http://bugzilla.songbirdnest.com/show_bug.cgi?id=18505), [6](http://bugzilla.songbirdnest.com/show_bug.cgi?id=18480), [7](http://bugzilla.songbirdnest.com/show_bug.cgi?id=18478), [8](http://bugzilla.songbirdnest.com/show_bug.cgi?id=25073), [9](http://bugzilla.songbirdnest.com/show_bug.cgi?id=25024), [10](http://bugzilla.songbirdnest.com/show_bug.cgi?id=5975), ...)
* missing output possibility (RAOP, PulseAudio, ...)
* none or too limited intelligent automatic queue (iTunes calls this DJ mode, others call this PartyShuffle)
* no library / database

Features of this player:

* open source (simplified BSD license, see [License.txt](https://github.com/albertz/music-player/blob/master/License.txt))
* simple
* support of most important sound formats
* advanced intelligent automatic queue which is the main mode to play music
* simple music database
* ReplayGain / audio volume normalization
* [Last.fm](http://last.fm) scrobbling
* [AcoustID](http://acoustid.org) fingerprint
* [Gapless playback](http://en.wikipedia.org/wiki/Gapless_playback)
* [MPD backend](https://github.com/albertz/music-player/blob/master/mpdBackend.readme.md)

![MusicPlayer screenshot](https://github.com/albertz/music-player/raw/master/screenshot.png)

About the intelligent automatic queue, what I want (maybe some of these somewhat configurable):

* continuously always add songs when queue becomes too empty
* liked songs more often
* context-based choices, e.g. related songs more likely
* possibility to easily manually add songs to the list
* easy way to restrict to a subset of songs (like a genre, a playlist, a filesystem directory, etc.)

About the database:

* main function: search
* should be fast and optional for playback, i.e. music can be played even when the database is currently not ready for some reason
* should automatically be filled by a filesystem directory
* import like-state from local players like iTunes and also online services like Last.fm

TODO / possible additional missing features:

* BPM determination and clever DJ-like fading
* use tags given by Last.fm (mostly more tags)
* watch music directory for changes (e.g. new files added)
* other GUI implementations

Comparison to other music players:

* [Music Player Daemon (MPD)](https://github.com/albertz/music-player/blob/master/Compare_to_MPD.md)

Installation:

So far, there is a prebuild MacOSX app bundle in the [download section](https://sourceforge.net/projects/az-music-player/files/) which should just work. Otherwise, to get the source working, you need these requirements (e.g. install on MacOSX via Homebrew):

* ffmpeg
* portaudio
* chromaprint

(Debian/Ubuntu: `apt-get install python-dev libsnappy-dev libtool yasm libchromaprint-dev portaudio19-dev libboost-dev`. FFmpeg in Debian/Ubuntu is too old (lacks libswresample), so either do `add-apt-repository ppa:jon-severinsson/ffmpeg && apt-get update && apt-get install libavformat-dev libswresample-dev` or install it from source. [Chromaprint](http://acoustid.org/chromaprint) depends on FFmpeg, so if you have a custom FFmpeg install, you might also want to install that manually. `./configure && make && sudo make install` should work for FFmpeg and PortAudio. You might also want to use `--enable-shared` for FFmpeg. `cmake . && sudo make install` for Chromaprint.)

Then call `./compile.py` to build the Python modules (it will build the Python modules `ffmpeg.so` and `leveldb.so`).

To start the player, just call `./main.py`.

The current GUI is Cocoa only. Additional Qt support is planned. The music player also works without any GUI.

You can also control the player via an interactive Python shell. You can get the shell directly by passing `--shell` to `main.py` or you can use `tools/shell.py`. Via the shell, you can do just anything. By default, the shell exports already the two main objects `state` and `queue`. Here some useful actions:

* `import utils`: common imports you might need for the other commands
* `state.curSong`: returns the current song
* `state.player.playing = True`: start playing. or start/stop via `state.playPause()`
* `state.nextSong()`: skips to next song
* `state.queue.shuffle()`: shuffles the queue
* `utils.formatTime(sum([s.get("duration", accuracy=0, fastOnly=True)[0] or 0 for s in queue.queue.list]))`: get the amount of time of all songs in the queue
* `import guiCocoa; reload(guiCocoa)`: reload Cocoa GUI. this might be useful if it crashed (which shouldn't happen, though)

You can use `dir` to get a list of attributes of an object. E.g. `dir(state)` returns list of all `state`-attributes. This might be useful if you want to figure out what you can do. But it might be easier to just look at the source. And you can use tab-autocompletion, e.g. type `state.` and press tab.

Also, don't hesitate to play around with the code. You might be interested in the [automatic queue handling code](https://github.com/albertz/music-player/blob/master/queue.py).

Authors:

* Albert Zeyer, <http://www.az2000.de>: founder of the project, main core, ffmpeg module, etc.
* Bryan Joseph, <http://bryaninspired.com>: some initial ideas about the database


# Roadmap

Optimize, either by reimplemtation in C or see below (via static compiling Python):
- binstruct.py
- songdb.py
- guiCocoa.py / guiCocoaCommon.py (aready WIP)
- maybe itunes.py and others
- etc.

On the DB (songdb.py):
- Separate DB low level stuff and Song/MusicPlayer stuff. We want to use the DB also outside.

What is a music player?
=======================

Sometimes I get asked questions like:

> What does a music player do?
> Isn't it trivial to just play some mp3s?
> What makes a music player better at playing music than some media player like [VLC](http://www.videolan.org/vlc/) ([*](#vlc))?
> Can the audio playback quality really differ between different players?

So, I'll try to answer these questions here now.


## [Resampling](http://en.wikipedia.org/wiki/Resampling_%28audio%29)

The [soundcard](http://en.wikipedia.org/wiki/Sound_card) or the [operating system (OS)](http://en.wikipedia.org/wiki/Operating_system) usually gets [raw PCM data](http://en.wikipedia.org/wiki/Pulse-code_modulation) from an application. It usually internally works with PCM data at 48 kHz or 96 kHz. If you feed it the PCM data at another frequency, it is often able to resample the data automatically.

Audio [CDs](http://en.wikipedia.org/wiki/Compact_Disc) and most MP3s are encoded with 44.1 kHz and thus there is some resampling needed at some point.

Resampling isn't trivial and there is not really a straight-forward way to do it. Thus, different algorithms can result in much different quality.

A simple media player usually doesn't cares about that and leaves the resampling to the OS or has only some simple resampling algorithm.

A music player usually has its own high-quality resampling algorithm.

This project uses [libswresample of FFmpeg](http://ffmpeg.org/doxygen/trunk/libswresample_2resample_8c-source.html).


## [Loudness normalization](http://en.wikipedia.org/wiki/Audio_normalization#Loudness_normalization)

Different songs from different sources often have different volume / loudness.

A media player usually just plays the song as-is.

In a music player, you usually want that all songs are played with about the same loudness so that you don't have to manually frequently change the volume to adopt to the current song.

Many existing music players don't have their own loudness analyzing algorithm. They depend on external software which analyzes your music and saves the volume-change-information in the metatags of your songs. The music player checks for that metadata information and applies the volume change. However, if it stumbles upon a song which misses this metadata information, it will not be able to do the loudness normalization.

Some professional music players such as iTunes have their own analyzing algorithm.

This project also has its own analyzing algorithm which calculates the loudness of a song based on the [ReplayGain specification](http://wiki.hydrogenaudio.org/index.php?title=ReplayGain_1.0_specification).


## Avoid [clipping](http://en.wikipedia.org/wiki/Clipping_%28audio%29) issues when incrementing the volume

When you set the volume to more than 100% (which could also theoretically, though rarely happen from the loudness normalization), you might get the case that you get PCM samples which exceeds the maximum value. E.g. assume that a PCM sample value must be between -1 and 1. If you apply the volume change and you get a value `v > 1`, you must make it fit somehow. The simplest variant would be to just use `1` as the value in that case. This is called clipping.

You want to avoid clipping because it results in bad distorted sound.

Via [dynamic range compression](http://en.wikipedia.org/wiki/Dynamic_range_compression), you can get rid of this effect while at the same time have other quality losses and you have the audio data altered.

This project uses a smooth compression variant which is only applied for values above some high threshold. Thus, in most cases, the audio data is not altered at all which is what [audiophiles](http://en.wikipedia.org/wiki/Audiophile) usually want. The compression itself has some nice properties such as that it is always smooth and will never need clipping.


## Equalizer

In some cases, you might want to have an equalizer to alter the sound a bit.


## Switching songs

The switch to the next song when some song is finished can be done in various ways.

The straight-forward way would be to just start the playback of the next song once the old song has hit the end. This is what most simple media players would do (if they have some playlist support at all).

A music player could do some fading, i.e. fading the old song out and at the same time fading the new song in.

Some players support [beatmatching](http://en.wikipedia.org/wiki/Beatmatching) so that the tempo or pitch of a song gets slightly changed so that it can seamlessly mixed with the next song. For that (and other things), it is useful to know the [beats per minute](http://en.wikipedia.org/wiki/Tempo#Beats_per_minute) of a song. Some music players and most DJ mixing software can analyze the song to determine the BPM. This is far from trivial and the BPM is not always well defined for all songs.

A music player could also try to avoid cracking if the song starts/ends abruptly.

Many music players also have support for [gapless playback](http://en.wikipedia.org/wiki/Gapless_playback). Some songs, e.g. coming from an album might have extra information how much pause there should be between them when playing the songs of the album consecutively. To have perfect control over how much pause there is, you usually need to preload the next song and mix them together in memory -- doing that on-the-fly would most certainly add some short pause.


## Skip silence sections of songs

Some songs have some longer silence sections in between them. In some cases, you might want to automatically skip these sections.


## Different sound formats

There is a wide range of sound formats, like MP3, Flac, WMA, Ogg, etc. It is very non-trivial to have support for them all.

This project uses the great [FFmpeg](http://ffmpeg.org/) library which has support for most formats and codecs.


## Intelligent automatic queue

In a music player when you have a big music library, you sometimes just want to play some random music, maybe listen to some songs you haven't heard in a while, randomly listening through your music. Sometimes you want to play some specific songs and when they are finished, it should randomly play further songs which are similar. Maybe you have some songs on your computer you don't like that much and you prefer to listen to music you like more.

Media players as well as many simple music players usually don't have any functionality where you can achieve this.

Some better music players have such things with some limited functionality. For example iTunes has this and calls it iTunes DJ mode. Some other players call this PartyShuffle.

In this project, this is central element - the main queue.

A music player could also try to choose similar songs to the current song. Analyzing the similarity of songs is again a wide area. There is for example the [MusicBox project / master thesis](http://thesis.flyingpudding.com/) which introduces in that area.


## Caching and realtime

Depending on where you are reading the song files from, e.g. local disc, network share, some Internet stream, CD, USB drive or so, reading takes some noticeable time and also might be delayed. Even worse, that might be very varying - there could be sudden drastic slow-downs or delays.

You want to be sure that while playing, the music doesn't stop suddenly. So you must make an estimation about how much data you must have read in advance into a local cache in memory so that you always have enough data left.

Also, encoding takes time. It is usually possible in realtime, meaning that encoding the full song takes less time than playing the full song, which makes it simpler in this regards. However, it still takes time and when you got the callback from the sound driver which requests for new data, you should provide data as fast as possible -- otherwise, the internal sound driver cache runs out of data and there will be a sudden drop of playback. Thus, you should do the encoding in parallel and do also some caching there so that there is always enough data present for delivery to the sound driver.

There might be situations where your operating system or the user is doing some heavy tasks which takes many system resources. This could slow down the IO access and the CPU time for the music player drastically. This would invalidate previous calculations about how much cache you need. Also, in extreme cases, encoding or even reading is not possible in realtime anymore -- which would always lead to drops in the playback.

Many operating systems provide ways to ensure your application that it got a certain amount of CPU time and also the needed amount of IO bandwidth. This is often called [real-time computing](http://en.wikipedia.org/wiki/Real-time_computing). Modern operating systems like Linux, MacOSX or Windows aren't true [real-time operating systems](http://en.wikipedia.org/wiki/Real-time_operating_system) -- however, their scheduler still can ensure certain real-time constraints with high probability.

This project, on MacOSX, uses [real-time threads](https://developer.apple.com/library/mac/#documentation/Darwin/Conceptual/KernelProgramming/scheduler/scheduler.html).


## [Last.fm](http://last.fm)

You might want to track the songs you listened with [Last.fm](http://last.fm) or some similar service (Last.fm calls this scrobbling). Last.fm can generate some interesting statistics about your music taste and make you new suggestions based on this.

This project supports Last.fm scrobbling.


## Song database

Most users have a huge amount of music. It makes sense for a music player to provide a simple and fast way to search in that music library. Also, the music player sometimes wants to save extra information about songs, such as when you lastly played it and how often you played it, etc. Also, you might want to give the user the ability to add some extra information about a song, such as further tags, some notes or some rating.

For all this, you need a database. Media players as well as simple music players usually don't have.

Most more complex music players as well as this project have that.


## Audio fingerprint

An audio fingerprint represents the song. Depending on the properties of the fingerprint, you can compare a song for similarity (based on the similarity of the fingerprint) and search for duplicate songs. Also, there are services like [MusicBrainz](http://musicbrainz.org) where you can query for metadata information such as artist name and title for any given song fingerprint. This makes sense if these information is missing.

This project can calculate the [AcoustId](http://acoustid.org/) fingerprint which is also used by MusicBrainz.


## Visual representation of audio data

You might want to see some visual representation of a song. This project supports that and calculates visual representations which look like this:

![song thumbnail](https://github.com/albertz/music-player/raw/master/song-thumbnail.png)

The color represents the spectral centroid of the sound frequency. This is calculated via a [fast Fourier transformation](http://en.wikipedia.org/wiki/Fast_Fourier_transform).


---

If you want to know some more about the internals of this project, read the [development notes](DevelopmentNotes.md).

---

## VLC

VLC is actually a bad example. It was more what you would probably expect what VLC is and does (as I did). But VLC nowadays has quite advanced in many respects and has basic volume normalizaton, dynamic range compression, an equalizer along other things. It is still missing gapless playback and a music library (although both is planned) and more advanced queue handling (such as an intelligent automatic queue).

