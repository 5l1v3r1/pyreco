__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# turses documentation build configuration file, created by
# sphinx-quickstart on Sat Apr 14 01:12:28 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

#import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.intersphinx', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'turses'
copyright = u'2012, Alejandro Gómez, Nicolas Paris'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The full version, including alpha/beta/rc tags.
from turses import version 
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'tursesdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'turses.tex', u'turses Documentation',
   u'Alejandro Gómez, Nicolas Paris', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'turses', u'turses Documentation',
     [u'Alejandro Gómez, Nicolas Paris'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'turses', u'turses Documentation',
   u'Alejandro Gómez, Nicolas Paris', 'turses', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = test_api
# -*- coding: utf-8 -*-

from sys import path
path.append('../')
import unittest

from . import create_status, create_direct_message

from turses.models import Timeline
from turses.api.base import AsyncApi
from turses.api.debug import MockApi
from turses.api.backends import TweepyApi
from turses.api.helpers import (
    TimelineFactory,

    is_home_timeline,
    is_mentions_timeline,
    is_favorites_timeline,
    is_messages_timeline,
    is_own_timeline,
    is_search_timeline,
    is_user_timeline,
    is_retweets_of_me_timeline,
    is_thread_timeline,
)


ACCESS_TOKEN = 'Yohohohoooo'
ACCESS_TOKEN_SECRET = 'Skull joke!'

mock_api = MockApi(ACCESS_TOKEN, ACCESS_TOKEN_SECRET)


class AsyncApiTest(unittest.TestCase):
    def test_that_implements_abstract_base_class(self):
         AsyncApi(MockApi,
                  access_token_key=ACCESS_TOKEN,
                  access_token_secret=ACCESS_TOKEN_SECRET,)


class MockApiTest(unittest.TestCase):
    def test_that_implements_abstract_base_class(self):
         MockApi(access_token_key=ACCESS_TOKEN,
                 access_token_secret=ACCESS_TOKEN_SECRET,)


class TweepyApiTest(unittest.TestCase):
    def test_that_implements_abstract_base_class(self):
         TweepyApi(access_token_key=ACCESS_TOKEN,
                   access_token_secret=ACCESS_TOKEN_SECRET,)


class HelperFunctionTest(unittest.TestCase):
    def test_is_home_timeline(self):
        a_timeline = Timeline()
        self.assertFalse(is_home_timeline(a_timeline))

        home_timeline = Timeline(update_function=mock_api.get_home_timeline)
        self.assertTrue(is_home_timeline(home_timeline))

    def test_is_mentions_timeline(self):
        a_timeline = Timeline()
        self.assertFalse(is_mentions_timeline(a_timeline))

        mentions_timeline = Timeline(update_function=mock_api.get_mentions)
        self.assertTrue(is_mentions_timeline(mentions_timeline))

    def test_is_favorites_timeline(self):
        a_timeline = Timeline()
        self.assertFalse(is_favorites_timeline(a_timeline))

        favorites_timeline = Timeline(update_function=mock_api.get_favorites)
        self.assertTrue(is_favorites_timeline(favorites_timeline))

    def test_is_own_timeline(self):
        a_timeline = Timeline()
        self.assertFalse(is_own_timeline(a_timeline))

        own_timeline = Timeline(update_function=mock_api.get_own_timeline)
        self.assertTrue(is_own_timeline(own_timeline))

    def test_is_messages_timeline(self):
        a_timeline = Timeline()
        self.assertFalse(is_messages_timeline(a_timeline))

        messages_timeline = Timeline(update_function=mock_api.get_direct_messages)
        self.assertTrue(is_messages_timeline(messages_timeline))

    def test_is_search_timeline(self):
        a_timeline = Timeline()
        self.assertFalse(is_search_timeline(a_timeline))

        search_timeline = Timeline(update_function=mock_api.search)
        self.assertTrue(is_search_timeline(search_timeline))

    def test_is_user_timeline(self):
        a_timeline = Timeline()
        self.assertFalse(is_user_timeline(a_timeline))

        user_timeline = Timeline(update_function=mock_api.get_user_timeline)
        self.assertTrue(is_user_timeline(user_timeline))

    def test_is_retweets_of_me_timeline(self):
        a_timeline = Timeline()
        self.assertFalse(is_retweets_of_me_timeline(a_timeline))

        rts_timeline = Timeline(update_function=mock_api.get_retweets_of_me)
        self.assertTrue(is_retweets_of_me_timeline(rts_timeline))

    def test_is_thread_timeline(self):
        a_timeline = Timeline()
        self.assertFalse(is_thread_timeline(a_timeline))

        thread_timeline = Timeline(update_function=mock_api.get_thread)
        self.assertTrue(is_thread_timeline(thread_timeline))


class TimelineFactoryTest(unittest.TestCase):
    def setUp(self):
        self.factory = TimelineFactory(mock_api)

    def valid_name(self, timeline_name):
        """Test that `timeline_name` is a valid timeline name."""
        self.assertTrue(self.factory.valid_timeline_name(timeline_name))

    def test_default_names_are_valid_timeline_names(self):
        self.valid_name('home')
        self.valid_name('mentions')
        self.valid_name('favorites')
        self.valid_name('messages')
        self.valid_name('own_tweets')

    def test_search_names_are_valid_timeline_name(self):
        self.valid_name('search:turses')
        self.valid_name('search:I love ramen!')
        self.valid_name('search:#Python is awesome')

    def test_user_names_are_valid_timeline_name(self):
        self.valid_name('user:dialelo')
        self.valid_name('user:PepeGuer')

    def test_retweets_of_me_is_valid_timeline_name(self):
        self.valid_name('retweets_of_me')

    def created_timeline_verifies(self, name, prop):
        """
        Test that the timeline created from `name` verifies the `prop`
        property.
        """
        timeline = self.factory(name)
        self.assertTrue(prop(timeline))

    # TODO: remove hardcoded timeline names
    def test_timeline_factory_home(self):
        self.created_timeline_verifies('home', is_home_timeline)

    def test_timeline_factory_mentions(self):
        self.created_timeline_verifies('mentions', is_mentions_timeline)

    def test_timeline_factory_favorites(self):
        self.created_timeline_verifies('favorites', is_favorites_timeline)

    def test_timeline_factory_messages(self):
        self.created_timeline_verifies('messages', is_messages_timeline)

    def test_timeline_factory_own_tweets(self):
        self.created_timeline_verifies('own_tweets', is_own_timeline)

    def test_timeline_factory_search(self):
        self.created_timeline_verifies('search:turses', is_search_timeline)

    def test_timeline_factory_search_query(self):
        query = 'Programming is fun'

        timeline = self.factory(':'.join(['search', query]))

        self.assertEqual(timeline._args, [query])

    def test_timeline_factory_retweets_of_me(self):
        self.created_timeline_verifies('retweets_of_me',
                                       is_retweets_of_me_timeline)

    def test_thread(self):
        status = create_status()

        thread_timeline = self.factory.thread(status)

        self.assertEqual(thread_timeline.update_function.__name__,
                         'get_thread',)
        self.assertEqual(thread_timeline._args[0], status)

    def test_dm_thread(self):
        message = create_direct_message()

        dm_thread_timeline = self.factory.thread(message)

        self.assertEqual(dm_thread_timeline.update_function.__name__,
                         'get_message_thread',)
        self.assertEqual(dm_thread_timeline._args[0], message)

########NEW FILE########
__FILENAME__ = test_config
# -*- coding: utf-8 -*-

import unittest
from mock import Mock
from os.path import join
from sys import path
path.append('../')

from turses.config import (
    CONFIG_PATH,
    DEFAULT_CONFIG_FILE,
    DEFAULT_TOKEN_FILE,
    PALETTE,
    STYLES,
    DEFAULT_SESSION,
    KEY_BINDINGS,
    TWITTER,
    LOGGING_LEVEL,

    validate_color,
    Configuration,
)


class Args(object):
    """
    Represents the arguments.
    """
    def __init__(self,
                 account=None,
                 config=None,
                 generate_config=None,
                 session=None):
        self.account = account
        self.config = config
        self.generate_config = generate_config
        self.session = session


class ConfigurationTest(unittest.TestCase):
    """Tests for `turses.config.Configuration`."""

    def test_palette(self):
        """Test that every color in the default `PALETTE` is valid."""
        for label in list(PALETTE):
            # ignore the label name
            for color in label[1:]:
                if color:
                    self.assertTrue(validate_color(color))

    def test_defaults(self):
        """Test that defaults get loaded correctly."""
        config = Configuration()

        # files
        self.assertEqual(config.config_file, DEFAULT_CONFIG_FILE)
        self.assertEqual(config.token_file, DEFAULT_TOKEN_FILE)

        # config options
        self.assertEqual(config.twitter['update_frequency'],
                         TWITTER['update_frequency'])
        self.assertEqual(config.twitter['use_https'],
                         TWITTER['use_https'])
        self.assertEqual(config.key_bindings, KEY_BINDINGS)
        self.assertEqual(config.palette, PALETTE)
        self.assertEqual(config.styles, STYLES)
        self.assertEqual(config.logging_level, LOGGING_LEVEL)

        # debug mode
        self.assertEqual(config.debug, False)

    def test_parse_config_file(self):
        pass

    def test_parse_token_file(self):
        pass

    def test_parse_legacy_config_file(self):
        pass

    def test_parse_legacy_token_file(self):
        pass

    def test_set_color(self):
        """Test `Configuration._set_color`."""
        config = Configuration()

        palette = [
            ['first', 'cyan', 'black', 'default', ''],
            ['second', 'green', 'black']
        ]
        modified_color = ['first', 'black', 'cyan', 'default', '']
        palette[0] = modified_color
        label, fg, bg = modified_color[:3]

        config.palette = list(palette)
        config._set_color(label, fg, bg)

        self.assertEqual(palette, config.palette)

        config._set_color('idontexist', fg, bg)
        self.assertEqual(palette, config.palette)

    def test_set_key_binding(self):
        """Test `Configuration._set_key_binding`."""
        config = Configuration()

        key_bindings = {
            'quit': ('q', 'Quit the program'),
            'help': ('h', 'Show help')
        }

        config.key_bindings = key_bindings.copy()
        # swap the key bindings
        config._set_key_binding('quit', 'h')
        config._set_key_binding('help', 'q')
        swapped_key_bindings = {
            'quit': ('h', 'Quit the program'),
            'help': ('q', 'Show help')
        }

        self.assertEqual(swapped_key_bindings, config.key_bindings)

        config._set_key_binding('idontexist', '~')
        self.assertEqual(swapped_key_bindings, config.key_bindings)

    def test_args_account(self):
        account = 'bob'
        args = Args(account=account)
        token_path = join(CONFIG_PATH, "%s.token" % account)

        config = Configuration()
        config.parse_args(args)

        self.assertEqual(token_path, config.token_file)

    def test_args_generate_config(self):
        config_path = '~/.turses/custom_config'
        args = Args(generate_config=config_path)

        config = Configuration()
        config.generate_config_file = Mock()
        config.exit_with_code = Mock()
        config.parse_args(args)

        config.generate_config_file.assert_called_once()
        config.exit_with_code.assert_called_once_with(0)

    def test_args_config(self):
        config_path = '/path/to/custom/config/file'
        args = Args(config=config_path)

        config = Configuration()
        config.parse_args(args)

        self.assertEqual(config_path, config.config_file)

    def test_no_session_arg_means_default_session(self):
        args = Args()

        config = Configuration()
        config.parse_args(args)

        self.assertEqual(DEFAULT_SESSION, config.session)

    def test_args_session(self):
        args = Args(session='interactions')

        config = Configuration()
        config.parse_args(args)

        self.assertEqual('interactions', config.session)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_core
# -*- coding: utf-8 -*-

from sys import path
path.append('../')
import unittest

from mock import Mock

from . import create_status
from turses.models import TimelineList
from turses.api.helpers import (
    is_home_timeline,
    is_user_timeline,
    is_own_timeline,
    is_mentions_timeline,
    is_messages_timeline,
    is_thread_timeline,
)
from turses.config import configuration
from turses.core import InputHandler, Controller
from turses.api.debug import MockApi


class InputHandlerTest(unittest.TestCase):

    # - Helpers ---------------------------------------------------------------

    def executes(self, commands):
        """Assert that calling the key handlers `handle` method with all
        the keys corresponding to the commands in `commands` calls the
        handler for that command."""
        for command in commands:
            handler = commands[command]
            key = self.key(command)

            self.key_handler.handle(key)

            self.failUnless(handler.called)

    def does_not_execute(self, commands):
        """Assert that calling the key handlers `handle` method with all
        the keys corresponding to the commands in `commands` DOES NOT call the
        handler for that command."""
        for command in commands:
            handler = commands[command]
            key = self.key(command)

            self.key_handler.handle(key)

            self.failIf(handler.called)

    def key(self, command):
        key, _ = configuration.key_bindings[command]
        return key

    # - Tests -----------------------------------------------------------------

    def setUp(self):
        self.controller = Mock(Controller)
        self.key_handler = InputHandler(self.controller)

        return_false = Mock(return_value=False)
        self.controller.is_in_info_mode = return_false
        self.controller.is_in_timeline_mode = return_false
        self.controller.is_in_help_mode = return_false
        self.controller.is_in_user_info_mode = return_false
        self.controller.is_in_editor_mode = return_false

    def test_info_mode(self):
        self.controller.is_in_info_mode = Mock(return_value=True)

        # execute
        self.executes(self.key_handler.TURSES_COMMANDS)
        self.executes(self.key_handler.TIMELINE_COMMANDS)

        # don't execute
        self.does_not_execute(self.key_handler.MOTION_COMMANDS)
        self.does_not_execute(self.key_handler.BUFFER_COMMANDS)
        self.does_not_execute(self.key_handler.TWITTER_COMMANDS)
        self.does_not_execute(self.key_handler.EXTERNAL_PROGRAM_COMMANDS)

    def test_timeline_mode(self):
        self.controller.is_in_timeline_mode = Mock(return_value=True)

        self.executes(self.key_handler.TURSES_COMMANDS)
        self.executes(self.key_handler.MOTION_COMMANDS)
        self.executes(self.key_handler.BUFFER_COMMANDS)
        self.executes(self.key_handler.TIMELINE_COMMANDS)
        self.executes(self.key_handler.TWITTER_COMMANDS)
        self.executes(self.key_handler.EXTERNAL_PROGRAM_COMMANDS)

    def test_help_mode(self):
        self.controller.is_in_help_mode = Mock(return_value=True)

        # execute
        self.executes(self.key_handler.TURSES_COMMANDS)
        self.executes(self.key_handler.MOTION_COMMANDS)

        # don't execute
        self.does_not_execute(self.key_handler.TIMELINE_COMMANDS)
        self.does_not_execute(self.key_handler.BUFFER_COMMANDS)
        self.does_not_execute(self.key_handler.TWITTER_COMMANDS)
        self.does_not_execute(self.key_handler.EXTERNAL_PROGRAM_COMMANDS)

    def test_editor_mode(self):
        self.controller.is_in_editor_mode = Mock(return_value=True)

        self.does_not_execute(self.key_handler.TURSES_COMMANDS)
        self.does_not_execute(self.key_handler.MOTION_COMMANDS)
        self.does_not_execute(self.key_handler.TIMELINE_COMMANDS)
        self.does_not_execute(self.key_handler.BUFFER_COMMANDS)
        self.does_not_execute(self.key_handler.TWITTER_COMMANDS)
        self.does_not_execute(self.key_handler.EXTERNAL_PROGRAM_COMMANDS)

        for key in "ABCDEFGHIJKLMNÑOPQRSTUVWXYZabcdefghijklmnñopqrstuvwxyz":
            self.key_handler.handle(key)
            self.controller.forward_to_editor.assert_called_with(key)


class ControllerTest(unittest.TestCase):
    def setUp(self):
        self.timelines = TimelineList()
        self.controller = Controller(ui=Mock(),
                                api=MockApi('foo', 'bar'),
                                timelines=self.timelines)

    def test_append_home_timeline(self):
        self.controller.append_home_timeline()

        appended_timeline = self.timelines[-1]
        self.assertTrue(is_home_timeline(appended_timeline))

    def test_append_user_timeline(self):
        user = 'dialelo'
        self.controller.append_user_timeline(user)

        appended_timeline = self.timelines[-1]
        self.assertTrue(is_user_timeline(appended_timeline))
        self.assertEqual(appended_timeline._kwargs, {'screen_name': user})

    def test_own_tweets_timeline(self):
        self.controller.append_own_tweets_timeline()

        appended_timeline = self.timelines[-1]
        self.assertTrue(is_own_timeline(appended_timeline))

    def test_mentions_timeline(self):
        self.controller.append_mentions_timeline()

        appended_timeline = self.timelines[-1]
        self.assertTrue(is_mentions_timeline(appended_timeline))

    def test_direct_messages_timeline(self):
        self.controller.append_direct_messages_timeline()

        appended_timeline = self.timelines[-1]
        self.assertTrue(is_messages_timeline(appended_timeline))

    def test_thread_timeline(self):
        active_timeline = self.controller.timelines.active
        active_timeline.add_status(create_status())
        # make sure that there is at least one status in the active timeline
        self.assertTrue(active_timeline.active)

        self.controller.append_thread_timeline()

        appended_timeline = self.timelines[-1]
        self.assertTrue(is_thread_timeline(appended_timeline))

    # TODO: test `append_search_timeline`
    # TODO: test `append_retweets_of_me_timeline`


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_meta
# -*- coding: utf-8 -*-

from sys import path
path.append('../')
import unittest

from mock import Mock

from turses.meta import ActiveList, Observable, notify


class ActiveListTest(unittest.TestCase):
    """
    A helper class for testing subclasses of the `turses.meta.ActiveList`
    abstract class.
    """
    def assert_null_index(self):
        """Assert that the `active_index` in `self.timeline` is
        `turses.meta.ActiveList.NULL_INDEX`"""
        self.assertEqual(self.active_index(),
                         ActiveList.NULL_INDEX)

    def active_index(self):
        raise NotImplementedError


class ObservableTest(unittest.TestCase):
    def setUp(self):
        self.observable = Observable()
        self.observer = Mock()
        self.observable.subscribe(self.observer)

    def test_notify_method_calls_update_on_observers(self):
        self.observable.notify()

        self.observer.update.assert_called_once()

    def test_methods_with_notify_decorator(self):
        # decorate `method`
        method = notify(lambda self: None)

        # pass `self.observable` as the first arguments to emulate a instance
        # method
        method(self.observable)

        self.observer.update.assert_called_once()

    def test_unsubscribe(self):
        self.observable.unsubscribe(self.observer)

        self.observable.notify()

        self.assertFalse(self.observer.update.called)



if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_models
# -*- coding: utf-8 -*-

from sys import path
path.append('../')
import unittest
from datetime import datetime

from mock import MagicMock

from tests import create_status, create_direct_message
from tests.test_meta import ActiveListTest

from turses.utils import prepend_at
from turses.models import is_DM, Timeline, TimelineList


class StatusTest(unittest.TestCase):
    def test_is_DM(self):
        # status is NOT a DM
        status = create_status()
        self.failIf(is_DM(status))

        dm = create_direct_message()
        self.failUnless(is_DM(dm))

    # properties

    def test_mentioned_usernames(self):
        user = 'turses'
        mentioned = ('dialelo', 'mental_floss', '4n_4Wfu1_US3RN4M3')

        expected_output = list(mentioned)

        text = "@%s, @%s and @%s" % mentioned
        status = create_status(user=user,
                               text=text)

        expected = set(expected_output)
        mentioned_usernames = status.mentioned_usernames
        self.assertEqual(expected, set(mentioned_usernames))

    def test_mentioned_for_reply(self):
        user = 'turses'
        mentioned = ('dialelo', 'mental_floss', '4n_4Wfu1_US3RN4M3')

        expected_output = list(mentioned)
        expected_output.append(user)
        expected_output = map(prepend_at, expected_output)

        text = "@%s, @%s and @%s" % mentioned
        status = create_status(user=user,
                               text=text)

        expected = set(filter(prepend_at, expected_output))
        mentioned_for_reply = status.mentioned_for_reply
        self.assertEqual(expected, set(mentioned_for_reply))

    def test_authors_username_tweet(self):
        user = 'turses'
        status = create_status(user=user)

        author = status.authors_username

        self.assertEqual(user, author)

    def test_authors_username_retweet(self):
        user = 'turses'
        status = create_status(user=user)
        retweeter = 'bot'
        retweet = create_status(user=retweeter,
                                is_retweet=True,
                                retweeted_status=status,
                                author=user)

        author = retweet.authors_username

        self.assertEqual(user, author)

    def test_authors_username_dm(self):
        user = 'turses'
        dm = create_direct_message(sender_screen_name=user,)

        author = dm.authors_username

        self.assertEqual(user, author)

    def test_dm_recipients_username_tweet(self):
        # authenticating user
        user = 'turses'

        # given a status in which the author is the authenticated author
        # must return `None`
        status = create_status(user=user)
        recipient_own_tweet = status.dm_recipients_username(user)
        self.failIf(recipient_own_tweet)

    def test_dm_recipients_username_dm(self):
        # authenticating user
        user = 'turses'

        # @user -> @another_user messages should return 'another_user'
        expected_recipient = 'dialelo'
        dm = create_direct_message(sender_screen_name=user,
                                   recipient_screen_name=expected_recipient,)
        recipient_dm_user_is_sender = dm.dm_recipients_username(user)
        self.assertEqual(recipient_dm_user_is_sender, expected_recipient)

        # @another_user -> @user messages should return 'another_user'
        dm = create_direct_message(sender_screen_name=expected_recipient,
                                   recipient_screen_name=user,)
        recipient_dm_user_is_recipient = dm.dm_recipients_username(user)
        self.assertEqual(recipient_dm_user_is_recipient, expected_recipient)

    def test_hashtags(self):
        user = 'turses'
        hashtags = ('#turses', '#arch_linux', '#I<3Python')

        expected_output = list(hashtags)

        text = "%s %s %s" % hashtags
        status = create_status(user=user,
                               text=text)

        expected = set(expected_output)
        mentioned_hashtags = status.hashtags
        self.assertEqual(expected, set(mentioned_hashtags))


class TimelineTest(ActiveListTest):

    def setUp(self):
        self.timeline = Timeline()
        self.assert_null_index()

    def active_index(self):
        return self.timeline.active_index

    # unique elements

    def test_unique_statuses_in_timeline(self):
        status = create_status()

        self.timeline.add_status(status)
        self.timeline.add_status(status)

        self.assertEqual(len(self.timeline), 1)

    # active index

    def test_active_index_is_0_when_creating_timeline_with_statuses(self):
        status = create_status()

        self.timeline = Timeline(statuses=[status])

        self.assertEqual(self.timeline.active_index, 0)

    def test_active_index_becomes_0_when_adding_first_status(self):
        status = create_status()

        self.timeline.add_status(status)

        self.assertEqual(self.timeline.active_index, 0)

    def test_active_index_does_not_change_when_adding_various_statuses(self):
        a_status = create_status(id=1)
        another_status = create_status(id=2)

        # first
        self.timeline.add_status(a_status)
        self.assertEqual(self.timeline.active_index, 0)

        # second
        self.timeline.add_status(another_status)
        self.assertEqual(self.timeline.active_index, 0)

    # insertion

    def test_insert_different_statuses_individually(self):
        old_status = create_status(created_at=datetime(1988, 12, 19))
        new_status = create_status(id=2)

        # first
        self.timeline.add_status(old_status)
        self.assertEqual(len(self.timeline), 1)

        # second
        self.timeline.add_status(new_status)
        self.assertEqual(len(self.timeline), 2)

    def test_insert_different_statuses(self):
        old_status = create_status(created_at=datetime(1988, 12, 19))
        new_status = create_status(id=2)

        self.timeline.add_statuses([old_status, new_status])

        self.assertEqual(len(self.timeline), 2)

    # order

    def test_statuses_ordered_reversely_by_date(self):
        old_status = create_status(created_at=datetime(1988, 12, 19))
        new_status = create_status(id=2)

        # ordered
        self.timeline = Timeline(statuses=[new_status, old_status])
        self.assertEqual(self.timeline[0], new_status)
        self.assertEqual(self.timeline[1], old_status)

        # unordered
        self.timeline = Timeline(statuses=[old_status, new_status])
        self.assertEqual(self.timeline[0], new_status)
        self.assertEqual(self.timeline[1], old_status)

    # unread

    def test_unread_count(self):
        self.assertEqual(self.timeline.unread_count, 0)

        # a status
        status = create_status(id=1)
        self.timeline.add_status(status)
        self.assertEqual(self.timeline.unread_count, 1)

        self.timeline.mark_all_as_read()
        self.assertEqual(self.timeline.unread_count, 0)

        # new statuses
        statuses = [create_status(id=id_num) for id_num in xrange(2, 10)]
        self.timeline.add_statuses(statuses)
        self.assertEqual(self.timeline.unread_count, len(statuses))

        self.timeline.mark_all_as_read()
        self.assertEqual(self.timeline.unread_count, 0)

    # clear

    def test_clear(self):
        old_created_at = datetime(1988, 12, 19)
        old_status = create_status(created_at=old_created_at)
        new_created_at = datetime.now()
        new_status = create_status(id=2,
                                   created_at=new_created_at)

        self.timeline.add_statuses([old_status, new_status])

        self.timeline.clear()

        self.assertEqual(len(self.timeline), 0)

    # update function related

    def test_extract_with_no_args(self):
        mock = MagicMock(name='update')

        timeline = Timeline(update_function=mock,)

        self.assertEqual(timeline._args, [])
        self.assertEqual(timeline._kwargs, {})

    def test_only_args(self):
        mock = MagicMock(name='update')
        args = 'python', 42

        timeline = Timeline(update_function=mock,
                            update_function_args=args,)

        self.assertEqual(timeline._args, list(args))
        self.assertEqual(timeline._kwargs, {})

    def test_with_only_kwargs(self):
        mock = MagicMock(name='update')
        kwargs = {'python': 'rocks'}

        timeline = Timeline(update_function=mock,
                            update_function_kwargs=kwargs)

        self.assertEqual(timeline._args, [])
        self.assertEqual(timeline._kwargs, kwargs)

    def test_with_both_args_and_kwargs(self):
        mock = MagicMock(name='update')
        args = 'python', 42
        kwargs = {'python': 'rocks'}

        timeline = Timeline(update_function=mock,
                            update_function_args=args,
                            update_function_kwargs=kwargs)

        self.assertEqual(timeline._args, list(args))
        self.assertEqual(timeline._kwargs, kwargs)

    # update invocation

    def test_update_with_no_args(self):
        mock = MagicMock(name='update')
        timeline = Timeline(update_function=mock,)

        timeline.update()

        mock.assert_called_once_with()

    def test_update_with_one_arg(self):
        mock = MagicMock(name='update')
        arg = '#python'
        timeline = Timeline(update_function=mock,
                            update_function_args=arg)

        timeline.update()

        mock.assert_called_once_with(arg)

    def test_update_with_multiple_args(self):
        mock = MagicMock(name='update')
        args = '#python', '#mock'
        timeline = Timeline(update_function=mock,
                            update_function_args=args)
        timeline.update()

        args = list(args)
        mock.assert_called_once_with(*args)

    def test_update_with_kwargs(self):
        mock = MagicMock(name='update')
        kwargs = {'text': '#python', 'action': 'search'}
        timeline = Timeline(update_function=mock,
                            update_function_kwargs=kwargs)
        timeline.update()

        mock.assert_called_once_with(**kwargs)

    def test_update_with_args_and_kwargs(self):
        mock = MagicMock(name='update')
        args = 'twitter', 42
        kwargs = {'text': '#python', 'action': 'search'}
        update_args = list(args)
        update_args.append(kwargs)

        timeline = Timeline(update_function=mock,
                            update_function_args=args,
                            update_function_kwargs=kwargs)
        timeline.update()

        args = list(args)
        mock.assert_called_once_with(*args, **kwargs)

    def test_update_with_no_args_extra_kwargs(self):
        mock = MagicMock(name='update')
        extra_kwargs = {'python': 'rocks'}

        timeline = Timeline(update_function=mock,)
        timeline.update(**extra_kwargs)

        mock.assert_called_once_with(**extra_kwargs)

    def test_update_with_one_arg_extra_kwargs(self):
        mock = MagicMock(name='update')
        arg = '#python'
        extra_kwargs = {'python': 'rocks'}

        timeline = Timeline(update_function=mock, update_function_args=arg)
        timeline.update(**extra_kwargs)

        mock.assert_called_once_with(arg, **extra_kwargs)

    def test_update_with_multiple_args_extra_kwargs(self):
        mock = MagicMock(name='update')
        args = ('#python', '#mock')
        extra_kwargs = {'python': 'rocks'}

        timeline = Timeline(update_function=mock,
                            update_function_args=args)
        timeline.update(**extra_kwargs)

        args = list(args)
        mock.assert_called_once_with(*args, **extra_kwargs)

    def test_update_with_kwargs_extra_kwargs(self):
        mock = MagicMock(name='update')
        kwargs = {'text': '#python', 'action': 'search'}
        extra_kwargs = {'text': 'rocks'}

        timeline = Timeline(update_function=mock,
                            update_function_kwargs=kwargs)
        timeline.update(**extra_kwargs)

        args = kwargs.copy()
        args.update(extra_kwargs)
        mock.assert_called_once_with(**args)

    def test_update_with_args_and_kwargs_extra_kwargs(self):
        mock = MagicMock(name='update')
        args = 'twitter', 42
        kwargs = {'text': '#python', 'action': 'search'}
        extra_kwargs = {'text': 'rocks'}

        timeline = Timeline(update_function=mock,
                            update_function_args=args,
                            update_function_kwargs=kwargs)
        timeline.update(**extra_kwargs)

        args = list(args)
        kwargs = kwargs.copy()
        kwargs.update(extra_kwargs)
        mock.assert_called_once_with(*args, **kwargs)


class TimelineListTest(ActiveListTest):

    def active_index(self):
        return self.timeline_list.active_index

    # - Helpers ---------------------------------------------------------------

    def append_timeline(self):
        self.timeline_list.append_timeline(Timeline('Timeline'))

    def assert_visible(self, visible_list):
        self.assertEqual(self.timeline_list.visible, visible_list)

    # - Tests -----------------------------------------------------------------

    def setUp(self):
        self.timeline_list = TimelineList()

    def test_has_timelines_false_if_empty(self):
        self.failIf(self.timeline_list.has_timelines())

    def test_has_timelines_true_otherwise(self):
        self.append_timeline()
        self.failUnless(self.timeline_list.has_timelines())

    def test_null_index_with_no_timelines(self):
        self.assert_null_index()

    def test_active_index_0_when_appending_first_timeline(self):
        self.append_timeline()
        self.assertEqual(self.timeline_list.active_index, 0)

    def test_activate_previous(self):
        # null index when there are no timelines
        self.timeline_list.activate_previous()
        self.assert_null_index()
        # does not change if its the first
        self.append_timeline()
        self.assertEqual(self.timeline_list.active_index, 0)
        self.timeline_list.activate_previous()
        self.assertEqual(self.timeline_list.active_index, 0)

    def test_activate_next(self):
        # null index when there are no timelines
        self.timeline_list.activate_next()
        self.assert_null_index()
        # does not change if its the last
        self.append_timeline()
        self.assertEqual(self.timeline_list.active_index, 0)
        self.timeline_list.activate_next()
        self.assertEqual(self.timeline_list.active_index, 0)

    def test_activate_previous_and_activate_next(self):
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        # next
        self.timeline_list.activate_next()
        self.assertEqual(self.timeline_list.active_index, 1)
        self.timeline_list.activate_next()
        self.assertEqual(self.timeline_list.active_index, 2)
        # previous
        self.timeline_list.activate_previous()
        self.assertEqual(self.timeline_list.active_index, 1)
        self.timeline_list.activate_previous()
        self.assertEqual(self.timeline_list.active_index, 0)

    def test_active_returns_first_appended(self):
        # append
        name = 'Timeline'
        timeline = Timeline(name)
        self.timeline_list.append_timeline(timeline)
        # assert
        active_timeline = self.timeline_list.active
        self.assertEqual(timeline, active_timeline)

    def test_active_returns_None_when_empty(self):
        self.assertEqual(self.timeline_list.active, None)

    def test_append_timeline_increases_timeline_size(self):
        self.assertEqual(len(self.timeline_list), 0)
        self.append_timeline()
        self.assertEqual(len(self.timeline_list), 1)
        self.append_timeline()
        self.assertEqual(len(self.timeline_list), 2)

    def test_activate_first(self):
        # null index when there are no timelines
        self.timeline_list.activate_first()
        self.assert_null_index()
        # does not change if its the first
        self.append_timeline()
        self.assertEqual(self.timeline_list.active_index, 0)
        self.timeline_list.activate_first()
        self.assertEqual(self.timeline_list.active_index, 0)
        # moves to the first when in another position
        self.append_timeline()
        self.append_timeline()
        self.timeline_list.activate_next()
        self.timeline_list.activate_next()
        self.timeline_list.activate_first()
        self.assertEqual(self.timeline_list.active_index, 0)

    def test_activate_last(self):
        # null index when there are no timelines
        self.timeline_list.activate_last()
        self.assert_null_index()
        # does not change if its the last
        self.append_timeline()
        self.assertEqual(self.timeline_list.active_index, 0)
        self.timeline_list.activate_last()
        self.assertEqual(self.timeline_list.active_index, 0)
        # moves to the last when in another position
        self.append_timeline()
        self.append_timeline()
        self.timeline_list.activate_last()
        self.assertEqual(self.timeline_list.active_index, 2)

    def test_shift_active_previous(self):
        # null index when there are no timelines
        self.timeline_list.shift_active_previous()
        self.assert_null_index()
        # does not change if its the first
        self.append_timeline()
        self.timeline_list.shift_active_previous()
        self.assertEqual(self.timeline_list.active_index, 0)

    def test_shift_active_next(self):
        # null index when there are no timelines
        self.timeline_list.shift_active_next()
        self.assert_null_index()
        # does not change if its the last
        self.append_timeline()
        self.timeline_list.shift_active_next()
        self.assertEqual(self.timeline_list.active_index, 0)
        # it increases until reaching the end
        self.append_timeline()
        self.timeline_list.shift_active_next()
        self.assertEqual(self.timeline_list.active_index, 1)
        self.append_timeline()
        self.timeline_list.shift_active_next()
        self.assertEqual(self.timeline_list.active_index, 2)
        self.timeline_list.shift_active_next()
        self.assertEqual(self.timeline_list.active_index, 2)

    # visibility

    def test_no_visible_when_newly_created(self):
        self.assert_visible([])
        self.timeline_list.expand_visible_previous()

    def test_only_visible_is_index_0_when_appending_first_timeline(self):
        self.append_timeline()
        self.assert_visible([0])

    def test_expand_visible_previous(self):
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        self.assert_visible([0])
        self.timeline_list.activate_last()
        self.assert_visible([2])

        self.timeline_list.expand_visible_previous()
        self.assert_visible([1, 2])
        self.timeline_list.expand_visible_previous()
        self.assert_visible([0, 1, 2])

        # there are no more timelines
        self.timeline_list.expand_visible_previous()
        self.assert_visible([0, 1, 2])

    def test_expand_visible_next(self):
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        self.assert_visible([0])

        self.timeline_list.expand_visible_next()
        self.assert_visible([0, 1])
        self.timeline_list.expand_visible_next()
        self.assert_visible([0, 1, 2])

        # there are no more timelines
        self.timeline_list.expand_visible_next()
        self.assert_visible([0, 1, 2])

    def test_shrink_visible_beggining(self):
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        self.timeline_list.activate_last()
        self.timeline_list.expand_visible_previous()
        self.timeline_list.expand_visible_previous()
        self.assert_visible([0, 1, 2])

        self.timeline_list.shrink_visible_beggining()
        self.assert_visible([1, 2])
        self.timeline_list.shrink_visible_beggining()
        self.assert_visible([2])

        # at least the active timeline has to be visible
        self.timeline_list.shrink_visible_beggining()
        self.assert_visible([2])

    def test_shrink_visible_end(self):
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        self.timeline_list.expand_visible_next()
        self.timeline_list.expand_visible_next()
        self.assert_visible([0, 1, 2])

        self.timeline_list.shrink_visible_end()
        self.assert_visible([0, 1])
        self.timeline_list.shrink_visible_end()
        self.assert_visible([0])

        # at least the active timeline has to be visible
        self.timeline_list.shrink_visible_end()
        self.assert_visible([0])

    def test_visible_active_only_when_activating_invisible_timeline(self):
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        self.timeline_list.expand_visible_next()
        self.assert_visible([0, 1])

        self.timeline_list.activate_last()
        self.assert_visible([2])

        self.timeline_list.expand_visible_previous()
        self.assert_visible([1, 2])

        self.timeline_list.activate_first()
        self.assert_visible([0])

    def test_consistent_visible_timelines_when_deleting_leftmost_active(self):
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        self.timeline_list.expand_visible_next()
        self.timeline_list.expand_visible_next()

        self.assertEqual(self.active_index(), 0)
        self.assert_visible([0, 1, 2])

        self.timeline_list.delete_active_timeline()

        # active index does not change
        self.assertEqual(self.active_index(), 0)

        # visible
        self.assert_visible([0, 1])

        # relative index
        relative_index = self.timeline_list.active_index_relative_to_visible
        self.assertEqual(relative_index, 0)

    def test_consistent_visible_timelines_when_deleting_middle_active(self):
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        self.timeline_list.expand_visible_next()
        self.timeline_list.expand_visible_next()
        self.timeline_list.expand_visible_next()
        self.timeline_list.expand_visible_next()
        self.timeline_list.expand_visible_next()

        self.assertEqual(self.active_index(), 0)
        self.assert_visible([0, 1, 2, 3, 4])

        self.timeline_list.activate_next()
        self.timeline_list.activate_next()

        self.assertEqual(self.active_index(), 2)
        self.assert_visible([0, 1, 2, 3, 4])

        self.timeline_list.delete_active_timeline()

        # active index does not change
        self.assertEqual(self.active_index(), 2)

        # visible
        self.assert_visible([0, 1, 2, 3])

        # relative index
        relative_index = self.timeline_list.active_index_relative_to_visible
        self.assertEqual(relative_index, 2)

    def test_consistent_visible_timelines_when_deleting_rightmost_timeline(self):
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        self.assertEqual(len(self.timeline_list), 3)

        self.timeline_list.expand_visible_next()
        self.timeline_list.expand_visible_next()

        self.assertEqual(self.active_index(), 0)
        self.assert_visible([0, 1, 2])

        self.timeline_list.activate_next()
        self.timeline_list.activate_next()

        self.assertEqual(self.active_index(), 2)
        self.assert_visible([0, 1, 2])

        self.timeline_list.delete_active_timeline()
        self.assertEqual(len(self.timeline_list), 2)

        # active index shifts left
        self.assertEqual(self.active_index(), 1)

        # visible
        self.assert_visible([0, 1])

        # relative index
        relative_index = self.timeline_list.active_index_relative_to_visible
        self.assertEqual(relative_index, 1)

    def test_delete_active_timeline_with_one_visible_timeline_in_the_left(self):
        self.append_timeline()
        self.append_timeline()

        self.assertEqual(self.active_index(), 0)
        self.assert_visible([0])

        self.timeline_list.delete_active_timeline()

        self.assertEqual(self.active_index(), 0)
        self.assert_visible([0])

    def test_delete_active_timeline_with_one_visible_timeline_in_the_middle(self):
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()

        self.assertEqual(self.active_index(), 0)
        self.assert_visible([0])
        self.assertEqual(len(self.timeline_list), 5)

        self.timeline_list.activate_next()
        self.timeline_list.activate_next()
        
        self.assertEqual(self.active_index(), 2)
        self.assert_visible([2])

        self.timeline_list.delete_active_timeline()
        self.assertEqual(len(self.timeline_list), 4)

        self.assertEqual(self.active_index(), 2)
        self.assert_visible([2])

    def test_delete_active_timeline_with_one_visible_timeline_in_the_right(self):
        self.append_timeline()
        self.append_timeline()
        self.append_timeline()
        self.assertEqual(len(self.timeline_list), 3)

        self.timeline_list.activate_next()
        self.timeline_list.activate_next()

        self.assertEqual(self.active_index(), 2)
        self.assert_visible([2])

        self.timeline_list.delete_active_timeline()
        self.assertEqual(len(self.timeline_list), 2)

        self.assertEqual(self.active_index(), 1)
        self.assert_visible([1])


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_session
# -*- coding: utf-8 -*-

from sys import path
path.append('../')
import unittest

from . import create_status, create_direct_message

from turses.api.debug import MockApi
from turses.models import Timeline, TimelineList
from turses.session import (
    Session,

    clean_timeline_list_string,
)
from turses.api.helpers import (
    is_home_timeline,
    is_mentions_timeline,
    is_favorites_timeline,
    is_messages_timeline,
    is_own_timeline,
    is_search_timeline,
    is_user_timeline,
    is_retweets_of_me_timeline,
    is_thread_timeline,
)


mock_api = MockApi('foo', 'bar')



class SessionTest(unittest.TestCase):
    def setUp(self):
        self.session = Session(mock_api)

    def test_clean_timeline_list_string(self):
        self.assertEqual(clean_timeline_list_string(''), [])

        self.assertEqual(clean_timeline_list_string('  '), [])

        self.assertEqual(clean_timeline_list_string('home'), ['home'])

        self.assertEqual(clean_timeline_list_string('  home, '), ['home'])

        self.assertEqual(clean_timeline_list_string('home, mentions'),
                         ['home', 'mentions'])

        self.assertEqual(clean_timeline_list_string('  home,mentions '),
                         ['home', 'mentions'])

        self.assertEqual(clean_timeline_list_string('mentions, favorites, messages, own_tweets'),
                         ['mentions', 'favorites', 'messages', 'own_tweets'])

    def test_custom_session(self):
        """
        Test that, when defining a custom session, the timelines are created
        correctly.
        """
        timeline_list = TimelineList()

        visible_string = 'home, mentions, search:turses'
        self.session.append_visible_timelines(visible_string, timeline_list)

        # check that the visible timelines are appended correctly
        self.assertTrue(len(timeline_list), 3)

        self.assertTrue(is_home_timeline(timeline_list[0]))
        self.assertTrue(is_mentions_timeline(timeline_list[1]))
        self.assertTrue(is_search_timeline(timeline_list[2]))

        self.assertEqual(timeline_list.visible_timelines,
                         [timeline_list[0], timeline_list[1], timeline_list[2]])

        # now let's append the buffers in the background
        buffers_string = 'messages'
        self.session.append_background_timelines(buffers_string, timeline_list)

        self.assertTrue(len(timeline_list), 4)

        self.assertTrue(is_messages_timeline(timeline_list[3]))

########NEW FILE########
__FILENAME__ = test_ui
# -*- coding: utf-8 -*-

from sys import path
path.append('../')
import unittest

from turses.ui import StatusWidget, map_attributes, parse_attributes
from tests  import create_status, create_direct_message


class AttributeTest(unittest.TestCase):
    def test_map_attributes_with_mentions_hashtags_and_url(self):
        text = (u'@aaloy  QT @Pybonacci: \xa1Qu\xe9 pasada con Vim!'
                u' #Python #IDE RT @dialelo uso un setup parecido a este: '
                u'http://t.co/5lTGNzba')
        entities = {
            u'user_mentions': [
                {u'id': 60840400,
                 u'indices': [0, 6],
                 u'id_str': u'60840400',
                 u'screen_name': u'aaloy',
                 u'name': u'Antoni Aloy'},
                {u'id': 552951614,
                 u'indices': [11, 21],
                 u'id_str': u'552951614',
                 u'screen_name': u'Pybonacci',
                 u'name': u'Pybonacci'},
                {u'id': 87322884,
                 u'indices': [60, 68],
                 u'id_str': u'87322884',
                 u'screen_name': u'dialelo',
                 u'name': u'Alejandro G\xf3mez'}
            ],
            u'hashtags': [
                {u'indices': [44, 51],
                 u'text': u'Python'},
                {u'indices': [52, 56],
                 u'text': u'IDE'}
            ],
            u'urls': [
                {u'url': u'http://t.co/5lTGNzba',
                 u'indices': [99, 119],
                 u'expanded_url':
                    u'http://sontek.net/turning-vim-into-a-modern-python-ide',
                 u'display_url': u'sontek.net/turning-vim-in\u2026'}
            ]}
        expected_result = [('attag', u'@aaloy'), u'  QT ',
                           ('attag', u'@Pybonacci'),
                           u': \xa1Qu\xe9 pasada con Vim! ',
                           ('hashtag', u'#Python'), u' ', ('hashtag', u'#IDE'),
                           u' RT ', ('attag', u'@dialelo'),
                           u' uso un setup parecido a este: ',
                           ('url', u'sontek.net/turning-vim-in\u2026')]

        status = create_status(text=text,
                               entities=entities)
        result = map_attributes(status,
                                hashtag='hashtag',
                                attag='attag',
                                url='url')

        self.assertEqual(result, expected_result)

        text = (u'New release of #Turses 0.1.6 with lots of improvements, '
                u'ncurses twitter client. https://t.co/cciH85AG via @dialelo')
        entities = {
            u'hashtags': [{u'indices': [15, 22], u'text': u'Turses'}],
            u'urls': [{u'display_url': u'github.com/alejandrogomez\u2026',
                       u'expanded_url':
                            u'https://github.com/alejandrogomez/turses',
                       u'indices': [80, 101],
                       u'url': u'https://t.co/cciH85AG'}],
            u'user_mentions': [{u'id': 87322884,
                                u'id_str': u'87322884',
                                u'indices': [106, 114],
                                u'name': u'Alejandro G\xf3mez',
                                u'screen_name': u'dialelo'}]
        }
        expected_result = [u'New release of ',
                           ('hashtag', u'#Turses'),
                           (u' 0.1.6 with lots of improvements, '
                           u'ncurses twitter client. '),
                           ('url', u'github.com/alejandrogomez\u2026'),
                           u' via ',
                           ('attag', u'@dialelo')]

        status = create_status(user='nicosphere',
                               text=text,
                               entities=entities)
        result = map_attributes(status,
                                hashtag='hashtag',
                                attag='attag',
                                url='url')

        self.assertEqual(result, expected_result)

    def test_map_attributes_to_retweet_with_hashtag(self):
        original_author = 'dialelo'
        original_text = 'I <3 #Python'
        original_status = create_status(user=original_author,
                                        text=original_text)

        text = 'RT @%s: %s' % (original_author, original_text)
        entities = {
            u'user_mentions': [],
            u'hashtags': [
                {u'indices': [5, 11],
                 u'text': u'Python'},
            ],
            u'urls': [],
            }
        retweet = create_status(text=text,
                                entities=entities,
                                is_retweet=True,
                                retweeted_status=original_status)

        # retweet text gets parsed because sometimes is not complete
        expected_result = [u'I ', u'<3 ', ('hashtag', '#Python')]
        result = map_attributes(retweet,
                                hashtag='hashtag',
                                attag='attag',
                                url='url')

        self.assertEqual(result, expected_result)

    def test_map_attributes_mention(self):
        text = '@pypi is down!'

        entities = {
            u'user_mentions': [
                {u'id': 60840400,
                 u'indices': [0, 5],
                 u'id_str': u'60840400',
                 u'screen_name': u'pypi',
                 u'name': u'PYthon Package Index'},
            ],
            u'hashtags': [],
            u'urls': [],
            }
        tweet = create_status(text=text,
                              entities=entities,)

        expected_result = [('attag', u'@pypi'), u' is down!']
        result = map_attributes(tweet,
                                hashtag='hashtag',
                                attag='attag',
                                url='url')

        self.assertEqual(result, expected_result)
    
    def test_parse_attributes(self):
        text = '@asdf http://www.dialelo.com #asf'

        expected_result = [('attag', u'@asdf'), u' ',
                           ('url', u'http://www.dialelo.com'), u' ',
                           ('hashtag', u'#asf')]

        result = parse_attributes(text=text,
                                  hashtag='hashtag',
                                  attag='attag',
                                  url='url')
        self.assertEqual(result, expected_result)


class StatusWidgetTest(unittest.TestCase):
    def test_create_with_status(self):
        # load the defaults
        status = create_status()
        StatusWidget(status)

    def test_create_with_direct_message(self):
        # load the defaults
        direct_message = create_direct_message()
        StatusWidget(direct_message)




if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils
# -*- coding: utf-8 -*-

from sys import path
path.append('../')
import unittest

from turses.utils import is_username, is_hashtag, sanitize_username


class UtilsTest(unittest.TestCase):
    """Tests for the functions contained in `turses.utils`."""
    def test_is_username(self):
        valid = ['dialelo', 'mental_floss', '4n_4Wfu1_US3RN4M3']
        for user in valid:
            self.failUnless(is_username(user))

        invalid = ['-asd', 'adsd?']

        for user in invalid:
            self.failIf(is_username(user))

    def test_is_hashtag(self):
        valid = ['#turses', '#cúrcuma', '#4n_4Wfu1_H45hT46']
        for hashtag in valid:
            self.failUnless(is_hashtag(hashtag))

        invalid = ['s#turses', '#']
        for hashtag in invalid:
            self.failIf(is_hashtag(hashtag))

    def test_sanitize_username(self):
        dirty_and_clean = [
            ('@dialelo',           'dialelo'),
            ('dialelo',            'dialelo'),
            ('?@mental_floss',     'mental_floss'),
            ('@4n_4Wfu1_US3RN4M3', '4n_4Wfu1_US3RN4M3'),
        ]
        for dirty, clean in dirty_and_clean:
            sanitized = sanitize_username(dirty)
            self.assertEqual(sanitized, clean)

    def test_is_valid_status_text(self):
        pass

    def test_is_valid_search_text(self):
        pass




if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = backends
# -*- coding: utf-8 -*-

"""
This module contains implementations of :class:`turses.api.base.ApiAdapter`
using libraries for accessing the Twitter API.
"""

from functools import wraps, partial

from tweepy import API as BaseTweepyApi
from tweepy import OAuthHandler as TweepyOAuthHandler

from turses.config import configuration
from turses.meta import filter_result
from turses.models import User, Status, DirectMessage, List
from turses.api.base import ApiAdapter


def include_entities(func):
    """
    Injects the `include_entities=True` keyword argument into `func`.
    """
    @wraps(func)
    def wrapper(*args, **kwargs):
        kwargs['include_entities'] = True
        return func(*args, **kwargs)
    return wrapper

# Decorators for converting data to `turses.models`


def _to_status(status, **kwargs):
    """
    Convert a `tweepy.Status` to a `turses.models.Status`.
    """
    defaults = {
        'id': status.id,
        'created_at': status.created_at,
        'user': None,
        'text': status.text,
        'is_reply': False,
        'is_retweet': False,
        'is_favorite': False,
        'in_reply_to_user': '',
        'in_reply_to_status_id': None,
        'retweeted_status': None,
        'retweet_count': 0,
        'author': '',
        'entities': getattr(status, 'entities', None),
    }

    # When fetching an individual user her last status is included and
    # does not include a `user` attribute
    if getattr(status, 'user', None):
        defaults['user'] = status.user.screen_name

    if hasattr(status, 'retweeted_status'):
        defaults['is_retweet'] = True
        defaults['retweeted_status'] = _to_status(status.retweeted_status)
        defaults['retweet_count'] = status.retweet_count

        # the `retweeted_status` could not have a `user` attribute
        # (e.g. when fetching a user and her last status is a retweet)
        if hasattr(status.retweeted_status, 'user'):
            defaults['author'] = status.retweeted_status.user.screen_name

    if getattr(status, 'in_reply_to_screen_name', False):
        defaults['is_reply'] = True
        defaults['in_reply_to_user'] = status.in_reply_to_screen_name

    if getattr(status, 'in_reply_to_status_id', False):
        defaults['in_reply_to_status_id'] = status.in_reply_to_status_id

    if hasattr(status, 'favorited'):
        defaults['is_favorite'] = status.favorited

    defaults.update(**kwargs)
    return Status(**defaults)


def _to_direct_message(dm, **kwargs):
    """
    Convert a `tweepy.DirectMessage` to a `turses.models.DirectMessage`.
    """
    defaults = {
        'id': dm.id,
        'created_at': dm.created_at,
        'sender_screen_name': dm.sender_screen_name,
        'recipient_screen_name': dm.recipient_screen_name,
        'text': dm.text,
        'entities': getattr(dm, 'entities', None),
    }

    defaults.update(**kwargs)
    return DirectMessage(**defaults)


def _to_user(user, **kwargs):
    """
    Convert a `tweepy.User` to a `turses.models.User`.
    """

    defaults = {
        'id': user.id,
        'name': user.name,
        'screen_name': user.screen_name,
        'description': user.description,
        'url': user.url,
        'created_at': user.created_at,
        'friends_count': user.friends_count,
        'followers_count': user.followers_count,
        'favorites_count': user.favourites_count,
    }

    if hasattr(user, 'status'):
        status = _to_status(user.status, user=user.screen_name)
        defaults['status'] = status

    defaults.update(**kwargs)
    return User(**defaults)


def _to_list(a_list, **kwargs):
    """
    Convert a `tweepy.List` to a `turses.models.List`.
    """
    defaults = {
        'id': a_list.id,
        'owner': _to_user(a_list.user),
        # TODO: `created_at` should be a datetime object
        'created_at': a_list.created_at,
        'name': a_list.name,
        'slug': a_list.slug,
        'description': a_list.description,
        'member_count': a_list.member_count,
        'subscriber_count': a_list.subscriber_count,
        'private': a_list.mode == u'private',
    }

    defaults.update(**kwargs)
    return List(**defaults)

to_status = partial(filter_result,
                    filter_func=_to_status)
to_direct_message = partial(filter_result,
                            filter_func=_to_direct_message)
to_user = partial(filter_result,
                  filter_func=_to_user)
to_list = partial(filter_result,
                  filter_func=_to_list)


class TweepyApi(BaseTweepyApi, ApiAdapter):
    """
    A :class:`turses.api.ApiAdapter` implementation using `tweepy` library.

        http://github.com/tweepy/tweepy/
    """

    def __init__(self, *args, **kwargs):
        ApiAdapter.__init__(self, *args, **kwargs)

    # from `turses.api.base.ApiAdapter`

    def init_api(self):
        oauth_handler = TweepyOAuthHandler(self._consumer_key,
                                           self._consumer_secret,
                                           secure=configuration.twitter['use_https'])
        oauth_handler.set_access_token(self._access_token_key,
                                       self._access_token_secret)
        self._api = BaseTweepyApi(oauth_handler, secure=configuration.twitter['use_https'])

    @to_user
    def verify_credentials(self):
        return self._api.me()

    @to_user
    @include_entities
    def get_user(self, screen_name, **kwargs):
        return self._api.get_user(screen_name=screen_name, **kwargs)

    # timelines

    @to_status
    @include_entities
    def get_status(self, status_id, **kwargs):
        return self._api.get_status(status_id, **kwargs)

    @to_status
    @include_entities
    def get_home_timeline(self, **kwargs):
        tweets = self._api.home_timeline(**kwargs)
        return tweets

    @to_status
    @include_entities
    def get_user_timeline(self, screen_name, **kwargs):
        return self._api.user_timeline(screen_name, **kwargs)

    @to_status
    @include_entities
    def get_own_timeline(self, **kwargs):
        me = self.verify_credentials()
        return self._api.user_timeline(screen_name=me.screen_name, **kwargs)

    @to_status
    @include_entities
    def get_mentions(self, **kwargs):
        return self._api.mentions_timeline(**kwargs)

    @to_status
    @include_entities
    def get_favorites(self, **kwargs):
        return self._api.favorites(**kwargs)

    @to_direct_message
    @include_entities
    def get_direct_messages(self, **kwargs):
        dms = self._api.direct_messages(**kwargs)
        sent = self._api.sent_direct_messages(**kwargs)
        dms.extend(sent)
        return dms

    @include_entities
    def get_thread(self, status, **kwargs):
        """
        Get the conversation to which `status` belongs.
        """
        users_in_conversation = [status.authors_username]

        # Save the users that are mentioned
        for user in status.mentioned_usernames:
            if user not in users_in_conversation:
                users_in_conversation.append(user)

        # Fetch the tweets from participants before and after `status`
        # was published
        tweets_from_participants = []
        for user in users_in_conversation:
            user_tweets = self._get_older_and_newer_tweets(user, status.id)
            tweets_from_participants.extend(user_tweets)

        def belongs_to_conversation(tweet):
            for user in users_in_conversation:
                if user in tweet.text:
                    return True

        return filter(belongs_to_conversation, tweets_from_participants)

    def _get_older_and_newer_tweets(self, screen_name, tweet_id, count=20):
        """
        Get tweets from the user with `screen_name` username that are older
        and newer than `tweet_id`.

        By default, 20 tweets are fetched. If provided, `count` controls how
        many tweets are requested.
        """
        older = self.get_user_timeline(screen_name,
                                       max_id=tweet_id,
                                       count=count/2)
        newer = self.get_user_timeline(screen_name,
                                       since_id=tweet_id,
                                       count=count/2)
        return older + newer

    def get_message_thread(self, dm, **kwargs):
        messages = self.get_direct_messages(**kwargs)

        me = self.verify_credentials()
        if dm.sender_screen_name == me.screen_name:
            with_user = dm.recipient_screen_name
        else:
            with_user = dm.sender_screen_name

        def belongs_to_conversation(message):
            return (message.sender_screen_name == with_user or
                    message.recipient_screen_name == with_user)

        return filter(belongs_to_conversation, messages)

    @to_status
    @include_entities
    def search(self, text, **kwargs):
        return self._api.search(text, **kwargs)

    @to_status
    @include_entities
    def get_retweets_of_me(self, **kwargs):
        return self._api.retweets_of_me(**kwargs)

    def update(self, text):
        self._api.update_status(text)

    def reply(self, status, text):
        self._api.update_status(text, in_reply_to_status_id=status.id)

    def destroy_status(self, status):
        self._api.destroy_status(status.id)

    def retweet(self, status):
        self._api.retweet(status.id)

    def direct_message(self, username, text):
        self._api.send_direct_message(user=username, text=text)

    def destroy_direct_message(self, dm):
        self._api.destroy_direct_message(dm.id)

    def create_friendship(self, screen_name):
        self._api.create_friendship(screen_name=screen_name)

    def destroy_friendship(self, screen_name):
        self._api.destroy_friendship(screen_name=screen_name)

    def create_favorite(self, status):
        self._api.create_favorite(status.id)

    def destroy_favorite(self, status):
        self._api.destroy_favorite(status.id)

    # list methods

    @to_list
    def get_lists(self, screen_name):
        return self._api.lists_all(screen_name)

    @to_list
    def get_own_lists(self):
        return self._api.lists_all()

    @to_list
    def get_list_memberships(self):
        return self._api.lists_memberships()

    @to_list
    def get_list_subscriptions(self):
        return self._api.lists_subscriptions()

    @to_status
    def get_list_timeline(self, a_list):
        owner = a_list.owner.screen_name
        return self._api.list_timeline(owner=owner, slug=a_list.slug)

    @to_user
    def get_list_members(self, a_list):
        owner = a_list.owner.screen_name
        return self._api.list_members(owner=owner, slug=a_list.slug)

    @to_list
    def subscribe_to_list(self, a_list):
        owner = a_list.owner
        return self._api.subscribe_list(owner=owner.screen_name,
                                        slug=a_list.slug)

    @to_user
    def get_list_subscribers(self, a_list):
        owner = a_list.owner
        return self._api.list_subscribers(owner=owner.screen_name,
                                          slug=a_list.slug,)

########NEW FILE########
__FILENAME__ = base
# -*- coding: utf-8 -*-

"""
This module contains an `ApiAdapter` abstract class that acts as an adapter
for different Twitter API implementations.

It also contains `AsyncApi`, an asynchronous wrapper to `ApiAdapter` and a
function to authorize `turses` to use a Twitter account obtaining the OAuth
tokens.
"""

from ssl import SSLError
from abc import ABCMeta, abstractmethod
import oauth2 as oauth
from urlparse import parse_qsl, urljoin
from gettext import gettext as _

from turses.models import is_DM
from turses.utils import encode
from turses.meta import async, wrap_exceptions


TWITTER_CONSUMER_KEY = 'OEn4hrNGknVz9ozQytoR0A'
TWITTER_CONSUMER_SECRET = 'viud49uVgdVO9dnOGxSQJRo7jphTioIlEn3OdpkZI'

BASE_URL = 'https://api.twitter.com'

HTTP_OK = 200


def get_authorization_tokens():
    """
    Authorize `turses` to use a Twitter account.

    Return a dictionary with `oauth_token` and `oauth_token_secret` keys
    if succesfull, `None` otherwise.
    """
    # This function was borrowed from python-twitter developers and experienced
    # an important refactoring
    #
    # Copyright 2007 The Python-Twitter Developers
    #
    # Licensed under the Apache License, Version 2.0 (the "License");
    # you may not use this file except in compliance with the License.
    # You may obtain a copy of the License at
    #
    #     http://www.apache.org/licenses/LICENSE-2.0
    #
    # Unless required by applicable law or agreed to in writing, software
    # distributed under the License is distributed on an "AS IS" BASIS,
    # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    # See the License for the specific language governing permissions and
    # limitations under the License.
    oauth_consumer = oauth.Consumer(key=TWITTER_CONSUMER_KEY,
                                    secret=TWITTER_CONSUMER_SECRET)
    oauth_client = oauth.Client(oauth_consumer)

    print _('Requesting temporary token from Twitter')

    try:
        oauth_token, oauth_token_secret = get_temporary_tokens(oauth_client)
    except SSLError:
        print _("""There was an SSL certificate error, your user may not have
                   permission to access SSL. Try executing `turses` as a
                   privileged user.""")
        return None
    except Exception as e:
        print e
        return None


    authorization_url = urljoin(BASE_URL, '/oauth/authorize')
    authorization_url_with_token = urljoin(authorization_url,
                                           '?oauth_token=%s' % oauth_token)
    print
    print  _('Please visit the following page to retrieve the pin code needed '
             'to obtain an Authorization Token:')
    print
    print authorization_url_with_token
    print

    pin_code = raw_input(_('Pin code? '))

    print
    print encode(_('Generating and signing request for an access token'))
    print

    # Generate an OAuth token that verifies the identity of the user
    token = oauth.Token(oauth_token, oauth_token_secret)
    token.set_verifier(pin_code)

    # Re-create the OAuth client with the corresponding token
    oauth_client = oauth.Client(oauth_consumer, token)

    try:
        access_tokens = get_access_tokens(oauth_client, pin_code)
        return access_tokens
    except Exception as e:
        print e
        return None

def get_temporary_tokens(oauth_client):
    """
    Request temporary OAuth tokens using the provided `oauth_client`; these
    tokens require the user to confirm its identity on Twitter's website for
    obtaining an access token.

    This function will return a tuple with a public and a private OAuth tokens
    that can be used to retrieve an access token from Twitter if the request
    was successfull.

    If there is an error with the HTTP request, it will raise an
    :class:`Exception` with a meaningful error message.
    """
    request_token_url = urljoin(BASE_URL, '/oauth/request_token')

    response, content = oauth_client.request(request_token_url, 'GET')


    status_code = int(response['status'])
    if status_code == HTTP_OK:
        response_content = dict(parse_qsl(content))

        oauth_token = response_content['oauth_token']
        oauth_token_secret = response_content['oauth_token_secret']

        return (oauth_token, oauth_token_secret)
    else:
        error_message = _('Twitter responded with an HTTP %s code.' % str(status_code))
        raise Exception(error_message)

def get_access_tokens(oauth_client, pin_code):
    """
    Request access tokens using the provided `oauth_client` and the
    `pin_code`that verifies the user's identity.

    This function will return a dictionary with `oauth_token` and
    `oauth_token_secret` keys if the request was successful.

    If there is an error with the HTTP request, it will raise an
    :class:`Exception` with a meaningful error message.
    """
    access_token_url = urljoin(BASE_URL, '/oauth/access_token')

    response, content = oauth_client.request(access_token_url,
                                             method='POST',
                                             body='oauth_verifier=%s' % pin_code)

    status_code = int(response['status'])

    if status_code == HTTP_OK:
        access_token = dict(parse_qsl(content))
        return access_token
    else:
        error_message = _('Twitter responded with an HTTP %s code.' % str(status_code))
        raise Exception(error_message)



class ApiAdapter(object):
    """
    A simplified version of the API to use as an adapter for a real
    implementation.
    """
    __metaclass__ = ABCMeta

    def __init__(self,
                 access_token_key,
                 access_token_secret,
                 consumer_key=TWITTER_CONSUMER_KEY,
                 consumer_secret=TWITTER_CONSUMER_SECRET,):
        self._consumer_key = consumer_key
        self._consumer_secret = consumer_secret
        self._access_token_key = access_token_key
        self._access_token_secret = access_token_secret
        self.is_authenticated = False

    @abstractmethod
    def init_api(self):
        pass

    @abstractmethod
    def verify_credentials(self):
        """
        Return a `turses.models.User` with the authenticating user if the given
        credentials are valid.
        """
        pass

    # users

    @abstractmethod
    def get_user(self, screen_name):
        pass

    # timelines

    @abstractmethod
    def get_status(self, status_id):
        pass

    @abstractmethod
    def get_home_timeline(self):
        pass

    @abstractmethod
    def get_user_timeline(self, screen_name):
        pass

    @abstractmethod
    def get_own_timeline(self):
        pass

    @abstractmethod
    def get_mentions(self):
        pass

    @abstractmethod
    def get_favorites(self):
        pass

    @abstractmethod
    def get_direct_messages(self):
        pass

    @abstractmethod
    def get_thread(self, status):
        pass

    @abstractmethod
    def get_message_thread(self, dm):
        pass

    @abstractmethod
    def search(self, text):
        pass

    @abstractmethod
    def get_retweets_of_me(self):
        pass

    # statuses

    @abstractmethod
    def update(self, text):
        pass

    @abstractmethod
    def reply(self, status, text):
        pass

    @abstractmethod
    def retweet(self, status):
        pass

    @abstractmethod
    def destroy_status(self, status):
        """
        Destroy the given `status` (must belong to authenticating user).
        """
        pass

    @abstractmethod
    def direct_message(self, screen_name, text):
        pass

    @abstractmethod
    def destroy_direct_message(self, dm):
        """
        Destroy the given `dm` (must be written by the authenticating user).
        """
        pass

    # friendship

    @abstractmethod
    def create_friendship(self, screen_name):
        pass

    @abstractmethod
    def destroy_friendship(self, screen_name):
        pass

    # favorite methods

    @abstractmethod
    def create_favorite(self, status):
        pass

    @abstractmethod
    def destroy_favorite(self, status):
        pass

    # list methods

    @abstractmethod
    def get_lists(self, screen_name):
        pass

    @abstractmethod
    def get_own_lists(self):
        pass

    @abstractmethod
    def get_list_memberships(self):
        pass

    @abstractmethod
    def get_list_subscriptions(self):
        pass

    @abstractmethod
    def get_list_timeline(self, list):
        pass

    @abstractmethod
    def get_list_members(self, list):
        pass

    @abstractmethod
    def subscribe_to_list(self, list):
        pass

    @abstractmethod
    def get_list_subscribers(self, list):
        pass


class AsyncApi(ApiAdapter):
    """
    Wrap an `ApiAdapter` subclass and execute the methods for creating,
    updating and deleting Twitter entities in background. Those methods
    are decorated with `turses.utils.wrap_exceptions`.
    """

    def __init__(self, api_cls, *args, **kwargs):
        """
        Args:
            api_cls -- the class used to instantiate the Twitter API,
                       it must implement the methods in `ApiAdapter`.
        """
        ApiAdapter.__init__(self, *args, **kwargs)
        self._api = api_cls(access_token_key=self._access_token_key,
                            access_token_secret=self._access_token_secret,)

    @wrap_exceptions
    def init_api(self):
        self._api.init_api()
        self.is_authenticated = True
        self.user = self.verify_credentials()

    def verify_credentials(self):
        return self._api.verify_credentials()

    def get_status(self, **kwargs):
        return self._api.get_status(**kwargs)

    def get_home_timeline(self, **kwargs):
        return self._api.get_home_timeline(**kwargs)

    def get_user_timeline(self, screen_name, **kwargs):
        return self._api.get_user_timeline(screen_name=screen_name, **kwargs)

    def get_own_timeline(self, **kwargs):
        return self._api.get_own_timeline(**kwargs)

    def get_mentions(self, **kwargs):
        return self._api.get_mentions()

    def get_favorites(self, **kwargs):
        return self._api.get_favorites()

    def get_direct_messages(self, **kwargs):
        return self._api.get_direct_messages(**kwargs)

    def get_thread(self, status, **kwargs):
        return self._api.get_thread(status, **kwargs)

    def get_message_thread(self, dm, **kwargs):
        return self._api.get_message_thread(dm, **kwargs)

    def search(self, text, **kwargs):
        return self._api.search(text, **kwargs)

    def get_retweets_of_me(self, **kwargs):
        return self._api.get_retweets_of_me(**kwargs)

    def get_user(self, screen_name):
        return self._api.get_user(screen_name)

    @async
    @wrap_exceptions
    def update(self, text):
        self._api.update(text)

    @async
    @wrap_exceptions
    def reply(self, status, text):
        self._api.reply(status, text)


    @async
    @wrap_exceptions
    def retweet(self, status):
        self._api.retweet(status)

    @async
    @wrap_exceptions
    def destroy_status(self, status):
        self._api.destroy_status(status)

    @async
    @wrap_exceptions
    def destroy_direct_message(self, status):
        self._api.destroy_direct_message(status)

    @async
    @wrap_exceptions
    def direct_message(self, screen_name, text):
        self._api.direct_message(screen_name, text)

    @async
    @wrap_exceptions
    def create_friendship(self, screen_name):
        self._api.create_friendship(screen_name)

    @async
    @wrap_exceptions
    def destroy_friendship(self, screen_name):
        self._api.destroy_friendship(screen_name)

    @async
    @wrap_exceptions
    def create_favorite(self, status):
        if is_DM(status) or status.is_favorite:
            raise Exception
        self._api.create_favorite(status)

    @async
    @wrap_exceptions
    def destroy_favorite(self, status):
        self._api.destroy_favorite(status)

    def get_list(self, screen_name, slug):
        pass

    def get_lists(self, screen_name):
        pass

    def get_own_lists(self):
        pass

    def get_list_memberships(self):
        pass

    def get_list_subscriptions(self):
        pass

    def get_list_timeline(self, list):
        pass

    def get_list_members(self, list):
        pass

    def subscribe_to_list(self, list):
        pass

    def get_list_subscribers(self, list):
        pass

########NEW FILE########
__FILENAME__ = debug
# -*- coding: utf-8 -*-

"""
Contains `MockApi`, a fake `turses.api.ApiAdapter` implementation for debugging
purposes.
"""

import random
from time import sleep
from datetime import datetime

from turses.models import User, Status
from turses.meta import wrap_exceptions
from turses.api.base import ApiAdapter


def random_status(quantity=1, **kwargs):
    """Return `quantity` random statuses.

    By default it returns a single `turses.models.Status` instance, but
    if `q` is greater than 1 it returns a list of random statuses."""
    def create_status():
        sleep(0.02)
        now = datetime.now()
        defaults = {
            'id': random.randint(0, 999),
            'created_at': now,
            'user': 'testbot',
            'text': 'Status created at %s' % now,
        }
        defaults.update(**kwargs)

        return Status(**defaults)

    if not quantity:
        return

    if quantity == 1:
        return create_status()

    return [create_status() for _ in range(0, quantity)]


def random_user(quantity=1, **kwargs):
    """Return `quantity` random users.

    By default it returns a single `turses.models.user` instance, but
    if `q` is greater than 1 it returns a list of random users."""
    def create_user():
        sleep(0.02)
        now = datetime.now()
        defaults = {
            'id': random.randint(0, 999),
            'name': 'Alejandro',
            'screen_name': 'dialelo',
            'description': None,
            'url': 'http://dialelo.com',
            'created_at': now,
            'friends_count': 3,
            'followers_count': 42,
            'favorites_count': 0,
            'status': random_status(),
        }
        defaults.update(**kwargs)

        return User(**defaults)

    if not quantity:
        return

    if quantity == 1:
        return create_user()

    return [create_user() for _ in range(0, quantity)]


class MockApi(ApiAdapter):
    """
    """
    def __init__(self, *args, **kwargs):
        ApiAdapter.__init__(self, *args, **kwargs)

    @wrap_exceptions
    def init_api(self):
        self.is_authenticated = True

    def verify_credentials(self):
        return random_user()

    # users

    def get_user(self, screen_name):
        return random_user(screen_name=screen_name)

    # timelines

    def get_status(self, status_id):
        return random_status(id=status_id)

    def get_home_timeline(self):
        return random_status(quantity=3)

    def get_user_timeline(self, screen_name):
        return random_status(quantity=10)

    def get_own_timeline(self):
        return random_status(quantity=10)

    def get_mentions(self):
        return random_status(quantity=10)

    def get_favorites(self):
        return random_status(quantity=10)

    def get_direct_messages(self):
        # TODO: random DM
        return random_status(quantity=10)

    def get_thread(self, status):
        return random_status(quantity=14)

    def get_message_thread(self, status):
        return random_status(quantity=4)

    def search(self, text):
        return random_status(quantity=14)

    def get_retweets_of_me(self):
        return random_status(quantity=14)

    # statuses

    def update(self, text):
        pass

    def reply(self, status, text):
        pass

    def retweet(self, status):
        pass

    def destroy_status(self, status):
        """
        Destroy the given `status` (must belong to authenticating user).
        """
        pass

    def direct_message(self, screen_name, text):
        pass

    def destroy_direct_message(self, dm):
        """
        Destroy the given `dm` (must be written by the authenticating user).
        """
        pass

    # friendship

    def create_friendship(self, screen_name):
        pass

    def destroy_friendship(self, screen_name):
        pass

    # favorite methods

    def create_favorite(self, status):
        pass

    def destroy_favorite(self, status):
        pass

    # list methods

    def get_lists(self, screen_name):
        pass

    def get_own_lists(self):
        pass

    def get_list_memberships(self):
        pass

    def get_list_subscriptions(self):
        pass

    def get_list_timeline(self, list):
        pass

    def get_list_members(self, list):
        pass


    def subscribe_to_list(self, list):
        pass

    def get_list_subscribers(self, list):
        pass


########NEW FILE########
__FILENAME__ = helpers
"""
This module contains various methods for checking the type of timelines and a
class that creates all kinds of timelines.
"""

import re
from functools import partial
from gettext import gettext as _

from turses.models import Timeline, is_DM


HOME_TIMELINE = 'home'
MENTIONS_TIMELINE = 'mentions'
FAVORITES_TIMELINE = 'favorites'
MESSAGES_TIMELINE = 'messages'
OWN_TWEETS_TIMELINE = 'own_tweets'

DEFAULT_TIMELINES = [
    HOME_TIMELINE,
    MENTIONS_TIMELINE,
    FAVORITES_TIMELINE,
    MESSAGES_TIMELINE,
    OWN_TWEETS_TIMELINE,
]


def check_update_function_name(timeline, update_function_name=None):
    if not isinstance(timeline, Timeline):
        return False

    update_function = timeline.update_function
    if update_function is None:
        return False

    return update_function.__name__ == update_function_name

is_home_timeline = partial(check_update_function_name,
                           update_function_name='get_home_timeline')
is_mentions_timeline = partial(check_update_function_name,
                               update_function_name='get_mentions')
is_favorites_timeline = partial(check_update_function_name,
                                update_function_name='get_favorites')
is_own_timeline = partial(check_update_function_name,
                          update_function_name='get_own_timeline')
is_messages_timeline = partial(check_update_function_name,
                               update_function_name='get_direct_messages')
is_search_timeline = partial(check_update_function_name,
                             update_function_name='search')
is_user_timeline = partial(check_update_function_name,
                           update_function_name='get_user_timeline')
is_retweets_of_me_timeline = partial(check_update_function_name,
                                     update_function_name='get_retweets_of_me')
is_thread_timeline = partial(check_update_function_name,
                             update_function_name='get_thread')


search_name_re = re.compile(r'^search:(?P<query>.+)$')
hashtag_name_re = re.compile(r'^hashtag:(?P<query>.+)$')
user_name_re = re.compile(r'^user:(?P<screen_name>[A-Za-z0-9_]+)$')


class TimelineFactory:
    def __init__(self, api):
        self.api = api

    def __call__(self, timeline_string):
        timeline = timeline_string.strip()

        if timeline == HOME_TIMELINE:
            return Timeline(name=_('tweets'),
                            update_function=self.api.get_home_timeline,)
        elif timeline == MENTIONS_TIMELINE:
            return Timeline(name=_('mentions'),
                            update_function=self.api.get_mentions,)
        elif timeline == FAVORITES_TIMELINE:
            return Timeline(name=_('favorites'),
                            update_function=self.api.get_favorites,)
        elif timeline == MESSAGES_TIMELINE:
            return Timeline(name=_('messages'),
                            update_function=self.api.get_direct_messages,)
        elif timeline == OWN_TWEETS_TIMELINE:
            return Timeline(name=_('me'),
                            update_function=self.api.get_own_timeline,)
        elif timeline == 'retweets_of_me':
            return Timeline(name=_('retweets of me'),
                            update_function=self.api.get_retweets_of_me,)

        is_search = search_name_re.match(timeline)
        if is_search:
            query = is_search.groupdict()['query']
            return Timeline(name=_('Search: %s' % query),
                            update_function=self.api.search,
                            update_function_args=query,)

        is_hashtag = hashtag_name_re.match(timeline)
        if is_hashtag:
            query = "#{}".format(is_hashtag.groupdict()['query'])
            return Timeline(name=_('hashtag: %s' % query),
                            update_function=self.api.search,
                            update_function_args=query,)

        is_user = user_name_re.match(timeline)
        if is_user:
            screen_name = is_user.groupdict()['screen_name']
            timeline_name = _('@{screen_name}'.format(screen_name=screen_name))
            return Timeline(name=timeline_name,
                            update_function=self.api.get_user_timeline,
                            update_function_args=screen_name,)

    def valid_timeline_name(self, name):
        if name in DEFAULT_TIMELINES:
            return True

        if name == 'retweets_of_me':
            return True

        # search
        if search_name_re.match(name):
            return True

        # user
        if user_name_re.match(name):
            return True

        return False

    def thread(self, status):
        """
        Create a timeline with the conversation to which `status` belongs.
        `status` can be a regular status or a direct message.
        """
        if is_DM(status):
            participants = [status.sender_screen_name,
                            status.recipient_screen_name]
            name = _('DM thread: %s' % ', '.join(participants))
            update_function = self.api.get_message_thread
        else:
            participants = status.mentioned_usernames
            author = status.authors_username
            if author not in participants:
                participants.insert(0, author)

            name = _('thread: %s' % ', '.join(participants))
            update_function = self.api.get_thread

        return Timeline(name=name,
                        update_function=update_function,
                        update_function_args=status,)

########NEW FILE########
__FILENAME__ = cli
# -*- coding: utf-8 -*-

"""
Handle the invocation of ``turses`` from the command line.
"""

import logging
from sys import stdout
from argparse import ArgumentParser
from os import getenv
from gettext import gettext as _

from urwid import set_encoding

from turses import __name__
from turses import version as turses_version
from turses.config import configuration, LOG_FILE
from turses.models import TimelineList
from turses.ui import CursesInterface
from turses.api.base import AsyncApi
from turses.api.debug import MockApi
from turses.api.backends import TweepyApi
from turses.core import Controller as Turses


def save_stdout():
    """Save shell screen."""
    stdout.write("\033[?1049h\033[H")


def restore_stdout():
    """Restore saved shell screen."""
    stdout.write("\033[?1049l")


def set_title(string):
    """Set window title."""
    try:
        if getenv('TERM').startswith("screen"):
            # terminal multiplexors
            if getenv('TMUX'):
                stdout.write("\033k%s\033\\" % string)  # for tmux
            else:
                stdout.write("\033_%s\033\\" % string)  # for GNU screen
        else:
            # terminal
            stdout.write("\x1b]2;%s\x07" % string)
    except:
        pass


def restore_title():
    """Restore original window title."""
    if getenv('TMUX'):
        set_title(getenv('SHELL').split('/')[-1])


def create_async_api(api_backend_cls):
    """
    Create an asynchronous API given a concrete API class ``api_backend_cls``.
    """
    oauth_token = configuration.oauth_token
    oauth_token_secret = configuration.oauth_token_secret

    return AsyncApi(api_backend_cls,
                    access_token_key=oauth_token,
                    access_token_secret=oauth_token_secret,)


def read_arguments():
    """Read arguments from the command line."""

    parser_title = "turses: Twitter client featuring a sexy curses interface."
    parser = ArgumentParser(parser_title)

    # load account
    parser.add_argument("-a",
                        "--account",
                        help=_("Use account with the specified username."))

    # load non-default configuration
    parser.add_argument("-c",
                        "--config",
                        help=_("Use the specified configuration file."))

    # generate configuration
    generate_config_help = _("Generate a default configuration file is "
                             "the specified path.")
    parser.add_argument("-g",
                        "--generate-config",
                        help=generate_config_help)

    # load session
    parser.add_argument("-s",
                        "--session",
                        help=_("Load the specified session"))

    # version
    version = "turses %s" % turses_version
    parser.add_argument("-v",
                        "--version",
                        action="version",
                        version=version,
                        help=_("Show the current version of turses"))

    # debug mode
    parser.add_argument("-d",
                        "--debug",
                        action="store_true",
                        help=_("Start turses in debug mode."))

    # offline debug mode
    parser.add_argument("-o",
                        "--offline",
                        action="store_true",
                        help=_("Start turses in offline debug mode."))

    args = parser.parse_args()
    return args


def main():
    """
    Launch ``turses``.
    """
    set_title(__name__)
    set_encoding('utf8')

    args = read_arguments()

    # check if stdout has to be restored after program exit
    if any([args.debug,
            args.offline,
            getattr(args, 'help', False),
            getattr(args, 'version', False)]):
        # we are going to print information to stdout
        save_and_restore_stdout = False
    else:
        save_and_restore_stdout = True

    if save_and_restore_stdout:
        save_stdout()

    # parse arguments and load configuration
    configuration.parse_args(args)
    configuration.load()

    # start logger
    logging.basicConfig(filename=LOG_FILE,
                        level=configuration.logging_level)

    # create view
    curses_interface = CursesInterface()

    # create model
    timeline_list = TimelineList()

    # create API
    api = create_async_api(MockApi if args.offline else TweepyApi)

    # create controller
    turses = Turses(ui=curses_interface,
                    api=api,
                    timelines=timeline_list,)

    try:
        turses.start()
    except:
        # A unexpected exception occurred, open the debugger in debug mode
        if args.debug or args.offline:
            import pdb
            pdb.post_mortem()
    finally:
        if save_and_restore_stdout:
            restore_stdout()

        restore_title()

        exit(0)

########NEW FILE########
__FILENAME__ = config
# -*- coding: utf-8 -*-

"""
The configuration files are located on ``$HOME/.turses`` directory.

There is one mayor configuration file in turses:

    ``config``
        contains user preferences: colors, bindings, etc.

An one default token file:

    ``token``
        contains authentication token for the default user account

Each user account that is no the default one needs to be aliased and  has its
own token file ``alias.token``.

To create an aliased account:

.. code-block:: sh

    $ turses -a work

And, after authorizing ``turses`` to use that account,  a token file named
``work.token`` will be created. Optionally you can create a ``work.config``
file for a configuration specific to that account.

Now, when you execute again:

.. code-block:: sh

    $ turses -a work

you will be logged in with the previously stored credentials.

Here is an example with two accounts apart from the default one, aliased
to ``alice`` and ``bob``.

.. code-block:: sh

    ~
    |+.turses/
    | |-config
    | |-alice.config
    | |-token
    | |-alice.token
    | `-bob.token
    |+...
    |-...
    `


If you want to generate a configuration file, you can do so executing:

.. code-block:: sh

    $ turses -g /path/to/file
"""

from sys import exit
from ConfigParser import RawConfigParser
from os import getenv, path, mkdir, remove
from functools import partial
from gettext import gettext as _

from turses.utils import encode
from turses.meta import wrap_exceptions
from turses.api.base import get_authorization_tokens

# -- Defaults -----------------------------------------------------------------

# Key bindings

KEY_BINDINGS = {
    # motion
    'up':
         ('k', _('scroll up')),
    'down':
         ('j', _('scroll down')),
    'left':
        ('h', _('activate the timeline on the left')),
    'right':
        ('l', _('activate the timeline on the right')),
    'scroll_to_top':
        ('g', _('scroll to top')),
    'scroll_to_bottom':
        ('G', _('scroll to bottom')),

    # buffers
    'activate_first_buffer':
       ('a', _('activate first buffer')),
    'activate_last_buffer':
        ('e', _('activate last buffer')),
    'shift_buffer_beggining':
        ('ctrl a', _('shift active buffer to the beginning')),
    'shift_buffer_end':
        ('ctrl e', _('shift active buffer to the end')),
    'shift_buffer_left':
        ('<', _('shift active buffer one position to the left')),
    'shift_buffer_right':
        ('>', _('shift active buffer one position to the right')),
    'expand_visible_left':
        ('p', _('expand visible timelines one column to the left')),
    'expand_visible_right':
        ('n', _('expand visible timelines one column to the right')),
    'shrink_visible_left':
        ('P', _('shrink visible timelines one column from the left')),
    'shrink_visible_right':
        ('N', _('shrink visible timelines one column from the left')),
    'delete_buffer':
        ('d', _('delete buffer')),
    'mark_all_as_read':
        ('A', _('mark all tweets in the current timeline as read')),

    # tweets
    'tweet':
        ('t', _('compose a tweet')),
    'delete_tweet':
        ('X', _('delete focused status')),
    'reply':
        ('r', _('reply to focused status')),
    'retweet':
        ('R', _('retweet focused status')),
    'retweet_and_edit':
        ('E', _('open a editor for manually retweeting the focused status')),
    'retweet_and_fav':
        ('Y', _('mark focused tweet as favorite and retweet it')),
    'send_dm':
        ('D', _('compose a direct message')),
    'update':
        ('u', _('refresh the active timeline')),
    'update_all':
        ('S', _('refresh all the timelines')),
    'tweet_hashtag':
        ('H', _('compose a tweet with the same hashtags as the focused status')),
    'fav':
        ('b', _('mark focused tweet as favorite')),
    'delete_fav':
        ('ctrl b', _('remove tweet from favorites')),
    'follow_selected':
        ('f', _('follow selected status\' author')),
    'follow_user':
        ('F', _('follow user given in an editor')),
    'unfollow_selected':
        ('U', _('unfollow selected status\' author')),
    'unfollow_user':
        ('ctrl u', _('unfollow user given in an editor')),

    # timelines
    'home':
        ('.', _('open a home timeline')),
    'own_tweets':
        ('_', _('open a timeline with your tweets')),
    'favorites':
        ('B', _('open a timeline with your favorites')),
    'mentions':
        ('m', _('open a mentions timeline')),
    'DMs':
        ('M', _('open a direct message timeline')),
    'search':
        ('/', _('search for term and show resulting timeline')),
    'search_user':
        ('@', _('open a timeline with the tweets of the specified user')),
    'user_timeline':
        ('+', _('open a timeline with the tweets of the focused status\' author')),
    'thread':
        ('T', _('open the thread of the focused status')),
    'hashtags':
        ('L', _('open a search timeline with the hashtags of the focused status')),
    'retweets_of_me':
        ('I', _('open a timeline with your tweets that have been retweeted')),

    # info
    'user_info':
        ('i', _('show user\'s info')),

    # meta
    'help':
        ('?', _('show program help')),
    'reload_config':
        ('C', _('reload configuration')),

    # turses
    'quit':
        ('q', _('exit program')),
    'clear':
        ('c', _('clear status bar')),
    'openurl':
        ('o', _('open URLs of the focused status in a browser')),
    'open_status_url':
        ('O', _('open the focused status in a browser')),
    'redraw':
        ('ctrl l', _('redraw the screen')),
}

# NOTE:
# The key binding categories are declared to order them in the configuration
# and in the help buffer. If you add a key binding, don't forget to include
# it in one of these categories.

MOTION_KEY_BINDINGS = [
    'up',
    'down',
    'left',
    'right',
    'scroll_to_top',
    'scroll_to_bottom',
]

BUFFERS_KEY_BINDINGS = [
    'activate_first_buffer',
    'activate_last_buffer',
    'shift_buffer_beggining',
    'shift_buffer_end',
    'shift_buffer_left',
    'shift_buffer_right',
    'expand_visible_left',
    'expand_visible_right',
    'shrink_visible_left',
    'shrink_visible_right',
    'delete_buffer',
    'mark_all_as_read',
]

TWEETS_KEY_BINDINGS = [
    'tweet',
    'delete_tweet',
    'reply',
    'retweet',
    'retweet_and_edit',
    'retweet_and_fav',
    'send_dm',
    'update',
    'update_all',
    'tweet_hashtag',
    'fav',
    'delete_fav',
    'follow_selected',
    'follow_user',
    'unfollow_selected',
    'unfollow_user',
    'user_info',
]

TIMELINES_KEY_BINDINGS = [
    'home',
    'own_tweets',
    'favorites',
    'mentions',
    'DMs',
    'search',
    'search_user',
    'user_timeline',
    'thread',
    'hashtags',
    'retweets_of_me',
]

META_KEY_BINDINGS = [
    'help',
    'reload_config',
]

TURSES_KEY_BINDINGS = [
    'clear',
    'quit',
    'openurl',
    'open_status_url',
    'redraw',
]

# Palette

# TODO: not hard coded
# valid colors for `urwid`s palette
VALID_COLORS = [
    'default',
    'black',
    'dark red',
    'dark green',
    'brown',
    'dark blue',
    'dark magenta',
    'dark cyan',
    'light gray',
    'dark gray',
    'light red',
    'light green',
    'yellow',
    'light blue',
    'light magenta',
    'light cyan',
    'white',
]


def validate_color(colorstring):
    return colorstring if colorstring in VALID_COLORS else ''

PALETTE = [
    #Tabs
    ['active_tab',  'white', 'dark blue'],
    ['visible_tab', 'yellow', 'dark blue'],
    ['inactive_tab', 'dark blue', ''],

    # Statuses
    ['header', 'light blue', ''],
    ['body', 'white', ''],
    ['focus', 'light red', ''],
    ['line', 'black', ''],
    ['unread', 'dark red', ''],
    ['read', 'dark blue', ''],
    ['favorited', 'yellow', ''],

    # Text
    ['highlight', 'dark red', ''],
    ['highlight_nick', 'light red', ''],
    ['attag', 'yellow', ''],
    ['hashtag', 'light red', ''],
    ['url', 'white', 'dark red'],

    # Messages
    ['error', 'white', 'dark red'],
    ['info', 'white', 'dark blue'],

    # Editor
    ['editor', 'white', 'dark blue'],
]

# Styles

STYLES = {
    # TODO: make time string configurable
    'reply_indicator': '@',
    'retweet_indicator': 'RT',
    'header_template': ' {username}{retweeted}{retweeter} - {time}{reply}{retweet_count} ',
    'dm_template': ' {sender_screen_name} => {recipient_screen_name} - {time} ',
    'tab_template': '{timeline_name} [{unread}]',
    'box_around_status': True,
    'status_divider': False,
    'status_bar': True,
    'status_divider_char': '─',
    'editor_horizontal_align': 'center',
    'editor_vertical_align': 'bottom',
    'url_format': 'display',
    'statuses_in_user_info': 3,
}

# Debug

LOGGING_LEVEL = 3

# Twitter
UPDATE_FREQUENCY = 300
USE_HTTPS = True

TWITTER = {
  'update_frequency': UPDATE_FREQUENCY,
  'use_https': USE_HTTPS,
}

# Environment

HOME = getenv('HOME')

# -- Configuration ------------------------------------------------------------

DEFAULT_SESSION = 'defaults'

# Default config path
CONFIG_DIR = '.turses'
CONFIG_PATH = path.join(HOME, CONFIG_DIR)
DEFAULT_CONFIG_FILE = path.join(CONFIG_PATH, 'config')
DEFAULT_TOKEN_FILE = path.join(CONFIG_PATH, 'token')
LOG_FILE = path.join(CONFIG_PATH, 'log')

LEGACY_CONFIG_DIR = '.config/turses'
LEGACY_CONFIG_PATH = path.join(HOME, LEGACY_CONFIG_DIR)
LEGACY_CONFIG_FILE = path.join(LEGACY_CONFIG_PATH, 'turses.cfg')
LEGACY_TOKEN_FILE = path.join(LEGACY_CONFIG_PATH, 'turses.tok')

# Names of the sections in the configuration
SECTION_DEFAULT_TIMELINES = 'timelines'
SECTION_KEY_BINDINGS = 'bindings'
SECTION_PALETTE = 'colors'
SECTION_STYLES = 'styles'
SECTION_DEBUG = 'debug'
SECTION_TWITTER = 'twitter'

# Names of the sections in the token file
SECTION_TOKEN = 'token'


def print_deprecation_notice():
    print "NOTE:"
    print
    print "The configuration file in %s has been deprecated." % LEGACY_CONFIG_FILE
    print "A new configuration directory is being generated in %s." % CONFIG_PATH
    print


def invert_command_map(bindings):
    """
    Invert configuration keybindings to make reverse lookups faster
    """
    command_map = {}
    for command, (key, _) in bindings.iteritems():
        command_map[key] = command
    return command_map


class Configuration(object):
    """
    Generate and parse configuration files. When instantiated, it loads the
    defaults.

    Calling :func:`Configuration.parse_args` with an
    :class:`argparse.ArgumentParser` instance will modify the instance to match
    the options provided by the command line arguments.

    Calling :func:`turses.config.Configuration.load` on this class' instances
    reads the preferences from the user configuration files. If no
    configuration or token files are found, this class will take care of
    creating them.

    Offers backwards compatibility with the Tyrs configuration.
    """

    def __init__(self):
        """
        Create a `Configuration` taking into account the arguments
        from the command line interface (if any).
        """
        # load defaults
        self.twitter = TWITTER
        self.key_bindings = KEY_BINDINGS
        self.key_mappings = invert_command_map(self.key_bindings)
        self.palette = PALETTE
        self.styles = STYLES
        self.logging_level = LOGGING_LEVEL
        self.session = DEFAULT_SESSION

        # config and token files
        self.config_file = DEFAULT_CONFIG_FILE
        self.token_file = DEFAULT_TOKEN_FILE

        # debug mode
        self.debug = False

        # create the config directory if it does not exist
        if not path.isdir(CONFIG_PATH):
            try:
                mkdir(CONFIG_PATH)
            except:
                print encode(_('Error creating config directory in %s' % CONFIG_DIR))
                self.exit_with_code(3)

    def parse_args(self, cli_args):
        """Interprets the arguments provided by `cli_args`."""
        if cli_args is None:
            return

        if cli_args.generate_config:
            self.generate_config_file(config_file=cli_args.generate_config,)
            self.exit_with_code(0)

        # path to configuration file
        if cli_args.config:
            self.config_file = cli_args.config
        elif cli_args.account:
            self.config_file = path.join(CONFIG_PATH, '%s.config' % cli_args.account)

        # path to token file
        if cli_args.account:
            self.token_file = path.join(CONFIG_PATH, '%s.token' % cli_args.account)

        # session
        if cli_args.session:
            self.session = cli_args.session

        # debug mode
        self.debug = getattr(cli_args, 'debug', False)

    def load(self):
        """
        Loads configuration from files.
        """
        self._init_config()
        self._init_token()

    def _init_config(self):
        if path.isfile(LEGACY_CONFIG_FILE):
            self._parse_legacy_config_file()
            print_deprecation_notice()
            remove(LEGACY_CONFIG_FILE)
        elif path.isfile(self.config_file):
            self.parse_config_file(self.config_file)
        else:
            self.generate_config_file(self.config_file)
        self.key_mappings = invert_command_map(self.key_bindings)

    def _add_section_twitter(self, conf):
        # Twitter
        if not conf.has_section(SECTION_TWITTER):
            conf.add_section(SECTION_TWITTER)
        if not conf.has_option(SECTION_TWITTER, 'update_frequency'):
            conf.set(SECTION_TWITTER, 'update_frequency', UPDATE_FREQUENCY)
        if not conf.has_option(SECTION_TWITTER, 'use_https'):
            conf.set(SECTION_TWITTER, 'use_https', USE_HTTPS)

    def _add_section_key_bindings(self, conf):
        # Key bindings
        if not conf.has_section(SECTION_KEY_BINDINGS):
            conf.add_section(SECTION_KEY_BINDINGS)
        binding_lists = [MOTION_KEY_BINDINGS,
                         BUFFERS_KEY_BINDINGS,
                         TWEETS_KEY_BINDINGS,
                         TIMELINES_KEY_BINDINGS,
                         META_KEY_BINDINGS,
                         TURSES_KEY_BINDINGS, ]
        for binding_list in binding_lists:
            for binding in binding_list:
                key = self.key_bindings[binding][0]
                if conf.has_option(SECTION_KEY_BINDINGS, binding):
                    continue
                conf.set(SECTION_KEY_BINDINGS, binding, key)

    def _add_section_palette(self, conf):
        # Color
        if not conf.has_section(SECTION_PALETTE):
            conf.add_section(SECTION_PALETTE)
        for label in PALETTE:
            label_name, fg, bg = label[0], label[1], label[2]

            # fg
            if conf.has_option(SECTION_PALETTE, label_name) and \
                validate_color(conf.get(SECTION_PALETTE, label_name)):
                pass
            else:
                conf.set(SECTION_PALETTE, label_name, fg)

            #bg
            label_name_bg = label_name + '_bg'
            if conf.has_option(SECTION_PALETTE, label_name_bg) and \
                validate_color(conf.get(SECTION_PALETTE, label_name_bg)):
                pass
            else:
                conf.set(SECTION_PALETTE, label_name_bg, bg)

    def _add_section_styles(self, conf):
        # Styles
        if not conf.has_section(SECTION_STYLES):
            conf.add_section(SECTION_STYLES)
        for style in STYLES:
            if conf.has_option(SECTION_STYLES, style):
                continue
            conf.set(SECTION_STYLES, style, self.styles[style])

    def _add_section_debug(self, conf):
        # Debug
        if not conf.has_section(SECTION_DEBUG):
            conf.add_section(SECTION_DEBUG)
        if conf.has_option(SECTION_DEBUG, 'logging_level'):
            return
        conf.set(SECTION_DEBUG, 'logging_level', LOGGING_LEVEL)

    def _init_token(self):
        if path.isfile(LEGACY_TOKEN_FILE):
            self.parse_token_file(LEGACY_TOKEN_FILE)
            remove(LEGACY_TOKEN_FILE)
            if (hasattr(self, 'oauth_token') and
                hasattr(self, 'oauth_token_secret')):
                self.generate_token_file(self.token_file,
                                         self.oauth_token,
                                         self.oauth_token_secret)
        elif not path.isfile(self.token_file):
            self.authorize_new_account()
        else:
            self.parse_token_file(self.token_file)

    def _parse_legacy_config_file(self):
        """
        Parse a legacy configuration file.
        """
        conf = RawConfigParser()
        conf.read(LEGACY_CONFIG_FILE)

        styles = self.styles.copy()

        if conf.has_option('params', 'dm_template'):
            styles['dm_template'] = conf.get('params', 'dm_template')

        if conf.has_option('params', 'header_template'):
            styles['header_template'] = conf.get('params', 'header_template')

        self.styles.update(styles)

        if conf.has_option('params', 'logging_level'):
            self.logging_level = conf.getint('params', 'logging_level')

        for binding in self.key_bindings:
            if conf.has_option('keys', binding):
                custom_key = conf.get('keys', binding)
                self._set_key_binding(binding, custom_key)

        palette_labels = [color[0] for color in PALETTE]
        for label in palette_labels:
            if conf.has_option('colors', label):
                custom_fg = conf.get('colors', label)
                self._set_color(label, custom_fg)

    def _parse_legacy_token_file(self):
        conf = RawConfigParser()
        conf.read(LEGACY_TOKEN_FILE)

        if conf.has_option(SECTION_TOKEN, 'oauth_token'):
            self.oauth_token = conf.get(SECTION_TOKEN, 'oauth_token')

        if conf.has_option(SECTION_TOKEN, 'oauth_token'):
            self.oauth_token_secret = conf.get(SECTION_TOKEN, 'oauth_token_secret')

    def _set_color(self, color_label, custom_fg=None, custom_bg=None):
        for color in self.palette:
            label, fg, bg = color[0], color[1], color[2]
            if label == color_label:
                color[1] = custom_fg if validate_color(custom_fg) is not None else fg
                color[2] = custom_bg if validate_color(custom_bg) is not None else bg

    def _set_key_binding(self, binding, new_key):
        if not binding in self.key_bindings:
            return

        key, description = self.key_bindings[binding]
        new_key_binding = new_key, description
        self.key_bindings[binding] = new_key_binding

    def generate_config_file(self, config_file):
        kwargs = {
            'config_file': config_file,
            'on_error': partial(self._config_generation_error, config_file),
        }

        if not path.isfile(config_file):
            kwargs.update({
                'on_success': partial(self._config_generation_success,
                                      config_file)
            })

        self._generate_config_file(**kwargs)

    @wrap_exceptions
    def _generate_config_file(self, config_file):
        conf = RawConfigParser()

        self._add_section_twitter(conf)
        self._add_section_key_bindings(conf)
        self._add_section_palette(conf)
        self._add_section_styles(conf)
        self._add_section_debug(conf)

        with open(config_file, 'wb') as config:
            conf.write(config)

    def _config_generation_success(self, config_file):
        print encode(_('Generated configuration file in %s')) % config_file

    def _config_generation_error(self, config_file):
        print encode(_('Unable to generate configuration file in %s')) % config_file
        self.exit_with_code(2)

    def generate_token_file(self,
                            token_file,
                            oauth_token,
                            oauth_token_secret):
        self.oauth_token = oauth_token
        self.oauth_token_secret = oauth_token_secret

        conf = RawConfigParser()
        conf.add_section(SECTION_TOKEN)
        conf.set(SECTION_TOKEN, 'oauth_token', oauth_token)
        conf.set(SECTION_TOKEN, 'oauth_token_secret', oauth_token_secret)

        with open(token_file, 'wb') as tokens:
            conf.write(tokens)

        print encode(_('your account has been saved'))

    def parse_config_file(self, config_file):
        conf = RawConfigParser()
        conf.read(config_file)

        self._parse_twitter(conf)
        self._parse_key_bindings(conf)
        self._parse_palette(conf)
        self._parse_styles(conf)
        self._parse_debug(conf)

    def _parse_twitter(self, conf):
        if conf.has_option(SECTION_TWITTER, 'update_frequency'):
            self.twitter['update_frequency'] = conf.getint(SECTION_TWITTER, 'update_frequency')
        if conf.has_option(SECTION_TWITTER, 'use_https'):
            self.twitter['use_https'] = conf.getboolean(SECTION_TWITTER, 'use_https')

    def _parse_key_bindings(self, conf):
        for binding in self.key_bindings:
            if conf.has_option(SECTION_KEY_BINDINGS, binding):
                custom_key = conf.get(SECTION_KEY_BINDINGS, binding)
                self._set_key_binding(binding, custom_key)

    def _parse_palette(self, conf):
        # Color
        for label in self.palette:
            label_name, fg, bg = label[0], label[1], label[2]
            if conf.has_option(SECTION_PALETTE, label_name):
                fg = conf.get(SECTION_PALETTE, label_name)
            if conf.has_option(SECTION_PALETTE, label_name + '_bg'):
                bg = conf.get(SECTION_PALETTE, label_name + '_bg')
            self._set_color(label_name, fg, bg)

    def _parse_styles(self, conf):
        for style in self.styles:
            if conf.has_option(SECTION_STYLES, style):
                if any([style == 'box_around_status',
                        style == 'status_divider',
                        style == 'status_bar']):
                    self.styles[style] = conf.getboolean(SECTION_STYLES, style)
                elif (style == 'editor_horizontal_align' and
                      style in ['left', 'center', 'right']):
                    self.styles[style] = conf.get(SECTION_STYLES, style)
                elif (style == 'url_format' and
                      style in ['shortened', 'original', 'display']):
                    self.styles[style] = conf.get(SECTION_STYLES, style)
                elif style == 'statuses_in_user_info':
                    self.styles[style] = conf.getint(SECTION_STYLES, style)
                else:
                    self.styles[style] = unicode(conf.get(SECTION_STYLES, style),
                                                 'utf-8')

    def _parse_debug(self, conf):
        if conf.has_option(SECTION_DEBUG, 'logging_level'):
            self.logging_level = conf.getint(SECTION_DEBUG, 'logging_level')

    def parse_token_file(self, token_file):
        conf = RawConfigParser()
        conf.read(token_file)

        if conf.has_option(SECTION_TOKEN, 'oauth_token'):
            self.oauth_token = conf.get(SECTION_TOKEN, 'oauth_token')
        if conf.has_option(SECTION_TOKEN, 'oauth_token_secret'):
            self.oauth_token_secret = conf.get(SECTION_TOKEN, 'oauth_token_secret')

    def authorize_new_account(self):
        access_tokens = get_authorization_tokens()
        if access_tokens:
            access_token = access_tokens['oauth_token']
            access_token_secret = access_tokens['oauth_token_secret']

            self.oauth_token = access_token
            self.generate_token_file(self.token_file,
                                     access_token,
                                     access_token_secret)
        else:
            # TODO: exit codes
            self.exit_with_code(2)

    def reload(self):
        self.parse_config_file(self.config_file)
        self.key_mappings = invert_command_map(self.key_bindings)

    def exit_with_code(self, code):
        """Invoke `sys.exit` with the given status `code`."""
        # This is here because makes testing exit codes easier
        exit(code)


# configuration singleton
configuration = Configuration()

########NEW FILE########
__FILENAME__ = core
# -*- coding: utf-8 -*-

"""
This module contains the controller and key handling logic of turses.
"""

import signal
import logging
from gettext import gettext as _
from functools import partial, wraps
import webbrowser

import urwid
from tweepy import TweepError

from turses.utils import get_urls
from turses.meta import async, wrap_exceptions, Observer
from turses.config import configuration
from turses.utils import is_username
from turses.models import (
    is_DM,
    is_valid_status_text,
    is_valid_search_text,
    sanitize_username,

    Timeline,
)
from turses.session import Session


def merge_dicts(*args):
    """
    Merge all dictionaries given as positional arguments in a single
    dictionary.
    """
    result = {}
    for arg in args:
        result.update(arg)
    return result


class InputHandler(object):
    """
    Maps user input to calls to :class:`Controller` functions.
    """
    ALLOWED_MOUSE_KEYS = (4, 5)

    def __init__(self, controller):
        self.controller = controller

        self.TURSES_COMMANDS = {
            'quit':          self.controller.exit,
            'redraw':        self.controller.redraw_screen,
            'help':          self.controller.help_mode,
            'reload_config': self.controller.reload_configuration,
            'clear':         self.controller.clear_status,
        }

        self.MOTION_COMMANDS = {
            'up':               self.controller.scroll_up,
            'down':             self.controller.scroll_down,
            'scroll_to_top':    self.controller.scroll_top,
            'scroll_to_bottom': self.controller.scroll_bottom,
        }

        self.BUFFER_COMMANDS = {
            'right':                  self.controller.next_timeline,
            'left':                   self.controller.previous_timeline,

            'shift_buffer_left':      self.controller.shift_buffer_left,
            'shift_buffer_right':     self.controller.shift_buffer_right,
            'shift_buffer_beggining': self.controller.shift_buffer_beggining,
            'shift_buffer_end':       self.controller.shift_buffer_end,

            'expand_visible_left':    self.controller.expand_buffer_left,
            'expand_visible_right':   self.controller.expand_buffer_right,
            'shrink_visible_left':    self.controller.shrink_buffer_left,
            'shrink_visible_right':   self.controller.shrink_buffer_right,

            'activate_first_buffer':  self.controller.activate_first_buffer,
            'activate_last_buffer':   self.controller.activate_last_buffer,

            'delete_buffer':          self.controller.delete_buffer,
            'mark_all_as_read':       self.controller.mark_all_as_read,
        }

        self.TIMELINE_COMMANDS = {
            'home':           self.controller.append_home_timeline,
            'own_tweets':     self.controller.append_own_tweets_timeline,
            'favorites':      self.controller.append_favorites_timeline,
            'mentions':       self.controller.append_mentions_timeline,
            'DMs':            self.controller.append_direct_messages_timeline,
            'search':         self.controller.search,
            'search_user':    self.controller.search_user,
            'thread':         self.controller.append_thread_timeline,
            'user_info':      self.controller.user_info,
            'hashtags':       self.controller.search_hashtags,
            'user_timeline':  self.controller.focused_status_author_timeline,
            'retweets_of_me': self.controller.append_retweets_of_me_timeline,
        }

        self.TWITTER_COMMANDS = {
            'update':            self.controller.update_active_timeline,
            'update_all':        self.controller.update_all_timelines,
            'tweet':             self.controller.tweet,
            'reply':             self.controller.reply,
            'retweet':           self.controller.retweet,
            'retweet_and_edit':  self.controller.manual_retweet,
            'retweet_and_fav':   self.controller.retweet_and_favorite,
            'delete_tweet':      self.controller.delete_tweet,
            'follow_selected':   self.controller.follow_selected,
            'follow_user':       self.controller.follow_user,
            'unfollow_selected': self.controller.unfollow_selected,
            'unfollow_user':     self.controller.unfollow_user,
            'send_dm':           self.controller.direct_message,
            'fav':               self.controller.favorite,
            'delete_fav':        self.controller.unfavorite,
            'tweet_hashtag':     self.controller.tweet_with_hashtags,
        }

        self.EXTERNAL_PROGRAM_COMMANDS = {
            'openurl':         self.controller.open_urls,
            'open_status_url': self.controller.open_status_url,
        }

        # commands grouped by modes
        all_commands = [self.TURSES_COMMANDS,
                        self.MOTION_COMMANDS,
                        self.BUFFER_COMMANDS,
                        self.TIMELINE_COMMANDS,
                        self.TWITTER_COMMANDS,
                        self.EXTERNAL_PROGRAM_COMMANDS]

        # Timeline mode
        self.TIMELINE_MODE_COMMANDS = merge_dicts(*all_commands)

        # Info mode
        self.INFO_MODE_COMMANDS = merge_dicts(self.TURSES_COMMANDS,
                                              self.TIMELINE_COMMANDS)

        # Help mode
        self.HELP_MODE_COMMANDS = merge_dicts(self.TURSES_COMMANDS,
                                              self.MOTION_COMMANDS)

    def command(self, key):
        """
        Return the command name that corresponds to `key` (if any).
        """
        return configuration.key_mappings.get(key)

    def filter_input(self, keys, raw):
        accepted_keys = []
        for key in keys:
            if (not self.is_mouse_input(key) or
                    key[1] in self.ALLOWED_MOUSE_KEYS):
                accepted_keys.append(key)
        return accepted_keys

    def handle(self, key):
        """Handle input."""
        command = self.command(key)

        # Editor mode -- don't interpret keypress as command
        if self.controller.is_in_editor_mode():
            if self.is_mouse_event(key):
                return key
            else:
                return self.controller.forward_to_editor(key)

        # Handle scroll events as normal key presses
        if self.is_mouse_input(key):
            if key[1] == 4:
                command = 'up'
                key = configuration.key_bindings[command][0]
            elif key[1] == 5:
                command = 'down'
                key = configuration.key_bindings[command][0]

        # User info mode
        #  we remove the user widget and activate timeline mode when
        #  receiving input
        # TODO: commands for info mode (any other input will transition to
        # timeline mode)
        if self.controller.is_in_user_info_mode():
            self.controller.timeline_mode()

        # Help mode
        if self.controller.is_in_help_mode():
            # <Esc> in Help mode is not associated with a command
            if key == 'esc':
                return self.controller.timeline_mode()
            elif command in self.HELP_MODE_COMMANDS:
                handler = self.HELP_MODE_COMMANDS[command]
                return handler()
        # Info mode
        elif self.controller.is_in_info_mode():
            if command in self.INFO_MODE_COMMANDS:
                handler = self.INFO_MODE_COMMANDS[command]
                return handler()
        # Timeline mode
        elif self.controller.is_in_timeline_mode():
            if command in self.TIMELINE_MODE_COMMANDS:
                handler = self.TIMELINE_MODE_COMMANDS[command]
                return handler()

        return key

    def is_mouse_input(self, key):
        return len(key) >= 2 and key[0] == 'mouse press'

    def is_mouse_event(self, key):
        return len(key) >= 2 and 'mouse' in key[0]



# Decorators


def has_active_status(func):
    """
    `func` only is executed if there is a active status.
    """
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        status = self.timelines.active_status
        if status is not None:
            return func(self, *args, **kwargs)
    return wrapper


def has_timelines(func):
    """
    `func` only is executed if there are any timelines.
    """
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        if self.timelines.has_timelines():
            return func(self, *args, **kwargs)
    return wrapper


def text_from_editor(func):
    """
    `func` receives text from an editor.
    """
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        self.ui.hide_editor(wrapper)
        self.timeline_mode()
        return func(self, *args, **kwargs)

    return wrapper


# Controller


class Controller(Observer):
    """
    The :class:`Controller`.
    """

    # Modes

    INFO_MODE = 0
    TIMELINE_MODE = 1
    HELP_MODE = 2
    EDITOR_MODE = 3
    USER_INFO_MODE = 4

    # -- Initialization -------------------------------------------------------

    def __init__(self, ui, api, timelines):
        # View
        self.ui = ui
        self.api = api
        self.timelines = timelines

        # Load session
        self.session = Session(self.api)
        self.session.populate(self.timelines)

        self.editor = None

        # Default Mode
        self.mode = self.INFO_MODE

        # Subscribe to model updates
        self.timelines.subscribe(self)

        signal.signal(signal.SIGCONT, self.handle_sigcont)

    def start(self):
        self.main_loop()

    def handle_sigcont(self, signum, stack_frame):
        self.loop.screen.stop()
        self.loop.screen.start()
        self.redraw_screen()

    def authenticate_api(self):
        self.info_message(_('Authenticating API'))

        self.api.init_api(on_error=self.api_init_error,
                          on_success=self.init_timelines,)

    @async
    def init_timelines(self):
        # API has to be authenticated
        while (not self.api.is_authenticated):
            pass

        # fetch the authenticated user
        self.user = self.api.verify_credentials()

        # initialize the timelines
        self.info_message(_('Fetching timelines'))

        for timeline in self.timelines:
            timeline.update()
            timeline.activate_first()

        self.timeline_mode()
        self.clear_status()

        # Main loop has to be running
        while not getattr(self, 'loop'):
            pass

        # update alarm
        seconds = configuration.twitter['update_frequency']
        self.loop.set_alarm_in(seconds, self.update_alarm)

    def main_loop(self):
        """
        Launch the main loop of the program.
        """
        if not hasattr(self, 'loop'):
            # Creating the main loop for the first time
            self.input_handler = InputHandler(self)
            self.loop = urwid.MainLoop(self.ui,
                                       configuration.palette,
                                       handle_mouse=True,
                                       unhandled_input=self.input_handler.handle,
                                       input_filter=self.input_handler.filter_input)

            # Authenticate API just before starting main loop
            self.authenticate_api()

        try:
            self.loop.run()
        except TweepError, message:
            logging.exception(message)
            self.error_message(_('API error: %s' % message))
            # recover from API errors
            self.main_loop()
        except KeyboardInterrupt:
            # treat Ctrl-C as Escape
            self.input_handler.handle('esc')
            self.main_loop()

    def exit(self):
        """Exit the program."""
        raise urwid.ExitMainLoop()

    # -- Observer -------------------------------------------------------------

    def update(self):
        """
        From :class:`~turses.meta.Observer`, gets called when the observed
        subjects change.
        """
        if self.is_in_info_mode():
            self.timeline_mode()
        self.draw_timelines()

    # -- Callbacks ------------------------------------------------------------

    def api_init_error(self):
        # TODO retry
        self.error_message(_('Couldn\'t initialize API'))

    def update_alarm(self, *args, **kwargs):
        self.update_all_timelines()

        seconds = configuration.twitter['update_frequency']
        self.loop.set_alarm_in(seconds, self.update_alarm)

    # -- Modes ----------------------------------------------------------------

    def timeline_mode(self):
        """
        Activates the Timeline mode if there are Timelines.

        If not, shows program info.
        """
        if self.is_in_user_info_mode():
            self.ui.hide_user_info()

        if self.is_in_timeline_mode():
            return

        if self.is_in_help_mode():
            self.clear_status()

        if self.timelines.has_timelines():
            self.mode = self.TIMELINE_MODE
            self.draw_timelines()
        else:
            self.mode = self.INFO_MODE
            self.ui.show_info()

        self.redraw_screen()

    def is_in_timeline_mode(self):
        return self.mode == self.TIMELINE_MODE

    def info_mode(self):
        self.mode = self.INFO_MODE
        self.ui.show_info()
        self.redraw_screen()

    def is_in_info_mode(self):
        return self.mode == self.INFO_MODE

    def help_mode(self):
        """Activate Help mode."""
        if self.is_in_help_mode():
            return

        self.mode = self.HELP_MODE
        self.ui.show_help()
        self.redraw_screen()

    def is_in_help_mode(self):
        return self.mode == self.HELP_MODE

    def editor_mode(self, editor):
        """Activate editor mode."""
        self.editor = editor
        self.mode = self.EDITOR_MODE

    def is_in_editor_mode(self):
        return self.mode == self.EDITOR_MODE

    def user_info_mode(self, user):
        """Activate user info mode."""
        self._user_info = user
        self.mode = self.USER_INFO_MODE

    def is_in_user_info_mode(self):
        return self.mode == self.USER_INFO_MODE

    # -- Timelines ------------------------------------------------------------

    @wrap_exceptions
    def append_timeline(self,
                        name,
                        update_function,
                        update_args=None,
                        update_kwargs=None):
        """
        Given a name, function to update a timeline and optionally
        arguments to the update function, it creates the timeline and
        appends it to `timelines`.
        """
        timeline = Timeline(name=name,
                            update_function=update_function,
                            update_function_args=update_args,
                            update_function_kwargs=update_kwargs)
        timeline.update()
        timeline.activate_first()
        self.timelines.append_timeline(timeline)

    def append_home_timeline(self):
        timeline_fetched = partial(self.info_message,
                                   _('Home timeline fetched'))
        timeline_not_fetched = partial(self.error_message,
                                       _('Failed to fetch home timeline'))

        self.append_timeline(name=_('tweets'),
                             update_function=self.api.get_home_timeline,
                             on_error=timeline_not_fetched,
                             on_success=timeline_fetched,)

    def append_user_timeline(self, username):
        success_message = _('@%s\'s tweets fetched' % username)
        timeline_fetched = partial(self.info_message,
                                   success_message)
        error_message = _('Failed to fetch @%s\'s tweets' % username)
        timeline_not_fetched = partial(self.error_message,
                                       error_message)

        self.append_timeline(name='@%s' % username,
                             update_function=self.api.get_user_timeline,
                             update_kwargs={'screen_name': username},
                             on_error=timeline_not_fetched,
                             on_success=timeline_fetched,)

    def append_own_tweets_timeline(self):
        timeline_fetched = partial(self.info_message,
                                   _('Your tweets fetched'))
        timeline_not_fetched = partial(self.error_message,
                                       _('Failed to fetch your tweets'))

        if not hasattr(self, 'user'):
            self.user = self.api.verify_credentials()
        self.append_timeline(name='@%s' % self.user.screen_name,
                             update_function=self.api.get_own_timeline,
                             on_error=timeline_not_fetched,
                             on_success=timeline_fetched,)

    def append_mentions_timeline(self):
        timeline_fetched = partial(self.info_message,
                                   _('Mentions fetched'))
        timeline_not_fetched = partial(self.error_message,
                                       _('Failed to fetch mentions'))

        self.append_timeline(name=_('mentions'),
                             update_function=self.api.get_mentions,
                             on_error=timeline_not_fetched,
                             on_success=timeline_fetched,)

    def append_favorites_timeline(self):
        timeline_fetched = partial(self.info_message,
                                   _('Favorites fetched'))
        timeline_not_fetched = partial(self.error_message,
                                       _('Failed to fetch favorites'))

        self.append_timeline(name=_('favorites'),
                             update_function=self.api.get_favorites,
                             on_error=timeline_not_fetched,
                             on_success=timeline_fetched,)

    def append_direct_messages_timeline(self):
        timeline_fetched = partial(self.info_message,
                                   _('Messages fetched'))
        timeline_not_fetched = partial(self.error_message,
                                       _('Failed to fetch messages'))

        self.append_timeline(name=_('messages'),
                             update_function=self.api.get_direct_messages,
                             on_error=timeline_not_fetched,
                             on_success=timeline_fetched,)

    @has_active_status
    def append_thread_timeline(self):
        status = self.timelines.active_status

        timeline_fetched = partial(self.info_message,
                                   _('Thread fetched'))
        timeline_not_fetched = partial(self.error_message,
                                       _('Failed to fetch thread'))

        if is_DM(status):
            participants = [status.sender_screen_name,
                            status.recipient_screen_name]
            name = _('DM thread: %s' % ', '.join(participants))
            update_function = self.api.get_message_thread
        else:
            participants = status.mentioned_usernames
            author = status.authors_username
            if author not in participants:
                participants.insert(0, author)

            name = _('thread: %s' % ', '.join(participants))
            update_function = self.api.get_thread

        self.append_timeline(name=name,
                             update_function=update_function,
                             update_args=status,
                             on_error=timeline_not_fetched,
                             on_success=timeline_fetched)

    @async
    def append_search_timeline(self, query):
        text = query.strip()
        if not is_valid_search_text(text):
            self.error_message(_('Invalid search'))
            return
        else:
            self.info_message(_('Creating search timeline for "%s"' % text))

        success_message = _('Search timeline for "%s" created' % text)
        timeline_created = partial(self.info_message,
                                   success_message)
        error_message = _('Error creating search timeline for "%s"' % text)
        timeline_not_created = partial(self.info_message,
                                       error_message)

        self.append_timeline(name=_('Search: %s' % text),
                             update_function=self.api.search,
                             update_args=text,
                             on_error=timeline_not_created,
                             on_success=timeline_created)

    @async
    def append_retweets_of_me_timeline(self):
        success_message = _('Your retweeted tweet timeline created')
        timeline_created = partial(self.info_message,
                                   success_message)
        error_message = _('Error creating timeline for your retweeted tweets')
        timeline_not_created = partial(self.info_message,
                                       error_message)

        self.append_timeline(name=_('Retweets of %s' % self.user.screen_name),
                             update_function=self.api.get_retweets_of_me,
                             on_error=timeline_not_created,
                             on_success=timeline_created)

    @async
    def update_all_timelines(self):
        for timeline in self.timelines:
            timeline.update()
            self.draw_timelines()
            self.info_message(_('%s updated' % timeline.name))
        self.redraw_screen()
        self.clear_status()

    # -- Timeline mode --------------------------------------------------------

    def draw_timelines(self):
        if not self.is_in_timeline_mode():
            return

        if self.timelines.has_timelines():
            self.update_header()

            # draw visible timelines
            visible_timelines = self.timelines.visible_timelines
            self.ui.draw_timelines(visible_timelines)

            # focus active timeline
            active_timeline = self.timelines.active
            active_pos = self.timelines.active_index_relative_to_visible

            # focus active status (if any)
            if active_timeline.active_index >= 0:
                self.ui.focus_timeline(active_pos)
                self.ui.focus_status(active_timeline.active_index)
        else:
            self.ui.clear_header()

    def update_header(self):
        template = configuration.styles['tab_template']
        name_and_unread = [(tl.name, tl.unread_count) for tl in self.timelines]

        tabs = [template.format(timeline_name=name, unread=unread)
                for (name, unread) in name_and_unread]
        self.ui.set_tab_names(tabs)

        # highlight the active
        active_index = self.timelines.active_index
        self.ui.activate_tab(active_index)

        # colorize the visible tabs
        visible_indexes = self.timelines.visible
        self.ui.highlight_tabs(visible_indexes)

    def mark_all_as_read(self):
        """Mark all statuses in active timeline as read."""
        active_timeline = self.timelines.active
        for tweet in active_timeline:
            tweet.read = True
        self.update_header()

    @async
    def update_active_timeline(self):
        """Update the active timeline and draw the timeline buffers."""
        if self.timelines.has_timelines():
            active_timeline = self.timelines.active
            try:
                newest = active_timeline[0]
            except IndexError:
                return
            active_timeline.update(since_id=newest.id)
            if self.is_in_timeline_mode():
                self.draw_timelines()
            self.info_message('%s updated' % active_timeline.name)

    @async
    def update_active_timeline_with_newer_statuses(self):
        """
        Updates the active timeline with newer tweets than the active.
        """
        active_timeline = self.timelines.active
        active_status = active_timeline.active
        if active_status:
            active_timeline.update(since_id=active_status.id)

    @async
    def update_active_timeline_with_older_statuses(self):
        """
        Updates the active timeline with older tweets than the active.
        """
        active_timeline = self.timelines.active
        active_status = active_timeline.active
        if active_status:
            active_timeline.update(max_id=active_status.id)

        # Center focus in order to make the fetched tweets visible
        self.draw_timelines()
        self.ui.center_focus()
        self.redraw_screen()

    @has_timelines
    def previous_timeline(self):
        self.timelines.activate_previous()

    @has_timelines
    def next_timeline(self):
        self.timelines.activate_next()

    @has_timelines
    def shift_buffer_left(self):
        self.timelines.shift_active_previous()

    @has_timelines
    def shift_buffer_right(self):
        self.timelines.shift_active_next()

    @has_timelines
    def shift_buffer_beggining(self):
        self.timelines.shift_active_beggining()

    @has_timelines
    def shift_buffer_end(self):
        self.timelines.shift_active_end()

    @has_timelines
    def expand_buffer_left(self):
        self.timelines.expand_visible_previous()

    @has_timelines
    def expand_buffer_right(self):
        self.timelines.expand_visible_next()

    @has_timelines
    def shrink_buffer_left(self):
        self.timelines.shrink_visible_beggining()

    @has_timelines
    def shrink_buffer_right(self):
        self.timelines.shrink_visible_end()

    @has_timelines
    def activate_first_buffer(self):
        self.timelines.activate_first()

    @has_timelines
    def activate_last_buffer(self):
        self.timelines.activate_last()

    def delete_buffer(self):
        self.timelines.delete_active_timeline()
        if not self.timelines.has_timelines():
            self.info_mode()

    # -- Motion ---------------------------------------------------------------

    def scroll_up(self):
        self.ui.focus_previous()
        if self.is_in_timeline_mode():
            active_timeline = self.timelines.active
            # update with newer tweets when scrolling down being at the bottom
            if active_timeline.active_index == 0:
                self.update_active_timeline_with_newer_statuses()
            active_timeline.activate_previous()
            self.draw_timelines()

    def scroll_down(self):
        self.ui.focus_next()
        if self.is_in_timeline_mode():
            active_timeline = self.timelines.active
            # update with older tweets when scrolling down being at the bottom
            if active_timeline.active_index == len(active_timeline) - 1:
                self.update_active_timeline_with_older_statuses()
            active_timeline.activate_next()
            self.draw_timelines()

    def scroll_top(self):
        self.ui.focus_first()
        if self.is_in_timeline_mode():
            active_timeline = self.timelines.active
            active_timeline.activate_first()
            self.draw_timelines()

    def scroll_bottom(self):
        self.ui.focus_last()
        if self.is_in_timeline_mode():
            active_timeline = self.timelines.active
            active_timeline.activate_last()
            self.draw_timelines()

    # -- Footer ---------------------------------------------------------------

    def error_message(self, message):
        self.ui.status_error_message(message)
        self.redraw_screen()

    def info_message(self, message):
        self.ui.status_info_message(message)
        self.redraw_screen()

    def clear_status(self):
        """Clear the status bar."""
        self.ui.clear_status()
        self.redraw_screen()

    # -- UI -------------------------------------------------------------------
    def redraw_screen(self):
        if hasattr(self, "loop"):
            try:
                self.loop.draw_screen()
            except AssertionError, message:
                logging.critical(message)

    # -- Editor ---------------------------------------------------------------

    def forward_to_editor(self, key):
        if self.editor:
            # FIXME: `keypress` function needs a `size` parameter
            size = 20,
            self.editor.keypress(size, key)

    @text_from_editor
    def tweet_handler(self, text):
        """Handle the post as a tweet of the given `text`."""
        self.info_message(_('Sending tweet'))

        if not is_valid_status_text(text):
            # tweet was explicitly cancelled or empty text
            self.info_message(_('Tweet canceled'))
            return

        tweet_sent = partial(self.info_message, _('Tweet sent'))
        tweet_not_sent = partial(self.error_message, _('Tweet not sent'))

        # API call
        self.api.update(text=text,
                        on_success=tweet_sent,
                        on_error=tweet_not_sent,)

    @text_from_editor
    @has_active_status
    def reply_handler(self, text):
        """Handle the post as a tweet of the given `text` replying to the
        current status."""
        status = self.timelines.active_status

        self.info_message(_('Sending reply'))

        if not is_valid_status_text(text):
            # reply was explicitly cancelled or empty text
            self.info_message(_('Reply canceled'))
            return

        reply_sent = partial(self.info_message, _('Reply sent'))
        reply_not_sent = partial(self.error_message, _('Reply not sent'))

        # API call
        self.api.reply(status=status,
                       text=text,
                       on_success=reply_sent,
                       on_error=reply_not_sent,)

    @text_from_editor
    def direct_message_handler(self, username, text):
        """Handle the post as a DM of the given `text` to `username`."""
        self.info_message(_('Sending DM'))

        if not is_valid_status_text(text):
            # <Esc> was pressed
            self.info_message(_('DM canceled'))
            return

        dm_info = _('Direct Message to @%s sent' % username)
        dm_sent = partial(self.info_message, dm_info)
        dm_error = _('Failed to send message to @%s' % username)
        dm_not_sent = partial(self.error_message, dm_error)

        self.api.direct_message(screen_name=username,
                                text=text,
                                on_success=dm_sent,
                                on_error=dm_not_sent,)

    @text_from_editor
    def follow_user_handler(self, username):
        """
        Handles following the user given in `username`.
        """
        if username is None:
            self.info_message(_('Search cancelled'))
            return

        username = sanitize_username(username)
        if username == self.user.screen_name:
            self.error_message(_('You can\'t follow yourself'))
            return

        # TODO make sure that the user EXISTS and THEN follow
        if not is_username(username):
            self.info_message(_('Invalid username'))
            return
        else:
            self.info_message(_('Following @%s' % username))

        success_message = _('You are now following @%s' % username)
        follow_done = partial(self.info_message,
                              success_message)

        error_template = _('We can not ensure that you are following @%s')
        error_message = error_template % username
        follow_error = partial(self.error_message,
                               error_message)

        self.api.create_friendship(screen_name=username,
                                   on_error=follow_error,
                                   on_success=follow_done)

    @text_from_editor
    def unfollow_user_handler(self, username):
        """
        Handles unfollowing the user given in `username`.
        """
        if username is None:
            self.info_message(_('Search cancelled'))
            return

        username = sanitize_username(username)
        if username == self.user.screen_name:
            self.error_message(_('That doesn\'t make any sense'))
            return

        # TODO make sure that the user EXISTS and THEN follow
        if not is_username(username):
            self.info_message(_('Invalid username'))
            return
        else:
            self.info_message(_('Unfollowing @%s' % username))

        success_message = _('You are no longer following %s' % username)
        unfollow_done = partial(self.info_message,
                                success_message)

        error_template = _('We can not ensure that you are not following %s')
        error_message = error_template % username
        unfollow_error = partial(self.error_message,
                                 error_message)

        self.api.destroy_friendship(screen_name=username,
                                    on_error=unfollow_error,
                                    on_success=unfollow_done)

    @text_from_editor
    def search_handler(self, text):
        """
        Handles creating a timeline tracking the search term given in
        `text`.
        """
        if text is None:
            self.info_message(_('Search cancelled'))
            return
        self.append_search_timeline(text)

    @text_from_editor
    def search_user_handler(self, username):
        """
        Handles creating a timeline tracking the searched user's tweets.
        """
        if username is None:
            self.info_message(_('Search cancelled'))
            return

        # TODO make sure that the user EXISTS and THEN fetch its tweets
        username = sanitize_username(username)
        if not is_username(username):
            self.info_message(_('Invalid username'))
            return
        else:
            self.info_message(_('Fetching latest tweets from @%s' % username))

        success_message = _('@%s\'s timeline created' % username)
        timeline_created = partial(self.info_message,
                                   success_message)
        error_message = _('Unable to create @%s\'s timeline' % username)
        timeline_not_created = partial(self.error_message,
                                       error_message)

        self.append_timeline(name='@%s' % username,
                             update_function=self.api.get_user_timeline,
                             update_args=username,
                             on_success=timeline_created,
                             on_error=timeline_not_created)

    # -- Twitter --------------------------------------------------------------

    def search(self, text=None):
        text = '' if text is None else text
        handler = self.search_handler
        editor = self.ui.show_text_editor(prompt='Search',
                                          content=text,
                                          done_signal_handler=handler)
        self.editor_mode(editor)

    def search_user(self):
        prompt = _('Search user (no need to prepend it with "@"')
        handler = self.search_user_handler
        editor = self.ui.show_text_editor(prompt=prompt,
                                          content='',
                                          done_signal_handler=handler)
        self.editor_mode(editor)

    @has_active_status
    def search_hashtags(self):
        status = self.timelines.active_status

        hashtags = ' '.join(status.hashtags)
        self.search_handler(text=hashtags)

    @has_active_status
    def focused_status_author_timeline(self):
        status = self.timelines.active_status

        author = status.authors_username
        self.append_user_timeline(author)

    def tweet(self,
              prompt=_('Tweet'),
              content='',
              cursor_position=None):
        handler = self.tweet_handler
        editor = self.ui.show_tweet_editor(prompt=prompt,
                                           content=content,
                                           done_signal_handler=handler,
                                           cursor_position=cursor_position)
        self.editor_mode(editor)

    @has_active_status
    def retweet(self):
        status = self.timelines.active_status

        if is_DM(status):
            self.error_message(_('You can\'t retweet direct messages'))
            return

        self._retweet(status)

    def _retweet(self, status):
        retweet_posted = partial(self.info_message,
                                 _('Retweet posted'))
        retweet_post_failed = partial(self.error_message,
                                      _('Failed to post retweet'))
        self.api.retweet(on_error=retweet_post_failed,
                         on_success=retweet_posted,
                         status=status,)

    @has_active_status
    def manual_retweet(self):
        status = self.timelines.active_status

        rt_text = ''.join([' RT @%s: ' % status.authors_username,
                           status.text])
        if is_valid_status_text(rt_text):
            self.tweet(content=rt_text,
                       cursor_position=0)
        else:
            self.error_message(_('Tweet too long for manual retweet'))

    @has_active_status
    def retweet_and_favorite(self):
        status = self.timelines.active_status

        if is_DM(status):
            self.error_message(_('You can\'t retweet or favorite direct messages'))
            return

        self._retweet(status)
        self._favorite(status)

    @has_active_status
    def reply(self):
        status = self.timelines.active_status

        if is_DM(status):
            self.direct_message()
            return

        author = status.authors_username
        mentioned = status.mentioned_for_reply
        try:
            mentioned.remove('@%s' % self.user.screen_name)
        except ValueError:
            pass

        handler = self.reply_handler
        editor = self.ui.show_tweet_editor(prompt=_('Reply to %s' % author),
                                           content=' '.join(mentioned),
                                           done_signal_handler=handler)
        self.editor_mode(editor)

    @has_active_status
    def direct_message(self):
        status = self.timelines.active_status

        recipient = status.dm_recipients_username(self.user.screen_name)
        if recipient:
            handler = self.direct_message_handler
            editor = self.ui.show_dm_editor(prompt=_('DM to %s' % recipient),
                                            content='',
                                            recipient=recipient,
                                            done_signal_handler=handler)
            self.editor_mode(editor)
        else:
            self.error_message(_('What do you mean?'))

    @has_active_status
    def tweet_with_hashtags(self):
        status = self.timelines.active_status

        hashtags = ' '.join(status.hashtags)
        if hashtags:
            handler = self.tweet_handler
            content = ''.join([' ', hashtags])
            editor = self.ui.show_tweet_editor(prompt=_('%s' % hashtags),
                                               content=content,
                                               done_signal_handler=handler,
                                               cursor_position=0)
            self.editor_mode(editor)

    @has_active_status
    def delete_tweet(self):
        status = self.timelines.active_status

        if is_DM(status):
            self.delete_dm()
            return

        author = status.authors_username
        if author != self.user.screen_name and status.user != self.user.screen_name:
            self.error_message(_('You can only delete your own tweets'))
            return

        status_deleted = partial(self.info_message,
                                 _('Tweet deleted'))
        status_not_deleted = partial(self.error_message,
                                     _('Failed to delete tweet'))

        self.api.destroy_status(status=status,
                                on_error=status_not_deleted,
                                on_success=status_deleted)

    def delete_dm(self):
        dm = self.timelines.active_status
        if dm is None:
            return

        if dm.sender_screen_name != self.user.screen_name:
            self.error_message(_('You can only delete messages sent by you'))
            return

        dm_deleted = partial(self.info_message,
                             _('Message deleted'))
        dm_not_deleted = partial(self.error_message,
                                 _('Failed to delete message'))

        self.api.destroy_direct_message(status=dm,
                                        on_error=dm_not_deleted,
                                        on_success=dm_deleted)

    @has_active_status
    def follow_selected(self):
        status = self.timelines.active_status

        username = status.authors_username
        if username == self.user.screen_name:
            self.error_message(_('You can\'t follow yourself'))
            return

        success_message = _('You are now following @%s' % username)
        follow_done = partial(self.info_message,
                              success_message)

        error_template = _('We can not ensure that you are following @%s')
        error_message = error_template % username
        follow_error = partial(self.error_message,
                               error_message)

        self.api.create_friendship(screen_name=username,
                                   on_error=follow_error,
                                   on_success=follow_done)

    def follow_user(self,
                    prompt=_('Follow user (no need to prepend it with "@"'),
                    content='',
                    cursor_position=None):
        handler = self.follow_user_handler
        editor = self.ui.show_text_editor(prompt=prompt,
                                          content=content,
                                          done_signal_handler=handler,
                                          cursor_position=cursor_position)
        self.editor_mode(editor)

    def unfollow_user(self,
                      prompt=_('Unfollow user (no need to prepend it with'
                               ' "@"'),
                      content='',
                      cursor_position=None):
        handler = self.unfollow_user_handler
        editor = self.ui.show_text_editor(prompt=prompt,
                                          content=content,
                                          done_signal_handler=handler,
                                          cursor_position=cursor_position)
        self.editor_mode(editor)

    @has_active_status
    def unfollow_selected(self):
        status = self.timelines.active_status

        username = status.authors_username
        if username == self.user.screen_name:
            self.error_message(_('That doesn\'t make any sense'))
            return

        success_message = _('You are no longer following %s' % username)
        unfollow_done = partial(self.info_message,
                                success_message)

        error_template = _('We can not ensure that you are not following %s')
        error_message = error_template % username
        unfollow_error = partial(self.error_message,
                                 error_message)

        self.api.destroy_friendship(screen_name=username,
                                    on_error=unfollow_error,
                                    on_success=unfollow_done)

    @has_active_status
    def favorite(self):
        status = self.timelines.active_status

        self._favorite(status)

    def _favorite(self, status):
        favorite_error = partial(self.error_message,
                                 _('Failed to mark tweet as favorite'))
        favorite_done = partial(self.info_message,
                                _('Tweet marked as favorite'))
        self.api.create_favorite(on_error=favorite_error,
                                 on_success=favorite_done,
                                 status=status,)

    @has_active_status
    def unfavorite(self):
        status = self.timelines.active_status

        unfavorite_error = partial(self.error_message,
                                   _('Failed to remove tweet from favorites'))
        unfavorite_done = partial(self.info_message,
                                  _('Tweet removed from favorites'))
        self.api.destroy_favorite(on_error=unfavorite_error,
                                  on_success=unfavorite_done,
                                  status=status,)

    @has_active_status
    def user_info(self):
        status = self.timelines.active_status

        username = status.authors_username
        user = self.api.get_user(username)
        last_statuses = self.api.get_user_timeline(username)
        self.ui.show_user_info(user, last_statuses)
        self.user_info_mode(user)

    # - Configuration ---------------------------------------------------------

    def reload_configuration(self):
        configuration.reload()
        self.redraw_screen()
        self.info_message(_('Configuration reloaded'))

    # - Browser ---------------------------------------------------------------

    @has_active_status
    def open_urls(self):
        """
        Open the URLs contained on the focused tweets in a browser.
        """
        status = self.timelines.active_status
        urls = get_urls(status.text)

        if not urls:
            self.info_message(_('No URLs found on this tweet'))
            return

        self.open_urls_in_browser(urls)

    @has_active_status
    def open_status_url(self):
        """
        Open the focused tweet in a browser.
        """
        status = self.timelines.active_status

        if is_DM(status):
            message = _('You only can open regular statuses in a browser')
            self.info_message(message)
            return

        self.open_urls_in_browser([status.url])

    def open_urls_in_browser(self, urls):
        """
        Open `urls` in $BROWSER if the environment variable is set.
        """
        # The webbrowser module respects the BROWSER environment variable,
        # so if that's set, it'll use it, otherwise it will try to find
        # something sensible
        try:
            # Firefox, w3m, etc can't handle multiple URLs at command line, so
            # split the URLs up for them
            for url in urls:
                webbrowser.open(url)
        except Exception, message:
            logging.exception(message)
            self.error_message(_('Unable to launch the browser'))

########NEW FILE########
__FILENAME__ = meta
# -*- coding: utf-8 -*-

"""
This module contains abstract classes and decorators.
"""

import logging
from abc import ABCMeta, abstractmethod, abstractproperty
from functools import wraps
from threading import Thread


# - Decorators ----------------------------------------------------------------


def wrap_exceptions(func):
    """
    Augments the function arguments with the `on_error` and `on_success`
    keyword arguments.

    Executes the decorated function in a try except block and calls
    `on_success` (if given) if no exception was raised, otherwise calls
    `on_error` (if given).
    """
    @wraps(func)
    def wrapper(self=None, *args, **kwargs):
        on_error = kwargs.pop('on_error', None)
        on_success = kwargs.pop('on_success', None)

        try:
            result = func(self, *args, **kwargs)
        except Exception, message:
            if callable(on_error):
                logging.exception(message)
                on_error()
        else:
            if callable(on_success):
                on_success()
            return result

    return wrapper


def async(func):
    """
    Decorator for executing a function in a separate :class:`threading.Thread`.
    """
    @wraps(func)
    def wrapper(*args, **kwargs):
        thread = Thread(target=func, args=args, kwargs=kwargs)
        thread.daemon = True
        return thread.start()
    return wrapper


def filter_result(func, filter_func=None):
    """
    Decorator for filtering the output of ``func`` with ``filter_func``.
    """
    @wraps(func)
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)

        if isinstance(result, list):
            return [filter_func(elem) for elem in result]
        else:
            return filter_func(result)
    return wrapper


# - Abstract classes ----------------------------------------------------------

# FIXME: Use urwid.MonitoredFocusList
class ActiveList(object):
    """
    A list that contains an *active* element.

    This abstract class implements some functions but the subclasses must
    define the :attr:`turses.meta.ActiveList.active` property, as well as
    :func:`turses.meta.ActiveList.is_valid_index` and
    :func:`turses.meta.ActiveList.activate_last`.
    methods.
    """
    __metaclass__ = ABCMeta

    NULL_INDEX = -1

    def __init__(self):
        self.active_index = self.NULL_INDEX

    @abstractproperty
    def active(self):
        pass

    @abstractmethod
    def is_valid_index(self, index):
        pass

    def activate_previous(self):
        """Mark as active the previous element if it exists."""
        new_index = self.active_index - 1
        if self.is_valid_index(new_index):
            self.active_index = new_index

    def activate_next(self):
        """Mark as active the next element if it exists."""
        new_index = self.active_index + 1
        if self.is_valid_index(new_index):
            self.active_index = new_index

    def activate_first(self):
        """Mark the first element as the 'active' if it exists."""
        first = 0
        if self.is_valid_index(first):
            self.active_index = first
        else:
            self.active_index = self.NULL_INDEX

    @abstractmethod
    def activate_last(self):
        pass


class UnsortedActiveList(ActiveList):
    """
    A :class:`~turses.meta.ActiveList` in which the *active* element position
    can be shifted either to the beginning or to the end.

    All the methods contained in this class are abstract.
    """

    @abstractmethod
    def shift_active_previous(self):
        """Shift the active element one position to the left."""
        pass

    @abstractmethod
    def shift_active_next(self):
        """Shift the active element one position to the right."""
        pass

    @abstractmethod
    def shift_active_beggining(self):
        """
        Shift the active element (if any) to the beginning of the list.
        """
        pass

    @abstractmethod
    def shift_active_end(self):
        """
        Shift the active element (if any) to the beginning of the list.
        """
        pass


class Updatable:
    """
    An abstract class for making a class *updatable*.

    The constructor takes an update function and arguments used to update the
    subclasses of :class:`~turses.meta.Updatable`.

    When :func:`~turses.meta.Updatable.update` is executed,
    :func:`~turses.meta.Updatable.update_callback` is called, passing it the
    result.
    """

    __metaclass__ = ABCMeta

    def __init__(self,
                 update_function=None,
                 update_function_args=None,
                 update_function_kwargs=None,):
        """
        `update_function` is the function used to update the class, with
        optional args `update_function_args` and `update_function_kwargs`.
        """
        self.update_function = update_function

        if isinstance(update_function_args, tuple):
            self._args = list(update_function_args)
        elif update_function_args:
            self._args = [update_function_args]
        else:
            self._args = []

        if update_function_kwargs:
            self._kwargs = dict(update_function_kwargs)
        else:
            self._kwargs = {}

    @wrap_exceptions
    def update(self, **extra_kwargs):
        """
        Update the object. The result of `update_function` is passed to the
        `update_callback` function.
        """
        if not self.update_function:
            return

        args = self._args
        kwargs = self._kwargs
        kwargs.update(extra_kwargs)

        result = self.update_function(*args, **kwargs)

        self.update_callback(result)

    @abstractmethod
    def update_callback(self, result):
        pass


def notify(func):
    """
    Wrap an instance method `func`, calling the instance's `notify` method after
    executing `func`.
    """
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        result = func(self, *args, **kwargs)
        if isinstance(self, Observable):
            self.notify()
        else:
            raise Exception("The `notify` decorator should only be applied to "
                            "`Observable` subclasses")
        return result

    return wrapper


class Observable:
    """
    An implementation of the *observer* pattern.

    Zero or more *observers* can `subscribe` to the changes in the instances
    of this class. When the instance changes, it will call its `notify` method,
    which loops through the *observers* and calls `update()` on them.
    """

    def __init__(self):
        self._observers = set([])

    def subscribe(self, observer):
        self._observers.add(observer)

    def unsubscribe(self, observer):
        self._observers.discard(observer)

    def notify(self):
        for observer in self._observers:
            observer.update()


class Observer:
    """
    An abstract class that can subscribe to updates from
    :class:`~turses.meta.Observable` instances.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def update(self):
        pass

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

"""
This module contains the data structures that power ``turses`` and
the Twitter entities represented into it.
"""

import time
from bisect import insort
from calendar import timegm

try:
    from functools import total_ordering
except ImportError:
    from turses.utils import total_ordering

from turses.meta import (ActiveList, UnsortedActiveList, Updatable, Observable,
                         notify)
from turses.utils import prepend_at, sanitize_username, is_hashtag


TWEET_MAXIMUM_CHARACTERS = 140
STATUS_URL_TEMPLATE = 'https://twitter.com/#!/{user}/status/{id}'


def is_DM(status):
    return status.__class__ == DirectMessage


def is_valid_status_text(text):
    """Checks the validity of a status text."""
    return text and len(text) <= TWEET_MAXIMUM_CHARACTERS


def is_valid_search_text(text):
    """Checks the validity of a search text."""
    return bool(text)


def timestamp_from_datetime(datetime):
    return timegm(datetime.utctimetuple())


# -- Model --------------------------------------------------------------------


class TimelineList(UnsortedActiveList, Observable):
    """
    A list of :class:`~turses.models.Timeline` instances that implements the
    :class:`~turses.meta.UnsortedActiveList` interface, thus having an *active*
    element and a group of adjacent *visible* timelines.
    """

    def __init__(self):
        UnsortedActiveList.__init__(self)
        Observable.__init__(self)
        self.timelines = []
        self.visible = []

    def has_timelines(self):
        return self.active_index != self.NULL_INDEX and self.timelines

    @property
    def active_status(self):
        if self.has_timelines():
            active_timeline = self.active
            return active_timeline.active

    @notify
    def append_timeline(self, timeline):
        """Appends a new `Timeline` to the end of the list."""
        if self.active_index == self.NULL_INDEX:
            # `timeline` becomes the active and the only visible
            self.active_index = 0
            self.visible = [0]
            self.timelines.append(timeline)
            self._mark_read()
            return
        self.timelines.append(timeline)

    @notify
    def delete_active_timeline(self):
        """Delete the active timeline (if any)."""
        if not self.has_timelines():
            return

        # delete timeline
        old_index = self.active_index
        del self.timelines[old_index]

        # recalculate visible indexes
        if len(self.visible) > 1:
            old_index_in_visible = self.visible.index(old_index)
            left_indexes = self.visible[:old_index_in_visible]
            right_indexes = self.visible[old_index_in_visible + 1:]
            # decrement those that are in the right of the deleted one
            self.visible = left_indexes + [index - 1 for index in right_indexes
                                                               if index]
        elif len(self.visible) == 1:
            visible_index = self.visible[0]
            if not self.is_valid_index(visible_index):
                self.visible = [visible_index - 1]

        if not self.is_valid_index(self.active_index):
            # Shift cursor to left when we don't have any element
            # in the right. When deleting the last timeline in the
            # list, the `active_index` becomes -1 (NULL_INDEX).
            self.active_index -= 1

    @notify
    def update_active_timeline(self):
        if self.has_timelines():
            self.active.update()

    @property
    def visible_timelines(self):
        return [self.timelines[i] for i in self.visible]

    @property
    def active_index_relative_to_visible(self):
        return self.visible.index(self.timelines.index(self.active))

    def _set_active_as_visible(self):
        if self.active_index not in self.visible:
            self.visible = [self.active_index]

    @notify
    def expand_visible_previous(self):
        if not self.visible:
            return

        self.visible.sort()
        lowest = self.visible[0]
        previous = lowest - 1
        if self.is_valid_index(previous):
            self.visible.insert(0, previous)

    @notify
    def expand_visible_next(self):
        if not self.visible:
            return

        self.visible.sort()
        highest = self.visible[-1]
        next = highest + 1
        if self.is_valid_index(next):
            self.visible.append(next)

    @notify
    def shrink_visible_beggining(self):
        self.visible.sort()
        try:
            first = self.visible.pop(0)
            # if the active is the first one does not change
            if first == self.active_index:
                self.visible.insert(0, first)
        except IndexError:
            pass

    @notify
    def shrink_visible_end(self):
        self.visible.sort()
        try:
            last = self.visible.pop()
            # if the active is the last one does not change
            if last == self.active_index:
                self.visible.append(last)
        except IndexError:
            pass

    # magic

    def __iter__(self):
        return self.timelines.__iter__()

    def __len__(self):
        return len(self.timelines)

    def __getitem__(self, key):
        return self.timelines[key]

    # from `UnsortedActiveList`

    @property
    def active(self):
        if self.has_timelines():
            return self.timelines[self.active_index]

    def is_valid_index(self, index):
        return index >= 0 and index < len(self.timelines)

    @notify
    def activate_previous(self):
        UnsortedActiveList.activate_previous(self)
        self._mark_read()
        self._set_active_as_visible()

    @notify
    def activate_next(self):
        UnsortedActiveList.activate_next(self)
        self._mark_read()
        self._set_active_as_visible()

    @notify
    def activate_first(self):
        UnsortedActiveList.activate_first(self)
        self._mark_read()
        self._set_active_as_visible()

    @notify
    def activate_last(self):
        if self.has_timelines():
            last_index = len(self.timelines) - 1
            self.active_index = last_index
        self._mark_read()
        self._set_active_as_visible()

    def _swap_timelines(self, one, other):
        """
        Given the indexes of two timelines `one` and `other`, it swaps the
        `Timeline` objects contained in those positions.
        """
        if self.is_valid_index(one) and self.is_valid_index(other):
            self.timelines[one], self.timelines[other] = \
                    self.timelines[other], self.timelines[one]

    def _mark_read(self):
        if self.has_timelines():
            active_timeline = self.active
            active_timeline.mark_active_as_read()

    @notify
    def shift_active_previous(self):
        active_index = self.active_index
        previous_index = active_index - 1
        if self.is_valid_index(previous_index):
            self._swap_timelines(previous_index, active_index)
            self.active_index = previous_index
            self._set_active_as_visible()

    @notify
    def shift_active_next(self):
        active_index = self.active_index
        next_index = active_index + 1
        if self.is_valid_index(next_index):
            self._swap_timelines(active_index, next_index)
            self.active_index = next_index
            self._set_active_as_visible()

    @notify
    def shift_active_beggining(self):
        if self.has_timelines():
            first_index = 0
            active_timeline = self.active
            self.timelines.insert(first_index, active_timeline)
            del self.timelines[self.active_index + 1]
            self.active_index = first_index
            self._set_active_as_visible()

    @notify
    def shift_active_end(self):
        if self.has_timelines():
            last_index = len(self.timelines)
            active_timeline = self.active
            self.timelines.insert(last_index, active_timeline)
            self.delete_active_timeline()
            self.active_index = last_index - 1
            self._set_active_as_visible()


# -- Twitter entities ---------------------------------------------------------


class Timeline(ActiveList, Updatable):
    """
    List of Twitter statuses ordered reversely by date, optionally with
    a name and a function that updates the current timeline and its arguments.

    Its :class:`~turses.meta.Updatable` and implements the
    :class:`~turses.meta.ActiveList` interface.
    """

    def __init__(self,
                 name='',
                 statuses=None,
                 **kwargs):
        ActiveList.__init__(self)
        Updatable.__init__(self, **kwargs)
        self.name = name

        self.statuses = []
        if statuses:
            self.add_statuses(statuses)
            self.activate_first()
            self.mark_active_as_read()

    def add_status(self, new_status):
        """
        Adds the given status to the status list of the Timeline if it's
        not already in it.
        """
        if new_status in self.statuses:
            return

        if self.active_index == self.NULL_INDEX:
            self.active_index = 0

        # keep the same tweet as the active when inserting statuses
        active = self.active
        is_more_recent_status = lambda a, b: a.created_at < b.created_at

        if active and is_more_recent_status(active, new_status):
            self.activate_next()

        insort(self.statuses, new_status)

    def add_statuses(self, new_statuses):
        """
        Adds the given new statuses to the status list of the Timeline
        if they are not already in it.
        """
        if not new_statuses:
            return

        for status in new_statuses:
            self.add_status(status)

    def clear(self):
        """Clears the Timeline."""
        self.active_index = self.NULL_INDEX
        self.statuses = []

    @property
    def unread_count(self):
        def one_if_unread(tweet):
            if hasattr(tweet, 'read') and tweet.read:
                return 0
            return 1

        return sum([one_if_unread(tweet) for tweet in self.statuses])

    def mark_active_as_read(self):
        """Set active status' `read` attribute to `True`."""
        if self.active:
            self.active.read = True

    def mark_all_as_read(self):
        for status in self.statuses:
            status.read = True
    # magic

    def __len__(self):
        return len(self.statuses)

    def __iter__(self):
        return self.statuses.__iter__()

    def __getitem__(self, key):
        return self.statuses[key]

    # from `ActiveList`

    @property
    def active(self):
        if self.statuses and self.is_valid_index(self.active_index):
            return self.statuses[self.active_index]

    def is_valid_index(self, index):
        if self.statuses:
            return index >= 0 and index < len(self.statuses)
        else:
            self.active_index = self.NULL_INDEX
        return False

    def activate_previous(self):
        ActiveList.activate_previous(self)
        self.mark_active_as_read()

    def activate_next(self):
        ActiveList.activate_next(self)
        self.mark_active_as_read()

    def activate_first(self):
        ActiveList.activate_first(self)
        self.mark_active_as_read()

    def activate_last(self):
        if self.statuses:
            self.active_index = len(self.statuses) - 1
            self.mark_active_as_read()
        else:
            self.active_index = self.NULL_INDEX

    # from `Updatable`

    def update_callback(self, result):
        self.add_statuses(result)


class User(object):
    """
    A Twitter user.
    """

    def __init__(self,
                 id,
                 name,
                 screen_name,
                 description,
                 url,
                 created_at,
                 friends_count,
                 followers_count,
                 favorites_count,
                 status=None):
        self.id = id
        self.name = name
        self.screen_name = screen_name
        self.description = description
        self.url = url
        self.created_at = created_at
        self.friends_count = friends_count
        self.followers_count = followers_count
        self.favorites_count = favorites_count
        self.status = status


@total_ordering
class Status(object):
    """
    A Twitter status.
    """

    def __init__(self,
                 id,
                 created_at,
                 user,
                 text,
                 author='',
                 entities=None,
                 # reply
                 is_reply=False,
                 in_reply_to_user='',
                 in_reply_to_status_id=None,
                 # retweet
                 is_retweet=False,
                 retweeted_status=None,
                 retweet_count=0,
                 # favorite
                 is_favorite=False,):
        self.id = id
        self.created_at = created_at
        self.user = user
        self.text = text
        self.is_reply = is_reply
        self.is_retweet = is_retweet
        self.is_favorite = is_favorite
        self.retweet_count = retweet_count
        self.retweeted_status = retweeted_status
        self.author = author
        self.entities = {} if entities is None else entities

    @property
    def relative_created_at(self):
        """Return a human readable string representing the posting time."""
        # This code is borrowed from `python-twitter` library
        fudge = 1.25
        delta = long(time.time()) - timestamp_from_datetime(self.created_at)

        if delta < (1 * fudge):
            return "a second ago"
        elif delta < (60 * (1 / fudge)):
            return "%d seconds ago" % (delta)
        elif delta < (60 * fudge):
            return "a minute ago"
        elif delta < (60 * 60 * (1 / fudge)):
            return "%d minutes ago" % (delta / 60)
        elif delta < (60 * 60 * fudge) or delta / (60 * 60) == 1:
            return "an hour ago"
        elif delta < (60 * 60 * 24 * (1 / fudge)):
            return "%d hours ago" % (delta / (60 * 60))
        elif delta < (60 * 60 * 24 * fudge) or delta / (60 * 60 * 24) == 1:
            return "a day ago"
        else:
            return "%d days ago" % (delta / (60 * 60 * 24))

    @property
    def url(self):
        return STATUS_URL_TEMPLATE.format(user=self.user, id=self.id)

    @property
    def mentioned_for_reply(self):
        """
        Return a list containing the author of `status` and all the mentioned
        usernames prepended with '@'.
        """
        author = self.authors_username
        mentioned = self.mentioned_usernames
        mentioned.insert(0, author)
        # avoid repetitions
        mentioned = list(set(mentioned))

        return [prepend_at(username) for username in mentioned]

    @property
    def authors_username(self):
        """Return the original author's username of the given status."""
        if is_DM(self):
            return self.sender_screen_name
        elif self.is_retweet:
            return self.retweeted_status.authors_username
        else:
            return self.user

    @property
    def mentioned_usernames(self):
        """
        Return mentioned usernames in `status` without '@'.
        """
        # TODO: use self.entities if available
        usernames = []
        for word in self.text.split():
            if len(word) > 1 and word.startswith('@'):
                word.strip('@')
                usernames.append(sanitize_username(word))
        return list(set(usernames))

    @property
    def hashtags(self):
        """
        Return a list of hashtags encountered in `status`.
        """
        # TODO: use self.entities
        return filter(is_hashtag, self.text.split())

    def dm_recipients_username(self, sender):
        """
        Return the recipient for a Direct Message depending on what `self`
        is.

        If is a `turses.models.Status` and sender != `status.user` I will
        return `status.user`.

        If is a `turses.models.DirectMessage` I will return the username that
        is not `sender` looking at the DMs sender and recipient.

        Otherwise I return `None`.
        """
        if is_DM(self):
            users = [self.sender_screen_name,
                     self.recipient_screen_name]
            if sender in users:
                users.pop(users.index(sender))
                return users.pop()
        elif self.user != sender:
            return self.user

    # magic

    def __eq__(self, other):
        return self.id == other.id

    def __lt__(self, other):
        # statuses are ordered reversely by date
        return self.created_at > other.created_at


class DirectMessage(Status):
    """
    A Twitter direct message.
    """

    def __init__(self,
                 id,
                 created_at,
                 sender_screen_name,
                 recipient_screen_name,
                 text,
                 entities=None):
        self.id = id
        self.created_at = created_at
        self.sender_screen_name = sender_screen_name
        self.recipient_screen_name = recipient_screen_name
        self.text = text
        self.entities = entities

    @property
    def url(self):
        return None


class List(object):
    """
    A Twitter list.
    """

    def __init__(self,
                 id,
                 owner,
                 created_at,
                 name,
                 slug,
                 description,
                 member_count,
                 subscriber_count,
                 private=False,):
        self.id = id
        self.owner = owner
        self.created_at = created_at
        self.name = name
        self.slug = slug
        self.description = description
        self.member_count = member_count
        self.subscriber_count = subscriber_count
        self.private = private

########NEW FILE########
__FILENAME__ = session
# -*- coding: utf-8 -*-

"""
The file with the session declarations is located on
``$HOME/.turses/sessions``.

``sessions`` is a ini-style configuration file in which each section represents
the layout of a session. The ``defaults`` session is loaded when no other
section is present.

Each section has only two options:

    ``visible``
        contains the timelines that will be visible stacked in columns

    ``buffers``
        contains the timelines that won't be visible but will be loaded

.. warning:: The ``visible`` option must be present for any session but
   ``buffers`` is optional.

For each option, you will define the timelines as a comma-separated list of
their names. Here is a list with the valid names:

 - ``home`` for the home timeline
 - ``mentions`` for the mentions timeline
 - ``favorites`` for the favorites timeline
 - ``messages`` for the direct message timeline
 - ``own_tweets`` for the timeline with your tweets
 - ``search:<query>`` for searching timelines
 - ``hashtag:<query>`` for searching a hashtag
 - ``user:<screen_name>`` for a user's timeline
 - ``retweets_of_me`` for the timeline with your retweeted tweets

Declaring a custom session is as easy as defining a section on the
``sessions`` file. As an example, let's define a session called
``interactions``, in which we would only like to view our mentions, messages
and what people are saying about ``turses``; and load the home timeline in
background:

.. code-block:: ini

    [interactions]
    visible = mentions, messages, search:turses, hashtag:turses
    buffer = home

If you would like to load a session when starting ``turses``, you must provide
the name of the session as a command-line argument. You can start the session
named ``interactions`` by executing:

.. code-block:: sh

    $ turses -s interactions
    # or, alternatively
    $ turses --session interactions
"""

import re
import logging
from ConfigParser import RawConfigParser
from os import path
from gettext import gettext as _

from turses.api.helpers import (
    TimelineFactory,

    HOME_TIMELINE,
    MENTIONS_TIMELINE,
    FAVORITES_TIMELINE,
    MESSAGES_TIMELINE,
    OWN_TWEETS_TIMELINE,
)
from turses.config import (
    CONFIG_PATH,
    DEFAULT_SESSION,

    configuration,
)


SESSIONS_FILE = path.join(CONFIG_PATH, 'sessions')

VISIBLE = 'visible'
BUFFERS = 'buffers'

invalid_name_re = re.compile(r'^\s*$')


def clean_timeline_list_string(timeline_list_string):
    """
    Return a list with the timeline names encountered in
    `timeline_list_string`.
    """
    timeline_names = [name.strip() for name in timeline_list_string.split(',')]
    return [name.lower() for name in timeline_names if not invalid_name_re.match(name)]


class Session:
    """Loads and saves sessions."""

    def __init__(self, api):
        self.api = api
        self.factory = TimelineFactory(api)
        self.sessions_conf = RawConfigParser()
        self.sessions = {
            DEFAULT_SESSION: {
                VISIBLE: HOME_TIMELINE,
                BUFFERS: ', '.join([MENTIONS_TIMELINE,
                                    FAVORITES_TIMELINE,
                                    MESSAGES_TIMELINE,
                                    OWN_TWEETS_TIMELINE])
            }
        }
        if not path.isfile(SESSIONS_FILE):
            # create the sessions file
            logging.info(_('Sessions file created'))
            self.init_sessions_file()

    def init_sessions_file(self):
        """Create the `SESSIONS_FILE`."""
        self.sessions_conf.add_section(DEFAULT_SESSION)
        self.sessions_conf.set(DEFAULT_SESSION,
                               VISIBLE,
                               self.sessions[DEFAULT_SESSION][VISIBLE])
        self.sessions_conf.set(DEFAULT_SESSION,
                               BUFFERS,
                               self.sessions[DEFAULT_SESSION][BUFFERS])

        # create the file and write the `default` session
        with open(SESSIONS_FILE, 'w') as sessions_fp:
            self.sessions_conf.write(sessions_fp)

    def load_from_session_conf(self, session_name):
        """
        Load the session `session_name` from :attr:session_conf to
        :attr:sessions dictionary.
        """
        # we assume that the `visible` option is present
        visible = self.sessions_conf.get(session_name, VISIBLE)

        # `buffers` option is not required, prevent loading the default
        # buffers when the aforementioned option is not present
        if self.sessions_conf.has_option(session_name, BUFFERS):
            buffers = self.sessions_conf.get(session_name, BUFFERS)
        else:
            buffers = ''

        self.sessions[session_name] = {
            VISIBLE: visible,
            BUFFERS: buffers,
        }

    def populate(self, timeline_list, session=None):
        """Populate `timeline_list` with the session timelines."""
        session_name = configuration.session

        # read the `SESSIONS_FILE`
        self.sessions_conf.read(SESSIONS_FILE)

        if self.sessions_conf.has_section(session_name):
            self.load_from_session_conf(session_name)
            session_dict = self.sessions[session_name]
        else:
            # `configuration.session` does not exist, load default session
            session_dict = self.sessions[DEFAULT_SESSION]

        visible_names = session_dict[VISIBLE]
        buffers_names = session_dict[BUFFERS]

        self.append_visible_timelines(visible_names, timeline_list)
        self.append_background_timelines(buffers_names, timeline_list)

    def append_visible_timelines(self, visible_string, timeline_list):
        """"
        Given a `visible_string` with the names of the visible timelines,
        append them to `timeline_list` and make them all visible.
        """
        visible_names = clean_timeline_list_string(visible_string)

        # append first timeline (is always visible)
        first_timeline_name = visible_names.pop(0)
        first_timeline = self.factory(first_timeline_name)

        timeline_list.append_timeline(first_timeline)

        # append the rest of the visible timelines, expanding `timeline_list`
        # visible columns for showing the visible timelines
        for timeline_name in visible_names:
            timeline_list.append_timeline(self.factory(timeline_name))
            timeline_list.expand_visible_next()

    def append_background_timelines(self, buffers_string, timeline_list):
        """
        Given a `buffers_string` with the names of the timelines that should be
        loaded in the background, append them to `timeline_list`.
        """
        buffers_names = clean_timeline_list_string(buffers_string)

        for timeline_name in buffers_names:
            timeline_list.append_timeline(self.factory(timeline_name))

########NEW FILE########
__FILENAME__ = ui
# -*- coding: utf-8 -*-

"""
This module contains the curses UI widgets.
"""

import os
import logging
import re
from gettext import gettext as _
from htmlentitydefs import entitydefs


from urwid import (AttrMap, WidgetWrap, Padding, Divider, SolidFill,
                   WidgetDecoration, LineBox, Filler,

                   # widgets
                   Text, Edit, Frame, Columns, Pile, ListBox, SimpleListWalker,
                   Overlay,

                   # signals
                   signals, emit_signal, connect_signal, disconnect_signal)

from turses import version
from turses.config import (MOTION_KEY_BINDINGS, BUFFERS_KEY_BINDINGS,
                           TWEETS_KEY_BINDINGS, TIMELINES_KEY_BINDINGS,
                           META_KEY_BINDINGS, TURSES_KEY_BINDINGS,

                           configuration)
from turses.models import is_DM, TWEET_MAXIMUM_CHARACTERS
from turses.utils import encode, is_hashtag, is_username, is_url


def surround_with_spaces(s):
    return ' '.join(['', s , ''])

# - Text parsing --------------------------------------------------------------

def apply_attribute(string,
                    hashtag='hashtag',
                    attag='attag',
                    url='url'):
    """
    Apply an attribute to `string` dependending on wether it is
    a hashtag, a Twitter username or an URL.

    >>> apply_attribute('#Python')
    ('hashtag', u'#Python')
    >>> apply_attribute('@dialelo')
    ('attag', u'@dialelo')
    >>> apply_attribute('@dialelo',
                        attag='username')
    ('username', u'@dialelo')
    >>> apply_attribute('http://www.dialelo.com')
    ('url', u'http://www.dialelo.com')
    >>> apply_attribute('turses')
    u'turses'
    """
    string = unicode(string)

    if is_hashtag(string):
        return (hashtag, string)
    elif string.startswith('@') and is_username(string[1:]):
        return (attag, string)
    elif is_url(string):
        return (url, string)
    else:
        return string


def parse_attributes(text,
                     hashtag='hashtag',
                     attag='attag',
                     url='url'):
    """
    Parse the attributes in `text` and isolate the hashtags, usernames
    and URLs with the provided attributes.

    >>> text = 'I love #Python'
    >>> parse_attributes(text=text,
    ...                  hashtag='hashtag')
    ['I love ', ('hashtag', '#Python')]
    """

    # nothing to do
    if not text:
        return u''

    words = text.split()
    parsed_text = [apply_attribute(word) for word in words]

    def add_withespace(parsed_word):
        if isinstance(parsed_word, tuple):
            # is an (attr, word) tuple
            return parsed_word
        else:
            return parsed_word + ' '

    tweet = [add_withespace(parsed_word) for parsed_word in parsed_text]

    # insert spaces after an attribute
    indices = []
    for i, word in enumerate(tweet[:-1]):
        word_is_attribute = isinstance(word, tuple)

        if word_is_attribute:
            indices.append(i + 1 + len(indices))

    for index in indices:
        tweet.insert(index, u' ')

    # remove trailing withespace
    if tweet and isinstance(tweet[-1], basestring):
        tweet[-1] = tweet[-1][:-1]

    return tweet


def extract_attributes(entities, hashtag, attag, url):
    """
    Extract attributes from entities.

    Return a list with (`attr`, string[, replacement]) tuples for each
    entity in the status.
    """
    def map_attr(attr, entity_list):
        """
        Return a list with (`attr`, string) tuples for each string in
        `entity_list`.
        """
        url_format = configuration.styles['url_format']
        attributes = []
        for entity in entity_list:
            # urls are a special case, we change the URL shortened by
            # Twitter (`http://t.co/*`) by the URL returned in
            # `display_url`
            indices = entity.get('indices')
            is_url = entity.get('display_url', False)

            if is_url:
                # `display_url` is the default
                url = entity.get('display_url')
                if url_format == 'shortened':
                    url = entity.get('url')
                elif url_format == 'original' and 'expanded_url' in entity:
                    url = entity.get('expanded_url')
                mapping = (attr, indices, url)
            else:
                mapping = (attr, indices)
            attributes.append(mapping)
        return attributes

    entity_names_and_attributes = [
        ('user_mentions', attag),
        ('hashtags', hashtag),
        ('urls', url),
        ('media', url),
    ]

    attributes = []
    for entity_name, entity_attribute in entity_names_and_attributes:
        entity_list = entities.get(entity_name, [])
        attributes.extend(map_attr(entity_attribute, entity_list))

    # sort mappings to split the text in order
    attributes.sort(key=lambda mapping: mapping[1][0])

    return attributes


def map_attributes(status, hashtag, attag, url):
    """
    Return a list of strings and tuples for hashtag, attag and
    url entities.

    For a hashtag, its tuple would be (`hashtag`, text).

    >>> from datetime import datetime
    >>> s = Status(id=0,
    ...            created_at=datetime.now(),
    ...            user='dialelo',
    ...            text='I love #Python',)
    >>> map_attributes(s, 'hashtag', 'attag', 'url')
    ['I love ', ('hashtag', '#Python')]
    """
    is_retweet = getattr(status, 'is_retweet', False)

    if is_retweet:
        # call this method on the retweeted status
        return map_attributes(status.retweeted_status, hashtag, attag, url)

    if not status.entities:
        # no entities defined, parse text *manually*
        #  - Favorites don't include any entities at the time of writing
        text = status.retweeted_status.text if is_retweet else status.text
        return parse_attributes(text, hashtag, attag, url)

    # we have entities, extract the (attr, string[, replacement]) tuples
    assert status.entities
    attribute_mappings = extract_attributes(entities=status.entities,
                                            hashtag=hashtag,
                                            attag=attag,
                                            url=url)

    text = []
    status_text = unicode(status.text)
    # start from the beggining
    index = 0
    for mapping in attribute_mappings:
        attribute = mapping[0]
        starts, ends = mapping[1]

        # this text has an attribute associated
        entity_text = status_text[starts:ends]

        if attribute == url and len(mapping) == 3:
            ## if the text is a url and a third element is included in the
            ## tuple; the third element is the original URL
            entity_text = mapping[2]

        # append normal text before the text with an attribute
        normal_text = status_text[index:starts]
        if normal_text:
            text.append(normal_text)

        # append text with attribute
        text_with_attribute = (attribute, entity_text)
        text.append(text_with_attribute)

        # update index, continue from where the attribute text ends
        index = ends

    # after parsing all attributes we can have some text left
    normal_text = status_text[index:]
    if normal_text:
        text.append(normal_text)

    return text


# - Main UI -------------------------------------------------------------------


class CursesInterface(WidgetWrap):
    """
    Creates a curses interface for the program, providing functions to draw
    all the components of the UI.

    Provides a facade API to draw the representation of the
    :class:`~turses.models.TimelineList`, help :class:`HelpBuffer`
    and intro :class:`Banner` screens.
    """

    def __init__(self):
        self._editor = None

        # header
        header = TabsWidget()

        # body
        body = Banner()

        # footer
        self._status_bar = configuration.styles.get('status_bar', False)
        if self._status_bar:
            footer = StatusBar('')
        else:
            footer = None

        self.frame = Frame(body,
                           header=header,
                           footer=footer)

        super(CursesInterface, self).__init__(self.frame)

    def _build_overlay_widget(self,
                              top_w,
                              align,
                              width,
                              valign,
                              height,
                              min_width,
                              min_height):
        return Overlay(top_w=Filler(top_w),
                       bottom_w=self.frame,
                       align=align,
                       width=width,
                       valign=valign,
                       height=height,
                       min_width=width,
                       min_height=height)

    # -- Modes ----------------------------------------------------------------

    def draw_timelines(self, timelines):
        self.frame.body = TimelinesBuffer(timelines)
        self.frame.set_body(self.frame.body)

    def show_info(self):
        self.frame.header.clear()
        self.frame.body = Banner()
        self.frame.set_body(self.frame.body)

    def show_help(self):
        self.clear_header()
        self.status_info_message(_('type <esc> to leave the help page.'))
        self.frame.body = HelpBuffer()
        self.frame.set_body(self.frame.body)

    # -- Header ---------------------------------------------------------------

    def clear_header(self):
        self.frame.header.clear()

    def set_tab_names(self, names):
        self.frame.header.set_tabs(names)
        self.frame.set_header(self.frame.header)

    def activate_tab(self, index):
        self.frame.header.set_active_tab(index)
        self.frame.set_header(self.frame.header)

    def highlight_tabs(self, indexes):
        self.frame.header.set_visible_tabs(indexes)

    # -- Footer ---------------------------------------------------------------

    @property
    def can_write_status(self):
        if self._status_bar:
            if self.frame.footer is None:
                self.frame.footer = StatusBar('')
            return True
        return False

    def status_message(self, text):
        if self.can_write_status:
            self.frame.footer.message(text)
            self.frame.set_footer(self.frame.footer)

    def status_error_message(self, message):
        if self.can_write_status:
            self.frame.footer.error_message(message)

    def status_info_message(self, message):
        if self.can_write_status:
            self.frame.footer.info_message(message)

    def clear_status(self):
        self.frame.footer = None
        self.frame.set_footer(self.frame.footer)

    # -- Timeline mode --------------------------------------------------------

    def focus_timeline(self, index):
        """Give focus to the `index`-th visible timeline."""
        self.frame.body.focus_timeline(index)

    def focus_status(self, index):
        if callable(getattr(self.frame.body, 'set_focus', None)):
            self.frame.body.set_focus(index)

    def center_focus(self):
        if callable(getattr(self.frame.body, 'set_focus_valign', None)):
            logging.debug('centering focus')
            self.frame.body.set_focus_valign('middle')

    # -- motions --------------------------------------------------------------

    def focus_next(self):
        self.frame.body.scroll_down()

    def focus_previous(self):
        self.frame.body.scroll_up()

    def focus_first(self):
        self.frame.body.scroll_top()

    def focus_last(self):
        self.frame.body.scroll_bottom()

    # -- editors --------------------------------------------------------------

    def _show_editor(self,
                     editor_cls,
                     prompt,
                     content,
                     done_signal_handler,
                     **kwargs):
        self._editor = editor_cls(prompt=prompt,
                                  content=content,
                                  done_signal_handler=done_signal_handler,
                                  **kwargs)

        styles = configuration.styles
        horizontal_align = styles['editor_horizontal_align']
        vertical_align = styles['editor_vertical_align']

        self.show_widget_on_top(widget=self._editor,
                                width=80,
                                height=5,
                                align=horizontal_align,
                                valign=vertical_align,
                                min_height=5,)
        return self._editor

    def show_text_editor(self,
                         prompt='',
                         content='',
                         done_signal_handler=None,
                         cursor_position=None):
        return self._show_editor(TextEditor,
                                 prompt,
                                 content,
                                 done_signal_handler,
                                 cursor_position=cursor_position)

    def show_tweet_editor(self,
                          prompt='',
                          content='',
                          done_signal_handler=None,
                          cursor_position=None):
        return self._show_editor(TweetEditor,
                                 prompt,
                                 content,
                                 done_signal_handler,
                                 cursor_position=cursor_position)

    def show_dm_editor(self,
                       prompt='',
                       content='',
                       recipient='',
                       done_signal_handler=None):
        return self._show_editor(DmEditor,
                                 prompt,
                                 content,
                                 done_signal_handler,
                                 recipient=recipient,)

    def hide_editor(self, done_signal_handler):
        try:
            disconnect_signal(self._editor, 'done', done_signal_handler)
        except Exception, message:
            # `disconnect_signal` raises an exception if no signal was
            # connected from `self._editor`. we can safely ignore it.
            logging.exception(message)
        self._editor = None
        self.hide_widget_on_top()

    # - pop ups ---------------------------------------------------------------

    def show_user_info(self, user, last_statuses):
        widget = UserInfo(user, last_statuses)

        # TODO: adjust height to widget size
        self.show_widget_on_top(widget, width=50, height=28)

    def hide_user_info(self):
        self.hide_widget_on_top()

    def show_widget_on_top(self,
                           widget,
                           width,
                           height,
                           align='center',
                           valign='middle',
                           min_height=0,
                           min_width=0):
        """Show `widget` on top of :attr:`frame`."""
        self._w = self._build_overlay_widget(top_w=widget,
                                             align=align,
                                             width=width,
                                             valign=valign,
                                             height=height,
                                             min_width=min_width,
                                             min_height=min_height)

    def hide_widget_on_top(self):
        """Hide the topmost widget (if any)."""
        self._w = self.frame


# - Program info --------------------------------------------------------------


class Banner(WidgetWrap):
    """Displays information about the program."""

    def __init__(self):
        self.text = []

        help_key = configuration.key_bindings['help'][0]
        quit_key = configuration.key_bindings['quit'][0]
        home_dir = os.getenv("HOME", _("unknown"))

        self.BANNER = [
            "   _                             ",
            " _| |_ _   _ _ __ ___  ___  ____ ",
            "|_   _| | | | '__/ __|/   \/ ___|",
            "  | | | | | | |  |   \  ~ ||   \\ ",
            "  | |_| |_| | |  \__ |  __/\__ | ",
            "  \___|\____|_| |____/\___||___/ ",
            "  ······························ ",
            "{0}".format(version),
            "",
            "",
            _("Press '{0}' for help").format(help_key),
            _("Press '{0}' to quit turses").format(quit_key),
            "",
            "",
            _("Configuration and token files reside under"),
            _("your $HOME directory ({0})").format(home_dir),
            #"",
            "",
            "    ~                                              ",
            "    |+.turses/                                     ",
            "    | |-sessions                                   ",
            "    | |-config                                     ",
            _("    | |-token       # default account's token      "),
            _("    | `-bob.token   # another account's token      "),
            "    |+...                                          ",
            "",
            "",
        ]
        super(Banner, self).__init__(self._create_text())

    def _create_text(self):
        """Create the text to display in the welcome buffer."""
        self.text = []
        for line in self.BANNER:
            self._insert_line(line)

        return ScrollableListBox(self.text)

    def _insert_line(self, line):
        text = Text(line, align='center')
        self.text.append(text)


# - Editors -------------------------------------------------------------------


class BaseEditor(WidgetWrap):
    """Base class for editors."""

    __metaclass__ = signals.MetaSignals
    signals = ['done']

    def __init__(self,
                 prompt,
                 content,
                 done_signal_handler,
                 cursor_position=None):
        """
        Initializes editor, connects 'done' signal.

        When pressing 'enter' twice the `submit` method is called, which by
        default calls `emit_done_signal` with the text that has been
        introduced.

        When pressing 'esc' the `cancel` method is called, which by default
        calls `emit_done_signal` with no arguments.

        The subclasses must call the `_wrap` method with the editor widgets
        and `BaseEditor` will wrap it in a `urwid.Colums` widget, calling to
        `urwid.WidgetWrap.__init__` with the wrapped widget.
        """
        caption = _(u'{0} (Enter key twice to validate, '
                    u'Esc or Ctrl-C to cancel) \n>> ').format(prompt)
        if content:
            content += ' '
        self.content = content
        self.editor = Edit(caption=caption,
                           edit_text=content,
                           edit_pos=cursor_position)
        self.last_key = None

        connect_signal(self, 'done', done_signal_handler)

    def _wrap(self, widgets):
        widgets = widgets if isinstance(widgets, list) else [widgets]
        composed_widget = Columns(widgets)

        widget = AttrMap(LineBox(composed_widget), 'editor')
        super(BaseEditor, self).__init__(widget)

    def keypress(self, size, key):
        if key == 'enter' and self.last_key == 'enter':
            self.submit()
            return
        elif key == 'esc':
            self.cancel()
            return

        self.last_key = key
        size = size,
        self.editor.keypress(size, key)

    def submit(self):
        self.emit_done_signal(self.editor.get_edit_text())

    def cancel(self):
        self.emit_done_signal()

    def emit_done_signal(self, content=None):
        emit_signal(self, 'done', content)


class TextEditor(BaseEditor):
    """Editor for creating arbitrary text."""

    __metaclass__ = signals.MetaSignals
    signals = ['done']

    def __init__(self,
                 prompt,
                 content,
                 done_signal_handler,
                 cursor_position=None):
        super(TextEditor, self).__init__(prompt,
                                         content,
                                         done_signal_handler,
                                         cursor_position)
        self._wrap(self.editor)


class TweetEditor(BaseEditor):
    """Editor for creating tweets."""

    __metaclass__ = signals.MetaSignals
    signals = ['done']

    def __init__(self,
                 prompt,
                 content,
                 done_signal_handler,
                 cursor_position=None):
        super(TweetEditor, self).__init__(prompt,
                                          content,
                                          done_signal_handler,
                                          cursor_position)

        self.counter = len(self.content)
        self.counter_widget = Text(str(self.counter))

        connect_signal(self.editor, 'change', self.update_counter)

        widgets = [('fixed', 4, self.counter_widget), self.editor]
        self._wrap(widgets)

    def update_counter(self, edit, new_edit_text):
        self.counter = len(new_edit_text)
        self.counter_widget.set_text(str(self.counter))

    def submit(self):
        if self.counter > TWEET_MAXIMUM_CHARACTERS:
            return
        else:
            self.emit_done_signal(self.editor.get_edit_text())


class DmEditor(TweetEditor):
    """Editor for creating DMs."""

    __metaclass__ = signals.MetaSignals
    signals = ['done']

    def __init__(self,
                 recipient,
                 prompt,
                 content,
                 done_signal_handler):
        self.recipient = recipient
        super(DmEditor, self).__init__(prompt='DM to {0}'.format(recipient),
                                       content='',
                                       done_signal_handler=done_signal_handler)

    def emit_done_signal(self, content=None):
        emit_signal(self, 'done', self.recipient, content)


# - Header and footer ---------------------------------------------------------


class TabsWidget(WidgetWrap):
    """
    A widget that renders tabs with the given strings as titles.

    One of them is highlighted as the active tab.
    """

    def __init__(self, tabs=[]):
        """Creates tabs with the names given in `tabs`."""
        self.tabs = tabs
        if tabs:
            self.active_index = 0
            self.visible_indexes = [0]
        else:
            self.active_index = -1
            self.visible_indexes = []
        created_text = self._create_text()
        text = created_text if created_text else ''
        super(TabsWidget, self).__init__(Text(text))

    def _is_valid_index(self, index):
        return index >= 0 and index < len(self.tabs)

    def _create_text(self):
        """Creates the text that is rendered as the tab list."""
        text = []
        for i, tab in enumerate(self.tabs):
            if i == self.active_index:
                text.append(('active_tab', u'│' + tab + u' '))
            elif i in self.visible_indexes:
                text.append(('visible_tab', u'│' + tab + u' '))
            else:
                text.append(('inactive_tab', u'│' + tab + u' '))
        return text

    def _update_text(self):
        text = self._create_text()
        self._w = Text(text)

    def append_tab(self, tab):
        self.tabs.append(unicode(tab))
        self._update_text()

    def delete_current_tab(self):
        del self.tabs[self.active_index]
        self._update_text()

    def set_active_tab(self, pos):
        self.active_index = pos
        self._update_text()

    def set_visible_tabs(self, indexes):
        self.visible_indexes = list(indexes)
        self._update_text()

    def set_tabs(self, tabs):
        self.tabs = tabs
        self._update_text()

    def clear(self):
        self._w.set_text('')


class StatusBar(WidgetWrap):
    """Displays text."""

    INFO = "[INFO]"
    ERROR = "[ERROR]"
    ARROW = " => "

    def __init__(self, text=''):
        super(StatusBar, self).__init__(Text(text))

    def message(self, text):
        """Write `text` on the footer."""
        self._w.set_text(text)

    def error_message(self, text):
        self.message([('error', self.ERROR),
                      ('default', self.ARROW + text)])

    def info_message(self, text):
        self.message([('info', self.INFO),
                      ('default', self.ARROW + text)])

    def clear(self):
        """Clear the text."""
        self._w.set_text('')


# - Base list widgets ---------------------------------------------------------


class Scrollable:
    """A interface that makes widgets *scrollable*."""
    def scroll_up(self):
        raise NotImplementedError

    def scroll_down(self):
        raise NotImplementedError

    def scroll_top(self):
        raise NotImplementedError

    def scroll_bottom(self):
        raise NotImplementedError


class ScrollableListBox(ListBox, Scrollable):
    """
    A ``urwid.ListBox`` subclass that implements the
    :class:`~turses.ui.Scrollable` interface.
    """
    def __init__(self,
                 contents,
                 offset=1):
        """
        Arguments:

        `contents` is a list with the elements contained in the
        `ScrollableListBox`.

        `offset` is the number of position that `scroll_up` and `scroll_down`
        shift the cursor.
        """
        self.offset = offset

        ListBox.__init__(self,
                         SimpleListWalker(contents))

    def scroll_up(self):
        focus_status, pos = self.get_focus()
        if pos is None:
            return

        new_pos = pos - self.offset
        if new_pos < 0:
            new_pos = 0
        self.set_focus(new_pos)

    def scroll_down(self):
        focus_status, pos = self.get_focus()
        if pos is None:
            return

        new_pos = pos + self.offset
        if new_pos >= len(self.body):
            new_pos = len(self.body) - 1
        self.set_focus(new_pos)

    def scroll_top(self):
        if len(self.body):
            self.set_focus(0)

    def scroll_bottom(self):
        last = len(self.body) - 1
        if last:
            self.set_focus(last)


class ScrollableWidgetWrap(WidgetWrap, Scrollable):
    """
    A ``urwid.WidgetWrap`` for :class:`~turses.ui.Scrollable`, list-like
    widgets.
    """
    def __init__(self, contents=None):
        columns = [] if contents is None else contents
        WidgetWrap.__init__(self, columns)

    def scroll_up(self):
        self._w.scroll_up()

    def scroll_down(self):
        self._w.scroll_down()

    def scroll_top(self):
        self._w.scroll_top()

    def scroll_bottom(self):
        self._w.scroll_bottom()


# - Help ----------------------------------------------------------------------


class HelpBuffer(ScrollableWidgetWrap):
    """
    A widget that displays all the keybindings of the given configuration.
    """

    col = [30, 7]

    def __init__(self):
        self.items = []
        self.create_help_buffer()

        offset = int(len(self.items) / 5)
        ScrollableWidgetWrap.__init__(self,
                                      ScrollableListBox(self.items,
                                                        offset=offset,))

    def _insert_bindings(self, bindings):
        for label in bindings:
            values = configuration.key_bindings[label]
            key, description = values[0], values[1]
            widgets = [
                ('fixed', self.col[0], Text('  ' + label)),
                ('fixed', self.col[1], Text(key)),
                Text(description)
            ]
            self.items.append(Columns(widgets))

    def create_help_buffer(self):
        self.insert_header()

        self.insert_title(_('Motion'))
        self._insert_bindings(MOTION_KEY_BINDINGS)

        self.insert_title(_('Buffers'))
        self._insert_bindings(BUFFERS_KEY_BINDINGS)

        self.insert_title(_('Tweets'))
        self._insert_bindings(TWEETS_KEY_BINDINGS)

        self.insert_title(_('Timelines'))
        self._insert_bindings(TIMELINES_KEY_BINDINGS)

        self.insert_title(_('Meta'))
        self._insert_bindings(META_KEY_BINDINGS)

        self.insert_title(_('Turses'))
        self._insert_bindings(TURSES_KEY_BINDINGS)

    def insert_header(self):
        widgets = [
            ('fixed', self.col[0], Text(_('  NAME'))),
            ('fixed', self.col[1], Text(_('KEY'))),
            Text(_('DESCRIPTION')),
        ]
        self.items.append(Columns(widgets))
        self.items.append(Divider('·'))

    def insert_title(self, title):
        self.items.append(Divider(' '))
        self.items.append(Padding(AttrMap(Text(title), 'focus'), left=4))


# - Timelines -----------------------------------------------------------------


class TimelinesBuffer(ScrollableWidgetWrap):
    """
    A widget that displays one or more `Timeline` objects.

    Another widget can be placed on top of it.
    """

    def __init__(self, timelines=None, **kwargs):
        timelines = [] if timelines is None else timelines

        widget = self._build_widget(timelines, **kwargs)

        ScrollableWidgetWrap.__init__(self, widget)

    def _build_widget(self, timelines, **kwargs):
        timeline_widgets = [TimelineWidget(timeline, **kwargs) for timeline in timelines]
        return Columns(timeline_widgets)

    def render_timelines(self, timelines, **kwargs):
        """Render the given statuses."""
        self._w = self._build_widget(timelines, **kwargs)

    @property
    def columns(self):
        """
        The `Columns` widget.
        """
        return self._w

    @property
    def active_widget(self):
        """
        The active widget.
        """
        return self.columns.get_focus()

    def scroll_up(self):
        self.active_widget.scroll_up()

    def scroll_down(self):
        self.active_widget.scroll_down()

    def scroll_top(self):
        self.active_widget.scroll_top()

    def scroll_bottom(self):
        self.active_widget.scroll_bottom()

    def clear(self):
        """Clears the buffer."""
        # TODO
        pass

    def set_focus(self, index):
        self.active_widget.set_focus(index)

    def set_focus_valign(self, valign):
        self.active_widget.set_focus_valign(valign)

    def focus_timeline(self, index):
        self.columns.set_focus_column(index)

    # XXX:
    #  All keypresses are ignored so `turses.core.InputHandler` can handle
    #  every keystroke. I tried to filter the input in `urwid`s `MainLoop`
    #  but did not work as expected.
    def keypress(self, size, key):
        return key


class TimelineWidget(ScrollableListBox):
    """
    A :class:`ScrollableListBox` containing a list of Twitter statuses, each of
    which is rendered as a :class:`StatusWidget`.
    """

    def __init__(self, timeline=None):
        statuses = timeline if timeline else []
        status_widgets = [StatusWidget(status) for status in statuses]
        ScrollableListBox.__init__(self, status_widgets)


class StatusWidget(WidgetWrap):
    """Widget containing a Twitter status."""

    def __init__(self, status):
        self.status = status

        header_text = self._create_header(status)
        text = map_attributes(status,
                              hashtag='hashtag',
                              attag='attag',
                              url='url')

        is_favorite = not is_DM(status) and status.is_favorite
        widget = self._build_widget(header_text, text, is_favorite)

        self.__super.__init__(widget)

    def _build_widget(self, header_text, text, favorite=False):
        """Return the wrapped widget."""
        box_around_status = configuration.styles.get('box_around_status', True)
        divider = configuration.styles.get('status_divider', False)

        header = AttrMap(Text(header_text), 'header')
        sanitized_text = [sanitize(t) for t in text] if isinstance(text, list) else sanitize(text)
        body = Padding(AttrMap(Text(sanitized_text), 'body'), left=1, right=1)

        border_attr = 'line'
        if favorite:
            border_attr = 'favorited'

        if box_around_status:
            # draw a box around the status
            # focusing the first item both dividers are highlighted
            # on focus
            widget = AttrMap(BoxDecoration(body, title=header_text),
                             border_attr, 'focus')
        elif divider:
            # use a divider
            # we focus the divider to change colors when this
            # widget is focused
            styles = configuration.styles
            status_divider = styles.get('status_divider_char', '·')

            divider = AttrMap(Divider(status_divider),
                              border_attr,
                              'focus')
            widget = Pile([header, body, divider], focus_item=2)
        else:
            widget = Pile([header, body], focus_item=1)
        return widget

    def selectable(self):
        return True

    def keypress(self, size, key):
        return key

    def _create_header(self, status):
        """
        Return the header text for the status associated with this widget.
        """
        if is_DM(status):
            return self._dm_header(status)

        reply = ''
        retweeted = ''
        retweet_count = ''
        retweeter = ''
        username = status.user
        relative_created_at = status.relative_created_at

        # reply
        if status.is_reply:
            reply = surround_with_spaces(configuration.styles['reply_indicator'])

        # retweet
        if status.is_retweet:
            retweeted = surround_with_spaces(configuration.styles['retweet_indicator'])
            # `username` is the author of the original tweet
            username = status.author
            # `retweeter` is the user who made the RT
            retweeter = status.user
            retweet_count = str(status.retweet_count)

        # create header
        styles = configuration.styles
        header_template = ' ' + styles.get('header_template') + ' '
        header = unicode(header_template).format(
            username=username,
            retweeted=retweeted,
            retweeter=retweeter,
            time=relative_created_at,
            reply=reply,
            retweet_count=retweet_count,
        )

        return encode(header)

    def _dm_header(self, dm):
        dm_template = ''.join([' ', configuration.styles['dm_template'], ' '])
        relative_created_at = dm.relative_created_at
        header = unicode(dm_template).format(
            sender_screen_name=dm.sender_screen_name,
            recipient_screen_name=dm.recipient_screen_name,
            time=relative_created_at,
        )

        return encode(header)


class BoxDecoration(WidgetDecoration, WidgetWrap):
    """Draw a box around `original_widget`."""

    def __init__(self, original_widget, title="",
                 tlcorner=u'┌', tline=u'─', lline=u'│',
                 trcorner=u'┐', blcorner=u'└', rline=u'│',
                 bline=u'─', brcorner=u'┘'):
        """
        Use 'title' to set an initial title text with will be centered
        on top of the box.

        You can also override the widgets used for the lines/corners:
            tline: top line
            bline: bottom line
            lline: left line
            rline: right line
            tlcorner: top left corner
            trcorner: top right corner
            blcorner: bottom left corner
            brcorner: bottom right corner
        """

        tline, bline = Divider(tline), Divider(bline)
        lline, rline = SolidFill(lline), SolidFill(rline)
        tlcorner, trcorner = Text(tlcorner), Text(trcorner)
        blcorner, brcorner = Text(blcorner), Text(brcorner)

        title_widget = ('fixed', len(title), AttrMap(Text(title), 'header'))
        top = Columns([
            ('fixed', 1, tlcorner),
            title_widget,
            tline,
            ('fixed', 1, trcorner)
        ])

        middle = Columns([('fixed', 1, lline),
                          original_widget,
                          ('fixed', 1, rline)],
                         box_columns=[0, 2],
                         focus_column=1)

        bottom = Columns([('fixed', 1, blcorner),
                          bline,
                          ('fixed', 1, brcorner)])

        pile = Pile([('flow', top),
                    middle,
                    ('flow', bottom)],
                    focus_item=1)

        # super?
        WidgetDecoration.__init__(self, original_widget)
        WidgetWrap.__init__(self, pile)


# - User ----------------------------------------------------------------------


class UserInfo(WidgetWrap):
    """
    A widget for displaying a Twitter user info.
    """

    __metaclass__ = signals.MetaSignals
    signals = ['done']

    def __init__(self, user, last_statuses):
        """
        Receive a ``user`` and its ``last_statuses`` to render the widget.
        """
        whitespace = Divider(' ')
        widgets = [Text(u"{0}".format(user.name)), whitespace]

        # bio
        if user.description:
            description = Text(parse_attributes(user.description))
            widgets.extend([description, whitespace])

        # URL
        if user.url:
            url_text_with_attr = ('url', user.url)
            url = Text(url_text_with_attr)

            widgets.extend([url, whitespace])

        # statistics: following, followers and favorites
        # TODO: tweet count
        following = Text(_('following:\n{0}'.format(user.friends_count)))
        followers = Text(_('followers:\n{0}'.format(user.followers_count)))
        favorites = Text(_('favorites:\n{0}'.format(user.favorites_count)))
        stats = Columns([following, followers, favorites])

        widgets.extend([stats, whitespace])

        # Last n statuses
        # TODO: make it configurable
        statuses_to_show = configuration.styles['statuses_in_user_info']
        status_widgets = [StatusWidget(status) for status in last_statuses[:statuses_to_show]]
        widgets.extend(status_widgets)

        pile = Pile(widgets)

        super(UserInfo, self).__init__(LineBox(title='@{0}'.format(user.screen_name),
                                       original_widget=pile))


def sanitize(text):
    if isinstance(text, unicode):
        return html_unescape(text)
    else:
        return text

def html_unescape(string):
    """Unescape HTML entities from ``string``."""
    def entity_replacer(m):
        entity = m.group(1)
        if entity in entitydefs:
            return entitydefs[entity]
        else:
            return m.group(0)

    return re.sub(r'&([^;]+);', entity_replacer, string)


########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-

"""
This module contains functions used across different modules.
"""

from re import findall
from re import compile as compile_regex
from subprocess import call
from sys import stdout
from os import devnull
from functools import partial


URL_REGEX = compile_regex('http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|'
                          '(?:%[0-9a-fA-F][0-9a-fA-F]))+')


def matches_word(regex, word):
    """
    Return `True` if the whole `word` is matched by `regex`, `False`
    otherwise.
    """
    match = regex.match(word)
    if match:
        return match.start() == 0 and match.end() == len(word)
    return False

# username
username_regex = compile_regex(r'[A-Za-z0-9_]+')
is_username = partial(matches_word, username_regex)
sanitize_username = partial(filter, is_username)
prepend_at = lambda username: '@%s' % username

# hashtag
hashtag_regex = compile_regex(r'#.+')
is_hashtag = partial(matches_word, hashtag_regex)

# URL
is_url = partial(matches_word, URL_REGEX)


def get_urls(text):
    return findall(URL_REGEX, text)


def encode(string):
    try:
        return string.encode(stdout.encoding, 'replace')
    except (AttributeError, TypeError):
        return string

# For Python < 2.7
# Code borrowed from python 2.7.3 stdlib
def total_ordering(cls):
    """Class decorator that fills in missing ordering methods"""
    convert = {
        '__lt__': [('__gt__', lambda self, other: not (self < other or self == other)),
                   ('__le__', lambda self, other: self < other or self == other),
                   ('__ge__', lambda self, other: not self < other)],
        '__le__': [('__ge__', lambda self, other: not self <= other or self == other),
                   ('__lt__', lambda self, other: self <= other and not self == other),
                   ('__gt__', lambda self, other: not self <= other)],
        '__gt__': [('__lt__', lambda self, other: not (self > other or self == other)),
                   ('__ge__', lambda self, other: self > other or self == other),
                   ('__le__', lambda self, other: not self > other)],
        '__ge__': [('__le__', lambda self, other: (not self >= other) or self == other),
                   ('__gt__', lambda self, other: self >= other and not self == other),
                   ('__lt__', lambda self, other: not self >= other)]
    }
    roots = set(dir(cls)) & set(convert)
    if not roots:
        raise ValueError('must define at least one ordering operation: < > <= >=')
    root = max(roots) # prefer __lt__ to __le__ to __gt__ to __ge__
    for opname, opfunc in convert[root]:
        if opname not in roots:
            opfunc.__name__ = opname
            opfunc.__doc__ = getattr(int, opname).__doc__
            setattr(cls, opname, opfunc)
    return cls

########NEW FILE########
