__FILENAME__ = bench_line_reading
import sys
from collections import defaultdict

from six.moves import xrange

from zero_buffer import Buffer, BufferCollator, BufferFull


N = 100


def run_py_bench():
    d = defaultdict(int)
    with open("/usr/share/dict/words") as f:
        for line in f:
            d[line[0]] += 1


def run_zero_buffer_bench():
    d = defaultdict(int)
    cur_buffer = Buffer.alloc(8192)
    last_pos = 0
    collator = BufferCollator()
    with open("/usr/share/dict/words") as f:
        done = False
        while not done:
            try:
                read = cur_buffer.read_from(f.fileno())
            except BufferFull:
                cur_buffer = Buffer.alloc(8192)
                last_pos = 0
                continue
            except EOFError:
                read = 0
                done = True
            view = cur_buffer.view(last_pos, last_pos + read)
            last_pos += read
            collator.append(view)
            if b"\n" in view:
                data = collator.collapse()
                last_newline_pos = data.rfind(b"\n")
                for line in data[:last_newline_pos].split(b"\n"):
                    d[chr(line[0])] += 1
                collator.append(data[last_newline_pos + 1:])


def main(argv):
    name = argv[1]
    if name == "py":
        for i in xrange(N):
            run_py_bench()
    elif name == "zero_buffer":
        for i in xrange(N):
            run_zero_buffer_bench()
    else:
        raise SystemExit("argv[1] should be either py or zero_buffer")

if __name__ == "__main__":
    main(sys.argv)

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Zero Buffer documentation build configuration file, created by
# sphinx-quickstart on Mon Oct  7 14:44:39 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Zero Buffer'
copyright = u'2013, Alex Gaynor and David Reid'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'ZeroBufferdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'ZeroBuffer.tex', u'Zero Buffer Documentation',
   u'Alex Gaynor and David Reid', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'zerobuffer', u'Zero Buffer Documentation',
     [u'Alex Gaynor and David Reid'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'ZeroBuffer', u'Zero Buffer Documentation',
   u'Alex Gaynor and David Reid', 'ZeroBuffer', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = tasks
from invoke import task, run


@task
def release(version):
    """
    Version should be a string like '0.4' or '1.0'
    """
    run('git tag -s "{}"'.format(version))
    run('python setup.py sdist')
    run('twine upload -s dist/zero_buffer-{}*'.format(version))

########NEW FILE########
__FILENAME__ = test_zero_buffer
import errno

import pytest

from zero_buffer import Buffer, BufferView, BufferCollator, BufferFull


@pytest.fixture
def buf():
    return Buffer.allocate(16)


class TestBuffer(object):
    def test_read_from(self, buf, tmpdir):
        t = tmpdir.join("t.txt")
        t.write("abc123")
        with t.open() as f:
            res = buf.read_from(f.fileno())
            assert res == 6
        assert buf.writepos == 6

    def test_read_from_error(self, buf):
        with pytest.raises(OSError) as exc_info:
            buf.read_from(-1)
        assert exc_info.value.errno == errno.EBADF

    def test_read_from_eof(self, buf, tmpdir):
        t = tmpdir.join("t.txt")
        t.write("")
        with t.open() as f:
            with pytest.raises(EOFError):
                buf.read_from(f.fileno())

    def test_read_from_end_of_buffer(self, buf, tmpdir):
        t = tmpdir.join("t.txt")
        t.write("a" * 16)
        with t.open() as f:
            buf.read_from(f.fileno())
        with t.open() as f:
            with pytest.raises(BufferFull):
                buf.read_from(f.fileno())

    def test_free(self, buf, tmpdir):
        t = tmpdir.join("t.txt")
        t.write("abc")
        assert buf.free == 16
        with t.open() as f:
            buf.read_from(f.fileno())
            assert buf.free == 13

    def test_capacity(self, buf):
        assert buf.capacity == 16
        buf.add_bytes(b"abc")
        assert buf.capacity == 16

    def test_add_bytes(self, buf):
        res = buf.add_bytes(b"abc")
        assert res == 3
        assert buf.writepos == 3

    def test_add_bytes_longer_than_buffer(self, buf):
        res = buf.add_bytes(b"a" * 20)
        assert res == 16
        assert buf.writepos == 16

    def test_add_bytes_buffer_full(self, buf):
        buf.add_bytes(b"a" * 16)
        with pytest.raises(BufferFull):
            buf.add_bytes(b"abc")

    def test_view(self, buf):
        buf.add_bytes(b"abc")
        view = buf.view(0, 3)
        assert isinstance(view, BufferView)
        view = buf.view()
        assert isinstance(view, BufferView)

    @pytest.mark.parametrize(("start", "stop"), [
        (3, 0),
        (10, 11),
        (0, 11),
        (-2, 0),
        (0, -2),
    ])
    def test_invalid_views(self, buf, start, stop):
        buf.add_bytes(b"abc123")
        with pytest.raises(ValueError):
            buf.view(start, stop)

    def test_writepos_assign(self, buf):
        with pytest.raises(AttributeError):
            buf.writepos = 12

    def test_repr(self, buf):
        buf.add_bytes(b"abc")
        assert repr(buf) == "Buffer(data=[97, 98, 99], capacity=16, free=13)"


class TestBufferView(object):
    def test_bytes(self, buf):
        buf.add_bytes(b"abc")
        assert bytes(buf.view()) == b"abc"

    def test_repr(self, buf):
        buf.add_bytes(b"abc")
        assert repr(buf.view()) == "BufferView(data=[97, 98, 99])"

    def test_equality(self, buf):
        buf.add_bytes(b"abc")
        assert buf.view() == buf.view()
        assert buf.view() != buf.view(0, 2)
        assert not (buf.view() == buf.view(0, 2))
        assert not (buf.view(0, 2) == buf.view(1, 3))
        assert not (buf.view(0, 2) != buf.view(0, 2))

    def test_equality_bytes(self, buf):
        buf.add_bytes(b"abc")
        assert buf.view() == b"abc"
        assert buf.view() != b"abd"
        assert not (buf.view() != b"abc")
        assert not (buf.view() == b"abd")
        assert buf.view() != b"ab"
        assert not (buf.view() == b"ab")

    def test_equality_other(self, buf):
        assert buf.view() != []

    def test_contains(self, buf):
        buf.add_bytes(b"abc")
        view = buf.view()
        assert b"a" in view
        assert b"d" not in view

    def test_find_char(self, buf):
        buf.add_bytes(b"abc")
        view = buf.view()
        assert view.find(b"a") == 0
        assert view.find(b"c") == 2
        assert view.find(b"d") == -1

    def test_find_char_offsets(self, buf):
        buf.add_bytes(b"abcdefghijklm")
        view = buf.view()
        assert view.find(b"a", 1) == -1
        assert view.find(b"c", 2) == 2
        assert view.find(b"d", 2, 4) == 3
        assert view.find(b"e", 2, 3) == -1
        assert view.find(b"m", 0, 20) == 12
        assert view.find(b"a", -1) == 0
        assert view.find(b"a", 3, 2) == -1

    def test_find_empty_bytes(self, buf):
        buf.add_bytes(b"abc")
        view = buf.view()
        assert view.find(b"") == 0
        assert view.find(b"", 2) == 2

    def test_find_bytes(self, buf):
        buf.add_bytes(b"abc123")
        view = buf.view()
        assert view.find(b"cc") == -1
        assert view.find(b"ab") == 0
        assert view.find(b"c1") == 2
        buf.add_bytes(b"aabbcc")
        view = buf.view()
        assert view.find(b"aa") == 6
        assert view.find(b"abb") == 7

    def test_index(self, buf):
        buf.add_bytes(b"abc123")
        view = buf.view()
        assert view.index(b"b") == 1
        with pytest.raises(ValueError):
            view.index(b"d")

    def test_rfind_empty(self, buf):
        view = buf.view()
        assert view.rfind(b"") == 0

    def test_rfind_char(self, buf):
        buf.add_bytes(b"abc123")
        view = buf.view()
        assert view.rfind(b"c") == 2
        assert view.rfind(b"3") == 5
        assert view.rfind(b"4") == -1
        assert view.rfind(b"3", -2) == 5
        assert view.rfind(b"2", 0, 10) == 4
        assert view.rfind(b"2", 10, 0) == -1

    def test_rfind_bytes(self, buf):
        buf.add_bytes(b"123abc123")
        view = buf.view()
        assert view.rfind(b"cc") == -1
        assert view.rfind(b"23") == 7
        assert view.rfind(b"124") == -1

    def test_rindex(self, buf):
        buf.add_bytes(b"abc")
        view = buf.view()
        assert view.rindex(b"c") == 2
        with pytest.raises(ValueError):
            view.rindex(b"d")

    def test_subscript_slice(self, buf):
        buf.add_bytes(b"abc123")
        view = buf.view()
        assert view[:3] == b"abc"
        assert view[3:] == b"123"
        assert view[2:3] == b"c"
        with pytest.raises(ValueError):
            view[2:2:2]
        with pytest.raises(ValueError):
            view[3:2]

    def test_subscript(self, buf):
        buf.add_bytes(b"abc123")
        view = buf.view()
        assert view[0] == ord(b"a")
        assert view[-1] == ord(b"3")
        with pytest.raises(IndexError):
            view[7]
        with pytest.raises(IndexError):
            view[-7]

    def test_split_char(self, buf):
        buf.add_bytes(b"a-b-c")
        view = buf.view()
        assert list(view.split(b"-")) == [b"a", b"b", b"c"]

    def test_split_char_maxsplit(self, buf):
        buf.add_bytes(b"a-b-c")
        view = buf.view()
        assert list(view.split(b"-", 1)) == [b"a", b"b-c"]

    def test_split_empty(self, buf):
        view = buf.view()
        with pytest.raises(ValueError):
            view.split(b"")

    def test_split_bytes(self, buf):
        buf.add_bytes(b"a::b::c")
        view = buf.view()
        assert list(view.split(b"::")) == [b"a", b"b", b"c"]

    def test_split_bytes_maxsplit(self, buf):
        buf.add_bytes(b"a::b::c")
        view = buf.view()
        assert list(view.split(b"::", 1)) == [b"a", b"b::c"]

    def test_splitlines(self):
        b = Buffer.allocate(32)
        b.add_bytes(b"abc\ndef\n\rghi")
        assert list(b.view().splitlines()) == [b"abc", b"def", b"", b"ghi"]

        b = Buffer.allocate(32)
        b.add_bytes(b"abc\ndef\r\nghi")
        assert list(b.view().splitlines()) == [b"abc", b"def", b"ghi"]

        b = Buffer.allocate(32)
        b.add_bytes(b"\nabc\ndef\r\nghi\n\r")
        assert list(b.view().splitlines(True)) == [
            b"\n", b"abc\n", b"def\r\n", b"ghi\n", b"\r"
        ]

    def test_strip_default_chars(self, buf):
        buf.add_bytes(b" \t\r\n\f\vabc\t\r\n\f\v ")
        view = buf.view()
        assert view.strip() == b"abc"

    def test_strip(self, buf):
        buf.add_bytes(b"abc123")
        view = buf.view()
        assert view.strip(b"ab3") == b"c12"

    def test_rstrip_default_chars(self, buf):
        buf.add_bytes(b" \t\r\n\f\vabc\t\r\n\f\v ")
        view = buf.view()
        assert view.rstrip() == b" \t\r\n\f\vabc"

    def test_lstrip_default_chars(self, buf):
        buf.add_bytes(b" \t\r\n\f\vabc\t\r\n\f\v ")
        view = buf.view()
        assert view.lstrip() == b"abc\t\r\n\f\v "

    def test_lstrip(self, buf):
        buf.add_bytes(b"abc123")
        view = buf.view()
        assert view.lstrip(b"ab3") == b"c123"

    def test_rstrip(self, buf):
        buf.add_bytes(b"abc123")
        view = buf.view()
        assert view.rstrip(b"ab3") == b"abc12"

    def test_isspace(self, buf):
        buf.add_bytes(b"a\t\r\n\f\v ")
        view = buf.view()
        assert not view[:1].isspace()
        assert view[1:].isspace()
        assert not buf.view(0, 0).isspace()
        assert not buf.view(0, 2).isspace()

    def test_iteration(self, buf):
        buf.add_bytes(b"abc")
        view = buf.view()
        assert list(view) == [ord(b"a"), ord(b"b"), ord(b"c")]

    def test_isdigit(self, buf):
        buf.add_bytes(b"123abc")
        assert not buf.view().isdigit()
        assert buf.view(0, 3).isdigit()
        assert not buf.view(0, 0).isdigit()

    def test_isalpha(self, buf):
        buf.add_bytes(b"abc123")
        assert not buf.view().isalpha()
        assert buf.view(0, 3).isalpha()
        assert not buf.view(0, 0).isalpha()

    def test_add_contigious(self, buf):
        buf.add_bytes(b"abc123")
        assert (buf.view(0, 3) + buf.view(3, 6)) == buf.view()

    def test_add_discontigious(self, buf):
        buf.add_bytes(b"abc123")
        bg = buf.view(0, 2) + buf.view(3, 6)
        assert bg == b"ab123"

    def test_add_typeerror(self, buf):
        view = buf.view()
        with pytest.raises(TypeError):
            view + 3

    def test_write_to(self, buf, tmpdir):
        buf.add_bytes(b"abcd")
        view = buf.view()
        with tmpdir.join("t.txt").open("wb") as f:
            res = view.write_to(f.fileno())
        assert res == 4
        assert tmpdir.join("t.txt").read("rb") == b"abcd"

    def test_write_to_badfd(self, buf):
        buf.add_bytes(b"abcd")
        view = buf.view()
        with pytest.raises(OSError) as exc_info:
            view.write_to(-1)
        assert exc_info.value.errno == errno.EBADF

    def test_write_to_empty_bytes(self, buf, tmpdir):
        view = buf.view()
        with tmpdir.join("t.txt").open("wb") as f:
            res = view.write_to(f.fileno())
        assert res == 0
        assert tmpdir.join("t.txt").read("rb") == b""


class TestBufferCollator(object):
    def test_single_item(self, buf):
        view = buf.view()
        collator = BufferCollator()
        collator.append(view)
        assert collator.collapse() is view

    def test_collapse_clears(self, buf):
        buf.add_bytes(b"abc")
        view = buf.view()
        collator = BufferCollator()
        collator.append(view)
        collator.collapse()
        view = collator.collapse()
        assert len(view) == 0

    def test_len(self, buf):
        buf.add_bytes(b"abc")
        view = buf.view()
        collator = BufferCollator()
        collator.append(view)
        collator.append(view)
        assert len(collator) == 6

########NEW FILE########
__FILENAME__ = zero_buffer
import os

import six
from six.moves import xrange

import cffi


_ffi = cffi.FFI()
_ffi.cdef("""
ssize_t read(int, void *, size_t);
ssize_t write(int, const void *, size_t);

int memcmp(const void *, const void *, size_t);
void *memchr(const void *, int, size_t);
void *Zero_memrchr(const void *, int, size_t);
void *memcpy(void *, const void *, size_t);
""")
_lib = _ffi.verify("""
#include <string.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>

#ifdef __GNU_SOURCE
#define Zero_memrchr memrchr
#else
void *Zero_memrchr(const void *s, int c, size_t n) {
    const unsigned char *cp;
    if (n != 0) {
        cp = (unsigned char *)s + n;
        do {
            if (*(--cp) == (unsigned char)c) {
                return (void *)cp;
            }
        } while (--n != 0);
    }
    return NULL;
}
#endif
""", extra_compile_args=["-D_GNU_SOURCE"])

BLOOM_WIDTH = _ffi.sizeof("long") * 8


class BufferFull(Exception):
    pass


class Buffer(object):
    def __init__(self, data, writepos):
        self._data = data
        self._writepos = writepos

    @classmethod
    def allocate(cls, size):
        return cls(_ffi.new("uint8_t[]", size), 0)

    def __repr__(self):
        return "Buffer(data=%r, capacity=%d, free=%d)" % (
            [self._data[i] for i in xrange(self.writepos)],
            self.capacity, self.free
        )

    @property
    def writepos(self):
        return self._writepos

    @property
    def capacity(self):
        return len(self._data)

    @property
    def free(self):
        return self.capacity - self.writepos

    def read_from(self, fd):
        if not self.free:
            raise BufferFull
        res = _lib.read(fd, self._data + self.writepos, self.free)
        if res == -1:
            raise OSError(_ffi.errno, os.strerror(_ffi.errno))
        elif res == 0:
            raise EOFError
        self._writepos += res
        return res

    def add_bytes(self, b):
        if not self.free:
            raise BufferFull
        bytes_written = min(len(b), self.free)
        for i in xrange(bytes_written):
            self._data[self.writepos] = six.indexbytes(b, i)
            self._writepos += 1
        return bytes_written

    def view(self, start=0, stop=None):
        if stop is None:
            stop = self.writepos
        if stop < start:
            raise ValueError("stop is less than start")
        if not (0 <= start <= self.writepos):
            raise ValueError(
                "The start is either negative or after the writepos"
            )
        if stop > self.writepos:
            raise ValueError("stop is after the writepos")
        return BufferView(self, self._data, start, stop)


class BufferView(object):
    def __init__(self, buf, data, start, stop):
        self._keepalive = buf
        self._data = data + start
        self._length = stop - start

    def __bytes__(self):
        return _ffi.buffer(self._data, self._length)[:]
    if six.PY2:
        __str__ = __bytes__

    def __repr__(self):
        return "BufferView(data=%r)" % (
            [self._data[i] for i in xrange(len(self))]
        )

    def __len__(self):
        return self._length

    def __eq__(self, other):
        if len(self) != len(other):
            return False
        if isinstance(other, BufferView):
            return _lib.memcmp(self._data, other._data, len(self)) == 0
        elif isinstance(other, bytes):
            for i in xrange(len(self)):
                if self[i] != six.indexbytes(other, i):
                    return False
            return True
        else:
            return NotImplemented

    def __ne__(self, other):
        return not (self == other)

    def __contains__(self, data):
        return self.find(data) != -1

    def __getitem__(self, idx):
        if isinstance(idx, slice):
            start, stop, step = idx.indices(len(self))
            if step != 1:
                raise ValueError("Can't slice with non-1 step.")
            if start > stop:
                raise ValueError("Can't slice backwards.")
            return BufferView(self._keepalive, self._data, start, stop)
        else:
            if idx < 0:
                idx += len(self)
            if not (0 <= idx < len(self)):
                raise IndexError(idx)
            return self._data[idx]

    def __add__(self, other):
        if isinstance(other, BufferView):
            collator = BufferCollator()
            collator.append(self)
            collator.append(other)
            return collator.collapse()
        else:
            return NotImplemented

    def find(self, needle, start=0, stop=None):
        stop = stop or len(self)
        if start < 0:
            start = 0
        if stop > len(self):
            stop = len(self)
        if stop - start < 0:
            return -1

        if len(needle) == 0:
            return start
        elif len(needle) == 1:
            res = _lib.memchr(self._data + start, ord(needle), stop - start)
            if res == _ffi.NULL:
                return -1
            else:
                return _ffi.cast("uint8_t *", res) - self._data
        else:
            mask, skip = self._make_find_mask(needle)
            return self._multi_char_find(needle, start, stop, mask, skip)

    def index(self, needle, start=0, stop=None):
        idx = self.find(needle, start, stop)
        if idx == -1:
            raise ValueError("substring not found")
        return idx

    def rfind(self, needle, start=0, stop=None):
        stop = stop or len(self)
        if start < 0:
            start = 0
        if stop > len(self):
            stop = len(self)
        if stop - start < 0:
            return -1

        if len(needle) == 0:
            return start
        elif len(needle) == 1:
            res = _lib.Zero_memrchr(
                self._data + start, ord(needle), stop - start
            )
            if res == _ffi.NULL:
                return -1
            else:
                return _ffi.cast("uint8_t *", res) - self._data
        else:
            mask, skip = self._make_rfind_mask(needle)
            return self._multi_char_rfind(needle, start, stop, mask, skip)

    def rindex(self, needle, start=0, stop=None):
        idx = self.rfind(needle, start, stop)
        if idx == -1:
            raise ValueError("substring not found")
        return idx

    def split(self, by, maxsplit=-1):
        if len(by) == 0:
            raise ValueError("empty separator")
        elif len(by) == 1:
            return self._split_char(by, maxsplit)
        else:
            return self._split_multi_char(by, maxsplit)

    def _split_char(self, by, maxsplit):
        start = 0
        while maxsplit != 0:
            next = self.find(by, start)
            if next == -1:
                break
            yield self[start:next]
            start = next + 1
            maxsplit -= 1
        yield self[start:]

    def _split_multi_char(self, by, maxsplit):
        start = 0
        mask, skip = self._make_find_mask(by)
        while maxsplit != 0:
            next = self._multi_char_find(by, start, len(self), mask, skip)
            if next < 0:
                break
            yield self[start:next]
            start = next + len(by)
            maxsplit -= 1
        yield self[start:]

    def _bloom_add(self, mask, c):
        return mask | (1 << (c & (BLOOM_WIDTH - 1)))

    def _bloom(self, mask, c):
        return mask & (1 << (c & (BLOOM_WIDTH - 1)))

    def _make_find_mask(self, needle):
        mlast = len(needle) - 1
        mask = 0
        skip = mlast - 1
        for i in xrange(mlast):
            mask = self._bloom_add(mask, six.indexbytes(needle, i))
            if needle[i] == needle[mlast]:
                skip = mlast - i - 1
        mask = self._bloom_add(mask, six.indexbytes(needle, mlast))
        return mask, skip

    def _multi_char_find(self, needle, start, stop, mask, skip):
        i = start - 1
        w = (stop - start) - len(needle)
        while i + 1 <= start + w:
            i += 1
            if self._data[i + len(needle) - 1] == six.indexbytes(needle, -1):
                for j in xrange(len(needle) - 1):
                    if self._data[i + j] != six.indexbytes(needle, j):
                        break
                else:
                    return i
                if (
                    i + len(needle) < len(self) and
                    not self._bloom(mask, self._data[i + len(needle)])
                ):
                    i += len(needle)
                else:
                    i += skip
            else:
                if (
                    i + len(needle) < len(self) and
                    not self._bloom(mask, self._data[i + len(needle)])
                ):
                    i += len(needle)
        return -1

    def _make_rfind_mask(self, needle):
        mask = self._bloom_add(0, six.indexbytes(needle, 0))
        skip = len(needle) - 1
        for i in xrange(len(needle) - 1, 0, -1):
            mask = self._bloom_add(mask, six.indexbytes(needle, i))
            if needle[i] == needle[0]:
                skip = i - 1
        return mask, skip

    def _multi_char_rfind(self, needle, start, stop, mask, skip):
        i = start + (stop - start - len(needle)) + 1
        while i - 1 >= start:
            i -= 1
            if self[i] == six.indexbytes(needle, 0):
                for j in xrange(len(needle) - 1, 0, -1):
                    if self[i + j] != six.indexbytes(needle, j):
                        break
                else:
                    return i
                if i - 1 >= 0 and not self._bloom(mask, self[i - 1]):
                    i -= len(needle)
                else:
                    i -= skip
            else:
                if i - 1 >= 0 and not self._bloom(mask, self[i - 1]):
                    i -= len(needle)
        return -1

    def splitlines(self, keepends=False):
        i = 0
        j = 0
        while j < len(self):
            while (
                i < len(self) and
                self[i] != ord(b"\n") and self[i] != ord(b"\r")
            ):
                i += 1
            eol = i
            if i < len(self):
                if (
                    self[i] == ord(b"\r") and
                    i + 1 < len(self) and self[i + 1] == ord(b"\n")
                ):
                    i += 2
                else:
                    i += 1
                if keepends:
                    eol = i
            yield self[j:eol]
            j = i

    def isspace(self):
        if not self:
            return False
        for ch in self:
            if ch != 32 and not (9 <= ch <= 13):
                return False
        return True

    def isdigit(self):
        if not self:
            return False
        for ch in self:
            if not (ord("0") <= ch <= ord("9")):
                return False
        return True

    def isalpha(self):
        if not self:
            return False
        for ch in self:
            if not (65 <= ch <= 90 or 97 <= ch <= 122):
                return False
        return True

    def _strip_none(self, left, right):
        lpos = 0
        rpos = len(self)

        if left:
            while lpos < rpos and chr(self[lpos]).isspace():
                lpos += 1

        if right:
            while rpos > lpos and chr(self[rpos - 1]).isspace():
                rpos -= 1
        return self[lpos:rpos]

    def _strip_chars(self, chars, left, right):
        lpos = 0
        rpos = len(self)

        if left:
            while lpos < rpos and six.int2byte(self[lpos]) in chars:
                lpos += 1

        if right:
            while rpos > lpos and six.int2byte(self[rpos - 1]) in chars:
                rpos -= 1
        return self[lpos:rpos]

    def strip(self, chars=None):
        if chars is None:
            return self._strip_none(left=True, right=True)
        else:
            return self._strip_chars(chars, left=True, right=True)

    def lstrip(self, chars=None):
        if chars is None:
            return self._strip_none(left=True, right=False)
        else:
            return self._strip_chars(chars, left=True, right=False)

    def rstrip(self, chars=None):
        if chars is None:
            return self._strip_none(left=False, right=True)
        else:
            return self._strip_chars(chars, left=False, right=True)

    def write_to(self, fd):
        res = _lib.write(fd, self._data, self._length)
        if res == -1:
            raise OSError(_ffi.errno, os.strerror(_ffi.errno))
        return res


class BufferCollator(object):
    def __init__(self):
        self._views = []
        self._total_length = 0

    def __len__(self):
        return self._total_length

    def append(self, view):
        if self._views:
            last_view = self._views[-1]
            if (
                last_view._keepalive is view._keepalive and
                last_view._data + len(last_view) == view._data
            ):
                self._views[-1] = BufferView(
                    last_view._keepalive,
                    last_view._data,
                    0,
                    len(last_view) + len(view)
                )
            else:
                self._views.append(view)
        else:
            self._views.append(view)
        self._total_length += len(view)

    def collapse(self):
        if len(self._views) == 1:
            result = self._views[0]
        else:
            data = _ffi.new("uint8_t[]", self._total_length)
            pos = 0
            for view in self._views:
                _lib.memcpy(data + pos, view._data, len(view))
                pos += len(view)
            result = Buffer(data, self._total_length).view()
        del self._views[:]
        self._total_length = 0
        return result

########NEW FILE########
