__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# konira documentation build configuration file, created by
# sphinx-quickstart on Wed Mar  9 17:14:43 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.
# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))
import sys, os
sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))
import konira
from konira_syntax import KoniraLexer, KoniraTermLexer

# -- General configuration -----------------------------------------------------
# Setup function.
def setup(app):
    app.add_lexer('konira', KoniraLexer())
    app.add_lexer('koniraterm', KoniraTermLexer())
# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'contents'

# General information about the project.
project = u'konira'
copyright = u'2011, Alfredo Deza'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = konira.__version__
# The full version, including alpha/beta/rc tags.
release = konira.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'bw'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'koniradoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'konira.tex', u'konira Documentation',
   u'Alfredo Deza', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'konira', u'konira Documentation',
     [u'Alfredo Deza'], 1)
]

########NEW FILE########
__FILENAME__ = konira_syntax
from pygments.token import Name, Keyword, Text, Comment
from pygments.lexer import RegexLexer, \
     include, combined, bygroups
from pygments.token import Text, \
     Comment, Operator, Keyword, Name, String, Number, Punctuation
from pygments.util import shebang_matches



class KoniraLexer(RegexLexer):

    name = 'Konira Lexer'
    aliases = ['konira']
    mimetypes = ['text/x-python', 'application/x-python']

    tokens = {
        'root': [
            (r'\n', Text),
            (r'^describe\s+', Keyword),
            (r'^before\s+\w+\s+', Keyword),
            (r'\s*it\s+', Keyword),
            (r'\s*let\s+', Keyword),
            (r'^\s*after\s+\w+', Keyword),
            (r'^\s*before\s+\w+', Keyword),
            (r'^\s*skip\s+\w+', Keyword),
            (r'^(\s*)([rRuU]{,2}"""(?:.|\n)*?""")', bygroups(Text, String.Doc)),
            (r"^(\s*)([rRuU]{,2}'''(?:.|\n)*?''')", bygroups(Text, String.Doc)),
            (r'[^\S\n]+', Text),
            (r'#.*$', Comment),
            (r'[]{}:(),;[]', Punctuation),
            (r'\\\n', Text),
            (r'\\', Text),
            (r'(in|is|and|or|not)\b', Operator.Word),
            (r'!=|==|<<|>>|[-~+/*%=<>&^|.]', Operator),
            include('keywords'),
            (r'(def)((?:\s|\\\s)+)', bygroups(Keyword, Text), 'funcname'),
            (r'(class)((?:\s|\\\s)+)', bygroups(Keyword, Text), 'classname'),
            (r'(from)((?:\s|\\\s)+)', bygroups(Keyword.Namespace, Text), 'fromimport'),
            (r'(import)((?:\s|\\\s)+)', bygroups(Keyword.Namespace, Text), 'import'),
            include('builtins'),
            include('backtick'),
            ('(?:[rR]|[uU][rR]|[rR][uU])"""', String, 'tdqs'),
            ("(?:[rR]|[uU][rR]|[rR][uU])'''", String, 'tsqs'),
            ('(?:[rR]|[uU][rR]|[rR][uU])"', String, 'dqs'),
            ("(?:[rR]|[uU][rR]|[rR][uU])'", String, 'sqs'),
            ('[uU]?"""', String, combined('stringescape', 'tdqs')),
            ("[uU]?'''", String, combined('stringescape', 'tsqs')),
            ('[uU]?"', String, combined('stringescape', 'dqs')),
            ("[uU]?'", String, combined('stringescape', 'sqs')),
            include('name'),
            include('numbers'),
        ],
        'keywords': [
            (r'(assert|break|continue|del|elif|else|except|exec|'
             r'finally|for|global|if|lambda|pass|print|raise|'
             r'return|try|while|yield|as|with)\b', Keyword),
        ],
        'builtins': [
            (r'(?<!\.)(__import__|abs|all|any|apply|basestring|bin|bool|buffer|'
             r'bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|'
             r'complex|delattr|dict|dir|divmod|enumerate|eval|execfile|exit|'
             r'file|filter|float|frozenset|getattr|globals|hasattr|hash|hex|id|'
             r'input|int|intern|isinstance|issubclass|iter|len|list|locals|'
             r'long|map|max|min|next|object|oct|open|ord|pow|property|range|'
             r'raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|'
             r'sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|'
             r'vars|xrange|zip)\b', Name.Builtin),
            (r'(?<!\.)(self|None|Ellipsis|NotImplemented|False|True'
             r')\b', Name.Builtin.Pseudo),
            (r'(?<!\.)(ArithmeticError|AssertionError|AttributeError|'
             r'BaseException|DeprecationWarning|EOFError|EnvironmentError|'
             r'Exception|FloatingPointError|FutureWarning|GeneratorExit|IOError|'
             r'ImportError|ImportWarning|IndentationError|IndexError|KeyError|'
             r'KeyboardInterrupt|LookupError|MemoryError|NameError|'
             r'NotImplemented|NotImplementedError|OSError|OverflowError|'
             r'OverflowWarning|PendingDeprecationWarning|ReferenceError|'
             r'RuntimeError|RuntimeWarning|StandardError|StopIteration|'
             r'SyntaxError|SyntaxWarning|SystemError|SystemExit|TabError|'
             r'TypeError|UnboundLocalError|UnicodeDecodeError|'
             r'UnicodeEncodeError|UnicodeError|UnicodeTranslateError|'
             r'UnicodeWarning|UserWarning|ValueError|VMSError|Warning|'
             r'WindowsError|ZeroDivisionError)\b', Name.Exception),
        ],
        'numbers': [
            (r'(\d+\.\d*|\d*\.\d+)([eE][+-]?[0-9]+)?', Number.Float),
            (r'\d+[eE][+-]?[0-9]+', Number.Float),
            (r'0[0-7]+', Number.Oct),
            (r'0[xX][a-fA-F0-9]+', Number.Hex),
            (r'\d+L', Number.Integer.Long),
            (r'\d+', Number.Integer)
        ],
        'backtick': [
            ('`.*?`', String.Backtick),
        ],
        'name': [
            (r'@[a-zA-Z0-9_.]+', Name.Decorator),
            ('[a-zA-Z_][a-zA-Z0-9_]*', Name),
        ],
        'funcname': [
            ('[a-zA-Z_][a-zA-Z0-9_]*', Name.Function, '#pop')
        ],
        'classname': [
            ('[a-zA-Z_][a-zA-Z0-9_]*', Name.Class, '#pop')
        ],
        'import': [
            (r'((?:\s|\\\s)+)(as)((?:\s|\\\s)+)',
             bygroups(Text, Keyword.Namespace, Text)),
            (r'[a-zA-Z_][a-zA-Z0-9_.]*', Name.Namespace),
            (r'(\s*)(,)(\s*)', bygroups(Text, Operator, Text)),
            (r'', Text, '#pop') # all else: go back
        ],
        'fromimport': [
            (r'((?:\s|\\\s)+)(import)\b', bygroups(Text, Keyword.Namespace), '#pop'),
            (r'[a-zA-Z_.][a-zA-Z0-9_.]*', Name.Namespace),
        ],
        'stringescape': [
            (r'\\([\\abfnrtv"\']|\n|N{.*?}|u[a-fA-F0-9]{4}|'
             r'U[a-fA-F0-9]{8}|x[a-fA-F0-9]{2}|[0-7]{1,3})', String.Escape)
        ],
        'strings': [
            (r'%(\([a-zA-Z0-9_]+\))?[-#0 +]*([0-9]+|[*])?(\.([0-9]+|[*]))?'
             '[hlL]?[diouxXeEfFgGcrs%]', String.Interpol),
            (r'[^\\\'"%\n]+', String),
            # quotes, percents and backslashes must be parsed one at a time
            (r'[\'"\\]', String),
            # unhandled string formatting sign
            (r'%', String)
            # newlines are an error (use "nl" state)
        ],
        'nl': [
            (r'\n', String)
        ],
        'dqs': [
            (r'"', String, '#pop'),
            (r'\\\\|\\"|\\\n', String.Escape), # included here again for raw strings
            include('strings')
        ],
        'sqs': [
            (r"'", String, '#pop'),
            (r"\\\\|\\'|\\\n", String.Escape), # included here again for raw strings
            include('strings')
        ],
        'tdqs': [
            (r'"""', String, '#pop'),
            include('strings'),
            include('nl')
        ],
        'tsqs': [
            (r"'''", String, '#pop'),
            include('strings'),
            include('nl')
        ],
    }

    def analyse_text(text):
        return shebang_matches(text, r'pythonw?(2\.\d)?')

class KoniraTermLexer(RegexLexer):

    name = 'Konira Terminal Lexer'
    aliases = ['koniraterm']

    tokens = {
        'root': [
            (r'\n', Text),
            (r'^\s*It.*', Keyword),
            (r'^All.*', Keyword),
            (r'^Profiling.*', Keyword),
            (r'^\d+\s+slowest.*', Keyword),
            (r'^Failures:$', String),
            (r'^--(.*)$', String),
            (r'^Failures:$', String),
            (r'^1\s+\=\=(.*)$', String),
            (r'^Starts\s+\w+(.*)$', String),
            (r'^Starts:\s+(.*)$', String),
            (r'^Ends:\s+(.*)$', String),
            (r'^\d+\s+\w+\s+failed(.*)$', String),
            (r'^\s+\w+\s+(.*)$', Text),
            (r'[^\S\n]+', Text),
            (r'#.*$', Comment),
            (r'\\\n', Text),
            (r'\\', Text),
            (r'^.*\n', Text),
            ],
        }

########NEW FILE########
__FILENAME__ = argopts


class ArgOpts(object):


    def __init__(self, options):
        self.options    = options
        self.help       = ['-h', '--h', '--help', 'help']
        self.version    = ['--version', 'version']
        self._arg_count = {}
        self._count_arg = {}
        

    def parse_args(self, argv):
        self.args = argv[1:]
        self.match = [i for i in argv if i in self.options]
        for count, argument in enumerate(self.args):
            self._arg_count[argument] = count
            self._count_arg[count]    = argument


    def get_value(self, opt):
        count = self._arg_count.get(opt)
        if count == None:
            return None
        value = self._count_arg.get(count+1)
        return value


    def has(self, opt):
        if type(opt) == list:
            for i in opt:
                if i in self._arg_count.keys():
                    return True
            return False
        if opt in self._arg_count.keys():
            return True
        return False


    def catches_help(self):
        if [i for i in self.args if i in self.help]:
            return True
        return False


    def catches_version(self):
        if [i for i in self.args if i in self.version]:
            return True
        return False


########NEW FILE########
__FILENAME__ = collector
from __future__ import with_statement
import sys
import tokenize
import os
import re
from konira.tokenizer import translate


class FileCollector(list):


    def __init__(self, path, config={}):
        self.user_match       = config.get('collect-match')
        self.case_insensitive = config.get('collect-ci')
        self.path             = path
        self._collect()


    @property
    def valid_module_name(self):
        fallback = re.compile(r'case[_a-z]\w*\.py$', re.IGNORECASE)
        if not self.user_match:
            return fallback
        else:
            try:
                if self.case_insensitive:
                    return re.compile(self.user_match, re.IGNORECASE)
                return re.compile(self.user_match)
            except Exception, msg:
                raise SystemExit('Could not compile regex, error was: %s' % msg)


    def _collect(self):
        if os.path.isfile(self.path):
            self.append(self.path)
            return

        # Local is faster
        walk = os.walk
        join = os.path.join
        path = self.path
        levels_deep = 0

        for root, dirs, files in walk(path):
            levels_deep += 1

            # Start checking for Python packages after 3 levels
            if levels_deep > 2:
                if not '__init__.py' in files:
                    continue
            for item in files:
                absolute_path = join(root, item)
                if not self.valid_module_name.match(item):
                    continue
                self.append(absolute_path)



def globals_from_file(filename):
    # be aware of same file path for relative imports
    old_path0   = sys.path[0]
    sys.path[0] = os.path.dirname(filename)

    _file = open(filename)
    data  = tokenize.untokenize(translate(_file.readline))
    compiled = compile(data, filename, "exec")
    globals_ = {}
    exec(compiled, globals_)

    # restore the original sys.path
    sys.path[0] = old_path0
    return globals_




########NEW FILE########
__FILENAME__ = exc
import inspect
import difflib



class DontReadFromInput(object):
    """Temporary stub class.  Ideally when stdin is accessed, the
    capturing should be turned off, with possibly all data captured
    so far sent to the screen.  This should be configurable, though,
    because in automated test runs it is better to crash than
    hang indefinitely.
    """
    msg = "reading from stdin while output is captured (using pdb?)"


    def flush(self, *args):
        raise KoniraIOError(self.msg)


    def write(self, *args):
        raise KoniraIOError(self.msg)


    def read(self, *args):
        raise KoniraIOError(self.msg)


    readline  = read
    readlines = read
    __iter__  = read



class KoniraExecutionError(Exception):


    def __init__(self, exc_name, filename, lineno, msg, exc):
        self.exc_name = exc_name
        self.msg      = msg
        self.filename = filename
        self.lineno   = lineno
        self.exc      = exc
        Exception.__init__(self, msg)



class KoniraNoSkip(Exception):


    def __init__(self, msg=''):
        Exception.__init__(self, msg)



class KoniraReassertError(Exception):


    def __init__(self, msg=''):
        Exception.__init__(self, msg)



class KoniraFirstFail(Exception):


    def __init__(self, msg=''):
        Exception.__init__(self, msg)



class KoniraIOError(Exception):


    def __init__(self, msg):
        Exception.__init__(self, msg)



class Source(object):


    def __init__(self, trace):
        self.trace    = trace
        self.line     = self.get_assert_line
        self.operand  = self.get_operand
        self.is_valid = True
        self._locals  = self.get_locals
        if not self.line or not self.operand:
            self.is_valid = False


    @property
    def get_locals(self):
        frame = self.trace[0]
        return inspect.getargvalues(frame)[3]


    @property
    def get_assert_line(self):
        line = self.trace[-2][0]
        if 'assert' in line:
            return line.replace('assert', '').strip()
        return False


    @property
    def get_operand(self):
        operators = ['==', '!=', '>', '<', 
                     '>=', '<=', ' is ', ' not in ']
        try:
            operator = [i for i in operators if i in self.line]
        except TypeError:
            return False
        if len(operator) > 1: # probably <, >, mixed with <= >= operators 
            return operator[-1]
        if operator:
            return operator[0]


    @property
    def _left_text(self):
        operator = self.operand
        return self.line.split(operator)[0].strip()


    @property
    def _right_text(self):
        operator = self.operand
        return self.line.split(operator)[1].strip()


    @property
    def right_value(self):
        right = self._locals.get(self._right_text)
        if right:
            return right
        return self._eval(self._right_text)


    @property
    def left_value(self):
        left = self._locals.get(self._left_text)
        if left:
            return left
        return self._eval(self._left_text)


    def _eval(self, code):
        return eval(code, None, self._locals)



def konira_assert(trace):
    source  = Source(trace)
    if source.is_valid:
        try:
            left     = source.left_value
            right    = source.right_value
            operand  = source.operand
            line     = source.line
        except NameError:
            return None

        # At this point we have tried everything we can to
        # get a valid comparison so return to basic Assertion
        # to avoid a huge traceback
        except Exception:
            return None

        try:
            reassert = assertrepr_compare(operand, left, right)
        except KoniraReassertError:
            return None

        if reassert:
            return reassert
        return assert_description(operand, left, right, line)



def assert_description(op, left, right, line):
    explanation = [line]
    explanation.append('%s %s %s' % (left, op, right))
    return explanation

    

def assertrepr_compare(op, left, right):
    """return specialised explanations for some operators/operands"""
    width      = 80 - 15 - len(op) - 2 # 15 chars indentation, 1 space around op
    left_repr  = left
    right_repr = right
    summary    = '%s %s %s' % (left_repr, op, right_repr)

    issequence = lambda x: isinstance(x, (list, tuple))
    istext     = lambda x: isinstance(x, basestring)
    isdict     = lambda x: isinstance(x, dict)
    isset      = lambda x: isinstance(x, set)

    explanation = None
    try:
        if op == '==':
            if istext(left) and istext(right):
                explanation = _diff_text(left, right)
            elif issequence(left) and issequence(right):
                explanation = _compare_eq_sequence(left, right)
            elif isset(left) and isset(right):
                explanation = _compare_eq_set(left, right)
            elif isdict(left) and isdict(right):
                explanation = _diff_text(str(left), str(right))
        elif op == ' not in ':
            if istext(left) and istext(right):
                explanation = _notin_text(left, right)
    except Exception, e:
        raise KoniraReassertError(e)

    if not explanation:
        return None

    # Don't include pageloads of data, should be configurable
    if len(''.join(explanation)) > 80*8:
        explanation = ['Detailed information too verbose, truncated']

    return [summary] + explanation


def _diff_text(left, right):
    """Return the explanation for the diff between text

    This will skip leading and trailing characters which are
    identical to keep the diff minimal.
    """
    explanation = []
    i = 0 # just in case left or right has zero length
    for i in range(min(len(left), len(right))):
        if left[i] != right[i]:
            break
    if i > 42:
        i -= 10                 # Provide some context
        explanation = ['Skipping %s identical '
                       'leading characters in diff' % i]
        left  = left[i:]
        right = right[i:]
    if len(left) == len(right):
        for i in range(len(left)):
            if left[-i] != right[-i]:
                break
        if i > 42:
            i -= 10     # Provide some context
            explanation += ['Skipping %s identical '
                            'trailing characters in diff' % i]
            left  = left[:-i]
            right = right[:-i]
    explanation += [line.strip('\n')
                    for line in difflib.ndiff(left.splitlines(),
                                                     right.splitlines())]
    return explanation


def _compare_eq_sequence(left, right):
    explanation = []
    for i in range(min(len(left), len(right))):
        if left[i] != right[i]:
            explanation += ['At index %s diff: %r != %r' %
                            (i, left[i], right[i])]
            break
    if len(left) > len(right):
        explanation += ['Left contains more items, '
            'first extra item: %s' % (left[len(right)],)]
    elif len(left) < len(right):
        explanation += ['Right contains more items, '
            'first extra item: %s' % (right[len(left)],)]
    return explanation  + _diff_text(str(left),str(right))


def _compare_eq_set(left, right):
    explanation = []
    diff_left   = left - right
    diff_right  = right - left
    if diff_left:
        explanation.append('Extra items in the left set:')
        for item in diff_left:
            explanation.append(repr(item))
    if diff_right:
        explanation.append('Extra items in the right set:')
        for item in diff_right:
            explanation.append(repr(item))
    return explanation


def _notin_text(term, text):
    index        = text.find(term)
    head         = text[:index]
    tail         = text[index+len(term):]
    correct_text = head + tail
    diff         = _diff_text(correct_text, text)
    newdiff      = ['%s is contained here:' % repr(term, maxsize = 42)]
    for line in diff:
        if line.startswith('Skipping'):
            continue
        if line.startswith('- '):
            continue
        if line.startswith('+ '):
            newdiff.append('  ' + line[2:])
        else:
            newdiff.append(line)
    return newdiff


########NEW FILE########
__FILENAME__ = cover
"""
Write and report coverage data with the 'coverage' package.
Original code by Ross Lawley. 

Requires Ned Batchelder's excellent coverage:
http://nedbatchelder.com/code/coverage/
"""
import sys


def import_coverage():
    try:
        from coverage import coverage
        return coverage()
    except ImportError:
        msg = "coverage is not installed or not available in current sys.path\n"
        msg +="make sure it is installed properly and try again."
        sys.stdout.write(msg)
        sys.exit(2)


class DoCoverage(object):


    __defaults__ = dict(
                    show_missing  = False,
                    report        = 'report',
                    directory     = 'coverage',
                    ignore_errors = True,
                    coverpackages = False
                    )


    def __init__(self, options=None):
        self.options = self.__defaults__
        if options:
            self.options.update(options)
        self._coverage = import_coverage()
        self._coverage.use_cache(False)
        self._coverage.start()


    def konira_terminal_summary(self):
        self._coverage.stop()
        self._coverage.save()

        show_missing = self.options.get('show_missing')
        report_type  = self.options.get('report')
        directory    = self.options.get('directory')
        ignore_err   = self.options.get('ignore_errors')
        
        report_args = {
            'ignore_errors': ignore_err,
        }

        coverpackages = self.options.get('coverpackages')
        if coverpackages:
            modules = report_args['morfs'] = []
            for name, module in sys.modules.items():
                if module is not None and hasattr(module, '__file__'):
                    fn = module.__file__
                    for pkg in coverpackages:
                        if name.startswith(pkg):
                            modules.append(fn)
                            break
        
        
        if report_type == 'report':
            self._coverage.report(show_missing=show_missing, file=sys.stdout,
                    **report_args)
        elif report_type == 'annotate':
            self._coverage.annotate(directory=directory, **report_type)
        elif report_type == 'html':
            self._coverage.html_report(directory=directory, **report_args)

########NEW FILE########
__FILENAME__ = output
import re
import sys
import traceback
from os.path     import dirname, abspath
from konira.util import name_convertion
from konira.exc  import konira_assert


class ReportResults(object):


    def __init__(self, results, writer=None):
        self.results = results
        self.config  = self.results.config
        self.writer  = writer
        if not self.writer:
            self.writer  = Writer()


    def report(self):
        self.writer.newline()
        if self.config.get('profiling'):
            self.profiler()
        if self.results.failures:
            self.failures()
        if self.results.errors:
            self.errors()
        self.footer()


    def failures(self):
        format_exc = ExcFormatter(self.results.failures, self.config, self.writer)
        format_exc.output_failures()


    def errors(self):
        format_exc = ExcFormatter(self.results.errors, self.config, self.writer)
        format_exc.output_errors()


    def footer(self):
        out_footer(self.results.total_cases, 
                self.results.total_failures, 
                self.results.elapsed,
                self.writer)


    def profiler(self):
        self.writer.newline()
        prof_message = "Profiling enabled\n10 slowest tests shown:\n"
        self.writer.write(prof_message, 'green')
        for p in self._sort_profiles():
            self._output_profiles(p)


    def _sort_profiles(self):
        _sorted =  sorted(self.results.profiles, 
                          key=lambda p: p[0], 
                          reverse=True)
        return _sorted[:10]


    def _output_profiles(self, data):
        str_time = str(data[0])[:10]
        elapsed  = self.writer.bold(str_time)
        case     = self.writer.green(name_convertion(data[1]))
        message  = "%s - %s" % (elapsed, case)
        self.writer.writeln(message)



class TerminalWriter(object):


    def __init__(self, dotted):
        self.dotted = dotted
        self.writer = Writer()


    def green_spec(self, title):
        string = "    %s" % (name_convertion(title))
        if not self.dotted:
            self.writer.writeln(string, 'green')
        else:
            self.writer.println('.')
            self.writer.flush()


    def red_spec(self, title):
        string = "    %s" % (name_convertion(title))
        if not self.dotted:
            self.writer.writeln(string, 'red')
        else:
            self.writer.println('F')
            self.writer.flush()


    def out_case(self, title):
        if not self.dotted:
            self.writer.println("\n\n%s" % name_convertion(title))


    def out_bold(self, string):
        self.writer.write(string, 'bold')


    def skipping(self):
        if not self.dotted:
            self.write.println(' ...skipping')
        else:
            self.writer.println('S')
            self.writer.flush()



def out_footer(cases, failures, elapsed, std=None):
    if not std:
        std = Writer()
    std.newline(2)
    if not failures and cases > 0:
        spec_verb = 'specs' if cases > 1 else 'spec'
        string = "All %s %s passed in %s secs.\n" % (cases, spec_verb, elapsed)
        std.writeln(string, 'green')
        return
    elif failures:
        spec_verb = 'specs' if failures > 1 else 'spec'
        string = "%s %s failed, %s total in %s secs.\n" % (failures, spec_verb, cases, elapsed)
        std.writeln(string, 'red')
        return
    if not cases or cases == 0:
        string = "No cases/specs collected.\n"
        std.writeln(string, 'bold')



def format_file_line(filename, line):
    return Writer().bold("%s:%s:" % (filename, line))



class ExcFormatter(object):


    def __init__(self, failures, config, std=None):
        self.config      = config
        self.failures    = failures
        self.failed_test = 1
        self.std = std
        if not self.std:
            self.std = Writer()


    def output_failures(self):
        self.std.writeln('Failures:\n---------', 'red')
        for failure in self.failures:
            self.single_exception(failure)


    def output_errors(self):
        self.std.writeln('\n\nErrors:\n-------', 'red')
        for error in self.failures:
            error = self.build_error_output(error)
            self.failure_header(error['description'])
            self.std.writeln("File: ", 'red')
            self.std.println(format_file_line(error['filename'], error['lineno']))
            if self.config.get('traceback') and error['text']:
                self.std.writeln(error['text'], 'red')


    def build_error_output(self, error):
        exc = {}
        p_error = PrettyExc(error['failure'], error=True)
        exc['description'] = p_error.exception_description
        try: # See if we have info at the message level and use that
            exc['filename'] = p_error.exc_value.filename
            exc['lineno']   = p_error.exc_value.lineno
        except:
            exc['filename']    = p_error.exception_file
            exc['lineno']      = p_error.exception_line
        exc['text']        = p_error.formatted_exception
        return exc


    def single_exception(self, failure):
        exc        = failure.get('failure')
        name       = failure.get('exc_name')
        trace      = failure.get('trace')
        pretty_exc = PrettyExc(exc, debug=self.config.get('debug'))

        self.failure_header(pretty_exc.exception_description)
        starts = pretty_exc.exception_file_start
        ends   = pretty_exc.exception_file_end

        if starts == ends:
            self.std.writeln("Starts and Ends: ", 'red')
            self.std.println(format_file_line(pretty_exc.exception_file_start, pretty_exc.exception_line_start))
        else:
            self.std.writeln("Starts: ", 'red')
            self.std.println(format_file_line(pretty_exc.exception_file_start, pretty_exc.exception_line_start))
            self.std.writeln("Ends: ", 'red')
            self.std.println(format_file_line(pretty_exc.exception_file_end, pretty_exc.exception_line_end))

        if self.config.get('traceback'):
            if name == 'AssertionError':
                reassert = konira_assert(trace)            
                if reassert:
                    self.assertion_diff(reassert)
                    self.std.writeln(pretty_exc.formatted_exception)
                else:
                    self.std.writeln(pretty_exc.formatted_exception)
            else:
                self.std.writeln(pretty_exc.formatted_exception)


    def assertion_diff(self, diff):
        self.std.writeln("Assert Diff: %s" % str(diff[0].__repr__()), 'red') 

        # remove actual assert line
        diff.pop(0)
        for line in diff:
            if "?" and "^" in line:
                self.std.writeln(self.std.red('E            '+line))
            else:
                self.std.writeln(self.std.red('E            ')+line)


    def failure_header(self, name):
        string = "\n%s ==> %s" % (self.failed_test, name)
        self.failed_test += 1
        self.std.writeln(string, 'red')



class PrettyExc(object):


    def __init__(self, exc_info, error=False, debug=False):
        self.error = error
        self.debug = debug
        self.exc_type, self.exc_value, self.exc_traceback = exc_info
        if self.error:
            self.exc_traceback =  self._last_traceback(self.exc_traceback)
        self.exc_traceback        = self._remove_konira_from_traceback(self.exc_traceback)
        self.end_traceback        = self._last_traceback(self.exc_traceback)
        self.exception_file_start = self.exc_traceback.tb_frame.f_code.co_filename
        self.exception_line_start = self.exc_traceback.tb_lineno
        self.exception_file_end   = self.end_traceback.tb_frame.f_code.co_filename
        self.exception_line_end   = self.end_traceback.tb_lineno
        self.exception_line       = self.exc_traceback.tb_lineno
        self.exception_file       = self.exc_traceback.tb_frame.f_code.co_filename
        self.exc_info             = exc_info


    @property
    def formatted_exception(self):
        traceback_lines = traceback.format_exception(self.exc_type,
                                                     self.exc_value,
                                                     self.exc_traceback)
        rewritten = self.translate_exc_line(traceback_lines)
        return ''.join(rewritten)


    def translate_exc_line(self, lines):
        if self.error or self.debug: return lines
        valid_file_name   = re.compile(r'\s+File\s+(.*)case[_a-z]\w*\.py', re.IGNORECASE)
        valid_method_name = re.compile(r'(.*)\s+in\s+it_[_a-z]\w*', re.IGNORECASE)
        valid_it_case     = re.compile(r'it_[_a-z]\w*', re.IGNORECASE)
        rewritten_lines   = []
        for line in lines:
            if valid_file_name.match(line) and valid_method_name.match(line):
                it_method = valid_it_case.search(line)
                if it_method:
                    rewrite_it = name_convertion(it_method.group(), capitalize=False)
                    line = re.sub(valid_it_case, rewrite_it, line)
                rewritten_lines.append(line)
            else:
                rewritten_lines.append(line)
        return rewritten_lines


    @property
    def indented_traceback(self):
        trace = self.formatted_exception.split('\n')
        add_indent = ["    "+i for i in trace]
        return '\n'.join(add_indent)


    def _remove_konira_from_traceback(self, traceback):
        if self.error or self.debug: return traceback
        konira_dir = dirname(abspath(__file__))

        while True:
            try:
                frame    = traceback.tb_frame
                code     = frame.f_code
                filename = code.co_filename
                code_dir = dirname(abspath(filename))
                if code_dir != konira_dir:
                    break
                else:
                    if traceback.tb_next is None:
                        return traceback
                    traceback = traceback.tb_next
            except AttributeError:
                return traceback

        return traceback


    @property
    def exception_description(self):
        desc = traceback.format_exception_only(self.exc_type, self.exc_value)
        return self._short_exception_description(desc)


    def _short_exception_description(self, exception_description_lines):
        return exception_description_lines[-1].strip()


    def _last_traceback(self, tb):
        if tb is None: return tb
        while tb.tb_next:
            tb = tb.tb_next
        return tb



class Writer(object):


    def __init__(self, stdout=None):
        if not stdout:
            self.stdout = sys.__stdout__
        else:
            self.stdout = stdout
        self.out    = self.stdout.write
        self.isatty = self.stdout.isatty()
        self.flush  = self.stdout.flush


    def color(self, form):
        if not self.isatty or self.is_windows: return ''
        if form == None: return ''
        available = dict(
                blue   = '\033[94m',
                green  = '\033[92m',
                yellow = '\033[93m',
                red    = '\033[91m',
                bold   = '\033[1m',
                ends   = '\033[0m'
            )
        try:
            return available[form]
        except:
            raise KeyError('%s is not a valid format/color' % form) 


    @property
    def is_windows(self):
        if sys.platform == 'win32':
            return True
        return False


    def println(self, string):
        self.out("%s" % string)


    def write(self, string, form):
        """No new line before or after"""
        color   = self.color(form)
        ends    = self.color('ends')
        out_str = "%s%s%s" % (color, string, ends)
        self.out(out_str)


    def writeln(self, string, form=None):
        """With a new line before and after"""
        color   = self.color(form)
        ends    = self.color('ends')
        out_str = "\n%s%s%s" % (color, string, ends)
        self.out(out_str)


    def newline(self, lines=1):
        nln = '\n'*lines
        self.out(nln)
        

    def green(self, string):
        """
        Makes incoming string output as green on the terminal
        """
        color   = self.color('green')
        ends    = self.color('ends')
        color_it = "%s%s%s" % (color, string, ends)
        return color_it


    def red(self, string):
        """
        Makes incoming string output as red on the terminal
        """
        color   = self.color('red')
        ends    = self.color('ends')
        color_it = "%s%s%s" % (color, string, ends)
        return color_it


    def bold(self, string):
        """
        Makes text bold in the terminal
        """
        color   = self.color('bold')
        ends    = self.color('ends')
        bold_it = "%s%s%s" % (color, string, ends)
        return bold_it


########NEW FILE########
__FILENAME__ = runner
import re
import inspect
import sys
from decimal          import Decimal
from konira.exc       import KoniraFirstFail, KoniraNoSkip
from konira.util      import StopWatch, get_class_name, get_let_attrs, set_let_attrs
from konira.collector import globals_from_file
from konira.output    import TerminalWriter


class Runner(object):

    def __init__(self, paths, config):
        self.config         = config
        self.paths          = paths
        self.failures       = []
        self.errors         = []
        self.profiles       = []
        self.total_cases    = 0
        self.total_failures = 0
        self.total_errors   = 0
        self.total_skips    = 0
        self.class_name     = config.get('class_name')
        self.method_name    = config.get('method_name')
        self.write          = sys.__stdout__.write
        self.writer         = TerminalWriter(config.get('dotted'))


    def run(self):
        self.timer = StopWatch()
        for f in self.paths:
            try:
                classes = get_classes(f, self.class_name)
            except Exception, e:
                self.total_errors += 1
                self.errors.append(
                    dict(
                        failure   = sys.exc_info(),
                        exc_name  = e.__class__.__name__
                       )
                    )
                continue
            try:
                for case in classes:
                    self.run_suite(case)
            except KoniraFirstFail:
                break

        self.elapsed = self.timer.elapsed()


    def run_suite(self, case):
        # Initialize the test class
        suite = case()

        # check test environment setup
        environ = TestEnviron(suite)

        methods = get_methods(suite, self.method_name)
        if not methods: return

        # Name the class
        class_name = suite.__class__.__name__
        self.writer.out_case(class_name)

        # Are we skipping?
        if safe_skip_call(environ.set_skip_if):
            self.writer.skipping()
            return

        let_map = get_let_attrs(suite)

        # Set before all if any
        self.safe_environ_call(environ.set_before_all)

        for test in methods:
            test_start_time = StopWatch(raw=True)
            suite = set_let_attrs(suite, let_map)
            self.total_cases += 1

            # Set before each if any
            self.safe_environ_call(environ.set_before_each)

            try:
                getattr(suite, test)()
                test_elapsed_time = Decimal(str(test_start_time.elapsed()))
                self.writer.green_spec(test)

            except BaseException, e:
                test_elapsed_time = Decimal(str(test_start_time.elapsed()))
                trace = inspect.trace()[-1]
                self.total_failures += 1
                self.writer.red_spec(test)
                self.failures.append(
                    dict(
                        failure  = sys.exc_info(),
                        trace    = trace,
                        exc_name = e.__class__.__name__
                       )
                    )
                if self.config.get('first_fail'):
                    raise KoniraFirstFail

            # Save profiling info
            self.profiles.append((test_elapsed_time,
                                  test,
                                  class_name))

            # Set after each if any
            self.safe_environ_call(environ.set_after_each)

        # Set after all if any
        self.safe_environ_call(environ.set_after_all)


    def safe_environ_call(self, env_call):
        try:
            env_call()
        except Exception, e:
            self.errors.append(
                dict(
                    failure   = sys.exc_info(),
                    exc_name  = e.__class__.__name__
                   )
                )



class TestEnviron(object):
    """
    Checks for all test setup calls and sets a boolean
    flag for each.
    This approach avoids the runner to be checking getattr
    for every time since we alredy did at the beginning.
    """


    def __init__(self, suite):
        self.suite           = suite
        self.has_skip_if     = self._skip_if
        self.has_before_all  = self._before_all
        self.has_before_each = self._before_each
        self.has_after_all   = self._after_all
        self.has_after_each  = self._after_each


    @property
    def _skip_if(self):
        if hasattr(self.suite, '_skip_if'):
            return True
        return False


    @property
    def _before_all(self):
        if hasattr(self.suite, '_before_all'):
            return True
        return False


    @property
    def _before_each(self):
        if hasattr(self.suite, '_before_each'):
            return True
        return False


    @property
    def _after_all(self):
        if hasattr(self.suite, '_after_all'):
            return True
        return False


    @property
    def _after_each(self):
        if hasattr(self.suite, '_after_each'):
            return True
        return False


    def set_skip_if(self):
        if self.has_skip_if:
            getattr(self.suite, '_skip_if')()
        else:
            raise KoniraNoSkip


    def set_before_all(self):
        if self.has_before_all:
            getattr(self.suite, '_before_all')()


    def set_before_each(self):
        if self.has_before_each:
            return getattr(self.suite, '_before_each')()


    def set_after_all(self):
        if self.has_after_all:
            return getattr(self.suite, '_after_all')()


    def set_after_each(self):
        if self.has_after_each:
            return getattr(self.suite, '_after_each')()

#
# Runner helpers
#

def get_classes(filename, class_name):
    if class_name:
        classes = [i for i in _collect_classes(filename)
                    if class_name == get_class_name(i)]
    else:
        classes = [i for i in _collect_classes(filename)]

    return classes



def get_methods(suite, method_name):
    if method_name:
        methods = [i for i in _collect_methods(suite)
                    if i == method_name]
    else:
        methods = _collect_methods(suite)

    return methods



def _collect_classes(path):
    global_modules = map(globals_from_file, [path])
    return [i for i in global_modules[0].values() if callable(i) and i.__name__.startswith('Case_')]



def _collect_methods(module):
    valid_method_name = re.compile(r'it_[_a-z]\w*$', re.IGNORECASE)
    return [i for i in dir(module) if valid_method_name.match(i)]



def safe_skip_call(env_call):
    try:
        env_call()
        return True
    except KoniraNoSkip:
        return False
    except Exception:
        return False


########NEW FILE########
__FILENAME__ = case_argopts
from konira import argopts


describe "parsing arguments":


    it "removes the first item in the list always":
        parser = argopts.ArgOpts([])
        parser.parse_args(['foo'])
        assert parser.args == []


    it "matches an option in arguments":
        parser = argopts.ArgOpts(['--foo'])
        parser.parse_args(['/bin/konira', '--foo'])
        assert parser.args  == ['--foo']
        assert parser.match == ['--foo']


    it "matches arguments with no values":
        parser = argopts.ArgOpts(['--foo'])
        parser.parse_args(['/bin/konira', '--foo'])
        assert parser._arg_count['--foo'] == 0
        assert parser._count_arg[0]       == '--foo'


    it "matches arguments with values":
        parser = argopts.ArgOpts(['--foo'])
        parser.parse_args(['/bin/konira', '--foo', 'BAR'])
        assert parser.match               == ['--foo']
        assert parser._arg_count['--foo'] == 0
        assert parser._count_arg[1]       == 'BAR'


    it "matches valid configured options only":
        parser = argopts.ArgOpts(['--fuuu'])
        parser.parse_args(['/bin/konira', '--foo', '--meh'])
        assert parser.match == []

    
    it "matches mixed values and arguments":
        parser = argopts.ArgOpts(['--foo', '--bar'])
        parser.parse_args(['/bin/konira', '--foo', 'FOO', '--bar'])
        assert parser.match == ['--foo', '--bar']
        assert parser._arg_count['--foo'] == 0
        assert parser._arg_count['--bar'] == 2
        assert parser._count_arg[1]       == 'FOO'
        assert parser._count_arg.get(3)   == None



describe "get values from arguments":


    before each:
        self.parser = argopts.ArgOpts(['--foo'])
        self.parser.parse_args(['/bin/konira', '--foo', 'BAR', '--bar'])


    it "returns a valid value from a matching argument":
        assert self.parser.get_value('--foo') == 'BAR'


    it "returns None when an argument does not exist":
        assert self.parser.get_value('--meh') == None


    it "returns None when an argument does not have a value":
        assert self.parser.get_value('--bar') == None



describe "has or does not have options":


    before each:
        self.parser = argopts.ArgOpts(['--foo'])
        self.parser.parse_args(['/bin/konira', '--foo', 'BAR', '--bar'])


    it "accepts lists and returns if one matches":
        opt = ['a', 'b', '--foo']
        assert self.parser.has(opt) == True


    it "returns none if cannot match from a list":
        opt = ['a', 'b']
        assert self.parser.has(opt) == False


    it "deals with single items that match":
        assert self.parser.has('--foo') == True


    it "returns False when a single item does not match":
        assert self.parser.has('--asdadfoo') == False



describe "catches help":


    before each:
        self.parser = argopts.ArgOpts(['--foo'])


    it "catches only help if it sees it as an argument":
        self.parser.args = ['foo', 'bar']
        assert self.parser.catches_help() == False


    it "catches single dash h":
        self.parser.args = ['-h']
        assert self.parser.catches_help() == True


    it "catches double dash h":
        self.parser.args = ['--h']
        assert self.parser.catches_help() == True


    it "catches double dash help":
        self.parser.args = ['--help']
        assert self.parser.catches_help() == True


    it "catches help if it sees it as an argument":
        self.parser.args = ['-h']
        assert self.parser.catches_help() == True



describe "catches version":


    before each:
        self.parser = argopts.ArgOpts(['--foo'])


    it "catches only version if it sees it as an argument":
        self.parser.args = ['foo', 'bar']
        assert self.parser.catches_version() == False


    it "catches double dash version":
        self.parser.args = ['foo', '--version']
        assert self.parser.catches_version() == True


    it "catches version if it sees it as an argument":
        self.parser.args = ['foo', 'version']
        assert self.parser.catches_version() == True


########NEW FILE########
__FILENAME__ = case_cli
import os
import sys
from konira.util import StringIO
from konira    import KoniraCommands



describe "stdout messages for the command line":


    before all:
        self.commands = KoniraCommands(argv=[], parse=False, test=True)


    before each:
        self.original_stdout = sys.stdout
        self.original_stderr = sys.stderr
        sys.stderr = self.mystderr = StringIO()
        sys.stdout = self.mystdout = StringIO()


    after each:
        sys.stdout = self.original_stdout
        sys.stderr = self.original_stderr

    
    it "should go to stdout if a flag is passed in":
        self.commands.msg("A stdout message")
        assert self.mystdout.getvalue() == "A stdout message\n"


    it "does not output stderr messages when stdout flaf is set":
        self.commands.msg("A stdout message")
        assert self.mystderr.getvalue() == ""


    it "outputs to stderr if a flag is passed in":
        self.commands.msg("A stderr message", stdout=False)
        assert self.mystderr.getvalue() == "A stderr message\n"


    it "does not output to stdout if the stderr flag is set":
        self.commands.msg("A stderr message", stdout=False)
        assert self.mystdout.getvalue() == ""



describe "getting tests and paths from arguments":


    before all:
        self.commands = KoniraCommands(argv=[], parse=False, test=True)


    it "returns the path only when it cannot split further":
        path = "/path/to/my/tests"
        from_path = self.commands.test_from_path(path)
        assert from_path.get('path') == path
        assert len(from_path)        == 1


    it "returns a class name if it can split more than once":
        path = "/path/to/my/tests::myclass"
        from_path = self.commands.test_from_path(path)
        assert len(from_path)              == 2
        assert from_path.get('class_name') == 'Case_myclass'
        assert from_path.get('path')       == '/path/to/my/tests'


    it "returns a valid case class name if it can split the path":
        path = "/path/to/my/tests::my separated class"
        from_path = self.commands.test_from_path(path)
        assert len(from_path)              == 2
        assert from_path.get('class_name') == 'Case_my_separated_class'
        assert from_path.get('path')       == '/path/to/my/tests'


    it "returns the path class and method name if it can":
        path = "/path::my class::my method"
        from_path = self.commands.test_from_path(path)
        assert len(from_path)               == 3
        assert from_path.get('class_name')  == 'Case_my_class'
        assert from_path.get('method_name') == 'it_my_method'
        assert from_path.get('path')        == '/path'


    it "always return the path if it fails to split garbage":
        path = "/path$$$"
        from_path = self.commands.test_from_path(path)
        assert len(from_path)        == 1
        assert from_path.get('path') == path



describe "getting parsed paths from arguments":


    before all:
        self.commands = KoniraCommands(argv=[], parse=False, test=True)
        self.cwd = os.getcwd()


    it "returns the current only the cwd for invalid paths":
        args = ['/bin/konira', '/a/completely/wrong/path']
        path_dict = self.commands.path_from_argument(args)
        assert len(path_dict)        == 1
        assert path_dict.get('path') == self.cwd


    it "if it is a valid path then return a dict with other options":
        args = ['/bin/konira', '/tmp']
        path_dict = self.commands.path_from_argument(args)
        assert len(path_dict)               == 3
        assert path_dict.get('class_name')  == None
        assert path_dict.get('method_name') == None
        assert path_dict.get('path')        == '/tmp'


    it "returns classes with paths if it is valid":
        args = ['/bin/konira', '/tmp::my class']
        path_dict = self.commands.path_from_argument(args)
        assert len(path_dict)               == 3
        assert path_dict.get('class_name')  == 'Case_my_class'
        assert path_dict.get('method_name') == None
        assert path_dict.get('path')        == '/tmp'

        
    it "returns classes and method when valid paths are passed":
        args = ['/bin/konira', '/tmp::my class:: my method']
        path_dict = self.commands.path_from_argument(args)
        assert len(path_dict)               == 3
        assert path_dict.get('class_name')  == 'Case_my_class'
        assert path_dict.get('method_name') == 'it_my_method'
        assert path_dict.get('path')        == '/tmp'


    it "returns the cwd if no paths are sent":
        args = ['/bin/konira']
        path_dict = self.commands.path_from_argument(args)
        assert len(path_dict)        == 1
        assert path_dict.get('path') == self.cwd

########NEW FILE########
__FILENAME__ = case_collector
import os
import konira
from konira.util      import StringIO
from konira.collector import FileCollector, globals_from_file
from util             import Foo


describe "path collection":


    before each:
        self.f = FileCollector(path='/asdf')


    it "should be a list":
        assert isinstance(self.f, list)


    it "does not match normal python files":
        py_file = "foo.py"
        assert self.f.valid_module_name.match(py_file) == None


    it "matches upper case python cases":
        py_file = "CASE_foo.py"
        assert self.f.valid_module_name.match(py_file)


    it "does not match case without underscores":
        py_file = "casfoo.py"
        assert self.f.valid_module_name.match(py_file) == None


    it "does not match if it doesn't start with case_":
        py_file = "foo_case.py"
        assert self.f.valid_module_name.match(py_file) == None


    it "matches if it has camelcase":
        py_file = "CaSe_foo.py"
        assert self.f.valid_module_name.match(py_file)


    it "does not match if it starts with underscore":
        py_file = "case_foo.py"
        assert self.f.valid_module_name.match(py_file)


    it "raises SystemExit if it user match is borked":
        raises SystemExit: FileCollector(path='/tmp', config={'collect-match':'*.py'})


    it "if user_match and case_insensitive IGNORECASE is used":
        config = {'collect-match': 'bar', 'collect-ci': True}
        collector = FileCollector(path='/asdf', config=config)

        assert collector.valid_module_name.match('BaR')


    it "if user_match and not case_insensitive no IGNORECASE is used":
        config = {'collect-match': 'bar'}
        collector = FileCollector(path='/asdf', config=config)

        assert collector.valid_module_name.match('BaR') == None



describe 'global values from file':


    before each:
        with open('/tmp/case_test.py', 'w') as self.case_test:
            self.case_test.write("import sys")


    after each:
        try:
            os.remove('/tmp/case_test.py')
        except:
            pass # who cares if you can't


    it 'should see globals':
        globs = globals_from_file('/tmp/case_test.py')
        assert globs
        assert len(globs) == 2


    it "raises IOError when it tries an invalid path":
        raises IOError: globals_from_file('/foo/bar/foo.py')


    it "raises TypeError when no filename is passed":
        raises TypeError: globals_from_file()

    it "is able to import from relative or same level modules":
        subject = Foo()
        assert subject.bar() is True

########NEW FILE########
__FILENAME__ = case_exc
import konira
import inspect
from konira.exc         import (KoniraIOError, KoniraExecutionError, KoniraNoSkip, 
                                KoniraReassertError, KoniraFirstFail)
from konira             import exc



describe "dont read from input":


    before each:
        self.dont_read = exc.DontReadFromInput()


    it "asks if you are using pdb":
        message = "reading from stdin while output is captured (using pdb?)"
        assert self.dont_read.msg == message


    it "throws an exception if you call flush":
        raises KoniraIOError: self.dont_read.flush()


    it "throws an exception if you call flush with any arguments":
        raises KoniraIOError: self.dont_read.flush(True, False)


    it "throws an exception if you call write":
        raises KoniraIOError: self.dont_read.write()


    it "throws an exception if you call write with any arguments":
        raises KoniraIOError: self.dont_read.write(True, False)


    it "throws an exception if you call read":
        raises KoniraIOError: self.dont_read.read()


    it "throws an exception if you call read with any arguments":
        raises KoniraIOError: self.dont_read.read(True, False)


    it "raises when you call readline, readlines or iter":
        raises KoniraIOError: self.dont_read.__iter__()
        raises KoniraIOError: self.dont_read.readline()
        raises KoniraIOError: self.dont_read.readlines()



describe "konira execution error exception":


    before all:
        self.exc_err = exc.KoniraExecutionError 

    
    it "is an Exception type":
        type(self.exc_err) == Exception
    

    it "raises when there are insufficient args":
        raises TypeError: self.exc_err()


    it "raises a konira execution error":
        args = ('exc_name', 'filename', 1, 'a message', 'exc')
        exc = self.exc_err('a', 'b', 'c', 'd', 'e')
        raises KoniraExecutionError: raise exc



describe "konira no skip exception":


    it "raises a konira no skip exception":
        exc_err = exc.KoniraNoSkip
        raises KoniraNoSkip: raise exc_err



describe "konira reassert error exception":


    it "raises a reassert error exception":
        exc_err = exc.KoniraReassertError
        raises KoniraReassertError: raise exc_err



describe "konira first fail exception":


    it "raises a first fail exception":
        exc_err = exc.KoniraFirstFail
        raises KoniraFirstFail: raise exc_err



describe "konira IO Error exception":


    it "raises TypeError when arguments are not enough":
        exc_err = exc.KoniraIOError
        raises TypeError: raise exc_err

    it "raises a konira IO Error":
        exc_err = exc.KoniraIOError
        raises KoniraIOError: raise exc_err("an exception message")
    


describe "Source False value and assertions":

    before all:
        try:
            assert False
        except:
            self.false_trace = inspect.trace()[0]

    before each:
        self.source = exc.Source(self.false_trace)


    it "returns invalid when it cannot match correctly":
        assert self.source.is_valid == False


    it "can return the actual assert line stripping out assert":
        assert self.source.line == 'False'


    it "parses and evals a single assert statement":
        assert self.source._left_text == 'False'
        assert self.source.left_value == False


    it "raises index error when doing eval of a right value of a single assert":
        raises IndexError: self.source.right_value


    it "is able to get the actual source line":
        assert self.source.line == 'False'


    it "should not be valid because there is no operand":
        assert self.source.is_valid == False


describe "Source equality assertions and values":

    before all:
        try:
            assert 1 == 2
        except:
            self.eq_trace = inspect.trace()[0]

    before each:
        self.source = exc.Source(self.eq_trace)


    it "catches equality operand":
        assert self.source.operand == '=='


    it "parses and evalueates left values and text values with an equality operand":
        assert self.source._left_text == '1'
        assert self.source.left_value == 1


    it "parses and evaluates right values and text values with an equality operand":
        assert self.source._right_text == '2'
        assert self.source.right_value == 2


    it "is able to get the actual source line":
        assert self.source.line ==  '1 == 2'



describe "Source more than or equal assertions and values":


    before all:
        try:
            assert 1 >= 2
        except:
            self.mte_trace = inspect.trace()[0]


    before each:
        self.source = exc.Source(self.mte_trace)


    it "catches more than or equal operand":
        assert self.source.operand == '>='


    it "parses and evalueates left values and text values with an equality operand":
        assert self.source._left_text == '1'
        assert self.source.left_value == 1


    it "parses and evaluates right values and text values with an equality operand":
        assert self.source._right_text == '2'
        assert self.source.right_value == 2


    it "is able to get the actual source line":
        assert self.source.line == '1 >= 2'



describe "Source less than or equal assertions and values":


    before all:
        try:
            assert 2 <= 1
        except:
            self.lte_trace = inspect.trace()[0]


    before each:
        self.source = exc.Source(self.lte_trace)


    it "catches less than or equal operand":
        assert self.source.operand == '<='


    it "parses and evalueates left values and text values with an equality operand":
        assert self.source._left_text == '2'
        assert self.source.left_value == 2


    it "parses and evaluates right values and text values with an equality operand":
        assert self.source._right_text == '1'
        assert self.source.right_value == 1
     

    it "is able to get the actual source line":
        assert self.source.line == '2 <= 1'



describe "Source not equal assertions and values":


    before all:
        try:
            assert 'foo' != 'foo'
        except:
            self.ne_trace = inspect.trace()[0]


    before each:
        self.source = exc.Source(self.ne_trace)
        
        
    it "catches not equal operand":
        assert self.source.operand == '!='


    it "parses and evaluates right values and text values with a not equal operand":
        assert type(self.source._right_text) == str
        assert self.source.right_value       == 'foo'


    it "parses and evaluates left values and text values with a not equal operand":
        assert type(self.source._left_text) == str
        assert self.source.left_value       == 'foo'


    it "is able to get the actual source line":
        assert self.source.line == """'foo' != 'foo'"""

    

describe "Source is assertions and values":


    before all:
        try:
            assert 'foo' is 'Foo'
        except:
            self.is_trace = inspect.trace()[0]


    before each:
        self.source = exc.Source(self.is_trace)


    it "catches the is keyword operand":
        assert self.source.operand == ' is '


    it "parses and evals right values and text values with an is operand":
        assert type(self.source._right_text) == str
        assert self.source.right_value       == 'Foo'

    
    it "parses and evals left values and text values with an is operand":
        assert type(self.source._left_text) == str
        assert self.source.left_value       == 'foo'


    it "is able to get the actual source line":
        assert self.source.line == """'foo' is 'Foo'"""



describe "Source more than assertions and values":


    before all:
        try:
            assert 1 > 2
        except:
            self.mt_trace = inspect.trace()[0]

    before each:
        self.source = exc.Source(self.mt_trace)


    it "catches more than operand":
        assert self.source.operand == '>'


    it "parses and evaluates left values and text values with an equality operand":
        assert self.source._left_text == '1'
        assert self.source.left_value == 1


    it "parses and evaluates right values and text values with an equality operand":
        assert self.source._right_text == '2'
        assert self.source.right_value == 2


    it "is able to get the actual source line":
        assert self.source.line == '1 > 2'
    


describe "Source less than assertions and values":


    before all:
        try:
            assert 2 < 1
        except:
            self.lt_trace = inspect.trace()[0]


    before each:
        self.source = exc.Source(self.lt_trace)


    it "catches less than operand":
        assert self.source.operand == '<'


    it "parses and evals right values and text values with a less than operand":
        assert self.source._right_text == '1'
        assert self.source.right_value == 1


    it "parses and evals left values and text values with a less than operand":
        assert self.source._left_text == '2'
        assert self.source.left_value == 2


    it "is able to get the actual source line":
        assert self.source.line == '2 < 1'



describe "Source not in values and assertions":


    before all:
        try:
            assert 'foo' not in 'a foo here'
        except:
            self.notin_trace = inspect.trace()[0]


    before each:
        self.source = exc.Source(self.notin_trace)


    it "catches the not int keyword operand":
        assert self.source.operand == ' not in '


    it "parses and evals left and text values from a not in operand":
        assert type(self.source._left_text) == str
        assert self.source.left_value       == 'foo'


    it "parses and evals right and text values from a not in operand":
        assert type(self.source._right_text) == str
        assert self.source.right_value       == 'a foo here'


    it "is able to get the actual source line":
        assert self.source.line == """'foo' not in 'a foo here'"""



describe "konira assert helper function":


    before all:
        try:
            assert False
        except:
            self.trace = inspect.trace()[0]

        try:
            assert "long string" == "Long string"
        except:
            self.bad_trace = inspect.trace()[0]

        try:
            assert ('a',1) == ('b',1)
        except:
            self.tpl_trace = inspect.trace()[0]

        try:
            assert {'a':1} == {'b':1}
        except:
            self.dict_trace = inspect.trace()[0]


    it "is None when the source is invalid":
        reassert = exc.konira_assert(self.trace)
        assert reassert == None


    it "returns a valid diff when comparing strings":
        reassert = exc.konira_assert(self.bad_trace)
        description = ['long string == Long string', '- long string', '? ^', '+ Long string', '? ^']
        assert reassert == description
        
        
    it "returns valid dictionary comparisons":
        reassert = exc.konira_assert(self.dict_trace)
        description = ["{'a': 1} == {'b': 1}", "- {'a': 1}", '?   ^', "+ {'b': 1}", '?   ^']
        assert reassert == description


    it "returns tuple comparisons":
        reassert = exc.konira_assert(self.tpl_trace)
        description = ["('a', 1) == ('b', 1)", "At index 0 diff: 'a' != 'b'", "- ('a', 1)", '?   ^', "+ ('b', 1)", '?   ^']
        assert reassert == description



describe "Assert repr from source lines":


    it "returns None when it does not have an equality operand":
        _repr = exc.assertrepr_compare('==', None, '')
        assert _repr == None

########NEW FILE########
__FILENAME__ = case_output
import inspect
import sys
import konira

from konira.util import StringIO
from konira.util import return_exception_trace
from konira    import output


describe "writer and ansi codes":


    before each:
        self.stdout = StringIO()
        self.writer = output.Writer(stdout=self.stdout)

    it "knows if it is atty or not":
        assert self.writer.isatty == False


    it "returns empty strings for colors if it is not atty":
        self.writer.isatty = False
        assert self.writer.color("") == ''


    it "returns empty strings for colors when for is None":
        self.writer.isatty = False
        assert self.writer.color(None) == ''


    it "raises a keyerror when you try to get an invalid color":
        self.writer.isatty = True
        raises KeyError: self.writer.color('foo')


    it "returns blue ansi codes":
        self.writer.isatty = True
        assert self.writer.color('blue') == '\033[94m'
        

    it "returns green ansi codes":
        self.writer.isatty = True
        assert self.writer.color('green') == '\033[92m'


    it "returns yellow ansi codes":
        self.writer.isatty = True
        assert self.writer.color('yellow') == '\033[93m'


    it "returns red ansi codes":
        self.writer.isatty = True
        assert self.writer.color('red') == '\033[91m'


    it "returns bold ansi codes":
        self.writer.isatty = True
        assert self.writer.color('bold') == '\033[1m'


    it "returns ends ansi codes":
        self.writer.isatty = True
        assert self.writer.color('ends') == '\033[0m'



describe "writer stdout ouput":


    before each:
        self.stdout = StringIO()
        self.writer = output.Writer(stdout=self.stdout)


    it "println to stdout the string correctly without colors":
        self.writer.println("a string with no colors")
        assert self.stdout.getvalue() == "a string with no colors"


    it "writes to stdout without newlines but with colors":
        self.writer.isatty = True
        self.writer.write("A blue string", "blue")
        assert self.stdout.getvalue() == '\033[94mA blue string\033[0m'


    it "writes to stdout without newlines with no colors if not atty":
        self.writer.write("A blue string", "blue")
        assert self.stdout.getvalue() == 'A blue string'


    it "writelns with newline and colors":
        self.writer.isatty = True
        self.writer.writeln("A blue string", "blue")
        assert self.stdout.getvalue() == '\n\033[94mA blue string\033[0m'


    it "writelns with newline and no colors":
        self.writer.writeln("A blue string", "blue")
        assert self.stdout.getvalue() == '\nA blue string'


    it "writes n number of newlines":
        self.writer.newline(lines=3)
        assert self.stdout.getvalue() == '\n\n\n'


    it "writes a single newline by default":
        self.writer.newline()
        assert self.stdout.getvalue() == '\n'


    it "returns valid green strings on demand":
        self.writer.isatty = True
        assert self.writer.green("A green string") == '\033[92mA green string\033[0m'


    it "returns valid red strings on demand":
        self.writer.isatty = True
        assert self.writer.red("A red string") == '\033[91mA red string\033[0m' 


    it "returns valid bold strings on demand":
        self.writer.isatty = True
        assert self.writer.bold("A bold string") == '\033[1mA bold string\033[0m' 



describe "terminal writer stdout ouput":


    before each:
        self.stdout         = StringIO()
        self.writer         = output.Writer(stdout=self.stdout)
        self.twriter        = output.TerminalWriter(False)
        self.twriter.writer = self.writer

    after each:
        self.stdout = StringIO()
        
    it "outputs green spec titles":
        self.twriter.green_spec("green spec title")
        assert self.stdout.getvalue() == "\n    Green spec title"


    it "outputs a dot for green specs when dotted option is passed":
        self.twriter.dotted = True
        self.twriter.green_spec("green spec title")
        assert self.stdout.getvalue() == '.'


    it "outputs red spec titles":
        self.twriter.red_spec("red spec title")
        assert self.stdout.getvalue() == "\n    Red spec title"


    it "outputs an eff for red specs when dotted option is passed":
        self.twriter.dotted = True
        self.twriter.red_spec("red spec title")
        assert self.stdout.getvalue() == 'F'


    it "is None when dotted for out case":
        self.twriter.dotted = True
        assert self.twriter.out_case("an out case") == None
        assert self.stdout.getvalue() == ''


    it "outputs an out case when not dotted":
        assert self.twriter.dotted ==  False
        self.twriter.out_case("an out case") 
        assert self.stdout.getvalue() == '\n\nAn out case'



describe "footer output":


    before each:
        self.stdout = StringIO()
        self.writer = output.Writer(stdout=self.stdout)
        self.footer = output.out_footer


    it "outputs all passed when no failures and cases are more than zero":
        self.footer(1, 0, 0, std=self.writer)
        assert self.stdout.getvalue() == "\n\n\nAll 1 spec passed in 0 secs.\n"


    it "outputs plural specs when no failures and cases are more than zero":
        self.footer(2, 0, 0, std=self.writer)
        assert self.stdout.getvalue() == "\n\n\nAll 2 specs passed in 0 secs.\n"


    it "outputs failures as singular":
        self.footer(1, 1, 0, std=self.writer)
        assert self.stdout.getvalue() == "\n\n\n1 spec failed, 1 total in 0 secs.\n"



describe "report results":


    before all:
        self.false_failure = return_exception_trace()
        #try:
        #    assert False
        #except Exception as e:
        #    trace = inspect.trace()
        #    self.false_failure = dict(
        #                    failure  = sys.exc_info(),
        #                    trace    = trace,
        #                    exc_name = e.__class__.__name__
        #                   ) 
        #    #self.false_trace = inspect.trace()[0]


    before each:
        class FakeObject(object): pass
        self.stdout         = StringIO()
        self.writer         = output.Writer(stdout=self.stdout)
        self.results        = FakeObject()
        self.results.config = {}
        self.reporter       = output.ReportResults


    it "writes a nice footer":
        self.results.total_cases    = 1
        self.results.total_failures = 1
        self.results.elapsed        = 0
        result = self.reporter(self.results, self.writer)
        result.footer()
        assert self.stdout.getvalue() == "\n\n\n1 spec failed, 1 total in 0 secs.\n"


    it "when sorting it returns only ten items":
        profiles = [(a, a, a) for a in range(0,15)]
        self.results.profiles = profiles 
        result = self.reporter(self.results, self.writer)
        assert len(result._sort_profiles()) == 10
        

    it "when sorting it does so in descending order":
        profiles = [(a, a, a) for a in range(0,15)]
        self.results.profiles = profiles 
        result = self.reporter(self.results, self.writer)
        assert result._sort_profiles()[0] == (14,14,14)
        assert result._sort_profiles()[1] == (13,13,13)
        assert result._sort_profiles()[2] == (12,12,12)


    it "outputs normalized test case names in the profiler":
        profiles = [(a, 'test_case', a) for a in range(0,15)]
        self.results.profiles = profiles 
        result = self.reporter(self.results, self.writer)
        result.profiler()
        assert "14 - Test case" in self.stdout.getvalue()


    it "displays a header showgin profiling is enabled":
        profiles = [(a, 'test_case', a) for a in range(0,15)]
        self.results.profiles = profiles 
        result = self.reporter(self.results, self.writer)
        result.profiler()
        expected = "Profiling enabled\n10 slowest tests shown:\n" 
        assert expected in self.stdout.getvalue()


    it "orders single profile messages by time and case name":
        result = self.reporter(self.results, self.writer)
        result._output_profiles((0, 'test_case'))
        assert self.stdout.getvalue() == '\n0 - Test case'


    it "only gices the 10 first digits in elapsed time":
        result = self.reporter(self.results, self.writer)
        result._output_profiles(('0.00000099999', 'test_case'))
        assert self.stdout.getvalue() == '\n0.00000099 - Test case'


    it "can report profiling errors and failures all at once":
        self.results.total_cases    = 1
        self.results.total_failures = 1
        self.results.elapsed        = 0
        self.results.failures = [self.false_failure]
        self.results.errors = [self.false_failure]
        self.results.profiles = [('0', 'Test_case')]
        result = self.reporter(self.results, self.writer)
        result.report()
        output = self.stdout.getvalue()
        assert 'AssertionError'  in output
        assert 'Failures'        in output
        assert 'Starts and Ends' in output
        assert 'File:'           in output
        assert 'util.py'         in output
        assert '1 spec failed, 1 total in 0 secs.' in output





########NEW FILE########
__FILENAME__ = case_runner
import os
import inspect
from konira        import Runner
from konira.runner import TestEnviron, safe_skip_call


describe "safe test environment calls":

    before all:
        def _raise():
            assert False
        
        def _not_raise():
            assert True
        self._raise     = _raise
        self._not_raise = _not_raise

    before each:
        self.runner = Runner(None, {})


    it "appends an error when an exception happens":
        self.runner.safe_environ_call(self._raise)
        assert len(self.runner.errors)               == 1
        assert self.runner.errors[0].get('exc_name') == 'AssertionError'


    it "does not append errors if the call does not raise":
        self.runner.safe_environ_call(self._not_raise)
        assert len(self.runner.errors) == 0
        assert self.runner.errors      == []



describe "save skip calls":


    before all:
        def _raise():
            assert False
        
        def _not_raise():
            assert True

        def _skip_raise():
            raise KoniraNoSkip

        self._raise      = _raise
        self._not_raise  = _not_raise
        self._skip_raise = _skip_raise


    before each:
        self.runner = Runner(None, {})


    it "returns true when it does not raise":
        result = safe_skip_call(self._not_raise)
        assert result


    it "returns false when it raises anything but a NoSkip exception":
        result = safe_skip_call(self._raise)
        assert result == False


    it "returns false when it raises a KoniraNoSkip exception":
        result = safe_skip_call(self._skip_raise)
        assert result == False


describe "running a spec suite":


    before all:
        self.cwdir    = os.getcwd()
        self.cwfile   = inspect.getfile(inspect.currentframe())


    before each:
        self.runner = Runner(None, {})


    it "appends an error when it raises at class collection":
        self.runner.paths = [self.cwdir]
        self.runner.run()
        assert len(self.runner.errors) == 1
        assert self.runner.errors[0].get('exc_name') == 'IOError'



describe "get test environ setup values":


    before each:
        class Object(object):
            pass
        self.object = Object


    it "does not have any environ attribute":
        environ = TestEnviron(self.object)
        assert environ.has_skip_if     == False
        assert environ.has_before_all  == False
        assert environ.has_before_each == False
        assert environ.has_after_all   == False
        assert environ.has_after_each  == False


    it "checks for skip if properties":
        skip_if          = self.object()
        skip_if._skip_if = True
        environ          = TestEnviron(skip_if)
        assert environ.has_skip_if     == True
        assert environ.has_before_all  == False
        assert environ.has_before_each == False
        assert environ.has_after_all   == False
        assert environ.has_after_each  == False


    it "checks for before all properties":
        before_all = self.object()
        before_all._before_all = True
        environ = TestEnviron(before_all)
        assert environ.has_skip_if     == False
        assert environ.has_before_all  == True
        assert environ.has_before_each == False
        assert environ.has_after_all   == False
        assert environ.has_after_each  == False


    it "checks for before each properties":
        before_each = self.object()
        before_each._before_each = True
        environ = TestEnviron(before_each)
        assert environ.has_skip_if     == False
        assert environ.has_before_all  == False
        assert environ.has_before_each == True
        assert environ.has_after_all   == False
        assert environ.has_after_each  == False


    it "checks for after all properties":
        after_all = self.object()
        after_all._after_all = True
        environ = TestEnviron(after_all)
        assert environ.has_skip_if     == False
        assert environ.has_before_all  == False
        assert environ.has_before_each == False
        assert environ.has_after_all   == True
        assert environ.has_after_each  == False


    it "checks for after each properties":
        after_each = self.object()
        after_each._after_each = True
        environ = TestEnviron(after_each)
        assert environ.has_skip_if     == False
        assert environ.has_before_all  == False
        assert environ.has_before_each == False
        assert environ.has_after_all   == False
        assert environ.has_after_each  == True


    it "catches all properties set":
        properties = self.object()
        properties._after_all   = True
        properties._after_each  = True
        properties._before_all  = True
        properties._before_each = True
        properties._skip_if     = True

        environ = TestEnviron(properties)
        assert environ.has_skip_if     == True
        assert environ.has_before_all  == True
        assert environ.has_before_each == True
        assert environ.has_after_all   == True
        assert environ.has_after_each  == True



describe "cached let attributes":

    let is_cached   = True
    let cached_dict = {'value' : False}

    it "correctly sees a cached attribute":
        assert self.is_cached == True


    it "mangles attributes that get reset":
        self.is_cached = False
        assert self.is_cached == False


    it "adds values to a cached dict attr":
        assert self.cached_dict.get('value') == False
        self.cached_dict = {'value': True}
        assert self.cached_dict.get('value') == True


    it "will get reset back to the original dict":
        assert self.cached_dict.get('value') == False

########NEW FILE########
__FILENAME__ = case_tokenizer
from konira.util import StringIO
from konira    import tokenizer


describe "quote remover":


    before each:
        self.remover = tokenizer.quote_remover


    it "removes commas from strings":
        assert self.remover("a,separated,string") == "aseparatedstring"


    it "removes commas respecting whitespace":
        assert self.remover("a, separated, string") == "a separated string"


    it "removes single quotes from strings":
        assert self.remover("a ' string '") == "a  string "


    it "removes a combination of commas and quotes":
        assert self.remover("a, 'string',") == "a string"


    it "removes dots from strings":
        assert self.remover("a. dotted. string.") == "a dotted string"


    it "respects camel case strings":
        assert self.remover("a Camel Case string") == "a Camel Case string"



describe "valid method names":


    before each:
        self.valid = tokenizer.valid_method_name


    it "replaces whitespace with underscores":
        assert self.valid("a name with underscores") == "it_a_name_with_underscores"


    it "removes double quotes from strings":
        assert self.valid('a double \"quoted\" string') == "it_a_double_quoted_string"


    it "removes commas from strings":
        assert self.valid('a ,in a string,') == "it_a_in_a_string"


    it "removes commas quotes and double quotes from strings":
        assert self.valid('a \", in a string\'') == 'it_a__in_a_string'


    it "removes dots from strings":
        assert self.valid("a. dotted. string.") == "it_a_dotted_string"


    it "respects camel case from strings":
        assert self.valid("a CamelCase string") == "it_a_CamelCase_string"



describe "valid class names":


    before each:
        self.valid = tokenizer.valid_class_name


    it "replaces whitespace with underscores":
        assert self.valid("a string with whitespace") == "Case_a_string_with_whitespace"


    it "removes double quotes from strings":
        assert self.valid("a string\"") == "Case_a_string"


    it "removes dots and commas from strings":
        assert self.valid("a. string, \'") == "Case_a_string_"


    it "removes single quotes from strings":
        assert self.valid("\'single quote") == "Case_single_quote"


    it "respects camel case in strings":
        assert self.valid("my Test") == "Case_my_Test"



describe "valid raises detection":


    before each:
        self.valid = tokenizer.valid_raises


    it "is True when the value is None":
        assert self.valid(None) == True


    it "is True when the value is an empty string":
        assert self.valid(" ") == True


    it "is false when the value has a character at the start":
        assert self.valid("d ") == False


    it "is false when the value has a character at the end":
        assert self.valid("   d") == False


    it "is true when there are non whitespace chars":
        assert self.valid("\n ") == True


    it "is true when an empty string is passed":
        assert self.valid("") == True



describe "translate dsl into valid Python":
    

    before each:
        self.translate = tokenizer.translate
        self.line      = StringIO


    it "never do implicit imports":
        line = self.line('').readline
        assert self.translate(line) == [[0, '']]

    
    it "translates describe into a class":
        line = self.line('describe "my test class":\n pass')
        result = self.translate(line.readline)
        assert len(result) == 11
        assert result[0][1]   == 'class'
        assert result[1][1]   == 'Case_my_test_class'
        assert result[2][1]   == '('
        assert result[3][1]   == 'object'
        assert result[4][1]   == ')'
        assert result[5][1]   == ':'
        assert result[6][1]   == '\n'
        assert result[7][1]   == ' '
        assert result[8][1]   == 'pass'
        assert result[9][1]   == ''
        assert result[10][1]  == ''
        

    it "translates an it to a def":
        line = self.line('it "should test my method":\n pass')
        result = self.translate(line.readline)
        assert len(result) == 11
        assert result[0][1]   == 'def'
        assert result[1][1]   == 'it_should_test_my_method'
        assert result[2][1]   == '('
        assert result[3][1]   == 'self'
        assert result[4][1]   == ')'
        assert result[5][1]   == ':'
        assert result[6][1]   == '\n'
        assert result[7][1]   == ' '
        assert result[8][1]   == 'pass'
        assert result[9][1]   == ''
        assert result[10][1]  == ''


    it "translates a describe with inheritance":
        line = self.line('describe "my test class", Foo:\n pass')
        result = self.translate(line.readline)
        assert len(result) == 11
        assert result[0][1]   == 'class'
        assert result[1][1]   == 'Case_my_test_class'
        assert result[2][1]   == '('
        assert result[3][1]   == 'Foo'
        assert result[4][1]   == ')'
        assert result[5][1]   == ':'
        assert result[6][1]   == '\n'
        assert result[7][1]   == ' '
        assert result[8][1]   == 'pass'
        assert result[9][1]   == ''
        assert result[10][1]  == ''


    it "translates a describe with inheritance regardless of space":
        line = self.line('describe "my test class",Foo:\n pass')
        result = self.translate(line.readline)
        assert len(result) == 11
        assert result[0][1]   == 'class'
        assert result[1][1]   == 'Case_my_test_class'
        assert result[2][1]   == '('
        assert result[3][1]   == 'Foo'
        assert result[4][1]   == ')'
        assert result[5][1]   == ':'
        assert result[6][1]   == '\n'
        assert result[7][1]   == ' '
        assert result[8][1]   == 'pass'
        assert result[9][1]   == ''
        assert result[10][1]  == ''


    it "translates a describe with inheritance with a lot of whitespace":
        line = self.line('describe "my test class"    ,          Foo:\n pass')
        result = self.translate(line.readline)
        assert len(result) == 11
        assert result[0][1]   == 'class'
        assert result[1][1]   == 'Case_my_test_class'
        assert result[2][1]   == '('
        assert result[3][1]   == 'Foo'
        assert result[4][1]   == ')'
        assert result[5][1]   == ':'
        assert result[6][1]   == '\n'
        assert result[7][1]   == ' '
        assert result[8][1]   == 'pass'
        assert result[9][1]   == ''
        assert result[10][1]  == ''


    it "translates skip if constructors":
        line = self.line('skip if:\n pass')
        result = self.translate(line.readline)
        assert len(result) == 11
        assert result[0][1]   == 'def'
        assert result[1][1]   == '_skip_if'
        assert result[2][1]   == '('
        assert result[3][1]   == 'self'
        assert result[4][1]   == ')'
        assert result[5][1]   == ':'
        assert result[6][1]   == '\n'
        assert result[7][1]   == ' '
        assert result[8][1]   == 'pass'
        assert result[9][1]   == ''
        assert result[10][1]  == ''


    it "translates before all constructors":
        line = self.line('before all:\n pass')
        result = self.translate(line.readline)
        assert len(result) == 11
        assert result[0][1]   == 'def'
        assert result[1][1]   == '_before_all'
        assert result[2][1]   == '('
        assert result[3][1]   == 'self'
        assert result[4][1]   == ')'
        assert result[5][1]   == ':'
        assert result[6][1]   == '\n'
        assert result[7][1]   == ' '
        assert result[8][1]   == 'pass'
        assert result[9][1]   == ''
        assert result[10][1]  == ''


    it "translates before each constructors":
        line = self.line('before each:\n pass')
        result = self.translate(line.readline)
        assert len(result) == 11
        assert result[0][1]   == 'def'
        assert result[1][1]   == '_before_each'
        assert result[2][1]   == '('
        assert result[3][1]   == 'self'
        assert result[4][1]   == ')'
        assert result[5][1]   == ':'
        assert result[6][1]   == '\n'
        assert result[7][1]   == ' '
        assert result[8][1]   == 'pass'
        assert result[9][1]   == ''
        assert result[10][1]  == ''


    it "translates after each constructors":
        line = self.line('after each:\n pass')
        result = self.translate(line.readline)
        assert len(result) == 11
        assert result[0][1]   == 'def'
        assert result[1][1]   == '_after_each'
        assert result[2][1]   == '('
        assert result[3][1]   == 'self'
        assert result[4][1]   == ')'
        assert result[5][1]   == ':'
        assert result[6][1]   == '\n'
        assert result[7][1]   == ' '
        assert result[8][1]   == 'pass'
        assert result[9][1]   == ''
        assert result[10][1]  == ''


    it "translates after all constructors":
        line = self.line('after all:\n pass')
        result = self.translate(line.readline)
        assert len(result) == 11
        assert result[0][1]   == 'def'
        assert result[1][1]   == '_after_all'
        assert result[2][1]   == '('
        assert result[3][1]   == 'self'
        assert result[4][1]   == ')'
        assert result[5][1]   == ':'
        assert result[6][1]   == '\n'
        assert result[7][1]   == ' '
        assert result[8][1]   == 'pass'
        assert result[9][1]   == ''
        assert result[10][1]  == ''


    it "translates raises into with statements":
        line = self.line('raises IOError: foo()')
        result = self.translate(line.readline)
        assert len(result) == 9
        assert result[0][1]   == 'with konira.tools.raises'
        assert result[1][1]   == '('
        assert result[2][1]   == 'IOError'
        assert result[3][1]   == ')'
        assert result[4][1]   == ':'
        assert result[5][1]   == 'foo'
        assert result[6][1]   == '('
        assert result[7][1]   == ')'
        assert result[8][1]   == ''


    it "does not translate a regular class":
        line = self.line('class Foo(object):\n pass')
        result = self.translate(line.readline)
        assert len(result) == 11
        assert result[0][1]   == 'class'
        assert result[1][1]   == 'Foo'
        assert result[2][1]   == '('
        assert result[3][1]   == 'object'
        assert result[4][1]   == ')'
        assert result[5][1]   == ':'
        assert result[6][1]   == '\n'
        assert result[7][1]   == ' '
        assert result[8][1]   == 'pass'
        assert result[9][1]   == ''
        assert result[10][1]  == ''


    it "does not translate a regular method":
        line = self.line('def foo(self):\n pass')
        result = self.translate(line.readline)
        assert len(result) == 11
        assert result[0][1]   == 'def'
        assert result[1][1]   == 'foo'
        assert result[2][1]   == '('
        assert result[3][1]   == 'self'
        assert result[4][1]   == ')'
        assert result[5][1]   == ':'
        assert result[6][1]   == '\n'
        assert result[7][1]   == ' '
        assert result[8][1]   == 'pass'
        assert result[9][1]   == ''
        assert result[10][1]  == ''


    it "translates let into a valid method":
        line = self.line('let foo = True')
        result = self.translate(line.readline)
        assert len(result)  == 4
        assert result[0][1] == '_let_foo'
        assert result[1][1] == '='
        assert result[2][1] == 'True'
        assert result[3][1] == ''


#
# Inheritance helpers
#
class Foo(object):

    def bar(self):
        return True

class Helpers(object):
    """ This class shows how Konira contructor helpers work
    so that they are individually tested afterwards
    """
    has_before_all  = False
    has_before_each = False
    has_after_each  = False
    has_after_all   = False

    def _before_all(self):
        self.has_before_all = True


    def _before_each(self):
        self.has_before_each = True


    def _after_each(self):
        self.has_after_each = True


    def _after_all(self):
        self.has_after_all = True



describe "class inheritance", Foo:


    it "is able to reach up to parent methods":
        assert self.bar() is True


describe "inheritance with constructor helpers", Helpers:
    # NOTE: These tests should not be run individually as they depend on each
    # other. I know - bad practice, but it is really the only way to test how
    # the constructors work (setting up before and after)


    it "before all works":
        # note that this test will run first
        assert self.has_before_all is True

    it "before each works":
        # note that this test will run second
        assert self.has_before_each is True

    it "works with after each":
        # this will run last
        assert self.has_after_each is True

    it "works with after all":
        # this is really a fake because we can't really test
        # the teardown after all tests since this is a test.
        # This functionality is properly "unit tested" elsewhere.
        assert self.has_after_all is False
        self._after_all()
        assert self.has_after_all is True

########NEW FILE########
__FILENAME__ = case_tools
import konira
from konira.exc import KoniraReassertError
from konira     import tools


describe "raises tool":

    before each:
        self.r = tools.raises

    it "is True when the exception matches":
        with self.r(): raise



describe "assert raises":

    it "raises when the exception does not match":
        assert_raises = tools.AssertRaises(Exception, None)
        raises KoniraReassertError: assert_raises.__exit__(None, None, None)


    it "is true when the exception matches":
        assert_raises = tools.AssertRaises(Exception, None)
        assert assert_raises.__exit__(Exception, None, None)


    it "raises when the exception message does not match":
        assert_raises = tools.AssertRaises(Exception, "foo")
        raises KoniraReassertError: assert_raises.__exit__(Exception, None, None)



########NEW FILE########
__FILENAME__ = case_util
from konira import util


describe "name convertion":


    it "replaces underscore with whitespace":
        name = "a_white_space_string"
        assert util.name_convertion(name) == 'A white space string'


    it "removes whitespaces from outer string":
        name = " a_white_space_string "
        assert util.name_convertion(name) == 'a white space string'


    it "removes case from a name string":
        name = "Case_foo_bar"
        assert util.name_convertion(name) == 'foo bar'


    it "does not remove case if not uppercase":
        name = "case_foo_bar"
        assert util.name_convertion(name) == 'Case foo bar'



describe "get class name":


    it "returns itself when it str does not start with case":
        name = "a string"
        assert util.get_class_name(name) == name 


    it "returns none when does not start with Case":
        name = """<class '_stdout_messages_for_the_command_line'>"""
        assert util.get_class_name(name) == None
        

    it "parses correctly when a valid class name is sent":
        name = """<class 'Case_stdout_messages_for_the_command_line'>"""
        assert util.get_class_name(name) == 'Case_stdout_messages_for_the_command_line'



#describe "stop watch":
#
#
#    it "returns no more than 5 chars":
#        swatch = util.StopWatch()
#        assert len(swatch.elapsed()) == 5
#

########NEW FILE########
__FILENAME__ = util

class Foo(object):
    """ A bare class to test same-level relative
    imports
    """

    def bar(self):
        return True

########NEW FILE########
__FILENAME__ = tokenizer
from tokenize           import NAME, OP, STRING, generate_tokens
import re



def quote_remover(string):
    _string = string.replace(",", "").replace(".", "")
    return _string.replace("'", "")


def valid_method_name(token):
    transform = token.strip().replace(" ", "_").replace("\"","" )
    return "it_%s" % quote_remover(transform)


def valid_class_name(token):
    transform = token.strip().replace(" ", "_").replace("\"","" )
    return "Case_%s" % quote_remover(transform)


def valid_raises(value):
    if not value:
        return True
    whitespace = re.compile(r'^\s*$')
    if whitespace.match(value):
        return True
    return False


def process_name(result, value, last_token, tokenum, last_type, descr_obj, last_kw):
    # From Describe to class - includes inheritance
    if value == 'describe':
        last_kw = 'describe'
        result.extend(([tokenum, 'class'],))

    elif last_type == OP and last_kw == 'describe':
        if descr_obj:
            result.extend(([NAME, value],
                           [OP, ')'],))
            last_kw   = None
            descr_obj = False

    # Skip if Constructors
    elif value == 'skip':
        result.extend(([tokenum, 'def'],))

    elif last_token == 'skip' and value == 'if':
        result.extend(([tokenum, '_skip_if'],
                       [OP, '('],
                       [NAME, 'self'],
                       [OP, ')']))

    # Before Constructors
    elif value == 'before':
        result.extend(([tokenum, 'def'],))

    elif last_token == 'before':
        result.extend(([tokenum, '_before_%s' % value],
                       [OP, '('],
                       [NAME, 'self'],
                       [OP, ')']))

    # After Constructors
    elif value == 'after':
        result.extend(([tokenum, 'def'],))

    elif last_token == 'after':
        result.extend(([tokenum, '_after_%s' % value],
                       [OP, '('],
                       [NAME, 'self'],
                       [OP, ')']))

    # From it to def
    elif value == 'it':
        result.extend(([tokenum, 'def'],))
    elif last_token == 'it':
        result.extend(([tokenum, valid_method_name(value)],
                       [OP, '('],
                       [NAME, 'self'],
                       [OP, ')'],))

    # From raises to with konira.tools.raises
    elif value == 'raises' and valid_raises(last_token):
        result.extend(([tokenum, 'with konira.tools.raises'],))

    elif last_token == 'raises':
        result.extend(([OP, '('],
                       [NAME, value],
                       [OP, ')'],))

    # From let to attribute
    elif value == 'let':
        result.extend(([tokenum, ''],))

    elif last_token == 'let':
        result.pop()
        result.extend(([tokenum, '_let_%s' % value],))

    else:
        result.append([tokenum, value])

    return result, descr_obj, last_kw



def process_string(result, value, last_token, tokenum, last_type, descr_obj, last_kw):
    if last_token == 'describe':
        last_kw   = 'describe'
        descr_obj = True
        result.extend(([NAME, valid_class_name(value)],))

    elif last_kw == 'describe':
        if descr_obj:
            result.extend(([OP, '('],
                           [NAME, 'object'],
                           [OP, ')'],
                           [OP, ':'],))
            last_kw   = None
            descr_obj = False

    elif last_token == 'it':
        result.extend(([tokenum, valid_method_name(value)],
                       [OP, '('],
                       [NAME, 'self'],
                       [OP, ')'],))

    else:
        result.append([tokenum, value])

    return result, descr_obj, last_kw



def process_operator(result, value, last_token, tokenum, last_type, descr_obj, last_kw):
    if value == ',' and last_type == STRING and last_kw == 'describe':
        if descr_obj:
            result.extend(([OP, '('],))
            last_kw   = 'describe'
            descr_obj = True

    elif last_type == STRING and last_kw == 'describe':
        if descr_obj:
            result.extend(([OP, '('],
                           [NAME, 'object'],
                           [OP, ')'],
                           [OP, ':'],))
            last_kw   = None
            descr_obj = False

    else:
        result.append([tokenum, value])

    return result, descr_obj, last_kw



def process_default(result, value, last_token, tokenum, last_type, descr_obj, last_kw):
    result.append([tokenum, value])
    return result, descr_obj, last_kw


# The dispatchers holds the tokenizer mappings, allowing
# to cut a huge if/elseif chaing that slows us down.
dispatcher={NAME: process_name, STRING: process_string, OP: process_operator}



def translate(readline):
    result     = []
    last_kw    = None
    last_token = None
    last_type  = None
    descr_obj  = False

    for tokenum, value, _, _, _ in generate_tokens(readline):
        process = dispatcher.get(tokenum, process_default)

        result, descr_obj, last_kw = process(result, value, last_token, tokenum, last_type, descr_obj, last_kw)

        last_token = value
        last_type  = tokenum

    return result

########NEW FILE########
__FILENAME__ = tools
from konira.exc import KoniraReassertError


def raises(cls=Exception, message=None):
    return AssertRaises(cls, message)



class AssertRaises(object):


    def __init__(self, exception_class, message):
        self._exception_class = exception_class
        self.message          = message


    def __enter__(self):
        pass


    def __exit__(self, exc_type, exc_value, traceback):
        success = not exc_type
        if success:
            raise KoniraReassertError(
                'Expected an exception of type %s but got none'
                % self._exception_class.__name__)
        else:
            return self.validate_failure(exc_type, exc_value)


    def validate_failure(self, exc_type, exc_value):
        wrong_message_was_raised = (self.message and
                                    self.message != str(exc_value))
        if wrong_message_was_raised:
            raise KoniraReassertError(
                "Expected %s('%s') but got %s('%s')" %
                 (self._exception_class.__name__,
                  str(self.message),
                  exc_type.__name__,
                  str(exc_value)))
        elif issubclass(exc_type, self._exception_class):
            return True
        else:
            pass


########NEW FILE########
__FILENAME__ = util
import re
import time
import sys
import inspect
if sys.version < '3':
    from cStringIO import StringIO
else:
    from io import StringIO

def return_exception_trace():
    """
    For testing purposes we need some valid
    tracebacks created for assertions.
    """
    try:
        assert False
    except Exception, e:
        trace = inspect.trace()
        return dict(
                        failure  = sys.exc_info(),
                        trace    = trace,
                        exc_name = e.__class__.__name__
                       )


def name_convertion(name, capitalize=True):
    name = name.replace('_', ' ').replace('Case', '')
    if capitalize:
        name = name.capitalize()
    return name.strip()



def get_class_name(class_name):
    try:
        name = str(class_name).split("'")[1]
    except IndexError:
        return class_name
    if name.startswith('Case_'):
        return name


#
# Let helpers
#

def get_let_name(method_name):
    return method_name.split('_let_')[-1]



def set_let_attrs(suite, let_map):
    if not let_map:
        return suite
    for k, v in let_map.items():
        setattr(suite, k, v)
    return suite



def get_let_attrs(suite):
    let_methods = collect_let_attrs(suite)
    if not let_methods:
        return {}
    value = getattr(suite, let_methods[-1])
    let_map = {}
    for method in let_methods:
        value = getattr(suite, method)
        valid_method = get_let_name(method)
        let_map[valid_method] = value
    return let_map



def collect_let_attrs(module):
    valid_let_method = re.compile(r'_let_[_a-z]\w*$', re.IGNORECASE)
    return [i for i in dir(module) if valid_let_method.match(i)]



class StopWatch(object):


    def __init__(self, raw=False):
        self.raw = raw
        self.start = time.time()


    def elapsed(self):
        _elapsed = str(time.time() - self.start)
        if not self.raw:
            return _elapsed[:5]
        return _elapsed


runner_options = dict(
        first_fail = False,
        capturing  = True,
        traceback  = False,
        dotted     = False,
        profiling  = False
        )

########NEW FILE########
