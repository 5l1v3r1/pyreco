__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Linesman documentation build configuration file, created by
# sphinx-quickstart on Fri Dec 10 16:32:38 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Linesman'
copyright = u'2011, Wireless Generation'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.2.2'
# The full version, including alpha/beta/rc tags.
release = '0.3.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_domain_indices = True

# If false, no index is generated.
html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Linesmandoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Linesman.tex', u'Linesman',
   u'Wireless Generation', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'linesman', u'Linesman Documentation',
     [u'Wireless Generation'], 1)
]

########NEW FILE########
__FILENAME__ = base
# This file is part of linesman.
#
# linesman is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# linesman is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along
# with linesman.  If not, see <http://www.gnu.org/licenses/>.
#


class Backend(object):
    """
    Base class for all backends.  Methods that raise a NotImplementedError
    exception are required to be overriden by children, while functions that
    pass are optional.
    """

    def __init__(self, *args, **kwargs):
        pass

    def setup(self):
        """
        Responsible for initializing the backend. for usage.  This is run once
        on middleware startup.

        Raises a :class:`NotImplementedError` exception.
        """
        raise NotImplementedError()

    def add(self, session):
        """
        Store a new session in history.

        Raises a :class:`NotImplementedError` exception.
        """
        raise NotImplementedError()

    def delete(self, session_uuid):
        """
        Removes a specific stored session from the history.

        This should return the number of rows removed (0 or 1).

        Raises a :class:`NotImplementedError` exception.
        """
        raise NotImplementedError()

    def delete_many(self, session_uuids):
        """
        Removes a list of stored sessions from the history.

        This should return the number of rows removed.

        Raises a :class:`NotImplementedError` exception.
        """
        raise NotImplementedError()

    def delete_all(self):
        """
        Removes all stored sessions from the history.

        This should return the number of rows removed.

        Raises a :class:`NotImplementedError` exception.
        """
        raise NotImplementedError()

    def get(self, session_uuid):
        """
        Returns the data associated with ``session_uuid``.  Should return
        `None` if no session can be found with the specified uuid.

        Raises a :class:`NotImplementedError` exception.
        """
        raise NotImplementedError()

    def get_all(self):
        """
        Return a dictionary-like object of ALL sessions, where the key is the
        `session uuid`.

        Raises a :class:`NotImplementedError` exception.
        """
        raise NotImplementedError()

########NEW FILE########
__FILENAME__ = pickle
# This file is part of linesman.
#
# linesman is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# linesman is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along
# with linesman.  If not, see <http://www.gnu.org/licenses/>.
#
import cPickle
import logging

from linesman.backends.base import Backend


try:
    # Python 2.7+
    from collections import OrderedDict
except ImportError: #pragma no cover
    # Python 2.4+
    from ordereddict import OrderedDict


log = logging.getLogger(__name__)


class PickleBackend(Backend):
    """
    Stores entire session as a pickled object.  This can be extremely slow when
    using even smaller sets of sessions--on the order of 30mb, or around 200
    requests.
    """

    def __init__(self, filename="sessions.dat"):
        self.filename = filename

    def _flush(self):
        """
        Writes the session history to disk, in pickled form.
        """
        with open(self.filename, "w+b") as pickle_fd:
            cPickle.dump(self._session_history,
                        pickle_fd,
                        cPickle.HIGHEST_PROTOCOL)

    def setup(self):
        """
        Reads in pickled data from ``filename``.
        """
        try:
            with open(self.filename, "rb") as pickle_fd:
                self._session_history = cPickle.load(pickle_fd)
        except IOError:
            log.debug(
                "`%s' does not exist; creating new dictionary.",
                self.filename)
            self._session_history = OrderedDict()
        except ValueError:
            log.error("Could not unpickle `%s`; this is likely not "
                      "recoverable.  Please delete this file and start "
                      "from scratch.", self.filename)
            raise

    def add(self, session):
        """
        Adds a session to this dictionary and flushes it to disk.
        """
        self._session_history[session.uuid] = session
        self._flush()

    def delete(self, session_uuid):
        """
        Remove a session from the dictionary and flush it to disk.
        """
        if self.get(session_uuid):
            del self._session_history[session_uuid]
            self._flush()
            return 1

        return 0

    def delete_many(self, session_uuids):
        """
        Remove the sessions from the dictionary and flush it to disk.
        """
        count = 0
        for session_uuid in session_uuids:
            if session_uuid in self._session_history:
                del self._session_history[session_uuid]
                count += 1

        self._flush()
        return count

    def delete_all(self):
        """
        Clear the entire session history and flush it to disk.
        """
        deleted_rows = len(self._session_history)
        self._session_history.clear()
        self._flush()

        return deleted_rows

    def get(self, session_uuid):
        return self._session_history.get(session_uuid)

    def get_all(self):
        return self._session_history.copy()

########NEW FILE########
__FILENAME__ = sqlite
# This file is part of linesman.
#
# linesman is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# linesman is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along
# with linesman.  If not, see <http://www.gnu.org/licenses/>.
#
import cPickle
import logging
import sqlite3
import time

from linesman.backends.base import Backend


try:
    # Python 2.7+
    from collections import OrderedDict
except ImportError:
    # Python 2.4+
    from ordereddict import OrderedDict


sqlite3.register_converter("pickle", cPickle.loads)
log = logging.getLogger(__name__)


class SqliteBackend(Backend):
    """
    Stores sessions in a SQLite database.
    """

    def __init__(self, filename="sessions.db"):
        """
        Opens up a connection to a sqlite3 database.

        ``filename``:
            filename of the sqlite database.  If this file does not exist, it
            will be created automatically.

            This can also be set to `:memory:` to store the database in
            memory; however, this will not persist across runs.
        """
        self.filename = filename

    @property
    def conn(self):
        return sqlite3.connect(self.filename, isolation_level=None,
            detect_types=(sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES))

    def setup(self):
        """
        Creates table for Linesman, if it doesn't already exist.
        """
        query = """
            CREATE TABLE sessions (
                uuid PRIMARY KEY,
                timestamp FLOAT,
                session PICKLE
            );
        """
        try:
            c = self.conn.cursor()
            c.execute(query)
        except sqlite3.OperationalError:
            log.debug("Table already exists.")

    def add(self, session):
        """
        Insert a new session into the database.
        """
        uuid = session.uuid
        if session.timestamp:
            timestamp = time.mktime(session.timestamp.timetuple())
        else:
            timestamp = None
        pickled_session = sqlite3.Binary(cPickle.dumps(session, -1))

        query = "INSERT INTO sessions VALUES (?, ?, ?);"
        params = (uuid, timestamp, pickled_session)

        c = self.conn.cursor()
        c.execute(query, params)

    def delete(self, session_uuid):
        """
        Remove the session.
        """
        query = "DELETE FROM sessions WHERE uuid = ?;"
        params = (session_uuid,)

        conn = self.conn
        curs = conn.cursor()
        curs.execute(query, params)

        return conn.total_changes

    def delete_many(self, session_uuids):
        """
        Remove the sessions.
        """
        query = "DELETE FROM sessions WHERE uuid IN (%s);" % ", ".join('?' * len(session_uuids))
        params = session_uuids

        conn = self.conn
        curs = conn.cursor()
        curs.execute(query, params)

        return conn.total_changes

    def delete_all(self):
        """
        Truncate the database.
        """
        query = "DELETE FROM sessions;"

        conn = self.conn
        curs = conn.cursor()
        curs.execute(query)

        return conn.total_changes

    def get(self, session_uuid):
        """
        Retrieves the session from the database.
        """
        query = "SELECT session FROM sessions WHERE uuid = ?;"
        params = (session_uuid,)

        c = self.conn.cursor()
        c.execute(query, params)
        result = c.fetchone()

        return result[0] if result else None

    def get_all(self):
        """
        Generates a dictionary of the data based on the contents of the DB.
        """
        query = "SELECT uuid, session FROM sessions ORDER BY timestamp;"

        c = self.conn.cursor()
        c.execute(query)

        return OrderedDict(c.fetchall())

########NEW FILE########
__FILENAME__ = middleware
# This file is part of linesman.
#
# linesman is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# linesman is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along
# with linesman.  If not, see <http://www.gnu.org/licenses/>.
#
import logging
import os
from cProfile import Profile
from datetime import datetime
from tempfile import gettempdir

from PIL import Image
import networkx as nx
from mako.lookup import TemplateLookup
from paste.urlparser import StaticURLParser
from pkg_resources import resource_filename
from webob import Request, Response
from webob.exc import HTTPNotFound

from linesman import ProfilingSession, draw_graph


log = logging.getLogger(__name__)

# Graphs
GRAPH_DIR = os.path.join(gettempdir(), "linesman-graph")
MEDIA_DIR = resource_filename("linesman", "media")
TEMPLATES_DIR = resource_filename("linesman", "templates")
ENABLED_FLAG_FILE = 'linesman-enabled'

CUTOFF_TIME_UNITS = 1e9  # Nanoseconds per second


class ProfilingMiddleware(object):
    """
    This wraps calls to the WSGI application with cProfile, storing the
    output and providing useful graphs for the user to view.

    ``app``:
        WSGI application
    ``profiler_path``:
        Path relative to the root to look up.  For example, if your script is
        mounted at the context `/someapp` and this variable is set to
        `/__profiler__`, `/someapp/__profiler__` will match.
    ``backend``:
        This should be a full module path, with the function or class name
        specified after the trailing `:`.  This function or class should return
        an implementation of :class:`~linesman.backend.Backend`.
    ``chart_packages``:
        Space separated list of packages to be charted in the pie graph.
    """

    def __init__(self, app,
                       profiler_path="/__profiler__",
                       backend="linesman.backends.sqlite:SqliteBackend",
                       chart_packages="",
                       **kwargs):
        self.app = app
        self.profiler_path = profiler_path

        # Always reverse sort these packages, so that child packages of the
        # same module will always be picked first.
        self.chart_packages = sorted(chart_packages.split(), reverse=True)

        # Setup the backend
        module_name, sep, class_name = backend.rpartition(":")
        module = __import__(module_name, fromlist=[class_name], level=0)
        self._backend = getattr(module, class_name)(**kwargs)

        # Attempt to create the GRAPH_DIR
        if not os.path.exists(GRAPH_DIR):
            try:
                os.makedirs(GRAPH_DIR)
            except IOError:
                log.error("Could not create directory `%s'", GRAPH_DIR)
                raise

        # Setup the Mako template lookup
        self.template_lookup = TemplateLookup(directories=[TEMPLATES_DIR])

        # Set it up
        self._backend.setup()

    def __call__(self, environ, start_response):
        """
        This will be called when the application is being run.  This can be
        either:

            - a request to the __profiler__ framework to display profiled
              information, or
            - a normal request that will be profiled.

        Returns the WSGI application.
        """
        # If we're not accessing the profiler, profile the request.
        req = Request(environ)

        self.profiling_enabled = os.path.exists(ENABLED_FLAG_FILE)
        if req.path_info_peek() != self.profiler_path.strip('/'):
            if not self.profiling_enabled:
                return self.app(environ, start_response)
            _locals = locals()
            prof = Profile()
            start_timestamp = datetime.now()
            prof.runctx(
                "app = self.app(environ, start_response)", globals(), _locals)
            stats = prof.getstats()
            session = ProfilingSession(stats, environ, start_timestamp)
            self._backend.add(session)

            return _locals['app']

        req.path_info_pop()

        # We could import `routes` and use something like that here, but since
        # not all frameworks use this, it might become an external dependency
        # that isn't needed.  So parse the URL manually using :class:`webob`.
        query_param = req.path_info_pop()
        if not query_param:
            wsgi_app = self.list_profiles(req)
        elif query_param == "graph":
            wsgi_app = self.render_graph(req)
        elif query_param == "media":
            wsgi_app = self.media(req)
        elif query_param == "profiles":
            wsgi_app = self.show_profile(req)
        elif query_param == "delete":
            wsgi_app = self.delete_profile(req)
        else:
            wsgi_app = HTTPNotFound()

        return wsgi_app(environ, start_response)

    def get_template(self, template):
        """
        Uses mako templating lookups to retrieve the template file.  If the
        file is ever changed underneath, this function will automatically
        retrieve and recompile the new version.

        ``template``:
            Filename of the template, relative to the `linesman/templates`
            directory.
        """
        return self.template_lookup.get_template(template)

    def list_profiles(self, req):
        """
        Displays all available profiles in list format.

        ``req``:
            :class:`webob.Request` containing the environment information from
            the request itself.

        Returns a WSGI application.
        """
        if 'enable' in req.params:
            try:
                if not os.path.exists(ENABLED_FLAG_FILE):
                    open(ENABLED_FLAG_FILE, 'w').close()
                self.profiling_enabled = True
            except IOError:
                log.error("Unable to create %s to enable profiling",
                          os.path.abspath(ENABLED_FLAG_FILE))
                raise
        elif 'disable' in req.params:
            try:
                if os.path.exists(ENABLED_FLAG_FILE):
                    os.remove(ENABLED_FLAG_FILE)
                self.profiling_enabled = False
            except IOError:
                log.error("Unable to delete %s to disable profiling",
                          os.path.abspath(ENABLED_FLAG_FILE))
                raise

        resp = Response(charset='utf8')
        session_history = self._backend.get_all()
        resp.unicode_body = self.get_template('list.tmpl').render_unicode(
            history=session_history,
            path=req.path,
            profiling_enabled=self.profiling_enabled)
        return resp

    def media(self, req):
        """
        Serves up static files relative to ``MEDIA_DIR``.

        ``req``:
            :class:`webob.Request` containing the environment information from
            the request itself.

        Returns a WSGI application.
        """
        return StaticURLParser(MEDIA_DIR)

    def render_graph(self, req):
        """
        Used to display rendered graphs; if the graph that the user is trying
        to access does not exist--and the ``session_uuid`` exists in our
        history--it will be rendered.

        This also creates a thumbnail image, since some of these graphs can
        grow to be extremely large.

        ``req``:
            :class:`webob.Request` containing the environment information from
            the request itself.

        Returns a WSGI application.
        """
        path_info = req.path_info_peek()
        if '.' not in path_info:
            return StaticURLParser(GRAPH_DIR)

        fileid, _, ext = path_info.rpartition('.')
        if path_info.startswith("thumb-"):
            fileid = fileid[6:]

        if '--' not in fileid:
            return StaticURLParser(GRAPH_DIR)

        session_uuid, _, cutoff_time = fileid.rpartition('--')
        cutoff_time = int(cutoff_time)

        # We now have the session_uuid
        session = self._backend.get(session_uuid)
        if session:
            force_thumbnail_creation = False

            filename = "%s.png" % fileid
            path = os.path.join(GRAPH_DIR, filename)
            if not os.path.exists(path):
                graph, root_nodes, removed_edges = prepare_graph(
                    session._graph, cutoff_time, False)
                draw_graph(graph, path)
                force_thumbnail_creation = True

            thumbnail_filename = "thumb-%s.png" % fileid
            thumbnail_path = os.path.join(GRAPH_DIR, thumbnail_filename)
            if not os.path.exists(thumbnail_path) or force_thumbnail_creation:
                log.debug("Creating thumbnail for %s at %s.", session_uuid,
                                                              thumbnail_path)
                im = Image.open(path, 'r')
                im.thumbnail((600, 600), Image.ANTIALIAS)
                im.save(thumbnail_path)

        return StaticURLParser(GRAPH_DIR)

    def delete_profile(self, req):
        """
        If the current path info refers to a specific ``session_uuid``, this
        session will be removed.  Otherwise, if it refers to `all`, then all
        tracked session info will be removed.

        ``req``:
            :class:`webob.Request` containing the environment information from
            the request itself.

        Returns a WSGI application.
        """
        resp = Response(charset='utf8')
        session_uuid = req.path_info_pop()
        if session_uuid == "all":
            deleted_rows = self._backend.delete_all()
        elif session_uuid:
            deleted_rows = self._backend.delete(session_uuid)
        else:
            deleted_rows = 0
            session_uuids = req.POST.getall('session_uuids[]')
            if session_uuids:
                deleted_rows = self._backend.delete_many(session_uuids)

        resp.text = u"%d row(s) deleted." % deleted_rows

        return resp

    def show_profile(self, req):
        """
        Displays specific profile information for the ``session_uuid``
        specified in the path.

        ``req``:
            :class:`webob.Request` containing the environment information from
            the request itself.

        Returns a WSGI application.
        """
        resp = Response(charset='utf8')
        session_uuid = req.path_info_pop()
        session = self._backend.get(session_uuid)

        # If the Session doesn't exist, return an appropriate error
        if not session:
            resp.status = "404 Not Found"
            resp.text = u"Session `%s' not found." % session_uuid
        else:
            # Otherwise, prepare the graph for display!
            cutoff_percentage = float(
                req.params.get('cutoff_percent', 5) or 5) / 100
            cutoff_time = int(
                session.duration * cutoff_percentage * CUTOFF_TIME_UNITS)
            graph, root_nodes, removed_edges = prepare_graph(
                session._graph, cutoff_time, True)
            chart_values = time_per_field(session._graph, root_nodes,
                                        self.chart_packages)
            resp.unicode_body = self.get_template('tree.tmpl').render_unicode(
                session=session,
                graph=graph,
                root_nodes=root_nodes,
                removed_edges=removed_edges,
                application_url=self.profiler_path,
                cutoff_percentage=cutoff_percentage,
                cutoff_time=cutoff_time,
                chart_values=chart_values
            )
        return resp


def time_per_field(full_graph, root_nodes, fields):
    """
    This function generates the fields used by the pie graph jQuery code on the
    session profile page.  This process is clever about calculating total time,
    so that packages and subpackages don't overlap.

    Additionally, if I were to track ``linesman.middleware``, and in that
    package an external package is called, say ``re``, the time spent in ``re``
    would be added to the total time in package ``linesman.middleware``, unless
    ``re`` is one of the fields that are being tracked.

    ``full_graph``:
        For best results, this should be an untouched copy of the original
        graph.  The reasoning is because, if certain packages are pruned, the
        graph result could be completely varied and inaccurate.
    ``root_nodes``:
        The list of starting point for this graph.
    ``fields``:
        The list of packages to be tracked.

    Returns a dictionary where the keys are the same as the ``fields``, plus an
    extra field called `Other` that contains packages that were not tracked.
    The values for each field is the total time spent in that package.

    .. warning::

        This will run into issues where separate packages rely on the same core
        set of functions.  I.e., of `PackageA` and `PackageB` both rely on
        ``re``, there's no defined outcome.  Whichever one is parsed first will
        include the time spent in ``re``.
    """
    if not fields:
        return

    # Keep track of all the nodes we've seen.
    seen_nodes = []
    values = dict((field, 0.0) for field in fields)
    values["Other"] = 0.0

    def is_field(node_name):
        """
        Returns True if ``node_name`` is part of the ``fields`` that should be
        tracked.
        """
        for field in fields:
            if node_name.startswith(field + "."):
                return field
        return None

    def recursive_parse(node_name, last_seen_field=None):
        """
        Given a node, follow its descendents and append their runtimes to the
        last seen "tracked" field.
        """
        if node_name in seen_nodes:
            return
        seen_nodes.append(node_name)

        field = is_field(node_name)
        inlinetime = full_graph.node[node_name]['inlinetime']
        if field:
            last_seen_field = field

        if last_seen_field:
            values[last_seen_field] += inlinetime
        else:
            values["Other"] += inlinetime

        # Parse the successors
        for node in full_graph.successors(node_name):
            recursive_parse(node, last_seen_field)

    for root_node in root_nodes:
        recursive_parse(root_node)

    return values


def prepare_graph(source_graph, cutoff_time, break_cycles=False):
    """
    Prepares a graph for display.  This includes:

        - removing subgraphs based on a cutoff time
        - breaking cycles

    Returns a tuple of (new_graph, removed_edges)
    """
    # Always use a copy for destructive changes
    graph = source_graph.copy()

    # Some node data could be empty dict
    for node, data in graph.nodes(data=True):
        if not data:
            data['totaltime'] = 0

    max_totaltime = max(data['totaltime']
                        for node, data in graph.nodes(data=True))
    for node, data in graph.nodes(data=True):
        data['color'] = "%f 1.0 1.0" % (
            (1 - (data['totaltime'] / max_totaltime)) / 3)
        data['style'] = 'filled'

    cyclic_breaks = []

    # Remove nodes where the totaltime is greater than the cutoff time
    graph.remove_nodes_from([
        node
        for node, data in graph.nodes(data=True)
        if int(data.get('totaltime') * CUTOFF_TIME_UNITS) < cutoff_time])

    # Break cycles
    if break_cycles:
        for cycle in nx.simple_cycles(graph):
            u, v = cycle[0], cycle[1]
            if graph.has_edge(u, v):
                graph.remove_edge(u, v)
                cyclic_breaks.append((u, v))

    root_nodes = [node
                  for node, degree in graph.in_degree_iter()
                  if degree == 0]

    return graph, root_nodes, cyclic_breaks


def profiler_filter_factory(conf, **kwargs):
    """
    Factory for creating :mod:`paste` filters.  Full documentation can be found
    in `the paste docs <http://pythonpaste.org/deploy/#paste-filter-factory>`_.
    """
    def filter(app):
        return ProfilingMiddleware(app, **kwargs)
    return filter


def profiler_filter_app_factory(app, conf, **kwargs):
    """
    Creates a single :mod:`paste` filter.  Full documentation can be found in
    `the paste docs <http://pythonpaste.org/deploy/#paste-filter-factory>`_.
    """
    return ProfilingMiddleware(app, **kwargs)


def make_linesman_middleware(app, **kwargs):
    """
    Helper function for wrapping an application with :mod:`!linesman`.  This
    can be used when manually wrapping middleware, although its also possible
    to simply call :class:`~linesman.middleware.ProfilingMiddleware` directly.
    """
    return ProfilingMiddleware(app, **kwargs)

########NEW FILE########
__FILENAME__ = test_backend_base
from nose.tools import raises

from linesman.backends.base import Backend
from linesman.tests.backends import TestBackend


class TestBaseBackend(TestBackend):

    def setUp(self):
        self.backend = Backend()

    @raises(NotImplementedError)
    def test_setup_not_implemented(self):
        """ Test that setup raises NotImplementedError. """
        self.backend.setup()

    @raises(NotImplementedError)
    def test_add_not_implemented(self):
        """ Test thatdd raises NotImplementedError. """
        self.backend.add(None)

    @raises(NotImplementedError)
    def test_delete_not_implemented(self):
        """ Test that delete raises NotImplementedError. """
        self.backend.delete(None)

    @raises(NotImplementedError)
    def test_delete_many_not_implemented(self):
        """ Test that delete_many raises NotImplementedError. """
        self.backend.delete_many([None])

    @raises(NotImplementedError)
    def test_delete_all_not_implemented(self):
        """ Test that delete_all raises NotImplementedError. """
        self.backend.delete_all()

    @raises(NotImplementedError)
    def test_get_not_implemented(self):
        """ Test that get raises NotImplementedError. """
        self.backend.get(None)

    @raises(NotImplementedError)
    def test_get_all_not_implemented(self):
        """ Test that get_all raises NotImplementedError. """
        self.backend.get_all()

########NEW FILE########
__FILENAME__ = test_backend_pickle
import os
from cPickle import HIGHEST_PROTOCOL
from nose.tools import raises
from mock import MagicMock, Mock, patch
from tempfile import TemporaryFile

import linesman.backends.pickle
from linesman.tests import get_temporary_filename
from linesman.tests.backends import TestBackend

MOCK_SESSION_UUID = "abcd1234"


class TestBackendPickle(TestBackend):

    def setUp(self):
        self.filename = get_temporary_filename()
        self.backend = linesman.backends.pickle.PickleBackend(self.filename)

    def tearDown(self):
        os.remove(self.filename)

    @patch("cPickle.dump")
    def test_flush(self, mock_dump):
        """ Test that the file is opened by cPickle. """
        test_fd = TemporaryFile()
        with patch("__builtin__.open", Mock(side_effect=IOError())):
            self.backend.setup()

        with patch("__builtin__.open") as mock_open:
            mock_open.return_value = test_fd
            self.backend._flush()
            mock_open.assert_called_once_with(
                self.backend.filename, "w+b")

        mock_dump.assert_called_once_with(
            self.backend._session_history,
            test_fd,
            HIGHEST_PROTOCOL)

    @patch("__builtin__.open")
    @patch("cPickle.load")
    def test_setup(self, mock_load, mock_open):
        """ Test that setup will load pickled data. """
        mock_open.return_value = MagicMock(spec=file)
        self.backend.setup()
        mock_open.assert_called_once_with(self.filename, "rb")
        mock_load.assert_called_once()

    @patch("__builtin__.open")
    @patch("linesman.backends.pickle.OrderedDict")
    def test_setup_ioerror(self, mock_ordered_dict, mock_open):
        """ Test that setup will create a new ordered dict if no file exists
        """
        mock_open.side_effect = IOError()
        self.backend.setup()
        mock_ordered_dict.assert_called_once_with()

    @raises(ValueError)
    @patch("__builtin__.open")
    def test_setup_value_error(self, mock_open):
        """ Test that bad pickled data raises a ValueError. """
        mock_open.side_effect = ValueError("Could not unpickle!")
        self.backend.setup()

    @patch("__builtin__.open", Mock(side_effect=IOError()))
    @patch("linesman.backends.pickle.PickleBackend._flush")
    def test_add(self, mock_flush):
        """ Test that add creates a new entry in the session. """
        mock_session = MagicMock()
        mock_session.uuid = MOCK_SESSION_UUID

        self.backend.setup()
        self.backend.add(mock_session)

        self.assertTrue(mock_session.uuid in self.backend._session_history)
        mock_flush.assert_called_once()

    @patch("__builtin__.open", Mock(side_effect=IOError()))
    @patch("linesman.backends.pickle.PickleBackend._flush")
    def test_delete(self, mock_flush):
        """ Test that deleting an existing UUID returns 0. """
        mock_session = MagicMock()
        mock_session.uuid = MOCK_SESSION_UUID

        self.backend.setup()
        self.backend.add(mock_session)
        self.assertEquals(self.backend.delete(mock_session.uuid), 1)
        mock_flush.assert_called_once()

    @patch("__builtin__.open", Mock(side_effect=IOError()))
    @patch("linesman.backends.pickle.PickleBackend._flush")
    def test_delete_non_existent_uuid(self, mock_flush):
        """ Test that deleting a non-existing UUID returns 0. """
        mock_session = MagicMock()
        mock_session.uuid = MOCK_SESSION_UUID

        self.backend.setup()
        self.backend.add(mock_session)
        self.assertEquals(self.backend.delete("basb3144"), 0)
        mock_flush.assert_called_once()

    @patch("__builtin__.open", Mock(side_effect=IOError()))
    @patch("linesman.backends.pickle.PickleBackend._flush")
    def test_delete_many(self, mock_flush):
        """ Test that delete_many does the right thing. """
        self.backend.setup()
        mock_sessions = []
        for i in range(10):
            mock_session = MagicMock()
            mock_session.uuid = str(i)
            mock_sessions.append(mock_session)
            self.backend.add(mock_session)

        self.assertEquals(self.backend.delete_many(session.uuid for session in mock_sessions[0:5]), 5)
        self.assertEquals(self.backend.delete_many(['11','12','13','14']), 0)
        self.assertEquals(len(self.backend._session_history), 5)
        mock_flush.assert_called_once()

    @patch("__builtin__.open", Mock(side_effect=IOError()))
    @patch("linesman.backends.pickle.PickleBackend._flush")
    def test_delete_all(self, mock_flush):
        """ Test that deleting a non-existing UUID returns 0. """
        mock_session1 = MagicMock()
        mock_session1.uuid = MOCK_SESSION_UUID

        mock_session2 = MagicMock()
        mock_session2.uuid = "something else"

        self.backend.setup()
        self.backend.add(mock_session1)
        self.backend.add(mock_session2)
        self.assertEquals(self.backend.delete_all(), 2)
        self.assertEquals(len(self.backend._session_history), 0)
        mock_flush.assert_called_once()

    @patch("__builtin__.open", Mock(side_effect=IOError()))
    @patch("linesman.backends.pickle.PickleBackend._flush")
    def test_delete_all_empty(self, mock_flush):
        """ Test that callign delete all on an empty dict returns 0. """
        self.backend.setup()
        self.assertEquals(self.backend.delete_all(), 0)
        mock_flush.assert_called_once()

    @patch("__builtin__.open", Mock(side_effect=IOError()))
    @patch("linesman.backends.pickle.PickleBackend._flush", Mock())
    def test_get(self):
        """ Test that retrieving an existing UUID succeeds. """
        mock_session = MagicMock()
        mock_session.uuid = MOCK_SESSION_UUID

        self.backend.setup()
        self.backend.add(mock_session)
        self.assertEquals(self.backend.get(MOCK_SESSION_UUID), mock_session)

    @patch("__builtin__.open", Mock(side_effect=IOError()))
    def test_get_non_existent_uuid(self):
        """ Test that retrieving an non-existent UUID returns None. """
        self.backend.setup()
        self.assertEquals(self.backend.get(MOCK_SESSION_UUID), None)

    @patch("__builtin__.open", Mock(side_effect=IOError()))
    @patch("linesman.backends.pickle.PickleBackend._flush", Mock())
    def test_get_all(self):
        """ Test that getting all results returns a copy. """
        mock_session = MagicMock()
        mock_session.uuid = MOCK_SESSION_UUID

        self.backend.setup()
        self.backend.add(mock_session)
        session_history_copy = self.backend.get_all()
        assert self.backend._session_history is not session_history_copy

########NEW FILE########
__FILENAME__ = test_backend_sqlite
import os

from linesman.backends.sqlite import SqliteBackend
from linesman.tests import (create_mock_session, get_temporary_filename, \
                            SPECIFIC_DATE_EPOCH)
from linesman.tests.backends import TestBackend


class TestBackendSqlite(TestBackend):

    def setUp(self):
        self.filename = get_temporary_filename()
        self.backend = SqliteBackend(self.filename)
        self.backend.setup()

    def tearDown(self):
        os.remove(self.filename)

    def test_setup(self):
        """ Test that setup() creates a new table with the correct columns. """
        expected_columns = [
            (u"uuid",       u"",        1),
            (u"timestamp",  u"FLOAT",    0),
            (u"session",    u"PICKLE",   0)
        ]

        # Verify that setup created the correct tables
        c = self.backend.conn.cursor()
        c.execute("PRAGMA table_info(sessions);")
        actual_columns = [
            (name, type, pk)
            for (cid, name, type, notnull, dflt_value, pk) in c.fetchall()]

        self.assertEqual(expected_columns, actual_columns)

    def test_duplicate_setup(self):
        """ Test that running setup() twice (duplicate tables) won't fail. """
        self.backend.setup()

    def test_add_session(self):
        """ Test that adding a session inserts it into the database. """
        mock_session = create_mock_session()
        self.backend.add(mock_session)

        query = "SELECT uuid, timestamp, session FROM sessions WHERE uuid = ?;"
        params = (mock_session.uuid,)

        c = self.backend.conn.cursor()
        c.execute(query, params)
        actual_uuid, actual_timestamp, actual_session = c.fetchone()

        # Assure the meta columns are equal
        self.assertEquals(mock_session.uuid, actual_uuid)
        self.assertEquals(SPECIFIC_DATE_EPOCH, actual_timestamp)

        # Also insure that the session we put in is intact!
        self.assertSessionsEqual(mock_session, actual_session)

    def test_delete(self):
        """ Test that removing an added session removes it from the DB. """
        mock_session = create_mock_session()
        self.backend.add(mock_session)
        self.backend.delete(mock_session.uuid)

        query = "SELECT * FROM sessions WHERE uuid = ?;"
        params = (mock_session.uuid,)

        # Verify that no rows are matched
        c = self.backend.conn.cursor()
        c.execute(query, params)
        self.assertEquals(c.fetchone(), None)

    def test_delete_many(self):
        """ Test that delete_many removes the correct sessions. """
        sessions = []
        for i in range(10):
            mock_session = create_mock_session()
            self.backend.add(mock_session)
            sessions.append(mock_session.uuid)

        delete_count = self.backend.delete_many(sessions[0:5])
        self.assertEquals(delete_count, 5)

        c = self.backend.conn.cursor()
        c.execute("SELECT COUNT(*) FROM sessions;")
        self.assertEquals(c.fetchone(), (5,))

    def test_delete_all(self):
        """ Test that deleting all session removes them all from the DB """
        # Add a few new session profiles
        for i in range(1, 5):
            self.backend.add(create_mock_session())

        # TODO Check to make sure rows were added?

        # Then delete them all.
        self.backend.delete_all()

        query = "SELECT * FROM sessions;"

        # Verify that no rows are matched
        c = self.backend.conn.cursor()
        c.execute(query)
        self.assertEquals(c.fetchone(), None)

    def test_get(self):
        """ Test that a session can be received using get(). """
        mock_session = create_mock_session()
        self.backend.add(mock_session)

        actual_session = self.backend.get(mock_session.uuid)
        self.assertSessionsEqual(mock_session, actual_session)

    def test_get_no_results(self):
        """ Test that when no sessions are available, get returns None """
        actual_session = self.backend.get("not a real uuid")
        self.assertEqual(None, actual_session)

    def test_get_all(self):
        """ Test that all sessions are retrieved when using get_all() """
        expected_sessions = {}
        for i in range(1, 5):
            mock_session = create_mock_session()
            self.backend.add(mock_session)
            expected_sessions[mock_session.uuid] = mock_session

        actual_sessions = self.backend.get_all()
        for (actual_uuid, actual_session) in actual_sessions.items():
            expected_session = expected_sessions.get(actual_uuid)
            self.assertTrue(expected_session != None,
                            "UUID `%s' not found in results." % actual_uuid)
            self.assertSessionsEqual(actual_session, expected_session)

    def test_get_all_no_results(self):
        """ Test that an empty dict is returned when no sessions exist. """
        actual_sessions = self.backend.get_all()
        self.assertFalse(len(actual_sessions))

########NEW FILE########
__FILENAME__ = test_graphs
import unittest
from cProfile import Profile

from mock import Mock, patch
from nose.tools import assert_equals

import linesman


class TestGraphUtils(unittest.TestCase):

    @patch("networkx.to_agraph")
    def test_draw_graph(self, mock_to_agraph):
        """ Test that the graph gets converted to an agraph """
        mock_draw = Mock()
        mock_to_agraph.return_value = mock_draw

        graph = "some graph object"
        output = "/tmp/somefile.png"
        linesman.draw_graph(graph, output)

        mock_to_agraph.assert_called_with(graph)
        mock_draw.draw.assert_called_with(output, prog="dot")

    def test_generate_key_builtin(self):
        """ Test that a key is generated for built-in functions """
        stat = Mock()
        stat.code = "__builtin__"
        key = linesman._generate_key(stat)
        assert_equals(key, stat.code)

    def test_generate_key_module(self):
        """ Test that a key is generated for module functions """
        def test_func():
            pass

        stat = Mock()
        stat.code = test_func.__code__

        expected_key = "%s.%s" % (self.__module__, stat.code.co_name)
        key = linesman._generate_key(stat)
        assert_equals(key, expected_key)

    @patch("linesman.getmodule", Mock(return_value=None))
    def test_generate_key_unknown(self):
        """ Test that unknown module functions return as strings """
        def test_func():
            pass

        stat = Mock()
        stat.code = test_func.__code__

        expected_key = "%s.%s" % (stat.code.co_filename, stat.code.co_name)
        key = linesman._generate_key(stat)
        assert_equals(key, expected_key)

    def test_create_graph(self):
        """ Test that a graph gets generated for a test function """
        def test_func():
            pass
        prof = Profile()
        prof.runctx("test_func()", locals(), globals())
        graph = linesman.create_graph(prof.getstats())

        # We should only ever have three items here
        assert_equals(len(graph), 3)

        # Assert that the three items we have are as expected
        assert_equals(graph.nodes(),
            ['<string>.<module>',
             'linesman.tests.test_graphs.test_func',
             "<method 'disable' of '_lsprof.Profiler' objects>"])

        # Assert that the correct edges are set-up
        assert_equals(
            [('<string>.<module>', 'linesman.tests.test_graphs.test_func')],
            graph.edges())

########NEW FILE########
__FILENAME__ = test_linesman_profiler
import unittest
from cProfile import Profile

from mock import patch
from nose.tools import assert_equals

import linesman


def generate_profiler_entry():
    def func():
        a = 1 + 2
        return a

    prof = Profile()
    prof.runctx("func()", locals(), globals())
    return prof.getstats()


class TestProfilingSession(unittest.TestCase):

    def setUp(self):
        self.stats = generate_profiler_entry()

    @patch("linesman.create_graph")
    def test_init_default_args(self, mock_create_graph):
        """ Test ProfilingSession initialization with default args """
        session = linesman.ProfilingSession(self.stats)
        mock_create_graph.assert_called_with(self.stats)
        assert_equals(session.path, None)
        assert_equals(session.timestamp, None)
        assert_equals(str(session._uuid), session.uuid)

    @patch("linesman.create_graph")
    def test_init_environ(self, mock_create_graph):
        """ Test ProfilingSession initialization with an environ args """
        environ = {'PATH_INFO': '/some/path'}
        session = linesman.ProfilingSession(self.stats, environ)
        mock_create_graph.assert_called_with(self.stats)
        assert_equals(session.path, environ.get('PATH_INFO'))
        assert_equals(session.timestamp, None)
        assert_equals(str(session._uuid), session.uuid)

    @patch("linesman.create_graph")
    def test_init_environ_timestamp(self, mock_create_graph):
        """ Test ProfilingSession initialization with all args """
        environ = {'PATH_INFO': '/some/path'}
        timestamp = "Some generic timestamp"
        session = linesman.ProfilingSession(self.stats, environ, timestamp)
        mock_create_graph.assert_called_with(self.stats)
        assert_equals(session.path, environ.get('PATH_INFO'))
        assert_equals(session.timestamp, timestamp)
        assert_equals(str(session._uuid), session.uuid)

########NEW FILE########
__FILENAME__ = test_middleware
import os
from cProfile import Profile
from unittest import TestCase

from mock import Mock, patch
from nose.tools import raises
from paste.urlmap import URLMap
from webtest import TestApp

import linesman.middleware
from linesman.tests import get_temporary_filename


try:
    # Python 2.7+
    from collections import OrderedDict
except ImportError:
    # Python 2.4+
    from ordereddict import OrderedDict


def generate_profiler_entry():
    def func():
        a = 1 + 2
        return a

    prof = Profile()
    prof.runctx("func()", locals(), globals())
    return prof.getstats()


class TestProfilingMiddleware(TestCase):

    @patch("os.path.exists", Mock(return_value=False))
    @patch("os.makedirs")
    def test_graph_dir_creation(self, mock_makedirs):
        """ Test that the graph dir gets created if it doesn't exist """
        pm = linesman.middleware.ProfilingMiddleware("app")
        mock_makedirs.assert_called_once_with(linesman.middleware.GRAPH_DIR)

    @patch("os.path.exists", Mock(return_value=False))
    @patch("os.makedirs", Mock(side_effect=IOError()))
    @raises(IOError)
    def test_graph_dir_error(self):
        """ Test that not being able to write fails """
        pm = linesman.middleware.ProfilingMiddleware("app")

    def test_middleware_app_non_profiler(self):
        temp_filename = get_temporary_filename()
        profiler_path = "/__profiler__"
        try:
            # Use a sample WSGI app
            map_app = URLMap()
            pm = linesman.middleware.ProfilingMiddleware(
                                        map_app,
                                        profiler_path=profiler_path)
            app = TestApp(pm)
            app.get("/not/profiled/url", status=404)
        finally:
            # Clean up after ourselves
            try:
                os.remove(temp_filename)
            except:
                pass

    def test_middleware_app_profiler(self):
        temp_filename = get_temporary_filename()
        profiler_path = "/__profiler__"
        try:
            pm = linesman.middleware.ProfilingMiddleware(
                                        Mock(),
                                        profiler_path=profiler_path)
            session = linesman.ProfilingSession(generate_profiler_entry())
            pm._backend.add(session)

            app = TestApp(pm)

            # Test that invalid URLs fail
            app.get('/__profiler__/notaurl', status=404)
            app.get('/__profiler__/graph/notavalidgraph', status=404)
            app.get('/__profiler__/media/js/notafile', status=404)
            app.get('/__profiler__/profiles/notavaliduuids', status=404)

            app.get('/__profiler__/media/js/accordian.js')
            app.get('/__profiler__/profiles/%s' % session.uuid)
            resp = app.get('/__profiler__')
            assert(session.uuid in resp.body)

            resp = app.get('/__profiler__/delete/%s' % session.uuid)
            assert('1 row(s) deleted' in resp.body)

            resp = app.get('/__profiler__/profiles/%s' % session.uuid,
                           status=404)

        finally:
            # Clean up after ourselves
            try:
                os.remove(temp_filename)
            except:
                pass

########NEW FILE########
