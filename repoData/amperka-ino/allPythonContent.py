__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Ino documentation build configuration file, created by
# sphinx-quickstart on Mon Oct 31 19:32:46 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Ino'
copyright = u'2011, Amperka Team'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.3'
# The full version, including alpha/beta/rc tags.
release = '0.3'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'basic'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Inodoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Ino.tex', u'Ino Documentation',
   u'Amperka Team', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'ino', u'Ino Documentation',
     [u'Amperka Team'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Ino', u'Ino Documentation', u'Amperka Team',
   'Ino', 'One line description of project.', 'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = argparsing
# -*- coding: utf-8; -*-
# Stolen from: http://bugs.python.org/issue12806

import argparse
import re
import textwrap

class FlexiFormatter(argparse.RawTextHelpFormatter):
    """FlexiFormatter which respects new line formatting and wraps the rest
    
    Example:
        >>> parser = argparse.ArgumentParser(formatter_class=FlexiFormatter)
        >>> parser.add_argument('--example', help='''\
        ...     This argument's help text will have this first long line\
        ...     wrapped to fit the target window size so that your text\
        ...     remains flexible.
        ...
        ...         1. This option list
        ...         2. is still persisted
        ...         3. and the option strings get wrapped like this with an\
        ...            indent for readability.
        ...
        ...     You must use backslashes at the end of lines to indicate that\
        ...     you want the text to wrap instead of preserving the newline.
        ...    
        ...     As with docstrings, the leading space to the text block is\
        ...     ignored.
        ... ''')
        >>> parser.parse_args(['-h'])
        usage: argparse_formatter.py [-h] [--example EXAMPLE]

        optional arguments:
          -h, --help         show this help message and exit
          --example EXAMPLE  This argument's help text will have this first
                             long line wrapped to fit the target window size
                             so that your text remains flexible.

                                 1. This option list
                                 2. is still persisted
                                 3. and the option strings get wrapped like
                                    this with an indent for readability.

                             You must use backslashes at the end of lines to
                             indicate that you want the text to wrap instead
                             of preserving the newline.

                             As with docstrings, the leading space to the
                             text block is ignored.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def _split_lines(self, text, width):
        lines = list()
        main_indent = len(re.match(r'( *)',text).group(1))
        # Wrap each line individually to allow for partial formatting
        for line in text.splitlines():

            # Get this line's indent and figure out what indent to use
            # if the line wraps. Account for lists of small variety.
            indent = len(re.match(r'( *)',line).group(1))
            list_match = re.match(r'( *)(([*-+>]+|\w+\)|\w+\.) +)',line)
            if(list_match):
                sub_indent = indent + len(list_match.group(2))
            else:
                sub_indent = indent
            
            # Textwrap will do all the hard work for us
            line = self._whitespace_matcher.sub(' ', line).strip()
            new_lines = textwrap.wrap(
                text=line,
                width=width,
                initial_indent=' '*(indent-main_indent),
                subsequent_indent=' '*(sub_indent-main_indent),
            )
            
            # Blank lines get eaten by textwrap, put it back with [' ']
            lines.extend(new_lines or [' '])

        return lines

if __name__ == '__main__':
    parser = argparse.ArgumentParser(formatter_class=FlexiFormatter)
    parser.add_argument('--example', help='''\
        This argument's help text will have this first long line wrapped to\
        fit the target window size so that your text remains flexible.

            1. This option list
            2. is still persisted
            3. and the option strings get wrapped like this with an indent\
               for readability.

        You must use backslashes at the end of lines to indicate that you\
        want the text to wrap instead of preserving the newline.
        
        As with docstrings, the leading space to the text block is ignored.
    ''')
    parser.parse_args(['-h'])

########NEW FILE########
__FILENAME__ = base
# -*- coding: utf-8; -*-

import textwrap


class Command(object):
    name = None
    help_line = None

    def __init__(self, environment):
        self.e = environment

    def setup_arg_parser(self, parser):
        if self.__doc__:
            parser.description = textwrap.dedent(self.__doc__)

    def run(self, args):
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = build
# -*- coding: utf-8; -*-

import re
import os.path
import inspect
import subprocess
import platform
import jinja2
import shlex

from jinja2.runtime import StrictUndefined

import ino.filters

from ino.commands.base import Command
from ino.environment import Version
from ino.filters import colorize
from ino.utils import SpaceList, list_subdirs
from ino.exc import Abort


class Build(Command):
    """
    Build a project in the current directory and produce a ready-to-upload
    firmware file.

    The project is expected to have a `src' subdirectory where all its sources
    are located. This directory is scanned recursively to find
    *.[c|cpp|pde|ino] files. They are compiled and linked into resulting
    firmware hex-file.

    Also any external library dependencies are tracked automatically. If a
    source file includes any library found among standard Arduino libraries or
    a library placed in `lib' subdirectory of the project, the library gets
    built too.

    Build artifacts are placed in `.build' subdirectory of the project.
    """

    name = 'build'
    help_line = "Build firmware from the current directory project"

    default_make = 'make'
    default_cc = 'avr-gcc'
    default_cxx = 'avr-g++'
    default_ar = 'avr-ar'
    default_objcopy = 'avr-objcopy'

    default_cppflags = '-ffunction-sections -fdata-sections -g -Os -w'
    default_cflags = ''
    default_cxxflags = '-fno-exceptions'
    default_ldflags = '-Os --gc-sections'

    def setup_arg_parser(self, parser):
        super(Build, self).setup_arg_parser(parser)
        self.e.add_board_model_arg(parser)
        self.e.add_arduino_dist_arg(parser)

        parser.add_argument('--make', metavar='MAKE',
                            default=self.default_make,
                            help='Specifies the make tool to use. If '
                            'a full path is not given, searches in Arduino '
                            'directories before PATH. Default: "%(default)s".')

        parser.add_argument('--cc', metavar='COMPILER',
                            default=self.default_cc,
                            help='Specifies the compiler used for C files. If '
                            'a full path is not given, searches in Arduino '
                            'directories before PATH. Default: "%(default)s".')

        parser.add_argument('--cxx', metavar='COMPILER',
                            default=self.default_cxx,
                            help='Specifies the compiler used for C++ files. '
                            'If a full path is not given, searches in Arduino '
                            'directories before PATH. Default: "%(default)s".')

        parser.add_argument('--ar', metavar='AR',
                            default=self.default_ar,
                            help='Specifies the AR tool to use. If a full path '
                            'is not given, searches in Arduino directories '
                            'before PATH. Default: "%(default)s".')

        parser.add_argument('--objcopy', metavar='OBJCOPY',
                            default=self.default_objcopy,
                            help='Specifies the OBJCOPY to use. If a full path '
                            'is not given, searches in Arduino directories '
                            'before PATH. Default: "%(default)s".')

        parser.add_argument('-f', '--cppflags', metavar='FLAGS',
                            default=self.default_cppflags,
                            help='Flags that will be passed to the compiler. '
                            'Note that multiple (space-separated) flags must '
                            'be surrounded by quotes, e.g. '
                            '`--cppflags="-DC1 -DC2"\' specifies flags to define '
                            'the constants C1 and C2. Default: "%(default)s".')

        parser.add_argument('--cflags', metavar='FLAGS',
                            default=self.default_cflags,
                            help='Like --cppflags, but the flags specified are '
                            'only passed to compilations of C source files. '
                            'Default: "%(default)s".')

        parser.add_argument('--cxxflags', metavar='FLAGS',
                            default=self.default_cxxflags,
                            help='Like --cppflags, but the flags specified '
                            'are only passed to compilations of C++ source '
                            'files. Default: "%(default)s".')

        parser.add_argument('--ldflags', metavar='FLAGS',
                            default=self.default_ldflags,
                            help='Like --cppflags, but the flags specified '
                            'are only passed during the linking stage. Note '
                            'these flags should be specified as if `ld\' were '
                            'being invoked directly (i.e. the `-Wl,\' prefix '
                            'should be omitted). Default: "%(default)s".')

        parser.add_argument('-v', '--verbose', default=False, action='store_true',
                            help='Verbose make output')

    def discover(self, args):
        board = self.e.board_model(args.board_model)

        core_place = os.path.join(board['_coredir'], 'cores', board['build']['core'])
        core_header = 'Arduino.h' if self.e.arduino_lib_version.major else 'WProgram.h'
        self.e.find_dir('arduino_core_dir', [core_header], [core_place],
                        human_name='Arduino core library')

        if self.e.arduino_lib_version.major:
            variants_place = os.path.join(board['_coredir'], 'variants')
            self.e.find_dir('arduino_variants_dir', ['.'], [variants_place],
                            human_name='Arduino variants directory')

        self.e.find_arduino_dir('arduino_libraries_dir', ['libraries'],
                                human_name='Arduino standard libraries')

        toolset = [
            ('make', args.make),
            ('cc', args.cc),
            ('cxx', args.cxx),
            ('ar', args.ar),
            ('objcopy', args.objcopy),
        ]

        for tool_key, tool_binary in toolset:
            self.e.find_arduino_tool(
                tool_key, ['hardware', 'tools', 'avr', 'bin'], 
                items=[tool_binary], human_name=tool_binary)

    def setup_flags(self, args):
        board = self.e.board_model(args.board_model)
        mcu = '-mmcu=' + board['build']['mcu']
        # Hard-code the flags that are essential to building the sketch
        self.e['cppflags'] = SpaceList([
            mcu,
            '-DF_CPU=' + board['build']['f_cpu'],
            '-DARDUINO=' + str(self.e.arduino_lib_version.as_int()),
            '-I' + self.e['arduino_core_dir'],
        ]) 
        # Add additional flags as specified
        self.e['cppflags'] += SpaceList(shlex.split(args.cppflags))

        if 'vid' in board['build']:
            self.e['cppflags'].append('-DUSB_VID=%s' % board['build']['vid'])
        if 'pid' in board['build']:
            self.e['cppflags'].append('-DUSB_PID=%s' % board['build']['pid'])
            
        if self.e.arduino_lib_version.major:
            variant_dir = os.path.join(self.e.arduino_variants_dir, 
                                       board['build']['variant'])
            self.e.cppflags.append('-I' + variant_dir)

        self.e['cflags'] = SpaceList(shlex.split(args.cflags))
        self.e['cxxflags'] = SpaceList(shlex.split(args.cxxflags))

        # Again, hard-code the flags that are essential to building the sketch
        self.e['ldflags'] = SpaceList([mcu])
        self.e['ldflags'] += SpaceList([
            '-Wl,' + flag for flag in shlex.split(args.ldflags)
        ])

        self.e['names'] = {
            'obj': '%s.o',
            'lib': 'lib%s.a',
            'cpp': '%s.cpp',
            'deps': '%s.d',
        }

    def create_jinja(self, verbose):
        templates_dir = os.path.join(os.path.dirname(__file__), '..', 'make')
        self.jenv = jinja2.Environment(
            loader=jinja2.FileSystemLoader(templates_dir),
            undefined=StrictUndefined, # bark on Undefined render
            extensions=['jinja2.ext.do'])

        # inject @filters from ino.filters
        for name, f in inspect.getmembers(ino.filters, lambda x: getattr(x, 'filter', False)):
            self.jenv.filters[name] = f

        # inject globals
        self.jenv.globals['e'] = self.e
        self.jenv.globals['v'] = '' if verbose else '@'
        self.jenv.globals['slash'] = os.path.sep
        self.jenv.globals['SpaceList'] = SpaceList

    def render_template(self, source, target, **ctx):
        template = self.jenv.get_template(source)
        contents = template.render(**ctx)
        out_path = os.path.join(self.e.build_dir, target)
        with open(out_path, 'wt') as f:
            f.write(contents)

        return out_path

    def make(self, makefile, **kwargs):
        makefile = self.render_template(makefile + '.jinja', makefile, **kwargs)
        ret = subprocess.call([self.e.make, '-f', makefile, 'all'])
        if ret != 0:
            raise Abort("Make failed with code %s" % ret)

    def recursive_inc_lib_flags(self, libdirs):
        flags = SpaceList()
        for d in libdirs:
            flags.append('-I' + d)
            flags.extend('-I' + subd for subd in list_subdirs(d, recursive=True, exclude=['examples']))
        return flags

    def _scan_dependencies(self, dir, lib_dirs, inc_flags):
        output_filepath = os.path.join(self.e.build_dir, os.path.basename(dir), 'dependencies.d')
        self.make('Makefile.deps', inc_flags=inc_flags, src_dir=dir, output_filepath=output_filepath)
        self.e['deps'].append(output_filepath)

        # search for dependencies on libraries
        # for this scan dependency file generated by make
        # with regexes to find entries that start with
        # libraries dirname
        regexes = dict((lib, re.compile(r'\s' + lib + re.escape(os.path.sep))) for lib in lib_dirs)
        used_libs = set()
        with open(output_filepath) as f:
            for line in f:
                for lib, regex in regexes.iteritems():
                    if regex.search(line) and lib != dir:
                        used_libs.add(lib)

        return used_libs

    def scan_dependencies(self):
        self.e['deps'] = SpaceList()

        lib_dirs = [self.e.arduino_core_dir] + list_subdirs(self.e.lib_dir) + list_subdirs(self.e.arduino_libraries_dir)
        inc_flags = self.recursive_inc_lib_flags(lib_dirs)

        # If lib A depends on lib B it have to appear before B in final
        # list so that linker could link all together correctly
        # but order of `_scan_dependencies` is not defined, so...
        
        # 1. Get dependencies of sources in arbitrary order
        used_libs = list(self._scan_dependencies(self.e.src_dir, lib_dirs, inc_flags))

        # 2. Get dependencies of dependency libs themselves: existing dependencies
        # are moved to the end of list maintaining order, new dependencies are appended
        scanned_libs = set()
        while scanned_libs != set(used_libs):
            for lib in set(used_libs) - scanned_libs:
                dep_libs = self._scan_dependencies(lib, lib_dirs, inc_flags)

                i = 0
                for ulib in used_libs[:]:
                    if ulib in dep_libs:
                        # dependency lib used already, move it to the tail
                        used_libs.append(used_libs.pop(i))
                        dep_libs.remove(ulib)
                    else:
                        i += 1

                # append new dependencies to the tail
                used_libs.extend(dep_libs)
                scanned_libs.add(lib)

        self.e['used_libs'] = used_libs
        self.e['cppflags'].extend(self.recursive_inc_lib_flags(used_libs))

    def run(self, args):
        self.discover(args)
        self.setup_flags(args)
        self.create_jinja(verbose=args.verbose)
        self.make('Makefile.sketch')
        self.scan_dependencies()
        self.make('Makefile')

########NEW FILE########
__FILENAME__ = clean
# -*- coding: utf-8; -*-

import os.path
import shutil

from ino.commands.base import Command


class Clean(Command):
    """
    Remove all intermediate compilation files and directories completely.

    In fact `.build' directory is simply removed.
    """

    name = 'clean'
    help_line = "Remove intermediate compilation files completely"

    def run(self, args):
        if os.path.isdir(self.e.output_dir):
            shutil.rmtree(self.e.output_dir)

########NEW FILE########
__FILENAME__ = init
# -*- coding: utf-8; -*-

import os.path
import shutil

from configobj import ConfigObj

from ino.commands.base import Command
from ino.exc import Abort
from ino.utils import format_available_options, list_subdirs


class Init(Command):
    """
    Setup a new project in the current directory.

    The directory must be empty.
    """

    name = 'init'
    help_line = "Setup a new project in the current directory"

    default_template = 'empty'

    def setup_arg_parser(self, parser):
        super(Init, self).setup_arg_parser(parser)
        parser.add_argument('-t', '--template', default=self.default_template, 
                            help='Project template to use')

        parser.epilog = "Available project templates:\n\n"

        template_items = []
        for tdir in list_subdirs(self.e.templates_dir):
            try:
                description = ConfigObj(os.path.join(tdir, 'manifest.ini'))['description']
            except KeyError:
                description = ''
            template_items.append((os.path.basename(tdir), description))

        parser.epilog += format_available_options(template_items, head_width=12, 
                                                  default=self.default_template)

    def run(self, args):
        try:
            copytree(os.path.join(self.e['templates_dir'], args.template),
                     '.', ignore=lambda *args: ['manifest.ini'])
        except shutil.Error as e:
            raise Abort(str(e))


def copytree(src, dst, symlinks=False, ignore=None):
    """
    Tweaked version of shutil.copy tree that allows to copy
    to current directory
    """
    names = os.listdir(src)
    if ignore is not None:
        ignored_names = ignore(src, names)
    else:
        ignored_names = set()

    if dst == '.':
        if os.listdir(dst):
            raise shutil.Error('Current directory is not empty')
    else:
        os.makedirs(dst)

    errors = []
    for name in names:
        if name in ignored_names:
            continue
        srcname = os.path.join(src, name)
        dstname = os.path.join(dst, name)
        try:
            if symlinks and os.path.islink(srcname):
                linkto = os.readlink(srcname)
                os.symlink(linkto, dstname)
            elif os.path.isdir(srcname):
                copytree(srcname, dstname, symlinks, ignore)
            else:
                shutil.copy2(srcname, dstname)
        except (IOError, os.error), why:
            errors.append((srcname, dstname, str(why)))
        # catch the Error from the recursive copytree so that we can
        # continue with other files
        except shutil.Error, err:
            errors.extend(err.args[0])
    if errors:
        raise shutil.Error(errors)

########NEW FILE########
__FILENAME__ = listmodels
# -*- coding: utf-8; -*-

from ino.commands.base import Command


class ListModels(Command):
    """
    Print list of supported Arduino board models.

    These could be used as a value for --board-model or -m command
    line switch for build and upload subcommands.

    Symbolic model names as well as their descriptions are fetched
    from `boards.txt' file within found Arduino distribution.
    """

    name = 'list-models'
    help_line = 'List supported Arduino board models'

    def setup_arg_parser(self, parser):
        super(ListModels, self).setup_arg_parser(parser)
        self.e.add_arduino_dist_arg(parser)

    def run(self, args):
        print self.e.board_models().format()

########NEW FILE########
__FILENAME__ = preproc
# -*- coding: utf-8; -*-

import sys
import re

from ino.commands.base import Command
from ino.exc import Abort


class Preprocess(Command):
    """
    Preprocess an .ino or .pde sketch file and produce ready-to-compile .cpp source.

    Ino mimics steps that are performed by official Arduino Software to
    produce similar result:

        * Either #include <Arduino.h> or <WProgram.h> is prepended
        * Function prototypes are added at the beginning of file
    """

    name = 'preproc'
    help_line = "Transform a sketch file into valid C++ source"

    def setup_arg_parser(self, parser):
        super(Preprocess, self).setup_arg_parser(parser)
        self.e.add_arduino_dist_arg(parser)
        parser.add_argument('sketch', help='Input sketch file name')
        parser.add_argument('-o', '--output', default='-', help='Output source file name (default: use stdout)')

    def run(self, args):
        if args.output == '-':
            out = sys.stdout
        else:
            out = open(args.output, 'wt')

        sketch = open(args.sketch, 'rt').read()
        prototypes = self.prototypes(sketch)
        lines = sketch.split('\n')
        includes, lines = self.extract_includes(lines)

        header = 'Arduino.h' if self.e.arduino_lib_version.major else 'WProgram.h'
        out.write('#include <%s>\n' % header)

        out.write('\n'.join(includes))
        out.write('\n')

        out.write('\n'.join(prototypes))
        out.write('\n')

        out.write('#line 1 "%s"\n' % args.sketch)
        out.write('\n'.join(lines))

    def prototypes(self, src):
        src = self.collapse_braces(self.strip(src))
        regex = re.compile("[\\w\\[\\]\\*]+\\s+[&\\[\\]\\*\\w\\s]+\\([&,\\[\\]\\*\\w\\s]*\\)(?=\\s*\\{)")
        matches = regex.findall(src)
        return [m + ';' for m in matches]

    def extract_includes(self, src_lines):
        regex = re.compile("^\\s*#include\\s*[<\"](\\S+)[\">]")
        includes = []
        sketch = []
        for line in src_lines:
            match = regex.match(line)
            if match:
                includes.append(line)
                # if the line is #include directive it should be
                # commented out in original sketch so that
                #  1) it would not be included twice
                #  2) line numbers will be preserved
                sketch.append('//' + line)
            else:
                sketch.append(line)

        return includes, sketch

    def collapse_braces(self, src):
        """
        Remove the contents of all top-level curly brace pairs {}.
        """
        result = []
        nesting = 0;

        for c in src:
            if not nesting:
                result.append(c)
            if c == '{':
                nesting += 1
            elif c == '}':
                nesting -= 1
                result.append(c)
        
        return ''.join(result)

    def strip(self, src):
        """
        Strips comments, pre-processor directives, single- and double-quoted
        strings from a string.
        """
        # single-quoted character
        p = "('.')"
        
        # double-quoted string
        p += "|(\"(?:[^\"\\\\]|\\\\.)*\")"
        
        # single and multi-line comment
        p += "|(//.*?$)|(/\\*[^*]*(?:\\*(?!/)[^*]*)*\\*/)"
        
        # pre-processor directive
        p += "|" + "(^\\s*#.*?$)"

        regex = re.compile(p, re.MULTILINE)
        return regex.sub(' ', src)

########NEW FILE########
__FILENAME__ = serial
# -*- coding: utf-8; -*-

import subprocess

from ino.commands.base import Command


class Serial(Command):
    """
    Open a serial monitor to communicate with the device.

    At the moment `picocom' is used as a program started by this command.
    Use Ctrl+A Ctrl+X to exit.
    """

    name = 'serial'
    help_line = "Open a serial monitor"

    def setup_arg_parser(self, parser):
        super(Serial, self).setup_arg_parser(parser)
        parser.add_argument('-p', '--serial-port', metavar='PORT',
                            help='Serial port to communicate with\nTry to guess if not specified')
        parser.add_argument('-b', '--baud-rate', metavar='RATE', type=int, default=9600, 
                            help='Communication baud rate, should match value set in Serial.begin() on Arduino')
        parser.add_argument('remainder', nargs='*', metavar='ARGS',
                            help='Extra picocom args that are passed as is')

        parser.usage = "%(prog)s [-h] [-p PORT] [-b RATE] [-- ARGS]"

    def run(self, args):
        serial_monitor = self.e.find_tool('serial', ['picocom'], human_name='Serial monitor (picocom)')
        serial_port = args.serial_port or self.e.guess_serial_port()

        subprocess.call([
            serial_monitor,
            serial_port,
            '-b', str(args.baud_rate),
            '-l'
        ] + args.remainder)

########NEW FILE########
__FILENAME__ = upload
# -*- coding: utf-8; -*-

from __future__ import absolute_import

import os.path
import subprocess
import platform

from time import sleep
from serial import Serial
from serial.serialutil import SerialException

from ino.commands.base import Command
from ino.exc import Abort


class Upload(Command):
    """
    Upload built firmware to the device.

    The firmware must be already explicitly built with `ino build'. If current
    device firmare reads/writes serial port extensively, upload may fail. In
    that case try to retry few times or upload just after pushing Reset button
    on Arduino board.
    """

    name = 'upload'
    help_line = "Upload built firmware to the device"

    def setup_arg_parser(self, parser):
        super(Upload, self).setup_arg_parser(parser)
        parser.add_argument('-p', '--serial-port', metavar='PORT',
                            help='Serial port to upload firmware to\nTry to guess if not specified')

        self.e.add_board_model_arg(parser)
        self.e.add_arduino_dist_arg(parser)

    def discover(self):
        self.e.find_tool('stty', ['stty'])
        if platform.system() == 'Linux':
            self.e.find_arduino_tool('avrdude', ['hardware', 'tools'])

            conf_places = self.e.arduino_dist_places(['hardware', 'tools'])
            conf_places.append('/etc/avrdude') # fallback to system-wide conf on Fedora
            self.e.find_file('avrdude.conf', places=conf_places)
        else:
            self.e.find_arduino_tool('avrdude', ['hardware', 'tools', 'avr', 'bin'])
            self.e.find_arduino_file('avrdude.conf', ['hardware', 'tools', 'avr', 'etc'])
    
    def run(self, args):
        self.discover()
        port = args.serial_port or self.e.guess_serial_port()
        board = self.e.board_model(args.board_model)

        protocol = board['upload']['protocol']
        if protocol == 'stk500':
            # if v1 is not specifid explicitly avrdude will
            # try v2 first and fail
            protocol = 'stk500v1'

        if not os.path.exists(port):
            raise Abort("%s doesn't exist. Is Arduino connected?" % port)

        # send a hangup signal when the last process closes the tty
        file_switch = '-f' if platform.system() == 'Darwin' else '-F'
        ret = subprocess.call([self.e['stty'], file_switch, port, 'hupcl'])
        if ret:
            raise Abort("stty failed")

        # pulse on DTR
        try:
            s = Serial(port, 115200)
        except SerialException as e:
            raise Abort(str(e))
        s.setDTR(False)
        sleep(0.1)
        s.setDTR(True)
        s.close()

        # Need to do a little dance for Leonardo and derivatives:
        # open then close the port at the magic baudrate (usually 1200 bps) first
        # to signal to the sketch that it should reset into bootloader. after doing
        # this wait a moment for the bootloader to enumerate. On Windows, also must
        # deal with the fact that the COM port number changes from bootloader to
        # sketch.
        touch_port = \
                board['upload'].get('use_1200bps_touch') == 'true' or \
                board['upload']['protocol'] == 'avr109'

        if touch_port:
            new_port = None
            before = self.e.list_serial_ports()
            if port in before:
                ser = Serial()
                ser.port = port
                ser.baudrate = 1200
                ser.open()
                ser.close()

                # Scanning for available ports seems to open the port or
                # otherwise assert DTR, which would cancel the WDT reset if
                # it happened within 250 ms. So we wait until the reset should
                # have already occured before we start scanning.
                if platform.system() != 'Darwin':
                    sleep(0.3)

            elapsed = 0
            enum_delay = 0.25
            while elapsed < 10:
                now = self.e.list_serial_ports()
                diff = list(set(now) - set(before))
                if diff:
                    new_port = diff[0]
                    break

                before = now
                sleep(enum_delay)
                elapsed += enum_delay

            if not new_port:
                raise Abort("Couldn’t find a board on the selected port. "
                            "Check that you have the correct port selected. "
                            "If it is correct, try pressing the board's reset "
                            "button after initiating the upload.")

            port = new_port

        # call avrdude to upload .hex
        subprocess.call([
            self.e['avrdude'],
            '-C', self.e['avrdude.conf'],
            '-p', board['build']['mcu'],
            '-P', port,
            '-c', protocol,
            '-b', board['upload']['speed'],
            '-D',
            '-U', 'flash:w:%s:i' % self.e['hex_path'],
        ])

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8; -*-

import os.path

from configobj import ConfigObj


class Configuration(object):
    def __init__(self, *files):
        self.cfg = ConfigObj()
        for f in files:
            self.cfg.merge(ConfigObj(os.path.expanduser(f)))

    def as_dict(self, section_name):
        section = self.cfg.get(section_name, ConfigObj())
        result = self._as_plain_dict(self.cfg)
        result.update(self._as_plain_dict(section))
        return result

    def _as_plain_dict(self, section):
        return dict((key.replace('-', '_'), section[key]) for key in section.scalars)


def configure():
    return Configuration('/etc/ino.ini', '~/.inorc', 'ino.ini')

########NEW FILE########
__FILENAME__ = environment
# -*- coding: utf-8; -*-

import sys
import os.path
import itertools
import argparse
import pickle
import platform
import hashlib
import re

try:
    from collections import OrderedDict
except ImportError:
    # Python < 2.7
    from ordereddict import OrderedDict

from collections import namedtuple
from glob2 import glob

from ino.filters import colorize
from ino.utils import format_available_options
from ino.exc import Abort


class Version(namedtuple('Version', 'major minor build')):

    regex = re.compile(ur'^([^:]+:)?(\d+(\.\d+(\.\d+)?)?)')

    @classmethod
    def parse(cls, s):
        # Version could have various forms
        #   0022
        #   0022ubuntu0.1
        #   0022-macosx-20110822
        #   1.0
        #   1:1.0.5+dfsg2-1
        # We have to extract a 3-int-tuple (major, minor, build)
        match = cls.regex.match(s)
        if not match:
            raise Abort("Could not parse Arduino library version: %s" % s)

        # v is numbers possibly split by dots without a trash
        v = match.group(2)

        if v.startswith('0'):
            # looks like old 0022 or something like that
            return cls(0, int(v), 0)

        parts = map(int, v.split('.'))

        # append nulls if they were not explicit
        while len(parts) < 3:
            parts.append(0)

        return cls(*parts)

    def as_int(self):
        if not self.major:
            return self.minor
        return self.major * 100 + self.minor * 10 + self.build

    def __str__(self):
        return '%s.%s.%s' % self


class Environment(dict):

    templates_dir = os.path.join(os.path.dirname(__file__), 'templates')
    output_dir = '.build'
    src_dir = 'src'
    lib_dir = 'lib'
    hex_filename = 'firmware.hex'

    arduino_dist_dir = None
    arduino_dist_dir_guesses = [
        '/usr/local/share/arduino',
        '/usr/share/arduino',
    ]

    if platform.system() == 'Darwin':
        arduino_dist_dir_guesses.insert(0, '/Applications/Arduino.app/Contents/Resources/Java')

    default_board_model = 'uno'
    ino = sys.argv[0]

    def dump(self):
        if not os.path.isdir(self.output_dir):
            return
        with open(self.dump_filepath, 'wb') as f:
            pickle.dump(self.items(), f)

    def load(self):
        if not os.path.exists(self.dump_filepath):
            return
        with open(self.dump_filepath, 'rb') as f:
            try:
                self.update(pickle.load(f))
            except:
                print colorize('Environment dump exists (%s), but failed to load' % 
                               self.dump_filepath, 'yellow')

    @property
    def dump_filepath(self):
        return os.path.join(self.output_dir, 'environment.pickle')

    def __getitem__(self, key):
        try:
            return super(Environment, self).__getitem__(key)
        except KeyError as e:
            try:
                return getattr(self, key)
            except AttributeError:
                raise e

    def __getattr__(self, attr):
        try:
            return super(Environment, self).__getitem__(attr)
        except KeyError:
            raise AttributeError("Environment has no attribute %r" % attr)

    @property
    def hex_path(self):
        return os.path.join(self.build_dir, self.hex_filename)

    def _find(self, key, items, places, human_name, join, multi):
        """
        Search for file-system entry with any name passed in `items` on
        all paths provided in `places`. Use `key` as a cache key.

        If `join` is True result will be a path join of place/item,
        otherwise only place is taken as result.

        Return first found match unless `multi` is True. In that case
        a list with all fount matches is returned.

        Raise `Abort` if no matches were found.
        """
        if key in self:
            return self[key]

        human_name = human_name or key

        # expand env variables in `places` and split on colons
        places = itertools.chain.from_iterable(os.path.expandvars(p).split(os.pathsep) for p in places)
        places = map(os.path.expanduser, places)

        glob_places = itertools.chain.from_iterable(glob(p) for p in places)
        
        print 'Searching for', human_name, '...',
        results = []
        for p in glob_places:
            for i in items:
                path = os.path.join(p, i)
                if os.path.exists(path):
                    result = path if join else p
                    if not multi:
                        print colorize(result, 'green')
                        self[key] = result
                        return result
                    results.append(result)

        if results:
            if len(results) > 1:
                formatted_results = ''.join(['\n  - ' + x for x in results])
                print colorize('found multiple: %s' % formatted_results, 'green')
            else:
                print colorize(results[0], 'green')

            self[key] = results
            return results

        print colorize('FAILED', 'red')
        raise Abort("%s not found. Searched in following places: %s" %
                    (human_name, ''.join(['\n  - ' + p for p in places])))

    def find_dir(self, key, items, places, human_name=None, multi=False):
        return self._find(key, items or ['.'], places, human_name, join=False, multi=multi)

    def find_file(self, key, items=None, places=None, human_name=None, multi=False):
        return self._find(key, items or [key], places, human_name, join=True, multi=multi)

    def find_tool(self, key, items, places=None, human_name=None, multi=False):
        return self.find_file(key, items, places or ['$PATH'], human_name, multi=multi)

    def find_arduino_dir(self, key, dirname_parts, items=None, human_name=None, multi=False):
        return self.find_dir(key, items, self.arduino_dist_places(dirname_parts), human_name, multi=multi)

    def find_arduino_file(self, key, dirname_parts, items=None, human_name=None, multi=False):
        return self.find_file(key, items, self.arduino_dist_places(dirname_parts), human_name, multi=multi)

    def find_arduino_tool(self, key, dirname_parts, items=None, human_name=None, multi=False):
        # if not bundled with Arduino Software the tool should be searched on PATH
        places = self.arduino_dist_places(dirname_parts) + ['$PATH']
        return self.find_file(key, items, places, human_name, multi=multi)

    def arduino_dist_places(self, dirname_parts):
        """
        For `dirname_parts` like [a, b, c] return list of
        search paths within Arduino distribution directory like:
            /user/specified/path/a/b/c
            /usr/local/share/arduino/a/b/c
            /usr/share/arduino/a/b/c
        """
        if 'arduino_dist_dir' in self:
            places = [self['arduino_dist_dir']]
        else:
            places = self.arduino_dist_dir_guesses
        return [os.path.join(p, *dirname_parts) for p in places]

    def board_models(self):
        if 'board_models' in self:
            return self['board_models']

        # boards.txt can be placed in following places
        # - hardware/arduino/boards.txt (Arduino IDE 0.xx, 1.0.x)
        # - hardware/arduino/{chipset}/boards.txt (Arduino 1.5.x, chipset like `avr`, `sam`)
        # - hardware/{platform}/boards.txt (MPIDE 0.xx, platform like `arduino`, `pic32`)
        # we should find and merge them all
        boards_txts = self.find_arduino_file('boards.txt', ['hardware', '**'], 
                                             human_name='Board description file (boards.txt)',
                                             multi=True)

        self['board_models'] = BoardModels()
        self['board_models'].default = self.default_board_model
        for boards_txt in boards_txts:
            with open(boards_txt) as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue

                    # Transform lines like:
                    #   yun.upload.maximum_data_size=2560
                    # into a nested dict `board_models` so that
                    #   self['board_models']['yun']['upload']['maximum_data_size'] == 2560
                    multikey, _, val = line.partition('=')
                    multikey = multikey.split('.')

                    # traverse into dictionary up to deepest level
                    # create nested dictionaries if they aren't exist yet
                    subdict = self['board_models']
                    for key in multikey[:-1]:
                        if key not in subdict:
                            subdict[key] = {}
                        elif not isinstance(subdict[key], dict):
                            # it happens that a particular key
                            # has a value and has sublevels at same time. E.g.:
                            #   diecimila.menu.cpu.atmega168=ATmega168
                            #   diecimila.menu.cpu.atmega168.upload.maximum_size=14336
                            #   diecimila.menu.cpu.atmega168.upload.maximum_data_size=1024
                            #   diecimila.menu.cpu.atmega168.upload.speed=19200
                            # place value `ATmega168` into a special key `_` in such case
                            subdict[key] = {'_': subdict[key]}
                        subdict = subdict[key]

                    subdict[multikey[-1]] = val

                    # store spectial `_coredir` value on top level so we later can build
                    # paths relative to a core directory of a specific board model
                    self['board_models'][multikey[0]]['_coredir'] = os.path.dirname(boards_txt)

        return self['board_models']

    def board_model(self, key):
        return self.board_models()[key]
    
    def add_board_model_arg(self, parser):
        help = '\n'.join([
            "Arduino board model (default: %(default)s)",
            "For a full list of supported models run:", 
            "`ino list-models'"
        ])

        parser.add_argument('-m', '--board-model', metavar='MODEL', 
                            default=self.default_board_model, help=help)

    def add_arduino_dist_arg(self, parser):
        parser.add_argument('-d', '--arduino-dist', metavar='PATH', 
                            help='Path to Arduino distribution, e.g. ~/Downloads/arduino-0022.\nTry to guess if not specified')

    def serial_port_patterns(self):
        system = platform.system()
        if system == 'Linux':
            return ['/dev/ttyACM*', '/dev/ttyUSB*']
        if system == 'Darwin':
            return ['/dev/tty.usbmodem*', '/dev/tty.usbserial*']
        raise NotImplementedError("Not implemented for Windows")

    def list_serial_ports(self):
        ports = []
        for p in self.serial_port_patterns():
            matches = glob(p)
            ports.extend(matches)
        return ports

    def guess_serial_port(self):
        print 'Guessing serial port ...',

        ports = self.list_serial_ports()
        if ports:
            result = ports[0]
            print colorize(result, 'yellow')
            return result

        print colorize('FAILED', 'red')
        raise Abort("No device matching following was found: %s" %
                    (''.join(['\n  - ' + p for p in self.serial_port_patterns()])))

    def process_args(self, args):
        arduino_dist = getattr(args, 'arduino_dist', None)
        if arduino_dist:
            self['arduino_dist_dir'] = arduino_dist

        board_model = getattr(args, 'board_model', None)
        if board_model:
            all_models = self.board_models()
            if board_model not in all_models:
                print "Supported Arduino board models are:"
                print all_models.format()
                raise Abort('%s is not a valid board model' % board_model)

        # Build artifacts for each Arduino distribution / Board model
        # pair should go to a separate subdirectory
        build_dirname = board_model or self.default_board_model
        if arduino_dist:
            hash = hashlib.md5(arduino_dist).hexdigest()[:8]
            build_dirname = '%s-%s' % (build_dirname, hash)

        self['build_dir'] = os.path.join(self.output_dir, build_dirname)

    @property
    def arduino_lib_version(self):
        self.find_arduino_file('version.txt', ['lib'],
                               human_name='Arduino lib version file (version.txt)')

        if 'arduino_lib_version' not in self:
            with open(self['version.txt']) as f:
                print 'Detecting Arduino software version ... ',
                v_string = f.read().strip()
                v = Version.parse(v_string)
                self['arduino_lib_version'] = v
                print colorize("%s (%s)" % (v, v_string), 'green')

        return self['arduino_lib_version']


class BoardModels(OrderedDict):
    def format(self):
        map = [(key, val['name']) for key, val in self.iteritems() if 'name' in val]
        return format_available_options(map, head_width=12, default=self.default)

########NEW FILE########
__FILENAME__ = exc
# -*- coding: utf-8; -*-

class Abort(Exception):
    pass

########NEW FILE########
__FILENAME__ = filters
# -*- coding: utf-8; -*-

import sys
import os.path
import fnmatch
import functools

from ino.utils import FileMap, SpaceList


class GlobFile(object):
    def __init__(self, filename, dirname):
        self.filename = filename
        self.dirname = dirname

    @property
    def path(self):
        return os.path.join(self.dirname, self.filename)

    def __repr__(self):
        return '<%s + %s>' % (self.dirname, self.filename)

    def __str__(self):
        return self.filename


def filter(f):
    f.filter = True
    return f


@filter
def glob(dir, *patterns, **kwargs):
    recursive = kwargs.get('recursive', True)
    subdir = kwargs.get('subdir', '')

    result = SpaceList()
    scan_dir = os.path.join(dir, subdir)
    if not os.path.isdir(scan_dir):
        return result

    for entry in os.listdir(scan_dir):
        path = os.path.join(scan_dir, entry)
        if os.path.isdir(path) and recursive:
            subglob = glob(dir, *patterns, recursive=True,
                           subdir=os.path.join(subdir, entry))
            result.extend(subglob)
        elif os.path.isfile(path) and any(fnmatch.fnmatch(entry, p) for p in patterns):
            result.append(GlobFile(os.path.join(subdir, entry), dir))

    return result


@filter
def pjoin(base, *parts):
    return os.path.join(str(base), *map(str, parts))


def xname(filepath, basename_fmt):
    head, tail = os.path.split(str(filepath))
    basename, _ = os.path.splitext(tail)
    return os.path.join(head, basename_fmt % basename)


@filter
def objname(filepath):
    return xname(filepath, '%s.o')


@filter
def libname(filepath):
    return xname(filepath, 'lib%s.a')


@filter
def depsname(filepath):
    return xname(filepath, '%s.d')


basename = filter(os.path.basename)
dirname = filter(os.path.dirname)
relative_to = filter(os.path.relpath)


@filter
def filemap(sources, target_dir, rename_rule):
    return FileMap((source, GlobFile(xname(source, rename_rule), target_dir)) 
                   for source in sources)

@filter
def libmap(source_dirs, target_dir):
    return FileMap((
        source_dir, 
        GlobFile(libname(basename(source_dir)), 
                 pjoin(target_dir, basename(source_dir))))
        for source_dir in source_dirs)


@filter
def colorize(s, color):
    if not sys.stdout.isatty():
        return s

    ccodes = {
        'cyan':     '96',
        'purple':   '95',
        'blue':     '94',
        'green':    '92',
        'yellow':   '93',
        'red':      '91',
    }

    return ''.join([
        '\033[', ccodes[color], 'm', 
        s,
        '\033[0m'
    ])

########NEW FILE########
__FILENAME__ = runner
#!/usr/bin/env python2
# -*- coding: utf-8; -*-

"""\
Ino is a command-line toolkit for working with Arduino hardware.

It is intended to replace Arduino IDE UI for those who prefer to work in
terminal or want to integrate Arduino development in a 3rd party IDE.

Ino can build sketches, libraries, upload firmwares, establish
serial-communication. For this it is split in a bunch of subcommands, like git
or mercurial do. The full list is provided below. You may run any of them with
--help to get further help. E.g.:

    ino build --help
"""

import sys
import os.path
import argparse
import inspect

import ino.commands

from ino.commands.base import Command
from ino.conf import configure
from ino.exc import Abort
from ino.filters import colorize
from ino.environment import Environment
from ino.argparsing import FlexiFormatter


def main():
    e = Environment()
    e.load()

    conf = configure()

    try:
        current_command = sys.argv[1]
    except IndexError:
        current_command = None

    parser = argparse.ArgumentParser(prog='ino', formatter_class=FlexiFormatter, description=__doc__)
    subparsers = parser.add_subparsers()
    is_command = lambda x: inspect.isclass(x) and issubclass(x, Command) and x != Command
    commands = [cls(e) for _, cls in inspect.getmembers(ino.commands, is_command)]
    for cmd in commands:
        p = subparsers.add_parser(cmd.name, formatter_class=FlexiFormatter, help=cmd.help_line)
        if current_command != cmd.name:
            continue
        cmd.setup_arg_parser(p)
        p.set_defaults(func=cmd.run, **conf.as_dict(cmd.name))

    args = parser.parse_args()

    try:
        run_anywhere = "init clean list-models serial"

        in_project_dir = os.path.isdir(e.src_dir)
        if not in_project_dir and current_command not in run_anywhere:
            raise Abort("No project found in this directory.")

        e.process_args(args)

        if current_command not in run_anywhere:
            # For valid projects create .build & lib
            if not os.path.isdir(e.build_dir):                
                os.makedirs(e.build_dir)

            if not os.path.isdir(e.lib_dir):
                os.makedirs(e.lib_dir)
                with open('lib/.holder', 'w') as f:
                    f.write("")

        args.func(args)
    except Abort as exc:
        print colorize(str(exc), 'red')
        sys.exit(1)
    except KeyboardInterrupt:
        print 'Terminated by user'
    finally:
        e.dump()

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8; -*-

import os.path
import itertools


try:
    from collections import OrderedDict
except ImportError:
    # Python < 2.7
    from ordereddict import OrderedDict


class SpaceList(list):
    def __add__(self, other):
        return SpaceList(super(SpaceList, self).__add__(other))

    def __str__(self):
        return ' '.join(map(str, self))

    def paths(self):
        return SpaceList(getattr(x, 'path', x) for x in self)


class FileMap(OrderedDict):
    def sources(self):
        return SpaceList(self.iterkeys())

    def targets(self):
        return SpaceList(self.itervalues())

    def iterpaths(self):
        for source, target in self.iteritems():
            yield (source.path, target.path)

    def target_paths(self):
        return SpaceList(x.path for x in self.targets())


def list_subdirs(dirname, recursive=False, exclude=[]):
    entries = [e for e in os.listdir(dirname) if e not in exclude and not e.startswith('.')]
    paths = [os.path.join(dirname, e) for e in entries]
    dirs = filter(os.path.isdir, paths)
    if recursive:
        sub = itertools.chain.from_iterable(
            list_subdirs(d, recursive=True, exclude=exclude) for d in dirs)
        dirs.extend(sub)
    return dirs


def format_available_options(items, head_width, head_color='cyan', 
                             default=None, default_mark="[DEFAULT]", 
                             default_mark_color='red'):
    from ino.filters import colorize
    default_mark = colorize(default_mark + ' ', default_mark_color)
    lines = ['%s: %s%s' % (colorize('%%%ds' % head_width % key, head_color), 
                           default_mark if key == default else '', 
                           val) 
             for key, val in items]
    return '\n'.join(lines)

########NEW FILE########
__FILENAME__ = environment_tests
# -*- coding: utf-8; -*-

from nose.tools import assert_equal

from ino.environment import Version


class TestVersion(object):
    def test_parsing(self):
        assert_equal(Version.parse('0022'), (0, 22, 0))
        assert_equal(Version.parse('0022ubuntu0.1'), (0, 22, 0))
        assert_equal(Version.parse('0022-macosx-20110822'), (0, 22, 0))
        assert_equal(Version.parse('1.0'), (1, 0, 0))
        assert_equal(Version.parse('1:1.0.5+dfsg2-1'), (1, 0, 5))

    def test_int_conversion(self):
        assert_equal(Version(0, 22, 0).as_int(), 22)
        assert_equal(Version(1, 0, 0).as_int(), 100)
        assert_equal(Version(1, 0, 5).as_int(), 105)
        assert_equal(Version(1, 5, 1).as_int(), 151)

########NEW FILE########
