<h1>Ajaxterm</h1>

<h2>Intro</h2>
<pre>
Ajaxterm is a web based terminal. It was totally inspired and works almost
exactly like http://anyterm.org/ except it's much easier to install (see
comparaison with anyterm below).

Ajaxterm written in python (and some AJAX javascript for client side) and
depends only on python2.3 or better.

Ajaxterm is '''very simple to install''' on Linux, MacOS X, FreeBSD, Solaris,
cygwin and any Unix that runs python2.3.

Ajaxterm was written by Antony Lesuisse (email: al AT udev.org), License Public
Domain.
</pre>

<!-- ====================================================== -->

<h2>News</h2>
<pre>
 - 2008-11-13: v0.11 switch to git, apply minor patches
 - 2006-10-29: v0.10 allow space in login, cgi launch fix, redhat init
 - 2006-07-12: v0.9 change uid, daemon fix (Daniel Fischer)
 - 2006-07-04: v0.8 add login support to ssh (Sven Geggus), change max width to 256
 - 2006-05-31: v0.7 minor fixes, daemon option
 - 2006-05-23: v0.6 Applied debian and gentoo patches, renamed to Ajaxterm, default port 8022
</pre>

<!-- ====================================================== -->

<h2>Download and Install</h2>
<pre>

 - Release: /ajaxterm/files/Ajaxterm-0.10.tar.gz

To install Ajaxterm issue the following commands:

    wget http://antony.lesuisse.org/ajaxterm/files/Ajaxterm-0.10.tar.gz
    tar zxvf Ajaxterm-0.10.tar.gz
    cd Ajaxterm-0.10
    ./ajaxterm.py

Then point your browser to this URL : http://localhost:8022/
</pre>

<!-- ====================================================== -->

<h2>Screenshot</h2>

<img src="scr.png" alt="ajaxterm screenshot"/>

<!-- ====================================================== -->

<h2>Documentation and Caveats</h2>
<pre>
 * Ajaxterm only support latin1, if you use Ubuntu or any LANG==en_US.UTF-8
   distribution don't forget to "unset LANG".

 * If run as root ajaxterm will run /bin/login, otherwise it will run ssh
   localhost. To use an other command use the -c option.

 * By default Ajaxterm only listen at 127.0.0.1:8022. For remote access, it is
   strongly recommended to use '''https SSL/TLS''', and that is simple to
   configure if you use the apache web server using mod_proxy.[[BR]][[BR]]
   Using ssl will also speed up ajaxterm (probably because of keepalive).[[BR]][[BR]]
   Here is an configuration example:

    Listen 443
    NameVirtualHost *:443

    &lt;VirtualHost *:443&gt;
       ServerName localhost
       SSLEngine On
       SSLCertificateKeyFile ssl/apache.pem
       SSLCertificateFile ssl/apache.pem

       ProxyRequests Off
       &lt;Proxy *&gt;
               Order deny,allow
               Allow from all
       &lt;/Proxy&gt;
       ProxyPass /ajaxterm/ http://localhost:8022/
       ProxyPassReverse /ajaxterm/ http://localhost:8022/
    &lt;/VirtualHost&gt;

 * Using GET HTTP request seems to speed up ajaxterm, just click on GET in the
   interface, but be warned that your keystrokes might be loggued (by apache or
   any proxy). I usually enable it after the login.

 * Ajaxterm commandline usage:

    usage: ajaxterm.py [options]

    options:
      -h, --help            show this help message and exit
      -pPORT, --port=PORT   Set the TCP port (default: 8022)
      -cCMD, --command=CMD  set the command (default: /bin/login or ssh localhost)
      -l, --log             log requests to stderr (default: quiet mode)
      -d, --daemon          run as daemon in the background
      -PPIDFILE, --pidfile=PIDFILE
                            set the pidfile (default: /var/run/ajaxterm.pid)
      -iINDEX_FILE, --index=INDEX_FILE
                            default index file (default: ajaxterm.html)
      -uUID, --uid=UID      Set the daemon's user id

 * Ajaxterm was first written as a demo for qweb (my web framework), but
   actually doesn't use many features of qweb.

 * Compared to anyterm:
   * There are no partial updates, ajaxterm updates either all the screen or
     nothing. That make the code simpler and I also think it's faster. HTTP
     replies are always gzencoded. When used in 80x25 mode, almost all of
     them are below the 1500 bytes (size of an ethernet frame) and we just
     replace the screen with the reply (no javascript string handling).
   * Ajaxterm polls the server for updates with an exponentially growing
     timeout when the screen hasn't changed. The timeout is also resetted as
     soon as a key is pressed. Anyterm blocks on a pending request and use a
     parallel connection for keypresses. The anyterm approch is better
     when there aren't any keypress.

 * Ajaxterm files are released in the Public Domain, (except
 [http://sarissa.sourceforge.net/doc/ sarissa*] which are LGPL).
</pre>

<!-- ====================================================== -->

<h2>TODO</h2>
<pre>
 * insert mode ESC [ 4 h
 * change size x,y from gui (sending signal)
 * vt102 graphic codepage
 * use innerHTML or prototype instead of sarissa
</pre>

<div style="margin: 0 0 0 4em;">
<h1>PyPHP the python php bridge</h1>
<div style="margin: 0 0 0 2em; width: 80%;">
Run your python <a href="http://www.python.org/peps/pep-0333.html">WSGI</a> web
applications (like QWeb ones) under a php enabled web server without any
setup.<br/>


<br/>
<small>
by Antony Lesuisse (Email: al at udev.org) in 2004-2005,<br/>
Released in the Public Domain.
</small>

</div>

<h2>Description</h2>
<div style="margin: 0 0 0 2em; width: 80%;">
PyPHP enables running Python web application using PHP as the interface to the
web server.<br>
Either:
<ul>
<li> Your python scripts are run like a php script would be run. (simple mode) </li>
<li> Your python file define a WSGI conformant app.  </li>
</ul>
<br/>
With PyPHP you get the best of both Python and PHP world:
<ul>
<li>The power, cleanness and robustness of the Python language</li>
<li>NO config files to edit, like php, just copy files to deploy</li>
<li>The low level integration of PHP with the web server including:
	<ul>
		<li> HTTP authentification</li>
		<li> Ouput buffering</li>
		<li> header/cookie management</li>
		<li> POST file upload handling</li>
		<li> HTTPS SSL TLS handling</li>
	</ul>
</li>
<li>Session management (using pickle you are able to store your python objects in the PHP sessions)</li>
<li>Database connection pooling (however we recommand the usage of python db api)</li>
<li>Access to all the PHP api (even if the python api is in most cases superior)</li>
</ul>


<span style="font-weight: bold;font-size: 120%;font-family: sans-serif;">
PyPHP doesn't require any form of installation or configuration !</span><br/>
Just copy the files pyphp.py and pyphp.php to your php-enabled web server
directory and you are ready to run.

</div>

<h2>Quickstart for the simple mode:</h2>
<div style="margin: 0 0 0 2em; width: 80%;">

Hello world in pyphp filename must ends with .php and begins with '&lt;?include("pyphp.php");pyphp_run();?&gt;':

<pre style="padding: 10px 10px 10px 3em; background-color: #f0f0f0;border: 1px solid #dddddd;">
&lt;?include("pyphp.php");pyphp_run();?&gt;
print "Hello World"
</pre>

A global object called "php" allows you to access php objects and functions.

</div>

<h2>Quickstart for the WSGI mode:</h2>
<div style="margin: 0 0 0 2em; width: 80%;">

Hello world app the filename must ends with .php and begins with
'&lt;?include("pyphp.php");pyphp_run("wsgiapp");?&gt;', the argument of
pyphp_run() must be the name of the web app.<br><br>

environ["php"] contains the PHPProxy.  <br><br>

Use that for file uploads, cookies, session etc..<br><br>

See the examples below demo_wsgi*.

</div>


<h2>The php object (PHPProxy)</h2>
<div style="margin: 0 0 0 2em; width: 80%;">

<ul>
<li> all the php namespace is acessible from the php object (example: php date() function is is availaible as <tt>php.date()</tt>)
<li> each time a php function is called, the arguments are serialized from python to
php, and the return value is serialized from php to python.
<li> the convertion of a php array is a dict in python
<li> $_GET is availaible as <tt>php._GET</tt>
<li> $_POST is availaible as <tt>php._POST</tt>
<li> $_SESSION is availaible as <tt>php._SESSION</tt>
<li> idem for all $_* global php variables
<li> <tt>php._ARG</tt> is the merge of <tt>php._GET</tt> and
<tt>php._POST</tt>, it is a python dict with an additional <tt>int(key)</tt>
method that return the corresponding <tt>int()</tt> value or 0 if not found.
Useful to handle parameters like database ids.
<li> use <tt>php.exit()</tt> to exit your script instead of <tt>sys.exit()</tt>
</ul>

<br/>
</div>

<h2>All examples:</h2>
<div style="margin: 0 0 0 2em; width: 80%;">





<!-- EXAMPLE -->


	Example : demo_hello.php<br>

	<pre style="padding: 10px 10px 10px 3em; background-color: #f0f0f0;border: 1px solid #dddddd;">&lt;?include("pyphp.php");pyphp_run();?&gt;
# vim:syntax=python:

print "Hello World"

</pre>
	<br>
	<br>
	
	Example : demo_wsgi1.php<br>

	<pre style="padding: 10px 10px 10px 3em; background-color: #f0f0f0;border: 1px solid #dddddd;">&lt;?include("pyphp.php");pyphp_run("mywsgiapp");?&gt;
# vim:syntax=python:

def mywsgiapp(environ, start_response):
	start_response('200 OK', [('Content-type','text/plain')])

	# access the php api via environ['php']
	ver = environ['php'].phpversion()

	return ['Hello world! via (php %s) \n'%ver]


</pre>
	<br>
	<br>
	
	Example : demo_wsgi2.php<br>

	<pre style="padding: 10px 10px 10px 3em; background-color: #f0f0f0;border: 1px solid #dddddd;">&lt;?include("pyphp.php");pyphp_run("test_app");?&gt;
# vim:syntax=python:

import cgi, time

def test_app(environ, start_response):
	start_response('200 OK', [('Content-Type', 'text/html')])

	# php proxy
	php=environ['php']

	# calling a php function
	php.header("Content-Type: text/html")

	yield '''&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello World!&lt;/title&gt;&lt;/head&gt;
	&lt;body&gt;&lt;p&gt;Hello World!&lt;/p&gt;
	&lt;br/&gt;
	&lt;form action="demo_wsgi2.php" method="GET"&gt;
	&lt;input type="text" name="a" value="test value"/&gt;
	&lt;input type="submit" name="s" value="submit"/&gt;
	&lt;/form&gt;
	&lt;br/&gt;
	&lt;br/&gt;
	'''

	# printing from python
	print "Hello from python time is ", time.ctime(), "&lt;br&gt;&lt;br&gt;"

	# access php $_GET array
	print "php._GET acessible as python dict:", php._GET ,"&lt;br&gt;&lt;br&gt;"

	# use a php function
	print "php exlode ", php.explode("/","/file/path/example"), "&lt;br&gt;&lt;br&gt;"

	# use the php function eval()
	php.eval("print_r(array());")

	# use php sessions
	if not "count" in php._SESSION:
		php._SESSION["count"]=1
	else:
		count=php._SESSION["count"]

	print "session: count,",count, "&lt;br&gt;&lt;br&gt;"
	php._SESSION["count"]=count+1

	# use php mysql api
	print "Try to list mysql users this wont work if root has a mysql password&lt;br&gt;&lt;br&gt;"

	php.mysql_connect(':/var/run/mysqld/mysqld.sock','root')
	php.mysql_select_db('mysql')

	q=php.mysql_query('select User from user LIMIT 0,10')

	while 1:
		r=php.mysql_fetch_assoc(q)
		if not r: break
		print r, '&lt;br&gt;'






</pre>
	<br>
	<br>
	
	Example : demo_wsgi3.php<br>

	<pre style="padding: 10px 10px 10px 3em; background-color: #f0f0f0;border: 1px solid #dddddd;">&lt;?include("pyphp.php");pyphp_run("testapp");?&gt;
# vim:syntax=python:

from demo_wsgi3_testapp import testapp

</pre>
	<br>
	<br>
	
	Example : demo_wsgi3_testapp.py<br>

	<pre style="padding: 10px 10px 10px 3em; background-color: #f0f0f0;border: 1px solid #dddddd;">#/usr/bin/python

def testapp(environ, start_response):
	start_response('200 OK',[('Content-type','text/plain')])
	php=environ['php']

	if 'PHP_AUTH_USER' not in php._SERVER:
		php.header('WWW-Authenticate: Basic realm="My Realm"')
		php.header('HTTP/1.0 401 Unauthorized')
		print 'Text to send if user hits Cancel button';
		php.exit()
	else:
		print "&lt;p&gt;Hello '%s'.&lt;/p&gt;"%(php._SERVER['PHP_AUTH_USER'],)
		print "&lt;p&gt;You entered '%s' as your password.&lt;/p&gt;"%(php._SERVER['PHP_AUTH_PW'])

	return ['done\n']

</pre>
	<br>
	<br>
	 </div> </div> 
You need:

setuptools-0.6a1c2-py2.3.egg
pysqlite-2.0.6-py2.3-linux-i686.egg
FormEncode-0.2.2-py2.3.egg
SQLObject-0.7.0-py2.3.egg

QWeb DemoApp
------------

WARNING:

Despite his name in .fcgi, the example is ALSO RUNNABLE FROM THE
COMMANDLINE !

When runned from command line it starts a webserver on port 8080. 

Point your browser to http://localhost:8080/

It also may be run as FastCGI or regular CGI by any FastCGI or CGI
compatible web server.


= QWeb Framework =

== What is QWeb ? ==

QWeb is a python based [http://www.python.org/doc/peps/pep-0333/ WSGI]
compatible web framework, it provides an infratructure to quickly build web
applications consisting of:

 * A lightweight request handler (QWebRequest)
 * An xml templating engine (QWebXml and QWebHtml)
 * A simple name based controler (qweb_control)
 * A standalone WSGI Server (QWebWSGIServer)
 * A cgi and fastcgi WSGI wrapper (taken from flup)
 * A startup function that starts cgi, factgi or standalone according to the
   evironement (qweb_autorun).

QWeb applications are runnable in standalone mode (from commandline), via
FastCGI, Regular CGI or by any python WSGI compliant server.

QWeb doesn't provide any database access but it integrates nicely with ORMs
such as SQLObject, SQLAlchemy or plain DB-API.

Written by Antony Lesuisse (email al AT udev.org)

Homepage: http://antony.lesuisse.org/qweb/trac/

Forum: [http://antony.lesuisse.org/qweb/forum/viewforum.php?id=1 Forum]

== Quick Start (for Linux, MacOS X and cygwin) ==

Make sure you have at least python 2.3 installed and run the following commands:

{{{
$ wget http://antony.lesuisse.org/qweb/files/QWeb-0.7.tar.gz
$ tar zxvf QWeb-0.7.tar.gz
$ cd QWeb-0.7/examples/blog
$ ./blog.py
}}}

And point your browser to http://localhost:8080/

You may also try AjaxTerm which uses qweb request handler.

== Download ==

 * Version 0.7:
   * Source [/qweb/files/QWeb-0.7.tar.gz QWeb-0.7.tar.gz]
   * Python 2.3 Egg [/qweb/files/QWeb-0.7-py2.3.egg QWeb-0.7-py2.3.egg]
   * Python 2.4 Egg [/qweb/files/QWeb-0.7-py2.4.egg QWeb-0.7-py2.4.egg]

 * [/qweb/trac/browser Browse the source repository]

== Documentation ==

 * [/qweb/trac/browser/trunk/README.txt?format=raw Read the included documentation] 
 * QwebTemplating

== Mailin-list ==

 * Forum: [http://antony.lesuisse.org/qweb/forum/viewforum.php?id=1 Forum]
 * No mailing-list exists yet, discussion should happen on: [http://mail.python.org/mailman/listinfo/web-sig web-sig] [http://mail.python.org/pipermail/web-sig/ archives]


= QWeb Framework =

== What is QWeb ? ==

QWeb is a python based [http://www.python.org/doc/peps/pep-0333/ WSGI]
compatible web framework, it provides an infratructure to quickly build web
applications consisting of:

 * A lightweight request handler (QWebRequest)
 * An xml templating engine (QWebXml and QWebHtml)
 * A simple name based controler (qweb_control)
 * A standalone WSGI Server (QWebWSGIServer)
 * A cgi and fastcgi WSGI wrapper (taken from flup)
 * A startup function that starts cgi, factgi or standalone according to the
   evironement (qweb_autorun).

QWeb applications are runnable in standalone mode (from commandline), via
FastCGI, Regular CGI or by any python WSGI compliant server.

QWeb doesn't provide any database access but it integrates nicely with ORMs
such as SQLObject, SQLAlchemy or plain DB-API.

Written by Antony Lesuisse (email al AT udev.org)

Homepage: http://antony.lesuisse.org/qweb/trac/

Forum: [http://antony.lesuisse.org/qweb/forum/viewforum.php?id=1 Forum]

== Quick Start (for Linux, MacOS X and cygwin) ==

Make sure you have at least python 2.3 installed and run the following commands:

{{{
$ wget http://antony.lesuisse.org/qweb/files/QWeb-0.7.tar.gz
$ tar zxvf QWeb-0.7.tar.gz
$ cd QWeb-0.7/examples/blog
$ ./blog.py
}}}

And point your browser to http://localhost:8080/

You may also try AjaxTerm which uses qweb request handler.

== Download ==

 * Version 0.7:
   * Source [/qweb/files/QWeb-0.7.tar.gz QWeb-0.7.tar.gz]
   * Python 2.3 Egg [/qweb/files/QWeb-0.7-py2.3.egg QWeb-0.7-py2.3.egg]
   * Python 2.4 Egg [/qweb/files/QWeb-0.7-py2.4.egg QWeb-0.7-py2.4.egg]

 * [/qweb/trac/browser Browse the source repository]

== Documentation ==

 * [/qweb/trac/browser/trunk/README.txt?format=raw Read the included documentation] 
 * QwebTemplating

== Mailin-list ==

 * Forum: [http://antony.lesuisse.org/qweb/forum/viewforum.php?id=1 Forum]
 * No mailing-list exists yet, discussion should happen on: [http://mail.python.org/mailman/listinfo/web-sig web-sig] [http://mail.python.org/pipermail/web-sig/ archives]

QWeb Components:
----------------

QWeb also feature a simple components api, that enables developers to easily
produces reusable components.

Default qweb components:

    - qweb_static:
        A qweb component to serve static content from the filesystem or from
        zipfiles.

    - qweb_dbadmin:
        scaffolding for sqlobject

License
-------
qweb/fcgi.py wich is BSD-like from saddi.com.
Everything else is put in the public domain.


TODO
----
    Announce QWeb to python-announce-list@python.org web-sig@python.org
    qweb_core
        rename request methods into
            request_save_files
            response_404
            response_redirect
            response_download
        request callback_generator, callback_function ?
        wsgi callback_server_local
        xml tags explicitly call render_attributes(t_att)?
        priority form-checkbox over t-value (for t-option)



QWebXml
-------

QWeb Xml templating engine
    
    The templating engine use a very simple syntax, "magic" xml attributes, to
    produce any kind of texutal output (even non-xml).
    
    QWebXml:
        the template engine core implements the basic magic attributes:
    
        t-att t-raw t-esc t-if t-foreach t-set t-call t-trim
    
    

QWebHtml
--------

QWebHtml
    QWebURL:
    QWebField:
    QWebForm:
    QWebHtml:
        an extended template engine, with a few utility class to easily produce
        HTML, handle URLs and process forms, it adds the following magic attributes:
    
        t-href t-action t-form-text t-form-password t-form-textarea t-form-radio
        t-form-checkbox t-form-select t-option t-selected t-checked t-pager
    
    # explication URL:
    # v['tableurl']=QWebUrl({p=afdmin,saar=,orderby=,des=,mlink;meta_active=})
    # t-href="tableurl?desc=1"
    #
    # explication FORM: t-if="form.valid()"
    # Foreach i
    #   email: <input type="text" t-esc-name="i" t-esc-value="form[i].value" t-esc-class="form[i].css"/>
    #   <input type="radio" name="spamtype" t-esc-value="i" t-selected="i==form.f.spamtype.value"/>
    #   <option t-esc-value="cc" t-selected="cc==form.f.country.value"><t t-esc="cname"></option>
    # Simple forms:
    #   <input t-form-text="form.email" t-check="email"/>
    #   <input t-form-password="form.email" t-check="email"/>
    #   <input t-form-radio="form.email" />
    #   <input t-form-checkbox="form.email" />
    #   <textarea t-form-textarea="form.email" t-check="email"/>
    #   <select t-form-select="form.email"/>
    #       <option t-value="1">
    #   <input t-form-radio="form.spamtype" t-value="1"/> Cars
    #   <input t-form-radio="form.spamtype" t-value="2"/> Sprt
    

QWebForm
--------

None

QWebURL
-------

 URL helper
    assert req.PATH_INFO== "/site/admin/page_edit"
    u = QWebURL(root_path="/site/",req_path=req.PATH_INFO)
    s=u.url2_href("user/login",{'a':'1'})
    assert s=="../user/login?a=1"
    
    

qweb_control
------------

 qweb_control(self,jump='main',p=[]):
    A simple function to handle the controler part of your application. It
    dispatch the control to the jump argument, while ensuring that prefix
    function have been called.

    qweb_control replace '/' to '_' and strip '_' from the jump argument.

    name1
    name1_name2
    name1_name2_name3

    

QWebRequest
-----------

QWebRequest a WSGI request handler.

    QWebRequest is a WSGI request handler that feature GET, POST and POST
    multipart methods, handles cookies and headers and provide a dict-like
    SESSION Object (either on the filesystem or in memory).

    It is constructed with the environ and start_response WSGI arguments:
    
      req=qweb.QWebRequest(environ, start_response)
    
    req has the folowing attributes :
    
      req.environ standard WSGI dict (CGI and wsgi ones)
    
    Some CGI vars as attributes from environ for convenience: 
    
      req.SCRIPT_NAME
      req.PATH_INFO
      req.REQUEST_URI
    
    Some computed value (also for convenience)
    
      req.FULL_URL full URL recontructed (http://host/query)
      req.FULL_PATH (URL path before ?querystring)
    
    Dict constructed from querystring and POST datas, PHP-like.
    
      req.GET contains GET vars
      req.POST contains POST vars
      req.REQUEST contains merge of GET and POST
      req.FILES contains uploaded files
      req.GET_LIST req.POST_LIST req.REQUEST_LIST req.FILES_LIST multiple arguments versions
      req.debug() returns an HTML dump of those vars
    
    A dict-like session object.
    
      req.SESSION the session start when the dict is not empty.
    
    Attribute for handling the response
    
      req.response_headers dict-like to set headers
      req.response_cookies a SimpleCookie to set cookies
      req.response_status a string to set the status like '200 OK'
    
      req.write() to write to the buffer
    
    req itselfs is an iterable object with the buffer, it will also also call
    start_response automatically before returning anything via the iterator.
    
    To make it short, it means that you may use
    
      return req
    
    at the end of your request handling to return the reponse to any WSGI
    application server.
    

QWebSession
-----------

None

QWebWSGIServer
--------------

 QWebWSGIServer
        qweb_wsgi_autorun(wsgiapp,ip='127.0.0.1',port=8080,threaded=1)
        A WSGI HTTP server threaded or not and a function to automatically run your
        app according to the environement (either standalone, CGI or FastCGI).

        This feature is called QWeb autorun. If you want to  To use it on your
        application use the following lines at the end of the main application
        python file:

        if __name__ == '__main__':
            qweb.qweb_wsgi_autorun(your_wsgi_app)

        this function will select the approriate running mode according to the
        calling environement (http-server, FastCGI or CGI).
    

qweb_wsgi_autorun
-----------------

None
== Welcome to Rails

Rails is a web-application and persistence framework that includes everything
needed to create database-backed web-applications according to the
Model-View-Control pattern of separation. This pattern splits the view (also
called the presentation) into "dumb" templates that are primarily responsible
for inserting pre-built data in between HTML tags. The model contains the
"smart" domain objects (such as Account, Product, Person, Post) that holds all
the business logic and knows how to persist themselves to a database. The
controller handles the incoming requests (such as Save New Account, Update
Product, Show Post) by manipulating the model and directing data to the view.

In Rails, the model is handled by what's called an object-relational mapping
layer entitled Active Record. This layer allows you to present the data from
database rows as objects and embellish these data objects with business logic
methods. You can read more about Active Record in 
link:files/vendor/rails/activerecord/README.html.

The controller and view are handled by the Action Pack, which handles both
layers by its two parts: Action View and Action Controller. These two layers
are bundled in a single package due to their heavy interdependence. This is
unlike the relationship between the Active Record and Action Pack that is much
more separate. Each of these packages can be used independently outside of
Rails.  You can read more about Action Pack in 
link:files/vendor/rails/actionpack/README.html.


== Getting started

1. Start the web server: <tt>ruby script/server</tt> (run with --help for options)
2. Go to http://localhost:3000/ and get "Welcome aboard: You’re riding the Rails!"
3. Follow the guidelines to start developing your application


== Web servers

Rails uses the built-in web server in Ruby called WEBrick by default, so you don't
have to install or configure anything to play around. 

If you have lighttpd installed, though, it'll be used instead when running script/server.
It's considerably faster than WEBrick and suited for production use, but requires additional
installation and currently only works well on OS X/Unix (Windows users are encouraged
to start with WEBrick). We recommend version 1.4.11 and higher. You can download it from
http://www.lighttpd.net.

If you want something that's halfway between WEBrick and lighttpd, we heartily recommend
Mongrel. It's a Ruby-based web server with a C-component (so it requires compilation) that
also works very well with Windows. See more at http://mongrel.rubyforge.org/.

But of course its also possible to run Rails with the premiere open source web server Apache.
To get decent performance, though, you'll need to install FastCGI. For Apache 1.3, you want
to use mod_fastcgi. For Apache 2.0+, you want to use mod_fcgid.

See http://wiki.rubyonrails.com/rails/pages/FastCGI for more information on FastCGI.

== Example for Apache conf

  <VirtualHost *:80>
    ServerName rails
    DocumentRoot /path/application/public/
    ErrorLog /path/application/log/server.log
  
    <Directory /path/application/public/>
      Options ExecCGI FollowSymLinks
      AllowOverride all
      Allow from all
      Order allow,deny
    </Directory>
  </VirtualHost>

NOTE: Be sure that CGIs can be executed in that directory as well. So ExecCGI
should be on and ".cgi" should respond. All requests from 127.0.0.1 go
through CGI, so no Apache restart is necessary for changes. All other requests
go through FCGI (or mod_ruby), which requires a restart to show changes.


== Debugging Rails

Have "tail -f" commands running on both the server.log, production.log, and
test.log files. Rails will automatically display debugging and runtime
information to these files. Debugging info will also be shown in the browser
on requests from 127.0.0.1.


== Breakpoints

Breakpoint support is available through the script/breakpointer client. This
means that you can break out of execution at any point in the code, investigate
and change the model, AND then resume execution! Example:

  class WeblogController < ActionController::Base
    def index
      @posts = Post.find_all
      breakpoint "Breaking out from the list"
    end
  end
  
So the controller will accept the action, run the first line, then present you
with a IRB prompt in the breakpointer window. Here you can do things like:

Executing breakpoint "Breaking out from the list" at .../webrick_server.rb:16 in 'breakpoint'

  >> @posts.inspect
  => "[#<Post:0x14a6be8 @attributes={\"title\"=>nil, \"body\"=>nil, \"id\"=>\"1\"}>, 
       #<Post:0x14a6620 @attributes={\"title\"=>\"Rails you know!\", \"body\"=>\"Only ten..\", \"id\"=>\"2\"}>]"
  >> @posts.first.title = "hello from a breakpoint"
  => "hello from a breakpoint"

...and even better is that you can examine how your runtime objects actually work:

  >> f = @posts.first 
  => #<Post:0x13630c4 @attributes={"title"=>nil, "body"=>nil, "id"=>"1"}>
  >> f.
  Display all 152 possibilities? (y or n)

Finally, when you're ready to resume execution, you press CTRL-D


== Console

You can interact with the domain model by starting the console through script/console. 
Here you'll have all parts of the application configured, just like it is when the
application is running. You can inspect domain models, change values, and save to the
database. Starting the script without arguments will launch it in the development environment.
Passing an argument will specify a different environment, like <tt>script/console production</tt>.

To reload your controllers and models after launching the console run <tt>reload!</tt>



== Description of contents

app
  Holds all the code that's specific to this particular application.

app/controllers
  Holds controllers that should be named like weblog_controller.rb for
  automated URL mapping. All controllers should descend from
  ActionController::Base.

app/models
  Holds models that should be named like post.rb.
  Most models will descend from ActiveRecord::Base.
  
app/views
  Holds the template files for the view that should be named like
  weblog/index.rhtml for the WeblogController#index action. All views use eRuby
  syntax. This directory can also be used to keep stylesheets, images, and so on
  that can be symlinked to public.
  
app/helpers
  Holds view helpers that should be named like weblog_helper.rb.

app/apis
  Holds API classes for web services.

config
  Configuration files for the Rails environment, the routing map, the database, and other dependencies.

components
  Self-contained mini-applications that can bundle together controllers, models, and views.

db
  Contains the database schema in schema.rb.  db/migrate contains all
  the sequence of Migrations for your schema.

lib
  Application specific libraries. Basically, any kind of custom code that doesn't
  belong under controllers, models, or helpers. This directory is in the load path.
    
public
  The directory available for the web server. Contains subdirectories for images, stylesheets,
  and javascripts. Also contains the dispatchers and the default HTML files.

script
  Helper scripts for automation and generation.

test
  Unit and functional tests along with fixtures.

vendor
  External libraries that the application depends on. Also includes the plugins subdirectory.
  This directory is in the load path.

What is QWeb ?
--------------
QWeb is web framework (mainly an XML templating system) implemented in various laguages.

The core component of qweb is its cool XML templating engine. Some versions
only implements that. While others (python/php) provide additional components.

QWeb was cool around 2006 when it was developped. Now we have many web frameworks.

But i'm still conviced that the xml template engine is better than enything
else on the market in 2011.


What is Ajaxterm ?
------------------
Ajaxterm is an ajax terminal it was made as a showcase for the python version
of QWeb. It only uses the QWeb request handler, not thei xml template engine.

I plan to separate it from qweb and update it to use WebOb instead of qweb.Request.


What is pyphp ? 
---------------
pyphp is a bridge that allow to use python on a php host, and call phpfunction
from python. I wanted to use QWeb python on a php host.


Versions of QWeb
----------------
And the components implemented:

 * qweb_javascript: XML templating
 * qweb_python: XML templating, HTML forms, Controller, WSGI/cgi/fastcgi/builtin-web-server Request handler, Sessions
 * qweb_ruby: XML templating, HTML forms
 * qweb_csharp: XML templating, Controller
 * qweb_java: XML templating, Controller
 * qweb_php: XML templating, HTML forms, Controller, Misc
 
Feedback
--------
Antony Lesuisse: lesuisse AT gmail.com


