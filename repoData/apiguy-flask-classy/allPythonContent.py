__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Flask Classy documentation build configuration file, created by
# sphinx-quickstart on Tue Oct 30 13:14:07 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Flask Classy'
copyright = u'2013, Freedom Dumlao'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.6.8'
# The full version, including alpha/beta/rc tags.
release = '0.6.8'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'FlaskClassydoc'
sys.path.append(os.path.abspath('_themes'))
html_theme_path = ['_themes']
html_theme = 'flask'

# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'FlaskClassy.tex', u'Flask Classy Documentation',
   u'Freedom Dumlao', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'flaskclassy', u'Flask Classy Documentation',
     [u'Freedom Dumlao'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'FlaskClassy', u'Flask Classy Documentation',
   u'Freedom Dumlao', 'FlaskClassy', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = flask_theme_support
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        #Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",      # class: 'w'
        Error:                     "#a40000 border:#ef2929", # class: 'err'
        Other:                     "#000000",                # class 'x'

        Comment:                   "italic #8f5902", # class: 'c'
        Comment.Preproc:           "noitalic",       # class: 'cp'

        Keyword:                   "bold #004461",   # class: 'k'
        Keyword.Constant:          "bold #004461",   # class: 'kc'
        Keyword.Declaration:       "bold #004461",   # class: 'kd'
        Keyword.Namespace:         "bold #004461",   # class: 'kn'
        Keyword.Pseudo:            "bold #004461",   # class: 'kp'
        Keyword.Reserved:          "bold #004461",   # class: 'kr'
        Keyword.Type:              "bold #004461",   # class: 'kt'

        Operator:                  "#582800",   # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",        # class: 'n'
        Name.Attribute:            "#c4a000",        # class: 'na' - to be revised
        Name.Builtin:              "#004461",        # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",        # class: 'bp'
        Name.Class:                "#000000",        # class: 'nc' - to be revised
        Name.Constant:             "#000000",        # class: 'no' - to be revised
        Name.Decorator:            "#888",           # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",        # class: 'ni'
        Name.Exception:            "bold #cc0000",   # class: 'ne'
        Name.Function:             "#000000",        # class: 'nf'
        Name.Property:             "#000000",        # class: 'py'
        Name.Label:                "#f57900",        # class: 'nl'
        Name.Namespace:            "#000000",        # class: 'nn' - to be revised
        Name.Other:                "#000000",        # class: 'nx'
        Name.Tag:                  "bold #004461",   # class: 'nt' - like a keyword
        Name.Variable:             "#000000",        # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",        # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",        # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",        # class: 'vi' - to be revised

        Number:                    "#990000",        # class: 'm'

        Literal:                   "#000000",        # class: 'l'
        Literal.Date:              "#000000",        # class: 'ld'

        String:                    "#4e9a06",        # class: 's'
        String.Backtick:           "#4e9a06",        # class: 'sb'
        String.Char:               "#4e9a06",        # class: 'sc'
        String.Doc:                "italic #8f5902", # class: 'sd' - like a comment
        String.Double:             "#4e9a06",        # class: 's2'
        String.Escape:             "#4e9a06",        # class: 'se'
        String.Heredoc:            "#4e9a06",        # class: 'sh'
        String.Interpol:           "#4e9a06",        # class: 'si'
        String.Other:              "#4e9a06",        # class: 'sx'
        String.Regex:              "#4e9a06",        # class: 'sr'
        String.Single:             "#4e9a06",        # class: 's1'
        String.Symbol:             "#4e9a06",        # class: 'ss'

        Generic:                   "#000000",        # class: 'g'
        Generic.Deleted:           "#a40000",        # class: 'gd'
        Generic.Emph:              "italic #000000", # class: 'ge'
        Generic.Error:             "#ef2929",        # class: 'gr'
        Generic.Heading:           "bold #000080",   # class: 'gh'
        Generic.Inserted:          "#00A000",        # class: 'gi'
        Generic.Output:            "#888",           # class: 'go'
        Generic.Prompt:            "#745334",        # class: 'gp'
        Generic.Strong:            "bold #000000",   # class: 'gs'
        Generic.Subheading:        "bold #800080",   # class: 'gu'
        Generic.Traceback:         "bold #a40000",   # class: 'gt'
    }

########NEW FILE########
__FILENAME__ = flask_classy
"""
    Flask-Classy
    ------------

    Class based views for the Flask microframework.

    :copyright: (c) 2013 by Freedom Dumlao.
    :license: BSD, see LICENSE for more details.
"""

__version__ = "0.6.8"

import sys
import functools
import inspect
from werkzeug.routing import parse_rule
from flask import request, Response, make_response
import re

_py2 = sys.version_info[0] == 2


def route(rule, **options):
    """A decorator that is used to define custom routes for methods in
    FlaskView subclasses. The format is exactly the same as Flask's
    `@app.route` decorator.
    """

    def decorator(f):
        # Put the rule cache on the method itself instead of globally
        if not hasattr(f, '_rule_cache') or f._rule_cache is None:
            f._rule_cache = {f.__name__: [(rule, options)]}
        elif not f.__name__ in f._rule_cache:
            f._rule_cache[f.__name__] = [(rule, options)]
        else:
            f._rule_cache[f.__name__].append((rule, options))

        return f

    return decorator


class FlaskView(object):
    """Base view for any class based views implemented with Flask-Classy. Will
    automatically configure routes when registered with a Flask app instance.
    """

    decorators = []
    route_base = None
    route_prefix = None
    trailing_slash = True

    @classmethod
    def register(cls, app, route_base=None, subdomain=None, route_prefix=None,
                 trailing_slash=None):
        """Registers a FlaskView class for use with a specific instance of a
        Flask app. Any methods not prefixes with an underscore are candidates
        to be routed and will have routes registered when this method is
        called.

        :param app: an instance of a Flask application

        :param route_base: The base path to use for all routes registered for
                           this class. Overrides the route_base attribute if
                           it has been set.

        :param subdomain:  A subdomain that this registration should use when
                           configuring routes.

        :param route_prefix: A prefix to be applied to all routes registered
                             for this class. Precedes route_base. Overrides
                             the class' route_prefix if it has been set.
        """

        if cls is FlaskView:
            raise TypeError("cls must be a subclass of FlaskView, not FlaskView itself")

        if route_base:
            cls.orig_route_base = cls.route_base
            cls.route_base = route_base

        if route_prefix:
            cls.orig_route_prefix = cls.route_prefix
            cls.route_prefix = route_prefix

        if not subdomain:
            if hasattr(app, "subdomain") and app.subdomain is not None:
                subdomain = app.subdomain
            elif hasattr(cls, "subdomain"):
                subdomain = cls.subdomain

        if trailing_slash is not None:
            cls.orig_trailing_slash = cls.trailing_slash
            cls.trailing_slash = trailing_slash


        members = get_interesting_members(FlaskView, cls)
        special_methods = ["get", "put", "patch", "post", "delete", "index"]

        for name, value in members:
            proxy = cls.make_proxy_method(name)
            route_name = cls.build_route_name(name)
            try:
                if hasattr(value, "_rule_cache") and name in value._rule_cache:
                    for idx, cached_rule in enumerate(value._rule_cache[name]):
                        rule, options = cached_rule
                        rule = cls.build_rule(rule)
                        sub, ep, options = cls.parse_options(options)

                        if not subdomain and sub:
                            subdomain = sub

                        if ep:
                            endpoint = ep
                        elif len(value._rule_cache[name]) == 1:
                            endpoint = route_name
                        else:
                            endpoint = "%s_%d" % (route_name, idx,)

                        app.add_url_rule(rule, endpoint, proxy, subdomain=subdomain, **options)

                elif name in special_methods:
                    if name in ["get", "index"]:
                        methods = ["GET"]
                    else:
                        methods = [name.upper()]

                    rule = cls.build_rule("/", value)
                    if not cls.trailing_slash:
                        rule = rule.rstrip("/")
                    app.add_url_rule(rule, route_name, proxy, methods=methods, subdomain=subdomain)

                else:
                    route_str = '/%s/' % name
                    if not cls.trailing_slash:
                        route_str = route_str.rstrip('/')
                    rule = cls.build_rule(route_str, value)
                    app.add_url_rule(rule, route_name, proxy, subdomain=subdomain)
            except DecoratorCompatibilityError:
                raise DecoratorCompatibilityError("Incompatible decorator detected on %s in class %s" % (name, cls.__name__))

        if hasattr(cls, "orig_route_base"):
            cls.route_base = cls.orig_route_base
            del cls.orig_route_base

        if hasattr(cls, "orig_route_prefix"):
            cls.route_prefix = cls.orig_route_prefix
            del cls.orig_route_prefix

        if hasattr(cls, "orig_trailing_slash"):
            cls.trailing_slash = cls.orig_trailing_slash
            del cls.orig_trailing_slash

    @classmethod
    def parse_options(cls, options):
        """Extracts subdomain and endpoint values from the options dict and returns
           them along with a new dict without those values.
        """
        options = options.copy()
        subdomain = options.pop('subdomain', None)
        endpoint = options.pop('endpoint', None)
        return subdomain, endpoint, options,


    @classmethod
    def make_proxy_method(cls, name):
        """Creates a proxy function that can be used by Flasks routing. The
        proxy instantiates the FlaskView subclass and calls the appropriate
        method.

        :param name: the name of the method to create a proxy for
        """

        i = cls()
        view = getattr(i, name)

        if cls.decorators:
            for decorator in cls.decorators:
                view = decorator(view)

        @functools.wraps(view)
        def proxy(**forgettable_view_args):
            # Always use the global request object's view_args, because they
            # can be modified by intervening function before an endpoint or
            # wrapper gets called. This matches Flask's behavior.
            del forgettable_view_args

            if hasattr(i, "before_request"):
                response = i.before_request(name, **request.view_args)
                if response is not None:
                    return response

            before_view_name = "before_" + name
            if hasattr(i, before_view_name):
                before_view = getattr(i, before_view_name)
                response = before_view(**request.view_args)
                if response is not None:
                    return response

            response = view(**request.view_args)
            if not isinstance(response, Response):
                response = make_response(response)

            after_view_name = "after_" + name
            if hasattr(i, after_view_name):
                after_view = getattr(i, after_view_name)
                response = after_view(response)

            if hasattr(i, "after_request"):
                response = i.after_request(name, response)

            return response

        return proxy

    @classmethod
    def build_rule(cls, rule, method=None):
        """Creates a routing rule based on either the class name (minus the
        'View' suffix) or the defined `route_base` attribute of the class

        :param rule: the path portion that should be appended to the
                     route base

        :param method: if a method's arguments should be considered when
                       constructing the rule, provide a reference to the
                       method here. arguments named "self" will be ignored
        """

        rule_parts = []

        if cls.route_prefix:
            rule_parts.append(cls.route_prefix)

        route_base = cls.get_route_base()
        if route_base:
            rule_parts.append(route_base)

        rule_parts.append(rule)
        ignored_rule_args = ['self']
        if hasattr(cls, 'base_args'):
            ignored_rule_args += cls.base_args

        if method:
            args = get_true_argspec(method)[0]
            for arg in args:
                if arg not in ignored_rule_args:
                    rule_parts.append("<%s>" % arg)

        result = "/%s" % "/".join(rule_parts)
        return re.sub(r'(/)\1+', r'\1', result)


    @classmethod
    def get_route_base(cls):
        """Returns the route base to use for the current class."""

        if cls.route_base is not None:
            route_base = cls.route_base
            base_rule = parse_rule(route_base)
            cls.base_args = [r[2] for r in base_rule]
        else:
            if cls.__name__.endswith("View"):
                route_base = cls.__name__[:-4].lower()
            else:
                route_base = cls.__name__.lower()

        return route_base.strip("/")


    @classmethod
    def build_route_name(cls, method_name):
        """Creates a unique route name based on the combination of the class
        name with the method name.

        :param method_name: the method name to use when building a route name
        """
        return cls.__name__ + ":%s" % method_name


def get_interesting_members(base_class, cls):
    """Returns a list of methods that can be routed to"""

    base_members = dir(base_class)
    predicate = inspect.ismethod if _py2 else inspect.isfunction
    all_members = inspect.getmembers(cls, predicate=predicate)
    return [member for member in all_members
            if not member[0] in base_members
            and ((hasattr(member[1], "__self__") and not member[1].__self__ in inspect.getmro(cls)) if _py2 else True)
            and not member[0].startswith("_")
            and not member[0].startswith("before_")
            and not member[0].startswith("after_")]


def get_true_argspec(method):
    """Drills through layers of decorators attempting to locate the actual argspec for the method."""

    argspec = inspect.getargspec(method)
    args = argspec[0]
    if args and args[0] == 'self':
        return argspec
    if hasattr(method, '__func__'):
        method = method.__func__
    if not hasattr(method, '__closure__') or method.__closure__ is None:
        raise DecoratorCompatibilityError

    closure = method.__closure__
    for cell in closure:
        inner_method = cell.cell_contents
        if inner_method is method:
            continue
        if not inspect.isfunction(inner_method) \
            and not inspect.ismethod(inner_method):
            continue
        true_argspec = get_true_argspec(inner_method)
        if true_argspec:
            return true_argspec


class DecoratorCompatibilityError(Exception):
    pass







########NEW FILE########
__FILENAME__ = test_blueprints
from flask import Flask, Blueprint
from .view_classes import BasicView, IndexView
from nose.tools import *

app = Flask("blueprints")
bp = Blueprint("bptest", "bptest")
BasicView.register(bp)
IndexView.register(bp)
app.register_blueprint(bp)

client = app.test_client()

def test_bp_index():
    resp = client.get("/basic/")
    eq_(b"Index", resp.data)

def test_bp_get():
    resp = client.get("/basic/1234")
    eq_(b"Get 1234", resp.data)

def test_bp_put():
    resp = client.put("/basic/1234")
    eq_(b"Put 1234", resp.data)

def test_bp_patch():
    resp = client.patch("/basic/1234")
    eq_(b"Patch 1234", resp.data)

def test_bp_post():
    resp = client.post("/basic/")
    eq_(b"Post", resp.data)

def test_bp_delete():
    resp = client.delete("/basic/1234")
    eq_(b"Delete 1234", resp.data)

def test_bp_custom_method():
    resp = client.get("/basic/custom_method/")
    eq_(b"Custom Method", resp.data)

def test_bp_custom_method_with_params():
    resp = client.get("/basic/custom_method_with_params/1234/abcd")
    eq_(b"Custom Method 1234 abcd", resp.data)

def test_bp_routed_method():
    resp = client.get("/basic/routed/")
    eq_(b"Routed Method", resp.data)

def test_bp_multi_routed_method():
    resp = client.get("/basic/route1/")
    eq_(b"Multi Routed Method", resp.data)

    resp = client.get("/basic/route2/")
    eq_(b"Multi Routed Method", resp.data)

def test_bp_no_slash():
    resp = client.get("/basic/noslash")
    eq_(b"No Slash Method", resp.data)

def test_bp_index_view_index():
    resp = client.get("/")
    eq_(b"Index", resp.data)

def test_bp_custom_http_method():
    resp = client.post("/basic/route3/")
    eq_(b"Custom HTTP Method", resp.data)

def test_bp_url_prefix():
    foo = Blueprint('foo', __name__)
    BasicView.register(foo, route_base="/")
    app.register_blueprint(foo, url_prefix='/foo')

    resp = client.get('/foo/')
    eq_(b"Index", resp.data)





########NEW FILE########
__FILENAME__ = test_bp_subdomains
from flask import Flask, Blueprint
from .view_classes import BasicView, SubdomainAttributeView, SubdomainRouteView
from nose.tools import *

app = Flask("blueprints")
app.config["SERVER_NAME"] = "test.test"

bp = Blueprint("bptest1", "bptest2")
SubdomainAttributeView.register(bp)
SubdomainRouteView.register(bp)
BasicView.register(bp, subdomain="sub3")

bp2 = Blueprint("bptest2", "bptest2", subdomain="sub4")
BasicView.register(bp2)

app.register_blueprint(bp)
app.register_blueprint(bp2)

client = app.test_client()

def test_bp_attr_subdomain():
    resp = client.get("/subdomainattribute/", base_url="http://sub1.test.test")
    eq_(b"Index", resp.data)

def test_bp_route_subdomain():
    resp = client.get("/subdomainroute/", base_url="http://sub2.test.test")
    eq_(b"Index", resp.data)

def test_bp_register_subdomain():
    resp = client.get("/basic/", base_url="http://sub3.test.test")
    eq_(b"Index", resp.data)

def test_bp_bp_subdomain():
    resp = client.get("/basic/", base_url="http://sub4.test.test")
    eq_(b"Index", resp.data)




########NEW FILE########
__FILENAME__ = test_common
from flask import Flask, url_for
from .view_classes import BasicView, IndexView
from nose.tools import *

app = Flask("common")
BasicView.register(app)
IndexView.register(app)

client = app.test_client()

def test_index():
    resp = client.get("/basic/")
    eq_(b"Index", resp.data)

def test_get():
    resp = client.get("/basic/1234")
    eq_(b"Get 1234", resp.data)

def test_put():
    resp = client.put("/basic/1234")
    eq_(b"Put 1234", resp.data)

def test_patch():
    resp = client.patch("/basic/1234")
    eq_(b"Patch 1234", resp.data)

def test_post():
    resp = client.post("/basic/")
    eq_(b"Post", resp.data)

def test_delete():
    resp = client.delete("/basic/1234")
    eq_(b"Delete 1234", resp.data)

def test_custom_method():
    resp = client.get("/basic/custom_method/")
    eq_(b"Custom Method", resp.data)

def test_custom_method_with_params():
    resp = client.get("/basic/custom_method_with_params/1234/abcd")
    eq_(b"Custom Method 1234 abcd", resp.data)

def test_routed_method():
    resp = client.get("/basic/routed/")
    eq_(b"Routed Method", resp.data)

def test_multi_routed_method():
    resp = client.get("/basic/route1/")
    eq_(b"Multi Routed Method", resp.data)

    resp = client.get("/basic/route2/")
    eq_(b"Multi Routed Method", resp.data)

def test_no_slash():
    resp = client.get("/basic/noslash")
    eq_(b"No Slash Method", resp.data)

def test_index_view_index():
    resp = client.get("/")
    eq_(b"Index", resp.data)

def test_custom_http_method():
    resp = client.post("/basic/route3/")
    eq_(b"Custom HTTP Method", resp.data)

def test_docstrings():
    proxy_func = app.view_functions["BasicView:index"]
    eq_(proxy_func.__doc__, BasicView.index.__doc__)










########NEW FILE########
__FILENAME__ = test_decorators
from flask import Flask, url_for
from .view_classes import DecoratedView
from nose.tools import *

app = Flask("decorated")
DecoratedView.register(app)
client = app.test_client()


def test_func_decorator_index():
    resp = client.get('/decorated/')
    eq_(b"Index", resp.data)


def test_func_decorator_get():
    resp = client.get('/decorated/1234')
    eq_(b"Get 1234", resp.data)


def test_recursive_decorator_post():
    resp = client.post('/decorated/')
    eq_(b"Post", resp.data)


def test_more_recursive_decorator_get():
    resp = client.get('/decorated/get_some/')
    eq_(b"Get Some", resp.data)


def test_multiple_recursive_decorators_get():
    resp = client.get('/decorated/get_this/')
    eq_(b"Get This", resp.data)


def test_routes_with_recursive_decorators():
    resp = client.get('/decorated/mixitup/')
    eq_(b"Mix It Up", resp.data)


def test_recursive_with_parameter():
    resp = client.get('/decorated/someval/1234')
    eq_(b"Someval 1234", resp.data)


def test_recursive_with_route_with_parameter():
    resp = client.get('/decorated/anotherval/1234')
    eq_(b"Anotherval 1234", resp.data)


def test_params_decorator():
    resp = client.get('/decorated/params_decorator_method/')
    eq_(b"Params Decorator", resp.data)

def test_params_decorator_delete():
    resp = client.delete('/decorated/1234')
    eq_(b"Params Decorator Delete 1234", resp.data)




########NEW FILE########
__FILENAME__ = test_endpoints
from flask import Flask, url_for
from .view_classes import BasicView, IndexView, RouteBaseView, VarBaseView
from nose.tools import *

app = Flask("common")
BasicView.register(app)
IndexView.register(app)
RouteBaseView.register(app)
VarBaseView.register(app)

client = app.test_client()

def test_index_url():
    with app.test_request_context():
        url = url_for("IndexView:index")
        eq_("/", url)

def test_basic_index_url():
    with app.test_request_context():
        url = url_for("BasicView:index")
        eq_("/basic/", url)

def test_custom_endpoint_url():
    with app.test_request_context():
        url = url_for("basic_endpoint")
        eq_("/basic/endpoint/", url)

def test_custom_route_base():
    with app.test_request_context():
        url = url_for('RouteBaseView:index')
        eq_("/base-routed/", url)

def test_variable_route_popped_base():
    with app.test_request_context():
        url = url_for('VarBaseView:index', route='bar')
        eq_('/var-base-route/bar/', url)

def test_variable_route_base():
    with app.test_request_context():
        url = url_for('VarBaseView:with_base_arg', route='bar')
        eq_('/var-base-route/bar/with_base_arg/', url)


def test_variable_route_base_with_local_route_var():
    client = app.test_client()
    resp = client.get('/var-base-route/bar/local/baz')
    eq_(resp.data, b"bar baz")


########NEW FILE########
__FILENAME__ = test_inheritance
from flask import Flask
from .view_classes import InheritanceView, DecoratedInheritanceView
from nose.tools import *

app = Flask('inheritance')
InheritanceView.register(app)
DecoratedInheritanceView.register(app)

client = app.test_client()


def test_index():
    resp = client.get('/inheritance/')
    eq_(b"Index", resp.data)


def test_override():
    resp = client.get("/inheritance/1234")
    eq_(b"Inheritance Get 1234", resp.data)


def test_inherited():
    resp = client.post('/inheritance/')
    eq_(b"Post", resp.data)


def test_with_route():
    resp = client.get("/inheritance/with_route")
    eq_(b"Inheritance with route", resp.data)


def test_override_with_route():
    resp = client.delete("/inheritance/1234/delete")
    eq_(b"Inheritance Delete 1234", resp.data)


def test_inherited_base_route():
    resp = client.get("/inheritance/routed/")
    eq_(b"Routed Method", resp.data)


def test_decorated_inherited_mixitup():
    resp = client.get("/decoratedinheritance/mixitup/")
    eq_(b"Mix It Up", resp.data)


def test_decorated_inheritance_get():
    resp = client.get("/decoratedinheritance/1234")
    eq_(b"Decorated Inheritance Get 1234", resp.data)

########NEW FILE########
__FILENAME__ = test_method_detection
from flask_classy import get_interesting_members, FlaskView
from .view_classes import VariedMethodsView, SubVariedMethodsView
from nose.tools import *

def test_special_method_detected():
    members = [m[1] for m in get_interesting_members(FlaskView, VariedMethodsView)]
    assert VariedMethodsView.index in members

def test_routed_method_detected():
    members = [m[1] for m in get_interesting_members(FlaskView, VariedMethodsView)]
    assert VariedMethodsView.routed_method in members

def test_classmethod_ignored():
    members = [m[1] for m in get_interesting_members(FlaskView, VariedMethodsView)]
    assert VariedMethodsView.class_method not in members

def test_subclass_classmethod_ignored():
    members = [m[1] for m in get_interesting_members(FlaskView, SubVariedMethodsView)]
    assert SubVariedMethodsView.class_method not in members
    assert VariedMethodsView.class_method not in members

########NEW FILE########
__FILENAME__ = test_route_base
from flask import Flask
from .view_classes import BasicView, RouteBaseView
from nose.tools import *

app = Flask('route_base')
RouteBaseView.register(app, route_base="/rb_test2/")


def test_route_base_override():
    client = app.test_client()
    resp = client.get('/rb_test2/')
    eq_(b"Index", resp.data)

########NEW FILE########
__FILENAME__ = test_route_prefix
from flask import Flask
from .view_classes import BasicView, RoutePrefixView, RouteBaseView
from nose.tools import *

app = Flask('route_base')

RoutePrefixView.register(app)
RouteBaseView.register(app, route_prefix='/prefix/')
BasicView.register(app, route_prefix='/prefix/')


def test_route_prefix():
    client = app.test_client()
    resp = client.get('/my_prefix/routeprefix/')
    eq_(b"Index", resp.data)


def test_route_prefix_override():
    client = app.test_client()
    resp = client.get('/prefix/basic/')
    eq_(b"Index", resp.data)


def test_route_prefix_with_route_base():
    client = app.test_client()
    resp = client.get('/prefix/base-routed/')
    eq_(b"Index", resp.data)


########NEW FILE########
__FILENAME__ = test_subdomains
from flask import Flask, url_for
from .view_classes import BasicView, IndexView
from nose.tools import *

app = Flask("common")
app.config["SERVER_NAME"] = "test.test"
BasicView.register(app, subdomain="basic")

client = app.test_client()

def test_index_subdomain():
    resp = client.get("/basic/", base_url="http://basic.test.test")
    eq_(b"Index", resp.data)

def test_get():
    resp = client.get("/basic/1234", base_url="http://basic.test.test")
    eq_(b"Get 1234", resp.data)

def test_put():
    resp = client.put("/basic/1234", base_url="http://basic.test.test")
    eq_(b"Put 1234", resp.data)

def test_patch():
    resp = client.patch("/basic/1234", base_url="http://basic.test.test")
    eq_(b"Patch 1234", resp.data)

def test_post():
    resp = client.post("/basic/", base_url="http://basic.test.test")
    eq_(b"Post", resp.data)

def test_delete():
    resp = client.delete("/basic/1234", base_url="http://basic.test.test")
    eq_(b"Delete 1234", resp.data)

def test_custom_method():
    resp = client.get("/basic/custom_method/", base_url="http://basic.test.test")
    eq_(b"Custom Method", resp.data)

def test_custom_method_with_params():
    resp = client.get("/basic/custom_method_with_params/1234/abcd", base_url="http://basic.test.test")
    eq_(b"Custom Method 1234 abcd", resp.data)

def test_routed_method():
    resp = client.get("/basic/routed/", base_url="http://basic.test.test")
    eq_(b"Routed Method", resp.data)

def test_multi_routed_method():
    resp = client.get("/basic/route1/", base_url="http://basic.test.test")
    eq_(b"Multi Routed Method", resp.data)

    resp = client.get("/basic/route2/", base_url="http://basic.test.test")
    eq_(b"Multi Routed Method", resp.data)

def test_no_slash():
    resp = client.get("/basic/noslash", base_url="http://basic.test.test")
    eq_(b"No Slash Method", resp.data)
########NEW FILE########
__FILENAME__ = test_trailing_slash
from flask import Flask
from .view_classes import BasicView, TrailingSlashView, InheritedTrailingSlashView, OverrideInheritedTrailingSlashView
from nose.tools import *

app = Flask('trailing_slash')
BasicView.register(app, trailing_slash=False)
TrailingSlashView.register(app)
InheritedTrailingSlashView.register(app)
OverrideInheritedTrailingSlashView.register(app)

client = app.test_client()

def test_index():
    resp = client.get("/basic")
    eq_(b"Index", resp.data)

def test_get():
    resp = client.get("/basic/1234")
    eq_(b"Get 1234", resp.data)

def test_put():
    resp = client.put("/basic/1234")
    eq_(b"Put 1234", resp.data)

def test_patch():
    resp = client.patch("/basic/1234")
    eq_(b"Patch 1234", resp.data)

def test_post():
    resp = client.post("/basic")
    eq_(b"Post", resp.data)

def test_delete():
    resp = client.delete("/basic/1234")
    eq_(b"Delete 1234", resp.data)

def test_custom_method():
    resp = client.get("/basic/custom_method")
    eq_(b"Custom Method", resp.data)

def test_custom_method_with_params():
    resp = client.get("/basic/custom_method_with_params/1234/abcd")
    eq_(b"Custom Method 1234 abcd", resp.data)

def test_routed_method():
    resp = client.get("/basic/routed/")
    eq_(b"Routed Method", resp.data)


# TrailingSlashView

def test_trailing_index():
    resp = client.get("/trailing")
    eq_(b"Index", resp.data)
    
def test_trailing_get():
    resp = client.get("/trailing/1234")
    eq_(b"Get 1234", resp.data)

def test_trailing_put():
    resp = client.put("/trailing/1234")
    eq_(b"Put 1234", resp.data)

def test_trailing_patch():
    resp = client.patch("/trailing/1234")
    eq_(b"Patch 1234", resp.data)

def test_trailing_post():
    resp = client.post("/trailing")
    eq_(b"Post", resp.data)

def test_trailing_delete():
    resp = client.delete("/trailing/1234")
    eq_(b"Delete 1234", resp.data)

def test_trailing_custom_method():
    resp = client.get("/trailing/custom_method")
    eq_(b"Custom Method", resp.data)

def test_trailing_custom_method_with_params():
    resp = client.get("/trailing/custom_method_with_params/1234/abcd")
    eq_(b"Custom Method 1234 abcd", resp.data)

def test_trailing_routed_method():
    resp = client.get("/trailing/routed/")
    eq_(b"Routed Method", resp.data)

def test_trailing_routed_method2():
    resp = client.get("/trailing/routed2")
    eq_(b"Routed Method 2", resp.data)


# InheritedTrailingSlashView

def test_inherited_trailing_slash():
    resp = client.get("/inherited/trailing")
    eq_(b"Index", resp.data)


# OverrideInheritedTrailingSlashView

def test_inherited_trailing_slash_override():
    resp = client.get("/override/trailing/")
    eq_(b"Index", resp.data)


########NEW FILE########
__FILENAME__ = test_view_wrappers
from flask import Flask
from .view_classes import (BeforeRequestView, BeforeViewView, AfterRequestView, AfterViewView, DecoratedView,
                           BeforeRequestReturnsView, BeforeViewReturnsView)
from nose.tools import *

app = Flask("wrappers")
BeforeRequestView.register(app)
BeforeRequestReturnsView.register(app)
BeforeViewView.register(app)
BeforeViewReturnsView.register(app)
AfterViewView.register(app)
AfterRequestView.register(app)
DecoratedView.register(app)

client = app.test_client()

def test_before_request():
    resp = client.get("/beforerequest/")
    eq_(b"Before Request", resp.data)

def test_before_view():
    resp = client.get("/beforeview/")
    eq_(b"Before View", resp.data)

def test_after_view():
    resp = client.get("/afterview/")
    eq_(b"After View", resp.data)

def test_after_request():
    resp = client.get("/afterrequest/")
    eq_(b"After Request", resp.data)

def test_decorated_view():
    resp = client.get("/decorated/")
    eq_(b"Index", resp.data)

    resp = client.get("/decorated/1234")
    eq_(b"Get 1234", resp.data)


def test_before_request_returns():
    resp = client.get("/beforerequestreturns/")
    eq_(b"BEFORE", resp.data)

def test_before_view_returns():
    resp = client.get("/beforeviewreturns/")
    eq_(b"BEFORE", resp.data)

########NEW FILE########
__FILENAME__ = view_classes
from flask_classy import FlaskView, route
from functools import wraps

VALUE1 = "value1"

def get_value():
    return VALUE1

class BasicView(FlaskView):

    def index(self):
        """A docstring for testing that docstrings are set"""
        return "Index"

    def get(self, obj_id):
        return "Get " + obj_id

    def put(self, id):
        return "Put " + id

    def patch(self, id):
        return "Patch " + id

    def post(self):
        return "Post"

    def delete(self, id):
        return "Delete " + id

    def custom_method(self):
        return "Custom Method"

    def custom_method_with_params(self, p_one, p_two):
        return "Custom Method %s %s" % (p_one, p_two,)

    @route("/routed/")
    def routed_method(self):
        return "Routed Method"

    @route("/route1/")
    @route("/route2/")
    def multi_routed_method(self):
        return "Multi Routed Method"

    @route("/noslash")
    def no_slash_method(self):
        return "No Slash Method"

    @route("/endpoint/", endpoint="basic_endpoint")
    def custom_endpoint(self):
        return "Custom Endpoint"

    @route("/route3/", methods=['POST'])
    def custom_http_method(self):
        return "Custom HTTP Method"

class SubdomainAttributeView(FlaskView):
    subdomain = "sub1"

    def index(self):
        return "Index"

class SubdomainRouteView(FlaskView):

    @route("/", subdomain="sub2")
    def index(self):
        return "Index"

class IndexView(FlaskView):
    route_base = "/"

    def index(self):
        return "Index"

class RouteBaseView(FlaskView):
    route_base = "/base-routed/"

    def index(self):
        return "Index"

class RoutePrefixView(FlaskView):
    route_prefix = "/my_prefix/"

    def index(self):
        return "Index"

class VarBaseView(FlaskView):
    route_base = "/var-base-route/<route>"

    def before_index(self):
        from flask import request
        request.view_args.pop('route')

    def index(self):
        return "Custom routed."

    def with_base_arg(self, route):
        return "Base route arg: " + route

    @route('/local/<route_local>', methods=['GET'])
    def with_route_arg(self, route, route_local):
        return "%s %s" % (route, route_local)

class BeforeRequestView(FlaskView):

    def before_request(self, name):
        self.response = "Before Request"

    def index(self):
        return self.response

class BeforeViewView(FlaskView):

    def before_index(self):
        self.response = "Before View"

    def index(self):
        return self.response

class BeforeRequestReturnsView(FlaskView):

    def before_request(self, name):
        return "BEFORE"

    def index(self):
        return "Should never see this"

class BeforeViewReturnsView(FlaskView):

    def before_index(self):
        return "BEFORE"

    def index(self):
        return "Should never see this"

class AfterViewView(FlaskView):

    def after_index(self, response):
        return "After View"

    def index(self):
        return "Index"

class AfterRequestView(FlaskView):

    def after_request(self, name, response):
        return "After Request"

    def index(self):
        return "Index"

class VariedMethodsView(FlaskView):

    def index(self):
        return "Index"

    @route("/routed/")
    def routed_method(self):
        return "Routed Method"

    @classmethod
    def class_method(cls):
        return "Class Method"

class SubVariedMethodsView(VariedMethodsView):
    pass

def func_decorator(f):
    def decorated_view(*args, **kwargs):
        return f(*args, **kwargs)
    return decorated_view

def wraps_decorator(f):
    @wraps(f)
    def decorated_view(*args, **kwargs):
      return f(*args, **kwargs)
    return decorated_view


def params_decorator(p_1, p_2):
    def decorator(f):
       @wraps(f)
       def decorated_function(*args, **kwargs):
           return f(*args, **kwargs)
       return decorated_function
    return decorator


def recursive_decorator(f):
    @wraps(f)
    def decorated_view(*args, **kwargs):
        decorated_view.foo()
        return f(*args, **kwargs)

    def foo():
        return 'bar'
    decorated_view.foo = foo

    return decorated_view

def more_recursive(stop_type):
    def _inner(func):
        def _recursive(*args, **kw):
            return func(*args, **kw)
        return _recursive
    return _inner


class DecoratedView(FlaskView):
    @func_decorator
    def index(self):
        return "Index"

    @func_decorator
    def get(self, id):
        return "Get " + id

    @recursive_decorator
    def post(self):
        return "Post"

    @params_decorator("oneval", "anotherval")
    def params_decorator_method(self):
        return "Params Decorator"

    @params_decorator(get_value(), "value")
    def delete(self, obj_id):
        return "Params Decorator Delete " + obj_id


    @more_recursive(None)
    def get_some(self):
        return "Get Some"

    @more_recursive(None)
    @recursive_decorator
    def get_this(self):
        return "Get This"

    @route('/mixitup')
    @more_recursive(None)
    @recursive_decorator
    def mixitup(self):
        return "Mix It Up"

    @more_recursive(None)
    def someval(self, val):
        return "Someval " + val

    @route('/anotherval/<val>')
    @more_recursive(None)
    @recursive_decorator
    def anotherval(self, val):
        return "Anotherval " + val



class InheritanceView(BasicView):

    # Tests method override
    def get(self, obj_id):
        return "Inheritance Get " + obj_id

    @route('/<obj_id>/delete', methods=['DELETE'])
    def delete(self, obj_id):
        return "Inheritance Delete " + obj_id

    @route('/with_route')
    def with_route(self):
        return "Inheritance with route"


class DecoratedInheritanceView(DecoratedView):

    @recursive_decorator
    def get(self, obj_id):
        return "Decorated Inheritance Get " + obj_id


class TrailingSlashView(FlaskView):
    trailing_slash = False
    route_base = '/trailing/'

    def index(self):
        """A docstring for testing that docstrings are set"""
        return "Index"

    def get(self, obj_id):
        return "Get " + obj_id

    def put(self, id):
        return "Put " + id

    def patch(self, id):
        return "Patch " + id

    def post(self):
        return "Post"

    def delete(self, id):
        return "Delete " + id

    def custom_method(self):
        return "Custom Method"

    def custom_method_with_params(self, p_one, p_two):
        return "Custom Method %s %s" % (p_one, p_two,)

    @route("/routed/")
    def routed_method(self):
        return "Routed Method"

    @route("/routed2")
    def routed_method2(self):
        return "Routed Method 2"


class InheritedTrailingSlashView(TrailingSlashView):
    route_base = '/inherited/trailing/'

    def index(self):
        return "Index"


class OverrideInheritedTrailingSlashView(TrailingSlashView):
    route_base = "/override/trailing/"
    trailing_slash = True

    def index(self):
        return "Index"




########NEW FILE########
