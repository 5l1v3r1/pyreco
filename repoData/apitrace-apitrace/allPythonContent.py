__FILENAME__ = dispatch
##########################################################################
#
# Copyright 2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""Generate DLL/SO dispatching functions.
""" 


# Adjust path
import os.path
import sys
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))


import specs.stdapi as stdapi


def function_pointer_type(function):
    return 'PFN_' + function.name.upper()


def function_pointer_value(function):
    return '_' + function.name + '_ptr'


class Dispatcher:

    def header(self):
        # Must be implemented by derived classes, which should define, declare,
        # or implement something like:
        #
        #  typedef void (*_PROC)(void);
        #
        #  static _PROC _getPublicProcAddress(const char *name);
        #  static _PROC _getPrivateProcAddress(const char *name);
        #
        raise NotImplementedError

    def dispatchModule(self, module):
        for function in module.functions:
            self.dispatchFunction(module, function)
        
        # define standard name aliases for convenience, but only when not
        # tracing, as that would cause symbol clashing with the tracing
        # functions
        print '#ifdef RETRACE'
        for function in module.functions:
            print '#define %s _%s' % (function.name, function.name)
        print '#endif /* RETRACE */'
        print

    def dispatchFunction(self, module, function):
        ptype = function_pointer_type(function)
        pvalue = function_pointer_value(function)
        print 'typedef ' + function.prototype('* %s' % ptype) + ';'
        print 'static %s %s = NULL;' % (ptype, pvalue)
        print
        print 'static inline ' + function.prototype('_' + function.name) + ' {'
        print '    const char *_name = "%s";' % function.name
        if function.type is stdapi.Void:
            ret = ''
        else:
            ret = 'return '
        self.invokeGetProcAddress(module, function)
        print '    %s%s(%s);' % (ret, pvalue, ', '.join([str(arg.name) for arg in function.args]))
        print '}'
        print

    def isFunctionPublic(self, module, function):
        return True

    def getProcAddressName(self, module, function):
        if self.isFunctionPublic(module, function):
            return '_getPublicProcAddress'
        else:
            return '_getPrivateProcAddress'

    def invokeGetProcAddress(self, module, function):
        ptype = function_pointer_type(function)
        pvalue = function_pointer_value(function)
        getProcAddressName = self.getProcAddressName(module, function)
        print '    if (!%s) {' % (pvalue,)
        print '        %s = (%s)%s(_name);' % (pvalue, ptype, getProcAddressName)
        print '        if (!%s) {' % (pvalue,)
        self.failFunction(function)
        print '        }'
        print '    }'

    def failFunction(self, function):
        if function.type is stdapi.Void or function.fail is not None:
            print r'            os::log("warning: ignoring call to unavailable function %s\n", _name);'
            if function.type is stdapi.Void:
                assert function.fail is None
                print '            return;' 
            else:
                assert function.fail is not None
                print '            return %s;' % function.fail
        else:
            print r'            os::log("error: unavailable function %s\n", _name);'
            print r'            os::abort();'



########NEW FILE########
__FILENAME__ = glproc
##########################################################################
#
# Copyright 2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""Generated an header, glproc.hpp, which does pretty much what GLEW does, but
covers all the functions we support.
""" 


from dispatch import Dispatcher
import specs.stdapi as stdapi
from specs.glapi import glapi
from specs.glxapi import glxapi
from specs.wglapi import wglapi
from specs.cglapi import cglapi
from specs.eglapi import eglapi
from specs.glesapi import glesapi


# See http://www.opengl.org/registry/ABI/
public_symbols = set([
    # GL 1.2 and ARB_multitexture
    "glAccum",
    "glAlphaFunc",
    "glAreTexturesResident",
    "glArrayElement",
    "glBegin",
    "glBindTexture",
    "glBitmap",
    "glBlendFunc",
    "glCallList",
    "glCallLists",
    "glClear",
    "glClearAccum",
    "glClearColor",
    "glClearDepth",
    "glClearIndex",
    "glClearStencil",
    "glClipPlane",
    "glColor3b",
    "glColor3bv",
    "glColor3d",
    "glColor3dv",
    "glColor3f",
    "glColor3fv",
    "glColor3i",
    "glColor3iv",
    "glColor3s",
    "glColor3sv",
    "glColor3ub",
    "glColor3ubv",
    "glColor3ui",
    "glColor3uiv",
    "glColor3us",
    "glColor3usv",
    "glColor4b",
    "glColor4bv",
    "glColor4d",
    "glColor4dv",
    "glColor4f",
    "glColor4fv",
    "glColor4i",
    "glColor4iv",
    "glColor4s",
    "glColor4sv",
    "glColor4ub",
    "glColor4ubv",
    "glColor4ui",
    "glColor4uiv",
    "glColor4us",
    "glColor4usv",
    "glColorMask",
    "glColorMaterial",
    "glColorPointer",
    "glCopyPixels",
    "glCopyTexImage1D",
    "glCopyTexImage2D",
    "glCopyTexSubImage1D",
    "glCopyTexSubImage2D",
    "glCullFace",
    "glDeleteLists",
    "glDeleteTextures",
    "glDepthFunc",
    "glDepthMask",
    "glDepthRange",
    "glDisable",
    "glDisableClientState",
    "glDrawArrays",
    "glDrawBuffer",
    "glDrawElements",
    "glDrawPixels",
    "glEdgeFlag",
    "glEdgeFlagPointer",
    "glEdgeFlagv",
    "glEnable",
    "glEnableClientState",
    "glEnd",
    "glEndList",
    "glEvalCoord1d",
    "glEvalCoord1dv",
    "glEvalCoord1f",
    "glEvalCoord1fv",
    "glEvalCoord2d",
    "glEvalCoord2dv",
    "glEvalCoord2f",
    "glEvalCoord2fv",
    "glEvalMesh1",
    "glEvalMesh2",
    "glEvalPoint1",
    "glEvalPoint2",
    "glFeedbackBuffer",
    "glFinish",
    "glFlush",
    "glFogf",
    "glFogfv",
    "glFogi",
    "glFogiv",
    "glFrontFace",
    "glFrustum",
    "glGenLists",
    "glGenTextures",
    "glGetBooleanv",
    "glGetClipPlane",
    "glGetDoublev",
    "glGetError",
    "glGetFloatv",
    "glGetIntegerv",
    "glGetLightfv",
    "glGetLightiv",
    "glGetMapdv",
    "glGetMapfv",
    "glGetMapiv",
    "glGetMaterialfv",
    "glGetMaterialiv",
    "glGetPixelMapfv",
    "glGetPixelMapuiv",
    "glGetPixelMapusv",
    "glGetPointerv",
    "glGetPolygonStipple",
    "glGetString",
    "glGetTexEnvfv",
    "glGetTexEnviv",
    "glGetTexGendv",
    "glGetTexGenfv",
    "glGetTexGeniv",
    "glGetTexImage",
    "glGetTexLevelParameterfv",
    "glGetTexLevelParameteriv",
    "glGetTexParameterfv",
    "glGetTexParameteriv",
    "glHint",
    "glIndexMask",
    "glIndexPointer",
    "glIndexd",
    "glIndexdv",
    "glIndexf",
    "glIndexfv",
    "glIndexi",
    "glIndexiv",
    "glIndexs",
    "glIndexsv",
    "glIndexub",
    "glIndexubv",
    "glInitNames",
    "glInterleavedArrays",
    "glIsEnabled",
    "glIsList",
    "glIsTexture",
    "glLightModelf",
    "glLightModelfv",
    "glLightModeli",
    "glLightModeliv",
    "glLightf",
    "glLightfv",
    "glLighti",
    "glLightiv",
    "glLineStipple",
    "glLineWidth",
    "glListBase",
    "glLoadIdentity",
    "glLoadMatrixd",
    "glLoadMatrixf",
    "glLoadName",
    "glLogicOp",
    "glMap1d",
    "glMap1f",
    "glMap2d",
    "glMap2f",
    "glMapGrid1d",
    "glMapGrid1f",
    "glMapGrid2d",
    "glMapGrid2f",
    "glMaterialf",
    "glMaterialfv",
    "glMateriali",
    "glMaterialiv",
    "glMatrixMode",
    "glMultMatrixd",
    "glMultMatrixf",
    "glNewList",
    "glNormal3b",
    "glNormal3bv",
    "glNormal3d",
    "glNormal3dv",
    "glNormal3f",
    "glNormal3fv",
    "glNormal3i",
    "glNormal3iv",
    "glNormal3s",
    "glNormal3sv",
    "glNormalPointer",
    "glOrtho",
    "glPassThrough",
    "glPixelMapfv",
    "glPixelMapuiv",
    "glPixelMapusv",
    "glPixelStoref",
    "glPixelStorei",
    "glPixelTransferf",
    "glPixelTransferi",
    "glPixelZoom",
    "glPointSize",
    "glPolygonMode",
    "glPolygonOffset",
    "glPolygonStipple",
    "glPopAttrib",
    "glPopClientAttrib",
    "glPopMatrix",
    "glPopName",
    "glPrioritizeTextures",
    "glPushAttrib",
    "glPushClientAttrib",
    "glPushMatrix",
    "glPushName",
    "glRasterPos2d",
    "glRasterPos2dv",
    "glRasterPos2f",
    "glRasterPos2fv",
    "glRasterPos2i",
    "glRasterPos2iv",
    "glRasterPos2s",
    "glRasterPos2sv",
    "glRasterPos3d",
    "glRasterPos3dv",
    "glRasterPos3f",
    "glRasterPos3fv",
    "glRasterPos3i",
    "glRasterPos3iv",
    "glRasterPos3s",
    "glRasterPos3sv",
    "glRasterPos4d",
    "glRasterPos4dv",
    "glRasterPos4f",
    "glRasterPos4fv",
    "glRasterPos4i",
    "glRasterPos4iv",
    "glRasterPos4s",
    "glRasterPos4sv",
    "glReadBuffer",
    "glReadPixels",
    "glRectd",
    "glRectdv",
    "glRectf",
    "glRectfv",
    "glRecti",
    "glRectiv",
    "glRects",
    "glRectsv",
    "glRenderMode",
    "glRotated",
    "glRotatef",
    "glScaled",
    "glScalef",
    "glScissor",
    "glSelectBuffer",
    "glShadeModel",
    "glStencilFunc",
    "glStencilMask",
    "glStencilOp",
    "glTexCoord1d",
    "glTexCoord1dv",
    "glTexCoord1f",
    "glTexCoord1fv",
    "glTexCoord1i",
    "glTexCoord1iv",
    "glTexCoord1s",
    "glTexCoord1sv",
    "glTexCoord2d",
    "glTexCoord2dv",
    "glTexCoord2f",
    "glTexCoord2fv",
    "glTexCoord2i",
    "glTexCoord2iv",
    "glTexCoord2s",
    "glTexCoord2sv",
    "glTexCoord3d",
    "glTexCoord3dv",
    "glTexCoord3f",
    "glTexCoord3fv",
    "glTexCoord3i",
    "glTexCoord3iv",
    "glTexCoord3s",
    "glTexCoord3sv",
    "glTexCoord4d",
    "glTexCoord4dv",
    "glTexCoord4f",
    "glTexCoord4fv",
    "glTexCoord4i",
    "glTexCoord4iv",
    "glTexCoord4s",
    "glTexCoord4sv",
    "glTexCoordPointer",
    "glTexEnvf",
    "glTexEnvfv",
    "glTexEnvi",
    "glTexEnviv",
    "glTexGend",
    "glTexGendv",
    "glTexGenf",
    "glTexGenfv",
    "glTexGeni",
    "glTexGeniv",
    "glTexImage1D",
    "glTexImage2D",
    "glTexParameterf",
    "glTexParameterfv",
    "glTexParameteri",
    "glTexParameteriv",
    "glTexSubImage1D",
    "glTexSubImage2D",
    "glTranslated",
    "glTranslatef",
    "glVertex2d",
    "glVertex2dv",
    "glVertex2f",
    "glVertex2fv",
    "glVertex2i",
    "glVertex2iv",
    "glVertex2s",
    "glVertex2sv",
    "glVertex3d",
    "glVertex3dv",
    "glVertex3f",
    "glVertex3fv",
    "glVertex3i",
    "glVertex3iv",
    "glVertex3s",
    "glVertex3sv",
    "glVertex4d",
    "glVertex4dv",
    "glVertex4f",
    "glVertex4fv",
    "glVertex4i",
    "glVertex4iv",
    "glVertex4s",
    "glVertex4sv",
    "glVertexPointer",
    "glViewport",

    # GLX 1.3 and GLX_ARB_get_proc_address
    "glXChooseVisual",
    "glXCreateContext",
    "glXDestroyContext",
    "glXMakeCurrent",
    "glXCopyContext",
    "glXSwapBuffers",
    "glXCreateGLXPixmap",
    "glXDestroyGLXPixmap",
    "glXQueryExtension",
    "glXQueryVersion",
    "glXIsDirect",
    "glXGetConfig",
    "glXGetCurrentContext",
    "glXGetCurrentDrawable",
    "glXWaitGL",
    "glXWaitX",
    "glXUseXFont",
    "glXQueryExtensionsString",
    "glXQueryServerString",
    "glXGetClientString",
    "glXGetCurrentDisplay",
    "glXChooseFBConfig",
    "glXGetFBConfigAttrib",
    "glXGetFBConfigs",
    "glXGetVisualFromFBConfig",
    "glXCreateWindow",
    "glXDestroyWindow",
    "glXCreatePixmap",
    "glXDestroyPixmap",
    "glXCreatePbuffer",
    "glXDestroyPbuffer",
    "glXQueryDrawable",
    "glXCreateNewContext",
    "glXMakeContextCurrent",
    "glXGetCurrentReadDrawable",
    "glXQueryContext",
    "glXSelectEvent",
    "glXGetSelectedEvent",
    "glXGetProcAddressARB",
    "glXGetProcAddress",
    
    # WGL
    #"glDebugEntry",
    "wglChoosePixelFormat",
    "wglCopyContext",
    "wglCreateContext",
    "wglCreateLayerContext",
    "wglDeleteContext",
    "wglDescribeLayerPlane",
    "wglDescribePixelFormat",
    "wglGetCurrentContext",
    "wglGetCurrentDC",
    "wglGetDefaultProcAddress",
    "wglGetLayerPaletteEntries",
    "wglGetPixelFormat",
    "wglGetProcAddress",
    "wglMakeCurrent",
    "wglRealizeLayerPalette",
    "wglSetLayerPaletteEntries",
    "wglSetPixelFormat",
    "wglShareLists",
    "wglSwapBuffers",
    "wglSwapLayerBuffers",
    "wglSwapMultipleBuffers",
    "wglUseFontBitmapsA",
    "wglUseFontBitmapsW",
    "wglUseFontOutlinesA",
    "wglUseFontOutlinesW",

])

# EGL 1.4
public_symbols.update([
   "eglBindAPI",
   "eglBindTexImage",
   "eglChooseConfig",
   "eglCopyBuffers",
   "eglCreateContext",
   "eglCreatePbufferFromClientBuffer",
   "eglCreatePbufferSurface",
   "eglCreatePixmapSurface",
   "eglCreateWindowSurface",
   "eglDestroyContext",
   "eglDestroySurface",
   "eglGetConfigAttrib",
   "eglGetConfigs",
   "eglGetCurrentContext",
   "eglGetCurrentDisplay",
   "eglGetCurrentSurface",
   "eglGetDisplay",
   "eglGetError",
   "eglGetProcAddress",
   "eglInitialize",
   "eglMakeCurrent",
   "eglQueryAPI",
   "eglQueryContext",
   "eglQueryString",
   "eglQuerySurface",
   "eglReleaseTexImage",
   "eglReleaseThread",
   "eglSurfaceAttrib",
   "eglSwapBuffers",
   "eglSwapInterval",
   "eglTerminate",
   "eglWaitClient",
   "eglWaitGL",
   "eglWaitNative",
])

class GlDispatcher(Dispatcher):

    def header(self):
        print '''
#if defined(_WIN32)
extern HMODULE _libGlHandle;
#else
extern void * _libGlHandle;
#endif

void * _getPublicProcAddress(const char *procName);
void * _getPrivateProcAddress(const char *procName);
'''
        
    def isFunctionPublic(self, module, function):
        return function.name in public_symbols or function.name.startswith('CGL')

    def failFunction(self, function):
        # We fake this when they are not available
        if function.name in ('glGetObjectLabel', 'glGetObjectPtrLabel', 'glGetObjectLabelEXT'):
            print r'    if (length != 0) *length = 0;'
            print r'    if (label != 0 && bufSize > 0) *label = 0;'
            return
        if function.name in ('glGetDebugMessageLog', 'glGetDebugMessageLogARB'):
            print r'    if (sources != 0) *sources = 0;'
            print r'    if (types != 0) *types = 0;'
            print r'    if (ids != 0) *ids = 0;'
            print r'    if (severities != 0) *severities = 0;'
            print r'    if (lengths != 0) *lengths = 0;'
            print r'    if (messageLog != 0 && bufsize > 0) *messageLog = 0;'
            return
        if function.name in ('glGetDebugMessageLogAMD'):
            print r'    if (categories != 0) *categories = 0;'
            print r'    if (ids != 0) *ids = 0;'
            print r'    if (severities != 0) *severities = 0;'
            print r'    if (lengths != 0) *lengths = 0;'
            print r'    if (message != 0 && bufsize > 0) *message = 0;'
            return

        Dispatcher.failFunction(self, function)


if __name__ == '__main__':
    print
    print '#ifndef _GLPROC_HPP_'
    print '#define _GLPROC_HPP_'
    print 
    print '#include "glimports.hpp"'
    print '#include "os.hpp"'
    print
    dispatcher = GlDispatcher()
    print
    dispatcher.header()
    print
    dispatcher.dispatchModule(eglapi)
    print
    print '#if defined(_WIN32)'
    print
    dispatcher.dispatchModule(wglapi)
    print
    print '#elif defined(__APPLE__)'
    print
    dispatcher.dispatchModule(cglapi)
    print
    print '#elif defined(HAVE_X11)'
    print
    dispatcher.dispatchModule(glxapi)
    print
    print '#endif'
    print
    dispatcher.dispatchModule(glapi)
    print
    dispatcher.dispatchModule(glesapi)
    print

    print '#endif /* !_GLPROC_HPP_ */'
    print

########NEW FILE########
__FILENAME__ = d3d9retrace
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""D3D retracer generator."""


import sys
from dllretrace import DllRetracer as Retracer
from specs.stdapi import API


class D3DRetracer(Retracer):

    def retraceApi(self, api):
        print '// Swizzling mapping for lock addresses'
        print 'static std::map<void *, void *> _maps;'
        print

        Retracer.retraceApi(self, api)

    def invokeFunction(self, function):
        if function.name in ('Direct3DCreate9', 'Direct3DCreate9Ex'):
            print 'if (retrace::debug >= 2 && !g_szD3D9DllName && LoadLibraryA("d3d9d.dll")) {'
            print '    /*'
            print '     * D3D9D only works for simple applications, it will often report bogus errors'
            print '     * on complex traces, or traces which use unofficial D3D9 features.'
            print '     */'
            print '    g_szD3D9DllName = "d3d9d.dll";'
            print '    SDKVersion |= 0x80000000;'
            print '} else {'
            print '    SDKVersion &= ~0x80000000;'
            print '}'

        Retracer.invokeFunction(self, function)

    createDeviceMethodNames = [
        'CreateDevice',
        'CreateDeviceEx',
    ]

    def invokeInterfaceMethod(self, interface, method):
        # keep track of the last used device for state dumping
        if interface.name in ('IDirect3DDevice9', 'IDirect3DDevice9Ex'):
            if method.name == 'Release':
                print r'    if (call.ret->toUInt() == 0) {'
                print r'        d3d9Dumper.unbindDevice(_this);'
                print r'    }'
            else:
                print r'    d3d9Dumper.bindDevice(_this);'
        if interface.name in ('IDirect3DDevice8', 'IDirect3DDevice8Ex'):
            if method.name == 'Release':
                print r'    if (call.ret->toUInt() == 0) {'
                print r'        d3d8Dumper.unbindDevice(_this);'
                print r'    }'
            else:
                print r'    d3d8Dumper.bindDevice(_this);'

        # create windows as neccessary
        if method.name in ('CreateDevice', 'CreateDeviceEx', 'CreateAdditionalSwapChain'):
            print r'    HWND hWnd = d3dretrace::createWindow(pPresentationParameters->BackBufferWidth, pPresentationParameters->BackBufferHeight);'
            print r'    pPresentationParameters->hDeviceWindow = hWnd;'
            if 'hFocusWindow' in method.argNames():
                print r'    hFocusWindow = hWnd;'

            # force windowed mode
            print r'    if (retrace::forceWindowed) {'
            print r'        pPresentationParameters->Windowed = TRUE;'
            print r'        pPresentationParameters->FullScreen_RefreshRateInHz = 0;'
            print r'    }'
        
        if method.name in self.createDeviceMethodNames:
            # override the device type
            print r'    switch (retrace::driver) {'
            print r'    case retrace::DRIVER_HARDWARE:'
            print r'        DeviceType = D3DDEVTYPE_HAL;'
            print r'        break;'
            print r'    case retrace::DRIVER_SOFTWARE:'
            print r'    case retrace::DRIVER_REFERENCE:'
            print r'        DeviceType = D3DDEVTYPE_REF;'
            print r'        break;'
            print r'    case retrace::DRIVER_NULL:'
            if interface.name.startswith('IDirect3D9'):
                print r'        DeviceType = D3DDEVTYPE_NULLREF;'
            else:
                print r'        retrace::warning(call) << "null driver not supported\n";'
            print r'        break;'
            print r'    case retrace::DRIVER_MODULE:'
            print r'        retrace::warning(call) << "driver module not supported\n";'
            print r'        break;'
            print r'    default:'
            print r'        assert(0);'
            print r'        /* fall-through */'
            print r'    case retrace::DRIVER_DEFAULT:'
            print r'        break;'
            print r'    }'

        if method.name in ('Reset', 'ResetEx'):
            # force windowed mode
            print r'    if (retrace::forceWindowed) {'
            print r'        pPresentationParameters->Windowed = TRUE;'
            print r'        pPresentationParameters->FullScreen_RefreshRateInHz = 0;'
            print r'    }'
            # resize window
            print r'    if (pPresentationParameters->Windowed) {'
            print r'        d3dretrace::resizeWindow(pPresentationParameters->hDeviceWindow, pPresentationParameters->BackBufferWidth, pPresentationParameters->BackBufferHeight);'
            print r'    }'

        # notify frame has been completed
        if method.name in ('Present', 'PresentEx'):
            print r'    retrace::frameComplete(call);'
            print r'    hDestWindowOverride = NULL;'

        if 'pSharedHandle' in method.argNames():
            print r'    if (pSharedHandle) {'
            print r'        retrace::warning(call) << "shared surfaces unsupported\n";'
            print r'        pSharedHandle = NULL;'
            print r'    }'

        Retracer.invokeInterfaceMethod(self, interface, method)

        if method.name in self.createDeviceMethodNames:
            print r'    if (FAILED(_result)) {'
            print r'        exit(1);'
            print r'    }'

        # process events after presents
        if method.name == 'Present':
            print r'    d3dretrace::processEvents();'

        if method.name in ('Lock', 'LockRect', 'LockBox'):
            print '    VOID *_pbData = NULL;'
            print '    size_t _MappedSize = 0;'
            print '    _getMapInfo(_this, %s, _pbData, _MappedSize);' % ', '.join(method.argNames()[:-1])
            print '    if (_MappedSize) {'
            print '        _maps[_this] = _pbData;'
            print '    } else {'
            print '        return;'
            print '    }'
        
        if method.name in ('Unlock', 'UnlockRect', 'UnlockBox'):
            print '    VOID *_pbData = 0;'
            print '    _pbData = _maps[_this];'
            print '    if (_pbData) {'
            print '        retrace::delRegionByPointer(_pbData);'
            print '        _maps[_this] = 0;'
            print '    }'


def main():
    print r'#include <string.h>'
    print
    print r'#include <iostream>'
    print
    print r'#include "d3dretrace.hpp"'
    print

    moduleName = sys.argv[1]
    support = int(sys.argv[2])

    api = API()
    
    if support:
        if moduleName == 'd3d9':
            from specs.d3d9 import d3d9
            print r'#include "d3d9imports.hpp"'
            print r'#include "d3d9size.hpp"'
            api.addModule(d3d9)
            print
            print '''static d3dretrace::D3DDumper<IDirect3DDevice9> d3d9Dumper;'''
            print
        elif moduleName == 'd3d8':
            from specs.d3d8 import d3d8
            print r'#include "d3d8imports.hpp"'
            print r'#include "d3d8size.hpp"'
            api.addModule(d3d8)
            print
            print '''static d3dretrace::D3DDumper<IDirect3DDevice8> d3d8Dumper;'''
            print
        else:
            assert False

    retracer = D3DRetracer()
    retracer.table_name = 'd3dretrace::%s_callbacks' % moduleName
    retracer.retraceApi(api)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = dllretrace
##########################################################################
#
# Copyright 2008-2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from retrace import Retracer
from dispatch import Dispatcher
from specs.stdapi import API


class DllDispatcher(Dispatcher):

    def dispatchModule(self, module):
        tag = module.name.upper()
        print r'const char *g_sz%sDllName = NULL;' % (tag,)
        print r'HMODULE g_h%sModule = NULL;' % (tag,)
        print r''
        print r'static PROC'
        print r'_get%sProcAddress(LPCSTR lpProcName) {' % tag
        print r'    if (!g_h%sModule) {' % tag
        print r'        if (g_sz%sDllName) {' % tag
        print r'            g_h%sModule = LoadLibraryA(g_sz%sDllName);' % (tag, tag)
        print r'            if (!g_h%sModule) {' % tag
        print r'                os::log("warning: failed to load %%s\n", g_sz%sDllName);' % tag 
        print r'            }'
        print r'        }'
        print r'        if (!g_h%sModule) {' % tag
        print r'            g_h%sModule = LoadLibraryA("%s.dll");' % (tag, module.name)
        print r'        }'
        print r'        if (!g_h%sModule) {' % tag
        print r'            os::log("error: failed to load %s.dll\n");' % module.name
        print r'            exit(1);'
        print r'        }'
        print r'    }'
        print r'    return GetProcAddress(g_h%sModule, lpProcName);' % tag
        print r'}'
        print r''

        Dispatcher.dispatchModule(self, module)

    def getProcAddressName(self, module, function):
        assert self.isFunctionPublic(module, function)
        return '_get%sProcAddress' % (module.name.upper())


class DllRetracer(Retracer):

    def retraceApi(self, api):
        for module in api.modules:
            dispatcher = DllDispatcher()
            dispatcher.dispatchModule(module)

        Retracer.retraceApi(self, api)

########NEW FILE########
__FILENAME__ = dxgiretrace
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""D3D retracer generator."""


import sys
from dllretrace import DllRetracer as Retracer
import specs.dxgi
from specs.stdapi import API
from specs.dxgi import dxgi
from specs.d3d10 import d3d10
from specs.d3d10_1 import d3d10_1
from specs.d3d11 import d3d11


class D3DRetracer(Retracer):

    def retraceApi(self, api):
        print '// Swizzling mapping for lock addresses'
        print 'static std::map<void *, void *> _maps;'
        print
        print r'''
static void 
createWindow(DXGI_SWAP_CHAIN_DESC *pSwapChainDesc) {
    UINT Width  = pSwapChainDesc->BufferDesc.Width;
    UINT Height = pSwapChainDesc->BufferDesc.Height;
    if (!Width)  Width = 1024;
    if (!Height) Height = 768;
    pSwapChainDesc->OutputWindow = d3dretrace::createWindow(Width, Height);
}
'''

        self.table_name = 'd3dretrace::dxgi_callbacks'

        Retracer.retraceApi(self, api)

    createDeviceFunctionNames = [
        "D3D10CreateDevice",
        "D3D10CreateDeviceAndSwapChain",
        "D3D10CreateDevice1",
        "D3D10CreateDeviceAndSwapChain1",
        "D3D11CreateDevice",
        "D3D11CreateDeviceAndSwapChain",
    ]

    def invokeFunction(self, function):
        if function.name in self.createDeviceFunctionNames:
            # create windows as neccessary
            if 'pSwapChainDesc' in function.argNames():
                print r'    createWindow(pSwapChainDesc);'

            # Compensate for the fact we don't trace DXGI object creation
            if function.name.startswith('D3D11CreateDevice'):
                print r'    if (DriverType == D3D_DRIVER_TYPE_UNKNOWN && !pAdapter) {'
                print r'        DriverType = D3D_DRIVER_TYPE_HARDWARE;'
                print r'    }'

            if function.name.startswith('D3D10CreateDevice'):
                # Toggle debugging
                print r'    Flags &= ~D3D10_CREATE_DEVICE_DEBUG;'
                print r'    if (retrace::debug) {'
                print r'        if (LoadLibraryA("d3d10sdklayers")) {'
                print r'            Flags |= D3D10_CREATE_DEVICE_DEBUG;'
                print r'        }'
                print r'    }'

                # Force driver
                self.forceDriver('D3D10_DRIVER_TYPE')

            if function.name.startswith('D3D11CreateDevice'):
                # Toggle debugging
                print r'    Flags &= ~D3D11_CREATE_DEVICE_DEBUG;'
                print r'    if (retrace::debug) {'
                print r'        OSVERSIONINFO osvi;'
                print r'        BOOL bIsWindows8orLater;'
                print r'        ZeroMemory(&osvi, sizeof osvi);'
                print r'        osvi.dwOSVersionInfoSize = sizeof osvi;'
                print r'        GetVersionEx(&osvi);'
                print r'        bIsWindows8orLater = '
                print r'            (osvi.dwMajorVersion > 6) ||'
                print r'            (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion >= 2);'
                print r'        const char *szD3d11SdkLayers = bIsWindows8orLater ? "d3d11_1sdklayers" : "d3d11sdklayers";'
                print r'        if (LoadLibraryA(szD3d11SdkLayers)) {'
                print r'            Flags |= D3D11_CREATE_DEVICE_DEBUG;'
                print r'        }'
                print r'    }'

                # Force driver
                self.forceDriver('D3D_DRIVER_TYPE')

        Retracer.invokeFunction(self, function)

        # Debug layers with Windows 8 or Windows 7 Platform update are a mess.
        # It's not possible to know before hand whether they are or not
        # available, so always retry with debug flag off..
        if function.name in self.createDeviceFunctionNames:
            print r'    if (FAILED(_result)) {'

            if function.name.startswith('D3D10CreateDevice'):
                print r'        if (_result == E_FAIL && (Flags & D3D10_CREATE_DEVICE_DEBUG)) {'
                print r'            retrace::warning(call) << "debug layer (d3d10sdklayers.dll) not installed\n";'
                print r'            Flags &= ~D3D10_CREATE_DEVICE_DEBUG;'
                Retracer.invokeFunction(self, function)
                print r'        }'
            elif function.name.startswith('D3D11CreateDevice'):
                print r'        if (_result == E_FAIL && (Flags & D3D11_CREATE_DEVICE_DEBUG)) {'
                print r'            retrace::warning(call) << "debug layer (d3d11sdklayers.dll for Windows 7, d3d11_1sdklayers.dll for Windows 8 or Windows 7 with KB 2670838) not properly installed\n";'
                print r'            Flags &= ~D3D11_CREATE_DEVICE_DEBUG;'
                Retracer.invokeFunction(self, function)
                print r'        }'
            else:
                assert False

            print r'        if (FAILED(_result)) {'
            print r'            exit(1);'
            print r'        }'

            print r'    }'

    def forceDriver(self, enum):
        # This can only work when pAdapter is NULL. For non-NULL pAdapter we
        # need to override inside the EnumAdapters call below
        print r'    if (pAdapter == NULL) {'
        print r'        switch (retrace::driver) {'
        print r'        case retrace::DRIVER_HARDWARE:'
        print r'            DriverType = %s_HARDWARE;' % enum
        print r'            Software = NULL;'
        print r'            break;'
        print r'        case retrace::DRIVER_SOFTWARE:'
        print r'            DriverType = %s_WARP;' % enum
        print r'            Software = NULL;'
        print r'            break;'
        print r'        case retrace::DRIVER_REFERENCE:'
        print r'            DriverType = %s_REFERENCE;' % enum
        print r'            Software = NULL;'
        print r'            break;'
        print r'        case retrace::DRIVER_NULL:'
        print r'            DriverType = %s_NULL;' % enum
        print r'            Software = NULL;'
        print r'            break;'
        print r'        case retrace::DRIVER_MODULE:'
        print r'            DriverType = %s_SOFTWARE;' % enum
        print r'            Software = LoadLibraryA(retrace::driverModule);'
        print r'            if (!Software) {'
        print r'                retrace::warning(call) << "failed to load " << retrace::driverModule << "\n";'
        print r'            }'
        print r'            break;'
        print r'        default:'
        print r'            assert(0);'
        print r'            /* fall-through */'
        print r'        case retrace::DRIVER_DEFAULT:'
        print r'            if (DriverType == %s_SOFTWARE) {' % enum
        print r'                Software = LoadLibraryA("d3d10warp");'
        print r'                if (!Software) {'
        print r'                    retrace::warning(call) << "failed to load d3d10warp.dll\n";'
        print r'                }'
        print r'            }'
        print r'            break;'
        print r'        }'
        print r'    } else {'
        print r'        Software = NULL;'
        print r'    }'

    def invokeInterfaceMethod(self, interface, method):
        # keep track of the last used device for state dumping
        if interface.name in ('ID3D10Device', 'ID3D10Device1'):
            if method.name == 'Release':
                print r'    if (call.ret->toUInt() == 0) {'
                print r'        d3d10Dumper.unbindDevice(_this);'
                print r'    }'
            else:
                print r'    d3d10Dumper.bindDevice(_this);'
        if interface.name in ('ID3D11DeviceContext', 'ID3D11DeviceContext1'):
            if method.name == 'Release':
                print r'    if (call.ret->toUInt() == 0) {'
                print r'        d3d11Dumper.unbindDevice(_this);'
                print r'    }'
            else:
                print r'    if (_this->GetType() == D3D11_DEVICE_CONTEXT_IMMEDIATE) {'
                print r'        d3d11Dumper.bindDevice(_this);'
                print r'    }'

        if interface.name == 'IDXGIFactory' and method.name == 'QueryInterface':
            print r'    if (riid == IID_IDXGIFactoryDWM) {'
            print r'        _this->AddRef();'
            print r'        *ppvObj = new d3dretrace::CDXGIFactoryDWM(_this);'
            print r'        _result = S_OK;'
            print r'    } else {'
            Retracer.invokeInterfaceMethod(self, interface, method)
            print r'    }'
            return

        # create windows as neccessary
        if method.name == 'CreateSwapChain':
            print r'    createWindow(pDesc);'

        # notify frame has been completed
        if method.name == 'Present':
            print r'    retrace::frameComplete(call);'

        if 'pSharedResource' in method.argNames():
            print r'    if (pSharedResource) {'
            print r'        retrace::warning(call) << "shared surfaces unsupported\n";'
            print r'        pSharedResource = NULL;'
            print r'    }'

        # Force driver
        if interface.name.startswith('IDXGIFactory') and method.name.startswith('EnumAdapters'):
            print r'    const char *szSoftware = NULL;'
            print r'    switch (retrace::driver) {'
            print r'    case retrace::DRIVER_REFERENCE:'
            print r'    case retrace::DRIVER_SOFTWARE:'
            print r'        szSoftware = "d3d10warp.dll";'
            print r'        break;'
            print r'    case retrace::DRIVER_MODULE:'
            print r'        szSoftware = retrace::driverModule;'
            print r'        break;'
            print r'    default:'
            print r'        break;'
            print r'    }'
            print r'    HMODULE hSoftware = NULL;'
            print r'    if (szSoftware) {'
            print r'        hSoftware = LoadLibraryA(szSoftware);'
            print r'        if (!hSoftware) {'
            print r'            retrace::warning(call) << "failed to load " << szSoftware << "\n";'
            print r'        }'
            print r'    }'
            print r'    if (hSoftware) {'
            print r'        _result = _this->CreateSoftwareAdapter(hSoftware, reinterpret_cast<IDXGIAdapter **>(ppAdapter));'
            print r'    } else {'
            Retracer.invokeInterfaceMethod(self, interface, method)
            print r'    }'
            return

        if interface.name.startswith('ID3D10Device') and method.name == 'OpenSharedResource':
            print r'    retrace::warning(call) << "replacing shared resource with checker pattern\n";'
            print r'    D3D10_TEXTURE2D_DESC Desc;'
            print r'    memset(&Desc, 0, sizeof Desc);'
            print r'    Desc.Width = 8;'
            print r'    Desc.Height = 8;'
            print r'    Desc.MipLevels = 1;'
            print r'    Desc.ArraySize = 1;'
            print r'    Desc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;'
            print r'    Desc.SampleDesc.Count = 1;'
            print r'    Desc.SampleDesc.Quality = 0;'
            print r'    Desc.Usage = D3D10_USAGE_DEFAULT;'
            print r'    Desc.BindFlags = D3D10_BIND_SHADER_RESOURCE | D3D10_BIND_RENDER_TARGET;'
            print r'    Desc.CPUAccessFlags = 0x0;'
            print r'    Desc.MiscFlags = 0 /* D3D10_RESOURCE_MISC_SHARED */;'
            print r'''
            static const DWORD Checker[8][8] = {
               { 0U, ~0U,  0U, ~0U,  0U, ~0U,  0U, ~0U },
               {~0U,  0U, ~0U,  0U, ~0U,  0U, ~0U,  0U },
               { 0U, ~0U,  0U, ~0U,  0U, ~0U,  0U, ~0U },
               {~0U,  0U, ~0U,  0U, ~0U,  0U, ~0U,  0U },
               { 0U, ~0U,  0U, ~0U,  0U, ~0U,  0U, ~0U },
               {~0U,  0U, ~0U,  0U, ~0U,  0U, ~0U,  0U },
               { 0U, ~0U,  0U, ~0U,  0U, ~0U,  0U, ~0U },
               {~0U,  0U, ~0U,  0U, ~0U,  0U, ~0U,  0U }
            };
            static const D3D10_SUBRESOURCE_DATA InitialData = {Checker, sizeof Checker[0], sizeof Checker};
            '''
            print r'    _result = _this->CreateTexture2D(&Desc, &InitialData, (ID3D10Texture2D**)ppResource);'
            self.checkResult(method.type)
            return

        if method.name == 'Map':
            # Reset _DO_NOT_WAIT flags. Otherwise they may fail, and we have no
            # way to cope with it (other than retry).
            mapFlagsArg = method.getArgByName('MapFlags')
            for flag in mapFlagsArg.type.values:
                if flag.endswith('_MAP_FLAG_DO_NOT_WAIT'):
                    print r'    MapFlags &= ~%s;' % flag

        Retracer.invokeInterfaceMethod(self, interface, method)

        # process events after presents
        if method.name == 'Present':
            print r'    d3dretrace::processEvents();'

        if method.name == 'Map':
            print '    _MAP_DESC _MapDesc;'
            print '    _getMapDesc(_this, %s, _MapDesc);' % ', '.join(method.argNames())
            print '    size_t _MappedSize = _MapDesc.Size;'
            print '    if (_MapDesc.Size) {'
            if interface.name.startswith('ID3D11DeviceContext'):
                print '        _maps[pResource] = _MapDesc.pData;'
            else:
                print '        _maps[_this] = _MapDesc.pData;'
            print '    } else {'
            print '        return;'
            print '    }'
        
        if method.name == 'Unmap':
            if interface.name.startswith('ID3D11DeviceContext'):
                print '    VOID *_pbData = 0;'
                print '    _pbData = _maps[pResource];'
                print '    if (_pbData) {'
                print '        retrace::delRegionByPointer(_pbData);'
                print '        _maps[pResource] = 0;'
                print '    }'
            else:
                print '    VOID *_pbData = 0;'
                print '    _pbData = _maps[_this];'
                print '    if (_pbData) {'
                print '        retrace::delRegionByPointer(_pbData);'
                print '        _maps[_this] = 0;'
                print '    }'

        # Attach shader byte code for lookup
        if 'pShaderBytecode' in method.argNames():
            ppShader = method.args[-1]
            assert ppShader.output
            print r'    if (retrace::dumpingState && SUCCEEDED(_result)) {'
            print r'        (*%s)->SetPrivateData(d3dstate::GUID_D3DSTATE, BytecodeLength, pShaderBytecode);' % ppShader.name
            print r'    }'


def main():
    print r'#define INITGUID'
    print
    print r'#include <string.h>'
    print
    print r'#include <iostream>'
    print
    print r'#include "d3dretrace.hpp"'
    print

    moduleNames = sys.argv[1:]

    api = API()
    
    if moduleNames:
        print r'#include "d3dretrace_dxgi.hpp"'
        api.addModule(dxgi)
    
    if 'd3d10' in moduleNames:
        if 'd3d10_1' in moduleNames:
            print r'#include "d3d10_1imports.hpp"'
            api.addModule(d3d10_1)
        else:
            print r'#include "d3d10imports.hpp"'
        print r'#include "d3d10size.hpp"'
        api.addModule(d3d10)
        print
        print '''static d3dretrace::D3DDumper<ID3D10Device> d3d10Dumper;'''
        print

    if 'd3d11' in moduleNames:
        print r'#include "d3d11imports.hpp"'
        if 'd3d11_1' in moduleNames:
            print '#include <d3d11_1.h>'
            import specs.d3d11_1
        print r'#include "d3d11size.hpp"'
        print r'#include "d3dstate.hpp"'
        api.addModule(d3d11)
        
        print
        print '''static d3dretrace::D3DDumper<ID3D11DeviceContext> d3d11Dumper;'''
        print

    retracer = D3DRetracer()
    retracer.retraceApi(api)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = glretrace
##########################################################################
#
# Copyright 2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""GL retracer generator."""


from retrace import Retracer
import specs.stdapi as stdapi
import specs.glapi as glapi
import specs.glesapi as glesapi


class GlRetracer(Retracer):

    table_name = 'glretrace::gl_callbacks'

    def retraceFunction(self, function):
        Retracer.retraceFunction(self, function)

    array_pointer_function_names = set((
        "glVertexPointer",
        "glNormalPointer",
        "glColorPointer",
        "glIndexPointer",
        "glTexCoordPointer",
        "glEdgeFlagPointer",
        "glFogCoordPointer",
        "glSecondaryColorPointer",

        "glInterleavedArrays",

        "glVertexPointerEXT",
        "glNormalPointerEXT",
        "glColorPointerEXT",
        "glIndexPointerEXT",
        "glTexCoordPointerEXT",
        "glEdgeFlagPointerEXT",
        "glFogCoordPointerEXT",
        "glSecondaryColorPointerEXT",

        "glVertexAttribPointer",
        "glVertexAttribPointerARB",
        "glVertexAttribPointerNV",
        "glVertexAttribIPointer",
        "glVertexAttribIPointerEXT",
        "glVertexAttribLPointer",
        "glVertexAttribLPointerEXT",
        
        #"glMatrixIndexPointerARB",
    ))

    draw_array_function_names = set([
        "glDrawArrays",
        "glDrawArraysEXT",
        "glDrawArraysIndirect",
        "glDrawArraysInstanced",
        "glDrawArraysInstancedARB",
        "glDrawArraysInstancedEXT",
        "glDrawArraysInstancedBaseInstance",
        "glDrawMeshArraysSUN",
        "glMultiDrawArrays",
        "glMultiDrawArraysEXT",
        "glMultiModeDrawArraysIBM",
        'glMultiDrawArraysIndirect',
        'glMultiDrawArraysIndirectAMD',
    ])

    draw_elements_function_names = set([
        "glDrawElements",
        "glDrawElementsBaseVertex",
        "glDrawElementsIndirect",
        "glDrawElementsInstanced",
        "glDrawElementsInstancedARB",
        "glDrawElementsInstancedEXT",
        "glDrawElementsInstancedBaseVertex",
        "glDrawElementsInstancedBaseInstance",
        "glDrawElementsInstancedBaseVertexBaseInstance",
        "glDrawRangeElements",
        "glDrawRangeElementsEXT",
        "glDrawRangeElementsBaseVertex",
        "glMultiDrawElements",
        "glMultiDrawElementsBaseVertex",
        "glMultiDrawElementsEXT",
        "glMultiModeDrawElementsIBM",
        'glMultiDrawElementsIndirect',
        'glMultiDrawElementsIndirectAMD',
    ])

    draw_indirect_function_names = set([
        "glDrawArraysIndirect",
        "glDrawElementsIndirect",
        'glMultiDrawArraysIndirect',
        'glMultiDrawArraysIndirectAMD',
        'glMultiDrawElementsIndirect',
        'glMultiDrawElementsIndirectAMD',
    ])

    misc_draw_function_names = set([
        "glCallList",
        "glCallLists",
        "glClear",
        "glEnd",
        "glDrawPixels",
        "glBlitFramebuffer",
        "glBlitFramebufferEXT",
    ])

    bind_framebuffer_function_names = set([
        "glBindFramebuffer",
        "glBindFramebufferEXT",
        "glBindFramebufferOES",
    ])

    # Names of the functions that can pack into the current pixel buffer
    # object.  See also the ARB_pixel_buffer_object specification.
    pack_function_names = set([
        'glGetCompressedTexImage',
        'glGetCompressedTexImageARB',
        'glGetCompressedTextureImageEXT',
        'glGetCompressedMultiTexImageEXT',
        'glGetConvolutionFilter',
        'glGetHistogram',
        'glGetMinmax',
        'glGetPixelMapfv',
        'glGetPixelMapuiv',
        'glGetPixelMapusv',
        'glGetPolygonStipple',
        'glGetSeparableFilter',
        'glGetTexImage',
        'glGetTextureImageEXT',
        'glGetMultiTexImageEXT',
        'glReadPixels',
        'glGetnCompressedTexImageARB',
        'glGetnConvolutionFilterARB',
        'glGetnHistogramARB',
        'glGetnMinmaxARB',
        'glGetnPixelMapfvARB',
        'glGetnPixelMapuivARB',
        'glGetnPixelMapusvARB',
        'glGetnPolygonStippleARB',
        'glGetnSeparableFilterARB',
        'glGetnTexImageARB',
        'glReadnPixelsARB',
    ])

    map_function_names = set([
        'glMapBuffer',
        'glMapBufferARB',
        'glMapBufferOES',
        'glMapBufferRange',
        'glMapNamedBufferEXT',
        'glMapNamedBufferRangeEXT',
        'glMapObjectBufferATI',
    ])

    unmap_function_names = set([
        'glUnmapBuffer',
        'glUnmapBufferARB',
        'glUnmapBufferOES',
        'glUnmapNamedBufferEXT',
        'glUnmapObjectBufferATI',
    ])

    def retraceFunctionBody(self, function):
        is_array_pointer = function.name in self.array_pointer_function_names
        is_draw_array = function.name in self.draw_array_function_names
        is_draw_elements = function.name in self.draw_elements_function_names
        is_misc_draw = function.name in self.misc_draw_function_names

        if is_array_pointer or is_draw_array or is_draw_elements:
            print '    if (retrace::parser.version < 1) {'

            if is_array_pointer or is_draw_array:
                print '        GLint _array_buffer = 0;'
                print '        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &_array_buffer);'
                print '        if (!_array_buffer) {'
                self.failFunction(function)
                print '        }'

            if is_draw_elements:
                print '        GLint _element_array_buffer = 0;'
                print '        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &_element_array_buffer);'
                print '        if (!_element_array_buffer) {'
                self.failFunction(function)
                print '        }'
            
            print '    }'

        # When no pack buffer object is bound, the pack functions are no-ops.
        if function.name in self.pack_function_names:
            print '    GLint _pack_buffer = 0;'
            print '    glGetIntegerv(GL_PIXEL_PACK_BUFFER_BINDING, &_pack_buffer);'
            print '    if (!_pack_buffer) {'
            print '        return;'
            print '    }'

        # Pre-snapshots
        if function.name in self.bind_framebuffer_function_names:
            print '    assert(call.flags & trace::CALL_FLAG_SWAP_RENDERTARGET);'
        if function.name == 'glStringMarkerGREMEDY':
            return
        if function.name == 'glFrameTerminatorGREMEDY':
            print '    glretrace::frame_complete(call);'
            return

        Retracer.retraceFunctionBody(self, function)

        # Post-snapshots
        if function.name in ('glFlush', 'glFinish'):
            print '    if (!retrace::doubleBuffer) {'
            print '        glretrace::frame_complete(call);'
            print '    }'
        if is_draw_array or is_draw_elements or is_misc_draw:
            print '    assert(call.flags & trace::CALL_FLAG_RENDER);'


    def invokeFunction(self, function):
        # Infer the drawable size from GL calls
        if function.name == "glViewport":
            print '    glretrace::updateDrawable(x + width, y + height);'
        if function.name == "glViewportArray":
            # We are concerned about drawables so only care for the first viewport
            print '    if (first == 0 && count > 0) {'
            print '        GLfloat x = v[0], y = v[1], w = v[2], h = v[3];'
            print '        glretrace::updateDrawable(x + w, y + h);'
            print '    }'
        if function.name == "glViewportIndexedf":
            print '    if (index == 0) {'
            print '        glretrace::updateDrawable(x + w, y + h);'
            print '    }'
        if function.name == "glViewportIndexedfv":
            print '    if (index == 0) {'
            print '        GLfloat x = v[0], y = v[1], w = v[2], h = v[3];'
            print '        glretrace::updateDrawable(x + w, y + h);'
            print '    }'
        if function.name in ('glBlitFramebuffer', 'glBlitFramebufferEXT'):
            # Some applications do all their rendering in a framebuffer, and
            # then just blit to the drawable without ever calling glViewport.
            print '    glretrace::updateDrawable(std::max(dstX0, dstX1), std::max(dstY0, dstY1));'

        if function.name == "glEnd":
            print '    glretrace::insideGlBeginEnd = false;'

        if function.name.startswith('gl') and not function.name.startswith('glX'):
            print r'    if (retrace::debug && !glretrace::getCurrentContext()) {'
            print r'        retrace::warning(call) << "no current context\n";'
            print r'    }'

        if function.name == 'memcpy':
            print '    if (!dest || !src || !n) return;'

        # Skip glEnable/Disable(GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB) as we don't
        # faithfully set the CONTEXT_DEBUG_BIT_ARB flags on context creation.
        if function.name in ('glEnable', 'glDisable'):
            print '    if (cap == GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB) return;'

        # Destroy the buffer mapping
        if function.name in self.unmap_function_names:
            print r'        GLvoid *ptr = NULL;'
            if function.name == 'glUnmapBuffer':
                print r'            glGetBufferPointerv(target, GL_BUFFER_MAP_POINTER, &ptr);'
            elif function.name == 'glUnmapBufferARB':
                print r'            glGetBufferPointervARB(target, GL_BUFFER_MAP_POINTER_ARB, &ptr);'
            elif function.name == 'glUnmapBufferOES':
                print r'            glGetBufferPointervOES(target, GL_BUFFER_MAP_POINTER_OES, &ptr);'
            elif function.name == 'glUnmapNamedBufferEXT':
                print r'            glGetNamedBufferPointervEXT(buffer, GL_BUFFER_MAP_POINTER, &ptr);'
            elif function.name == 'glUnmapObjectBufferATI':
                # TODO
                pass
            else:
                assert False
            print r'        if (ptr) {'
            print r'            retrace::delRegionByPointer(ptr);'
            print r'        } else {'
            print r'            retrace::warning(call) << "no current context\n";'
            print r'        }'

        if function.name in ('glBindProgramPipeline', 'glBindProgramPipelineEXT'):
            # Note if glBindProgramPipeline has ever been called
            print r'    if (pipeline) {'
            print r'        _pipelineHasBeenBound = true;'
            print r'    }'

        profileDraw = (
            function.name in self.draw_array_function_names or
            function.name in self.draw_elements_function_names or
            function.name in self.draw_indirect_function_names or
            function.name in self.misc_draw_function_names or
            function.name == 'glBegin'
        )

        if function.name in ('glUseProgram', 'glUseProgramObjectARB'):
            print r'    glretrace::Context *currentContext = glretrace::getCurrentContext();'
            print r'    if (currentContext) {'
            print r'        currentContext->activeProgram = call.arg(0).toUInt();'
            print r'    }'

        # Only profile if not inside a list as the queries get inserted into list
        if function.name == 'glNewList':
            print r'    glretrace::insideList = true;'

        if function.name == 'glEndList':
            print r'    glretrace::insideList = false;'

        if function.name != 'glEnd':
            print r'    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {'
            if profileDraw:
                print r'        glretrace::beginProfile(call, true);'
            else:
                print r'        glretrace::beginProfile(call, false);'
            print r'    }'

        if function.name == 'glCreateShaderProgramv':
            # When dumping state, break down glCreateShaderProgramv so that the
            # shader source can be recovered.
            print r'    if (retrace::dumpingState) {'
            print r'        GLuint _shader = glCreateShader(type);'
            print r'        if (_shader) {'
            print r'            glShaderSource(_shader, count, strings, NULL);'
            print r'            glCompileShader(_shader);'
            print r'            const GLuint _program = glCreateProgram();'
            print r'            if (_program) {'
            print r'                GLint compiled = GL_FALSE;'
            print r'                glGetShaderiv(_shader, GL_COMPILE_STATUS, &compiled);'
            print r'                glProgramParameteri(_program, GL_PROGRAM_SEPARABLE, GL_TRUE);'
            print r'                if (compiled) {'
            print r'                    glAttachShader(_program, _shader);'
            print r'                    glLinkProgram(_program);'
            print r'                    //glDetachShader(_program, _shader);'
            print r'                }'
            print r'                //append-shader-info-log-to-program-info-log'
            print r'            }'
            print r'            //glDeleteShader(_shader);'
            print r'            _result = _program;'
            print r'        } else {'
            print r'            _result = 0;'
            print r'        }'
            print r'    } else {'
            Retracer.invokeFunction(self, function)
            print r'    }'
        else:
            Retracer.invokeFunction(self, function)

        if function.name == "glBegin":
            print '    glretrace::insideGlBeginEnd = true;'

        print r'    if (!glretrace::insideList && !glretrace::insideGlBeginEnd && retrace::profiling) {'
        if profileDraw:
            print r'        glretrace::endProfile(call, true);'
        else:
            print r'        glretrace::endProfile(call, false);'
        print r'    }'

        # Error checking
        if function.name.startswith('gl'):
            # glGetError is not allowed inside glBegin/glEnd
            print '    if (retrace::debug && !glretrace::insideGlBeginEnd && glretrace::getCurrentContext()) {'
            print '        glretrace::checkGlError(call);'
            if function.name in ('glProgramStringARB', 'glProgramStringNV'):
                print r'        GLint error_position = -1;'
                print r'        glGetIntegerv(GL_PROGRAM_ERROR_POSITION_ARB, &error_position);'
                print r'        if (error_position != -1) {'
                print r'            const char *error_string = (const char *)glGetString(GL_PROGRAM_ERROR_STRING_ARB);'
                print r'            retrace::warning(call) << error_string << "\n";'
                print r'        }'
            if function.name == 'glCompileShader':
                print r'        GLint compile_status = 0;'
                print r'        glGetShaderiv(shader, GL_COMPILE_STATUS, &compile_status);'
                print r'        if (!compile_status) {'
                print r'             GLint info_log_length = 0;'
                print r'             glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &info_log_length);'
                print r'             GLchar *infoLog = new GLchar[info_log_length];'
                print r'             glGetShaderInfoLog(shader, info_log_length, NULL, infoLog);'
                print r'             retrace::warning(call) << infoLog << "\n";'
                print r'             delete [] infoLog;'
                print r'        }'
            if function.name in ('glLinkProgram', 'glCreateShaderProgramv', 'glCreateShaderProgramEXT'):
                if function.name != 'glLinkProgram':
                    print r'        GLuint program = _result;'
                print r'        GLint link_status = 0;'
                print r'        glGetProgramiv(program, GL_LINK_STATUS, &link_status);'
                print r'        if (!link_status) {'
                print r'             GLint info_log_length = 0;'
                print r'             glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);'
                print r'             GLchar *infoLog = new GLchar[info_log_length];'
                print r'             glGetProgramInfoLog(program, info_log_length, NULL, infoLog);'
                print r'             retrace::warning(call) << infoLog << "\n";'
                print r'             delete [] infoLog;'
                print r'        }'
            if function.name == 'glCompileShaderARB':
                print r'        GLint compile_status = 0;'
                print r'        glGetObjectParameterivARB(shaderObj, GL_OBJECT_COMPILE_STATUS_ARB, &compile_status);'
                print r'        if (!compile_status) {'
                print r'             GLint info_log_length = 0;'
                print r'             glGetObjectParameterivARB(shaderObj, GL_OBJECT_INFO_LOG_LENGTH_ARB, &info_log_length);'
                print r'             GLchar *infoLog = new GLchar[info_log_length];'
                print r'             glGetInfoLogARB(shaderObj, info_log_length, NULL, infoLog);'
                print r'             retrace::warning(call) << infoLog << "\n";'
                print r'             delete [] infoLog;'
                print r'        }'
            if function.name == 'glLinkProgramARB':
                print r'        GLint link_status = 0;'
                print r'        glGetObjectParameterivARB(programObj, GL_OBJECT_LINK_STATUS_ARB, &link_status);'
                print r'        if (!link_status) {'
                print r'             GLint info_log_length = 0;'
                print r'             glGetObjectParameterivARB(programObj, GL_OBJECT_INFO_LOG_LENGTH_ARB, &info_log_length);'
                print r'             GLchar *infoLog = new GLchar[info_log_length];'
                print r'             glGetInfoLogARB(programObj, info_log_length, NULL, infoLog);'
                print r'             retrace::warning(call) << infoLog << "\n";'
                print r'             delete [] infoLog;'
                print r'        }'
            if function.name in self.map_function_names:
                print r'        if (!_result) {'
                print r'             retrace::warning(call) << "failed to map buffer\n";'
                print r'        }'
            if function.name in self.unmap_function_names and function.type is not stdapi.Void:
                print r'        if (!_result) {'
                print r'             retrace::warning(call) << "failed to unmap buffer\n";'
                print r'        }'
            if function.name in ('glGetAttribLocation', 'glGetAttribLocationARB'):
                print r'    GLint _origResult = call.ret->toSInt();'
                print r'    if (_result != _origResult) {'
                print r'        retrace::warning(call) << "vertex attrib location mismatch " << _origResult << " -> " << _result << "\n";'
                print r'    }'
            if function.name in ('glCheckFramebufferStatus', 'glCheckFramebufferStatusEXT', 'glCheckNamedFramebufferStatusEXT'):
                print r'    GLint _origResult = call.ret->toSInt();'
                print r'    if (_origResult == GL_FRAMEBUFFER_COMPLETE &&'
                print r'        _result != GL_FRAMEBUFFER_COMPLETE) {'
                print r'        retrace::warning(call) << "incomplete framebuffer (" << glstate::enumToString(_result) << ")\n";'
                print r'    }'
            print '    }'

        # Query the buffer length for whole buffer mappings
        if function.name in self.map_function_names:
            if 'length' in function.argNames():
                assert 'BufferRange' in function.name
            else:
                assert 'BufferRange' not in function.name
                print r'    GLint length = 0;'
                if function.name in ('glMapBuffer', 'glMapBufferOES'):
                    print r'    glGetBufferParameteriv(target, GL_BUFFER_SIZE, &length);'
                elif function.name == 'glMapBufferARB':
                    print r'    glGetBufferParameterivARB(target, GL_BUFFER_SIZE_ARB, &length);'
                elif function.name == 'glMapNamedBufferEXT':
                    print r'    glGetNamedBufferParameterivEXT(buffer, GL_BUFFER_SIZE, &length);'
                elif function.name == 'glMapObjectBufferATI':
                    print r'    glGetObjectBufferivATI(buffer, GL_OBJECT_BUFFER_SIZE_ATI, &length);'
                else:
                    assert False

    def extractArg(self, function, arg, arg_type, lvalue, rvalue):
        if function.name in self.array_pointer_function_names and arg.name == 'pointer':
            print '    %s = static_cast<%s>(retrace::toPointer(%s, true));' % (lvalue, arg_type, rvalue)
            return

        if function.name in self.draw_elements_function_names and arg.name == 'indices' or\
           function.name in self.draw_indirect_function_names and arg.name == 'indirect':
            self.extractOpaqueArg(function, arg, arg_type, lvalue, rvalue)
            return

        # Handle pointer with offsets into the current pack pixel buffer
        # object.
        if function.name in self.pack_function_names and arg.output:
            assert isinstance(arg_type, (stdapi.Pointer, stdapi.Array, stdapi.Blob, stdapi.Opaque))
            print '    %s = static_cast<%s>((%s).toPointer());' % (lvalue, arg_type, rvalue)
            return

        if arg.type is glapi.GLlocation \
           and 'program' not in function.argNames():
            # Determine the active program for uniforms swizzling
            print '    GLint program = -1;'
            print '    if (glretrace::insideList) {'
            print '        // glUseProgram & glUseProgramObjectARB are display-list-able'
            print r'    glretrace::Context *currentContext = glretrace::getCurrentContext();'
            print '        program = _program_map[currentContext->activeProgram];'
            print '    } else {'
            print '        GLint pipeline = 0;'
            print '        if (_pipelineHasBeenBound) {'
            print '            glGetIntegerv(GL_PROGRAM_PIPELINE_BINDING, &pipeline);'
            print '        }'
            print '        if (pipeline) {'
            print '            glGetProgramPipelineiv(pipeline, GL_ACTIVE_PROGRAM, &program);'
            print '        } else {'
            print '            glGetIntegerv(GL_CURRENT_PROGRAM, &program);'
            print '        }'
            print '    }'
            print

        if arg.type is glapi.GLlocationARB \
           and 'programObj' not in function.argNames():
            print '    GLhandleARB programObj = glGetHandleARB(GL_PROGRAM_OBJECT_ARB);'

        Retracer.extractArg(self, function, arg, arg_type, lvalue, rvalue)

        # Don't try to use more samples than the implementation supports
        if arg.name == 'samples':
            assert arg.type is glapi.GLsizei
            print '    GLint max_samples = 0;'
            print '    glGetIntegerv(GL_MAX_SAMPLES, &max_samples);'
            print '    if (samples > max_samples) {'
            print '        samples = max_samples;'
            print '    }'

        # These parameters are referred beyond the call life-time
        # TODO: Replace ad-hoc solution for bindable parameters with general one
        if function.name in ('glFeedbackBuffer', 'glSelectBuffer') and arg.output:
            print '    _allocator.bind(%s);' % arg.name



if __name__ == '__main__':
    print r'''
#include <string.h>

#include "glproc.hpp"
#include "glretrace.hpp"
#include "glstate.hpp"


static bool _pipelineHasBeenBound = false;
'''
    api = stdapi.API()
    api.addModule(glapi.glapi)
    api.addModule(glesapi.glesapi)
    retracer = GlRetracer()
    retracer.retraceApi(api)

########NEW FILE########
__FILENAME__ = glstate_params
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


'''Generate code to dump most GL state into JSON.'''


import retrace # to adjust sys.path

from specs.stdapi import *

from specs.gltypes import *
from specs.glparams import *


framebuffer_targets = [
    ('GL_DRAW_FRAMEBUFFER', 'GL_DRAW_FRAMEBUFFER_BINDING'),
    ('GL_READ_FRAMEBUFFER', 'GL_READ_FRAMEBUFFER_BINDING'),
]

class GetInflector:
    '''Objects that describes how to inflect.'''

    reduced_types = {
        B: I,
        E: I,
        I: F,
    }

    def __init__(self, radical, inflections, suffix = ''):
        self.radical = radical
        self.inflections = inflections
        self.suffix = suffix

    def reduced_type(self, type):
        if type in self.inflections:
            return type
        if type in self.reduced_types:
            return self.reduced_type(self.reduced_types[type])
        raise NotImplementedError

    def inflect(self, type):
        return self.radical + self.inflection(type) + self.suffix

    def inflection(self, type):
        type = self.reduced_type(type)
        assert type in self.inflections
        return self.inflections[type]

    def __str__(self):
        return self.radical + self.suffix


class StateGetter(Visitor):
    '''Type visitor that is able to extract the state via one of the glGet*
    functions.

    It will declare any temporary variable
    '''

    def __init__(self, radical, inflections, suffix=''):
        self.inflector = GetInflector(radical, inflections)
        self.suffix = suffix

    def iter(self):
        for function, type, count, name in parameters:
            inflection = self.inflector.radical + self.suffix
            if inflection not in function.split(','):
                continue
            if type is X:
                continue
            yield type, count, name

    def __call__(self, *args):
        pname = args[-1]

        for type, count, name in self.iter():
            if name == pname:
                if count != 1:
                    type = Array(type, str(count))

                return type, self.visit(type, args)

        raise NotImplementedError

    def temp_name(self, args):
        '''Return the name of a temporary variable to hold the state.'''
        pname = args[-1]

        return pname[3:].lower()

    def visitConst(self, const, args):
        return self.visit(const.type, args)

    def visitScalar(self, type, args):
        temp_name = self.temp_name(args)
        elem_type = self.inflector.reduced_type(type)
        inflection = self.inflector.inflect(type)
        if inflection.endswith('v'):
            print '    %s %s = 0;' % (elem_type, temp_name)
            print '    %s(%s, &%s);' % (inflection + self.suffix, ', '.join(args), temp_name)
        else:
            print '    %s %s = %s(%s);' % (elem_type, temp_name, inflection + self.suffix, ', '.join(args))
        return temp_name

    def visitString(self, string, args):
        temp_name = self.temp_name(args)
        inflection = self.inflector.inflect(string)
        assert not inflection.endswith('v')
        print '    %s %s = (%s)%s(%s);' % (string, temp_name, string, inflection + self.suffix, ', '.join(args))
        return temp_name

    def visitAlias(self, alias, args):
        return self.visitScalar(alias, args)

    def visitEnum(self, enum, args):
        return self.visitScalar(enum, args)

    def visitBitmask(self, bitmask, args):
        return self.visit(GLint, args)

    def visitArray(self, array, args):
        temp_name = self.temp_name(args)
        if array.length == '1':
            return self.visit(array.type)
        elem_type = self.inflector.reduced_type(array.type)
        inflection = self.inflector.inflect(array.type)
        assert inflection.endswith('v')
        array_length = array.length
        if array_length.isdigit():
            # Static integer length
            print '    %s %s[%s + 1];' % (elem_type, temp_name, array_length)
        else:
            # Put the length in a variable to avoid recomputing it every time
            print '    size_t _%s_length = %s;' % (temp_name, array_length)
            array_length = '_%s_length' % temp_name
            # Allocate a dynamic sized array
            print '    %s *%s = _allocator.alloc<%s>(%s + 1);' % (elem_type, temp_name, elem_type, array_length)
        print '    memset(%s, 0, %s * sizeof *%s);' % (temp_name, array_length, temp_name)
        print '    %s[%s] = (%s)0xdeadc0de;' % (temp_name, array_length, elem_type)
        print '    if (%s) {' % array_length
        print '        %s(%s, %s);' % (inflection + self.suffix, ', '.join(args), temp_name)
        print '    }'
        # Simple buffer overflow detection
        print '    assert(%s[%s] == (%s)0xdeadc0de);' % (temp_name, array_length, elem_type)
        return temp_name

    def visitOpaque(self, pointer, args):
        temp_name = self.temp_name(args)
        inflection = self.inflector.inflect(pointer)
        assert inflection.endswith('v')
        print '    GLvoid *%s;' % temp_name
        print '    %s(%s, &%s);' % (inflection + self.suffix, ', '.join(args), temp_name)
        return temp_name


glGet = StateGetter('glGet', {
    B: 'Booleanv',
    I: 'Integerv',
    F: 'Floatv',
    D: 'Doublev',
    S: 'String',
    P: 'Pointerv',
})

glGetMaterial = StateGetter('glGetMaterial', {I: 'iv', F: 'fv'})
glGetLight = StateGetter('glGetLight', {I: 'iv', F: 'fv'})
glGetVertexAttrib = StateGetter('glGetVertexAttrib', {I: 'iv', F: 'fv', D: 'dv', P: 'Pointerv'})
glGetTexParameter = StateGetter('glGetTexParameter', {I: 'iv', F: 'fv'})
glGetTexEnv = StateGetter('glGetTexEnv', {I: 'iv', F: 'fv'})
glGetTexLevelParameter = StateGetter('glGetTexLevelParameter', {I: 'iv', F: 'fv'})
glGetShader = StateGetter('glGetShaderiv', {I: 'iv'})
glGetProgram = StateGetter('glGetProgram', {I: 'iv'})
glGetProgramARB = StateGetter('glGetProgram', {I: 'iv', F: 'fv', S: 'Stringv'}, 'ARB')
glGetFramebufferAttachmentParameter = StateGetter('glGetFramebufferAttachmentParameter', {I: 'iv'})
glGetSamplerParameter = StateGetter('glGetSamplerParameter', {I: 'iv', F: 'fv'})


class JsonWriter(Visitor):
    '''Type visitor that will dump a value of the specified type through the
    JSON writer.
    
    It expects a previously declared JSONWriter instance named "json".'''

    def visitLiteral(self, literal, instance):
        if literal.kind == 'Bool':
            print '    json.writeBool(%s);' % instance
        elif literal.kind in ('SInt', 'Uint'):
            print '    json.writeInt(%s);' % instance
        elif literal.kind in ('Float', 'Double'):
            print '    json.writeFloat(%s);' % instance
        else:
            raise NotImplementedError

    def visitString(self, string, instance):
        assert string.length is None
        print '    json.writeString((const char *)%s);' % instance

    def visitEnum(self, enum, instance):
        if enum is GLboolean:
            print '    dumpBoolean(json, %s);' % instance
        elif enum is GLenum:
            print '    dumpEnum(json, %s);' % instance
        else:
            assert False
            print '    json.writeInt(%s);' % instance

    def visitBitmask(self, bitmask, instance):
        raise NotImplementedError

    def visitAlias(self, alias, instance):
        self.visit(alias.type, instance)

    def visitOpaque(self, opaque, instance):
        print '    json.writeInt((size_t)%s);' % instance

    __index = 0

    def visitArray(self, array, instance):
        index = '_i%u' % JsonWriter.__index
        JsonWriter.__index += 1
        print '    json.beginArray();'
        print '    for (unsigned %s = 0; %s < %s; ++%s) {' % (index, index, array.length, index)
        self.visit(array.type, '%s[%s]' % (instance, index))
        print '    }'
        print '    json.endArray();'



class StateDumper:
    '''Class to generate code to dump all GL state in JSON format via
    stdout.'''

    def __init__(self):
        pass

    def dump(self):
        print '#include <assert.h>'
        print '#include <string.h>'
        print
        print '#include "json.hpp"'
        print '#include "scoped_allocator.hpp"'
        print '#include "glproc.hpp"'
        print '#include "glsize.hpp"'
        print '#include "glstate.hpp"'
        print '#include "glstate_internal.hpp"'
        print
        print 'namespace glstate {'
        print

        print 'static void'
        print 'flushErrors(void) {'
        print '    while (glGetError() != GL_NO_ERROR) {}'
        print '}'
        print

        print 'void'
        print 'dumpBoolean(JSONWriter &json, GLboolean value)'
        print '{'
        print '    switch (value) {'
        print '    case GL_FALSE:'
        print '        json.writeString("GL_FALSE");'
        print '        break;'
        print '    case GL_TRUE:'
        print '        json.writeString("GL_TRUE");'
        print '        break;'
        print '    default:'
        print '        json.writeInt(static_cast<GLint>(value));'
        print '        break;'
        print '    }'
        print '}'
        print

        print 'const char *'
        print 'enumToString(GLenum pname)'
        print '{'
        print '    switch (pname) {'
        for name in GLenum.values:
            print '    case %s:' % name
            print '        return "%s";' % name
        print '    default:'
        print '        return NULL;'
        print '    }'
        print '}'
        print

        print 'void'
        print 'dumpEnum(JSONWriter &json, GLenum pname)'
        print '{'
        print '    const char *s = enumToString(pname);'
        print '    if (s) {'
        print '        json.writeString(s);'
        print '    } else {'
        print '        json.writeInt(pname);'
        print '    }'
        print '}'
        print

        print 'static void'
        print 'dumpTextureTargetParameters(JSONWriter &json, Context &context, GLenum target)'
        print '{'
        print '    GLenum binding_param = getTextureBinding(target);'
        print '    GLboolean enabled = GL_FALSE;'
        print '    GLint binding = 0;'
        print '    glGetBooleanv(target, &enabled);'
        print '    json.beginMember(enumToString(target));'
        print '    dumpBoolean(json, enabled);'
        print '    json.endMember();'
        print '    glGetIntegerv(binding_param, &binding);'
        print '    json.writeIntMember(enumToString(binding_param), binding);'
        print '    if (enabled || binding) {'
        print '        json.beginMember(enumToString(target));'
        print '        json.beginObject();'
        print '        dumpObjectLabel(json, context, GL_TEXTURE, binding, "GL_TEXTURE_LABEL");'
        self.dump_atoms(glGetTexParameter, 'target')
        print '        if (!context.ES) {'
        print '            GLenum levelTarget;'
        print '            if (target == GL_TEXTURE_CUBE_MAP ||'
        print '                target == GL_TEXTURE_CUBE_MAP_ARRAY) {'
        print '                // Must pick a face'
        print '                levelTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X;'
        print '            } else {'
        print '                levelTarget = target;'
        print '            }'
        self.dump_atoms(glGetTexLevelParameter, 'levelTarget', '0')
        print '        }'
        print '        json.endObject();'
        print '        json.endMember(); // target'
        print '    }'
        print '}'
        print

        print 'static void'
        print 'dumpFramebufferAttachementParameters(JSONWriter &json, Context &context, GLenum target, GLenum attachment)'
        print '{'
        self.dump_attachment_parameters('target', 'attachment')
        print '}'
        print

        print 'void dumpParameters(JSONWriter &json, Context &context)'
        print '{'
        print '    ScopedAllocator _allocator;'
        print '    (void)_allocator;'
        print
        print '    json.beginMember("parameters");'
        print '    json.beginObject();'
        
        self.dump_atoms(glGet)
        
        self.dump_material_params()
        self.dump_light_params()
        self.dump_vertex_attribs()
        self.dump_program_params()
        self.dump_texture_parameters()
        self.dump_framebuffer_parameters()
        self.dump_labels()

        print '    json.endObject();'
        print '    json.endMember(); // parameters'
        print '}'
        print
        
        print '} /*namespace glstate */'

    def dump_material_params(self):
        print '    if (!context.ES) {'
        for face in ['GL_FRONT', 'GL_BACK']:
            print '    json.beginMember("%s");' % face
            print '    json.beginObject();'
            self.dump_atoms(glGetMaterial, face)
            print '    json.endObject();'
        print '    }'
        print

    def dump_light_params(self):
        print '    GLint max_lights = 0;'
        print '    _glGetIntegerv(GL_MAX_LIGHTS, &max_lights);'
        print '    for (GLint index = 0; index < max_lights; ++index) {'
        print '        GLenum light = GL_LIGHT0 + index;'
        print '        if (glIsEnabled(light)) {'
        print '            char name[32];'
        print '            snprintf(name, sizeof name, "GL_LIGHT%i", index);'
        print '            json.beginMember(name);'
        print '            json.beginObject();'
        self.dump_atoms(glGetLight, '    GL_LIGHT0 + index')
        print '            json.endObject();'
        print '            json.endMember(); // GL_LIGHTi'
        print '        }'
        print '    }'
        print

    def dump_sampler_params(self):
        print '    // GL_SAMPLER_BINDING'
        print '    if (context.ARB_sampler_objects) {'
        print '        GLint sampler_binding = 0;'
        print '        glGetIntegerv(GL_SAMPLER_BINDING, &sampler_binding);'
        print '        json.beginMember("GL_SAMPLER_BINDING");'
        print '        json.writeInt(sampler_binding);'
        print '        json.endMember();'
        print '        if (sampler_binding) {'
        print '            json.beginMember("GL_SAMPLER");'
        print '            json.beginObject();'
        print '            dumpObjectLabel(json, context, GL_SAMPLER, sampler_binding, "GL_SAMPLER_LABEL");'
        for _, _, name in glGetSamplerParameter.iter():
            self.dump_atom(glGetSamplerParameter, 'sampler_binding', name)
        print '           json.endObject();'
        print '           json.endMember(); // GL_SAMPLER'
        print '       }'
        print '    }'

    def texenv_param_target(self, name):
        if name == 'GL_TEXTURE_LOD_BIAS':
           return 'GL_TEXTURE_FILTER_CONTROL'
        elif name == 'GL_COORD_REPLACE':
           return 'GL_POINT_SPRITE'
        else:
           return 'GL_TEXTURE_ENV'

    def dump_texenv_params(self):
        for target in ['GL_TEXTURE_ENV', 'GL_TEXTURE_FILTER_CONTROL', 'GL_POINT_SPRITE']:
            print '    if (!context.ES) {'
            print '        json.beginMember("%s");' % target
            print '        json.beginObject();'
            for _, _, name in glGetTexEnv.iter():
                if self.texenv_param_target(name) == target:
                    self.dump_atom(glGetTexEnv, target, name) 
            print '        json.endObject();'
            print '    }'

    def dump_vertex_attribs(self):
        print '    GLint max_vertex_attribs = 0;'
        print '    _glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &max_vertex_attribs);'
        print '    for (GLint index = 0; index < max_vertex_attribs; ++index) {'
        print '        char name[32];'
        print '        snprintf(name, sizeof name, "GL_VERTEX_ATTRIB_ARRAY%i", index);'
        print '        json.beginMember(name);'
        print '        json.beginObject();'
        self.dump_atoms(glGetVertexAttrib, 'index')
        
        # Dump vertex attrib buffer label
        print '        GLint buffer_binding = 0;'
        print '        glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, &buffer_binding);'
        print '        dumpObjectLabel(json, context, GL_BUFFER, buffer_binding, "GL_VERTEX_ATTRIB_ARRAY_BUFFER_LABEL");'

        print '        json.endObject();'
        print '        json.endMember(); // GL_VERTEX_ATTRIB_ARRAYi'
        print '    }'
        print

    object_bindings = [
        ('GL_BUFFER', 'GL_ARRAY_BUFFER_BINDING'),
        ('GL_BUFFER', 'GL_COLOR_ARRAY_BUFFER_BINDING'),
        ('GL_BUFFER', 'GL_EDGE_FLAG_ARRAY_BUFFER_BINDING'),
        ('GL_BUFFER', 'GL_ELEMENT_ARRAY_BUFFER_BINDING'),
        ('GL_BUFFER', 'GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING'),
        ('GL_BUFFER', 'GL_INDEX_ARRAY_BUFFER_BINDING'),
        ('GL_BUFFER', 'GL_NORMAL_ARRAY_BUFFER_BINDING'),
        ('GL_BUFFER', 'GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING'),
        ('GL_BUFFER', 'GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING'),
        ('GL_BUFFER', 'GL_TRANSFORM_FEEDBACK_BUFFER_BINDING'),
        ('GL_BUFFER', 'GL_VERTEX_ARRAY_BUFFER_BINDING'),
        ('GL_BUFFER', 'GL_WEIGHT_ARRAY_BUFFER_BINDING'),
        ('GL_FRAMEBUFFER', 'GL_DRAW_FRAMEBUFFER_BINDING'),
        ('GL_FRAMEBUFFER', 'GL_READ_FRAMEBUFFER_BINDING'),
        ('GL_PROGRAM', 'GL_CURRENT_PROGRAM'),
        ('GL_PROGRAM_PIPELINE', 'GL_PROGRAM_PIPELINE_BINDING'),
        ('GL_RENDERBUFFER', 'GL_RENDERBUFFER_BINDING'),
        ('GL_TRANSFORM_FEEDBACK', 'GL_TRANSFORM_FEEDBACK_BINDING'),
        ('GL_VERTEX_ARRAY', 'GL_VERTEX_ARRAY_BINDING'),
    ]

    def dump_labels(self):
        for object_type, object_binding in self.object_bindings:
            member_name = object_binding.replace('BINDING', 'LABEL')
            if member_name == object_binding:
                member_name += '_LABEL'
            print '    {'
            print '        GLint binding = 0;'
            print '        glGetIntegerv(%s, &binding);' % object_binding
            print '        dumpObjectLabel(json, context, %s, binding, "%s");' % (object_type, member_name)
            print '    }'

    program_targets = [
        'GL_FRAGMENT_PROGRAM_ARB',
        'GL_VERTEX_PROGRAM_ARB',
    ]

    def dump_program_params(self):
        for target in self.program_targets:
            print '    if (glIsEnabled(%s)) {' % target
            print '        json.beginMember("%s");' % target
            print '        json.beginObject();'
            self.dump_atoms(glGetProgramARB, target)
            print '        json.endObject();'
            print '    }'

    def dump_texture_parameters(self):
        print '    {'
        print '        GLint active_texture = GL_TEXTURE0;'
        print '        glGetIntegerv(GL_ACTIVE_TEXTURE, &active_texture);'
        print '        GLint max_texture_coords = 0;'
        print '        glGetIntegerv(GL_MAX_TEXTURE_COORDS, &max_texture_coords);'
        print '        GLint max_combined_texture_image_units = 0;'
        print '        glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, &max_combined_texture_image_units);'
        print '        GLint max_units = std::max(std::max(max_combined_texture_image_units, max_texture_coords), 2);'
        print '        for (GLint unit = 0; unit < max_units; ++unit) {'
        print '            char name[32];'
        print '            snprintf(name, sizeof name, "GL_TEXTURE%i", unit);'
        print '            json.beginMember(name);'
        print '            glActiveTexture(GL_TEXTURE0 + unit);'
        print '            json.beginObject();'
        print
        print '            for (unsigned i = 0; i < numTextureTargets; ++i) {'
        print '                GLenum target = textureTargets[i];'
        print '                dumpTextureTargetParameters(json, context, target);'
        print '            }'
        print
        self.dump_sampler_params()
        print
        print '            if (unit < max_texture_coords) {'
        self.dump_texenv_params()
        print '            }'
        print '            json.endObject();'
        print '            json.endMember(); // GL_TEXTUREi'
        print '        }'
        print '        glActiveTexture(active_texture);'
        print '    }'
        print

    def dump_framebuffer_parameters(self):
        print '    {'
        print '        GLint max_color_attachments = 0;'
        print '        glGetIntegerv(GL_MAX_COLOR_ATTACHMENTS, &max_color_attachments);'
        print '        GLint framebuffer;'
        for target, binding in framebuffer_targets:
            print '            // %s' % target
            print '            framebuffer = 0;'
            print '            glGetIntegerv(%s, &framebuffer);' % binding
            print '            if (framebuffer) {'
            print '                json.beginMember("%s");' % target
            print '                json.beginObject();'
            print '                dumpObjectLabel(json, context, GL_FRAMEBUFFER, framebuffer, "GL_FRAMEBUFFER_LABEL");'
            print '                for (GLint i = 0; i < max_color_attachments; ++i) {'
            print '                    GLint color_attachment = GL_COLOR_ATTACHMENT0 + i;'
            print '                    dumpFramebufferAttachementParameters(json, context, %s, color_attachment);' % target
            print '                }'
            print '                dumpFramebufferAttachementParameters(json, context, %s, GL_DEPTH_ATTACHMENT);' % target
            print '                dumpFramebufferAttachementParameters(json, context, %s, GL_STENCIL_ATTACHMENT);' % target
            print '                json.endObject();'
            print '                json.endMember(); // %s' % target
            print '            }'
            print
        print '    }'
        print

    def dump_attachment_parameters(self, target, attachment):
        print '            {'
        print '                GLint object_type = GL_NONE;'
        print '                glGetFramebufferAttachmentParameteriv(%s, %s, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, &object_type);' % (target, attachment)
        print '                if (object_type != GL_NONE) {'
        print '                    json.beginMember(enumToString(%s));' % attachment
        print '                    json.beginObject();'
        self.dump_atoms(glGetFramebufferAttachmentParameter, target, attachment)
        print '                    GLint object_name = 0;'
        print '                    glGetFramebufferAttachmentParameteriv(%s, %s, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, &object_name);' % (target, attachment)
        print '                    dumpObjectLabel(json, context, object_type, object_name, "GL_FRAMEBUFFER_ATTACHMENT_OBJECT_LABEL");'
        print '                    json.endObject();'
        print '                    json.endMember(); // GL_x_ATTACHMENT'
        print '                }'
        print '            }'

    def dump_atoms(self, getter, *args):
        for _, _, name in getter.iter():
            self.dump_atom(getter, *(args + (name,)))

    def dump_atom(self, getter, *args):
        name = args[-1]

        print '        // %s' % name
        print '        {'
        print '            flushErrors();'
        type, value = getter(*args)
        print '            if (glGetError() != GL_NO_ERROR) {'
        #print '                std::cerr << "warning: %s(%s) failed\\n";' % (inflection, name)
        print '                flushErrors();'
        print '            } else {'
        print '                json.beginMember("%s");' % name
        JsonWriter().visit(type, value)
        print '                json.endMember();'
        print '            }'
        print '        }'
        print


if __name__ == '__main__':
    StateDumper().dump()

########NEW FILE########
__FILENAME__ = retrace
##########################################################################
#
# Copyright 2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""Generic retracing code generator."""


# Adjust path
import os.path
import sys
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))


import specs.stdapi as stdapi


class UnsupportedType(Exception):
    pass


def lookupHandle(handle, value, lval=False):
    if handle.key is None:
        return "_%s_map[%s]" % (handle.name, value)
    else:
        key_name, key_type = handle.key
        if handle.name == "location" and lval == False:
            return "_location_map[%s].lookupUniformLocation(%s)" % (key_name, value)
        else:
            return "_%s_map[%s][%s]" % (handle.name, key_name, value)


class ValueAllocator(stdapi.Visitor):

    def visitLiteral(self, literal, lvalue, rvalue):
        pass

    def visitConst(self, const, lvalue, rvalue):
        self.visit(const.type, lvalue, rvalue)

    def visitAlias(self, alias, lvalue, rvalue):
        self.visit(alias.type, lvalue, rvalue)

    def visitEnum(self, enum, lvalue, rvalue):
        pass

    def visitBitmask(self, bitmask, lvalue, rvalue):
        pass

    def visitArray(self, array, lvalue, rvalue):
        print '    %s = static_cast<%s *>(_allocator.alloc(&%s, sizeof *%s));' % (lvalue, array.type, rvalue, lvalue)

    def visitPointer(self, pointer, lvalue, rvalue):
        print '    %s = static_cast<%s *>(_allocator.alloc(&%s, sizeof *%s));' % (lvalue, pointer.type, rvalue, lvalue)

    def visitIntPointer(self, pointer, lvalue, rvalue):
        pass

    def visitObjPointer(self, pointer, lvalue, rvalue):
        pass

    def visitLinearPointer(self, pointer, lvalue, rvalue):
        pass

    def visitReference(self, reference, lvalue, rvalue):
        self.visit(reference.type, lvalue, rvalue);

    def visitHandle(self, handle, lvalue, rvalue):
        pass

    def visitBlob(self, blob, lvalue, rvalue):
        pass

    def visitString(self, string, lvalue, rvalue):
        pass

    def visitStruct(self, struct, lvalue, rvalue):
        pass

    def visitPolymorphic(self, polymorphic, lvalue, rvalue):
        assert polymorphic.defaultType is not None
        self.visit(polymorphic.defaultType, lvalue, rvalue)

    def visitOpaque(self, opaque, lvalue, rvalue):
        pass


class ValueDeserializer(stdapi.Visitor, stdapi.ExpanderMixin):

    def visitLiteral(self, literal, lvalue, rvalue):
        print '    %s = (%s).to%s();' % (lvalue, rvalue, literal.kind)

    def visitConst(self, const, lvalue, rvalue):
        self.visit(const.type, lvalue, rvalue)

    def visitAlias(self, alias, lvalue, rvalue):
        self.visit(alias.type, lvalue, rvalue)
    
    def visitEnum(self, enum, lvalue, rvalue):
        print '    %s = static_cast<%s>((%s).toSInt());' % (lvalue, enum, rvalue)

    def visitBitmask(self, bitmask, lvalue, rvalue):
        self.visit(bitmask.type, lvalue, rvalue)

    def visitArray(self, array, lvalue, rvalue):

        tmp = '_a_' + array.tag + '_' + str(self.seq)
        self.seq += 1

        print '    if (%s) {' % (lvalue,)
        print '        const trace::Array *%s = (%s).toArray();' % (tmp, rvalue)
        length = '%s->values.size()' % (tmp,)
        index = '_j' + array.tag
        print '        for (size_t {i} = 0; {i} < {length}; ++{i}) {{'.format(i = index, length = length)
        try:
            self.visit(array.type, '%s[%s]' % (lvalue, index), '*%s->values[%s]' % (tmp, index))
        finally:
            print '        }'
            print '    }'
    
    def visitPointer(self, pointer, lvalue, rvalue):
        tmp = '_a_' + pointer.tag + '_' + str(self.seq)
        self.seq += 1

        print '    if (%s) {' % (lvalue,)
        print '        const trace::Array *%s = (%s).toArray();' % (tmp, rvalue)
        try:
            self.visit(pointer.type, '%s[0]' % (lvalue,), '*%s->values[0]' % (tmp,))
        finally:
            print '    }'

    def visitIntPointer(self, pointer, lvalue, rvalue):
        print '    %s = static_cast<%s>((%s).toPointer());' % (lvalue, pointer, rvalue)

    def visitObjPointer(self, pointer, lvalue, rvalue):
        print '    %s = static_cast<%s>(retrace::toObjPointer(call, %s));' % (lvalue, pointer, rvalue)

    def visitLinearPointer(self, pointer, lvalue, rvalue):
        print '    %s = static_cast<%s>(retrace::toPointer(%s));' % (lvalue, pointer, rvalue)

    def visitReference(self, reference, lvalue, rvalue):
        self.visit(reference.type, lvalue, rvalue);

    def visitHandle(self, handle, lvalue, rvalue):
        #OpaqueValueDeserializer().visit(handle.type, lvalue, rvalue);
        self.visit(handle.type, lvalue, rvalue);
        new_lvalue = lookupHandle(handle, lvalue)
        print '    if (retrace::verbosity >= 2) {'
        print '        std::cout << "%s " << size_t(%s) << " <- " << size_t(%s) << "\\n";' % (handle.name, lvalue, new_lvalue)
        print '    }'
        if (new_lvalue.startswith('_program_map') or new_lvalue.startswith('_shader_map')):
            print 'if (glretrace::supportsARBShaderObjects) {'
            print '    %s = _handleARB_map[%s];' % (lvalue, lvalue)
            print '} else {'
            print '    %s = %s;' % (lvalue, new_lvalue)
            print '}'
        else:
            print '    %s = %s;' % (lvalue, new_lvalue)
    
    def visitBlob(self, blob, lvalue, rvalue):
        print '    %s = static_cast<%s>((%s).toPointer());' % (lvalue, blob, rvalue)
    
    def visitString(self, string, lvalue, rvalue):
        print '    %s = (%s)((%s).toString());' % (lvalue, string.expr, rvalue)

    seq = 0

    def visitStruct(self, struct, lvalue, rvalue):
        tmp = '_s_' + struct.tag + '_' + str(self.seq)
        self.seq += 1

        print '    const trace::Struct *%s = (%s).toStruct();' % (tmp, rvalue)
        print '    assert(%s);' % (tmp)
        for i in range(len(struct.members)):
            member = struct.members[i]
            self.visitMember(member, lvalue, '*%s->members[%s]' % (tmp, i))

    def visitPolymorphic(self, polymorphic, lvalue, rvalue):
        if polymorphic.defaultType is None:
            switchExpr = self.expand(polymorphic.switchExpr)
            print r'    switch (%s) {' % switchExpr
            for cases, type in polymorphic.iterSwitch():
                for case in cases:
                    print r'    %s:' % case
                caseLvalue = lvalue
                if type.expr is not None:
                    caseLvalue = 'static_cast<%s>(%s)' % (type, caseLvalue)
                print r'        {'
                try:
                    self.visit(type, caseLvalue, rvalue)
                finally:
                    print r'        }'
                print r'        break;'
            if polymorphic.defaultType is None:
                print r'    default:'
                print r'        retrace::warning(call) << "unexpected polymorphic case" << %s << "\n";' % (switchExpr,)
                print r'        break;'
            print r'    }'
        else:
            self.visit(polymorphic.defaultType, lvalue, rvalue)
    
    def visitOpaque(self, opaque, lvalue, rvalue):
        raise UnsupportedType


class OpaqueValueDeserializer(ValueDeserializer):
    '''Value extractor that also understands opaque values.

    Normally opaque values can't be retraced, unless they are being extracted
    in the context of handles.'''

    def visitOpaque(self, opaque, lvalue, rvalue):
        print '    %s = static_cast<%s>(retrace::toPointer(%s));' % (lvalue, opaque, rvalue)


class SwizzledValueRegistrator(stdapi.Visitor, stdapi.ExpanderMixin):
    '''Type visitor which will register (un)swizzled value pairs, to later be
    swizzled.'''

    def visitLiteral(self, literal, lvalue, rvalue):
        pass

    def visitAlias(self, alias, lvalue, rvalue):
        self.visit(alias.type, lvalue, rvalue)
    
    def visitEnum(self, enum, lvalue, rvalue):
        pass

    def visitBitmask(self, bitmask, lvalue, rvalue):
        pass

    def visitArray(self, array, lvalue, rvalue):
        print '    const trace::Array *_a%s = (%s).toArray();' % (array.tag, rvalue)
        print '    if (_a%s) {' % (array.tag)
        length = '_a%s->values.size()' % array.tag
        index = '_j' + array.tag
        print '        for (size_t {i} = 0; {i} < {length}; ++{i}) {{'.format(i = index, length = length)
        try:
            self.visit(array.type, '%s[%s]' % (lvalue, index), '*_a%s->values[%s]' % (array.tag, index))
        finally:
            print '        }'
            print '    }'
    
    def visitPointer(self, pointer, lvalue, rvalue):
        print '    const trace::Array *_a%s = (%s).toArray();' % (pointer.tag, rvalue)
        print '    if (_a%s) {' % (pointer.tag)
        try:
            self.visit(pointer.type, '%s[0]' % (lvalue,), '*_a%s->values[0]' % (pointer.tag,))
        finally:
            print '    }'
    
    def visitIntPointer(self, pointer, lvalue, rvalue):
        pass
    
    def visitObjPointer(self, pointer, lvalue, rvalue):
        print r'    retrace::addObj(call, %s, %s);' % (rvalue, lvalue)
    
    def visitLinearPointer(self, pointer, lvalue, rvalue):
        assert pointer.size is not None
        if pointer.size is not None:
            print r'    retrace::addRegion((%s).toUIntPtr(), %s, %s);' % (rvalue, lvalue, pointer.size)

    def visitReference(self, reference, lvalue, rvalue):
        pass
    
    def visitHandle(self, handle, lvalue, rvalue):
        print '    %s _origResult;' % handle.type
        OpaqueValueDeserializer().visit(handle.type, '_origResult', rvalue);
        if handle.range is None:
            rvalue = "_origResult"
            entry = lookupHandle(handle, rvalue, True)
            if (entry.startswith('_program_map') or entry.startswith('_shader_map')):
                print 'if (glretrace::supportsARBShaderObjects) {'
                print '    _handleARB_map[%s] = %s;' % (rvalue, lvalue)
                print '} else {'
                print '    %s = %s;' % (entry, lvalue)
                print '}'
            else:
                print "    %s = %s;" % (entry, lvalue)
            print '    if (retrace::verbosity >= 2) {'
            print '        std::cout << "{handle.name} " << {rvalue} << " -> " << {lvalue} << "\\n";'.format(**locals())
            print '    }'
        else:
            i = '_h' + handle.tag
            lvalue = "%s + %s" % (lvalue, i)
            rvalue = "_origResult + %s" % (i,)
            entry = lookupHandle(handle, rvalue) 
            print '    for ({handle.type} {i} = 0; {i} < {handle.range}; ++{i}) {{'.format(**locals())
            print '        {entry} = {lvalue};'.format(**locals())
            print '        if (retrace::verbosity >= 2) {'
            print '            std::cout << "{handle.name} " << ({rvalue}) << " -> " << ({lvalue}) << "\\n";'.format(**locals())
            print '        }'
            print '    }'
    
    def visitBlob(self, blob, lvalue, rvalue):
        pass
    
    def visitString(self, string, lvalue, rvalue):
        pass

    seq = 0

    def visitStruct(self, struct, lvalue, rvalue):
        tmp = '_s_' + struct.tag + '_' + str(self.seq)
        self.seq += 1

        print '    const trace::Struct *%s = (%s).toStruct();' % (tmp, rvalue)
        print '    assert(%s);' % (tmp,)
        print '    (void)%s;' % (tmp,)
        for i in range(len(struct.members)):
            member = struct.members[i]
            self.visitMember(member, lvalue, '*%s->members[%s]' % (tmp, i))
    
    def visitPolymorphic(self, polymorphic, lvalue, rvalue):
        assert polymorphic.defaultType is not None
        self.visit(polymorphic.defaultType, lvalue, rvalue)
    
    def visitOpaque(self, opaque, lvalue, rvalue):
        pass


class Retracer:

    def retraceFunction(self, function):
        print 'static void retrace_%s(trace::Call &call) {' % function.name
        self.retraceFunctionBody(function)
        print '}'
        print

    def retraceInterfaceMethod(self, interface, method):
        print 'static void retrace_%s__%s(trace::Call &call) {' % (interface.name, method.name)
        self.retraceInterfaceMethodBody(interface, method)
        print '}'
        print

    def retraceFunctionBody(self, function):
        assert function.sideeffects

        if function.type is not stdapi.Void:
            self.checkOrigResult(function)

        self.deserializeArgs(function)
        
        self.declareRet(function)
        self.invokeFunction(function)

        self.swizzleValues(function)

    def retraceInterfaceMethodBody(self, interface, method):
        assert method.sideeffects

        if method.type is not stdapi.Void:
            self.checkOrigResult(method)

        self.deserializeThisPointer(interface)

        self.deserializeArgs(method)
        
        self.declareRet(method)
        self.invokeInterfaceMethod(interface, method)

        self.swizzleValues(method)

    def checkOrigResult(self, function):
        '''Hook for checking the original result, to prevent succeeding now
        where the original did not, which would cause diversion and potentially
        unpredictable results.'''

        assert function.type is not stdapi.Void

        if str(function.type) == 'HRESULT':
            print r'    if (call.ret && FAILED(call.ret->toSInt())) {'
            print r'        return;'
            print r'    }'

    def deserializeThisPointer(self, interface):
        print r'    %s *_this;' % (interface.name,)
        print r'    _this = static_cast<%s *>(retrace::toObjPointer(call, call.arg(0)));' % (interface.name,)
        print r'    if (!_this) {'
        print r'        return;'
        print r'    }'

    def deserializeArgs(self, function):
        print '    retrace::ScopedAllocator _allocator;'
        print '    (void)_allocator;'
        success = True
        for arg in function.args:
            arg_type = arg.type.mutable()
            print '    %s %s;' % (arg_type, arg.name)
            rvalue = 'call.arg(%u)' % (arg.index,)
            lvalue = arg.name
            try:
                self.extractArg(function, arg, arg_type, lvalue, rvalue)
            except UnsupportedType:
                success =  False
                print '    memset(&%s, 0, sizeof %s); // FIXME' % (arg.name, arg.name)
            print

        if not success:
            print '    if (1) {'
            self.failFunction(function)
            sys.stderr.write('warning: unsupported %s call\n' % function.name)
            print '    }'

    def swizzleValues(self, function):
        for arg in function.args:
            if arg.output:
                arg_type = arg.type.mutable()
                rvalue = 'call.arg(%u)' % (arg.index,)
                lvalue = arg.name
                try:
                    self.regiterSwizzledValue(arg_type, lvalue, rvalue)
                except UnsupportedType:
                    print '    // XXX: %s' % arg.name
        if function.type is not stdapi.Void:
            rvalue = '*call.ret'
            lvalue = '_result'
            try:
                self.regiterSwizzledValue(function.type, lvalue, rvalue)
            except UnsupportedType:
                raise
                print '    // XXX: result'

    def failFunction(self, function):
        print '    if (retrace::verbosity >= 0) {'
        print '        retrace::unsupported(call);'
        print '    }'
        print '    return;'

    def extractArg(self, function, arg, arg_type, lvalue, rvalue):
        ValueAllocator().visit(arg_type, lvalue, rvalue)
        if arg.input:
            ValueDeserializer().visit(arg_type, lvalue, rvalue)
    
    def extractOpaqueArg(self, function, arg, arg_type, lvalue, rvalue):
        try:
            ValueAllocator().visit(arg_type, lvalue, rvalue)
        except UnsupportedType:
            pass
        OpaqueValueDeserializer().visit(arg_type, lvalue, rvalue)

    def regiterSwizzledValue(self, type, lvalue, rvalue):
        visitor = SwizzledValueRegistrator()
        visitor.visit(type, lvalue, rvalue)

    def declareRet(self, function):
        if function.type is not stdapi.Void:
            print '    %s _result;' % (function.type)

    def invokeFunction(self, function):
        arg_names = ", ".join(function.argNames())
        if function.type is not stdapi.Void:
            print '    _result = %s(%s);' % (function.name, arg_names)
            print '    (void)_result;'
            self.checkResult(function.type)
        else:
            print '    %s(%s);' % (function.name, arg_names)

    def invokeInterfaceMethod(self, interface, method):
        # On release our reference when we reach Release() == 0 call in the
        # trace.
        if method.name == 'Release':
            print '    if (call.ret->toUInt() == 0) {'
            print '        retrace::delObj(call.arg(0));'
            print '    }'

        arg_names = ", ".join(method.argNames())
        if method.type is not stdapi.Void:
            print '    _result = _this->%s(%s);' % (method.name, arg_names)
            print '    (void)_result;'
            self.checkResult(method.type)
        else:
            print '    _this->%s(%s);' % (method.name, arg_names)

    def checkResult(self, resultType):
        if str(resultType) == 'HRESULT':
            print r'    if (FAILED(_result)) {'
            print '         static char szMessageBuffer[128];'
            print r'        retrace::warning(call) << "call returned 0x" << std::hex << _result << std::dec << ": " << (FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, _result, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), szMessageBuffer, sizeof szMessageBuffer, NULL) ? szMessageBuffer : "???") << "\n";'
            print r'    }'

    def filterFunction(self, function):
        return True

    table_name = 'retrace::callbacks'

    def retraceApi(self, api):

        print '#include "os_time.hpp"'
        print '#include "trace_parser.hpp"'
        print '#include "retrace.hpp"'
        print '#include "retrace_swizzle.hpp"'
        print

        types = api.getAllTypes()
        handles = [type for type in types if isinstance(type, stdapi.Handle)]
        handle_names = set()
        for handle in handles:
            if handle.name not in handle_names:
                if handle.key is None:
                    print 'static retrace::map<%s> _%s_map;' % (handle.type, handle.name)
                else:
                    key_name, key_type = handle.key
                    print 'static std::map<%s, retrace::map<%s> > _%s_map;' % (key_type, handle.type, handle.name)
                handle_names.add(handle.name)
        print

        functions = filter(self.filterFunction, api.getAllFunctions())
        for function in functions:
            if function.sideeffects and not function.internal:
                self.retraceFunction(function)
        interfaces = api.getAllInterfaces()
        for interface in interfaces:
            for method in interface.iterMethods():
                if method.sideeffects and not method.internal:
                    self.retraceInterfaceMethod(interface, method)

        print 'const retrace::Entry %s[] = {' % self.table_name
        for function in functions:
            if not function.internal:
                if function.sideeffects:
                    print '    {"%s", &retrace_%s},' % (function.name, function.name)
                else:
                    print '    {"%s", &retrace::ignore},' % (function.name,)
        for interface in interfaces:
            for method in interface.iterMethods():                
                if method.sideeffects:
                    print '    {"%s::%s", &retrace_%s__%s},' % (interface.name, method.name, interface.name, method.name)
                else:
                    print '    {"%s::%s", &retrace::ignore},' % (interface.name, method.name)
        print '    {NULL, NULL}'
        print '};'
        print


########NEW FILE########
__FILENAME__ = convert
#!/usr/bin/env python
##########################################################################
#
# Copyright 2012 VMware Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the 'Software'), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

'''Convert traces to/from PIX.
'''


import optparse
import os.path
import subprocess
import platform
import sys


def getPixExe():
    try:
        programFiles = os.environ['ProgramFiles(x86)']
    except KeyError:
        programFiles = os.environ['ProgramFiles']
    try:
        dxsdkDir = os.environ['DXSDK_DIR']
    except KeyError:
        dxsdkDir = os.path.join(programFiles, "Microsoft DirectX SDL (June 2010)")
    pixExe = os.path.join(dxsdkDir, "Utilities", "bin", 'x86', 'PIXwin.exe')
    return pixExe


def callProcess(cmd):
    if options.verbose:
        sys.stderr.write(' '.join(cmd) + '\n')
    ret = subprocess.call(cmd)
    if ret:
        exeName = os.path.basename(cmd[0])
        sys.stderr.write('error: %s failed with exit code %u\n' % (exeName, ret))
        sys.exit(ret)
    return ret


def convertToPix(inTrace, outPixrun):
    pix = getPixExe()

    pixExp = os.path.join(os.path.dirname(__file__), 'apitrace.PIXExp')

    # http://social.msdn.microsoft.com/Forums/sv/devdocs/thread/15addc0c-036d-413a-854a-35637ccbb834
    # http://src.chromium.org/svn/trunk/o3d/tests/test_driver.py
    cmd = [
        getPixExe(),
        pixExp,
        '-start',
        '-runfile', os.path.abspath(outPixrun),
        '-targetpath', os.path.abspath(options.retrace),
        #'-targetstartfolder', ...,
        '-targetargs', os.path.abspath(inTrace),
    ]

    callProcess(cmd)
    if os.path.exists(outPixrun):
        sys.stderr.write('info: %s written\n' % outPixrun)
        if options.verify:
            subprocess.call([pix, os.path.abspath(outPixrun)])
    else:
        sys.stderr.write('error: %s not written\n' % outPixrun)
        sys.exit(1)


def convertFromPix(inPix, outTrace):
    pixExe = getPixExe()

    if False:
        # TODO: Use -exporttocsv option to detect which API to use
        cmd = [
            pixExe,
            inPix,
            '-exporttocsv', # XXX: output filename is ignored
        ]
        callProcess(cmd)

    cmd = [
        options.apitrace,
        'trace',
        '-a', options.api,
        '-o', outTrace,
        pixExe,
        inPix,
        '-playstandalone',
    ]

    callProcess(cmd)
    if os.path.exists(outTrace):
        sys.stderr.write('info: %s written\n' % outTrace)
        if options.verify:
            subprocess.call([options.retrace, os.path.abspath(outTrace)])
    else:
        sys.stderr.write('error: %s not written\n' % outTrace)
        sys.exit(1)


def main():
    global options

    # Parse command line options
    optparser = optparse.OptionParser(
        usage='\n\t%prog [options] <trace> ...',
        version='%%prog')
    optparser.add_option(
        '--apitrace', metavar='PROGRAM',
        type='string', dest='apitrace', default='apitrace.exe',
        help='path to apitrace command [default: %default]')
    optparser.add_option(
        '-a', '--api', metavar='API',
        type='string', dest='api', default='d3d9',
        help='api [default: %default]')
    optparser.add_option(
        '-r', '--retrace', metavar='PROGRAM',
        type='string', dest='retrace', default='d3dretrace.exe',
        help='path to retrace command [default: %default]')
    optparser.add_option(
        '-v', '--verbose',
        action='store_true', dest='verbose', default=False,
        help='verbose output')
    optparser.add_option(
        '-o', '--output', metavar='FILE',
        type="string", dest="output",
        help="output file [default: stdout]")
    optparser.add_option(
        '--verify',
        action='store_true', dest='verify', default=False,
        help='verify output by replaying it')

    (options, args) = optparser.parse_args(sys.argv[1:])
    if not args:
        optparser.error("incorrect number of arguments")
    
    for inFile in args:
        name, inExt = os.path.splitext(os.path.basename(inFile))
        inExt = inExt
        if inExt.lower() == '.trace':
            convert = convertToPix
            outExt = '.PIXRun'
        elif inExt.lower() == '.pixrun':
            convert = convertFromPix
            outExt = '.trace'
        else:
            optparser.error("unexpected file extensions `%s`" % inExt)
        if options.output:
            outFile = options.output
        else:
            outFile = name + outExt
        convert(inFile, outFile)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = highlight
#########################################################################
#
# Copyright 2011-2012 Jose Fonseca
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


import platform
import subprocess
import sys


class PlainHighlighter:
    '''Plain highlighter.'''

    black = None
    red = None
    green = None
    yellow = None
    blue = None
    magenta = None
    cyan = None
    white = None

    def __init__(self, stream = sys.stdout):
        self.stream = stream

    def write(self, text):
        self.stream.write(text)

    def flush(self):
        self.stream.flush()

    def normal(self):
        pass

    def color(self, color):
        pass

    def bold(self, enable = True):
        pass

    def strike(self):
        pass

    def italic(self):
        pass


class AnsiHighlighter(PlainHighlighter):
    '''Highlighter for plain-text files which outputs ANSI escape codes. See
    http://en.wikipedia.org/wiki/ANSI_escape_code for more information
    concerning ANSI escape codes.
    '''

    _csi = '\33['

    _normal = '0m'
    _italic = '3m'

    black = 0
    red = 1
    green = 2
    yellow = 3
    blue = 4
    magenta = 5
    cyan = 6
    white = 7

    def __init__(self, stream = sys.stdout):
        PlainHighlighter.__init__(self, stream)

    def _escape(self, code):
        self.stream.write(self._csi + code)

    def normal(self):
        self._escape(self._normal)

    def color(self, color):
        self._escape(str(30 + color) + 'm')

    def bold(self, enable = True):
        if enable:
            self._escape('1m')
        else:
            self._escape('21m')

    def strike(self):
        self._escape('9m')

    def italic(self):
        self._escape(self._italic)


class WindowsConsoleHighlighter(PlainHighlighter):
    '''Highlighter for the Windows Console. See 
    http://code.activestate.com/recipes/496901/ for more information.
    '''

    INVALID_HANDLE_VALUE = -1
    STD_INPUT_HANDLE  = -10
    STD_OUTPUT_HANDLE = -11
    STD_ERROR_HANDLE  = -12

    FOREGROUND_BLUE      = 0x01
    FOREGROUND_GREEN     = 0x02
    FOREGROUND_RED       = 0x04
    FOREGROUND_INTENSITY = 0x08
    BACKGROUND_BLUE      = 0x10
    BACKGROUND_GREEN     = 0x20
    BACKGROUND_RED       = 0x40
    BACKGROUND_INTENSITY = 0x80

    COMMON_LVB_LEADING_BYTE = 0x0100
    COMMON_LVB_TRAILING_BYTE = 0x0200
    COMMON_LVB_GRID_HORIZONTAL = 0x0400
    COMMON_LVB_GRID_LVERTICAL = 0x0800
    COMMON_LVB_GRID_RVERTICAL = 0x1000
    COMMON_LVB_REVERSE_VIDEO = 0x4000
    COMMON_LVB_UNDERSCORE = 0x8000

    _normal = FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED
    _italic = FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED

    black   = 0
    red     =                                      FOREGROUND_RED
    green   =                   FOREGROUND_GREEN                 
    blue    = FOREGROUND_BLUE                                    
    white   = FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED

    def __init__(self, stream = sys.stdout):
        PlainHighlighter.__init__(self, stream)

        if stream is sys.stdin:
            nStdHandle = self.STD_INPUT_HANDLE
        elif stream is sys.stdout:
            nStdHandle = self.STD_OUTPUT_HANDLE
        elif stream is sys.stderr:
            nStdHandle = self.STD_ERROR_HANDLE
        else:
            nStdHandle = None

        if nStdHandle is not None:
            import ctypes
            self._handle = ctypes.windll.kernel32.GetStdHandle(nStdHandle)
        else:
            self._handle = self.INVALID_HANDLE_VALUE

        self._attribute = self.white

    def _setAttribute(self, attr):
        if self._handle != self.INVALID_HANDLE_VALUE:
            import ctypes
            ctypes.windll.kernel32.SetConsoleTextAttribute(self._handle, attr)
        self._attribute = attr

    def normal(self):
        self._setAttribute(self._normal)

    def color(self, color):
        intensity = self._attribute & self.FOREGROUND_INTENSITY
        self._setAttribute(color | intensity)

    def bold(self, enable = True):
        if enable:
            attribute = self._attribute | self.FOREGROUND_INTENSITY
        else:
            attribute = self._attribute & ~self.FOREGROUND_INTENSITY
        self._setAttribute(attribute)

    def italic(self):
        pass


if platform.system() == 'Windows':
    ColorHighlighter = WindowsConsoleHighlighter
else:
    ColorHighlighter = AnsiHighlighter


def AutoHighlighter(stream = sys.stdout):
    if stream.isatty():
        return ColorHighlighter(stream)
    else:
        return PlainHighlighter(stream)


class _LessHighlighter(AnsiHighlighter):

    def __init__(self, less):
        AnsiHighlighter.__init__(self, less.stdin)
        self.less = less

    def __del__(self):
        self.less.stdin.close()
        self.less.wait()


def LessHighlighter():
    if sys.stdout.isatty():
        try:
            less = subprocess.Popen(
                args = ['less', '-FRXn'],
                stdin = subprocess.PIPE
            )
        except OSError:
            return ColorHighlighter()
        else:
            return _LessHighlighter(less)
    return PlainHighlighter(sys.stdout)


########NEW FILE########
__FILENAME__ = jsondiff
#!/usr/bin/env python
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


import json
import optparse
import re
import sys


def strip_object_hook(obj):
    if '__class__' in obj:
        return None
    for name in obj.keys():
        if name.startswith('__') and name.endswith('__'):
            del obj[name]
    return obj


class Visitor:

    def visit(self, node, *args, **kwargs):
        if isinstance(node, dict):
            return self.visitObject(node, *args, **kwargs)
        elif isinstance(node, list):
            return self.visitArray(node, *args, **kwargs)
        else:
            return self.visitValue(node, *args, **kwargs)

    def visitObject(self, node, *args, **kwargs):
        pass

    def visitArray(self, node, *args, **kwargs):
        pass

    def visitValue(self, node, *args, **kwargs):
        pass


class Dumper(Visitor):

    def __init__(self, stream = sys.stdout):
        self.stream = stream
        self.level = 0

    def _write(self, s):
        self.stream.write(s)

    def _indent(self):
        self._write('  '*self.level)

    def _newline(self):
        self._write('\n')

    def visitObject(self, node):
        self.enter_object()

        members = node.keys()
        members.sort()
        for i in range(len(members)):
            name = members[i]
            value = node[name]
            self.enter_member(name)
            self.visit(value)
            self.leave_member(i == len(members) - 1)
        self.leave_object()

    def enter_object(self):
        self._write('{')
        self._newline()
        self.level += 1

    def enter_member(self, name):
        self._indent()
        self._write('%s: ' % name)

    def leave_member(self, last):
        if not last:
            self._write(',')
        self._newline()

    def leave_object(self):
        self.level -= 1
        self._indent()
        self._write('}')
        if self.level <= 0:
            self._newline()

    def visitArray(self, node):
        self.enter_array()
        for i in range(len(node)):
            value = node[i]
            self._indent()
            self.visit(value)
            if i != len(node) - 1:
                self._write(',')
            self._newline()
        self.leave_array()

    def enter_array(self):
        self._write('[')
        self._newline()
        self.level += 1

    def leave_array(self):
        self.level -= 1
        self._indent()
        self._write(']')

    def visitValue(self, node):
        self._write(json.dumps(node))



class Comparer(Visitor):

    def __init__(self, ignore_added = False, tolerance = 2.0 ** -24):
        self.ignore_added = ignore_added
        self.tolerance = tolerance

    def visitObject(self, a, b):
        if not isinstance(b, dict):
            return False
        if len(a) != len(b) and not self.ignore_added:
            return False
        ak = a.keys()
        bk = b.keys()
        ak.sort()
        bk.sort()
        if ak != bk and not self.ignore_added:
            return False
        for k in ak:
            ae = a[k]
            try:
                be = b[k]
            except KeyError:
                return False
            if not self.visit(ae, be):
                return False
        return True

    def visitArray(self, a, b):
        if not isinstance(b, list):
            return False
        if len(a) != len(b):
            return False
        for ae, be in zip(a, b):
            if not self.visit(ae, be):
                return False
        return True

    def visitValue(self, a, b):
        if isinstance(a, float) or isinstance(b, float):
            if a == 0:
                return abs(b) < self.tolerance
            else:
                return abs((b - a)/a) < self.tolerance
        else:
            return a == b


class Differ(Visitor):

    def __init__(self, stream = sys.stdout, ignore_added = False):
        self.dumper = Dumper(stream)
        self.comparer = Comparer(ignore_added = ignore_added)

    def visit(self, a, b):
        if self.comparer.visit(a, b):
            return
        Visitor.visit(self, a, b)

    def visitObject(self, a, b):
        if not isinstance(b, dict):
            self.replace(a, b)
        else:
            self.dumper.enter_object()
            names = set(a.keys())
            if not self.comparer.ignore_added:
                names.update(b.keys())
            names = list(names)
            names.sort()

            for i in range(len(names)):
                name = names[i]
                ae = a.get(name, None)
                be = b.get(name, None)
                if not self.comparer.visit(ae, be):
                    self.dumper.enter_member(name)
                    self.visit(ae, be)
                    self.dumper.leave_member(i == len(names) - 1)

            self.dumper.leave_object()

    def visitArray(self, a, b):
        if not isinstance(b, list):
            self.replace(a, b)
        else:
            self.dumper.enter_array()
            max_len = max(len(a), len(b))
            for i in range(max_len):
                try:
                    ae = a[i]
                except IndexError:
                    ae = None
                try:
                    be = b[i]
                except IndexError:
                    be = None
                self.dumper._indent()
                if self.comparer.visit(ae, be):
                    self.dumper.visit(ae)
                else:
                    self.visit(ae, be)
                if i != max_len - 1:
                    self.dumper._write(',')
                self.dumper._newline()

            self.dumper.leave_array()

    def visitValue(self, a, b):
        if a != b:
            self.replace(a, b)

    def replace(self, a, b):
        self.dumper.visit(a)
        self.dumper._write(' -> ')
        self.dumper.visit(b)


#
# Unfortunately JSON standard does not include comments, but this is a quite
# useful feature to have on regressions tests
#

_token_res = [
    r'//[^\r\n]*', # comment
    r'"[^"\\]*(\\.[^"\\]*)*"', # string
]

_tokens_re = re.compile(r'|'.join(['(' + token_re + ')' for token_re in _token_res]), re.DOTALL)


def _strip_comment(mo):
    if mo.group(1):
        return ''
    else:
        return mo.group(0)


def _strip_comments(data):
    '''Strip (non-standard) JSON comments.'''
    return _tokens_re.sub(_strip_comment, data)


assert _strip_comments('''// a comment
"// a comment in a string
"''') == '''
"// a comment in a string
"'''


def load(stream, strip_images = True, strip_comments = True):
    if strip_images:
        object_hook = strip_object_hook
    else:
        object_hook = None
    if strip_comments:
        data = stream.read()
        data = _strip_comments(data)
        return json.loads(data, strict=False, object_hook = object_hook)
    else:
        return json.load(stream, strict=False, object_hook = object_hook)


def main():
    optparser = optparse.OptionParser(
        usage="\n\t%prog [options] <ref_json> <src_json>")
    optparser.add_option(
        '--keep-images',
        action="store_false", dest="strip_images", default=True,
        help="compare images")

    (options, args) = optparser.parse_args(sys.argv[1:])

    if len(args) != 2:
        optparser.error('incorrect number of arguments')

    a = load(open(sys.argv[1], 'rt'), options.strip_images)
    b = load(open(sys.argv[2], 'rt'), options.strip_images)

    if False:
        dumper = Dumper()
        dumper.visit(a)

    differ = Differ()
    differ.visit(a, b)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = jsonextractimages
#!/usr/bin/env python
##########################################################################
#
# Copyright 2012 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


'''Simple script to extract PNG files from the JSON state dumps.'''


import json
import optparse
import base64
import sys


def dumpSurfaces(state, memberName):
    for name, imageObj in state[memberName].iteritems():
        data = imageObj['__data__']
        data = base64.b64decode(data)

        imageName = '%s.png' % name
        open(imageName, 'wb').write(data)
        sys.stderr.write('Wrote %s\n' % imageName)


def main():
    optparser = optparse.OptionParser(
        usage="\n\t%prog [options] <json>")

    (options, args) = optparser.parse_args(sys.argv[1:])

    for arg in args:
        state = json.load(open(arg, 'rt'), strict=False)

        dumpSurfaces(state, 'textures')
        dumpSurfaces(state, 'framebuffer')



if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = profileshader
#!/usr/bin/env python
##########################################################################
#
# Copyright 2012-2013 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


import optparse
import sys


def process(stream, groupField):
    times = {}

    # Read header describing fields
    header = stream.readline()
    assert header.startswith('#')

    fields = header.rstrip('\r\n').split(' ')[1:]
    columns = {}
    for column in range(len(fields)):
        columns[fields[column]] = column

    callCol = columns['call']
    callIdCol = columns['no']
    gpuDuraCol = columns['gpu_dura']
    programCol = columns['program']
    funcNameCol = columns['name']

    groupCol = columns[groupField]

    maxGroupLen = 0

    for line in stream:
        fields = line.rstrip('\r\n').split(' ')

        if line.startswith('#'):
            continue

        if fields[callCol] == 'call':
            callId = long(fields[callIdCol])
            duration = long(fields[gpuDuraCol])
            group = fields[groupCol]

            maxGroupLen = max(maxGroupLen, len(group))

            if times.has_key(group):
                times[group]['draws'] += 1
                times[group]['duration'] += duration

                if duration > times[group]['longestDuration']:
                    times[group]['longest'] = callId
                    times[group]['longestDuration'] = duration
            else:
                times[group] = {'draws': 1, 'duration': duration, 'longest': callId, 'longestDuration': duration}

    times = sorted(times.items(), key=lambda x: x[1]['duration'], reverse=True)

    if groupField == 'program':
        groupTitle = 'Shader[id]'
    else:
        groupTitle = groupField
    maxGroupLen = max(maxGroupLen, len(groupTitle))
    groupTitle = groupField.center(maxGroupLen)
    groupLine = '-' * maxGroupLen

    print '+-%s-+--------------+--------------------+--------------+-------------+' % groupLine
    print '| %s |   Draws [#]  |   Duration [ns]  v | Per Call[ns] | Longest[id] |' % groupTitle
    print '+-%s-+--------------+--------------------+--------------+-------------+' % groupLine

    for group in times:
        id = str(group[0]).rjust(maxGroupLen)
        draw = str(group[1]['draws']).rjust(12)
        dura = str(group[1]['duration']).rjust(18)
        perCall = str(group[1]['duration'] / group[1]['draws']).rjust(12)
        longest = str(group[1]['longest']).rjust(11)
        print "| %s | %s | %s | %s | %s |" % (id, draw, dura, perCall, longest)

    print '+-%s-+--------------+--------------------+--------------+-------------+' % groupLine


def main():

    # Parse command line options
    optparser = optparse.OptionParser(
        usage='\n\t%prog [options] <profile_input>',
        version='%%prog')

    optparser.add_option(
        '-g', '--group', metavar='FIELD',
        type="string", dest="group", default='program',
        help="group by specified field [default: %default]")
    
    (options, args) = optparser.parse_args(sys.argv[1:])

    if len(args):
        for arg in args:
            process(open(arg, 'rt'), options.group)
    else:
        process(sys.stdin, options.group)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = retracediff
#!/usr/bin/env python
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the 'Software'), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

'''Run two retrace instances in parallel, comparing generated snapshots.
'''


import math
import optparse
import os.path
import subprocess
import platform
import sys

from PIL import Image

from snapdiff import Comparer
from highlight import AutoHighlighter
import jsondiff


# Null file, to use when we're not interested in subprocesses output
if platform.system() == 'Windows':
    NULL = open('NUL:', 'wb')
else:
    NULL = open('/dev/null', 'wb')


class RetraceRun:

    def __init__(self, process):
        self.process = process

    def nextSnapshot(self):
        image, comment = read_pnm(self.process.stdout)
        if image is None:
            return None, None

        callNo = int(comment.strip())

        return image, callNo

    def terminate(self):
        try:
            self.process.terminate()
        except OSError:
            # Avoid http://bugs.python.org/issue14252
            pass


class Retracer:

    def __init__(self, retraceExe, args, env=None):
        self.retraceExe = retraceExe
        self.args = args
        self.env = env

    def _retrace(self, args, stdout=subprocess.PIPE):
        cmd = [
            self.retraceExe,
        ] + args + self.args
        if self.env:
            for name, value in self.env.iteritems():
                sys.stderr.write('%s=%s ' % (name, value))
        sys.stderr.write(' '.join(cmd) + '\n')
        try:
            return subprocess.Popen(cmd, env=self.env, stdout=stdout, stderr=NULL)
        except OSError, ex:
            sys.stderr.write('error: failed to execute %s: %s\n' % (cmd[0], ex.strerror))
            sys.exit(1)

    def retrace(self, args):
        p = self._retrace([])
        p.wait()
        return p.returncode

    def snapshot(self, call_nos):
        process = self._retrace([
            '-s', '-',
            '-S', call_nos,
        ])
        return RetraceRun(process)

    def dump_state(self, call_no):
        '''Get the state dump at the specified call no.'''

        p = self._retrace([
            '-D', str(call_no),
        ])
        state = jsondiff.load(p.stdout)
        p.wait()
        return state.get('parameters', {})

    def diff_state(self, ref_call_no, src_call_no, stream):
        '''Compare the state between two calls.'''

        ref_state = self.dump_state(ref_call_no)
        src_state = self.dump_state(src_call_no)

        stream.flush()
        differ = jsondiff.Differ(stream)
        differ.visit(ref_state, src_state)
        stream.write('\n')


def read_pnm(stream):
    '''Read a PNM from the stream, and return the image object, and the comment.'''

    magic = stream.readline()
    if not magic:
        return None, None
    magic = magic.rstrip()
    if magic == 'P5':
        channels = 1
        bytesPerChannel = 1
        mode = 'L'
    elif magic == 'P6':
        channels = 3
        bytesPerChannel = 1
        mode = 'RGB'
    elif magic == 'Pf':
        channels = 1
        bytesPerChannel = 4
        mode = 'R'
    elif magic == 'PF':
        channels = 3
        bytesPerChannel = 4
        mode = 'RGB'
    elif magic == 'PX':
        channels = 4
        bytesPerChannel = 4
        mode = 'RGB'
    else:
        raise Exception('Unsupported magic `%s`' % magic)
    comment = ''
    line = stream.readline()
    while line.startswith('#'):
        comment += line[1:]
        line = stream.readline()
    width, height = map(int, line.strip().split())
    maximum = int(stream.readline().strip())
    if bytesPerChannel == 1:
        assert maximum == 255
    else:
        assert maximum == 1
    data = stream.read(height * width * channels * bytesPerChannel)
    if bytesPerChannel == 4:
        # Image magic only supports single channel floating point images, so
        # represent the image as numpy arrays

        import numpy
        pixels = numpy.fromstring(data, dtype=numpy.float32)
        pixels.resize((height, width, channels))
        return pixels, comment

    image = Image.frombuffer(mode, (width, height), data, 'raw', mode, 0, 1)
    return image, comment


def dumpNumpyImage(output, pixels, filename):
    height, width, channels = pixels.shape

    import numpy

    pixels = (pixels*255).clip(0, 255).astype('uint8')

    if 0:
        # XXX: Doesn't work somehow
        im = Image.fromarray(pixels)
    else:
        # http://code.activestate.com/recipes/577591-conversion-of-pil-image-and-numpy-array/
        pixels = pixels.reshape(height*width, channels)
        if channels == 4:
            mode = 'RGBA'
        else:
            if channels < 3:
                pixels = numpy.c_[arr, 255*numpy.ones((heigth * width, 3 - channels), numpy.uint8)]
            assert channels == 3
            mode = 'RGB'
        im = Image.frombuffer(mode, (width, height), pixels.tostring(), 'raw', mode, 0, 1)
    im.save(filename)

    if 0:
        # Dump to stdout
        for y in range(height):
            output.write('  ')
            for x in range(width):
                for c in range(channels):
                    output.write('%0.9g,' % pixels[y, x, c])
                output.write('  ')
            output.write('\n')


def parse_env(optparser, entries):
    '''Translate a list of NAME=VALUE entries into an environment dictionary.'''

    if not entries:
        return None

    env = os.environ.copy()
    for entry in entries:
        try:
            name, var = entry.split('=', 1)
        except Exception:
            optparser.error('invalid environment entry %r' % entry)
        env[name] = var
    return env


def main():
    '''Main program.
    '''

    global options

    # Parse command line options
    optparser = optparse.OptionParser(
        usage='\n\t%prog [options] -- [glretrace options] <trace>',
        version='%%prog')
    optparser.add_option(
        '-r', '--retrace', metavar='PROGRAM',
        type='string', dest='retrace', default='glretrace',
        help='retrace command [default: %default]')
    optparser.add_option(
        '--ref-driver', metavar='DRIVER',
        type='string', dest='ref_driver', default=None,
        help='force reference driver')
    optparser.add_option(
        '--src-driver', metavar='DRIVER',
        type='string', dest='src_driver', default=None,
        help='force source driver')
    optparser.add_option(
        '--ref-arg', metavar='OPTION',
        type='string', action='append', dest='ref_args', default=[],
        help='pass argument to reference retrace')
    optparser.add_option(
        '--src-arg', metavar='OPTION',
        type='string', action='append', dest='src_args', default=[],
        help='pass argument to source retrace')
    optparser.add_option(
        '--ref-env', metavar='NAME=VALUE',
        type='string', action='append', dest='ref_env', default=[],
        help='add variable to reference environment')
    optparser.add_option(
        '--src-env', metavar='NAME=VALUE',
        type='string', action='append', dest='src_env', default=[],
        help='add variable to source environment')
    optparser.add_option(
        '--diff-prefix', metavar='PATH',
        type='string', dest='diff_prefix', default='.',
        help='prefix for the difference images')
    optparser.add_option(
        '-t', '--threshold', metavar='BITS',
        type="float", dest="threshold", default=12.0,
        help="threshold precision  [default: %default]")
    optparser.add_option(
        '-S', '--snapshot-frequency', metavar='CALLSET',
        type="string", dest="snapshot_frequency", default='draw',
        help="calls to compare [default: %default]")
    optparser.add_option(
        '--diff-state',
        action='store_true', dest='diff_state', default=False,
        help='diff state between failing calls')
    optparser.add_option(
        '-o', '--output', metavar='FILE',
        type="string", dest="output",
        help="output file [default: stdout]")

    (options, args) = optparser.parse_args(sys.argv[1:])
    ref_env = parse_env(optparser, options.ref_env)
    src_env = parse_env(optparser, options.src_env)
    if not args:
        optparser.error("incorrect number of arguments")
    
    if options.ref_driver:
        options.ref_args.insert(0, '--driver=' + options.ref_driver)
    if options.src_driver:
        options.src_args.insert(0, '--driver=' + options.src_driver)

    refRetracer = Retracer(options.retrace, options.ref_args + args, ref_env)
    srcRetracer = Retracer(options.retrace, options.src_args + args, src_env)

    if options.output:
        output = open(options.output, 'wt')
    else:
        output = sys.stdout

    highligher = AutoHighlighter(output)

    highligher.write('call\tprecision\n')

    last_bad = -1
    last_good = 0
    refRun = refRetracer.snapshot(options.snapshot_frequency)
    try:
        srcRun = srcRetracer.snapshot(options.snapshot_frequency)
        try:
            while True:
                # Get the reference image
                refImage, refCallNo = refRun.nextSnapshot()
                if refImage is None:
                    break

                # Get the source image
                srcImage, srcCallNo = srcRun.nextSnapshot()
                if srcImage is None:
                    break

                assert refCallNo == srcCallNo
                callNo = refCallNo

                # Compare the two images
                if isinstance(refImage, Image.Image) and isinstance(srcImage, Image.Image):
                    # Using PIL
                    numpyImages = False
                    comparer = Comparer(refImage, srcImage)
                    precision = comparer.precision()
                else:
                    # Using numpy (for floating point images)
                    # TODO: drop PIL when numpy path becomes general enough
                    import numpy
                    assert not isinstance(refImage, Image.Image)
                    assert not isinstance(srcImage, Image.Image)
                    numpyImages = True
                    assert refImage.shape == srcImage.shape
                    diffImage = numpy.square(srcImage - refImage)

                    height, width, channels = diffImage.shape
                    square_error = numpy.sum(diffImage)
                    rel_error = square_error / float(height*width*channels)
                    bits = -math.log(rel_error)/math.log(2.0)
                    precision = bits

                mismatch = precision < options.threshold

                if mismatch:
                    highligher.color(highligher.red)
                    highligher.bold()
                highligher.write('%u\t%f\n' % (callNo, precision))
                if mismatch:
                    highligher.normal()

                if mismatch:
                    if options.diff_prefix:
                        prefix = os.path.join(options.diff_prefix, '%010u' % callNo)
                        prefix_dir = os.path.dirname(prefix)
                        if not os.path.isdir(prefix_dir):
                            os.makedirs(prefix_dir)
                        if numpyImages:
                            dumpNumpyImage(output, refImage, prefix + '.ref.png')
                            dumpNumpyImage(output, srcImage, prefix + '.src.png')
                        else:
                            refImage.save(prefix + '.ref.png')
                            srcImage.save(prefix + '.src.png')
                            comparer.write_diff(prefix + '.diff.png')
                    if last_bad < last_good and options.diff_state:
                        srcRetracer.diff_state(last_good, callNo, output)
                    last_bad = callNo
                else:
                    last_good = callNo

                highligher.flush()
        finally:
            srcRun.terminate()
    finally:
        refRun.terminate()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = snapdiff
#!/usr/bin/env python
##########################################################################
#
# Copyright 2011 Jose Fonseca
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


'''Snapshot (image) comparison script.
'''


import sys
import os.path
import optparse
import math
import operator

from PIL import Image
from PIL import ImageChops
from PIL import ImageEnhance
from PIL import ImageFilter


thumbSize = 320

gaussian_kernel = ImageFilter.Kernel((3, 3), [1, 2, 1, 2, 4, 2, 1, 2, 1], 16)

class Comparer:
    '''Image comparer.'''

    def __init__(self, ref_image, src_image, alpha = False):
        if isinstance(ref_image, basestring):
            self.ref_im = Image.open(ref_image)
        else:
            self.ref_im = ref_image

        if isinstance(src_image, basestring):
            self.src_im = Image.open(src_image)
        else:
            self.src_im = src_image

        # Ignore
        if not alpha:
            self.ref_im = self.ref_im.convert('RGB')
            self.src_im = self.src_im.convert('RGB')

        self.diff = ImageChops.difference(self.src_im, self.ref_im)

    def size_mismatch(self):
        return self.ref_im.size != self.src_im.size

    def write_diff(self, diff_image, fuzz = 0.05):
        if self.size_mismatch():
            return

        # make a difference image similar to ImageMagick's compare utility
        mask = ImageEnhance.Brightness(self.diff).enhance(1.0/fuzz)
        mask = mask.convert('L')

        lowlight = Image.new('RGB', self.src_im.size, (0xff, 0xff, 0xff))
        highlight = Image.new('RGB', self.src_im.size, (0xf1, 0x00, 0x1e))
        diff_im = Image.composite(highlight, lowlight, mask)

        diff_im = Image.blend(self.src_im, diff_im, 0xcc/255.0)
        diff_im.save(diff_image)

    def precision(self, filter=False):
        if self.size_mismatch():
            return 0.0

        diff = self.diff
        if filter:
            diff = diff.filter(gaussian_kernel)

        # See also http://effbot.org/zone/pil-comparing-images.htm
        h = diff.histogram()
        square_error = 0
        for i in range(1, 256):
            square_error += sum(h[i : 3*256: 256])*i*i
        rel_error = float(square_error*2 + 1) / float(self.diff.size[0]*self.diff.size[1]*3*255*255*2)
        bits = -math.log(rel_error)/math.log(2.0)
        return bits

    def ae(self, fuzz = 0.05):
        # Compute absolute error

        if self.size_mismatch():
            return sys.maxint

        # TODO: this is approximate due to the grayscale conversion
        h = self.diff.convert('L').histogram()
        ae = sum(h[int(255 * fuzz) + 1 : 256])
        return ae


def surface(html, image):
    if True:
        name, ext = os.path.splitext(image)
        thumb = name + '.thumb' + ext
        if os.path.exists(image) \
           and (not os.path.exists(thumb) \
                or os.path.getmtime(thumb) < os.path.getmtime(image)):
            im = Image.open(image)
            imageWidth, imageHeight = im.size
            if imageWidth <= thumbSize and imageHeight <= thumbSize:
                if imageWidth >= imageHeight:
                    imageHeight = imageHeight*thumbSize/imageWidth
                    imageWidth = thumbSize
                else:
                    imageWidth = imageWidth*thumbSize/imageHeight
                    imageHeight = thumbSize
                html.write('        <td><img src="%s" width="%u" height="%u"/></td>\n' % (image, imageWidth, imageHeight))
                return

            im.thumbnail((thumbSize, thumbSize))
            im.save(thumb)
    else:
        thumb = image
    html.write('        <td><a href="%s"><img src="%s"/></a></td>\n' % (image, thumb))


def is_image(path):
    name = os.path.basename(path)
    name, ext1 = os.path.splitext(name)
    name, ext2 = os.path.splitext(name)
    return ext1 in ('.png', '.bmp') and ext2 not in ('.diff', '.thumb')


def find_images(prefix):
    if os.path.isdir(prefix):
        prefix_dir = prefix
    else:
        prefix_dir = os.path.dirname(prefix)

    images = []
    for dirname, dirnames, filenames in os.walk(prefix_dir, followlinks=True):
        for filename in filenames:
            filepath = os.path.join(dirname, filename)
            if filepath.startswith(prefix) and is_image(filepath):
                images.append(filepath[len(prefix):])

    return images


def main():
    global options

    optparser = optparse.OptionParser(
        usage="\n\t%prog [options] <ref_prefix> <src_prefix>")
    optparser.add_option(
        '-v', '--verbose',
        action="store_true", dest="verbose", default=False,
        help="verbose output")
    optparser.add_option(
        '-o', '--output', metavar='FILE',
        type="string", dest="output", default='index.html',
        help="output filename [default: %default]")
    optparser.add_option(
        '-f', '--fuzz',
        type="float", dest="fuzz", default=0.05,
        help="fuzz ratio [default: %default]")
    optparser.add_option(
        '-a', '--alpha',
        action="store_true", dest="alpha", default=False,
        help="take alpha channel in consideration")
    optparser.add_option(
        '--overwrite',
        action="store_true", dest="overwrite", default=False,
        help="overwrite images")
    optparser.add_option(
        '--show-all',
        action="store_true", dest="show_all", default=False,
        help="show all images, including similar ones")

    (options, args) = optparser.parse_args(sys.argv[1:])

    if len(args) != 2:
        optparser.error('incorrect number of arguments')

    ref_prefix = args[0]
    src_prefix = args[1]

    ref_images = find_images(ref_prefix)
    src_images = find_images(src_prefix)
    images = list(set(ref_images).intersection(set(src_images)))
    images.sort()

    if options.output:
        html = open(options.output, 'wt')
    else:
        html = sys.stdout
    html.write('<html>\n')
    html.write('  <body>\n')
    html.write('    <table border="1">\n')
    html.write('      <tr><th>File</th><th>%s</th><th>%s</th><th>&Delta;</th></tr>\n' % (ref_prefix, src_prefix))
    failures = 0
    for image in images:
        ref_image = ref_prefix + image
        src_image = src_prefix + image
        root, ext = os.path.splitext(src_image)
        delta_image = "%s.diff.png" % (root, )
        if os.path.exists(ref_image) and os.path.exists(src_image):
            if options.verbose:
                sys.stdout.write('Comparing %s and %s ...' % (ref_image, src_image))
            comparer = Comparer(ref_image, src_image, options.alpha)
            match = comparer.ae(fuzz=options.fuzz) == 0
            if match:
                result = 'MATCH'
                bgcolor = '#20ff20'
            else:
                result = 'MISMATCH'
                failures += 1
                bgcolor = '#ff2020'
            if options.verbose:
                sys.stdout.write(' %s\n' % (result,))
            html.write('      <tr>\n')
            html.write('        <td bgcolor="%s"><a href="%s">%s<a/></td>\n' % (bgcolor, ref_image, image))
            if not match or options.show_all:
                if options.overwrite \
                   or not os.path.exists(delta_image) \
                   or (os.path.getmtime(delta_image) < os.path.getmtime(ref_image) \
                       and os.path.getmtime(delta_image) < os.path.getmtime(src_image)):
                    comparer.write_diff(delta_image, fuzz=options.fuzz)
                surface(html, ref_image)
                surface(html, src_image)
                surface(html, delta_image)
            html.write('      </tr>\n')
            html.flush()
    html.write('    </table>\n')
    html.write('  </body>\n')
    html.write('</html>\n')

    if failures:
        sys.exit(1)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = tracecheck
#!/usr/bin/env python
##########################################################################
#
# Copyright 2011 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the 'Software'), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

'''Check a trace replays successfully or not.

It is meant to be used with git bisect.  See git bisect manpage for more
details.
'''


import optparse
import os.path
import platform
import re
import subprocess
import sys
import traceback

import snapdiff
import retracediff


def good():
    '''Tell git-bisect that this commit is good.'''

    sys.stdout.write('GOOD\n')
    sys.exit(0)


def bad():
    '''Tell git-bisect that this commit is bad.'''

    sys.stdout.write('BAD\n')
    sys.exit(1)


def skip():
    '''Tell git-bisect to skip this commit.'''

    sys.stdout.write('SKIP\n')
    sys.exit(125)


def abort():
    '''Tell git-bisect to abort.'''

    sys.stdout.write('ABORT\n')
    sys.exit(-1)


def which(executable):
    '''Search for the executable on the PATH.'''

    if platform.system() == 'Windows':
        exts = ['.exe']
    else:
        exts = ['']
    dirs = os.environ['PATH'].split(os.path.pathsep)
    for dir in dirs:
        path = os.path.join(dir, executable)
        for ext in exts:
            if os.path.exists(path + ext):
                return True
    return False


def main():
    '''Main program.

    It will always invoke sys.exit(), and never return normally.
    '''

    # Try to guess the build command.
    if os.path.exists('SConstruct'):
        default_build = 'scons'
    elif os.path.exists('Makefile'):
        default_build = 'make'
    else:
        default_build = None

    # Parse command line options
    optparser = optparse.OptionParser(
        usage='\n\tgit bisect run %prog [options] -- [glretrace options] <trace>',
        version='%%prog')
    optparser.add_option(
        '-b', '--build', metavar='COMMAND',
        type='string', dest='build', default=default_build,
        help='build command [default: %default]')
    optparser.add_option(
        '-r', '--retrace', metavar='PROGRAM',
        type='string', dest='retrace', default='glretrace',
        help='retrace command [default: %default]')
    optparser.add_option(
        '-c', '--compare', metavar='PREFIX',
        type='string', dest='compare_prefix', default=None,
        help='snapshot comparison prefix')
    optparser.add_option(
        '--precision-threshold', metavar='BITS',
        type='float', dest='precision_threshold', default=8.0,
        help='precision threshold in bits [default: %default]')
    optparser.add_option(
        '--gl-renderer', metavar='REGEXP',
        type='string', dest='gl_renderer_re', default='^.*$',
        help='require a matching GL_RENDERER string [default: %default]')

    (options, args) = optparser.parse_args(sys.argv[1:])
    if not args:
        optparser.error("incorrect number of arguments")

    # Build the source
    if options.build:
        sys.stdout.write(options.build + '\n')
        sys.stdout.flush()
        returncode = subprocess.call(options.build, shell=True)
        if returncode:
            skip()

    # TODO: For this to be useful on Windows we'll also need an installation
    # procedure here.

    # Do some sanity checks.  In particular we want to make sure that the GL
    # implementation is usable, and is the right one (i.e., we didn't fallback
    # to a different OpenGL implementation due to missing symbols).
    if platform.system() != 'Windows' and which('glxinfo'):
        glxinfo = subprocess.Popen(['glxinfo'], stdout=subprocess.PIPE)
        stdout, stderr = glxinfo.communicate()
        if glxinfo.returncode:
            skip()

        # Search for the GL_RENDERER string
        gl_renderer_header = 'OpenGL renderer string: '
        gl_renderer = ''
        for line in stdout.split('\n'):
            if line.startswith(gl_renderer_header):
                gl_renderer = line[len(gl_renderer_header):]
            if line.startswith('direct rendering: No'):
                sys.stderr.write('Indirect rendering.\n')
                skip()

        # and match it against the regular expression specified in the command
        # line.
        if not re.search(options.gl_renderer_re, gl_renderer):
            sys.stderr.write("GL_RENDERER mismatch: %r !~ /%s/\n"  % (gl_renderer, options.gl_renderer_re))
            skip()

    # Run glretrace
    
    retracer = retracediff.Retracer(options.retrace, args)

    if options.compare_prefix:
        refImages = {}
        callNos = []
            
        images = snapdiff.find_images(options.compare_prefix)
        images.sort()
        for image in images:
            imageName, ext = os.path.splitext(image)
            try:
                callNo = int(imageName)
            except ValueError:
                continue
            refImages[callNo] = options.compare_prefix + image
            callNos.append(callNo)

        run = retracer.snapshot(','.join(map(str, callNos)))
        while True:
            srcImage, callNo = run.nextSnapshot()
            if srcImage is None:
                break

            refImage = refImages[callNo]

            # Compare the two images
            comparer = snapdiff.Comparer(refImage, srcImage)
            precision = comparer.precision()

            mismatch = precision < options.precision_threshold
            if mismatch:
                bad()
        run.process.wait()
        if run.process.returncode:
            skip()
    else:
        returncode = retracer.retrace('-b')
        if returncode:
            bad()

    # TODO: allow more criterias here, such as, performance threshold

    # Success
    good()


# Invoke main program, aborting the bisection on Ctrl+C or any uncaught Python
# exception.
if __name__ == '__main__':
    try:
        main()
    except SystemExit:
        raise
    except KeyboardInterrupt:
        abort()
    except:
        traceback.print_exc()
        abort()

########NEW FILE########
__FILENAME__ = tracediff
#!/usr/bin/env python
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


import difflib
import itertools
import optparse
import os.path
import platform
import shutil
import subprocess
import sys
import tempfile


##########################################################################/
#
# Abstract interface
#


class Differ:

    def __init__(self, apitrace):
        self.apitrace = apitrace
        self.isatty = sys.stdout.isatty()

    def setRefTrace(self, ref_trace, ref_calls):
        raise NotImplementedError

    def setSrcTrace(self, src_trace, src_calls):
        raise NotImplementedError

    def diff(self):
        raise NotImplementedError


##########################################################################/
#
# External diff tool
#


class AsciiDumper:

    def __init__(self, apitrace, trace, calls, callNos):
        self.output = tempfile.NamedTemporaryFile()

        dump_args = [
            apitrace,
            'dump',
            '--color=never',
            '--call-nos=' + ('yes' if callNos else 'no'),
            '--arg-names=no',
            '--calls=' + calls,
            trace
        ]

        self.dump = subprocess.Popen(
            args = dump_args,
            stdout = self.output,
            universal_newlines = True,
        )


class ExternalDiffer(Differ):

    if platform.system() == 'Windows':
        start_delete = ''
        end_delete   = ''
        start_insert = ''
        end_insert   = ''
    else:
        start_delete = '\33[9m\33[31m'
        end_delete   = '\33[0m'
        start_insert = '\33[32m'
        end_insert   = '\33[0m'

    def __init__(self, apitrace, tool, width=None, callNos = False):
        Differ.__init__(self, apitrace)
        self.diff_args = [tool]
        if tool == 'diff':
            self.diff_args += [
                '--speed-large-files',
            ]
            if self.isatty:
                self.diff_args += [
                    '--old-line-format=' + self.start_delete + '%l' + self.end_delete + '\n',
                    '--new-line-format=' + self.start_insert + '%l' + self.end_insert + '\n',
                ]
        elif tool == 'sdiff':
            if width is None:
                import curses
                curses.setupterm()
                width = curses.tigetnum('cols')
            self.diff_args += [
                '--width=%u' % width,
                '--speed-large-files',
            ]
        elif tool == 'wdiff':
            self.diff_args += [
                #'--terminal',
                '--avoid-wraps',
            ]
            if self.isatty:
                self.diff_args += [
                    '--start-delete=' + self.start_delete,
                    '--end-delete=' + self.end_delete,
                    '--start-insert=' + self.start_insert,
                    '--end-insert=' + self.end_insert,
                ]
        else:
            assert False
        self.callNos = callNos

    def setRefTrace(self, ref_trace, ref_calls):
        self.ref_dumper = AsciiDumper(self.apitrace, ref_trace, ref_calls, self.callNos)

    def setSrcTrace(self, src_trace, src_calls):
        self.src_dumper = AsciiDumper(self.apitrace, src_trace, src_calls, self.callNos)

    def diff(self):
        diff_args = self.diff_args + [
            self.ref_dumper.output.name,
            self.src_dumper.output.name,
        ]

        self.ref_dumper.dump.wait()
        self.src_dumper.dump.wait()

        less = None
        diff_stdout = None
        if self.isatty:
            try:
                less = subprocess.Popen(
                    args = ['less', '-FRXn'],
                    stdin = subprocess.PIPE
                )
            except OSError:
                pass
            else:
                diff_stdout = less.stdin

        diff = subprocess.Popen(
            args = diff_args,
            stdout = diff_stdout,
            universal_newlines = True,
        )

        diff.wait()

        if less is not None:
            less.stdin.close()
            less.wait()


##########################################################################/
#
# Python diff
#

from unpickle import Unpickler, Dumper, Rebuilder
from highlight import PlainHighlighter, LessHighlighter


ignoredFunctionNames = set([
    'glGetString',
    'glXGetClientString',
    'glXGetCurrentDisplay',
    'glXGetCurrentContext',
    'glXGetProcAddress',
    'glXGetProcAddressARB',
    'wglGetProcAddress',
])


class Blob:
    '''Data-less proxy for bytearrays, to save memory.'''

    def __init__(self, size, hash):
        self.size = size
        self.hash = hash

    def __repr__(self):
        return 'blob(%u)' % self.size

    def __eq__(self, other):
        return isinstance(other, Blob) and self.size == other.size and self.hash == other.hash

    def __hash__(self):
        return self.hash


class BlobReplacer(Rebuilder):
    '''Replace blobs with proxys.'''

    def visitByteArray(self, obj):
        return Blob(len(obj), hash(str(obj)))

    def visitCall(self, call):
        call.args = map(self.visit, call.args)
        call.ret = self.visit(call.ret)


class Loader(Unpickler):

    def __init__(self, stream):
        Unpickler.__init__(self, stream)
        self.calls = []
        self.rebuilder = BlobReplacer()

    def handleCall(self, call):
        if call.functionName not in ignoredFunctionNames:
            self.rebuilder.visitCall(call)
            self.calls.append(call)


class PythonDiffer(Differ):

    def __init__(self, apitrace, callNos = False):
        Differ.__init__(self, apitrace)
        self.a = None
        self.b = None
        if self.isatty:
            self.highlighter = LessHighlighter()
        else:
            self.highlighter = PlainHighlighter()
        self.delete_color = self.highlighter.red
        self.insert_color = self.highlighter.green
        self.callNos = callNos
        self.aSpace = 0
        self.bSpace = 0
        self.dumper = Dumper()

    def setRefTrace(self, ref_trace, ref_calls):
        self.a = self.readTrace(ref_trace, ref_calls)

    def setSrcTrace(self, src_trace, src_calls):
        self.b = self.readTrace(src_trace, src_calls)

    def readTrace(self, trace, calls):
        p = subprocess.Popen(
            args = [
                self.apitrace,
                'pickle',
                '--symbolic',
                '--calls=' + calls,
                trace
            ],
            stdout = subprocess.PIPE,
        )

        parser = Loader(p.stdout)
        parser.parse()
        return parser.calls

    def diff(self):
        try:
            self._diff()
        except IOError:
            pass

    def _diff(self):
        matcher = difflib.SequenceMatcher(self.isjunk, self.a, self.b)
        for tag, alo, ahi, blo, bhi in matcher.get_opcodes():
            if tag == 'replace':
                self.replace(alo, ahi, blo, bhi)
            elif tag == 'delete':
                self.delete(alo, ahi, blo, bhi)
            elif tag == 'insert':
                self.insert(alo, ahi, blo, bhi)
            elif tag == 'equal':
                self.equal(alo, ahi, blo, bhi)
            else:
                raise ValueError, 'unknown tag %s' % (tag,)

    def isjunk(self, call):
        return call.functionName == 'glGetError' and call.ret in ('GL_NO_ERROR', 0)

    def replace(self, alo, ahi, blo, bhi):
        assert alo < ahi and blo < bhi

        a_names = [call.functionName for call in self.a[alo:ahi]]
        b_names = [call.functionName for call in self.b[blo:bhi]]

        matcher = difflib.SequenceMatcher(None, a_names, b_names)
        for tag, _alo, _ahi, _blo, _bhi in matcher.get_opcodes():
            _alo += alo
            _ahi += alo
            _blo += blo
            _bhi += blo
            if tag == 'replace':
                self.replace_dissimilar(_alo, _ahi, _blo, _bhi)
            elif tag == 'delete':
                self.delete(_alo, _ahi, _blo, _bhi)
            elif tag == 'insert':
                self.insert(_alo, _ahi, _blo, _bhi)
            elif tag == 'equal':
                self.replace_similar(_alo, _ahi, _blo, _bhi)
            else:
                raise ValueError, 'unknown tag %s' % (tag,)

    def replace_similar(self, alo, ahi, blo, bhi):
        assert alo < ahi and blo < bhi
        assert ahi - alo == bhi - blo
        for i in xrange(0, bhi - blo):
            self.highlighter.write('| ')
            a_call = self.a[alo + i]
            b_call = self.b[blo + i]
            assert a_call.functionName == b_call.functionName
            self.dumpCallNos(a_call.no, b_call.no)
            self.highlighter.bold(True)
            self.highlighter.write(b_call.functionName)
            self.highlighter.bold(False)
            self.highlighter.write('(')
            sep = ''
            numArgs = max(len(a_call.args), len(b_call.args))
            for j in xrange(numArgs):
                self.highlighter.write(sep)
                try:
                    a_arg = a_call.args[j]
                except IndexError:
                    pass
                try:
                    b_arg = b_call.args[j]
                except IndexError:
                    pass
                self.replace_value(a_arg, b_arg)
                sep = ', '
            self.highlighter.write(')')
            if a_call.ret is not None or b_call.ret is not None:
                self.highlighter.write(' = ')
                self.replace_value(a_call.ret, b_call.ret)
            self.highlighter.write('\n')

    def replace_dissimilar(self, alo, ahi, blo, bhi):
        assert alo < ahi and blo < bhi
        if bhi - blo < ahi - alo:
            self.insert(alo, alo, blo, bhi)
            self.delete(alo, ahi, bhi, bhi)
        else:
            self.delete(alo, ahi, blo, blo)
            self.insert(ahi, ahi, blo, bhi)

    def replace_value(self, a, b):
        if b == a:
            self.highlighter.write(self.dumper.visit(b))
        else:
            self.highlighter.strike()
            self.highlighter.color(self.delete_color)
            self.highlighter.write(self.dumper.visit(a))
            self.highlighter.normal()
            self.highlighter.write(" ")
            self.highlighter.color(self.insert_color)
            self.highlighter.write(self.dumper.visit(b))
            self.highlighter.normal()

    escape = "\33["

    def delete(self, alo, ahi, blo, bhi):
        assert alo < ahi
        assert blo == bhi
        for i in xrange(alo, ahi):
            call = self.a[i]
            self.highlighter.write('- ')
            self.dumpCallNos(call.no, None)
            self.highlighter.strike()
            self.highlighter.color(self.delete_color)
            self.dumpCall(call)

    def insert(self, alo, ahi, blo, bhi):
        assert alo == ahi
        assert blo < bhi
        for i in xrange(blo, bhi):
            call = self.b[i]
            self.highlighter.write('+ ')
            self.dumpCallNos(None, call.no)
            self.highlighter.color(self.insert_color)
            self.dumpCall(call)

    def equal(self, alo, ahi, blo, bhi):
        assert alo < ahi and blo < bhi
        assert ahi - alo == bhi - blo
        for i in xrange(0, bhi - blo):
            self.highlighter.write('  ')
            a_call = self.a[alo + i]
            b_call = self.b[blo + i]
            assert a_call.functionName == b_call.functionName
            assert len(a_call.args) == len(b_call.args)
            self.dumpCallNos(a_call.no, b_call.no)
            self.dumpCall(b_call)

    def dumpCallNos(self, aNo, bNo):
        if not self.callNos:
            return

        if aNo is not None and bNo is not None and aNo == bNo:
            aNoStr = str(aNo)
            self.highlighter.write(aNoStr)
            self.aSpace = len(aNoStr)
            self.bSpace = self.aSpace
            self.highlighter.write(' ')
            return

        if aNo is None:
            self.highlighter.write(' '*self.aSpace)
        else:
            aNoStr = str(aNo)
            self.highlighter.strike()
            self.highlighter.color(self.delete_color)
            self.highlighter.write(aNoStr)
            self.highlighter.normal()
            self.aSpace = len(aNoStr)
        self.highlighter.write(' ')
        if bNo is None:
            self.highlighter.write(' '*self.bSpace)
        else:
            bNoStr = str(bNo)
            self.highlighter.color(self.insert_color)
            self.highlighter.write(bNoStr)
            self.highlighter.normal()
            self.bSpace = len(bNoStr)
        self.highlighter.write(' ')

    def dumpCall(self, call):
        self.highlighter.bold(True)
        self.highlighter.write(call.functionName)
        self.highlighter.bold(False)
        self.highlighter.write('(' + ', '.join(itertools.imap(self.dumper.visit, call.args)) + ')')
        if call.ret is not None:
            self.highlighter.write(' = ' + self.dumper.visit(call.ret))
        self.highlighter.normal()
        self.highlighter.write('\n')



##########################################################################/
#
# Main program
#


def which(executable):
    '''Search for the executable on the PATH.'''

    if platform.system() == 'Windows':
        exts = ['.exe']
    else:
        exts = ['']
    dirs = os.environ['PATH'].split(os.path.pathsep)
    for dir in dirs:
        path = os.path.join(dir, executable)
        for ext in exts:
            if os.path.exists(path + ext):
                return True
    return False


def main():
    '''Main program.
    '''

    # Parse command line options
    optparser = optparse.OptionParser(
        usage='\n\t%prog [options] TRACE TRACE',
        version='%%prog')
    optparser.add_option(
        '-a', '--apitrace', metavar='PROGRAM',
        type='string', dest='apitrace', default='apitrace',
        help='apitrace command [default: %default]')
    optparser.add_option(
        '-t', '--tool', metavar='TOOL',
        type="choice", choices=('diff', 'sdiff', 'wdiff', 'python'),
        dest="tool", default=None,
        help="diff tool: diff, sdiff, wdiff, or python [default: auto]")
    optparser.add_option(
        '-c', '--calls', metavar='CALLSET',
        type="string", dest="calls", default='0-10000',
        help="calls to compare [default: %default]")
    optparser.add_option(
        '--ref-calls', metavar='CALLSET',
        type="string", dest="ref_calls", default=None,
        help="calls to compare from reference trace")
    optparser.add_option(
        '--src-calls', metavar='CALLSET',
        type="string", dest="src_calls", default=None,
        help="calls to compare from source trace")
    optparser.add_option(
        '--call-nos',
        action="store_true",
        dest="call_nos", default=False,
        help="dump call numbers")
    optparser.add_option(
        '-w', '--width', metavar='NUM',
        type="int", dest="width",
        help="columns [default: auto]")

    (options, args) = optparser.parse_args(sys.argv[1:])
    if len(args) != 2:
        optparser.error("incorrect number of arguments")

    if options.tool is None:
        if platform.system() == 'Windows':
            options.tool = 'python'
        else:
            if which('wdiff'):
                options.tool = 'wdiff'
            else:
                sys.stderr.write('warning: wdiff not found\n')
                if which('sdiff'):
                    options.tool = 'sdiff'
                else:
                    sys.stderr.write('warning: sdiff not found\n')
                    options.tool = 'diff'

    if options.ref_calls is None:
        options.ref_calls = options.calls
    if options.src_calls is None:
        options.src_calls = options.calls

    ref_trace, src_trace = args

    if options.tool == 'python':
        differ = PythonDiffer(options.apitrace, options.call_nos)
    else:
        differ = ExternalDiffer(options.apitrace, options.tool, options.width, options.call_nos)
    differ.setRefTrace(ref_trace, options.ref_calls)
    differ.setSrcTrace(src_trace, options.src_calls)
    differ.diff()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = unpickle
#!/usr/bin/env python
##########################################################################
#
# Copyright 2012 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

'''Sample program for apitrace pickle command.

Run as:

   apitrace pickle foo.trace | python unpickle.py

'''


import itertools
import optparse
import sys
import time
import re
import cPickle as pickle


class Visitor:

    def __init__(self):
        self.dispatch = {}
        self.dispatch[type(None)] = self.visitNone
        self.dispatch[bool] = self.visitBool
        self.dispatch[int] = self.visitInt
        self.dispatch[long] = self.visitInt
        self.dispatch[float] = self.visitFloat
        self.dispatch[str] = self.visitStr
        self.dispatch[tuple] = self.visitTuple
        self.dispatch[list] = self.visitList
        self.dispatch[dict] = self.visitDict
        self.dispatch[bytearray] = self.visitByteArray

    def visit(self, obj):
        method = self.dispatch.get(type(obj), self.visitObj)
        return method(obj)

    def visitObj(self, obj):
        raise NotImplementedError

    def visitAtom(self, obj):
        return self.visitObj(obj)

    def visitNone(self, obj):
        return self.visitAtom(obj)

    def visitBool(self, obj):
        return self.visitAtom(obj)

    def visitInt(self, obj):
        return self.visitAtom(obj)

    def visitFloat(self, obj):
        return self.visitAtom(obj)

    def visitStr(self, obj):
        return self.visitAtom(obj)

    def visitIterable(self, obj):
        return self.visitObj(obj)

    def visitTuple(self, obj):
        return self.visitIterable(obj)

    def visitList(self, obj):
        return self.visitIterable(obj)

    def visitDict(self, obj):
        raise NotImplementedError

    def visitByteArray(self, obj):
        raise NotImplementedError


class Dumper(Visitor):

    id_re = re.compile('^[_A-Za-z][_A-Za-z0-9]*$')

    def visitObj(self, obj):
        return repr(obj)

    def visitStr(self, obj):
        if self.id_re.match(obj):
            return obj
        else:
            return repr(obj)

    def visitTuple(self, obj):
        return '[' + ', '.join(itertools.imap(self.visit, obj)) + ']'

    def visitList(self, obj):
        return '(' + ', '.join(itertools.imap(self.visit, obj)) + ')'

    def visitByteArray(self, obj):
        return 'blob(%u)' % len(obj)


class Hasher(Visitor):
    '''Returns a hashable version of the objtree.'''

    def visitObj(self, obj):
        return obj

    def visitAtom(self, obj):
        return obj

    def visitIterable(self, obj):
        return tuple(itertools.imap(self.visit, obj))

    def visitByteArray(self, obj):
        return str(obj)


class Rebuilder(Visitor):
    '''Returns a hashable version of the objtree.'''

    def visitAtom(self, obj):
        return obj

    def visitIterable(self, obj):
        changed = False
        newItems = []
        for oldItem in obj:
            newItem = self.visit(oldItem)
            if newItem is not oldItem:
                changed = True
            newItems.append(newItem)
        if changed:
            klass = type(obj)
            return klass(newItems)
        else:
            return obj

    def visitByteArray(self, obj):
        return obj


class Call:

    def __init__(self, callTuple):
        self.no, self.functionName, self.args, self.ret = callTuple
        self._hash = None

    def __str__(self):
        s = self.functionName
        if self.no is not None:
            s = str(self.no) + ' ' + s
        dumper = Dumper()
        s += '(' + ', '.join(itertools.imap(dumper.visit, self.args)) + ')'
        if self.ret is not None:
            s += ' = '
            s += dumper.visit(self.ret)
        return s

    def __eq__(self, other):
        return \
            self.functionName == other.functionName and \
            self.args == other.args and \
            self.ret == other.ret

    def __hash__(self):
        if self._hash is None:
            hasher = Hasher()
            hashable = hasher.visit(self.functionName), hasher.visit(self.args), hasher.visit(self.ret)
            self._hash = hash(hashable)
        return self._hash


class Unpickler:

    callFactory = Call

    def __init__(self, stream):
        self.stream = stream

    def parse(self):
        while self.parseCall():
            pass

    def parseCall(self):
        try:
            callTuple = pickle.load(self.stream)
        except EOFError:
            return False
        else:
            call = self.callFactory(callTuple)
            self.handleCall(call)
            return True

    def handleCall(self, call):
        pass


class Counter(Unpickler):

    def __init__(self, stream, verbose = False):
        Unpickler.__init__(self, stream)
        self.verbose = verbose
        self.numCalls = 0
        self.functionFrequencies = {}

    def parse(self):
        Unpickler.parse(self)

        functionFrequencies = self.functionFrequencies.items()
        functionFrequencies.sort(lambda (name1, freq1), (name2, freq2): cmp(freq1, freq2))
        for name, frequency in functionFrequencies:
            sys.stdout.write('%8u %s\n' % (frequency, name))

    def handleCall(self, call):
        if self.verbose:
            sys.stdout.write(str(call))
            sys.stdout.write('\n')
        self.numCalls += 1
        try:
            self.functionFrequencies[call.functionName] += 1
        except KeyError:
            self.functionFrequencies[call.functionName] = 1


def main():
    optparser = optparse.OptionParser(
        usage="\n\tapitrace pickle <trace> | %prog [options]")
    optparser.add_option(
        '-p', '--profile',
        action="store_true", dest="profile", default=False,
        help="profile call parsing")
    optparser.add_option(
        '-v', '--verbose',
        action="store_true", dest="verbose", default=False,
        help="dump calls to stdout")

    (options, args) = optparser.parse_args(sys.argv[1:])

    if args:
        optparser.error('unexpected arguments')

    # Change stdin to binary mode
    try:
        import msvcrt
    except ImportError:
        pass
    else:
        import os
        msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)

    startTime = time.time()
    parser = Counter(sys.stdin, options.verbose)
    parser.parse()
    stopTime = time.time()
    duration = stopTime - startTime

    if options.profile:
        sys.stderr.write('Processed %u calls in %.03f secs, at %u calls/sec\n' % (parser.numCalls, duration, parser.numCalls/duration))


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = cglapi
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""CGL API description.

http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Reference/CGL_OpenGL/Reference/reference.html
"""


from stdapi import *
from glapi import *
from glapi import glapi

IOSurfaceRef = Opaque("IOSurfaceRef")
CGLContextObj = Opaque("CGLContextObj")
CGLPixelFormatObj = Opaque("CGLPixelFormatObj")
CGLRendererInfoObj = Opaque("CGLRendererInfoObj")
CGLPBufferObj = Opaque("CGLPBufferObj")
CGLShareGroup = Opaque("CGLShareGroup")
CGLShareGroupObj = Opaque("CGLShareGroupObj")
CGSConnectionID = Opaque("CGSConnectionID")
CGSWindowID = Alias("CGSWindowID", Int)
CGSSurfaceID = Alias("CGSSurfaceID", Int)

CGLOpenGLProfile = Enum("CGLOpenGLProfile", [
    'kCGLOGLPVersion_Legacy',
    'kCGLOGLPVersion_3_2_Core',
    #'kCGLOGLPVersion_GL3_Core', # Same as kCGLOGLPVersion_3_2_Core
    'kCGLOGLPVersion_GL4_Core',
])

CGLPixelFormatAttributes = [
    ("kCGLPFAAllRenderers", None),
    ("kCGLPFATripleBuffer", None),
    ("kCGLPFADoubleBuffer", None),
    ("kCGLPFAStereo", None),
    ("kCGLPFAColorSize", Int),
    ("kCGLPFAAlphaSize", Int),
    ("kCGLPFADepthSize", Int),
    ("kCGLPFAStencilSize", Int),
    ("kCGLPFAMinimumPolicy", None),
    ("kCGLPFAMaximumPolicy", None),
    ("kCGLPFASampleBuffers", Int),
    ("kCGLPFASamples", Int),
    ("kCGLPFAColorFloat", None),
    ("kCGLPFAMultisample", None),
    ("kCGLPFASupersample", None),
    ("kCGLPFASampleAlpha", None),
    ("kCGLPFARendererID", Int),
    ("kCGLPFANoRecovery", None),
    ("kCGLPFAAccelerated", None),
    ("kCGLPFAClosestPolicy", None),
    ("kCGLPFABackingStore", None),
    ("kCGLPFABackingVolatile", None),
    ("kCGLPFADisplayMask", Int),
    ("kCGLPFAAllowOfflineRenderers", None),
    ("kCGLPFAAcceleratedCompute", None),
    ("kCGLPFAOpenGLProfile", CGLOpenGLProfile),
    ("kCGLPFASupportsAutomaticGraphicsSwitching", None),
    ("kCGLPFAVirtualScreenCount", Int),
    ("kCGLPFAAuxBuffers", None),
    ("kCGLPFAAccumSize", Int),
    ("kCGLPFAAuxDepthStencil", None),
    ("kCGLPFAOffScreen", None),
    ("kCGLPFAWindow", None),
    ("kCGLPFACompliant", None),
    ("kCGLPFAPBuffer", None),
    ("kCGLPFARemotePBuffer", None),
    ("kCGLPFASingleRenderer", None),
    ("kCGLPFARobust", None),
    ("kCGLPFAMPSafe", None),
    ("kCGLPFAMultiScreen", None),
    ("kCGLPFAFullScreen", None),
]

CGLPixelFormatAttribute = Enum("CGLPixelFormatAttribute",
    [attrib for attrib, _ in CGLPixelFormatAttributes]
)

CGLPixelFormatAttribs = AttribArray(
    Const(CGLPixelFormatAttribute),
    CGLPixelFormatAttributes
)

CGLRendererProperty = Enum("CGLRendererProperty", [
    "kCGLRPOffScreen",
    "kCGLRPFullScreen",
    "kCGLRPRendererID",
    "kCGLRPAccelerated",
    "kCGLRPRobust",
    "kCGLRPBackingStore",
    "kCGLRPMPSafe",
    "kCGLRPWindow",
    "kCGLRPMultiScreen",
    "kCGLRPCompliant",
    "kCGLRPDisplayMask",
    "kCGLRPBufferModes",
    "kCGLRPColorModes",
    "kCGLRPAccumModes",
    "kCGLRPDepthModes",
    "kCGLRPStencilModes",
    "kCGLRPMaxAuxBuffers",
    "kCGLRPMaxSampleBuffers",
    "kCGLRPMaxSamples",
    "kCGLRPSampleModes",
    "kCGLRPSampleAlpha",
    "kCGLRPVideoMemory",
    "kCGLRPTextureMemory",
    "kCGLRPGPUVertProcCapable",
    "kCGLRPGPUFragProcCapable",
    "kCGLRPRendererCount",
    "kCGLRPOnline",
    "kCGLRPAcceleratedCompute",
    "kCGLRPVideoMemoryMegabytes",
    "kCGLRPTextureMemoryMegabytes",
    "kCGLRPMajorGLVersion",
])

CGLContextEnable = Enum("CGLContextEnable", [
    "kCGLCESwapRectangle",
    "kCGLCESwapLimit",
    "kCGLCERasterization",
    "kCGLCEStateValidation",
    "kCGLCESurfaceBackingSize",
    "kCGLCEDisplayListOptimization",
    "kCGLCEMPEngine",
    "kCGLCECrashOnRemovedFunctions",
])

CGLContextParameter = Enum("CGLContextParameter", [
    "kCGLCPSwapRectangle",
    "kCGLCPSwapInterval",
    "kCGLCPDispatchTableSize",
    "kCGLCPClientStorage",
    "kCGLCPSurfaceTexture",
    "kCGLCPSurfaceOrder",
    "kCGLCPSurfaceOpacity",
    "kCGLCPSurfaceBackingSize",
    "kCGLCPSurfaceSurfaceVolatile",
    "kCGLCPReclaimResources",
    "kCGLCPCurrentRendererID",
    "kCGLCPGPUVertexProcessing",
    "kCGLCPGPUFragmentProcessing",
    "kCGLCPHasDrawable",
    "kCGLCPMPSwapsInFlight",
])

CGLGlobalOption = Enum("CGLGlobalOption", [
    "kCGLGOFormatCacheSize",
    "kCGLGOClearFormatCache",
    "kCGLGORetainRenderers",
    "kCGLGOResetLibrary",
    "kCGLGOUseErrorHandler",
    "kCGLGOUseBuildCache",
])

CGLError = Enum("CGLError", [
    "kCGLNoError",
    "kCGLBadAttribute",
    "kCGLBadProperty",
    "kCGLBadPixelFormat",
    "kCGLBadRendererInfo",
    "kCGLBadContext",
    "kCGLBadDrawable",
    "kCGLBadDisplay",
    "kCGLBadState",
    "kCGLBadValue",
    "kCGLBadMatch",
    "kCGLBadEnumeration",
    "kCGLBadOffScreen",
    "kCGLBadFullScreen",
    "kCGLBadWindow",
    "kCGLBadAddress",
    "kCGLBadCodeModule",
    "kCGLBadAlloc",
    "kCGLBadConnection",
])

CGLContextObj = Opaque("CGLContextObj")

cglapi = Module("CGL")

cglapi.addFunctions([
    # CGLCurrent.h, libGL.dylib
    Function(CGLError, "CGLSetCurrentContext", [(CGLContextObj, "ctx")]),
    Function(CGLContextObj, "CGLGetCurrentContext", []),

    # OpenGL.h, OpenGL framework
    Function(CGLError, "CGLChoosePixelFormat", [(CGLPixelFormatAttribs, "attribs"), Out(Pointer(CGLPixelFormatObj), "pix"), Out(Pointer(GLint), "npix")]),
    Function(CGLError, "CGLDestroyPixelFormat", [(CGLPixelFormatObj, "pix")]),
    Function(CGLError, "CGLDescribePixelFormat", [(CGLPixelFormatObj, "pix"), (GLint, "pix_num"), (CGLPixelFormatAttribute, "attrib"), Out(Pointer(GLint), "value")], sideeffects=False),
    Function(Void, "CGLReleasePixelFormat", [(CGLPixelFormatObj, "pix")]),
    Function(CGLPixelFormatObj, "CGLRetainPixelFormat", [(CGLPixelFormatObj, "pix")]),
    Function(GLuint, "CGLGetPixelFormatRetainCount", [(CGLPixelFormatObj, "pix")]),
    Function(CGLError, "CGLQueryRendererInfo", [(GLuint, "display_mask"), Out(Pointer(CGLRendererInfoObj), "rend"), Out(Pointer(GLint), "nrend")]),
    Function(CGLError, "CGLDestroyRendererInfo", [(CGLRendererInfoObj, "rend")]),
    Function(CGLError, "CGLDescribeRenderer", [(CGLRendererInfoObj, "rend"), (GLint, "rend_num"), (CGLRendererProperty, "prop"), Out(Pointer(GLint), "value")], sideeffects=False),
    Function(CGLError, "CGLCreateContext", [(CGLPixelFormatObj, "pix"), (CGLContextObj, "share"), Out(Pointer(CGLContextObj), "ctx")]),
    Function(CGLError, "CGLDestroyContext", [(CGLContextObj, "ctx")]),
    Function(CGLError, "CGLCopyContext", [(CGLContextObj, "src"), (CGLContextObj, "dst"), (GLbitfield, "mask")]),
    Function(CGLContextObj, "CGLRetainContext", [(CGLContextObj, "ctx")]),
    Function(Void, "CGLReleaseContext", [(CGLContextObj, "ctx")]),
    Function(GLuint, "CGLGetContextRetainCount", [(CGLContextObj, "ctx")]),
    Function(CGLPixelFormatObj, "CGLGetPixelFormat", [(CGLContextObj, "ctx")]),
    Function(CGLError, "CGLCreatePBuffer", [(GLsizei, "width"), (GLsizei, "height"), (GLenum, "target"), (GLenum, "internalFormat"), (GLint, "max_level"), Out(Pointer(CGLPBufferObj), "pbuffer")]),
    Function(CGLError, "CGLDestroyPBuffer", [(CGLPBufferObj, "pbuffer")]),
    Function(CGLError, "CGLDescribePBuffer", [(CGLPBufferObj, "obj"), Out(Pointer(GLsizei), "width"), Out(Pointer(GLsizei), "height"), Out(Pointer(GLenum), "target"), Out(Pointer(GLenum), "internalFormat"), Out(Pointer(GLint), "mipmap")]),
    Function(CGLError, "CGLTexImagePBuffer", [(CGLContextObj, "ctx"), (CGLPBufferObj, "pbuffer"), (GLenum, "source")]),
    Function(CGLPBufferObj, "CGLRetainPBuffer", [(CGLPBufferObj, "pbuffer")]),
    Function(Void, "CGLReleasePBuffer", [(CGLPBufferObj, "pbuffer")]),
    Function(GLuint, "CGLGetPBufferRetainCount", [(CGLPBufferObj, "pbuffer")]),
    Function(CGLError, "CGLSetOffScreen", [(CGLContextObj, "ctx"), (GLsizei, "width"), (GLsizei, "height"), (GLint, "rowbytes"), (OpaquePointer(Void), "baseaddr")]),
    Function(CGLError, "CGLGetOffScreen", [(CGLContextObj, "ctx"), Out(Pointer(GLsizei), "width"), Out(Pointer(GLsizei), "height"), Out(Pointer(GLint), "rowbytes"), Out(Pointer(OpaquePointer(Void)), "baseaddr")]),
    Function(CGLError, "CGLSetFullScreen", [(CGLContextObj, "ctx")]),
    Function(CGLError, "CGLSetFullScreenOnDisplay", [(CGLContextObj, "ctx"), (GLuint, "display_mask")]),
    Function(CGLError, "CGLSetPBuffer", [(CGLContextObj, "ctx"), (CGLPBufferObj, "pbuffer"), (GLenum, "face"), (GLint, "level"), (GLint, "screen")]),
    Function(CGLError, "CGLGetPBuffer", [(CGLContextObj, "ctx"), Out(Pointer(CGLPBufferObj), "pbuffer"), Out(Pointer(GLenum), "face"), Out(Pointer(GLint), "level"), Out(Pointer(GLint), "screen")]),
    Function(CGLError, "CGLClearDrawable", [(CGLContextObj, "ctx")]),
    Function(CGLError, "CGLFlushDrawable", [(CGLContextObj, "ctx")]),
    Function(CGLError, "CGLEnable", [(CGLContextObj, "ctx"), (CGLContextEnable, "pname")]),
    Function(CGLError, "CGLDisable", [(CGLContextObj, "ctx"), (CGLContextEnable, "pname")]),
    Function(CGLError, "CGLIsEnabled", [(CGLContextObj, "ctx"), (CGLContextEnable, "pname"), Out(Pointer(GLint), "enable")], sideeffects=False),
    Function(CGLError, "CGLSetParameter", [(CGLContextObj, "ctx"), (CGLContextParameter, "pname"), (Array(Const(GLint), 1), "params")]),
    Function(CGLError, "CGLGetParameter", [(CGLContextObj, "ctx"), (CGLContextParameter, "pname"), Out(Array(GLint, 1), "params")], sideeffects=False),
    Function(CGLError, "CGLSetVirtualScreen", [(CGLContextObj, "ctx"), (GLint, "screen")]),
    Function(CGLError, "CGLGetVirtualScreen", [(CGLContextObj, "ctx"), Out(Pointer(GLint), "screen")], sideeffects=False),
    Function(CGLError, "CGLSetGlobalOption", [(CGLGlobalOption, "pname"), (OpaquePointer(Const(GLint)), "params")]),
    Function(CGLError, "CGLGetGlobalOption", [(CGLGlobalOption, "pname"), Out(OpaquePointer(GLint), "params")], sideeffects=False),
    Function(CGLError, "CGLSetOption", [(CGLGlobalOption, "pname"), (GLint, "param")]),
    Function(CGLError, "CGLGetOption", [(CGLGlobalOption, "pname"), Out(Pointer(GLint), "param")], sideeffects=False),
    Function(CGLError, "CGLLockContext", [(CGLContextObj, "ctx")]),
    Function(CGLError, "CGLUnlockContext", [(CGLContextObj, "ctx")]),
    Function(Void, "CGLGetVersion", [Out(Pointer(GLint), "majorvers"), Out(Pointer(GLint), "minorvers")], sideeffects=False),
    Function(ConstCString, "CGLErrorString", [(CGLError, "error")], sideeffects=False),

    # CGLIOSurface.h, OpenGL framework
    Function(CGLError, "CGLTexImageIOSurface2D", [(CGLContextObj, "ctx"), (GLenum, "target"), (GLenum, "internal_format"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLenum, "type"), (IOSurfaceRef, "ioSurface"), (GLuint, "plane")]),

    # CGLDevice.h, OpenGL framework
    Function(CGLShareGroupObj, "CGLGetShareGroup", [(CGLContextObj, "ctx")]),

    # Undocumented, OpenGL framework
    Function(CGLError, "CGLSetSurface", [(CGLContextObj, "ctx"), (CGSConnectionID, "cid"), (CGSWindowID, "wid"), (CGSSurfaceID, "sid")]),
    Function(CGLError, "CGLGetSurface", [(CGLContextObj, "ctx"), Out(Pointer(CGSConnectionID), "cid"), Out(Pointer(CGSWindowID), "wid"), Out(Pointer(CGSSurfaceID), "sid")]),
    Function(CGLError, "CGLUpdateContext", [(CGLContextObj, "ctx")]),
    # XXX: All the following prototypes are little more than guesses
    # TODO: A potentially simpler alternative would be to use the
    # DYLD_INTERPOSE mechanism and only intercept the calls that we
    # really care about
    Function(CGLError, "CGLOpenCLMuxLockDown", [], internal=True),
    Function(GLboolean, "CGLAreContextsShared", [(CGLContextObj, "ctx1"), (CGLContextObj, "ctx2")], internal=True),
    Function(CGLContextObj, "CGLGetNextContext", [(CGLContextObj, "ctx")], internal=True),
    Function(OpaquePointer(Void), "CGLFrontDispatch", [(CGLContextObj, "ctx")], internal=True),
    Function(OpaquePointer(Void), "CGLBackDispatch", [(CGLContextObj, "ctx")], internal=True),
    Function(Void, "CGLSelectDispatch", [(CGLContextObj, "ctx"), (OpaquePointer(Void), "dispatch")], internal=True),
    Function(Void, "CGLSelectDispatchBounded", [(CGLContextObj, "ctx"), (OpaquePointer(Void), "dispatch"), (GLint, "size")], internal=True),
    Function(Void, "CGLSelectDispatchFunction", [(CGLContextObj, "ctx"), (OpaquePointer(Void), "functionPtr"), (GLint, "functionId")], internal=True),
    Function(Void, "CGLRestoreDispatch", [(CGLContextObj, "ctx")], internal=True),
    Function(Void, "CGLRestoreDispatchFunction", [(CGLContextObj, "ctx"), (GLint, "functionId")], internal=True),
    Function(CGLError, "CGLSetPBufferVolatileState", [(CGLPBufferObj, "pbuffer"), (OpaquePointer(Void), "state")], internal=True),
])


########NEW FILE########
__FILENAME__ = d2d1
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from winapi import *
from dxgiformat import DXGI_FORMAT
from dxgi import IDXGISurface
from d2derr import *
from d2dbasetypes import *
from dwrite import *


ID2D1Resource = Interface("ID2D1Resource", IUnknown)
ID2D1Bitmap = Interface("ID2D1Bitmap", ID2D1Resource)
ID2D1GradientStopCollection = Interface("ID2D1GradientStopCollection", ID2D1Resource)
ID2D1Brush = Interface("ID2D1Brush", ID2D1Resource)
ID2D1BitmapBrush = Interface("ID2D1BitmapBrush", ID2D1Brush)
ID2D1SolidColorBrush = Interface("ID2D1SolidColorBrush", ID2D1Brush)
ID2D1LinearGradientBrush = Interface("ID2D1LinearGradientBrush", ID2D1Brush)
ID2D1RadialGradientBrush = Interface("ID2D1RadialGradientBrush", ID2D1Brush)
ID2D1StrokeStyle = Interface("ID2D1StrokeStyle", ID2D1Resource)
ID2D1Geometry = Interface("ID2D1Geometry", ID2D1Resource)
ID2D1RectangleGeometry = Interface("ID2D1RectangleGeometry", ID2D1Geometry)
ID2D1RoundedRectangleGeometry = Interface("ID2D1RoundedRectangleGeometry", ID2D1Geometry)
ID2D1EllipseGeometry = Interface("ID2D1EllipseGeometry", ID2D1Geometry)
ID2D1GeometryGroup = Interface("ID2D1GeometryGroup", ID2D1Geometry)
ID2D1TransformedGeometry = Interface("ID2D1TransformedGeometry", ID2D1Geometry)
ID2D1GeometrySink = Interface("ID2D1GeometrySink", ID2D1SimplifiedGeometrySink)
ID2D1TessellationSink = Interface("ID2D1TessellationSink", IUnknown)
ID2D1PathGeometry = Interface("ID2D1PathGeometry", ID2D1Geometry)
ID2D1Mesh = Interface("ID2D1Mesh", ID2D1Resource)
ID2D1Layer = Interface("ID2D1Layer", ID2D1Resource)
ID2D1DrawingStateBlock = Interface("ID2D1DrawingStateBlock", ID2D1Resource)
ID2D1RenderTarget = Interface("ID2D1RenderTarget", ID2D1Resource)
ID2D1BitmapRenderTarget = Interface("ID2D1BitmapRenderTarget", ID2D1RenderTarget)
ID2D1HwndRenderTarget = Interface("ID2D1HwndRenderTarget", ID2D1RenderTarget)
ID2D1GdiInteropRenderTarget = Interface("ID2D1GdiInteropRenderTarget", IUnknown)
ID2D1DCRenderTarget = Interface("ID2D1DCRenderTarget", ID2D1RenderTarget)
ID2D1Factory = Interface("ID2D1Factory", IUnknown)


D2D1_ALPHA_MODE = Enum("D2D1_ALPHA_MODE", [
    "D2D1_ALPHA_MODE_UNKNOWN",
    "D2D1_ALPHA_MODE_PREMULTIPLIED",
    "D2D1_ALPHA_MODE_STRAIGHT",
    "D2D1_ALPHA_MODE_IGNORE",
])

D2D1_GAMMA = Enum("D2D1_GAMMA", [
    "D2D1_GAMMA_2_2",
    "D2D1_GAMMA_1_0",
])

D2D1_OPACITY_MASK_CONTENT = Enum("D2D1_OPACITY_MASK_CONTENT", [
    "D2D1_OPACITY_MASK_CONTENT_GRAPHICS",
    "D2D1_OPACITY_MASK_CONTENT_TEXT_NATURAL",
    "D2D1_OPACITY_MASK_CONTENT_TEXT_GDI_COMPATIBLE",
])

D2D1_EXTEND_MODE = Enum("D2D1_EXTEND_MODE", [
    "D2D1_EXTEND_MODE_CLAMP",
    "D2D1_EXTEND_MODE_WRAP",
    "D2D1_EXTEND_MODE_MIRROR",
])

D2D1_ANTIALIAS_MODE = Enum("D2D1_ANTIALIAS_MODE", [
    "D2D1_ANTIALIAS_MODE_PER_PRIMITIVE",
    "D2D1_ANTIALIAS_MODE_ALIASED",
])

D2D1_TEXT_ANTIALIAS_MODE = Enum("D2D1_TEXT_ANTIALIAS_MODE", [
    "D2D1_TEXT_ANTIALIAS_MODE_DEFAULT",
    "D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE",
    "D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE",
    "D2D1_TEXT_ANTIALIAS_MODE_ALIASED",
])

D2D1_BITMAP_INTERPOLATION_MODE = Enum("D2D1_BITMAP_INTERPOLATION_MODE", [
    "D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR",
    "D2D1_BITMAP_INTERPOLATION_MODE_LINEAR",
])

D2D1_DRAW_TEXT_OPTIONS = EnumFlag("D2D1_DRAW_TEXT_OPTIONS", [
    "D2D1_DRAW_TEXT_OPTIONS_NONE",
    "D2D1_DRAW_TEXT_OPTIONS_NO_SNAP",
    "D2D1_DRAW_TEXT_OPTIONS_CLIP",
])

D2D1_PIXEL_FORMAT = Struct("D2D1_PIXEL_FORMAT", [
    (DXGI_FORMAT, "format"),
    (D2D1_ALPHA_MODE, "alphaMode"),
])

D2D1_POINT_2U = Alias("D2D1_POINT_2U", D2D_POINT_2U)
D2D1_POINT_2F = Alias("D2D1_POINT_2F", D2D_POINT_2F)
D2D1_RECT_F = Alias("D2D1_RECT_F", D2D_RECT_F)
D2D1_RECT_U = Alias("D2D1_RECT_U", D2D_RECT_U)
D2D1_SIZE_F = Alias("D2D1_SIZE_F", D2D_SIZE_F)
D2D1_SIZE_U = Alias("D2D1_SIZE_U", D2D_SIZE_U)
D2D1_COLOR_F = Alias("D2D1_COLOR_F", D2D_COLOR_F)
D2D1_MATRIX_3X2_F = Alias("D2D1_MATRIX_3X2_F", D2D_MATRIX_3X2_F)
D2D1_TAG = Alias("D2D1_TAG", UINT64)
D2D1_BITMAP_PROPERTIES = Struct("D2D1_BITMAP_PROPERTIES", [
    (D2D1_PIXEL_FORMAT, "pixelFormat"),
    (FLOAT, "dpiX"),
    (FLOAT, "dpiY"),
])

D2D1_GRADIENT_STOP = Struct("D2D1_GRADIENT_STOP", [
    (FLOAT, "position"),
    (D2D1_COLOR_F, "color"),
])

D2D1_BRUSH_PROPERTIES = Struct("D2D1_BRUSH_PROPERTIES", [
    (FLOAT, "opacity"),
    (D2D1_MATRIX_3X2_F, "transform"),
])

D2D1_BITMAP_BRUSH_PROPERTIES = Struct("D2D1_BITMAP_BRUSH_PROPERTIES", [
    (D2D1_EXTEND_MODE, "extendModeX"),
    (D2D1_EXTEND_MODE, "extendModeY"),
    (D2D1_BITMAP_INTERPOLATION_MODE, "interpolationMode"),
])

D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES = Struct("D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES", [
    (D2D1_POINT_2F, "startPoint"),
    (D2D1_POINT_2F, "endPoint"),
])

D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES = Struct("D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES", [
    (D2D1_POINT_2F, "center"),
    (D2D1_POINT_2F, "gradientOriginOffset"),
    (FLOAT, "radiusX"),
    (FLOAT, "radiusY"),
])

D2D1_ARC_SIZE = Enum("D2D1_ARC_SIZE", [
    "D2D1_ARC_SIZE_SMALL",
    "D2D1_ARC_SIZE_LARGE",
])

D2D1_CAP_STYLE = Enum("D2D1_CAP_STYLE", [
    "D2D1_CAP_STYLE_FLAT",
    "D2D1_CAP_STYLE_SQUARE",
    "D2D1_CAP_STYLE_ROUND",
    "D2D1_CAP_STYLE_TRIANGLE",
])

D2D1_DASH_STYLE = Enum("D2D1_DASH_STYLE", [
    "D2D1_DASH_STYLE_SOLID",
    "D2D1_DASH_STYLE_DASH",
    "D2D1_DASH_STYLE_DOT",
    "D2D1_DASH_STYLE_DASH_DOT",
    "D2D1_DASH_STYLE_DASH_DOT_DOT",
    "D2D1_DASH_STYLE_CUSTOM",
])

D2D1_LINE_JOIN = Enum("D2D1_LINE_JOIN", [
    "D2D1_LINE_JOIN_MITER",
    "D2D1_LINE_JOIN_BEVEL",
    "D2D1_LINE_JOIN_ROUND",
    "D2D1_LINE_JOIN_MITER_OR_BEVEL",
])

D2D1_COMBINE_MODE = Enum("D2D1_COMBINE_MODE", [
    "D2D1_COMBINE_MODE_UNION",
    "D2D1_COMBINE_MODE_INTERSECT",
    "D2D1_COMBINE_MODE_XOR",
    "D2D1_COMBINE_MODE_EXCLUDE",
])

D2D1_GEOMETRY_RELATION = Enum("D2D1_GEOMETRY_RELATION", [
    "D2D1_GEOMETRY_RELATION_UNKNOWN",
    "D2D1_GEOMETRY_RELATION_DISJOINT",
    "D2D1_GEOMETRY_RELATION_IS_CONTAINED",
    "D2D1_GEOMETRY_RELATION_CONTAINS",
    "D2D1_GEOMETRY_RELATION_OVERLAP",
])

D2D1_GEOMETRY_SIMPLIFICATION_OPTION = Enum("D2D1_GEOMETRY_SIMPLIFICATION_OPTION", [
    "D2D1_GEOMETRY_SIMPLIFICATION_OPTION_CUBICS_AND_LINES",
    "D2D1_GEOMETRY_SIMPLIFICATION_OPTION_LINES",
])

D2D1_FIGURE_BEGIN = Enum("D2D1_FIGURE_BEGIN", [
    "D2D1_FIGURE_BEGIN_FILLED",
    "D2D1_FIGURE_BEGIN_HOLLOW",
])

D2D1_FIGURE_END = Enum("D2D1_FIGURE_END", [
    "D2D1_FIGURE_END_OPEN",
    "D2D1_FIGURE_END_CLOSED",
])

D2D1_BEZIER_SEGMENT = Struct("D2D1_BEZIER_SEGMENT", [
    (D2D1_POINT_2F, "point1"),
    (D2D1_POINT_2F, "point2"),
    (D2D1_POINT_2F, "point3"),
])

D2D1_TRIANGLE = Struct("D2D1_TRIANGLE", [
    (D2D1_POINT_2F, "point1"),
    (D2D1_POINT_2F, "point2"),
    (D2D1_POINT_2F, "point3"),
])

D2D1_PATH_SEGMENT = EnumFlag("D2D1_PATH_SEGMENT", [
    "D2D1_PATH_SEGMENT_NONE",
    "D2D1_PATH_SEGMENT_FORCE_UNSTROKED",
    "D2D1_PATH_SEGMENT_FORCE_ROUND_LINE_JOIN",
])

D2D1_SWEEP_DIRECTION = Enum("D2D1_SWEEP_DIRECTION", [
    "D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE",
    "D2D1_SWEEP_DIRECTION_CLOCKWISE",
])

D2D1_FILL_MODE = Enum("D2D1_FILL_MODE", [
    "D2D1_FILL_MODE_ALTERNATE",
    "D2D1_FILL_MODE_WINDING",
])

D2D1_ARC_SEGMENT = Struct("D2D1_ARC_SEGMENT", [
    (D2D1_POINT_2F, "point"),
    (D2D1_SIZE_F, "size"),
    (FLOAT, "rotationAngle"),
    (D2D1_SWEEP_DIRECTION, "sweepDirection"),
    (D2D1_ARC_SIZE, "arcSize"),
])

D2D1_QUADRATIC_BEZIER_SEGMENT = Struct("D2D1_QUADRATIC_BEZIER_SEGMENT", [
    (D2D1_POINT_2F, "point1"),
    (D2D1_POINT_2F, "point2"),
])

D2D1_ELLIPSE = Struct("D2D1_ELLIPSE", [
    (D2D1_POINT_2F, "point"),
    (FLOAT, "radiusX"),
    (FLOAT, "radiusY"),
])

D2D1_ROUNDED_RECT = Struct("D2D1_ROUNDED_RECT", [
    (D2D1_RECT_F, "rect"),
    (FLOAT, "radiusX"),
    (FLOAT, "radiusY"),
])

D2D1_STROKE_STYLE_PROPERTIES = Struct("D2D1_STROKE_STYLE_PROPERTIES", [
    (D2D1_CAP_STYLE, "startCap"),
    (D2D1_CAP_STYLE, "endCap"),
    (D2D1_CAP_STYLE, "dashCap"),
    (D2D1_LINE_JOIN, "lineJoin"),
    (FLOAT, "miterLimit"),
    (D2D1_DASH_STYLE, "dashStyle"),
    (FLOAT, "dashOffset"),
])

D2D1_LAYER_OPTIONS = EnumFlag("D2D1_LAYER_OPTIONS", [
    "D2D1_LAYER_OPTIONS_NONE",
    "D2D1_LAYER_OPTIONS_INITIALIZE_FOR_CLEARTYPE",
])

D2D1_LAYER_PARAMETERS = Struct("D2D1_LAYER_PARAMETERS", [
    (D2D1_RECT_F, "contentBounds"),
    (ObjPointer(ID2D1Geometry), "geometricMask"),
    (D2D1_ANTIALIAS_MODE, "maskAntialiasMode"),
    (D2D1_MATRIX_3X2_F, "maskTransform"),
    (FLOAT, "opacity"),
    (ObjPointer(ID2D1Brush), "opacityBrush"),
    (D2D1_LAYER_OPTIONS, "layerOptions"),
])

D2D1_WINDOW_STATE = EnumFlag("D2D1_WINDOW_STATE", [
    "D2D1_WINDOW_STATE_NONE",
    "D2D1_WINDOW_STATE_OCCLUDED",
])

D2D1_RENDER_TARGET_TYPE = Enum("D2D1_RENDER_TARGET_TYPE", [
    "D2D1_RENDER_TARGET_TYPE_DEFAULT",
    "D2D1_RENDER_TARGET_TYPE_SOFTWARE",
    "D2D1_RENDER_TARGET_TYPE_HARDWARE",
])

D2D1_FEATURE_LEVEL = Enum("D2D1_FEATURE_LEVEL", [
    "D2D1_FEATURE_LEVEL_DEFAULT",
    "D2D1_FEATURE_LEVEL_9",
    "D2D1_FEATURE_LEVEL_10",
])

D2D1_RENDER_TARGET_USAGE = EnumFlag("D2D1_RENDER_TARGET_USAGE", [
    "D2D1_RENDER_TARGET_USAGE_NONE",
    "D2D1_RENDER_TARGET_USAGE_FORCE_BITMAP_REMOTING",
    "D2D1_RENDER_TARGET_USAGE_GDI_COMPATIBLE",
])

D2D1_PRESENT_OPTIONS = EnumFlag("D2D1_PRESENT_OPTIONS", [
    "D2D1_PRESENT_OPTIONS_NONE",
    "D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS",
    "D2D1_PRESENT_OPTIONS_IMMEDIATELY",
])

D2D1_RENDER_TARGET_PROPERTIES = Struct("D2D1_RENDER_TARGET_PROPERTIES", [
    (D2D1_RENDER_TARGET_TYPE, "type"),
    (D2D1_PIXEL_FORMAT, "pixelFormat"),
    (FLOAT, "dpiX"),
    (FLOAT, "dpiY"),
    (D2D1_RENDER_TARGET_USAGE, "usage"),
    (D2D1_FEATURE_LEVEL, "minLevel"),
])

D2D1_HWND_RENDER_TARGET_PROPERTIES = Struct("D2D1_HWND_RENDER_TARGET_PROPERTIES", [
    (HWND, "hwnd"),
    (D2D1_SIZE_U, "pixelSize"),
    (D2D1_PRESENT_OPTIONS, "presentOptions"),
])

D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS = EnumFlag("D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS", [
    "D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE",
    "D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_GDI_COMPATIBLE",
])

D2D1_DRAWING_STATE_DESCRIPTION = Struct("D2D1_DRAWING_STATE_DESCRIPTION", [
    (D2D1_ANTIALIAS_MODE, "antialiasMode"),
    (D2D1_TEXT_ANTIALIAS_MODE, "textAntialiasMode"),
    (D2D1_TAG, "tag1"),
    (D2D1_TAG, "tag2"),
    (D2D1_MATRIX_3X2_F, "transform"),
])

D2D1_DC_INITIALIZE_MODE = Enum("D2D1_DC_INITIALIZE_MODE", [
    "D2D1_DC_INITIALIZE_MODE_COPY",
    "D2D1_DC_INITIALIZE_MODE_CLEAR",
])

D2D1_DEBUG_LEVEL = Enum("D2D1_DEBUG_LEVEL", [
    "D2D1_DEBUG_LEVEL_NONE",
    "D2D1_DEBUG_LEVEL_ERROR",
    "D2D1_DEBUG_LEVEL_WARNING",
    "D2D1_DEBUG_LEVEL_INFORMATION",
])

D2D1_FACTORY_TYPE = Enum("D2D1_FACTORY_TYPE", [
    "D2D1_FACTORY_TYPE_SINGLE_THREADED",
    "D2D1_FACTORY_TYPE_MULTI_THREADED",
])

D2D1_FACTORY_OPTIONS = Struct("D2D1_FACTORY_OPTIONS", [
    (D2D1_DEBUG_LEVEL, "debugLevel"),
])

ID2D1Resource.methods += [
    StdMethod(Void, "GetFactory", [Out(Pointer(ObjPointer(ID2D1Factory)), "factory")], const=True),
]

ID2D1Bitmap.methods += [
    StdMethod(D2D1_SIZE_F, "GetSize", [], const=True),
    StdMethod(D2D1_SIZE_U, "GetPixelSize", [], const=True),
    StdMethod(D2D1_PIXEL_FORMAT, "GetPixelFormat", [], const=True),
    StdMethod(Void, "GetDpi", [Out(Pointer(FLOAT), "dpiX"), Out(Pointer(FLOAT), "dpiY")], const=True),
    StdMethod(HRESULT, "CopyFromBitmap", [(Pointer(Const(D2D1_POINT_2U)), "destPoint"), (ObjPointer(ID2D1Bitmap), "bitmap"), (Pointer(Const(D2D1_RECT_U)), "srcRect")]),
    StdMethod(HRESULT, "CopyFromRenderTarget", [(Pointer(Const(D2D1_POINT_2U)), "destPoint"), (ObjPointer(ID2D1RenderTarget), "renderTarget"), (Pointer(Const(D2D1_RECT_U)), "srcRect")]),
    StdMethod(HRESULT, "CopyFromMemory", [(Pointer(Const(D2D1_RECT_U)), "dstRect"), (OpaquePointer(Const(Void)), "srcData"), (UINT32, "pitch")]),
]

ID2D1GradientStopCollection.methods += [
    StdMethod(UINT32, "GetGradientStopCount", [], const=True),
    StdMethod(Void, "GetGradientStops", [Out(Pointer(D2D1_GRADIENT_STOP), "gradientStops"), (UINT, "gradientStopsCount")], const=True),
    StdMethod(D2D1_GAMMA, "GetColorInterpolationGamma", [], const=True),
    StdMethod(D2D1_EXTEND_MODE, "GetExtendMode", [], const=True),
]

ID2D1Brush.methods += [
    StdMethod(Void, "SetOpacity", [(FLOAT, "opacity")]),
    StdMethod(Void, "SetTransform", [(Pointer(Const(D2D1_MATRIX_3X2_F)), "transform")]),
    StdMethod(FLOAT, "GetOpacity", [], const=True),
    StdMethod(Void, "GetTransform", [Out(Pointer(D2D1_MATRIX_3X2_F), "transform")], const=True),
]

ID2D1BitmapBrush.methods += [
    StdMethod(Void, "SetExtendModeX", [(D2D1_EXTEND_MODE, "extendModeX")]),
    StdMethod(Void, "SetExtendModeY", [(D2D1_EXTEND_MODE, "extendModeY")]),
    StdMethod(Void, "SetInterpolationMode", [(D2D1_BITMAP_INTERPOLATION_MODE, "interpolationMode")]),
    StdMethod(Void, "SetBitmap", [(ObjPointer(ID2D1Bitmap), "bitmap")]),
    StdMethod(D2D1_EXTEND_MODE, "GetExtendModeX", [], const=True),
    StdMethod(D2D1_EXTEND_MODE, "GetExtendModeY", [], const=True),
    StdMethod(D2D1_BITMAP_INTERPOLATION_MODE, "GetInterpolationMode", [], const=True),
    StdMethod(Void, "GetBitmap", [Out(Pointer(ObjPointer(ID2D1Bitmap)), "bitmap")], const=True),
]

ID2D1SolidColorBrush.methods += [
    StdMethod(Void, "SetColor", [(Pointer(Const(D2D1_COLOR_F)), "color")]),
    StdMethod(D2D1_COLOR_F, "GetColor", [], const=True),
]

ID2D1LinearGradientBrush.methods += [
    StdMethod(Void, "SetStartPoint", [(D2D1_POINT_2F, "startPoint")]),
    StdMethod(Void, "SetEndPoint", [(D2D1_POINT_2F, "endPoint")]),
    StdMethod(D2D1_POINT_2F, "GetStartPoint", [], const=True),
    StdMethod(D2D1_POINT_2F, "GetEndPoint", [], const=True),
    StdMethod(Void, "GetGradientStopCollection", [Out(Pointer(ObjPointer(ID2D1GradientStopCollection)), "gradientStopCollection")], const=True),
]

ID2D1RadialGradientBrush.methods += [
    StdMethod(Void, "SetCenter", [(D2D1_POINT_2F, "center")]),
    StdMethod(Void, "SetGradientOriginOffset", [(D2D1_POINT_2F, "gradientOriginOffset")]),
    StdMethod(Void, "SetRadiusX", [(FLOAT, "radiusX")]),
    StdMethod(Void, "SetRadiusY", [(FLOAT, "radiusY")]),
    StdMethod(D2D1_POINT_2F, "GetCenter", [], const=True),
    StdMethod(D2D1_POINT_2F, "GetGradientOriginOffset", [], const=True),
    StdMethod(FLOAT, "GetRadiusX", [], const=True),
    StdMethod(FLOAT, "GetRadiusY", [], const=True),
    StdMethod(Void, "GetGradientStopCollection", [Out(Pointer(ObjPointer(ID2D1GradientStopCollection)), "gradientStopCollection")], const=True),
]

ID2D1StrokeStyle.methods += [
    StdMethod(D2D1_CAP_STYLE, "GetStartCap", [], const=True),
    StdMethod(D2D1_CAP_STYLE, "GetEndCap", [], const=True),
    StdMethod(D2D1_CAP_STYLE, "GetDashCap", [], const=True),
    StdMethod(FLOAT, "GetMiterLimit", [], const=True),
    StdMethod(D2D1_LINE_JOIN, "GetLineJoin", [], const=True),
    StdMethod(FLOAT, "GetDashOffset", [], const=True),
    StdMethod(D2D1_DASH_STYLE, "GetDashStyle", [], const=True),
    StdMethod(UINT32, "GetDashesCount", [], const=True),
    StdMethod(Void, "GetDashes", [Out(Array(FLOAT, "dashesCount"), "dashes"), (UINT, "dashesCount")], const=True),
]

ID2D1Geometry.methods += [
    StdMethod(HRESULT, "GetBounds", [(Pointer(Const(D2D1_MATRIX_3X2_F)), "worldTransform"), Out(Pointer(D2D1_RECT_F), "bounds")], const=True),
    StdMethod(HRESULT, "GetWidenedBounds", [(FLOAT, "strokeWidth"), (ObjPointer(ID2D1StrokeStyle), "strokeStyle"), (Pointer(Const(D2D1_MATRIX_3X2_F)), "worldTransform"), (FLOAT, "flatteningTolerance"), Out(Pointer(D2D1_RECT_F), "bounds")], const=True),
    StdMethod(HRESULT, "StrokeContainsPoint", [(D2D1_POINT_2F, "point"), (FLOAT, "strokeWidth"), (ObjPointer(ID2D1StrokeStyle), "strokeStyle"), (Pointer(Const(D2D1_MATRIX_3X2_F)), "worldTransform"), (FLOAT, "flatteningTolerance"), Out(Pointer(BOOL), "contains")], const=True),
    StdMethod(HRESULT, "FillContainsPoint", [(D2D1_POINT_2F, "point"), (Pointer(Const(D2D1_MATRIX_3X2_F)), "worldTransform"), (FLOAT, "flatteningTolerance"), Out(Pointer(BOOL), "contains")], const=True),
    StdMethod(HRESULT, "CompareWithGeometry", [(ObjPointer(ID2D1Geometry), "inputGeometry"), (Pointer(Const(D2D1_MATRIX_3X2_F)), "inputGeometryTransform"), (FLOAT, "flatteningTolerance"), Out(Pointer(D2D1_GEOMETRY_RELATION), "relation")], const=True),
    StdMethod(HRESULT, "Simplify", [(D2D1_GEOMETRY_SIMPLIFICATION_OPTION, "simplificationOption"), (Pointer(Const(D2D1_MATRIX_3X2_F)), "worldTransform"), (FLOAT, "flatteningTolerance"), (ObjPointer(ID2D1SimplifiedGeometrySink), "geometrySink")], const=True),
    StdMethod(HRESULT, "Tessellate", [(Pointer(Const(D2D1_MATRIX_3X2_F)), "worldTransform"), (FLOAT, "flatteningTolerance"), (ObjPointer(ID2D1TessellationSink), "tessellationSink")], const=True),
    StdMethod(HRESULT, "CombineWithGeometry", [(ObjPointer(ID2D1Geometry), "inputGeometry"), (D2D1_COMBINE_MODE, "combineMode"), (Pointer(Const(D2D1_MATRIX_3X2_F)), "inputGeometryTransform"), (FLOAT, "flatteningTolerance"), (ObjPointer(ID2D1SimplifiedGeometrySink), "geometrySink")], const=True),
    StdMethod(HRESULT, "Outline", [(Pointer(Const(D2D1_MATRIX_3X2_F)), "worldTransform"), (FLOAT, "flatteningTolerance"), (ObjPointer(ID2D1SimplifiedGeometrySink), "geometrySink")], const=True),
    StdMethod(HRESULT, "ComputeArea", [(Pointer(Const(D2D1_MATRIX_3X2_F)), "worldTransform"), (FLOAT, "flatteningTolerance"), Out(Pointer(FLOAT), "area")], const=True),
    StdMethod(HRESULT, "ComputeLength", [(Pointer(Const(D2D1_MATRIX_3X2_F)), "worldTransform"), (FLOAT, "flatteningTolerance"), Out(Pointer(FLOAT), "length")], const=True),
    StdMethod(HRESULT, "ComputePointAtLength", [(FLOAT, "length"), (Pointer(Const(D2D1_MATRIX_3X2_F)), "worldTransform"), (FLOAT, "flatteningTolerance"), Out(Pointer(D2D1_POINT_2F), "point"), Out(Pointer(D2D1_POINT_2F), "unitTangentVector")], const=True),
    StdMethod(HRESULT, "Widen", [(FLOAT, "strokeWidth"), (ObjPointer(ID2D1StrokeStyle), "strokeStyle"), (Pointer(Const(D2D1_MATRIX_3X2_F)), "worldTransform"), (FLOAT, "flatteningTolerance"), (ObjPointer(ID2D1SimplifiedGeometrySink), "geometrySink")], const=True),
]

ID2D1RectangleGeometry.methods += [
    StdMethod(Void, "GetRect", [Out(Pointer(D2D1_RECT_F), "rect")], const=True),
]

ID2D1RoundedRectangleGeometry.methods += [
    StdMethod(Void, "GetRoundedRect", [Out(Pointer(D2D1_ROUNDED_RECT), "roundedRect")], const=True),
]

ID2D1EllipseGeometry.methods += [
    StdMethod(Void, "GetEllipse", [Out(Pointer(D2D1_ELLIPSE), "ellipse")], const=True),
]

ID2D1GeometryGroup.methods += [
    StdMethod(D2D1_FILL_MODE, "GetFillMode", [], const=True),
    StdMethod(UINT32, "GetSourceGeometryCount", [], const=True),
    StdMethod(Void, "GetSourceGeometries", [Out(Array(ObjPointer(ID2D1Geometry), "geometriesCount"), "geometries"), (UINT, "geometriesCount")], const=True),
]

ID2D1TransformedGeometry.methods += [
    StdMethod(Void, "GetSourceGeometry", [Out(Pointer(ObjPointer(ID2D1Geometry)), "sourceGeometry")], const=True),
    StdMethod(Void, "GetTransform", [Out(Pointer(D2D1_MATRIX_3X2_F), "transform")], const=True),
]

ID2D1SimplifiedGeometrySink.methods += [
    StdMethod(Void, "SetFillMode", [(D2D1_FILL_MODE, "fillMode")]),
    StdMethod(Void, "SetSegmentFlags", [(D2D1_PATH_SEGMENT, "vertexFlags")]),
    StdMethod(Void, "BeginFigure", [(D2D1_POINT_2F, "startPoint"), (D2D1_FIGURE_BEGIN, "figureBegin")]),
    StdMethod(Void, "AddLines", [(Array(Const(D2D1_POINT_2F), "pointsCount"), "points"), (UINT, "pointsCount")]),
    StdMethod(Void, "AddBeziers", [(Array(Const(D2D1_BEZIER_SEGMENT), "beziersCount"), "beziers"), (UINT, "beziersCount")]),
    StdMethod(Void, "EndFigure", [(D2D1_FIGURE_END, "figureEnd")]),
    StdMethod(HRESULT, "Close", []),
]

ID2D1GeometrySink.methods += [
    StdMethod(Void, "AddLine", [(D2D1_POINT_2F, "point")]),
    StdMethod(Void, "AddBezier", [(Pointer(Const(D2D1_BEZIER_SEGMENT)), "bezier")]),
    StdMethod(Void, "AddQuadraticBezier", [(Pointer(Const(D2D1_QUADRATIC_BEZIER_SEGMENT)), "bezier")]),
    StdMethod(Void, "AddQuadraticBeziers", [(Array(Const(D2D1_QUADRATIC_BEZIER_SEGMENT), "beziersCount"), "beziers"), (UINT, "beziersCount")]),
    StdMethod(Void, "AddArc", [(Pointer(Const(D2D1_ARC_SEGMENT)), "arc")]),
]

ID2D1TessellationSink.methods += [
    StdMethod(Void, "AddTriangles", [(Array(Const(D2D1_TRIANGLE), "trianglesCount"), "triangles"), (UINT, "trianglesCount")]),
    StdMethod(HRESULT, "Close", []),
]

ID2D1PathGeometry.methods += [
    StdMethod(HRESULT, "Open", [Out(Pointer(ObjPointer(ID2D1GeometrySink)), "geometrySink")]),
    StdMethod(HRESULT, "Stream", [(ObjPointer(ID2D1GeometrySink), "geometrySink")], const=True),
    StdMethod(HRESULT, "GetSegmentCount", [Out(Pointer(UINT32), "count")], const=True),
    StdMethod(HRESULT, "GetFigureCount", [Out(Pointer(UINT32), "count")], const=True),
]

ID2D1Mesh.methods += [
    StdMethod(HRESULT, "Open", [Out(Pointer(ObjPointer(ID2D1TessellationSink)), "tessellationSink")]),
]

ID2D1Layer.methods += [
    StdMethod(D2D1_SIZE_F, "GetSize", [], const=True),
]

ID2D1DrawingStateBlock.methods += [
    StdMethod(Void, "GetDescription", [Out(Pointer(D2D1_DRAWING_STATE_DESCRIPTION), "stateDescription")], const=True),
    StdMethod(Void, "SetDescription", [(Pointer(Const(D2D1_DRAWING_STATE_DESCRIPTION)), "stateDescription")]),
    StdMethod(Void, "SetTextRenderingParams", [(ObjPointer(IDWriteRenderingParams), "textRenderingParams")]),
    StdMethod(Void, "GetTextRenderingParams", [Out(Pointer(ObjPointer(IDWriteRenderingParams)), "textRenderingParams")], const=True),
]

ID2D1RenderTarget.methods += [
    StdMethod(HRESULT, "CreateBitmap", [(D2D1_SIZE_U, "size"), (OpaquePointer(Const(Void)), "srcData"), (UINT32, "pitch"), (Pointer(Const(D2D1_BITMAP_PROPERTIES)), "bitmapProperties"), Out(Pointer(ObjPointer(ID2D1Bitmap)), "bitmap")]),
    StdMethod(HRESULT, "CreateBitmapFromWicBitmap", [(Opaque("IWICBitmapSource *"), "wicBitmapSource"), (Pointer(Const(D2D1_BITMAP_PROPERTIES)), "bitmapProperties"), Out(Pointer(ObjPointer(ID2D1Bitmap)), "bitmap")]),
    StdMethod(HRESULT, "CreateSharedBitmap", [(REFIID, "riid"), Out(OpaquePointer(Void), "data"), (Pointer(Const(D2D1_BITMAP_PROPERTIES)), "bitmapProperties"), Out(Pointer(ObjPointer(ID2D1Bitmap)), "bitmap")]),
    StdMethod(HRESULT, "CreateBitmapBrush", [(ObjPointer(ID2D1Bitmap), "bitmap"), (Pointer(Const(D2D1_BITMAP_BRUSH_PROPERTIES)), "bitmapBrushProperties"), (Pointer(Const(D2D1_BRUSH_PROPERTIES)), "brushProperties"), Out(Pointer(ObjPointer(ID2D1BitmapBrush)), "bitmapBrush")]),
    StdMethod(HRESULT, "CreateSolidColorBrush", [(Pointer(Const(D2D1_COLOR_F)), "color"), (Pointer(Const(D2D1_BRUSH_PROPERTIES)), "brushProperties"), Out(Pointer(ObjPointer(ID2D1SolidColorBrush)), "solidColorBrush")]),
    StdMethod(HRESULT, "CreateGradientStopCollection", [(Array(Const(D2D1_GRADIENT_STOP), "gradientStopsCount"), "gradientStops"), (UINT, "gradientStopsCount"), (D2D1_GAMMA, "colorInterpolationGamma"), (D2D1_EXTEND_MODE, "extendMode"), Out(Pointer(ObjPointer(ID2D1GradientStopCollection)), "gradientStopCollection")]),
    StdMethod(HRESULT, "CreateLinearGradientBrush", [(Pointer(Const(D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES)), "linearGradientBrushProperties"), (Pointer(Const(D2D1_BRUSH_PROPERTIES)), "brushProperties"), (ObjPointer(ID2D1GradientStopCollection), "gradientStopCollection"), Out(Pointer(ObjPointer(ID2D1LinearGradientBrush)), "linearGradientBrush")]),
    StdMethod(HRESULT, "CreateRadialGradientBrush", [(Pointer(Const(D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES)), "radialGradientBrushProperties"), (Pointer(Const(D2D1_BRUSH_PROPERTIES)), "brushProperties"), (ObjPointer(ID2D1GradientStopCollection), "gradientStopCollection"), Out(Pointer(ObjPointer(ID2D1RadialGradientBrush)), "radialGradientBrush")]),
    StdMethod(HRESULT, "CreateCompatibleRenderTarget", [(Pointer(Const(D2D1_SIZE_F)), "desiredSize"), (Pointer(Const(D2D1_SIZE_U)), "desiredPixelSize"), (Pointer(Const(D2D1_PIXEL_FORMAT)), "desiredFormat"), (D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS, "options"), Out(Pointer(ObjPointer(ID2D1BitmapRenderTarget)), "bitmapRenderTarget")]),
    StdMethod(HRESULT, "CreateLayer", [(Pointer(Const(D2D1_SIZE_F)), "size"), Out(Pointer(ObjPointer(ID2D1Layer)), "layer")]),
    StdMethod(HRESULT, "CreateMesh", [Out(Pointer(ObjPointer(ID2D1Mesh)), "mesh")]),
    StdMethod(Void, "DrawLine", [(D2D1_POINT_2F, "point0"), (D2D1_POINT_2F, "point1"), (ObjPointer(ID2D1Brush), "brush"), (FLOAT, "strokeWidth"), (ObjPointer(ID2D1StrokeStyle), "strokeStyle")]),
    StdMethod(Void, "DrawRectangle", [(Pointer(Const(D2D1_RECT_F)), "rect"), (ObjPointer(ID2D1Brush), "brush"), (FLOAT, "strokeWidth"), (ObjPointer(ID2D1StrokeStyle), "strokeStyle")]),
    StdMethod(Void, "FillRectangle", [(Pointer(Const(D2D1_RECT_F)), "rect"), (ObjPointer(ID2D1Brush), "brush")]),
    StdMethod(Void, "DrawRoundedRectangle", [(Pointer(Const(D2D1_ROUNDED_RECT)), "roundedRect"), (ObjPointer(ID2D1Brush), "brush"), (FLOAT, "strokeWidth"), (ObjPointer(ID2D1StrokeStyle), "strokeStyle")]),
    StdMethod(Void, "FillRoundedRectangle", [(Pointer(Const(D2D1_ROUNDED_RECT)), "roundedRect"), (ObjPointer(ID2D1Brush), "brush")]),
    StdMethod(Void, "DrawEllipse", [(Pointer(Const(D2D1_ELLIPSE)), "ellipse"), (ObjPointer(ID2D1Brush), "brush"), (FLOAT, "strokeWidth"), (ObjPointer(ID2D1StrokeStyle), "strokeStyle")]),
    StdMethod(Void, "FillEllipse", [(Pointer(Const(D2D1_ELLIPSE)), "ellipse"), (ObjPointer(ID2D1Brush), "brush")]),
    StdMethod(Void, "DrawGeometry", [(ObjPointer(ID2D1Geometry), "geometry"), (ObjPointer(ID2D1Brush), "brush"), (FLOAT, "strokeWidth"), (ObjPointer(ID2D1StrokeStyle), "strokeStyle")]),
    StdMethod(Void, "FillGeometry", [(ObjPointer(ID2D1Geometry), "geometry"), (ObjPointer(ID2D1Brush), "brush"), (ObjPointer(ID2D1Brush), "opacityBrush")]),
    StdMethod(Void, "FillMesh", [(ObjPointer(ID2D1Mesh), "mesh"), (ObjPointer(ID2D1Brush), "brush")]),
    StdMethod(Void, "FillOpacityMask", [(ObjPointer(ID2D1Bitmap), "opacityMask"), (ObjPointer(ID2D1Brush), "brush"), (D2D1_OPACITY_MASK_CONTENT, "content"), (Pointer(Const(D2D1_RECT_F)), "destinationRectangle"), (Pointer(Const(D2D1_RECT_F)), "sourceRectangle")]),
    StdMethod(Void, "DrawBitmap", [(ObjPointer(ID2D1Bitmap), "bitmap"), (Pointer(Const(D2D1_RECT_F)), "destinationRectangle"), (FLOAT, "opacity"), (D2D1_BITMAP_INTERPOLATION_MODE, "interpolationMode"), (Pointer(Const(D2D1_RECT_F)), "sourceRectangle")]),
    StdMethod(Void, "DrawText", [(Pointer(Const(WCHAR)), "string"), (UINT, "stringLength"), (ObjPointer(IDWriteTextFormat), "textFormat"), (Pointer(Const(D2D1_RECT_F)), "layoutRect"), (ObjPointer(ID2D1Brush), "defaultForegroundBrush"), (D2D1_DRAW_TEXT_OPTIONS, "options"), (DWRITE_MEASURING_MODE, "measuringMode")]),
    StdMethod(Void, "DrawTextLayout", [(D2D1_POINT_2F, "origin"), (ObjPointer(IDWriteTextLayout), "textLayout"), (ObjPointer(ID2D1Brush), "defaultForegroundBrush"), (D2D1_DRAW_TEXT_OPTIONS, "options")]),
    StdMethod(Void, "DrawGlyphRun", [(D2D1_POINT_2F, "baselineOrigin"), (Pointer(Const(DWRITE_GLYPH_RUN)), "glyphRun"), (ObjPointer(ID2D1Brush), "foregroundBrush"), (DWRITE_MEASURING_MODE, "measuringMode")]),
    StdMethod(Void, "SetTransform", [(Pointer(Const(D2D1_MATRIX_3X2_F)), "transform")]),
    StdMethod(Void, "GetTransform", [Out(Pointer(D2D1_MATRIX_3X2_F), "transform")], const=True),
    StdMethod(Void, "SetAntialiasMode", [(D2D1_ANTIALIAS_MODE, "antialiasMode")]),
    StdMethod(D2D1_ANTIALIAS_MODE, "GetAntialiasMode", [], const=True),
    StdMethod(Void, "SetTextAntialiasMode", [(D2D1_TEXT_ANTIALIAS_MODE, "textAntialiasMode")]),
    StdMethod(D2D1_TEXT_ANTIALIAS_MODE, "GetTextAntialiasMode", [], const=True),
    StdMethod(Void, "SetTextRenderingParams", [(ObjPointer(IDWriteRenderingParams), "textRenderingParams")]),
    StdMethod(Void, "GetTextRenderingParams", [Out(Pointer(ObjPointer(IDWriteRenderingParams)), "textRenderingParams")], const=True),
    StdMethod(Void, "SetTags", [(D2D1_TAG, "tag1"), (D2D1_TAG, "tag2")]),
    StdMethod(Void, "GetTags", [Out(Pointer(D2D1_TAG), "tag1"), Out(Pointer(D2D1_TAG), "tag2")], const=True),
    StdMethod(Void, "PushLayer", [(Pointer(Const(D2D1_LAYER_PARAMETERS)), "layerParameters"), (ObjPointer(ID2D1Layer), "layer")]),
    StdMethod(Void, "PopLayer", []),
    StdMethod(HRESULT, "Flush", [Out(Pointer(D2D1_TAG), "tag1"), Out(Pointer(D2D1_TAG), "tag2")]),
    StdMethod(Void, "SaveDrawingState", [(ObjPointer(ID2D1DrawingStateBlock), "drawingStateBlock")], const=True),
    StdMethod(Void, "RestoreDrawingState", [(ObjPointer(ID2D1DrawingStateBlock), "drawingStateBlock")]),
    StdMethod(Void, "PushAxisAlignedClip", [(Pointer(Const(D2D1_RECT_F)), "clipRect"), (D2D1_ANTIALIAS_MODE, "antialiasMode")]),
    StdMethod(Void, "PopAxisAlignedClip", []),
    StdMethod(Void, "Clear", [(Pointer(Const(D2D1_COLOR_F)), "clearColor")]),
    StdMethod(Void, "BeginDraw", []),
    StdMethod(HRESULT, "EndDraw", [Out(Pointer(D2D1_TAG), "tag1"), Out(Pointer(D2D1_TAG), "tag2")]),
    StdMethod(D2D1_PIXEL_FORMAT, "GetPixelFormat", [], const=True),
    StdMethod(Void, "SetDpi", [(FLOAT, "dpiX"), (FLOAT, "dpiY")]),
    StdMethod(Void, "GetDpi", [Out(Pointer(FLOAT), "dpiX"), Out(Pointer(FLOAT), "dpiY")], const=True),
    StdMethod(D2D1_SIZE_F, "GetSize", [], const=True),
    StdMethod(D2D1_SIZE_U, "GetPixelSize", [], const=True),
    StdMethod(UINT32, "GetMaximumBitmapSize", [], const=True),
    StdMethod(BOOL, "IsSupported", [(Pointer(Const(D2D1_RENDER_TARGET_PROPERTIES)), "renderTargetProperties")], const=True),
]

ID2D1BitmapRenderTarget.methods += [
    StdMethod(HRESULT, "GetBitmap", [Out(Pointer(ObjPointer(ID2D1Bitmap)), "bitmap")]),
]

ID2D1HwndRenderTarget.methods += [
    StdMethod(D2D1_WINDOW_STATE, "CheckWindowState", []),
    StdMethod(HRESULT, "Resize", [(Pointer(Const(D2D1_SIZE_U)), "pixelSize")]),
    StdMethod(HWND, "GetHwnd", [], const=True),
]

ID2D1GdiInteropRenderTarget.methods += [
    StdMethod(HRESULT, "GetDC", [(D2D1_DC_INITIALIZE_MODE, "mode"), Out(Pointer(HDC), "hdc")]),
    StdMethod(HRESULT, "ReleaseDC", [(Pointer(Const(RECT)), "update")]),
]

ID2D1DCRenderTarget.methods += [
    StdMethod(HRESULT, "BindDC", [(Const(HDC), "hDC"), (Pointer(Const(RECT)), "pSubRect")]),
]

ID2D1Factory.methods += [
    StdMethod(HRESULT, "ReloadSystemMetrics", []),
    StdMethod(Void, "GetDesktopDpi", [Out(Pointer(FLOAT), "dpiX"), Out(Pointer(FLOAT), "dpiY")]),
    StdMethod(HRESULT, "CreateRectangleGeometry", [(Pointer(Const(D2D1_RECT_F)), "rectangle"), Out(Pointer(ObjPointer(ID2D1RectangleGeometry)), "rectangleGeometry")]),
    StdMethod(HRESULT, "CreateRoundedRectangleGeometry", [(Pointer(Const(D2D1_ROUNDED_RECT)), "roundedRectangle"), Out(Pointer(ObjPointer(ID2D1RoundedRectangleGeometry)), "roundedRectangleGeometry")]),
    StdMethod(HRESULT, "CreateEllipseGeometry", [(Pointer(Const(D2D1_ELLIPSE)), "ellipse"), Out(Pointer(ObjPointer(ID2D1EllipseGeometry)), "ellipseGeometry")]),
    StdMethod(HRESULT, "CreateGeometryGroup", [(D2D1_FILL_MODE, "fillMode"), (Pointer(ObjPointer(ID2D1Geometry)), "geometries"), (UINT, "geometriesCount"), Out(Pointer(ObjPointer(ID2D1GeometryGroup)), "geometryGroup")]),
    StdMethod(HRESULT, "CreateTransformedGeometry", [(ObjPointer(ID2D1Geometry), "sourceGeometry"), (Pointer(Const(D2D1_MATRIX_3X2_F)), "transform"), Out(Pointer(ObjPointer(ID2D1TransformedGeometry)), "transformedGeometry")]),
    StdMethod(HRESULT, "CreatePathGeometry", [Out(Pointer(ObjPointer(ID2D1PathGeometry)), "pathGeometry")]),
    StdMethod(HRESULT, "CreateStrokeStyle", [(Pointer(Const(D2D1_STROKE_STYLE_PROPERTIES)), "strokeStyleProperties"), (Pointer(Const(FLOAT)), "dashes"), (UINT, "dashesCount"), Out(Pointer(ObjPointer(ID2D1StrokeStyle)), "strokeStyle")]),
    StdMethod(HRESULT, "CreateDrawingStateBlock", [(Pointer(Const(D2D1_DRAWING_STATE_DESCRIPTION)), "drawingStateDescription"), (ObjPointer(IDWriteRenderingParams), "textRenderingParams"), Out(Pointer(ObjPointer(ID2D1DrawingStateBlock)), "drawingStateBlock")]),
    StdMethod(HRESULT, "CreateWicBitmapRenderTarget", [(Opaque("IWICBitmap *"), "target"), (Pointer(Const(D2D1_RENDER_TARGET_PROPERTIES)), "renderTargetProperties"), Out(Pointer(ObjPointer(ID2D1RenderTarget)), "renderTarget")]),
    StdMethod(HRESULT, "CreateHwndRenderTarget", [(Pointer(Const(D2D1_RENDER_TARGET_PROPERTIES)), "renderTargetProperties"), (Pointer(Const(D2D1_HWND_RENDER_TARGET_PROPERTIES)), "hwndRenderTargetProperties"), Out(Pointer(ObjPointer(ID2D1HwndRenderTarget)), "hwndRenderTarget")]),
    StdMethod(HRESULT, "CreateDxgiSurfaceRenderTarget", [(ObjPointer(IDXGISurface), "dxgiSurface"), (Pointer(Const(D2D1_RENDER_TARGET_PROPERTIES)), "renderTargetProperties"), Out(Pointer(ObjPointer(ID2D1RenderTarget)), "renderTarget")]),
    StdMethod(HRESULT, "CreateDCRenderTarget", [(Pointer(Const(D2D1_RENDER_TARGET_PROPERTIES)), "renderTargetProperties"), Out(Pointer(ObjPointer(ID2D1DCRenderTarget)), "dcRenderTarget")]),
]

d2d1 = Module("d2d1")
d2d1.addInterfaces([
    ID2D1Factory
])
d2d1.addFunctions([
    StdFunction(HRESULT, "D2D1CreateFactory", [(D2D1_FACTORY_TYPE, "factoryType"), (REFIID, "riid"), (Pointer(Const(D2D1_FACTORY_OPTIONS)), "pFactoryOptions"), Out(Pointer(ObjPointer(Void)), "ppIFactory")]),
    StdFunction(Void, "D2D1MakeRotateMatrix", [(FLOAT, "angle"), (D2D1_POINT_2F, "center"), Out(Pointer(D2D1_MATRIX_3X2_F), "matrix")]),
    StdFunction(Void, "D2D1MakeSkewMatrix", [(FLOAT, "angleX"), (FLOAT, "angleY"), (D2D1_POINT_2F, "center"), Out(Pointer(D2D1_MATRIX_3X2_F), "matrix")]),
    StdFunction(BOOL, "D2D1IsMatrixInvertible", [(Pointer(Const(D2D1_MATRIX_3X2_F)), "matrix")]),
    StdFunction(BOOL, "D2D1InvertMatrix", [InOut(Pointer(D2D1_MATRIX_3X2_F), "matrix")]),
])

########NEW FILE########
__FILENAME__ = d2dbasetypes
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from winapi import *


D3DCOLORVALUE = Struct("D3DCOLORVALUE", [
    (FLOAT, "r"),
    (FLOAT, "g"),
    (FLOAT, "b"),
    (FLOAT, "a"),
])

D2D_POINT_2U = Struct("D2D_POINT_2U", [
    (UINT32, "x"),
    (UINT32, "y"),
])

D2D_POINT_2F = Struct("D2D_POINT_2F", [
    (FLOAT, "x"),
    (FLOAT, "y"),
])

D2D_RECT_F = Struct("D2D_RECT_F", [
    (FLOAT, "left"),
    (FLOAT, "top"),
    (FLOAT, "right"),
    (FLOAT, "bottom"),
])

D2D_RECT_U = Struct("D2D_RECT_U", [
    (UINT32, "left"),
    (UINT32, "top"),
    (UINT32, "right"),
    (UINT32, "bottom"),
])

D2D_SIZE_F = Struct("D2D_SIZE_F", [
    (FLOAT, "width"),
    (FLOAT, "height"),
])

D2D_SIZE_U = Struct("D2D_SIZE_U", [
    (UINT32, "width"),
    (UINT32, "height"),
])

D2D_COLOR_F = Alias("D2D_COLOR_F", D3DCOLORVALUE)
D2D_MATRIX_3X2_F = Struct("D2D_MATRIX_3X2_F", [
    (FLOAT, "_11"),
    (FLOAT, "_12"),
    (FLOAT, "_21"),
    (FLOAT, "_22"),
    (FLOAT, "_31"),
    (FLOAT, "_32"),
])


########NEW FILE########
__FILENAME__ = d2derr
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from winapi import *


HRESULT = Enum("HRESULT", [
    "D2DERR_UNSUPPORTED_PIXEL_FORMAT",
    "D2DERR_INSUFFICIENT_BUFFER",
    "D2DERR_WRONG_STATE",
    "D2DERR_NOT_INITIALIZED",
    "D2DERR_UNSUPPORTED_OPERATION",
    "D2DERR_SCANNER_FAILED",
    "D2DERR_SCREEN_ACCESS_DENIED",
    "D2DERR_DISPLAY_STATE_INVALID",
    "D2DERR_ZERO_VECTOR",
    "D2DERR_INTERNAL_ERROR",
    "D2DERR_DISPLAY_FORMAT_NOT_SUPPORTED",
    "D2DERR_INVALID_CALL",
    "D2DERR_NO_HARDWARE_DEVICE",
    "D2DERR_RECREATE_TARGET",
    "D2DERR_TOO_MANY_SHADER_ELEMENTS",
    "D2DERR_SHADER_COMPILE_FAILED",
    "D2DERR_MAX_TEXTURE_SIZE_EXCEEDED",
    "D2DERR_UNSUPPORTED_VERSION",
    "D2DERR_BAD_NUMBER",
    "D2DERR_WRONG_FACTORY",
    "D2DERR_LAYER_ALREADY_IN_USE",
    "D2DERR_POP_CALL_DID_NOT_MATCH_PUSH",
    "D2DERR_WRONG_RENDER_TARGET",
    "D2DERR_PUSH_POP_UNBALANCED",
    "D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT",
    "D2DERR_INCOMPATIBLE_BRUSH_TYPES",
    "D2DERR_WIN32_ERROR",
    "D2DERR_TARGET_NOT_GDI_COMPATIBLE",
    "D2DERR_TEXT_EFFECT_IS_WRONG_TYPE",
    "D2DERR_TEXT_RENDERER_NOT_RELEASED",
    "D2DERR_EXCEEDS_MAX_BITMAP_SIZE",
])

########NEW FILE########
__FILENAME__ = d3d
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""d3d.h"""

from winapi import *
from ddraw import *
from d3dtypes import *
from d3dcaps import *

d3dnextFlags = Flags(DWORD, [
    "D3DNEXT_NEXT",
    "D3DNEXT_HEAD",
    "D3DNEXT_TAIL",
])

direct3dFlags = Flags(DWORD, [
    "DIRECT3D_VERSION",
])

d3ddpFlags = Flags(DWORD, [
    "D3DDP_WAIT",
    "D3DDP_OUTOFORDER",
    "D3DDP_DONOTCLIP",
    "D3DDP_DONOTUPDATEEXTENTS",
    "D3DDP_DONOTLIGHT",
])

HRESULT = MAKE_HRESULT(ok = "D3D_OK", errors = [
    "D3DERR_BADMAJORVERSION",
    "D3DERR_BADMINORVERSION",
    "D3DERR_INVALID_DEVICE",
    "D3DERR_INITFAILED",
    "D3DERR_DEVICEAGGREGATED",
    "D3DERR_EXECUTE_CREATE_FAILED",
    "D3DERR_EXECUTE_DESTROY_FAILED",
    "D3DERR_EXECUTE_LOCK_FAILED",
    "D3DERR_EXECUTE_UNLOCK_FAILED",
    "D3DERR_EXECUTE_LOCKED",
    "D3DERR_EXECUTE_NOT_LOCKED",
    "D3DERR_EXECUTE_FAILED",
    "D3DERR_EXECUTE_CLIPPED_FAILED",
    "D3DERR_TEXTURE_NO_SUPPORT",
    "D3DERR_TEXTURE_CREATE_FAILED",
    "D3DERR_TEXTURE_DESTROY_FAILED",
    "D3DERR_TEXTURE_LOCK_FAILED",
    "D3DERR_TEXTURE_UNLOCK_FAILED",
    "D3DERR_TEXTURE_LOAD_FAILED",
    "D3DERR_TEXTURE_SWAP_FAILED",
    "D3DERR_TEXTURE_LOCKED",
    "D3DERR_TEXTURE_NOT_LOCKED",
    "D3DERR_TEXTURE_GETSURF_FAILED",
    "D3DERR_MATRIX_CREATE_FAILED",
    "D3DERR_MATRIX_DESTROY_FAILED",
    "D3DERR_MATRIX_SETDATA_FAILED",
    "D3DERR_MATRIX_GETDATA_FAILED",
    "D3DERR_SETVIEWPORTDATA_FAILED",
    "D3DERR_INVALIDCURRENTVIEWPORT",
    "D3DERR_INVALIDPRIMITIVETYPE",
    "D3DERR_INVALIDVERTEXTYPE",
    "D3DERR_TEXTURE_BADSIZE",
    "D3DERR_INVALIDRAMPTEXTURE",
    "D3DERR_MATERIAL_CREATE_FAILED",
    "D3DERR_MATERIAL_DESTROY_FAILED",
    "D3DERR_MATERIAL_SETDATA_FAILED",
    "D3DERR_MATERIAL_GETDATA_FAILED",
    "D3DERR_INVALIDPALETTE",
    "D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY",
    "D3DERR_ZBUFF_NEEDS_VIDEOMEMORY",
    "D3DERR_SURFACENOTINVIDMEM",
    "D3DERR_LIGHT_SET_FAILED",
    "D3DERR_LIGHTHASVIEWPORT",
    "D3DERR_LIGHTNOTINTHISVIEWPORT",
    "D3DERR_SCENE_IN_SCENE",
    "D3DERR_SCENE_NOT_IN_SCENE",
    "D3DERR_SCENE_BEGIN_FAILED",
    "D3DERR_SCENE_END_FAILED",
    "D3DERR_INBEGIN",
    "D3DERR_NOTINBEGIN",
    "D3DERR_NOVIEWPORTS",
    "D3DERR_VIEWPORTDATANOTSET",
    "D3DERR_VIEWPORTHASNODEVICE",
    "D3DERR_NOCURRENTVIEWPORT",
    "D3DERR_INVALIDVERTEXFORMAT",
    "D3DERR_COLORKEYATTACHED",
    "D3DERR_VERTEXBUFFEROPTIMIZED",
    "D3DERR_VBUF_CREATE_FAILED",
    "D3DERR_VERTEXBUFFERLOCKED",
    "D3DERR_VERTEXBUFFERUNLOCKFAILED",
    "D3DERR_ZBUFFER_NOTPRESENT",
    "D3DERR_STENCILBUFFER_NOTPRESENT",
    "D3DERR_WRONGTEXTUREFORMAT",
    "D3DERR_UNSUPPORTEDCOLOROPERATION",
    "D3DERR_UNSUPPORTEDCOLORARG",
    "D3DERR_UNSUPPORTEDALPHAOPERATION",
    "D3DERR_UNSUPPORTEDALPHAARG",
    "D3DERR_TOOMANYOPERATIONS",
    "D3DERR_CONFLICTINGTEXTUREFILTER",
    "D3DERR_UNSUPPORTEDFACTORVALUE",
    "D3DERR_CONFLICTINGRENDERSTATE",
    "D3DERR_UNSUPPORTEDTEXTUREFILTER",
    "D3DERR_TOOMANYPRIMITIVES",
    "D3DERR_INVALIDMATRIX",
    "D3DERR_TOOMANYVERTICES",
    "D3DERR_CONFLICTINGTEXTUREPALETTE",
    "D3DERR_INVALIDSTATEBLOCK",
    "D3DERR_INBEGINSTATEBLOCK",
    "D3DERR_NOTINBEGINSTATEBLOCK",
])

IDirect3D = Interface("IDirect3D", IUnknown)
IDirect3D2 = Interface("IDirect3D2", IUnknown)
IDirect3D3 = Interface("IDirect3D3", IUnknown)
IDirect3D7 = Interface("IDirect3D7", IUnknown)
IDirect3DDevice = Interface("IDirect3DDevice", IUnknown)
IDirect3DDevice2 = Interface("IDirect3DDevice2", IUnknown)
IDirect3DDevice3 = Interface("IDirect3DDevice3", IUnknown)
IDirect3DDevice7 = Interface("IDirect3DDevice7", IUnknown)
IDirect3DExecuteBuffer = Interface("IDirect3DExecuteBuffer", IUnknown)
IDirect3DLight = Interface("IDirect3DLight", IUnknown)
IDirect3DMaterial = Interface("IDirect3DMaterial", IUnknown)
IDirect3DMaterial2 = Interface("IDirect3DMaterial2", IUnknown)
IDirect3DMaterial3 = Interface("IDirect3DMaterial3", IUnknown)
IDirect3DTexture = Interface("IDirect3DTexture", IUnknown)
IDirect3DTexture2 = Interface("IDirect3DTexture2", IUnknown)
IDirect3DViewport = Interface("IDirect3DViewport", IUnknown)
IDirect3DViewport2 = Interface("IDirect3DViewport2", IDirect3DViewport)
IDirect3DViewport3 = Interface("IDirect3DViewport3", IDirect3DViewport2)
IDirect3DVertexBuffer = Interface("IDirect3DVertexBuffer", IUnknown)
IDirect3DVertexBuffer7 = Interface("IDirect3DVertexBuffer7", IUnknown)

LPUNKNOWN = ObjPointer(IUnknown)

LPDIRECT3D = ObjPointer(IDirect3D)
LPDIRECT3DDEVICE = ObjPointer(IDirect3DDevice)
LPDIRECT3DEXECUTEBUFFER = ObjPointer(IDirect3DExecuteBuffer)
LPDIRECT3DLIGHT = ObjPointer(IDirect3DLight)
LPDIRECT3DMATERIAL = ObjPointer(IDirect3DMaterial)
LPDIRECT3DTEXTURE = ObjPointer(IDirect3DTexture)
LPDIRECT3DVIEWPORT = ObjPointer(IDirect3DViewport)

LPDIRECT3D2 = ObjPointer(IDirect3D2)
LPDIRECT3DDEVICE2 = ObjPointer(IDirect3DDevice2)
LPDIRECT3DMATERIAL2 = ObjPointer(IDirect3DMaterial2)
LPDIRECT3DTEXTURE2 = ObjPointer(IDirect3DTexture2)
LPDIRECT3DVIEWPORT2 = ObjPointer(IDirect3DViewport2)

LPDIRECT3D3 = ObjPointer(IDirect3D3)
LPDIRECT3DDEVICE3 = ObjPointer(IDirect3DDevice3)
LPDIRECT3DMATERIAL3 = ObjPointer(IDirect3DMaterial3)
LPDIRECT3DVIEWPORT3 = ObjPointer(IDirect3DViewport3)
LPDIRECT3DVERTEXBUFFER = ObjPointer(IDirect3DVertexBuffer)

LPDIRECT3D7 = ObjPointer(IDirect3D7)
LPDIRECT3DDEVICE7 = ObjPointer(IDirect3DDevice7)
LPDIRECT3DVERTEXBUFFER7 = ObjPointer(IDirect3DVertexBuffer7)

IDirect3D.methods += [
    StdMethod(HRESULT, "Initialize", [(REFCLSID, "riid")]),
    StdMethod(HRESULT, "EnumDevices", [(LPD3DENUMDEVICESCALLBACK, "lpEnumDevicesCallback"), (LPVOID, "lpUserArg")]),
    StdMethod(HRESULT, "CreateLight", [Out(Pointer(LPDIRECT3DLIGHT), "lplpDirect3DLight"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(HRESULT, "CreateMaterial", [Out(Pointer(LPDIRECT3DMATERIAL), "lplpDirect3DMaterial"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(HRESULT, "CreateViewport", [Out(Pointer(LPDIRECT3DVIEWPORT), "lplpD3DViewport"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(HRESULT, "FindDevice", [(LPD3DFINDDEVICESEARCH, "lpD3DDFS"), (LPD3DFINDDEVICERESULT, "lplpD3DDevice")]),
]

IDirect3D2.methods += [
    StdMethod(HRESULT, "EnumDevices", [(LPD3DENUMDEVICESCALLBACK, "lpEnumDevicesCallback"), (LPVOID, "lpUserArg")]),
    StdMethod(HRESULT, "CreateLight", [Out(Pointer(LPDIRECT3DLIGHT), "lplpDirect3DLight"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(HRESULT, "CreateMaterial", [Out(Pointer(LPDIRECT3DMATERIAL2), "lplpDirect3DMaterial2"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(HRESULT, "CreateViewport", [Out(Pointer(LPDIRECT3DVIEWPORT2), "lplpD3DViewport2"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(HRESULT, "FindDevice", [(LPD3DFINDDEVICESEARCH, "lpD3DDFS"), (LPD3DFINDDEVICERESULT, "lpD3DFDR")]),
    StdMethod(HRESULT, "CreateDevice", [(REFCLSID, "rclsid"), (LPDIRECTDRAWSURFACE, "lpDDS"), Out(Pointer(LPDIRECT3DDEVICE2), "lplpD3DDevice2")]),
]

IDirect3D3.methods += [
    StdMethod(HRESULT, "EnumDevices", [(LPD3DENUMDEVICESCALLBACK, "lpEnumDevicesCallback"), (LPVOID, "lpUserArg")]),
    StdMethod(HRESULT, "CreateLight", [Out(Pointer(LPDIRECT3DLIGHT), "lplpDirect3DLight"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(HRESULT, "CreateMaterial", [Out(Pointer(LPDIRECT3DMATERIAL3), "lplpDirect3DMaterial3"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(HRESULT, "CreateViewport", [Out(Pointer(LPDIRECT3DVIEWPORT3), "lplpD3DViewport3"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(HRESULT, "FindDevice", [(LPD3DFINDDEVICESEARCH, "lpD3DDFS"), Out(LPD3DFINDDEVICERESULT, "lpD3DFDR")]),
    StdMethod(HRESULT, "CreateDevice", [(REFCLSID, "rclsid"), (LPDIRECTDRAWSURFACE4, "lpDDS"), Out(Pointer(LPDIRECT3DDEVICE3), "lplpD3DDevice3"), (LPUNKNOWN, "lpUnk")]),
    StdMethod(HRESULT, "CreateVertexBuffer", [(LPD3DVERTEXBUFFERDESC, "lpD3DVertBufDesc"), Out(Pointer(LPDIRECT3DVERTEXBUFFER), "lplpD3DVertBuf"), (DWORD, "dwFlags"), (LPUNKNOWN, "lpUnk")]),
    StdMethod(HRESULT, "EnumZBufferFormats", [(REFCLSID, "riidDevice"), (LPD3DENUMPIXELFORMATSCALLBACK, "lpEnumCallback"), (LPVOID, "lpContext")]),
    StdMethod(HRESULT, "EvictManagedTextures", []),
]

IDirect3D7.methods += [
    StdMethod(HRESULT, "EnumDevices", [(LPD3DENUMDEVICESCALLBACK7, "lpEnumDevicesCallback"), (LPVOID, "lpUserArg")]),
    StdMethod(HRESULT, "CreateDevice", [(REFCLSID, "rclsid"), (LPDIRECTDRAWSURFACE7, "lpDDS"), Out(Pointer(LPDIRECT3DDEVICE7), "lplpD3DDevice")]),
    StdMethod(HRESULT, "CreateVertexBuffer", [(LPD3DVERTEXBUFFERDESC, "lpD3DVertBufDesc"), Out(Pointer(LPDIRECT3DVERTEXBUFFER7), "lplpD3DVertBuf"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "EnumZBufferFormats", [(REFCLSID, "riidDevice"), (LPD3DENUMPIXELFORMATSCALLBACK, "lpEnumCallback"), (LPVOID, "lpContext")]),
    StdMethod(HRESULT, "EvictManagedTextures", []),
]

IDirect3DDevice.methods += [
    StdMethod(HRESULT, "Initialize", [(LPDIRECT3D, "lpDirect3D"), (LPGUID, "lpGUID"), (LPD3DDEVICEDESC, "lpD3DDVDesc")]),
    StdMethod(HRESULT, "GetCaps", [Out(LPD3DDEVICEDESC, "lpD3DHWDevDesc"), Out(LPD3DDEVICEDESC, "lpD3DHELDevDesc")]),
    StdMethod(HRESULT, "SwapTextureHandles", [(LPDIRECT3DTEXTURE, "lpD3Dtex1"), (LPDIRECT3DTEXTURE, "lpD3DTex2")]),
    StdMethod(HRESULT, "CreateExecuteBuffer", [(LPD3DEXECUTEBUFFERDESC, "lpDesc"), Out(Pointer(LPDIRECT3DEXECUTEBUFFER), "lplpDirect3DExecuteBuffer"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(HRESULT, "GetStats", [(LPD3DSTATS, "lpD3DStats")]),
    StdMethod(HRESULT, "Execute", [(LPDIRECT3DEXECUTEBUFFER, "lpDirect3DExecuteBuffer"), (LPDIRECT3DVIEWPORT, "lpDirect3DViewport"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "AddViewport", [(LPDIRECT3DVIEWPORT, "lpDirect3DViewport")]),
    StdMethod(HRESULT, "DeleteViewport", [(LPDIRECT3DVIEWPORT, "lpDirect3DViewport")]),
    StdMethod(HRESULT, "NextViewport", [(LPDIRECT3DVIEWPORT, "lpDirect3DViewport"), Out(Pointer(LPDIRECT3DVIEWPORT), "lplpDirect3DViewport"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "Pick", [(LPDIRECT3DEXECUTEBUFFER, "lpDirect3DExecuteBuffer"), (LPDIRECT3DVIEWPORT, "lpDirect3DViewport"), (DWORD, "dwFlags"), (LPD3DRECT, "lpRect")]),
    StdMethod(HRESULT, "GetPickRecords", [(LPDWORD, "lpCount"), (LPD3DPICKRECORD, "lpD3DPickRec")]),
    StdMethod(HRESULT, "EnumTextureFormats", [(LPD3DENUMTEXTUREFORMATSCALLBACK, "lpD3DEnumTextureProc"), (LPVOID, "lpArg")]),
    StdMethod(HRESULT, "CreateMatrix", [Out(LPD3DMATRIXHANDLE, "lpD3DMatHandle")]),
    StdMethod(HRESULT, "SetMatrix", [(D3DMATRIXHANDLE, "D3DMatHandle"), (Const(LPD3DMATRIX), "lpD3DMatrix")]),
    StdMethod(HRESULT, "GetMatrix", [(D3DMATRIXHANDLE, "D3DMatHandle"), Out(LPD3DMATRIX, "lpD3DMatrix")]),
    StdMethod(HRESULT, "DeleteMatrix", [(D3DMATRIXHANDLE, "D3DMatHandle")]),
    StdMethod(HRESULT, "BeginScene", []),
    StdMethod(HRESULT, "EndScene", []),
    StdMethod(HRESULT, "GetDirect3D", [Out(Pointer(LPDIRECT3D), "lplpDirect3D")]),
]

IDirect3DDevice2.methods += [
    StdMethod(HRESULT, "GetCaps", [Out(LPD3DDEVICEDESC, "lpD3DHWDevDesc"), Out(LPD3DDEVICEDESC, "lpD3DHELDevDesc")]),
    StdMethod(HRESULT, "SwapTextureHandles", [(LPDIRECT3DTEXTURE2, "lpD3DTex1"), (LPDIRECT3DTEXTURE2, "lpD3DTex2")]),
    StdMethod(HRESULT, "GetStats", [Out(LPD3DSTATS, "lpD3DStats")]),
    StdMethod(HRESULT, "AddViewport", [(LPDIRECT3DVIEWPORT2, "lpDirect3DViewport2")]),
    StdMethod(HRESULT, "DeleteViewport", [(LPDIRECT3DVIEWPORT2, "lpDirect3DViewport2")]),
    StdMethod(HRESULT, "NextViewport", [(LPDIRECT3DVIEWPORT2, "lpDirect3DViewport2"), Out(Pointer(LPDIRECT3DVIEWPORT2), "lplpDirect3DViewport2"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "EnumTextureFormats", [(LPD3DENUMTEXTUREFORMATSCALLBACK, "lpD3DEnumTextureProc"), (LPVOID, "lpArg")]),
    StdMethod(HRESULT, "BeginScene", []),
    StdMethod(HRESULT, "EndScene", []),
    StdMethod(HRESULT, "GetDirect3D", [Out(Pointer(LPDIRECT3D2), "lplpDirect3D2")]),
    StdMethod(HRESULT, "SetCurrentViewport", [(LPDIRECT3DVIEWPORT2, "lpDirect3DViewport2")]),
    StdMethod(HRESULT, "GetCurrentViewport", [Out(Pointer(LPDIRECT3DVIEWPORT2), "lplpDirect3DViewport2")]),
    StdMethod(HRESULT, "SetRenderTarget", [(LPDIRECTDRAWSURFACE, "lpNewRenderTarget"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "GetRenderTarget", [Out(Pointer(LPDIRECTDRAWSURFACE), "lplpRenderTarget")]),
    StdMethod(HRESULT, "Begin", [(D3DPRIMITIVETYPE, "d3dpt"), (D3DVERTEXTYPE, "dwVertexTypeDesc"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "BeginIndexed", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (D3DVERTEXTYPE, "d3dvtVertexType"), (LPVOID, "lpvVertices"), (DWORD, "dwNumVertices"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "Vertex", [(LPVOID, "lpVertexType")]),
    StdMethod(HRESULT, "Index", [(WORD, "wVertexIndex")]),
    StdMethod(HRESULT, "End", [(DWORD, "dwFlags")]),
    StdMethod(HRESULT, "GetRenderState", [(D3DRENDERSTATETYPE, "dwRenderStateType"), Out(LPDWORD, "lpdwRenderState")]),
    StdMethod(HRESULT, "SetRenderState", [(D3DRENDERSTATETYPE, "dwRenderStateType"), (DWORD, "dwRenderState")]),
    StdMethod(HRESULT, "GetLightState", [(D3DLIGHTSTATETYPE, "dwLightStateType"), Out(LPDWORD, "lpdwLightState")]),
    StdMethod(HRESULT, "SetLightState", [(D3DLIGHTSTATETYPE, "dwLightStateType"), (DWORD, "dwLightState")]),
    StdMethod(HRESULT, "SetTransform", [(D3DTRANSFORMSTATETYPE, "dtstTransformStateType"), (LPD3DMATRIX, "lpD3DMatrix")]),
    StdMethod(HRESULT, "GetTransform", [(D3DTRANSFORMSTATETYPE, "dtstTransformStateType"), Out(LPD3DMATRIX, "lpD3DMatrix")]),
    StdMethod(HRESULT, "MultiplyTransform", [(D3DTRANSFORMSTATETYPE, "dtstTransformStateType"), (LPD3DMATRIX, "lpD3DMatrix")]),
    StdMethod(HRESULT, "DrawPrimitive", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (D3DVERTEXTYPE, "d3dvtVertexType"), (LPVOID, "lpvVertices"), (DWORD, "dwVertexCount"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "DrawIndexedPrimitive", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (D3DVERTEXTYPE, "d3dvtVertexType"), (LPVOID, "lpvVertices"), (DWORD, "dwVertexCount"), (LPWORD, "dwIndices"), (DWORD, "dwIndexCount"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "SetClipStatus", [(LPD3DCLIPSTATUS, "lpD3DClipStatus")]),
    StdMethod(HRESULT, "GetClipStatus", [(LPD3DCLIPSTATUS, "lpD3DClipStatus")]),
]

IDirect3DDevice3.methods += [
    StdMethod(HRESULT, "GetCaps", [Out(LPD3DDEVICEDESC, "lpD3DHWDevDesc"), Out(LPD3DDEVICEDESC, "lpD3DHELDevDesc")]),
    StdMethod(HRESULT, "GetStats", [Out(LPD3DSTATS, "lpD3DStats")]),
    StdMethod(HRESULT, "AddViewport", [(LPDIRECT3DVIEWPORT3, "lpDirect3DViewport3")]),
    StdMethod(HRESULT, "DeleteViewport", [(LPDIRECT3DVIEWPORT3, "lpDirect3DViewport3")]),
    StdMethod(HRESULT, "NextViewport", [(LPDIRECT3DVIEWPORT3, "lpDirect3DViewport3"), Out(Pointer(LPDIRECT3DVIEWPORT3), "lplpDirect3DViewport3"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "EnumTextureFormats", [(LPD3DENUMPIXELFORMATSCALLBACK, "lpD3DEnumPixelProc"), (LPVOID, "lpArg")]),
    StdMethod(HRESULT, "BeginScene", []),
    StdMethod(HRESULT, "EndScene", []),
    StdMethod(HRESULT, "GetDirect3D", [Out(Pointer(LPDIRECT3D3), "lplpDirect3D3")]),
    StdMethod(HRESULT, "SetCurrentViewport", [(LPDIRECT3DVIEWPORT3, "lpDirect3DViewport3")]),
    StdMethod(HRESULT, "GetCurrentViewport", [Out(Pointer(LPDIRECT3DVIEWPORT3), "lplpDirect3DViewport3")]),
    StdMethod(HRESULT, "SetRenderTarget", [(LPDIRECTDRAWSURFACE4, "lpNewRenderTarget"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "GetRenderTarget", [Out(Pointer(LPDIRECTDRAWSURFACE4), "lplpRenderTarget")]),
    StdMethod(HRESULT, "Begin", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (DWORD, "dwVertexTypeDesc"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "BeginIndexed", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (DWORD, "d3dvtVertexType"), (LPVOID, "lpvVertices"), (DWORD, "dwNumVertices"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "Vertex", [(LPVOID, "lpVertexType")]),
    StdMethod(HRESULT, "Index", [(WORD, "wVertexIndex")]),
    StdMethod(HRESULT, "End", [(DWORD, "dwFlags")]),
    StdMethod(HRESULT, "GetRenderState", [(D3DRENDERSTATETYPE, "dwRenderStateType"), Out(LPDWORD, "lpdwRenderState")]),
    StdMethod(HRESULT, "SetRenderState", [(D3DRENDERSTATETYPE, "dwRenderStateType"), (DWORD, "dwRenderState")]),
    StdMethod(HRESULT, "GetLightState", [(D3DLIGHTSTATETYPE, "dwLightStateType"), Out(LPDWORD, "lpdwLightState")]),
    StdMethod(HRESULT, "SetLightState", [(D3DLIGHTSTATETYPE, "dwLightStateType"), (DWORD, "dwLightState")]),
    StdMethod(HRESULT, "SetTransform", [(D3DTRANSFORMSTATETYPE, "dtstTransformStateType"), (LPD3DMATRIX, "lpD3DMatrix")]),
    StdMethod(HRESULT, "GetTransform", [(D3DTRANSFORMSTATETYPE, "dtstTransformStateType"), Out(LPD3DMATRIX, "lpD3DMatrix")]),
    StdMethod(HRESULT, "MultiplyTransform", [(D3DTRANSFORMSTATETYPE, "dtstTransformStateType"), (LPD3DMATRIX, "lpD3DMatrix")]),
    StdMethod(HRESULT, "DrawPrimitive", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (DWORD, "d3dvtVertexType"), (LPVOID, "lpvVertices"), (DWORD, "dwVertexCount"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "DrawIndexedPrimitive", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (DWORD, "d3dvtVertexType"), (LPVOID, "lpvVertices"), (DWORD, "dwVertexCount"), (LPWORD, "dwIndices"), (DWORD, "dwIndexCount"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "SetClipStatus", [(LPD3DCLIPSTATUS, "lpD3DClipStatus")]),
    StdMethod(HRESULT, "GetClipStatus", [Out(LPD3DCLIPSTATUS, "lpD3DClipStatus")]),
    StdMethod(HRESULT, "DrawPrimitiveStrided", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (DWORD, "dwVertexType"), (LPD3DDRAWPRIMITIVESTRIDEDDATA, "lpD3DDrawPrimStrideData"), (DWORD, "dwVertexCount"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "DrawIndexedPrimitiveStrided", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (DWORD, "dwVertexType"), (LPD3DDRAWPRIMITIVESTRIDEDDATA, "lpD3DDrawPrimStrideData"), (DWORD, "dwVertexCount"), (LPWORD, "lpIndex"), (DWORD, "dwIndexCount"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "DrawPrimitiveVB", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (LPDIRECT3DVERTEXBUFFER, "lpD3DVertexBuf"), (DWORD, "dwStartVertex"), (DWORD, "dwNumVertices"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "DrawIndexedPrimitiveVB", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (LPDIRECT3DVERTEXBUFFER, "lpD3DVertexBuf"), (LPWORD, "lpwIndices"), (DWORD, "dwIndexCount"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "ComputeSphereVisibility", [(LPD3DVECTOR, "lpCenters"), (LPD3DVALUE, "lpRadii"), (DWORD, "dwNumSpheres"), (DWORD, "dwFlags"), (LPDWORD, "lpdwReturnValues")]),
    StdMethod(HRESULT, "GetTexture", [(DWORD, "dwStage"), Out(Pointer(LPDIRECT3DTEXTURE2), "lplpTexture2")]),
    StdMethod(HRESULT, "SetTexture", [(DWORD, "dwStage"), (LPDIRECT3DTEXTURE2, "lpTexture2")]),
    StdMethod(HRESULT, "GetTextureStageState", [(DWORD, "dwStage"), (D3DTEXTURESTAGESTATETYPE, "d3dTexStageStateType"), Out(LPDWORD, "lpdwState")]),
    StdMethod(HRESULT, "SetTextureStageState", [(DWORD, "dwStage"), (D3DTEXTURESTAGESTATETYPE, "d3dTexStageStateType"), (DWORD, "dwState")]),
    StdMethod(HRESULT, "ValidateDevice", [(LPDWORD, "lpdwPasses")]),
]

IDirect3DDevice7.methods += [
    StdMethod(HRESULT, "GetCaps", [Out(LPD3DDEVICEDESC7, "lpD3DHELDevDesc")]),
    StdMethod(HRESULT, "EnumTextureFormats", [(LPD3DENUMPIXELFORMATSCALLBACK, "lpD3DEnumPixelProc"), (LPVOID, "lpArg")]),
    StdMethod(HRESULT, "BeginScene", []),
    StdMethod(HRESULT, "EndScene", []),
    StdMethod(HRESULT, "GetDirect3D", [Out(Pointer(LPDIRECT3D7), "lplpDirect3D3")]),
    StdMethod(HRESULT, "SetRenderTarget", [(LPDIRECTDRAWSURFACE7, "lpNewRenderTarget"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "GetRenderTarget", [Out(Pointer(LPDIRECTDRAWSURFACE7), "lplpRenderTarget")]),
    StdMethod(HRESULT, "Clear", [(DWORD, "dwCount"), (LPD3DRECT, "lpRects"), (DWORD, "dwFlags"), (D3DCOLOR, "dwColor"), (D3DVALUE, "dvZ"), (DWORD, "dwStencil")]),
    StdMethod(HRESULT, "SetTransform", [(D3DTRANSFORMSTATETYPE, "dtstTransformStateType"), (LPD3DMATRIX, "lpD3DMatrix")]),
    StdMethod(HRESULT, "GetTransform", [(D3DTRANSFORMSTATETYPE, "dtstTransformStateType"), Out(LPD3DMATRIX, "lpD3DMatrix")]),
    StdMethod(HRESULT, "SetViewport", [(LPD3DVIEWPORT7, "lpData")]),
    StdMethod(HRESULT, "MultiplyTransform", [(D3DTRANSFORMSTATETYPE, "dtstTransformStateType"), (LPD3DMATRIX, "lpD3DMatrix")]),
    StdMethod(HRESULT, "GetViewport", [Out(LPD3DVIEWPORT7, "lpData")]),
    StdMethod(HRESULT, "SetMaterial", [(LPD3DMATERIAL7, "lpMat")]),
    StdMethod(HRESULT, "GetMaterial", [Out(LPD3DMATERIAL7, "lpMat")]),
    StdMethod(HRESULT, "SetLight", [(DWORD, "dwLightIndex"), (LPD3DLIGHT7, "lpLight")]),
    StdMethod(HRESULT, "GetLight", [(DWORD, "dwLightIndex"), (LPD3DLIGHT7, "lpLight")]),
    StdMethod(HRESULT, "SetRenderState", [(D3DRENDERSTATETYPE, "dwRenderStateType"), (DWORD, "dwRenderState")]),
    StdMethod(HRESULT, "GetRenderState", [(D3DRENDERSTATETYPE, "dwRenderStateType"), Out(LPDWORD, "lpdwRenderState")]),
    StdMethod(HRESULT, "BeginStateBlock", []),
    StdMethod(HRESULT, "EndStateBlock", [Out(LPDWORD, "lpdwBlockHandle")]),
    StdMethod(HRESULT, "PreLoad", [(LPDIRECTDRAWSURFACE7, "lpddsTexture")]),
    StdMethod(HRESULT, "DrawPrimitive", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (D3DFVF, "d3dvtVertexType"), (LPVOID, "lpvVertices"), (DWORD, "dwVertexCount"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "DrawIndexedPrimitive", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (D3DFVF, "d3dvtVertexType"), (LPVOID, "lpvVertices"), (DWORD, "dwVertexCount"), (LPWORD, "dwIndices"), (DWORD, "dwIndexCount"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "SetClipStatus", [(LPD3DCLIPSTATUS, "lpD3DClipStatus")]),
    StdMethod(HRESULT, "GetClipStatus", [Out(LPD3DCLIPSTATUS, "lpD3DClipStatus")]),
    StdMethod(HRESULT, "DrawPrimitiveStrided", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (D3DFVF, "dwVertexType"), (LPD3DDRAWPRIMITIVESTRIDEDDATA, "lpD3DDrawPrimStrideData"), (DWORD, "dwVertexCount"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "DrawIndexedPrimitiveStrided", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (D3DFVF, "dwVertexType"), (LPD3DDRAWPRIMITIVESTRIDEDDATA, "lpD3DDrawPrimStrideData"), (DWORD, "dwVertexCount"), (LPWORD, "lpIndex"), (DWORD, "dwIndexCount"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "DrawPrimitiveVB", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (LPDIRECT3DVERTEXBUFFER7, "lpD3DVertexBuf"), (DWORD, "dwStartVertex"), (DWORD, "dwNumVertices"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "DrawIndexedPrimitiveVB", [(D3DPRIMITIVETYPE, "d3dptPrimitiveType"), (LPDIRECT3DVERTEXBUFFER7, "lpD3DVertexBuf"), (DWORD, "dwStartVertex"), (DWORD, "dwNumVertices"), (LPWORD, "lpwIndices"), (DWORD, "dwIndexCount"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "ComputeSphereVisibility", [(LPD3DVECTOR, "lpCenters"), (LPD3DVALUE, "lpRadii"), (DWORD, "dwNumSpheres"), (DWORD, "dwFlags"), (LPDWORD, "lpdwReturnValues")]),
    StdMethod(HRESULT, "GetTexture", [(DWORD, "dwStage"), Out(Pointer(LPDIRECTDRAWSURFACE7), "lpTexture")]),
    StdMethod(HRESULT, "SetTexture", [(DWORD, "dwStage"), (LPDIRECTDRAWSURFACE7, "lpTexture")]),
    StdMethod(HRESULT, "GetTextureStageState", [(DWORD, "dwStage"), (D3DTEXTURESTAGESTATETYPE, "d3dTexStageStateType"), Out(LPDWORD, "lpdwState")]),
    StdMethod(HRESULT, "SetTextureStageState", [(DWORD, "dwStage"), (D3DTEXTURESTAGESTATETYPE, "d3dTexStageStateType"), (DWORD, "dwState")]),
    StdMethod(HRESULT, "ValidateDevice", [Out(LPDWORD, "lpdwPasses")]),
    StdMethod(HRESULT, "ApplyStateBlock", [(DWORD, "dwBlockHandle")]),
    StdMethod(HRESULT, "CaptureStateBlock", [(DWORD, "dwBlockHandle")]),
    StdMethod(HRESULT, "DeleteStateBlock", [(DWORD, "dwBlockHandle")]),
    StdMethod(HRESULT, "CreateStateBlock", [(D3DSTATEBLOCKTYPE, "d3dsbType"), Out(LPDWORD, "lpdwBlockHandle")]),
    StdMethod(HRESULT, "Load", [(LPDIRECTDRAWSURFACE7, "lpDestTex"), (LPPOINT, "lpDestPoint"), (LPDIRECTDRAWSURFACE7, "lpSrcTex"), (LPRECT, "lprcSrcRect"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "LightEnable", [(DWORD, "dwLightIndex"), (BOOL, "bEnable")]),
    StdMethod(HRESULT, "GetLightEnable", [(DWORD, "dwLightIndex"), Out(Pointer(BOOL), "pbEnable")]),
    StdMethod(HRESULT, "SetClipPlane", [(DWORD, "dwIndex"), (Pointer(D3DVALUE), "pPlaneEquation")]),
    StdMethod(HRESULT, "GetClipPlane", [(DWORD, "dwIndex"), Out(Pointer(D3DVALUE), "pPlaneEquation")]),
    StdMethod(HRESULT, "GetInfo", [(DWORD, "dwDevInfoID"), Out(LPVOID, "pDevInfoStruct"), (DWORD, "dwSize")]),
]

IDirect3DExecuteBuffer.methods += [
    StdMethod(HRESULT, "Initialize", [(LPDIRECT3DDEVICE, "lpDirect3DDevice"), (LPD3DEXECUTEBUFFERDESC, "lpDesc")]),
    StdMethod(HRESULT, "Lock", [(LPD3DEXECUTEBUFFERDESC, "lpDesc")]),
    StdMethod(HRESULT, "Unlock", []),
    StdMethod(HRESULT, "SetExecuteData", [(LPD3DEXECUTEDATA, "lpData")]),
    StdMethod(HRESULT, "GetExecuteData", [Out(LPD3DEXECUTEDATA, "lpData")]),
    StdMethod(HRESULT, "Validate", [(LPDWORD, "lpdwOffset"), (LPD3DVALIDATECALLBACK, "lpFunc"), (LPVOID, "lpUserArg"), (DWORD, "dwReserved")]),
    StdMethod(HRESULT, "Optimize", [(DWORD, "dwDummy")]),
]

IDirect3DLight.methods += [
    StdMethod(HRESULT, "Initialize", [(LPDIRECT3D, "lpDirect3D")]),
    StdMethod(HRESULT, "SetLight", [(LPD3DLIGHT, "lpLight")]),
    StdMethod(HRESULT, "GetLight", [Out(LPD3DLIGHT, "lpLight")]),
]

IDirect3DMaterial.methods += [
    StdMethod(HRESULT, "Initialize", [(LPDIRECT3D, "lpDirect3D")]),
    StdMethod(HRESULT, "SetMaterial", [(LPD3DMATERIAL, "lpMat")]),
    StdMethod(HRESULT, "GetMaterial", [Out(LPD3DMATERIAL, "lpMat")]),
    StdMethod(HRESULT, "GetHandle", [(LPDIRECT3DDEVICE, "lpDirect3DDevice"), Out(LPD3DMATERIALHANDLE, "lpHandle")]),
    StdMethod(HRESULT, "Reserve", []),
    StdMethod(HRESULT, "Unreserve", []),
]

IDirect3DMaterial2.methods += [
    StdMethod(HRESULT, "SetMaterial", [(LPD3DMATERIAL, "lpMat")]),
    StdMethod(HRESULT, "GetMaterial", [Out(LPD3DMATERIAL, "lpMat")]),
    StdMethod(HRESULT, "GetHandle", [(LPDIRECT3DDEVICE2, "lpDirect3DDevice2"), Out(LPD3DMATERIALHANDLE, "lpHandle")]),
]

IDirect3DMaterial3.methods += [
    StdMethod(HRESULT, "SetMaterial", [(LPD3DMATERIAL, "lpMat")]),
    StdMethod(HRESULT, "GetMaterial", [Out(LPD3DMATERIAL, "lpMat")]),
    StdMethod(HRESULT, "GetHandle", [(LPDIRECT3DDEVICE3, "lpDirect3DDevice3"), Out(LPD3DMATERIALHANDLE, "lpHandle")]),
]

IDirect3DTexture.methods += [
    StdMethod(HRESULT, "Initialize", [(LPDIRECT3DDEVICE, "lpDirect3DDevice"), (LPDIRECTDRAWSURFACE, "lpDDSurface")]),
    StdMethod(HRESULT, "GetHandle", [(LPDIRECT3DDEVICE, "lpDirect3DDevice"), Out(LPD3DTEXTUREHANDLE, "lpHandle")]),
    StdMethod(HRESULT, "PaletteChanged", [(DWORD, "dwStart"), (DWORD, "dwCount")]),
    StdMethod(HRESULT, "Load", [(LPDIRECT3DTEXTURE, "lpD3DTexture")]),
    StdMethod(HRESULT, "Unload", []),
]

IDirect3DTexture2.methods += [
    StdMethod(HRESULT, "GetHandle", [(LPDIRECT3DDEVICE2, "lpDirect3DDevice2"), Out(LPD3DTEXTUREHANDLE, "lpHandle")]),
    StdMethod(HRESULT, "PaletteChanged", [(DWORD, "dwStart"), (DWORD, "dwCount")]),
    StdMethod(HRESULT, "Load", [(LPDIRECT3DTEXTURE2, "lpD3DTexture2")]),
]

IDirect3DViewport.methods += [
    StdMethod(HRESULT, "Initialize", [(LPDIRECT3D, "lpDirect3D")]),
    StdMethod(HRESULT, "GetViewport", [Out(LPD3DVIEWPORT, "lpData")]),
    StdMethod(HRESULT, "SetViewport", [(LPD3DVIEWPORT, "lpData")]),
    StdMethod(HRESULT, "TransformVertices", [(DWORD, "dwVertexCount"), (LPD3DTRANSFORMDATA, "lpData"), (DWORD, "dwFlags"), (LPDWORD, "lpOffScreen")]),
    StdMethod(HRESULT, "LightElements", [(DWORD, "dwElementCount"), (LPD3DLIGHTDATA, "lpData")]),
    StdMethod(HRESULT, "SetBackground", [(D3DMATERIALHANDLE, "hMat")]),
    StdMethod(HRESULT, "GetBackground", [Out(LPD3DMATERIALHANDLE, "lphMat"), Out(LPBOOL, "lpValid")]),
    StdMethod(HRESULT, "SetBackgroundDepth", [(LPDIRECTDRAWSURFACE, "lpDDSurface")]),
    StdMethod(HRESULT, "GetBackgroundDepth", [Out(Pointer(LPDIRECTDRAWSURFACE), "lplpDDSurface"), Out(LPBOOL, "lpValid")]),
    StdMethod(HRESULT, "Clear", [(DWORD, "dwCount"), (LPD3DRECT, "lpRects"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "AddLight", [(LPDIRECT3DLIGHT, "lpDirect3DLight")]),
    StdMethod(HRESULT, "DeleteLight", [(LPDIRECT3DLIGHT, "lpDirect3DLight")]),
    StdMethod(HRESULT, "NextLight", [(LPDIRECT3DLIGHT, "lpDirect3DLight"), Out(Pointer(LPDIRECT3DLIGHT), "lplpDirect3DLight"), (DWORD, "dwFlags")]),
]

IDirect3DViewport2.methods += [
   StdMethod(HRESULT, "GetViewport2", [Out(LPD3DVIEWPORT2, "lpData")]),
    StdMethod(HRESULT, "SetViewport2", [(LPD3DVIEWPORT2, "lpData")]),
]

IDirect3DViewport3.methods += [
    StdMethod(HRESULT, "SetBackgroundDepth2", [(LPDIRECTDRAWSURFACE4, "lpDDS")]),
    StdMethod(HRESULT, "GetBackgroundDepth2", [Out(Pointer(LPDIRECTDRAWSURFACE4), "lplpDDS"), (LPBOOL, "lpValid")]),
    StdMethod(HRESULT, "Clear2", [(DWORD, "dwCount"), (LPD3DRECT, "lpRects"), (DWORD, "dwFlags"), (D3DCOLOR, "dwColor"), (D3DVALUE, "dvZ"), (DWORD, "dwStencil")]),
]

IDirect3DVertexBuffer.methods += [
    StdMethod(HRESULT, "Lock", [(DWORD, "dwFlags"), Out(Pointer(LPVOID), "lplpData"), (LPDWORD, "lpdwSize")]),
    StdMethod(HRESULT, "Unlock", []),
    StdMethod(HRESULT, "ProcessVertices", [(DWORD, "dwVertexOp"), (DWORD, "dwDestIndex"), (DWORD, "dwCount"), (LPDIRECT3DVERTEXBUFFER, "lpSrcBuffer"), (DWORD, "dwSrcIndex"), (LPDIRECT3DDEVICE3, "lpD3DDevice"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "GetVertexBufferDesc", [Out(LPD3DVERTEXBUFFERDESC, "lpD3DVertexBufferDesc")]),
    StdMethod(HRESULT, "Optimize", [(LPDIRECT3DDEVICE3, "lpD3DDevice"), (DWORD, "dwFlags")]),
]

IDirect3DVertexBuffer7.methods += [
    StdMethod(HRESULT, "Lock", [(DWORD, "dwFlags"), Out(Pointer(LPVOID), "lplpData"), (LPDWORD, "lpdwSize")]),
    StdMethod(HRESULT, "Unlock", []),
    StdMethod(HRESULT, "ProcessVertices", [(DWORD, "dwVertexOp"), (DWORD, "dwDestIndex"), (DWORD, "dwCount"), (LPDIRECT3DVERTEXBUFFER7, "lpSrcBuffer"), (DWORD, "dwSrcIndex"), (LPDIRECT3DDEVICE7, "lpD3DDevice"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "GetVertexBufferDesc", [Out(LPD3DVERTEXBUFFERDESC, "lpD3DVertexBufferDesc")]),
    StdMethod(HRESULT, "Optimize", [(LPDIRECT3DDEVICE7, "lpD3DDevice"), (DWORD, "dwFlags")]),
    StdMethod(HRESULT, "ProcessVerticesStrided", [(DWORD, "dwVertexOp"), (DWORD, "dwDestIndex"), (DWORD, "dwCount"), (LPD3DDRAWPRIMITIVESTRIDEDDATA, "lpStrideData"), (DWORD, "dwVertexTypeDesc"), (LPDIRECT3DDEVICE7, "lpD3DDevice"), (DWORD, "dwFlags")]),
]

interfaces = [
    IDirectDraw,
    IDirectDraw2,
    IDirectDraw4,
    IDirectDraw7,
    IDirect3D,
    IDirect3D2,
    IDirect3D3,
    IDirect3D7,
]

ddraw.addInterfaces(interfaces)


########NEW FILE########
__FILENAME__ = d3d10
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from dxgi import *
from d3dcommon import *


HRESULT = MAKE_HRESULT([
    "D3D10_ERROR_FILE_NOT_FOUND",
    "D3D10_ERROR_TOO_MANY_UNIQUE_STATE_OBJECTS",
    "D3DERR_INVALIDCALL",
    "D3DERR_WASSTILLDRAWING",
])

D3D10_BLEND = Enum("D3D10_BLEND", [
    "D3D10_BLEND_ZERO",
    "D3D10_BLEND_ONE",
    "D3D10_BLEND_SRC_COLOR",
    "D3D10_BLEND_INV_SRC_COLOR",
    "D3D10_BLEND_SRC_ALPHA",
    "D3D10_BLEND_INV_SRC_ALPHA",
    "D3D10_BLEND_DEST_ALPHA",
    "D3D10_BLEND_INV_DEST_ALPHA",
    "D3D10_BLEND_DEST_COLOR",
    "D3D10_BLEND_INV_DEST_COLOR",
    "D3D10_BLEND_SRC_ALPHA_SAT",
    "D3D10_BLEND_BLEND_FACTOR",
    "D3D10_BLEND_INV_BLEND_FACTOR",
    "D3D10_BLEND_SRC1_COLOR",
    "D3D10_BLEND_INV_SRC1_COLOR",
    "D3D10_BLEND_SRC1_ALPHA",
    "D3D10_BLEND_INV_SRC1_ALPHA",
])

D3D10_BLEND_OP = Enum("D3D10_BLEND_OP", [
    "D3D10_BLEND_OP_ADD",
    "D3D10_BLEND_OP_SUBTRACT",
    "D3D10_BLEND_OP_REV_SUBTRACT",
    "D3D10_BLEND_OP_MIN",
    "D3D10_BLEND_OP_MAX",
])

D3D10_BLEND_DESC = Struct("D3D10_BLEND_DESC", [
    (BOOL, "AlphaToCoverageEnable"),
    (Array(BOOL, 8), "BlendEnable"),
    (D3D10_BLEND, "SrcBlend"),
    (D3D10_BLEND, "DestBlend"),
    (D3D10_BLEND_OP, "BlendOp"),
    (D3D10_BLEND, "SrcBlendAlpha"),
    (D3D10_BLEND, "DestBlendAlpha"),
    (D3D10_BLEND_OP, "BlendOpAlpha"),
    (Array(UINT8, 8), "RenderTargetWriteMask"),
])

D3D10_DEPTH_WRITE_MASK = Enum("D3D10_DEPTH_WRITE_MASK", [
    "D3D10_DEPTH_WRITE_MASK_ZERO",
    "D3D10_DEPTH_WRITE_MASK_ALL",
])

D3D10_COMPARISON_FUNC = Enum("D3D10_COMPARISON_FUNC", [
    "D3D10_COMPARISON_NEVER",
    "D3D10_COMPARISON_LESS",
    "D3D10_COMPARISON_EQUAL",
    "D3D10_COMPARISON_LESS_EQUAL",
    "D3D10_COMPARISON_GREATER",
    "D3D10_COMPARISON_NOT_EQUAL",
    "D3D10_COMPARISON_GREATER_EQUAL",
    "D3D10_COMPARISON_ALWAYS",
])

D3D10_STENCIL_OP = Enum("D3D10_STENCIL_OP", [
    "D3D10_STENCIL_OP_KEEP",
    "D3D10_STENCIL_OP_ZERO",
    "D3D10_STENCIL_OP_REPLACE",
    "D3D10_STENCIL_OP_INCR_SAT",
    "D3D10_STENCIL_OP_DECR_SAT",
    "D3D10_STENCIL_OP_INVERT",
    "D3D10_STENCIL_OP_INCR",
    "D3D10_STENCIL_OP_DECR",
])

D3D10_DEPTH_STENCILOP_DESC = Struct("D3D10_DEPTH_STENCILOP_DESC", [
    (D3D10_STENCIL_OP, "StencilFailOp"),
    (D3D10_STENCIL_OP, "StencilDepthFailOp"),
    (D3D10_STENCIL_OP, "StencilPassOp"),
    (D3D10_COMPARISON_FUNC, "StencilFunc"),
])

D3D10_DEPTH_STENCIL_DESC = Struct("D3D10_DEPTH_STENCIL_DESC", [
    (BOOL, "DepthEnable"),
    (D3D10_DEPTH_WRITE_MASK, "DepthWriteMask"),
    (D3D10_COMPARISON_FUNC, "DepthFunc"),
    (BOOL, "StencilEnable"),
    (UINT8, "StencilReadMask"),
    (UINT8, "StencilWriteMask"),
    (D3D10_DEPTH_STENCILOP_DESC, "FrontFace"),
    (D3D10_DEPTH_STENCILOP_DESC, "BackFace"),
])

D3D10_FILL_MODE = Enum("D3D10_FILL_MODE", [
    "D3D10_FILL_WIREFRAME",
    "D3D10_FILL_SOLID",
])

D3D10_CULL_MODE = Enum("D3D10_CULL_MODE", [
    "D3D10_CULL_NONE",
    "D3D10_CULL_FRONT",
    "D3D10_CULL_BACK",
])

D3D10_RASTERIZER_DESC = Struct("D3D10_RASTERIZER_DESC", [
    (D3D10_FILL_MODE, "FillMode"),
    (D3D10_CULL_MODE, "CullMode"),
    (BOOL, "FrontCounterClockwise"),
    (INT, "DepthBias"),
    (FLOAT, "DepthBiasClamp"),
    (FLOAT, "SlopeScaledDepthBias"),
    (BOOL, "DepthClipEnable"),
    (BOOL, "ScissorEnable"),
    (BOOL, "MultisampleEnable"),
    (BOOL, "AntialiasedLineEnable"),
])

D3D10_FILTER = Enum("D3D10_FILTER", [
    "D3D10_FILTER_MIN_MAG_MIP_POINT",
    "D3D10_FILTER_MIN_MAG_POINT_MIP_LINEAR",
    "D3D10_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT",
    "D3D10_FILTER_MIN_POINT_MAG_MIP_LINEAR",
    "D3D10_FILTER_MIN_LINEAR_MAG_MIP_POINT",
    "D3D10_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR",
    "D3D10_FILTER_MIN_MAG_LINEAR_MIP_POINT",
    "D3D10_FILTER_MIN_MAG_MIP_LINEAR",
    "D3D10_FILTER_ANISOTROPIC",
    "D3D10_FILTER_COMPARISON_MIN_MAG_MIP_POINT",
    "D3D10_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR",
    "D3D10_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT",
    "D3D10_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR",
    "D3D10_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT",
    "D3D10_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR",
    "D3D10_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT",
    "D3D10_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR",
    "D3D10_FILTER_COMPARISON_ANISOTROPIC",
    "D3D10_FILTER_TEXT_1BIT",
])

D3D10_TEXTURE_ADDRESS_MODE = Enum("D3D10_TEXTURE_ADDRESS_MODE", [
    "D3D10_TEXTURE_ADDRESS_WRAP",
    "D3D10_TEXTURE_ADDRESS_MIRROR",
    "D3D10_TEXTURE_ADDRESS_CLAMP",
    "D3D10_TEXTURE_ADDRESS_BORDER",
    "D3D10_TEXTURE_ADDRESS_MIRROR_ONCE",
])

D3D10_SAMPLER_DESC = Struct("D3D10_SAMPLER_DESC", [
    (D3D10_FILTER, "Filter"),
    (D3D10_TEXTURE_ADDRESS_MODE, "AddressU"),
    (D3D10_TEXTURE_ADDRESS_MODE, "AddressV"),
    (D3D10_TEXTURE_ADDRESS_MODE, "AddressW"),
    (FLOAT, "MipLODBias"),
    (UINT, "MaxAnisotropy"),
    (D3D10_COMPARISON_FUNC, "ComparisonFunc"),
    (Array(FLOAT, 4), "BorderColor"),
    (FLOAT, "MinLOD"),
    (FLOAT, "MaxLOD"),
])

D3D10_FORMAT_SUPPORT = Flags(UINT, [
    "D3D10_FORMAT_SUPPORT_BUFFER",
    "D3D10_FORMAT_SUPPORT_IA_VERTEX_BUFFER",
    "D3D10_FORMAT_SUPPORT_IA_INDEX_BUFFER",
    "D3D10_FORMAT_SUPPORT_SO_BUFFER",
    "D3D10_FORMAT_SUPPORT_TEXTURE1D",
    "D3D10_FORMAT_SUPPORT_TEXTURE2D",
    "D3D10_FORMAT_SUPPORT_TEXTURE3D",
    "D3D10_FORMAT_SUPPORT_TEXTURECUBE",
    "D3D10_FORMAT_SUPPORT_SHADER_LOAD",
    "D3D10_FORMAT_SUPPORT_SHADER_SAMPLE",
    "D3D10_FORMAT_SUPPORT_SHADER_SAMPLE_COMPARISON",
    "D3D10_FORMAT_SUPPORT_SHADER_SAMPLE_MONO_TEXT",
    "D3D10_FORMAT_SUPPORT_MIP",
    "D3D10_FORMAT_SUPPORT_MIP_AUTOGEN",
    "D3D10_FORMAT_SUPPORT_RENDER_TARGET",
    "D3D10_FORMAT_SUPPORT_BLENDABLE",
    "D3D10_FORMAT_SUPPORT_DEPTH_STENCIL",
    "D3D10_FORMAT_SUPPORT_CPU_LOCKABLE",
    "D3D10_FORMAT_SUPPORT_MULTISAMPLE_RESOLVE",
    "D3D10_FORMAT_SUPPORT_DISPLAY",
    "D3D10_FORMAT_SUPPORT_CAST_WITHIN_BIT_LAYOUT",
    "D3D10_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET",
    "D3D10_FORMAT_SUPPORT_MULTISAMPLE_LOAD",
    "D3D10_FORMAT_SUPPORT_SHADER_GATHER",
    "D3D10_FORMAT_SUPPORT_BACK_BUFFER_CAST",
])

D3D10_COUNTER = Enum("D3D10_COUNTER", [
    "D3D10_COUNTER_GPU_IDLE",
    "D3D10_COUNTER_VERTEX_PROCESSING",
    "D3D10_COUNTER_GEOMETRY_PROCESSING",
    "D3D10_COUNTER_PIXEL_PROCESSING",
    "D3D10_COUNTER_OTHER_GPU_PROCESSING",
    "D3D10_COUNTER_HOST_ADAPTER_BANDWIDTH_UTILIZATION",
    "D3D10_COUNTER_LOCAL_VIDMEM_BANDWIDTH_UTILIZATION",
    "D3D10_COUNTER_VERTEX_THROUGHPUT_UTILIZATION",
    "D3D10_COUNTER_TRIANGLE_SETUP_THROUGHPUT_UTILIZATION",
    "D3D10_COUNTER_FILLRATE_THROUGHPUT_UTILIZATION",
    "D3D10_COUNTER_VS_MEMORY_LIMITED",
    "D3D10_COUNTER_VS_COMPUTATION_LIMITED",
    "D3D10_COUNTER_GS_MEMORY_LIMITED",
    "D3D10_COUNTER_GS_COMPUTATION_LIMITED",
    "D3D10_COUNTER_PS_MEMORY_LIMITED",
    "D3D10_COUNTER_PS_COMPUTATION_LIMITED",
    "D3D10_COUNTER_POST_TRANSFORM_CACHE_HIT_RATE",
    "D3D10_COUNTER_TEXTURE_CACHE_HIT_RATE",
    "D3D10_COUNTER_DEVICE_DEPENDENT_0",
])

D3D10_COUNTER_DESC = Struct("D3D10_COUNTER_DESC", [
    (D3D10_COUNTER, "Counter"),
    (UINT, "MiscFlags"),
])

D3D10_COUNTER_TYPE = Enum("D3D10_COUNTER_TYPE", [
    "D3D10_COUNTER_TYPE_FLOAT32",
    "D3D10_COUNTER_TYPE_UINT16",
    "D3D10_COUNTER_TYPE_UINT32",
    "D3D10_COUNTER_TYPE_UINT64",
])

D3D10_COUNTER_INFO = Struct("D3D10_COUNTER_INFO", [
    (D3D10_COUNTER, "LastDeviceDependentCounter"),
    (UINT, "NumSimultaneousCounters"),
    (UINT8, "NumDetectableParallelUnits"),
])

D3D10_RESOURCE_DIMENSION = Enum("D3D10_RESOURCE_DIMENSION", [
    "D3D10_RESOURCE_DIMENSION_UNKNOWN",
    "D3D10_RESOURCE_DIMENSION_BUFFER",
    "D3D10_RESOURCE_DIMENSION_TEXTURE1D",
    "D3D10_RESOURCE_DIMENSION_TEXTURE2D",
    "D3D10_RESOURCE_DIMENSION_TEXTURE3D",
])

D3D10_USAGE = Enum("D3D10_USAGE", [
    "D3D10_USAGE_DEFAULT",
    "D3D10_USAGE_IMMUTABLE",
    "D3D10_USAGE_DYNAMIC",
    "D3D10_USAGE_STAGING",
])

D3D10_BIND_FLAG = Flags(UINT, [
    "D3D10_BIND_VERTEX_BUFFER",
    "D3D10_BIND_INDEX_BUFFER",
    "D3D10_BIND_CONSTANT_BUFFER",
    "D3D10_BIND_SHADER_RESOURCE",
    "D3D10_BIND_STREAM_OUTPUT",
    "D3D10_BIND_RENDER_TARGET",
    "D3D10_BIND_DEPTH_STENCIL",
])

D3D10_CPU_ACCESS_FLAG = Flags(UINT, [
    "D3D10_CPU_ACCESS_WRITE",
    "D3D10_CPU_ACCESS_READ",
])

D3D10_RESOURCE_MISC_FLAG = Flags(UINT, [
    "D3D10_RESOURCE_MISC_GENERATE_MIPS",
    "D3D10_RESOURCE_MISC_SHARED",
    "D3D10_RESOURCE_MISC_TEXTURECUBE",
    "D3D10_RESOURCE_MISC_SHARED_KEYEDMUTEX",
    "D3D10_RESOURCE_MISC_GDI_COMPATIBLE",
])

D3D10_BUFFER_DESC = Struct("D3D10_BUFFER_DESC", [
    (UINT, "ByteWidth"),
    (D3D10_USAGE, "Usage"),
    (D3D10_BIND_FLAG, "BindFlags"),
    (D3D10_CPU_ACCESS_FLAG, "CPUAccessFlags"),
    (D3D10_RESOURCE_MISC_FLAG, "MiscFlags"),
])

D3D10_MAP = Enum("D3D10_MAP", [
    "D3D10_MAP_READ",
    "D3D10_MAP_WRITE",
    "D3D10_MAP_READ_WRITE",
    "D3D10_MAP_WRITE_DISCARD",
    "D3D10_MAP_WRITE_NO_OVERWRITE",
])

D3D10_TEXTURE1D_DESC = Struct("D3D10_TEXTURE1D_DESC", [
    (UINT, "Width"),
    (UINT, "MipLevels"),
    (UINT, "ArraySize"),
    (DXGI_FORMAT, "Format"),
    (D3D10_USAGE, "Usage"),
    (D3D10_BIND_FLAG, "BindFlags"),
    (D3D10_CPU_ACCESS_FLAG, "CPUAccessFlags"),
    (D3D10_RESOURCE_MISC_FLAG, "MiscFlags"),
])

D3D10_TEXTURE2D_DESC = Struct("D3D10_TEXTURE2D_DESC", [
    (UINT, "Width"),
    (UINT, "Height"),
    (UINT, "MipLevels"),
    (UINT, "ArraySize"),
    (DXGI_FORMAT, "Format"),
    (DXGI_SAMPLE_DESC, "SampleDesc"),
    (D3D10_USAGE, "Usage"),
    (D3D10_BIND_FLAG, "BindFlags"),
    (D3D10_CPU_ACCESS_FLAG, "CPUAccessFlags"),
    (D3D10_RESOURCE_MISC_FLAG, "MiscFlags"),
])

D3D10_TEXTURE3D_DESC = Struct("D3D10_TEXTURE3D_DESC", [
    (UINT, "Width"),
    (UINT, "Height"),
    (UINT, "Depth"),
    (UINT, "MipLevels"),
    (DXGI_FORMAT, "Format"),
    (D3D10_USAGE, "Usage"),
    (D3D10_BIND_FLAG, "BindFlags"),
    (D3D10_CPU_ACCESS_FLAG, "CPUAccessFlags"),
    (D3D10_RESOURCE_MISC_FLAG, "MiscFlags"),
])

D3D10_DSV_DIMENSION = Enum("D3D10_DSV_DIMENSION", [
    "D3D10_DSV_DIMENSION_UNKNOWN",
    "D3D10_DSV_DIMENSION_TEXTURE1D",
    "D3D10_DSV_DIMENSION_TEXTURE1DARRAY",
    "D3D10_DSV_DIMENSION_TEXTURE2D",
    "D3D10_DSV_DIMENSION_TEXTURE2DARRAY",
    "D3D10_DSV_DIMENSION_TEXTURE2DMS",
    "D3D10_DSV_DIMENSION_TEXTURE2DMSARRAY",
])

D3D10_TEX1D_DSV = Struct("D3D10_TEX1D_DSV", [
    (UINT, "MipSlice"),
])

D3D10_TEX1D_ARRAY_DSV = Struct("D3D10_TEX1D_ARRAY_DSV", [
    (UINT, "MipSlice"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D10_TEX2D_DSV = Struct("D3D10_TEX2D_DSV", [
    (UINT, "MipSlice"),
])

D3D10_TEX2D_ARRAY_DSV = Struct("D3D10_TEX2D_ARRAY_DSV", [
    (UINT, "MipSlice"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D10_TEX2DMS_DSV = Struct("D3D10_TEX2DMS_DSV", [
    (UINT, "UnusedField_NothingToDefine"),
])

D3D10_TEX2DMS_ARRAY_DSV = Struct("D3D10_TEX2DMS_ARRAY_DSV", [
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D10_DEPTH_STENCIL_VIEW_DESC = Struct("D3D10_DEPTH_STENCIL_VIEW_DESC", [
    (DXGI_FORMAT, "Format"),
    (D3D10_DSV_DIMENSION, "ViewDimension"),
    (Union("{self}.ViewDimension", [
        ("D3D10_DSV_DIMENSION_TEXTURE1D", D3D10_TEX1D_DSV, "Texture1D"),
        ("D3D10_DSV_DIMENSION_TEXTURE1DARRAY", D3D10_TEX1D_ARRAY_DSV, "Texture1DArray"),
        ("D3D10_DSV_DIMENSION_TEXTURE2D", D3D10_TEX2D_DSV, "Texture2D"),
        ("D3D10_DSV_DIMENSION_TEXTURE2DARRAY", D3D10_TEX2D_ARRAY_DSV, "Texture2DArray"),
        ("D3D10_DSV_DIMENSION_TEXTURE2DMS", D3D10_TEX2DMS_DSV, "Texture2DMS"),
        ("D3D10_DSV_DIMENSION_TEXTURE2DMSARRAY", D3D10_TEX2DMS_ARRAY_DSV, "Texture2DMSArray"),
    ]), None),
])

D3D10_RTV_DIMENSION = Enum("D3D10_RTV_DIMENSION", [
    "D3D10_RTV_DIMENSION_UNKNOWN",
    "D3D10_RTV_DIMENSION_BUFFER",
    "D3D10_RTV_DIMENSION_TEXTURE1D",
    "D3D10_RTV_DIMENSION_TEXTURE1DARRAY",
    "D3D10_RTV_DIMENSION_TEXTURE2D",
    "D3D10_RTV_DIMENSION_TEXTURE2DARRAY",
    "D3D10_RTV_DIMENSION_TEXTURE2DMS",
    "D3D10_RTV_DIMENSION_TEXTURE2DMSARRAY",
    "D3D10_RTV_DIMENSION_TEXTURE3D",
])

D3D10_BUFFER_RTV = Struct("D3D10_BUFFER_RTV", [
    (UINT, "FirstElement"),
    (UINT, "NumElements"),
])

D3D10_TEX1D_RTV = Struct("D3D10_TEX1D_RTV", [
    (UINT, "MipSlice"),
])

D3D10_TEX1D_ARRAY_RTV = Struct("D3D10_TEX1D_ARRAY_RTV", [
    (UINT, "MipSlice"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D10_TEX2D_RTV = Struct("D3D10_TEX2D_RTV", [
    (UINT, "MipSlice"),
])

D3D10_TEX2D_ARRAY_RTV = Struct("D3D10_TEX2D_ARRAY_RTV", [
    (UINT, "MipSlice"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D10_TEX2DMS_RTV = Struct("D3D10_TEX2DMS_RTV", [
    (UINT, "UnusedField_NothingToDefine"),
])

D3D10_TEX2DMS_ARRAY_RTV = Struct("D3D10_TEX2DMS_ARRAY_RTV", [
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D10_TEX3D_RTV = Struct("D3D10_TEX3D_RTV", [
    (UINT, "MipSlice"),
    (UINT, "FirstWSlice"),
    (UINT, "WSize"),
])

D3D10_RENDER_TARGET_VIEW_DESC = Struct("D3D10_RENDER_TARGET_VIEW_DESC", [
    (DXGI_FORMAT, "Format"),
    (D3D10_RTV_DIMENSION, "ViewDimension"),
    (Union("{self}.ViewDimension", [
        ("D3D10_RTV_DIMENSION_BUFFER", D3D10_BUFFER_RTV, "Buffer"),
        ("D3D10_RTV_DIMENSION_TEXTURE1D", D3D10_TEX1D_RTV, "Texture1D"),
        ("D3D10_RTV_DIMENSION_TEXTURE1DARRAY", D3D10_TEX1D_ARRAY_RTV, "Texture1DArray"),
        ("D3D10_RTV_DIMENSION_TEXTURE2D", D3D10_TEX2D_RTV, "Texture2D"),
        ("D3D10_RTV_DIMENSION_TEXTURE2DARRAY", D3D10_TEX2D_ARRAY_RTV, "Texture2DArray"),
        ("D3D10_RTV_DIMENSION_TEXTURE2DMS", D3D10_TEX2DMS_RTV, "Texture2DMS"),
        ("D3D10_RTV_DIMENSION_TEXTURE2DMSARRAY", D3D10_TEX2DMS_ARRAY_RTV, "Texture2DMSArray"),
        ("D3D10_RTV_DIMENSION_TEXTURE3D", D3D10_TEX3D_RTV, "Texture3D"),
    ]), None),
])

D3D10_SRV_DIMENSION = Enum("D3D10_SRV_DIMENSION", [
    "D3D10_SRV_DIMENSION_UNKNOWN",
	"D3D10_SRV_DIMENSION_BUFFER",
	"D3D10_SRV_DIMENSION_TEXTURE1D",
	"D3D10_SRV_DIMENSION_TEXTURE1DARRAY",
	"D3D10_SRV_DIMENSION_TEXTURE2D",
	"D3D10_SRV_DIMENSION_TEXTURE2DARRAY",
	"D3D10_SRV_DIMENSION_TEXTURE2DMS",
	"D3D10_SRV_DIMENSION_TEXTURE2DMSARRAY",
	"D3D10_SRV_DIMENSION_TEXTURE3D",
	"D3D10_SRV_DIMENSION_TEXTURECUBE",
])

D3D10_BUFFER_SRV = Struct("D3D10_BUFFER_SRV", [
    (UINT, "FirstElement"),
    (UINT, "NumElements"),
])

D3D10_TEX1D_SRV = Struct("D3D10_TEX1D_SRV", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
])

D3D10_TEX1D_ARRAY_SRV = Struct("D3D10_TEX1D_ARRAY_SRV", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D10_TEX2D_SRV = Struct("D3D10_TEX2D_SRV", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
])

D3D10_TEX2D_ARRAY_SRV = Struct("D3D10_TEX2D_ARRAY_SRV", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D10_TEX2DMS_SRV = Struct("D3D10_TEX2DMS_SRV", [
    (UINT, "UnusedField_NothingToDefine"),
])

D3D10_TEX2DMS_ARRAY_SRV = Struct("D3D10_TEX2DMS_ARRAY_SRV", [
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D10_TEX3D_SRV = Struct("D3D10_TEX3D_SRV", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
])

D3D10_TEXCUBE_SRV = Struct("D3D10_TEXCUBE_SRV", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
])

D3D10_SHADER_RESOURCE_VIEW_DESC = Struct("D3D10_SHADER_RESOURCE_VIEW_DESC", [
    (DXGI_FORMAT, "Format"),
    (D3D10_SRV_DIMENSION, "ViewDimension"),
    (Union("{self}.ViewDimension", [
        ("D3D10_SRV_DIMENSION_BUFFER", D3D10_BUFFER_SRV, "Buffer"),
        ("D3D10_SRV_DIMENSION_TEXTURE1D", D3D10_TEX1D_SRV, "Texture1D"),
        ("D3D10_SRV_DIMENSION_TEXTURE1DARRAY", D3D10_TEX1D_ARRAY_SRV, "Texture1DArray"),
        ("D3D10_SRV_DIMENSION_TEXTURE2D", D3D10_TEX2D_SRV, "Texture2D"), 
        ("D3D10_SRV_DIMENSION_TEXTURE2DARRAY", D3D10_TEX2D_ARRAY_SRV, "Texture2DArray"),
        ("D3D10_SRV_DIMENSION_TEXTURE2DMS", D3D10_TEX2DMS_SRV, "Texture2DMS"),
        ("D3D10_SRV_DIMENSION_TEXTURE2DMSARRAY", D3D10_TEX2DMS_ARRAY_SRV, "Texture2DMSArray"),
        ("D3D10_SRV_DIMENSION_TEXTURE3D", D3D10_TEX3D_SRV, "Texture3D"),
        ("D3D10_SRV_DIMENSION_TEXTURECUBE", D3D10_TEXCUBE_SRV, "TextureCube"),
    ]), None),
])

D3D10_BOX = Struct("D3D10_BOX", [
    (UINT, "left"),
    (UINT, "top"),
    (UINT, "front"),
    (UINT, "right"),
    (UINT, "bottom"),
    (UINT, "back"),
])

D3D10_SUBRESOURCE_DATA = Struct("D3D10_SUBRESOURCE_DATA", [
    (Blob(Const(Void), "_calcSubresourceSize(pDesc, {i}, {self}.SysMemPitch, {self}.SysMemSlicePitch)"), "pSysMem"),
    (UINT, "SysMemPitch"),
    (UINT, "SysMemSlicePitch"),
])

D3D10_SO_DECLARATION_ENTRY = Struct("D3D10_SO_DECLARATION_ENTRY", [
    (LPCSTR, "SemanticName"),
    (UINT, "SemanticIndex"),
    (BYTE, "StartComponent"),
    (BYTE, "ComponentCount"),
    (BYTE, "OutputSlot"),
])

D3D10_INPUT_CLASSIFICATION = Enum("D3D10_INPUT_CLASSIFICATION", [
    "D3D10_INPUT_PER_VERTEX_DATA",
    "D3D10_INPUT_PER_INSTANCE_DATA",
])

D3D10_INPUT_ELEMENT_DESC = Struct("D3D10_INPUT_ELEMENT_DESC", [
    (LPCSTR, "SemanticName"),
    (UINT, "SemanticIndex"),
    (DXGI_FORMAT, "Format"),
    (UINT, "InputSlot"),
    (UINT, "AlignedByteOffset"),
    (D3D10_INPUT_CLASSIFICATION, "InputSlotClass"),
    (UINT, "InstanceDataStepRate"),
])

D3D10_QUERY = Enum("D3D10_QUERY", [
    "D3D10_QUERY_EVENT",
    "D3D10_QUERY_OCCLUSION",
    "D3D10_QUERY_TIMESTAMP",
    "D3D10_QUERY_TIMESTAMP_DISJOINT",
    "D3D10_QUERY_PIPELINE_STATISTICS",
    "D3D10_QUERY_OCCLUSION_PREDICATE",
    "D3D10_QUERY_SO_STATISTICS",
    "D3D10_QUERY_SO_OVERFLOW_PREDICATE",
])

D3D10_QUERY_MISC_FLAG = Flags(UINT, [
    "D3D10_QUERY_MISC_PREDICATEHINT",
])

D3D10_QUERY_DESC = Struct("D3D10_QUERY_DESC", [
    (D3D10_QUERY, "Query"),
    (D3D10_QUERY_MISC_FLAG, "MiscFlags"),
])

D3D10_RECT = Alias("D3D10_RECT", RECT)
D3D10_VIEWPORT = Struct("D3D10_VIEWPORT", [
    (INT, "TopLeftX"),
    (INT, "TopLeftY"),
    (UINT, "Width"),
    (UINT, "Height"),
    (FLOAT, "MinDepth"),
    (FLOAT, "MaxDepth"),
])

D3D10_MAPPED_TEXTURE2D = Struct("D3D10_MAPPED_TEXTURE2D", [
    (LinearPointer(Void, "_MappedSize"), "pData"),
    (UINT, "RowPitch"),
])

D3D10_MAPPED_TEXTURE3D = Struct("D3D10_MAPPED_TEXTURE3D", [
    (LinearPointer(Void, "_MappedSize"), "pData"),
    (UINT, "RowPitch"),
    (UINT, "DepthPitch"),
])

D3D10_MAP_FLAG = Flags(UINT, [
    "D3D10_MAP_FLAG_DO_NOT_WAIT",
])

D3D10_CLEAR_FLAG = Flags(UINT, [
    "D3D10_CLEAR_DEPTH",
    "D3D10_CLEAR_STENCIL",
])

D3D10_COLOR_WRITE_ENABLE = Flags(UINT, [
    "D3D10_COLOR_WRITE_ENABLE_ALL",
    "D3D10_COLOR_WRITE_ENABLE_RED",
    "D3D10_COLOR_WRITE_ENABLE_GREEN",
    "D3D10_COLOR_WRITE_ENABLE_BLUE",
    "D3D10_COLOR_WRITE_ENABLE_ALPHA",
])

D3D10_TEXTURECUBE_FACE = Enum("D3D10_TEXTURECUBE_FACE", [
    "D3D10_TEXTURECUBE_FACE_POSITIVE_X",
    "D3D10_TEXTURECUBE_FACE_NEGATIVE_X",
    "D3D10_TEXTURECUBE_FACE_POSITIVE_Y",
    "D3D10_TEXTURECUBE_FACE_NEGATIVE_Y",
    "D3D10_TEXTURECUBE_FACE_POSITIVE_Z",
    "D3D10_TEXTURECUBE_FACE_NEGATIVE_Z",
])

D3D10_ASYNC_GETDATA_FLAG = Flags(UINT, [
    "D3D10_ASYNC_GETDATA_DONOTFLUSH",
])

D3D10_FILTER_TYPE = Enum("D3D10_FILTER_TYPE", [
    "D3D10_FILTER_TYPE_POINT",
    "D3D10_FILTER_TYPE_LINEAR",
])

D3D10_QUERY_DATA_TIMESTAMP_DISJOINT = Struct("D3D10_QUERY_DATA_TIMESTAMP_DISJOINT", [
    (UINT64, "Frequency"),
    (BOOL, "Disjoint"),
])

D3D10_QUERY_DATA_PIPELINE_STATISTICS = Struct("D3D10_QUERY_DATA_PIPELINE_STATISTICS", [
    (UINT64, "IAVertices"),
    (UINT64, "IAPrimitives"),
    (UINT64, "VSInvocations"),
    (UINT64, "GSInvocations"),
    (UINT64, "GSPrimitives"),
    (UINT64, "CInvocations"),
    (UINT64, "CPrimitives"),
    (UINT64, "PSInvocations"),
])

D3D10_QUERY_DATA_SO_STATISTICS = Struct("D3D10_QUERY_DATA_SO_STATISTICS", [
    (UINT64, "NumPrimitivesWritten"),
    (UINT64, "PrimitivesStorageNeeded"),
])

D3D10_CREATE_DEVICE_FLAG = Flags(UINT, [
    "D3D10_CREATE_DEVICE_SINGLETHREADED",
    "D3D10_CREATE_DEVICE_DEBUG",
    "D3D10_CREATE_DEVICE_SWITCH_TO_REF",
    "D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS",
    "D3D10_CREATE_DEVICE_ALLOW_NULL_FROM_MAP",
    "D3D10_CREATE_DEVICE_BGRA_SUPPORT",
    "D3D10_CREATE_DEVICE_STRICT_VALIDATION",
    "D3D10_CREATE_DEVICE_BGRA_SUPPORT",
    "D3D10_CREATE_DEVICE_PREVENT_ALTERING_LAYER_SETTINGS_FROM_REGISTRY",
    "D3D10_CREATE_DEVICE_STRICT_VALIDATION",
    "D3D10_CREATE_DEVICE_DEBUGGABLE",
])

D3D10_RAISE_FLAG = Flags(UINT, [
    "D3D10_RAISE_FLAG_DRIVER_INTERNAL_ERROR",
])

ID3D10DeviceChild = Interface("ID3D10DeviceChild", IUnknown)
ID3D10Resource = Interface("ID3D10Resource", ID3D10DeviceChild)
ID3D10Buffer = Interface("ID3D10Buffer", ID3D10Resource)
ID3D10Texture1D = Interface("ID3D10Texture1D", ID3D10Resource)
ID3D10Texture2D = Interface("ID3D10Texture2D", ID3D10Resource)
ID3D10Texture3D = Interface("ID3D10Texture3D", ID3D10Resource)
ID3D10View = Interface("ID3D10View", ID3D10DeviceChild)
ID3D10DepthStencilView = Interface("ID3D10DepthStencilView", ID3D10View)
ID3D10RenderTargetView = Interface("ID3D10RenderTargetView", ID3D10View)
ID3D10ShaderResourceView = Interface("ID3D10ShaderResourceView", ID3D10View)
ID3D10BlendState = Interface("ID3D10BlendState", ID3D10DeviceChild)
ID3D10DepthStencilState = Interface("ID3D10DepthStencilState", ID3D10DeviceChild)
ID3D10GeometryShader = Interface("ID3D10GeometryShader", ID3D10DeviceChild)
ID3D10InputLayout = Interface("ID3D10InputLayout", ID3D10DeviceChild)
ID3D10PixelShader = Interface("ID3D10PixelShader", ID3D10DeviceChild)
ID3D10RasterizerState = Interface("ID3D10RasterizerState", ID3D10DeviceChild)
ID3D10SamplerState = Interface("ID3D10SamplerState", ID3D10DeviceChild)
ID3D10VertexShader = Interface("ID3D10VertexShader", ID3D10DeviceChild)
ID3D10Asynchronous = Interface("ID3D10Asynchronous", ID3D10DeviceChild)
ID3D10Counter = Interface("ID3D10Counter", ID3D10Asynchronous)
ID3D10Query = Interface("ID3D10Query", ID3D10Asynchronous)
ID3D10Predicate = Interface("ID3D10Predicate", ID3D10Query)
ID3D10Device = Interface("ID3D10Device", IUnknown)
ID3D10Multithread = Interface("ID3D10Multithread", IUnknown)

ID3D10DeviceChild.methods += [
    StdMethod(Void, "GetDevice", [Out(Pointer(ObjPointer(ID3D10Device)), "ppDevice")]),
    StdMethod(HRESULT, "GetPrivateData", [(REFGUID, "guid"), Out(Pointer(UINT), "pDataSize"), Out(OpaquePointer(Void), "pData")], sideeffects=False),
    StdMethod(HRESULT, "SetPrivateData", [(REFGUID, "guid"), (UINT, "DataSize"), (OpaqueBlob(Const(Void), "DataSize"), "pData")], sideeffects=False),
    StdMethod(HRESULT, "SetPrivateDataInterface", [(REFGUID, "guid"), (OpaquePointer(Const(IUnknown)), "pData")], sideeffects=False),
]

ID3D10Resource.methods += [
    StdMethod(Void, "GetType", [Out(Pointer(D3D10_RESOURCE_DIMENSION), "rType")], sideeffects=False),
    StdMethod(Void, "SetEvictionPriority", [(UINT, "EvictionPriority")]),
    StdMethod(UINT, "GetEvictionPriority", [], sideeffects=False),
]

ID3D10Buffer.methods += [
    StdMethod(HRESULT, "Map", [(D3D10_MAP, "MapType"), (D3D10_MAP_FLAG, "MapFlags"), Out(Pointer(LinearPointer(Void, "_MappedSize")), "ppData")]),
    StdMethod(Void, "Unmap", []),
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D10_BUFFER_DESC), "pDesc")], sideeffects=False),
]

ID3D10Texture1D.methods += [
    StdMethod(HRESULT, "Map", [(UINT, "Subresource"), (D3D10_MAP, "MapType"), (D3D10_MAP_FLAG, "MapFlags"), Out(Pointer(LinearPointer(Void, "_MappedSize")), "ppData")]),
    StdMethod(Void, "Unmap", [(UINT, "Subresource")]),
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D10_TEXTURE1D_DESC), "pDesc")], sideeffects=False),
]

ID3D10Texture2D.methods += [
    StdMethod(HRESULT, "Map", [(UINT, "Subresource"), (D3D10_MAP, "MapType"), (D3D10_MAP_FLAG, "MapFlags"), Out(Pointer(D3D10_MAPPED_TEXTURE2D), "pMappedTex2D")]),
    StdMethod(Void, "Unmap", [(UINT, "Subresource")]),
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D10_TEXTURE2D_DESC), "pDesc")], sideeffects=False),
]

ID3D10Texture3D.methods += [
    StdMethod(HRESULT, "Map", [(UINT, "Subresource"), (D3D10_MAP, "MapType"), (D3D10_MAP_FLAG, "MapFlags"), Out(Pointer(D3D10_MAPPED_TEXTURE3D), "pMappedTex3D")]),
    StdMethod(Void, "Unmap", [(UINT, "Subresource")]),
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D10_TEXTURE3D_DESC), "pDesc")], sideeffects=False),
]

ID3D10View.methods += [
    StdMethod(Void, "GetResource", [Out(Pointer(ObjPointer(ID3D10Resource)), "ppResource")]),
]

ID3D10DepthStencilView.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D10_DEPTH_STENCIL_VIEW_DESC), "pDesc")], sideeffects=False),
]

ID3D10RenderTargetView.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D10_RENDER_TARGET_VIEW_DESC), "pDesc")], sideeffects=False),
]

ID3D10ShaderResourceView.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D10_SHADER_RESOURCE_VIEW_DESC), "pDesc")], sideeffects=False),
]

ID3D10BlendState.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D10_BLEND_DESC), "pDesc")], sideeffects=False),
]

ID3D10DepthStencilState.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D10_DEPTH_STENCIL_DESC), "pDesc")], sideeffects=False),
]

ID3D10RasterizerState.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D10_RASTERIZER_DESC), "pDesc")], sideeffects=False),
]

ID3D10SamplerState.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D10_SAMPLER_DESC), "pDesc")], sideeffects=False),
]

ID3D10Asynchronous.methods += [
    StdMethod(Void, "Begin", []),
    StdMethod(Void, "End", []),
    StdMethod(HRESULT, "GetData", [Out(Blob(Void, "DataSize"), "pData"), (UINT, "DataSize"), (D3D10_ASYNC_GETDATA_FLAG, "GetDataFlags")], sideeffects=False),
    StdMethod(UINT, "GetDataSize", [], sideeffects=False),
]

ID3D10Counter.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D10_COUNTER_DESC), "pDesc")], sideeffects=False),
]

ID3D10Query.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D10_QUERY_DESC), "pDesc")], sideeffects=False),
]

ID3D10Device.methods += [
    StdMethod(Void, "VSSetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D10Buffer)), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "PSSetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), (Array(Const(ObjPointer(ID3D10ShaderResourceView)), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "PSSetShader", [(ObjPointer(ID3D10PixelShader), "pPixelShader")]),
    StdMethod(Void, "PSSetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), (Array(Const(ObjPointer(ID3D10SamplerState)), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "VSSetShader", [(ObjPointer(ID3D10VertexShader), "pVertexShader")]),
    StdMethod(Void, "DrawIndexed", [(UINT, "IndexCount"), (UINT, "StartIndexLocation"), (INT, "BaseVertexLocation")]),
    StdMethod(Void, "Draw", [(UINT, "VertexCount"), (UINT, "StartVertexLocation")]),
    StdMethod(Void, "PSSetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D10Buffer)), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "IASetInputLayout", [(ObjPointer(ID3D10InputLayout), "pInputLayout")]),
    StdMethod(Void, "IASetVertexBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D10Buffer)), "NumBuffers"), "ppVertexBuffers"), (Array(Const(UINT), "NumBuffers"), "pStrides"), (Array(Const(UINT), "NumBuffers"), "pOffsets")]),
    StdMethod(Void, "IASetIndexBuffer", [(ObjPointer(ID3D10Buffer), "pIndexBuffer"), (DXGI_FORMAT, "Format"), (UINT, "Offset")]),
    StdMethod(Void, "DrawIndexedInstanced", [(UINT, "IndexCountPerInstance"), (UINT, "InstanceCount"), (UINT, "StartIndexLocation"), (INT, "BaseVertexLocation"), (UINT, "StartInstanceLocation")]),
    StdMethod(Void, "DrawInstanced", [(UINT, "VertexCountPerInstance"), (UINT, "InstanceCount"), (UINT, "StartVertexLocation"), (UINT, "StartInstanceLocation")]),
    StdMethod(Void, "GSSetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D10Buffer)), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "GSSetShader", [(ObjPointer(ID3D10GeometryShader), "pShader")]),
    StdMethod(Void, "IASetPrimitiveTopology", [(D3D10_PRIMITIVE_TOPOLOGY, "Topology")]),
    StdMethod(Void, "VSSetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), (Array(Const(ObjPointer(ID3D10ShaderResourceView)), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "VSSetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), (Array(Const(ObjPointer(ID3D10SamplerState)), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "SetPredication", [(ObjPointer(ID3D10Predicate), "pPredicate"), (BOOL, "PredicateValue")]),
    StdMethod(Void, "GSSetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), (Array(Const(ObjPointer(ID3D10ShaderResourceView)), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "GSSetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), (Array(Const(ObjPointer(ID3D10SamplerState)), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "OMSetRenderTargets", [(UINT, "NumViews"), (Array(Const(ObjPointer(ID3D10RenderTargetView)), "NumViews"), "ppRenderTargetViews"), (ObjPointer(ID3D10DepthStencilView), "pDepthStencilView")]),
    StdMethod(Void, "OMSetBlendState", [(ObjPointer(ID3D10BlendState), "pBlendState"), (Array(Const(FLOAT), 4), "BlendFactor"), (UINT, "SampleMask")]),
    StdMethod(Void, "OMSetDepthStencilState", [(ObjPointer(ID3D10DepthStencilState), "pDepthStencilState"), (UINT, "StencilRef")]),
    StdMethod(Void, "SOSetTargets", [(UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D10Buffer)), "NumBuffers"), "ppSOTargets"), (Array(Const(UINT), "NumBuffers"), "pOffsets")]),
    StdMethod(Void, "DrawAuto", []),
    StdMethod(Void, "RSSetState", [(ObjPointer(ID3D10RasterizerState), "pRasterizerState")]),
    StdMethod(Void, "RSSetViewports", [(UINT, "NumViewports"), (Array(Const(D3D10_VIEWPORT), "NumViewports"), "pViewports")]),
    StdMethod(Void, "RSSetScissorRects", [(UINT, "NumRects"), (Array(Const(D3D10_RECT), "NumRects"), "pRects")]),
    StdMethod(Void, "CopySubresourceRegion", [(ObjPointer(ID3D10Resource), "pDstResource"), (UINT, "DstSubresource"), (UINT, "DstX"), (UINT, "DstY"), (UINT, "DstZ"), (ObjPointer(ID3D10Resource), "pSrcResource"), (UINT, "SrcSubresource"), (Pointer(Const(D3D10_BOX)), "pSrcBox")]),
    StdMethod(Void, "CopyResource", [(ObjPointer(ID3D10Resource), "pDstResource"), (ObjPointer(ID3D10Resource), "pSrcResource")]),
    StdMethod(Void, "UpdateSubresource", [(ObjPointer(ID3D10Resource), "pDstResource"), (UINT, "DstSubresource"), (Pointer(Const(D3D10_BOX)), "pDstBox"), (Blob(Const(Void), "_calcSubresourceSize(pDstResource, DstSubresource, pDstBox, SrcRowPitch, SrcDepthPitch)"), "pSrcData"), (UINT, "SrcRowPitch"), (UINT, "SrcDepthPitch")]),
    StdMethod(Void, "ClearRenderTargetView", [(ObjPointer(ID3D10RenderTargetView), "pRenderTargetView"), (Array(Const(FLOAT), 4), "ColorRGBA")]),
    StdMethod(Void, "ClearDepthStencilView", [(ObjPointer(ID3D10DepthStencilView), "pDepthStencilView"), (D3D10_CLEAR_FLAG, "ClearFlags"), (FLOAT, "Depth"), (UINT8, "Stencil")]),
    StdMethod(Void, "GenerateMips", [(ObjPointer(ID3D10ShaderResourceView), "pShaderResourceView")]),
    StdMethod(Void, "ResolveSubresource", [(ObjPointer(ID3D10Resource), "pDstResource"), (UINT, "DstSubresource"), (ObjPointer(ID3D10Resource), "pSrcResource"), (UINT, "SrcSubresource"), (DXGI_FORMAT, "Format")]),
    StdMethod(Void, "VSGetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D10Buffer), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "PSGetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), Out(Array(ObjPointer(ID3D10ShaderResourceView), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "PSGetShader", [Out(Pointer(ObjPointer(ID3D10PixelShader)), "ppPixelShader")]),
    StdMethod(Void, "PSGetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), Out(Array(ObjPointer(ID3D10SamplerState), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "VSGetShader", [Out(Pointer(ObjPointer(ID3D10VertexShader)), "ppVertexShader")]),
    StdMethod(Void, "PSGetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D10Buffer), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "IAGetInputLayout", [Out(Pointer(ObjPointer(ID3D10InputLayout)), "ppInputLayout")]),
    StdMethod(Void, "IAGetVertexBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D10Buffer), "NumBuffers"), "ppVertexBuffers"), Out(Array(UINT, "NumBuffers"), "pStrides"), Out(Array(UINT, "NumBuffers"), "pOffsets")]),
    StdMethod(Void, "IAGetIndexBuffer", [Out(Pointer(ObjPointer(ID3D10Buffer)), "pIndexBuffer"), Out(Pointer(DXGI_FORMAT), "Format"), Out(Pointer(UINT), "Offset")]),
    StdMethod(Void, "GSGetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D10Buffer), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "GSGetShader", [Out(Pointer(ObjPointer(ID3D10GeometryShader)), "ppGeometryShader")]),
    StdMethod(Void, "IAGetPrimitiveTopology", [Out(Pointer(D3D10_PRIMITIVE_TOPOLOGY), "pTopology")], sideeffects=False),
    StdMethod(Void, "VSGetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), Out(Array(ObjPointer(ID3D10ShaderResourceView), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "VSGetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), Out(Array(ObjPointer(ID3D10SamplerState), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "GetPredication", [Out(Pointer(ObjPointer(ID3D10Predicate)), "ppPredicate"), Out(Pointer(BOOL), "pPredicateValue")]),
    StdMethod(Void, "GSGetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), Out(Array(ObjPointer(ID3D10ShaderResourceView), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "GSGetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), Out(Array(ObjPointer(ID3D10SamplerState), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "OMGetRenderTargets", [(UINT, "NumViews"), Out(Array(ObjPointer(ID3D10RenderTargetView), "NumViews"), "ppRenderTargetViews"), Out(Pointer(ObjPointer(ID3D10DepthStencilView)), "ppDepthStencilView")]),
    StdMethod(Void, "OMGetBlendState", [Out(Pointer(ObjPointer(ID3D10BlendState)), "ppBlendState"), Out(Array(FLOAT, 4), "BlendFactor"), Out(Pointer(UINT), "pSampleMask")]),
    StdMethod(Void, "OMGetDepthStencilState", [Out(Pointer(ObjPointer(ID3D10DepthStencilState)), "ppDepthStencilState"), Out(Pointer(UINT), "pStencilRef")]),
    StdMethod(Void, "SOGetTargets", [(UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D10Buffer), "NumBuffers"), "ppSOTargets"), Out(Array(UINT, "NumBuffers"), "pOffsets")]),
    StdMethod(Void, "RSGetState", [Out(Pointer(ObjPointer(ID3D10RasterizerState)), "ppRasterizerState")]),
    StdMethod(Void, "RSGetViewports", [Out(Pointer(UINT), "NumViewports"), Out(Array(D3D10_VIEWPORT, "*NumViewports"), "pViewports")], sideeffects=False),
    StdMethod(Void, "RSGetScissorRects", [Out(Pointer(UINT), "NumRects"), Out(Array(D3D10_RECT, "*NumRects"), "pRects")], sideeffects=False),
    StdMethod(HRESULT, "GetDeviceRemovedReason", [], sideeffects=False),
    StdMethod(HRESULT, "SetExceptionMode", [(D3D10_RAISE_FLAG, "RaiseFlags")]),
    StdMethod(D3D10_RAISE_FLAG, "GetExceptionMode", [], sideeffects=False),
    StdMethod(HRESULT, "GetPrivateData", [(REFGUID, "guid"), Out(Pointer(UINT), "pDataSize"), Out(OpaquePointer(Void), "pData")], sideeffects=False),
    StdMethod(HRESULT, "SetPrivateData", [(REFGUID, "guid"), (UINT, "DataSize"), (OpaqueBlob(Const(Void), "DataSize"), "pData")], sideeffects=False),
    StdMethod(HRESULT, "SetPrivateDataInterface", [(REFGUID, "guid"), (OpaquePointer(Const(IUnknown)), "pData")], sideeffects=False),
    StdMethod(Void, "ClearState", []),
    StdMethod(Void, "Flush", []),
    StdMethod(HRESULT, "CreateBuffer", [(Pointer(Const(D3D10_BUFFER_DESC)), "pDesc"), (Array(Const(D3D10_SUBRESOURCE_DATA), "1"), "pInitialData"), Out(Pointer(ObjPointer(ID3D10Buffer)), "ppBuffer")]),
    StdMethod(HRESULT, "CreateTexture1D", [(Pointer(Const(D3D10_TEXTURE1D_DESC)), "pDesc"), (Array(Const(D3D10_SUBRESOURCE_DATA), "_getNumSubResources(pDesc)"), "pInitialData"), Out(Pointer(ObjPointer(ID3D10Texture1D)), "ppTexture1D")]),
    StdMethod(HRESULT, "CreateTexture2D", [(Pointer(Const(D3D10_TEXTURE2D_DESC)), "pDesc"), (Array(Const(D3D10_SUBRESOURCE_DATA), "_getNumSubResources(pDesc)"), "pInitialData"), Out(Pointer(ObjPointer(ID3D10Texture2D)), "ppTexture2D")]),
    StdMethod(HRESULT, "CreateTexture3D", [(Pointer(Const(D3D10_TEXTURE3D_DESC)), "pDesc"), (Array(Const(D3D10_SUBRESOURCE_DATA), "_getNumSubResources(pDesc)"), "pInitialData"), Out(Pointer(ObjPointer(ID3D10Texture3D)), "ppTexture3D")]),
    StdMethod(HRESULT, "CreateShaderResourceView", [(ObjPointer(ID3D10Resource), "pResource"), (Pointer(Const(D3D10_SHADER_RESOURCE_VIEW_DESC)), "pDesc"), Out(Pointer(ObjPointer(ID3D10ShaderResourceView)), "ppSRView")]),
    StdMethod(HRESULT, "CreateRenderTargetView", [(ObjPointer(ID3D10Resource), "pResource"), (Pointer(Const(D3D10_RENDER_TARGET_VIEW_DESC)), "pDesc"), Out(Pointer(ObjPointer(ID3D10RenderTargetView)), "ppRTView")]),
    StdMethod(HRESULT, "CreateDepthStencilView", [(ObjPointer(ID3D10Resource), "pResource"), (Pointer(Const(D3D10_DEPTH_STENCIL_VIEW_DESC)), "pDesc"), Out(Pointer(ObjPointer(ID3D10DepthStencilView)), "ppDepthStencilView")]),
    StdMethod(HRESULT, "CreateInputLayout", [(Array(Const(D3D10_INPUT_ELEMENT_DESC), "NumElements"), "pInputElementDescs"), (UINT, "NumElements"), (Blob(Const(Void), "BytecodeLength"), "pShaderBytecodeWithInputSignature"), (SIZE_T, "BytecodeLength"), Out(Pointer(ObjPointer(ID3D10InputLayout)), "ppInputLayout")]),
    StdMethod(HRESULT, "CreateVertexShader", [(Blob(Const(Void), "BytecodeLength"), "pShaderBytecode"), (SIZE_T, "BytecodeLength"), Out(Pointer(ObjPointer(ID3D10VertexShader)), "ppVertexShader")]),
    StdMethod(HRESULT, "CreateGeometryShader", [(Blob(Const(Void), "BytecodeLength"), "pShaderBytecode"), (SIZE_T, "BytecodeLength"), Out(Pointer(ObjPointer(ID3D10GeometryShader)), "ppGeometryShader")]),
    StdMethod(HRESULT, "CreateGeometryShaderWithStreamOutput", [(Blob(Const(Void), "BytecodeLength"), "pShaderBytecode"), (SIZE_T, "BytecodeLength"), (Array(Const(D3D10_SO_DECLARATION_ENTRY), "NumEntries"), "pSODeclaration"), (UINT, "NumEntries"), (UINT, "OutputStreamStride"), Out(Pointer(ObjPointer(ID3D10GeometryShader)), "ppGeometryShader")]),
    StdMethod(HRESULT, "CreatePixelShader", [(Blob(Const(Void), "BytecodeLength"), "pShaderBytecode"), (SIZE_T, "BytecodeLength"), Out(Pointer(ObjPointer(ID3D10PixelShader)), "ppPixelShader")]),
    StdMethod(HRESULT, "CreateBlendState", [(Pointer(Const(D3D10_BLEND_DESC)), "pBlendStateDesc"), Out(Pointer(ObjPointer(ID3D10BlendState)), "ppBlendState")]),
    StdMethod(HRESULT, "CreateDepthStencilState", [(Pointer(Const(D3D10_DEPTH_STENCIL_DESC)), "pDepthStencilDesc"), Out(Pointer(ObjPointer(ID3D10DepthStencilState)), "ppDepthStencilState")]),
    StdMethod(HRESULT, "CreateRasterizerState", [(Pointer(Const(D3D10_RASTERIZER_DESC)), "pRasterizerDesc"), Out(Pointer(ObjPointer(ID3D10RasterizerState)), "ppRasterizerState")]),
    StdMethod(HRESULT, "CreateSamplerState", [(Pointer(Const(D3D10_SAMPLER_DESC)), "pSamplerDesc"), Out(Pointer(ObjPointer(ID3D10SamplerState)), "ppSamplerState")]),
    StdMethod(HRESULT, "CreateQuery", [(Pointer(Const(D3D10_QUERY_DESC)), "pQueryDesc"), Out(Pointer(ObjPointer(ID3D10Query)), "ppQuery")]),
    StdMethod(HRESULT, "CreatePredicate", [(Pointer(Const(D3D10_QUERY_DESC)), "pPredicateDesc"), Out(Pointer(ObjPointer(ID3D10Predicate)), "ppPredicate")]),
    StdMethod(HRESULT, "CreateCounter", [(Pointer(Const(D3D10_COUNTER_DESC)), "pCounterDesc"), Out(Pointer(ObjPointer(ID3D10Counter)), "ppCounter")]),
    StdMethod(HRESULT, "CheckFormatSupport", [(DXGI_FORMAT, "Format"), Out(Pointer(D3D10_FORMAT_SUPPORT), "pFormatSupport")], sideeffects=False),
    StdMethod(HRESULT, "CheckMultisampleQualityLevels", [(DXGI_FORMAT, "Format"), (UINT, "SampleCount"), Out(Pointer(UINT), "pNumQualityLevels")], sideeffects=False),
    StdMethod(Void, "CheckCounterInfo", [Out(Pointer(D3D10_COUNTER_INFO), "pCounterInfo")], sideeffects=False),
    StdMethod(HRESULT, "CheckCounter", [(Pointer(Const(D3D10_COUNTER_DESC)), "pDesc"), Out(Pointer(D3D10_COUNTER_TYPE), "pType"), Out(Pointer(UINT), "pActiveCounters"), Out(LPSTR, "szName"), Out(Pointer(UINT), "pNameLength"), Out(LPSTR, "szUnits"), Out(Pointer(UINT), "pUnitsLength"), Out(LPSTR, "szDescription"), Out(Pointer(UINT), "pDescriptionLength")], sideeffects=False),
    StdMethod(D3D10_CREATE_DEVICE_FLAG, "GetCreationFlags", [], sideeffects=False),
    StdMethod(HRESULT, "OpenSharedResource", [(HANDLE, "hResource"), (REFIID, "ReturnedInterface"), Out(Pointer(ObjPointer(Void)), "ppResource")]),
    StdMethod(Void, "SetTextFilterSize", [(UINT, "Width"), (UINT, "Height")]),
    StdMethod(Void, "GetTextFilterSize", [Out(Pointer(UINT), "pWidth"), Out(Pointer(UINT), "pHeight")], sideeffects=False),
]

ID3D10Multithread.methods += [
    StdMethod(Void, "Enter", []),
    StdMethod(Void, "Leave", []),
    StdMethod(BOOL, "SetMultithreadProtected", [(BOOL, "bMTProtect")]),
    StdMethod(BOOL, "GetMultithreadProtected", [], sideeffects=False),
]


d3d10 = Module("d3d10")


from d3d10sdklayers import *
import d3d10misc

########NEW FILE########
__FILENAME__ = d3d10misc
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""d3d10misc.h"""

from winapi import *
from d3d10 import *


D3D10_DRIVER_TYPE = Enum("D3D10_DRIVER_TYPE", [
    "D3D10_DRIVER_TYPE_HARDWARE",
    "D3D10_DRIVER_TYPE_REFERENCE",
    "D3D10_DRIVER_TYPE_NULL",
    "D3D10_DRIVER_TYPE_SOFTWARE",
    "D3D10_DRIVER_TYPE_WARP",
])


d3d10.addFunctions([
    StdFunction(HRESULT, "D3D10CreateDevice", [(ObjPointer(IDXGIAdapter), "pAdapter"), (D3D10_DRIVER_TYPE, "DriverType"), (HMODULE, "Software"), (D3D10_CREATE_DEVICE_FLAG, "Flags"), (UINT, "SDKVersion"), Out(Pointer(ObjPointer(ID3D10Device)), "ppDevice")]),
    StdFunction(HRESULT, "D3D10CreateDeviceAndSwapChain", [(ObjPointer(IDXGIAdapter), "pAdapter"), (D3D10_DRIVER_TYPE, "DriverType"), (HMODULE, "Software"), (D3D10_CREATE_DEVICE_FLAG, "Flags"), (UINT, "SDKVersion"), (Pointer(DXGI_SWAP_CHAIN_DESC), "pSwapChainDesc"), Out(Pointer(ObjPointer(IDXGISwapChain)), "ppSwapChain"), Out(Pointer(ObjPointer(ID3D10Device)), "ppDevice")]),
])

d3d10.addInterfaces([
    IDXGIAdapter1,
    IDXGIDevice1,
    IDXGIResource,
    ID3D10Debug,
    ID3D10InfoQueue,
    ID3D10Multithread,
    ID3D10SwitchToRef,
])


########NEW FILE########
__FILENAME__ = d3d10sdklayers
##########################################################################
#
# Copyright 2012 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

from dxgi import *
from d3d10 import HRESULT

D3D10_DEBUG_FEATURE = Flags(UINT, [
    "D3D10_DEBUG_FEATURE_FLUSH_PER_RENDER_OP",
    "D3D10_DEBUG_FEATURE_FINISH_PER_RENDER_OP",
    "D3D10_DEBUG_FEATURE_PRESENT_PER_RENDER_OP",
])

ID3D10Debug = Interface("ID3D10Debug", IUnknown)
ID3D10Debug.methods += [
    StdMethod(HRESULT, "SetFeatureMask", [(D3D10_DEBUG_FEATURE, "Mask")]),
    StdMethod(UINT, "GetFeatureMask", [], sideeffects=False),
    StdMethod(HRESULT, "SetPresentPerRenderOpDelay", [(UINT, "Milliseconds")]),
    StdMethod(UINT, "GetPresentPerRenderOpDelay", [], sideeffects=False),
    StdMethod(HRESULT, "SetSwapChain", [(ObjPointer(IDXGISwapChain), "pSwapChain")]),
    StdMethod(HRESULT, "GetSwapChain", [Out(Pointer(ObjPointer(IDXGISwapChain)), "ppSwapChain")]),
    StdMethod(HRESULT, "Validate", []),
]

ID3D10SwitchToRef = Interface("ID3D10SwitchToRef", IUnknown)
ID3D10SwitchToRef.methods += [
    StdMethod(BOOL, "SetUseRef", [(BOOL, "UseRef")]),
    StdMethod(BOOL, "GetUseRef", [], sideeffects=False),
]

D3D10_MESSAGE_CATEGORY = Enum("D3D10_MESSAGE_CATEGORY", [
    "D3D10_MESSAGE_CATEGORY_APPLICATION_DEFINED",
    "D3D10_MESSAGE_CATEGORY_MISCELLANEOUS",
    "D3D10_MESSAGE_CATEGORY_INITIALIZATION",
    "D3D10_MESSAGE_CATEGORY_CLEANUP",
    "D3D10_MESSAGE_CATEGORY_COMPILATION",
    "D3D10_MESSAGE_CATEGORY_STATE_CREATION",
    "D3D10_MESSAGE_CATEGORY_STATE_SETTING",
    "D3D10_MESSAGE_CATEGORY_STATE_GETTING",
    "D3D10_MESSAGE_CATEGORY_RESOURCE_MANIPULATION",
    "D3D10_MESSAGE_CATEGORY_EXECUTION",
])

D3D10_MESSAGE_SEVERITY = Enum("D3D10_MESSAGE_SEVERITY", [
    "D3D10_MESSAGE_SEVERITY_CORRUPTION",
    "D3D10_MESSAGE_SEVERITY_ERROR",
    "D3D10_MESSAGE_SEVERITY_WARNING",
    "D3D10_MESSAGE_SEVERITY_INFO",
])

D3D10_MESSAGE_ID = Enum("D3D10_MESSAGE_ID", [
    "D3D10_MESSAGE_ID_UNKNOWN",
    "D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_HAZARD",
    "D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_HAZARD",
    "D3D10_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_HAZARD",
    "D3D10_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_HAZARD",
    "D3D10_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_HAZARD",
    "D3D10_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_HAZARD",
    "D3D10_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_HAZARD",
    "D3D10_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_HAZARD",
    "D3D10_MESSAGE_ID_DEVICE_OMSETRENDERTARGETS_HAZARD",
    "D3D10_MESSAGE_ID_DEVICE_SOSETTARGETS_HAZARD",
    "D3D10_MESSAGE_ID_STRING_FROM_APPLICATION",
    "D3D10_MESSAGE_ID_CORRUPTED_THIS",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER1",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER2",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER3",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER4",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER5",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER6",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER7",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER8",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER9",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER10",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER11",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER12",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER13",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER14",
    "D3D10_MESSAGE_ID_CORRUPTED_PARAMETER15",
    "D3D10_MESSAGE_ID_CORRUPTED_MULTITHREADING",
    "D3D10_MESSAGE_ID_MESSAGE_REPORTING_OUTOFMEMORY",
    "D3D10_MESSAGE_ID_IASETINPUTLAYOUT_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_IASETINDEXBUFFER_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_VSSETSHADER_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_VSSETSHADERRESOURCES_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_VSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_VSSETSAMPLERS_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_GSSETSHADER_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_GSSETSHADERRESOURCES_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_GSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_GSSETSAMPLERS_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_SOSETTARGETS_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_PSSETSHADER_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_PSSETSHADERRESOURCES_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_PSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_PSSETSAMPLERS_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_RSSETSTATE_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_OMSETBLENDSTATE_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_OMSETDEPTHSTENCILSTATE_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_OMSETRENDERTARGETS_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_SETPREDICATION_UNBINDDELETINGOBJECT",
    "D3D10_MESSAGE_ID_GETPRIVATEDATA_MOREDATA",
    "D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDFREEDATA",
    "D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDIUNKNOWN",
    "D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDFLAGS",
    "D3D10_MESSAGE_ID_SETPRIVATEDATA_CHANGINGPARAMS",
    "D3D10_MESSAGE_ID_SETPRIVATEDATA_OUTOFMEMORY",
    "D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDFORMAT",
    "D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDSAMPLES",
    "D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDUSAGE",
    "D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDBINDFLAGS",
    "D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDCPUACCESSFLAGS",
    "D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDMISCFLAGS",
    "D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDCPUACCESSFLAGS",
    "D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDBINDFLAGS",
    "D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDINITIALDATA",
    "D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDDIMENSIONS",
    "D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDMIPLEVELS",
    "D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDMISCFLAGS",
    "D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDARG_RETURN",
    "D3D10_MESSAGE_ID_CREATEBUFFER_OUTOFMEMORY_RETURN",
    "D3D10_MESSAGE_ID_CREATEBUFFER_NULLDESC",
    "D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDCONSTANTBUFFERBINDINGS",
    "D3D10_MESSAGE_ID_CREATEBUFFER_LARGEALLOCATION",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDFORMAT",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_UNSUPPORTEDFORMAT",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDSAMPLES",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDUSAGE",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDBINDFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDCPUACCESSFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDMISCFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDCPUACCESSFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDBINDFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDINITIALDATA",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDDIMENSIONS",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDMIPLEVELS",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDMISCFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDARG_RETURN",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_OUTOFMEMORY_RETURN",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_NULLDESC",
    "D3D10_MESSAGE_ID_CREATETEXTURE1D_LARGEALLOCATION",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDFORMAT",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_UNSUPPORTEDFORMAT",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDSAMPLES",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDUSAGE",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDBINDFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDCPUACCESSFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDMISCFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDCPUACCESSFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDBINDFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDINITIALDATA",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDDIMENSIONS",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDMIPLEVELS",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDMISCFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDARG_RETURN",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_OUTOFMEMORY_RETURN",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_NULLDESC",
    "D3D10_MESSAGE_ID_CREATETEXTURE2D_LARGEALLOCATION",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDFORMAT",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_UNSUPPORTEDFORMAT",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDSAMPLES",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDUSAGE",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDBINDFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDCPUACCESSFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDMISCFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDCPUACCESSFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDBINDFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDINITIALDATA",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDDIMENSIONS",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDMIPLEVELS",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDMISCFLAGS",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDARG_RETURN",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_OUTOFMEMORY_RETURN",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_NULLDESC",
    "D3D10_MESSAGE_ID_CREATETEXTURE3D_LARGEALLOCATION",
    "D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT",
    "D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDESC",
    "D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFORMAT",
    "D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS",
    "D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDRESOURCE",
    "D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_TOOMANYOBJECTS",
    "D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDARG_RETURN",
    "D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_OUTOFMEMORY_RETURN",
    "D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT",
    "D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT",
    "D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDESC",
    "D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDFORMAT",
    "D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDIMENSIONS",
    "D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDRESOURCE",
    "D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_TOOMANYOBJECTS",
    "D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDARG_RETURN",
    "D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_OUTOFMEMORY_RETURN",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDESC",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFORMAT",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_TOOMANYOBJECTS",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDARG_RETURN",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_OUTOFMEMORY_RETURN",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_OUTOFMEMORY",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TOOMANYELEMENTS",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDFORMAT",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOT",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDALIGNMENT",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_DUPLICATESEMANTIC",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_NULLSEMANTIC",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_MISSINGELEMENT",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_NULLDESC",
    "D3D10_MESSAGE_ID_CREATEVERTEXSHADER_OUTOFMEMORY",
    "D3D10_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERBYTECODE",
    "D3D10_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERTYPE",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_OUTOFMEMORY",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERTYPE",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDDECL",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_EXPECTEDDECL",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE",
    "D3D10_MESSAGE_ID_CREATEPIXELSHADER_OUTOFMEMORY",
    "D3D10_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERBYTECODE",
    "D3D10_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERTYPE",
    "D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFILLMODE",
    "D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDCULLMODE",
    "D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP",
    "D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS",
    "D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_TOOMANYOBJECTS",
    "D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_NULLDESC",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_TOOMANYOBJECTS",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_NULLDESC",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLEND",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLEND",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOP",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLENDALPHA",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLENDALPHA",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOPALPHA",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_TOOMANYOBJECTS",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_NULLDESC",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDFILTER",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSU",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSV",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSW",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMIPLODBIAS",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXANISOTROPY",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDCOMPARISONFUNC",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMINLOD",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXLOD",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_TOOMANYOBJECTS",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NULLDESC",
    "D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDQUERY",
    "D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDMISCFLAGS",
    "D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_UNEXPECTEDMISCFLAG",
    "D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_NULLDESC",
    "D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNRECOGNIZED",
    "D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNDEFINED",
    "D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_INVALIDBUFFER",
    "D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_OFFSET_TOO_LARGE",
    "D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_BUFFERS_EMPTY",
    "D3D10_MESSAGE_ID_IASETINDEXBUFFER_INVALIDBUFFER",
    "D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_FORMAT_INVALID",
    "D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_TOO_LARGE",
    "D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_UNALIGNED",
    "D3D10_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D10_MESSAGE_ID_VSSETCONSTANTBUFFERS_INVALIDBUFFER",
    "D3D10_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_VSSETSAMPLERS_SAMPLERS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D10_MESSAGE_ID_GSSETCONSTANTBUFFERS_INVALIDBUFFER",
    "D3D10_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_GSSETSAMPLERS_SAMPLERS_EMPTY",
    "D3D10_MESSAGE_ID_SOSETTARGETS_INVALIDBUFFER",
    "D3D10_MESSAGE_ID_DEVICE_SOSETTARGETS_OFFSET_UNALIGNED",
    "D3D10_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D10_MESSAGE_ID_PSSETCONSTANTBUFFERS_INVALIDBUFFER",
    "D3D10_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_PSSETSAMPLERS_SAMPLERS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_INVALIDVIEWPORT",
    "D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_INVALIDSCISSOR",
    "D3D10_MESSAGE_ID_CLEARRENDERTARGETVIEW_DENORMFLUSH",
    "D3D10_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DENORMFLUSH",
    "D3D10_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALID",
    "D3D10_MESSAGE_ID_DEVICE_IAGETVERTEXBUFFERS_BUFFERS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_VSGETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_VSGETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_VSGETSAMPLERS_SAMPLERS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_GSGETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_GSGETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_GSGETSAMPLERS_SAMPLERS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_SOGETTARGETS_BUFFERS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_PSGETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_PSGETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_PSGETSAMPLERS_SAMPLERS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_RSGETVIEWPORTS_VIEWPORTS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_RSGETSCISSORRECTS_RECTS_EMPTY",
    "D3D10_MESSAGE_ID_DEVICE_GENERATEMIPS_RESOURCE_INVALID",
    "D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSUBRESOURCE",
    "D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESUBRESOURCE",
    "D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCEBOX",
    "D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCE",
    "D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSTATE",
    "D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESTATE",
    "D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCE",
    "D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDDESTINATIONSTATE",
    "D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCESTATE",
    "D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSUBRESOURCE",
    "D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONBOX",
    "D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSTATE",
    "D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_INVALID",
    "D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_SUBRESOURCE_INVALID",
    "D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_INVALID",
    "D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_SUBRESOURCE_INVALID",
    "D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_FORMAT_INVALID",
    "D3D10_MESSAGE_ID_BUFFER_MAP_INVALIDMAPTYPE",
    "D3D10_MESSAGE_ID_BUFFER_MAP_INVALIDFLAGS",
    "D3D10_MESSAGE_ID_BUFFER_MAP_ALREADYMAPPED",
    "D3D10_MESSAGE_ID_BUFFER_MAP_DEVICEREMOVED_RETURN",
    "D3D10_MESSAGE_ID_BUFFER_UNMAP_NOTMAPPED",
    "D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDMAPTYPE",
    "D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDSUBRESOURCE",
    "D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDFLAGS",
    "D3D10_MESSAGE_ID_TEXTURE1D_MAP_ALREADYMAPPED",
    "D3D10_MESSAGE_ID_TEXTURE1D_MAP_DEVICEREMOVED_RETURN",
    "D3D10_MESSAGE_ID_TEXTURE1D_UNMAP_INVALIDSUBRESOURCE",
    "D3D10_MESSAGE_ID_TEXTURE1D_UNMAP_NOTMAPPED",
    "D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDMAPTYPE",
    "D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDSUBRESOURCE",
    "D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDFLAGS",
    "D3D10_MESSAGE_ID_TEXTURE2D_MAP_ALREADYMAPPED",
    "D3D10_MESSAGE_ID_TEXTURE2D_MAP_DEVICEREMOVED_RETURN",
    "D3D10_MESSAGE_ID_TEXTURE2D_UNMAP_INVALIDSUBRESOURCE",
    "D3D10_MESSAGE_ID_TEXTURE2D_UNMAP_NOTMAPPED",
    "D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDMAPTYPE",
    "D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDSUBRESOURCE",
    "D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDFLAGS",
    "D3D10_MESSAGE_ID_TEXTURE3D_MAP_ALREADYMAPPED",
    "D3D10_MESSAGE_ID_TEXTURE3D_MAP_DEVICEREMOVED_RETURN",
    "D3D10_MESSAGE_ID_TEXTURE3D_UNMAP_INVALIDSUBRESOURCE",
    "D3D10_MESSAGE_ID_TEXTURE3D_UNMAP_NOTMAPPED",
    "D3D10_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_DEPRECATED",
    "D3D10_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_FORMAT_DEPRECATED",
    "D3D10_MESSAGE_ID_SETEXCEPTIONMODE_UNRECOGNIZEDFLAGS",
    "D3D10_MESSAGE_ID_SETEXCEPTIONMODE_INVALIDARG_RETURN",
    "D3D10_MESSAGE_ID_SETEXCEPTIONMODE_DEVICEREMOVED_RETURN",
    "D3D10_MESSAGE_ID_REF_SIMULATING_INFINITELY_FAST_HARDWARE",
    "D3D10_MESSAGE_ID_REF_THREADING_MODE",
    "D3D10_MESSAGE_ID_REF_UMDRIVER_EXCEPTION",
    "D3D10_MESSAGE_ID_REF_KMDRIVER_EXCEPTION",
    "D3D10_MESSAGE_ID_REF_HARDWARE_EXCEPTION",
    "D3D10_MESSAGE_ID_REF_ACCESSING_INDEXABLE_TEMP_OUT_OF_RANGE",
    "D3D10_MESSAGE_ID_REF_PROBLEM_PARSING_SHADER",
    "D3D10_MESSAGE_ID_REF_OUT_OF_MEMORY",
    "D3D10_MESSAGE_ID_REF_INFO",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEXPOS_OVERFLOW",
    "D3D10_MESSAGE_ID_DEVICE_DRAWINDEXED_INDEXPOS_OVERFLOW",
    "D3D10_MESSAGE_ID_DEVICE_DRAWINSTANCED_VERTEXPOS_OVERFLOW",
    "D3D10_MESSAGE_ID_DEVICE_DRAWINSTANCED_INSTANCEPOS_OVERFLOW",
    "D3D10_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INSTANCEPOS_OVERFLOW",
    "D3D10_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INDEXPOS_OVERFLOW",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_SHADER_NOT_SET",
    "D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND",
    "D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERINDEX",
    "D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_COMPONENTTYPE",
    "D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERMASK",
    "D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SYSTEMVALUE",
    "D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_NOT_SET",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_INPUTLAYOUT_NOT_SET",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_NOT_SET",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_TOO_SMALL",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_SAMPLER_NOT_SET",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_SHADERRESOURCEVIEW_NOT_SET",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_VIEW_DIMENSION_MISMATCH",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_TOO_SMALL",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_NOT_SET",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_FORMAT_INVALID",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_TOO_SMALL",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_GS_INPUT_PRIMITIVE_MISMATCH",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_RETURN_TYPE_MISMATCH",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_POSITION_NOT_PRESENT",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_NOT_SET",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_BOUND_RESOURCE_MAPPED",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_INVALID_PRIMITIVETOPOLOGY",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_OFFSET_UNALIGNED",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_STRIDE_UNALIGNED",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_OFFSET_UNALIGNED",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_OFFSET_UNALIGNED",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_LD_UNSUPPORTED",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_UNSUPPORTED",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_C_UNSUPPORTED",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_MULTISAMPLE_UNSUPPORTED",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_SO_TARGETS_BOUND_WITHOUT_SOURCE",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_SO_STRIDE_LARGER_THAN_BUFFER",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0",
    "D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_AT_FAULT",
    "D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT",
    "D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT",
    "D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_INVALIDARG_RETURN",
    "D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_OUTOFMEMORY_RETURN",
    "D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BADINTERFACE_RETURN",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_VIEWPORT_NOT_SET",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC",
    "D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC",
    "D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_DENORMFLUSH",
    "D3D10_MESSAGE_ID_OMSETRENDERTARGETS_INVALIDVIEW",
    "D3D10_MESSAGE_ID_DEVICE_SETTEXTFILTERSIZE_INVALIDDIMENSIONS",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_SAMPLER_MISMATCH",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TYPE_MISMATCH",
    "D3D10_MESSAGE_ID_BLENDSTATE_GETDESC_LEGACY",
    "D3D10_MESSAGE_ID_SHADERRESOURCEVIEW_GETDESC_LEGACY",
    "D3D10_MESSAGE_ID_CREATEQUERY_OUTOFMEMORY_RETURN",
    "D3D10_MESSAGE_ID_CREATEPREDICATE_OUTOFMEMORY_RETURN",
    "D3D10_MESSAGE_ID_CREATECOUNTER_OUTOFRANGE_COUNTER",
    "D3D10_MESSAGE_ID_CREATECOUNTER_SIMULTANEOUS_ACTIVE_COUNTERS_EXHAUSTED",
    "D3D10_MESSAGE_ID_CREATECOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER",
    "D3D10_MESSAGE_ID_CREATECOUNTER_OUTOFMEMORY_RETURN",
    "D3D10_MESSAGE_ID_CREATECOUNTER_NONEXCLUSIVE_RETURN",
    "D3D10_MESSAGE_ID_CREATECOUNTER_NULLDESC",
    "D3D10_MESSAGE_ID_CHECKCOUNTER_OUTOFRANGE_COUNTER",
    "D3D10_MESSAGE_ID_CHECKCOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER",
    "D3D10_MESSAGE_ID_SETPREDICATION_INVALID_PREDICATE_STATE",
    "D3D10_MESSAGE_ID_QUERY_BEGIN_UNSUPPORTED",
    "D3D10_MESSAGE_ID_PREDICATE_BEGIN_DURING_PREDICATION",
    "D3D10_MESSAGE_ID_QUERY_BEGIN_DUPLICATE",
    "D3D10_MESSAGE_ID_QUERY_BEGIN_ABANDONING_PREVIOUS_RESULTS",
    "D3D10_MESSAGE_ID_PREDICATE_END_DURING_PREDICATION",
    "D3D10_MESSAGE_ID_QUERY_END_ABANDONING_PREVIOUS_RESULTS",
    "D3D10_MESSAGE_ID_QUERY_END_WITHOUT_BEGIN",
    "D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_DATASIZE",
    "D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_FLAGS",
    "D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_CALL",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_PS_OUTPUT_TYPE_MISMATCH",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_GATHER_UNSUPPORTED",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN",
    "D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_STRIDE_TOO_LARGE",
    "D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_INVALIDRANGE",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_EMPTY_LAYOUT",
    "D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_SAMPLE_COUNT_MISMATCH",
    "D3D10_MESSAGE_ID_D3D10_MESSAGES_END",
    "D3D10_MESSAGE_ID_D3D10L9_MESSAGES_START",
    "D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_STENCIL_NO_TWO_SIDED",
    "D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_DepthBiasClamp_NOT_SUPPORTED",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NO_COMPARISON_SUPPORT",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_EXCESSIVE_ANISOTROPY",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_OUT_OF_RANGE",
    "D3D10_MESSAGE_ID_VSSETSAMPLERS_NOT_SUPPORTED",
    "D3D10_MESSAGE_ID_VSSETSAMPLERS_TOO_MANY_SAMPLERS",
    "D3D10_MESSAGE_ID_PSSETSAMPLERS_TOO_MANY_SAMPLERS",
    "D3D10_MESSAGE_ID_CREATERESOURCE_NO_ARRAYS",
    "D3D10_MESSAGE_ID_CREATERESOURCE_NO_VB_AND_IB_BIND",
    "D3D10_MESSAGE_ID_CREATERESOURCE_NO_TEXTURE_1D",
    "D3D10_MESSAGE_ID_CREATERESOURCE_DIMENSION_OUT_OF_RANGE",
    "D3D10_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_SHADER_RESOURCE",
    "D3D10_MESSAGE_ID_OMSETRENDERTARGETS_TOO_MANY_RENDER_TARGETS",
    "D3D10_MESSAGE_ID_OMSETRENDERTARGETS_NO_DIFFERING_BIT_DEPTHS",
    "D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_BAD_BUFFER_INDEX",
    "D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_TOO_MANY_VIEWPORTS",
    "D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_ADJACENCY_UNSUPPORTED",
    "D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_TOO_MANY_SCISSORS",
    "D3D10_MESSAGE_ID_COPYRESOURCE_ONLY_TEXTURE_2D_WITHIN_GPU_MEMORY",
    "D3D10_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_3D_READBACK",
    "D3D10_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_ONLY_READBACK",
    "D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_UNSUPPORTED_FORMAT",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_ALPHA_TO_COVERAGE",
    "D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_DepthClipEnable_MUST_BE_TRUE",
    "D3D10_MESSAGE_ID_DRAWINDEXED_STARTINDEXLOCATION_MUST_BE_POSITIVE",
    "D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_MUST_USE_LOWEST_LOD",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_MINLOD_MUST_NOT_BE_FRACTIONAL",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_MAXLOD_MUST_BE_FLT_MAX",
    "D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_FIRSTARRAYSLICE_MUST_BE_ZERO",
    "D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_CUBES_MUST_HAVE_6_SIDES",
    "D3D10_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_RENDER_TARGET",
    "D3D10_MESSAGE_ID_CREATERESOURCE_NO_DWORD_INDEX_BUFFER",
    "D3D10_MESSAGE_ID_CREATERESOURCE_MSAA_PRECLUDES_SHADER_RESOURCE",
    "D3D10_MESSAGE_ID_CREATERESOURCE_PRESENTATION_PRECLUDES_SHADER_RESOURCE",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_BLEND_ENABLE",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_WRITE_MASKS",
    "D3D10_MESSAGE_ID_CREATERESOURCE_NO_STREAM_OUT",
    "D3D10_MESSAGE_ID_CREATERESOURCE_ONLY_VB_IB_FOR_BUFFERS",
    "D3D10_MESSAGE_ID_CREATERESOURCE_NO_AUTOGEN_FOR_VOLUMES",
    "D3D10_MESSAGE_ID_CREATERESOURCE_DXGI_FORMAT_R8G8B8A8_CANNOT_BE_SHARED",
    "D3D10_MESSAGE_ID_VSSHADERRESOURCES_NOT_SUPPORTED",
    "D3D10_MESSAGE_ID_GEOMETRY_SHADER_NOT_SUPPORTED",
    "D3D10_MESSAGE_ID_STREAM_OUT_NOT_SUPPORTED",
    "D3D10_MESSAGE_ID_TEXT_FILTER_NOT_SUPPORTED",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_SEPARATE_ALPHA_BLEND",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_MRT_BLEND",
    "D3D10_MESSAGE_ID_CREATEBLENDSTATE_OPERATION_NOT_SUPPORTED",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NO_MIRRORONCE",
    "D3D10_MESSAGE_ID_DRAWINSTANCED_NOT_SUPPORTED",
    "D3D10_MESSAGE_ID_DRAWINDEXEDINSTANCED_NOT_SUPPORTED_BELOW_9_3",
    "D3D10_MESSAGE_ID_DRAWINDEXED_POINTLIST_UNSUPPORTED",
    "D3D10_MESSAGE_ID_SETBLENDSTATE_SAMPLE_MASK_CANNOT_BE_ZERO",
    "D3D10_MESSAGE_ID_CREATERESOURCE_DIMENSION_EXCEEDS_FEATURE_LEVEL_DEFINITION",
    "D3D10_MESSAGE_ID_CREATERESOURCE_ONLY_SINGLE_MIP_LEVEL_DEPTH_STENCIL_SUPPORTED",
    "D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_NEGATIVESCISSOR",
    "D3D10_MESSAGE_ID_SLOT_ZERO_MUST_BE_D3D10_INPUT_PER_VERTEX_DATA",
    "D3D10_MESSAGE_ID_CREATERESOURCE_NON_POW_2_MIPMAP",
    "D3D10_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_NOT_SUPPORTED",
    "D3D10_MESSAGE_ID_OMSETRENDERTARGETS_NO_SRGB_MRT",
    "D3D10_MESSAGE_ID_D3D10L9_MESSAGES_END",
])

D3D10_MESSAGE = Struct("D3D10_MESSAGE", [
    (D3D10_MESSAGE_CATEGORY, "Category"),
    (D3D10_MESSAGE_SEVERITY, "Severity"),
    (D3D10_MESSAGE_ID, "ID"),
    (ConstCString, "pDescription"),
    (SIZE_T, "DescriptionByteLength"),
])

D3D10_INFO_QUEUE_FILTER_DESC = Struct("D3D10_INFO_QUEUE_FILTER_DESC", [
    (UINT, "NumCategories"),
    (Pointer(D3D10_MESSAGE_CATEGORY), "pCategoryList"),
    (UINT, "NumSeverities"),
    (Pointer(D3D10_MESSAGE_SEVERITY), "pSeverityList"),
    (UINT, "NumIDs"),
    (OpaquePointer(D3D10_MESSAGE_ID), "pIDList"), # TODO: Array
])

D3D10_INFO_QUEUE_FILTER = Struct("D3D10_INFO_QUEUE_FILTER", [
    (D3D10_INFO_QUEUE_FILTER_DESC, "AllowList"),
    (D3D10_INFO_QUEUE_FILTER_DESC, "DenyList"),
])

ID3D10InfoQueue = Interface("ID3D10InfoQueue", IUnknown)
ID3D10InfoQueue.methods += [
    StdMethod(HRESULT, "SetMessageCountLimit", [(UINT64, "MessageCountLimit")], sideeffects=False),
    StdMethod(Void, "ClearStoredMessages", [], sideeffects=False),
    StdMethod(HRESULT, "GetMessage", [(UINT64, "MessageIndex"), Out(Pointer(D3D10_MESSAGE), "pMessage"), Out(Pointer(SIZE_T), "pMessageByteLength")], sideeffects=False),
    StdMethod(UINT64, "GetNumMessagesAllowedByStorageFilter", [], sideeffects=False),
    StdMethod(UINT64, "GetNumMessagesDeniedByStorageFilter", [], sideeffects=False),
    StdMethod(UINT64, "GetNumStoredMessages", [], sideeffects=False),
    StdMethod(UINT64, "GetNumStoredMessagesAllowedByRetrievalFilter", [], sideeffects=False),
    StdMethod(UINT64, "GetNumMessagesDiscardedByMessageCountLimit", [], sideeffects=False),
    StdMethod(UINT64, "GetMessageCountLimit", [], sideeffects=False),
    StdMethod(HRESULT, "AddStorageFilterEntries", [(Pointer(D3D10_INFO_QUEUE_FILTER), "pFilter")], sideeffects=False),
    StdMethod(HRESULT, "GetStorageFilter", [Out(Pointer(D3D10_INFO_QUEUE_FILTER), "pFilter"), Out(Pointer(SIZE_T), "pFilterByteLength")], sideeffects=False),
    StdMethod(Void, "ClearStorageFilter", [], sideeffects=False),
    StdMethod(HRESULT, "PushEmptyStorageFilter", [], sideeffects=False),
    StdMethod(HRESULT, "PushCopyOfStorageFilter", [], sideeffects=False),
    StdMethod(HRESULT, "PushStorageFilter", [(Pointer(D3D10_INFO_QUEUE_FILTER), "pFilter")], sideeffects=False),
    StdMethod(Void, "PopStorageFilter", [], sideeffects=False),
    StdMethod(UINT, "GetStorageFilterStackSize", [], sideeffects=False),
    StdMethod(HRESULT, "AddRetrievalFilterEntries", [(Pointer(D3D10_INFO_QUEUE_FILTER), "pFilter")], sideeffects=False),
    StdMethod(HRESULT, "GetRetrievalFilter", [Out(Pointer(D3D10_INFO_QUEUE_FILTER), "pFilter"), Out(Pointer(SIZE_T), "pFilterByteLength")], sideeffects=False),
    StdMethod(Void, "ClearRetrievalFilter", [], sideeffects=False),
    StdMethod(HRESULT, "PushEmptyRetrievalFilter", [], sideeffects=False),
    StdMethod(HRESULT, "PushCopyOfRetrievalFilter", [], sideeffects=False),
    StdMethod(HRESULT, "PushRetrievalFilter", [(Pointer(D3D10_INFO_QUEUE_FILTER), "pFilter")], sideeffects=False),
    StdMethod(Void, "PopRetrievalFilter", [], sideeffects=False),
    StdMethod(UINT, "GetRetrievalFilterStackSize", [], sideeffects=False),
    StdMethod(HRESULT, "AddMessage", [(D3D10_MESSAGE_CATEGORY, "Category"), (D3D10_MESSAGE_SEVERITY, "Severity"), (D3D10_MESSAGE_ID, "ID"), (LPCSTR, "pDescription")], sideeffects=False),
    StdMethod(HRESULT, "AddApplicationMessage", [(D3D10_MESSAGE_SEVERITY, "Severity"), (LPCSTR, "pDescription")], sideeffects=False),
    StdMethod(HRESULT, "SetBreakOnCategory", [(D3D10_MESSAGE_CATEGORY, "Category"), (BOOL, "bEnable")], sideeffects=False),
    StdMethod(HRESULT, "SetBreakOnSeverity", [(D3D10_MESSAGE_SEVERITY, "Severity"), (BOOL, "bEnable")], sideeffects=False),
    StdMethod(HRESULT, "SetBreakOnID", [(D3D10_MESSAGE_ID, "ID"), (BOOL, "bEnable")], sideeffects=False),
    StdMethod(BOOL, "GetBreakOnCategory", [(D3D10_MESSAGE_CATEGORY, "Category")], sideeffects=False),
    StdMethod(BOOL, "GetBreakOnSeverity", [(D3D10_MESSAGE_SEVERITY, "Severity")], sideeffects=False),
    StdMethod(BOOL, "GetBreakOnID", [(D3D10_MESSAGE_ID, "ID")], sideeffects=False),
    StdMethod(Void, "SetMuteDebugOutput", [(BOOL, "bMute")], sideeffects=False),
    StdMethod(BOOL, "GetMuteDebugOutput", [], sideeffects=False),
]


########NEW FILE########
__FILENAME__ = d3d10_1
##########################################################################
#
# Copyright 2008-2012 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""d3d10_1.h"""

from winapi import *
from d3d10 import *

D3D10_DRIVER_TYPE = Enum("D3D10_DRIVER_TYPE", [
    "D3D10_DRIVER_TYPE_HARDWARE",
    "D3D10_DRIVER_TYPE_REFERENCE",
    "D3D10_DRIVER_TYPE_NULL",
    "D3D10_DRIVER_TYPE_SOFTWARE",
    "D3D10_DRIVER_TYPE_WARP",
])

D3D10_FEATURE_LEVEL1 = Enum("D3D10_FEATURE_LEVEL1", [
    "D3D10_FEATURE_LEVEL_10_0",
    "D3D10_FEATURE_LEVEL_10_1",
	"D3D10_FEATURE_LEVEL_9_1",
	"D3D10_FEATURE_LEVEL_9_2",
	"D3D10_FEATURE_LEVEL_9_3",
])

D3D10_RENDER_TARGET_BLEND_DESC1 = Struct("D3D10_RENDER_TARGET_BLEND_DESC1", [
    (BOOL, "BlendEnable"),
    (D3D10_BLEND, "SrcBlend"),
    (D3D10_BLEND, "DestBlend"),
    (D3D10_BLEND_OP, "BlendOp"),
    (D3D10_BLEND, "SrcBlendAlpha"),
    (D3D10_BLEND, "DestBlendAlpha"),
    (D3D10_BLEND_OP, "BlendOpAlpha"),
    (UINT8, "RenderTargetWriteMask"),
])

D3D10_BLEND_DESC1 = Struct("D3D10_BLEND_DESC1", [
    (BOOL, "AlphaToCoverageEnable"),
    (BOOL, "IndependentBlendEnable"),
    (Array(D3D10_RENDER_TARGET_BLEND_DESC1, "D3D10_SIMULTANEOUS_RENDER_TARGET_COUNT"), "RenderTarget"),
])

ID3D10BlendState1 = Interface("ID3D10BlendState1", ID3D10BlendState)
ID3D10BlendState1.methods += [
    StdMethod(Void, "GetDesc1", [Out(Pointer(D3D10_BLEND_DESC1), "pDesc")], sideeffects=False),
]

D3D10_TEXCUBE_ARRAY_SRV1 = Struct("D3D10_TEXCUBE_ARRAY_SRV1", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
    (UINT, "First2DArrayFace"),
    (UINT, "NumCubes"),
])

D3D10_SHADER_RESOURCE_VIEW_DESC1 = Struct("D3D10_SHADER_RESOURCE_VIEW_DESC1", [
    (DXGI_FORMAT, "Format"),
    (D3D10_SRV_DIMENSION1, "ViewDimension"),
    (Union("{self}.ViewDimension", [
        ("D3D10_1_SRV_DIMENSION_BUFFER", D3D10_BUFFER_SRV, "Buffer"),
        ("D3D10_1_SRV_DIMENSION_TEXTURE1D", D3D10_TEX1D_SRV, "Texture1D"),
        ("D3D10_1_SRV_DIMENSION_TEXTURE1DARRAY", D3D10_TEX1D_ARRAY_SRV, "Texture1DArray"),
        ("D3D10_1_SRV_DIMENSION_TEXTURE2D", D3D10_TEX2D_SRV, "Texture2D"), 
        ("D3D10_1_SRV_DIMENSION_TEXTURE2DARRAY", D3D10_TEX2D_ARRAY_SRV, "Texture2DArray"),
        ("D3D10_1_SRV_DIMENSION_TEXTURE2DMS", D3D10_TEX2DMS_SRV, "Texture2DMS"),
        ("D3D10_1_SRV_DIMENSION_TEXTURE2DMSARRAY", D3D10_TEX2DMS_ARRAY_SRV, "Texture2DMSArray"),
        ("D3D10_1_SRV_DIMENSION_TEXTURE3D", D3D10_TEX3D_SRV, "Texture3D"),
        ("D3D10_1_SRV_DIMENSION_TEXTURECUBE", D3D10_TEXCUBE_SRV, "TextureCube"),
        ("D3D10_1_SRV_DIMENSION_TEXTURECUBEARRAY", D3D10_TEXCUBE_ARRAY_SRV1, "TextureCubeArray"),
    ]), None),
])

ID3D10ShaderResourceView1 = Interface("ID3D10ShaderResourceView1", ID3D10ShaderResourceView)
ID3D10ShaderResourceView1.methods += [
    StdMethod(Void, "GetDesc1", [Out(Pointer(D3D10_SHADER_RESOURCE_VIEW_DESC1), "pDesc")], sideeffects=False),
]

ID3D10Device1 = Interface("ID3D10Device1", ID3D10Device)
ID3D10Device1.methods += [
    StdMethod(HRESULT, "CreateShaderResourceView1", [(ObjPointer(ID3D10Resource), "pResource"), (Pointer(Const(D3D10_SHADER_RESOURCE_VIEW_DESC1)), "pDesc"), Out(Pointer(ObjPointer(ID3D10ShaderResourceView1)), "ppSRView")]),
    StdMethod(HRESULT, "CreateBlendState1", [(Pointer(Const(D3D10_BLEND_DESC1)), "pBlendStateDesc"), Out(Pointer(ObjPointer(ID3D10BlendState1)), "ppBlendState")]),
    StdMethod(D3D10_FEATURE_LEVEL1, "GetFeatureLevel", [], sideeffects=False),
]

d3d10_1 = Module("d3d10_1")
d3d10_1.addFunctions([
    StdFunction(HRESULT, "D3D10CreateDevice1", [(ObjPointer(IDXGIAdapter), "pAdapter"), (D3D10_DRIVER_TYPE, "DriverType"), (HMODULE, "Software"), (D3D10_CREATE_DEVICE_FLAG, "Flags"), (D3D10_FEATURE_LEVEL1, "HardwareLevel"), (UINT, "SDKVersion"), Out(Pointer(ObjPointer(ID3D10Device1)), "ppDevice")]),
    StdFunction(HRESULT, "D3D10CreateDeviceAndSwapChain1", [(ObjPointer(IDXGIAdapter), "pAdapter"), (D3D10_DRIVER_TYPE, "DriverType"), (HMODULE, "Software"), (D3D10_CREATE_DEVICE_FLAG, "Flags"), (D3D10_FEATURE_LEVEL1, "HardwareLevel"), (UINT, "SDKVersion"), (Pointer(DXGI_SWAP_CHAIN_DESC), "pSwapChainDesc"), Out(Pointer(ObjPointer(IDXGISwapChain)), "ppSwapChain"), Out(Pointer(ObjPointer(ID3D10Device1)), "ppDevice")]),
])

d3d10_1.addInterfaces([
    IDXGIAdapter1,
    IDXGIDevice1,
    IDXGIResource,
    ID3D10Debug,
    ID3D10InfoQueue,
    ID3D10Multithread,
    ID3D10SwitchToRef,
])

########NEW FILE########
__FILENAME__ = d3d11
##########################################################################
#
# Copyright 2012 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from dxgi import *
from d3dcommon import *
from d3d11sdklayers import *


HRESULT = MAKE_HRESULT([
    "D3D11_ERROR_FILE_NOT_FOUND",
    "D3D11_ERROR_TOO_MANY_UNIQUE_STATE_OBJECTS",
    "D3D11_ERROR_TOO_MANY_UNIQUE_VIEW_OBJECTS",
    "D3D11_ERROR_DEFERRED_CONTEXT_MAP_WITHOUT_INITIAL_DISCARD",
    "D3DERR_INVALIDCALL",
    "D3DERR_WASSTILLDRAWING",
])


ID3D11DepthStencilState = Interface("ID3D11DepthStencilState", ID3D11DeviceChild)
ID3D11BlendState = Interface("ID3D11BlendState", ID3D11DeviceChild)
ID3D11RasterizerState = Interface("ID3D11RasterizerState", ID3D11DeviceChild)
ID3D11Resource = Interface("ID3D11Resource", ID3D11DeviceChild)
ID3D11Buffer = Interface("ID3D11Buffer", ID3D11Resource)
ID3D11Texture1D = Interface("ID3D11Texture1D", ID3D11Resource)
ID3D11Texture2D = Interface("ID3D11Texture2D", ID3D11Resource)
ID3D11Texture3D = Interface("ID3D11Texture3D", ID3D11Resource)
ID3D11View = Interface("ID3D11View", ID3D11DeviceChild)
ID3D11ShaderResourceView = Interface("ID3D11ShaderResourceView", ID3D11View)
ID3D11RenderTargetView = Interface("ID3D11RenderTargetView", ID3D11View)
ID3D11DepthStencilView = Interface("ID3D11DepthStencilView", ID3D11View)
ID3D11UnorderedAccessView = Interface("ID3D11UnorderedAccessView", ID3D11View)
ID3D11VertexShader = Interface("ID3D11VertexShader", ID3D11DeviceChild)
ID3D11HullShader = Interface("ID3D11HullShader", ID3D11DeviceChild)
ID3D11DomainShader = Interface("ID3D11DomainShader", ID3D11DeviceChild)
ID3D11GeometryShader = Interface("ID3D11GeometryShader", ID3D11DeviceChild)
ID3D11PixelShader = Interface("ID3D11PixelShader", ID3D11DeviceChild)
ID3D11ComputeShader = Interface("ID3D11ComputeShader", ID3D11DeviceChild)
ID3D11InputLayout = Interface("ID3D11InputLayout", ID3D11DeviceChild)
ID3D11SamplerState = Interface("ID3D11SamplerState", ID3D11DeviceChild)
ID3D11Asynchronous = Interface("ID3D11Asynchronous", ID3D11DeviceChild)
ID3D11Query = Interface("ID3D11Query", ID3D11Asynchronous)
ID3D11Predicate = Interface("ID3D11Predicate", ID3D11Query)
ID3D11Counter = Interface("ID3D11Counter", ID3D11Asynchronous)
ID3D11ClassInstance = Interface("ID3D11ClassInstance", ID3D11DeviceChild)
ID3D11ClassLinkage = Interface("ID3D11ClassLinkage", ID3D11DeviceChild)
ID3D11CommandList = Interface("ID3D11CommandList", ID3D11DeviceChild)
ID3D11Device = Interface("ID3D11Device", IUnknown)


D3D11_INPUT_CLASSIFICATION = Enum("D3D11_INPUT_CLASSIFICATION", [
    "D3D11_INPUT_PER_VERTEX_DATA",
    "D3D11_INPUT_PER_INSTANCE_DATA",
])

D3D11_INPUT_ELEMENT_ALIGNED_BYTE_OFFSET = FakeEnum(UINT, [
    "D3D11_APPEND_ALIGNED_ELEMENT",
])

D3D11_INPUT_ELEMENT_DESC = Struct("D3D11_INPUT_ELEMENT_DESC", [
    (LPCSTR, "SemanticName"),
    (UINT, "SemanticIndex"),
    (DXGI_FORMAT, "Format"),
    (UINT, "InputSlot"),
    (D3D11_INPUT_ELEMENT_ALIGNED_BYTE_OFFSET, "AlignedByteOffset"),
    (D3D11_INPUT_CLASSIFICATION, "InputSlotClass"),
    (UINT, "InstanceDataStepRate"),
])

D3D11_FILL_MODE = Enum("D3D11_FILL_MODE", [
    "D3D11_FILL_WIREFRAME",
    "D3D11_FILL_SOLID",
])

D3D11_PRIMITIVE_TOPOLOGY = Enum("D3D11_PRIMITIVE_TOPOLOGY", [
    "D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED",
    "D3D11_PRIMITIVE_TOPOLOGY_POINTLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_LINELIST",
    "D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP",
    "D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST",
    "D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP",
    "D3D11_PRIMITIVE_TOPOLOGY_LINELIST_ADJ",
    "D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ",
    "D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ",
    "D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ",
    "D3D11_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST",
    "D3D11_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST",
])

D3D11_PRIMITIVE = Enum("D3D11_PRIMITIVE", [
    "D3D11_PRIMITIVE_UNDEFINED",
    "D3D11_PRIMITIVE_POINT",
    "D3D11_PRIMITIVE_LINE",
    "D3D11_PRIMITIVE_TRIANGLE",
    "D3D11_PRIMITIVE_LINE_ADJ",
    "D3D11_PRIMITIVE_TRIANGLE_ADJ",
    "D3D11_PRIMITIVE_1_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_2_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_3_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_4_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_5_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_6_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_7_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_8_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_9_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_10_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_11_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_12_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_13_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_14_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_15_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_16_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_17_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_18_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_19_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_20_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_21_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_22_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_23_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_24_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_25_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_26_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_27_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_28_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_29_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_30_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_31_CONTROL_POINT_PATCH",
    "D3D11_PRIMITIVE_32_CONTROL_POINT_PATCH",
])

D3D11_CULL_MODE = Enum("D3D11_CULL_MODE", [
    "D3D11_CULL_NONE",
    "D3D11_CULL_FRONT",
    "D3D11_CULL_BACK",
])

D3D11_SO_DECLARATION_ENTRY = Struct("D3D11_SO_DECLARATION_ENTRY", [
    (UINT, "Stream"),
    (LPCSTR, "SemanticName"),
    (UINT, "SemanticIndex"),
    (BYTE, "StartComponent"),
    (BYTE, "ComponentCount"),
    (BYTE, "OutputSlot"),
])

D3D11_VIEWPORT = Struct("D3D11_VIEWPORT", [
    (FLOAT, "TopLeftX"),
    (FLOAT, "TopLeftY"),
    (FLOAT, "Width"),
    (FLOAT, "Height"),
    (FLOAT, "MinDepth"),
    (FLOAT, "MaxDepth"),
])

D3D11_RESOURCE_DIMENSION = Enum("D3D11_RESOURCE_DIMENSION", [
    "D3D11_RESOURCE_DIMENSION_UNKNOWN",
    "D3D11_RESOURCE_DIMENSION_BUFFER",
    "D3D11_RESOURCE_DIMENSION_TEXTURE1D",
    "D3D11_RESOURCE_DIMENSION_TEXTURE2D",
    "D3D11_RESOURCE_DIMENSION_TEXTURE3D",
])

D3D11_SRV_DIMENSION = Enum("D3D11_SRV_DIMENSION", [
    "D3D11_SRV_DIMENSION_UNKNOWN",
    "D3D11_SRV_DIMENSION_BUFFER",
    "D3D11_SRV_DIMENSION_TEXTURE1D",
    "D3D11_SRV_DIMENSION_TEXTURE1DARRAY",
    "D3D11_SRV_DIMENSION_TEXTURE2D",
    "D3D11_SRV_DIMENSION_TEXTURE2DARRAY",
    "D3D11_SRV_DIMENSION_TEXTURE2DMS",
    "D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY",
    "D3D11_SRV_DIMENSION_TEXTURE3D",
    "D3D11_SRV_DIMENSION_TEXTURECUBE",
    "D3D11_SRV_DIMENSION_TEXTURECUBEARRAY",
    "D3D11_SRV_DIMENSION_BUFFEREX",
])

D3D11_DSV_DIMENSION = Enum("D3D11_DSV_DIMENSION", [
    "D3D11_DSV_DIMENSION_UNKNOWN",
    "D3D11_DSV_DIMENSION_TEXTURE1D",
    "D3D11_DSV_DIMENSION_TEXTURE1DARRAY",
    "D3D11_DSV_DIMENSION_TEXTURE2D",
    "D3D11_DSV_DIMENSION_TEXTURE2DARRAY",
    "D3D11_DSV_DIMENSION_TEXTURE2DMS",
    "D3D11_DSV_DIMENSION_TEXTURE2DMSARRAY",
])

D3D11_RTV_DIMENSION = Enum("D3D11_RTV_DIMENSION", [
    "D3D11_RTV_DIMENSION_UNKNOWN",
    "D3D11_RTV_DIMENSION_BUFFER",
    "D3D11_RTV_DIMENSION_TEXTURE1D",
    "D3D11_RTV_DIMENSION_TEXTURE1DARRAY",
    "D3D11_RTV_DIMENSION_TEXTURE2D",
    "D3D11_RTV_DIMENSION_TEXTURE2DARRAY",
    "D3D11_RTV_DIMENSION_TEXTURE2DMS",
    "D3D11_RTV_DIMENSION_TEXTURE2DMSARRAY",
    "D3D11_RTV_DIMENSION_TEXTURE3D",
])

D3D11_UAV_DIMENSION = Enum("D3D11_UAV_DIMENSION", [
    "D3D11_UAV_DIMENSION_UNKNOWN",
    "D3D11_UAV_DIMENSION_BUFFER",
    "D3D11_UAV_DIMENSION_TEXTURE1D",
    "D3D11_UAV_DIMENSION_TEXTURE1DARRAY",
    "D3D11_UAV_DIMENSION_TEXTURE2D",
    "D3D11_UAV_DIMENSION_TEXTURE2DARRAY",
    "D3D11_UAV_DIMENSION_TEXTURE3D",
])

D3D11_USAGE = Enum("D3D11_USAGE", [
    "D3D11_USAGE_DEFAULT",
    "D3D11_USAGE_IMMUTABLE",
    "D3D11_USAGE_DYNAMIC",
    "D3D11_USAGE_STAGING",
])

D3D11_BIND_FLAG = Flags(UINT, [
    "D3D11_BIND_VERTEX_BUFFER",
    "D3D11_BIND_INDEX_BUFFER",
    "D3D11_BIND_CONSTANT_BUFFER",
    "D3D11_BIND_SHADER_RESOURCE",
    "D3D11_BIND_STREAM_OUTPUT",
    "D3D11_BIND_RENDER_TARGET",
    "D3D11_BIND_DEPTH_STENCIL",
    "D3D11_BIND_UNORDERED_ACCESS",
])

D3D11_CPU_ACCESS_FLAG = Flags(UINT, [
    "D3D11_CPU_ACCESS_WRITE",
    "D3D11_CPU_ACCESS_READ",
])

D3D11_RESOURCE_MISC_FLAG = Flags(UINT, [
    "D3D11_RESOURCE_MISC_GENERATE_MIPS",
    "D3D11_RESOURCE_MISC_SHARED",
    "D3D11_RESOURCE_MISC_TEXTURECUBE",
    "D3D11_RESOURCE_MISC_DRAWINDIRECT_ARGS",
    "D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS",
    "D3D11_RESOURCE_MISC_BUFFER_STRUCTURED",
    "D3D11_RESOURCE_MISC_RESOURCE_CLAMP",
    "D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX",
    "D3D11_RESOURCE_MISC_GDI_COMPATIBLE",
])

D3D11_MAP = Enum("D3D11_MAP", [
    "D3D11_MAP_READ",
    "D3D11_MAP_WRITE",
    "D3D11_MAP_READ_WRITE",
    "D3D11_MAP_WRITE_DISCARD",
    "D3D11_MAP_WRITE_NO_OVERWRITE",
])

D3D11_MAP_FLAG = Flags(UINT, [
    "D3D11_MAP_FLAG_DO_NOT_WAIT",
])

D3D11_RAISE_FLAG = Flags(UINT, [
    "D3D11_RAISE_FLAG_DRIVER_INTERNAL_ERROR",
])

D3D11_CLEAR_FLAG = Flags(UINT, [
    "D3D11_CLEAR_DEPTH",
    "D3D11_CLEAR_STENCIL",
])

D3D11_RECT = Alias("D3D11_RECT", RECT)
D3D11_BOX = Struct("D3D11_BOX", [
    (UINT, "left"),
    (UINT, "top"),
    (UINT, "front"),
    (UINT, "right"),
    (UINT, "bottom"),
    (UINT, "back"),
])

ID3D11DeviceChild.methods += [
    StdMethod(Void, "GetDevice", [Out(Pointer(ObjPointer(ID3D11Device)), "ppDevice")]),
    StdMethod(HRESULT, "GetPrivateData", [(REFGUID, "guid"), Out(Pointer(UINT), "pDataSize"), Out(OpaquePointer(Void), "pData")], sideeffects=False),
    StdMethod(HRESULT, "SetPrivateData", [(REFGUID, "guid"), (UINT, "DataSize"), (OpaqueBlob(Const(Void), "DataSize"), "pData")], sideeffects=False),
    StdMethod(HRESULT, "SetPrivateDataInterface", [(REFGUID, "guid"), (OpaquePointer(Const(IUnknown)), "pData")], sideeffects=False),
]

D3D11_COMPARISON_FUNC = Enum("D3D11_COMPARISON_FUNC", [
    "D3D11_COMPARISON_NEVER",
    "D3D11_COMPARISON_LESS",
    "D3D11_COMPARISON_EQUAL",
    "D3D11_COMPARISON_LESS_EQUAL",
    "D3D11_COMPARISON_GREATER",
    "D3D11_COMPARISON_NOT_EQUAL",
    "D3D11_COMPARISON_GREATER_EQUAL",
    "D3D11_COMPARISON_ALWAYS",
])

D3D11_DEPTH_WRITE_MASK = Enum("D3D11_DEPTH_WRITE_MASK", [
    "D3D11_DEPTH_WRITE_MASK_ZERO",
    "D3D11_DEPTH_WRITE_MASK_ALL",
])

D3D11_STENCIL_OP = Enum("D3D11_STENCIL_OP", [
    "D3D11_STENCIL_OP_KEEP",
    "D3D11_STENCIL_OP_ZERO",
    "D3D11_STENCIL_OP_REPLACE",
    "D3D11_STENCIL_OP_INCR_SAT",
    "D3D11_STENCIL_OP_DECR_SAT",
    "D3D11_STENCIL_OP_INVERT",
    "D3D11_STENCIL_OP_INCR",
    "D3D11_STENCIL_OP_DECR",
])

D3D11_DEPTH_STENCILOP_DESC = Struct("D3D11_DEPTH_STENCILOP_DESC", [
    (D3D11_STENCIL_OP, "StencilFailOp"),
    (D3D11_STENCIL_OP, "StencilDepthFailOp"),
    (D3D11_STENCIL_OP, "StencilPassOp"),
    (D3D11_COMPARISON_FUNC, "StencilFunc"),
])

D3D11_DEPTH_STENCIL_DESC = Struct("D3D11_DEPTH_STENCIL_DESC", [
    (BOOL, "DepthEnable"),
    (D3D11_DEPTH_WRITE_MASK, "DepthWriteMask"),
    (D3D11_COMPARISON_FUNC, "DepthFunc"),
    (BOOL, "StencilEnable"),
    (UINT8, "StencilReadMask"),
    (UINT8, "StencilWriteMask"),
    (D3D11_DEPTH_STENCILOP_DESC, "FrontFace"),
    (D3D11_DEPTH_STENCILOP_DESC, "BackFace"),
])

ID3D11DepthStencilState.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_DEPTH_STENCIL_DESC), "pDesc")], sideeffects=False),
]

D3D11_BLEND = Enum("D3D11_BLEND", [
    "D3D11_BLEND_ZERO",
    "D3D11_BLEND_ONE",
    "D3D11_BLEND_SRC_COLOR",
    "D3D11_BLEND_INV_SRC_COLOR",
    "D3D11_BLEND_SRC_ALPHA",
    "D3D11_BLEND_INV_SRC_ALPHA",
    "D3D11_BLEND_DEST_ALPHA",
    "D3D11_BLEND_INV_DEST_ALPHA",
    "D3D11_BLEND_DEST_COLOR",
    "D3D11_BLEND_INV_DEST_COLOR",
    "D3D11_BLEND_SRC_ALPHA_SAT",
    "D3D11_BLEND_BLEND_FACTOR",
    "D3D11_BLEND_INV_BLEND_FACTOR",
    "D3D11_BLEND_SRC1_COLOR",
    "D3D11_BLEND_INV_SRC1_COLOR",
    "D3D11_BLEND_SRC1_ALPHA",
    "D3D11_BLEND_INV_SRC1_ALPHA",
])

D3D11_BLEND_OP = Enum("D3D11_BLEND_OP", [
    "D3D11_BLEND_OP_ADD",
    "D3D11_BLEND_OP_SUBTRACT",
    "D3D11_BLEND_OP_REV_SUBTRACT",
    "D3D11_BLEND_OP_MIN",
    "D3D11_BLEND_OP_MAX",
])

D3D11_COLOR_WRITE_ENABLE = Enum("D3D11_COLOR_WRITE_ENABLE", [
    "D3D11_COLOR_WRITE_ENABLE_ALL",
    "D3D11_COLOR_WRITE_ENABLE_RED",
    "D3D11_COLOR_WRITE_ENABLE_GREEN",
    "D3D11_COLOR_WRITE_ENABLE_BLUE",
    "D3D11_COLOR_WRITE_ENABLE_ALPHA",
])

D3D11_RENDER_TARGET_BLEND_DESC = Struct("D3D11_RENDER_TARGET_BLEND_DESC", [
    (BOOL, "BlendEnable"),
    (D3D11_BLEND, "SrcBlend"),
    (D3D11_BLEND, "DestBlend"),
    (D3D11_BLEND_OP, "BlendOp"),
    (D3D11_BLEND, "SrcBlendAlpha"),
    (D3D11_BLEND, "DestBlendAlpha"),
    (D3D11_BLEND_OP, "BlendOpAlpha"),
    (UINT8, "RenderTargetWriteMask"),
])

D3D11_BLEND_DESC = Struct("D3D11_BLEND_DESC", [
    (BOOL, "AlphaToCoverageEnable"),
    (BOOL, "IndependentBlendEnable"),
    (Array(D3D11_RENDER_TARGET_BLEND_DESC, 8), "RenderTarget"),
])

ID3D11BlendState.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_BLEND_DESC), "pDesc")], sideeffects=False),
]

D3D11_RASTERIZER_DESC = Struct("D3D11_RASTERIZER_DESC", [
    (D3D11_FILL_MODE, "FillMode"),
    (D3D11_CULL_MODE, "CullMode"),
    (BOOL, "FrontCounterClockwise"),
    (INT, "DepthBias"),
    (FLOAT, "DepthBiasClamp"),
    (FLOAT, "SlopeScaledDepthBias"),
    (BOOL, "DepthClipEnable"),
    (BOOL, "ScissorEnable"),
    (BOOL, "MultisampleEnable"),
    (BOOL, "AntialiasedLineEnable"),
])

ID3D11RasterizerState.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_RASTERIZER_DESC), "pDesc")], sideeffects=False),
]

D3D11_SUBRESOURCE_DATA = Struct("D3D11_SUBRESOURCE_DATA", [
    (Blob(Const(Void), "_calcSubresourceSize(pDesc, {i}, {self}.SysMemPitch, {self}.SysMemSlicePitch)"), "pSysMem"),
    (UINT, "SysMemPitch"),
    (UINT, "SysMemSlicePitch"),
])

D3D11_MAPPED_SUBRESOURCE = Struct("D3D11_MAPPED_SUBRESOURCE", [
    (LinearPointer(Void, "_MappedSize"), "pData"),
    (UINT, "RowPitch"),
    (UINT, "DepthPitch"),
])

ID3D11Resource.methods += [
    StdMethod(Void, "GetType", [Out(Pointer(D3D11_RESOURCE_DIMENSION), "pResourceDimension")], sideeffects=False),
    StdMethod(Void, "SetEvictionPriority", [(UINT, "EvictionPriority")]),
    StdMethod(UINT, "GetEvictionPriority", [], sideeffects=False),
]

D3D11_BUFFER_DESC = Struct("D3D11_BUFFER_DESC", [
    (UINT, "ByteWidth"),
    (D3D11_USAGE, "Usage"),
    (D3D11_BIND_FLAG, "BindFlags"),
    (D3D11_CPU_ACCESS_FLAG, "CPUAccessFlags"),
    (D3D11_RESOURCE_MISC_FLAG, "MiscFlags"),
    (UINT, "StructureByteStride"),
])

ID3D11Buffer.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_BUFFER_DESC), "pDesc")], sideeffects=False),
]

D3D11_TEXTURE1D_DESC = Struct("D3D11_TEXTURE1D_DESC", [
    (UINT, "Width"),
    (UINT, "MipLevels"),
    (UINT, "ArraySize"),
    (DXGI_FORMAT, "Format"),
    (D3D11_USAGE, "Usage"),
    (D3D11_BIND_FLAG, "BindFlags"),
    (D3D11_CPU_ACCESS_FLAG, "CPUAccessFlags"),
    (D3D11_RESOURCE_MISC_FLAG, "MiscFlags"),
])

ID3D11Texture1D.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_TEXTURE1D_DESC), "pDesc")], sideeffects=False),
]

D3D11_TEXTURE2D_DESC = Struct("D3D11_TEXTURE2D_DESC", [
    (UINT, "Width"),
    (UINT, "Height"),
    (UINT, "MipLevels"),
    (UINT, "ArraySize"),
    (DXGI_FORMAT, "Format"),
    (DXGI_SAMPLE_DESC, "SampleDesc"),
    (D3D11_USAGE, "Usage"),
    (D3D11_BIND_FLAG, "BindFlags"),
    (D3D11_CPU_ACCESS_FLAG, "CPUAccessFlags"),
    (D3D11_RESOURCE_MISC_FLAG, "MiscFlags"),
])

ID3D11Texture2D.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_TEXTURE2D_DESC), "pDesc")], sideeffects=False),
]

D3D11_TEXTURE3D_DESC = Struct("D3D11_TEXTURE3D_DESC", [
    (UINT, "Width"),
    (UINT, "Height"),
    (UINT, "Depth"),
    (UINT, "MipLevels"),
    (DXGI_FORMAT, "Format"),
    (D3D11_USAGE, "Usage"),
    (D3D11_BIND_FLAG, "BindFlags"),
    (D3D11_CPU_ACCESS_FLAG, "CPUAccessFlags"),
    (D3D11_RESOURCE_MISC_FLAG, "MiscFlags"),
])

ID3D11Texture3D.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_TEXTURE3D_DESC), "pDesc")], sideeffects=False),
]

D3D11_TEXTURECUBE_FACE = Enum("D3D11_TEXTURECUBE_FACE", [
    "D3D11_TEXTURECUBE_FACE_POSITIVE_X",
    "D3D11_TEXTURECUBE_FACE_NEGATIVE_X",
    "D3D11_TEXTURECUBE_FACE_POSITIVE_Y",
    "D3D11_TEXTURECUBE_FACE_NEGATIVE_Y",
    "D3D11_TEXTURECUBE_FACE_POSITIVE_Z",
    "D3D11_TEXTURECUBE_FACE_NEGATIVE_Z",
])

ID3D11View.methods += [
    StdMethod(Void, "GetResource", [Out(Pointer(ObjPointer(ID3D11Resource)), "ppResource")]),
]

D3D11_BUFFER_SRV = Struct("D3D11_BUFFER_SRV", [
    (UINT, "FirstElement"),
    (UINT, "NumElements"),
])

D3D11_BUFFEREX_SRV_FLAG = Flags(UINT, [
    "D3D11_BUFFEREX_SRV_FLAG_RAW",
])

D3D11_BUFFEREX_SRV = Struct("D3D11_BUFFEREX_SRV", [
    (UINT, "FirstElement"),
    (UINT, "NumElements"),
    (D3D11_BUFFEREX_SRV_FLAG, "Flags"),
])

D3D11_TEX1D_SRV = Struct("D3D11_TEX1D_SRV", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
])

D3D11_TEX1D_ARRAY_SRV = Struct("D3D11_TEX1D_ARRAY_SRV", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D11_TEX2D_SRV = Struct("D3D11_TEX2D_SRV", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
])

D3D11_TEX2D_ARRAY_SRV = Struct("D3D11_TEX2D_ARRAY_SRV", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D11_TEX3D_SRV = Struct("D3D11_TEX3D_SRV", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
])

D3D11_TEXCUBE_SRV = Struct("D3D11_TEXCUBE_SRV", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
])

D3D11_TEXCUBE_ARRAY_SRV = Struct("D3D11_TEXCUBE_ARRAY_SRV", [
    (UINT, "MostDetailedMip"),
    (UINT, "MipLevels"),
    (UINT, "First2DArrayFace"),
    (UINT, "NumCubes"),
])

D3D11_TEX2DMS_SRV = Struct("D3D11_TEX2DMS_SRV", [
    (UINT, "UnusedField_NothingToDefine"),
])

D3D11_TEX2DMS_ARRAY_SRV = Struct("D3D11_TEX2DMS_ARRAY_SRV", [
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D11_SHADER_RESOURCE_VIEW_DESC = Struct("D3D11_SHADER_RESOURCE_VIEW_DESC", [
    (DXGI_FORMAT, "Format"),
    (D3D11_SRV_DIMENSION, "ViewDimension"),
    (Union("{self}.ViewDimension", [
        ("D3D11_SRV_DIMENSION_BUFFER", D3D11_BUFFER_SRV, "Buffer"),
        ("D3D11_SRV_DIMENSION_TEXTURE1D", D3D11_TEX1D_SRV, "Texture1D"),
        ("D3D11_SRV_DIMENSION_TEXTURE1DARRAY", D3D11_TEX1D_ARRAY_SRV, "Texture1DArray"),
        ("D3D11_SRV_DIMENSION_TEXTURE2D", D3D11_TEX2D_SRV, "Texture2D"), 
        ("D3D11_SRV_DIMENSION_TEXTURE2DARRAY", D3D11_TEX2D_ARRAY_SRV, "Texture2DArray"),
        ("D3D11_SRV_DIMENSION_TEXTURE2DMS", D3D11_TEX2DMS_SRV, "Texture2DMS"),
        ("D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY", D3D11_TEX2DMS_ARRAY_SRV, "Texture2DMSArray"),
        ("D3D11_SRV_DIMENSION_TEXTURE3D", D3D11_TEX3D_SRV, "Texture3D"),
        ("D3D11_SRV_DIMENSION_TEXTURECUBE", D3D11_TEXCUBE_SRV, "TextureCube"),
        ("D3D11_SRV_DIMENSION_TEXTURECUBEARRAY", D3D11_TEXCUBE_ARRAY_SRV, "TextureCubeArray"),
        ("D3D11_SRV_DIMENSION_BUFFEREX", D3D11_BUFFEREX_SRV, "BufferEx"),
    ]), None),
])

ID3D11ShaderResourceView.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_SHADER_RESOURCE_VIEW_DESC), "pDesc")], sideeffects=False),
]

D3D11_BUFFER_RTV = Struct("D3D11_BUFFER_RTV", [
    (UINT, "FirstElement"),
    (UINT, "NumElements"),
])

D3D11_TEX1D_RTV = Struct("D3D11_TEX1D_RTV", [
    (UINT, "MipSlice"),
])

D3D11_TEX1D_ARRAY_RTV = Struct("D3D11_TEX1D_ARRAY_RTV", [
    (UINT, "MipSlice"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D11_TEX2D_RTV = Struct("D3D11_TEX2D_RTV", [
    (UINT, "MipSlice"),
])

D3D11_TEX2DMS_RTV = Struct("D3D11_TEX2DMS_RTV", [
    (UINT, "UnusedField_NothingToDefine"),
])

D3D11_TEX2D_ARRAY_RTV = Struct("D3D11_TEX2D_ARRAY_RTV", [
    (UINT, "MipSlice"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D11_TEX2DMS_ARRAY_RTV = Struct("D3D11_TEX2DMS_ARRAY_RTV", [
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D11_TEX3D_RTV = Struct("D3D11_TEX3D_RTV", [
    (UINT, "MipSlice"),
    (UINT, "FirstWSlice"),
    (UINT, "WSize"),
])

D3D11_RENDER_TARGET_VIEW_DESC = Struct("D3D11_RENDER_TARGET_VIEW_DESC", [
    (DXGI_FORMAT, "Format"),
    (D3D11_RTV_DIMENSION, "ViewDimension"),
    (Union("{self}.ViewDimension", [
        ("D3D11_RTV_DIMENSION_BUFFER", D3D11_BUFFER_RTV, "Buffer"),
        ("D3D11_RTV_DIMENSION_TEXTURE1D", D3D11_TEX1D_RTV, "Texture1D"),
        ("D3D11_RTV_DIMENSION_TEXTURE1DARRAY", D3D11_TEX1D_ARRAY_RTV, "Texture1DArray"),
        ("D3D11_RTV_DIMENSION_TEXTURE2D", D3D11_TEX2D_RTV, "Texture2D"),
        ("D3D11_RTV_DIMENSION_TEXTURE2DARRAY", D3D11_TEX2D_ARRAY_RTV, "Texture2DArray"),
        ("D3D11_RTV_DIMENSION_TEXTURE2DMS", D3D11_TEX2DMS_RTV, "Texture2DMS"),
        ("D3D11_RTV_DIMENSION_TEXTURE2DMSARRAY", D3D11_TEX2DMS_ARRAY_RTV, "Texture2DMSArray"),
        ("D3D11_RTV_DIMENSION_TEXTURE3D", D3D11_TEX3D_RTV, "Texture3D"),
    ]), None),
])

ID3D11RenderTargetView.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_RENDER_TARGET_VIEW_DESC), "pDesc")], sideeffects=False),
]

D3D11_TEX1D_DSV = Struct("D3D11_TEX1D_DSV", [
    (UINT, "MipSlice"),
])

D3D11_TEX1D_ARRAY_DSV = Struct("D3D11_TEX1D_ARRAY_DSV", [
    (UINT, "MipSlice"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D11_TEX2D_DSV = Struct("D3D11_TEX2D_DSV", [
    (UINT, "MipSlice"),
])

D3D11_TEX2D_ARRAY_DSV = Struct("D3D11_TEX2D_ARRAY_DSV", [
    (UINT, "MipSlice"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D11_TEX2DMS_DSV = Struct("D3D11_TEX2DMS_DSV", [
    (UINT, "UnusedField_NothingToDefine"),
])

D3D11_TEX2DMS_ARRAY_DSV = Struct("D3D11_TEX2DMS_ARRAY_DSV", [
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D11_DSV_FLAG = Flags(UINT, [
    "D3D11_DSV_READ_ONLY_DEPTH",
    "D3D11_DSV_READ_ONLY_STENCIL",
])

D3D11_DEPTH_STENCIL_VIEW_DESC = Struct("D3D11_DEPTH_STENCIL_VIEW_DESC", [
    (DXGI_FORMAT, "Format"),
    (D3D11_DSV_DIMENSION, "ViewDimension"),
    (D3D11_DSV_FLAG, "Flags"),
    (Union("{self}.ViewDimension", [
        ("D3D11_DSV_DIMENSION_TEXTURE1D", D3D11_TEX1D_DSV, "Texture1D"),
        ("D3D11_DSV_DIMENSION_TEXTURE1DARRAY", D3D11_TEX1D_ARRAY_DSV, "Texture1DArray"),
        ("D3D11_DSV_DIMENSION_TEXTURE2D", D3D11_TEX2D_DSV, "Texture2D"),
        ("D3D11_DSV_DIMENSION_TEXTURE2DARRAY", D3D11_TEX2D_ARRAY_DSV, "Texture2DArray"),
        ("D3D11_DSV_DIMENSION_TEXTURE2DMS", D3D11_TEX2DMS_DSV, "Texture2DMS"),
        ("D3D11_DSV_DIMENSION_TEXTURE2DMSARRAY", D3D11_TEX2DMS_ARRAY_DSV, "Texture2DMSArray"),
    ]), None),
])

ID3D11DepthStencilView.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_DEPTH_STENCIL_VIEW_DESC), "pDesc")], sideeffects=False),
]

D3D11_BUFFER_UAV_FLAG = Flags(UINT, [
    "D3D11_BUFFER_UAV_FLAG_RAW",
    "D3D11_BUFFER_UAV_FLAG_APPEND",
    "D3D11_BUFFER_UAV_FLAG_COUNTER",
])

D3D11_BUFFER_UAV = Struct("D3D11_BUFFER_UAV", [
    (UINT, "FirstElement"),
    (UINT, "NumElements"),
    (D3D11_BUFFER_UAV_FLAG, "Flags"),
])

D3D11_TEX1D_UAV = Struct("D3D11_TEX1D_UAV", [
    (UINT, "MipSlice"),
])

D3D11_TEX1D_ARRAY_UAV = Struct("D3D11_TEX1D_ARRAY_UAV", [
    (UINT, "MipSlice"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D11_TEX2D_UAV = Struct("D3D11_TEX2D_UAV", [
    (UINT, "MipSlice"),
])

D3D11_TEX2D_ARRAY_UAV = Struct("D3D11_TEX2D_ARRAY_UAV", [
    (UINT, "MipSlice"),
    (UINT, "FirstArraySlice"),
    (UINT, "ArraySize"),
])

D3D11_TEX3D_UAV = Struct("D3D11_TEX3D_UAV", [
    (UINT, "MipSlice"),
    (UINT, "FirstWSlice"),
    (UINT, "WSize"),
])

D3D11_UNORDERED_ACCESS_VIEW_DESC = Struct("D3D11_UNORDERED_ACCESS_VIEW_DESC", [
    (DXGI_FORMAT, "Format"),
    (D3D11_UAV_DIMENSION, "ViewDimension"),
    (Union("{self}.ViewDimension", [
        ("D3D11_UAV_DIMENSION_BUFFER", D3D11_BUFFER_UAV, "Buffer"),
        ("D3D11_UAV_DIMENSION_TEXTURE1D", D3D11_TEX1D_UAV, "Texture1D"),
        ("D3D11_UAV_DIMENSION_TEXTURE1DARRAY", D3D11_TEX1D_ARRAY_UAV, "Texture1DArray"),
        ("D3D11_UAV_DIMENSION_TEXTURE2D", D3D11_TEX2D_UAV, "Texture2D"),
        ("D3D11_UAV_DIMENSION_TEXTURE2DARRAY", D3D11_TEX2D_ARRAY_UAV, "Texture2DArray"),
        ("D3D11_UAV_DIMENSION_TEXTURE3D", D3D11_TEX3D_UAV, "Texture3D"),
    ]), None),
])

ID3D11UnorderedAccessView.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_UNORDERED_ACCESS_VIEW_DESC), "pDesc")], sideeffects=False),
]

D3D11_FILTER = Enum("D3D11_FILTER", [
    "D3D11_FILTER_MIN_MAG_MIP_POINT",
    "D3D11_FILTER_MIN_MAG_POINT_MIP_LINEAR",
    "D3D11_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT",
    "D3D11_FILTER_MIN_POINT_MAG_MIP_LINEAR",
    "D3D11_FILTER_MIN_LINEAR_MAG_MIP_POINT",
    "D3D11_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR",
    "D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT",
    "D3D11_FILTER_MIN_MAG_MIP_LINEAR",
    "D3D11_FILTER_ANISOTROPIC",
    "D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT",
    "D3D11_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR",
    "D3D11_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT",
    "D3D11_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR",
    "D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT",
    "D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR",
    "D3D11_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT",
    "D3D11_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR",
    "D3D11_FILTER_COMPARISON_ANISOTROPIC",
])

D3D11_FILTER_TYPE = Enum("D3D11_FILTER_TYPE", [
    "D3D11_FILTER_TYPE_POINT",
    "D3D11_FILTER_TYPE_LINEAR",
])

D3D11_TEXTURE_ADDRESS_MODE = Enum("D3D11_TEXTURE_ADDRESS_MODE", [
    "D3D11_TEXTURE_ADDRESS_WRAP",
    "D3D11_TEXTURE_ADDRESS_MIRROR",
    "D3D11_TEXTURE_ADDRESS_CLAMP",
    "D3D11_TEXTURE_ADDRESS_BORDER",
    "D3D11_TEXTURE_ADDRESS_MIRROR_ONCE",
])

D3D11_SAMPLER_DESC = Struct("D3D11_SAMPLER_DESC", [
    (D3D11_FILTER, "Filter"),
    (D3D11_TEXTURE_ADDRESS_MODE, "AddressU"),
    (D3D11_TEXTURE_ADDRESS_MODE, "AddressV"),
    (D3D11_TEXTURE_ADDRESS_MODE, "AddressW"),
    (FLOAT, "MipLODBias"),
    (UINT, "MaxAnisotropy"),
    (D3D11_COMPARISON_FUNC, "ComparisonFunc"),
    (Array(FLOAT, 4), "BorderColor"),
    (FLOAT, "MinLOD"),
    (FLOAT, "MaxLOD"),
])

ID3D11SamplerState.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_SAMPLER_DESC), "pDesc")], sideeffects=False),
]

D3D11_FORMAT_SUPPORT = Flags(UINT, [
    "D3D11_FORMAT_SUPPORT_BUFFER",
    "D3D11_FORMAT_SUPPORT_IA_VERTEX_BUFFER",
    "D3D11_FORMAT_SUPPORT_IA_INDEX_BUFFER",
    "D3D11_FORMAT_SUPPORT_SO_BUFFER",
    "D3D11_FORMAT_SUPPORT_TEXTURE1D",
    "D3D11_FORMAT_SUPPORT_TEXTURE2D",
    "D3D11_FORMAT_SUPPORT_TEXTURE3D",
    "D3D11_FORMAT_SUPPORT_TEXTURECUBE",
    "D3D11_FORMAT_SUPPORT_SHADER_LOAD",
    "D3D11_FORMAT_SUPPORT_SHADER_SAMPLE",
    "D3D11_FORMAT_SUPPORT_SHADER_SAMPLE_COMPARISON",
    "D3D11_FORMAT_SUPPORT_SHADER_SAMPLE_MONO_TEXT",
    "D3D11_FORMAT_SUPPORT_MIP",
    "D3D11_FORMAT_SUPPORT_MIP_AUTOGEN",
    "D3D11_FORMAT_SUPPORT_RENDER_TARGET",
    "D3D11_FORMAT_SUPPORT_BLENDABLE",
    "D3D11_FORMAT_SUPPORT_DEPTH_STENCIL",
    "D3D11_FORMAT_SUPPORT_CPU_LOCKABLE",
    "D3D11_FORMAT_SUPPORT_MULTISAMPLE_RESOLVE",
    "D3D11_FORMAT_SUPPORT_DISPLAY",
    "D3D11_FORMAT_SUPPORT_CAST_WITHIN_BIT_LAYOUT",
    "D3D11_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET",
    "D3D11_FORMAT_SUPPORT_MULTISAMPLE_LOAD",
    "D3D11_FORMAT_SUPPORT_SHADER_GATHER",
    "D3D11_FORMAT_SUPPORT_BACK_BUFFER_CAST",
    "D3D11_FORMAT_SUPPORT_TYPED_UNORDERED_ACCESS_VIEW",
    "D3D11_FORMAT_SUPPORT_SHADER_GATHER_COMPARISON",
])

D3D11_FORMAT_SUPPORT2 = Enum("D3D11_FORMAT_SUPPORT2", [
    "D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_ADD",
    "D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_BITWISE_OPS",
    "D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_COMPARE_STORE_OR_COMPARE_EXCHANGE",
    "D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_EXCHANGE",
    "D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_SIGNED_MIN_OR_MAX",
    "D3D11_FORMAT_SUPPORT2_UAV_ATOMIC_UNSIGNED_MIN_OR_MAX",
    "D3D11_FORMAT_SUPPORT2_UAV_TYPED_LOAD",
    "D3D11_FORMAT_SUPPORT2_UAV_TYPED_STORE",
])

ID3D11Asynchronous.methods += [
    StdMethod(UINT, "GetDataSize", [], sideeffects=False),
]

D3D11_ASYNC_GETDATA_FLAG = Flags(UINT, [
    "D3D11_ASYNC_GETDATA_DONOTFLUSH",
])

D3D11_QUERY = Enum("D3D11_QUERY", [
    "D3D11_QUERY_EVENT",
    "D3D11_QUERY_OCCLUSION",
    "D3D11_QUERY_TIMESTAMP",
    "D3D11_QUERY_TIMESTAMP_DISJOINT",
    "D3D11_QUERY_PIPELINE_STATISTICS",
    "D3D11_QUERY_OCCLUSION_PREDICATE",
    "D3D11_QUERY_SO_STATISTICS",
    "D3D11_QUERY_SO_OVERFLOW_PREDICATE",
    "D3D11_QUERY_SO_STATISTICS_STREAM0",
    "D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM0",
    "D3D11_QUERY_SO_STATISTICS_STREAM1",
    "D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM1",
    "D3D11_QUERY_SO_STATISTICS_STREAM2",
    "D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM2",
    "D3D11_QUERY_SO_STATISTICS_STREAM3",
    "D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM3",
])

D3D11_QUERY_MISC_FLAG = Flags(UINT, [
    "D3D11_QUERY_MISC_PREDICATEHINT",
])

D3D11_QUERY_DESC = Struct("D3D11_QUERY_DESC", [
    (D3D11_QUERY, "Query"),
    (D3D11_QUERY_MISC_FLAG, "MiscFlags"),
])

ID3D11Query.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_QUERY_DESC), "pDesc")], sideeffects=False),
]

D3D11_QUERY_DATA_TIMESTAMP_DISJOINT = Struct("D3D11_QUERY_DATA_TIMESTAMP_DISJOINT", [
    (UINT64, "Frequency"),
    (BOOL, "Disjoint"),
])

D3D11_QUERY_DATA_PIPELINE_STATISTICS = Struct("D3D11_QUERY_DATA_PIPELINE_STATISTICS", [
    (UINT64, "IAVertices"),
    (UINT64, "IAPrimitives"),
    (UINT64, "VSInvocations"),
    (UINT64, "GSInvocations"),
    (UINT64, "GSPrimitives"),
    (UINT64, "CInvocations"),
    (UINT64, "CPrimitives"),
    (UINT64, "PSInvocations"),
    (UINT64, "HSInvocations"),
    (UINT64, "DSInvocations"),
    (UINT64, "CSInvocations"),
])

D3D11_QUERY_DATA_SO_STATISTICS = Struct("D3D11_QUERY_DATA_SO_STATISTICS", [
    (UINT64, "NumPrimitivesWritten"),
    (UINT64, "PrimitivesStorageNeeded"),
])

D3D11_COUNTER = Enum("D3D11_COUNTER", [
    "D3D11_COUNTER_DEVICE_DEPENDENT_0",
])

D3D11_COUNTER_TYPE = Enum("D3D11_COUNTER_TYPE", [
    "D3D11_COUNTER_TYPE_FLOAT32",
    "D3D11_COUNTER_TYPE_UINT16",
    "D3D11_COUNTER_TYPE_UINT32",
    "D3D11_COUNTER_TYPE_UINT64",
])

D3D11_COUNTER_DESC = Struct("D3D11_COUNTER_DESC", [
    (D3D11_COUNTER, "Counter"),
    (UINT, "MiscFlags"),
])

D3D11_COUNTER_INFO = Struct("D3D11_COUNTER_INFO", [
    (D3D11_COUNTER, "LastDeviceDependentCounter"),
    (UINT, "NumSimultaneousCounters"),
    (UINT8, "NumDetectableParallelUnits"),
])

ID3D11Counter.methods += [
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_COUNTER_DESC), "pDesc")], sideeffects=False),
]

D3D11_STANDARD_MULTISAMPLE_QUALITY_LEVELS = Enum("D3D11_STANDARD_MULTISAMPLE_QUALITY_LEVELS", [
    "D3D11_STANDARD_MULTISAMPLE_PATTERN",
    "D3D11_CENTER_MULTISAMPLE_PATTERN",
])

D3D11_DEVICE_CONTEXT_TYPE = Enum("D3D11_DEVICE_CONTEXT_TYPE", [
    "D3D11_DEVICE_CONTEXT_IMMEDIATE",
    "D3D11_DEVICE_CONTEXT_DEFERRED",
])

D3D11_CLASS_INSTANCE_DESC = Struct("D3D11_CLASS_INSTANCE_DESC", [
    (UINT, "InstanceId"),
    (UINT, "InstanceIndex"),
    (UINT, "TypeId"),
    (UINT, "ConstantBuffer"),
    (UINT, "BaseConstantBufferOffset"),
    (UINT, "BaseTexture"),
    (UINT, "BaseSampler"),
    (BOOL, "Created"),
])


ID3D11ClassInstance.methods += [
    StdMethod(Void, "GetClassLinkage", [Out(Pointer(ObjPointer(ID3D11ClassLinkage)), "ppLinkage")]),
    StdMethod(Void, "GetDesc", [Out(Pointer(D3D11_CLASS_INSTANCE_DESC), "pDesc")], sideeffects=False),
    StdMethod(Void, "GetInstanceName", [Out(LPSTR, "pInstanceName"), Out(Pointer(SIZE_T), "pBufferLength")], sideeffects=False),
    StdMethod(Void, "GetTypeName", [Out(LPSTR, "pTypeName"), Out(Pointer(SIZE_T), "pBufferLength")], sideeffects=False),
]

ID3D11ClassLinkage.methods += [
    StdMethod(HRESULT, "GetClassInstance", [(LPCSTR, "pClassInstanceName"), (UINT, "InstanceIndex"), Out(Pointer(ObjPointer(ID3D11ClassInstance)), "ppInstance")]),
    StdMethod(HRESULT, "CreateClassInstance", [(LPCSTR, "pClassTypeName"), (UINT, "ConstantBufferOffset"), (UINT, "ConstantVectorOffset"), (UINT, "TextureOffset"), (UINT, "SamplerOffset"), Out(Pointer(ObjPointer(ID3D11ClassInstance)), "ppInstance")]),
]

ID3D11CommandList.methods += [
    StdMethod(UINT, "GetContextFlags", [], sideeffects=False),
]

D3D11_FEATURE_DATA_THREADING = Struct("D3D11_FEATURE_DATA_THREADING", [
    (BOOL, "DriverConcurrentCreates"),
    (BOOL, "DriverCommandLists"),
])

D3D11_FEATURE_DATA_DOUBLES = Struct("D3D11_FEATURE_DATA_DOUBLES", [
    (BOOL, "DoublePrecisionFloatShaderOps"),
])

D3D11_FEATURE_DATA_FORMAT_SUPPORT = Struct("D3D11_FEATURE_DATA_FORMAT_SUPPORT", [
    (DXGI_FORMAT, "InFormat"),
    (D3D11_FORMAT_SUPPORT, "OutFormatSupport"),
])

D3D11_FEATURE_DATA_FORMAT_SUPPORT2 = Struct("D3D11_FEATURE_DATA_FORMAT_SUPPORT2", [
    (DXGI_FORMAT, "InFormat"),
    (D3D11_FORMAT_SUPPORT2, "OutFormatSupport2"),
])

D3D11_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS = Struct("D3D11_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS", [
    (BOOL, "ComputeShaders_Plus_RawAndStructuredBuffers_Via_Shader_4_x"),
])

D3D11_FEATURE, D3D11_FEATURE_DATA = EnumPolymorphic("D3D11_FEATURE", "Feature", [
    ("D3D11_FEATURE_THREADING", Pointer(D3D11_FEATURE_DATA_THREADING)),
    ("D3D11_FEATURE_DOUBLES", Pointer(D3D11_FEATURE_DATA_DOUBLES)),
    ("D3D11_FEATURE_FORMAT_SUPPORT", Pointer(D3D11_FEATURE_DATA_FORMAT_SUPPORT)),
    ("D3D11_FEATURE_FORMAT_SUPPORT2", Pointer(D3D11_FEATURE_DATA_FORMAT_SUPPORT2)),
    ("D3D11_FEATURE_D3D10_X_HARDWARE_OPTIONS", Pointer(D3D11_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS)),
], Blob(Void, "FeatureSupportDataSize"), False)

ID3D11DeviceContext.methods += [
    StdMethod(Void, "VSSetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "PSSetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), (Array(Const(ObjPointer(ID3D11ShaderResourceView)), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "PSSetShader", [(ObjPointer(ID3D11PixelShader), "pPixelShader"), (Array(Const(ObjPointer(ID3D11ClassInstance)), "NumClassInstances"), "ppClassInstances"), (UINT, "NumClassInstances")]),
    StdMethod(Void, "PSSetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), (Array(Const(ObjPointer(ID3D11SamplerState)), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "VSSetShader", [(ObjPointer(ID3D11VertexShader), "pVertexShader"), (Array(Const(ObjPointer(ID3D11ClassInstance)), "NumClassInstances"), "ppClassInstances"), (UINT, "NumClassInstances")]),
    StdMethod(Void, "DrawIndexed", [(UINT, "IndexCount"), (UINT, "StartIndexLocation"), (INT, "BaseVertexLocation")]),
    StdMethod(Void, "Draw", [(UINT, "VertexCount"), (UINT, "StartVertexLocation")]),
    StdMethod(HRESULT, "Map", [(ObjPointer(ID3D11Resource), "pResource"), (UINT, "Subresource"), (D3D11_MAP, "MapType"), (D3D11_MAP_FLAG, "MapFlags"), Out(Pointer(D3D11_MAPPED_SUBRESOURCE), "pMappedResource")]),
    StdMethod(Void, "Unmap", [(ObjPointer(ID3D11Resource), "pResource"), (UINT, "Subresource")]),
    StdMethod(Void, "PSSetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "IASetInputLayout", [(ObjPointer(ID3D11InputLayout), "pInputLayout")]),
    StdMethod(Void, "IASetVertexBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppVertexBuffers"), (Array(Const(UINT), "NumBuffers"), "pStrides"), (Array(Const(UINT), "NumBuffers"), "pOffsets")]),
    StdMethod(Void, "IASetIndexBuffer", [(ObjPointer(ID3D11Buffer), "pIndexBuffer"), (DXGI_FORMAT, "Format"), (UINT, "Offset")]),
    StdMethod(Void, "DrawIndexedInstanced", [(UINT, "IndexCountPerInstance"), (UINT, "InstanceCount"), (UINT, "StartIndexLocation"), (INT, "BaseVertexLocation"), (UINT, "StartInstanceLocation")]),
    StdMethod(Void, "DrawInstanced", [(UINT, "VertexCountPerInstance"), (UINT, "InstanceCount"), (UINT, "StartVertexLocation"), (UINT, "StartInstanceLocation")]),
    StdMethod(Void, "GSSetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "GSSetShader", [(ObjPointer(ID3D11GeometryShader), "pShader"), (Array(Const(ObjPointer(ID3D11ClassInstance)), "NumClassInstances"), "ppClassInstances"), (UINT, "NumClassInstances")]),
    StdMethod(Void, "IASetPrimitiveTopology", [(D3D11_PRIMITIVE_TOPOLOGY, "Topology")]),
    StdMethod(Void, "VSSetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), (Array(Const(ObjPointer(ID3D11ShaderResourceView)), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "VSSetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), (Array(Const(ObjPointer(ID3D11SamplerState)), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "Begin", [(ObjPointer(ID3D11Asynchronous), "pAsync")]),
    StdMethod(Void, "End", [(ObjPointer(ID3D11Asynchronous), "pAsync")]),
    StdMethod(HRESULT, "GetData", [(ObjPointer(ID3D11Asynchronous), "pAsync"), Out(OpaqueBlob(Void, "DataSize"), "pData"), (UINT, "DataSize"), (D3D11_ASYNC_GETDATA_FLAG, "GetDataFlags")], sideeffects=False),
    StdMethod(Void, "SetPredication", [(ObjPointer(ID3D11Predicate), "pPredicate"), (BOOL, "PredicateValue")]),
    StdMethod(Void, "GSSetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), (Array(Const(ObjPointer(ID3D11ShaderResourceView)), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "GSSetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), (Array(Const(ObjPointer(ID3D11SamplerState)), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "OMSetRenderTargets", [(UINT, "NumViews"), (Array(Const(ObjPointer(ID3D11RenderTargetView)), "NumViews"), "ppRenderTargetViews"), (ObjPointer(ID3D11DepthStencilView), "pDepthStencilView")]),
    StdMethod(Void, "OMSetRenderTargetsAndUnorderedAccessViews", [(UINT, "NumRTVs"), (Array(Const(ObjPointer(ID3D11RenderTargetView)), "NumRTVs"), "ppRenderTargetViews"), (ObjPointer(ID3D11DepthStencilView), "pDepthStencilView"), (UINT, "UAVStartSlot"), (UINT, "NumUAVs"), (Array(Const(ObjPointer(ID3D11UnorderedAccessView)), "NumUAVs"), "ppUnorderedAccessViews"), (Array(Const(UINT), "NumUAVs"), "pUAVInitialCounts")]),
    StdMethod(Void, "OMSetBlendState", [(ObjPointer(ID3D11BlendState), "pBlendState"), (Array(Const(FLOAT), 4), "BlendFactor"), (UINT, "SampleMask")]),
    StdMethod(Void, "OMSetDepthStencilState", [(ObjPointer(ID3D11DepthStencilState), "pDepthStencilState"), (UINT, "StencilRef")]),
    StdMethod(Void, "SOSetTargets", [(UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppSOTargets"), (Array(Const(UINT), "NumBuffers"), "pOffsets")]),
    StdMethod(Void, "DrawAuto", []),
    StdMethod(Void, "DrawIndexedInstancedIndirect", [(ObjPointer(ID3D11Buffer), "pBufferForArgs"), (UINT, "AlignedByteOffsetForArgs")]),
    StdMethod(Void, "DrawInstancedIndirect", [(ObjPointer(ID3D11Buffer), "pBufferForArgs"), (UINT, "AlignedByteOffsetForArgs")]),
    StdMethod(Void, "Dispatch", [(UINT, "ThreadGroupCountX"), (UINT, "ThreadGroupCountY"), (UINT, "ThreadGroupCountZ")]),
    StdMethod(Void, "DispatchIndirect", [(ObjPointer(ID3D11Buffer), "pBufferForArgs"), (UINT, "AlignedByteOffsetForArgs")]),
    StdMethod(Void, "RSSetState", [(ObjPointer(ID3D11RasterizerState), "pRasterizerState")]),
    StdMethod(Void, "RSSetViewports", [(UINT, "NumViewports"), (Array(Const(D3D11_VIEWPORT), "NumViewports"), "pViewports")]),
    StdMethod(Void, "RSSetScissorRects", [(UINT, "NumRects"), (Array(Const(D3D11_RECT), "NumRects"), "pRects")]),
    StdMethod(Void, "CopySubresourceRegion", [(ObjPointer(ID3D11Resource), "pDstResource"), (UINT, "DstSubresource"), (UINT, "DstX"), (UINT, "DstY"), (UINT, "DstZ"), (ObjPointer(ID3D11Resource), "pSrcResource"), (UINT, "SrcSubresource"), (Pointer(Const(D3D11_BOX)), "pSrcBox")]),
    StdMethod(Void, "CopyResource", [(ObjPointer(ID3D11Resource), "pDstResource"), (ObjPointer(ID3D11Resource), "pSrcResource")]),
    StdMethod(Void, "UpdateSubresource", [(ObjPointer(ID3D11Resource), "pDstResource"), (UINT, "DstSubresource"), (Pointer(Const(D3D11_BOX)), "pDstBox"), (Blob(Const(Void), "_calcSubresourceSize(pDstResource, DstSubresource, pDstBox, SrcRowPitch, SrcDepthPitch)"), "pSrcData"), (UINT, "SrcRowPitch"), (UINT, "SrcDepthPitch")]),
    StdMethod(Void, "CopyStructureCount", [(ObjPointer(ID3D11Buffer), "pDstBuffer"), (UINT, "DstAlignedByteOffset"), (ObjPointer(ID3D11UnorderedAccessView), "pSrcView")]),
    StdMethod(Void, "ClearRenderTargetView", [(ObjPointer(ID3D11RenderTargetView), "pRenderTargetView"), (Array(Const(FLOAT), 4), "ColorRGBA")]),
    StdMethod(Void, "ClearUnorderedAccessViewUint", [(ObjPointer(ID3D11UnorderedAccessView), "pUnorderedAccessView"), (Array(Const(UINT), 4), "Values")]),
    StdMethod(Void, "ClearUnorderedAccessViewFloat", [(ObjPointer(ID3D11UnorderedAccessView), "pUnorderedAccessView"), (Array(Const(FLOAT), 4), "Values")]),
    StdMethod(Void, "ClearDepthStencilView", [(ObjPointer(ID3D11DepthStencilView), "pDepthStencilView"), (D3D11_CLEAR_FLAG, "ClearFlags"), (FLOAT, "Depth"), (UINT8, "Stencil")]),
    StdMethod(Void, "GenerateMips", [(ObjPointer(ID3D11ShaderResourceView), "pShaderResourceView")]),
    StdMethod(Void, "SetResourceMinLOD", [(ObjPointer(ID3D11Resource), "pResource"), (FLOAT, "MinLOD")]),
    StdMethod(FLOAT, "GetResourceMinLOD", [(ObjPointer(ID3D11Resource), "pResource")], sideeffects=False),
    StdMethod(Void, "ResolveSubresource", [(ObjPointer(ID3D11Resource), "pDstResource"), (UINT, "DstSubresource"), (ObjPointer(ID3D11Resource), "pSrcResource"), (UINT, "SrcSubresource"), (DXGI_FORMAT, "Format")]),
    StdMethod(Void, "ExecuteCommandList", [(ObjPointer(ID3D11CommandList), "pCommandList"), (BOOL, "RestoreContextState")]),
    StdMethod(Void, "HSSetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), (Array(Const(ObjPointer(ID3D11ShaderResourceView)), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "HSSetShader", [(ObjPointer(ID3D11HullShader), "pHullShader"), (Array(Const(ObjPointer(ID3D11ClassInstance)), "NumClassInstances"), "ppClassInstances"), (UINT, "NumClassInstances")]),
    StdMethod(Void, "HSSetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), (Array(Const(ObjPointer(ID3D11SamplerState)), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "HSSetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "DSSetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), (Array(Const(ObjPointer(ID3D11ShaderResourceView)), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "DSSetShader", [(ObjPointer(ID3D11DomainShader), "pDomainShader"), (Array(Const(ObjPointer(ID3D11ClassInstance)), "NumClassInstances"), "ppClassInstances"), (UINT, "NumClassInstances")]),
    StdMethod(Void, "DSSetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), (Array(Const(ObjPointer(ID3D11SamplerState)), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "DSSetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "CSSetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), (Array(Const(ObjPointer(ID3D11ShaderResourceView)), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "CSSetUnorderedAccessViews", [(UINT, "StartSlot"), (UINT, "NumUAVs"), (Array(Const(ObjPointer(ID3D11UnorderedAccessView)), "NumUAVs"), "ppUnorderedAccessViews"), (Array(Const(UINT), "NumUAVs"), "pUAVInitialCounts")]),
    StdMethod(Void, "CSSetShader", [(ObjPointer(ID3D11ComputeShader), "pComputeShader"), (Array(Const(ObjPointer(ID3D11ClassInstance)), "NumClassInstances"), "ppClassInstances"), (UINT, "NumClassInstances")]),
    StdMethod(Void, "CSSetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), (Array(Const(ObjPointer(ID3D11SamplerState)), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "CSSetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "VSGetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "PSGetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), Out(Array(ObjPointer(ID3D11ShaderResourceView), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "PSGetShader", [Out(Pointer(ObjPointer(ID3D11PixelShader)), "ppPixelShader"), Out(Array(ObjPointer(ID3D11ClassInstance), "*pNumClassInstances"), "ppClassInstances"), Out(Pointer(UINT), "pNumClassInstances")]),
    StdMethod(Void, "PSGetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), Out(Array(ObjPointer(ID3D11SamplerState), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "VSGetShader", [Out(Pointer(ObjPointer(ID3D11VertexShader)), "ppVertexShader"), Out(Array(ObjPointer(ID3D11ClassInstance), "*pNumClassInstances"), "ppClassInstances"), Out(Pointer(UINT), "pNumClassInstances")]),
    StdMethod(Void, "PSGetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "IAGetInputLayout", [Out(Pointer(ObjPointer(ID3D11InputLayout)), "ppInputLayout")]),
    StdMethod(Void, "IAGetVertexBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppVertexBuffers"), Out(Array(UINT, "NumBuffers"), "pStrides"), Out(Array(UINT, "NumBuffers"), "pOffsets")]),
    StdMethod(Void, "IAGetIndexBuffer", [Out(Pointer(ObjPointer(ID3D11Buffer)), "pIndexBuffer"), Out(Pointer(DXGI_FORMAT), "Format"), Out(Pointer(UINT), "Offset")]),
    StdMethod(Void, "GSGetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "GSGetShader", [Out(Pointer(ObjPointer(ID3D11GeometryShader)), "ppGeometryShader"), Out(Array(ObjPointer(ID3D11ClassInstance), "*pNumClassInstances"), "ppClassInstances"), Out(Pointer(UINT), "pNumClassInstances")]),
    StdMethod(Void, "IAGetPrimitiveTopology", [Out(Pointer(D3D11_PRIMITIVE_TOPOLOGY), "pTopology")], sideeffects=False),
    StdMethod(Void, "VSGetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), Out(Array(ObjPointer(ID3D11ShaderResourceView), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "VSGetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), Out(Array(ObjPointer(ID3D11SamplerState), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "GetPredication", [Out(Pointer(ObjPointer(ID3D11Predicate)), "ppPredicate"), Out(Pointer(BOOL), "pPredicateValue")]),
    StdMethod(Void, "GSGetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), Out(Array(ObjPointer(ID3D11ShaderResourceView), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "GSGetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), Out(Array(ObjPointer(ID3D11SamplerState), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "OMGetRenderTargets", [(UINT, "NumViews"), Out(Array(ObjPointer(ID3D11RenderTargetView), "NumViews"), "ppRenderTargetViews"), Out(Pointer(ObjPointer(ID3D11DepthStencilView)), "ppDepthStencilView")]),
    StdMethod(Void, "OMGetRenderTargetsAndUnorderedAccessViews", [(UINT, "NumRTVs"), Out(Array(ObjPointer(ID3D11RenderTargetView), "NumRTVs"), "ppRenderTargetViews"), Out(Pointer(ObjPointer(ID3D11DepthStencilView)), "ppDepthStencilView"), (UINT, "UAVStartSlot"), (UINT, "NumUAVs"), Out(Array(ObjPointer(ID3D11UnorderedAccessView), "NumUAVs"), "ppUnorderedAccessViews")]),
    StdMethod(Void, "OMGetBlendState", [Out(Pointer(ObjPointer(ID3D11BlendState)), "ppBlendState"), Out(Array(FLOAT, 4), "BlendFactor"), Out(Pointer(UINT), "pSampleMask")]),
    StdMethod(Void, "OMGetDepthStencilState", [Out(Pointer(ObjPointer(ID3D11DepthStencilState)), "ppDepthStencilState"), Out(Pointer(UINT), "pStencilRef")]),
    StdMethod(Void, "SOGetTargets", [(UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppSOTargets")]),
    StdMethod(Void, "RSGetState", [Out(Pointer(ObjPointer(ID3D11RasterizerState)), "ppRasterizerState")]),
    StdMethod(Void, "RSGetViewports", [Out(Pointer(UINT), "pNumViewports"), Out(Array(D3D11_VIEWPORT, "*pNumViewports"), "pViewports")]),
    StdMethod(Void, "RSGetScissorRects", [Out(Pointer(UINT), "pNumRects"), Out(Array(D3D11_RECT, "*pNumRects"), "pRects")]),
    StdMethod(Void, "HSGetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), Out(Array(ObjPointer(ID3D11ShaderResourceView), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "HSGetShader", [Out(Pointer(ObjPointer(ID3D11HullShader)), "ppHullShader"), Out(Array(ObjPointer(ID3D11ClassInstance), "*pNumClassInstances"), "ppClassInstances"), Out(Pointer(UINT), "pNumClassInstances")]),
    StdMethod(Void, "HSGetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), Out(Array(ObjPointer(ID3D11SamplerState), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "HSGetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "DSGetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), Out(Array(ObjPointer(ID3D11ShaderResourceView), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "DSGetShader", [Out(Pointer(ObjPointer(ID3D11DomainShader)), "ppDomainShader"), Out(Array(ObjPointer(ID3D11ClassInstance), "*pNumClassInstances"), "ppClassInstances"), Out(Pointer(UINT), "pNumClassInstances")]),
    StdMethod(Void, "DSGetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), Out(Array(ObjPointer(ID3D11SamplerState), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "DSGetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "CSGetShaderResources", [(UINT, "StartSlot"), (UINT, "NumViews"), Out(Array(ObjPointer(ID3D11ShaderResourceView), "NumViews"), "ppShaderResourceViews")]),
    StdMethod(Void, "CSGetUnorderedAccessViews", [(UINT, "StartSlot"), (UINT, "NumUAVs"), Out(Array(ObjPointer(ID3D11UnorderedAccessView), "NumUAVs"), "ppUnorderedAccessViews")]),
    StdMethod(Void, "CSGetShader", [Out(Pointer(ObjPointer(ID3D11ComputeShader)), "ppComputeShader"), Out(Array(ObjPointer(ID3D11ClassInstance), "*pNumClassInstances"), "ppClassInstances"), Out(Pointer(UINT), "pNumClassInstances")]),
    StdMethod(Void, "CSGetSamplers", [(UINT, "StartSlot"), (UINT, "NumSamplers"), Out(Array(ObjPointer(ID3D11SamplerState), "NumSamplers"), "ppSamplers")]),
    StdMethod(Void, "CSGetConstantBuffers", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppConstantBuffers")]),
    StdMethod(Void, "ClearState", []),
    StdMethod(Void, "Flush", []),
    StdMethod(D3D11_DEVICE_CONTEXT_TYPE, "GetType", [], sideeffects=False),
    StdMethod(UINT, "GetContextFlags", [], sideeffects=False),
    StdMethod(HRESULT, "FinishCommandList", [(BOOL, "RestoreDeferredContextState"), Out(Pointer(ObjPointer(ID3D11CommandList)), "ppCommandList")]),
]

D3D11_CREATE_DEVICE_FLAG = Flags(UINT, [
    "D3D11_CREATE_DEVICE_SINGLETHREADED",
    "D3D11_CREATE_DEVICE_DEBUG",
    "D3D11_CREATE_DEVICE_SWITCH_TO_REF",
    "D3D11_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS",
    "D3D11_CREATE_DEVICE_BGRA_SUPPORT",
])

ID3D11Device.methods += [
    StdMethod(HRESULT, "CreateBuffer", [(Pointer(Const(D3D11_BUFFER_DESC)), "pDesc"), (Array(Const(D3D11_SUBRESOURCE_DATA), "1"), "pInitialData"), Out(Pointer(ObjPointer(ID3D11Buffer)), "ppBuffer")]),
    StdMethod(HRESULT, "CreateTexture1D", [(Pointer(Const(D3D11_TEXTURE1D_DESC)), "pDesc"), (Array(Const(D3D11_SUBRESOURCE_DATA), "_getNumSubResources(pDesc)"), "pInitialData"), Out(Pointer(ObjPointer(ID3D11Texture1D)), "ppTexture1D")]),
    StdMethod(HRESULT, "CreateTexture2D", [(Pointer(Const(D3D11_TEXTURE2D_DESC)), "pDesc"), (Array(Const(D3D11_SUBRESOURCE_DATA), "_getNumSubResources(pDesc)"), "pInitialData"), Out(Pointer(ObjPointer(ID3D11Texture2D)), "ppTexture2D")]),
    StdMethod(HRESULT, "CreateTexture3D", [(Pointer(Const(D3D11_TEXTURE3D_DESC)), "pDesc"), (Array(Const(D3D11_SUBRESOURCE_DATA), "_getNumSubResources(pDesc)"), "pInitialData"), Out(Pointer(ObjPointer(ID3D11Texture3D)), "ppTexture3D")]),
    StdMethod(HRESULT, "CreateShaderResourceView", [(ObjPointer(ID3D11Resource), "pResource"), (Pointer(Const(D3D11_SHADER_RESOURCE_VIEW_DESC)), "pDesc"), Out(Pointer(ObjPointer(ID3D11ShaderResourceView)), "ppSRView")]),
    StdMethod(HRESULT, "CreateUnorderedAccessView", [(ObjPointer(ID3D11Resource), "pResource"), (Pointer(Const(D3D11_UNORDERED_ACCESS_VIEW_DESC)), "pDesc"), Out(Pointer(ObjPointer(ID3D11UnorderedAccessView)), "ppUAView")]),
    StdMethod(HRESULT, "CreateRenderTargetView", [(ObjPointer(ID3D11Resource), "pResource"), (Pointer(Const(D3D11_RENDER_TARGET_VIEW_DESC)), "pDesc"), Out(Pointer(ObjPointer(ID3D11RenderTargetView)), "ppRTView")]),
    StdMethod(HRESULT, "CreateDepthStencilView", [(ObjPointer(ID3D11Resource), "pResource"), (Pointer(Const(D3D11_DEPTH_STENCIL_VIEW_DESC)), "pDesc"), Out(Pointer(ObjPointer(ID3D11DepthStencilView)), "ppDepthStencilView")]),
    StdMethod(HRESULT, "CreateInputLayout", [(Array(Const(D3D11_INPUT_ELEMENT_DESC), "NumElements"), "pInputElementDescs"), (UINT, "NumElements"), (Blob(Const(Void), "BytecodeLength"), "pShaderBytecodeWithInputSignature"), (SIZE_T, "BytecodeLength"), Out(Pointer(ObjPointer(ID3D11InputLayout)), "ppInputLayout")]),
    StdMethod(HRESULT, "CreateVertexShader", [(Blob(Const(Void), "BytecodeLength"), "pShaderBytecode"), (SIZE_T, "BytecodeLength"), (ObjPointer(ID3D11ClassLinkage), "pClassLinkage"), Out(Pointer(ObjPointer(ID3D11VertexShader)), "ppVertexShader")]),
    StdMethod(HRESULT, "CreateGeometryShader", [(Blob(Const(Void), "BytecodeLength"), "pShaderBytecode"), (SIZE_T, "BytecodeLength"), (ObjPointer(ID3D11ClassLinkage), "pClassLinkage"), Out(Pointer(ObjPointer(ID3D11GeometryShader)), "ppGeometryShader")]),
    StdMethod(HRESULT, "CreateGeometryShaderWithStreamOutput", [(Blob(Const(Void), "BytecodeLength"), "pShaderBytecode"), (SIZE_T, "BytecodeLength"), (Array(Const(D3D11_SO_DECLARATION_ENTRY), "NumEntries"), "pSODeclaration"), (UINT, "NumEntries"), (Array(Const(UINT), "NumStrides"), "pBufferStrides"), (UINT, "NumStrides"), (UINT, "RasterizedStream"), (ObjPointer(ID3D11ClassLinkage), "pClassLinkage"), Out(Pointer(ObjPointer(ID3D11GeometryShader)), "ppGeometryShader")]),
    StdMethod(HRESULT, "CreatePixelShader", [(Blob(Const(Void), "BytecodeLength"), "pShaderBytecode"), (SIZE_T, "BytecodeLength"), (ObjPointer(ID3D11ClassLinkage), "pClassLinkage"), Out(Pointer(ObjPointer(ID3D11PixelShader)), "ppPixelShader")]),
    StdMethod(HRESULT, "CreateHullShader", [(Blob(Const(Void), "BytecodeLength"), "pShaderBytecode"), (SIZE_T, "BytecodeLength"), (ObjPointer(ID3D11ClassLinkage), "pClassLinkage"), Out(Pointer(ObjPointer(ID3D11HullShader)), "ppHullShader")]),
    StdMethod(HRESULT, "CreateDomainShader", [(Blob(Const(Void), "BytecodeLength"), "pShaderBytecode"), (SIZE_T, "BytecodeLength"), (ObjPointer(ID3D11ClassLinkage), "pClassLinkage"), Out(Pointer(ObjPointer(ID3D11DomainShader)), "ppDomainShader")]),
    StdMethod(HRESULT, "CreateComputeShader", [(Blob(Const(Void), "BytecodeLength"), "pShaderBytecode"), (SIZE_T, "BytecodeLength"), (ObjPointer(ID3D11ClassLinkage), "pClassLinkage"), Out(Pointer(ObjPointer(ID3D11ComputeShader)), "ppComputeShader")]),
    StdMethod(HRESULT, "CreateClassLinkage", [Out(Pointer(ObjPointer(ID3D11ClassLinkage)), "ppLinkage")]),
    StdMethod(HRESULT, "CreateBlendState", [(Pointer(Const(D3D11_BLEND_DESC)), "pBlendStateDesc"), Out(Pointer(ObjPointer(ID3D11BlendState)), "ppBlendState")]),
    StdMethod(HRESULT, "CreateDepthStencilState", [(Pointer(Const(D3D11_DEPTH_STENCIL_DESC)), "pDepthStencilDesc"), Out(Pointer(ObjPointer(ID3D11DepthStencilState)), "ppDepthStencilState")]),
    StdMethod(HRESULT, "CreateRasterizerState", [(Pointer(Const(D3D11_RASTERIZER_DESC)), "pRasterizerDesc"), Out(Pointer(ObjPointer(ID3D11RasterizerState)), "ppRasterizerState")]),
    StdMethod(HRESULT, "CreateSamplerState", [(Pointer(Const(D3D11_SAMPLER_DESC)), "pSamplerDesc"), Out(Pointer(ObjPointer(ID3D11SamplerState)), "ppSamplerState")]),
    StdMethod(HRESULT, "CreateQuery", [(Pointer(Const(D3D11_QUERY_DESC)), "pQueryDesc"), Out(Pointer(ObjPointer(ID3D11Query)), "ppQuery")]),
    StdMethod(HRESULT, "CreatePredicate", [(Pointer(Const(D3D11_QUERY_DESC)), "pPredicateDesc"), Out(Pointer(ObjPointer(ID3D11Predicate)), "ppPredicate")]),
    StdMethod(HRESULT, "CreateCounter", [(Pointer(Const(D3D11_COUNTER_DESC)), "pCounterDesc"), Out(Pointer(ObjPointer(ID3D11Counter)), "ppCounter")]),
    StdMethod(HRESULT, "CreateDeferredContext", [(UINT, "ContextFlags"), Out(Pointer(ObjPointer(ID3D11DeviceContext)), "ppDeferredContext")]),
    StdMethod(HRESULT, "OpenSharedResource", [(HANDLE, "hResource"), (REFIID, "ReturnedInterface"), Out(Pointer(ObjPointer(Void)), "ppResource")]),
    StdMethod(HRESULT, "CheckFormatSupport", [(DXGI_FORMAT, "Format"), Out(Pointer(D3D11_FORMAT_SUPPORT), "pFormatSupport")], sideeffects=False),
    StdMethod(HRESULT, "CheckMultisampleQualityLevels", [(DXGI_FORMAT, "Format"), (UINT, "SampleCount"), Out(Pointer(UINT), "pNumQualityLevels")], sideeffects=False),
    StdMethod(Void, "CheckCounterInfo", [Out(Pointer(D3D11_COUNTER_INFO), "pCounterInfo")], sideeffects=False),
    StdMethod(HRESULT, "CheckCounter", [(Pointer(Const(D3D11_COUNTER_DESC)), "pDesc"), Out(Pointer(D3D11_COUNTER_TYPE), "pType"), Out(Pointer(UINT), "pActiveCounters"), Out(LPSTR, "szName"), Out(Pointer(UINT), "pNameLength"), Out(LPSTR, "szUnits"), Out(Pointer(UINT), "pUnitsLength"), Out(LPSTR, "szDescription"), Out(Pointer(UINT), "pDescriptionLength")], sideeffects=False),
    StdMethod(HRESULT, "CheckFeatureSupport", [(D3D11_FEATURE, "Feature"), Out(D3D11_FEATURE_DATA, "pFeatureSupportData"), (UINT, "FeatureSupportDataSize")], sideeffects=False),
    StdMethod(HRESULT, "GetPrivateData", [(REFGUID, "guid"), Out(Pointer(UINT), "pDataSize"), Out(OpaquePointer(Void), "pData")], sideeffects=False),
    StdMethod(HRESULT, "SetPrivateData", [(REFGUID, "guid"), (UINT, "DataSize"), (OpaqueBlob(Const(Void), "DataSize"), "pData")], sideeffects=False),
    StdMethod(HRESULT, "SetPrivateDataInterface", [(REFGUID, "guid"), (OpaquePointer(Const(IUnknown)), "pData")], sideeffects=False),
    StdMethod(D3D_FEATURE_LEVEL, "GetFeatureLevel", [], sideeffects=False),
    StdMethod(D3D11_CREATE_DEVICE_FLAG, "GetCreationFlags", [], sideeffects=False),
    StdMethod(HRESULT, "GetDeviceRemovedReason", [], sideeffects=False),
    StdMethod(Void, "GetImmediateContext", [Out(Pointer(ObjPointer(ID3D11DeviceContext)), "ppImmediateContext")]),
    StdMethod(HRESULT, "SetExceptionMode", [(D3D11_RAISE_FLAG, "RaiseFlags")]),
    StdMethod(UINT, "GetExceptionMode", [], sideeffects=False),
]

d3d11 = Module("d3d11")

d3d11.addFunctions([
    StdFunction(HRESULT, "D3D11CreateDevice", [(ObjPointer(IDXGIAdapter), "pAdapter"), (D3D_DRIVER_TYPE, "DriverType"), (HMODULE, "Software"), (D3D11_CREATE_DEVICE_FLAG, "Flags"), (Array(Const(D3D_FEATURE_LEVEL), "FeatureLevels"), "pFeatureLevels"), (UINT, "FeatureLevels"), (UINT, "SDKVersion"), Out(Pointer(ObjPointer(ID3D11Device)), "ppDevice"), Out(Pointer(D3D_FEATURE_LEVEL), "pFeatureLevel"), Out(Pointer(ObjPointer(ID3D11DeviceContext)), "ppImmediateContext")]),
    StdFunction(HRESULT, "D3D11CreateDeviceAndSwapChain", [(ObjPointer(IDXGIAdapter), "pAdapter"), (D3D_DRIVER_TYPE, "DriverType"), (HMODULE, "Software"), (D3D11_CREATE_DEVICE_FLAG, "Flags"), (Array(Const(D3D_FEATURE_LEVEL), "FeatureLevels"), "pFeatureLevels"), (UINT, "FeatureLevels"), (UINT, "SDKVersion"), (Pointer(Const(DXGI_SWAP_CHAIN_DESC)), "pSwapChainDesc"), Out(Pointer(ObjPointer(IDXGISwapChain)), "ppSwapChain"), Out(Pointer(ObjPointer(ID3D11Device)), "ppDevice"), Out(Pointer(D3D_FEATURE_LEVEL), "pFeatureLevel"), Out(Pointer(ObjPointer(ID3D11DeviceContext)), "ppImmediateContext")]),
])

d3d11.addInterfaces([
    IDXGIFactory1,
    IDXGIAdapter1,
    IDXGIDevice1,
    IDXGIResource,
    ID3D11Debug,
    ID3D11InfoQueue,
    ID3D11SwitchToRef,
])

########NEW FILE########
__FILENAME__ = d3d11sdklayers
##########################################################################
#
# Copyright 2012 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from dxgi import *


ID3D11DeviceChild = Interface("ID3D11DeviceChild", IUnknown)
ID3D11DeviceContext = Interface("ID3D11DeviceContext", ID3D11DeviceChild)


D3D11_DEBUG_FEATURE = Flags(UINT, [
    "D3D11_DEBUG_FEATURE_FLUSH_PER_RENDER_OP",
    "D3D11_DEBUG_FEATURE_FINISH_PER_RENDER_OP",
    "D3D11_DEBUG_FEATURE_PRESENT_PER_RENDER_OP",
])

D3D11_RLDO_FLAGS = Enum("D3D11_RLDO_FLAGS", [
    "D3D11_RLDO_SUMMARY",
    "D3D11_RLDO_DETAIL",
])

ID3D11Debug = Interface("ID3D11Debug", IUnknown)
ID3D11Debug.methods += [
    StdMethod(HRESULT, "SetFeatureMask", [(D3D11_DEBUG_FEATURE, "Mask")]),
    StdMethod(D3D11_DEBUG_FEATURE, "GetFeatureMask", [], sideeffects=False),
    StdMethod(HRESULT, "SetPresentPerRenderOpDelay", [(UINT, "Milliseconds")]),
    StdMethod(UINT, "GetPresentPerRenderOpDelay", [], sideeffects=False),
    StdMethod(HRESULT, "SetSwapChain", [(ObjPointer(IDXGISwapChain), "pSwapChain")]),
    StdMethod(HRESULT, "GetSwapChain", [Out(Pointer(ObjPointer(IDXGISwapChain)), "ppSwapChain")]),
    StdMethod(HRESULT, "ValidateContext", [(ObjPointer(ID3D11DeviceContext), "pContext")]),
    StdMethod(HRESULT, "ReportLiveDeviceObjects", [(D3D11_RLDO_FLAGS, "Flags")]),
    StdMethod(HRESULT, "ValidateContextForDispatch", [(ObjPointer(ID3D11DeviceContext), "pContext")]),
]

ID3D11SwitchToRef = Interface("ID3D11SwitchToRef", IUnknown)
ID3D11SwitchToRef.methods += [
    StdMethod(BOOL, "SetUseRef", [(BOOL, "UseRef")]),
    StdMethod(BOOL, "GetUseRef", [], sideeffects=False),
]

D3D11_MESSAGE_CATEGORY = Enum("D3D11_MESSAGE_CATEGORY", [
    "D3D11_MESSAGE_CATEGORY_APPLICATION_DEFINED",
    "D3D11_MESSAGE_CATEGORY_MISCELLANEOUS",
    "D3D11_MESSAGE_CATEGORY_INITIALIZATION",
    "D3D11_MESSAGE_CATEGORY_CLEANUP",
    "D3D11_MESSAGE_CATEGORY_COMPILATION",
    "D3D11_MESSAGE_CATEGORY_STATE_CREATION",
    "D3D11_MESSAGE_CATEGORY_STATE_SETTING",
    "D3D11_MESSAGE_CATEGORY_STATE_GETTING",
    "D3D11_MESSAGE_CATEGORY_RESOURCE_MANIPULATION",
    "D3D11_MESSAGE_CATEGORY_EXECUTION",
])

D3D11_MESSAGE_SEVERITY = Enum("D3D11_MESSAGE_SEVERITY", [
    "D3D11_MESSAGE_SEVERITY_CORRUPTION",
    "D3D11_MESSAGE_SEVERITY_ERROR",
    "D3D11_MESSAGE_SEVERITY_WARNING",
    "D3D11_MESSAGE_SEVERITY_INFO",
])

D3D11_MESSAGE_ID = Enum("D3D11_MESSAGE_ID", [
    "D3D11_MESSAGE_ID_UNKNOWN",
    "D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_HAZARD",
    "D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_HAZARD",
    "D3D11_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_HAZARD",
    "D3D11_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_HAZARD",
    "D3D11_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_HAZARD",
    "D3D11_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_HAZARD",
    "D3D11_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_HAZARD",
    "D3D11_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_HAZARD",
    "D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETS_HAZARD",
    "D3D11_MESSAGE_ID_DEVICE_SOSETTARGETS_HAZARD",
    "D3D11_MESSAGE_ID_STRING_FROM_APPLICATION",
    "D3D11_MESSAGE_ID_CORRUPTED_THIS",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER1",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER2",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER3",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER4",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER5",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER6",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER7",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER8",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER9",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER10",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER11",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER12",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER13",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER14",
    "D3D11_MESSAGE_ID_CORRUPTED_PARAMETER15",
    "D3D11_MESSAGE_ID_CORRUPTED_MULTITHREADING",
    "D3D11_MESSAGE_ID_MESSAGE_REPORTING_OUTOFMEMORY",
    "D3D11_MESSAGE_ID_IASETINPUTLAYOUT_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_IASETVERTEXBUFFERS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_IASETINDEXBUFFER_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_VSSETSHADER_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_VSSETSHADERRESOURCES_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_VSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_VSSETSAMPLERS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_GSSETSHADER_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_GSSETSHADERRESOURCES_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_GSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_GSSETSAMPLERS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_SOSETTARGETS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_PSSETSHADER_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_PSSETSHADERRESOURCES_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_PSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_PSSETSAMPLERS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_RSSETSTATE_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_OMSETBLENDSTATE_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_OMSETDEPTHSTENCILSTATE_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_OMSETRENDERTARGETS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_SETPREDICATION_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_GETPRIVATEDATA_MOREDATA",
    "D3D11_MESSAGE_ID_SETPRIVATEDATA_INVALIDFREEDATA",
    "D3D11_MESSAGE_ID_SETPRIVATEDATA_INVALIDIUNKNOWN",
    "D3D11_MESSAGE_ID_SETPRIVATEDATA_INVALIDFLAGS",
    "D3D11_MESSAGE_ID_SETPRIVATEDATA_CHANGINGPARAMS",
    "D3D11_MESSAGE_ID_SETPRIVATEDATA_OUTOFMEMORY",
    "D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDFORMAT",
    "D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDSAMPLES",
    "D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDUSAGE",
    "D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDBINDFLAGS",
    "D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDCPUACCESSFLAGS",
    "D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDMISCFLAGS",
    "D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDCPUACCESSFLAGS",
    "D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDBINDFLAGS",
    "D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDINITIALDATA",
    "D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDDIMENSIONS",
    "D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDMIPLEVELS",
    "D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDMISCFLAGS",
    "D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDARG_RETURN",
    "D3D11_MESSAGE_ID_CREATEBUFFER_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_CREATEBUFFER_NULLDESC",
    "D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDCONSTANTBUFFERBINDINGS",
    "D3D11_MESSAGE_ID_CREATEBUFFER_LARGEALLOCATION",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDFORMAT",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_UNSUPPORTEDFORMAT",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDSAMPLES",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDUSAGE",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDBINDFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDCPUACCESSFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDMISCFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDCPUACCESSFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDBINDFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDINITIALDATA",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDDIMENSIONS",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDMIPLEVELS",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDMISCFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDARG_RETURN",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_NULLDESC",
    "D3D11_MESSAGE_ID_CREATETEXTURE1D_LARGEALLOCATION",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDFORMAT",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_UNSUPPORTEDFORMAT",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDSAMPLES",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDUSAGE",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDBINDFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDCPUACCESSFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDMISCFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDCPUACCESSFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDBINDFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDINITIALDATA",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDDIMENSIONS",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDMIPLEVELS",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDMISCFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDARG_RETURN",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_NULLDESC",
    "D3D11_MESSAGE_ID_CREATETEXTURE2D_LARGEALLOCATION",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDFORMAT",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_UNSUPPORTEDFORMAT",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDSAMPLES",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDUSAGE",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDBINDFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDCPUACCESSFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDMISCFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDCPUACCESSFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDBINDFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDINITIALDATA",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDDIMENSIONS",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDMIPLEVELS",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDMISCFLAGS",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDARG_RETURN",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_NULLDESC",
    "D3D11_MESSAGE_ID_CREATETEXTURE3D_LARGEALLOCATION",
    "D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT",
    "D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDESC",
    "D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFORMAT",
    "D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS",
    "D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDRESOURCE",
    "D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_TOOMANYOBJECTS",
    "D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDARG_RETURN",
    "D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT",
    "D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT",
    "D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDESC",
    "D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDFORMAT",
    "D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDIMENSIONS",
    "D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDRESOURCE",
    "D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_TOOMANYOBJECTS",
    "D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDARG_RETURN",
    "D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDESC",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFORMAT",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_TOOMANYOBJECTS",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDARG_RETURN",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_OUTOFMEMORY",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_TOOMANYELEMENTS",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDFORMAT",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOT",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDALIGNMENT",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_DUPLICATESEMANTIC",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_NULLSEMANTIC",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_MISSINGELEMENT",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_NULLDESC",
    "D3D11_MESSAGE_ID_CREATEVERTEXSHADER_OUTOFMEMORY",
    "D3D11_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERBYTECODE",
    "D3D11_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERTYPE",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_OUTOFMEMORY",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERTYPE",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDDECL",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_EXPECTEDDECL",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE",
    "D3D11_MESSAGE_ID_CREATEPIXELSHADER_OUTOFMEMORY",
    "D3D11_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERBYTECODE",
    "D3D11_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERTYPE",
    "D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFILLMODE",
    "D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDCULLMODE",
    "D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP",
    "D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS",
    "D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_TOOMANYOBJECTS",
    "D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_NULLDESC",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_TOOMANYOBJECTS",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_NULLDESC",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLEND",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLEND",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOP",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLENDALPHA",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLENDALPHA",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOPALPHA",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_TOOMANYOBJECTS",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_NULLDESC",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDFILTER",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSU",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSV",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSW",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMIPLODBIAS",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXANISOTROPY",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDCOMPARISONFUNC",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMINLOD",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXLOD",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_TOOMANYOBJECTS",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_NULLDESC",
    "D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDQUERY",
    "D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDMISCFLAGS",
    "D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_UNEXPECTEDMISCFLAG",
    "D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_NULLDESC",
    "D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNRECOGNIZED",
    "D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNDEFINED",
    "D3D11_MESSAGE_ID_IASETVERTEXBUFFERS_INVALIDBUFFER",
    "D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_OFFSET_TOO_LARGE",
    "D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_IASETINDEXBUFFER_INVALIDBUFFER",
    "D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_FORMAT_INVALID",
    "D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_TOO_LARGE",
    "D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_UNALIGNED",
    "D3D11_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_VSSETCONSTANTBUFFERS_INVALIDBUFFER",
    "D3D11_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_VSSETSAMPLERS_SAMPLERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_GSSETCONSTANTBUFFERS_INVALIDBUFFER",
    "D3D11_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_GSSETSAMPLERS_SAMPLERS_EMPTY",
    "D3D11_MESSAGE_ID_SOSETTARGETS_INVALIDBUFFER",
    "D3D11_MESSAGE_ID_DEVICE_SOSETTARGETS_OFFSET_UNALIGNED",
    "D3D11_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_PSSETCONSTANTBUFFERS_INVALIDBUFFER",
    "D3D11_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_PSSETSAMPLERS_SAMPLERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_INVALIDVIEWPORT",
    "D3D11_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_INVALIDSCISSOR",
    "D3D11_MESSAGE_ID_CLEARRENDERTARGETVIEW_DENORMFLUSH",
    "D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DENORMFLUSH",
    "D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALID",
    "D3D11_MESSAGE_ID_DEVICE_IAGETVERTEXBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_VSGETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_VSGETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_VSGETSAMPLERS_SAMPLERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_GSGETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_GSGETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_GSGETSAMPLERS_SAMPLERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_SOGETTARGETS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_PSGETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_PSGETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_PSGETSAMPLERS_SAMPLERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_RSGETVIEWPORTS_VIEWPORTS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_RSGETSCISSORRECTS_RECTS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_GENERATEMIPS_RESOURCE_INVALID",
    "D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSUBRESOURCE",
    "D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESUBRESOURCE",
    "D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCEBOX",
    "D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCE",
    "D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSTATE",
    "D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESTATE",
    "D3D11_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCE",
    "D3D11_MESSAGE_ID_COPYRESOURCE_INVALIDDESTINATIONSTATE",
    "D3D11_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCESTATE",
    "D3D11_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSUBRESOURCE",
    "D3D11_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONBOX",
    "D3D11_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSTATE",
    "D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_INVALID",
    "D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_SUBRESOURCE_INVALID",
    "D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_INVALID",
    "D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_SUBRESOURCE_INVALID",
    "D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_FORMAT_INVALID",
    "D3D11_MESSAGE_ID_BUFFER_MAP_INVALIDMAPTYPE",
    "D3D11_MESSAGE_ID_BUFFER_MAP_INVALIDFLAGS",
    "D3D11_MESSAGE_ID_BUFFER_MAP_ALREADYMAPPED",
    "D3D11_MESSAGE_ID_BUFFER_MAP_DEVICEREMOVED_RETURN",
    "D3D11_MESSAGE_ID_BUFFER_UNMAP_NOTMAPPED",
    "D3D11_MESSAGE_ID_TEXTURE1D_MAP_INVALIDMAPTYPE",
    "D3D11_MESSAGE_ID_TEXTURE1D_MAP_INVALIDSUBRESOURCE",
    "D3D11_MESSAGE_ID_TEXTURE1D_MAP_INVALIDFLAGS",
    "D3D11_MESSAGE_ID_TEXTURE1D_MAP_ALREADYMAPPED",
    "D3D11_MESSAGE_ID_TEXTURE1D_MAP_DEVICEREMOVED_RETURN",
    "D3D11_MESSAGE_ID_TEXTURE1D_UNMAP_INVALIDSUBRESOURCE",
    "D3D11_MESSAGE_ID_TEXTURE1D_UNMAP_NOTMAPPED",
    "D3D11_MESSAGE_ID_TEXTURE2D_MAP_INVALIDMAPTYPE",
    "D3D11_MESSAGE_ID_TEXTURE2D_MAP_INVALIDSUBRESOURCE",
    "D3D11_MESSAGE_ID_TEXTURE2D_MAP_INVALIDFLAGS",
    "D3D11_MESSAGE_ID_TEXTURE2D_MAP_ALREADYMAPPED",
    "D3D11_MESSAGE_ID_TEXTURE2D_MAP_DEVICEREMOVED_RETURN",
    "D3D11_MESSAGE_ID_TEXTURE2D_UNMAP_INVALIDSUBRESOURCE",
    "D3D11_MESSAGE_ID_TEXTURE2D_UNMAP_NOTMAPPED",
    "D3D11_MESSAGE_ID_TEXTURE3D_MAP_INVALIDMAPTYPE",
    "D3D11_MESSAGE_ID_TEXTURE3D_MAP_INVALIDSUBRESOURCE",
    "D3D11_MESSAGE_ID_TEXTURE3D_MAP_INVALIDFLAGS",
    "D3D11_MESSAGE_ID_TEXTURE3D_MAP_ALREADYMAPPED",
    "D3D11_MESSAGE_ID_TEXTURE3D_MAP_DEVICEREMOVED_RETURN",
    "D3D11_MESSAGE_ID_TEXTURE3D_UNMAP_INVALIDSUBRESOURCE",
    "D3D11_MESSAGE_ID_TEXTURE3D_UNMAP_NOTMAPPED",
    "D3D11_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_DEPRECATED",
    "D3D11_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_FORMAT_DEPRECATED",
    "D3D11_MESSAGE_ID_SETEXCEPTIONMODE_UNRECOGNIZEDFLAGS",
    "D3D11_MESSAGE_ID_SETEXCEPTIONMODE_INVALIDARG_RETURN",
    "D3D11_MESSAGE_ID_SETEXCEPTIONMODE_DEVICEREMOVED_RETURN",
    "D3D11_MESSAGE_ID_REF_SIMULATING_INFINITELY_FAST_HARDWARE",
    "D3D11_MESSAGE_ID_REF_THREADING_MODE",
    "D3D11_MESSAGE_ID_REF_UMDRIVER_EXCEPTION",
    "D3D11_MESSAGE_ID_REF_KMDRIVER_EXCEPTION",
    "D3D11_MESSAGE_ID_REF_HARDWARE_EXCEPTION",
    "D3D11_MESSAGE_ID_REF_ACCESSING_INDEXABLE_TEMP_OUT_OF_RANGE",
    "D3D11_MESSAGE_ID_REF_PROBLEM_PARSING_SHADER",
    "D3D11_MESSAGE_ID_REF_OUT_OF_MEMORY",
    "D3D11_MESSAGE_ID_REF_INFO",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEXPOS_OVERFLOW",
    "D3D11_MESSAGE_ID_DEVICE_DRAWINDEXED_INDEXPOS_OVERFLOW",
    "D3D11_MESSAGE_ID_DEVICE_DRAWINSTANCED_VERTEXPOS_OVERFLOW",
    "D3D11_MESSAGE_ID_DEVICE_DRAWINSTANCED_INSTANCEPOS_OVERFLOW",
    "D3D11_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INSTANCEPOS_OVERFLOW",
    "D3D11_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INDEXPOS_OVERFLOW",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_SHADER_NOT_SET",
    "D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND",
    "D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERINDEX",
    "D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_COMPONENTTYPE",
    "D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERMASK",
    "D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SYSTEMVALUE",
    "D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_NOT_SET",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_INPUTLAYOUT_NOT_SET",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_NOT_SET",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_TOO_SMALL",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_SAMPLER_NOT_SET",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_SHADERRESOURCEVIEW_NOT_SET",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_VIEW_DIMENSION_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_TOO_SMALL",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_NOT_SET",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_FORMAT_INVALID",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_TOO_SMALL",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_GS_INPUT_PRIMITIVE_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_RETURN_TYPE_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_POSITION_NOT_PRESENT",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_NOT_SET",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_BOUND_RESOURCE_MAPPED",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_INVALID_PRIMITIVETOPOLOGY",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_OFFSET_UNALIGNED",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_STRIDE_UNALIGNED",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_OFFSET_UNALIGNED",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_OFFSET_UNALIGNED",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_LD_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_C_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_MULTISAMPLE_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_SO_TARGETS_BOUND_WITHOUT_SOURCE",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_SO_STRIDE_LARGER_THAN_BUFFER",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0",
    "D3D11_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_AT_FAULT",
    "D3D11_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT",
    "D3D11_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT",
    "D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_INVALIDARG_RETURN",
    "D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BADINTERFACE_RETURN",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_VIEWPORT_NOT_SET",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC",
    "D3D11_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_DENORMFLUSH",
    "D3D11_MESSAGE_ID_OMSETRENDERTARGETS_INVALIDVIEW",
    "D3D11_MESSAGE_ID_DEVICE_SETTEXTFILTERSIZE_INVALIDDIMENSIONS",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_SAMPLER_MISMATCH",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_TYPE_MISMATCH",
    "D3D11_MESSAGE_ID_BLENDSTATE_GETDESC_LEGACY",
    "D3D11_MESSAGE_ID_SHADERRESOURCEVIEW_GETDESC_LEGACY",
    "D3D11_MESSAGE_ID_CREATEQUERY_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_CREATEPREDICATE_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_CREATECOUNTER_OUTOFRANGE_COUNTER",
    "D3D11_MESSAGE_ID_CREATECOUNTER_SIMULTANEOUS_ACTIVE_COUNTERS_EXHAUSTED",
    "D3D11_MESSAGE_ID_CREATECOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER",
    "D3D11_MESSAGE_ID_CREATECOUNTER_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_CREATECOUNTER_NONEXCLUSIVE_RETURN",
    "D3D11_MESSAGE_ID_CREATECOUNTER_NULLDESC",
    "D3D11_MESSAGE_ID_CHECKCOUNTER_OUTOFRANGE_COUNTER",
    "D3D11_MESSAGE_ID_CHECKCOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER",
    "D3D11_MESSAGE_ID_SETPREDICATION_INVALID_PREDICATE_STATE",
    "D3D11_MESSAGE_ID_QUERY_BEGIN_UNSUPPORTED",
    "D3D11_MESSAGE_ID_PREDICATE_BEGIN_DURING_PREDICATION",
    "D3D11_MESSAGE_ID_QUERY_BEGIN_DUPLICATE",
    "D3D11_MESSAGE_ID_QUERY_BEGIN_ABANDONING_PREVIOUS_RESULTS",
    "D3D11_MESSAGE_ID_PREDICATE_END_DURING_PREDICATION",
    "D3D11_MESSAGE_ID_QUERY_END_ABANDONING_PREVIOUS_RESULTS",
    "D3D11_MESSAGE_ID_QUERY_END_WITHOUT_BEGIN",
    "D3D11_MESSAGE_ID_QUERY_GETDATA_INVALID_DATASIZE",
    "D3D11_MESSAGE_ID_QUERY_GETDATA_INVALID_FLAGS",
    "D3D11_MESSAGE_ID_QUERY_GETDATA_INVALID_CALL",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_PS_OUTPUT_TYPE_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_GATHER_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN",
    "D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_STRIDE_TOO_LARGE",
    "D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_INVALIDRANGE",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_EMPTY_LAYOUT",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_SAMPLE_COUNT_MISMATCH",
    "D3D11_MESSAGE_ID_D3D10_MESSAGES_END",
    "D3D11_MESSAGE_ID_D3D10L9_MESSAGES_START",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_STENCIL_NO_TWO_SIDED",
    "D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_DepthBiasClamp_NOT_SUPPORTED",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_NO_COMPARISON_SUPPORT",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_EXCESSIVE_ANISOTROPY",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_OUT_OF_RANGE",
    "D3D11_MESSAGE_ID_VSSETSAMPLERS_NOT_SUPPORTED",
    "D3D11_MESSAGE_ID_VSSETSAMPLERS_TOO_MANY_SAMPLERS",
    "D3D11_MESSAGE_ID_PSSETSAMPLERS_TOO_MANY_SAMPLERS",
    "D3D11_MESSAGE_ID_CREATERESOURCE_NO_ARRAYS",
    "D3D11_MESSAGE_ID_CREATERESOURCE_NO_VB_AND_IB_BIND",
    "D3D11_MESSAGE_ID_CREATERESOURCE_NO_TEXTURE_1D",
    "D3D11_MESSAGE_ID_CREATERESOURCE_DIMENSION_OUT_OF_RANGE",
    "D3D11_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_SHADER_RESOURCE",
    "D3D11_MESSAGE_ID_OMSETRENDERTARGETS_TOO_MANY_RENDER_TARGETS",
    "D3D11_MESSAGE_ID_OMSETRENDERTARGETS_NO_DIFFERING_BIT_DEPTHS",
    "D3D11_MESSAGE_ID_IASETVERTEXBUFFERS_BAD_BUFFER_INDEX",
    "D3D11_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_TOO_MANY_VIEWPORTS",
    "D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_ADJACENCY_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_TOO_MANY_SCISSORS",
    "D3D11_MESSAGE_ID_COPYRESOURCE_ONLY_TEXTURE_2D_WITHIN_GPU_MEMORY",
    "D3D11_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_3D_READBACK",
    "D3D11_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_ONLY_READBACK",
    "D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_UNSUPPORTED_FORMAT",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_ALPHA_TO_COVERAGE",
    "D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_DepthClipEnable_MUST_BE_TRUE",
    "D3D11_MESSAGE_ID_DRAWINDEXED_STARTINDEXLOCATION_MUST_BE_POSITIVE",
    "D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_MUST_USE_LOWEST_LOD",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_MINLOD_MUST_NOT_BE_FRACTIONAL",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_MAXLOD_MUST_BE_FLT_MAX",
    "D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_FIRSTARRAYSLICE_MUST_BE_ZERO",
    "D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_CUBES_MUST_HAVE_6_SIDES",
    "D3D11_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_RENDER_TARGET",
    "D3D11_MESSAGE_ID_CREATERESOURCE_NO_DWORD_INDEX_BUFFER",
    "D3D11_MESSAGE_ID_CREATERESOURCE_MSAA_PRECLUDES_SHADER_RESOURCE",
    "D3D11_MESSAGE_ID_CREATERESOURCE_PRESENTATION_PRECLUDES_SHADER_RESOURCE",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_BLEND_ENABLE",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_WRITE_MASKS",
    "D3D11_MESSAGE_ID_CREATERESOURCE_NO_STREAM_OUT",
    "D3D11_MESSAGE_ID_CREATERESOURCE_ONLY_VB_IB_FOR_BUFFERS",
    "D3D11_MESSAGE_ID_CREATERESOURCE_NO_AUTOGEN_FOR_VOLUMES",
    "D3D11_MESSAGE_ID_CREATERESOURCE_DXGI_FORMAT_R8G8B8A8_CANNOT_BE_SHARED",
    "D3D11_MESSAGE_ID_VSSHADERRESOURCES_NOT_SUPPORTED",
    "D3D11_MESSAGE_ID_GEOMETRY_SHADER_NOT_SUPPORTED",
    "D3D11_MESSAGE_ID_STREAM_OUT_NOT_SUPPORTED",
    "D3D11_MESSAGE_ID_TEXT_FILTER_NOT_SUPPORTED",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_SEPARATE_ALPHA_BLEND",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_MRT_BLEND",
    "D3D11_MESSAGE_ID_CREATEBLENDSTATE_OPERATION_NOT_SUPPORTED",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_NO_MIRRORONCE",
    "D3D11_MESSAGE_ID_DRAWINSTANCED_NOT_SUPPORTED",
    "D3D11_MESSAGE_ID_DRAWINDEXEDINSTANCED_NOT_SUPPORTED_BELOW_9_3",
    "D3D11_MESSAGE_ID_DRAWINDEXED_POINTLIST_UNSUPPORTED",
    "D3D11_MESSAGE_ID_SETBLENDSTATE_SAMPLE_MASK_CANNOT_BE_ZERO",
    "D3D11_MESSAGE_ID_CREATERESOURCE_DIMENSION_EXCEEDS_FEATURE_LEVEL_DEFINITION",
    "D3D11_MESSAGE_ID_CREATERESOURCE_ONLY_SINGLE_MIP_LEVEL_DEPTH_STENCIL_SUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_NEGATIVESCISSOR",
    "D3D11_MESSAGE_ID_SLOT_ZERO_MUST_BE_D3D10_INPUT_PER_VERTEX_DATA",
    "D3D11_MESSAGE_ID_CREATERESOURCE_NON_POW_2_MIPMAP",
    "D3D11_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_NOT_SUPPORTED",
    "D3D11_MESSAGE_ID_OMSETRENDERTARGETS_NO_SRGB_MRT",
    "D3D11_MESSAGE_ID_D3D10L9_MESSAGES_END",
    "D3D11_MESSAGE_ID_D3D11_MESSAGES_START",
    "D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFLAGS",
    "D3D11_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDCLASSLINKAGE",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDCLASSLINKAGE",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTREAMS",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAMTORASTERIZER",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTREAMS",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCLASSLINKAGE",
    "D3D11_MESSAGE_ID_CREATEPIXELSHADER_INVALIDCLASSLINKAGE",
    "D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_INVALID_COMMANDLISTFLAGS",
    "D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_SINGLETHREADED",
    "D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_INVALIDARG_RETURN",
    "D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_INVALID_CALL_RETURN",
    "D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_FINISHDISPLAYLIST_ONIMMEDIATECONTEXT",
    "D3D11_MESSAGE_ID_FINISHDISPLAYLIST_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_FINISHDISPLAYLIST_INVALID_CALL_RETURN",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAM",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDENTRIES",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTRIDES",
    "D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTRIDES",
    "D3D11_MESSAGE_ID_DEVICE_HSSETSHADERRESOURCES_HAZARD",
    "D3D11_MESSAGE_ID_DEVICE_HSSETCONSTANTBUFFERS_HAZARD",
    "D3D11_MESSAGE_ID_HSSETSHADERRESOURCES_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_HSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDCALL",
    "D3D11_MESSAGE_ID_CREATEHULLSHADER_OUTOFMEMORY",
    "D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERBYTECODE",
    "D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERTYPE",
    "D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDCLASSLINKAGE",
    "D3D11_MESSAGE_ID_DEVICE_HSSETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_HSSETCONSTANTBUFFERS_INVALIDBUFFER",
    "D3D11_MESSAGE_ID_DEVICE_HSSETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_HSSETSAMPLERS_SAMPLERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_HSGETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_HSGETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_HSGETSAMPLERS_SAMPLERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_DSSETSHADERRESOURCES_HAZARD",
    "D3D11_MESSAGE_ID_DEVICE_DSSETCONSTANTBUFFERS_HAZARD",
    "D3D11_MESSAGE_ID_DSSETSHADERRESOURCES_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_DSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDCALL",
    "D3D11_MESSAGE_ID_CREATEDOMAINSHADER_OUTOFMEMORY",
    "D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERBYTECODE",
    "D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERTYPE",
    "D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDCLASSLINKAGE",
    "D3D11_MESSAGE_ID_DEVICE_DSSETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_DSSETCONSTANTBUFFERS_INVALIDBUFFER",
    "D3D11_MESSAGE_ID_DEVICE_DSSETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_DSSETSAMPLERS_SAMPLERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_DSGETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_DSGETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_DSGETSAMPLERS_SAMPLERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_HS_XOR_DS_MISMATCH",
    "D3D11_MESSAGE_ID_DEFERRED_CONTEXT_REMOVAL_PROCESS_AT_FAULT",
    "D3D11_MESSAGE_ID_DEVICE_DRAWINDIRECT_INVALID_ARG_BUFFER",
    "D3D11_MESSAGE_ID_DEVICE_DRAWINDIRECT_OFFSET_UNALIGNED",
    "D3D11_MESSAGE_ID_DEVICE_DRAWINDIRECT_OFFSET_OVERFLOW",
    "D3D11_MESSAGE_ID_RESOURCE_MAP_INVALIDMAPTYPE",
    "D3D11_MESSAGE_ID_RESOURCE_MAP_INVALIDSUBRESOURCE",
    "D3D11_MESSAGE_ID_RESOURCE_MAP_INVALIDFLAGS",
    "D3D11_MESSAGE_ID_RESOURCE_MAP_ALREADYMAPPED",
    "D3D11_MESSAGE_ID_RESOURCE_MAP_DEVICEREMOVED_RETURN",
    "D3D11_MESSAGE_ID_RESOURCE_MAP_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_RESOURCE_MAP_WITHOUT_INITIAL_DISCARD",
    "D3D11_MESSAGE_ID_RESOURCE_UNMAP_INVALIDSUBRESOURCE",
    "D3D11_MESSAGE_ID_RESOURCE_UNMAP_NOTMAPPED",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_RASTERIZING_CONTROL_POINTS",
    "D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_HS_DS_SIGNATURE_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_HULL_SHADER_INPUT_TOPOLOGY_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_HS_DS_CONTROL_POINT_COUNT_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_HS_DS_TESSELLATOR_DOMAIN_MISMATCH",
    "D3D11_MESSAGE_ID_CREATE_CONTEXT",
    "D3D11_MESSAGE_ID_LIVE_CONTEXT",
    "D3D11_MESSAGE_ID_DESTROY_CONTEXT",
    "D3D11_MESSAGE_ID_CREATE_BUFFER",
    "D3D11_MESSAGE_ID_LIVE_BUFFER",
    "D3D11_MESSAGE_ID_DESTROY_BUFFER",
    "D3D11_MESSAGE_ID_CREATE_TEXTURE1D",
    "D3D11_MESSAGE_ID_LIVE_TEXTURE1D",
    "D3D11_MESSAGE_ID_DESTROY_TEXTURE1D",
    "D3D11_MESSAGE_ID_CREATE_TEXTURE2D",
    "D3D11_MESSAGE_ID_LIVE_TEXTURE2D",
    "D3D11_MESSAGE_ID_DESTROY_TEXTURE2D",
    "D3D11_MESSAGE_ID_CREATE_TEXTURE3D",
    "D3D11_MESSAGE_ID_LIVE_TEXTURE3D",
    "D3D11_MESSAGE_ID_DESTROY_TEXTURE3D",
    "D3D11_MESSAGE_ID_CREATE_SHADERRESOURCEVIEW",
    "D3D11_MESSAGE_ID_LIVE_SHADERRESOURCEVIEW",
    "D3D11_MESSAGE_ID_DESTROY_SHADERRESOURCEVIEW",
    "D3D11_MESSAGE_ID_CREATE_RENDERTARGETVIEW",
    "D3D11_MESSAGE_ID_LIVE_RENDERTARGETVIEW",
    "D3D11_MESSAGE_ID_DESTROY_RENDERTARGETVIEW",
    "D3D11_MESSAGE_ID_CREATE_DEPTHSTENCILVIEW",
    "D3D11_MESSAGE_ID_LIVE_DEPTHSTENCILVIEW",
    "D3D11_MESSAGE_ID_DESTROY_DEPTHSTENCILVIEW",
    "D3D11_MESSAGE_ID_CREATE_VERTEXSHADER",
    "D3D11_MESSAGE_ID_LIVE_VERTEXSHADER",
    "D3D11_MESSAGE_ID_DESTROY_VERTEXSHADER",
    "D3D11_MESSAGE_ID_CREATE_HULLSHADER",
    "D3D11_MESSAGE_ID_LIVE_HULLSHADER",
    "D3D11_MESSAGE_ID_DESTROY_HULLSHADER",
    "D3D11_MESSAGE_ID_CREATE_DOMAINSHADER",
    "D3D11_MESSAGE_ID_LIVE_DOMAINSHADER",
    "D3D11_MESSAGE_ID_DESTROY_DOMAINSHADER",
    "D3D11_MESSAGE_ID_CREATE_GEOMETRYSHADER",
    "D3D11_MESSAGE_ID_LIVE_GEOMETRYSHADER",
    "D3D11_MESSAGE_ID_DESTROY_GEOMETRYSHADER",
    "D3D11_MESSAGE_ID_CREATE_PIXELSHADER",
    "D3D11_MESSAGE_ID_LIVE_PIXELSHADER",
    "D3D11_MESSAGE_ID_DESTROY_PIXELSHADER",
    "D3D11_MESSAGE_ID_CREATE_INPUTLAYOUT",
    "D3D11_MESSAGE_ID_LIVE_INPUTLAYOUT",
    "D3D11_MESSAGE_ID_DESTROY_INPUTLAYOUT",
    "D3D11_MESSAGE_ID_CREATE_SAMPLER",
    "D3D11_MESSAGE_ID_LIVE_SAMPLER",
    "D3D11_MESSAGE_ID_DESTROY_SAMPLER",
    "D3D11_MESSAGE_ID_CREATE_BLENDSTATE",
    "D3D11_MESSAGE_ID_LIVE_BLENDSTATE",
    "D3D11_MESSAGE_ID_DESTROY_BLENDSTATE",
    "D3D11_MESSAGE_ID_CREATE_DEPTHSTENCILSTATE",
    "D3D11_MESSAGE_ID_LIVE_DEPTHSTENCILSTATE",
    "D3D11_MESSAGE_ID_DESTROY_DEPTHSTENCILSTATE",
    "D3D11_MESSAGE_ID_CREATE_RASTERIZERSTATE",
    "D3D11_MESSAGE_ID_LIVE_RASTERIZERSTATE",
    "D3D11_MESSAGE_ID_DESTROY_RASTERIZERSTATE",
    "D3D11_MESSAGE_ID_CREATE_QUERY",
    "D3D11_MESSAGE_ID_LIVE_QUERY",
    "D3D11_MESSAGE_ID_DESTROY_QUERY",
    "D3D11_MESSAGE_ID_CREATE_PREDICATE",
    "D3D11_MESSAGE_ID_LIVE_PREDICATE",
    "D3D11_MESSAGE_ID_DESTROY_PREDICATE",
    "D3D11_MESSAGE_ID_CREATE_COUNTER",
    "D3D11_MESSAGE_ID_LIVE_COUNTER",
    "D3D11_MESSAGE_ID_DESTROY_COUNTER",
    "D3D11_MESSAGE_ID_CREATE_COMMANDLIST",
    "D3D11_MESSAGE_ID_LIVE_COMMANDLIST",
    "D3D11_MESSAGE_ID_DESTROY_COMMANDLIST",
    "D3D11_MESSAGE_ID_CREATE_CLASSINSTANCE",
    "D3D11_MESSAGE_ID_LIVE_CLASSINSTANCE",
    "D3D11_MESSAGE_ID_DESTROY_CLASSINSTANCE",
    "D3D11_MESSAGE_ID_CREATE_CLASSLINKAGE",
    "D3D11_MESSAGE_ID_LIVE_CLASSLINKAGE",
    "D3D11_MESSAGE_ID_DESTROY_CLASSLINKAGE",
    "D3D11_MESSAGE_ID_LIVE_DEVICE",
    "D3D11_MESSAGE_ID_LIVE_OBJECT_SUMMARY",
    "D3D11_MESSAGE_ID_CREATE_COMPUTESHADER",
    "D3D11_MESSAGE_ID_LIVE_COMPUTESHADER",
    "D3D11_MESSAGE_ID_DESTROY_COMPUTESHADER",
    "D3D11_MESSAGE_ID_CREATE_UNORDEREDACCESSVIEW",
    "D3D11_MESSAGE_ID_LIVE_UNORDEREDACCESSVIEW",
    "D3D11_MESSAGE_ID_DESTROY_UNORDEREDACCESSVIEW",
    "D3D11_MESSAGE_ID_DEVICE_SETSHADER_INTERFACES_FEATURELEVEL",
    "D3D11_MESSAGE_ID_DEVICE_SETSHADER_INTERFACE_COUNT_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE",
    "D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE_INDEX",
    "D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE_TYPE",
    "D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE_DATA",
    "D3D11_MESSAGE_ID_DEVICE_SETSHADER_UNBOUND_INSTANCE_DATA",
    "D3D11_MESSAGE_ID_DEVICE_SETSHADER_INSTANCE_DATA_BINDINGS",
    "D3D11_MESSAGE_ID_DEVICE_CREATESHADER_CLASSLINKAGE_FULL",
    "D3D11_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_UNRECOGNIZED_FEATURE",
    "D3D11_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_MISMATCHED_DATA_SIZE",
    "D3D11_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_INVALIDARG_RETURN",
    "D3D11_MESSAGE_ID_DEVICE_CSSETSHADERRESOURCES_HAZARD",
    "D3D11_MESSAGE_ID_DEVICE_CSSETCONSTANTBUFFERS_HAZARD",
    "D3D11_MESSAGE_ID_CSSETSHADERRESOURCES_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_CSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDCALL",
    "D3D11_MESSAGE_ID_CREATECOMPUTESHADER_OUTOFMEMORY",
    "D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDSHADERBYTECODE",
    "D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDSHADERTYPE",
    "D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDCLASSLINKAGE",
    "D3D11_MESSAGE_ID_DEVICE_CSSETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_CSSETCONSTANTBUFFERS_INVALIDBUFFER",
    "D3D11_MESSAGE_ID_DEVICE_CSSETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_CSSETSAMPLERS_SAMPLERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_CSGETSHADERRESOURCES_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_CSGETCONSTANTBUFFERS_BUFFERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_CSGETSAMPLERS_SAMPLERS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_DOUBLEFLOATOPSNOTSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_CREATEHULLSHADER_DOUBLEFLOATOPSNOTSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_DOUBLEFLOATOPSNOTSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_DOUBLEFLOATOPSNOTSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEFLOATOPSNOTSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_DOUBLEFLOATOPSNOTSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_DOUBLEFLOATOPSNOTSUPPORTED",
    "D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDSTRUCTURESTRIDE",
    "D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFLAGS",
    "D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDRESOURCE",
    "D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDESC",
    "D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFORMAT",
    "D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDIMENSIONS",
    "D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_UNRECOGNIZEDFORMAT",
    "D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_HAZARD",
    "D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_OVERLAPPING_OLD_SLOTS",
    "D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_NO_OP",
    "D3D11_MESSAGE_ID_CSSETUNORDEREDACCESSVIEWS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_PSSETUNORDEREDACCESSVIEWS_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDARG_RETURN",
    "D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_OUTOFMEMORY_RETURN",
    "D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_TOOMANYOBJECTS",
    "D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_HAZARD",
    "D3D11_MESSAGE_ID_CLEARUNORDEREDACCESSVIEW_DENORMFLUSH",
    "D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSS_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_DEVICE_CSGETUNORDEREDACCESSS_VIEWS_EMPTY",
    "D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFLAGS",
    "D3D11_MESSAGE_ID_CREATESHADERRESESOURCEVIEW_TOOMANYOBJECTS",
    "D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_INVALID_ARG_BUFFER",
    "D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_OFFSET_UNALIGNED",
    "D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_OFFSET_OVERFLOW",
    "D3D11_MESSAGE_ID_DEVICE_SETRESOURCEMINLOD_INVALIDCONTEXT",
    "D3D11_MESSAGE_ID_DEVICE_SETRESOURCEMINLOD_INVALIDRESOURCE",
    "D3D11_MESSAGE_ID_DEVICE_SETRESOURCEMINLOD_INVALIDMINLOD",
    "D3D11_MESSAGE_ID_DEVICE_GETRESOURCEMINLOD_INVALIDCONTEXT",
    "D3D11_MESSAGE_ID_DEVICE_GETRESOURCEMINLOD_INVALIDRESOURCE",
    "D3D11_MESSAGE_ID_OMSETDEPTHSTENCIL_UNBINDDELETINGOBJECT",
    "D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DEPTH_READONLY",
    "D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_STENCIL_READONLY",
    "D3D11_MESSAGE_ID_CHECKFEATURESUPPORT_FORMAT_DEPRECATED",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_RETURN_TYPE_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_NOT_SET",
    "D3D11_MESSAGE_ID_DEVICE_DRAW_UNORDEREDACCESSVIEW_RENDERTARGETVIEW_OVERLAP",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_DIMENSION_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_APPEND_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMICS_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_STRUCTURE_STRIDE_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_BUFFER_TYPE_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_RAW_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_FORMAT_LD_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_FORMAT_STORE_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_ADD_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_BITWISE_OPS_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_CMPSTORE_CMPEXCHANGE_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_EXCHANGE_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_SIGNED_MINMAX_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_UNSIGNED_MINMAX_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_DISPATCH_BOUND_RESOURCE_MAPPED",
    "D3D11_MESSAGE_ID_DEVICE_DISPATCH_THREADGROUPCOUNT_OVERFLOW",
    "D3D11_MESSAGE_ID_DEVICE_DISPATCH_THREADGROUPCOUNT_ZERO",
    "D3D11_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_STRUCTURE_STRIDE_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_BUFFER_TYPE_MISMATCH",
    "D3D11_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_RAW_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_DISPATCH_UNSUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_UNSUPPORTED",
    "D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDOFFSET",
    "D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_LARGEOFFSET",
    "D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDDESTINATIONSTATE",
    "D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDSOURCESTATE",
    "D3D11_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_NOT_SUPPORTED",
    "D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_INVALIDVIEW",
    "D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_INVALIDOFFSET",
    "D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_TOOMANYVIEWS",
    "D3D11_MESSAGE_ID_CLEARUNORDEREDACCESSVIEWFLOAT_INVALIDFORMAT",
    "D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_COUNTER_UNSUPPORTED",
    "D3D11_MESSAGE_ID_REF_WARNING",
    "D3D11_MESSAGE_ID_D3D11_MESSAGES_END",
])

D3D11_MESSAGE = Struct("D3D11_MESSAGE", [
    (D3D11_MESSAGE_CATEGORY, "Category"),
    (D3D11_MESSAGE_SEVERITY, "Severity"),
    (D3D11_MESSAGE_ID, "ID"),
    (Pointer(Const(Int)), "pDescription"),
    (SIZE_T, "DescriptionByteLength"),
])

D3D11_INFO_QUEUE_FILTER_DESC = Struct("D3D11_INFO_QUEUE_FILTER_DESC", [
    (UINT, "NumCategories"),
    (Pointer(D3D11_MESSAGE_CATEGORY), "pCategoryList"),
    (UINT, "NumSeverities"),
    (Pointer(D3D11_MESSAGE_SEVERITY), "pSeverityList"),
    (UINT, "NumIDs"),
    (Pointer(D3D11_MESSAGE_ID), "pIDList"),
])

D3D11_INFO_QUEUE_FILTER = Struct("D3D11_INFO_QUEUE_FILTER", [
    (D3D11_INFO_QUEUE_FILTER_DESC, "AllowList"),
    (D3D11_INFO_QUEUE_FILTER_DESC, "DenyList"),
])

ID3D11InfoQueue = Interface("ID3D11InfoQueue", IUnknown)
ID3D11InfoQueue.methods += [
    StdMethod(HRESULT, "SetMessageCountLimit", [(UINT64, "MessageCountLimit")], sideeffects=False),
    StdMethod(Void, "ClearStoredMessages", [], sideeffects=False),
    StdMethod(HRESULT, "GetMessage", [(UINT64, "MessageIndex"), Out(Pointer(D3D11_MESSAGE), "pMessage"), Out(Pointer(SIZE_T), "pMessageByteLength")], sideeffects=False),
    StdMethod(UINT64, "GetNumMessagesAllowedByStorageFilter", [], sideeffects=False),
    StdMethod(UINT64, "GetNumMessagesDeniedByStorageFilter", [], sideeffects=False),
    StdMethod(UINT64, "GetNumStoredMessages", [], sideeffects=False),
    StdMethod(UINT64, "GetNumStoredMessagesAllowedByRetrievalFilter", [], sideeffects=False),
    StdMethod(UINT64, "GetNumMessagesDiscardedByMessageCountLimit", [], sideeffects=False),
    StdMethod(UINT64, "GetMessageCountLimit", [], sideeffects=False),
    StdMethod(HRESULT, "AddStorageFilterEntries", [(Pointer(D3D11_INFO_QUEUE_FILTER), "pFilter")], sideeffects=False),
    StdMethod(HRESULT, "GetStorageFilter", [Out(Pointer(D3D11_INFO_QUEUE_FILTER), "pFilter"), Out(Pointer(SIZE_T), "pFilterByteLength")], sideeffects=False),
    StdMethod(Void, "ClearStorageFilter", [], sideeffects=False),
    StdMethod(HRESULT, "PushEmptyStorageFilter", [], sideeffects=False),
    StdMethod(HRESULT, "PushCopyOfStorageFilter", [], sideeffects=False),
    StdMethod(HRESULT, "PushStorageFilter", [(Pointer(D3D11_INFO_QUEUE_FILTER), "pFilter")], sideeffects=False),
    StdMethod(Void, "PopStorageFilter", [], sideeffects=False),
    StdMethod(UINT, "GetStorageFilterStackSize", [], sideeffects=False),
    StdMethod(HRESULT, "AddRetrievalFilterEntries", [(Pointer(D3D11_INFO_QUEUE_FILTER), "pFilter")], sideeffects=False),
    StdMethod(HRESULT, "GetRetrievalFilter", [Out(Pointer(D3D11_INFO_QUEUE_FILTER), "pFilter"), Out(Pointer(SIZE_T), "pFilterByteLength")], sideeffects=False),
    StdMethod(Void, "ClearRetrievalFilter", [], sideeffects=False),
    StdMethod(HRESULT, "PushEmptyRetrievalFilter", [], sideeffects=False),
    StdMethod(HRESULT, "PushCopyOfRetrievalFilter", [], sideeffects=False),
    StdMethod(HRESULT, "PushRetrievalFilter", [(Pointer(D3D11_INFO_QUEUE_FILTER), "pFilter")], sideeffects=False),
    StdMethod(Void, "PopRetrievalFilter", [], sideeffects=False),
    StdMethod(UINT, "GetRetrievalFilterStackSize", [], sideeffects=False),
    StdMethod(HRESULT, "AddMessage", [(D3D11_MESSAGE_CATEGORY, "Category"), (D3D11_MESSAGE_SEVERITY, "Severity"), (D3D11_MESSAGE_ID, "ID"), (LPCSTR, "pDescription")], sideeffects=False),
    StdMethod(HRESULT, "AddApplicationMessage", [(D3D11_MESSAGE_SEVERITY, "Severity"), (LPCSTR, "pDescription")], sideeffects=False),
    StdMethod(HRESULT, "SetBreakOnCategory", [(D3D11_MESSAGE_CATEGORY, "Category"), (BOOL, "bEnable")], sideeffects=False),
    StdMethod(HRESULT, "SetBreakOnSeverity", [(D3D11_MESSAGE_SEVERITY, "Severity"), (BOOL, "bEnable")], sideeffects=False),
    StdMethod(HRESULT, "SetBreakOnID", [(D3D11_MESSAGE_ID, "ID"), (BOOL, "bEnable")], sideeffects=False),
    StdMethod(BOOL, "GetBreakOnCategory", [(D3D11_MESSAGE_CATEGORY, "Category")], sideeffects=False),
    StdMethod(BOOL, "GetBreakOnSeverity", [(D3D11_MESSAGE_SEVERITY, "Severity")], sideeffects=False),
    StdMethod(BOOL, "GetBreakOnID", [(D3D11_MESSAGE_ID, "ID")], sideeffects=False),
    StdMethod(Void, "SetMuteDebugOutput", [(BOOL, "bMute")], sideeffects=False),
    StdMethod(BOOL, "GetMuteDebugOutput", [], sideeffects=False),
]


########NEW FILE########
__FILENAME__ = d3d11shader
##########################################################################
#
# Copyright 2012 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from d3dcommon import *


ID3D11ShaderReflectionType = Interface("ID3D11ShaderReflectionType", IUnknown)
ID3D11ShaderReflectionVariable = Interface("ID3D11ShaderReflectionVariable", IUnknown)
ID3D11ShaderReflectionConstantBuffer = Interface("ID3D11ShaderReflectionConstantBuffer", IUnknown)
ID3D11ShaderReflection = Interface("ID3D11ShaderReflection", IUnknown)


D3D11_SHADER_VERSION_TYPE = Enum("D3D11_SHADER_VERSION_TYPE", [
    "D3D11_SHVER_PIXEL_SHADER",
    "D3D11_SHVER_VERTEX_SHADER",
    "D3D11_SHVER_GEOMETRY_SHADER",
    "D3D11_SHVER_HULL_SHADER",
    "D3D11_SHVER_DOMAIN_SHADER",
    "D3D11_SHVER_COMPUTE_SHADER",
])

D3D11_SIGNATURE_PARAMETER_DESC = Struct("D3D11_SIGNATURE_PARAMETER_DESC", [
    (LPCSTR, "SemanticName"),
    (UINT, "SemanticIndex"),
    (UINT, "Register"),
    (D3D_NAME, "SystemValueType"),
    (D3D_REGISTER_COMPONENT_TYPE, "ComponentType"),
    (BYTE, "Mask"),
    (BYTE, "ReadWriteMask"),
    (UINT, "Stream"),
])

D3D11_SHADER_BUFFER_DESC = Struct("D3D11_SHADER_BUFFER_DESC", [
    (LPCSTR, "Name"),
    (D3D_CBUFFER_TYPE, "Type"),
    (UINT, "Variables"),
    (UINT, "Size"),
    (UINT, "uFlags"),
])

D3D11_SHADER_VARIABLE_DESC = Struct("D3D11_SHADER_VARIABLE_DESC", [
    (LPCSTR, "Name"),
    (UINT, "StartOffset"),
    (UINT, "Size"),
    (UINT, "uFlags"),
    (LPVOID, "DefaultValue"),
    (UINT, "StartTexture"),
    (UINT, "TextureSize"),
    (UINT, "StartSampler"),
    (UINT, "SamplerSize"),
])

D3D11_SHADER_TYPE_DESC = Struct("D3D11_SHADER_TYPE_DESC", [
    (D3D_SHADER_VARIABLE_CLASS, "Class"),
    (D3D_SHADER_VARIABLE_TYPE, "Type"),
    (UINT, "Rows"),
    (UINT, "Columns"),
    (UINT, "Elements"),
    (UINT, "Members"),
    (UINT, "Offset"),
    (LPCSTR, "Name"),
])

D3D11_SHADER_DESC = Struct("D3D11_SHADER_DESC", [
    (UINT, "Version"),
    (LPCSTR, "Creator"),
    (UINT, "Flags"),
    (UINT, "ConstantBuffers"),
    (UINT, "BoundResources"),
    (UINT, "InputParameters"),
    (UINT, "OutputParameters"),
    (UINT, "InstructionCount"),
    (UINT, "TempRegisterCount"),
    (UINT, "TempArrayCount"),
    (UINT, "DefCount"),
    (UINT, "DclCount"),
    (UINT, "TextureNormalInstructions"),
    (UINT, "TextureLoadInstructions"),
    (UINT, "TextureCompInstructions"),
    (UINT, "TextureBiasInstructions"),
    (UINT, "TextureGradientInstructions"),
    (UINT, "FloatInstructionCount"),
    (UINT, "IntInstructionCount"),
    (UINT, "UintInstructionCount"),
    (UINT, "StaticFlowControlCount"),
    (UINT, "DynamicFlowControlCount"),
    (UINT, "MacroInstructionCount"),
    (UINT, "ArrayInstructionCount"),
    (UINT, "CutInstructionCount"),
    (UINT, "EmitInstructionCount"),
    (D3D_PRIMITIVE_TOPOLOGY, "GSOutputTopology"),
    (UINT, "GSMaxOutputVertexCount"),
    (D3D_PRIMITIVE, "InputPrimitive"),
    (UINT, "PatchConstantParameters"),
    (UINT, "cGSInstanceCount"),
    (UINT, "cControlPoints"),
    (D3D_TESSELLATOR_OUTPUT_PRIMITIVE, "HSOutputPrimitive"),
    (D3D_TESSELLATOR_PARTITIONING, "HSPartitioning"),
    (D3D_TESSELLATOR_DOMAIN, "TessellatorDomain"),
    (UINT, "cBarrierInstructions"),
    (UINT, "cInterlockedInstructions"),
    (UINT, "cTextureStoreInstructions"),
])

D3D11_SHADER_INPUT_BIND_DESC = Struct("D3D11_SHADER_INPUT_BIND_DESC", [
    (LPCSTR, "Name"),
    (D3D_SHADER_INPUT_TYPE, "Type"),
    (UINT, "BindPoint"),
    (UINT, "BindCount"),
    (UINT, "uFlags"),
    (D3D_RESOURCE_RETURN_TYPE, "ReturnType"),
    (D3D_SRV_DIMENSION, "Dimension"),
    (UINT, "NumSamples"),
])

ID3D11ShaderReflectionType.methods += [
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(D3D11_SHADER_TYPE_DESC), "pDesc")], sideeffects=False),
    StdMethod(ObjPointer(ID3D11ShaderReflectionType), "GetMemberTypeByIndex", [(UINT, "Index")]),
    StdMethod(ObjPointer(ID3D11ShaderReflectionType), "GetMemberTypeByName", [(LPCSTR, "Name")]),
    StdMethod(LPCSTR, "GetMemberTypeName", [(UINT, "Index")], sideeffects=False),
    StdMethod(HRESULT, "IsEqual", [(ObjPointer(ID3D11ShaderReflectionType), "pType")], sideeffects=False),
    StdMethod(ObjPointer(ID3D11ShaderReflectionType), "GetSubType", []),
    StdMethod(ObjPointer(ID3D11ShaderReflectionType), "GetBaseClass", []),
    StdMethod(UINT, "GetNumInterfaces", [], sideeffects=False),
    StdMethod(ObjPointer(ID3D11ShaderReflectionType), "GetInterfaceByIndex", [(UINT, "uIndex")]),
    StdMethod(HRESULT, "IsOfType", [(ObjPointer(ID3D11ShaderReflectionType), "pType")], sideeffects=False),
    StdMethod(HRESULT, "ImplementsInterface", [(ObjPointer(ID3D11ShaderReflectionType), "pBase")], sideeffects=False),
]

ID3D11ShaderReflectionVariable.methods += [
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(D3D11_SHADER_VARIABLE_DESC), "pDesc")], sideeffects=False),
    StdMethod(ObjPointer(ID3D11ShaderReflectionType), "GetType", []),
    StdMethod(ObjPointer(ID3D11ShaderReflectionConstantBuffer), "GetBuffer", []),
    StdMethod(UINT, "GetInterfaceSlot", [(UINT, "uArrayIndex")], sideeffects=False),
]

ID3D11ShaderReflectionConstantBuffer.methods += [
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(D3D11_SHADER_BUFFER_DESC), "pDesc")], sideeffects=False),
    StdMethod(ObjPointer(ID3D11ShaderReflectionVariable), "GetVariableByIndex", [(UINT, "Index")]),
    StdMethod(ObjPointer(ID3D11ShaderReflectionVariable), "GetVariableByName", [(LPCSTR, "Name")]),
]

ID3D11ShaderReflection.methods += [
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(D3D11_SHADER_DESC), "pDesc")]),
    StdMethod(ObjPointer(ID3D11ShaderReflectionConstantBuffer), "GetConstantBufferByIndex", [(UINT, "Index")]),
    StdMethod(ObjPointer(ID3D11ShaderReflectionConstantBuffer), "GetConstantBufferByName", [(LPCSTR, "Name")]),
    StdMethod(HRESULT, "GetResourceBindingDesc", [(UINT, "ResourceIndex"), Out(Pointer(D3D11_SHADER_INPUT_BIND_DESC), "pDesc")]),
    StdMethod(HRESULT, "GetInputParameterDesc", [(UINT, "ParameterIndex"), Out(Pointer(D3D11_SIGNATURE_PARAMETER_DESC), "pDesc")]),
    StdMethod(HRESULT, "GetOutputParameterDesc", [(UINT, "ParameterIndex"), Out(Pointer(D3D11_SIGNATURE_PARAMETER_DESC), "pDesc")]),
    StdMethod(HRESULT, "GetPatchConstantParameterDesc", [(UINT, "ParameterIndex"), Out(Pointer(D3D11_SIGNATURE_PARAMETER_DESC), "pDesc")]),
    StdMethod(ObjPointer(ID3D11ShaderReflectionVariable), "GetVariableByName", [(LPCSTR, "Name")]),
    StdMethod(HRESULT, "GetResourceBindingDescByName", [(LPCSTR, "Name"), Out(Pointer(D3D11_SHADER_INPUT_BIND_DESC), "pDesc")]),
    StdMethod(UINT, "GetMovInstructionCount", [], sideeffects=False),
    StdMethod(UINT, "GetMovcInstructionCount", [], sideeffects=False),
    StdMethod(UINT, "GetConversionInstructionCount", [], sideeffects=False),
    StdMethod(UINT, "GetBitwiseInstructionCount", [], sideeffects=False),
    StdMethod(D3D_PRIMITIVE, "GetGSInputPrimitive", [], sideeffects=False),
    StdMethod(BOOL, "IsSampleFrequencyShader", [], sideeffects=False),
    StdMethod(UINT, "GetNumInterfaceSlots", [], sideeffects=False),
    StdMethod(HRESULT, "GetMinFeatureLevel", [Out(Pointer(D3D_FEATURE_LEVEL), "pLevel")]),
    StdMethod(UINT, "GetThreadGroupSize", [Out(Pointer(UINT), "pSizeX"), Out(Pointer(UINT), "pSizeY"), Out(Pointer(UINT), "pSizeZ")], sideeffects=False),
]


########NEW FILE########
__FILENAME__ = d3d11_1
##########################################################################
#
# Copyright 2012 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""d3d11_1.h"""


from winapi import *
from d3d11sdklayers import *
from d3d11 import *

import dxgi1_2

D3D_FEATURE_LEVEL.values += [
    "D3D_FEATURE_LEVEL_11_1",
]

D3D11_CREATE_DEVICE_FLAG.values += [
    "D3D11_CREATE_DEVICE_DEBUGGABLE",
    "D3D11_CREATE_DEVICE_PREVENT_ALTERING_LAYER_SETTINGS_FROM_REGISTRY",
    "D3D11_CREATE_DEVICE_DISABLE_GPU_TIMEOUT",
    "D3D11_CREATE_DEVICE_VIDEO_SUPPORT",
]

D3D_MIN_PRECISION = Enum("D3D_MIN_PRECISION", [
    "D3D_MIN_PRECISION_DEFAULT",
    "D3D_MIN_PRECISION_FLOAT_16",
    "D3D_MIN_PRECISION_FLOAT_2_8",
    "D3D_MIN_PRECISION_RESERVED",
    "D3D_MIN_PRECISION_SINT_16",
    "D3D_MIN_PRECISION_UINT_16",
    "D3D_MIN_PRECISION_ANY_16",
    "D3D_MIN_PRECISION_ANY_10",
])

ID3D11BlendState1 = Interface("ID3D11BlendState1", ID3D11BlendState)
ID3D11RasterizerState1 = Interface("ID3D11RasterizerState1", ID3D11RasterizerState)
ID3DDeviceContextState = Interface("ID3DDeviceContextState", ID3D11DeviceChild)
ID3D11DeviceContext1 = Interface("ID3D11DeviceContext1", ID3D11DeviceContext)
ID3D11Device1 = Interface("ID3D11Device1", ID3D11Device)
ID3DUserDefinedAnnotation = Interface("ID3DUserDefinedAnnotation", IUnknown)


D3D11_COPY_FLAGS = Flags(UINT, [
    "D3D11_COPY_NO_OVERWRITE",
    "D3D11_COPY_DISCARD",
])

D3D11_LOGIC_OP = Enum("D3D11_LOGIC_OP", [
    "D3D11_LOGIC_OP_CLEAR",
    "D3D11_LOGIC_OP_SET",
    "D3D11_LOGIC_OP_COPY",
    "D3D11_LOGIC_OP_COPY_INVERTED",
    "D3D11_LOGIC_OP_NOOP",
    "D3D11_LOGIC_OP_INVERT",
    "D3D11_LOGIC_OP_AND",
    "D3D11_LOGIC_OP_NAND",
    "D3D11_LOGIC_OP_OR",
    "D3D11_LOGIC_OP_NOR",
    "D3D11_LOGIC_OP_XOR",
    "D3D11_LOGIC_OP_EQUIV",
    "D3D11_LOGIC_OP_AND_REVERSE",
    "D3D11_LOGIC_OP_AND_INVERTED",
    "D3D11_LOGIC_OP_OR_REVERSE",
    "D3D11_LOGIC_OP_OR_INVERTED",
])

D3D11_RENDER_TARGET_BLEND_DESC1 = Struct("D3D11_RENDER_TARGET_BLEND_DESC1", [
    (BOOL, "BlendEnable"),
    (BOOL, "LogicOpEnable"),
    (D3D11_BLEND, "SrcBlend"),
    (D3D11_BLEND, "DestBlend"),
    (D3D11_BLEND_OP, "BlendOp"),
    (D3D11_BLEND, "SrcBlendAlpha"),
    (D3D11_BLEND, "DestBlendAlpha"),
    (D3D11_BLEND_OP, "BlendOpAlpha"),
    (D3D11_LOGIC_OP, "LogicOp"),
    (UINT8, "RenderTargetWriteMask"),
])

D3D11_BLEND_DESC1 = Struct("D3D11_BLEND_DESC1", [
    (BOOL, "AlphaToCoverageEnable"),
    (BOOL, "IndependentBlendEnable"),
    (Array(D3D11_RENDER_TARGET_BLEND_DESC1, "D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT"), "RenderTarget"),
])

ID3D11BlendState1.methods += [
    StdMethod(Void, "GetDesc1", [Out(Pointer(D3D11_BLEND_DESC1), "pDesc")], sideeffects=False),
]

D3D11_RASTERIZER_DESC1 = Struct("D3D11_RASTERIZER_DESC1", [
    (D3D11_FILL_MODE, "FillMode"),
    (D3D11_CULL_MODE, "CullMode"),
    (BOOL, "FrontCounterClockwise"),
    (INT, "DepthBias"),
    (FLOAT, "DepthBiasClamp"),
    (FLOAT, "SlopeScaledDepthBias"),
    (BOOL, "DepthClipEnable"),
    (BOOL, "ScissorEnable"),
    (BOOL, "MultisampleEnable"),
    (BOOL, "AntialiasedLineEnable"),
    (UINT, "ForcedSampleCount"),
])

ID3D11RasterizerState1.methods += [
    StdMethod(Void, "GetDesc1", [Out(Pointer(D3D11_RASTERIZER_DESC1), "pDesc")], sideeffects=False),
]

D3D11_1_CREATE_DEVICE_CONTEXT_STATE_FLAG = Flags(UINT, [
    "D3D11_1_CREATE_DEVICE_CONTEXT_STATE_SINGLETHREADED",
])

ID3D11DeviceContext1.methods += [
    StdMethod(Void, "CopySubresourceRegion1", [(ObjPointer(ID3D11Resource), "pDstResource"), (UINT, "DstSubresource"), (UINT, "DstX"), (UINT, "DstY"), (UINT, "DstZ"), (ObjPointer(ID3D11Resource), "pSrcResource"), (UINT, "SrcSubresource"), (Pointer(Const(D3D11_BOX)), "pSrcBox"), (D3D11_COPY_FLAGS, "CopyFlags")]),
    StdMethod(Void, "UpdateSubresource1", [(ObjPointer(ID3D11Resource), "pDstResource"), (UINT, "DstSubresource"), (Pointer(Const(D3D11_BOX)), "pDstBox"), (Blob(Const(Void), "_calcSubresourceSize(pDstResource, DstSubresource, pDstBox, SrcRowPitch, SrcDepthPitch)"), "pSrcData"), (UINT, "SrcRowPitch"), (UINT, "SrcDepthPitch"), (D3D11_COPY_FLAGS, "CopyFlags")]),
    StdMethod(Void, "DiscardResource", [(ObjPointer(ID3D11Resource), "pResource")]),
    StdMethod(Void, "DiscardView", [(ObjPointer(ID3D11View), "pResourceView")]),
    StdMethod(Void, "DiscardView1", [(ObjPointer(ID3D11View), "pResourceView"), (Array(Const(D3D11_RECT), "NumRects"), "pRect"), (UINT, "NumRects")]),
    StdMethod(Void, "VSSetConstantBuffers1", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppConstantBuffers"), (Array(Const(UINT), "NumBuffers"), "pFirstConstant"), (Array(Const(UINT), "NumBuffers"), "pNumConstants")]),
    StdMethod(Void, "HSSetConstantBuffers1", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppConstantBuffers"), (Array(Const(UINT), "NumBuffers"), "pFirstConstant"), (Array(Const(UINT), "NumBuffers"), "pNumConstants")]),
    StdMethod(Void, "DSSetConstantBuffers1", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppConstantBuffers"), (Array(Const(UINT), "NumBuffers"), "pFirstConstant"), (Array(Const(UINT), "NumBuffers"), "pNumConstants")]),
    StdMethod(Void, "GSSetConstantBuffers1", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppConstantBuffers"), (Array(Const(UINT), "NumBuffers"), "pFirstConstant"), (Array(Const(UINT), "NumBuffers"), "pNumConstants")]),
    StdMethod(Void, "PSSetConstantBuffers1", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppConstantBuffers"), (Array(Const(UINT), "NumBuffers"), "pFirstConstant"), (Array(Const(UINT), "NumBuffers"), "pNumConstants")]),
    StdMethod(Void, "CSSetConstantBuffers1", [(UINT, "StartSlot"), (UINT, "NumBuffers"), (Array(Const(ObjPointer(ID3D11Buffer)), "NumBuffers"), "ppConstantBuffers"), (Array(Const(UINT), "NumBuffers"), "pFirstConstant"), (Array(Const(UINT), "NumBuffers"), "pNumConstants")]),
    StdMethod(Void, "VSGetConstantBuffers1", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppConstantBuffers"), Out(Array(UINT, "NumBuffers"), "pFirstConstant"), Out(Array(UINT, "NumBuffers"), "pNumConstants")]),
    StdMethod(Void, "HSGetConstantBuffers1", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppConstantBuffers"), Out(Array(UINT, "NumBuffers"), "pFirstConstant"), Out(Array(UINT, "NumBuffers"), "pNumConstants")]),
    StdMethod(Void, "DSGetConstantBuffers1", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppConstantBuffers"), Out(Array(UINT, "NumBuffers"), "pFirstConstant"), Out(Array(UINT, "NumBuffers"), "pNumConstants")]),
    StdMethod(Void, "GSGetConstantBuffers1", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppConstantBuffers"), Out(Array(UINT, "NumBuffers"), "pFirstConstant"), Out(Array(UINT, "NumBuffers"), "pNumConstants")]),
    StdMethod(Void, "PSGetConstantBuffers1", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppConstantBuffers"), Out(Array(UINT, "NumBuffers"), "pFirstConstant"), Out(Array(UINT, "NumBuffers"), "pNumConstants")]),
    StdMethod(Void, "CSGetConstantBuffers1", [(UINT, "StartSlot"), (UINT, "NumBuffers"), Out(Array(ObjPointer(ID3D11Buffer), "NumBuffers"), "ppConstantBuffers"), Out(Array(UINT, "NumBuffers"), "pFirstConstant"), Out(Array(UINT, "NumBuffers"), "pNumConstants")]),
    StdMethod(Void, "SwapDeviceContextState", [(ObjPointer(ID3DDeviceContextState), "pState"), Out(Pointer(ObjPointer(ID3DDeviceContextState)), "ppPreviousState")]),
    StdMethod(Void, "ClearView", [(ObjPointer(ID3D11View), "pView"), (Array(Const(FLOAT), 4), "Color"), (Pointer(Const(D3D11_RECT)), "pRect"), (UINT, "NumRects")]),
]


ID3D11Device1.methods += [
    StdMethod(Void, "GetImmediateContext1", [Out(Pointer(ObjPointer(ID3D11DeviceContext1)), "ppImmediateContext")]),
    StdMethod(HRESULT, "CreateDeferredContext1", [(UINT, "ContextFlags"), Out(Pointer(ObjPointer(ID3D11DeviceContext1)), "ppDeferredContext")]),
    StdMethod(HRESULT, "CreateBlendState1", [(Pointer(Const(D3D11_BLEND_DESC1)), "pBlendStateDesc"), Out(Pointer(ObjPointer(ID3D11BlendState1)), "ppBlendState")]),
    StdMethod(HRESULT, "CreateRasterizerState1", [(Pointer(Const(D3D11_RASTERIZER_DESC1)), "pRasterizerDesc"), Out(Pointer(ObjPointer(ID3D11RasterizerState1)), "ppRasterizerState")]),
    StdMethod(HRESULT, "CreateDeviceContextState", [(D3D11_1_CREATE_DEVICE_CONTEXT_STATE_FLAG, "Flags"), (Array(Const(D3D_FEATURE_LEVEL), "FeatureLevels"), "pFeatureLevels"), (UINT, "FeatureLevels"), (UINT, "SDKVersion"), (REFIID, "EmulatedInterface"), Out(Pointer(D3D_FEATURE_LEVEL), "pChosenFeatureLevel"), Out(Pointer(ObjPointer(ID3DDeviceContextState)), "ppContextState")]),
    StdMethod(HRESULT, "OpenSharedResource1", [(HANDLE, "hResource"), (REFIID, "returnedInterface"), Out(Pointer(ObjPointer(Void)), "ppResource")]),
    StdMethod(HRESULT, "OpenSharedResourceByName", [(LPCWSTR, "lpName"), (DXGI_SHARED_RESOURCE_FLAG, "dwDesiredAccess"), (REFIID, "returnedInterface"), Out(Pointer(ObjPointer(Void)), "ppResource")]),
]

ID3DUserDefinedAnnotation.methods += [
    StdMethod(INT, "BeginEvent", [(LPCWSTR, "Name")], sideeffects=False),
    StdMethod(INT, "EndEvent", [], sideeffects=False),
    StdMethod(Void, "SetMarker", [(LPCWSTR, "Name")], sideeffects=False),
    StdMethod(BOOL, "GetStatus", [], sideeffects=False),
]

d3d11.addInterfaces([
    ID3D11Device1,
    ID3DUserDefinedAnnotation,
])

########NEW FILE########
__FILENAME__ = d3d8
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""d3d8.h"""

from winapi import *
from d3d8types import *
from d3d8caps import *


D3DSHADER8 = Blob(Const(DWORD), "_shaderSize(pFunction)")

D3DSPD = Flags(DWORD, [
    "D3DSPD_IUNKNOWN",
])

D3DADAPTER = FakeEnum(UINT, [
    "D3DADAPTER_DEFAULT",
])

D3DENUM = FakeEnum(DWORD, [
    "D3DENUM_NO_WHQL_LEVEL",
])

D3DSGR = Flags(DWORD, [
    "D3DSGR_NO_CALIBRATION",
    "D3DSGR_CALIBRATE",
])

D3DCURSOR = Flags(DWORD, [
    "D3DCURSOR_IMMEDIATE_UPDATE",
])

HRESULT = MAKE_HRESULT(ok = "D3D_OK", errors = [
    "D3DERR_WRONGTEXTUREFORMAT",
    "D3DERR_UNSUPPORTEDCOLOROPERATION",
    "D3DERR_UNSUPPORTEDCOLORARG",
    "D3DERR_UNSUPPORTEDALPHAOPERATION",
    "D3DERR_UNSUPPORTEDALPHAARG",
    "D3DERR_TOOMANYOPERATIONS",
    "D3DERR_CONFLICTINGTEXTUREFILTER",
    "D3DERR_UNSUPPORTEDFACTORVALUE",
    "D3DERR_CONFLICTINGRENDERSTATE",
    "D3DERR_UNSUPPORTEDTEXTUREFILTER",
    "D3DERR_CONFLICTINGTEXTUREPALETTE",
    "D3DERR_DRIVERINTERNALERROR",
    "D3DERR_NOTFOUND",
    "D3DERR_MOREDATA",
    "D3DERR_DEVICELOST",
    "D3DERR_DEVICENOTRESET",
    "D3DERR_NOTAVAILABLE",
    "D3DERR_OUTOFVIDEOMEMORY",
    "D3DERR_INVALIDDEVICE",
    "D3DERR_INVALIDCALL",
    "D3DERR_DRIVERINVALIDCALL",
])

IDirect3D8 = Interface("IDirect3D8", IUnknown)
IDirect3DDevice8 = Interface("IDirect3DDevice8", IUnknown)
IDirect3DSwapChain8 = Interface("IDirect3DSwapChain8", IUnknown)
IDirect3DResource8 = Interface("IDirect3DResource8", IUnknown)
IDirect3DBaseTexture8 = Interface("IDirect3DBaseTexture8", IDirect3DResource8)
IDirect3DTexture8 = Interface("IDirect3DTexture8", IDirect3DBaseTexture8)
IDirect3DVolumeTexture8 = Interface("IDirect3DVolumeTexture8", IDirect3DBaseTexture8)
IDirect3DCubeTexture8 = Interface("IDirect3DCubeTexture8", IDirect3DBaseTexture8)
IDirect3DVertexBuffer8 = Interface("IDirect3DVertexBuffer8", IDirect3DResource8)
IDirect3DIndexBuffer8 = Interface("IDirect3DIndexBuffer8", IDirect3DResource8)
IDirect3DSurface8 = Interface("IDirect3DSurface8", IUnknown)
IDirect3DVolume8 = Interface("IDirect3DVolume8", IUnknown)

PDIRECT3D8 = ObjPointer(IDirect3D8)
PDIRECT3DDEVICE8 = ObjPointer(IDirect3DDevice8)
PDIRECT3DSWAPCHAIN8 = ObjPointer(IDirect3DSwapChain8)
PDIRECT3DRESOURCE8 = ObjPointer(IDirect3DResource8)
PDIRECT3DBASETEXTURE8 = ObjPointer(IDirect3DBaseTexture8)
PDIRECT3DTEXTURE8 = ObjPointer(IDirect3DTexture8)
PDIRECT3DVOLUMETEXTURE8 = ObjPointer(IDirect3DVolumeTexture8)
PDIRECT3DCUBETEXTURE8 = ObjPointer(IDirect3DCubeTexture8)
PDIRECT3DVERTEXBUFFER8 = ObjPointer(IDirect3DVertexBuffer8)
PDIRECT3DINDEXBUFFER8 = ObjPointer(IDirect3DIndexBuffer8)
PDIRECT3DSURFACE8 = ObjPointer(IDirect3DSurface8)
PDIRECT3DVOLUME8 = ObjPointer(IDirect3DVolume8)

IDirect3D8.methods += [
    StdMethod(HRESULT, "RegisterSoftwareDevice", [(OpaquePointer(Void), "pInitializeFunction")], sideeffects=False),
    StdMethod(UINT, "GetAdapterCount", [], sideeffects=False),
    StdMethod(HRESULT, "GetAdapterIdentifier", [(D3DADAPTER, "Adapter"), (D3DENUM, "Flags"), Out(Pointer(D3DADAPTER_IDENTIFIER8), "pIdentifier")], sideeffects=False),
    StdMethod(UINT, "GetAdapterModeCount", [(D3DADAPTER, "Adapter")], sideeffects=False),
    StdMethod(HRESULT, "EnumAdapterModes", [(D3DADAPTER, "Adapter"), (UINT, "Mode"), Out(Pointer(D3DDISPLAYMODE), "pMode")], sideeffects=False),
    StdMethod(HRESULT, "GetAdapterDisplayMode", [(D3DADAPTER, "Adapter"), Out(Pointer(D3DDISPLAYMODE), "pMode")], sideeffects=False),
    StdMethod(HRESULT, "CheckDeviceType", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "CheckType"), (D3DFORMAT, "DisplayFormat"), (D3DFORMAT, "BackBufferFormat"), (BOOL, "Windowed")], sideeffects=False),
    StdMethod(HRESULT, "CheckDeviceFormat", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "DeviceType"), (D3DFORMAT, "AdapterFormat"), (D3DUSAGE, "Usage"), (D3DRESOURCETYPE, "RType"), (D3DFORMAT, "CheckFormat")], sideeffects=False),
    StdMethod(HRESULT, "CheckDeviceMultiSampleType", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "DeviceType"), (D3DFORMAT, "SurfaceFormat"), (BOOL, "Windowed"), (D3DMULTISAMPLE_TYPE, "MultiSampleType")], sideeffects=False),
    StdMethod(HRESULT, "CheckDepthStencilMatch", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "DeviceType"), (D3DFORMAT, "AdapterFormat"), (D3DFORMAT, "RenderTargetFormat"), (D3DFORMAT, "DepthStencilFormat")], sideeffects=False),
    StdMethod(HRESULT, "GetDeviceCaps", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "DeviceType"), Out(Pointer(D3DCAPS8), "pCaps")], sideeffects=False),
    StdMethod(HMONITOR, "GetAdapterMonitor", [(D3DADAPTER, "Adapter")], sideeffects=False),
    StdMethod(HRESULT, "CreateDevice", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "DeviceType"), (HWND, "hFocusWindow"), (D3DCREATE, "BehaviorFlags"), InOut(Pointer(D3DPRESENT_PARAMETERS), "pPresentationParameters"), Out(Pointer(PDIRECT3DDEVICE8), "ppReturnedDeviceInterface")]),
]

IDirect3DDevice8.methods += [
    StdMethod(HRESULT, "TestCooperativeLevel", []),
    StdMethod(UINT, "GetAvailableTextureMem", [], sideeffects=False),
    StdMethod(HRESULT, "ResourceManagerDiscardBytes", [(DWORD, "Bytes")]),
    StdMethod(HRESULT, "GetDirect3D", [Out(Pointer(PDIRECT3D8), "ppD3D8")]),
    StdMethod(HRESULT, "GetDeviceCaps", [Out(Pointer(D3DCAPS8), "pCaps")], sideeffects=False),
    StdMethod(HRESULT, "GetDisplayMode", [Out(Pointer(D3DDISPLAYMODE), "pMode")], sideeffects=False),
    StdMethod(HRESULT, "GetCreationParameters", [Out(Pointer(D3DDEVICE_CREATION_PARAMETERS), "pParameters")], sideeffects=False),
    StdMethod(HRESULT, "SetCursorProperties", [(UINT, "XHotSpot"), (UINT, "YHotSpot"), (PDIRECT3DSURFACE8, "pCursorBitmap")]),
    # XXX: There are different signatures of
    # IDirect3DDevice8::SetCursorPosition depending on the DXSDK version
    #StdMethod(Void, "SetCursorPosition", [(UINT, "XScreenSpace"), (UINT, "YScreenSpace"), (D3DCURSOR, "Flags")]),
    StdMethod(Void, "SetCursorPosition", [(Int, "X"), (Int, "Y"), (D3DCURSOR, "Flags")]),
    StdMethod(BOOL, "ShowCursor", [(BOOL, "bShow")]),
    StdMethod(HRESULT, "CreateAdditionalSwapChain", [InOut(Pointer(D3DPRESENT_PARAMETERS), "pPresentationParameters"), Out(Pointer(PDIRECT3DSWAPCHAIN8), "pSwapChain")]),
    StdMethod(HRESULT, "Reset", [InOut(Pointer(D3DPRESENT_PARAMETERS), "pPresentationParameters")]),
    StdMethod(HRESULT, "Present", [(ConstPointer(RECT), "pSourceRect"), (ConstPointer(RECT), "pDestRect"), (HWND, "hDestWindowOverride"), (ConstPointer(RGNDATA), "pDirtyRegion")]),
    StdMethod(HRESULT, "GetBackBuffer", [(UINT, "BackBuffer"), (D3DBACKBUFFER_TYPE, "Type"), Out(Pointer(PDIRECT3DSURFACE8), "ppBackBuffer")]),
    StdMethod(HRESULT, "GetRasterStatus", [Out(Pointer(D3DRASTER_STATUS), "pRasterStatus")], sideeffects=False),
    StdMethod(Void, "SetGammaRamp", [(D3DSGR, "Flags"), (ConstPointer(D3DGAMMARAMP), "pRamp")]),
    StdMethod(Void, "GetGammaRamp", [Out(Pointer(D3DGAMMARAMP), "pRamp")], sideeffects=False),
    StdMethod(HRESULT, "CreateTexture", [(UINT, "Width"), (UINT, "Height"), (UINT, "Levels"), (D3DUSAGE, "Usage"), (D3DFORMAT, "Format"), (D3DPOOL, "Pool"), Out(Pointer(PDIRECT3DTEXTURE8), "ppTexture")]),
    StdMethod(HRESULT, "CreateVolumeTexture", [(UINT, "Width"), (UINT, "Height"), (UINT, "Depth"), (UINT, "Levels"), (D3DUSAGE, "Usage"), (D3DFORMAT, "Format"), (D3DPOOL, "Pool"), Out(Pointer(PDIRECT3DVOLUMETEXTURE8), "ppVolumeTexture")]),
    StdMethod(HRESULT, "CreateCubeTexture", [(UINT, "EdgeLength"), (UINT, "Levels"), (D3DUSAGE, "Usage"), (D3DFORMAT, "Format"), (D3DPOOL, "Pool"), Out(Pointer(PDIRECT3DCUBETEXTURE8), "ppCubeTexture")]),
    StdMethod(HRESULT, "CreateVertexBuffer", [(UINT, "Length"), (D3DUSAGE, "Usage"), (D3DFVF, "FVF"), (D3DPOOL, "Pool"), Out(Pointer(PDIRECT3DVERTEXBUFFER8), "ppVertexBuffer")]),
    StdMethod(HRESULT, "CreateIndexBuffer", [(UINT, "Length"), (D3DUSAGE, "Usage"), (D3DFORMAT, "Format"), (D3DPOOL, "Pool"), Out(Pointer(PDIRECT3DINDEXBUFFER8), "ppIndexBuffer")]),
    StdMethod(HRESULT, "CreateRenderTarget", [(UINT, "Width"), (UINT, "Height"), (D3DFORMAT, "Format"), (D3DMULTISAMPLE_TYPE, "MultiSample"), (BOOL, "Lockable"), Out(Pointer(PDIRECT3DSURFACE8), "ppSurface")]),
    StdMethod(HRESULT, "CreateDepthStencilSurface", [(UINT, "Width"), (UINT, "Height"), (D3DFORMAT, "Format"), (D3DMULTISAMPLE_TYPE, "MultiSample"), Out(Pointer(PDIRECT3DSURFACE8), "ppSurface")]),
    StdMethod(HRESULT, "CreateImageSurface", [(UINT, "Width"), (UINT, "Height"), (D3DFORMAT, "Format"), Out(Pointer(PDIRECT3DSURFACE8), "ppSurface")]),
    StdMethod(HRESULT, "CopyRects", [(PDIRECT3DSURFACE8, "pSourceSurface"), (ConstPointer(RECT), "pSourceRectsArray"), (UINT, "cRects"), (PDIRECT3DSURFACE8, "pDestinationSurface"), (ConstPointer(POINT), "pDestPointsArray")]),
    StdMethod(HRESULT, "UpdateTexture", [(PDIRECT3DBASETEXTURE8, "pSourceTexture"), (PDIRECT3DBASETEXTURE8, "pDestinationTexture")]),
    StdMethod(HRESULT, "GetFrontBuffer", [(PDIRECT3DSURFACE8, "pDestSurface")]),
    StdMethod(HRESULT, "SetRenderTarget", [(PDIRECT3DSURFACE8, "pRenderTarget"), (PDIRECT3DSURFACE8, "pNewZStencil")]),
    StdMethod(HRESULT, "GetRenderTarget", [Out(Pointer(PDIRECT3DSURFACE8), "ppRenderTarget")]),
    StdMethod(HRESULT, "GetDepthStencilSurface", [Out(Pointer(PDIRECT3DSURFACE8), "ppZStencilSurface")]),
    StdMethod(HRESULT, "BeginScene", []),
    StdMethod(HRESULT, "EndScene", []),
    StdMethod(HRESULT, "Clear", [(DWORD, "Count"), (ConstPointer(D3DRECT), "pRects"), (D3DCLEAR, "Flags"), (D3DCOLOR, "Color"), (Float, "Z"), (DWORD, "Stencil")]),
    StdMethod(HRESULT, "SetTransform", [(D3DTRANSFORMSTATETYPE, "State"), (ConstPointer(D3DMATRIX), "pMatrix")]),
    StdMethod(HRESULT, "GetTransform", [(D3DTRANSFORMSTATETYPE, "State"), Out(Pointer(D3DMATRIX), "pMatrix")], sideeffects=False),
    StdMethod(HRESULT, "MultiplyTransform", [(D3DTRANSFORMSTATETYPE, "State"), (ConstPointer(D3DMATRIX), "pMatrix")]),
    StdMethod(HRESULT, "SetViewport", [(ConstPointer(D3DVIEWPORT8), "pViewport")]),
    StdMethod(HRESULT, "GetViewport", [Out(Pointer(D3DVIEWPORT8), "pViewport")], sideeffects=False),
    StdMethod(HRESULT, "SetMaterial", [(ConstPointer(D3DMATERIAL8), "pMaterial")]),
    StdMethod(HRESULT, "GetMaterial", [Out(Pointer(D3DMATERIAL8), "pMaterial")], sideeffects=False),
    StdMethod(HRESULT, "SetLight", [(DWORD, "Index"), (ConstPointer(D3DLIGHT8), "pLight")]),
    StdMethod(HRESULT, "GetLight", [(DWORD, "Index"), Out(Pointer(D3DLIGHT8), "pLight")], sideeffects=False),
    StdMethod(HRESULT, "LightEnable", [(DWORD, "Index"), (BOOL, "Enable")]),
    StdMethod(HRESULT, "GetLightEnable", [(DWORD, "Index"), Out(Pointer(BOOL), "pEnable")], sideeffects=False),
    StdMethod(HRESULT, "SetClipPlane", [(DWORD, "Index"), (ConstPointer(Float), "pPlane")]),
    StdMethod(HRESULT, "GetClipPlane", [(DWORD, "Index"), Out(Pointer(Float), "pPlane")], sideeffects=False),
    StdMethod(HRESULT, "SetRenderState", [(D3DRENDERSTATETYPE, "State"), (D3DRENDERSTATEVALUE, "Value")]),
    StdMethod(HRESULT, "GetRenderState", [(D3DRENDERSTATETYPE, "State"), Out(Pointer(D3DRENDERSTATEVALUE), "pValue")], sideeffects=False),
    StdMethod(HRESULT, "BeginStateBlock", []),
    StdMethod(HRESULT, "EndStateBlock", [Out(Pointer(DWORD), "pToken")]),
    StdMethod(HRESULT, "ApplyStateBlock", [(DWORD, "Token")]),
    StdMethod(HRESULT, "CaptureStateBlock", [(DWORD, "Token")]),
    StdMethod(HRESULT, "DeleteStateBlock", [(DWORD, "Token")]),
    StdMethod(HRESULT, "CreateStateBlock", [(D3DSTATEBLOCKTYPE, "Type"), Out(Pointer(DWORD), "pToken")]),
    StdMethod(HRESULT, "SetClipStatus", [(ConstPointer(D3DCLIPSTATUS8), "pClipStatus")]),
    StdMethod(HRESULT, "GetClipStatus", [Out(Pointer(D3DCLIPSTATUS8), "pClipStatus")], sideeffects=False),
    StdMethod(HRESULT, "GetTexture", [(DWORD, "Stage"), Out(Pointer(PDIRECT3DBASETEXTURE8), "ppTexture")]),
    StdMethod(HRESULT, "SetTexture", [(DWORD, "Stage"), (PDIRECT3DBASETEXTURE8, "pTexture")]),
    StdMethod(HRESULT, "GetTextureStageState", [(DWORD, "Stage"), (D3DTEXTURESTAGESTATETYPE, "Type"), Out(Pointer(D3DTEXTURESTAGESTATEVALUE), "pValue")], sideeffects=False),
    StdMethod(HRESULT, "SetTextureStageState", [(DWORD, "Stage"), (D3DTEXTURESTAGESTATETYPE, "Type"), (D3DTEXTURESTAGESTATEVALUE, "Value")]),
    StdMethod(HRESULT, "ValidateDevice", [Out(Pointer(DWORD), "pNumPasses")]),
    StdMethod(HRESULT, "GetInfo", [(D3DDEVINFOID, "DevInfoID"), Out(OpaqueBlob(Void, "DevInfoStructSize"), "pDevInfoStruct"), (DWORD, "DevInfoStructSize")], sideeffects=False),
    StdMethod(HRESULT, "SetPaletteEntries", [(UINT, "PaletteNumber"), (ConstPointer(PALETTEENTRY), "pEntries")]),
    StdMethod(HRESULT, "GetPaletteEntries", [(UINT, "PaletteNumber"), Out(Pointer(PALETTEENTRY), "pEntries")], sideeffects=False),
    StdMethod(HRESULT, "SetCurrentTexturePalette", [(UINT, "PaletteNumber")]),
    StdMethod(HRESULT, "GetCurrentTexturePalette", [Out(Pointer(UINT), "PaletteNumber")], sideeffects=False),
    StdMethod(HRESULT, "DrawPrimitive", [(D3DPRIMITIVETYPE, "PrimitiveType"), (UINT, "StartVertex"), (UINT, "PrimitiveCount")]),
    StdMethod(HRESULT, "DrawIndexedPrimitive", [(D3DPRIMITIVETYPE, "PrimitiveType"), (UINT, "minIndex"), (UINT, "NumVertices"), (UINT, "startIndex"), (UINT, "primCount")]),
    StdMethod(HRESULT, "DrawPrimitiveUP", [(D3DPRIMITIVETYPE, "PrimitiveType"), (UINT, "PrimitiveCount"), (Blob(Const(Void), "_vertexDataSize(PrimitiveType, PrimitiveCount, VertexStreamZeroStride)"), "pVertexStreamZeroData"), (UINT, "VertexStreamZeroStride")]),
    StdMethod(HRESULT, "DrawIndexedPrimitiveUP", [(D3DPRIMITIVETYPE, "PrimitiveType"), (UINT, "MinVertexIndex"), (UINT, "NumVertexIndices"), (UINT, "PrimitiveCount"), (Blob(Const(Void), "_indexDataSize(PrimitiveType, PrimitiveCount, IndexDataFormat)"), "pIndexData"), (D3DFORMAT, "IndexDataFormat"), (Blob(Const(Void), "NumVertexIndices*VertexStreamZeroStride"), "pVertexStreamZeroData"), (UINT, "VertexStreamZeroStride")]),
    StdMethod(HRESULT, "ProcessVertices", [(UINT, "SrcStartIndex"), (UINT, "DestIndex"), (UINT, "VertexCount"), (PDIRECT3DVERTEXBUFFER8, "pDestBuffer"), (D3DPV, "Flags")]),
    StdMethod(HRESULT, "CreateVertexShader", [(Array(Const(DWORD), "_declCount(pDeclaration)"), "pDeclaration"), (D3DSHADER8, "pFunction"), Out(Pointer(DWORD), "pHandle"), (D3DUSAGE, "Usage")]),
    StdMethod(HRESULT, "SetVertexShader", [(DWORD, "Handle")]),
    StdMethod(HRESULT, "GetVertexShader", [Out(Pointer(DWORD), "pHandle")], sideeffects=False),
    StdMethod(HRESULT, "DeleteVertexShader", [(DWORD, "Handle")]),
    StdMethod(HRESULT, "SetVertexShaderConstant", [(DWORD, "Register"), (Blob(Const(Void), "ConstantCount*4*sizeof(float)"), "pConstantData"), (DWORD, "ConstantCount")]),
    StdMethod(HRESULT, "GetVertexShaderConstant", [(DWORD, "Register"), Out(OpaqueBlob(Void, "ConstantCount*4*sizeof(float)"), "pConstantData"), (DWORD, "ConstantCount")], sideeffects=False),
    StdMethod(HRESULT, "GetVertexShaderDeclaration", [(DWORD, "Handle"), Out(OpaqueBlob(Void, "*pSizeOfData"), "pData"), Out(Pointer(DWORD), "pSizeOfData")], sideeffects=False),
    StdMethod(HRESULT, "GetVertexShaderFunction", [(DWORD, "Handle"), Out(OpaqueBlob(Void, "*pSizeOfData"), "pData"), Out(Pointer(DWORD), "pSizeOfData")], sideeffects=False),
    StdMethod(HRESULT, "SetStreamSource", [(UINT, "StreamNumber"), (PDIRECT3DVERTEXBUFFER8, "pStreamData"), (UINT, "Stride")]),
    StdMethod(HRESULT, "GetStreamSource", [(UINT, "StreamNumber"), Out(Pointer(PDIRECT3DVERTEXBUFFER8), "ppStreamData"), Out(Pointer(UINT), "pStride")]),
    StdMethod(HRESULT, "SetIndices", [(PDIRECT3DINDEXBUFFER8, "pIndexData"), (UINT, "BaseVertexIndex")]),
    StdMethod(HRESULT, "GetIndices", [Out(Pointer(PDIRECT3DINDEXBUFFER8), "ppIndexData"), Out(Pointer(UINT), "pBaseVertexIndex")]),
    StdMethod(HRESULT, "CreatePixelShader", [(D3DSHADER8, "pFunction"), Out(Pointer(DWORD), "pHandle")]),
    StdMethod(HRESULT, "SetPixelShader", [(DWORD, "Handle")]),
    StdMethod(HRESULT, "GetPixelShader", [Out(Pointer(DWORD), "pHandle")], sideeffects=False),
    StdMethod(HRESULT, "DeletePixelShader", [(DWORD, "Handle")]),
    StdMethod(HRESULT, "SetPixelShaderConstant", [(DWORD, "Register"), (Blob(Const(Void), "ConstantCount*4*sizeof(float)"), "pConstantData"), (DWORD, "ConstantCount")]),
    StdMethod(HRESULT, "GetPixelShaderConstant", [(DWORD, "Register"), Out(OpaqueBlob(Void, "ConstantCount*4*sizeof(float)"), "pConstantData"), (DWORD, "ConstantCount")], sideeffects=False),
    StdMethod(HRESULT, "GetPixelShaderFunction", [(DWORD, "Handle"), Out(OpaqueBlob(Void, "*pSizeOfData"), "pData"), Out(Pointer(DWORD), "pSizeOfData")], sideeffects=False),
    StdMethod(HRESULT, "DrawRectPatch", [(UINT, "Handle"), (ConstPointer(Float), "pNumSegs"), (ConstPointer(D3DRECTPATCH_INFO), "pRectPatchInfo")]),
    StdMethod(HRESULT, "DrawTriPatch", [(UINT, "Handle"), (ConstPointer(Float), "pNumSegs"), (ConstPointer(D3DTRIPATCH_INFO), "pTriPatchInfo")]),
    StdMethod(HRESULT, "DeletePatch", [(UINT, "Handle")]),
]

IDirect3DSwapChain8.methods += [
    StdMethod(HRESULT, "Present", [(ConstPointer(RECT), "pSourceRect"), (ConstPointer(RECT), "pDestRect"), (HWND, "hDestWindowOverride"), (ConstPointer(RGNDATA), "pDirtyRegion")]),
    StdMethod(HRESULT, "GetBackBuffer", [(UINT, "BackBuffer"), (D3DBACKBUFFER_TYPE, "Type"), Out(Pointer(PDIRECT3DSURFACE8), "ppBackBuffer")]),
]

IDirect3DResource8.methods += [
    StdMethod(HRESULT, "GetDevice", [Out(Pointer(PDIRECT3DDEVICE8), "ppDevice")]),
    StdMethod(HRESULT, "SetPrivateData", [(REFGUID, "refguid"), (OpaqueBlob(Const(Void), "SizeOfData"), "pData"), (DWORD, "SizeOfData"), (D3DSPD, "Flags")], sideeffects=False),
    StdMethod(HRESULT, "GetPrivateData", [(REFGUID, "refguid"), Out(OpaqueBlob(Void, "*pSizeOfData"), "pData"), Out(Pointer(DWORD), "pSizeOfData")], sideeffects=False),
    StdMethod(HRESULT, "FreePrivateData", [(REFGUID, "refguid")], sideeffects=False),
    StdMethod(DWORD, "SetPriority", [(DWORD, "PriorityNew")]),
    StdMethod(DWORD, "GetPriority", [], sideeffects=False),
    StdMethod(Void, "PreLoad", []),
    StdMethod(D3DRESOURCETYPE, "GetType", [], sideeffects=False),
]

IDirect3DBaseTexture8.methods += [
    StdMethod(DWORD, "SetLOD", [(DWORD, "LODNew")]),
    StdMethod(DWORD, "GetLOD", [], sideeffects=False),
    StdMethod(DWORD, "GetLevelCount", [], sideeffects=False),
]

IDirect3DTexture8.methods += [
    StdMethod(HRESULT, "GetLevelDesc", [(UINT, "Level"), Out(Pointer(D3DSURFACE_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "GetSurfaceLevel", [(UINT, "Level"), Out(Pointer(PDIRECT3DSURFACE8), "ppSurfaceLevel")]),
    StdMethod(HRESULT, "LockRect", [(UINT, "Level"), Out(Pointer(D3DLOCKED_RECT), "pLockedRect"), (ConstPointer(RECT), "pRect"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "UnlockRect", [(UINT, "Level")]),
    StdMethod(HRESULT, "AddDirtyRect", [(ConstPointer(RECT), "pDirtyRect")]),
]

IDirect3DVolumeTexture8.methods += [
    StdMethod(HRESULT, "GetLevelDesc", [(UINT, "Level"), Out(Pointer(D3DVOLUME_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "GetVolumeLevel", [(UINT, "Level"), Out(Pointer(PDIRECT3DVOLUME8), "ppVolumeLevel")]),
    StdMethod(HRESULT, "LockBox", [(UINT, "Level"), Out(Pointer(D3DLOCKED_BOX), "pLockedVolume"), (ConstPointer(D3DBOX), "pBox"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "UnlockBox", [(UINT, "Level")]),
    StdMethod(HRESULT, "AddDirtyBox", [(ConstPointer(D3DBOX), "pDirtyBox")]),
]

IDirect3DCubeTexture8.methods += [
    StdMethod(HRESULT, "GetLevelDesc", [(UINT, "Level"), Out(Pointer(D3DSURFACE_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "GetCubeMapSurface", [(D3DCUBEMAP_FACES, "FaceType"), (UINT, "Level"), Out(Pointer(PDIRECT3DSURFACE8), "ppCubeMapSurface")]),
    StdMethod(HRESULT, "LockRect", [(D3DCUBEMAP_FACES, "FaceType"), (UINT, "Level"), Out(Pointer(D3DLOCKED_RECT), "pLockedRect"), (ConstPointer(RECT), "pRect"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "UnlockRect", [(D3DCUBEMAP_FACES, "FaceType"), (UINT, "Level")]),
    StdMethod(HRESULT, "AddDirtyRect", [(D3DCUBEMAP_FACES, "FaceType"), (ConstPointer(RECT), "pDirtyRect")]),
]

IDirect3DVertexBuffer8.methods += [
    StdMethod(HRESULT, "Lock", [(UINT, "OffsetToLock"), (UINT, "SizeToLock"), Out(Pointer(LinearPointer(BYTE, "_MappedSize")), "ppbData"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "Unlock", []),
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(D3DVERTEXBUFFER_DESC), "pDesc")], sideeffects=False),
]

IDirect3DIndexBuffer8.methods += [
    StdMethod(HRESULT, "Lock", [(UINT, "OffsetToLock"), (UINT, "SizeToLock"), Out(Pointer(LinearPointer(BYTE, "_MappedSize")), "ppbData"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "Unlock", []),
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(D3DINDEXBUFFER_DESC), "pDesc")], sideeffects=False),
]

IDirect3DSurface8.methods += [
    StdMethod(HRESULT, "GetDevice", [Out(Pointer(PDIRECT3DDEVICE8), "ppDevice")]),
    StdMethod(HRESULT, "SetPrivateData", [(REFGUID, "refguid"), (OpaqueBlob(Const(Void), "SizeOfData"), "pData"), (DWORD, "SizeOfData"), (D3DSPD, "Flags")], sideeffects=False),
    StdMethod(HRESULT, "GetPrivateData", [(REFGUID, "refguid"), Out(OpaqueBlob(Void, "*pSizeOfData"), "pData"), Out(Pointer(DWORD), "pSizeOfData")], sideeffects=False),
    StdMethod(HRESULT, "FreePrivateData", [(REFGUID, "refguid")], sideeffects=False),
    StdMethod(HRESULT, "GetContainer", [(REFIID, "riid"), Out(Pointer(ObjPointer(Void)), "ppContainer")]),
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(D3DSURFACE_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "LockRect", [Out(Pointer(D3DLOCKED_RECT), "pLockedRect"), (ConstPointer(RECT), "pRect"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "UnlockRect", []),
]

IDirect3DVolume8.methods += [
    StdMethod(HRESULT, "GetDevice", [Out(Pointer(PDIRECT3DDEVICE8), "ppDevice")]),
    StdMethod(HRESULT, "SetPrivateData", [(REFGUID, "refguid"), (OpaqueBlob(Const(Void), "SizeOfData"), "pData"), (DWORD, "SizeOfData"), (D3DSPD, "Flags")], sideeffects=False),
    StdMethod(HRESULT, "GetPrivateData", [(REFGUID, "refguid"), Out(OpaqueBlob(Void, "*pSizeOfData"), "pData"), Out(Pointer(DWORD), "pSizeOfData")], sideeffects=False),
    StdMethod(HRESULT, "FreePrivateData", [(REFGUID, "refguid")], sideeffects=False),
    StdMethod(HRESULT, "GetContainer", [(REFIID, "riid"), Out(Pointer(ObjPointer(Void)), "ppContainer")]),
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(D3DVOLUME_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "LockBox", [Out(Pointer(D3DLOCKED_BOX), "pLockedVolume"), (ConstPointer(D3DBOX), "pBox"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "UnlockBox", []),
]

d3d8 = Module("d3d8")
d3d8.addFunctions([
    StdFunction(PDIRECT3D8, "Direct3DCreate8", [(UINT, "SDKVersion")]),
])

########NEW FILE########
__FILENAME__ = d3d8caps
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""d3d8caps.h"""

from winapi import *
from d3d8types import *

D3DCAPS = Flags(DWORD, [
    "D3DCAPS_READ_SCANLINE",
])

D3DCAPS2 = Flags(DWORD, [
    "D3DCAPS2_NO2DDURING3DSCENE",
    "D3DCAPS2_FULLSCREENGAMMA",
    "D3DCAPS2_CANRENDERWINDOWED",
    "D3DCAPS2_CANCALIBRATEGAMMA",
    "D3DCAPS2_RESERVED",
    "D3DCAPS2_CANMANAGERESOURCE",
    "D3DCAPS2_DYNAMICTEXTURES",
])

D3DCAPS3 = Flags(DWORD, [
    "D3DCAPS3_RESERVED",
    "D3DCAPS3_ALPHA_FULLSCREEN_FLIP_OR_DISCARD",
])

D3DCURSORCAPS = Flags(DWORD, [
    "D3DCURSORCAPS_COLOR",
    "D3DCURSORCAPS_LOWRES",
])

D3DDEVCAPS = Flags(DWORD, [
    "D3DDEVCAPS_EXECUTESYSTEMMEMORY",
    "D3DDEVCAPS_EXECUTEVIDEOMEMORY",
    "D3DDEVCAPS_TLVERTEXSYSTEMMEMORY",
    "D3DDEVCAPS_TLVERTEXVIDEOMEMORY",
    "D3DDEVCAPS_TEXTURESYSTEMMEMORY",
    "D3DDEVCAPS_TEXTUREVIDEOMEMORY",
    "D3DDEVCAPS_DRAWPRIMTLVERTEX",
    "D3DDEVCAPS_CANRENDERAFTERFLIP",
    "D3DDEVCAPS_TEXTURENONLOCALVIDMEM",
    "D3DDEVCAPS_DRAWPRIMITIVES2",
    "D3DDEVCAPS_SEPARATETEXTUREMEMORIES",
    "D3DDEVCAPS_DRAWPRIMITIVES2EX",
    "D3DDEVCAPS_HWTRANSFORMANDLIGHT",
    "D3DDEVCAPS_CANBLTSYSTONONLOCAL",
    "D3DDEVCAPS_HWRASTERIZATION",
    "D3DDEVCAPS_PUREDEVICE",
    "D3DDEVCAPS_QUINTICRTPATCHES",
    "D3DDEVCAPS_RTPATCHES",
    "D3DDEVCAPS_RTPATCHHANDLEZERO",
    "D3DDEVCAPS_NPATCHES",
])

D3DPMISCCAPS = Flags(DWORD, [
    "D3DPMISCCAPS_MASKZ",
    "D3DPMISCCAPS_LINEPATTERNREP",
    "D3DPMISCCAPS_CULLNONE",
    "D3DPMISCCAPS_CULLCW",
    "D3DPMISCCAPS_CULLCCW",
    "D3DPMISCCAPS_COLORWRITEENABLE",
    "D3DPMISCCAPS_CLIPPLANESCALEDPOINTS",
    "D3DPMISCCAPS_CLIPTLVERTS",
    "D3DPMISCCAPS_TSSARGTEMP",
    "D3DPMISCCAPS_BLENDOP",
    "D3DPMISCCAPS_NULLREFERENCE",
])

D3DLINECAPS = Flags(DWORD, [
    "D3DLINECAPS_TEXTURE",
    "D3DLINECAPS_ZTEST",
    "D3DLINECAPS_BLEND",
    "D3DLINECAPS_ALPHACMP",
    "D3DLINECAPS_FOG",
])

D3DPRASTERCAPS = Flags(DWORD, [
    "D3DPRASTERCAPS_DITHER",
    "D3DPRASTERCAPS_PAT",
    "D3DPRASTERCAPS_ZTEST",
    "D3DPRASTERCAPS_FOGVERTEX",
    "D3DPRASTERCAPS_FOGTABLE",
    "D3DPRASTERCAPS_ANTIALIASEDGES",
    "D3DPRASTERCAPS_MIPMAPLODBIAS",
    "D3DPRASTERCAPS_ZBIAS",
    "D3DPRASTERCAPS_ZBUFFERLESSHSR",
    "D3DPRASTERCAPS_FOGRANGE",
    "D3DPRASTERCAPS_ANISOTROPY",
    "D3DPRASTERCAPS_WBUFFER",
    "D3DPRASTERCAPS_WFOG",
    "D3DPRASTERCAPS_ZFOG",
    "D3DPRASTERCAPS_COLORPERSPECTIVE",
    "D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE",
])

D3DPCMPCAPS = Flags(DWORD, [
    "D3DPCMPCAPS_NEVER",
    "D3DPCMPCAPS_LESS",
    "D3DPCMPCAPS_EQUAL",
    "D3DPCMPCAPS_LESSEQUAL",
    "D3DPCMPCAPS_GREATER",
    "D3DPCMPCAPS_NOTEQUAL",
    "D3DPCMPCAPS_GREATEREQUAL",
    "D3DPCMPCAPS_ALWAYS",
])

D3DPBLENDCAPS = Flags(DWORD, [
    "D3DPBLENDCAPS_ZERO",
    "D3DPBLENDCAPS_ONE",
    "D3DPBLENDCAPS_SRCCOLOR",
    "D3DPBLENDCAPS_INVSRCCOLOR",
    "D3DPBLENDCAPS_SRCALPHA",
    "D3DPBLENDCAPS_INVSRCALPHA",
    "D3DPBLENDCAPS_DESTALPHA",
    "D3DPBLENDCAPS_INVDESTALPHA",
    "D3DPBLENDCAPS_DESTCOLOR",
    "D3DPBLENDCAPS_INVDESTCOLOR",
    "D3DPBLENDCAPS_SRCALPHASAT",
    "D3DPBLENDCAPS_BOTHSRCALPHA",
    "D3DPBLENDCAPS_BOTHINVSRCALPHA",
])

D3DPSHADECAPS = Flags(DWORD, [
    "D3DPSHADECAPS_COLORGOURAUDRGB",
    "D3DPSHADECAPS_SPECULARGOURAUDRGB",
    "D3DPSHADECAPS_ALPHAGOURAUDBLEND",
    "D3DPSHADECAPS_FOGGOURAUD",
])

D3DPTEXTURECAPS = Flags(DWORD, [
    "D3DPTEXTURECAPS_PERSPECTIVE",
    "D3DPTEXTURECAPS_POW2",
    "D3DPTEXTURECAPS_ALPHA",
    "D3DPTEXTURECAPS_SQUAREONLY",
    "D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE",
    "D3DPTEXTURECAPS_ALPHAPALETTE",
    "D3DPTEXTURECAPS_NONPOW2CONDITIONAL",
    "D3DPTEXTURECAPS_PROJECTED",
    "D3DPTEXTURECAPS_CUBEMAP",
    "D3DPTEXTURECAPS_VOLUMEMAP",
    "D3DPTEXTURECAPS_MIPMAP",
    "D3DPTEXTURECAPS_MIPVOLUMEMAP",
    "D3DPTEXTURECAPS_MIPCUBEMAP",
    "D3DPTEXTURECAPS_CUBEMAP_POW2",
    "D3DPTEXTURECAPS_VOLUMEMAP_POW2",
])

D3DPTFILTERCAPS = Flags(DWORD, [
    "D3DPTFILTERCAPS_MINFPOINT",
    "D3DPTFILTERCAPS_MINFLINEAR",
    "D3DPTFILTERCAPS_MINFANISOTROPIC",
    "D3DPTFILTERCAPS_MIPFPOINT",
    "D3DPTFILTERCAPS_MIPFLINEAR",
    "D3DPTFILTERCAPS_MAGFPOINT",
    "D3DPTFILTERCAPS_MAGFLINEAR",
    "D3DPTFILTERCAPS_MAGFANISOTROPIC",
    "D3DPTFILTERCAPS_MAGFAFLATCUBIC",
    "D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC",
])

D3DPTADDRESSCAPS = Flags(DWORD, [
    "D3DPTADDRESSCAPS_WRAP",
    "D3DPTADDRESSCAPS_MIRROR",
    "D3DPTADDRESSCAPS_CLAMP",
    "D3DPTADDRESSCAPS_BORDER",
    "D3DPTADDRESSCAPS_INDEPENDENTUV",
    "D3DPTADDRESSCAPS_MIRRORONCE",
])

D3DSTENCILCAPS = Flags(DWORD, [
    "D3DSTENCILCAPS_KEEP",
    "D3DSTENCILCAPS_ZERO",
    "D3DSTENCILCAPS_REPLACE",
    "D3DSTENCILCAPS_INCRSAT",
    "D3DSTENCILCAPS_DECRSAT",
    "D3DSTENCILCAPS_INVERT",
    "D3DSTENCILCAPS_INCR",
    "D3DSTENCILCAPS_DECR",
])

D3DTEXOPCAPS = Flags(DWORD, [
    "D3DTEXOPCAPS_DISABLE",
    "D3DTEXOPCAPS_SELECTARG1",
    "D3DTEXOPCAPS_SELECTARG2",
    "D3DTEXOPCAPS_MODULATE",
    "D3DTEXOPCAPS_MODULATE2X",
    "D3DTEXOPCAPS_MODULATE4X",
    "D3DTEXOPCAPS_ADD",
    "D3DTEXOPCAPS_ADDSIGNED",
    "D3DTEXOPCAPS_ADDSIGNED2X",
    "D3DTEXOPCAPS_SUBTRACT",
    "D3DTEXOPCAPS_ADDSMOOTH",
    "D3DTEXOPCAPS_BLENDDIFFUSEALPHA",
    "D3DTEXOPCAPS_BLENDTEXTUREALPHA",
    "D3DTEXOPCAPS_BLENDFACTORALPHA",
    "D3DTEXOPCAPS_BLENDTEXTUREALPHAPM",
    "D3DTEXOPCAPS_BLENDCURRENTALPHA",
    "D3DTEXOPCAPS_PREMODULATE",
    "D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR",
    "D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA",
    "D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR",
    "D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA",
    "D3DTEXOPCAPS_BUMPENVMAP",
    "D3DTEXOPCAPS_BUMPENVMAPLUMINANCE",
    "D3DTEXOPCAPS_DOTPRODUCT3",
    "D3DTEXOPCAPS_MULTIPLYADD",
    "D3DTEXOPCAPS_LERP",
])

D3DFVFCAPS = Flags(DWORD, [
    "D3DFVFCAPS_TEXCOORDCOUNTMASK",
    "D3DFVFCAPS_DONOTSTRIPELEMENTS",
    "D3DFVFCAPS_PSIZE",
])

D3DVTXPCAPS = Flags(DWORD, [
    "D3DVTXPCAPS_TEXGEN",
    "D3DVTXPCAPS_MATERIALSOURCE7",
    "D3DVTXPCAPS_DIRECTIONALLIGHTS",
    "D3DVTXPCAPS_POSITIONALLIGHTS",
    "D3DVTXPCAPS_LOCALVIEWER",
    "D3DVTXPCAPS_TWEENING",
    "D3DVTXPCAPS_NO_VSDT_UBYTE4",
])

#D3DPS_VERSION = Enum("DWORD", [
#    "D3DPS_VERSION(0,0)",
#    "D3DPS_VERSION(1,0)",
#    "D3DPS_VERSION(1,1)",
#    "D3DPS_VERSION(1,2)",
#    "D3DPS_VERSION(1,3)",
#    "D3DPS_VERSION(1,4)",
#    "D3DPS_VERSION(2,0)",
#    "D3DPS_VERSION(3,0)",
#])
D3DPS_VERSION = DWORD

#D3DVS_VERSION = Enum("DWORD", [
#    "D3DVS_VERSION(0,0)",
#    "D3DVS_VERSION(1,0)",
#    "D3DVS_VERSION(1,1)",
#    "D3DVS_VERSION(2,0)",
#    "D3DVS_VERSION(3,0)",
#])
D3DVS_VERSION = DWORD

D3DCAPS8 = Struct("D3DCAPS8", [
    (D3DDEVTYPE, "DeviceType"),
    (UINT, "AdapterOrdinal"),
    (D3DCAPS, "Caps"),
    (D3DCAPS2, "Caps2"),
    (D3DCAPS3, "Caps3"),
    (D3DPRESENT_INTERVAL, "PresentationIntervals"),
    (D3DCURSORCAPS, "CursorCaps"),
    (D3DDEVCAPS, "DevCaps"),
    (D3DPMISCCAPS, "PrimitiveMiscCaps"),
    (D3DPRASTERCAPS, "RasterCaps"),
    (D3DPCMPCAPS, "ZCmpCaps"),
    (D3DPBLENDCAPS, "SrcBlendCaps"),
    (D3DPBLENDCAPS, "DestBlendCaps"),
    (D3DPCMPCAPS, "AlphaCmpCaps"),
    (D3DPSHADECAPS, "ShadeCaps"),
    (D3DPTEXTURECAPS, "TextureCaps"),
    (D3DPTFILTERCAPS, "TextureFilterCaps"),
    (D3DPTFILTERCAPS, "CubeTextureFilterCaps"),
    (D3DPTFILTERCAPS, "VolumeTextureFilterCaps"),
    (D3DPTADDRESSCAPS, "TextureAddressCaps"),
    (D3DPTADDRESSCAPS, "VolumeTextureAddressCaps"),
    (D3DLINECAPS, "LineCaps"),
    (DWORD, "MaxTextureWidth"),
    (DWORD, "MaxTextureHeight"),
    (DWORD, "MaxVolumeExtent"),
    (DWORD, "MaxTextureRepeat"),
    (DWORD, "MaxTextureAspectRatio"),
    (DWORD, "MaxAnisotropy"),
    (Float, "MaxVertexW"),
    (Float, "GuardBandLeft"),
    (Float, "GuardBandTop"),
    (Float, "GuardBandRight"),
    (Float, "GuardBandBottom"),
    (Float, "ExtentsAdjust"),
    (D3DSTENCILCAPS, "StencilCaps"),
    (D3DFVFCAPS, "FVFCaps"),
    (D3DTEXOPCAPS, "TextureOpCaps"),
    (DWORD, "MaxTextureBlendStages"),
    (DWORD, "MaxSimultaneousTextures"),
    (D3DVTXPCAPS, "VertexProcessingCaps"),
    (DWORD, "MaxActiveLights"),
    (DWORD, "MaxUserClipPlanes"),
    (DWORD, "MaxVertexBlendMatrices"),
    (DWORD, "MaxVertexBlendMatrixIndex"),
    (Float, "MaxPointSize"),
    (DWORD, "MaxPrimitiveCount"),
    (DWORD, "MaxVertexIndex"),
    (DWORD, "MaxStreams"),
    (DWORD, "MaxStreamStride"),
    (D3DVS_VERSION, "VertexShaderVersion"),
    (DWORD, "MaxVertexShaderConst"),
    (D3DPS_VERSION, "PixelShaderVersion"),
    (Float, "MaxPixelShaderValue"),
])


########NEW FILE########
__FILENAME__ = d3d8types
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""d3d8types.h"""

from winapi import *

D3DCOLOR = Alias("D3DCOLOR", DWORD)

D3DVECTOR = Struct("D3DVECTOR", [
    (Float, "x"),
    (Float, "y"),
    (Float, "z"),
])

D3DCOLORVALUE = Struct("D3DCOLORVALUE", [
    (Float, "r"),
    (Float, "g"),
    (Float, "b"),
    (Float, "a"),
])

D3DRECT = Struct("D3DRECT", [
    (LONG, "x1"),
    (LONG, "y1"),
    (LONG, "x2"),
    (LONG, "y2"),
])

D3DMATRIX = Struct("D3DMATRIX", [
    (Array(Array(Float, 4), "4"), "m"),
])

D3DVIEWPORT8 = Struct("D3DVIEWPORT8", [
    (DWORD, "X"),
    (DWORD, "Y"),
    (DWORD, "Width"),
    (DWORD, "Height"),
    (Float, "MinZ"),
    (Float, "MaxZ"),
])

D3DCLIPPLANE = Flags(DWORD, [
    "D3DCLIPPLANE0",
    "D3DCLIPPLANE1",
    "D3DCLIPPLANE2",
    "D3DCLIPPLANE3",
    "D3DCLIPPLANE4",
    "D3DCLIPPLANE5",
])

D3DCS = Flags(DWORD, [
    "D3DCS_ALL",
    "D3DCS_LEFT",
    "D3DCS_RIGHT",
    "D3DCS_TOP",
    "D3DCS_BOTTOM",
    "D3DCS_FRONT",
    "D3DCS_BACK",
    "D3DCS_PLANE0",
    "D3DCS_PLANE1",
    "D3DCS_PLANE2",
    "D3DCS_PLANE3",
    "D3DCS_PLANE4",
    "D3DCS_PLANE5",
])

D3DCLIPSTATUS8 = Struct("D3DCLIPSTATUS8", [
    (DWORD, "ClipUnion"),
    (DWORD, "ClipIntersection"),
])

D3DMATERIAL8 = Struct("D3DMATERIAL8", [
    (D3DCOLORVALUE, "Diffuse"),
    (D3DCOLORVALUE, "Ambient"),
    (D3DCOLORVALUE, "Specular"),
    (D3DCOLORVALUE, "Emissive"),
    (Float, "Power"),
])

D3DLIGHTTYPE = Enum("D3DLIGHTTYPE", [
    "D3DLIGHT_POINT",
    "D3DLIGHT_SPOT",
    "D3DLIGHT_DIRECTIONAL",
])

D3DLIGHT8 = Struct("D3DLIGHT8", [
    (D3DLIGHTTYPE, "Type"),
    (D3DCOLORVALUE, "Diffuse"),
    (D3DCOLORVALUE, "Specular"),
    (D3DCOLORVALUE, "Ambient"),
    (D3DVECTOR, "Position"),
    (D3DVECTOR, "Direction"),
    (Float, "Range"),
    (Float, "Falloff"),
    (Float, "Attenuation0"),
    (Float, "Attenuation1"),
    (Float, "Attenuation2"),
    (Float, "Theta"),
    (Float, "Phi"),
])

D3DCLEAR = Flags(DWORD, [
    "D3DCLEAR_TARGET",
    "D3DCLEAR_ZBUFFER",
    "D3DCLEAR_STENCIL",
])

D3DSHADEMODE = Enum("D3DSHADEMODE", [
    "D3DSHADE_FLAT",
    "D3DSHADE_GOURAUD",
    "D3DSHADE_PHONG",
])

D3DFILLMODE = Enum("D3DFILLMODE", [
    "D3DFILL_POINT",
    "D3DFILL_WIREFRAME",
    "D3DFILL_SOLID",
])

D3DLINEPATTERN = Struct("D3DLINEPATTERN", [
    (WORD, "wRepeatFactor"),
    (WORD, "wLinePattern"),
])

D3DBLEND = Enum("D3DBLEND", [
    "D3DBLEND_ZERO",
    "D3DBLEND_ONE",
    "D3DBLEND_SRCCOLOR",
    "D3DBLEND_INVSRCCOLOR",
    "D3DBLEND_SRCALPHA",
    "D3DBLEND_INVSRCALPHA",
    "D3DBLEND_DESTALPHA",
    "D3DBLEND_INVDESTALPHA",
    "D3DBLEND_DESTCOLOR",
    "D3DBLEND_INVDESTCOLOR",
    "D3DBLEND_SRCALPHASAT",
    "D3DBLEND_BOTHSRCALPHA",
    "D3DBLEND_BOTHINVSRCALPHA",
])

D3DBLENDOP = Enum("D3DBLENDOP", [
    "D3DBLENDOP_ADD",
    "D3DBLENDOP_SUBTRACT",
    "D3DBLENDOP_REVSUBTRACT",
    "D3DBLENDOP_MIN",
    "D3DBLENDOP_MAX",
])

D3DTEXTUREADDRESS = Enum("D3DTEXTUREADDRESS", [
    "D3DTADDRESS_WRAP",
    "D3DTADDRESS_MIRROR",
    "D3DTADDRESS_CLAMP",
    "D3DTADDRESS_BORDER",
    "D3DTADDRESS_MIRRORONCE",
])

D3DCULL = Enum("D3DCULL", [
    "D3DCULL_NONE",
    "D3DCULL_CW",
    "D3DCULL_CCW",
])

D3DCMPFUNC = Enum("D3DCMPFUNC", [
    "D3DCMP_NEVER",
    "D3DCMP_LESS",
    "D3DCMP_EQUAL",
    "D3DCMP_LESSEQUAL",
    "D3DCMP_GREATER",
    "D3DCMP_NOTEQUAL",
    "D3DCMP_GREATEREQUAL",
    "D3DCMP_ALWAYS",
])

D3DSTENCILOP = Enum("D3DSTENCILOP", [
    "D3DSTENCILOP_KEEP",
    "D3DSTENCILOP_ZERO",
    "D3DSTENCILOP_REPLACE",
    "D3DSTENCILOP_INCRSAT",
    "D3DSTENCILOP_DECRSAT",
    "D3DSTENCILOP_INVERT",
    "D3DSTENCILOP_INCR",
    "D3DSTENCILOP_DECR",
])

D3DFOGMODE = Enum("D3DFOGMODE", [
    "D3DFOG_NONE",
    "D3DFOG_EXP",
    "D3DFOG_EXP2",
    "D3DFOG_LINEAR",
])

D3DZBUFFERTYPE = Enum("D3DZBUFFERTYPE", [
    "D3DZB_FALSE",
    "D3DZB_TRUE",
    "D3DZB_USEW",
])

D3DPRIMITIVETYPE = Enum("D3DPRIMITIVETYPE", [
    "D3DPT_POINTLIST",
    "D3DPT_LINELIST",
    "D3DPT_LINESTRIP",
    "D3DPT_TRIANGLELIST",
    "D3DPT_TRIANGLESTRIP",
    "D3DPT_TRIANGLEFAN",
])

D3DTRANSFORMSTATETYPE = Enum("D3DTRANSFORMSTATETYPE", [
    "D3DTS_VIEW",
    "D3DTS_PROJECTION",
    "D3DTS_TEXTURE0",
    "D3DTS_TEXTURE1",
    "D3DTS_TEXTURE2",
    "D3DTS_TEXTURE3",
    "D3DTS_TEXTURE4",
    "D3DTS_TEXTURE5",
    "D3DTS_TEXTURE6",
    "D3DTS_TEXTURE7",
    "D3DTS_WORLD",
    "D3DTS_WORLD1",
    "D3DTS_WORLD2",
    "D3DTS_WORLD3",
])

D3DMATERIALCOLORSOURCE = Enum("D3DMATERIALCOLORSOURCE", [
    "D3DMCS_MATERIAL",
    "D3DMCS_COLOR1",
    "D3DMCS_COLOR2",
])

D3DWRAPCOORD = Flags(DWORD, [
    "D3DWRAPCOORD_0",
    "D3DWRAPCOORD_1",
    "D3DWRAPCOORD_2",
    "D3DWRAPCOORD_3",
])

D3DCOLORWRITEENABLE = Flags(DWORD, [
    "D3DCOLORWRITEENABLE_RED",
    "D3DCOLORWRITEENABLE_GREEN",
    "D3DCOLORWRITEENABLE_BLUE",
    "D3DCOLORWRITEENABLE_ALPHA",
])

D3DORDERTYPE = Enum("D3DORDERTYPE", [
    "D3DORDER_LINEAR",
    "D3DORDER_QUADRATIC",
    "D3DORDER_CUBIC",
    "D3DORDER_QUINTIC",
])

D3DPATCHEDGESTYLE = Enum("D3DPATCHEDGESTYLE", [
    "D3DPATCHEDGE_DISCRETE",
    "D3DPATCHEDGE_CONTINUOUS",
])

D3DVERTEXBLENDFLAGS = Enum("D3DVERTEXBLENDFLAGS", [
    "D3DVBF_DISABLE",
    "D3DVBF_1WEIGHTS",
    "D3DVBF_2WEIGHTS",
    "D3DVBF_3WEIGHTS",
    "D3DVBF_TWEENING",
    "D3DVBF_0WEIGHTS",
])

D3DDEBUGMONITORTOKENS = Enum("D3DDEBUGMONITORTOKENS", [
    "D3DDMT_ENABLE",
    "D3DDMT_DISABLE",
])

# TODO: Convert these to/from actual floats
FLOAT_AS_DWORD = DWORD

D3DRENDERSTATETYPE, D3DRENDERSTATEVALUE = EnumPolymorphic("D3DRENDERSTATETYPE", "State", [
    ("D3DRS_ZENABLE", D3DZBUFFERTYPE),
    ("D3DRS_FILLMODE", D3DFILLMODE),
    ("D3DRS_SHADEMODE", D3DSHADEMODE),
    ("D3DRS_LINEPATTERN", DWORD), # D3DLINEPATTERN
    ("D3DRS_ZWRITEENABLE", BOOL),
    ("D3DRS_ALPHATESTENABLE", BOOL),
    ("D3DRS_LASTPIXEL", BOOL),
    ("D3DRS_SRCBLEND", D3DBLEND),
    ("D3DRS_DESTBLEND", D3DBLEND),
    ("D3DRS_CULLMODE", D3DCULL),
    ("D3DRS_ZFUNC", D3DCMPFUNC),
    ("D3DRS_ALPHAREF", DWORD),
    ("D3DRS_ALPHAFUNC", D3DCMPFUNC),
    ("D3DRS_DITHERENABLE", BOOL),
    ("D3DRS_ALPHABLENDENABLE", BOOL),
    ("D3DRS_FOGENABLE", BOOL),
    ("D3DRS_SPECULARENABLE", BOOL),
    ("D3DRS_ZVISIBLE", BOOL),
    ("D3DRS_FOGCOLOR", D3DCOLOR),
    ("D3DRS_FOGTABLEMODE", D3DFOGMODE),
    ("D3DRS_FOGSTART", FLOAT_AS_DWORD),
    ("D3DRS_FOGEND", FLOAT_AS_DWORD),
    ("D3DRS_FOGDENSITY", FLOAT_AS_DWORD),
    ("D3DRS_EDGEANTIALIAS", BOOL),
    ("D3DRS_ZBIAS", LONG),
    ("D3DRS_RANGEFOGENABLE", BOOL),
    ("D3DRS_STENCILENABLE", BOOL),
    ("D3DRS_STENCILFAIL", D3DSTENCILOP),
    ("D3DRS_STENCILZFAIL", D3DSTENCILOP),
    ("D3DRS_STENCILPASS", D3DSTENCILOP),
    ("D3DRS_STENCILFUNC", D3DCMPFUNC),
    ("D3DRS_STENCILREF", DWORD),
    ("D3DRS_STENCILMASK", DWORD),
    ("D3DRS_STENCILWRITEMASK", DWORD),
    ("D3DRS_TEXTUREFACTOR", D3DCOLOR),
    ("D3DRS_WRAP0", D3DWRAPCOORD),
    ("D3DRS_WRAP1", D3DWRAPCOORD),
    ("D3DRS_WRAP2", D3DWRAPCOORD),
    ("D3DRS_WRAP3", D3DWRAPCOORD),
    ("D3DRS_WRAP4", D3DWRAPCOORD),
    ("D3DRS_WRAP5", D3DWRAPCOORD),
    ("D3DRS_WRAP6", D3DWRAPCOORD),
    ("D3DRS_WRAP7", D3DWRAPCOORD),
    ("D3DRS_CLIPPING", BOOL),
    ("D3DRS_LIGHTING", BOOL),
    ("D3DRS_AMBIENT", D3DCOLOR),
    ("D3DRS_FOGVERTEXMODE", D3DFOGMODE),
    ("D3DRS_COLORVERTEX", BOOL),
    ("D3DRS_LOCALVIEWER", BOOL),
    ("D3DRS_NORMALIZENORMALS", BOOL),
    ("D3DRS_DIFFUSEMATERIALSOURCE", D3DMATERIALCOLORSOURCE),
    ("D3DRS_SPECULARMATERIALSOURCE", D3DMATERIALCOLORSOURCE),
    ("D3DRS_AMBIENTMATERIALSOURCE", D3DMATERIALCOLORSOURCE),
    ("D3DRS_EMISSIVEMATERIALSOURCE", D3DMATERIALCOLORSOURCE),
    ("D3DRS_VERTEXBLEND", D3DVERTEXBLENDFLAGS),
    ("D3DRS_CLIPPLANEENABLE", D3DCLIPPLANE),
    ("D3DRS_SOFTWAREVERTEXPROCESSING", BOOL),
    ("D3DRS_POINTSIZE", FLOAT_AS_DWORD),
    ("D3DRS_POINTSIZE_MIN", FLOAT_AS_DWORD),
    ("D3DRS_POINTSPRITEENABLE", BOOL),
    ("D3DRS_POINTSCALEENABLE", BOOL),
    ("D3DRS_POINTSCALE_A", FLOAT_AS_DWORD),
    ("D3DRS_POINTSCALE_B", FLOAT_AS_DWORD),
    ("D3DRS_POINTSCALE_C", FLOAT_AS_DWORD),
    ("D3DRS_MULTISAMPLEANTIALIAS", BOOL),
    ("D3DRS_MULTISAMPLEMASK", DWORD),
    ("D3DRS_PATCHEDGESTYLE", D3DPATCHEDGESTYLE),
    ("D3DRS_PATCHSEGMENTS", DWORD),
    ("D3DRS_DEBUGMONITORTOKEN", D3DDEBUGMONITORTOKENS),
    ("D3DRS_POINTSIZE_MAX", FLOAT_AS_DWORD),
    ("D3DRS_INDEXEDVERTEXBLENDENABLE", BOOL),
    ("D3DRS_COLORWRITEENABLE", DWORD),
    ("D3DRS_TWEENFACTOR", FLOAT_AS_DWORD),
    ("D3DRS_BLENDOP", D3DBLENDOP),
    ("D3DRS_POSITIONORDER", D3DORDERTYPE),
    ("D3DRS_NORMALORDER", D3DORDERTYPE),

    # XXX: D3DRENDERSTATE_WRAPBIAS + n
], DWORD)

D3DTSS_TCI = Flags(DWORD, [
    #"D3DTSS_TCI_PASSTHRU", # 0
    "D3DTSS_TCI_CAMERASPACENORMAL",
    "D3DTSS_TCI_CAMERASPACEPOSITION",
    "D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR",
])

D3DTEXTUREOP = Enum("D3DTEXTUREOP", [
    "D3DTOP_DISABLE",
    "D3DTOP_SELECTARG1",
    "D3DTOP_SELECTARG2",
    "D3DTOP_MODULATE",
    "D3DTOP_MODULATE2X",
    "D3DTOP_MODULATE4X",
    "D3DTOP_ADD",
    "D3DTOP_ADDSIGNED",
    "D3DTOP_ADDSIGNED2X",
    "D3DTOP_SUBTRACT",
    "D3DTOP_ADDSMOOTH",
    "D3DTOP_BLENDDIFFUSEALPHA",
    "D3DTOP_BLENDTEXTUREALPHA",
    "D3DTOP_BLENDFACTORALPHA",
    "D3DTOP_BLENDTEXTUREALPHAPM",
    "D3DTOP_BLENDCURRENTALPHA",
    "D3DTOP_PREMODULATE",
    "D3DTOP_MODULATEALPHA_ADDCOLOR",
    "D3DTOP_MODULATECOLOR_ADDALPHA",
    "D3DTOP_MODULATEINVALPHA_ADDCOLOR",
    "D3DTOP_MODULATEINVCOLOR_ADDALPHA",
    "D3DTOP_BUMPENVMAP",
    "D3DTOP_BUMPENVMAPLUMINANCE",
    "D3DTOP_DOTPRODUCT3",
    "D3DTOP_MULTIPLYADD",
    "D3DTOP_LERP",
])

# XXX: Actually a mixture of enums and flags
D3DTA = FakeEnum(DWORD, [
    "D3DTA_DIFFUSE",
    "D3DTA_CURRENT",
    "D3DTA_TEXTURE",
    "D3DTA_TFACTOR",
    "D3DTA_SPECULAR",
    "D3DTA_TEMP",
    #"D3DTA_COMPLEMENT",
    #"D3DTA_ALPHAREPLICATE",
])

D3DTEXTURETRANSFORMFLAGS = Enum("D3DTEXTURETRANSFORMFLAGS", [
    "D3DTTFF_DISABLE",
    "D3DTTFF_COUNT1",
    "D3DTTFF_COUNT2",
    "D3DTTFF_COUNT3",
    "D3DTTFF_COUNT4",
    "D3DTTFF_PROJECTED",
])

D3DTEXTUREFILTERTYPE = Enum("D3DTEXTUREFILTERTYPE", [
    "D3DTEXF_NONE",
    "D3DTEXF_POINT",
    "D3DTEXF_LINEAR",
    "D3DTEXF_ANISOTROPIC",
    "D3DTEXF_FLATCUBIC",
    "D3DTEXF_GAUSSIANCUBIC",
])

D3DTEXTURESTAGESTATETYPE, D3DTEXTURESTAGESTATEVALUE = EnumPolymorphic("D3DTEXTURESTAGESTATETYPE", "Type", [
    ("D3DTSS_COLOROP", D3DTEXTUREOP),
    ("D3DTSS_COLORARG1", D3DTA),
    ("D3DTSS_COLORARG2", D3DTA),
    ("D3DTSS_ALPHAOP", D3DTEXTUREOP),
    ("D3DTSS_ALPHAARG1", D3DTA),
    ("D3DTSS_ALPHAARG2", D3DTA),
    ("D3DTSS_BUMPENVMAT00", FLOAT_AS_DWORD),
    ("D3DTSS_BUMPENVMAT01", FLOAT_AS_DWORD),
    ("D3DTSS_BUMPENVMAT10", FLOAT_AS_DWORD),
    ("D3DTSS_BUMPENVMAT11", FLOAT_AS_DWORD),
    ("D3DTSS_TEXCOORDINDEX", D3DTSS_TCI),
    ("D3DTSS_ADDRESSU", D3DTEXTUREADDRESS),
    ("D3DTSS_ADDRESSV", D3DTEXTUREADDRESS),
    ("D3DTSS_BORDERCOLOR", D3DCOLOR),
    ("D3DTSS_MAGFILTER", D3DTEXTUREFILTERTYPE),
    ("D3DTSS_MINFILTER", D3DTEXTUREFILTERTYPE),
    ("D3DTSS_MIPFILTER", D3DTEXTUREFILTERTYPE),
    ("D3DTSS_MIPMAPLODBIAS", FLOAT_AS_DWORD),
    ("D3DTSS_MAXMIPLEVEL", DWORD),
    ("D3DTSS_MAXANISOTROPY", DWORD),
    ("D3DTSS_BUMPENVLSCALE", FLOAT_AS_DWORD),
    ("D3DTSS_BUMPENVLOFFSET", FLOAT_AS_DWORD),
    ("D3DTSS_TEXTURETRANSFORMFLAGS", D3DTEXTURETRANSFORMFLAGS),
    ("D3DTSS_ADDRESSW", D3DTEXTUREADDRESS),
    ("D3DTSS_COLORARG0", D3DTA),
    ("D3DTSS_ALPHAARG0", D3DTA),
    ("D3DTSS_RESULTARG", D3DTA),
], DWORD)

D3DPV = Flags(DWORD, [
    "D3DPV_DONOTCOPYDATA",
])

# XXX: Actually a mixture of enums and flags
D3DFVF = Flags(DWORD, [
    "D3DFVF_RESERVED0",
    "D3DFVF_XYZ",
    "D3DFVF_XYZRHW",
    "D3DFVF_XYZB1",
    "D3DFVF_XYZB2",
    "D3DFVF_XYZB3",
    "D3DFVF_XYZB4",
    "D3DFVF_XYZB5",
    "D3DFVF_NORMAL",
    "D3DFVF_PSIZE",
    "D3DFVF_DIFFUSE",
    "D3DFVF_SPECULAR",
    #"D3DFVF_TEX0",
    #"D3DFVF_TEX1",
    #"D3DFVF_TEX2",
    #"D3DFVF_TEX3",
    #"D3DFVF_TEX4",
    #"D3DFVF_TEX5",
    #"D3DFVF_TEX6",
    #"D3DFVF_TEX7",
    #"D3DFVF_TEX8",
    "D3DFVF_LASTBETA_UBYTE4",
    "D3DFVF_RESERVED2",
    #"D3DFVF_TEXCOORDSIZE1(0)",
    #"D3DFVF_TEXCOORDSIZE2(0)",
    #"D3DFVF_TEXCOORDSIZE3(0)",
    #"D3DFVF_TEXCOORDSIZE4(0)",
    #"D3DFVF_TEXCOORDSIZE1(1)",
    #"D3DFVF_TEXCOORDSIZE2(1)",
    #"D3DFVF_TEXCOORDSIZE3(1)",
    #"D3DFVF_TEXCOORDSIZE4(1)",
    #"D3DFVF_TEXCOORDSIZE1(2)",
    #"D3DFVF_TEXCOORDSIZE2(2)",
    #"D3DFVF_TEXCOORDSIZE3(2)",
    #"D3DFVF_TEXCOORDSIZE4(2)",
    #"D3DFVF_TEXCOORDSIZE1(3)",
    #"D3DFVF_TEXCOORDSIZE2(3)",
    #"D3DFVF_TEXCOORDSIZE3(3)",
    #"D3DFVF_TEXCOORDSIZE4(3)",
])

# XXX
D3DVSD_TOKENTYPE = Enum("D3DVSD_TOKENTYPE", [
    "D3DVSD_TOKEN_NOP",
    "D3DVSD_TOKEN_STREAM",
    "D3DVSD_TOKEN_STREAMDATA",
    "D3DVSD_TOKEN_TESSELLATOR",
    "D3DVSD_TOKEN_CONSTMEM",
    "D3DVSD_TOKEN_EXT",
    "D3DVSD_TOKEN_END",
])

# XXX
D3DVSDT = FakeEnum(DWORD, [
    "D3DVSDT_FLOAT1",
    "D3DVSDT_FLOAT2",
    "D3DVSDT_FLOAT3",
    "D3DVSDT_FLOAT4",
    "D3DVSDT_D3DCOLOR",
    "D3DVSDT_UBYTE4",
    "D3DVSDT_SHORT2",
    "D3DVSDT_SHORT4",
    "D3DVSDE_POSITION",
    "D3DVSDE_BLENDWEIGHT",
    "D3DVSDE_BLENDINDICES",
    "D3DVSDE_NORMAL",
    "D3DVSDE_PSIZE",
    "D3DVSDE_DIFFUSE",
    "D3DVSDE_SPECULAR",
    "D3DVSDE_TEXCOORD0",
    "D3DVSDE_TEXCOORD1",
    "D3DVSDE_TEXCOORD2",
    "D3DVSDE_TEXCOORD3",
    "D3DVSDE_TEXCOORD4",
    "D3DVSDE_TEXCOORD5",
    "D3DVSDE_TEXCOORD6",
    "D3DVSDE_TEXCOORD7",
    "D3DVSDE_POSITION2",
    "D3DVSDE_NORMAL2",
    "D3DDP_MAXTEXCOORD",
    "D3DSI_OPCODE_MASK",
])

D3DBASISTYPE = Enum("D3DBASISTYPE", [
    "D3DBASIS_BEZIER",
    "D3DBASIS_BSPLINE",
    "D3DBASIS_INTERPOLATE",
])

D3DSTATEBLOCKTYPE = Enum("D3DSTATEBLOCKTYPE", [
    "D3DSBT_ALL",
    "D3DSBT_PIXELSTATE",
    "D3DSBT_VERTEXSTATE",
])

D3DDEVTYPE = Enum("D3DDEVTYPE", [
    "D3DDEVTYPE_HAL",
    "D3DDEVTYPE_REF",
    "D3DDEVTYPE_SW",
])

D3DMULTISAMPLE_TYPE = Enum("D3DMULTISAMPLE_TYPE", [
    "D3DMULTISAMPLE_NONE",
    "D3DMULTISAMPLE_2_SAMPLES",
    "D3DMULTISAMPLE_3_SAMPLES",
    "D3DMULTISAMPLE_4_SAMPLES",
    "D3DMULTISAMPLE_5_SAMPLES",
    "D3DMULTISAMPLE_6_SAMPLES",
    "D3DMULTISAMPLE_7_SAMPLES",
    "D3DMULTISAMPLE_8_SAMPLES",
    "D3DMULTISAMPLE_9_SAMPLES",
    "D3DMULTISAMPLE_10_SAMPLES",
    "D3DMULTISAMPLE_11_SAMPLES",
    "D3DMULTISAMPLE_12_SAMPLES",
    "D3DMULTISAMPLE_13_SAMPLES",
    "D3DMULTISAMPLE_14_SAMPLES",
    "D3DMULTISAMPLE_15_SAMPLES",
    "D3DMULTISAMPLE_16_SAMPLES",
])

D3DFORMAT = Enum("D3DFORMAT", [
    "D3DFMT_UNKNOWN",
    "D3DFMT_R8G8B8",
    "D3DFMT_A8R8G8B8",
    "D3DFMT_X8R8G8B8",
    "D3DFMT_R5G6B5",
    "D3DFMT_X1R5G5B5",
    "D3DFMT_A1R5G5B5",
    "D3DFMT_A4R4G4B4",
    "D3DFMT_R3G3B2",
    "D3DFMT_A8",
    "D3DFMT_A8R3G3B2",
    "D3DFMT_X4R4G4B4",
    "D3DFMT_A2B10G10R10",
    "D3DFMT_G16R16",
    "D3DFMT_A8P8",
    "D3DFMT_P8",
    "D3DFMT_L8",
    "D3DFMT_A8L8",
    "D3DFMT_A4L4",
    "D3DFMT_V8U8",
    "D3DFMT_L6V5U5",
    "D3DFMT_X8L8V8U8",
    "D3DFMT_Q8W8V8U8",
    "D3DFMT_V16U16",
    "D3DFMT_W11V11U10",
    "D3DFMT_A2W10V10U10",
    "D3DFMT_UYVY",
    "D3DFMT_YUY2",
    "D3DFMT_DXT1",
    "D3DFMT_DXT2",
    "D3DFMT_DXT3",
    "D3DFMT_DXT4",
    "D3DFMT_DXT5",
    "D3DFMT_D16_LOCKABLE",
    "D3DFMT_D32",
    "D3DFMT_D15S1",
    "D3DFMT_D24S8",
    "D3DFMT_D16",
    "D3DFMT_D24X8",
    "D3DFMT_D24X4S4",
    "D3DFMT_VERTEXDATA",
    "D3DFMT_INDEX16",
    "D3DFMT_INDEX32",
])

D3DDISPLAYMODE = Struct("D3DDISPLAYMODE", [
    (UINT, "Width"),
    (UINT, "Height"),
    (UINT, "RefreshRate"),
    (D3DFORMAT, "Format"),
])

D3DCREATE = Flags(DWORD, [
    "D3DCREATE_FPU_PRESERVE",
    "D3DCREATE_MULTITHREADED",
    "D3DCREATE_PUREDEVICE",
    "D3DCREATE_SOFTWARE_VERTEXPROCESSING",
    "D3DCREATE_HARDWARE_VERTEXPROCESSING",
    "D3DCREATE_MIXED_VERTEXPROCESSING",
    "D3DCREATE_DISABLE_DRIVER_MANAGEMENT",
])

D3DDEVICE_CREATION_PARAMETERS = Struct("D3DDEVICE_CREATION_PARAMETERS", [
    (UINT, "AdapterOrdinal"),
    (D3DDEVTYPE, "DeviceType"),
    (HWND, "hFocusWindow"),
    (D3DCREATE, "BehaviorFlags"),
])

D3DSWAPEFFECT = Enum("D3DSWAPEFFECT", [
    "D3DSWAPEFFECT_DISCARD",
    "D3DSWAPEFFECT_FLIP",
    "D3DSWAPEFFECT_COPY",
    "D3DSWAPEFFECT_COPY_VSYNC",
])

D3DPOOL = Enum("D3DPOOL", [
    "D3DPOOL_DEFAULT",
    "D3DPOOL_MANAGED",
    "D3DPOOL_SYSTEMMEM",
    "D3DPOOL_SCRATCH",
])

D3DPRESENT = FakeEnum(DWORD, [
    "D3DPRESENT_RATE_DEFAULT",
    "D3DPRESENT_RATE_UNLIMITED",
])

D3DPRESENTFLAG = Flags(DWORD, [
    "D3DPRESENTFLAG_LOCKABLE_BACKBUFFER",
])

D3DPRESENT_INTERVAL = Flags(DWORD, [
    "D3DPRESENT_INTERVAL_DEFAULT", # 0
    "D3DPRESENT_INTERVAL_ONE",
    "D3DPRESENT_INTERVAL_TWO",
    "D3DPRESENT_INTERVAL_THREE",
    "D3DPRESENT_INTERVAL_FOUR",
    "D3DPRESENT_INTERVAL_IMMEDIATE",
])

D3DPRESENT_PARAMETERS = Struct("D3DPRESENT_PARAMETERS", [
    (UINT, "BackBufferWidth"),
    (UINT, "BackBufferHeight"),
    (D3DFORMAT, "BackBufferFormat"),
    (UINT, "BackBufferCount"),
    (D3DMULTISAMPLE_TYPE, "MultiSampleType"),
    (D3DSWAPEFFECT, "SwapEffect"),
    (HWND, "hDeviceWindow"),
    (BOOL, "Windowed"),
    (BOOL, "EnableAutoDepthStencil"),
    (D3DFORMAT, "AutoDepthStencilFormat"),
    (D3DPRESENTFLAG, "Flags"),
    (UINT, "FullScreen_RefreshRateInHz"),
    (D3DPRESENT_INTERVAL, "FullScreen_PresentationInterval"),
])

D3DGAMMARAMP = Struct("D3DGAMMARAMP", [
    (Array(WORD, 256), "red"),
    (Array(WORD, 256), "green"),
    (Array(WORD, 256), "blue"),
])

D3DBACKBUFFER_TYPE = Enum("D3DBACKBUFFER_TYPE", [
    "D3DBACKBUFFER_TYPE_MONO",
    "D3DBACKBUFFER_TYPE_LEFT",
    "D3DBACKBUFFER_TYPE_RIGHT",
])

D3DRESOURCETYPE = Enum("D3DRESOURCETYPE", [
    "D3DRTYPE_SURFACE",
    "D3DRTYPE_VOLUME",
    "D3DRTYPE_TEXTURE",
    "D3DRTYPE_VOLUMETEXTURE",
    "D3DRTYPE_CUBETEXTURE",
    "D3DRTYPE_VERTEXBUFFER",
    "D3DRTYPE_INDEXBUFFER",
])

D3DUSAGE = Flags(DWORD, [
    "D3DUSAGE_RENDERTARGET",
    "D3DUSAGE_DEPTHSTENCIL",
    "D3DUSAGE_WRITEONLY",
    "D3DUSAGE_SOFTWAREPROCESSING",
    "D3DUSAGE_DONOTCLIP",
    "D3DUSAGE_POINTS",
    "D3DUSAGE_RTPATCHES",
    "D3DUSAGE_NPATCHES",
    "D3DUSAGE_DYNAMIC",
])

D3DCUBEMAP_FACES = Enum("D3DCUBEMAP_FACES", [
    "D3DCUBEMAP_FACE_POSITIVE_X",
    "D3DCUBEMAP_FACE_NEGATIVE_X",
    "D3DCUBEMAP_FACE_POSITIVE_Y",
    "D3DCUBEMAP_FACE_NEGATIVE_Y",
    "D3DCUBEMAP_FACE_POSITIVE_Z",
    "D3DCUBEMAP_FACE_NEGATIVE_Z",
])

D3DLOCK = Flags(DWORD, [
    "D3DLOCK_READONLY",
    "D3DLOCK_DISCARD",
    "D3DLOCK_NOOVERWRITE",
    "D3DLOCK_NOSYSLOCK",
    "D3DLOCK_NO_DIRTY_UPDATE",
])

D3DVERTEXBUFFER_DESC = Struct("D3DVERTEXBUFFER_DESC", [
    (D3DFORMAT, "Format"),
    (D3DRESOURCETYPE, "Type"),
    (D3DUSAGE, "Usage"),
    (D3DPOOL, "Pool"),
    (UINT, "Size"),
    (DWORD, "FVF"),
])

D3DINDEXBUFFER_DESC = Struct("D3DINDEXBUFFER_DESC", [
    (D3DFORMAT, "Format"),
    (D3DRESOURCETYPE, "Type"),
    (D3DUSAGE, "Usage"),
    (D3DPOOL, "Pool"),
    (UINT, "Size"),
])

D3DSURFACE_DESC = Struct("D3DSURFACE_DESC", [
    (D3DFORMAT, "Format"),
    (D3DRESOURCETYPE, "Type"),
    (D3DUSAGE, "Usage"),
    (D3DPOOL, "Pool"),
    (UINT, "Size"),
    (D3DMULTISAMPLE_TYPE, "MultiSampleType"),
    (UINT, "Width"),
    (UINT, "Height"),
])

D3DVOLUME_DESC = Struct("D3DVOLUME_DESC", [
    (D3DFORMAT, "Format"),
    (D3DRESOURCETYPE, "Type"),
    (D3DUSAGE, "Usage"),
    (D3DPOOL, "Pool"),
    (UINT, "Size"),
    (UINT, "Width"),
    (UINT, "Height"),
    (UINT, "Depth"),
])

D3DLOCKED_RECT = Struct("D3DLOCKED_RECT", [
    (INT, "Pitch"),
    (LinearPointer(Void, "_MappedSize"), "pBits"),
])

D3DBOX = Struct("D3DBOX", [
    (UINT, "Left"),
    (UINT, "Top"),
    (UINT, "Right"),
    (UINT, "Bottom"),
    (UINT, "Front"),
    (UINT, "Back"),
])

D3DLOCKED_BOX = Struct("D3DLOCKED_BOX", [
    (INT, "RowPitch"),
    (INT, "SlicePitch"),
    (LinearPointer(Void, "_MappedSize"), "pBits"),
])

D3DRANGE = Struct("D3DRANGE", [
    (UINT, "Offset"),
    (UINT, "Size"),
])

D3DRECTPATCH_INFO = Struct("D3DRECTPATCH_INFO", [
    (UINT, "StartVertexOffsetWidth"),
    (UINT, "StartVertexOffsetHeight"),
    (UINT, "Width"),
    (UINT, "Height"),
    (UINT, "Stride"),
    (D3DBASISTYPE, "Basis"),
    (D3DORDERTYPE, "Order"),
])

D3DTRIPATCH_INFO = Struct("D3DTRIPATCH_INFO", [
    (UINT, "StartVertexOffset"),
    (UINT, "NumVertices"),
    (D3DBASISTYPE, "Basis"),
    (D3DORDERTYPE, "Order"),
])

D3DADAPTER_IDENTIFIER8 = Struct("D3DADAPTER_IDENTIFIER8", [
    (CString, "Driver"),
    (CString, "Description"),
    (LARGE_INTEGER, "DriverVersion"),
    (DWORD, "VendorId"),
    (DWORD, "DeviceId"),
    (DWORD, "SubSysId"),
    (DWORD, "Revision"),
    (GUID, "DeviceIdentifier"),
    (DWORD, "WHQLLevel"),
])

D3DRASTER_STATUS = Struct("D3DRASTER_STATUS", [
    (BOOL, "InVBlank"),
    (UINT, "ScanLine"),
])

D3DDEVINFOID = FakeEnum(DWORD, [
    "D3DDEVINFOID_RESOURCEMANAGER",
    "D3DDEVINFOID_VERTEXSTATS",
])

D3DRESOURCESTATS = Struct("D3DRESOURCESTATS", [
    (BOOL, "bThrashing"),
    (DWORD, "ApproxBytesDownloaded"),
    (DWORD, "NumEvicts"),
    (DWORD, "NumVidCreates"),
    (DWORD, "LastPri"),
    (DWORD, "NumUsed"),
    (DWORD, "NumUsedInVidMem"),
    (DWORD, "WorkingSet"),
    (DWORD, "WorkingSetBytes"),
    (DWORD, "TotalManaged"),
    (DWORD, "TotalBytes"),
])

D3DDEVINFO_RESOURCEMANAGER = Struct("D3DDEVINFO_RESOURCEMANAGER", [
    (Array(D3DRESOURCESTATS, "D3DRTYPECOUNT"), "stats"),
])

D3DDEVINFO_D3DVERTEXSTATS = Struct("D3DDEVINFO_D3DVERTEXSTATS", [
    (DWORD, "NumRenderedTriangles"),
    (DWORD, "NumExtraClippingTriangles"),
])


########NEW FILE########
__FILENAME__ = d3d9
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""d3d9.h"""

from winapi import *
from d3d9types import *
from d3d9caps import *


D3DSHADER9 = Blob(Const(DWORD), "_shaderSize(pFunction)")

D3DSPD = Flags(DWORD, [
    "D3DSPD_IUNKNOWN",
])

D3DADAPTER = FakeEnum(UINT, [
    "D3DADAPTER_DEFAULT",
])

D3DENUM = FakeEnum(DWORD, [
    "D3DENUM_WHQL_LEVEL",
])

D3DSGR = Flags(DWORD, [
    "D3DSGR_NO_CALIBRATION",
    "D3DSGR_CALIBRATE",
])

D3DCURSOR = Flags(DWORD, [
    "D3DCURSOR_IMMEDIATE_UPDATE",
])

D3DPRESENT = Flags(DWORD, [
    "D3DPRESENT_DONOTWAIT",
    "D3DPRESENT_LINEAR_CONTENT",
    "D3DPRESENT_DONOTFLIP",
    "D3DPRESENT_FLIPRESTART",
    "D3DPRESENT_VIDEO_RESTRICT_TO_MONITOR",
])

HRESULT = MAKE_HRESULT(ok = "D3D_OK", errors = [
    "D3DERR_WRONGTEXTUREFORMAT",
    "D3DERR_UNSUPPORTEDCOLOROPERATION",
    "D3DERR_UNSUPPORTEDCOLORARG",
    "D3DERR_UNSUPPORTEDALPHAOPERATION",
    "D3DERR_UNSUPPORTEDALPHAARG",
    "D3DERR_TOOMANYOPERATIONS",
    "D3DERR_CONFLICTINGTEXTUREFILTER",
    "D3DERR_UNSUPPORTEDFACTORVALUE",
    "D3DERR_CONFLICTINGRENDERSTATE",
    "D3DERR_UNSUPPORTEDTEXTUREFILTER",
    "D3DERR_CONFLICTINGTEXTUREPALETTE",
    "D3DERR_DRIVERINTERNALERROR",
    "D3DERR_NOTFOUND",
    "D3DERR_MOREDATA",
    "D3DERR_DEVICELOST",
    "D3DERR_DEVICENOTRESET",
    "D3DERR_NOTAVAILABLE",
    "D3DERR_OUTOFVIDEOMEMORY",
    "D3DERR_INVALIDDEVICE",
    "D3DERR_INVALIDCALL",
    "D3DERR_DRIVERINVALIDCALL",
    "D3DERR_WASSTILLDRAWING",
    "D3DOK_NOAUTOGEN",
    "D3DERR_DEVICEREMOVED",
    "S_NOT_RESIDENT",
    "S_RESIDENT_IN_SHARED_MEMORY",
    "S_PRESENT_MODE_CHANGED",
    "S_PRESENT_OCCLUDED",
    "D3DERR_DEVICEHUNG",
])

IDirect3D9 = Interface("IDirect3D9", IUnknown)
IDirect3DDevice9 = Interface("IDirect3DDevice9", IUnknown)
IDirect3DStateBlock9 = Interface("IDirect3DStateBlock9", IUnknown)
IDirect3DSwapChain9 = Interface("IDirect3DSwapChain9", IUnknown)
IDirect3DResource9 = Interface("IDirect3DResource9", IUnknown)
IDirect3DVertexDeclaration9 = Interface("IDirect3DVertexDeclaration9", IUnknown)
IDirect3DVertexShader9 = Interface("IDirect3DVertexShader9", IUnknown)
IDirect3DPixelShader9 = Interface("IDirect3DPixelShader9", IUnknown)
IDirect3DBaseTexture9 = Interface("IDirect3DBaseTexture9", IDirect3DResource9)
IDirect3DTexture9 = Interface("IDirect3DTexture9", IDirect3DBaseTexture9)
IDirect3DVolumeTexture9 = Interface("IDirect3DVolumeTexture9", IDirect3DBaseTexture9)
IDirect3DCubeTexture9 = Interface("IDirect3DCubeTexture9", IDirect3DBaseTexture9)
IDirect3DVertexBuffer9 = Interface("IDirect3DVertexBuffer9", IDirect3DResource9)
IDirect3DIndexBuffer9 = Interface("IDirect3DIndexBuffer9", IDirect3DResource9)
IDirect3DSurface9 = Interface("IDirect3DSurface9", IDirect3DResource9)
IDirect3DVolume9 = Interface("IDirect3DVolume9", IUnknown)
IDirect3DQuery9 = Interface("IDirect3DQuery9", IUnknown)
IDirect3D9Ex = Interface("IDirect3D9Ex", IDirect3D9)
IDirect3DDevice9Ex = Interface("IDirect3DDevice9Ex", IDirect3DDevice9)
IDirect3DSwapChain9Ex = Interface("IDirect3DSwapChain9Ex", IDirect3DSwapChain9)

PDIRECT3D9 = ObjPointer(IDirect3D9)
PDIRECT3DDEVICE9 = ObjPointer(IDirect3DDevice9)
PDIRECT3DSTATEBLOCK9 = ObjPointer(IDirect3DStateBlock9)
PDIRECT3DSWAPCHAIN9 = ObjPointer(IDirect3DSwapChain9)
PDIRECT3DRESOURCE9 = ObjPointer(IDirect3DResource9)
PDIRECT3DVERTEXDECLARATION9 = ObjPointer(IDirect3DVertexDeclaration9)
PDIRECT3DVERTEXSHADER9 = ObjPointer(IDirect3DVertexShader9)
PDIRECT3DPIXELSHADER9 = ObjPointer(IDirect3DPixelShader9)
PDIRECT3DBASETEXTURE9 = ObjPointer(IDirect3DBaseTexture9)
PDIRECT3DTEXTURE9 = ObjPointer(IDirect3DTexture9)
PDIRECT3DVOLUMETEXTURE9 = ObjPointer(IDirect3DVolumeTexture9)
PDIRECT3DCUBETEXTURE9 = ObjPointer(IDirect3DCubeTexture9)
PDIRECT3DVERTEXBUFFER9 = ObjPointer(IDirect3DVertexBuffer9)
PDIRECT3DINDEXBUFFER9 = ObjPointer(IDirect3DIndexBuffer9)
PDIRECT3DSURFACE9 = ObjPointer(IDirect3DSurface9)
PDIRECT3DVOLUME9 = ObjPointer(IDirect3DVolume9)
PDIRECT3DQUERY9 = ObjPointer(IDirect3DQuery9)
PDIRECT3D9EX = ObjPointer(IDirect3D9Ex)
PDIRECT3DDEVICE9EX = ObjPointer(IDirect3DDevice9Ex)
PDIRECT3DSWAPCHAIN9EX = ObjPointer(IDirect3DSwapChain9Ex)

IDirect3D9.methods += [
    StdMethod(HRESULT, "RegisterSoftwareDevice", [(OpaquePointer(Void), "pInitializeFunction")], sideeffects=False),
    StdMethod(UINT, "GetAdapterCount", [], sideeffects=False),
    StdMethod(HRESULT, "GetAdapterIdentifier", [(D3DADAPTER, "Adapter"), (D3DENUM, "Flags"), Out(Pointer(D3DADAPTER_IDENTIFIER9), "pIdentifier")], sideeffects=False),
    StdMethod(UINT, "GetAdapterModeCount", [(D3DADAPTER, "Adapter"), (D3DFORMAT, "Format")], sideeffects=False),
    StdMethod(HRESULT, "EnumAdapterModes", [(D3DADAPTER, "Adapter"), (D3DFORMAT, "Format"), (UINT, "Mode"), Out(Pointer(D3DDISPLAYMODE), "pMode")], sideeffects=False),
    StdMethod(HRESULT, "GetAdapterDisplayMode", [(D3DADAPTER, "Adapter"), Out(Pointer(D3DDISPLAYMODE), "pMode")], sideeffects=False),
    StdMethod(HRESULT, "CheckDeviceType", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "DevType"), (D3DFORMAT, "AdapterFormat"), (D3DFORMAT, "BackBufferFormat"), (BOOL, "bWindowed")], sideeffects=False),
    StdMethod(HRESULT, "CheckDeviceFormat", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "DeviceType"), (D3DFORMAT, "AdapterFormat"), (D3DUSAGE, "Usage"), (D3DRESOURCETYPE, "RType"), (D3DFORMAT, "CheckFormat")], sideeffects=False),
    StdMethod(HRESULT, "CheckDeviceMultiSampleType", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "DeviceType"), (D3DFORMAT, "SurfaceFormat"), (BOOL, "Windowed"), (D3DMULTISAMPLE_TYPE, "MultiSampleType"), Out(Pointer(DWORD), "pQualityLevels")], sideeffects=False),
    StdMethod(HRESULT, "CheckDepthStencilMatch", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "DeviceType"), (D3DFORMAT, "AdapterFormat"), (D3DFORMAT, "RenderTargetFormat"), (D3DFORMAT, "DepthStencilFormat")], sideeffects=False),
    StdMethod(HRESULT, "CheckDeviceFormatConversion", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "DeviceType"), (D3DFORMAT, "SourceFormat"), (D3DFORMAT, "TargetFormat")], sideeffects=False),
    StdMethod(HRESULT, "GetDeviceCaps", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "DeviceType"), Out(Pointer(D3DCAPS9), "pCaps")], sideeffects=False),
    StdMethod(HMONITOR, "GetAdapterMonitor", [(D3DADAPTER, "Adapter")], sideeffects=False),
    StdMethod(HRESULT, "CreateDevice", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "DeviceType"), (HWND, "hFocusWindow"), (D3DCREATE, "BehaviorFlags"), InOut(Pointer(D3DPRESENT_PARAMETERS), "pPresentationParameters"), Out(Pointer(PDIRECT3DDEVICE9), "ppReturnedDeviceInterface")]),
]

IDirect3DDevice9.methods += [
    StdMethod(HRESULT, "TestCooperativeLevel", []),
    StdMethod(UINT, "GetAvailableTextureMem", [], sideeffects=False),
    StdMethod(HRESULT, "EvictManagedResources", []),
    StdMethod(HRESULT, "GetDirect3D", [Out(Pointer(PDIRECT3D9), "ppD3D9")]),
    StdMethod(HRESULT, "GetDeviceCaps", [Out(Pointer(D3DCAPS9), "pCaps")], sideeffects=False),
    StdMethod(HRESULT, "GetDisplayMode", [(UINT, "iSwapChain"), Out(Pointer(D3DDISPLAYMODE), "pMode")], sideeffects=False),
    StdMethod(HRESULT, "GetCreationParameters", [Out(Pointer(D3DDEVICE_CREATION_PARAMETERS), "pParameters")], sideeffects=False),
    StdMethod(HRESULT, "SetCursorProperties", [(UINT, "XHotSpot"), (UINT, "YHotSpot"), (PDIRECT3DSURFACE9, "pCursorBitmap")]),
    StdMethod(Void, "SetCursorPosition", [(Int, "X"), (Int, "Y"), (D3DCURSOR, "Flags")]),
    StdMethod(BOOL, "ShowCursor", [(BOOL, "bShow")]),
    StdMethod(HRESULT, "CreateAdditionalSwapChain", [InOut(Pointer(D3DPRESENT_PARAMETERS), "pPresentationParameters"), Out(Pointer(PDIRECT3DSWAPCHAIN9), "pSwapChain")]),
    StdMethod(HRESULT, "GetSwapChain", [(UINT, "iSwapChain"), Out(Pointer(PDIRECT3DSWAPCHAIN9), "pSwapChain")]),
    StdMethod(UINT, "GetNumberOfSwapChains", [], sideeffects=False),
    StdMethod(HRESULT, "Reset", [InOut(Pointer(D3DPRESENT_PARAMETERS), "pPresentationParameters")]),
    StdMethod(HRESULT, "Present", [(ConstPointer(RECT), "pSourceRect"), (ConstPointer(RECT), "pDestRect"), (HWND, "hDestWindowOverride"), (ConstPointer(RGNDATA), "pDirtyRegion")]),
    StdMethod(HRESULT, "GetBackBuffer", [(UINT, "iSwapChain"), (UINT, "iBackBuffer"), (D3DBACKBUFFER_TYPE, "Type"), Out(Pointer(PDIRECT3DSURFACE9), "ppBackBuffer")]),
    StdMethod(HRESULT, "GetRasterStatus", [(UINT, "iSwapChain"), Out(Pointer(D3DRASTER_STATUS), "pRasterStatus")], sideeffects=False),
    StdMethod(HRESULT, "SetDialogBoxMode", [(BOOL, "bEnableDialogs")]),
    StdMethod(Void, "SetGammaRamp", [(UINT, "iSwapChain"), (D3DSGR, "Flags"), (ConstPointer(D3DGAMMARAMP), "pRamp")]),
    StdMethod(Void, "GetGammaRamp", [(UINT, "iSwapChain"), Out(Pointer(D3DGAMMARAMP), "pRamp")], sideeffects=False),
    StdMethod(HRESULT, "CreateTexture", [(UINT, "Width"), (UINT, "Height"), (UINT, "Levels"), (D3DUSAGE, "Usage"), (D3DFORMAT, "Format"), (D3DPOOL, "Pool"), Out(Pointer(PDIRECT3DTEXTURE9), "ppTexture"), (Pointer(HANDLE), "pSharedHandle")]),
    StdMethod(HRESULT, "CreateVolumeTexture", [(UINT, "Width"), (UINT, "Height"), (UINT, "Depth"), (UINT, "Levels"), (D3DUSAGE, "Usage"), (D3DFORMAT, "Format"), (D3DPOOL, "Pool"), Out(Pointer(PDIRECT3DVOLUMETEXTURE9), "ppVolumeTexture"), (Pointer(HANDLE), "pSharedHandle")]),
    StdMethod(HRESULT, "CreateCubeTexture", [(UINT, "EdgeLength"), (UINT, "Levels"), (D3DUSAGE, "Usage"), (D3DFORMAT, "Format"), (D3DPOOL, "Pool"), Out(Pointer(PDIRECT3DCUBETEXTURE9), "ppCubeTexture"), (Pointer(HANDLE), "pSharedHandle")]),
    StdMethod(HRESULT, "CreateVertexBuffer", [(UINT, "Length"), (D3DUSAGE, "Usage"), (D3DFVF, "FVF"), (D3DPOOL, "Pool"), Out(Pointer(PDIRECT3DVERTEXBUFFER9), "ppVertexBuffer"), (Pointer(HANDLE), "pSharedHandle")]),
    StdMethod(HRESULT, "CreateIndexBuffer", [(UINT, "Length"), (D3DUSAGE, "Usage"), (D3DFORMAT, "Format"), (D3DPOOL, "Pool"), Out(Pointer(PDIRECT3DINDEXBUFFER9), "ppIndexBuffer"), (Pointer(HANDLE), "pSharedHandle")]),
    StdMethod(HRESULT, "CreateRenderTarget", [(UINT, "Width"), (UINT, "Height"), (D3DFORMAT, "Format"), (D3DMULTISAMPLE_TYPE, "MultiSample"), (DWORD, "MultisampleQuality"), (BOOL, "Lockable"), Out(Pointer(PDIRECT3DSURFACE9), "ppSurface"), (Pointer(HANDLE), "pSharedHandle")]),
    StdMethod(HRESULT, "CreateDepthStencilSurface", [(UINT, "Width"), (UINT, "Height"), (D3DFORMAT, "Format"), (D3DMULTISAMPLE_TYPE, "MultiSample"), (DWORD, "MultisampleQuality"), (BOOL, "Discard"), Out(Pointer(PDIRECT3DSURFACE9), "ppSurface"), (Pointer(HANDLE), "pSharedHandle")]),
    StdMethod(HRESULT, "UpdateSurface", [(PDIRECT3DSURFACE9, "pSourceSurface"), (ConstPointer(RECT), "pSourceRect"), (PDIRECT3DSURFACE9, "pDestinationSurface"), (ConstPointer(POINT), "pDestPoint")]),
    StdMethod(HRESULT, "UpdateTexture", [(PDIRECT3DBASETEXTURE9, "pSourceTexture"), (PDIRECT3DBASETEXTURE9, "pDestinationTexture")]),
    StdMethod(HRESULT, "GetRenderTargetData", [(PDIRECT3DSURFACE9, "pRenderTarget"), (PDIRECT3DSURFACE9, "pDestSurface")]),
    StdMethod(HRESULT, "GetFrontBufferData", [(UINT, "iSwapChain"), (PDIRECT3DSURFACE9, "pDestSurface")]),
    StdMethod(HRESULT, "StretchRect", [(PDIRECT3DSURFACE9, "pSourceSurface"), (ConstPointer(RECT), "pSourceRect"), (PDIRECT3DSURFACE9, "pDestSurface"), (ConstPointer(RECT), "pDestRect"), (D3DTEXTUREFILTERTYPE, "Filter")]),
    StdMethod(HRESULT, "ColorFill", [(PDIRECT3DSURFACE9, "pSurface"), (ConstPointer(RECT), "pRect"), (D3DCOLOR, "color")]),
    StdMethod(HRESULT, "CreateOffscreenPlainSurface", [(UINT, "Width"), (UINT, "Height"), (D3DFORMAT, "Format"), (D3DPOOL, "Pool"), Out(Pointer(PDIRECT3DSURFACE9), "ppSurface"), (Pointer(HANDLE), "pSharedHandle")]),
    StdMethod(HRESULT, "SetRenderTarget", [(DWORD, "RenderTargetIndex"), (PDIRECT3DSURFACE9, "pRenderTarget")]),
    StdMethod(HRESULT, "GetRenderTarget", [(DWORD, "RenderTargetIndex"), Out(Pointer(PDIRECT3DSURFACE9), "ppRenderTarget")]),
    StdMethod(HRESULT, "SetDepthStencilSurface", [(PDIRECT3DSURFACE9, "pNewZStencil")]),
    StdMethod(HRESULT, "GetDepthStencilSurface", [Out(Pointer(PDIRECT3DSURFACE9), "ppZStencilSurface")]),
    StdMethod(HRESULT, "BeginScene", []),
    StdMethod(HRESULT, "EndScene", []),
    StdMethod(HRESULT, "Clear", [(DWORD, "Count"), (ConstPointer(D3DRECT), "pRects"), (D3DCLEAR, "Flags"), (D3DCOLOR, "Color"), (Float, "Z"), (DWORD, "Stencil")]),
    StdMethod(HRESULT, "SetTransform", [(D3DTRANSFORMSTATETYPE, "State"), (ConstPointer(D3DMATRIX), "pMatrix")]),
    StdMethod(HRESULT, "GetTransform", [(D3DTRANSFORMSTATETYPE, "State"), Out(Pointer(D3DMATRIX), "pMatrix")], sideeffects=False),
    StdMethod(HRESULT, "MultiplyTransform", [(D3DTRANSFORMSTATETYPE, "State"), (ConstPointer(D3DMATRIX), "pMatrix")]),
    StdMethod(HRESULT, "SetViewport", [(ConstPointer(D3DVIEWPORT9), "pViewport")]),
    StdMethod(HRESULT, "GetViewport", [Out(Pointer(D3DVIEWPORT9), "pViewport")], sideeffects=False),
    StdMethod(HRESULT, "SetMaterial", [(ConstPointer(D3DMATERIAL9), "pMaterial")]),
    StdMethod(HRESULT, "GetMaterial", [Out(Pointer(D3DMATERIAL9), "pMaterial")], sideeffects=False),
    StdMethod(HRESULT, "SetLight", [(DWORD, "Index"), (ConstPointer(D3DLIGHT9), "pLight")]),
    StdMethod(HRESULT, "GetLight", [(DWORD, "Index"), Out(Pointer(D3DLIGHT9), "pLight")], sideeffects=False),
    StdMethod(HRESULT, "LightEnable", [(DWORD, "Index"), (BOOL, "Enable")]),
    StdMethod(HRESULT, "GetLightEnable", [(DWORD, "Index"), Out(Pointer(BOOL), "pEnable")], sideeffects=False),
    StdMethod(HRESULT, "SetClipPlane", [(DWORD, "Index"), (ConstPointer(Float), "pPlane")]),
    StdMethod(HRESULT, "GetClipPlane", [(DWORD, "Index"), Out(Pointer(Float), "pPlane")], sideeffects=False),
    StdMethod(HRESULT, "SetRenderState", [(D3DRENDERSTATETYPE, "State"), (D3DRENDERSTATEVALUE, "Value")]),
    StdMethod(HRESULT, "GetRenderState", [(D3DRENDERSTATETYPE, "State"), Out(Pointer(D3DRENDERSTATEVALUE), "pValue")], sideeffects=False),
    StdMethod(HRESULT, "CreateStateBlock", [(D3DSTATEBLOCKTYPE, "Type"), Out(Pointer(PDIRECT3DSTATEBLOCK9), "ppSB")]),
    StdMethod(HRESULT, "BeginStateBlock", []),
    StdMethod(HRESULT, "EndStateBlock", [Out(Pointer(PDIRECT3DSTATEBLOCK9), "ppSB")]),
    StdMethod(HRESULT, "SetClipStatus", [(ConstPointer(D3DCLIPSTATUS9), "pClipStatus")]),
    StdMethod(HRESULT, "GetClipStatus", [Out(Pointer(D3DCLIPSTATUS9), "pClipStatus")], sideeffects=False),
    StdMethod(HRESULT, "GetTexture", [(DWORD, "Stage"), Out(Pointer(PDIRECT3DBASETEXTURE9), "ppTexture")]),
    StdMethod(HRESULT, "SetTexture", [(DWORD, "Stage"), (PDIRECT3DBASETEXTURE9, "pTexture")]),
    StdMethod(HRESULT, "GetTextureStageState", [(DWORD, "Stage"), (D3DTEXTURESTAGESTATETYPE, "Type"), Out(Pointer(D3DTEXTURESTAGESTATEVALUE), "pValue")], sideeffects=False),
    StdMethod(HRESULT, "SetTextureStageState", [(DWORD, "Stage"), (D3DTEXTURESTAGESTATETYPE, "Type"), (D3DTEXTURESTAGESTATEVALUE, "Value")]),
    StdMethod(HRESULT, "GetSamplerState", [(DWORD, "Sampler"), (D3DSAMPLERSTATETYPE, "Type"), Out(Pointer(D3DSAMPLERSTATEVALUE), "pValue")], sideeffects=False),
    StdMethod(HRESULT, "SetSamplerState", [(DWORD, "Sampler"), (D3DSAMPLERSTATETYPE, "Type"), (D3DSAMPLERSTATEVALUE, "Value")]),
    StdMethod(HRESULT, "ValidateDevice", [Out(Pointer(DWORD), "pNumPasses")]),
    StdMethod(HRESULT, "SetPaletteEntries", [(UINT, "PaletteNumber"), (ConstPointer(PALETTEENTRY), "pEntries")]),
    StdMethod(HRESULT, "GetPaletteEntries", [(UINT, "PaletteNumber"), Out(Pointer(PALETTEENTRY), "pEntries")], sideeffects=False),
    StdMethod(HRESULT, "SetCurrentTexturePalette", [(UINT, "PaletteNumber")]),
    StdMethod(HRESULT, "GetCurrentTexturePalette", [Out(Pointer(UINT), "PaletteNumber")], sideeffects=False),
    StdMethod(HRESULT, "SetScissorRect", [(ConstPointer(RECT), "pRect")]),
    StdMethod(HRESULT, "GetScissorRect", [Out(Pointer(RECT), "pRect")]),
    StdMethod(HRESULT, "SetSoftwareVertexProcessing", [(BOOL, "bSoftware")]),
    StdMethod(BOOL, "GetSoftwareVertexProcessing", [], sideeffects=False),
    StdMethod(HRESULT, "SetNPatchMode", [(Float, "nSegments")]),
    StdMethod(Float, "GetNPatchMode", [], sideeffects=False),
    StdMethod(HRESULT, "DrawPrimitive", [(D3DPRIMITIVETYPE, "PrimitiveType"), (UINT, "StartVertex"), (UINT, "PrimitiveCount")]),
    StdMethod(HRESULT, "DrawIndexedPrimitive", [(D3DPRIMITIVETYPE, "PrimitiveType"), (INT, "BaseVertexIndex"), (UINT, "MinVertexIndex"), (UINT, "NumVertices"), (UINT, "startIndex"), (UINT, "primCount")]),
    StdMethod(HRESULT, "DrawPrimitiveUP", [(D3DPRIMITIVETYPE, "PrimitiveType"), (UINT, "PrimitiveCount"), (Blob(Const(Void), "_vertexDataSize(PrimitiveType, PrimitiveCount, VertexStreamZeroStride)"), "pVertexStreamZeroData"), (UINT, "VertexStreamZeroStride")]),
    StdMethod(HRESULT, "DrawIndexedPrimitiveUP", [(D3DPRIMITIVETYPE, "PrimitiveType"), (UINT, "MinVertexIndex"), (UINT, "NumVertices"), (UINT, "PrimitiveCount"), (Blob(Const(Void), "_indexDataSize(PrimitiveType, PrimitiveCount, IndexDataFormat)"), "pIndexData"), (D3DFORMAT, "IndexDataFormat"), (Blob(Const(Void), "NumVertices*VertexStreamZeroStride"), "pVertexStreamZeroData"), (UINT, "VertexStreamZeroStride")]),
    StdMethod(HRESULT, "ProcessVertices", [(UINT, "SrcStartIndex"), (UINT, "DestIndex"), (UINT, "VertexCount"), (PDIRECT3DVERTEXBUFFER9, "pDestBuffer"), (PDIRECT3DVERTEXDECLARATION9, "pVertexDecl"), (D3DPV, "Flags")]),
    StdMethod(HRESULT, "CreateVertexDeclaration", [(Array(Const(D3DVERTEXELEMENT9), "_declCount(pVertexElements)"), "pVertexElements"), Out(Pointer(PDIRECT3DVERTEXDECLARATION9), "ppDecl")]),
    StdMethod(HRESULT, "SetVertexDeclaration", [(PDIRECT3DVERTEXDECLARATION9, "pDecl")]),
    StdMethod(HRESULT, "GetVertexDeclaration", [Out(Pointer(PDIRECT3DVERTEXDECLARATION9), "ppDecl")]),
    StdMethod(HRESULT, "SetFVF", [(D3DFVF, "FVF")]),
    StdMethod(HRESULT, "GetFVF", [Out(Pointer(D3DFVF), "pFVF")], sideeffects=False),
    StdMethod(HRESULT, "CreateVertexShader", [(D3DSHADER9, "pFunction"), Out(Pointer(PDIRECT3DVERTEXSHADER9), "ppShader")]),
    StdMethod(HRESULT, "SetVertexShader", [(PDIRECT3DVERTEXSHADER9, "pShader")]),
    StdMethod(HRESULT, "GetVertexShader", [Out(Pointer(PDIRECT3DVERTEXSHADER9), "ppShader")]),
    StdMethod(HRESULT, "SetVertexShaderConstantF", [(UINT, "StartRegister"), (Array(Const(Float), "4*Vector4fCount"), "pConstantData"), (UINT, "Vector4fCount")]),
    StdMethod(HRESULT, "GetVertexShaderConstantF", [(UINT, "StartRegister"), Out(Array(Float, "4*Vector4fCount"), "pConstantData"), (UINT, "Vector4fCount")], sideeffects=False),
    StdMethod(HRESULT, "SetVertexShaderConstantI", [(UINT, "StartRegister"), (Array(Const(Int), "4*Vector4iCount"), "pConstantData"), (UINT, "Vector4iCount")]),
    StdMethod(HRESULT, "GetVertexShaderConstantI", [(UINT, "StartRegister"), Out(Array(Int, "4*Vector4iCount"), "pConstantData"), (UINT, "Vector4iCount")], sideeffects=False),
    StdMethod(HRESULT, "SetVertexShaderConstantB", [(UINT, "StartRegister"), (Array(Const(BOOL), "BoolCount"), "pConstantData"), (UINT, "BoolCount")]),
    StdMethod(HRESULT, "GetVertexShaderConstantB", [(UINT, "StartRegister"), Out(Array(BOOL, "BoolCount"), "pConstantData"), (UINT, "BoolCount")], sideeffects=False),
    StdMethod(HRESULT, "SetStreamSource", [(UINT, "StreamNumber"), (PDIRECT3DVERTEXBUFFER9, "pStreamData"), (UINT, "OffsetInBytes"), (UINT, "Stride")]),
    StdMethod(HRESULT, "GetStreamSource", [(UINT, "StreamNumber"), Out(Pointer(PDIRECT3DVERTEXBUFFER9), "ppStreamData"), Out(Pointer(UINT), "pOffsetInBytes"), Out(Pointer(UINT), "pStride")]),
    StdMethod(HRESULT, "SetStreamSourceFreq", [(UINT, "StreamNumber"), (UINT, "Setting")]),
    StdMethod(HRESULT, "GetStreamSourceFreq", [(UINT, "StreamNumber"), Out(Pointer(UINT), "pSetting")], sideeffects=False),
    StdMethod(HRESULT, "SetIndices", [(PDIRECT3DINDEXBUFFER9, "pIndexData")]),
    StdMethod(HRESULT, "GetIndices", [Out(Pointer(PDIRECT3DINDEXBUFFER9), "ppIndexData")]),
    StdMethod(HRESULT, "CreatePixelShader", [(D3DSHADER9, "pFunction"), Out(Pointer(PDIRECT3DPIXELSHADER9), "ppShader")]),
    StdMethod(HRESULT, "SetPixelShader", [(PDIRECT3DPIXELSHADER9, "pShader")]),
    StdMethod(HRESULT, "GetPixelShader", [Out(Pointer(PDIRECT3DPIXELSHADER9), "ppShader")]),
    StdMethod(HRESULT, "SetPixelShaderConstantF", [(UINT, "StartRegister"), (Array(Const(Float), "4*Vector4fCount"), "pConstantData"), (UINT, "Vector4fCount")]),
    StdMethod(HRESULT, "GetPixelShaderConstantF", [(UINT, "StartRegister"), Out(Array(Float, "4*Vector4fCount"), "pConstantData"), (UINT, "Vector4fCount")], sideeffects=False),
    StdMethod(HRESULT, "SetPixelShaderConstantI", [(UINT, "StartRegister"), (Array(Const(Int), "4*Vector4iCount"), "pConstantData"), (UINT, "Vector4iCount")]),
    StdMethod(HRESULT, "GetPixelShaderConstantI", [(UINT, "StartRegister"), Out(Array(Int, "4*Vector4iCount"), "pConstantData"), (UINT, "Vector4iCount")], sideeffects=False),
    StdMethod(HRESULT, "SetPixelShaderConstantB", [(UINT, "StartRegister"), (Array(Const(BOOL), "BoolCount"), "pConstantData"), (UINT, "BoolCount")]),
    StdMethod(HRESULT, "GetPixelShaderConstantB", [(UINT, "StartRegister"), Out(Array(BOOL, "BoolCount"), "pConstantData"), (UINT, "BoolCount")], sideeffects=False),
    StdMethod(HRESULT, "DrawRectPatch", [(UINT, "Handle"), (ConstPointer(Float), "pNumSegs"), (ConstPointer(D3DRECTPATCH_INFO), "pRectPatchInfo")]),
    StdMethod(HRESULT, "DrawTriPatch", [(UINT, "Handle"), (ConstPointer(Float), "pNumSegs"), (ConstPointer(D3DTRIPATCH_INFO), "pTriPatchInfo")]),
    StdMethod(HRESULT, "DeletePatch", [(UINT, "Handle")]),
    StdMethod(HRESULT, "CreateQuery", [(D3DQUERYTYPE, "Type"), Out(Pointer(PDIRECT3DQUERY9), "ppQuery")]),
]

IDirect3DStateBlock9.methods += [
    StdMethod(HRESULT, "GetDevice", [Out(Pointer(PDIRECT3DDEVICE9), "ppDevice")]),
    StdMethod(HRESULT, "Capture", []),
    StdMethod(HRESULT, "Apply", []),
]

IDirect3DSwapChain9.methods += [
    StdMethod(HRESULT, "Present", [(ConstPointer(RECT), "pSourceRect"), (ConstPointer(RECT), "pDestRect"), (HWND, "hDestWindowOverride"), (ConstPointer(RGNDATA), "pDirtyRegion"), (D3DPRESENT, "dwFlags")]),
    StdMethod(HRESULT, "GetFrontBufferData", [(PDIRECT3DSURFACE9, "pDestSurface")]),
    StdMethod(HRESULT, "GetBackBuffer", [(UINT, "iBackBuffer"), (D3DBACKBUFFER_TYPE, "Type"), Out(Pointer(PDIRECT3DSURFACE9), "ppBackBuffer")]),
    StdMethod(HRESULT, "GetRasterStatus", [Out(Pointer(D3DRASTER_STATUS), "pRasterStatus")], sideeffects=False),
    StdMethod(HRESULT, "GetDisplayMode", [Out(Pointer(D3DDISPLAYMODE), "pMode")], sideeffects=False),
    StdMethod(HRESULT, "GetDevice", [Out(Pointer(PDIRECT3DDEVICE9), "ppDevice")]),
    StdMethod(HRESULT, "GetPresentParameters", [Out(Pointer(D3DPRESENT_PARAMETERS), "pPresentationParameters")], sideeffects=False),
]

IDirect3DResource9.methods += [
    StdMethod(HRESULT, "GetDevice", [Out(Pointer(PDIRECT3DDEVICE9), "ppDevice")]),
    StdMethod(HRESULT, "SetPrivateData", [(REFGUID, "refguid"), (OpaqueBlob(Const(Void), "SizeOfData"), "pData"), (DWORD, "SizeOfData"), (D3DSPD, "Flags")], sideeffects=False),
    StdMethod(HRESULT, "GetPrivateData", [(REFGUID, "refguid"), Out(OpaqueBlob(Void, "*pSizeOfData"), "pData"), Out(Pointer(DWORD), "pSizeOfData")], sideeffects=False),
    StdMethod(HRESULT, "FreePrivateData", [(REFGUID, "refguid")], sideeffects=False),
    StdMethod(D3D9_RESOURCE_PRIORITY, "SetPriority", [(D3D9_RESOURCE_PRIORITY, "PriorityNew")]),
    StdMethod(D3D9_RESOURCE_PRIORITY, "GetPriority", [], sideeffects=False),
    StdMethod(Void, "PreLoad", []),
    StdMethod(D3DRESOURCETYPE, "GetType", [], sideeffects=False),
]

IDirect3DVertexDeclaration9.methods += [
    StdMethod(HRESULT, "GetDevice", [Out(Pointer(PDIRECT3DDEVICE9), "ppDevice")]),
    StdMethod(HRESULT, "GetDeclaration", [Out(Array(D3DVERTEXELEMENT9, "*pNumElements"), "pElement"), Out(Pointer(UINT), "pNumElements")], sideeffects=False),
]

IDirect3DVertexShader9.methods += [
    StdMethod(HRESULT, "GetDevice", [Out(Pointer(PDIRECT3DDEVICE9), "ppDevice")]),
    StdMethod(HRESULT, "GetFunction", [Out(OpaqueBlob(Void, "*pSizeOfData"), "pData"), Out(Pointer(UINT), "pSizeOfData")], sideeffects=False),
]

IDirect3DPixelShader9.methods += [
    StdMethod(HRESULT, "GetDevice", [Out(Pointer(PDIRECT3DDEVICE9), "ppDevice")]),
    StdMethod(HRESULT, "GetFunction", [Out(OpaqueBlob(Void, "*pSizeOfData"), "pData"), Out(Pointer(UINT), "pSizeOfData")], sideeffects=False),
]

IDirect3DBaseTexture9.methods += [
    StdMethod(DWORD, "SetLOD", [(DWORD, "LODNew")]),
    StdMethod(DWORD, "GetLOD", [], sideeffects=False),
    StdMethod(DWORD, "GetLevelCount", [], sideeffects=False),
    StdMethod(HRESULT, "SetAutoGenFilterType", [(D3DTEXTUREFILTERTYPE, "FilterType")]),
    StdMethod(D3DTEXTUREFILTERTYPE, "GetAutoGenFilterType", [], sideeffects=False),
    StdMethod(Void, "GenerateMipSubLevels", []),
]

IDirect3DTexture9.methods += [
    StdMethod(HRESULT, "GetLevelDesc", [(UINT, "Level"), Out(Pointer(D3DSURFACE_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "GetSurfaceLevel", [(UINT, "Level"), Out(Pointer(PDIRECT3DSURFACE9), "ppSurfaceLevel")]),
    StdMethod(HRESULT, "LockRect", [(UINT, "Level"), Out(Pointer(D3DLOCKED_RECT), "pLockedRect"), (ConstPointer(RECT), "pRect"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "UnlockRect", [(UINT, "Level")]),
    StdMethod(HRESULT, "AddDirtyRect", [(ConstPointer(RECT), "pDirtyRect")]),
]

IDirect3DVolumeTexture9.methods += [
    StdMethod(HRESULT, "GetLevelDesc", [(UINT, "Level"), Out(Pointer(D3DVOLUME_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "GetVolumeLevel", [(UINT, "Level"), Out(Pointer(PDIRECT3DVOLUME9), "ppVolumeLevel")]),
    StdMethod(HRESULT, "LockBox", [(UINT, "Level"), Out(Pointer(D3DLOCKED_BOX), "pLockedVolume"), (ConstPointer(D3DBOX), "pBox"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "UnlockBox", [(UINT, "Level")]),
    StdMethod(HRESULT, "AddDirtyBox", [(ConstPointer(D3DBOX), "pDirtyBox")]),
]

IDirect3DCubeTexture9.methods += [
    StdMethod(HRESULT, "GetLevelDesc", [(UINT, "Level"), Out(Pointer(D3DSURFACE_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "GetCubeMapSurface", [(D3DCUBEMAP_FACES, "FaceType"), (UINT, "Level"), Out(Pointer(PDIRECT3DSURFACE9), "ppCubeMapSurface")]),
    StdMethod(HRESULT, "LockRect", [(D3DCUBEMAP_FACES, "FaceType"), (UINT, "Level"), Out(Pointer(D3DLOCKED_RECT), "pLockedRect"), (ConstPointer(RECT), "pRect"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "UnlockRect", [(D3DCUBEMAP_FACES, "FaceType"), (UINT, "Level")]),
    StdMethod(HRESULT, "AddDirtyRect", [(D3DCUBEMAP_FACES, "FaceType"), (ConstPointer(RECT), "pDirtyRect")]),
]

IDirect3DVertexBuffer9.methods += [
    StdMethod(HRESULT, "Lock", [(UINT, "OffsetToLock"), (UINT, "SizeToLock"), Out(Pointer(LinearPointer(Void, "_MappedSize")), "ppbData"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "Unlock", []),
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(D3DVERTEXBUFFER_DESC), "pDesc")], sideeffects=False),
]

IDirect3DIndexBuffer9.methods += [
    StdMethod(HRESULT, "Lock", [(UINT, "OffsetToLock"), (UINT, "SizeToLock"), Out(Pointer(LinearPointer(Void, "_MappedSize")), "ppbData"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "Unlock", []),
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(D3DINDEXBUFFER_DESC), "pDesc")], sideeffects=False),
]

IDirect3DSurface9.methods += [
    StdMethod(HRESULT, "GetContainer", [(REFIID, "riid"), Out(Pointer(ObjPointer(Void)), "ppContainer")]),
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(D3DSURFACE_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "LockRect", [Out(Pointer(D3DLOCKED_RECT), "pLockedRect"), (ConstPointer(RECT), "pRect"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "UnlockRect", []),
    StdMethod(HRESULT, "GetDC", [Out(Pointer(HDC), "phdc")]),
    StdMethod(HRESULT, "ReleaseDC", [(HDC, "hdc")]),
]

IDirect3DVolume9.methods += [
    StdMethod(HRESULT, "GetDevice", [Out(Pointer(PDIRECT3DDEVICE9), "ppDevice")]),
    StdMethod(HRESULT, "SetPrivateData", [(REFGUID, "refguid"), (OpaqueBlob(Const(Void), "SizeOfData"), "pData"), (DWORD, "SizeOfData"), (D3DSPD, "Flags")], sideeffects=False),
    StdMethod(HRESULT, "GetPrivateData", [(REFGUID, "refguid"), Out(OpaqueBlob(Void, "*pSizeOfData"), "pData"), Out(Pointer(DWORD), "pSizeOfData")], sideeffects=False),
    StdMethod(HRESULT, "FreePrivateData", [(REFGUID, "refguid")], sideeffects=False),
    StdMethod(HRESULT, "GetContainer", [(REFIID, "riid"), Out(Pointer(ObjPointer(Void)), "ppContainer")]),
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(D3DVOLUME_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "LockBox", [Out(Pointer(D3DLOCKED_BOX), "pLockedVolume"), (ConstPointer(D3DBOX), "pBox"), (D3DLOCK, "Flags")]),
    StdMethod(HRESULT, "UnlockBox", []),
]

IDirect3DQuery9.methods += [
    StdMethod(HRESULT, "GetDevice", [Out(Pointer(PDIRECT3DDEVICE9), "ppDevice")]),
    StdMethod(D3DQUERYTYPE, "GetType", [], sideeffects=False),
    StdMethod(DWORD, "GetDataSize", [], sideeffects=False),
    StdMethod(HRESULT, "Issue", [(D3DISSUE, "dwIssueFlags")]),
    StdMethod(HRESULT, "GetData", [Out(D3DQUERYDATA, "pData"), (DWORD, "dwSize"), (D3DGETDATA, "dwGetDataFlags")], sideeffects=False),
]

IDirect3D9Ex.methods += [
    StdMethod(UINT, "GetAdapterModeCountEx", [(D3DADAPTER, "Adapter"), (ConstPointer(D3DDISPLAYMODEFILTER), "pFilter") ], sideeffects=False),
    StdMethod(HRESULT, "EnumAdapterModesEx", [(D3DADAPTER, "Adapter"), (ConstPointer(D3DDISPLAYMODEFILTER), "pFilter"), (UINT, "Mode"), Out(Pointer(D3DDISPLAYMODEEX), "pMode")], sideeffects=False),
    StdMethod(HRESULT, "GetAdapterDisplayModeEx", [(D3DADAPTER, "Adapter"), Out(Pointer(D3DDISPLAYMODEEX), "pMode"), Out(Pointer(D3DDISPLAYROTATION), "pRotation")], sideeffects=False),
    StdMethod(HRESULT, "CreateDeviceEx", [(D3DADAPTER, "Adapter"), (D3DDEVTYPE, "DeviceType"), (HWND, "hFocusWindow"), (D3DCREATE, "BehaviorFlags"), InOut(Pointer(D3DPRESENT_PARAMETERS), "pPresentationParameters"), Out(Pointer(D3DDISPLAYMODEEX), "pFullscreenDisplayMode"), Out(Pointer(PDIRECT3DDEVICE9EX), "ppReturnedDeviceInterface")]),
    StdMethod(HRESULT, "GetAdapterLUID", [(D3DADAPTER, "Adapter"), Out(Pointer(LUID), "pLUID")], sideeffects=False),
]

IDirect3DDevice9Ex.methods += [
    StdMethod(HRESULT, "SetConvolutionMonoKernel", [(UINT, "width"), (UINT, "height"), (Array(Float, "width"), "rows"), (Array(Float, "height"), "columns")]),
    StdMethod(HRESULT, "ComposeRects", [(PDIRECT3DSURFACE9, "pSrc"), (PDIRECT3DSURFACE9, "pDst"), (PDIRECT3DVERTEXBUFFER9, "pSrcRectDescs"), (UINT, "NumRects"), (PDIRECT3DVERTEXBUFFER9, "pDstRectDescs"), (D3DCOMPOSERECTSOP, "Operation"), (Int, "Xoffset"), (Int, "Yoffset")]),
    StdMethod(HRESULT, "PresentEx", [(ConstPointer(RECT), "pSourceRect"), (ConstPointer(RECT), "pDestRect"), (HWND, "hDestWindowOverride"), (ConstPointer(RGNDATA), "pDirtyRegion"), (D3DPRESENT, "dwFlags")]),
    StdMethod(HRESULT, "GetGPUThreadPriority", [Out(Pointer(INT), "pPriority")], sideeffects=False),
    StdMethod(HRESULT, "SetGPUThreadPriority", [(INT, "Priority")]),
    StdMethod(HRESULT, "WaitForVBlank", [(UINT, "iSwapChain")]),
    StdMethod(HRESULT, "CheckResourceResidency", [(Array(PDIRECT3DRESOURCE9, "NumResources"), "pResourceArray"), (UINT32, "NumResources")]),
    StdMethod(HRESULT, "SetMaximumFrameLatency", [(UINT, "MaxLatency")]),
    StdMethod(HRESULT, "GetMaximumFrameLatency", [Out(Pointer(UINT), "pMaxLatency")], sideeffects=False),
    StdMethod(HRESULT, "CheckDeviceState", [(HWND, "hDestinationWindow")], sideeffects=False),
    StdMethod(HRESULT, "CreateRenderTargetEx", [(UINT, "Width"), (UINT, "Height"), (D3DFORMAT, "Format"), (D3DMULTISAMPLE_TYPE, "MultiSample"), (DWORD, "MultisampleQuality"), (BOOL, "Lockable"), Out(Pointer(PDIRECT3DSURFACE9), "ppSurface"), (Pointer(HANDLE), "pSharedHandle"), (D3DUSAGE, "Usage")]),
    StdMethod(HRESULT, "CreateOffscreenPlainSurfaceEx", [(UINT, "Width"), (UINT, "Height"), (D3DFORMAT, "Format"), (D3DPOOL, "Pool"), Out(Pointer(PDIRECT3DSURFACE9), "ppSurface"), Out(Pointer(HANDLE), "pSharedHandle"), (D3DUSAGE, "Usage")]),
    StdMethod(HRESULT, "CreateDepthStencilSurfaceEx", [(UINT, "Width"), (UINT, "Height"), (D3DFORMAT, "Format"), (D3DMULTISAMPLE_TYPE, "MultiSample"), (DWORD, "MultisampleQuality"), (BOOL, "Discard"), Out(Pointer(PDIRECT3DSURFACE9), "ppSurface"), (Pointer(HANDLE), "pSharedHandle"), (D3DUSAGE, "Usage")]),
    StdMethod(HRESULT, "ResetEx", [InOut(Pointer(D3DPRESENT_PARAMETERS), "pPresentationParameters"), Out(Pointer(D3DDISPLAYMODEEX), "pFullscreenDisplayMode")]),
    StdMethod(HRESULT, "GetDisplayModeEx", [(UINT, "iSwapChain"), Out(Pointer(D3DDISPLAYMODEEX), "pMode"), Out(Pointer(D3DDISPLAYROTATION), "pRotation")], sideeffects=False),
]

IDirect3DSwapChain9Ex.methods += [
    StdMethod(HRESULT, "GetLastPresentCount", [Out(Pointer(UINT), "pLastPresentCount")], sideeffects=False),
    StdMethod(HRESULT, "GetPresentStats", [Out(Pointer(D3DPRESENTSTATS), "pPresentationStatistics")], sideeffects=False),
    StdMethod(HRESULT, "GetDisplayModeEx", [Out(Pointer(D3DDISPLAYMODEEX), "pMode"), Out(Pointer(D3DDISPLAYROTATION), "pRotation")], sideeffects=False),
]

d3d9 = Module("d3d9")
d3d9.addFunctions([
    StdFunction(PDIRECT3D9, "Direct3DCreate9", [(UINT, "SDKVersion")], fail='NULL'),
    StdFunction(HRESULT, "Direct3DCreate9Ex", [(UINT, "SDKVersion"), Out(Pointer(PDIRECT3D9EX), "ppD3D")], fail='D3DERR_NOTAVAILABLE'),
    StdFunction(Int, "D3DPERF_BeginEvent", [(D3DCOLOR, "col"), (LPCWSTR, "wszName")], fail='-1', sideeffects=False),
    StdFunction(Int, "D3DPERF_EndEvent", [], fail='-1', sideeffects=False),
    StdFunction(Void, "D3DPERF_SetMarker", [(D3DCOLOR, "col"), (LPCWSTR, "wszName")], sideeffects=False),
    StdFunction(Void, "D3DPERF_SetRegion", [(D3DCOLOR, "col"), (LPCWSTR, "wszName")], sideeffects=False),
    StdFunction(BOOL, "D3DPERF_QueryRepeatFrame", [], fail='FALSE', sideeffects=False),
    StdFunction(Void, "D3DPERF_SetOptions", [(DWORD, "dwOptions")], sideeffects=False),
    StdFunction(DWORD, "D3DPERF_GetStatus", [], fail='0', sideeffects=False),
])
d3d9.addInterfaces([
    IDirect3DSwapChain9Ex,
])

########NEW FILE########
__FILENAME__ = d3d9caps
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""d3d9caps.h"""

from winapi import *
from d3d9types import *

D3DVS20CAPS = Flags(DWORD, [
    "D3DVS20CAPS_PREDICATION",
])

D3DVSHADERCAPS2_0 = Struct("D3DVSHADERCAPS2_0", [
    (D3DVS20CAPS, "Caps"),
    (INT, "DynamicFlowControlDepth"),
    (INT, "NumTemps"),
    (INT, "StaticFlowControlDepth"),
])

D3DPS20CAPS = Flags(DWORD, [
    "D3DPS20CAPS_ARBITRARYSWIZZLE",
    "D3DPS20CAPS_GRADIENTINSTRUCTIONS",
    "D3DPS20CAPS_PREDICATION",
    "D3DPS20CAPS_NODEPENDENTREADLIMIT",
    "D3DPS20CAPS_NOTEXINSTRUCTIONLIMIT",
])

D3DPSHADERCAPS2_0 = Struct("D3DPSHADERCAPS2_0", [
    (D3DPS20CAPS, "Caps"),
    (INT, "DynamicFlowControlDepth"),
    (INT, "NumTemps"),
    (INT, "StaticFlowControlDepth"),
    (INT, "NumInstructionSlots"),
])

D3DCAPS = Flags(DWORD, [
    "D3DCAPS_READ_SCANLINE",
])

D3DCAPS2 = Flags(DWORD, [
    "D3DCAPS2_FULLSCREENGAMMA",
    "D3DCAPS2_CANCALIBRATEGAMMA",
    "D3DCAPS2_RESERVED",
    "D3DCAPS2_CANMANAGERESOURCE",
    "D3DCAPS2_DYNAMICTEXTURES",
    "D3DCAPS2_CANAUTOGENMIPMAP",
    "D3DCAPS2_CANSHARERESOURCE",
])

D3DCAPS3 = Flags(DWORD, [
    "D3DCAPS3_RESERVED",
    "D3DCAPS3_ALPHA_FULLSCREEN_FLIP_OR_DISCARD",
    "D3DCAPS3_LINEAR_TO_SRGB_PRESENTATION",
    "D3DCAPS3_COPY_TO_VIDMEM",
    "D3DCAPS3_COPY_TO_SYSTEMMEM",
    "D3DCAPS3_DXVAHD",
])

D3DCURSORCAPS = Flags(DWORD, [
    "D3DCURSORCAPS_COLOR",
    "D3DCURSORCAPS_LOWRES",
])

D3DDEVCAPS = Flags(DWORD, [
    "D3DDEVCAPS_EXECUTESYSTEMMEMORY",
    "D3DDEVCAPS_EXECUTEVIDEOMEMORY",
    "D3DDEVCAPS_TLVERTEXSYSTEMMEMORY",
    "D3DDEVCAPS_TLVERTEXVIDEOMEMORY",
    "D3DDEVCAPS_TEXTURESYSTEMMEMORY",
    "D3DDEVCAPS_TEXTUREVIDEOMEMORY",
    "D3DDEVCAPS_DRAWPRIMTLVERTEX",
    "D3DDEVCAPS_CANRENDERAFTERFLIP",
    "D3DDEVCAPS_TEXTURENONLOCALVIDMEM",
    "D3DDEVCAPS_DRAWPRIMITIVES2",
    "D3DDEVCAPS_SEPARATETEXTUREMEMORIES",
    "D3DDEVCAPS_DRAWPRIMITIVES2EX",
    "D3DDEVCAPS_HWTRANSFORMANDLIGHT",
    "D3DDEVCAPS_CANBLTSYSTONONLOCAL",
    "D3DDEVCAPS_HWRASTERIZATION",
    "D3DDEVCAPS_PUREDEVICE",
    "D3DDEVCAPS_QUINTICRTPATCHES",
    "D3DDEVCAPS_RTPATCHES",
    "D3DDEVCAPS_RTPATCHHANDLEZERO",
    "D3DDEVCAPS_NPATCHES",
])

D3DPMISCCAPS = Flags(DWORD, [
    "D3DPMISCCAPS_MASKZ",
    "D3DPMISCCAPS_CULLNONE",
    "D3DPMISCCAPS_CULLCW",
    "D3DPMISCCAPS_CULLCCW",
    "D3DPMISCCAPS_COLORWRITEENABLE",
    "D3DPMISCCAPS_CLIPPLANESCALEDPOINTS",
    "D3DPMISCCAPS_CLIPTLVERTS",
    "D3DPMISCCAPS_TSSARGTEMP",
    "D3DPMISCCAPS_BLENDOP",
    "D3DPMISCCAPS_NULLREFERENCE",
    "D3DPMISCCAPS_INDEPENDENTWRITEMASKS",
    "D3DPMISCCAPS_PERSTAGECONSTANT",
    "D3DPMISCCAPS_FOGANDSPECULARALPHA",
    "D3DPMISCCAPS_SEPARATEALPHABLEND",
    "D3DPMISCCAPS_MRTINDEPENDENTBITDEPTHS",
    "D3DPMISCCAPS_MRTPOSTPIXELSHADERBLENDING",
    "D3DPMISCCAPS_FOGVERTEXCLAMPED",
    "D3DPMISCCAPS_POSTBLENDSRGBCONVERT",
])

D3DLINECAPS = Flags(DWORD, [
    "D3DLINECAPS_TEXTURE",
    "D3DLINECAPS_ZTEST",
    "D3DLINECAPS_BLEND",
    "D3DLINECAPS_ALPHACMP",
    "D3DLINECAPS_FOG",
    "D3DLINECAPS_ANTIALIAS",
])

D3DPRASTERCAPS = Flags(DWORD, [
    "D3DPRASTERCAPS_DITHER",
    "D3DPRASTERCAPS_ZTEST",
    "D3DPRASTERCAPS_FOGVERTEX",
    "D3DPRASTERCAPS_FOGTABLE",
    "D3DPRASTERCAPS_MIPMAPLODBIAS",
    "D3DPRASTERCAPS_ZBUFFERLESSHSR",
    "D3DPRASTERCAPS_FOGRANGE",
    "D3DPRASTERCAPS_ANISOTROPY",
    "D3DPRASTERCAPS_WBUFFER",
    "D3DPRASTERCAPS_WFOG",
    "D3DPRASTERCAPS_ZFOG",
    "D3DPRASTERCAPS_COLORPERSPECTIVE",
    "D3DPRASTERCAPS_SCISSORTEST",
    "D3DPRASTERCAPS_SLOPESCALEDEPTHBIAS",
    "D3DPRASTERCAPS_DEPTHBIAS",
    "D3DPRASTERCAPS_MULTISAMPLE_TOGGLE",
])

D3DPCMPCAPS = Flags(DWORD, [
    "D3DPCMPCAPS_NEVER",
    "D3DPCMPCAPS_LESS",
    "D3DPCMPCAPS_EQUAL",
    "D3DPCMPCAPS_LESSEQUAL",
    "D3DPCMPCAPS_GREATER",
    "D3DPCMPCAPS_NOTEQUAL",
    "D3DPCMPCAPS_GREATEREQUAL",
    "D3DPCMPCAPS_ALWAYS",
])

D3DPBLENDCAPS = Flags(DWORD, [
    "D3DPBLENDCAPS_ZERO",
    "D3DPBLENDCAPS_ONE",
    "D3DPBLENDCAPS_SRCCOLOR",
    "D3DPBLENDCAPS_INVSRCCOLOR",
    "D3DPBLENDCAPS_SRCALPHA",
    "D3DPBLENDCAPS_INVSRCALPHA",
    "D3DPBLENDCAPS_DESTALPHA",
    "D3DPBLENDCAPS_INVDESTALPHA",
    "D3DPBLENDCAPS_DESTCOLOR",
    "D3DPBLENDCAPS_INVDESTCOLOR",
    "D3DPBLENDCAPS_SRCALPHASAT",
    "D3DPBLENDCAPS_BOTHSRCALPHA",
    "D3DPBLENDCAPS_BOTHINVSRCALPHA",
    "D3DPBLENDCAPS_BLENDFACTOR",
    "D3DPBLENDCAPS_SRCCOLOR2",
    "D3DPBLENDCAPS_INVSRCCOLOR2",
])

D3DPSHADECAPS = Flags(DWORD, [
    "D3DPSHADECAPS_COLORGOURAUDRGB",
    "D3DPSHADECAPS_SPECULARGOURAUDRGB",
    "D3DPSHADECAPS_ALPHAGOURAUDBLEND",
    "D3DPSHADECAPS_FOGGOURAUD",
])

D3DPTEXTURECAPS = Flags(DWORD, [
    "D3DPTEXTURECAPS_PERSPECTIVE",
    "D3DPTEXTURECAPS_POW2",
    "D3DPTEXTURECAPS_ALPHA",
    "D3DPTEXTURECAPS_SQUAREONLY",
    "D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE",
    "D3DPTEXTURECAPS_ALPHAPALETTE",
    "D3DPTEXTURECAPS_NONPOW2CONDITIONAL",
    "D3DPTEXTURECAPS_PROJECTED",
    "D3DPTEXTURECAPS_CUBEMAP",
    "D3DPTEXTURECAPS_VOLUMEMAP",
    "D3DPTEXTURECAPS_MIPMAP",
    "D3DPTEXTURECAPS_MIPVOLUMEMAP",
    "D3DPTEXTURECAPS_MIPCUBEMAP",
    "D3DPTEXTURECAPS_CUBEMAP_POW2",
    "D3DPTEXTURECAPS_VOLUMEMAP_POW2",
    "D3DPTEXTURECAPS_NOPROJECTEDBUMPENV",
])

D3DPTFILTERCAPS = Flags(DWORD, [
    "D3DPTFILTERCAPS_MINFPOINT",
    "D3DPTFILTERCAPS_MINFLINEAR",
    "D3DPTFILTERCAPS_MINFANISOTROPIC",
    "D3DPTFILTERCAPS_MINFPYRAMIDALQUAD",
    "D3DPTFILTERCAPS_MINFGAUSSIANQUAD",
    "D3DPTFILTERCAPS_MIPFPOINT",
    "D3DPTFILTERCAPS_MIPFLINEAR",
    "D3DPTFILTERCAPS_CONVOLUTIONMONO",
    "D3DPTFILTERCAPS_MAGFPOINT",
    "D3DPTFILTERCAPS_MAGFLINEAR",
    "D3DPTFILTERCAPS_MAGFANISOTROPIC",
    "D3DPTFILTERCAPS_MAGFPYRAMIDALQUAD",
    "D3DPTFILTERCAPS_MAGFGAUSSIANQUAD",
])

D3DPTADDRESSCAPS = Flags(DWORD, [
    "D3DPTADDRESSCAPS_WRAP",
    "D3DPTADDRESSCAPS_MIRROR",
    "D3DPTADDRESSCAPS_CLAMP",
    "D3DPTADDRESSCAPS_BORDER",
    "D3DPTADDRESSCAPS_INDEPENDENTUV",
    "D3DPTADDRESSCAPS_MIRRORONCE",
])

D3DSTENCILCAPS = Flags(DWORD, [
    "D3DSTENCILCAPS_KEEP",
    "D3DSTENCILCAPS_ZERO",
    "D3DSTENCILCAPS_REPLACE",
    "D3DSTENCILCAPS_INCRSAT",
    "D3DSTENCILCAPS_DECRSAT",
    "D3DSTENCILCAPS_INVERT",
    "D3DSTENCILCAPS_INCR",
    "D3DSTENCILCAPS_DECR",
    "D3DSTENCILCAPS_TWOSIDED",
])

D3DTEXOPCAPS = Flags(DWORD, [
    "D3DTEXOPCAPS_DISABLE",
    "D3DTEXOPCAPS_SELECTARG1",
    "D3DTEXOPCAPS_SELECTARG2",
    "D3DTEXOPCAPS_MODULATE",
    "D3DTEXOPCAPS_MODULATE2X",
    "D3DTEXOPCAPS_MODULATE4X",
    "D3DTEXOPCAPS_ADD",
    "D3DTEXOPCAPS_ADDSIGNED",
    "D3DTEXOPCAPS_ADDSIGNED2X",
    "D3DTEXOPCAPS_SUBTRACT",
    "D3DTEXOPCAPS_ADDSMOOTH",
    "D3DTEXOPCAPS_BLENDDIFFUSEALPHA",
    "D3DTEXOPCAPS_BLENDTEXTUREALPHA",
    "D3DTEXOPCAPS_BLENDFACTORALPHA",
    "D3DTEXOPCAPS_BLENDTEXTUREALPHAPM",
    "D3DTEXOPCAPS_BLENDCURRENTALPHA",
    "D3DTEXOPCAPS_PREMODULATE",
    "D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR",
    "D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA",
    "D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR",
    "D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA",
    "D3DTEXOPCAPS_BUMPENVMAP",
    "D3DTEXOPCAPS_BUMPENVMAPLUMINANCE",
    "D3DTEXOPCAPS_DOTPRODUCT3",
    "D3DTEXOPCAPS_MULTIPLYADD",
    "D3DTEXOPCAPS_LERP",
])

D3DFVFCAPS = Flags(DWORD, [
    "D3DFVFCAPS_TEXCOORDCOUNTMASK",
    "D3DFVFCAPS_DONOTSTRIPELEMENTS",
    "D3DFVFCAPS_PSIZE",
])

D3DVTXPCAPS = Flags(DWORD, [
    "D3DVTXPCAPS_TEXGEN",
    "D3DVTXPCAPS_MATERIALSOURCE7",
    "D3DVTXPCAPS_DIRECTIONALLIGHTS",
    "D3DVTXPCAPS_POSITIONALLIGHTS",
    "D3DVTXPCAPS_LOCALVIEWER",
    "D3DVTXPCAPS_TWEENING",
    "D3DVTXPCAPS_TEXGEN_SPHEREMAP",
    "D3DVTXPCAPS_NO_TEXGEN_NONLOCALVIEWER",
])

D3DDEVCAPS2 = Flags(DWORD, [
    "D3DDEVCAPS2_STREAMOFFSET",
    "D3DDEVCAPS2_DMAPNPATCH",
    "D3DDEVCAPS2_ADAPTIVETESSRTPATCH",
    "D3DDEVCAPS2_ADAPTIVETESSNPATCH",
    "D3DDEVCAPS2_CAN_STRETCHRECT_FROM_TEXTURES",
    "D3DDEVCAPS2_PRESAMPLEDDMAPNPATCH",
    "D3DDEVCAPS2_VERTEXELEMENTSCANSHARESTREAMOFFSET",
])

D3DDTCAPS = Flags(DWORD, [
    "D3DDTCAPS_UBYTE4",
    "D3DDTCAPS_UBYTE4N",
    "D3DDTCAPS_SHORT2N",
    "D3DDTCAPS_SHORT4N",
    "D3DDTCAPS_USHORT2N",
    "D3DDTCAPS_USHORT4N",
    "D3DDTCAPS_UDEC3",
    "D3DDTCAPS_DEC3N",
    "D3DDTCAPS_FLOAT16_2",
    "D3DDTCAPS_FLOAT16_4",
])

#D3DPS_VERSION = Enum("DWORD", [
#    "D3DPS_VERSION(0,0)",
#    "D3DPS_VERSION(1,0)",
#    "D3DPS_VERSION(1,1)",
#    "D3DPS_VERSION(1,2)",
#    "D3DPS_VERSION(1,3)",
#    "D3DPS_VERSION(1,4)",
#    "D3DPS_VERSION(2,0)",
#    "D3DPS_VERSION(3,0)",
#])
D3DPS_VERSION = DWORD

#D3DVS_VERSION = Enum("DWORD", [
#    "D3DVS_VERSION(0,0)",
#    "D3DVS_VERSION(1,0)",
#    "D3DVS_VERSION(1,1)",
#    "D3DVS_VERSION(2,0)",
#    "D3DVS_VERSION(3,0)",
#])
D3DVS_VERSION = DWORD

D3DCAPS9 = Struct("D3DCAPS9", [
    (D3DDEVTYPE, "DeviceType"),
    (UINT, "AdapterOrdinal"),
    (D3DCAPS, "Caps"),
    (D3DCAPS2, "Caps2"),
    (D3DCAPS3, "Caps3"),
    (D3DPRESENT_INTERVAL, "PresentationIntervals"),
    (D3DCURSORCAPS, "CursorCaps"),
    (D3DDEVCAPS, "DevCaps"),
    (D3DPMISCCAPS, "PrimitiveMiscCaps"),
    (D3DPRASTERCAPS, "RasterCaps"),
    (D3DPCMPCAPS, "ZCmpCaps"),
    (D3DPBLENDCAPS, "SrcBlendCaps"),
    (D3DPBLENDCAPS, "DestBlendCaps"),
    (D3DPCMPCAPS, "AlphaCmpCaps"),
    (D3DPSHADECAPS, "ShadeCaps"),
    (D3DPTEXTURECAPS, "TextureCaps"),
    (D3DPTFILTERCAPS, "TextureFilterCaps"),
    (D3DPTFILTERCAPS, "CubeTextureFilterCaps"),
    (D3DPTFILTERCAPS, "VolumeTextureFilterCaps"),
    (D3DPTADDRESSCAPS, "TextureAddressCaps"),
    (D3DPTADDRESSCAPS, "VolumeTextureAddressCaps"),
    (D3DLINECAPS, "LineCaps"),
    (DWORD, "MaxTextureWidth"),
    (DWORD, "MaxTextureHeight"),
    (DWORD, "MaxVolumeExtent"),
    (DWORD, "MaxTextureRepeat"),
    (DWORD, "MaxTextureAspectRatio"),
    (DWORD, "MaxAnisotropy"),
    (Float, "MaxVertexW"),
    (Float, "GuardBandLeft"),
    (Float, "GuardBandTop"),
    (Float, "GuardBandRight"),
    (Float, "GuardBandBottom"),
    (Float, "ExtentsAdjust"),
    (D3DSTENCILCAPS, "StencilCaps"),
    (D3DFVFCAPS, "FVFCaps"),
    (D3DTEXOPCAPS, "TextureOpCaps"),
    (DWORD, "MaxTextureBlendStages"),
    (DWORD, "MaxSimultaneousTextures"),
    (D3DVTXPCAPS, "VertexProcessingCaps"),
    (DWORD, "MaxActiveLights"),
    (DWORD, "MaxUserClipPlanes"),
    (DWORD, "MaxVertexBlendMatrices"),
    (DWORD, "MaxVertexBlendMatrixIndex"),
    (Float, "MaxPointSize"),
    (DWORD, "MaxPrimitiveCount"),
    (DWORD, "MaxVertexIndex"),
    (DWORD, "MaxStreams"),
    (DWORD, "MaxStreamStride"),
    (D3DVS_VERSION, "VertexShaderVersion"),
    (DWORD, "MaxVertexShaderConst"),
    (D3DPS_VERSION, "PixelShaderVersion"),
    (Float, "PixelShader1xMaxValue"),
    (D3DDEVCAPS2, "DevCaps2"),
    (Float, "MaxNpatchTessellationLevel"),
    (DWORD, "Reserved5"),
    (UINT, "MasterAdapterOrdinal"),
    (UINT, "AdapterOrdinalInGroup"),
    (UINT, "NumberOfAdaptersInGroup"),
    (D3DDTCAPS, "DeclTypes"),
    (DWORD, "NumSimultaneousRTs"),
    (D3DPTFILTERCAPS, "StretchRectFilterCaps"),
    (D3DVSHADERCAPS2_0, "VS20Caps"),
    (D3DPSHADERCAPS2_0, "PS20Caps"),
    (D3DPTFILTERCAPS, "VertexTextureFilterCaps"),
    (DWORD, "MaxVShaderInstructionsExecuted"),
    (DWORD, "MaxPShaderInstructionsExecuted"),
    (DWORD, "MaxVertexShader30InstructionSlots"),
    (DWORD, "MaxPixelShader30InstructionSlots"),
])


########NEW FILE########
__FILENAME__ = d3d9dxva2
##########################################################################
#
# Copyright 2012 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from d3d9 import *

REFERENCE_TIME = Alias("REFERENCE_TIME", LONGLONG)

DXVA2_ProcAmp = Flags(UINT, [
    "DXVA2_ProcAmp_None",
    "DXVA2_ProcAmp_Brightness",
    "DXVA2_ProcAmp_Contrast",
    "DXVA2_ProcAmp_Hue",
    "DXVA2_ProcAmp_Saturation",
])

HRESULT = FakeEnum(HRESULT, [
    "DXVA2_E_NOT_INITIALIZED",
    "DXVA2_E_NEW_VIDEO_DEVICE",
    "DXVA2_E_VIDEO_DEVICE_LOCKED",
    "DXVA2_E_NOT_AVAILABLE",
])

DXVA2_SampleFormat = Enum("DXVA2_SampleFormat", [
    "DXVA2_SampleFormatMask",
    "DXVA2_SampleUnknown",
    "DXVA2_SampleProgressiveFrame",
    "DXVA2_SampleFieldInterleavedEvenFirst",
    "DXVA2_SampleFieldInterleavedOddFirst",
    "DXVA2_SampleFieldSingleEven",
    "DXVA2_SampleFieldSingleOdd",
    "DXVA2_SampleSubStream",
])

DXVA2_VideoChromaSubSampling = Enum("DXVA2_VideoChromaSubSampling", [
    "DXVA2_VideoChromaSubsamplingMask",
    "DXVA2_VideoChromaSubsampling_Unknown",
    "DXVA2_VideoChromaSubsampling_ProgressiveChroma",
    "DXVA2_VideoChromaSubsampling_Horizontally_Cosited",
    "DXVA2_VideoChromaSubsampling_Vertically_Cosited",
    "DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes",
    "DXVA2_VideoChromaSubsampling_MPEG2",
    "DXVA2_VideoChromaSubsampling_MPEG1",
    "DXVA2_VideoChromaSubsampling_DV_PAL",
    "DXVA2_VideoChromaSubsampling_Cosited",
])

DXVA2_NominalRange = Enum("DXVA2_NominalRange", [
    "DXVA2_NominalRangeMask",
    "DXVA2_NominalRange_Unknown",
    "DXVA2_NominalRange_Normal",
    "DXVA2_NominalRange_Wide",
    "DXVA2_NominalRange_0_255",
    "DXVA2_NominalRange_16_235",
    "DXVA2_NominalRange_48_208",
])

DXVA2_VideoLighting = Enum("DXVA2_VideoLighting", [
    "DXVA2_VideoLightingMask",
    "DXVA2_VideoLighting_Unknown",
    "DXVA2_VideoLighting_bright",
    "DXVA2_VideoLighting_office",
    "DXVA2_VideoLighting_dim",
    "DXVA2_VideoLighting_dark",
])

DXVA2_VideoPrimaries = Enum("DXVA2_VideoPrimaries", [
    "DXVA2_VideoPrimariesMask",
    "DXVA2_VideoPrimaries_Unknown",
    "DXVA2_VideoPrimaries_reserved",
    "DXVA2_VideoPrimaries_BT709",
    "DXVA2_VideoPrimaries_BT470_2_SysM",
    "DXVA2_VideoPrimaries_BT470_2_SysBG",
    "DXVA2_VideoPrimaries_SMPTE170M",
    "DXVA2_VideoPrimaries_SMPTE240M",
    "DXVA2_VideoPrimaries_EBU3213",
    "DXVA2_VideoPrimaries_SMPTE_C",
])

DXVA2_VideoTransferFunction = Enum("DXVA2_VideoTransferFunction", [
    "DXVA2_VideoTransFuncMask",
    "DXVA2_VideoTransFunc_Unknown",
    "DXVA2_VideoTransFunc_10",
    "DXVA2_VideoTransFunc_18",
    "DXVA2_VideoTransFunc_20",
    "DXVA2_VideoTransFunc_22",
    "DXVA2_VideoTransFunc_709",
    "DXVA2_VideoTransFunc_240M",
    "DXVA2_VideoTransFunc_sRGB",
    "DXVA2_VideoTransFunc_28",
])

DXVA2_SurfaceType = FakeEnum(DWORD, [
    "DXVA2_SurfaceType_DecoderRenderTarget",
    "DXVA2_SurfaceType_ProcessorRenderTarget",
    "DXVA2_SurfaceType_D3DRenderTargetTexture",
])

DXVA2_VideoTransferMatrix = Enum("DXVA2_VideoTransferMatrix", [
    "DXVA2_VideoTransferMatrixMask",
    "DXVA2_VideoTransferMatrix_Unknown",
    "DXVA2_VideoTransferMatrix_BT709",
    "DXVA2_VideoTransferMatrix_BT601",
    "DXVA2_VideoTransferMatrix_SMPTE240M",
])

DXVA2_AYUVSample16 = Struct("DXVA2_AYUVSample16", [
    (USHORT, "Cr"),
    (USHORT, "Cb"),
    (USHORT, "Y"),
    (USHORT, "Alpha"),
])

DXVA2_AYUVSample8 = Struct("DXVA2_AYUVSample8", [
    (UCHAR, "Cr"),
    (UCHAR, "Cb"),
    (UCHAR, "Y"),
    (UCHAR, "Alpha"),
])

DXVA2_ConfigPictureDecode = Struct("DXVA2_ConfigPictureDecode", [
    (GUID, "guidConfigBitstreamEncryption"),
    (GUID, "guidConfigMBcontrolEncryption"),
    (GUID, "guidConfigResidDiffEncryption"),
    (UINT, "ConfigBitstreamRaw"),
    (UINT, "ConfigMBcontrolRasterOrder"),
    (UINT, "ConfigResidDiffHost"),
    (UINT, "ConfigSpatialResid8"),
    (UINT, "ConfigResid8Subtraction"),
    (UINT, "ConfigSpatialHost8or9Clipping"),
    (UINT, "ConfigSpatialResidInterleaved"),
    (UINT, "ConfigIntraResidUnsigned"),
    (UINT, "ConfigResidDiffAccelerator"),
    (UINT, "ConfigHostInverseScan"),
    (UINT, "ConfigSpecificIDCT"),
    (UINT, "Config4GroupedCoefs"),
    (USHORT, "ConfigMinRenderTargetBuffCount"),
    (USHORT, "ConfigDecoderSpecific"),
])

DXVA2_DecodeBufferDesc = Struct("DXVA2_DecodeBufferDesc", [
    (DWORD, "CompressedBufferType"),
    (UINT, "BufferIndex"),
    (UINT, "DataOffset"),
    (UINT, "DataSize"),
    (UINT, "FirstMBaddress"),
    (UINT, "NumMBsInBuffer"),
    (UINT, "Width"),
    (UINT, "Height"),
    (UINT, "Stride"),
    (UINT, "ReservedBits"),
    (PVOID, "pvPVPState"),
])

DXVA2_DecodeExtensionData = Struct("DXVA2_DecodeExtensionData", [
    (UINT, "Function"),
    (PVOID, "pPrivateInputData"),
    (UINT, "PrivateInputDataSize"),
    (PVOID, "pPrivateOutputData"),
    (UINT, "PrivateOutputDataSize"),
])

DXVA2_DecodeExecuteParams = Struct("DXVA2_DecodeExecuteParams", [
    (UINT, "NumCompBuffers"),
    (Array(DXVA2_DecodeBufferDesc, "{self}.NumCompBuffers"), "pCompressedBuffers"),
    (Pointer(DXVA2_DecodeExtensionData), "pExtensionData"),
])

DXVA2_ExtendedFormat = Struct("DXVA2_ExtendedFormat", [
    (UINT, "value"),
])

DXVA2_Fixed32 = Struct("DXVA2_Fixed32", [
    (USHORT, "Fraction"),
    (SHORT, "Value"),
])

DXVA2_FilterValues = Struct("DXVA2_FilterValues", [
    (DXVA2_Fixed32, "Level"),
    (DXVA2_Fixed32, "Threshold"),
    (DXVA2_Fixed32, "Radius"),
])

DXVA2_Frequency = Struct("DXVA2_Frequency", [
    (UINT, "Numerator"),
    (UINT, "Denominator"),
])

DXVA2_ProcAmpValues = Struct("DXVA2_ProcAmpValues", [
    (DXVA2_Fixed32, "Brightness"),
    (DXVA2_Fixed32, "Contrast"),
    (DXVA2_Fixed32, "Hue"),
    (DXVA2_Fixed32, "Saturation"),
])

DXVA2_ValueRange = Struct("DXVA2_ValueRange", [
    (DXVA2_Fixed32, "MinValue"),
    (DXVA2_Fixed32, "MaxValue"),
    (DXVA2_Fixed32, "DefaultValue"),
    (DXVA2_Fixed32, "StepSize"),
])

DXVA2_VideoDesc = Struct("DXVA2_VideoDesc", [
    (UINT, "SampleWidth"),
    (UINT, "SampleHeight"),
    (DXVA2_ExtendedFormat, "SampleFormat"),
    (D3DFORMAT, "Format"),
    (DXVA2_Frequency, "InputSampleFreq"),
    (DXVA2_Frequency, "OutputFrameFreq"),
    (UINT, "UABProtectionLevel"),
    (UINT, "Reserved"),
])

DXVA2_VideoProcessBltParams = Struct("DXVA2_VideoProcessBltParams", [
    (REFERENCE_TIME, "TargetFrame"),
    (RECT, "TargetRect"),
    (SIZE, "ConstrictionSize"),
    (UINT, "StreamingFlags"),
    (DXVA2_AYUVSample16, "BackgroundColor"),
    (DXVA2_ExtendedFormat, "DestFormat"),
    (DXVA2_ProcAmpValues, "ProcAmpValues"),
    (DXVA2_Fixed32, "Alpha"),
    (DXVA2_FilterValues, "NoiseFilterLuma"),
    (DXVA2_FilterValues, "NoiseFilterChroma"),
    (DXVA2_FilterValues, "DetailFilterLuma"),
    (DXVA2_FilterValues, "DetailFilterChroma"),
    (DWORD, "DestData"),
])

DXVA2_VideoProcessorCaps = Struct("DXVA2_VideoProcessorCaps", [
    (UINT, "DeviceCaps"),
    (D3DPOOL, "InputPool"),
    (UINT, "NumForwardRefSamples"),
    (UINT, "NumBackwardRefSamples"),
    (UINT, "Reserved"),
    (UINT, "DeinterlaceTechnology"),
    (UINT, "ProcAmpControlCaps"),
    (UINT, "VideoProcessorOperations"),
    (UINT, "NoiseFilterTechnology"),
    (UINT, "DetailFilterTechnology"),
])


# See also DXVADDI_PVP_KEY128
DXVA2_PVP_KEY128 = Struct('DXVA2_PVP_KEY128', [
    (Array(BYTE, 16), 'Data'),
])

# See also DXVADDI_PVP_SETKEY
DXVA2_PVP_SETKEY = Struct('DXVA2_PVP_SETKEY', [
    (DXVA2_PVP_KEY128, 'ContentKey'),
])

DXVA2_DECODEBUFFERDESC = Struct("DXVA2_DECODEBUFFERDESC", [
    (ObjPointer(IDirect3DSurface9), "pRenderTarget"),
    (DWORD, "CompressedBufferType"),
    (DWORD, "BufferIndex"),
    (DWORD, "DataOffset"),
    (DWORD, "DataSize"),
    (DWORD, "FirstMBaddress"),
    (DWORD, "NumMBsInBuffer"),
    (DWORD, "Width"),
    (DWORD, "Height"),
    (DWORD, "Stride"),
    (DWORD, "ReservedBits"),
    (PVOID, "pCipherCounter"),
])

DXVA2_DECODEEXECUTE = Struct("DXVA2_DECODEEXECUTE", [
    (UINT, "NumCompBuffers"),
    (Array(DXVA2_DECODEBUFFERDESC, "{self}.NumCompBuffers"), "pCompressedBuffers"),
])

DXVA2_VIDEOSAMPLE = Struct("DXVA2_VIDEOSAMPLE", [
    (REFERENCE_TIME, "Start"),
    (REFERENCE_TIME, "End"),
    (DXVA2_ExtendedFormat, "SampleFormat"),
    (DWORD, "SampleFlags"),
    (ObjPointer(IDirect3DSurface9), "SrcSurface"),
    (RECT, "SrcRect"),
    (RECT, "DstRect"),
    #(Array(DXVA2_AYUVSample8, 16), "Pal"),
    (DXVA2_Fixed32, "PlanarAlpha"),
])

DXVA2_VIDEOPROCESSBLT = Struct("DXVA2_VIDEOPROCESSBLT", [
    (REFERENCE_TIME, "TargetFrame"),
    (RECT, "TargetRect"),
    (SIZE, "ConstrictionSize"),
    (DWORD, "StreamingFlags"),
    (DXVA2_AYUVSample16, "BackgroundColor"),
    (DXVA2_ExtendedFormat, "DestFormat"),
    (DWORD, "DestFlags"),
    (DXVA2_ProcAmpValues, "ProcAmpValues"),
    (DXVA2_Fixed32, "Alpha"),
    (DXVA2_FilterValues, "NoiseFilterLuma"),
    (DXVA2_FilterValues, "NoiseFilterChroma"),
    (DXVA2_FilterValues, "DetailFilterLuma"),
    (DXVA2_FilterValues, "DetailFilterChroma"),
    (Array(DXVA2_VIDEOSAMPLE, "{self}.NumSrcSurfaces"), "pSrcSurfaces"),
    (UINT, "NumSrcSurfaces"),
])

DXVA2_EXTENSIONEXECUTE = Opaque('DXVA2_EXTENSIONEXECUTE')
DXVA2_DECODEBUFFERINFO = Opaque('DXVA2_DECODEBUFFERINFO')


IDirect3DDecodeDevice9 = Interface("IDirect3DDecodeDevice9", IUnknown)
IDirect3DDecodeDevice9.methods += [
    StdMethod(HRESULT, "DecodeBeginFrame", [(Pointer(DXVA2_PVP_SETKEY), "pPVPSetKey")]),
    StdMethod(HRESULT, "DecodeEndFrame", [(Pointer(HANDLE), "pHandleComplete")]),
    StdMethod(HRESULT, "DecodeSetRenderTarget", [(ObjPointer(IDirect3DSurface9), "pRenderTarget")]),
    StdMethod(HRESULT, "DecodeExecute", [(Pointer(DXVA2_DECODEEXECUTE), "pExecuteParams")]),
]

IDirect3DVideoProcessDevice9 = Interface("IDirect3DVideoProcessDevice9", IUnknown)
IDirect3DVideoProcessDevice9.methods += [
    StdMethod(HRESULT, "VideoProcessBeginFrame", []),
    StdMethod(HRESULT, "VideoProcessEndFrame", [(Pointer(HANDLE), "pHandleComplete")]),
    StdMethod(HRESULT, "VideoProcessSetRenderTarget", [(ObjPointer(IDirect3DSurface9), "pRenderTarget")]),
    StdMethod(HRESULT, "VideoProcessBlt", [(Pointer(DXVA2_VIDEOPROCESSBLT), "pData")]),
]

IDirect3DDXVAExtensionDevice9 = Interface("IDirect3DDXVAExtensionDevice9", IUnknown)
IDirect3DDXVAExtensionDevice9.methods += [
    StdMethod(HRESULT, "ExtensionExecute", [(OpaquePointer(DXVA2_EXTENSIONEXECUTE), "pData")]),
]

IDirect3DDxva2Container9 = Interface("IDirect3DDxva2Container9", IUnknown)
IDirect3DDxva2Container9.methods += [
    StdMethod(HRESULT, "CreateSurface", [(UINT, "Width"), (UINT, "Height"), (UINT, "BackBuffers"), (D3DFORMAT, "Format"), (D3DPOOL, "Pool"), (DWORD, "Usage"), (DXVA2_SurfaceType, "DxvaType"), Out(Array(ObjPointer(IDirect3DSurface9), "1 + BackBuffers"), "ppSurface"), (Pointer(HANDLE), "pSharedHandle")]),
    StdMethod(HRESULT, "VidToSysBlt", [(ObjPointer(IDirect3DSurface9), "pSourceSurface"), (Pointer(RECT), "pSourceRect"), (ObjPointer(IDirect3DSurface9), "pDestSurface"), (Pointer(RECT), "pDestRect")]),
    StdMethod(HRESULT, "GetDecodeGuidCount", [Out(Pointer(UINT), "pCount")], sideeffects=False),
    StdMethod(HRESULT, "GetDecodeGuids", [(UINT, "Count"), Out(Array(GUID, "Count"), "pGuids")], sideeffects=False),
    StdMethod(HRESULT, "GetDecodeRenderTargetFormatCount", [(REFGUID, "Guid"), Out(Pointer(UINT), "pCount")], sideeffects=False),
    StdMethod(HRESULT, "GetDecodeRenderTargets", [(REFGUID, "Guid"), (UINT, "Count"), Out(Array(D3DFORMAT, "Count"), "pFormats")], sideeffects=False),
    StdMethod(HRESULT, "GetDecodeCompressedBufferCount", [(REFGUID, "Guid"), (Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), Out(Pointer(UINT), "pCount")], sideeffects=False),
    StdMethod(HRESULT, "GetDecodeCompressedBuffers", [(REFGUID, "Guid"), (Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), (UINT, "Count"), Out(OpaquePointer(DXVA2_DECODEBUFFERINFO), "pBufferInfo")], sideeffects=False),
    StdMethod(HRESULT, "GetDecodeConfigurationCount", [(REFGUID, "Guid"), (Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), Out(Pointer(UINT), "pCount")], sideeffects=False),
    StdMethod(HRESULT, "GetDecodeConfigurations", [(REFGUID, "Guid"), (Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), (UINT, "Count"), Out(Array(DXVA2_ConfigPictureDecode, "Count"), "pConfigs")], sideeffects=False),
    StdMethod(HRESULT, "CreateDecodeDevice", [(REFGUID, "Guid"), (Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), (Pointer(Const(DXVA2_ConfigPictureDecode)), "pConfig"), (Array(ObjPointer(IDirect3DSurface9), "NumSurfaces"), "ppDecoderRenderTargets"), (UINT, "NumSurfaces"), Out(Pointer(ObjPointer(IDirect3DDecodeDevice9)), "ppDecode")]),
    StdMethod(HRESULT, "GetVideoProcessorDeviceGuidCount", [(Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), Out(Pointer(UINT), "pCount")], sideeffects=False),
    StdMethod(HRESULT, "GetVideoProcessorDeviceGuids", [(Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), (UINT, "Count"), Out(Pointer(GUID), "pGuids")], sideeffects=False),
    StdMethod(HRESULT, "GetVideoProcessorCaps", [(REFGUID, "Guid"), (Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), (D3DFORMAT, "Format"), Out(Pointer(DXVA2_VideoProcessorCaps), "pCaps")], sideeffects=False),
    StdMethod(HRESULT, "GetProcAmpRange", [(REFGUID, "Guid"), (Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), (D3DFORMAT, "Format"), (UINT, "ProcAmpCap"), Out(Pointer(DXVA2_ValueRange), "pRange")]),
    StdMethod(HRESULT, "GetFilterPropertyRange", [(REFGUID, "Guid"), (Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), (D3DFORMAT, "Format"), (UINT, "FilterSetting"), Out(Pointer(DXVA2_ValueRange), "pRange")], sideeffects=False),
    StdMethod(HRESULT, "GetVideoProcessorRenderTargetCount", [(REFGUID, "Guid"), (Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), Out(Pointer(UINT), "pCount")], sideeffects=False),
    StdMethod(HRESULT, "GetVideoProcessorRenderTargets", [(REFGUID, "Guid"), (Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), (UINT, "Count"), Out(Array(D3DFORMAT, "Count"), "pFormats")], sideeffects=False),
    StdMethod(HRESULT, "GetVideoProcessorSubStreamFormatCount", [(REFGUID, "Guid"), (Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), (D3DFORMAT, "Format"), Out(Pointer(UINT), "pCount")], sideeffects=False),
    StdMethod(HRESULT, "GetVideoProcessorSubStreamFormats", [(REFGUID, "Guid"), (Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), (D3DFORMAT, "Format"), (UINT, "Count"), Out(Array(D3DFORMAT, "Count"), "pFormats")], sideeffects=False),
    StdMethod(HRESULT, "CreateVideoProcessDevice", [(REFGUID, "Guid"), (Pointer(Const(DXVA2_VideoDesc)), "pVideoDesc"), (D3DFORMAT, "Format"), (UINT, "MaxSubStreams"), Out(Pointer(ObjPointer(IDirect3DVideoProcessDevice9)), "ppVideoProcessDevice")]),
    StdMethod(HRESULT, "GetExtensionGuidCount", [(DWORD, "Extension"), Out(Pointer(UINT), "pCount")], sideeffects=False),
    StdMethod(HRESULT, "GetExtensionGuids", [(DWORD, "Extension"), (UINT, "Count"), Out(Array(GUID, "Count"), "pGuids")], sideeffects=False),
    StdMethod(HRESULT, "GetExtensionCaps", [(REFGUID, "Guid"), (UINT, "arg2"), (OpaquePointer(Void), "arg3"), (UINT, "arg4"), (OpaquePointer(Void), "arg5"), (UINT, "arg6")], sideeffects=False),
    StdMethod(HRESULT, "CreateExtensionDevice", [(REFGUID, "Guid"), (OpaquePointer(Void), "arg2"), (UINT, "arg3"), Out(Pointer(ObjPointer(IDirect3DDXVAExtensionDevice9)), "ppExtension")]),
]

d3d9.addInterfaces([
    IDirect3DDxva2Container9,
])

########NEW FILE########
__FILENAME__ = d3d9types
##########################################################################
#
# Copyright 2011 Jose Fonseca
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""d3d9types.h"""

from winapi import *

D3DCOLOR = Alias("D3DCOLOR", DWORD)

D3DVECTOR = Struct("D3DVECTOR", [
    (Float, "x"),
    (Float, "y"),
    (Float, "z"),
])

D3DCOLORVALUE = Struct("D3DCOLORVALUE", [
    (Float, "r"),
    (Float, "g"),
    (Float, "b"),
    (Float, "a"),
])

D3DRECT = Struct("D3DRECT", [
    (LONG, "x1"),
    (LONG, "y1"),
    (LONG, "x2"),
    (LONG, "y2"),
])

D3DMATRIX = Struct("D3DMATRIX", [
    (Array(Array(Float, 4), "4"), "m"),
])

D3DVIEWPORT9 = Struct("D3DVIEWPORT9", [
    (DWORD, "X"),
    (DWORD, "Y"),
    (DWORD, "Width"),
    (DWORD, "Height"),
    (Float, "MinZ"),
    (Float, "MaxZ"),
])

D3DCLIPPLANE = Flags(DWORD, [
    "D3DCLIPPLANE0",
    "D3DCLIPPLANE1",
    "D3DCLIPPLANE2",
    "D3DCLIPPLANE3",
    "D3DCLIPPLANE4",
    "D3DCLIPPLANE5",
])

D3DCS = Flags(DWORD, [
    "D3DCS_ALL",
    "D3DCS_LEFT",
    "D3DCS_RIGHT",
    "D3DCS_TOP",
    "D3DCS_BOTTOM",
    "D3DCS_FRONT",
    "D3DCS_BACK",
    "D3DCS_PLANE0",
    "D3DCS_PLANE1",
    "D3DCS_PLANE2",
    "D3DCS_PLANE3",
    "D3DCS_PLANE4",
    "D3DCS_PLANE5",
])

D3DCLIPSTATUS9 = Struct("D3DCLIPSTATUS9", [
    (DWORD, "ClipUnion"),
    (DWORD, "ClipIntersection"),
])

D3DMATERIAL9 = Struct("D3DMATERIAL9", [
    (D3DCOLORVALUE, "Diffuse"),
    (D3DCOLORVALUE, "Ambient"),
    (D3DCOLORVALUE, "Specular"),
    (D3DCOLORVALUE, "Emissive"),
    (Float, "Power"),
])

D3DLIGHTTYPE = Enum("D3DLIGHTTYPE", [
    "D3DLIGHT_POINT",
    "D3DLIGHT_SPOT",
    "D3DLIGHT_DIRECTIONAL",
])

D3DLIGHT9 = Struct("D3DLIGHT9", [
    (D3DLIGHTTYPE, "Type"),
    (D3DCOLORVALUE, "Diffuse"),
    (D3DCOLORVALUE, "Specular"),
    (D3DCOLORVALUE, "Ambient"),
    (D3DVECTOR, "Position"),
    (D3DVECTOR, "Direction"),
    (Float, "Range"),
    (Float, "Falloff"),
    (Float, "Attenuation0"),
    (Float, "Attenuation1"),
    (Float, "Attenuation2"),
    (Float, "Theta"),
    (Float, "Phi"),
])

D3DCLEAR = Flags(DWORD, [
    "D3DCLEAR_TARGET",
    "D3DCLEAR_ZBUFFER",
    "D3DCLEAR_STENCIL",
])

D3DSHADEMODE = Enum("D3DSHADEMODE", [
    "D3DSHADE_FLAT",
    "D3DSHADE_GOURAUD",
    "D3DSHADE_PHONG",
])

D3DFILLMODE = Enum("D3DFILLMODE", [
    "D3DFILL_POINT",
    "D3DFILL_WIREFRAME",
    "D3DFILL_SOLID",
])

D3DBLEND = Enum("D3DBLEND", [
    "D3DBLEND_ZERO",
    "D3DBLEND_ONE",
    "D3DBLEND_SRCCOLOR",
    "D3DBLEND_INVSRCCOLOR",
    "D3DBLEND_SRCALPHA",
    "D3DBLEND_INVSRCALPHA",
    "D3DBLEND_DESTALPHA",
    "D3DBLEND_INVDESTALPHA",
    "D3DBLEND_DESTCOLOR",
    "D3DBLEND_INVDESTCOLOR",
    "D3DBLEND_SRCALPHASAT",
    "D3DBLEND_BOTHSRCALPHA",
    "D3DBLEND_BOTHINVSRCALPHA",
    "D3DBLEND_BLENDFACTOR",
    "D3DBLEND_INVBLENDFACTOR",
    "D3DBLEND_SRCCOLOR2",
    "D3DBLEND_INVSRCCOLOR2",
])

D3DBLENDOP = Enum("D3DBLENDOP", [
    "D3DBLENDOP_ADD",
    "D3DBLENDOP_SUBTRACT",
    "D3DBLENDOP_REVSUBTRACT",
    "D3DBLENDOP_MIN",
    "D3DBLENDOP_MAX",
])

D3DTEXTUREADDRESS = Enum("D3DTEXTUREADDRESS", [
    "D3DTADDRESS_WRAP",
    "D3DTADDRESS_MIRROR",
    "D3DTADDRESS_CLAMP",
    "D3DTADDRESS_BORDER",
    "D3DTADDRESS_MIRRORONCE",
])

D3DCULL = Enum("D3DCULL", [
    "D3DCULL_NONE",
    "D3DCULL_CW",
    "D3DCULL_CCW",
])

D3DCMPFUNC = Enum("D3DCMPFUNC", [
    "D3DCMP_NEVER",
    "D3DCMP_LESS",
    "D3DCMP_EQUAL",
    "D3DCMP_LESSEQUAL",
    "D3DCMP_GREATER",
    "D3DCMP_NOTEQUAL",
    "D3DCMP_GREATEREQUAL",
    "D3DCMP_ALWAYS",
])

D3DSTENCILOP = Enum("D3DSTENCILOP", [
    "D3DSTENCILOP_KEEP",
    "D3DSTENCILOP_ZERO",
    "D3DSTENCILOP_REPLACE",
    "D3DSTENCILOP_INCRSAT",
    "D3DSTENCILOP_DECRSAT",
    "D3DSTENCILOP_INVERT",
    "D3DSTENCILOP_INCR",
    "D3DSTENCILOP_DECR",
])

D3DFOGMODE = Enum("D3DFOGMODE", [
    "D3DFOG_NONE",
    "D3DFOG_EXP",
    "D3DFOG_EXP2",
    "D3DFOG_LINEAR",
])

D3DZBUFFERTYPE = Enum("D3DZBUFFERTYPE", [
    "D3DZB_FALSE",
    "D3DZB_TRUE",
    "D3DZB_USEW",
])

D3DPRIMITIVETYPE = Enum("D3DPRIMITIVETYPE", [
    "D3DPT_POINTLIST",
    "D3DPT_LINELIST",
    "D3DPT_LINESTRIP",
    "D3DPT_TRIANGLELIST",
    "D3DPT_TRIANGLESTRIP",
    "D3DPT_TRIANGLEFAN",
])

D3DTRANSFORMSTATETYPE = Enum("D3DTRANSFORMSTATETYPE", [
    "D3DTS_VIEW",
    "D3DTS_PROJECTION",
    "D3DTS_TEXTURE0",
    "D3DTS_TEXTURE1",
    "D3DTS_TEXTURE2",
    "D3DTS_TEXTURE3",
    "D3DTS_TEXTURE4",
    "D3DTS_TEXTURE5",
    "D3DTS_TEXTURE6",
    "D3DTS_TEXTURE7",
    "D3DTS_WORLD",
    "D3DTS_WORLD1",
    "D3DTS_WORLD2",
    "D3DTS_WORLD3",
])

D3DMATERIALCOLORSOURCE = Enum("D3DMATERIALCOLORSOURCE", [
    "D3DMCS_MATERIAL",
    "D3DMCS_COLOR1",
    "D3DMCS_COLOR2",
])

D3DWRAPCOORD = Flags(DWORD, [
    "D3DWRAPCOORD_0",
    "D3DWRAPCOORD_1",
    "D3DWRAPCOORD_2",
    "D3DWRAPCOORD_3",
])

D3DCOLORWRITEENABLE = Flags(DWORD, [
    "D3DCOLORWRITEENABLE_RED",
    "D3DCOLORWRITEENABLE_GREEN",
    "D3DCOLORWRITEENABLE_BLUE",
    "D3DCOLORWRITEENABLE_ALPHA",
])

D3DDEGREETYPE = Enum("D3DDEGREETYPE", [
    "D3DDEGREE_LINEAR",
    "D3DDEGREE_QUADRATIC",
    "D3DDEGREE_CUBIC",
    "D3DDEGREE_QUINTIC",
])

D3DPATCHEDGESTYLE = Enum("D3DPATCHEDGESTYLE", [
    "D3DPATCHEDGE_DISCRETE",
    "D3DPATCHEDGE_CONTINUOUS",
])

D3DVERTEXBLENDFLAGS = Enum("D3DVERTEXBLENDFLAGS", [
    "D3DVBF_DISABLE",
    "D3DVBF_1WEIGHTS",
    "D3DVBF_2WEIGHTS",
    "D3DVBF_3WEIGHTS",
    "D3DVBF_TWEENING",
    "D3DVBF_0WEIGHTS",
])

D3DDEBUGMONITORTOKENS = Enum("D3DDEBUGMONITORTOKENS", [
    "D3DDMT_ENABLE",
    "D3DDMT_DISABLE",
])

# TODO: Convert these to/from actual floats
FLOAT_AS_DWORD = DWORD

D3DRENDERSTATETYPE, D3DRENDERSTATEVALUE = EnumPolymorphic("D3DRENDERSTATETYPE", "State", [
    ("D3DRS_ZENABLE", D3DZBUFFERTYPE),
    ("D3DRS_FILLMODE", D3DFILLMODE),
    ("D3DRS_SHADEMODE", D3DSHADEMODE),
    ("D3DRS_ZWRITEENABLE", BOOL),
    ("D3DRS_ALPHATESTENABLE", BOOL),
    ("D3DRS_LASTPIXEL", BOOL),
    ("D3DRS_SRCBLEND", D3DBLEND),
    ("D3DRS_DESTBLEND", D3DBLEND),
    ("D3DRS_CULLMODE", D3DCULL),
    ("D3DRS_ZFUNC", D3DCMPFUNC),
    ("D3DRS_ALPHAREF", DWORD),
    ("D3DRS_ALPHAFUNC", D3DCMPFUNC),
    ("D3DRS_DITHERENABLE", BOOL),
    ("D3DRS_ALPHABLENDENABLE", BOOL),
    ("D3DRS_FOGENABLE", BOOL),
    ("D3DRS_SPECULARENABLE", BOOL),
    ("D3DRS_FOGCOLOR", D3DCOLOR),
    ("D3DRS_FOGTABLEMODE", D3DFOGMODE),
    ("D3DRS_FOGSTART", FLOAT_AS_DWORD),
    ("D3DRS_FOGEND", FLOAT_AS_DWORD),
    ("D3DRS_FOGDENSITY", FLOAT_AS_DWORD),
    ("D3DRS_RANGEFOGENABLE", BOOL),
    ("D3DRS_STENCILENABLE", BOOL),
    ("D3DRS_STENCILFAIL", D3DSTENCILOP),
    ("D3DRS_STENCILZFAIL", D3DSTENCILOP),
    ("D3DRS_STENCILPASS", D3DSTENCILOP),
    ("D3DRS_STENCILFUNC", D3DCMPFUNC),
    ("D3DRS_STENCILREF", DWORD),
    ("D3DRS_STENCILMASK", DWORD),
    ("D3DRS_STENCILWRITEMASK", DWORD),
    ("D3DRS_TEXTUREFACTOR", D3DCOLOR),
    ("D3DRS_WRAP0", D3DWRAPCOORD),
    ("D3DRS_WRAP1", D3DWRAPCOORD),
    ("D3DRS_WRAP2", D3DWRAPCOORD),
    ("D3DRS_WRAP3", D3DWRAPCOORD),
    ("D3DRS_WRAP4", D3DWRAPCOORD),
    ("D3DRS_WRAP5", D3DWRAPCOORD),
    ("D3DRS_WRAP6", D3DWRAPCOORD),
    ("D3DRS_WRAP7", D3DWRAPCOORD),
    ("D3DRS_CLIPPING", BOOL),
    ("D3DRS_LIGHTING", BOOL),
    ("D3DRS_AMBIENT", D3DCOLOR),
    ("D3DRS_FOGVERTEXMODE", D3DFOGMODE),
    ("D3DRS_COLORVERTEX", BOOL),
    ("D3DRS_LOCALVIEWER", BOOL),
    ("D3DRS_NORMALIZENORMALS", BOOL),
    ("D3DRS_DIFFUSEMATERIALSOURCE", D3DMATERIALCOLORSOURCE),
    ("D3DRS_SPECULARMATERIALSOURCE", D3DMATERIALCOLORSOURCE),
    ("D3DRS_AMBIENTMATERIALSOURCE", D3DMATERIALCOLORSOURCE),
    ("D3DRS_EMISSIVEMATERIALSOURCE", D3DMATERIALCOLORSOURCE),
    ("D3DRS_VERTEXBLEND", D3DVERTEXBLENDFLAGS),
    ("D3DRS_CLIPPLANEENABLE", D3DCLIPPLANE),
    ("D3DRS_POINTSIZE", FLOAT_AS_DWORD),
    ("D3DRS_POINTSIZE_MIN", FLOAT_AS_DWORD),
    ("D3DRS_POINTSPRITEENABLE", BOOL),
    ("D3DRS_POINTSCALEENABLE", BOOL),
    ("D3DRS_POINTSCALE_A", FLOAT_AS_DWORD),
    ("D3DRS_POINTSCALE_B", FLOAT_AS_DWORD),
    ("D3DRS_POINTSCALE_C", FLOAT_AS_DWORD),
    ("D3DRS_MULTISAMPLEANTIALIAS", BOOL),
    ("D3DRS_MULTISAMPLEMASK", DWORD),
    ("D3DRS_PATCHEDGESTYLE", D3DPATCHEDGESTYLE),
    ("D3DRS_DEBUGMONITORTOKEN", D3DDEBUGMONITORTOKENS),
    ("D3DRS_POINTSIZE_MAX", FLOAT_AS_DWORD),
    ("D3DRS_INDEXEDVERTEXBLENDENABLE", BOOL),
    ("D3DRS_COLORWRITEENABLE", DWORD),
    ("D3DRS_TWEENFACTOR", FLOAT_AS_DWORD),
    ("D3DRS_BLENDOP", D3DBLENDOP),
    ("D3DRS_POSITIONDEGREE", D3DDEGREETYPE),
    ("D3DRS_NORMALDEGREE", D3DDEGREETYPE),
    ("D3DRS_SCISSORTESTENABLE", BOOL),
    ("D3DRS_SLOPESCALEDEPTHBIAS", FLOAT_AS_DWORD),
    ("D3DRS_ANTIALIASEDLINEENABLE", BOOL),
    ("D3DRS_MINTESSELLATIONLEVEL", FLOAT_AS_DWORD),
    ("D3DRS_MAXTESSELLATIONLEVEL", FLOAT_AS_DWORD),
    ("D3DRS_ADAPTIVETESS_X", FLOAT_AS_DWORD),
    ("D3DRS_ADAPTIVETESS_Y", FLOAT_AS_DWORD),
    ("D3DRS_ADAPTIVETESS_Z", FLOAT_AS_DWORD),
    ("D3DRS_ADAPTIVETESS_W", FLOAT_AS_DWORD),
    ("D3DRS_ENABLEADAPTIVETESSELLATION", BOOL),
    ("D3DRS_TWOSIDEDSTENCILMODE", BOOL),
    ("D3DRS_CCW_STENCILFAIL", D3DSTENCILOP),
    ("D3DRS_CCW_STENCILZFAIL", D3DSTENCILOP),
    ("D3DRS_CCW_STENCILPASS", D3DSTENCILOP),
    ("D3DRS_CCW_STENCILFUNC", D3DCMPFUNC),
    ("D3DRS_COLORWRITEENABLE1", D3DCOLORWRITEENABLE),
    ("D3DRS_COLORWRITEENABLE2", D3DCOLORWRITEENABLE),
    ("D3DRS_COLORWRITEENABLE3", D3DCOLORWRITEENABLE),
    ("D3DRS_BLENDFACTOR", D3DCOLOR),
    ("D3DRS_SRGBWRITEENABLE", BOOL),
    ("D3DRS_DEPTHBIAS", FLOAT_AS_DWORD),
    ("D3DRS_WRAP8", D3DWRAPCOORD),
    ("D3DRS_WRAP9", D3DWRAPCOORD),
    ("D3DRS_WRAP10", D3DWRAPCOORD),
    ("D3DRS_WRAP11", D3DWRAPCOORD),
    ("D3DRS_WRAP12", D3DWRAPCOORD),
    ("D3DRS_WRAP13", D3DWRAPCOORD),
    ("D3DRS_WRAP14", D3DWRAPCOORD),
    ("D3DRS_WRAP15", D3DWRAPCOORD),
    ("D3DRS_SEPARATEALPHABLENDENABLE", BOOL),
    ("D3DRS_SRCBLENDALPHA", D3DBLEND),
    ("D3DRS_DESTBLENDALPHA", D3DBLEND),
    ("D3DRS_BLENDOPALPHA", D3DBLENDOP),

    # XXX: D3DRENDERSTATE_WRAPBIAS + n
], DWORD)

D3DTSS_TCI = Flags(DWORD, [
    #"D3DTSS_TCI_PASSTHRU", # 0
    "D3DTSS_TCI_CAMERASPACENORMAL",
    "D3DTSS_TCI_CAMERASPACEPOSITION",
    "D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR",
    "D3DTSS_TCI_SPHEREMAP",
])

D3DTEXTUREOP = Enum("D3DTEXTUREOP", [
    "D3DTOP_DISABLE",
    "D3DTOP_SELECTARG1",
    "D3DTOP_SELECTARG2",
    "D3DTOP_MODULATE",
    "D3DTOP_MODULATE2X",
    "D3DTOP_MODULATE4X",
    "D3DTOP_ADD",
    "D3DTOP_ADDSIGNED",
    "D3DTOP_ADDSIGNED2X",
    "D3DTOP_SUBTRACT",
    "D3DTOP_ADDSMOOTH",
    "D3DTOP_BLENDDIFFUSEALPHA",
    "D3DTOP_BLENDTEXTUREALPHA",
    "D3DTOP_BLENDFACTORALPHA",
    "D3DTOP_BLENDTEXTUREALPHAPM",
    "D3DTOP_BLENDCURRENTALPHA",
    "D3DTOP_PREMODULATE",
    "D3DTOP_MODULATEALPHA_ADDCOLOR",
    "D3DTOP_MODULATECOLOR_ADDALPHA",
    "D3DTOP_MODULATEINVALPHA_ADDCOLOR",
    "D3DTOP_MODULATEINVCOLOR_ADDALPHA",
    "D3DTOP_BUMPENVMAP",
    "D3DTOP_BUMPENVMAPLUMINANCE",
    "D3DTOP_DOTPRODUCT3",
    "D3DTOP_MULTIPLYADD",
    "D3DTOP_LERP",
])

# XXX: Actually a mixture of enums and flags
D3DTA = FakeEnum(DWORD, [
    "D3DTA_DIFFUSE",
    "D3DTA_CURRENT",
    "D3DTA_TEXTURE",
    "D3DTA_TFACTOR",
    "D3DTA_SPECULAR",
    "D3DTA_TEMP",
    "D3DTA_CONSTANT",
    #"D3DTA_COMPLEMENT",
    #"D3DTA_ALPHAREPLICATE",
])

D3DTEXTURETRANSFORMFLAGS = Enum("D3DTEXTURETRANSFORMFLAGS", [
    "D3DTTFF_DISABLE",
    "D3DTTFF_COUNT1",
    "D3DTTFF_COUNT2",
    "D3DTTFF_COUNT3",
    "D3DTTFF_COUNT4",
    "D3DTTFF_PROJECTED",
])

D3DTEXTUREFILTERTYPE = Enum("D3DTEXTUREFILTERTYPE", [
    "D3DTEXF_NONE",
    "D3DTEXF_POINT",
    "D3DTEXF_LINEAR",
    "D3DTEXF_ANISOTROPIC",
    "D3DTEXF_PYRAMIDALQUAD",
    "D3DTEXF_GAUSSIANQUAD",
    "D3DTEXF_CONVOLUTIONMONO",
])

D3DTEXTURESTAGESTATETYPE, D3DTEXTURESTAGESTATEVALUE = EnumPolymorphic("D3DTEXTURESTAGESTATETYPE", "Type", [
    ("D3DTSS_COLOROP", D3DTEXTUREOP),
    ("D3DTSS_COLORARG1", D3DTA),
    ("D3DTSS_COLORARG2", D3DTA),
    ("D3DTSS_ALPHAOP", D3DTEXTUREOP),
    ("D3DTSS_ALPHAARG1", D3DTA),
    ("D3DTSS_ALPHAARG2", D3DTA),
    ("D3DTSS_BUMPENVMAT00", FLOAT_AS_DWORD),
    ("D3DTSS_BUMPENVMAT01", FLOAT_AS_DWORD),
    ("D3DTSS_BUMPENVMAT10", FLOAT_AS_DWORD),
    ("D3DTSS_BUMPENVMAT11", FLOAT_AS_DWORD),
    ("D3DTSS_TEXCOORDINDEX", D3DTSS_TCI),
    ("D3DTSS_BUMPENVLSCALE", FLOAT_AS_DWORD),
    ("D3DTSS_BUMPENVLOFFSET", FLOAT_AS_DWORD),
    ("D3DTSS_TEXTURETRANSFORMFLAGS", D3DTEXTURETRANSFORMFLAGS),
    ("D3DTSS_COLORARG0", D3DTA,),
    ("D3DTSS_ALPHAARG0", D3DTA,),
    ("D3DTSS_RESULTARG", D3DTA,),
    ("D3DTSS_CONSTANT", D3DCOLOR),
], DWORD)

D3DSAMPLERSTATETYPE, D3DSAMPLERSTATEVALUE = EnumPolymorphic("D3DSAMPLERSTATETYPE", "Type", [
    ("D3DSAMP_ADDRESSU", D3DTEXTUREADDRESS),
    ("D3DSAMP_ADDRESSV", D3DTEXTUREADDRESS),
    ("D3DSAMP_ADDRESSW", D3DTEXTUREADDRESS),
    ("D3DSAMP_BORDERCOLOR", D3DCOLOR),
    ("D3DSAMP_MAGFILTER", D3DTEXTUREFILTERTYPE),
    ("D3DSAMP_MINFILTER", D3DTEXTUREFILTERTYPE),
    ("D3DSAMP_MIPFILTER", D3DTEXTUREFILTERTYPE),
    ("D3DSAMP_MIPMAPLODBIAS", FLOAT_AS_DWORD),
    ("D3DSAMP_MAXMIPLEVEL", DWORD),
    ("D3DSAMP_MAXANISOTROPY", DWORD),
    ("D3DSAMP_SRGBTEXTURE", BOOL),
    ("D3DSAMP_ELEMENTINDEX", DWORD),
    ("D3DSAMP_DMAPOFFSET", DWORD),
], DWORD)

D3DPV = Flags(DWORD, [
    "D3DPV_DONOTCOPYDATA",
])

# XXX: Actually a mixture of enums and flags
D3DFVF = Flags(DWORD, [
    "D3DFVF_RESERVED0",
    "D3DFVF_XYZ",
    "D3DFVF_XYZRHW",
    "D3DFVF_XYZB1",
    "D3DFVF_XYZB2",
    "D3DFVF_XYZB3",
    "D3DFVF_XYZB4",
    "D3DFVF_XYZB5",
    "D3DFVF_XYZW",
    "D3DFVF_NORMAL",
    "D3DFVF_PSIZE",
    "D3DFVF_DIFFUSE",
    "D3DFVF_SPECULAR",
    #"D3DFVF_TEX0",
    #"D3DFVF_TEX1",
    #"D3DFVF_TEX2",
    #"D3DFVF_TEX3",
    #"D3DFVF_TEX4",
    #"D3DFVF_TEX5",
    #"D3DFVF_TEX6",
    #"D3DFVF_TEX7",
    #"D3DFVF_TEX8",
    "D3DFVF_LASTBETA_UBYTE4",
    "D3DFVF_LASTBETA_D3DCOLOR",
    "D3DFVF_RESERVED2",
    #"D3DFVF_TEXCOORDSIZE1(0)",
    #"D3DFVF_TEXCOORDSIZE2(0)",
    #"D3DFVF_TEXCOORDSIZE3(0)",
    #"D3DFVF_TEXCOORDSIZE4(0)",
    #"D3DFVF_TEXCOORDSIZE1(1)",
    #"D3DFVF_TEXCOORDSIZE2(1)",
    #"D3DFVF_TEXCOORDSIZE3(1)",
    #"D3DFVF_TEXCOORDSIZE4(1)",
    #"D3DFVF_TEXCOORDSIZE1(2)",
    #"D3DFVF_TEXCOORDSIZE2(2)",
    #"D3DFVF_TEXCOORDSIZE3(2)",
    #"D3DFVF_TEXCOORDSIZE4(2)",
    #"D3DFVF_TEXCOORDSIZE1(3)",
    #"D3DFVF_TEXCOORDSIZE2(3)",
    #"D3DFVF_TEXCOORDSIZE3(3)",
    #"D3DFVF_TEXCOORDSIZE4(3)",
])

D3DDECLUSAGE = FakeEnum(BYTE, [
    "D3DDECLUSAGE_POSITION",
    "D3DDECLUSAGE_BLENDWEIGHT",
    "D3DDECLUSAGE_BLENDINDICES",
    "D3DDECLUSAGE_NORMAL",
    "D3DDECLUSAGE_PSIZE",
    "D3DDECLUSAGE_TEXCOORD",
    "D3DDECLUSAGE_TANGENT",
    "D3DDECLUSAGE_BINORMAL",
    "D3DDECLUSAGE_TESSFACTOR",
    "D3DDECLUSAGE_POSITIONT",
    "D3DDECLUSAGE_COLOR",
    "D3DDECLUSAGE_FOG",
    "D3DDECLUSAGE_DEPTH",
    "D3DDECLUSAGE_SAMPLE",
])

D3DDECLMETHOD = FakeEnum(BYTE, [
    "D3DDECLMETHOD_DEFAULT",
    "D3DDECLMETHOD_PARTIALU",
    "D3DDECLMETHOD_PARTIALV",
    "D3DDECLMETHOD_CROSSUV",
    "D3DDECLMETHOD_UV",
    "D3DDECLMETHOD_LOOKUP",
    "D3DDECLMETHOD_LOOKUPPRESAMPLED",
])

D3DDECLTYPE = FakeEnum(BYTE, [
    "D3DDECLTYPE_FLOAT1",
    "D3DDECLTYPE_FLOAT2",
    "D3DDECLTYPE_FLOAT3",
    "D3DDECLTYPE_FLOAT4",
    "D3DDECLTYPE_D3DCOLOR",
    "D3DDECLTYPE_UBYTE4",
    "D3DDECLTYPE_SHORT2",
    "D3DDECLTYPE_SHORT4",
    "D3DDECLTYPE_UBYTE4N",
    "D3DDECLTYPE_SHORT2N",
    "D3DDECLTYPE_SHORT4N",
    "D3DDECLTYPE_USHORT2N",
    "D3DDECLTYPE_USHORT4N",
    "D3DDECLTYPE_UDEC3",
    "D3DDECLTYPE_DEC3N",
    "D3DDECLTYPE_FLOAT16_2",
    "D3DDECLTYPE_FLOAT16_4",
    "D3DDECLTYPE_UNUSED",
])

D3DVERTEXELEMENT9 = Struct("D3DVERTEXELEMENT9", [
    (WORD, "Stream"),
    (WORD, "Offset"),
    (D3DDECLTYPE, "Type"), # BYTE
    (D3DDECLMETHOD, "Method"), # BYTE
    (D3DDECLUSAGE, "Usage"), # BYTE
    (BYTE, "UsageIndex"),
])

D3DBASISTYPE = Enum("D3DBASISTYPE", [
    "D3DBASIS_BEZIER",
    "D3DBASIS_BSPLINE",
    "D3DBASIS_CATMULL_ROM",
])

D3DSTATEBLOCKTYPE = Enum("D3DSTATEBLOCKTYPE", [
    "D3DSBT_ALL",
    "D3DSBT_PIXELSTATE",
    "D3DSBT_VERTEXSTATE",
])

D3DDEVTYPE = Enum("D3DDEVTYPE", [
    "D3DDEVTYPE_HAL",
    "D3DDEVTYPE_REF",
    "D3DDEVTYPE_SW",
    "D3DDEVTYPE_NULLREF",
])

D3DMULTISAMPLE_TYPE = Enum("D3DMULTISAMPLE_TYPE", [
    "D3DMULTISAMPLE_NONE",
    "D3DMULTISAMPLE_NONMASKABLE",
    "D3DMULTISAMPLE_2_SAMPLES",
    "D3DMULTISAMPLE_3_SAMPLES",
    "D3DMULTISAMPLE_4_SAMPLES",
    "D3DMULTISAMPLE_5_SAMPLES",
    "D3DMULTISAMPLE_6_SAMPLES",
    "D3DMULTISAMPLE_7_SAMPLES",
    "D3DMULTISAMPLE_8_SAMPLES",
    "D3DMULTISAMPLE_9_SAMPLES",
    "D3DMULTISAMPLE_10_SAMPLES",
    "D3DMULTISAMPLE_11_SAMPLES",
    "D3DMULTISAMPLE_12_SAMPLES",
    "D3DMULTISAMPLE_13_SAMPLES",
    "D3DMULTISAMPLE_14_SAMPLES",
    "D3DMULTISAMPLE_15_SAMPLES",
    "D3DMULTISAMPLE_16_SAMPLES",
])

D3DFORMAT = Enum("D3DFORMAT", [
    "D3DFMT_UNKNOWN",
    "D3DFMT_R8G8B8",
    "D3DFMT_A8R8G8B8",
    "D3DFMT_X8R8G8B8",
    "D3DFMT_R5G6B5",
    "D3DFMT_X1R5G5B5",
    "D3DFMT_A1R5G5B5",
    "D3DFMT_A4R4G4B4",
    "D3DFMT_R3G3B2",
    "D3DFMT_A8",
    "D3DFMT_A8R3G3B2",
    "D3DFMT_X4R4G4B4",
    "D3DFMT_A2B10G10R10",
    "D3DFMT_A8B8G8R8",
    "D3DFMT_X8B8G8R8",
    "D3DFMT_G16R16",
    "D3DFMT_A2R10G10B10",
    "D3DFMT_A16B16G16R16",
    "D3DFMT_A8P8",
    "D3DFMT_P8",
    "D3DFMT_L8",
    "D3DFMT_A8L8",
    "D3DFMT_A4L4",
    "D3DFMT_V8U8",
    "D3DFMT_L6V5U5",
    "D3DFMT_X8L8V8U8",
    "D3DFMT_Q8W8V8U8",
    "D3DFMT_V16U16",
    "D3DFMT_A2W10V10U10",
    "D3DFMT_UYVY",
    "D3DFMT_R8G8_B8G8",
    "D3DFMT_YUY2",
    "D3DFMT_G8R8_G8B8",
    "D3DFMT_DXT1",
    "D3DFMT_DXT2",
    "D3DFMT_DXT3",
    "D3DFMT_DXT4",
    "D3DFMT_DXT5",
    "D3DFMT_D16_LOCKABLE",
    "D3DFMT_D32",
    "D3DFMT_D15S1",
    "D3DFMT_D24S8",
    "D3DFMT_D24X8",
    "D3DFMT_D24X4S4",
    "D3DFMT_D16",
    "D3DFMT_D32F_LOCKABLE",
    "D3DFMT_D24FS8",
    "D3DFMT_D32_LOCKABLE",
    "D3DFMT_S8_LOCKABLE",
    "D3DFMT_L16",
    "D3DFMT_VERTEXDATA",
    "D3DFMT_INDEX16",
    "D3DFMT_INDEX32",
    "D3DFMT_Q16W16V16U16",
    "D3DFMT_MULTI2_ARGB8",
    "D3DFMT_R16F",
    "D3DFMT_G16R16F",
    "D3DFMT_A16B16G16R16F",
    "D3DFMT_R32F",
    "D3DFMT_G32R32F",
    "D3DFMT_A32B32G32R32F",
    "D3DFMT_CxV8U8",
    "D3DFMT_A1",
    "D3DFMT_A2B10G10R10_XR_BIAS",
    "D3DFMT_BINARYBUFFER",

    # Unofficial formats
    "D3DFMT_ATI1N",
    "D3DFMT_ATI2N",
    "D3DFMT_AYUV",
    "D3DFMT_DF16",
    "D3DFMT_DF24",
    "D3DFMT_INTZ",
    "D3DFMT_NULL",
    "D3DFMT_NV12",
    "D3DFMT_YV12",
    "D3DFMT_RAWZ",
])

D3DDISPLAYMODE = Struct("D3DDISPLAYMODE", [
    (UINT, "Width"),
    (UINT, "Height"),
    (UINT, "RefreshRate"),
    (D3DFORMAT, "Format"),
])

D3DCREATE = Flags(DWORD, [
    "D3DCREATE_FPU_PRESERVE",
    "D3DCREATE_MULTITHREADED",
    "D3DCREATE_PUREDEVICE",
    "D3DCREATE_SOFTWARE_VERTEXPROCESSING",
    "D3DCREATE_HARDWARE_VERTEXPROCESSING",
    "D3DCREATE_MIXED_VERTEXPROCESSING",
    "D3DCREATE_DISABLE_DRIVER_MANAGEMENT",
    "D3DCREATE_ADAPTERGROUP_DEVICE",
    "D3DCREATE_DISABLE_DRIVER_MANAGEMENT_EX",
    "D3DCREATE_NOWINDOWCHANGES",
    "D3DCREATE_DISABLE_PSGP_THREADING",
    "D3DCREATE_ENABLE_PRESENTSTATS",
    "D3DCREATE_DISABLE_PRINTSCREEN",
    "D3DCREATE_SCREENSAVER",
])

D3DDEVICE_CREATION_PARAMETERS = Struct("D3DDEVICE_CREATION_PARAMETERS", [
    (UINT, "AdapterOrdinal"),
    (D3DDEVTYPE, "DeviceType"),
    (HWND, "hFocusWindow"),
    (D3DCREATE, "BehaviorFlags"),
])

D3DSWAPEFFECT = Enum("D3DSWAPEFFECT", [
    "D3DSWAPEFFECT_DISCARD",
    "D3DSWAPEFFECT_FLIP",
    "D3DSWAPEFFECT_COPY",
])

D3DPOOL = Enum("D3DPOOL", [
    "D3DPOOL_DEFAULT",
    "D3DPOOL_MANAGED",
    "D3DPOOL_SYSTEMMEM",
    "D3DPOOL_SCRATCH",
])

D3DPRESENT = FakeEnum(DWORD, [
    "D3DPRESENT_RATE_DEFAULT",
])

D3DPRESENTFLAG = Flags(DWORD, [
    "D3DPRESENTFLAG_LOCKABLE_BACKBUFFER",
    "D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL",
    "D3DPRESENTFLAG_DEVICECLIP",
    "D3DPRESENTFLAG_VIDEO",
    "D3DPRESENTFLAG_NOAUTOROTATE",
    "D3DPRESENTFLAG_UNPRUNEDMODE",
])

D3DPRESENT_INTERVAL = Flags(DWORD, [
    "D3DPRESENT_INTERVAL_DEFAULT", # 0
    "D3DPRESENT_INTERVAL_ONE",
    "D3DPRESENT_INTERVAL_TWO",
    "D3DPRESENT_INTERVAL_THREE",
    "D3DPRESENT_INTERVAL_FOUR",
    "D3DPRESENT_INTERVAL_IMMEDIATE",
])

D3DPRESENT_PARAMETERS = Struct("D3DPRESENT_PARAMETERS", [
    (UINT, "BackBufferWidth"),
    (UINT, "BackBufferHeight"),
    (D3DFORMAT, "BackBufferFormat"),
    (UINT, "BackBufferCount"),
    (D3DMULTISAMPLE_TYPE, "MultiSampleType"),
    (DWORD, "MultiSampleQuality"),
    (D3DSWAPEFFECT, "SwapEffect"),
    (HWND, "hDeviceWindow"),
    (BOOL, "Windowed"),
    (BOOL, "EnableAutoDepthStencil"),
    (D3DFORMAT, "AutoDepthStencilFormat"),
    (D3DPRESENTFLAG, "Flags"),
    (UINT, "FullScreen_RefreshRateInHz"),
    (D3DPRESENT_INTERVAL, "PresentationInterval"),
])

D3DGAMMARAMP = Struct("D3DGAMMARAMP", [
    (Array(WORD, 256), "red"),
    (Array(WORD, 256), "green"),
    (Array(WORD, 256), "blue"),
])

D3DBACKBUFFER_TYPE = Enum("D3DBACKBUFFER_TYPE", [
    "D3DBACKBUFFER_TYPE_MONO",
    "D3DBACKBUFFER_TYPE_LEFT",
    "D3DBACKBUFFER_TYPE_RIGHT",
])

D3DRESOURCETYPE = Enum("D3DRESOURCETYPE", [
    "D3DRTYPE_SURFACE",
    "D3DRTYPE_VOLUME",
    "D3DRTYPE_TEXTURE",
    "D3DRTYPE_VOLUMETEXTURE",
    "D3DRTYPE_CUBETEXTURE",
    "D3DRTYPE_VERTEXBUFFER",
    "D3DRTYPE_INDEXBUFFER",
])

D3DUSAGE = Flags(DWORD, [
    "D3DUSAGE_RENDERTARGET",
    "D3DUSAGE_DEPTHSTENCIL",
    "D3DUSAGE_WRITEONLY",
    "D3DUSAGE_SOFTWAREPROCESSING",
    "D3DUSAGE_DONOTCLIP",
    "D3DUSAGE_POINTS",
    "D3DUSAGE_RTPATCHES",
    "D3DUSAGE_NPATCHES",
    "D3DUSAGE_DYNAMIC",
    "D3DUSAGE_AUTOGENMIPMAP",
    "D3DUSAGE_RESTRICTED_CONTENT",
    "D3DUSAGE_RESTRICT_SHARED_RESOURCE",
    "D3DUSAGE_RESTRICT_SHARED_RESOURCE_DRIVER",
    "D3DUSAGE_DMAP",
    "D3DUSAGE_QUERY_LEGACYBUMPMAP",
    "D3DUSAGE_QUERY_SRGBREAD",
    "D3DUSAGE_QUERY_FILTER",
    "D3DUSAGE_QUERY_SRGBWRITE",
    "D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING",
    "D3DUSAGE_QUERY_VERTEXTEXTURE",
    "D3DUSAGE_QUERY_WRAPANDMIP",
    "D3DUSAGE_NONSECURE",
    "D3DUSAGE_TEXTAPI",
])

D3DCUBEMAP_FACES = Enum("D3DCUBEMAP_FACES", [
    "D3DCUBEMAP_FACE_POSITIVE_X",
    "D3DCUBEMAP_FACE_NEGATIVE_X",
    "D3DCUBEMAP_FACE_POSITIVE_Y",
    "D3DCUBEMAP_FACE_NEGATIVE_Y",
    "D3DCUBEMAP_FACE_POSITIVE_Z",
    "D3DCUBEMAP_FACE_NEGATIVE_Z",
])

D3DLOCK = Flags(DWORD, [
    "D3DLOCK_READONLY",
    "D3DLOCK_DISCARD",
    "D3DLOCK_NOOVERWRITE",
    "D3DLOCK_NOSYSLOCK",
    "D3DLOCK_DONOTWAIT",
    "D3DLOCK_NO_DIRTY_UPDATE",
])

D3DVERTEXBUFFER_DESC = Struct("D3DVERTEXBUFFER_DESC", [
    (D3DFORMAT, "Format"),
    (D3DRESOURCETYPE, "Type"),
    (D3DUSAGE, "Usage"),
    (D3DPOOL, "Pool"),
    (UINT, "Size"),
    (DWORD, "FVF"),
])

D3DINDEXBUFFER_DESC = Struct("D3DINDEXBUFFER_DESC", [
    (D3DFORMAT, "Format"),
    (D3DRESOURCETYPE, "Type"),
    (D3DUSAGE, "Usage"),
    (D3DPOOL, "Pool"),
    (UINT, "Size"),
])

D3DSURFACE_DESC = Struct("D3DSURFACE_DESC", [
    (D3DFORMAT, "Format"),
    (D3DRESOURCETYPE, "Type"),
    (D3DUSAGE, "Usage"),
    (D3DPOOL, "Pool"),
    (D3DMULTISAMPLE_TYPE, "MultiSampleType"),
    (DWORD, "MultiSampleQuality"),
    (UINT, "Width"),
    (UINT, "Height"),
])

D3DVOLUME_DESC = Struct("D3DVOLUME_DESC", [
    (D3DFORMAT, "Format"),
    (D3DRESOURCETYPE, "Type"),
    (D3DUSAGE, "Usage"),
    (D3DPOOL, "Pool"),
    (UINT, "Width"),
    (UINT, "Height"),
    (UINT, "Depth"),
])

D3DLOCKED_RECT = Struct("D3DLOCKED_RECT", [
    (INT, "Pitch"),
    (LinearPointer(Void, "_MappedSize"), "pBits"),
])

D3DBOX = Struct("D3DBOX", [
    (UINT, "Left"),
    (UINT, "Top"),
    (UINT, "Right"),
    (UINT, "Bottom"),
    (UINT, "Front"),
    (UINT, "Back"),
])

D3DLOCKED_BOX = Struct("D3DLOCKED_BOX", [
    (INT, "RowPitch"),
    (INT, "SlicePitch"),
    (LinearPointer(Void, "_MappedSize"), "pBits"),
])

D3DRANGE = Struct("D3DRANGE", [
    (UINT, "Offset"),
    (UINT, "Size"),
])

D3DRECTPATCH_INFO = Struct("D3DRECTPATCH_INFO", [
    (UINT, "StartVertexOffsetWidth"),
    (UINT, "StartVertexOffsetHeight"),
    (UINT, "Width"),
    (UINT, "Height"),
    (UINT, "Stride"),
    (D3DBASISTYPE, "Basis"),
    (D3DDEGREETYPE, "Degree"),
])

D3DTRIPATCH_INFO = Struct("D3DTRIPATCH_INFO", [
    (UINT, "StartVertexOffset"),
    (UINT, "NumVertices"),
    (D3DBASISTYPE, "Basis"),
    (D3DDEGREETYPE, "Degree"),
])

D3DADAPTER_IDENTIFIER9 = Struct("D3DADAPTER_IDENTIFIER9", [
    (CString, "Driver"),
    (CString, "Description"),
    (CString, "DeviceName"),
    (LARGE_INTEGER, "DriverVersion"),
    (DWORD, "VendorId"),
    (DWORD, "DeviceId"),
    (DWORD, "SubSysId"),
    (DWORD, "Revision"),
    (GUID, "DeviceIdentifier"),
    (DWORD, "WHQLLevel"),
])

D3DRASTER_STATUS = Struct("D3DRASTER_STATUS", [
    (BOOL, "InVBlank"),
    (UINT, "ScanLine"),
])

D3DISSUE = Flags(DWORD, [
    "D3DISSUE_END",
    "D3DISSUE_BEGIN",
])

D3DGETDATA = Flags(DWORD, [
    "D3DGETDATA_FLUSH",
])

D3DRESOURCESTATS = Struct("D3DRESOURCESTATS", [
    (BOOL, "bThrashing"),
    (DWORD, "ApproxBytesDownloaded"),
    (DWORD, "NumEvicts"),
    (DWORD, "NumVidCreates"),
    (DWORD, "LastPri"),
    (DWORD, "NumUsed"),
    (DWORD, "NumUsedInVidMem"),
    (DWORD, "WorkingSet"),
    (DWORD, "WorkingSetBytes"),
    (DWORD, "TotalManaged"),
    (DWORD, "TotalBytes"),
])

D3DDEVINFO_RESOURCEMANAGER = Struct("D3DDEVINFO_RESOURCEMANAGER", [
    (Array(D3DRESOURCESTATS, "D3DRTYPECOUNT"), "stats"),
])

D3DDEVINFO_D3DVERTEXSTATS = Struct("D3DDEVINFO_D3DVERTEXSTATS", [
    (DWORD, "NumRenderedTriangles"),
    (DWORD, "NumExtraClippingTriangles"),
])

D3DDEVINFO_VCACHE = Struct("D3DDEVINFO_VCACHE", [
    (DWORD, "Pattern"),
    (DWORD, "OptMethod"),
    (DWORD, "CacheSize"),
    (DWORD, "MagicNumber"),
])

D3DDEVINFO_D3D9PIPELINETIMINGS = Struct("D3DDEVINFO_D3D9PIPELINETIMINGS", [
    (FLOAT, "VertexProcessingTimePercent"),
    (FLOAT, "PixelProcessingTimePercent"),
    (FLOAT, "OtherGPUProcessingTimePercent"),
    (FLOAT, "GPUIdleTimePercent"),
])

D3DDEVINFO_D3D9INTERFACETIMINGS = Struct("D3DDEVINFO_D3D9INTERFACETIMINGS", [
    (FLOAT, "WaitingForGPUToUseApplicationResourceTimePercent"),
    (FLOAT, "WaitingForGPUToAcceptMoreCommandsTimePercent"),
    (FLOAT, "WaitingForGPUToStayWithinLatencyTimePercent"),
    (FLOAT, "WaitingForGPUExclusiveResourceTimePercent"),
    (FLOAT, "WaitingForGPUOtherTimePercent"),
])

D3DDEVINFO_D3D9STAGETIMINGS = Struct("D3DDEVINFO_D3D9STAGETIMINGS", [
    (FLOAT, "MemoryProcessingPercent"),
    (FLOAT, "ComputationProcessingPercent"),
])

D3DDEVINFO_D3D9BANDWIDTHTIMINGS = Struct("D3DDEVINFO_D3D9BANDWIDTHTIMINGS", [
    (FLOAT, "MaxBandwidthUtilized"),
    (FLOAT, "FrontEndUploadMemoryUtilizedPercent"),
    (FLOAT, "VertexRateUtilizedPercent"),
    (FLOAT, "TriangleSetupRateUtilizedPercent"),
    (FLOAT, "FillRateUtilizedPercent"),
])

D3DDEVINFO_D3D9CACHEUTILIZATION = Struct("D3DDEVINFO_D3D9CACHEUTILIZATION", [
    (FLOAT, "TextureCacheHitRate"),
    (FLOAT, "PostTransformVertexCacheHitRate"),
])

D3DQUERYTYPE, D3DQUERYDATA = EnumPolymorphic("D3DQUERYTYPE", "_this->GetType()", [
    ("D3DQUERYTYPE_VCACHE", Pointer(D3DDEVINFO_VCACHE)),
    ("D3DQUERYTYPE_RESOURCEMANAGER", Pointer(D3DDEVINFO_RESOURCEMANAGER)),
    ("D3DQUERYTYPE_VERTEXSTATS", Pointer(D3DDEVINFO_D3DVERTEXSTATS)),
    ("D3DQUERYTYPE_EVENT", Pointer(BOOL)),
    ("D3DQUERYTYPE_OCCLUSION", Pointer(DWORD)),
    ("D3DQUERYTYPE_TIMESTAMP", Pointer(UINT64)),
    ("D3DQUERYTYPE_TIMESTAMPDISJOINT", Pointer(BOOL)),
    ("D3DQUERYTYPE_TIMESTAMPFREQ", Pointer(UINT64)),
    ("D3DQUERYTYPE_PIPELINETIMINGS", Pointer(D3DDEVINFO_D3D9PIPELINETIMINGS)),
    ("D3DQUERYTYPE_INTERFACETIMINGS", Pointer(D3DDEVINFO_D3D9INTERFACETIMINGS)),
    ("D3DQUERYTYPE_VERTEXTIMINGS", Pointer(D3DDEVINFO_D3D9STAGETIMINGS)),
    ("D3DQUERYTYPE_PIXELTIMINGS", Pointer(D3DDEVINFO_D3D9STAGETIMINGS)),
    ("D3DQUERYTYPE_BANDWIDTHTIMINGS", Pointer(D3DDEVINFO_D3D9BANDWIDTHTIMINGS)),
    ("D3DQUERYTYPE_CACHEUTILIZATION", Pointer(D3DDEVINFO_D3D9CACHEUTILIZATION)),
], Blob(Void, "dwSize"), False)

D3DCOMPOSERECTSOP = Enum("D3DCOMPOSERECTSOP", [
    "D3DCOMPOSERECTS_COPY",
    "D3DCOMPOSERECTS_OR",
    "D3DCOMPOSERECTS_AND",
    "D3DCOMPOSERECTS_NEG",
])

D3DCOMPOSERECTDESC = Struct("D3DCOMPOSERECTDESC", [
    (USHORT, "X"),
    (USHORT, "Y"),
    (USHORT, "Width"),
    (USHORT, "Height"),
])

D3DCOMPOSERECTDESTINATION = Struct("D3DCOMPOSERECTDESTINATION", [
    (USHORT, "SrcRectIndex"),
    (USHORT, "Reserved"),
    (Short, "X"),
    (Short, "Y"),
])

D3DPRESENTSTATS = Struct("D3DPRESENTSTATS", [
    (UINT, "PresentCount"),
    (UINT, "PresentRefreshCount"),
    (UINT, "SyncRefreshCount"),
    (LARGE_INTEGER, "SyncQPCTime"),
    (LARGE_INTEGER, "SyncGPUTime"),
])

D3DSCANLINEORDERING = Enum("D3DSCANLINEORDERING", [
    "D3DSCANLINEORDERING_UNKNOWN",
    "D3DSCANLINEORDERING_PROGRESSIVE",
    "D3DSCANLINEORDERING_INTERLACED",
])

D3DDISPLAYMODEEX = Struct("D3DDISPLAYMODEEX", [
    (UINT, "Size"),
    (UINT, "Width"),
    (UINT, "Height"),
    (UINT, "RefreshRate"),
    (D3DFORMAT, "Format"),
    (D3DSCANLINEORDERING, "ScanLineOrdering"),
])

D3DDISPLAYMODEFILTER = Struct("D3DDISPLAYMODEFILTER", [
    (UINT, "Size"),
    (D3DFORMAT, "Format"),
    (D3DSCANLINEORDERING, "ScanLineOrdering"),
])

D3DDISPLAYROTATION = Enum("D3DDISPLAYROTATION", [
    "D3DDISPLAYROTATION_IDENTITY",
    "D3DDISPLAYROTATION_90",
    "D3DDISPLAYROTATION_180",
    "D3DDISPLAYROTATION_270",
])

D3D9_RESOURCE_PRIORITY = FakeEnum(DWORD, [
    "D3D9_RESOURCE_PRIORITY_MINIMUM",
    "D3D9_RESOURCE_PRIORITY_LOW",
    "D3D9_RESOURCE_PRIORITY_NORMAL",
    "D3D9_RESOURCE_PRIORITY_HIGH",
    "D3D9_RESOURCE_PRIORITY_MAXIMUM",
])


########NEW FILE########
__FILENAME__ = d3dcaps
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""d3dcaps.h"""

from winapi import *
from d3dtypes import *

D3DTRANSFORMCAPS = Flags(DWORD, [
    "D3DTRANSFORMCAPS_CLIP",
])

D3DTRANSFORMCAPS = Struct("D3DTRANSFORMCAPS", [
    (DWORD, "dwSize"),
    (DWORD, "dwCaps"),
])

D3DLIGHTINGCAPS = Struct("D3DLIGHTINGCAPS", [
    (DWORD, "dwSize"),
    (DWORD, "dwCaps"),
    (DWORD, "dwLightingModel"),
    (DWORD, "dwNumLights"),
])

D3DLIGHTINGMODEL = Flags(DWORD, [
    "D3DLIGHTINGMODEL_RGB",
    "D3DLIGHTINGMODEL_MONO",
])

D3DLIGHTCAPS = Flags(DWORD, [
    "D3DLIGHTCAPS_POINT",
    "D3DLIGHTCAPS_SPOT",
    "D3DLIGHTCAPS_DIRECTIONAL",
    "D3DLIGHTCAPS_PARALLELPOINT",
    "D3DLIGHTCAPS_GLSPOT",
])

D3DPRIMCAPS = Struct("D3DPRIMCAPS", [
    (DWORD, "dwSize"),
    (DWORD, "dwMiscCaps"),
    (DWORD, "dwRasterCaps"),
    (DWORD, "dwZCmpCaps"),
    (DWORD, "dwSrcBlendCaps"),
    (DWORD, "dwDestBlendCaps"),
    (DWORD, "dwAlphaCmpCaps"),
    (DWORD, "dwShadeCaps"),
    (DWORD, "dwTextureCaps"),
    (DWORD, "dwTextureFilterCaps"),
    (DWORD, "dwTextureBlendCaps"),
    (DWORD, "dwTextureAddressCaps"),
    (DWORD, "dwStippleWidth"),
    (DWORD, "dwStippleHeight"),
])

D3DPMISCCAPS = Flags(DWORD, [
    "D3DPMISCCAPS_MASKPLANES",
    "D3DPMISCCAPS_MASKZ",
    "D3DPMISCCAPS_LINEPATTERNREP",
    "D3DPMISCCAPS_CONFORMANT",
    "D3DPMISCCAPS_CULLNONE",
    "D3DPMISCCAPS_CULLCW",
    "D3DPMISCCAPS_CULLCCW",
])

D3DXD3DPRASTERCAPSXX = Flags(DWORD, [
    "D3DPRASTERCAPS_DITHER",
    "D3DPRASTERCAPS_ROP2",
    "D3DPRASTERCAPS_XOR",
    "D3DPRASTERCAPS_PAT",
    "D3DPRASTERCAPS_ZTEST",
    "D3DPRASTERCAPS_SUBPIXEL",
    "D3DPRASTERCAPS_SUBPIXELX",
    "D3DPRASTERCAPS_FOGVERTEX",
    "D3DPRASTERCAPS_FOGTABLE",
    "D3DPRASTERCAPS_STIPPLE",
    "D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT",
    "D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT",
    "D3DPRASTERCAPS_ANTIALIASEDGES",
    "D3DPRASTERCAPS_MIPMAPLODBIAS",
    "D3DPRASTERCAPS_ZBIAS",
    "D3DPRASTERCAPS_ZBUFFERLESSHSR",
    "D3DPRASTERCAPS_FOGRANGE",
    "D3DPRASTERCAPS_ANISOTROPY",
    "D3DPRASTERCAPS_WBUFFER",
    "D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT",
    "D3DPRASTERCAPS_WFOG",
    "D3DPRASTERCAPS_ZFOG",
])

D3DPCMPCAPS = Flags(DWORD, [
    "D3DPCMPCAPS_NEVER",
    "D3DPCMPCAPS_LESS",
    "D3DPCMPCAPS_EQUAL",
    "D3DPCMPCAPS_LESSEQUAL",
    "D3DPCMPCAPS_GREATER",
    "D3DPCMPCAPS_NOTEQUAL",
    "D3DPCMPCAPS_GREATEREQUAL",
    "D3DPCMPCAPS_ALWAYS",
])

D3DPBLENDCAPS = Flags(DWORD, [
    "D3DPBLENDCAPS_ZERO",
    "D3DPBLENDCAPS_ONE",
    "D3DPBLENDCAPS_SRCCOLOR",
    "D3DPBLENDCAPS_INVSRCCOLOR",
    "D3DPBLENDCAPS_SRCALPHA",
    "D3DPBLENDCAPS_INVSRCALPHA",
    "D3DPBLENDCAPS_DESTALPHA",
    "D3DPBLENDCAPS_INVDESTALPHA",
    "D3DPBLENDCAPS_DESTCOLOR",
    "D3DPBLENDCAPS_INVDESTCOLOR",
    "D3DPBLENDCAPS_SRCALPHASAT",
    "D3DPBLENDCAPS_BOTHSRCALPHA",
    "D3DPBLENDCAPS_BOTHINVSRCALPHA",
])

D3DPSHADECAPS = Flags(DWORD, [
    "D3DPSHADECAPS_COLORFLATMONO",
    "D3DPSHADECAPS_COLORFLATRGB",
    "D3DPSHADECAPS_COLORGOURAUDMONO",
    "D3DPSHADECAPS_COLORGOURAUDRGB",
    "D3DPSHADECAPS_COLORPHONGMONO",
    "D3DPSHADECAPS_COLORPHONGRGB",
    "D3DPSHADECAPS_SPECULARFLATMONO",
    "D3DPSHADECAPS_SPECULARFLATRGB",
    "D3DPSHADECAPS_SPECULARGOURAUDMONO",
    "D3DPSHADECAPS_SPECULARGOURAUDRGB",
    "D3DPSHADECAPS_SPECULARPHONGMONO",
    "D3DPSHADECAPS_SPECULARPHONGRGB",
    "D3DPSHADECAPS_ALPHAFLATBLEND",
    "D3DPSHADECAPS_ALPHAFLATSTIPPLED",
    "D3DPSHADECAPS_ALPHAGOURAUDBLEND",
    "D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED",
    "D3DPSHADECAPS_ALPHAPHONGBLEND",
    "D3DPSHADECAPS_ALPHAPHONGSTIPPLED",
    "D3DPSHADECAPS_FOGFLAT",
    "D3DPSHADECAPS_FOGGOURAUD",
    "D3DPSHADECAPS_FOGPHONG",
])

D3DPTEXTURECAPS = Flags(DWORD, [
    "D3DPTEXTURECAPS_PERSPECTIVE",
    "D3DPTEXTURECAPS_POW2",
    "D3DPTEXTURECAPS_ALPHA",
    "D3DPTEXTURECAPS_TRANSPARENCY",
    "D3DPTEXTURECAPS_BORDER",
    "D3DPTEXTURECAPS_SQUAREONLY",
    "D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE",
    "D3DPTEXTURECAPS_ALPHAPALETTE",
    "D3DPTEXTURECAPS_NONPOW2CONDITIONAL",
    "D3DPTEXTURECAPS_PROJECTED",
    "D3DPTEXTURECAPS_CUBEMAP",
    "D3DPTEXTURECAPS_COLORKEYBLEND",
])

D3DPTFILTERCAPS = Flags(DWORD, [
    "D3DPTFILTERCAPS_NEAREST",
    "D3DPTFILTERCAPS_LINEAR",
    "D3DPTFILTERCAPS_MIPNEAREST",
    "D3DPTFILTERCAPS_MIPLINEAR",
    "D3DPTFILTERCAPS_LINEARMIPNEAREST",
    "D3DPTFILTERCAPS_LINEARMIPLINEAR",
    "D3DPTFILTERCAPS_MINFPOINT",
    "D3DPTFILTERCAPS_MINFLINEAR",
    "D3DPTFILTERCAPS_MINFANISOTROPIC",
    "D3DPTFILTERCAPS_MIPFPOINT",
    "D3DPTFILTERCAPS_MIPFLINEAR",
    "D3DPTFILTERCAPS_MAGFPOINT",
    "D3DPTFILTERCAPS_MAGFLINEAR",
    "D3DPTFILTERCAPS_MAGFANISOTROPIC",
    "D3DPTFILTERCAPS_MAGFAFLATCUBIC",
    "D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC",
])

D3DPTBLENDCAPS = Flags(DWORD, [
    "D3DPTBLENDCAPS_DECAL",
    "D3DPTBLENDCAPS_MODULATE",
    "D3DPTBLENDCAPS_DECALALPHA",
    "D3DPTBLENDCAPS_MODULATEALPHA",
    "D3DPTBLENDCAPS_DECALMASK",
    "D3DPTBLENDCAPS_MODULATEMASK",
    "D3DPTBLENDCAPS_COPY",
    "D3DPTBLENDCAPS_ADD",
])

D3DPTADDRESSCAPS = Flags(DWORD, [
    "D3DPTADDRESSCAPS_WRAP",
    "D3DPTADDRESSCAPS_MIRROR",
    "D3DPTADDRESSCAPS_CLAMP",
    "D3DPTADDRESSCAPS_BORDER",
    "D3DPTADDRESSCAPS_INDEPENDENTUV",
])

D3DSTENCILCAPS = Flags(DWORD, [
    "D3DSTENCILCAPS_KEEP",
    "D3DSTENCILCAPS_ZERO",
    "D3DSTENCILCAPS_REPLACE",
    "D3DSTENCILCAPS_INCRSAT",
    "D3DSTENCILCAPS_DECRSAT",
    "D3DSTENCILCAPS_INVERT",
    "D3DSTENCILCAPS_INCR",
    "D3DSTENCILCAPS_DECR",
])

D3DTEXOPCAPS = Flags(DWORD, [
    "D3DTEXOPCAPS_DISABLE",
    "D3DTEXOPCAPS_SELECTARG1",
    "D3DTEXOPCAPS_SELECTARG2",
    "D3DTEXOPCAPS_MODULATE",
    "D3DTEXOPCAPS_MODULATE2X",
    "D3DTEXOPCAPS_MODULATE4X",
    "D3DTEXOPCAPS_ADD",
    "D3DTEXOPCAPS_ADDSIGNED",
    "D3DTEXOPCAPS_ADDSIGNED2X",
    "D3DTEXOPCAPS_SUBTRACT",
    "D3DTEXOPCAPS_ADDSMOOTH",
    "D3DTEXOPCAPS_BLENDDIFFUSEALPHA",
    "D3DTEXOPCAPS_BLENDTEXTUREALPHA",
    "D3DTEXOPCAPS_BLENDFACTORALPHA",
    "D3DTEXOPCAPS_BLENDTEXTUREALPHAPM",
    "D3DTEXOPCAPS_BLENDCURRENTALPHA",
    "D3DTEXOPCAPS_PREMODULATE",
    "D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR",
    "D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA",
    "D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR",
    "D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA",
    "D3DTEXOPCAPS_BUMPENVMAP",
    "D3DTEXOPCAPS_BUMPENVMAPLUMINANCE",
    "D3DTEXOPCAPS_DOTPRODUCT3",
])

D3DFVFCAPS = Flags(DWORD, [
    "D3DFVFCAPS_TEXCOORDCOUNTMASK",
    "D3DFVFCAPS_DONOTSTRIPELEMENTS",
])

D3DDD = Flags(DWORD, [
    "D3DDD_COLORMODEL",
    "D3DDD_DEVCAPS",
    "D3DDD_TRANSFORMCAPS",
    "D3DDD_LIGHTINGCAPS",
    "D3DDD_BCLIPPING",
    "D3DDD_LINECAPS",
    "D3DDD_TRICAPS",
    "D3DDD_DEVICERENDERBITDEPTH",
    "D3DDD_DEVICEZBUFFERBITDEPTH",
    "D3DDD_MAXBUFFERSIZE",
    "D3DDD_MAXVERTEXCOUNT",
])

D3DDEVCAPS = Flags(DWORD, [
    "D3DDEVCAPS_FLOATTLVERTEX",
    "D3DDEVCAPS_SORTINCREASINGZ",
    "D3DDEVCAPS_SORTDECREASINGZ",
    "D3DDEVCAPS_SORTEXACT",
    "D3DDEVCAPS_EXECUTESYSTEMMEMORY",
    "D3DDEVCAPS_EXECUTEVIDEOMEMORY",
    "D3DDEVCAPS_TLVERTEXSYSTEMMEMORY",
    "D3DDEVCAPS_TLVERTEXVIDEOMEMORY",
    "D3DDEVCAPS_TEXTURESYSTEMMEMORY",
    "D3DDEVCAPS_TEXTUREVIDEOMEMORY",
    "D3DDEVCAPS_DRAWPRIMTLVERTEX",
    "D3DDEVCAPS_CANRENDERAFTERFLIP",
    "D3DDEVCAPS_TEXTURENONLOCALVIDMEM",
    "D3DDEVCAPS_DRAWPRIMITIVES2",
    "D3DDEVCAPS_SEPARATETEXTUREMEMORIES",
    "D3DDEVCAPS_DRAWPRIMITIVES2EX",
    "D3DDEVCAPS_HWTRANSFORMANDLIGHT",
    "D3DDEVCAPS_CANBLTSYSTONONLOCAL",
    "D3DDEVCAPS_HWRASTERIZATION",
])

D3DVTXPCAPS = Flags(DWORD, [
    "D3DVTXPCAPS_TEXGEN",
    "D3DVTXPCAPS_MATERIALSOURCE7",
    "D3DVTXPCAPS_VERTEXFOG",
    "D3DVTXPCAPS_DIRECTIONALLIGHTS",
    "D3DVTXPCAPS_POSITIONALLIGHTS",
    "D3DVTXPCAPS_LOCALVIEWER",
])

D3DFDS = Flags(DWORD, [
    "D3DFDS_COLORMODEL",
    "D3DFDS_GUID",
    "D3DFDS_HARDWARE",
    "D3DFDS_TRIANGLES",
    "D3DFDS_LINES",
    "D3DFDS_MISCCAPS",
    "D3DFDS_RASTERCAPS",
    "D3DFDS_ZCMPCAPS",
    "D3DFDS_ALPHACMPCAPS",
    "D3DFDS_SRCBLENDCAPS",
    "D3DFDS_DSTBLENDCAPS",
    "D3DFDS_SHADECAPS",
    "D3DFDS_TEXTURECAPS",
    "D3DFDS_TEXTUREFILTERCAPS",
    "D3DFDS_TEXTUREBLENDCAPS",
    "D3DFDS_TEXTUREADDRESSCAPS",
])

D3DFINDDEVICESEARCH = Struct("D3DFINDDEVICESEARCH", [
    (DWORD, "dwSize"),
    (DWORD, "dwFlags"),
    (BOOL, "bHardware"),
    (D3DCOLORMODEL, "dcmColorModel"),
    (GUID, "guid"),
    (DWORD, "dwCaps"),
    (D3DPRIMCAPS, "dpcPrimCaps"),
])
LPD3DFINDDEVICESEARCH = Pointer(D3DFINDDEVICESEARCH)

D3DEXECUTEBUFFERDESC = Struct("D3DEXECUTEBUFFERDESC", [
    (DWORD, "dwSize"),
    (DWORD, "dwFlags"),
    (DWORD, "dwCaps"),
    (DWORD, "dwBufferSize"),
    (LPVOID, "lpData"),
])
LPD3DEXECUTEBUFFERDESC = Pointer(D3DEXECUTEBUFFERDESC)

D3DDEB = Flags(DWORD, [
    "D3DDEB_BUFSIZE",
    "D3DDEB_CAPS",
    "D3DDEB_LPDATA",
])

D3DDEBCAPS = Flags(DWORD, [
    "D3DDEBCAPS_SYSTEMMEMORY",
    "D3DDEBCAPS_VIDEOMEMORY",
    "D3DDEBCAPS_MEM",
])

D3DDEVINFO_TEXTUREMANAGER = Struct("D3DDEVINFO_TEXTUREMANAGER", [
    (BOOL, "bThrashing"),
    (DWORD, "dwApproxBytesDownloaded"),
    (DWORD, "dwNumEvicts"),
    (DWORD, "dwNumVidCreates"),
    (DWORD, "dwNumTexturesUsed"),
    (DWORD, "dwNumUsedTexInVid"),
    (DWORD, "dwWorkingSet"),
    (DWORD, "dwWorkingSetBytes"),
    (DWORD, "dwTotalManaged"),
    (DWORD, "dwTotalBytes"),
    (DWORD, "dwLastPri"),
])

D3DDEVINFO_TEXTURING = Struct("D3DDEVINFO_TEXTURING", [
    (DWORD, "dwNumLoads"),
    (DWORD, "dwApproxBytesLoaded"),
    (DWORD, "dwNumPreLoads"),
    (DWORD, "dwNumSet"),
    (DWORD, "dwNumCreates"),
    (DWORD, "dwNumDestroys"),
    (DWORD, "dwNumSetPriorities"),
    (DWORD, "dwNumSetLODs"),
    (DWORD, "dwNumLocks"),
    (DWORD, "dwNumGetDCs"),
])

D3DDEVICEDESC = Struct("D3DDEVICEDESC", [
    (DWORD, "dwSize"),
    (DWORD, "dwFlags"),
    (D3DCOLORMODEL, "dcmColorModel"),
    (DWORD, "dwDevCaps"),
    (D3DTRANSFORMCAPS, "dtcTransformCaps"),
    (BOOL, "bClipping"),
    (D3DLIGHTINGCAPS, "dlcLightingCaps"),
    (D3DPRIMCAPS, "dpcLineCaps"),
    (D3DPRIMCAPS, "dpcTriCaps"),
    (DWORD, "dwDeviceRenderBitDepth"),
    (DWORD, "dwDeviceZBufferBitDepth"),
    (DWORD, "dwMaxBufferSize"),
    (DWORD, "dwMaxVertexCount"),
    (DWORD, "dwMinTextureWidth"),
    (DWORD, "dwMinTextureHeight"),
    (DWORD, "dwMaxTextureWidth"),
    (DWORD, "dwMaxTextureHeight"),
    (DWORD, "dwMinStippleWidth"),
    (DWORD, "dwMaxStippleWidth"),
    (DWORD, "dwMinStippleHeight"),
    (DWORD, "dwMaxStippleHeight"),
    (DWORD, "dwMaxTextureRepeat"),
    (DWORD, "dwMaxTextureAspectRatio"),
    (DWORD, "dwMaxAnisotropy"),
    (D3DVALUE, "dvGuardBandLeft"),
    (D3DVALUE, "dvGuardBandTop"),
    (D3DVALUE, "dvGuardBandRight"),
    (D3DVALUE, "dvGuardBandBottom"),
    (D3DVALUE, "dvExtentsAdjust"),
    (DWORD, "dwStencilCaps"),
    (DWORD, "dwFVFCaps"),
    (DWORD, "dwTextureOpCaps"),
    (WORD, "wMaxTextureBlendStages"),
    (WORD, "wMaxSimultaneousTextures"),
])
LPD3DDEVICEDESC = Pointer(D3DDEVICEDESC)

D3DDEVICEDESC7 = Struct("D3DDEVICEDESC7", [
    (DWORD, "dwDevCaps"),
    (D3DPRIMCAPS, "dpcLineCaps"),
    (D3DPRIMCAPS, "dpcTriCaps"),
    (DWORD, "dwDeviceRenderBitDepth"),
    (DWORD, "dwDeviceZBufferBitDepth"),
    (DWORD, "dwMinTextureWidth"),
    (DWORD, "dwMinTextureHeight"),
    (DWORD, "dwMaxTextureWidth"),
    (DWORD, "dwMaxTextureHeight"),
    (DWORD, "dwMaxTextureRepeat"),
    (DWORD, "dwMaxTextureAspectRatio"),
    (DWORD, "dwMaxAnisotropy"),
    (D3DVALUE, "dvGuardBandLeft"),
    (D3DVALUE, "dvGuardBandTop"),
    (D3DVALUE, "dvGuardBandRight"),
    (D3DVALUE, "dvGuardBandBottom"),
    (D3DVALUE, "dvExtentsAdjust"),
    (DWORD, "dwStencilCaps"),
    (DWORD, "dwFVFCaps"),
    (DWORD, "dwTextureOpCaps"),
    (WORD, "wMaxTextureBlendStages"),
    (WORD, "wMaxSimultaneousTextures"),
    (DWORD, "dwMaxActiveLights"),
    (D3DVALUE, "dvMaxVertexW"),
    (GUID, "deviceGUID"),
    (WORD, "wMaxUserClipPlanes"),
    (WORD, "wMaxVertexBlendMatrices"),
    (DWORD, "dwVertexProcessingCaps"),
    (DWORD, "dwReserved1"),
    (DWORD, "dwReserved2"),
    (DWORD, "dwReserved3"),
    (DWORD, "dwReserved4"),
])
LPD3DDEVICEDESC7 = Pointer(D3DDEVICEDESC7)

D3DFINDDEVICERESULT = Struct("D3DFINDDEVICERESULT", [
    (DWORD, "dwSize"),
    (GUID, "guid"),
    (D3DDEVICEDESC, "ddHwDesc"),
    (D3DDEVICEDESC, "ddSwDesc"),
])
LPD3DFINDDEVICERESULT = Pointer(D3DFINDDEVICERESULT)

LPD3DENUMDEVICESCALLBACK = FunctionPointer(HRESULT, "LPD3DENUMDEVICESCALLBACK", [(Pointer(GUID), "lpGuid"), (LPSTR, "lpDeviceDescription"), (LPSTR, "lpDeviceName"), LPD3DDEVICEDESC, LPD3DDEVICEDESC, LPVOID])
LPD3DENUMDEVICESCALLBACK7 = FunctionPointer(HRESULT, "LPD3DENUMDEVICESCALLBACK7", [(LPSTR, "lpDeviceDescription"), (LPSTR, "lpDeviceName"), LPD3DDEVICEDESC7, LPVOID])


########NEW FILE########
__FILENAME__ = d3dcommon
##########################################################################
#
# Copyright 2012 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from winapi import *


D3D_DRIVER_TYPE = Enum('D3D_DRIVER_TYPE', [
    'D3D_DRIVER_TYPE_UNKNOWN',
    'D3D_DRIVER_TYPE_HARDWARE',
    'D3D_DRIVER_TYPE_REFERENCE',
    'D3D_DRIVER_TYPE_NULL',
    'D3D_DRIVER_TYPE_SOFTWARE',
    'D3D_DRIVER_TYPE_WARP',
])

D3D_FEATURE_LEVEL = Enum('D3D_FEATURE_LEVEL', [
    'D3D_FEATURE_LEVEL_9_1',
    'D3D_FEATURE_LEVEL_9_2',
    'D3D_FEATURE_LEVEL_9_3',
    'D3D_FEATURE_LEVEL_10_0',
    'D3D_FEATURE_LEVEL_10_1',
    'D3D_FEATURE_LEVEL_11_0',
])

D3D_PRIMITIVE_TOPOLOGY = Enum('D3D_PRIMITIVE_TOPOLOGY', [
    'D3D_PRIMITIVE_TOPOLOGY_UNDEFINED',
    'D3D_PRIMITIVE_TOPOLOGY_POINTLIST',
    'D3D_PRIMITIVE_TOPOLOGY_LINELIST',
    'D3D_PRIMITIVE_TOPOLOGY_LINESTRIP',
    'D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST',
    'D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP',
    'D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ',
    'D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ',
    'D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ',
    'D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ',
    'D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST',
    'D3D_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST',
])

D3D10_PRIMITIVE_TOPOLOGY = Enum('D3D10_PRIMITIVE_TOPOLOGY', [
    'D3D10_PRIMITIVE_TOPOLOGY_UNDEFINED',
    'D3D10_PRIMITIVE_TOPOLOGY_POINTLIST',
    'D3D10_PRIMITIVE_TOPOLOGY_LINELIST',
    'D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP',
    'D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST',
    'D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP',
    'D3D10_PRIMITIVE_TOPOLOGY_LINELIST_ADJ',
    'D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ',
    'D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ',
    'D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ',
])

D3D11_PRIMITIVE_TOPOLOGY = Enum('D3D11_PRIMITIVE_TOPOLOGY', [
    'D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED',
    'D3D11_PRIMITIVE_TOPOLOGY_POINTLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_LINELIST',
    'D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP',
    'D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST',
    'D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP',
    'D3D11_PRIMITIVE_TOPOLOGY_LINELIST_ADJ',
    'D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ',
    'D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ',
    'D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ',
    'D3D11_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST',
    'D3D11_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST',
])

D3D_PRIMITIVE = Enum('D3D_PRIMITIVE', [
    'D3D_PRIMITIVE_UNDEFINED',
    'D3D_PRIMITIVE_POINT',
    'D3D_PRIMITIVE_LINE',
    'D3D_PRIMITIVE_TRIANGLE',
    'D3D_PRIMITIVE_LINE_ADJ',
    'D3D_PRIMITIVE_TRIANGLE_ADJ',
    'D3D_PRIMITIVE_1_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_2_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_3_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_4_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_5_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_6_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_7_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_8_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_9_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_10_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_11_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_12_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_13_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_14_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_15_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_16_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_17_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_18_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_19_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_20_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_21_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_22_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_23_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_24_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_25_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_26_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_27_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_28_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_29_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_30_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_31_CONTROL_POINT_PATCH',
    'D3D_PRIMITIVE_32_CONTROL_POINT_PATCH',
])

D3D10_PRIMITIVE = Enum('D3D10_PRIMITIVE', [
    'D3D10_PRIMITIVE_UNDEFINED',
    'D3D10_PRIMITIVE_POINT',
    'D3D10_PRIMITIVE_LINE',
    'D3D10_PRIMITIVE_TRIANGLE',
    'D3D10_PRIMITIVE_LINE_ADJ',
    'D3D10_PRIMITIVE_TRIANGLE_ADJ',
])

D3D11_PRIMITIVE = Enum('D3D11_PRIMITIVE', [
    'D3D11_PRIMITIVE_UNDEFINED',
    'D3D11_PRIMITIVE_POINT',
    'D3D11_PRIMITIVE_LINE',
    'D3D11_PRIMITIVE_TRIANGLE',
    'D3D11_PRIMITIVE_LINE_ADJ',
    'D3D11_PRIMITIVE_TRIANGLE_ADJ',
    'D3D11_PRIMITIVE_1_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_2_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_3_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_4_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_5_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_6_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_7_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_8_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_9_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_10_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_11_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_12_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_13_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_14_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_15_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_16_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_17_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_18_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_19_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_20_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_21_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_22_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_23_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_24_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_25_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_26_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_27_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_28_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_29_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_30_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_31_CONTROL_POINT_PATCH',
    'D3D11_PRIMITIVE_32_CONTROL_POINT_PATCH',
])

D3D_SRV_DIMENSION = Enum('D3D_SRV_DIMENSION', [
    'D3D_SRV_DIMENSION_UNKNOWN',
    'D3D_SRV_DIMENSION_BUFFER',
    'D3D_SRV_DIMENSION_TEXTURE1D',
    'D3D_SRV_DIMENSION_TEXTURE1DARRAY',
    'D3D_SRV_DIMENSION_TEXTURE2D',
    'D3D_SRV_DIMENSION_TEXTURE2DARRAY',
    'D3D_SRV_DIMENSION_TEXTURE2DMS',
    'D3D_SRV_DIMENSION_TEXTURE2DMSARRAY',
    'D3D_SRV_DIMENSION_TEXTURE3D',
    'D3D_SRV_DIMENSION_TEXTURECUBE',
    'D3D_SRV_DIMENSION_TEXTURECUBEARRAY',
    'D3D_SRV_DIMENSION_BUFFEREX',
])

D3D10_SRV_DIMENSION = Enum('D3D10_SRV_DIMENSION', [
    'D3D10_SRV_DIMENSION_UNKNOWN',
    'D3D10_SRV_DIMENSION_BUFFER',
    'D3D10_SRV_DIMENSION_TEXTURE1D',
    'D3D10_SRV_DIMENSION_TEXTURE1DARRAY',
    'D3D10_SRV_DIMENSION_TEXTURE2D',
    'D3D10_SRV_DIMENSION_TEXTURE2DARRAY',
    'D3D10_SRV_DIMENSION_TEXTURE2DMS',
    'D3D10_SRV_DIMENSION_TEXTURE2DMSARRAY',
    'D3D10_SRV_DIMENSION_TEXTURE3D',
    'D3D10_SRV_DIMENSION_TEXTURECUBE',
])

D3D10_SRV_DIMENSION1 = Enum('D3D10_SRV_DIMENSION1', [
    'D3D10_1_SRV_DIMENSION_UNKNOWN',
    'D3D10_1_SRV_DIMENSION_BUFFER',
    'D3D10_1_SRV_DIMENSION_TEXTURE1D',
    'D3D10_1_SRV_DIMENSION_TEXTURE1DARRAY',
    'D3D10_1_SRV_DIMENSION_TEXTURE2D',
    'D3D10_1_SRV_DIMENSION_TEXTURE2DARRAY',
    'D3D10_1_SRV_DIMENSION_TEXTURE2DMS',
    'D3D10_1_SRV_DIMENSION_TEXTURE2DMSARRAY',
    'D3D10_1_SRV_DIMENSION_TEXTURE3D',
    'D3D10_1_SRV_DIMENSION_TEXTURECUBE',
    'D3D10_1_SRV_DIMENSION_TEXTURECUBEARRAY',
])

D3D11_SRV_DIMENSION = Enum('D3D11_SRV_DIMENSION', [
    'D3D11_SRV_DIMENSION_UNKNOWN',
    'D3D11_SRV_DIMENSION_BUFFER',
    'D3D11_SRV_DIMENSION_TEXTURE1D',
    'D3D11_SRV_DIMENSION_TEXTURE1DARRAY',
    'D3D11_SRV_DIMENSION_TEXTURE2D',
    'D3D11_SRV_DIMENSION_TEXTURE2DARRAY',
    'D3D11_SRV_DIMENSION_TEXTURE2DMS',
    'D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY',
    'D3D11_SRV_DIMENSION_TEXTURE3D',
    'D3D11_SRV_DIMENSION_TEXTURECUBE',
    'D3D11_SRV_DIMENSION_TEXTURECUBEARRAY',
    'D3D11_SRV_DIMENSION_BUFFEREX',
])

D3D10_SHADER_MACRO = Struct('D3D10_SHADER_MACRO', [
    (LPCSTR, 'Name'),
    (LPCSTR, 'Definition'),
])

ID3D10Blob = Interface('ID3D10Blob', IUnknown)
ID3D10Blob.methods += [
    StdMethod(LPVOID, 'GetBufferPointer', [], sideeffects=False),
    StdMethod(SIZE_T, 'GetBufferSize', [], sideeffects=False),
]
LPD3D10BLOB = ObjPointer(ID3D10Blob)

D3D_INCLUDE_TYPE = Enum('D3D_INCLUDE_TYPE', [
    'D3D_INCLUDE_LOCAL',
    'D3D_INCLUDE_SYSTEM',
])

D3D10_INCLUDE_TYPE = Enum('D3D10_INCLUDE_TYPE', [
    'D3D10_INCLUDE_LOCAL',
    'D3D10_INCLUDE_SYSTEM',
])

ID3D10Include = Interface("ID3D10Include", IUnknown)
ID3D10Include.methods += [
    StdMethod(HRESULT, "Open", [(D3D10_INCLUDE_TYPE, "IncludeType"), (LPCSTR, "pFileName"), (LPCVOID, "pParentData"), Out(Pointer(LPCVOID), "ppData"), Out(Pointer(UINT), "pBytes")]),
    StdMethod(HRESULT, "Close", [(LPCVOID, "pData")]),
]
# It is implemented by applications, not D3D runtime, so treat as opaque for
# now.
LPD3D10INCLUDE = OpaquePointer(ID3D10Include)

D3D_SHADER_VARIABLE_CLASS = Enum('D3D_SHADER_VARIABLE_CLASS', [
    'D3D_SVC_SCALAR',
    'D3D_SVC_VECTOR',
    'D3D_SVC_MATRIX_ROWS',
    'D3D_SVC_MATRIX_COLUMNS',
    'D3D_SVC_OBJECT',
    'D3D_SVC_STRUCT',
    'D3D_SVC_INTERFACE_CLASS',
    'D3D_SVC_INTERFACE_POINTER',
])

D3D10_SHADER_VARIABLE_CLASS = Enum('D3D_SHADER_VARIABLE_CLASS', [
    'D3D10_SVC_SCALAR',
    'D3D10_SVC_VECTOR',
    'D3D10_SVC_MATRIX_ROWS',
    'D3D10_SVC_MATRIX_COLUMNS',
    'D3D10_SVC_OBJECT',
    'D3D10_SVC_STRUCT',
])

D3D11_SHADER_VARIABLE_CLASS = Enum('D3D_SHADER_VARIABLE_CLASS', [
    'D3D11_SVC_INTERFACE_CLASS',
    'D3D11_SVC_INTERFACE_POINTER',
])

D3D10_SHADER_VARIABLE_FLAGS = Enum('D3D10_SHADER_VARIABLE_FLAGS', [
    'D3D_SVF_USERPACKED',
    'D3D_SVF_USED',
    'D3D_SVF_INTERFACE_POINTER',
    'D3D_SVF_INTERFACE_PARAMETER',
])

D3D11_SHADER_VARIABLE_FLAGS = Enum('D3D11_SHADER_VARIABLE_FLAGS', [
    'D3D10_SVF_USERPACKED',
    'D3D10_SVF_USED',
    'D3D11_SVF_INTERFACE_POINTER',
    'D3D11_SVF_INTERFACE_PARAMETER',
])

D3D_SHADER_VARIABLE_TYPE = Enum('D3D_SHADER_VARIABLE_TYPE', [
    'D3D_SVT_VOID',
    'D3D_SVT_BOOL',
    'D3D_SVT_INT',
    'D3D_SVT_FLOAT',
    'D3D_SVT_STRING',
    'D3D_SVT_TEXTURE',
    'D3D_SVT_TEXTURE1D',
    'D3D_SVT_TEXTURE2D',
    'D3D_SVT_TEXTURE3D',
    'D3D_SVT_TEXTURECUBE',
    'D3D_SVT_SAMPLER',
    'D3D_SVT_SAMPLER1D',
    'D3D_SVT_SAMPLER2D',
    'D3D_SVT_SAMPLER3D',
    'D3D_SVT_SAMPLERCUBE',
    'D3D_SVT_PIXELSHADER',
    'D3D_SVT_VERTEXSHADER',
    'D3D_SVT_PIXELFRAGMENT',
    'D3D_SVT_VERTEXFRAGMENT',
    'D3D_SVT_UINT',
    'D3D_SVT_UINT8',
    'D3D_SVT_GEOMETRYSHADER',
    'D3D_SVT_RASTERIZER',
    'D3D_SVT_DEPTHSTENCIL',
    'D3D_SVT_BLEND',
    'D3D_SVT_BUFFER',
    'D3D_SVT_CBUFFER',
    'D3D_SVT_TBUFFER',
    'D3D_SVT_TEXTURE1DARRAY',
    'D3D_SVT_TEXTURE2DARRAY',
    'D3D_SVT_RENDERTARGETVIEW',
    'D3D_SVT_DEPTHSTENCILVIEW',
    'D3D_SVT_TEXTURE2DMS',
    'D3D_SVT_TEXTURE2DMSARRAY',
    'D3D_SVT_TEXTURECUBEARRAY',
    'D3D_SVT_HULLSHADER',
    'D3D_SVT_DOMAINSHADER',
    'D3D_SVT_INTERFACE_POINTER',
    'D3D_SVT_COMPUTESHADER',
    'D3D_SVT_DOUBLE',
    'D3D_SVT_RWTEXTURE1D',
    'D3D_SVT_RWTEXTURE1DARRAY',
    'D3D_SVT_RWTEXTURE2D',
    'D3D_SVT_RWTEXTURE2DARRAY',
    'D3D_SVT_RWTEXTURE3D',
    'D3D_SVT_RWBUFFER',
    'D3D_SVT_BYTEADDRESS_BUFFER',
    'D3D_SVT_RWBYTEADDRESS_BUFFER',
    'D3D_SVT_STRUCTURED_BUFFER',
    'D3D_SVT_RWSTRUCTURED_BUFFER',
    'D3D_SVT_APPEND_STRUCTURED_BUFFER',
    'D3D_SVT_CONSUME_STRUCTURED_BUFFER',
])

D3D10_SHADER_VARIABLE_TYPE = Enum('D3D10_SHADER_VARIABLE_TYPE', [
    'D3D10_SVT_VOID',
    'D3D10_SVT_BOOL',
    'D3D10_SVT_INT',
    'D3D10_SVT_FLOAT',
    'D3D10_SVT_STRING',
    'D3D10_SVT_TEXTURE',
    'D3D10_SVT_TEXTURE1D',
    'D3D10_SVT_TEXTURE2D',
    'D3D10_SVT_TEXTURE3D',
    'D3D10_SVT_TEXTURECUBE',
    'D3D10_SVT_SAMPLER',
    'D3D10_SVT_SAMPLER1D',
    'D3D10_SVT_SAMPLER2D',
    'D3D10_SVT_SAMPLER3D',
    'D3D10_SVT_SAMPLERCUBE',
    'D3D10_SVT_PIXELSHADER',
    'D3D10_SVT_VERTEXSHADER',
    'D3D10_SVT_PIXELFRAGMENT',
    'D3D10_SVT_VERTEXFRAGMENT',
    'D3D10_SVT_UINT',
    'D3D10_SVT_UINT8',
    'D3D10_SVT_GEOMETRYSHADER',
    'D3D10_SVT_RASTERIZER',
    'D3D10_SVT_DEPTHSTENCIL',
    'D3D10_SVT_BLEND',
    'D3D10_SVT_BUFFER',
    'D3D10_SVT_CBUFFER',
    'D3D10_SVT_TBUFFER',
    'D3D10_SVT_TEXTURE1DARRAY',
    'D3D10_SVT_TEXTURE2DARRAY',
    'D3D10_SVT_RENDERTARGETVIEW',
    'D3D10_SVT_DEPTHSTENCILVIEW',
    'D3D10_SVT_TEXTURE2DMS',
    'D3D10_SVT_TEXTURE2DMSARRAY',
    'D3D10_SVT_TEXTURECUBEARRAY',
])

D3D11_SHADER_VARIABLE_TYPE = Enum('D3D11_SHADER_VARIABLE_TYPE', [
    'D3D11_SVT_HULLSHADER',
    'D3D11_SVT_DOMAINSHADER',
    'D3D11_SVT_INTERFACE_POINTER',
    'D3D11_SVT_COMPUTESHADER',
    'D3D11_SVT_DOUBLE',
    'D3D11_SVT_RWTEXTURE1D',
    'D3D11_SVT_RWTEXTURE1DARRAY',
    'D3D11_SVT_RWTEXTURE2D',
    'D3D11_SVT_RWTEXTURE2DARRAY',
    'D3D11_SVT_RWTEXTURE3D',
    'D3D11_SVT_RWBUFFER',
    'D3D11_SVT_BYTEADDRESS_BUFFER',
    'D3D11_SVT_RWBYTEADDRESS_BUFFER',
    'D3D11_SVT_STRUCTURED_BUFFER',
    'D3D11_SVT_RWSTRUCTURED_BUFFER',
    'D3D11_SVT_APPEND_STRUCTURED_BUFFER',
    'D3D11_SVT_CONSUME_STRUCTURED_BUFFER',
])

D3D_SHADER_INPUT_FLAGS = Enum('D3D_SHADER_INPUT_FLAGS', [
    'D3D_SIF_USERPACKED',
    'D3D_SIF_COMPARISON_SAMPLER',
    'D3D_SIF_TEXTURE_COMPONENT_0',
    'D3D_SIF_TEXTURE_COMPONENT_1',
    'D3D_SIF_TEXTURE_COMPONENTS',
])

D3D10_SHADER_INPUT_FLAGS = Enum('D3D10_SHADER_INPUT_FLAGS', [
    'D3D10_SIF_USERPACKED',
    'D3D10_SIF_COMPARISON_SAMPLER',
    'D3D10_SIF_TEXTURE_COMPONENT_0',
    'D3D10_SIF_TEXTURE_COMPONENT_1',
    'D3D10_SIF_TEXTURE_COMPONENTS',
])

D3D_SHADER_INPUT_TYPE = Enum('D3D_SHADER_INPUT_TYPE', [
    'D3D_SIT_CBUFFER',
    'D3D_SIT_TBUFFER',
    'D3D_SIT_TEXTURE',
    'D3D_SIT_SAMPLER',
    'D3D_SIT_UAV_RWTYPED',
    'D3D_SIT_STRUCTURED',
    'D3D_SIT_UAV_RWSTRUCTURED',
    'D3D_SIT_BYTEADDRESS',
    'D3D_SIT_UAV_RWBYTEADDRESS',
    'D3D_SIT_UAV_APPEND_STRUCTURED',
    'D3D_SIT_UAV_CONSUME_STRUCTURED',
    'D3D_SIT_UAV_RWSTRUCTURED_WITH_COUNTER',
])

D3D10_SHADER_INPUT_TYPE = Enum('D3D10_SHADER_INPUT_TYPE', [
    'D3D10_SIT_CBUFFER',
    'D3D10_SIT_TBUFFER',
    'D3D10_SIT_TEXTURE',
    'D3D10_SIT_SAMPLER',
])

D3D11_SHADER_INPUT_TYPE = Enum('D3D11_SHADER_INPUT_TYPE', [
    'D3D11_SIT_UAV_RWTYPED',
    'D3D11_SIT_STRUCTURED',
    'D3D11_SIT_UAV_RWSTRUCTURED',
    'D3D11_SIT_BYTEADDRESS',
    'D3D11_SIT_UAV_RWBYTEADDRESS',
    'D3D11_SIT_UAV_APPEND_STRUCTURED',
    'D3D11_SIT_UAV_CONSUME_STRUCTURED',
    'D3D11_SIT_UAV_RWSTRUCTURED_WITH_COUNTER',
])

D3D_SHADER_CBUFFER_FLAGS = Enum('D3D_SHADER_CBUFFER_FLAGS', [
    'D3D_CBF_USERPACKED',
])

D3D10_SHADER_CBUFFER_FLAGS = Enum('D3D10_SHADER_CBUFFER_FLAGS', [
    'D3D10_CBF_USERPACKED',
])

D3D_CBUFFER_TYPE = Enum('D3D_CBUFFER_TYPE', [
    'D3D_CT_CBUFFER',
    'D3D_CT_TBUFFER',
    'D3D_CT_INTERFACE_POINTERS',
    'D3D_CT_RESOURCE_BIND_INFO',
])

D3D10_CBUFFER_TYPE = Enum('D3D10_CBUFFER_TYPE', [
    'D3D10_CT_CBUFFER',
    'D3D10_CT_TBUFFER',
])

D3D11_CBUFFER_TYPE = Enum('D3D11_CBUFFER_TYPE', [
    'D3D11_CT_CBUFFER',
    'D3D11_CT_TBUFFER',
    'D3D11_CT_INTERFACE_POINTERS',
    'D3D11_CT_RESOURCE_BIND_INFO',
])

D3D_NAME = Enum('D3D_NAME', [
    'D3D_NAME_UNDEFINED',
    'D3D_NAME_POSITION',
    'D3D_NAME_CLIP_DISTANCE',
    'D3D_NAME_CULL_DISTANCE',
    'D3D_NAME_RENDER_TARGET_ARRAY_INDEX',
    'D3D_NAME_VIEWPORT_ARRAY_INDEX',
    'D3D_NAME_VERTEX_ID',
    'D3D_NAME_PRIMITIVE_ID',
    'D3D_NAME_INSTANCE_ID',
    'D3D_NAME_IS_FRONT_FACE',
    'D3D_NAME_SAMPLE_INDEX',
    'D3D_NAME_FINAL_QUAD_EDGE_TESSFACTOR',
    'D3D_NAME_FINAL_QUAD_INSIDE_TESSFACTOR',
    'D3D_NAME_FINAL_TRI_EDGE_TESSFACTOR',
    'D3D_NAME_FINAL_TRI_INSIDE_TESSFACTOR',
    'D3D_NAME_FINAL_LINE_DETAIL_TESSFACTOR',
    'D3D_NAME_FINAL_LINE_DENSITY_TESSFACTOR',
    'D3D_NAME_TARGET',
    'D3D_NAME_DEPTH',
    'D3D_NAME_COVERAGE',
    'D3D_NAME_DEPTH_GREATER_EQUAL',
    'D3D_NAME_DEPTH_LESS_EQUAL',
])

D3D10_NAME = Enum('D3D10_NAME', [
    'D3D10_NAME_UNDEFINED',
    'D3D10_NAME_POSITION',
    'D3D10_NAME_CLIP_DISTANCE',
    'D3D10_NAME_CULL_DISTANCE',
    'D3D10_NAME_RENDER_TARGET_ARRAY_INDEX',
    'D3D10_NAME_VIEWPORT_ARRAY_INDEX',
    'D3D10_NAME_VERTEX_ID',
    'D3D10_NAME_PRIMITIVE_ID',
    'D3D10_NAME_INSTANCE_ID',
    'D3D10_NAME_IS_FRONT_FACE',
    'D3D10_NAME_SAMPLE_INDEX',
    'D3D10_NAME_TARGET',
    'D3D10_NAME_DEPTH',
    'D3D10_NAME_COVERAGE',
])

D3D11_NAME = Enum('D3D11_NAME', [
    'D3D11_NAME_FINAL_QUAD_EDGE_TESSFACTOR',
    'D3D11_NAME_FINAL_QUAD_INSIDE_TESSFACTOR',
    'D3D11_NAME_FINAL_TRI_EDGE_TESSFACTOR',
    'D3D11_NAME_FINAL_TRI_INSIDE_TESSFACTOR',
    'D3D11_NAME_FINAL_LINE_DETAIL_TESSFACTOR',
    'D3D11_NAME_FINAL_LINE_DENSITY_TESSFACTOR',
    'D3D11_NAME_DEPTH_GREATER_EQUAL',
    'D3D11_NAME_DEPTH_LESS_EQUAL',
])

D3D_RESOURCE_RETURN_TYPE = Enum('D3D_RESOURCE_RETURN_TYPE', [
    'D3D_RETURN_TYPE_UNORM',
    'D3D_RETURN_TYPE_SNORM',
    'D3D_RETURN_TYPE_SINT',
    'D3D_RETURN_TYPE_UINT',
    'D3D_RETURN_TYPE_FLOAT',
    'D3D_RETURN_TYPE_MIXED',
    'D3D_RETURN_TYPE_DOUBLE',
    'D3D_RETURN_TYPE_CONTINUED',
])

D3D10_RESOURCE_RETURN_TYPE = Enum('D3D10_RESOURCE_RETURN_TYPE', [
    'D3D10_RETURN_TYPE_UNORM',
    'D3D10_RETURN_TYPE_SNORM',
    'D3D10_RETURN_TYPE_SINT',
    'D3D10_RETURN_TYPE_UINT',
    'D3D10_RETURN_TYPE_FLOAT',
    'D3D10_RETURN_TYPE_MIXED',
])

D3D11_RESOURCE_RETURN_TYPE = Enum('D3D11_RESOURCE_RETURN_TYPE', [
    'D3D11_RETURN_TYPE_UNORM',
    'D3D11_RETURN_TYPE_SNORM',
    'D3D11_RETURN_TYPE_SINT',
    'D3D11_RETURN_TYPE_UINT',
    'D3D11_RETURN_TYPE_FLOAT',
    'D3D11_RETURN_TYPE_MIXED',
    'D3D11_RETURN_TYPE_DOUBLE',
    'D3D11_RETURN_TYPE_CONTINUED',
])

D3D_REGISTER_COMPONENT_TYPE = Enum('D3D_REGISTER_COMPONENT_TYPE', [
    'D3D_REGISTER_COMPONENT_UNKNOWN',
    'D3D_REGISTER_COMPONENT_UINT32',
    'D3D_REGISTER_COMPONENT_SINT32',
    'D3D_REGISTER_COMPONENT_FLOAT32',
])

D3D10_REGISTER_COMPONENT_TYPE = Enum('D3D10_REGISTER_COMPONENT_TYPE', [
    'D3D10_REGISTER_COMPONENT_UNKNOWN',
    'D3D10_REGISTER_COMPONENT_UINT32',
    'D3D10_REGISTER_COMPONENT_SINT32',
    'D3D10_REGISTER_COMPONENT_FLOAT32',
])

D3D_TESSELLATOR_DOMAIN = Enum('D3D_TESSELLATOR_DOMAIN', [
    'D3D_TESSELLATOR_DOMAIN_UNDEFINED',
    'D3D_TESSELLATOR_DOMAIN_ISOLINE',
    'D3D_TESSELLATOR_DOMAIN_TRI',
    'D3D_TESSELLATOR_DOMAIN_QUAD',
])

D3D11_TESSELLATOR_DOMAIN = Enum('D3D11_TESSELLATOR_DOMAIN', [
    'D3D11_TESSELLATOR_DOMAIN_UNDEFINED',
    'D3D11_TESSELLATOR_DOMAIN_ISOLINE',
    'D3D11_TESSELLATOR_DOMAIN_TRI',
    'D3D11_TESSELLATOR_DOMAIN_QUAD',
])

D3D_TESSELLATOR_PARTITIONING = Enum('D3D_TESSELLATOR_PARTITIONING', [
    'D3D_TESSELLATOR_PARTITIONING_UNDEFINED',
    'D3D_TESSELLATOR_PARTITIONING_INTEGER',
    'D3D_TESSELLATOR_PARTITIONING_POW2',
    'D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD',
    'D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN',
])

D3D11_TESSELLATOR_PARTITIONING = Enum('D3D11_TESSELLATOR_PARTITIONING', [
    'D3D11_TESSELLATOR_PARTITIONING_UNDEFINED',
    'D3D11_TESSELLATOR_PARTITIONING_INTEGER',
    'D3D11_TESSELLATOR_PARTITIONING_POW2',
    'D3D11_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD',
    'D3D11_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN',
])

D3D_TESSELLATOR_OUTPUT_PRIMITIVE = Enum('D3D_TESSELLATOR_OUTPUT_PRIMITIVE', [
    'D3D_TESSELLATOR_OUTPUT_UNDEFINED',
    'D3D_TESSELLATOR_OUTPUT_POINT',
    'D3D_TESSELLATOR_OUTPUT_LINE',
    'D3D_TESSELLATOR_OUTPUT_TRIANGLE_CW',
    'D3D_TESSELLATOR_OUTPUT_TRIANGLE_CCW',
])

D3D11_TESSELLATOR_OUTPUT_PRIMITIVE = Enum('D3D11_TESSELLATOR_OUTPUT_PRIMITIVE', [
    'D3D11_TESSELLATOR_OUTPUT_UNDEFINED',
    'D3D11_TESSELLATOR_OUTPUT_POINT',
    'D3D11_TESSELLATOR_OUTPUT_LINE',
    'D3D11_TESSELLATOR_OUTPUT_TRIANGLE_CW',
    'D3D11_TESSELLATOR_OUTPUT_TRIANGLE_CCW',
])


########NEW FILE########
__FILENAME__ = d3dtypes
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""d3dtypes.h"""

from winapi import *

D3DVALUE = Float
LPD3DVALUE = Pointer(D3DVALUE)

D3DFIXED = LONG

LPD3DVALIDATECALLBACK = Opaque("LPD3DVALIDATECALLBACK")
LPD3DENUMTEXTUREFORMATSCALLBACK = Opaque("LPD3DENUMTEXTUREFORMATSCALLBACK")
LPD3DENUMPIXELFORMATSCALLBACK = Opaque("LPD3DENUMPIXELFORMATSCALLBACK")

D3DCOLOR = Alias("D3DCOLOR", DWORD)

D3DVECTOR = Struct("D3DVECTOR", [
    (D3DVALUE, "x"),
    (D3DVALUE, "y"),
    (D3DVALUE, "z"),
])
LPD3DVECTOR = Pointer(D3DVECTOR)

D3DCOLORVALUE = Struct("D3DCOLORVALUE", [
    (D3DVALUE, "r"),
    (D3DVALUE, "g"),
    (D3DVALUE, "b"),
    (D3DVALUE, "a"),
])
LPD3DCOLORVALUE = Pointer(D3DCOLORVALUE)

D3DRECT = Struct("D3DRECT", [
    (LONG, "x1"),
    (LONG, "y1"),
    (LONG, "x2"),
    (LONG, "y2"),
])
LPD3DRECT = Pointer(D3DRECT)

D3DMATERIALHANDLE = DWORD
LPD3DMATERIALHANDLE = Pointer(D3DMATERIALHANDLE)

D3DTEXTUREHANDLE = DWORD
LPD3DTEXTUREHANDLE = Pointer(D3DTEXTUREHANDLE)

D3DMATRIXHANDLE = DWORD
LPD3DMATRIXHANDLE = Pointer(D3DMATRIXHANDLE)

D3DHVERTEX = Struct("D3DHVERTEX", [
    (DWORD, "dwFlags"),
    (D3DVALUE, "hx"),
    (D3DVALUE, "hy"),
    (D3DVALUE, "hz"),
])
LPD3DHVERTEX = Pointer(D3DHVERTEX)

D3DTLVERTEX = Struct("D3DTLVERTEX", [
    (D3DVALUE, "sx"),
    (D3DVALUE, "sy"),
    (D3DVALUE, "sz"),
    (D3DVALUE, "rhw"),
    (D3DCOLOR, "color"),
    (D3DCOLOR, "specular"),
    (D3DVALUE, "tu"),
    (D3DVALUE, "tv"),
])
LPD3DTLVERTEX = Pointer(D3DTLVERTEX)

D3DLVERTEX = Struct("D3DLVERTEX", [
    (D3DVALUE, "x"),
    (D3DVALUE, "y"),
    (D3DVALUE, "z"),
    (DWORD, "dwReserved"),
    (D3DCOLOR, "color"),
    (D3DCOLOR, "specular"),
    (D3DVALUE, "tu"),
    (D3DVALUE, "tv"),
])
LPD3DLVERTEX = Pointer(D3DLVERTEX)

D3DVERTEX = Struct("D3DVERTEX", [
    (D3DVALUE, "x"),
    (D3DVALUE, "y"),
    (D3DVALUE, "z"),
    (D3DVALUE, "nx"),
    (D3DVALUE, "ny"),
    (D3DVALUE, "nz"),
    (D3DVALUE, "tu"),
    (D3DVALUE, "tv"),
])
LPD3DVERTEX = Pointer(D3DVERTEX)

D3DMATRIX = Struct("D3DMATRIX", [
    (D3DVALUE, "_%u" % index) for index in [
         11, 12, 13, 14,
         21, 22, 23, 24,
         31, 32, 33, 34,
         41, 42, 43, 44
    ]
])
LPD3DMATRIX = Alias("LPD3DMATRIX", Pointer(D3DMATRIX))

D3DVIEWPORT = Struct("D3DVIEWPORT", [
    (DWORD, "dwSize"),
    (DWORD, "dwX"),
    (DWORD, "dwY"),
    (DWORD, "dwWidth"),
    (DWORD, "dwHeight"),
    (D3DVALUE, "dvScaleX"),
    (D3DVALUE, "dvScaleY"),
    (D3DVALUE, "dvMaxX"),
    (D3DVALUE, "dvMaxY"),
    (D3DVALUE, "dvMinZ"),
    (D3DVALUE, "dvMaxZ"),
])
LPD3DVIEWPORT = Pointer(D3DVIEWPORT)

D3DVIEWPORT2 = Struct("D3DVIEWPORT2", [
    (DWORD, "dwSize"),
    (DWORD, "dwX"),
    (DWORD, "dwY"),
    (DWORD, "dwWidth"),
    (DWORD, "dwHeight"),
    (D3DVALUE, "dvClipX"),
    (D3DVALUE, "dvClipY"),
    (D3DVALUE, "dvClipWidth"),
    (D3DVALUE, "dvClipHeight"),
    (D3DVALUE, "dvMinZ"),
    (D3DVALUE, "dvMaxZ"),
])
LPD3DVIEWPORT2 = Pointer(D3DVIEWPORT2)

D3DVIEWPORT7 = Struct("D3DVIEWPORT7", [
    (DWORD, "dwX"),
    (DWORD, "dwY"),
    (DWORD, "dwWidth"),
    (DWORD, "dwHeight"),
    (D3DVALUE, "dvMinZ"),
    (D3DVALUE, "dvMaxZ"),
])
LPD3DVIEWPORT7 = Pointer(D3DVIEWPORT7)

D3DCLIP = Flags(DWORD, [
    "D3DCLIP_LEFT",
    "D3DCLIP_RIGHT",
    "D3DCLIP_TOP",
    "D3DCLIP_BOTTOM",
    "D3DCLIP_FRONT",
    "D3DCLIP_BACK",
    "D3DCLIP_GEN0",
    "D3DCLIP_GEN1",
    "D3DCLIP_GEN2",
    "D3DCLIP_GEN3",
    "D3DCLIP_GEN4",
    "D3DCLIP_GEN5",
])

D3DSTATUS = Flags(DWORD, [
    "D3DSTATUS_DEFAULT",
    "D3DSTATUS_CLIPUNIONALL",
    "D3DSTATUS_CLIPUNIONLEFT",
    "D3DSTATUS_CLIPUNIONRIGHT",
    "D3DSTATUS_CLIPUNIONTOP",
    "D3DSTATUS_CLIPUNIONBOTTOM",
    "D3DSTATUS_CLIPUNIONFRONT",
    "D3DSTATUS_CLIPUNIONBACK",
    "D3DSTATUS_CLIPUNIONGEN0",
    "D3DSTATUS_CLIPUNIONGEN1",
    "D3DSTATUS_CLIPUNIONGEN2",
    "D3DSTATUS_CLIPUNIONGEN3",
    "D3DSTATUS_CLIPUNIONGEN4",
    "D3DSTATUS_CLIPUNIONGEN5",
    "D3DSTATUS_CLIPINTERSECTIONALL",
    "D3DSTATUS_CLIPINTERSECTIONLEFT",
    "D3DSTATUS_CLIPINTERSECTIONRIGHT",
    "D3DSTATUS_CLIPINTERSECTIONTOP",
    "D3DSTATUS_CLIPINTERSECTIONBOTTOM",
    "D3DSTATUS_CLIPINTERSECTIONFRONT",
    "D3DSTATUS_CLIPINTERSECTIONBACK",
    "D3DSTATUS_CLIPINTERSECTIONGEN0",
    "D3DSTATUS_CLIPINTERSECTIONGEN1",
    "D3DSTATUS_CLIPINTERSECTIONGEN2",
    "D3DSTATUS_CLIPINTERSECTIONGEN3",
    "D3DSTATUS_CLIPINTERSECTIONGEN4",
    "D3DSTATUS_CLIPINTERSECTIONGEN5",
    "D3DSTATUS_ZNOTVISIBLE",
])

D3DTRANSFORM = Flags(DWORD, [
    "D3DTRANSFORM_CLIPPED",
    "D3DTRANSFORM_UNCLIPPED",
])

D3DTRANSFORMDATA = Struct("D3DTRANSFORMDATA", [
    (DWORD, "dwSize"),
    (LPVOID, "lpIn"),
    (DWORD, "dwInSize"),
    (LPVOID, "lpOut"),
    (DWORD, "dwOutSize"),
    (LPD3DHVERTEX, "lpHOut"),
    (DWORD, "dwClip"),
    (DWORD, "dwClipIntersection"),
    (DWORD, "dwClipUnion"),
    (D3DRECT, "drExtent"),
])
LPD3DTRANSFORMDATA = Pointer(D3DTRANSFORMDATA)

D3DLIGHTINGELEMENT = Struct("D3DLIGHTINGELEMENT", [
    (D3DVECTOR, "dvPosition"),
    (D3DVECTOR, "dvNormal"),
])
LPD3DLIGHTINGELEMENT = Pointer(D3DLIGHTINGELEMENT)

D3DMATERIAL = Struct("D3DMATERIAL", [
    (DWORD, "dwSize"),
    (D3DCOLORVALUE, "diffuse"),
    (D3DCOLORVALUE, "ambient"),
    (D3DCOLORVALUE, "specular"),
    (D3DCOLORVALUE, "emissive"),
    (D3DVALUE, "power"),
    (D3DTEXTUREHANDLE, "hTexture"),
    (DWORD, "dwRampSize"),
])
LPD3DMATERIAL = Pointer(D3DMATERIAL)

D3DMATERIAL7 = Struct("D3DMATERIAL7", [
    (D3DCOLORVALUE, "diffuse"),
    (D3DCOLORVALUE, "ambient"),
    (D3DCOLORVALUE, "specular"),
    (D3DCOLORVALUE, "emissive"),
    (D3DVALUE, "power"),
])
LPD3DMATERIAL7 = Pointer(D3DMATERIAL7)

D3DLIGHTTYPE = Enum("D3DLIGHTTYPE", [
    "D3DLIGHT_POINT",
    "D3DLIGHT_SPOT",
    "D3DLIGHT_DIRECTIONAL",
    "D3DLIGHT_PARALLELPOINT",
    "D3DLIGHT_GLSPOT",
])

D3DLIGHT = Struct("D3DLIGHT", [
    (DWORD, "dwSize"),
    (D3DLIGHTTYPE, "dltType"),
    (D3DCOLORVALUE, "dcvColor"),
    (D3DVECTOR, "dvPosition"),
    (D3DVECTOR, "dvDirection"),
    (D3DVALUE, "dvRange"),
    (D3DVALUE, "dvFalloff"),
    (D3DVALUE, "dvAttenuation0"),
    (D3DVALUE, "dvAttenuation1"),
    (D3DVALUE, "dvAttenuation2"),
    (D3DVALUE, "dvTheta"),
    (D3DVALUE, "dvPhi"),
])
LPD3DLIGHT = Pointer(D3DLIGHT)

D3DLIGHT7 = Struct("D3DLIGHT7", [
    (D3DLIGHTTYPE, "dltType"),
    (D3DCOLORVALUE, "dcvDiffuse"),
    (D3DCOLORVALUE, "dcvSpecular"),
    (D3DCOLORVALUE, "dcvAmbient"),
    (D3DVECTOR, "dvPosition"),
    (D3DVECTOR, "dvDirection"),
    (D3DVALUE, "dvRange"),
    (D3DVALUE, "dvFalloff"),
    (D3DVALUE, "dvAttenuation0"),
    (D3DVALUE, "dvAttenuation1"),
    (D3DVALUE, "dvAttenuation2"),
    (D3DVALUE, "dvTheta"),
    (D3DVALUE, "dvPhi"),
])
LPD3DLIGHT7 = Pointer(D3DLIGHT7)

D3DLIGHTFLAGS = Flags(DWORD, [
    "D3DLIGHT_ACTIVE",
    "D3DLIGHT_NO_SPECULAR",
    "D3DLIGHT_ALL",
])

D3DLIGHT2 = Struct("D3DLIGHT2", [
    (DWORD, "dwSize"),
    (D3DLIGHTTYPE, "dltType"),
    (D3DCOLORVALUE, "dcvColor"),
    (D3DVECTOR, "dvPosition"),
    (D3DVECTOR, "dvDirection"),
    (D3DVALUE, "dvRange"),
    (D3DVALUE, "dvFalloff"),
    (D3DVALUE, "dvAttenuation0"),
    (D3DVALUE, "dvAttenuation1"),
    (D3DVALUE, "dvAttenuation2"),
    (D3DVALUE, "dvTheta"),
    (D3DVALUE, "dvPhi"),
    (DWORD, "dwFlags"),
])
LPD3DLIGHT2 = Pointer(D3DLIGHT2)

D3DLIGHTDATA = Struct("D3DLIGHTDATA", [
    (DWORD, "dwSize"),
    (LPD3DLIGHTINGELEMENT, "lpIn"),
    (DWORD, "dwInSize"),
    (LPD3DTLVERTEX, "lpOut"),
    (DWORD, "dwOutSize"),
])
LPD3DLIGHTDATA = Pointer(D3DLIGHTDATA)

D3DCOLOR = Flags(DWORD, [
    "D3DCOLOR_MONO",
    "D3DCOLOR_RGB",
])

D3DCOLORMODEL = DWORD

D3DCLEAR = Flags(DWORD, [
    "D3DCLEAR_TARGET",
    "D3DCLEAR_ZBUFFER",
    "D3DCLEAR_STENCIL",
])

D3DOPCODE = Enum("D3DOPCODE", [
    "D3DOP_POINT",
    "D3DOP_LINE",
    "D3DOP_TRIANGLE",
    "D3DOP_MATRIXLOAD",
    "D3DOP_MATRIXMULTIPLY",
    "D3DOP_STATETRANSFORM",
    "D3DOP_STATELIGHT",
    "D3DOP_STATERENDER",
    "D3DOP_PROCESSVERTICES",
    "D3DOP_TEXTURELOAD",
    "D3DOP_EXIT",
    "D3DOP_BRANCHFORWARD",
    "D3DOP_SPAN",
    "D3DOP_SETSTATUS",
])

D3DINSTRUCTION = Struct("D3DINSTRUCTION", [
    (BYTE, "bOpcode"),
    (BYTE, "bSize"),
    (WORD, "wCount"),
])

D3DTEXTURELOAD = Struct("D3DTEXTURELOAD", [
    (D3DTEXTUREHANDLE, "hDestTexture"),
    (D3DTEXTUREHANDLE, "hSrcTexture"),
])

D3DPICKRECORD = Struct("D3DPICKRECORD", [
    (BYTE, "bOpcode"),
    (BYTE, "bPad"),
    (DWORD, "dwOffset"),
    (D3DVALUE, "dvZ"),
])
LPD3DPICKRECORD = Pointer(D3DPICKRECORD)

D3DSHADEMODE = Enum("D3DSHADEMODE", [
    "D3DSHADE_FLAT",
    "D3DSHADE_GOURAUD",
    "D3DSHADE_PHONG",
])

D3DFILLMODE = Enum("D3DFILLMODE", [
    "D3DFILL_POINT",
    "D3DFILL_WIREFRAME",
    "D3DFILL_SOLID",
])

D3DLINEPATTERN = Struct("D3DLINEPATTERN", [
    (WORD, "wRepeatFactor"),
    (WORD, "wLinePattern"),
])

D3DTEXTUREFILTER = Enum("D3DTEXTUREFILTER", [
    "D3DFILTER_NEAREST",
    "D3DFILTER_LINEAR",
    "D3DFILTER_MIPNEAREST",
    "D3DFILTER_MIPLINEAR",
    "D3DFILTER_LINEARMIPNEAREST",
    "D3DFILTER_LINEARMIPLINEAR",
])

D3DBLEND = Enum("D3DBLEND", [
    "D3DBLEND_ZERO",
    "D3DBLEND_ONE",
    "D3DBLEND_SRCCOLOR",
    "D3DBLEND_INVSRCCOLOR",
    "D3DBLEND_SRCALPHA",
    "D3DBLEND_INVSRCALPHA",
    "D3DBLEND_DESTALPHA",
    "D3DBLEND_INVDESTALPHA",
    "D3DBLEND_DESTCOLOR",
    "D3DBLEND_INVDESTCOLOR",
    "D3DBLEND_SRCALPHASAT",
    "D3DBLEND_BOTHSRCALPHA",
    "D3DBLEND_BOTHINVSRCALPHA",
])

D3DTEXTUREBLEND = Enum("D3DTEXTUREBLEND", [
    "D3DTBLEND_DECAL",
    "D3DTBLEND_MODULATE",
    "D3DTBLEND_DECALALPHA",
    "D3DTBLEND_MODULATEALPHA",
    "D3DTBLEND_DECALMASK",
    "D3DTBLEND_MODULATEMASK",
    "D3DTBLEND_COPY",
    "D3DTBLEND_ADD",
])

D3DTEXTUREADDRESS = Enum("D3DTEXTUREADDRESS", [
    "D3DTADDRESS_WRAP",
    "D3DTADDRESS_MIRROR",
    "D3DTADDRESS_CLAMP",
    "D3DTADDRESS_BORDER",
])

D3DCULL = Enum("D3DCULL", [
    "D3DCULL_NONE",
    "D3DCULL_CW",
    "D3DCULL_CCW",
])

D3DCMPFUNC = Enum("D3DCMPFUNC", [
    "D3DCMP_NEVER",
    "D3DCMP_LESS",
    "D3DCMP_EQUAL",
    "D3DCMP_LESSEQUAL",
    "D3DCMP_GREATER",
    "D3DCMP_NOTEQUAL",
    "D3DCMP_GREATEREQUAL",
    "D3DCMP_ALWAYS",
])

D3DSTENCILOP = Enum("D3DSTENCILOP", [
    "D3DSTENCILOP_KEEP",
    "D3DSTENCILOP_ZERO",
    "D3DSTENCILOP_REPLACE",
    "D3DSTENCILOP_INCRSAT",
    "D3DSTENCILOP_DECRSAT",
    "D3DSTENCILOP_INVERT",
    "D3DSTENCILOP_INCR",
    "D3DSTENCILOP_DECR",
])

D3DFOGMODE = Enum("D3DFOGMODE", [
    "D3DFOG_NONE",
    "D3DFOG_EXP",
    "D3DFOG_EXP2",
    "D3DFOG_LINEAR",
])

D3DZBUFFERTYPE = Enum("D3DZBUFFERTYPE", [
    "D3DZB_FALSE",
    "D3DZB_TRUE",
    "D3DZB_USEW",
])

D3DANTIALIASMODE = Enum("D3DANTIALIASMODE", [
    "D3DANTIALIAS_NONE",
    "D3DANTIALIAS_SORTDEPENDENT",
    "D3DANTIALIAS_SORTINDEPENDENT",
])

D3DVERTEXTYPE = Enum("D3DVERTEXTYPE", [
    "D3DVT_VERTEX",
    "D3DVT_LVERTEX",
    "D3DVT_TLVERTEX",
])

D3DPRIMITIVETYPE = Enum("D3DPRIMITIVETYPE", [
    "D3DPT_POINTLIST",
    "D3DPT_LINELIST",
    "D3DPT_LINESTRIP",
    "D3DPT_TRIANGLELIST",
    "D3DPT_TRIANGLESTRIP",
    "D3DPT_TRIANGLEFAN",
])

D3DTRANSFORMSTATETYPE = Enum("D3DTRANSFORMSTATETYPE", [
    "D3DTRANSFORMSTATE_WORLD",
    "D3DTRANSFORMSTATE_VIEW",
    "D3DTRANSFORMSTATE_PROJECTION",
    "D3DTRANSFORMSTATE_WORLD1",
    "D3DTRANSFORMSTATE_WORLD2",
    "D3DTRANSFORMSTATE_WORLD3",
    "D3DTRANSFORMSTATE_TEXTURE0",
    "D3DTRANSFORMSTATE_TEXTURE1",
    "D3DTRANSFORMSTATE_TEXTURE2",
    "D3DTRANSFORMSTATE_TEXTURE3",
    "D3DTRANSFORMSTATE_TEXTURE4",
    "D3DTRANSFORMSTATE_TEXTURE5",
    "D3DTRANSFORMSTATE_TEXTURE6",
    "D3DTRANSFORMSTATE_TEXTURE7",
])

D3DLIGHTSTATETYPE = Enum("D3DLIGHTSTATETYPE", [
    "D3DLIGHTSTATE_MATERIAL",
    "D3DLIGHTSTATE_AMBIENT",
    "D3DLIGHTSTATE_COLORMODEL",
    "D3DLIGHTSTATE_FOGMODE",
    "D3DLIGHTSTATE_FOGSTART",
    "D3DLIGHTSTATE_FOGEND",
    "D3DLIGHTSTATE_FOGDENSITY",
    "D3DLIGHTSTATE_COLORVERTEX",
])

D3DMATERIALCOLORSOURCE = Enum("D3DMATERIALCOLORSOURCE", [
    "D3DMCS_MATERIAL",
    "D3DMCS_COLOR1",
    "D3DMCS_COLOR2",
])

D3DWRAPCOORD = Flags(DWORD, [
    "D3DWRAPCOORD_0",
    "D3DWRAPCOORD_1",
    "D3DWRAPCOORD_2",
    "D3DWRAPCOORD_3",
])

D3DRENDERSTATETYPE = Enum("D3DRENDERSTATETYPE", [
    "D3DRENDERSTATE_ANTIALIAS",
    "D3DRENDERSTATE_TEXTUREPERSPECTIVE",
    "D3DRENDERSTATE_ZENABLE",
    "D3DRENDERSTATE_FILLMODE",
    "D3DRENDERSTATE_SHADEMODE",
    "D3DRENDERSTATE_LINEPATTERN",
    "D3DRENDERSTATE_ZWRITEENABLE",
    "D3DRENDERSTATE_ALPHATESTENABLE",
    "D3DRENDERSTATE_LASTPIXEL",
    "D3DRENDERSTATE_SRCBLEND",
    "D3DRENDERSTATE_DESTBLEND",
    "D3DRENDERSTATE_CULLMODE",
    "D3DRENDERSTATE_ZFUNC",
    "D3DRENDERSTATE_ALPHAREF",
    "D3DRENDERSTATE_ALPHAFUNC",
    "D3DRENDERSTATE_DITHERENABLE",
    "D3DRENDERSTATE_ALPHABLENDENABLE",
    "D3DRENDERSTATE_FOGENABLE",
    "D3DRENDERSTATE_SPECULARENABLE",
    "D3DRENDERSTATE_ZVISIBLE",
    "D3DRENDERSTATE_STIPPLEDALPHA",
    "D3DRENDERSTATE_FOGCOLOR",
    "D3DRENDERSTATE_FOGTABLEMODE",
    "D3DRENDERSTATE_FOGSTART",
    "D3DRENDERSTATE_FOGEND",
    "D3DRENDERSTATE_FOGDENSITY",
    "D3DRENDERSTATE_EDGEANTIALIAS",
    "D3DRENDERSTATE_COLORKEYENABLE",
    "D3DRENDERSTATE_ZBIAS",
    "D3DRENDERSTATE_RANGEFOGENABLE",
    "D3DRENDERSTATE_STENCILENABLE",
    "D3DRENDERSTATE_STENCILFAIL",
    "D3DRENDERSTATE_STENCILZFAIL",
    "D3DRENDERSTATE_STENCILPASS",
    "D3DRENDERSTATE_STENCILFUNC",
    "D3DRENDERSTATE_STENCILREF",
    "D3DRENDERSTATE_STENCILMASK",
    "D3DRENDERSTATE_STENCILWRITEMASK",
    "D3DRENDERSTATE_TEXTUREFACTOR",
    "D3DRENDERSTATE_WRAP0",
    "D3DRENDERSTATE_WRAP1",
    "D3DRENDERSTATE_WRAP2",
    "D3DRENDERSTATE_WRAP3",
    "D3DRENDERSTATE_WRAP4",
    "D3DRENDERSTATE_WRAP5",
    "D3DRENDERSTATE_WRAP6",
    "D3DRENDERSTATE_WRAP7",
    "D3DRENDERSTATE_CLIPPING",
    "D3DRENDERSTATE_LIGHTING",
    "D3DRENDERSTATE_EXTENTS",
    "D3DRENDERSTATE_AMBIENT",
    "D3DRENDERSTATE_FOGVERTEXMODE",
    "D3DRENDERSTATE_COLORVERTEX",
    "D3DRENDERSTATE_LOCALVIEWER",
    "D3DRENDERSTATE_NORMALIZENORMALS",
    "D3DRENDERSTATE_COLORKEYBLENDENABLE",
    "D3DRENDERSTATE_DIFFUSEMATERIALSOURCE",
    "D3DRENDERSTATE_SPECULARMATERIALSOURCE",
    "D3DRENDERSTATE_AMBIENTMATERIALSOURCE",
    "D3DRENDERSTATE_EMISSIVEMATERIALSOURCE",
    "D3DRENDERSTATE_VERTEXBLEND",
    "D3DRENDERSTATE_CLIPPLANEENABLE",
    "D3DRENDERSTATE_TEXTUREHANDLE",
    "D3DRENDERSTATE_TEXTUREADDRESS",
    "D3DRENDERSTATE_WRAPU",
    "D3DRENDERSTATE_WRAPV",
    "D3DRENDERSTATE_MONOENABLE",
    "D3DRENDERSTATE_ROP2",
    "D3DRENDERSTATE_PLANEMASK",
    "D3DRENDERSTATE_TEXTUREMAG",
    "D3DRENDERSTATE_TEXTUREMIN",
    "D3DRENDERSTATE_TEXTUREMAPBLEND",
    "D3DRENDERSTATE_SUBPIXEL",
    "D3DRENDERSTATE_SUBPIXELX",
    "D3DRENDERSTATE_STIPPLEENABLE",
    "D3DRENDERSTATE_BORDERCOLOR",
    "D3DRENDERSTATE_TEXTUREADDRESSU",
    "D3DRENDERSTATE_TEXTUREADDRESSV",
    "D3DRENDERSTATE_MIPMAPLODBIAS",
    "D3DRENDERSTATE_ANISOTROPY",
    "D3DRENDERSTATE_FLUSHBATCH",
    "D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT",
    "D3DRENDERSTATE_STIPPLEPATTERN00",
    "D3DRENDERSTATE_STIPPLEPATTERN01",
    "D3DRENDERSTATE_STIPPLEPATTERN02",
    "D3DRENDERSTATE_STIPPLEPATTERN03",
    "D3DRENDERSTATE_STIPPLEPATTERN04",
    "D3DRENDERSTATE_STIPPLEPATTERN05",
    "D3DRENDERSTATE_STIPPLEPATTERN06",
    "D3DRENDERSTATE_STIPPLEPATTERN07",
    "D3DRENDERSTATE_STIPPLEPATTERN08",
    "D3DRENDERSTATE_STIPPLEPATTERN09",
    "D3DRENDERSTATE_STIPPLEPATTERN10",
    "D3DRENDERSTATE_STIPPLEPATTERN11",
    "D3DRENDERSTATE_STIPPLEPATTERN12",
    "D3DRENDERSTATE_STIPPLEPATTERN13",
    "D3DRENDERSTATE_STIPPLEPATTERN14",
    "D3DRENDERSTATE_STIPPLEPATTERN15",
    "D3DRENDERSTATE_STIPPLEPATTERN16",
    "D3DRENDERSTATE_STIPPLEPATTERN17",
    "D3DRENDERSTATE_STIPPLEPATTERN18",
    "D3DRENDERSTATE_STIPPLEPATTERN19",
    "D3DRENDERSTATE_STIPPLEPATTERN20",
    "D3DRENDERSTATE_STIPPLEPATTERN21",
    "D3DRENDERSTATE_STIPPLEPATTERN22",
    "D3DRENDERSTATE_STIPPLEPATTERN23",
    "D3DRENDERSTATE_STIPPLEPATTERN24",
    "D3DRENDERSTATE_STIPPLEPATTERN25",
    "D3DRENDERSTATE_STIPPLEPATTERN26",
    "D3DRENDERSTATE_STIPPLEPATTERN27",
    "D3DRENDERSTATE_STIPPLEPATTERN28",
    "D3DRENDERSTATE_STIPPLEPATTERN29",
    "D3DRENDERSTATE_STIPPLEPATTERN30",
    "D3DRENDERSTATE_STIPPLEPATTERN31",
])

D3DSTATE = Struct("D3DSTATE", [
    (D3DTRANSFORMSTATETYPE, "dtstTransformStateType"),
    (D3DLIGHTSTATETYPE, "dlstLightStateType"),
    (D3DRENDERSTATETYPE, "drstRenderStateType"),
    (Array(DWORD, 1), "dwArg"),
    (Array(D3DVALUE, 1), "dvArg"),
])

D3DMATRIXLOAD = Struct("D3DMATRIXLOAD", [
    (D3DMATRIXHANDLE, "hDestMatrix"),
    (D3DMATRIXHANDLE, "hSrcMatrix"),
])

D3DMATRIXMULTIPLY = Struct("D3DMATRIXMULTIPLY", [
    (D3DMATRIXHANDLE, "hDestMatrix"),
    (D3DMATRIXHANDLE, "hSrcMatrix1"),
    (D3DMATRIXHANDLE, "hSrcMatrix2"),
])

D3DPROCESSVERTICES = Struct("D3DPROCESSVERTICES", [
    (DWORD, "dwFlags"),
    (WORD, "wStart"),
    (WORD, "wDest"),
    (DWORD, "dwCount"),
    (DWORD, "dwReserved"),
])

D3DPROCESSVERTICES = Flags(DWORD, [
    "D3DPROCESSVERTICES_TRANSFORMLIGHT",
    "D3DPROCESSVERTICES_TRANSFORM",
    "D3DPROCESSVERTICES_COPY",
    "D3DPROCESSVERTICES_OPMASK",
    "D3DPROCESSVERTICES_UPDATEEXTENTS",
    "D3DPROCESSVERTICES_NOCOLOR",
])

D3DTEXTURESTAGESTATETYPE = Enum("D3DTEXTURESTAGESTATETYPE", [
    "D3DTSS_COLOROP",
    "D3DTSS_COLORARG1",
    "D3DTSS_COLORARG2",
    "D3DTSS_ALPHAOP",
    "D3DTSS_ALPHAARG1",
    "D3DTSS_ALPHAARG2",
    "D3DTSS_BUMPENVMAT00",
    "D3DTSS_BUMPENVMAT01",
    "D3DTSS_BUMPENVMAT10",
    "D3DTSS_BUMPENVMAT11",
    "D3DTSS_TEXCOORDINDEX",
    "D3DTSS_ADDRESS",
    "D3DTSS_ADDRESSU",
    "D3DTSS_ADDRESSV",
    "D3DTSS_BORDERCOLOR",
    "D3DTSS_MAGFILTER",
    "D3DTSS_MINFILTER",
    "D3DTSS_MIPFILTER",
    "D3DTSS_MIPMAPLODBIAS",
    "D3DTSS_MAXMIPLEVEL",
    "D3DTSS_MAXANISOTROPY",
    "D3DTSS_BUMPENVLSCALE",
    "D3DTSS_BUMPENVLOFFSET",
    "D3DTSS_TEXTURETRANSFORMFLAGS",
])

D3DTSS_TCI = Flags(DWORD, [
    "D3DTSS_TCI_PASSTHRU",
    "D3DTSS_TCI_CAMERASPACENORMAL",
    "D3DTSS_TCI_CAMERASPACEPOSITION",
    "D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR",
])

D3DTEXTUREOP = Enum("D3DTEXTUREOP", [
    "D3DTOP_DISABLE",
    "D3DTOP_SELECTARG1",
    "D3DTOP_SELECTARG2",
    "D3DTOP_MODULATE",
    "D3DTOP_MODULATE2X",
    "D3DTOP_MODULATE4X",
    "D3DTOP_ADD",
    "D3DTOP_ADDSIGNED",
    "D3DTOP_ADDSIGNED2X",
    "D3DTOP_SUBTRACT",
    "D3DTOP_ADDSMOOTH",
    "D3DTOP_BLENDDIFFUSEALPHA",
    "D3DTOP_BLENDTEXTUREALPHA",
    "D3DTOP_BLENDFACTORALPHA",
    "D3DTOP_BLENDTEXTUREALPHAPM",
    "D3DTOP_BLENDCURRENTALPHA",
    "D3DTOP_PREMODULATE",
    "D3DTOP_MODULATEALPHA_ADDCOLOR",
    "D3DTOP_MODULATECOLOR_ADDALPHA",
    "D3DTOP_MODULATEINVALPHA_ADDCOLOR",
    "D3DTOP_MODULATEINVCOLOR_ADDALPHA",
    "D3DTOP_BUMPENVMAP",
    "D3DTOP_BUMPENVMAPLUMINANCE",
    "D3DTOP_DOTPRODUCT3",
])

# XXX: Actually a mixture of enums and flags
D3DTA = FakeEnum(DWORD, [
    "D3DTA_DIFFUSE",
    "D3DTA_CURRENT",
    "D3DTA_TEXTURE",
    "D3DTA_TFACTOR",
    "D3DTA_SPECULAR",
    #"D3DTA_COMPLEMENT",
    #"D3DTA_ALPHAREPLICATE",
])

D3DTEXTUREMAGFILTER = Enum("D3DTEXTUREMAGFILTER", [
    "D3DTFG_POINT",
    "D3DTFG_LINEAR",
    "D3DTFG_FLATCUBIC",
    "D3DTFG_GAUSSIANCUBIC",
    "D3DTFG_ANISOTROPIC",
])

D3DTEXTUREMINFILTER = Enum("D3DTEXTUREMINFILTER", [
    "D3DTFN_POINT",
    "D3DTFN_LINEAR",
    "D3DTFN_ANISOTROPIC",
])

D3DTEXTUREMIPFILTER = Enum("D3DTEXTUREMIPFILTER", [
    "D3DTFP_NONE",
    "D3DTFP_POINT",
    "D3DTFP_LINEAR",
])

D3DTRIFLAG = Flags(DWORD, [
    "D3DTRIFLAG_START",
    "D3DTRIFLAG_STARTFLAT(len)",
    "D3DTRIFLAG_ODD",
    "D3DTRIFLAG_EVEN",
    "D3DTRIFLAG_EDGEENABLETRIANGLE",
    "D3DTRIFLAG_EDGEENABLE1",
    "D3DTRIFLAG_EDGEENABLE2",
    "D3DTRIFLAG_EDGEENABLE3",
])

D3DTRIANGLE = Struct("D3DTRIANGLE", [
    (WORD, "v1"),
    (WORD, "v2"),
    (WORD, "v3"),
    (WORD, "wFlags"),
])

D3DLINE = Struct("D3DLINE", [
    (WORD, "v1"),
    (WORD, "v2"),
])

D3DSPAN = Struct("D3DSPAN", [
    (WORD, "wCount"),
    (WORD, "wFirst"),
])

D3DPOINT = Struct("D3DPOINT", [
    (WORD, "wCount"),
    (WORD, "wFirst"),
])

D3DBRANCH = Struct("D3DBRANCH", [
    (DWORD, "dwMask"),
    (DWORD, "dwValue"),
    (BOOL, "bNegate"),
    (DWORD, "dwOffset"),
])

D3DSTATUS = Struct("D3DSTATUS", [
    (DWORD, "dwFlags"),
    (DWORD, "dwStatus"),
    (D3DRECT, "drExtent"),
])

D3DSETSTATUS = Flags(DWORD, [
    "D3DSETSTATUS_STATUS",
    "D3DSETSTATUS_EXTENTS",
    "D3DSETSTATUS_ALL",
])

D3DCLIPSTATUS = Struct("D3DCLIPSTATUS", [
    (DWORD, "dwFlags"),
    (DWORD, "dwStatus"),
    (Float, "minx"),
    (Float, "maxx"),
    (Float, "miny"),
    (Float, "maxy"),
    (Float, "minz"),
    (Float, "maxz"),
])
LPD3DCLIPSTATUS = Pointer(D3DCLIPSTATUS)

D3DCLIPSTATUS = Flags(DWORD, [
    "D3DCLIPSTATUS_STATUS",
    "D3DCLIPSTATUS_EXTENTS2",
    "D3DCLIPSTATUS_EXTENTS3",
])

D3DSTATS = Struct("D3DSTATS", [
    (DWORD, "dwSize"),
    (DWORD, "dwTrianglesDrawn"),
    (DWORD, "dwLinesDrawn"),
    (DWORD, "dwPointsDrawn"),
    (DWORD, "dwSpansDrawn"),
    (DWORD, "dwVerticesProcessed"),
])
LPD3DSTATS = Pointer(D3DSTATS)

D3DEXECUTE = Flags(DWORD, [
    "D3DEXECUTE_CLIPPED",
    "D3DEXECUTE_UNCLIPPED",
])

D3DEXECUTEDATA = Struct("D3DEXECUTEDATA", [
    (DWORD, "dwSize"),
    (DWORD, "dwVertexOffset"),
    (DWORD, "dwVertexCount"),
    (DWORD, "dwInstructionOffset"),
    (DWORD, "dwInstructionLength"),
    (DWORD, "dwHVertexOffset"),
    (D3DSTATUS, "dsStatus"),
])
LPD3DEXECUTEDATA = Pointer(D3DEXECUTEDATA)

D3DPAL = Flags(DWORD, [
    "D3DPAL_FREE",
    "D3DPAL_READONLY",
    "D3DPAL_RESERVED",
])

D3DVERTEXBUFFERDESC = Struct("D3DVERTEXBUFFERDESC", [
    (DWORD, "dwSize"),
    (DWORD, "dwCaps"),
    (DWORD, "dwFVF"),
    (DWORD, "dwNumVertices"),
])
LPD3DVERTEXBUFFERDESC = Pointer(D3DVERTEXBUFFERDESC)

D3DVBCAPS = Flags(DWORD, [
    "D3DVBCAPS_SYSTEMMEMORY",
    "D3DVBCAPS_WRITEONLY",
    "D3DVBCAPS_OPTIMIZED",
    "D3DVBCAPS_DONOTCLIP",
])

D3DVOP = Flags(DWORD, [
    "D3DVOP_LIGHT",
    "D3DVOP_TRANSFORM",
    "D3DVOP_CLIP",
    "D3DVOP_EXTENTS",
])

D3DPV = Flags(DWORD, [
    "D3DPV_DONOTCOPYDATA",
])

D3DFVF = Flags(DWORD, [
    "D3DFVF_RESERVED0",
    "D3DFVF_XYZ",
    "D3DFVF_XYZRHW",
    "D3DFVF_XYZB1",
    "D3DFVF_XYZB2",
    "D3DFVF_XYZB3",
    "D3DFVF_XYZB4",
    "D3DFVF_XYZB5",
    "D3DFVF_NORMAL",
    "D3DFVF_RESERVED1",
    "D3DFVF_DIFFUSE",
    "D3DFVF_SPECULAR",
    #"D3DFVF_TEX0",
    #"D3DFVF_TEX1",
    #"D3DFVF_TEX2",
    #"D3DFVF_TEX3",
    #"D3DFVF_TEX4",
    #"D3DFVF_TEX5",
    #"D3DFVF_TEX6",
    #"D3DFVF_TEX7",
    #"D3DFVF_TEX8",
    "D3DFVF_RESERVED2",
    #"D3DFVF_TEXCOORDSIZE1(0)",
    #"D3DFVF_TEXCOORDSIZE2(0)",
    #"D3DFVF_TEXCOORDSIZE3(0)",
    #"D3DFVF_TEXCOORDSIZE4(0)",
    #"D3DFVF_TEXCOORDSIZE1(1)",
    #"D3DFVF_TEXCOORDSIZE2(1)",
    #"D3DFVF_TEXCOORDSIZE3(1)",
    #"D3DFVF_TEXCOORDSIZE4(1)",
    #"D3DFVF_TEXCOORDSIZE1(2)",
    #"D3DFVF_TEXCOORDSIZE2(2)",
    #"D3DFVF_TEXCOORDSIZE3(2)",
    #"D3DFVF_TEXCOORDSIZE4(2)",
    #"D3DFVF_TEXCOORDSIZE1(3)",
    #"D3DFVF_TEXCOORDSIZE2(3)",
    #"D3DFVF_TEXCOORDSIZE3(3)",
    #"D3DFVF_TEXCOORDSIZE4(3)",
])

D3DDP_PTRSTRIDE = Struct("D3DDP_PTRSTRIDE", [
    (LPVOID, "lpvData"),
    (DWORD, "dwStride"),
])

D3DDRAWPRIMITIVESTRIDEDDATA = Struct("D3DDRAWPRIMITIVESTRIDEDDATA", [
    (D3DDP_PTRSTRIDE, "position"),
    (D3DDP_PTRSTRIDE, "normal"),
    (D3DDP_PTRSTRIDE, "diffuse"),
    (D3DDP_PTRSTRIDE, "specular"),
    (Array(D3DDP_PTRSTRIDE, "D3DDP_MAXTEXCOORD"), "textureCoords"),
])
LPD3DDRAWPRIMITIVESTRIDEDDATA = Pointer(D3DDRAWPRIMITIVESTRIDEDDATA)

D3DVIS = Flags(DWORD, [
    "D3DVIS_INSIDE_FRUSTUM",
    "D3DVIS_INTERSECT_FRUSTUM",
    "D3DVIS_OUTSIDE_FRUSTUM",
    "D3DVIS_INSIDE_LEFT",
    "D3DVIS_INTERSECT_LEFT",
    "D3DVIS_OUTSIDE_LEFT",
    "D3DVIS_INSIDE_RIGHT",
    "D3DVIS_INTERSECT_RIGHT",
    "D3DVIS_OUTSIDE_RIGHT",
    "D3DVIS_INSIDE_TOP",
    "D3DVIS_INTERSECT_TOP",
    "D3DVIS_OUTSIDE_TOP",
    "D3DVIS_INSIDE_BOTTOM",
    "D3DVIS_INTERSECT_BOTTOM",
    "D3DVIS_OUTSIDE_BOTTOM",
    "D3DVIS_INSIDE_NEAR",
    "D3DVIS_INTERSECT_NEAR",
    "D3DVIS_OUTSIDE_NEAR",
    "D3DVIS_INSIDE_FAR",
    "D3DVIS_INTERSECT_FAR",
    "D3DVIS_OUTSIDE_FAR",
    "D3DVIS_MASK_FRUSTUM",
    "D3DVIS_MASK_LEFT",
    "D3DVIS_MASK_RIGHT",
    "D3DVIS_MASK_TOP",
    "D3DVIS_MASK_BOTTOM",
    "D3DVIS_MASK_NEAR",
    "D3DVIS_MASK_FAR",
])

D3DDEVINFOID = Flags(DWORD, [
    "D3DDEVINFOID_TEXTUREMANAGER",
    "D3DDEVINFOID_D3DTEXTUREMANAGER",
    "D3DDEVINFOID_TEXTURING",
])

D3DSTATEBLOCKTYPE = Enum("D3DSTATEBLOCKTYPE", [
    "D3DSBT_ALL",
    "D3DSBT_PIXELSTATE",
    "D3DSBT_VERTEXSTATE",
])

D3DVERTEXBLENDFLAGS = Enum("D3DVERTEXBLENDFLAGS", [
    "D3DVBLEND_DISABLE",
    "D3DVBLEND_1WEIGHT",
    "D3DVBLEND_2WEIGHTS",
    "D3DVBLEND_3WEIGHTS",
])

D3DTEXTURETRANSFORMFLAGS = Enum("D3DTEXTURETRANSFORMFLAGS", [
    "D3DTTFF_DISABLE",
    "D3DTTFF_COUNT1",
    "D3DTTFF_COUNT2",
    "D3DTTFF_COUNT3",
    "D3DTTFF_COUNT4",
    "D3DTTFF_PROJECTED",
])

########NEW FILE########
__FILENAME__ = dcommon
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from winapi import *


DWRITE_MEASURING_MODE = Enum("DWRITE_MEASURING_MODE", [
    "DWRITE_MEASURING_MODE_NATURAL",
    "DWRITE_MEASURING_MODE_GDI_CLASSIC",
    "DWRITE_MEASURING_MODE_GDI_NATURAL",
])

########NEW FILE########
__FILENAME__ = ddraw
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""ddraw.h"""

from winapi import *

DirectDrawOptSurfaceDescFlags = Flags(DWORD, [
    "DDOSD_GUID",
    "DDOSD_COMPRESSION_RATIO",
    "DDOSD_SCAPS",
    "DDOSD_OSCAPS",
    "DDOSD_ALL",
])

DirectDrawOptSurfaceDescCapsFlags = Flags(DWORD, [
    "DDOSDCAPS_OPTCOMPRESSED",
    "DDOSDCAPS_OPTREORDERED",
    "DDOSDCAPS_MONOLITHICMIPMAP",
])

DirectDrawGetDeviceIdentifierFlags = Flags(DWORD, [
    "DDGDI_GETHOSTIDENTIFIER",
])

IDirectDraw = Interface("IDirectDraw", IUnknown)
IDirectDraw2 = Interface("IDirectDraw2", IUnknown)
IDirectDraw4 = Interface("IDirectDraw4", IUnknown)
IDirectDraw7 = Interface("IDirectDraw7", IUnknown)
IDirectDrawPalette = Interface("IDirectDrawPalette", IUnknown)
IDirectDrawClipper = Interface("IDirectDrawClipper", IUnknown)
IDirectDrawSurface = Interface("IDirectDrawSurface", IUnknown)
IDirectDrawSurface2 = Interface("IDirectDrawSurface2", IUnknown)
IDirectDrawSurface3 = Interface("IDirectDrawSurface3", IUnknown)
IDirectDrawSurface4 = Interface("IDirectDrawSurface4", IUnknown)
IDirectDrawSurface7 = Interface("IDirectDrawSurface7", IUnknown)
IDirectDrawColorControl = Interface("IDirectDrawColorControl", IUnknown)
IDirectDrawGammaControl = Interface("IDirectDrawGammaControl", IUnknown)

LPUNKNOWN = ObjPointer(IUnknown)
LPDIRECTDRAW = ObjPointer(IDirectDraw)
LPDIRECTDRAW2 = ObjPointer(IDirectDraw2)
LPDIRECTDRAW4 = ObjPointer(IDirectDraw4)
LPDIRECTDRAW7 = ObjPointer(IDirectDraw7)
LPDIRECTDRAWSURFACE = ObjPointer(IDirectDrawSurface)
LPDIRECTDRAWSURFACE2 = ObjPointer(IDirectDrawSurface2)
LPDIRECTDRAWSURFACE3 = ObjPointer(IDirectDrawSurface3)
LPDIRECTDRAWSURFACE4 = ObjPointer(IDirectDrawSurface4)
LPDIRECTDRAWSURFACE7 = ObjPointer(IDirectDrawSurface7)
LPDIRECTDRAWPALETTE = ObjPointer(IDirectDrawPalette)
LPDIRECTDRAWCLIPPER = ObjPointer(IDirectDrawClipper)
LPDIRECTDRAWCOLORCONTROL = ObjPointer(IDirectDrawColorControl)
LPDIRECTDRAWGAMMACONTROL = ObjPointer(IDirectDrawGammaControl)

DDARGB = Struct("DDARGB", [
    (BYTE, "blue"),
    (BYTE, "green"),
    (BYTE, "red"),
    (BYTE, "alpha"),
])

LPDDARGB = Pointer(DDARGB)

DDRGBA = Struct("DDRGBA", [
    (BYTE, "red"),
    (BYTE, "green"),
    (BYTE, "blue"),
    (BYTE, "alpha"),
])
LPDDRGBA = Pointer(DDRGBA)

DDCOLORKEY = Struct("DDCOLORKEY", [
    (DWORD, "dwColorSpaceLowValue"),
    (DWORD, "dwColorSpaceHighValue"),
])
LPDDCOLORKEY = Pointer(DDCOLORKEY)

DDBLTFX = Struct("DDBLTFX", [
    (DWORD, "dwSize"),
    (DWORD, "dwDDFX"),
    (DWORD, "dwROP"),
    (DWORD, "dwDDROP"),
    (DWORD, "dwRotationAngle"),
    (DWORD, "dwZBufferOpCode"),
    (DWORD, "dwZBufferLow"),
    (DWORD, "dwZBufferHigh"),
    (DWORD, "dwZBufferBaseDest"),
    (DWORD, "dwZDestConstBitDepth"),
    (DWORD, "dwZDestConst"),
    (LPDIRECTDRAWSURFACE, "lpDDSZBufferDest"),
    (DWORD, "dwZSrcConstBitDepth"),
    (DWORD, "dwZSrcConst"),
    (LPDIRECTDRAWSURFACE, "lpDDSZBufferSrc"),
    (DWORD, "dwAlphaEdgeBlendBitDepth"),
    (DWORD, "dwAlphaEdgeBlend"),
    (DWORD, "dwReserved"),
    (DWORD, "dwAlphaDestConstBitDepth"),
    (DWORD, "dwAlphaDestConst"),
    (LPDIRECTDRAWSURFACE, "lpDDSAlphaDest"),
    (DWORD, "dwAlphaSrcConstBitDepth"),
    (DWORD, "dwAlphaSrcConst"),
    (LPDIRECTDRAWSURFACE, "lpDDSAlphaSrc"),
    (DWORD, "dwFillColor"),
    (DWORD, "dwFillDepth"),
    (DWORD, "dwFillPixel"),
    (LPDIRECTDRAWSURFACE, "lpDDSPattern"),
    (DDCOLORKEY, "ddckDestColorkey"),
    (DDCOLORKEY, "ddckSrcColorkey"),
])
LPDDBLTFX = Pointer(DDBLTFX)

DDSCAPS = Struct("DDSCAPS", [
    (DWORD, "dwCaps"),
])
LPDDSCAPS = Pointer(DDSCAPS)

DDOSCAPS = Struct("DDOSCAPS", [
    (DWORD, "dwCaps"),
])
LPDDOSCAPS = Pointer(DDOSCAPS)

DDSCAPSEX = Struct("DDSCAPSEX", [
    (DWORD, "dwCaps2"),
    (DWORD, "dwCaps3"),
    (DWORD, "dwCaps4"),
])

DDSCAPS2 = Struct("DDSCAPS2", [
    (DWORD, "dwCaps"),
    (DWORD, "dwCaps2"),
    (DWORD, "dwCaps3"),
    (DWORD, "dwCaps4"),
])
LPDDSCAPS2 = Pointer(DDSCAPS2)

DDCAPS_DX1 = Struct("DDCAPS_DX1", [
    (DWORD, "dwSize"),
    (DWORD, "dwCaps"),
    (DWORD, "dwCaps2"),
    (DWORD, "dwCKeyCaps"),
    (DWORD, "dwFXCaps"),
    (DWORD, "dwFXAlphaCaps"),
    (DWORD, "dwPalCaps"),
    (DWORD, "dwSVCaps"),
    (DWORD, "dwAlphaBltConstBitDepths"),
    (DWORD, "dwAlphaBltPixelBitDepths"),
    (DWORD, "dwAlphaBltSurfaceBitDepths"),
    (DWORD, "dwAlphaOverlayConstBitDepths"),
    (DWORD, "dwAlphaOverlayPixelBitDepths"),
    (DWORD, "dwAlphaOverlaySurfaceBitDepths"),
    (DWORD, "dwZBufferBitDepths"),
    (DWORD, "dwVidMemTotal"),
    (DWORD, "dwVidMemFree"),
    (DWORD, "dwMaxVisibleOverlays"),
    (DWORD, "dwCurrVisibleOverlays"),
    (DWORD, "dwNumFourCCCodes"),
    (DWORD, "dwAlignBoundarySrc"),
    (DWORD, "dwAlignSizeSrc"),
    (DWORD, "dwAlignBoundaryDest"),
    (DWORD, "dwAlignSizeDest"),
    (DWORD, "dwAlignStrideAlign"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwRops"),
    (DDSCAPS, "ddsCaps"),
    (DWORD, "dwMinOverlayStretch"),
    (DWORD, "dwMaxOverlayStretch"),
    (DWORD, "dwMinLiveVideoStretch"),
    (DWORD, "dwMaxLiveVideoStretch"),
    (DWORD, "dwMinHwCodecStretch"),
    (DWORD, "dwMaxHwCodecStretch"),
    (DWORD, "dwReserved1"),
    (DWORD, "dwReserved2"),
    (DWORD, "dwReserved3"),
])
LPDDCAPS_DX1 = Pointer(DDCAPS_DX1)

DDCAPS_DX3 = Struct("DDCAPS_DX3", [
    (DWORD, "dwSize"),
    (DWORD, "dwCaps"),
    (DWORD, "dwCaps2"),
    (DWORD, "dwCKeyCaps"),
    (DWORD, "dwFXCaps"),
    (DWORD, "dwFXAlphaCaps"),
    (DWORD, "dwPalCaps"),
    (DWORD, "dwSVCaps"),
    (DWORD, "dwAlphaBltConstBitDepths"),
    (DWORD, "dwAlphaBltPixelBitDepths"),
    (DWORD, "dwAlphaBltSurfaceBitDepths"),
    (DWORD, "dwAlphaOverlayConstBitDepths"),
    (DWORD, "dwAlphaOverlayPixelBitDepths"),
    (DWORD, "dwAlphaOverlaySurfaceBitDepths"),
    (DWORD, "dwZBufferBitDepths"),
    (DWORD, "dwVidMemTotal"),
    (DWORD, "dwVidMemFree"),
    (DWORD, "dwMaxVisibleOverlays"),
    (DWORD, "dwCurrVisibleOverlays"),
    (DWORD, "dwNumFourCCCodes"),
    (DWORD, "dwAlignBoundarySrc"),
    (DWORD, "dwAlignSizeSrc"),
    (DWORD, "dwAlignBoundaryDest"),
    (DWORD, "dwAlignSizeDest"),
    (DWORD, "dwAlignStrideAlign"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwRops"),
    (DDSCAPS, "ddsCaps"),
    (DWORD, "dwMinOverlayStretch"),
    (DWORD, "dwMaxOverlayStretch"),
    (DWORD, "dwMinLiveVideoStretch"),
    (DWORD, "dwMaxLiveVideoStretch"),
    (DWORD, "dwMinHwCodecStretch"),
    (DWORD, "dwMaxHwCodecStretch"),
    (DWORD, "dwReserved1"),
    (DWORD, "dwReserved2"),
    (DWORD, "dwReserved3"),
    (DWORD, "dwSVBCaps"),
    (DWORD, "dwSVBCKeyCaps"),
    (DWORD, "dwSVBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwSVBRops"),
    (DWORD, "dwVSBCaps"),
    (DWORD, "dwVSBCKeyCaps"),
    (DWORD, "dwVSBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwVSBRops"),
    (DWORD, "dwSSBCaps"),
    (DWORD, "dwSSBCKeyCaps"),
    (DWORD, "dwSSBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwSSBRops"),
    (DWORD, "dwReserved4"),
    (DWORD, "dwReserved5"),
    (DWORD, "dwReserved6"),
])
LPDDCAPS_DX3 = Pointer(DDCAPS_DX3)

DDCAPS_DX5 = Struct("DDCAPS_DX5", [
    (DWORD, "dwSize"),
    (DWORD, "dwCaps"),
    (DWORD, "dwCaps2"),
    (DWORD, "dwCKeyCaps"),
    (DWORD, "dwFXCaps"),
    (DWORD, "dwFXAlphaCaps"),
    (DWORD, "dwPalCaps"),
    (DWORD, "dwSVCaps"),
    (DWORD, "dwAlphaBltConstBitDepths"),
    (DWORD, "dwAlphaBltPixelBitDepths"),
    (DWORD, "dwAlphaBltSurfaceBitDepths"),
    (DWORD, "dwAlphaOverlayConstBitDepths"),
    (DWORD, "dwAlphaOverlayPixelBitDepths"),
    (DWORD, "dwAlphaOverlaySurfaceBitDepths"),
    (DWORD, "dwZBufferBitDepths"),
    (DWORD, "dwVidMemTotal"),
    (DWORD, "dwVidMemFree"),
    (DWORD, "dwMaxVisibleOverlays"),
    (DWORD, "dwCurrVisibleOverlays"),
    (DWORD, "dwNumFourCCCodes"),
    (DWORD, "dwAlignBoundarySrc"),
    (DWORD, "dwAlignSizeSrc"),
    (DWORD, "dwAlignBoundaryDest"),
    (DWORD, "dwAlignSizeDest"),
    (DWORD, "dwAlignStrideAlign"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwRops"),
    (DDSCAPS, "ddsCaps"),
    (DWORD, "dwMinOverlayStretch"),
    (DWORD, "dwMaxOverlayStretch"),
    (DWORD, "dwMinLiveVideoStretch"),
    (DWORD, "dwMaxLiveVideoStretch"),
    (DWORD, "dwMinHwCodecStretch"),
    (DWORD, "dwMaxHwCodecStretch"),
    (DWORD, "dwReserved1"),
    (DWORD, "dwReserved2"),
    (DWORD, "dwReserved3"),
    (DWORD, "dwSVBCaps"),
    (DWORD, "dwSVBCKeyCaps"),
    (DWORD, "dwSVBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwSVBRops"),
    (DWORD, "dwVSBCaps"),
    (DWORD, "dwVSBCKeyCaps"),
    (DWORD, "dwVSBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwVSBRops"),
    (DWORD, "dwSSBCaps"),
    (DWORD, "dwSSBCKeyCaps"),
    (DWORD, "dwSSBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwSSBRops"),
    (DWORD, "dwMaxVideoPorts"),
    (DWORD, "dwCurrVideoPorts"),
    (DWORD, "dwSVBCaps2"),
    (DWORD, "dwNLVBCaps"),
    (DWORD, "dwNLVBCaps2"),
    (DWORD, "dwNLVBCKeyCaps"),
    (DWORD, "dwNLVBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwNLVBRops"),
])
LPDDCAPS_DX5 = Pointer(DDCAPS_DX5)

DDCAPS_DX6 = Struct("DDCAPS_DX6", [
    (DWORD, "dwSize"),
    (DWORD, "dwCaps"),
    (DWORD, "dwCaps2"),
    (DWORD, "dwCKeyCaps"),
    (DWORD, "dwFXCaps"),
    (DWORD, "dwFXAlphaCaps"),
    (DWORD, "dwPalCaps"),
    (DWORD, "dwSVCaps"),
    (DWORD, "dwAlphaBltConstBitDepths"),
    (DWORD, "dwAlphaBltPixelBitDepths"),
    (DWORD, "dwAlphaBltSurfaceBitDepths"),
    (DWORD, "dwAlphaOverlayConstBitDepths"),
    (DWORD, "dwAlphaOverlayPixelBitDepths"),
    (DWORD, "dwAlphaOverlaySurfaceBitDepths"),
    (DWORD, "dwZBufferBitDepths"),
    (DWORD, "dwVidMemTotal"),
    (DWORD, "dwVidMemFree"),
    (DWORD, "dwMaxVisibleOverlays"),
    (DWORD, "dwCurrVisibleOverlays"),
    (DWORD, "dwNumFourCCCodes"),
    (DWORD, "dwAlignBoundarySrc"),
    (DWORD, "dwAlignSizeSrc"),
    (DWORD, "dwAlignBoundaryDest"),
    (DWORD, "dwAlignSizeDest"),
    (DWORD, "dwAlignStrideAlign"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwRops"),
    (DDSCAPS, "ddsOldCaps"),
    (DWORD, "dwMinOverlayStretch"),
    (DWORD, "dwMaxOverlayStretch"),
    (DWORD, "dwMinLiveVideoStretch"),
    (DWORD, "dwMaxLiveVideoStretch"),
    (DWORD, "dwMinHwCodecStretch"),
    (DWORD, "dwMaxHwCodecStretch"),
    (DWORD, "dwReserved1"),
    (DWORD, "dwReserved2"),
    (DWORD, "dwReserved3"),
    (DWORD, "dwSVBCaps"),
    (DWORD, "dwSVBCKeyCaps"),
    (DWORD, "dwSVBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwSVBRops"),
    (DWORD, "dwVSBCaps"),
    (DWORD, "dwVSBCKeyCaps"),
    (DWORD, "dwVSBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwVSBRops"),
    (DWORD, "dwSSBCaps"),
    (DWORD, "dwSSBCKeyCaps"),
    (DWORD, "dwSSBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwSSBRops"),
    (DWORD, "dwMaxVideoPorts"),
    (DWORD, "dwCurrVideoPorts"),
    (DWORD, "dwSVBCaps2"),
    (DWORD, "dwNLVBCaps"),
    (DWORD, "dwNLVBCaps2"),
    (DWORD, "dwNLVBCKeyCaps"),
    (DWORD, "dwNLVBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwNLVBRops"),
    (DDSCAPS2, "ddsCaps"),
])
LPDDCAPS_DX6 = Pointer(DDCAPS_DX6)

DDCAPS_DX7 = Struct("DDCAPS_DX7", [
    (DWORD, "dwSize"),
    (DWORD, "dwCaps"),
    (DWORD, "dwCaps2"),
    (DWORD, "dwCKeyCaps"),
    (DWORD, "dwFXCaps"),
    (DWORD, "dwFXAlphaCaps"),
    (DWORD, "dwPalCaps"),
    (DWORD, "dwSVCaps"),
    (DWORD, "dwAlphaBltConstBitDepths"),
    (DWORD, "dwAlphaBltPixelBitDepths"),
    (DWORD, "dwAlphaBltSurfaceBitDepths"),
    (DWORD, "dwAlphaOverlayConstBitDepths"),
    (DWORD, "dwAlphaOverlayPixelBitDepths"),
    (DWORD, "dwAlphaOverlaySurfaceBitDepths"),
    (DWORD, "dwZBufferBitDepths"),
    (DWORD, "dwVidMemTotal"),
    (DWORD, "dwVidMemFree"),
    (DWORD, "dwMaxVisibleOverlays"),
    (DWORD, "dwCurrVisibleOverlays"),
    (DWORD, "dwNumFourCCCodes"),
    (DWORD, "dwAlignBoundarySrc"),
    (DWORD, "dwAlignSizeSrc"),
    (DWORD, "dwAlignBoundaryDest"),
    (DWORD, "dwAlignSizeDest"),
    (DWORD, "dwAlignStrideAlign"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwRops"),
    (DDSCAPS, "ddsOldCaps"),
    (DWORD, "dwMinOverlayStretch"),
    (DWORD, "dwMaxOverlayStretch"),
    (DWORD, "dwMinLiveVideoStretch"),
    (DWORD, "dwMaxLiveVideoStretch"),
    (DWORD, "dwMinHwCodecStretch"),
    (DWORD, "dwMaxHwCodecStretch"),
    (DWORD, "dwReserved1"),
    (DWORD, "dwReserved2"),
    (DWORD, "dwReserved3"),
    (DWORD, "dwSVBCaps"),
    (DWORD, "dwSVBCKeyCaps"),
    (DWORD, "dwSVBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwSVBRops"),
    (DWORD, "dwVSBCaps"),
    (DWORD, "dwVSBCKeyCaps"),
    (DWORD, "dwVSBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwVSBRops"),
    (DWORD, "dwSSBCaps"),
    (DWORD, "dwSSBCKeyCaps"),
    (DWORD, "dwSSBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwSSBRops"),
    (DWORD, "dwMaxVideoPorts"),
    (DWORD, "dwCurrVideoPorts"),
    (DWORD, "dwSVBCaps2"),
    (DWORD, "dwNLVBCaps"),
    (DWORD, "dwNLVBCaps2"),
    (DWORD, "dwNLVBCKeyCaps"),
    (DWORD, "dwNLVBFXCaps"),
    (Array(DWORD, "DD_ROP_SPACE"), "dwNLVBRops"),
    (DDSCAPS2, "ddsCaps"),
])
LPDDCAPS_DX7 = Pointer(DDCAPS_DX7)
DDCAPS = DDCAPS_DX7
LPDDCAPS = Pointer(DDCAPS)

DDPIXELFORMAT = Struct("DDPIXELFORMAT", [
    (DWORD, "dwSize"),
    (DWORD, "dwFlags"),
    (DWORD, "dwFourCC"),
    (DWORD, "dwRGBBitCount"),
    (DWORD, "dwYUVBitCount"),
    (DWORD, "dwZBufferBitDepth"),
    (DWORD, "dwAlphaBitDepth"),
    (DWORD, "dwLuminanceBitCount"),
    (DWORD, "dwBumpBitCount"),
    (DWORD, "dwPrivateFormatBitCount"),
    (DWORD, "dwRBitMask"),
    (DWORD, "dwYBitMask"),
    (DWORD, "dwStencilBitDepth"),
    (DWORD, "dwLuminanceBitMask"),
    (DWORD, "dwBumpDuBitMask"),
    (DWORD, "dwOperations"),
    (DWORD, "dwGBitMask"),
    (DWORD, "dwUBitMask"),
    (DWORD, "dwZBitMask"),
    (DWORD, "dwBumpDvBitMask"),
    (Struct(None, [
        (WORD, "wFlipMSTypes"),
        (WORD, "wBltMSTypes"),
    ]), "MultiSampleCaps"),
    (DWORD, "dwBBitMask"),
    (DWORD, "dwVBitMask"),
    (DWORD, "dwStencilBitMask"),
    (DWORD, "dwBumpLuminanceBitMask"),
    (DWORD, "dwRGBAlphaBitMask"),
    (DWORD, "dwYUVAlphaBitMask"),
    (DWORD, "dwLuminanceAlphaBitMask"),
    (DWORD, "dwRGBZBitMask"),
    (DWORD, "dwYUVZBitMask"),
])
LPDDPIXELFORMAT = Pointer(DDPIXELFORMAT)

DDOVERLAYFX = Struct("DDOVERLAYFX", [
    (DWORD, "dwSize"),
    (DWORD, "dwAlphaEdgeBlendBitDepth"),
    (DWORD, "dwAlphaEdgeBlend"),
    (DWORD, "dwReserved"),
    (DWORD, "dwAlphaDestConstBitDepth"),
    (DWORD, "dwAlphaDestConst"),
    (LPDIRECTDRAWSURFACE, "lpDDSAlphaDest"),
    (DWORD, "dwAlphaSrcConstBitDepth"),
    (DWORD, "dwAlphaSrcConst"),
    (LPDIRECTDRAWSURFACE, "lpDDSAlphaSrc"),
    (DDCOLORKEY, "dckDestColorkey"),
    (DDCOLORKEY, "dckSrcColorkey"),
    (DWORD, "dwDDFX"),
    (DWORD, "dwFlags"),
])
LPDDOVERLAYFX = Pointer(DDOVERLAYFX)

DDBLTBATCH = Struct("DDBLTBATCH", [
    (LPRECT, "lprDest"),
    (LPDIRECTDRAWSURFACE, "lpDDSSrc"),
    (LPRECT, "lprSrc"),
    (DWORD, "dwFlags"),
    (LPDDBLTFX, "lpDDBltFx"),
])
LPDDBLTBATCH = Pointer(DDBLTBATCH)

DDGAMMARAMP = Struct("DDGAMMARAMP", [
    (Array(WORD, 256), "red"),
    (Array(WORD, 256), "green"),
    (Array(WORD, 256), "blue"),
])
LPDDGAMMARAMP = Pointer(DDGAMMARAMP)

DDDEVICEIDENTIFIER = Struct("DDDEVICEIDENTIFIER", [
    (CString, "szDriver"),
    (CString, "szDescription"),
    (LARGE_INTEGER, "liDriverVersion"),
    (DWORD, "dwVendorId"),
    (DWORD, "dwDeviceId"),
    (DWORD, "dwSubSysId"),
    (DWORD, "dwRevision"),
    (GUID, "guidDeviceIdentifier"),
])
LPDDDEVICEIDENTIFIER = Pointer(DDDEVICEIDENTIFIER)

DDDEVICEIDENTIFIER2 = Struct("DDDEVICEIDENTIFIER2", [
    (CString, "szDriver"),
    (CString, "szDescription"),
    (LARGE_INTEGER, "liDriverVersion"),
    (DWORD, "dwVendorId"),
    (DWORD, "dwDeviceId"),
    (DWORD, "dwSubSysId"),
    (DWORD, "dwRevision"),
    (GUID, "guidDeviceIdentifier"),
    (DWORD, "dwWHQLLevel"),
])
LPDDDEVICEIDENTIFIER2 = Pointer(DDDEVICEIDENTIFIER2)

LPCLIPPERCALLBACK = FunctionPointer(DWORD, "LPCLIPPERCALLBACK", [(LPDIRECTDRAWCLIPPER, "lpDDClipper"), (HWND, "hWnd"), (DWORD, "code"), (LPVOID, "lpContext")])
LPSURFACESTREAMINGCALLBACK = FunctionPointer(DWORD, "LPSURFACESTREAMINGCALLBACK", [DWORD])

DDSURFACEDESC = Struct("DDSURFACEDESC", [
    (DWORD, "dwSize"),
    (DWORD, "dwFlags"),
    (DWORD, "dwHeight"),
    (DWORD, "dwWidth"),
    (LONG, "lPitch"),
    (DWORD, "dwLinearSize"),
    (DWORD, "dwBackBufferCount"),
    (DWORD, "dwMipMapCount"),
    (DWORD, "dwZBufferBitDepth"),
    (DWORD, "dwRefreshRate"),
    (DWORD, "dwAlphaBitDepth"),
    (DWORD, "dwReserved"),
    (LPVOID, "lpSurface"),
    (DDCOLORKEY, "ddckCKDestOverlay"),
    (DDCOLORKEY, "ddckCKDestBlt"),
    (DDCOLORKEY, "ddckCKSrcOverlay"),
    (DDCOLORKEY, "ddckCKSrcBlt"),
    (DDPIXELFORMAT, "ddpfPixelFormat"),
    (DDSCAPS, "ddsCaps"),
])
LPDDSURFACEDESC = Pointer(DDSURFACEDESC)

DDSURFACEDESC2 = Struct("DDSURFACEDESC2", [
    (DWORD, "dwSize"),
    (DWORD, "dwFlags"),
    (DWORD, "dwHeight"),
    (DWORD, "dwWidth"),
    (LONG, "lPitch"),
    (DWORD, "dwLinearSize"),
    (DWORD, "dwBackBufferCount"),
    (DWORD, "dwDepth"),
    (DWORD, "dwMipMapCount"),
    (DWORD, "dwRefreshRate"),
    (DWORD, "dwSrcVBHandle"),
    (DWORD, "dwAlphaBitDepth"),
    (DWORD, "dwReserved"),
    (LPVOID, "lpSurface"),
    (DDCOLORKEY, "ddckCKDestOverlay"),
    (DWORD, "dwEmptyFaceColor"),
    (DDCOLORKEY, "ddckCKDestBlt"),
    (DDCOLORKEY, "ddckCKSrcOverlay"),
    (DDCOLORKEY, "ddckCKSrcBlt"),
    (DDPIXELFORMAT, "ddpfPixelFormat"),
    (DWORD, "dwFVF"),
    (DDSCAPS2, "ddsCaps"),
    (DWORD, "dwTextureStage"),
])
LPDDSURFACEDESC2 = Pointer(DDSURFACEDESC2)

DirectDrawSurfaceDescFlags = Flags(DWORD, [
    "DDSD_CAPS",
    "DDSD_HEIGHT",
    "DDSD_WIDTH",
    "DDSD_PITCH",
    "DDSD_BACKBUFFERCOUNT",
    "DDSD_ZBUFFERBITDEPTH",
    "DDSD_ALPHABITDEPTH",
    "DDSD_LPSURFACE",
    "DDSD_PIXELFORMAT",
    "DDSD_CKDESTOVERLAY",
    "DDSD_CKDESTBLT",
    "DDSD_CKSRCOVERLAY",
    "DDSD_CKSRCBLT",
    "DDSD_MIPMAPCOUNT",
    "DDSD_REFRESHRATE",
    "DDSD_LINEARSIZE",
    "DDSD_TEXTURESTAGE",
    "DDSD_FVF",
    "DDSD_SRCVBHANDLE",
    "DDSD_DEPTH",
    "DDSD_ALL",
])

DDOPTSURFACEDESC = Struct("DDOPTSURFACEDESC", [
    (DWORD, "dwSize"),
    (DWORD, "dwFlags"),
    (DDSCAPS2, "ddSCaps"),
    (DDOSCAPS, "ddOSCaps"),
    (GUID, "guid"),
    (DWORD, "dwCompressionRatio"),
])

DDSD = Flags(DWORD, [
    "DDOSD_GUID",
    "DDOSD_COMPRESSION_RATIO",
    "DDOSD_SCAPS",
    "DDOSD_OSCAPS",
    "DDOSD_ALL",
])

DDOSDCAPS = Flags(DWORD, [
    "DDOSDCAPS_OPTCOMPRESSED",
    "DDOSDCAPS_OPTREORDERED",
    "DDOSDCAPS_MONOLITHICMIPMAP",
    "DDOSDCAPS_VALIDSCAPS",
    "DDOSDCAPS_VALIDOSCAPS",
])

DDCOLORCONTROL = Struct("DDCOLORCONTROL", [
    (DWORD, "dwSize"),
    (DWORD, "dwFlags"),
    (LONG, "lBrightness"),
    (LONG, "lContrast"),
    (LONG, "lHue"),
    (LONG, "lSaturation"),
    (LONG, "lSharpness"),
    (LONG, "lGamma"),
    (LONG, "lColorEnable"),
    (DWORD, "dwReserved1"),
])
LPDDCOLORCONTROL = Pointer(DDCOLORCONTROL)

DirectDrawEnumerateExFlags = Flags(DWORD, [
    "DDENUM_ATTACHEDSECONDARYDEVICES",
    "DDENUM_DETACHEDSECONDARYDEVICES",
    "DDENUM_NONDISPLAYDEVICES",
])

DirectDrawCreateFlags = FakeEnum(DWORD, [
    "DDCREATE_HARDWAREONLY",
    "DDCREATE_EMULATIONONLY",
])

DirectDrawColorControlFlags = Flags(DWORD, [
    "DDCOLOR_BRIGHTNESS",
    "DDCOLOR_CONTRAST",
    "DDCOLOR_HUE",
    "DDCOLOR_SATURATION",
    "DDCOLOR_SHARPNESS",
    "DDCOLOR_GAMMA",
    "DDCOLOR_COLORENABLE",
])

DirectDrawCapsFlags = Flags(DWORD, [
    "DDSCAPS_RESERVED1",
    "DDSCAPS_ALPHA",
    "DDSCAPS_BACKBUFFER",
    "DDSCAPS_COMPLEX",
    "DDSCAPS_FLIP",
    "DDSCAPS_FRONTBUFFER",
    "DDSCAPS_OFFSCREENPLAIN",
    "DDSCAPS_OVERLAY",
    "DDSCAPS_PALETTE",
    "DDSCAPS_PRIMARYSURFACE",
    "DDSCAPS_RESERVED3",
    "DDSCAPS_PRIMARYSURFACELEFT",
    "DDSCAPS_SYSTEMMEMORY",
    "DDSCAPS_TEXTURE",
    "DDSCAPS_3DDEVICE",
    "DDSCAPS_VIDEOMEMORY",
    "DDSCAPS_VISIBLE",
    "DDSCAPS_WRITEONLY",
    "DDSCAPS_ZBUFFER",
    "DDSCAPS_OWNDC",
    "DDSCAPS_LIVEVIDEO",
    "DDSCAPS_HWCODEC",
    "DDSCAPS_MODEX",
    "DDSCAPS_MIPMAP",
    "DDSCAPS_RESERVED2",
    "DDSCAPS_ALLOCONLOAD",
    "DDSCAPS_VIDEOPORT",
    "DDSCAPS_LOCALVIDMEM",
    "DDSCAPS_NONLOCALVIDMEM",
    "DDSCAPS_STANDARDVGAMODE",
    "DDSCAPS_OPTIMIZED",
])

DirectDrawCapabilityFlags2 = Flags(DWORD, [
    "DDSCAPS2_RESERVED4",
    "DDSCAPS2_HARDWAREDEINTERLACE",
    "DDSCAPS2_HINTDYNAMIC",
    "DDSCAPS2_HINTSTATIC",
    "DDSCAPS2_TEXTUREMANAGE",
    "DDSCAPS2_RESERVED1",
    "DDSCAPS2_RESERVED2",
    "DDSCAPS2_OPAQUE",
    "DDSCAPS2_HINTANTIALIASING",
    "DDSCAPS2_CUBEMAP",
    "DDSCAPS2_CUBEMAP_ALLFACES",
    "DDSCAPS2_CUBEMAP_POSITIVEX",
    "DDSCAPS2_CUBEMAP_NEGATIVEX",
    "DDSCAPS2_CUBEMAP_POSITIVEY",
    "DDSCAPS2_CUBEMAP_NEGATIVEY",
    "DDSCAPS2_CUBEMAP_POSITIVEZ",
    "DDSCAPS2_CUBEMAP_NEGATIVEZ",
    "DDSCAPS2_MIPMAPSUBLEVEL",
    "DDSCAPS2_D3DTEXTUREMANAGE",
    "DDSCAPS2_DONOTPERSIST",
    "DDSCAPS2_STEREOSURFACELEFT",
    "DDSCAPS2_VOLUME",
    "DDSCAPS2_NOTUSERLOCKABLE",
    "DDSCAPS2_POINTS",
    "DDSCAPS2_RTPATCHES",
    "DDSCAPS2_NPATCHES",
    "DDSCAPS2_RESERVED3",
    "DDSCAPS2_DISCARDBACKBUFFER",
    "DDSCAPS2_ENABLEALPHACHANNEL",
    "DDSCAPS2_EXTENDEDFORMATPRIMARY",
    "DDSCAPS2_ADDITIONALPRIMARY",
])
DDSCAPS3 = Flags(DWORD, [
    "DDSCAPS3_MULTISAMPLE_MASK",
    "DDSCAPS3_MULTISAMPLE_QUALITY_MASK",
    "DDSCAPS3_MULTISAMPLE_QUALITY_SHIFT",
    "DDSCAPS3_RESERVED1",
    "DDSCAPS3_RESERVED2",
    "DDSCAPS3_LIGHTWEIGHTMIPMAP",
    "DDSCAPS3_AUTOGENMIPMAP",
    "DDSCAPS3_DMAP",
    "DDSCAPS3_CREATESHAREDRESOURCE",
    "DDSCAPS3_READONLYRESOURCE",
    "DDSCAPS3_OPENSHAREDRESOURCE",
])

DirectDrawDriverCapsFlags = Flags(DWORD, [
    "DDCAPS_3D",
    "DDCAPS_ALIGNBOUNDARYDEST",
    "DDCAPS_ALIGNSIZEDEST",
    "DDCAPS_ALIGNBOUNDARYSRC",
    "DDCAPS_ALIGNSIZESRC",
    "DDCAPS_ALIGNSTRIDE",
    "DDCAPS_BLT",
    "DDCAPS_BLTQUEUE",
    "DDCAPS_BLTFOURCC",
    "DDCAPS_BLTSTRETCH",
    "DDCAPS_GDI",
    "DDCAPS_OVERLAY",
    "DDCAPS_OVERLAYCANTCLIP",
    "DDCAPS_OVERLAYFOURCC",
    "DDCAPS_OVERLAYSTRETCH",
    "DDCAPS_PALETTE",
    "DDCAPS_PALETTEVSYNC",
    "DDCAPS_READSCANLINE",
    "DDCAPS_RESERVED1",
    "DDCAPS_VBI",
    "DDCAPS_ZBLTS",
    "DDCAPS_ZOVERLAYS",
    "DDCAPS_COLORKEY",
    "DDCAPS_ALPHA",
    "DDCAPS_COLORKEYHWASSIST",
    "DDCAPS_NOHARDWARE",
    "DDCAPS_BLTCOLORFILL",
    "DDCAPS_BANKSWITCHED",
    "DDCAPS_BLTDEPTHFILL",
    "DDCAPS_CANCLIP",
    "DDCAPS_CANCLIPSTRETCHED",
    "DDCAPS_CANBLTSYSMEM",
])

DirectDrawDriverCapsFlags2 = Flags(DWORD, [
    "DDCAPS2_CERTIFIED",
    "DDCAPS2_NO2DDURING3DSCENE",
    "DDCAPS2_VIDEOPORT",
    "DDCAPS2_AUTOFLIPOVERLAY",
    "DDCAPS2_CANBOBINTERLEAVED",
    "DDCAPS2_CANBOBNONINTERLEAVED",
    "DDCAPS2_COLORCONTROLOVERLAY",
    "DDCAPS2_COLORCONTROLPRIMARY",
    "DDCAPS2_CANDROPZ16BIT",
    "DDCAPS2_NONLOCALVIDMEM",
    "DDCAPS2_NONLOCALVIDMEMCAPS",
    "DDCAPS2_NOPAGELOCKREQUIRED",
    "DDCAPS2_WIDESURFACES",
    "DDCAPS2_CANFLIPODDEVEN",
    "DDCAPS2_CANBOBHARDWARE",
    "DDCAPS2_COPYFOURCC",
    "DDCAPS2_PRIMARYGAMMA",
    "DDCAPS2_CANRENDERWINDOWED",
    "DDCAPS2_CANCALIBRATEGAMMA",
    "DDCAPS2_FLIPINTERVAL",
    "DDCAPS2_FLIPNOVSYNC",
    "DDCAPS2_CANMANAGETEXTURE",
    "DDCAPS2_TEXMANINNONLOCALVIDMEM",
    "DDCAPS2_STEREO",
    "DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL",
    "DDCAPS2_RESERVED1",
    "DDCAPS2_CANMANAGERESOURCE",
    "DDCAPS2_DYNAMICTEXTURES",
    "DDCAPS2_CANAUTOGENMIPMAP",
    "DDCAPS2_CANSHARERESOURCE",
])

DirectDrawFxAlphaCapsFlags = Flags(DWORD, [
    "DDFXALPHACAPS_BLTALPHAEDGEBLEND",
    "DDFXALPHACAPS_BLTALPHAPIXELS",
    "DDFXALPHACAPS_BLTALPHAPIXELSNEG",
    "DDFXALPHACAPS_BLTALPHASURFACES",
    "DDFXALPHACAPS_BLTALPHASURFACESNEG",
    "DDFXALPHACAPS_OVERLAYALPHAEDGEBLEND",
    "DDFXALPHACAPS_OVERLAYALPHAPIXELS",
    "DDFXALPHACAPS_OVERLAYALPHAPIXELSNEG",
    "DDFXALPHACAPS_OVERLAYALPHASURFACES",
    "DDFXALPHACAPS_OVERLAYALPHASURFACESNEG",
])

DirectDrawFxCapsFlags = Flags(DWORD, [
    "DDFXCAPS_BLTARITHSTRETCHY",
    "DDFXCAPS_BLTARITHSTRETCHYN",
    "DDFXCAPS_BLTMIRRORLEFTRIGHT",
    "DDFXCAPS_BLTMIRRORUPDOWN",
    "DDFXCAPS_BLTROTATION",
    "DDFXCAPS_BLTROTATION90",
    "DDFXCAPS_BLTSHRINKX",
    "DDFXCAPS_BLTSHRINKXN",
    "DDFXCAPS_BLTSHRINKY",
    "DDFXCAPS_BLTSHRINKYN",
    "DDFXCAPS_BLTSTRETCHX",
    "DDFXCAPS_BLTSTRETCHXN",
    "DDFXCAPS_BLTSTRETCHY",
    "DDFXCAPS_BLTSTRETCHYN",
    "DDFXCAPS_OVERLAYARITHSTRETCHY",
    "DDFXCAPS_OVERLAYARITHSTRETCHYN",
    "DDFXCAPS_OVERLAYSHRINKX",
    "DDFXCAPS_OVERLAYSHRINKXN",
    "DDFXCAPS_OVERLAYSHRINKY",
    "DDFXCAPS_OVERLAYSHRINKYN",
    "DDFXCAPS_OVERLAYSTRETCHX",
    "DDFXCAPS_OVERLAYSTRETCHXN",
    "DDFXCAPS_OVERLAYSTRETCHY",
    "DDFXCAPS_OVERLAYSTRETCHYN",
    "DDFXCAPS_OVERLAYMIRRORLEFTRIGHT",
    "DDFXCAPS_OVERLAYMIRRORUPDOWN",
    "DDFXCAPS_OVERLAYDEINTERLACE",
    "DDFXCAPS_BLTALPHA",
    "DDFXCAPS_BLTFILTER",
    "DDFXCAPS_OVERLAYALPHA",
    "DDFXCAPS_OVERLAYFILTER",
])

DirectDrawStereoViewCapsFlags = Flags(DWORD, [
    "DDSVCAPS_RESERVED1",
    "DDSVCAPS_RESERVED2",
    "DDSVCAPS_RESERVED3",
    "DDSVCAPS_RESERVED4",
    "DDSVCAPS_STEREOSEQUENTIAL",
])

DirectDrawPaletteCapsFlags = Flags(DWORD, [
    "DDPCAPS_4BIT",
    "DDPCAPS_8BITENTRIES",
    "DDPCAPS_8BIT",
    "DDPCAPS_INITIALIZE",
    "DDPCAPS_PRIMARYSURFACE",
    "DDPCAPS_PRIMARYSURFACELEFT",
    "DDPCAPS_ALLOW256",
    "DDPCAPS_VSYNC",
    "DDPCAPS_1BIT",
    "DDPCAPS_2BIT",
    "DDPCAPS_ALPHA",
])

DirectDrawSurfaceSetPrivateDataConstants = FakeEnum(DWORD, [
    "DDSPD_IUNKNOWNPOINTER",
    "DDSPD_VOLATILE",
])

DirectDrawSurfaceSetPaletteConstants = FakeEnum(DWORD, [
    "DDBD_1",
    "DDBD_2",
    "DDBD_4",
    "DDBD_8",
    "DDBD_16",
    "DDBD_24",
    "DDBD_32",
])

DirectDrawSurfaceSetGetColorKeyFlags = Flags(DWORD, [
    "DDCKEY_COLORSPACE",
    "DDCKEY_DESTBLT",
    "DDCKEY_DESTOVERLAY",
    "DDCKEY_SRCBLT",
    "DDCKEY_SRCOVERLAY",
])

DirectDrawColorKeyCapsFlags = Flags(DWORD, [
    "DDCKEYCAPS_DESTBLT",
    "DDCKEYCAPS_DESTBLTCLRSPACE",
    "DDCKEYCAPS_DESTBLTCLRSPACEYUV",
    "DDCKEYCAPS_DESTBLTYUV",
    "DDCKEYCAPS_DESTOVERLAY",
    "DDCKEYCAPS_DESTOVERLAYCLRSPACE",
    "DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV",
    "DDCKEYCAPS_DESTOVERLAYONEACTIVE",
    "DDCKEYCAPS_DESTOVERLAYYUV",
    "DDCKEYCAPS_SRCBLT",
    "DDCKEYCAPS_SRCBLTCLRSPACE",
    "DDCKEYCAPS_SRCBLTCLRSPACEYUV",
    "DDCKEYCAPS_SRCBLTYUV",
    "DDCKEYCAPS_SRCOVERLAY",
    "DDCKEYCAPS_SRCOVERLAYCLRSPACE",
    "DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV",
    "DDCKEYCAPS_SRCOVERLAYONEACTIVE",
    "DDCKEYCAPS_SRCOVERLAYYUV",
    "DDCKEYCAPS_NOCOSTOVERLAY",
])

DirectDrawPixelFormatFlags = Flags(DWORD, [
    "DDPF_ALPHAPIXELS",
    "DDPF_ALPHA",
    "DDPF_FOURCC",
    "DDPF_PALETTEINDEXED4",
    "DDPF_PALETTEINDEXEDTO8",
    "DDPF_PALETTEINDEXED8",
    "DDPF_RGB",
    "DDPF_COMPRESSED",
    "DDPF_RGBTOYUV",
    "DDPF_YUV",
    "DDPF_ZBUFFER",
    "DDPF_PALETTEINDEXED1",
    "DDPF_PALETTEINDEXED2",
    "DDPF_ZPIXELS",
    "DDPF_STENCILBUFFER",
    "DDPF_ALPHAPREMULT",
    "DDPF_LUMINANCE",
    "DDPF_BUMPLUMINANCE",
    "DDPF_BUMPDUDV",
])

DirectDrawEnumSurfacesFlags = Flags(DWORD, [
    "DDENUMSURFACES_ALL",
    "DDENUMSURFACES_MATCH",
    "DDENUMSURFACES_NOMATCH",
    "DDENUMSURFACES_CANBECREATED",
    "DDENUMSURFACES_DOESEXIST",
])

DirectDrawSetDisplayModeFlags = Flags(DWORD, [
    "DDSDM_STANDARDVGAMODE",
])

DirectDrawEnumDisplayModesFlags = Flags(DWORD, [
    "DDEDM_REFRESHRATES",
    "DDEDM_STANDARDVGAMODES",
])

DirectDrawSetCooperativeLevelFlags = Flags(DWORD, [
    "DDSCL_FULLSCREEN",
    "DDSCL_ALLOWREBOOT",
    "DDSCL_NOWINDOWCHANGES",
    "DDSCL_NORMAL",
    "DDSCL_EXCLUSIVE",
    "DDSCL_ALLOWMODEX",
    "DDSCL_SETFOCUSWINDOW",
    "DDSCL_SETDEVICEWINDOW",
    "DDSCL_CREATEDEVICEWINDOW",
    "DDSCL_MULTITHREADED",
    "DDSCL_FPUSETUP",
    "DDSCL_FPUPRESERVE",
])

DirectDrawBltFlags = Flags(DWORD, [
    "DDBLT_ALPHADEST",
    "DDBLT_ALPHADESTCONSTOVERRIDE",
    "DDBLT_ALPHADESTNEG",
    "DDBLT_ALPHADESTSURFACEOVERRIDE",
    "DDBLT_ALPHAEDGEBLEND",
    "DDBLT_ALPHASRC",
    "DDBLT_ALPHASRCCONSTOVERRIDE",
    "DDBLT_ALPHASRCNEG",
    "DDBLT_ALPHASRCSURFACEOVERRIDE",
    "DDBLT_ASYNC",
    "DDBLT_COLORFILL",
    "DDBLT_DDFX",
    "DDBLT_DDROPS",
    "DDBLT_KEYDEST",
    "DDBLT_KEYDESTOVERRIDE",
    "DDBLT_KEYSRC",
    "DDBLT_KEYSRCOVERRIDE",
    "DDBLT_ROP",
    "DDBLT_ROTATIONANGLE",
    "DDBLT_ZBUFFER",
    "DDBLT_ZBUFFERDESTCONSTOVERRIDE",
    "DDBLT_ZBUFFERDESTOVERRIDE",
    "DDBLT_ZBUFFERSRCCONSTOVERRIDE",
    "DDBLT_ZBUFFERSRCOVERRIDE",
    "DDBLT_WAIT",
    "DDBLT_DEPTHFILL",
    "DDBLT_DONOTWAIT",
    "DDBLT_PRESENTATION",
    "DDBLT_LAST_PRESENTATION",
    "DDBLT_EXTENDED_FLAGS",
    "DDBLT_EXTENDED_LINEAR_CONTENT",
])

DirectDrawBltFastFlags = Flags(DWORD, [
    "DDBLTFAST_NOCOLORKEY",
    "DDBLTFAST_SRCCOLORKEY",
    "DDBLTFAST_DESTCOLORKEY",
    "DDBLTFAST_WAIT",
    "DDBLTFAST_DONOTWAIT",
])

DirectDrawFlipFlags = Flags(DWORD, [
    "DDFLIP_WAIT",
    "DDFLIP_EVEN",
    "DDFLIP_ODD",
    "DDFLIP_NOVSYNC",
    "DDFLIP_INTERVAL2",
    "DDFLIP_INTERVAL3",
    "DDFLIP_INTERVAL4",
    "DDFLIP_STEREO",
    "DDFLIP_DONOTWAIT",
])

DirectDrawSurfaceOverlayFlags = Flags(DWORD, [
    "DDOVER_ALPHADEST",
    "DDOVER_ALPHADESTCONSTOVERRIDE",
    "DDOVER_ALPHADESTNEG",
    "DDOVER_ALPHADESTSURFACEOVERRIDE",
    "DDOVER_ALPHAEDGEBLEND",
    "DDOVER_ALPHASRC",
    "DDOVER_ALPHASRCCONSTOVERRIDE",
    "DDOVER_ALPHASRCNEG",
    "DDOVER_ALPHASRCSURFACEOVERRIDE",
    "DDOVER_HIDE",
    "DDOVER_KEYDEST",
    "DDOVER_KEYDESTOVERRIDE",
    "DDOVER_KEYSRC",
    "DDOVER_KEYSRCOVERRIDE",
    "DDOVER_SHOW",
    "DDOVER_ADDDIRTYRECT",
    "DDOVER_REFRESHDIRTYRECTS",
    "DDOVER_REFRESHALL",
    "DDOVER_DDFX",
    "DDOVER_AUTOFLIP",
    "DDOVER_BOB",
    "DDOVER_OVERRIDEBOBWEAVE",
    "DDOVER_INTERLEAVED",
    "DDOVER_BOBHARDWARE",
    "DDOVER_ARGBSCALEFACTORS",
    "DDOVER_DEGRADEARGBSCALING",
])

DDSETSURFACEDESC = Flags(DWORD, [
    #"DDSETSURFACEDESC_RECREATEDC",
    #"DDSETSURFACEDESC_PRESERVEDC",
])

DirectDrawSurfaceLockFlags = Flags(DWORD, [
    "DDLOCK_SURFACEMEMORYPTR",
    "DDLOCK_WAIT",
    "DDLOCK_EVENT",
    "DDLOCK_READONLY",
    "DDLOCK_WRITEONLY",
    "DDLOCK_NOSYSLOCK",
    "DDLOCK_NOOVERWRITE",
    "DDLOCK_DISCARDCONTENTS",
    "DDLOCK_OKTOSWAP",
    "DDLOCK_DONOTWAIT",
    "DDLOCK_HASVOLUMETEXTUREBOXRECT",
    "DDLOCK_NODIRTYUPDATE",
])

DirectDrawSurfaceBltFxFlags = Flags(DWORD, [
    "DDBLTFX_ARITHSTRETCHY",
    "DDBLTFX_MIRRORLEFTRIGHT",
    "DDBLTFX_MIRRORUPDOWN",
    "DDBLTFX_NOTEARING",
    "DDBLTFX_ROTATE180",
    "DDBLTFX_ROTATE270",
    "DDBLTFX_ROTATE90",
    "DDBLTFX_ZBUFFERRANGE",
    "DDBLTFX_ZBUFFERBASEDEST",
])

DirectDrawOverlayFxFlags = Flags(DWORD, [
    "DDOVERFX_ARITHSTRETCHY",
    "DDOVERFX_MIRRORLEFTRIGHT",
    "DDOVERFX_MIRRORUPDOWN",
    "DDOVERFX_DEINTERLACE",
])

DirectDrawWaitForVerticalBlankFlags = Flags(DWORD, [
    "DDWAITVB_BLOCKBEGIN",
    "DDWAITVB_BLOCKBEGINEVENT",
    "DDWAITVB_BLOCKEND",
])

DirectDrawGetFlipStatusFlags = Flags(DWORD, [
    "DDGFS_CANFLIP",
    "DDGFS_ISFLIPDONE",
])

DirectDrawGetBltStatusFlags = Flags(DWORD, [
    "DDGBS_CANBLT",
    "DDGBS_ISBLTDONE",
])

DirectDrawEnumOverlayZOrderFlags = Flags(DWORD, [
    "DDENUMOVERLAYZ_BACKTOFRONT",
    "DDENUMOVERLAYZ_FRONTTOBACK",
])

DirectDrawUpdateOverlayZOrderFlags = Flags(DWORD, [
    "DDOVERZ_SENDTOFRONT",
    "DDOVERZ_SENDTOBACK",
    "DDOVERZ_MOVEFORWARD",
    "DDOVERZ_MOVEBACKWARD",
    "DDOVERZ_INSERTINFRONTOF",
    "DDOVERZ_INSERTINBACKOF",
])

DirectDrawSetGammaRampFlags = Flags(DWORD, [
    "DDSGR_CALIBRATE",
])

DirectDrawStartModeTestFlags = Flags(DWORD, [
    "DDSMT_ISTESTREQUIRED",
])

DirectDrawEvaluateModeFlags = Flags(DWORD, [
    "DDEM_MODEPASSED",
    "DDEM_MODEFAILED",
])

DDRESULT = MAKE_HRESULT(ok = "DD_OK", false = "DD_FALSE", errors = [
    "DDERR_ALREADYINITIALIZED",
    "DDERR_CANNOTATTACHSURFACE",
    "DDERR_CANNOTDETACHSURFACE",
    "DDERR_CURRENTLYNOTAVAIL",
    "DDERR_EXCEPTION",
    "DDERR_GENERIC",
    "DDERR_HEIGHTALIGN",
    "DDERR_INCOMPATIBLEPRIMARY",
    "DDERR_INVALIDCAPS",
    "DDERR_INVALIDCLIPLIST",
    "DDERR_INVALIDMODE",
    "DDERR_INVALIDOBJECT",
    "DDERR_INVALIDPARAMS",
    "DDERR_INVALIDPIXELFORMAT",
    "DDERR_INVALIDRECT",
    "DDERR_LOCKEDSURFACES",
    "DDERR_NO3D",
    "DDERR_NOALPHAHW",
    "DDERR_NOSTEREOHARDWARE",
    "DDERR_NOSURFACELEFT",
    "DDERR_NOCLIPLIST",
    "DDERR_NOCOLORCONVHW",
    "DDERR_NOCOOPERATIVELEVELSET",
    "DDERR_NOCOLORKEY",
    "DDERR_NOCOLORKEYHW",
    "DDERR_NODIRECTDRAWSUPPORT",
    "DDERR_NOEXCLUSIVEMODE",
    "DDERR_NOFLIPHW",
    "DDERR_NOGDI",
    "DDERR_NOMIRRORHW",
    "DDERR_NOTFOUND",
    "DDERR_NOOVERLAYHW",
    "DDERR_OVERLAPPINGRECTS",
    "DDERR_NORASTEROPHW",
    "DDERR_NOROTATIONHW",
    "DDERR_NOSTRETCHHW",
    "DDERR_NOT4BITCOLOR",
    "DDERR_NOT4BITCOLORINDEX",
    "DDERR_NOT8BITCOLOR",
    "DDERR_NOTEXTUREHW",
    "DDERR_NOVSYNCHW",
    "DDERR_NOZBUFFERHW",
    "DDERR_NOZOVERLAYHW",
    "DDERR_OUTOFCAPS",
    "DDERR_OUTOFMEMORY",
    "DDERR_OUTOFVIDEOMEMORY",
    "DDERR_OVERLAYCANTCLIP",
    "DDERR_OVERLAYCOLORKEYONLYONEACTIVE",
    "DDERR_PALETTEBUSY",
    "DDERR_COLORKEYNOTSET",
    "DDERR_SURFACEALREADYATTACHED",
    "DDERR_SURFACEALREADYDEPENDENT",
    "DDERR_SURFACEBUSY",
    "DDERR_CANTLOCKSURFACE",
    "DDERR_SURFACEISOBSCURED",
    "DDERR_SURFACELOST",
    "DDERR_SURFACENOTATTACHED",
    "DDERR_TOOBIGHEIGHT",
    "DDERR_TOOBIGSIZE",
    "DDERR_TOOBIGWIDTH",
    "DDERR_UNSUPPORTED",
    "DDERR_UNSUPPORTEDFORMAT",
    "DDERR_UNSUPPORTEDMASK",
    "DDERR_INVALIDSTREAM",
    "DDERR_VERTICALBLANKINPROGRESS",
    "DDERR_WASSTILLDRAWING",
    "DDERR_DDSCAPSCOMPLEXREQUIRED",
    "DDERR_XALIGN",
    "DDERR_INVALIDDIRECTDRAWGUID",
    "DDERR_DIRECTDRAWALREADYCREATED",
    "DDERR_NODIRECTDRAWHW",
    "DDERR_PRIMARYSURFACEALREADYEXISTS",
    "DDERR_NOEMULATION",
    "DDERR_REGIONTOOSMALL",
    "DDERR_CLIPPERISUSINGHWND",
    "DDERR_NOCLIPPERATTACHED",
    "DDERR_NOHWND",
    "DDERR_HWNDSUBCLASSED",
    "DDERR_HWNDALREADYSET",
    "DDERR_NOPALETTEATTACHED",
    "DDERR_NOPALETTEHW",
    "DDERR_BLTFASTCANTCLIP",
    "DDERR_NOBLTHW",
    "DDERR_NODDROPSHW",
    "DDERR_OVERLAYNOTVISIBLE",
    "DDERR_NOOVERLAYDEST",
    "DDERR_INVALIDPOSITION",
    "DDERR_NOTAOVERLAYSURFACE",
    "DDERR_EXCLUSIVEMODEALREADYSET",
    "DDERR_NOTFLIPPABLE",
    "DDERR_CANTDUPLICATE",
    "DDERR_NOTLOCKED",
    "DDERR_CANTCREATEDC",
    "DDERR_NODC",
    "DDERR_WRONGMODE",
    "DDERR_IMPLICITLYCREATED",
    "DDERR_NOTPALETTIZED",
    "DDERR_UNSUPPORTEDMODE",
    "DDERR_NOMIPMAPHW",
    "DDERR_INVALIDSURFACETYPE",
    "DDERR_NOOPTIMIZEHW",
    "DDERR_NOTLOADED",
    "DDERR_NOFOCUSWINDOW",
    "DDERR_NOTONMIPMAPSUBLEVEL",
    "DDERR_DCALREADYCREATED",
    "DDERR_NONONLOCALVIDMEM",
    "DDERR_CANTPAGELOCK",
    "DDERR_CANTPAGEUNLOCK",
    "DDERR_NOTPAGELOCKED",
    "DDERR_MOREDATA",
    "DDERR_EXPIRED",
    "DDERR_TESTFINISHED",
    "DDERR_NEWMODE",
    "DDERR_D3DNOTINITIALIZED",
    "DDERR_VIDEONOTACTIVE",
    "DDERR_NOMONITORINFORMATION",
    "DDERR_NODRIVERSUPPORT",
    "DDERR_DEVICEDOESNTOWNSURFACE",
    "DDERR_NOTINITIALIZED",
])

LPDDENUMMODESCALLBACK     = FunctionPointer(HRESULT, "LPDDENUMMODESCALLBACK", [LPDDSURFACEDESC, LPVOID])
LPDDENUMMODESCALLBACK2    = FunctionPointer(HRESULT, "LPDDENUMMODESCALLBACK2", [LPDDSURFACEDESC2, LPVOID])
LPDDENUMSURFACESCALLBACK  = FunctionPointer(HRESULT, "LPDDENUMSURFACESCALLBACK", [LPDIRECTDRAWSURFACE, LPDDSURFACEDESC, LPVOID])
LPDDENUMSURFACESCALLBACK2 = FunctionPointer(HRESULT, "LPDDENUMSURFACESCALLBACK2", [LPDIRECTDRAWSURFACE4, LPDDSURFACEDESC2, LPVOID])
LPDDENUMSURFACESCALLBACK7 = FunctionPointer(HRESULT, "LPDDENUMSURFACESCALLBACK7", [LPDIRECTDRAWSURFACE7, LPDDSURFACEDESC2, LPVOID])

IDirectDraw.methods += [
    StdMethod(DDRESULT, "Compact", []),
    StdMethod(DDRESULT, "CreateClipper", [(DWORD, "dwFlags"), Out(Pointer(LPDIRECTDRAWCLIPPER), "lplpDDClipper"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(DDRESULT, "CreatePalette", [(DirectDrawPaletteCapsFlags, "dwFlags"), (LPPALETTEENTRY, "lpDDColorArray"), Out(Pointer(LPDIRECTDRAWPALETTE), "lplpDDPalette"), (ObjPointer(IUnknown), "pUnkOuter")]),
    StdMethod(DDRESULT, "CreateSurface", [(LPDDSURFACEDESC, "lpDDSurfaceDesc"), Out(Pointer(LPDIRECTDRAWSURFACE), "lplpDDSurface"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(DDRESULT, "DuplicateSurface", [(LPDIRECTDRAWSURFACE, "lpDDSurface"), Out(Pointer(LPDIRECTDRAWSURFACE), "lplpDupDDSurface")]),
    StdMethod(DDRESULT, "EnumDisplayModes", [(DirectDrawEnumDisplayModesFlags, "dwFlags"), (LPDDSURFACEDESC, "lpDDSurfaceDesc"), (LPVOID, "lpContext"), (LPDDENUMMODESCALLBACK, "lpEnumModesCallback")]),
    StdMethod(DDRESULT, "EnumSurfaces", [(DirectDrawEnumSurfacesFlags, "dwFlags"), (LPDDSURFACEDESC, "lpDDSurfaceDesc"), (LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK, "lpEnumSurfacesCallback")]),
    StdMethod(DDRESULT, "FlipToGDISurface", []),
    StdMethod(DDRESULT, "GetCaps", [Out(LPDDCAPS, "lpDDDriverCaps"), Out(LPDDCAPS, "lpDDHELCaps")]),
    StdMethod(DDRESULT, "GetDisplayMode", [Out(LPDDSURFACEDESC, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "GetFourCCCodes", [Out(LPDWORD, "lpNumCodes"), Out(LPDWORD, "lpCodes")]),
    StdMethod(DDRESULT, "GetGDISurface", [Out(Pointer(LPDIRECTDRAWSURFACE), "lplpGDIDDSSurface")]),
    StdMethod(DDRESULT, "GetMonitorFrequency", [Out(LPDWORD, "lpdwFrequency")]),
    StdMethod(DDRESULT, "GetScanLine", [Out(LPDWORD, "lpdwScanLine")]),
    StdMethod(DDRESULT, "GetVerticalBlankStatus", [Out(LPBOOL, "lpbIsInVB")]),
    StdMethod(DDRESULT, "Initialize", [(Pointer(GUID), "lpGUID")]),
    StdMethod(DDRESULT, "RestoreDisplayMode", []),
    StdMethod(DDRESULT, "SetCooperativeLevel", [(HWND, "hWnd"), (DirectDrawSetCooperativeLevelFlags, "dwFlags")]),
    StdMethod(DDRESULT, "SetDisplayMode", [(DWORD, "dwWidth"), (DWORD, "dwHeight"), (DWORD, "dwBPP")]),
    StdMethod(DDRESULT, "WaitForVerticalBlank", [(DirectDrawWaitForVerticalBlankFlags, "dwFlags"), (HANDLE, "hEvent")]),
]

IDirectDraw2.methods += [
    StdMethod(DDRESULT, "Compact", []),
    StdMethod(DDRESULT, "CreateClipper", [(DWORD, "dwFlags"), Out(Pointer(LPDIRECTDRAWCLIPPER), "lplpDDClipper"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(DDRESULT, "CreatePalette", [(DirectDrawPaletteCapsFlags, "dwFlags"), (LPPALETTEENTRY, "lpDDColorArray"), Out(Pointer(LPDIRECTDRAWPALETTE), "lplpDDPalette"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(DDRESULT, "CreateSurface", [(LPDDSURFACEDESC, "lpDDSurfaceDesc"), Out(Pointer(LPDIRECTDRAWSURFACE), "lplpDDSurface"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(DDRESULT, "DuplicateSurface", [(LPDIRECTDRAWSURFACE, "lpDDSurface"), Out(Pointer(LPDIRECTDRAWSURFACE), "lplpDupDDSurface")]),
    StdMethod(DDRESULT, "EnumDisplayModes", [(DirectDrawEnumDisplayModesFlags, "dwFlags"), (LPDDSURFACEDESC, "lpDDSurfaceDesc"), (LPVOID, "lpContext"), (LPDDENUMMODESCALLBACK, "lpEnumModesCallback")]),
    StdMethod(DDRESULT, "EnumSurfaces", [(DirectDrawEnumSurfacesFlags, "dwFlags"), (LPDDSURFACEDESC, "lpDDSurfaceDesc"), (LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK, "lpEnumSurfacesCallback")]),
    StdMethod(DDRESULT, "FlipToGDISurface", []),
    StdMethod(DDRESULT, "GetCaps", [Out(LPDDCAPS, "lpDDDriverCaps"), Out(LPDDCAPS, "lpDDHELCaps")]),
    StdMethod(DDRESULT, "GetDisplayMode", [Out(LPDDSURFACEDESC, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "GetFourCCCodes", [Out(LPDWORD, "lpNumCodes"), Out(LPDWORD, "lpCodes")]),
    StdMethod(DDRESULT, "GetGDISurface", [Out(Pointer(LPDIRECTDRAWSURFACE), "lplpGDIDDSSurface")]),
    StdMethod(DDRESULT, "GetMonitorFrequency", [Out(LPDWORD, "lpdwFrequency")]),
    StdMethod(DDRESULT, "GetScanLine", [Out(LPDWORD, "lpdwScanLine")]),
    StdMethod(DDRESULT, "GetVerticalBlankStatus", [Out(LPBOOL, "lpbIsInVB")]),
    StdMethod(DDRESULT, "Initialize", [(Pointer(GUID), "lpGUID")]),
    StdMethod(DDRESULT, "RestoreDisplayMode", []),
    StdMethod(DDRESULT, "SetCooperativeLevel", [(HWND, "hWnd"), (DirectDrawSetCooperativeLevelFlags, "dwFlags")]),
    StdMethod(DDRESULT, "SetDisplayMode", [(DWORD, "dwWidth"), (DWORD, "dwHeight"), (DWORD, "dwBPP"), (DWORD, "dwRefreshRate"), (DirectDrawSetDisplayModeFlags, "dwFlags")]),
    StdMethod(DDRESULT, "WaitForVerticalBlank", [(DirectDrawWaitForVerticalBlankFlags, "dwFlags"), (HANDLE, "hEvent")]),
    StdMethod(DDRESULT, "GetAvailableVidMem", [(LPDDSCAPS, "lpDDSCaps"), Out(LPDWORD, "lpdwTotal"), Out(LPDWORD, "lpdwFree")]),
]

IDirectDraw4.methods += [
    StdMethod(DDRESULT, "Compact", []),
    StdMethod(DDRESULT, "CreateClipper", [(DWORD, "dwFlags"), Out(Pointer(LPDIRECTDRAWCLIPPER), "lplpDDClipper"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(DDRESULT, "CreatePalette", [(DirectDrawPaletteCapsFlags, "dwFlags"), (LPPALETTEENTRY, "lpDDColorArray"), Out(Pointer(LPDIRECTDRAWPALETTE), "lplpDDPalette"), (ObjPointer(IUnknown), "pUnkOuter")]),
    StdMethod(DDRESULT, "CreateSurface", [(LPDDSURFACEDESC2, "lpDDSurfaceDesc"), Out(Pointer(LPDIRECTDRAWSURFACE4), "lplpDDSurface"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(DDRESULT, "DuplicateSurface", [(LPDIRECTDRAWSURFACE4, "lpDDSurface"), Out(Pointer(LPDIRECTDRAWSURFACE4), "lplpDupDDSurface")]),
    StdMethod(DDRESULT, "EnumDisplayModes", [(DirectDrawEnumDisplayModesFlags, "dwFlags"), (LPDDSURFACEDESC2, "lpDDSurfaceDesc"), (LPVOID, "lpContext"), (LPDDENUMMODESCALLBACK2, "lpEnumModesCallback")]),
    StdMethod(DDRESULT, "EnumSurfaces", [(DirectDrawEnumSurfacesFlags, "dwFlags"), (LPDDSURFACEDESC2, "lpDDSurfaceDesc"), (LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK2, "lpEnumSurfacesCallback")]),
    StdMethod(DDRESULT, "FlipToGDISurface", []),
    StdMethod(DDRESULT, "GetCaps", [Out(LPDDCAPS, "lpDDDriverCaps"), Out(LPDDCAPS, "lpDDHELCaps")]),
    StdMethod(DDRESULT, "GetDisplayMode", [Out(LPDDSURFACEDESC2, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "GetFourCCCodes", [Out(LPDWORD, "lpNumCodes"), Out(LPDWORD, "lpCodes")]),
    StdMethod(DDRESULT, "GetGDISurface", [Out(Pointer(LPDIRECTDRAWSURFACE4), "lplpGDIDDSSurface")]),
    StdMethod(DDRESULT, "GetMonitorFrequency", [Out(LPDWORD, "lpdwFrequency")]),
    StdMethod(DDRESULT, "GetScanLine", [Out(LPDWORD, "lpdwScanLine")]),
    StdMethod(DDRESULT, "GetVerticalBlankStatus", [Out(LPBOOL, "lpbIsInVB")]),
    StdMethod(DDRESULT, "Initialize", [(Pointer(GUID), "lpGUID")]),
    StdMethod(DDRESULT, "RestoreDisplayMode", []),
    StdMethod(DDRESULT, "SetCooperativeLevel", [(HWND, "hWnd"), (DirectDrawSetCooperativeLevelFlags, "dwFlags")]),
    StdMethod(DDRESULT, "SetDisplayMode", [(DWORD, "dwWidth"), (DWORD, "dwHeight"), (DWORD, "dwBPP"), (DWORD, "dwRefreshRate"), (DirectDrawSetDisplayModeFlags, "dwFlags")]),
    StdMethod(DDRESULT, "WaitForVerticalBlank", [(DirectDrawWaitForVerticalBlankFlags, "dwFlags"), (HANDLE, "hEvent")]),
    StdMethod(DDRESULT, "GetAvailableVidMem", [(LPDDSCAPS2, "lpDDSCaps"), Out(LPDWORD, "lpdwTotal"), Out(LPDWORD, "lpdwFree")]),
    StdMethod(DDRESULT, "GetSurfaceFromDC", [(HDC, "hdc"), Out(Pointer(LPDIRECTDRAWSURFACE4), "lpDDSurface")]),
    StdMethod(DDRESULT, "RestoreAllSurfaces", []),
    StdMethod(DDRESULT, "TestCooperativeLevel", []),
    StdMethod(DDRESULT, "GetDeviceIdentifier", [Out(LPDDDEVICEIDENTIFIER, "lpDDDI"), (DirectDrawGetDeviceIdentifierFlags, "dwFlags")]),
]

IDirectDraw7.methods += [
    StdMethod(DDRESULT, "Compact", []),
    StdMethod(DDRESULT, "CreateClipper", [(DWORD, "dwFlags"), Out(Pointer(LPDIRECTDRAWCLIPPER), "lplpDDClipper"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(DDRESULT, "CreatePalette", [(DirectDrawPaletteCapsFlags, "dwFlags"), (LPPALETTEENTRY, "lpDDColorArray"), Out(Pointer(LPDIRECTDRAWPALETTE), "lplpDDPalette"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(DDRESULT, "CreateSurface", [(LPDDSURFACEDESC2, "lpDDSurfaceDesc"), Out(Pointer(LPDIRECTDRAWSURFACE7), "lplpDDSurface"), (LPUNKNOWN, "pUnkOuter")]),
    StdMethod(DDRESULT, "DuplicateSurface", [(LPDIRECTDRAWSURFACE7, "lpDDSurface"), Out(Pointer(LPDIRECTDRAWSURFACE7), "lplpDupDDSurface")]),
    StdMethod(DDRESULT, "EnumDisplayModes", [(DirectDrawEnumDisplayModesFlags, "dwFlags"), (LPDDSURFACEDESC2, "lpDDSurfaceDesc"), (LPVOID, "lpContext"), (LPDDENUMMODESCALLBACK2, "lpEnumModesCallback")]),
    StdMethod(DDRESULT, "EnumSurfaces", [(DirectDrawEnumSurfacesFlags, "dwFlags"), (LPDDSURFACEDESC2, "lpDDSurfaceDesc"), (LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK7, "lpEnumSurfacesCallback")]),
    StdMethod(DDRESULT, "FlipToGDISurface", []),
    StdMethod(DDRESULT, "GetCaps", [Out(LPDDCAPS, "lpDDDriverCaps"), Out(LPDDCAPS, "lpDDHELCaps")]),
    StdMethod(DDRESULT, "GetDisplayMode", [Out(LPDDSURFACEDESC2, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "GetFourCCCodes", [Out(LPDWORD, "lpNumCodes"), Out(LPDWORD, "lpCodes")]),
    StdMethod(DDRESULT, "GetGDISurface", [Out(Pointer(LPDIRECTDRAWSURFACE7), "lplpGDIDDSSurface")]),
    StdMethod(DDRESULT, "GetMonitorFrequency", [Out(LPDWORD, "lpdwFrequency")]),
    StdMethod(DDRESULT, "GetScanLine", [Out(LPDWORD, "lpdwScanLine")]),
    StdMethod(DDRESULT, "GetVerticalBlankStatus", [Out(LPBOOL, "lpbIsInVB")]),
    StdMethod(DDRESULT, "Initialize", [(Pointer(GUID), "lpGUID")]),
    StdMethod(DDRESULT, "RestoreDisplayMode", []),
    StdMethod(DDRESULT, "SetCooperativeLevel", [(HWND, "hWnd"), (DirectDrawSetCooperativeLevelFlags, "dwFlags")]),
    StdMethod(DDRESULT, "SetDisplayMode", [(DWORD, "dwWidth"), (DWORD, "dwHeight"), (DWORD, "dwBPP"), (DWORD, "dwRefreshRate"), (DirectDrawSetDisplayModeFlags, "dwFlags")]),
    StdMethod(DDRESULT, "WaitForVerticalBlank", [(DirectDrawWaitForVerticalBlankFlags, "dwFlags"), (HANDLE, "hEvent")]),
    StdMethod(DDRESULT, "GetAvailableVidMem", [(LPDDSCAPS2, "lpDDSCaps"), Out(LPDWORD, "lpdwTotal"), Out(LPDWORD, "lpdwFree")]),
    StdMethod(DDRESULT, "GetSurfaceFromDC", [(HDC, "hdc"), Out(Pointer(LPDIRECTDRAWSURFACE7), "lpDDSurface")]),
    StdMethod(DDRESULT, "RestoreAllSurfaces", []),
    StdMethod(DDRESULT, "TestCooperativeLevel", []),
    StdMethod(DDRESULT, "GetDeviceIdentifier", [Out(LPDDDEVICEIDENTIFIER2, "lpDDDI"), (DirectDrawGetDeviceIdentifierFlags, "dwFlags")]),
    StdMethod(DDRESULT, "StartModeTest", [(LPSIZE, "lpModesToTest"), (DWORD, "dwNumEntries"), (DirectDrawStartModeTestFlags, "dwFlags")]),
    StdMethod(DDRESULT, "EvaluateMode", [(DirectDrawEvaluateModeFlags, "dwFlags"), Out(Pointer(DWORD), "pSecondsUntilTimeout")]),
]

IDirectDrawPalette.methods += [
    StdMethod(DDRESULT, "GetCaps", [Out(Pointer(DirectDrawPaletteCapsFlags), "lpdwCaps")]),
    StdMethod(DDRESULT, "GetEntries", [(DWORD, "dwFlags"), (DWORD, "dwBase"), (DWORD, "dwNumEntries"), Out(LPPALETTEENTRY, "lpEntries")]),
    StdMethod(DDRESULT, "Initialize", [(LPDIRECTDRAW, "lpDD"), (DWORD, "dwFlags"), (LPPALETTEENTRY, "lpDDColorTable")]),
    StdMethod(DDRESULT, "SetEntries", [(DWORD, "dwFlags"), (DWORD, "dwStartingEntry"), (DWORD, "dwCount"), (LPPALETTEENTRY, "lpEntries")]),
]

IDirectDrawClipper.methods += [
    StdMethod(DDRESULT, "GetClipList", [(LPRECT, "lpRect"), (LPRGNDATA, "lpClipList"), Out(LPDWORD, "lpdwSize")]),
    StdMethod(DDRESULT, "GetHWnd", [Out(Pointer(HWND), "hWnd")]),
    StdMethod(DDRESULT, "Initialize", [(LPDIRECTDRAW, "lpDD"), (DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "IsClipListChanged", [Out(Pointer(BOOL), "lpbChanged")]),
    StdMethod(DDRESULT, "SetClipList", [(LPRGNDATA, "lpClipList"), (DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "SetHWnd", [(DWORD, "dwFlags"), (HWND, "hWnd")]),
]


IDirectDrawSurface.methods += [
    StdMethod(DDRESULT, "AddAttachedSurface", [(LPDIRECTDRAWSURFACE, "lpDDSAttachedSurface")]),
    StdMethod(DDRESULT, "AddOverlayDirtyRect", [(LPRECT, "lpRect")]),
    StdMethod(DDRESULT, "Blt", [(LPRECT, "lpDestRect"), (LPDIRECTDRAWSURFACE, "lpDDSrcSurface"), (LPRECT, "lpSrcRect"), (DirectDrawBltFlags, "dwFlags"), (LPDDBLTFX, "lpDDBltFx")]),
    StdMethod(DDRESULT, "BltBatch", [(LPDDBLTBATCH, "lpDDBltBatch"), (DWORD, "dwCount"), (DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "BltFast", [(DWORD, "dwX"), (DWORD, "dwY"), (LPDIRECTDRAWSURFACE, "lpDDSrcSurface"), (LPRECT, "lpSrcRect"), (DWORD, "dwTrans")]),
    StdMethod(DDRESULT, "DeleteAttachedSurface", [(DWORD, "dwFlags"), (LPDIRECTDRAWSURFACE, "lpDDSurface")]),
    StdMethod(DDRESULT, "EnumAttachedSurfaces", [(LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK, "lpEnumSurfacesCallback")]),
    StdMethod(DDRESULT, "EnumOverlayZOrders", [(DirectDrawEnumOverlayZOrderFlags, "dwFlags"), (LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK, "lpfnCallback")]),
    StdMethod(DDRESULT, "Flip", [(LPDIRECTDRAWSURFACE, "lpDDSurfaceTargetOverride"), (DirectDrawFlipFlags, "dwFlags")]),
    StdMethod(DDRESULT, "GetAttachedSurface", [(LPDDSCAPS, "lpDDSCaps"), Out(Pointer(LPDIRECTDRAWSURFACE), "lplpDDAttachedSurface")]),
    StdMethod(DDRESULT, "GetBltStatus", [(DirectDrawGetBltStatusFlags, "dwFlags")]),
    StdMethod(DDRESULT, "GetCaps", [Out(LPDDSCAPS, "lpDDSCaps")]),
    StdMethod(DDRESULT, "GetClipper", [Out(Pointer(LPDIRECTDRAWCLIPPER), "lplpDDClipper")]),
    StdMethod(DDRESULT, "GetColorKey", [(DirectDrawSurfaceSetGetColorKeyFlags, "dwFlags"), Out(LPDDCOLORKEY, "lpDDColorKey")]),
    StdMethod(DDRESULT, "GetDC", [Out(Pointer(HDC), "phDC")]),
    StdMethod(DDRESULT, "GetFlipStatus", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "GetOverlayPosition", [Out(LPLONG, "lplX"), Out(LPLONG, "lplY")]),
    StdMethod(DDRESULT, "GetPalette", [Out(Pointer(LPDIRECTDRAWPALETTE), "lplpDDPalette")]),
    StdMethod(DDRESULT, "GetPixelFormat", [Out(LPDDPIXELFORMAT, "lpDDPixelFormat")]),
    StdMethod(DDRESULT, "GetSurfaceDesc", [Out(LPDDSURFACEDESC, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "Initialize", [(LPDIRECTDRAW, "lpDD"), (LPDDSURFACEDESC, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "IsLost", []),
    StdMethod(DDRESULT, "Lock", [(LPRECT, "lpDestRect"), (LPDDSURFACEDESC, "lpDDSurfaceDesc"), (DirectDrawSurfaceLockFlags, "dwFlags"), (HANDLE, "hEvent")]),
    StdMethod(DDRESULT, "ReleaseDC", [(HDC, "hDC")]),
    StdMethod(DDRESULT, "Restore", []),
    StdMethod(DDRESULT, "SetClipper", [(LPDIRECTDRAWCLIPPER, "lpDDClipper")]),
    StdMethod(DDRESULT, "SetColorKey", [(DirectDrawSurfaceSetGetColorKeyFlags, "dwFlags"), Out(LPDDCOLORKEY, "lpDDColorKey")]),
    StdMethod(DDRESULT, "SetOverlayPosition", [(LONG, "lX"), (LONG, "lY")]),
    StdMethod(DDRESULT, "SetPalette", [(LPDIRECTDRAWPALETTE, "lpDDPalette")]),
    StdMethod(DDRESULT, "Unlock", [(LPVOID, "lp")]),
    StdMethod(DDRESULT, "UpdateOverlay", [(LPRECT, "lpSrcRect"), (LPDIRECTDRAWSURFACE, "lpDDDestSurface"), (LPRECT, "lpDestRect"), (DirectDrawSurfaceOverlayFlags, "dwFlags"), (LPDDOVERLAYFX, "lpDDOverlayFx")]),
    StdMethod(DDRESULT, "UpdateOverlayDisplay", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "UpdateOverlayZOrder", [(DirectDrawUpdateOverlayZOrderFlags, "dwFlags"), (LPDIRECTDRAWSURFACE, "lpDDSReference")]),
]

IDirectDrawSurface2.methods += [
    StdMethod(DDRESULT, "AddAttachedSurface", [(LPDIRECTDRAWSURFACE2, "lpDDSAttachedSurface")]),
    StdMethod(DDRESULT, "AddOverlayDirtyRect", [(LPRECT, "lpRect")]),
    StdMethod(DDRESULT, "Blt", [(LPRECT, "lpDestRect"), (LPDIRECTDRAWSURFACE2, "lpDDSrcSurface"), (LPRECT, "lpSrcRect"), (DirectDrawBltFlags, "dwFlags"), (LPDDBLTFX, "lpDDBltFx")]),
    StdMethod(DDRESULT, "BltBatch", [(LPDDBLTBATCH, "lpDDBltBatch"), (DWORD, "dwCount"), (DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "BltFast", [(DWORD, "dwX"), (DWORD, "dwY"), (LPDIRECTDRAWSURFACE2, "lpDDSrcSurface"), (LPRECT, "lpSrcRect"), (DWORD, "dwTrans")]),
    StdMethod(DDRESULT, "DeleteAttachedSurface", [(DWORD, "dwFlags"), (LPDIRECTDRAWSURFACE2, "lpDDSurface")]),
    StdMethod(DDRESULT, "EnumAttachedSurfaces", [(LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK, "lpEnumSurfacesCallback")]),
    StdMethod(DDRESULT, "EnumOverlayZOrders", [(DirectDrawEnumOverlayZOrderFlags, "dwFlags"), (LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK, "lpfnCallback")]),
    StdMethod(DDRESULT, "Flip", [(LPDIRECTDRAWSURFACE2, "lpDDSurfaceTargetOverride"), (DirectDrawFlipFlags, "dwFlags")]),
    StdMethod(DDRESULT, "GetAttachedSurface", [(LPDDSCAPS, "lpDDSCaps"), Out(Pointer(LPDIRECTDRAWSURFACE2), "lplpDDAttachedSurface")]),
    StdMethod(DDRESULT, "GetBltStatus", [(DirectDrawGetBltStatusFlags, "dwFlags")]),
    StdMethod(DDRESULT, "GetCaps", [Out(LPDDSCAPS, "lpDDSCaps")]),
    StdMethod(DDRESULT, "GetClipper", [Out(Pointer(LPDIRECTDRAWCLIPPER), "lplpDDClipper")]),
    StdMethod(DDRESULT, "GetColorKey", [(DirectDrawSurfaceSetGetColorKeyFlags, "dwFlags"), Out(LPDDCOLORKEY, "lpDDColorKey")]),
    StdMethod(DDRESULT, "GetDC", [Out(Pointer(HDC), "phDC")]),
    StdMethod(DDRESULT, "GetFlipStatus", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "GetOverlayPosition", [Out(LPLONG, "lplX"), Out(LPLONG, "lplY")]),
    StdMethod(DDRESULT, "GetPalette", [Out(Pointer(LPDIRECTDRAWPALETTE), "lplpDDPalette")]),
    StdMethod(DDRESULT, "GetPixelFormat", [Out(LPDDPIXELFORMAT, "lpDDPixelFormat")]),
    StdMethod(DDRESULT, "GetSurfaceDesc", [Out(LPDDSURFACEDESC, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "Initialize", [(LPDIRECTDRAW, "lpDD"), (LPDDSURFACEDESC, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "IsLost", []),
    StdMethod(DDRESULT, "Lock", [(LPRECT, "lpDestRect"), (LPDDSURFACEDESC, "lpDDSurfaceDesc"), (DirectDrawSurfaceLockFlags, "dwFlags"), (HANDLE, "hEvent")]),
    StdMethod(DDRESULT, "ReleaseDC", [(HDC, "hDC")]),
    StdMethod(DDRESULT, "Restore", []),
    StdMethod(DDRESULT, "SetClipper", [(LPDIRECTDRAWCLIPPER, "lpDDClipper")]),
    StdMethod(DDRESULT, "SetColorKey", [(DirectDrawSurfaceSetGetColorKeyFlags, "dwFlags"), Out(LPDDCOLORKEY, "lpDDColorKey")]),
    StdMethod(DDRESULT, "SetOverlayPosition", [(LONG, "lX"), (LONG, "lY")]),
    StdMethod(DDRESULT, "SetPalette", [(LPDIRECTDRAWPALETTE, "lpDDPalette")]),
    StdMethod(DDRESULT, "Unlock", [(LPVOID, "lp")]),
    StdMethod(DDRESULT, "UpdateOverlay", [(LPRECT, "lpSrcRect"), (LPDIRECTDRAWSURFACE2, "lpDDDestSurface"), (LPRECT, "lpDestRect"), (DirectDrawSurfaceOverlayFlags, "dwFlags"), (LPDDOVERLAYFX, "lpDDOverlayFx")]),
    StdMethod(DDRESULT, "UpdateOverlayDisplay", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "UpdateOverlayZOrder", [(DirectDrawUpdateOverlayZOrderFlags, "dwFlags"), (LPDIRECTDRAWSURFACE2, "lpDDSReference")]),
    StdMethod(DDRESULT, "GetDDInterface", [Out(LPUNKNOWN, "lplpDD")]),
    StdMethod(DDRESULT, "PageLock", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "PageUnlock", [(DWORD, "dwFlags")]),
]

IDirectDrawSurface3.methods += [
    StdMethod(DDRESULT, "AddAttachedSurface", [(LPDIRECTDRAWSURFACE3, "lpDDSAttachedSurface")]),
    StdMethod(DDRESULT, "AddOverlayDirtyRect", [(LPRECT, "lpRect")]),
    StdMethod(DDRESULT, "Blt", [(LPRECT, "lpDestRect"), (LPDIRECTDRAWSURFACE3, "lpDDSrcSurface"), (LPRECT, "lpSrcRect"), (DirectDrawBltFlags, "dwFlags"), (LPDDBLTFX, "lpDDBltFx")]),
    StdMethod(DDRESULT, "BltBatch", [(LPDDBLTBATCH, "lpDDBltBatch"), (DWORD, "dwCount"), (DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "BltFast", [(DWORD, "dwX"), (DWORD, "dwY"), (LPDIRECTDRAWSURFACE3, "lpDDSrcSurface"), (LPRECT, "lpSrcRect"), (DWORD, "dwTrans")]),
    StdMethod(DDRESULT, "DeleteAttachedSurface", [(DWORD, "dwFlags"), (LPDIRECTDRAWSURFACE3, "lpDDSurface")]),
    StdMethod(DDRESULT, "EnumAttachedSurfaces", [(LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK, "lpEnumSurfacesCallback")]),
    StdMethod(DDRESULT, "EnumOverlayZOrders", [(DirectDrawEnumOverlayZOrderFlags, "dwFlags"), (LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK, "lpfnCallback")]),
    StdMethod(DDRESULT, "Flip", [(LPDIRECTDRAWSURFACE3, "lpDDSurfaceTargetOverride"), (DirectDrawFlipFlags, "dwFlags")]),
    StdMethod(DDRESULT, "GetAttachedSurface", [(LPDDSCAPS, "lpDDSCaps"), Out(Pointer(LPDIRECTDRAWSURFACE3), "lplpDDAttachedSurface")]),
    StdMethod(DDRESULT, "GetBltStatus", [(DirectDrawGetBltStatusFlags, "dwFlags")]),
    StdMethod(DDRESULT, "GetCaps", [Out(LPDDSCAPS, "lpDDSCaps")]),
    StdMethod(DDRESULT, "GetClipper", [Out(Pointer(LPDIRECTDRAWCLIPPER), "lplpDDClipper")]),
    StdMethod(DDRESULT, "GetColorKey", [(DirectDrawSurfaceSetGetColorKeyFlags, "dwFlags"), Out(LPDDCOLORKEY, "lpDDColorKey")]),
    StdMethod(DDRESULT, "GetDC", [Out(Pointer(HDC), "phDC")]),
    StdMethod(DDRESULT, "GetFlipStatus", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "GetOverlayPosition", [Out(LPLONG, "lplX"), Out(LPLONG, "lplY")]),
    StdMethod(DDRESULT, "GetPalette", [Out(Pointer(LPDIRECTDRAWPALETTE), "lplpDDPalette")]),
    StdMethod(DDRESULT, "GetPixelFormat", [Out(LPDDPIXELFORMAT, "lpDDPixelFormat")]),
    StdMethod(DDRESULT, "GetSurfaceDesc", [Out(LPDDSURFACEDESC, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "Initialize", [(LPDIRECTDRAW, "lpDD"), (LPDDSURFACEDESC, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "IsLost", []),
    StdMethod(DDRESULT, "Lock", [(LPRECT, "lpDestRect"), (LPDDSURFACEDESC, "lpDDSurfaceDesc"), (DirectDrawSurfaceLockFlags, "dwFlags"), (HANDLE, "hEvent")]),
    StdMethod(DDRESULT, "ReleaseDC", [(HDC, "hDC")]),
    StdMethod(DDRESULT, "Restore", []),
    StdMethod(DDRESULT, "SetClipper", [(LPDIRECTDRAWCLIPPER, "lpDDClipper")]),
    StdMethod(DDRESULT, "SetColorKey", [(DirectDrawSurfaceSetGetColorKeyFlags, "dwFlags"), Out(LPDDCOLORKEY, "lpDDColorKey")]),
    StdMethod(DDRESULT, "SetOverlayPosition", [(LONG, "lX"), (LONG, "lY")]),
    StdMethod(DDRESULT, "SetPalette", [(LPDIRECTDRAWPALETTE, "lpDDPalette")]),
    StdMethod(DDRESULT, "Unlock", [(LPVOID, "lp")]),
    StdMethod(DDRESULT, "UpdateOverlay", [(LPRECT, "lpSrcRect"), (LPDIRECTDRAWSURFACE3, "lpDDDestSurface"), (LPRECT, "lpDestRect"), (DirectDrawSurfaceOverlayFlags, "dwFlags"), (LPDDOVERLAYFX, "lpDDOverlayFx")]),
    StdMethod(DDRESULT, "UpdateOverlayDisplay", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "UpdateOverlayZOrder", [(DirectDrawUpdateOverlayZOrderFlags, "dwFlags"), (LPDIRECTDRAWSURFACE3, "lpDDSReference")]),
    StdMethod(DDRESULT, "GetDDInterface", [Out(LPUNKNOWN, "lplpDD")]),
    StdMethod(DDRESULT, "PageLock", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "PageUnlock", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "SetSurfaceDesc", [(LPDDSURFACEDESC, "lpDDSD"), (DWORD, "dwFlags")]),
]

IDirectDrawSurface4.methods += [
    StdMethod(DDRESULT, "AddAttachedSurface", [(LPDIRECTDRAWSURFACE4, "lpDDSAttachedSurface")]),
    StdMethod(DDRESULT, "AddOverlayDirtyRect", [(LPRECT, "lpRect")]),
    StdMethod(DDRESULT, "Blt", [(LPRECT, "lpDestRect"), (LPDIRECTDRAWSURFACE4, "lpDDSrcSurface"), (LPRECT, "lpSrcRect"), (DirectDrawBltFlags, "dwFlags"), (LPDDBLTFX, "lpDDBltFx")]),
    StdMethod(DDRESULT, "BltBatch", [(LPDDBLTBATCH, "lpDDBltBatch"), (DWORD, "dwCount"), (DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "BltFast", [(DWORD, "dwX"), (DWORD, "dwY"), (LPDIRECTDRAWSURFACE4, "lpDDSrcSurface"), (LPRECT, "lpSrcRect"), (DWORD, "dwTrans")]),
    StdMethod(DDRESULT, "DeleteAttachedSurface", [(DWORD, "dwFlags"), (LPDIRECTDRAWSURFACE4, "lpDDSurface")]),
    StdMethod(DDRESULT, "EnumAttachedSurfaces", [(LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK2, "lpEnumSurfacesCallback")]),
    StdMethod(DDRESULT, "EnumOverlayZOrders", [(DirectDrawEnumOverlayZOrderFlags, "dwFlags"), (LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK2, "lpfnCallback")]),
    StdMethod(DDRESULT, "Flip", [(LPDIRECTDRAWSURFACE4, "lpDDSurfaceTargetOverride"), (DirectDrawFlipFlags, "dwFlags")]),
    StdMethod(DDRESULT, "GetAttachedSurface", [(LPDDSCAPS2, "lpDDSCaps"), Out(Pointer(LPDIRECTDRAWSURFACE4), "lplpDDAttachedSurface")]),
    StdMethod(DDRESULT, "GetBltStatus", [(DirectDrawGetBltStatusFlags, "dwFlags")]),
    StdMethod(DDRESULT, "GetCaps", [Out(LPDDSCAPS2, "lpDDSCaps")]),
    StdMethod(DDRESULT, "GetClipper", [Out(Pointer(LPDIRECTDRAWCLIPPER), "lplpDDClipper")]),
    StdMethod(DDRESULT, "GetColorKey", [(DirectDrawSurfaceSetGetColorKeyFlags, "dwFlags"), Out(LPDDCOLORKEY, "lpDDColorKey")]),
    StdMethod(DDRESULT, "GetDC", [Out(Pointer(HDC), "phDC")]),
    StdMethod(DDRESULT, "GetFlipStatus", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "GetOverlayPosition", [Out(LPLONG, "lplX"), Out(LPLONG, "lplY")]),
    StdMethod(DDRESULT, "GetPalette", [Out(Pointer(LPDIRECTDRAWPALETTE), "lplpDDPalette")]),
    StdMethod(DDRESULT, "GetPixelFormat", [Out(LPDDPIXELFORMAT, "lpDDPixelFormat")]),
    StdMethod(DDRESULT, "GetSurfaceDesc", [Out(LPDDSURFACEDESC2, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "Initialize", [(LPDIRECTDRAW, "lpDD"), (LPDDSURFACEDESC2, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "IsLost", []),
    StdMethod(DDRESULT, "Lock", [(LPRECT, "lpDestRect"), (LPDDSURFACEDESC2, "lpDDSurfaceDesc"), (DirectDrawSurfaceLockFlags, "dwFlags"), (HANDLE, "hEvent")]),
    StdMethod(DDRESULT, "ReleaseDC", [(HDC, "hDC")]),
    StdMethod(DDRESULT, "Restore", []),
    StdMethod(DDRESULT, "SetClipper", [(LPDIRECTDRAWCLIPPER, "lpDDClipper")]),
    StdMethod(DDRESULT, "SetColorKey", [(DirectDrawSurfaceSetGetColorKeyFlags, "dwFlags"), Out(LPDDCOLORKEY, "lpDDColorKey")]),
    StdMethod(DDRESULT, "SetOverlayPosition", [(LONG, "lX"), (LONG, "lY")]),
    StdMethod(DDRESULT, "SetPalette", [(LPDIRECTDRAWPALETTE, "lpDDPalette")]),
    StdMethod(DDRESULT, "Unlock", [(LPRECT, "lpRect")]),
    StdMethod(DDRESULT, "UpdateOverlay", [(LPRECT, "lpSrcRect"), (LPDIRECTDRAWSURFACE4, "lpDDDestSurface"), (LPRECT, "lpDestRect"), (DirectDrawSurfaceOverlayFlags, "dwFlags"), (LPDDOVERLAYFX, "lpDDOverlayFx")]),
    StdMethod(DDRESULT, "UpdateOverlayDisplay", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "UpdateOverlayZOrder", [(DirectDrawUpdateOverlayZOrderFlags, "dwFlags"), (LPDIRECTDRAWSURFACE4, "lpDDSReference")]),
    StdMethod(DDRESULT, "GetDDInterface", [Out(Pointer(LPVOID), "lplpDD")]),
    StdMethod(DDRESULT, "PageLock", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "PageUnlock", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "SetSurfaceDesc", [(LPDDSURFACEDESC2, "lpDDSD"), (DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "SetPrivateData", [(REFGUID, "guidTag"), (LPVOID, "lpData"), (DWORD, "cbSize"), (DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "GetPrivateData", [(REFGUID, "guidTag"), (LPVOID, "lpData"), Out(LPDWORD, "lpcbBufferSize")]),
    StdMethod(DDRESULT, "FreePrivateData", [(REFGUID, "guidTag")]),
    StdMethod(DDRESULT, "GetUniquenessValue", [Out(LPDWORD, "lpValue")]),
    StdMethod(DDRESULT, "ChangeUniquenessValue", []),
]

IDirectDrawSurface7.methods += [
    StdMethod(DDRESULT, "AddAttachedSurface", [(LPDIRECTDRAWSURFACE7, "lpDDSAttachedSurface")]),
    StdMethod(DDRESULT, "AddOverlayDirtyRect", [(LPRECT, "lpRect")]),
    StdMethod(DDRESULT, "Blt", [(LPRECT, "lpDestRect"), (LPDIRECTDRAWSURFACE7, "lpDDSrcSurface"), (LPRECT, "lpSrcRect"), (DirectDrawBltFlags, "dwFlags"), (LPDDBLTFX, "lpDDBltFx")]),
    StdMethod(DDRESULT, "BltBatch", [(LPDDBLTBATCH, "lpDDBltBatch"), (DWORD, "dwCount"), (DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "BltFast", [(DWORD, "dwX"), (DWORD, "dwY"), (LPDIRECTDRAWSURFACE7, "lpDDSrcSurface"), (LPRECT, "lpSrcRect"), (DWORD, "dwTrans")]),
    StdMethod(DDRESULT, "DeleteAttachedSurface", [(DWORD, "dwFlags"), (LPDIRECTDRAWSURFACE7, "lpDDSurface")]),
    StdMethod(DDRESULT, "EnumAttachedSurfaces", [(LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK7, "lpEnumSurfacesCallback")]),
    StdMethod(DDRESULT, "EnumOverlayZOrders", [(DirectDrawEnumOverlayZOrderFlags, "dwFlags"), (LPVOID, "lpContext"), (LPDDENUMSURFACESCALLBACK7, "lpfnCallback")]),
    StdMethod(DDRESULT, "Flip", [(LPDIRECTDRAWSURFACE7, "lpDDSurfaceTargetOverride"), (DirectDrawFlipFlags, "dwFlags")]),
    StdMethod(DDRESULT, "GetAttachedSurface", [(LPDDSCAPS2, "lpDDSCaps"), Out(Pointer(LPDIRECTDRAWSURFACE7), "lplpDDAttachedSurface")]),
    StdMethod(DDRESULT, "GetBltStatus", [(DirectDrawGetBltStatusFlags, "dwFlags")]),
    StdMethod(DDRESULT, "GetCaps", [Out(LPDDSCAPS2, "lpDDSCaps")]),
    StdMethod(DDRESULT, "GetClipper", [Out(Pointer(LPDIRECTDRAWCLIPPER), "lplpDDClipper")]),
    StdMethod(DDRESULT, "GetColorKey", [(DirectDrawSurfaceSetGetColorKeyFlags, "dwFlags"), Out(LPDDCOLORKEY, "lpDDColorKey")]),
    StdMethod(DDRESULT, "GetDC", [Out(Pointer(HDC), "phDC")]),
    StdMethod(DDRESULT, "GetFlipStatus", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "GetOverlayPosition", [Out(LPLONG, "lplX"), Out(LPLONG, "lplY")]),
    StdMethod(DDRESULT, "GetPalette", [Out(Pointer(LPDIRECTDRAWPALETTE), "lplpDDPalette")]),
    StdMethod(DDRESULT, "GetPixelFormat", [Out(LPDDPIXELFORMAT, "lpDDPixelFormat")]),
    StdMethod(DDRESULT, "GetSurfaceDesc", [Out(LPDDSURFACEDESC2, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "Initialize", [(LPDIRECTDRAW, "lpDD"), (LPDDSURFACEDESC2, "lpDDSurfaceDesc")]),
    StdMethod(DDRESULT, "IsLost", []),
    StdMethod(DDRESULT, "Lock", [(LPRECT, "lpDestRect"), (LPDDSURFACEDESC2, "lpDDSurfaceDesc"), (DirectDrawSurfaceLockFlags, "dwFlags"), (HANDLE, "hEvent")]),
    StdMethod(DDRESULT, "ReleaseDC", [(HDC, "hDC")]),
    StdMethod(DDRESULT, "Restore", []),
    StdMethod(DDRESULT, "SetClipper", [(LPDIRECTDRAWCLIPPER, "lpDDClipper")]),
    StdMethod(DDRESULT, "SetColorKey", [(DirectDrawSurfaceSetGetColorKeyFlags, "dwFlags"), Out(LPDDCOLORKEY, "lpDDColorKey")]),
    StdMethod(DDRESULT, "SetOverlayPosition", [(LONG, "lX"), (LONG, "lY")]),
    StdMethod(DDRESULT, "SetPalette", [(LPDIRECTDRAWPALETTE, "lpDDPalette")]),
    StdMethod(DDRESULT, "Unlock", [(LPRECT, "lpRect")]),
    StdMethod(DDRESULT, "UpdateOverlay", [(LPRECT, "lpSrcRect"), (LPDIRECTDRAWSURFACE7, "lpDDDestSurface"), (LPRECT, "lpDestRect"), (DirectDrawSurfaceOverlayFlags, "dwFlags"), (LPDDOVERLAYFX, "lpDDOverlayFx")]),
    StdMethod(DDRESULT, "UpdateOverlayDisplay", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "UpdateOverlayZOrder", [(DirectDrawUpdateOverlayZOrderFlags, "dwFlags"), (LPDIRECTDRAWSURFACE7, "lpDDSReference")]),
    StdMethod(DDRESULT, "GetDDInterface", [Out(Pointer(LPVOID), "lplpDD")]),
    StdMethod(DDRESULT, "PageLock", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "PageUnlock", [(DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "SetSurfaceDesc", [(LPDDSURFACEDESC2, "lpDDSD"), (DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "SetPrivateData", [(REFGUID, "guidTag"), (LPVOID, "lpData"), (DWORD, "cbSize"), (DWORD, "dwFlags")]),
    StdMethod(DDRESULT, "GetPrivateData", [(REFGUID, "guidTag"), (LPVOID, "lpData"), Out(LPDWORD, "lpcbBufferSize")]),
    StdMethod(DDRESULT, "FreePrivateData", [(REFGUID, "guidTag")]),
    StdMethod(DDRESULT, "GetUniquenessValue", [Out(LPDWORD, "lpValue")]),
    StdMethod(DDRESULT, "ChangeUniquenessValue", []),
    StdMethod(DDRESULT, "SetPriority", [(DWORD, "dwPriority")]),
    StdMethod(DDRESULT, "GetPriority", [Out(LPDWORD, "lpdwPriority")]),
    StdMethod(DDRESULT, "SetLOD", [(DWORD, "dwMaxLOD")]),
    StdMethod(DDRESULT, "GetLOD", [Out(LPDWORD, "lpdwMaxLOD")]),
]

IDirectDrawColorControl.methods += [
    StdMethod(DDRESULT, "GetColorControls", [(LPDDCOLORCONTROL, "lpColorControl")]),
    StdMethod(DDRESULT, "SetColorControls", [(LPDDCOLORCONTROL, "lpColorControl")]),
]

IDirectDrawGammaControl.methods += [
    StdMethod(DDRESULT, "GetGammaRamp", [(DWORD, "dwFlags"), Out(LPDDGAMMARAMP, "lpRampData")]),
    StdMethod(DDRESULT, "SetGammaRamp", [(DirectDrawSetGammaRampFlags, "dwFlags"), (LPDDGAMMARAMP, "lpRampData")]),
]

LPDDENUMCALLBACKA   = FunctionPointer(BOOL, "LPDDENUMCALLBACKA", [Pointer(GUID), LPSTR, LPSTR, LPVOID])
LPDDENUMCALLBACKW   = FunctionPointer(BOOL, "LPDDENUMCALLBACKW", [Pointer(GUID), LPWSTR, LPWSTR, LPVOID])
LPDDENUMCALLBACKEXA = FunctionPointer(BOOL, "LPDDENUMCALLBACKEXA", [Pointer(GUID), LPSTR, LPSTR, LPVOID, HMONITOR])
LPDDENUMCALLBACKEXW = FunctionPointer(BOOL, "LPDDENUMCALLBACKEXW", [Pointer(GUID), LPWSTR, LPWSTR, LPVOID, HMONITOR])

DDENUM = Flags(DWORD, [
    "DDENUM_ATTACHEDSECONDARYDEVICES",
    "DDENUM_DETACHEDSECONDARYDEVICES",
    "DDENUM_NONDISPLAYDEVICES",
])

DDCREATE = Flags(DWORD, [
    "DDCREATE_HARDWAREONLY",
    "DDCREATE_EMULATIONONLY",
])

ddraw = Module("ddraw")
ddraw.addFunctions([
    StdFunction(HRESULT, "DirectDrawEnumerateW", [(LPDDENUMCALLBACKW, "lpCallback"), (LPVOID, "lpContext")]),
    StdFunction(HRESULT, "DirectDrawEnumerateA", [(LPDDENUMCALLBACKA, "lpCallback"), (LPVOID, "lpContext")]),
    StdFunction(HRESULT, "DirectDrawEnumerateExW", [(LPDDENUMCALLBACKEXW, "lpCallback"), (LPVOID, "lpContext"), (DDENUM, "dwFlags")]),
    StdFunction(HRESULT, "DirectDrawEnumerateExA", [(LPDDENUMCALLBACKEXA, "lpCallback"), (LPVOID, "lpContext"), (DDENUM, "dwFlags")]),
    StdFunction(HRESULT, "DirectDrawCreate", [(Pointer(GUID), "lpGUID"), Out(Pointer(LPDIRECTDRAW), "lplpDD"), (LPUNKNOWN, "pUnkOuter")]),
    StdFunction(HRESULT, "DirectDrawCreateEx", [(Pointer(GUID), "lpGuid"), Out(Pointer(ObjPointer(Void)), "lplpDD"), (REFIID, "iid"), (LPUNKNOWN, "pUnkOuter")]),
    StdFunction(HRESULT, "DirectDrawCreateClipper", [(DWORD, "dwFlags"), Out(Pointer(LPDIRECTDRAWCLIPPER), "lplpDDClipper"), (LPUNKNOWN, "pUnkOuter")]),
    StdFunction(Void, "AcquireDDThreadLock", [], internal=True),
    StdFunction(Void, "ReleaseDDThreadLock", [], internal=True),
    StdFunction(DWORD, "D3DParseUnknownCommand", [(LPVOID, "lpCmd"), Out(Pointer(LPVOID), "lpRetCmd")]),
    StdFunction(HRESULT, "DllCanUnloadNow", []),
    StdFunction(HRESULT, "DllGetClassObject", [(REFCLSID, "rclsid"), (REFIID, "riid"), Out(Pointer(ObjPointer(Void)), "ppv")]),

    # XXX
    StdFunction(HRESULT, "CompleteCreateSysmemSurface", [Int, Int]),
    StdFunction(HRESULT, "GetSurfaceFromDC", [Int, Int, Int]),
    StdFunction(HRESULT, "DDInternalLock", [Int, Int]),
    StdFunction(HRESULT, "DDInternalUnlock", [Int]),
    StdFunction(HRESULT, "DSoundHelp", [HWND, Int, Int]),
    StdFunction(HRESULT, "GetDDSurfaceLocal", [Int, Int, Int]),
    StdFunction(HANDLE, "GetOLEThunkData", [Int]),
    StdFunction(HRESULT, "RegisterSpecialCase", [Int, Int, Int, Int]),
    StdFunction(HRESULT, "DDGetAttachedSurfaceLcl", [Int, Int, Int]),

    # TODO: SetAppCompatData
])


########NEW FILE########
__FILENAME__ = debug
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

'''Debugging utilities.'''


import sys
import traceback
import inspect


def excepthook(type, value, tb):
	"""
	Automatically start the debugger on an exception.

	See also:
	- http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/65287
	"""

	if hasattr(sys, 'ps1') \
	or not (sys.stdin.isatty() and sys.stdout.isatty() and sys.stderr.isatty()) \
	or type == SyntaxError or type == KeyboardInterrupt:
		# we are in interactive mode or we don't have a tty-like
		# device, so we call the default hook
		oldexcepthook(type, value, tb)
	else:
		import traceback, pdb
		# we are NOT in interactive mode, print the exception...
		traceback.print_exception(type, value, tb)
		print
		# ...then start the debugger in post-mortem mode.
		pdb.pm()

oldexcepthook, sys.excepthook = sys.excepthook, excepthook


def dump(var):
	sys.stderr.write(repr(var) + '\n')
	

########NEW FILE########
__FILENAME__ = dwrite
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from winapi import *
from dcommon import *


ID2D1SimplifiedGeometrySink = Interface("ID2D1SimplifiedGeometrySink", IUnknown)
IDWriteGeometrySink = Alias("IDWriteGeometrySink", ID2D1SimplifiedGeometrySink)

IDWriteFontFileLoader = Interface("IDWriteFontFileLoader", IUnknown)
IDWriteLocalFontFileLoader = Interface("IDWriteLocalFontFileLoader", IDWriteFontFileLoader)
IDWriteFontFileStream = Interface("IDWriteFontFileStream", IUnknown)
IDWriteFontFile = Interface("IDWriteFontFile", IUnknown)
IDWriteRenderingParams = Interface("IDWriteRenderingParams", IUnknown)
IDWriteFontFace = Interface("IDWriteFontFace", IUnknown)
IDWriteFontCollectionLoader = Interface("IDWriteFontCollectionLoader", IUnknown)
IDWriteFontFileEnumerator = Interface("IDWriteFontFileEnumerator", IUnknown)
IDWriteLocalizedStrings = Interface("IDWriteLocalizedStrings", IUnknown)
IDWriteFontCollection = Interface("IDWriteFontCollection", IUnknown)
IDWriteFontList = Interface("IDWriteFontList", IUnknown)
IDWriteFontFamily = Interface("IDWriteFontFamily", IDWriteFontList)
IDWriteFont = Interface("IDWriteFont", IUnknown)
IDWriteTextFormat = Interface("IDWriteTextFormat", IUnknown)
IDWriteTypography = Interface("IDWriteTypography", IUnknown)
IDWriteNumberSubstitution = Interface("IDWriteNumberSubstitution", IUnknown)
IDWriteTextAnalysisSource = Interface("IDWriteTextAnalysisSource", IUnknown)
IDWriteTextAnalysisSink = Interface("IDWriteTextAnalysisSink", IUnknown)
IDWriteTextAnalyzer = Interface("IDWriteTextAnalyzer", IUnknown)
IDWriteInlineObject = Interface("IDWriteInlineObject", IUnknown)
IDWritePixelSnapping = Interface("IDWritePixelSnapping", IUnknown)
IDWriteTextRenderer = Interface("IDWriteTextRenderer", IDWritePixelSnapping)
IDWriteTextLayout = Interface("IDWriteTextLayout", IDWriteTextFormat)
IDWriteBitmapRenderTarget = Interface("IDWriteBitmapRenderTarget", IUnknown)
IDWriteGdiInterop = Interface("IDWriteGdiInterop", IUnknown)
IDWriteGlyphRunAnalysis = Interface("IDWriteGlyphRunAnalysis", IUnknown)
IDWriteFactory = Interface("IDWriteFactory", IUnknown)


def EnumFlag(expr, values):
    return Flags(Alias(expr, DWORD), values)


DWRITE_FONT_FILE_TYPE = Enum("DWRITE_FONT_FILE_TYPE", [
    "DWRITE_FONT_FILE_TYPE_UNKNOWN",
    "DWRITE_FONT_FILE_TYPE_CFF",
    "DWRITE_FONT_FILE_TYPE_TRUETYPE",
    "DWRITE_FONT_FILE_TYPE_TRUETYPE_COLLECTION",
    "DWRITE_FONT_FILE_TYPE_TYPE1_PFM",
    "DWRITE_FONT_FILE_TYPE_TYPE1_PFB",
    "DWRITE_FONT_FILE_TYPE_VECTOR",
    "DWRITE_FONT_FILE_TYPE_BITMAP",
])

DWRITE_FONT_FACE_TYPE = Enum("DWRITE_FONT_FACE_TYPE", [
    "DWRITE_FONT_FACE_TYPE_CFF",
    "DWRITE_FONT_FACE_TYPE_TRUETYPE",
    "DWRITE_FONT_FACE_TYPE_TRUETYPE_COLLECTION",
    "DWRITE_FONT_FACE_TYPE_TYPE1",
    "DWRITE_FONT_FACE_TYPE_VECTOR",
    "DWRITE_FONT_FACE_TYPE_BITMAP",
    "DWRITE_FONT_FACE_TYPE_UNKNOWN",
])

DWRITE_FONT_SIMULATIONS = EnumFlag("DWRITE_FONT_SIMULATIONS", [
    "DWRITE_FONT_SIMULATIONS_NONE",
    "DWRITE_FONT_SIMULATIONS_BOLD",
    "DWRITE_FONT_SIMULATIONS_OBLIQUE",
])

DWRITE_FONT_WEIGHT = Enum("DWRITE_FONT_WEIGHT", [
    "DWRITE_FONT_WEIGHT_THIN",
    "DWRITE_FONT_WEIGHT_EXTRA_LIGHT",
    #"DWRITE_FONT_WEIGHT_ULTRA_LIGHT",
    "DWRITE_FONT_WEIGHT_LIGHT",
    "DWRITE_FONT_WEIGHT_NORMAL",
    #"DWRITE_FONT_WEIGHT_REGULAR",
    "DWRITE_FONT_WEIGHT_MEDIUM",
    "DWRITE_FONT_WEIGHT_DEMI_BOLD",
    #"DWRITE_FONT_WEIGHT_SEMI_BOLD",
    "DWRITE_FONT_WEIGHT_BOLD",
    "DWRITE_FONT_WEIGHT_EXTRA_BOLD",
    #"DWRITE_FONT_WEIGHT_ULTRA_BOLD",
    "DWRITE_FONT_WEIGHT_BLACK",
    #"DWRITE_FONT_WEIGHT_HEAVY",
    "DWRITE_FONT_WEIGHT_EXTRA_BLACK",
    #"DWRITE_FONT_WEIGHT_ULTRA_BLACK",
])

DWRITE_FONT_STRETCH = Enum("DWRITE_FONT_STRETCH", [
    "DWRITE_FONT_STRETCH_UNDEFINED",
    "DWRITE_FONT_STRETCH_ULTRA_CONDENSED",
    "DWRITE_FONT_STRETCH_EXTRA_CONDENSED",
    "DWRITE_FONT_STRETCH_CONDENSED",
    "DWRITE_FONT_STRETCH_SEMI_CONDENSED",
    "DWRITE_FONT_STRETCH_NORMAL",
    #"DWRITE_FONT_STRETCH_MEDIUM",
    "DWRITE_FONT_STRETCH_SEMI_EXPANDED",
    "DWRITE_FONT_STRETCH_EXPANDED",
    "DWRITE_FONT_STRETCH_EXTRA_EXPANDED",
    "DWRITE_FONT_STRETCH_ULTRA_EXPANDED",
])

DWRITE_FONT_STYLE = Enum("DWRITE_FONT_STYLE", [
    "DWRITE_FONT_STYLE_NORMAL",
    "DWRITE_FONT_STYLE_OBLIQUE",
    "DWRITE_FONT_STYLE_ITALIC",
])

DWRITE_INFORMATIONAL_STRING_ID = Enum("DWRITE_INFORMATIONAL_STRING_ID", [
    "DWRITE_INFORMATIONAL_STRING_NONE",
    "DWRITE_INFORMATIONAL_STRING_COPYRIGHT_NOTICE",
    "DWRITE_INFORMATIONAL_STRING_VERSION_STRINGS",
    "DWRITE_INFORMATIONAL_STRING_TRADEMARK",
    "DWRITE_INFORMATIONAL_STRING_MANUFACTURER",
    "DWRITE_INFORMATIONAL_STRING_DESIGNER",
    "DWRITE_INFORMATIONAL_STRING_DESIGNER_URL",
    "DWRITE_INFORMATIONAL_STRING_DESCRIPTION",
    "DWRITE_INFORMATIONAL_STRING_FONT_VENDOR_URL",
    "DWRITE_INFORMATIONAL_STRING_LICENSE_DESCRIPTION",
    "DWRITE_INFORMATIONAL_STRING_LICENSE_INFO_URL",
    "DWRITE_INFORMATIONAL_STRING_WIN32_FAMILY_NAMES",
    "DWRITE_INFORMATIONAL_STRING_WIN32_SUBFAMILY_NAMES",
    "DWRITE_INFORMATIONAL_STRING_PREFERRED_FAMILY_NAMES",
    "DWRITE_INFORMATIONAL_STRING_PREFERRED_SUBFAMILY_NAMES",
    "DWRITE_INFORMATIONAL_STRING_SAMPLE_TEXT",
])

DWRITE_FONT_METRICS = Struct("DWRITE_FONT_METRICS", [
    (UINT16, "designUnitsPerEm"),
    (UINT16, "ascent"),
    (UINT16, "descent"),
    (INT16, "lineGap"),
    (UINT16, "capHeight"),
    (UINT16, "xHeight"),
    (INT16, "underlinePosition"),
    (UINT16, "underlineThickness"),
    (INT16, "strikethroughPosition"),
    (UINT16, "strikethroughThickness"),
])

DWRITE_GLYPH_METRICS = Struct("DWRITE_GLYPH_METRICS", [
    (INT32, "leftSideBearing"),
    (UINT32, "advanceWidth"),
    (INT32, "rightSideBearing"),
    (INT32, "topSideBearing"),
    (UINT32, "advanceHeight"),
    (INT32, "bottomSideBearing"),
    (INT32, "verticalOriginY"),
])

DWRITE_GLYPH_OFFSET = Struct("DWRITE_GLYPH_OFFSET", [
    (FLOAT, "advanceOffset"),
    (FLOAT, "ascenderOffset"),
])

DWRITE_FACTORY_TYPE = Enum("DWRITE_FACTORY_TYPE", [
    "DWRITE_FACTORY_TYPE_SHARED",
    "DWRITE_FACTORY_TYPE_ISOLATED",
])

IDWriteFontFileLoader.methods += [
    StdMethod(HRESULT, "CreateStreamFromKey", [(OpaquePointer(Const(Void)), "fontFileReferenceKey"), (UINT32, "fontFileReferenceKeySize"), Out(Pointer(ObjPointer(IDWriteFontFileStream)), "fontFileStream")]),
]

IDWriteLocalFontFileLoader.methods += [
    StdMethod(HRESULT, "GetFilePathLengthFromKey", [(OpaquePointer(Const(Void)), "fontFileReferenceKey"), (UINT32, "fontFileReferenceKeySize"), Out(Pointer(UINT32), "filePathLength")]),
    StdMethod(HRESULT, "GetFilePathFromKey", [(OpaquePointer(Const(Void)), "fontFileReferenceKey"), (UINT32, "fontFileReferenceKeySize"), Out(Pointer(WCHAR), "filePath"), (UINT32, "filePathSize")]),
    StdMethod(HRESULT, "GetLastWriteTimeFromKey", [(OpaquePointer(Const(Void)), "fontFileReferenceKey"), (UINT32, "fontFileReferenceKeySize"), Out(Pointer(FILETIME), "lastWriteTime")]),
]

IDWriteFontFileStream.methods += [
    StdMethod(HRESULT, "ReadFileFragment", [Out(Pointer(OpaquePointer(Const(Void))), "fragmentStart"), (UINT64, "fileOffset"), (UINT64, "fragmentSize"), Out(Pointer(OpaquePointer(Void)), "fragmentContext")]),
    StdMethod(Void, "ReleaseFileFragment", [(OpaquePointer(Void), "fragmentContext")]),
    StdMethod(HRESULT, "GetFileSize", [Out(Pointer(UINT64), "fileSize")]),
    StdMethod(HRESULT, "GetLastWriteTime", [Out(Pointer(UINT64), "lastWriteTime")]),
]

IDWriteFontFile.methods += [
    StdMethod(HRESULT, "GetReferenceKey", [Out(Pointer(OpaquePointer(Const(Void))), "fontFileReferenceKey"), Out(Pointer(UINT32), "fontFileReferenceKeySize")]),
    StdMethod(HRESULT, "GetLoader", [Out(Pointer(ObjPointer(IDWriteFontFileLoader)), "fontFileLoader")]),
    StdMethod(HRESULT, "Analyze", [Out(Pointer(BOOL), "isSupportedFontType"), Out(Pointer(DWRITE_FONT_FILE_TYPE), "fontFileType"), Out(Pointer(DWRITE_FONT_FACE_TYPE), "fontFaceType"), Out(Pointer(UINT32), "numberOfFaces")]),
]

DWRITE_PIXEL_GEOMETRY = Enum("DWRITE_PIXEL_GEOMETRY", [
    "DWRITE_PIXEL_GEOMETRY_FLAT",
    "DWRITE_PIXEL_GEOMETRY_RGB",
    "DWRITE_PIXEL_GEOMETRY_BGR",
])

DWRITE_RENDERING_MODE = Enum("DWRITE_RENDERING_MODE", [
    "DWRITE_RENDERING_MODE_DEFAULT",
    "DWRITE_RENDERING_MODE_ALIASED",
    "DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC",
    "DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL",
    "DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL",
    "DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC",
    "DWRITE_RENDERING_MODE_OUTLINE",
])

DWRITE_MATRIX = Struct("DWRITE_MATRIX", [
    (FLOAT, "m11"),
    (FLOAT, "m12"),
    (FLOAT, "m21"),
    (FLOAT, "m22"),
    (FLOAT, "dx"),
    (FLOAT, "dy"),
])

IDWriteRenderingParams.methods += [
    StdMethod(FLOAT, "GetGamma", []),
    StdMethod(FLOAT, "GetEnhancedContrast", []),
    StdMethod(FLOAT, "GetClearTypeLevel", []),
    StdMethod(DWRITE_PIXEL_GEOMETRY, "GetPixelGeometry", []),
    StdMethod(DWRITE_RENDERING_MODE, "GetRenderingMode", []),
]

IDWriteFontFace.methods += [
    StdMethod(DWRITE_FONT_FACE_TYPE, "GetType", []),
    StdMethod(HRESULT, "GetFiles", [(OpaquePointer(UINT32), "numberOfFiles"), Out(Pointer(ObjPointer(IDWriteFontFile)), "fontFiles")]),
    StdMethod(UINT32, "GetIndex", []),
    StdMethod(DWRITE_FONT_SIMULATIONS, "GetSimulations", []),
    StdMethod(BOOL, "IsSymbolFont", []),
    StdMethod(Void, "GetMetrics", [Out(Pointer(DWRITE_FONT_METRICS), "fontFaceMetrics")]),
    StdMethod(UINT16, "GetGlyphCount", []),
    StdMethod(HRESULT, "GetDesignGlyphMetrics", [(Pointer(Const(UINT16)), "glyphIndices"), (UINT32, "glyphCount"), Out(Pointer(DWRITE_GLYPH_METRICS), "glyphMetrics"), (BOOL, "isSideways")]),
    StdMethod(HRESULT, "GetGlyphIndices", [(Pointer(Const(UINT32)), "codePoints"), (UINT32, "codePointCount"), Out(Pointer(UINT16), "glyphIndices")]),
    StdMethod(HRESULT, "TryGetFontTable", [(UINT32, "openTypeTableTag"), Out(Pointer(OpaquePointer(Const(Void))), "tableData"), Out(Pointer(UINT32), "tableSize"), Out(Pointer(OpaquePointer(Void)), "tableContext"), Out(Pointer(BOOL), "exists")]),
    StdMethod(Void, "ReleaseFontTable", [(OpaquePointer(Void), "tableContext")]),
    StdMethod(HRESULT, "GetGlyphRunOutline", [(FLOAT, "emSize"), (Pointer(Const(UINT16)), "glyphIndices"), (Pointer(Const(FLOAT)), "glyphAdvances"), (Pointer(Const(DWRITE_GLYPH_OFFSET)), "glyphOffsets"), (UINT32, "glyphCount"), (BOOL, "isSideways"), (BOOL, "isRightToLeft"), (ObjPointer(IDWriteGeometrySink), "geometrySink")]),
    StdMethod(HRESULT, "GetRecommendedRenderingMode", [(FLOAT, "emSize"), (FLOAT, "pixelsPerDip"), (DWRITE_MEASURING_MODE, "measuringMode"), (ObjPointer(IDWriteRenderingParams), "renderingParams"), Out(Pointer(DWRITE_RENDERING_MODE), "renderingMode")]),
    StdMethod(HRESULT, "GetGdiCompatibleMetrics", [(FLOAT, "emSize"), (FLOAT, "pixelsPerDip"), (Pointer(Const(DWRITE_MATRIX)), "transform"), Out(Pointer(DWRITE_FONT_METRICS), "fontFaceMetrics")]),
    StdMethod(HRESULT, "GetGdiCompatibleGlyphMetrics", [(FLOAT, "emSize"), (FLOAT, "pixelsPerDip"), (Pointer(Const(DWRITE_MATRIX)), "transform"), (BOOL, "useGdiNatural"), (Array(Const(UINT16), "glyphCount"), "glyphIndices"), (UINT32, "glyphCount"), Out(Array(DWRITE_GLYPH_METRICS, "glyphCount"), "glyphMetrics"), (BOOL, "isSideways")]),
]

IDWriteFontCollectionLoader.methods += [
    StdMethod(HRESULT, "CreateEnumeratorFromKey", [(ObjPointer(IDWriteFactory), "factory"), (OpaquePointer(Const(Void)), "collectionKey"), (UINT32, "collectionKeySize"), Out(Pointer(ObjPointer(IDWriteFontFileEnumerator)), "fontFileEnumerator")]),
]

IDWriteFontFileEnumerator.methods += [
    StdMethod(HRESULT, "MoveNext", [Out(Pointer(BOOL), "hasCurrentFile")]),
    StdMethod(HRESULT, "GetCurrentFontFile", [Out(Pointer(ObjPointer(IDWriteFontFile)), "fontFile")]),
]

IDWriteLocalizedStrings.methods += [
    StdMethod(UINT32, "GetCount", []),
    StdMethod(HRESULT, "FindLocaleName", [(Pointer(Const(WCHAR)), "localeName"), Out(Pointer(UINT32), "index"), Out(Pointer(BOOL), "exists")]),
    StdMethod(HRESULT, "GetLocaleNameLength", [(UINT32, "index"), Out(Pointer(UINT32), "length")]),
    StdMethod(HRESULT, "GetLocaleName", [(UINT32, "index"), Out(Pointer(WCHAR), "localeName"), (UINT32, "size")]),
    StdMethod(HRESULT, "GetStringLength", [(UINT32, "index"), Out(Pointer(UINT32), "length")]),
    StdMethod(HRESULT, "GetString", [(UINT32, "index"), Out(Pointer(WCHAR), "stringBuffer"), (UINT32, "size")]),
]

IDWriteFontCollection.methods += [
    StdMethod(UINT32, "GetFontFamilyCount", []),
    StdMethod(HRESULT, "GetFontFamily", [(UINT32, "index"), Out(Pointer(ObjPointer(IDWriteFontFamily)), "fontFamily")]),
    StdMethod(HRESULT, "FindFamilyName", [(Pointer(Const(WCHAR)), "familyName"), Out(Pointer(UINT32), "index"), Out(Pointer(BOOL), "exists")]),
    StdMethod(HRESULT, "GetFontFromFontFace", [(ObjPointer(IDWriteFontFace), "fontFace"), Out(Pointer(ObjPointer(IDWriteFont)), "font")]),
]

IDWriteFontList.methods += [
    StdMethod(HRESULT, "GetFontCollection", [Out(Pointer(ObjPointer(IDWriteFontCollection)), "fontCollection")]),
    StdMethod(UINT32, "GetFontCount", []),
    StdMethod(HRESULT, "GetFont", [(UINT32, "index"), Out(Pointer(ObjPointer(IDWriteFont)), "font")]),
]

IDWriteFontFamily.methods += [
    StdMethod(HRESULT, "GetFamilyNames", [Out(Pointer(ObjPointer(IDWriteLocalizedStrings)), "names")]),
    StdMethod(HRESULT, "GetFirstMatchingFont", [(DWRITE_FONT_WEIGHT, "weight"), (DWRITE_FONT_STRETCH, "stretch"), (DWRITE_FONT_STYLE, "style"), Out(Pointer(ObjPointer(IDWriteFont)), "matchingFont")]),
    StdMethod(HRESULT, "GetMatchingFonts", [(DWRITE_FONT_WEIGHT, "weight"), (DWRITE_FONT_STRETCH, "stretch"), (DWRITE_FONT_STYLE, "style"), Out(Pointer(ObjPointer(IDWriteFontList)), "matchingFonts")]),
]

IDWriteFont.methods += [
    StdMethod(HRESULT, "GetFontFamily", [Out(Pointer(ObjPointer(IDWriteFontFamily)), "fontFamily")]),
    StdMethod(DWRITE_FONT_WEIGHT, "GetWeight", []),
    StdMethod(DWRITE_FONT_STRETCH, "GetStretch", []),
    StdMethod(DWRITE_FONT_STYLE, "GetStyle", []),
    StdMethod(BOOL, "IsSymbolFont", []),
    StdMethod(HRESULT, "GetFaceNames", [Out(Pointer(ObjPointer(IDWriteLocalizedStrings)), "names")]),
    StdMethod(HRESULT, "GetInformationalStrings", [(DWRITE_INFORMATIONAL_STRING_ID, "informationalStringID"), Out(Pointer(ObjPointer(IDWriteLocalizedStrings)), "informationalStrings"), Out(Pointer(BOOL), "exists")]),
    StdMethod(DWRITE_FONT_SIMULATIONS, "GetSimulations", []),
    StdMethod(Void, "GetMetrics", [Out(Pointer(DWRITE_FONT_METRICS), "fontMetrics")]),
    StdMethod(HRESULT, "HasCharacter", [(UINT32, "unicodeValue"), Out(Pointer(BOOL), "exists")]),
    StdMethod(HRESULT, "CreateFontFace", [Out(Pointer(ObjPointer(IDWriteFontFace)), "fontFace")]),
]

DWRITE_READING_DIRECTION = Enum("DWRITE_READING_DIRECTION", [
    "DWRITE_READING_DIRECTION_LEFT_TO_RIGHT",
    "DWRITE_READING_DIRECTION_RIGHT_TO_LEFT",
])

DWRITE_FLOW_DIRECTION = Enum("DWRITE_FLOW_DIRECTION", [
    "DWRITE_FLOW_DIRECTION_TOP_TO_BOTTOM",
])

DWRITE_TEXT_ALIGNMENT = Enum("DWRITE_TEXT_ALIGNMENT", [
    "DWRITE_TEXT_ALIGNMENT_LEADING",
    "DWRITE_TEXT_ALIGNMENT_TRAILING",
    "DWRITE_TEXT_ALIGNMENT_CENTER",
])

DWRITE_PARAGRAPH_ALIGNMENT = Enum("DWRITE_PARAGRAPH_ALIGNMENT", [
    "DWRITE_PARAGRAPH_ALIGNMENT_NEAR",
    "DWRITE_PARAGRAPH_ALIGNMENT_FAR",
    "DWRITE_PARAGRAPH_ALIGNMENT_CENTER",
])

DWRITE_WORD_WRAPPING = Enum("DWRITE_WORD_WRAPPING", [
    "DWRITE_WORD_WRAPPING_WRAP",
    "DWRITE_WORD_WRAPPING_NO_WRAP",
])

DWRITE_LINE_SPACING_METHOD = Enum("DWRITE_LINE_SPACING_METHOD", [
    "DWRITE_LINE_SPACING_METHOD_DEFAULT",
    "DWRITE_LINE_SPACING_METHOD_UNIFORM",
])

DWRITE_TRIMMING_GRANULARITY = Enum("DWRITE_TRIMMING_GRANULARITY", [
    "DWRITE_TRIMMING_GRANULARITY_NONE",
    "DWRITE_TRIMMING_GRANULARITY_CHARACTER",
    "DWRITE_TRIMMING_GRANULARITY_WORD",
])

DWRITE_FONT_FEATURE_TAG = Enum("DWRITE_FONT_FEATURE_TAG", [
    "DWRITE_FONT_FEATURE_TAG_ALTERNATIVE_FRACTIONS",
    "DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS_FROM_CAPITALS",
    "DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS_FROM_CAPITALS",
    "DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_ALTERNATES",
    "DWRITE_FONT_FEATURE_TAG_CASE_SENSITIVE_FORMS",
    "DWRITE_FONT_FEATURE_TAG_GLYPH_COMPOSITION_DECOMPOSITION",
    "DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_LIGATURES",
    "DWRITE_FONT_FEATURE_TAG_CAPITAL_SPACING",
    "DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_SWASH",
    "DWRITE_FONT_FEATURE_TAG_CURSIVE_POSITIONING",
    "DWRITE_FONT_FEATURE_TAG_DEFAULT",
    "DWRITE_FONT_FEATURE_TAG_DISCRETIONARY_LIGATURES",
    "DWRITE_FONT_FEATURE_TAG_EXPERT_FORMS",
    "DWRITE_FONT_FEATURE_TAG_FRACTIONS",
    "DWRITE_FONT_FEATURE_TAG_FULL_WIDTH",
    "DWRITE_FONT_FEATURE_TAG_HALF_FORMS",
    "DWRITE_FONT_FEATURE_TAG_HALANT_FORMS",
    "DWRITE_FONT_FEATURE_TAG_ALTERNATE_HALF_WIDTH",
    "DWRITE_FONT_FEATURE_TAG_HISTORICAL_FORMS",
    "DWRITE_FONT_FEATURE_TAG_HORIZONTAL_KANA_ALTERNATES",
    "DWRITE_FONT_FEATURE_TAG_HISTORICAL_LIGATURES",
    "DWRITE_FONT_FEATURE_TAG_HALF_WIDTH",
    "DWRITE_FONT_FEATURE_TAG_HOJO_KANJI_FORMS",
    "DWRITE_FONT_FEATURE_TAG_JIS04_FORMS",
    "DWRITE_FONT_FEATURE_TAG_JIS78_FORMS",
    "DWRITE_FONT_FEATURE_TAG_JIS83_FORMS",
    "DWRITE_FONT_FEATURE_TAG_JIS90_FORMS",
    "DWRITE_FONT_FEATURE_TAG_KERNING",
    "DWRITE_FONT_FEATURE_TAG_STANDARD_LIGATURES",
    "DWRITE_FONT_FEATURE_TAG_LINING_FIGURES",
    "DWRITE_FONT_FEATURE_TAG_LOCALIZED_FORMS",
    "DWRITE_FONT_FEATURE_TAG_MARK_POSITIONING",
    "DWRITE_FONT_FEATURE_TAG_MATHEMATICAL_GREEK",
    "DWRITE_FONT_FEATURE_TAG_MARK_TO_MARK_POSITIONING",
    "DWRITE_FONT_FEATURE_TAG_ALTERNATE_ANNOTATION_FORMS",
    "DWRITE_FONT_FEATURE_TAG_NLC_KANJI_FORMS",
    "DWRITE_FONT_FEATURE_TAG_OLD_STYLE_FIGURES",
    "DWRITE_FONT_FEATURE_TAG_ORDINALS",
    "DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_ALTERNATE_WIDTH",
    "DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS",
    "DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_FIGURES",
    "DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_WIDTHS",
    "DWRITE_FONT_FEATURE_TAG_QUARTER_WIDTHS",
    "DWRITE_FONT_FEATURE_TAG_REQUIRED_LIGATURES",
    "DWRITE_FONT_FEATURE_TAG_RUBY_NOTATION_FORMS",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_ALTERNATES",
    "DWRITE_FONT_FEATURE_TAG_SCIENTIFIC_INFERIORS",
    "DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS",
    "DWRITE_FONT_FEATURE_TAG_SIMPLIFIED_FORMS",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_2",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_3",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_4",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_5",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_6",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_7",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_8",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_9",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_10",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_11",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_12",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_13",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_14",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_15",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_16",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_17",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_18",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_19",
    "DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_20",
    "DWRITE_FONT_FEATURE_TAG_SUBSCRIPT",
    "DWRITE_FONT_FEATURE_TAG_SUPERSCRIPT",
    "DWRITE_FONT_FEATURE_TAG_SWASH",
    "DWRITE_FONT_FEATURE_TAG_TITLING",
    "DWRITE_FONT_FEATURE_TAG_TRADITIONAL_NAME_FORMS",
    "DWRITE_FONT_FEATURE_TAG_TABULAR_FIGURES",
    "DWRITE_FONT_FEATURE_TAG_TRADITIONAL_FORMS",
    "DWRITE_FONT_FEATURE_TAG_THIRD_WIDTHS",
    "DWRITE_FONT_FEATURE_TAG_UNICASE",
    "DWRITE_FONT_FEATURE_TAG_SLASHED_ZERO",
])

DWRITE_TEXT_RANGE = Struct("DWRITE_TEXT_RANGE", [
    (UINT32, "startPosition"),
    (UINT32, "length"),
])

DWRITE_FONT_FEATURE = Struct("DWRITE_FONT_FEATURE", [
    (DWRITE_FONT_FEATURE_TAG, "nameTag"),
    (UINT32, "parameter"),
])

DWRITE_TYPOGRAPHIC_FEATURES = Struct("DWRITE_TYPOGRAPHIC_FEATURES", [
    (OpaquePointer(DWRITE_FONT_FEATURE), "features"),
    (UINT32, "featureCount"),
])

DWRITE_TRIMMING = Struct("DWRITE_TRIMMING", [
    (DWRITE_TRIMMING_GRANULARITY, "granularity"),
    (UINT32, "delimiter"),
    (UINT32, "delimiterCount"),
])

IDWriteTextFormat.methods += [
    StdMethod(HRESULT, "SetTextAlignment", [(DWRITE_TEXT_ALIGNMENT, "textAlignment")]),
    StdMethod(HRESULT, "SetParagraphAlignment", [(DWRITE_PARAGRAPH_ALIGNMENT, "paragraphAlignment")]),
    StdMethod(HRESULT, "SetWordWrapping", [(DWRITE_WORD_WRAPPING, "wordWrapping")]),
    StdMethod(HRESULT, "SetReadingDirection", [(DWRITE_READING_DIRECTION, "readingDirection")]),
    StdMethod(HRESULT, "SetFlowDirection", [(DWRITE_FLOW_DIRECTION, "flowDirection")]),
    StdMethod(HRESULT, "SetIncrementalTabStop", [(FLOAT, "incrementalTabStop")]),
    StdMethod(HRESULT, "SetTrimming", [(Pointer(Const(DWRITE_TRIMMING)), "trimmingOptions"), (OpaquePointer(IDWriteInlineObject), "trimmingSign")]),
    StdMethod(HRESULT, "SetLineSpacing", [(DWRITE_LINE_SPACING_METHOD, "lineSpacingMethod"), (FLOAT, "lineSpacing"), (FLOAT, "baseline")]),
    StdMethod(DWRITE_TEXT_ALIGNMENT, "GetTextAlignment", []),
    StdMethod(DWRITE_PARAGRAPH_ALIGNMENT, "GetParagraphAlignment", []),
    StdMethod(DWRITE_WORD_WRAPPING, "GetWordWrapping", []),
    StdMethod(DWRITE_READING_DIRECTION, "GetReadingDirection", []),
    StdMethod(DWRITE_FLOW_DIRECTION, "GetFlowDirection", []),
    StdMethod(FLOAT, "GetIncrementalTabStop", []),
    StdMethod(HRESULT, "GetTrimming", [Out(Pointer(DWRITE_TRIMMING), "trimmingOptions"), Out(Pointer(OpaquePointer(IDWriteInlineObject)), "trimmingSign")]),
    StdMethod(HRESULT, "GetLineSpacing", [Out(Pointer(DWRITE_LINE_SPACING_METHOD), "lineSpacingMethod"), Out(Pointer(FLOAT), "lineSpacing"), Out(Pointer(FLOAT), "baseline")]),
    StdMethod(HRESULT, "GetFontCollection", [Out(Pointer(ObjPointer(IDWriteFontCollection)), "fontCollection")]),
    StdMethod(UINT32, "GetFontFamilyNameLength", []),
    StdMethod(HRESULT, "GetFontFamilyName", [Out(Pointer(WCHAR), "fontFamilyName"), (UINT32, "nameSize")]),
    StdMethod(DWRITE_FONT_WEIGHT, "GetFontWeight", []),
    StdMethod(DWRITE_FONT_STYLE, "GetFontStyle", []),
    StdMethod(DWRITE_FONT_STRETCH, "GetFontStretch", []),
    StdMethod(FLOAT, "GetFontSize", []),
    StdMethod(UINT32, "GetLocaleNameLength", []),
    StdMethod(HRESULT, "GetLocaleName", [Out(Pointer(WCHAR), "localeName"), (UINT32, "nameSize")]),
]

IDWriteTypography.methods += [
    StdMethod(HRESULT, "AddFontFeature", [(DWRITE_FONT_FEATURE, "fontFeature")]),
    StdMethod(UINT32, "GetFontFeatureCount", []),
    StdMethod(HRESULT, "GetFontFeature", [(UINT32, "fontFeatureIndex"), Out(Pointer(DWRITE_FONT_FEATURE), "fontFeature")]),
]

DWRITE_SCRIPT_SHAPES = EnumFlag("DWRITE_SCRIPT_SHAPES", [
    "DWRITE_SCRIPT_SHAPES_DEFAULT",
    "DWRITE_SCRIPT_SHAPES_NO_VISUAL",
])

DWRITE_SCRIPT_ANALYSIS = Struct("DWRITE_SCRIPT_ANALYSIS", [
    (UINT16, "script"),
    (DWRITE_SCRIPT_SHAPES, "shapes"),
])

DWRITE_BREAK_CONDITION = Enum("DWRITE_BREAK_CONDITION", [
    "DWRITE_BREAK_CONDITION_NEUTRAL",
    "DWRITE_BREAK_CONDITION_CAN_BREAK",
    "DWRITE_BREAK_CONDITION_MAY_NOT_BREAK",
    "DWRITE_BREAK_CONDITION_MUST_BREAK",
])

DWRITE_LINE_BREAKPOINT = Struct("DWRITE_LINE_BREAKPOINT", [
    (UINT8, "breakConditionBefore"),
    (UINT8, "breakConditionAfter"),
    (UINT8, "isWhitespace"),
    (UINT8, "isSoftHyphen"),
    (UINT8, "padding"),
])

DWRITE_NUMBER_SUBSTITUTION_METHOD = Enum("DWRITE_NUMBER_SUBSTITUTION_METHOD", [
    "DWRITE_NUMBER_SUBSTITUTION_METHOD_FROM_CULTURE",
    "DWRITE_NUMBER_SUBSTITUTION_METHOD_CONTEXTUAL",
    "DWRITE_NUMBER_SUBSTITUTION_METHOD_NONE",
    "DWRITE_NUMBER_SUBSTITUTION_METHOD_NATIONAL",
    "DWRITE_NUMBER_SUBSTITUTION_METHOD_TRADITIONAL",
])

IDWriteNumberSubstitution.methods += [
]

DWRITE_SHAPING_TEXT_PROPERTIES = Struct("DWRITE_SHAPING_TEXT_PROPERTIES", [
    (UINT16, "isShapedAlone"),
    (UINT16, "reserved"),
])

DWRITE_SHAPING_GLYPH_PROPERTIES = Struct("DWRITE_SHAPING_GLYPH_PROPERTIES", [
    (UINT16, "justification"),
    (UINT16, "isClusterStart"),
    (UINT16, "isDiacritic"),
    (UINT16, "isZeroWidthSpace"),
    (UINT16, "reserved"),
])

IDWriteTextAnalysisSource.methods += [
    StdMethod(HRESULT, "GetTextAtPosition", [(UINT32, "textPosition"), Out(Pointer(Pointer(Const(WCHAR))), "textString"), Out(Pointer(UINT32), "textLength")]),
    StdMethod(HRESULT, "GetTextBeforePosition", [(UINT32, "textPosition"), Out(Pointer(Pointer(Const(WCHAR))), "textString"), Out(Pointer(UINT32), "textLength")]),
    StdMethod(DWRITE_READING_DIRECTION, "GetParagraphReadingDirection", []),
    StdMethod(HRESULT, "GetLocaleName", [(UINT32, "textPosition"), Out(Pointer(UINT32), "textLength"), Out(Pointer(Pointer(Const(WCHAR))), "localeName")]),
    StdMethod(HRESULT, "GetNumberSubstitution", [(UINT32, "textPosition"), Out(Pointer(UINT32), "textLength"), Out(Pointer(ObjPointer(IDWriteNumberSubstitution)), "numberSubstitution")]),
]

IDWriteTextAnalysisSink.methods += [
    StdMethod(HRESULT, "SetScriptAnalysis", [(UINT32, "textPosition"), (UINT32, "textLength"), (Pointer(Const(DWRITE_SCRIPT_ANALYSIS)), "scriptAnalysis")]),
    StdMethod(HRESULT, "SetLineBreakpoints", [(UINT32, "textPosition"), (UINT32, "textLength"), (Pointer(Const(DWRITE_LINE_BREAKPOINT)), "lineBreakpoints")]),
    StdMethod(HRESULT, "SetBidiLevel", [(UINT32, "textPosition"), (UINT32, "textLength"), (UINT8, "explicitLevel"), (UINT8, "resolvedLevel")]),
    StdMethod(HRESULT, "SetNumberSubstitution", [(UINT32, "textPosition"), (UINT32, "textLength"), (ObjPointer(IDWriteNumberSubstitution), "numberSubstitution")]),
]

IDWriteTextAnalyzer.methods += [
    StdMethod(HRESULT, "AnalyzeScript", [(ObjPointer(IDWriteTextAnalysisSource), "analysisSource"), (UINT32, "textPosition"), (UINT32, "textLength"), (ObjPointer(IDWriteTextAnalysisSink), "analysisSink")]),
    StdMethod(HRESULT, "AnalyzeBidi", [(ObjPointer(IDWriteTextAnalysisSource), "analysisSource"), (UINT32, "textPosition"), (UINT32, "textLength"), (ObjPointer(IDWriteTextAnalysisSink), "analysisSink")]),
    StdMethod(HRESULT, "AnalyzeNumberSubstitution", [(ObjPointer(IDWriteTextAnalysisSource), "analysisSource"), (UINT32, "textPosition"), (UINT32, "textLength"), (ObjPointer(IDWriteTextAnalysisSink), "analysisSink")]),
    StdMethod(HRESULT, "AnalyzeLineBreakpoints", [(ObjPointer(IDWriteTextAnalysisSource), "analysisSource"), (UINT32, "textPosition"), (UINT32, "textLength"), (ObjPointer(IDWriteTextAnalysisSink), "analysisSink")]),
    StdMethod(HRESULT, "GetGlyphs", [(Pointer(Const(WCHAR)), "textString"), (UINT32, "textLength"), (ObjPointer(IDWriteFontFace), "fontFace"), (BOOL, "isSideways"), (BOOL, "isRightToLeft"), (Pointer(Const(DWRITE_SCRIPT_ANALYSIS)), "scriptAnalysis"), (Pointer(Const(WCHAR)), "localeName"), (ObjPointer(IDWriteNumberSubstitution), "numberSubstitution"), (OpaquePointer(Pointer(Const(DWRITE_TYPOGRAPHIC_FEATURES))), "features"), (Pointer(Const(UINT32)), "featureRangeLengths"), (UINT32, "featureRanges"), (UINT32, "maxGlyphCount"), Out(Pointer(UINT16), "clusterMap"), Out(Pointer(DWRITE_SHAPING_TEXT_PROPERTIES), "textProps"), Out(Pointer(UINT16), "glyphIndices"), Out(Pointer(DWRITE_SHAPING_GLYPH_PROPERTIES), "glyphProps"), Out(Pointer(UINT32), "actualGlyphCount")]),
    StdMethod(HRESULT, "GetGlyphPlacements", [(Array(Const(WCHAR), "textLength"), "textString"), (Array(Const(UINT16), "textLength"), "clusterMap"), (Array(DWRITE_SHAPING_TEXT_PROPERTIES, "textLength"), "textProps"), (UINT32, "textLength"), (Array(Const(UINT16), "glyphCount"), "glyphIndices"), (Array(Const(DWRITE_SHAPING_GLYPH_PROPERTIES), "glyphCount"), "glyphProps"), (UINT32, "glyphCount"), (ObjPointer(IDWriteFontFace), "fontFace"), (FLOAT, "fontEmSize"), (BOOL, "isSideways"), (BOOL, "isRightToLeft"), (Pointer(Const(DWRITE_SCRIPT_ANALYSIS)), "scriptAnalysis"), (LPCWSTR, "localeName"), (Array(Pointer(Const(DWRITE_TYPOGRAPHIC_FEATURES)), "featureRanges"), "features"), (Array(Const(UINT32), "featureRanges"), "featureRangeLengths"), (UINT32, "featureRanges"), Out(Array(FLOAT, "glyphCount"), "glyphAdvances"), Out(Array(DWRITE_GLYPH_OFFSET, "glyphCount"), "glyphOffsets")]), 
    StdMethod(HRESULT, "GetGdiCompatibleGlyphPlacements", [(Array(Const(WCHAR), "textLength"), "textString"), (Array(Const(UINT16), "textLength"), "clusterMap"), (Array(DWRITE_SHAPING_TEXT_PROPERTIES, "textLength"), "textProps"), (UINT32, "textLength"), (Array(Const(UINT16), "glyphCount"), "glyphIndices"), (Array(Const(DWRITE_SHAPING_GLYPH_PROPERTIES), "glyphCount"), "glyphProps"), (UINT32, "glyphCount"), (ObjPointer(IDWriteFontFace), "fontFace"), (FLOAT, "fontEmSize"), (FLOAT, "pixelsPerDip"), (Pointer(Const(DWRITE_MATRIX)), "transform"), (BOOL, "useGdiNatural"), (BOOL, "isSideways"), (BOOL, "isRightToLeft"), (Pointer(Const(DWRITE_SCRIPT_ANALYSIS)), "scriptAnalysis"), (LPCWSTR, "localeName"), (Array(Pointer(Const(DWRITE_TYPOGRAPHIC_FEATURES)), "featureRanges"), "features"), (Array(Const(UINT32), "featureRanges"), "featureRangeLengths"), (UINT32, "featureRanges"), Out(Array(FLOAT, "glyphCount"), "glyphAdvances"), Out(Array(DWRITE_GLYPH_OFFSET, "glyphCount"), "glyphOffsets")]),
]

DWRITE_GLYPH_RUN = Struct("DWRITE_GLYPH_RUN", [
    (ObjPointer(IDWriteFontFace), "fontFace"),
    (FLOAT, "fontEmSize"),
    (UINT32, "glyphCount"),
    (Pointer(Const(UINT16)), "glyphIndices"),
    (Pointer(Const(FLOAT)), "glyphAdvances"),
    (Pointer(Const(DWRITE_GLYPH_OFFSET)), "glyphOffsets"),
    (BOOL, "isSideways"),
    (UINT32, "bidiLevel"),
])

DWRITE_GLYPH_RUN_DESCRIPTION = Struct("DWRITE_GLYPH_RUN_DESCRIPTION", [
    (Pointer(Const(WCHAR)), "localeName"),
    (Pointer(Const(WCHAR)), "string"),
    (UINT32, "stringLength"),
    (Pointer(Const(UINT16)), "clusterMap"),
    (UINT32, "textPosition"),
])

DWRITE_UNDERLINE = Struct("DWRITE_UNDERLINE", [
    (FLOAT, "width"),
    (FLOAT, "thickness"),
    (FLOAT, "offset"),
    (FLOAT, "runHeight"),
    (DWRITE_READING_DIRECTION, "readingDirection"),
    (DWRITE_FLOW_DIRECTION, "flowDirection"),
    (Pointer(Const(WCHAR)), "localeName"),
    (DWRITE_MEASURING_MODE, "measuringMode"),
])

DWRITE_STRIKETHROUGH = Struct("DWRITE_STRIKETHROUGH", [
    (FLOAT, "width"),
    (FLOAT, "thickness"),
    (FLOAT, "offset"),
    (DWRITE_READING_DIRECTION, "readingDirection"),
    (DWRITE_FLOW_DIRECTION, "flowDirection"),
    (Pointer(Const(WCHAR)), "localeName"),
    (DWRITE_MEASURING_MODE, "measuringMode"),
])

DWRITE_LINE_METRICS = Struct("DWRITE_LINE_METRICS", [
    (UINT32, "length"),
    (UINT32, "trailingWhitespaceLength"),
    (UINT32, "newlineLength"),
    (FLOAT, "height"),
    (FLOAT, "baseline"),
    (BOOL, "isTrimmed"),
])

DWRITE_CLUSTER_METRICS = Struct("DWRITE_CLUSTER_METRICS", [
    (FLOAT, "width"),
    (UINT16, "length"),
    (UINT16, "canWrapLineAfter"),
    (UINT16, "isWhitespace"),
    (UINT16, "isNewline"),
    (UINT16, "isSoftHyphen"),
    (UINT16, "isRightToLeft"),
    (UINT16, "padding"),
])

DWRITE_TEXT_METRICS = Struct("DWRITE_TEXT_METRICS", [
    (FLOAT, "left"),
    (FLOAT, "top"),
    (FLOAT, "width"),
    (FLOAT, "widthIncludingTrailingWhitespace"),
    (FLOAT, "height"),
    (FLOAT, "layoutWidth"),
    (FLOAT, "layoutHeight"),
    (UINT32, "maxBidiReorderingDepth"),
    (UINT32, "lineCount"),
])

DWRITE_INLINE_OBJECT_METRICS = Struct("DWRITE_INLINE_OBJECT_METRICS", [
    (FLOAT, "width"),
    (FLOAT, "height"),
    (FLOAT, "baseline"),
    (BOOL, "supportsSideways"),
])

DWRITE_OVERHANG_METRICS = Struct("DWRITE_OVERHANG_METRICS", [
    (FLOAT, "left"),
    (FLOAT, "top"),
    (FLOAT, "right"),
    (FLOAT, "bottom"),
])

DWRITE_HIT_TEST_METRICS = Struct("DWRITE_HIT_TEST_METRICS", [
    (UINT32, "textPosition"),
    (UINT32, "length"),
    (FLOAT, "left"),
    (FLOAT, "top"),
    (FLOAT, "width"),
    (FLOAT, "height"),
    (UINT32, "bidiLevel"),
    (BOOL, "isText"),
    (BOOL, "isTrimmed"),
])

IDWriteInlineObject.methods += [
    StdMethod(HRESULT, "Draw", [(OpaquePointer(Void), "clientDrawingContext"), (OpaquePointer(IDWriteTextRenderer), "renderer"), (FLOAT, "originX"), (FLOAT, "originY"), (BOOL, "isSideways"), (BOOL, "isRightToLeft"), (ObjPointer(IUnknown), "clientDrawingEffect")]),
    StdMethod(HRESULT, "GetMetrics", [Out(Pointer(DWRITE_INLINE_OBJECT_METRICS), "metrics")]),
    StdMethod(HRESULT, "GetOverhangMetrics", [Out(Pointer(DWRITE_OVERHANG_METRICS), "overhangs")]),
    StdMethod(HRESULT, "GetBreakConditions", [Out(Pointer(DWRITE_BREAK_CONDITION), "breakConditionBefore"), Out(Pointer(DWRITE_BREAK_CONDITION), "breakConditionAfter")]),
]

IDWritePixelSnapping.methods += [
    StdMethod(HRESULT, "IsPixelSnappingDisabled", [(OpaquePointer(Void), "clientDrawingContext"), Out(Pointer(BOOL), "isDisabled")]),
    StdMethod(HRESULT, "GetCurrentTransform", [(OpaquePointer(Void), "clientDrawingContext"), Out(Pointer(DWRITE_MATRIX), "transform")]),
    StdMethod(HRESULT, "GetPixelsPerDip", [(OpaquePointer(Void), "clientDrawingContext"), Out(Pointer(FLOAT), "pixelsPerDip")]),
]

IDWriteTextRenderer.methods += [
    StdMethod(HRESULT, "DrawGlyphRun", [(OpaquePointer(Void), "clientDrawingContext"), (FLOAT, "baselineOriginX"), (FLOAT, "baselineOriginY"), (DWRITE_MEASURING_MODE, "measuringMode"), (Pointer(Const(DWRITE_GLYPH_RUN)), "glyphRun"), (Pointer(Const(DWRITE_GLYPH_RUN_DESCRIPTION)), "glyphRunDescription"), (ObjPointer(IUnknown), "clientDrawingEffect")]),
    StdMethod(HRESULT, "DrawUnderline", [(OpaquePointer(Void), "clientDrawingContext"), (FLOAT, "baselineOriginX"), (FLOAT, "baselineOriginY"), (Pointer(Const(DWRITE_UNDERLINE)), "underline"), (ObjPointer(IUnknown), "clientDrawingEffect")]),
    StdMethod(HRESULT, "DrawStrikethrough", [(OpaquePointer(Void), "clientDrawingContext"), (FLOAT, "baselineOriginX"), (FLOAT, "baselineOriginY"), (Pointer(Const(DWRITE_STRIKETHROUGH)), "strikethrough"), (ObjPointer(IUnknown), "clientDrawingEffect")]),
    StdMethod(HRESULT, "DrawInlineObject", [(OpaquePointer(Void), "clientDrawingContext"), (FLOAT, "originX"), (FLOAT, "originY"), (ObjPointer(IDWriteInlineObject), "inlineObject"), (BOOL, "isSideways"), (BOOL, "isRightToLeft"), (ObjPointer(IUnknown), "clientDrawingEffect")]),
]

IDWriteTextLayout.methods += [
    StdMethod(HRESULT, "SetMaxWidth", [(FLOAT, "maxWidth")]),
    StdMethod(HRESULT, "SetMaxHeight", [(FLOAT, "maxHeight")]),
    StdMethod(HRESULT, "SetFontCollection", [(ObjPointer(IDWriteFontCollection), "fontCollection"), (DWRITE_TEXT_RANGE, "textRange")]),
    StdMethod(HRESULT, "SetFontFamilyName", [(Pointer(Const(WCHAR)), "fontFamilyName"), (DWRITE_TEXT_RANGE, "textRange")]),
    StdMethod(HRESULT, "SetFontWeight", [(DWRITE_FONT_WEIGHT, "fontWeight"), (DWRITE_TEXT_RANGE, "textRange")]),
    StdMethod(HRESULT, "SetFontStyle", [(DWRITE_FONT_STYLE, "fontStyle"), (DWRITE_TEXT_RANGE, "textRange")]),
    StdMethod(HRESULT, "SetFontStretch", [(DWRITE_FONT_STRETCH, "fontStretch"), (DWRITE_TEXT_RANGE, "textRange")]),
    StdMethod(HRESULT, "SetFontSize", [(FLOAT, "fontSize"), (DWRITE_TEXT_RANGE, "textRange")]),
    StdMethod(HRESULT, "SetUnderline", [(BOOL, "hasUnderline"), (DWRITE_TEXT_RANGE, "textRange")]),
    StdMethod(HRESULT, "SetStrikethrough", [(BOOL, "hasStrikethrough"), (DWRITE_TEXT_RANGE, "textRange")]),
    StdMethod(HRESULT, "SetDrawingEffect", [(ObjPointer(IUnknown), "drawingEffect"), (DWRITE_TEXT_RANGE, "textRange")]),
    StdMethod(HRESULT, "SetInlineObject", [(ObjPointer(IDWriteInlineObject), "inlineObject"), (DWRITE_TEXT_RANGE, "textRange")]),
    StdMethod(HRESULT, "SetTypography", [(ObjPointer(IDWriteTypography), "typography"), (DWRITE_TEXT_RANGE, "textRange")]),
    StdMethod(HRESULT, "SetLocaleName", [(Pointer(Const(WCHAR)), "localeName"), (DWRITE_TEXT_RANGE, "textRange")]),
    StdMethod(FLOAT, "GetMaxWidth", []),
    StdMethod(FLOAT, "GetMaxHeight", []),
    StdMethod(HRESULT, "GetFontCollection", [(UINT32, "currentPosition"), Out(Pointer(ObjPointer(IDWriteFontCollection)), "fontCollection"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "GetFontFamilyNameLength", [(UINT32, "currentPosition"), Out(Pointer(UINT32), "nameLength"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "GetFontFamilyName", [(UINT32, "currentPosition"), Out(Pointer(WCHAR), "fontFamilyName"), (UINT32, "nameSize"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "GetFontWeight", [(UINT32, "currentPosition"), Out(Pointer(DWRITE_FONT_WEIGHT), "fontWeight"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "GetFontStyle", [(UINT32, "currentPosition"), Out(Pointer(DWRITE_FONT_STYLE), "fontStyle"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "GetFontStretch", [(UINT32, "currentPosition"), Out(Pointer(DWRITE_FONT_STRETCH), "fontStretch"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "GetFontSize", [(UINT32, "currentPosition"), Out(Pointer(FLOAT), "fontSize"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "GetUnderline", [(UINT32, "currentPosition"), Out(Pointer(BOOL), "hasUnderline"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "GetStrikethrough", [(UINT32, "currentPosition"), Out(Pointer(BOOL), "hasStrikethrough"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "GetDrawingEffect", [(UINT32, "currentPosition"), Out(Pointer(ObjPointer(IUnknown)), "drawingEffect"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "GetInlineObject", [(UINT32, "currentPosition"), Out(Pointer(ObjPointer(IDWriteInlineObject)), "inlineObject"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "GetTypography", [(UINT32, "currentPosition"), Out(Pointer(ObjPointer(IDWriteTypography)), "typography"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "GetLocaleNameLength", [(UINT32, "currentPosition"), Out(Pointer(UINT32), "nameLength"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "GetLocaleName", [(UINT32, "currentPosition"), Out(Pointer(WCHAR), "localeName"), (UINT32, "nameSize"), Out(Pointer(DWRITE_TEXT_RANGE), "textRange")]),
    StdMethod(HRESULT, "Draw", [(OpaquePointer(Void), "clientDrawingContext"), (OpaquePointer(IDWriteTextRenderer), "renderer"), (FLOAT, "originX"), (FLOAT, "originY")]),
    StdMethod(HRESULT, "GetLineMetrics", [Out(Pointer(DWRITE_LINE_METRICS), "lineMetrics"), (UINT32, "maxLineCount"), Out(Pointer(UINT32), "actualLineCount")]),
    StdMethod(HRESULT, "GetMetrics", [Out(Pointer(DWRITE_TEXT_METRICS), "textMetrics")]),
    StdMethod(HRESULT, "GetOverhangMetrics", [Out(Pointer(DWRITE_OVERHANG_METRICS), "overhangs")]),
    StdMethod(HRESULT, "GetClusterMetrics", [Out(Pointer(DWRITE_CLUSTER_METRICS), "clusterMetrics"), (UINT32, "maxClusterCount"), Out(Pointer(UINT32), "actualClusterCount")]),
    StdMethod(HRESULT, "DetermineMinWidth", [Out(Pointer(FLOAT), "minWidth")]),
    StdMethod(HRESULT, "HitTestPoint", [(FLOAT, "pointX"), (FLOAT, "pointY"), Out(Pointer(BOOL), "isTrailingHit"), Out(Pointer(BOOL), "isInside"), Out(Pointer(DWRITE_HIT_TEST_METRICS), "hitTestMetrics")]),
    StdMethod(HRESULT, "HitTestTextPosition", [(UINT32, "textPosition"), (BOOL, "isTrailingHit"), Out(Pointer(FLOAT), "pointX"), Out(Pointer(FLOAT), "pointY"), Out(Pointer(DWRITE_HIT_TEST_METRICS), "hitTestMetrics")]),
    StdMethod(HRESULT, "HitTestTextRange", [(UINT32, "textPosition"), (UINT32, "textLength"), (FLOAT, "originX"), (FLOAT, "originY"), Out(Pointer(DWRITE_HIT_TEST_METRICS), "hitTestMetrics"), (UINT32, "maxHitTestMetricsCount"), Out(Pointer(UINT32), "actualHitTestMetricsCount")]),
]

IDWriteBitmapRenderTarget.methods += [
    StdMethod(HRESULT, "DrawGlyphRun", [(FLOAT, "baselineOriginX"), (FLOAT, "baselineOriginY"), (DWRITE_MEASURING_MODE, "measuringMode"), (Pointer(Const(DWRITE_GLYPH_RUN)), "glyphRun"), (ObjPointer(IDWriteRenderingParams), "renderingParams"), (COLORREF, "textColor"), Out(Pointer(RECT), "blackBoxRect")]),
    StdMethod(HDC, "GetMemoryDC", []),
    StdMethod(FLOAT, "GetPixelsPerDip", []),
    StdMethod(HRESULT, "SetPixelsPerDip", [(FLOAT, "pixelsPerDip")]),
    StdMethod(HRESULT, "GetCurrentTransform", [Out(Pointer(DWRITE_MATRIX), "transform")]),
    StdMethod(HRESULT, "SetCurrentTransform", [(Pointer(Const(DWRITE_MATRIX)), "transform")]),
    StdMethod(HRESULT, "GetSize", [Out(Pointer(SIZE), "size")]),
    StdMethod(HRESULT, "Resize", [(UINT32, "width"), (UINT32, "height")]),
]

IDWriteGdiInterop.methods += [
    StdMethod(HRESULT, "CreateFontFromLOGFONT", [(Pointer(Const(LOGFONTW)), "logFont"), Out(Pointer(ObjPointer(IDWriteFont)), "font")]),
    StdMethod(HRESULT, "ConvertFontToLOGFONT", [(ObjPointer(IDWriteFont), "font"), Out(Pointer(LOGFONTW), "logFont"), Out(Pointer(BOOL), "isSystemFont")]),
    StdMethod(HRESULT, "ConvertFontFaceToLOGFONT", [(ObjPointer(IDWriteFontFace), "font"), Out(Pointer(LOGFONTW), "logFont")]),
    StdMethod(HRESULT, "CreateFontFaceFromHdc", [(HDC, "hdc"), Out(Pointer(ObjPointer(IDWriteFontFace)), "fontFace")]),
    StdMethod(HRESULT, "CreateBitmapRenderTarget", [(HDC, "hdc"), (UINT32, "width"), (UINT32, "height"), Out(Pointer(ObjPointer(IDWriteBitmapRenderTarget)), "renderTarget")]),
]

DWRITE_TEXTURE_TYPE = Enum("DWRITE_TEXTURE_TYPE", [
    "DWRITE_TEXTURE_ALIASED_1x1",
    "DWRITE_TEXTURE_CLEARTYPE_3x1",
])

IDWriteGlyphRunAnalysis.methods += [
    StdMethod(HRESULT, "GetAlphaTextureBounds", [(DWRITE_TEXTURE_TYPE, "textureType"), Out(Pointer(RECT), "textureBounds")]),
    StdMethod(HRESULT, "CreateAlphaTexture", [(DWRITE_TEXTURE_TYPE, "textureType"), (Pointer(Const(RECT)), "textureBounds"), Out(Pointer(BYTE), "alphaValues"), (UINT32, "bufferSize")]),
    StdMethod(HRESULT, "GetAlphaBlendParams", [(ObjPointer(IDWriteRenderingParams), "renderingParams"), Out(Pointer(FLOAT), "blendGamma"), Out(Pointer(FLOAT), "blendEnhancedContrast"), Out(Pointer(FLOAT), "blendClearTypeLevel")]),
]

IDWriteFactory.methods += [
    StdMethod(HRESULT, "GetSystemFontCollection", [Out(Pointer(ObjPointer(IDWriteFontCollection)), "fontCollection"), (BOOL, "checkForUpdates")]),
    StdMethod(HRESULT, "CreateCustomFontCollection", [(ObjPointer(IDWriteFontCollectionLoader), "collectionLoader"), (OpaquePointer(Const(Void)), "collectionKey"), (UINT32, "collectionKeySize"), Out(Pointer(ObjPointer(IDWriteFontCollection)), "fontCollection")]),
    StdMethod(HRESULT, "RegisterFontCollectionLoader", [(ObjPointer(IDWriteFontCollectionLoader), "fontCollectionLoader")]),
    StdMethod(HRESULT, "UnregisterFontCollectionLoader", [(ObjPointer(IDWriteFontCollectionLoader), "fontCollectionLoader")]),
    StdMethod(HRESULT, "CreateFontFileReference", [(Pointer(Const(WCHAR)), "filePath"), (Pointer(Const(FILETIME)), "lastWriteTime"), Out(Pointer(ObjPointer(IDWriteFontFile)), "fontFile")]),
    StdMethod(HRESULT, "CreateCustomFontFileReference", [(OpaquePointer(Const(Void)), "fontFileReferenceKey"), (UINT32, "fontFileReferenceKeySize"), (ObjPointer(IDWriteFontFileLoader), "fontFileLoader"), Out(Pointer(ObjPointer(IDWriteFontFile)), "fontFile")]),
    StdMethod(HRESULT, "CreateFontFace", [(DWRITE_FONT_FACE_TYPE, "fontFaceType"), (UINT32, "numberOfFiles"), (Array(Const(ObjPointer(IDWriteFontFile)), "numberOfFiles"), "fontFiles"), (UINT32, "faceIndex"), (DWRITE_FONT_SIMULATIONS, "fontFaceSimulationFlags"), Out(Pointer(ObjPointer(IDWriteFontFace)), "fontFace")]),
    StdMethod(HRESULT, "CreateRenderingParams", [Out(Pointer(ObjPointer(IDWriteRenderingParams)), "renderingParams")]),
    StdMethod(HRESULT, "CreateMonitorRenderingParams", [(HMONITOR, "monitor"), Out(Pointer(ObjPointer(IDWriteRenderingParams)), "renderingParams")]),
    StdMethod(HRESULT, "CreateCustomRenderingParams", [(FLOAT, "gamma"), (FLOAT, "enhancedContrast"), (FLOAT, "clearTypeLevel"), (DWRITE_PIXEL_GEOMETRY, "pixelGeometry"), (DWRITE_RENDERING_MODE, "renderingMode"), Out(Pointer(ObjPointer(IDWriteRenderingParams)), "renderingParams")]),
    StdMethod(HRESULT, "RegisterFontFileLoader", [(ObjPointer(IDWriteFontFileLoader), "fontFileLoader")]),
    StdMethod(HRESULT, "UnregisterFontFileLoader", [(ObjPointer(IDWriteFontFileLoader), "fontFileLoader")]),
    StdMethod(HRESULT, "CreateTextFormat", [(Pointer(Const(WCHAR)), "fontFamilyName"), (ObjPointer(IDWriteFontCollection), "fontCollection"), (DWRITE_FONT_WEIGHT, "fontWeight"), (DWRITE_FONT_STYLE, "fontStyle"), (DWRITE_FONT_STRETCH, "fontStretch"), (FLOAT, "fontSize"), (Pointer(Const(WCHAR)), "localeName"), Out(Pointer(ObjPointer(IDWriteTextFormat)), "textFormat")]),
    StdMethod(HRESULT, "CreateTypography", [Out(Pointer(ObjPointer(IDWriteTypography)), "typography")]),
    StdMethod(HRESULT, "GetGdiInterop", [Out(Pointer(ObjPointer(IDWriteGdiInterop)), "gdiInterop")]),
    StdMethod(HRESULT, "CreateTextLayout", [(Pointer(Const(WCHAR)), "string"), (UINT32, "stringLength"), (ObjPointer(IDWriteTextFormat), "textFormat"), (FLOAT, "maxWidth"), (FLOAT, "maxHeight"), Out(Pointer(ObjPointer(IDWriteTextLayout)), "textLayout")]),
    StdMethod(HRESULT, "CreateGdiCompatibleTextLayout", [(Pointer(Const(WCHAR)), "string"), (UINT32, "stringLength"), (ObjPointer(IDWriteTextFormat), "textFormat"), (FLOAT, "layoutWidth"), (FLOAT, "layoutHeight"), (FLOAT, "pixelsPerDip"), (Pointer(Const(DWRITE_MATRIX)), "transform"), (BOOL, "useGdiNatural"), Out(Pointer(ObjPointer(IDWriteTextLayout)), "textLayout")]),
    StdMethod(HRESULT, "CreateEllipsisTrimmingSign", [(ObjPointer(IDWriteTextFormat), "textFormat"), Out(Pointer(ObjPointer(IDWriteInlineObject)), "trimmingSign")]),
    StdMethod(HRESULT, "CreateTextAnalyzer", [Out(Pointer(ObjPointer(IDWriteTextAnalyzer)), "textAnalyzer")]),
    StdMethod(HRESULT, "CreateNumberSubstitution", [(DWRITE_NUMBER_SUBSTITUTION_METHOD, "substitutionMethod"), (Pointer(Const(WCHAR)), "localeName"), (BOOL, "ignoreUserOverride"), Out(Pointer(ObjPointer(IDWriteNumberSubstitution)), "numberSubstitution")]),
    StdMethod(HRESULT, "CreateGlyphRunAnalysis", [(Pointer(Const(DWRITE_GLYPH_RUN)), "glyphRun"), (FLOAT, "pixelsPerDip"), (Pointer(Const(DWRITE_MATRIX)), "transform"), (DWRITE_RENDERING_MODE, "renderingMode"), (DWRITE_MEASURING_MODE, "measuringMode"), (FLOAT, "baselineOriginX"), (FLOAT, "baselineOriginY"), Out(Pointer(ObjPointer(IDWriteGlyphRunAnalysis)), "glyphRunAnalysis")]),
]

dwrite = Module("dwrite")
dwrite.addInterfaces([
    IDWriteFactory
])
dwrite.addFunctions([
    StdFunction(HRESULT, "DWriteCreateFactory", [(DWRITE_FACTORY_TYPE, "factoryType"), (REFIID, "iid"), Out(Pointer(ObjPointer(IUnknown)), "factory")]),
])

########NEW FILE########
__FILENAME__ = dxgi
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from dxgitype import *


IDXGIObject = Interface("IDXGIObject", IUnknown)
IDXGIDeviceSubObject = Interface("IDXGIDeviceSubObject", IDXGIObject)
IDXGIResource = Interface("IDXGIResource", IDXGIDeviceSubObject)
IDXGIKeyedMutex = Interface("IDXGIKeyedMutex", IDXGIDeviceSubObject)
IDXGISurface = Interface("IDXGISurface", IDXGIDeviceSubObject)
IDXGISurface1 = Interface("IDXGISurface1", IDXGISurface)
IDXGIAdapter = Interface("IDXGIAdapter", IDXGIObject)
IDXGIOutput = Interface("IDXGIOutput", IDXGIObject)
IDXGISwapChain = Interface("IDXGISwapChain", IDXGIDeviceSubObject)
IDXGIFactory = Interface("IDXGIFactory", IDXGIObject)
IDXGIDevice = Interface("IDXGIDevice", IDXGIObject)
IDXGIFactory1 = Interface("IDXGIFactory1", IDXGIFactory)
IDXGIAdapter1 = Interface("IDXGIAdapter1", IDXGIAdapter)
IDXGIDevice1 = Interface("IDXGIDevice1", IDXGIDevice)


DXGI_USAGE = Flags(UINT, [
    "DXGI_CPU_ACCESS_NONE", # 0
    "DXGI_CPU_ACCESS_SCRATCH", # 3
    "DXGI_CPU_ACCESS_DYNAMIC", # 1
    "DXGI_CPU_ACCESS_READ_WRITE", # 2
    "DXGI_USAGE_SHADER_INPUT",
    "DXGI_USAGE_RENDER_TARGET_OUTPUT",
    "DXGI_USAGE_BACK_BUFFER",
    "DXGI_USAGE_SHARED",
    "DXGI_USAGE_READ_ONLY",
    "DXGI_USAGE_DISCARD_ON_PRESENT",
    "DXGI_USAGE_UNORDERED_ACCESS",
])

DXGI_FRAME_STATISTICS = Struct("DXGI_FRAME_STATISTICS", [
    (UINT, "PresentCount"),
    (UINT, "PresentRefreshCount"),
    (UINT, "SyncRefreshCount"),
    (LARGE_INTEGER, "SyncQPCTime"),
    (LARGE_INTEGER, "SyncGPUTime"),
])

DXGI_MAPPED_RECT = Struct("DXGI_MAPPED_RECT", [
    (INT, "Pitch"),
    (LinearPointer(BYTE, "_MappedSize"), "pBits"),
])

DXGI_ADAPTER_DESC = Struct("DXGI_ADAPTER_DESC", [
    (WString, "Description"),
    (UINT, "VendorId"),
    (UINT, "DeviceId"),
    (UINT, "SubSysId"),
    (UINT, "Revision"),
    (SIZE_T, "DedicatedVideoMemory"),
    (SIZE_T, "DedicatedSystemMemory"),
    (SIZE_T, "SharedSystemMemory"),
    (LUID, "AdapterLuid"),
])

DXGI_OUTPUT_DESC = Struct("DXGI_OUTPUT_DESC", [
    (WString, "DeviceName"),
    (RECT, "DesktopCoordinates"),
    (BOOL, "AttachedToDesktop"),
    (DXGI_MODE_ROTATION, "Rotation"),
    (HMONITOR, "Monitor"),
])

DXGI_SHARED_RESOURCE = Struct("DXGI_SHARED_RESOURCE", [
    (HANDLE, "Handle"),
])

DXGI_RESOURCE_PRIORITY = FakeEnum(UINT, [
    "DXGI_RESOURCE_PRIORITY_MINIMUM",
    "DXGI_RESOURCE_PRIORITY_LOW",
    "DXGI_RESOURCE_PRIORITY_NORMAL",
    "DXGI_RESOURCE_PRIORITY_HIGH",
    "DXGI_RESOURCE_PRIORITY_MAXIMUM",
])

DXGI_RESIDENCY = Enum("DXGI_RESIDENCY", [
    "DXGI_RESIDENCY_FULLY_RESIDENT",
    "DXGI_RESIDENCY_RESIDENT_IN_SHARED_MEMORY",
    "DXGI_RESIDENCY_EVICTED_TO_DISK",
])

DXGI_SURFACE_DESC = Struct("DXGI_SURFACE_DESC", [
    (UINT, "Width"),
    (UINT, "Height"),
    (DXGI_FORMAT, "Format"),
    (DXGI_SAMPLE_DESC, "SampleDesc"),
])

DXGI_SWAP_EFFECT = Enum("DXGI_SWAP_EFFECT", [
    "DXGI_SWAP_EFFECT_DISCARD",
    "DXGI_SWAP_EFFECT_SEQUENTIAL",
])

DXGI_SWAP_CHAIN_FLAG = Flags(UINT, [
    "DXGI_SWAP_CHAIN_FLAG_NONPREROTATED",
    "DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH",
    "DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE",
])

DXGI_SWAP_CHAIN_DESC = Struct("DXGI_SWAP_CHAIN_DESC", [
    (DXGI_MODE_DESC, "BufferDesc"),
    (DXGI_SAMPLE_DESC, "SampleDesc"),
    (DXGI_USAGE, "BufferUsage"),
    (UINT, "BufferCount"),
    (HWND, "OutputWindow"),
    (BOOL, "Windowed"),
    (DXGI_SWAP_EFFECT, "SwapEffect"),
    (DXGI_SWAP_CHAIN_FLAG, "Flags"),
])

IDXGIObject.methods += [
    StdMethod(HRESULT, "SetPrivateData", [(REFGUID, "Name"), (UINT, "DataSize"), (OpaqueBlob(Const(Void), "DataSize"), "pData")], sideeffects=False),
    StdMethod(HRESULT, "SetPrivateDataInterface", [(REFGUID, "Name"), (OpaquePointer(Const(IUnknown)), "pUnknown")], sideeffects=False),
    StdMethod(HRESULT, "GetPrivateData", [(REFGUID, "Name"), Out(Pointer(UINT), "pDataSize"), Out(OpaquePointer(Void), "pData")], sideeffects=False),
    StdMethod(HRESULT, "GetParent", [(REFIID, "riid"), Out(Pointer(ObjPointer(Void)), "ppParent")]),
]

IDXGIDeviceSubObject.methods += [
    StdMethod(HRESULT, "GetDevice", [(REFIID, "riid"), Out(Pointer(ObjPointer(Void)), "ppDevice")]),
]

IDXGIResource.methods += [
    StdMethod(HRESULT, "GetSharedHandle", [Out(Pointer(HANDLE), "pSharedHandle")]),
    StdMethod(HRESULT, "GetUsage", [Out(Pointer(DXGI_USAGE), "pUsage")], sideeffects=False),
    StdMethod(HRESULT, "SetEvictionPriority", [(DXGI_RESOURCE_PRIORITY, "EvictionPriority")]),
    StdMethod(HRESULT, "GetEvictionPriority", [Out(Pointer(DXGI_RESOURCE_PRIORITY), "pEvictionPriority")], sideeffects=False),
]

DXGI_SHARED_RESOURCE_FLAG = Flags(DWORD, [
    "DXGI_SHARED_RESOURCE_READ",
    "DXGI_SHARED_RESOURCE_WRITE",
])


IDXGIKeyedMutex.methods += [
    StdMethod(HRESULT, "AcquireSync", [(UINT64, "Key"), (DWORD, "dwMilliseconds")]),
    StdMethod(HRESULT, "ReleaseSync", [(UINT64, "Key")]),
]

DXGI_MAP = Flags(UINT, [
    "DXGI_MAP_READ",
    "DXGI_MAP_WRITE",
    "DXGI_MAP_DISCARD",
])

IDXGISurface.methods += [
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(DXGI_SURFACE_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "Map", [Out(Pointer(DXGI_MAPPED_RECT), "pLockedRect"), (DXGI_MAP, "MapFlags")]),
    StdMethod(HRESULT, "Unmap", []),
]

IDXGISurface1.methods += [
    StdMethod(HRESULT, "GetDC", [(BOOL, "Discard"), Out(Pointer(HDC), "phdc")]),
    StdMethod(HRESULT, "ReleaseDC", [(Pointer(RECT), "pDirtyRect")]),
]

IDXGIAdapter.methods += [
    StdMethod(HRESULT, "EnumOutputs", [(UINT, "Output"), Out(Pointer(ObjPointer(IDXGIOutput)), "ppOutput")]),
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(DXGI_ADAPTER_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "CheckInterfaceSupport", [(REFGUID, "InterfaceName"), Out(Pointer(LARGE_INTEGER), "pUMDVersion")], sideeffects=False),
]

DXGI_ENUM_MODES = Flags(UINT, [
    "DXGI_ENUM_MODES_INTERLACED",
    "DXGI_ENUM_MODES_SCALING",
])

IDXGIOutput.methods += [
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(DXGI_OUTPUT_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "GetDisplayModeList", [(DXGI_FORMAT, "EnumFormat"), (DXGI_ENUM_MODES, "Flags"), Out(Pointer(UINT), "pNumModes"), Out(Array(DXGI_MODE_DESC, "*pNumModes"), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "FindClosestMatchingMode", [(Pointer(Const(DXGI_MODE_DESC)), "pModeToMatch"), Out(Pointer(DXGI_MODE_DESC), "pClosestMatch"), (ObjPointer(IUnknown), "pConcernedDevice")]),
    StdMethod(HRESULT, "WaitForVBlank", []),
    StdMethod(HRESULT, "TakeOwnership", [(ObjPointer(IUnknown), "pDevice"), (BOOL, "Exclusive")]),
    StdMethod(Void, "ReleaseOwnership", []),
    StdMethod(HRESULT, "GetGammaControlCapabilities", [Out(Pointer(DXGI_GAMMA_CONTROL_CAPABILITIES), "pGammaCaps")]),
    StdMethod(HRESULT, "SetGammaControl", [(Pointer(Const(DXGI_GAMMA_CONTROL)), "pArray")]),
    StdMethod(HRESULT, "GetGammaControl", [Out(Pointer(DXGI_GAMMA_CONTROL), "pArray")], sideeffects=False),
    StdMethod(HRESULT, "SetDisplaySurface", [(ObjPointer(IDXGISurface), "pScanoutSurface")]),
    StdMethod(HRESULT, "GetDisplaySurfaceData", [(ObjPointer(IDXGISurface), "pDestination")]),
    StdMethod(HRESULT, "GetFrameStatistics", [Out(Pointer(DXGI_FRAME_STATISTICS), "pStats")], sideeffects=False),
]

DXGI_PRESENT = Flags(UINT, [
    "DXGI_PRESENT_TEST",
    "DXGI_PRESENT_DO_NOT_SEQUENCE",
    "DXGI_PRESENT_RESTART",
])

IDXGISwapChain.methods += [
    StdMethod(HRESULT, "Present", [(UINT, "SyncInterval"), (DXGI_PRESENT, "Flags")]),
    StdMethod(HRESULT, "GetBuffer", [(UINT, "Buffer"), (REFIID, "riid"), Out(Pointer(ObjPointer(Void)), "ppSurface")]),
    StdMethod(HRESULT, "SetFullscreenState", [(BOOL, "Fullscreen"), (ObjPointer(IDXGIOutput), "pTarget")]),
    StdMethod(HRESULT, "GetFullscreenState", [Out(Pointer(BOOL), "pFullscreen"), Out(Pointer(ObjPointer(IDXGIOutput)), "ppTarget")]),
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(DXGI_SWAP_CHAIN_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "ResizeBuffers", [(UINT, "BufferCount"), (UINT, "Width"), (UINT, "Height"), (DXGI_FORMAT, "NewFormat"), (DXGI_SWAP_CHAIN_FLAG, "SwapChainFlags")]),
    StdMethod(HRESULT, "ResizeTarget", [(Pointer(Const(DXGI_MODE_DESC)), "pNewTargetParameters")]),
    StdMethod(HRESULT, "GetContainingOutput", [Out(Pointer(ObjPointer(IDXGIOutput)), "ppOutput")]),
    StdMethod(HRESULT, "GetFrameStatistics", [Out(Pointer(DXGI_FRAME_STATISTICS), "pStats")], sideeffects=False),
    StdMethod(HRESULT, "GetLastPresentCount", [Out(Pointer(UINT), "pLastPresentCount")], sideeffects=False),
]

DXGI_MWA = Flags(UINT, [
    "DXGI_MWA_NO_WINDOW_CHANGES",
    "DXGI_MWA_NO_ALT_ENTER",
    "DXGI_MWA_NO_PRINT_SCREEN",
    "DXGI_MWA_VALID",
])

IDXGIFactory.methods += [
    StdMethod(HRESULT, "EnumAdapters", [(UINT, "Adapter"), Out(Pointer(ObjPointer(IDXGIAdapter)), "ppAdapter")]),
    StdMethod(HRESULT, "MakeWindowAssociation", [(HWND, "WindowHandle"), (DXGI_MWA, "Flags")]),
    StdMethod(HRESULT, "GetWindowAssociation", [Out(Pointer(HWND), "pWindowHandle")], sideeffects=False),
    StdMethod(HRESULT, "CreateSwapChain", [(ObjPointer(IUnknown), "pDevice"), (Pointer(DXGI_SWAP_CHAIN_DESC), "pDesc"), Out(Pointer(ObjPointer(IDXGISwapChain)), "ppSwapChain")]),
    StdMethod(HRESULT, "CreateSoftwareAdapter", [(HMODULE, "Module"), Out(Pointer(ObjPointer(IDXGIAdapter)), "ppAdapter")]),
]

IDXGIDevice.methods += [
    StdMethod(HRESULT, "GetAdapter", [Out(Pointer(ObjPointer(IDXGIAdapter)), "pAdapter")]),
    StdMethod(HRESULT, "CreateSurface", [(Pointer(Const(DXGI_SURFACE_DESC)), "pDesc"), (UINT, "NumSurfaces"), (DXGI_USAGE, "Usage"), (Pointer(Const(DXGI_SHARED_RESOURCE)), "pSharedResource"), Out(Pointer(ObjPointer(IDXGISurface)), "ppSurface")]),
    StdMethod(HRESULT, "QueryResourceResidency", [(Array(Const(ObjPointer(IUnknown)), "NumResources"), "ppResources"), Out(Array(DXGI_RESIDENCY, "NumResources"), "pResidencyStatus"), (UINT, "NumResources")], sideeffects=False),
    StdMethod(HRESULT, "SetGPUThreadPriority", [(INT, "Priority")]),
    StdMethod(HRESULT, "GetGPUThreadPriority", [Out(Pointer(INT), "pPriority")], sideeffects=False),
]

DXGI_ADAPTER_FLAG = Enum("DXGI_ADAPTER_FLAG", [
    "DXGI_ADAPTER_FLAG_NONE",
    "DXGI_ADAPTER_FLAG_REMOTE",
])

DXGI_ADAPTER_DESC1 = Struct("DXGI_ADAPTER_DESC1", [
    (WString, "Description"),
    (UINT, "VendorId"),
    (UINT, "DeviceId"),
    (UINT, "SubSysId"),
    (UINT, "Revision"),
    (SIZE_T, "DedicatedVideoMemory"),
    (SIZE_T, "DedicatedSystemMemory"),
    (SIZE_T, "SharedSystemMemory"),
    (LUID, "AdapterLuid"),
    (UINT, "Flags"),
])

DXGI_DISPLAY_COLOR_SPACE = Struct("DXGI_DISPLAY_COLOR_SPACE", [
    (Array(Array(FLOAT, 8), 2), "PrimaryCoordinates"),
    (Array(Array(FLOAT, 16), 2), "WhitePoints"),
])

IDXGIFactory1.methods += [
    StdMethod(HRESULT, "EnumAdapters1", [(UINT, "Adapter"), Out(Pointer(ObjPointer(IDXGIAdapter1)), "ppAdapter")]),
    StdMethod(BOOL, "IsCurrent", []),
]

IDXGIAdapter1.methods += [
    StdMethod(HRESULT, "GetDesc1", [Out(Pointer(DXGI_ADAPTER_DESC1), "pDesc")], sideeffects=False),
]

IDXGIDevice1.methods += [
    StdMethod(HRESULT, "SetMaximumFrameLatency", [(UINT, "MaxLatency")]),
    StdMethod(HRESULT, "GetMaximumFrameLatency", [Out(Pointer(UINT), "pMaxLatency")], sideeffects=False),
]


IDXGIFactoryDWM = Interface("IDXGIFactoryDWM", IUnknown)
IDXGISwapChainDWM = Interface("IDXGISwapChainDWM", IDXGIDeviceSubObject)

IDXGIFactoryDWM.methods += [
    StdMethod(HRESULT, "CreateSwapChain", [(ObjPointer(IUnknown), "pDevice"), (Pointer(DXGI_SWAP_CHAIN_DESC), "pDesc"), (ObjPointer(IDXGIOutput), "pOutput"), Out(Pointer(ObjPointer(IDXGISwapChainDWM)), "ppSwapChain")]),
]

# http://shchetinin.blogspot.co.uk/2012/04/dwm-graphics-directx-win8win7.html
IDXGISwapChainDWM.methods += [
    StdMethod(HRESULT, "Present", [(UINT, "SyncInterval"), (DXGI_PRESENT, "Flags")]),
    StdMethod(HRESULT, "GetBuffer", [(UINT, "Buffer"), (REFIID, "riid"), Out(Pointer(ObjPointer(Void)), "ppSurface")]),
    StdMethod(HRESULT, "GetDesc", [Out(Pointer(DXGI_SWAP_CHAIN_DESC), "pDesc")], sideeffects=False),
    StdMethod(HRESULT, "ResizeBuffers", [(UINT, "BufferCount"), (UINT, "Width"), (UINT, "Height"), (DXGI_FORMAT, "NewFormat"), (DXGI_SWAP_CHAIN_FLAG, "SwapChainFlags")]),
    StdMethod(HRESULT, "ResizeTarget", [(Pointer(Const(DXGI_MODE_DESC)), "pNewTargetParameters")]),
    StdMethod(HRESULT, "GetContainingOutput", [Out(Pointer(ObjPointer(IDXGIOutput)), "ppOutput")]),
    StdMethod(HRESULT, "GetFrameStatistics", [Out(Pointer(DXGI_FRAME_STATISTICS), "pStats")], sideeffects=False),
    StdMethod(HRESULT, "GetLastPresentCount", [Out(Pointer(UINT), "pLastPresentCount")], sideeffects=False),
    StdMethod(HRESULT, "SetFullscreenState", [(BOOL, "Fullscreen"), (ObjPointer(IDXGIOutput), "pTarget")]),
    StdMethod(HRESULT, "GetFullscreenState", [Out(Pointer(BOOL), "pFullscreen"), Out(Pointer(ObjPointer(IDXGIOutput)), "ppTarget")]),
]


dxgi = Module('dxgi')
dxgi.addInterfaces([
    IDXGIFactory1,
    IDXGIFactoryDWM,
])
dxgi.addFunctions([
    StdFunction(HRESULT, "CreateDXGIFactory", [(REFIID, "riid"), Out(Pointer(ObjPointer(Void)), "ppFactory")]),
    StdFunction(HRESULT, "CreateDXGIFactory1", [(REFIID, "riid"), Out(Pointer(ObjPointer(Void)), "ppFactory")]),
])

########NEW FILE########
__FILENAME__ = dxgi1_2
##########################################################################
#
# Copyright 2013 Jeff Muizelaar
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from dxgi import *


IDXGIResource1 = Interface("IDXGIResource1", IDXGIResource)
IDXGISurface2 = Interface("IDXGISurface2", IDXGISurface1)


DXGI_SHARED_RESOURCE_FLAG = Flags(DWORD, [
    "DXGI_SHARED_RESOURCE_READ",
    "DXGI_SHARED_RESOURCE_WRITE",
])


IDXGIResource1.methods += [
    StdMethod(HRESULT, "CreateSharedHandle", [(Pointer(Const(SECURITY_ATTRIBUTES)), "pAttributes"), (DXGI_SHARED_RESOURCE_FLAG, "dwAccess"), (LPCWSTR, "lpName"), Out(Pointer(HANDLE), "pHandle")]),
    StdMethod(HRESULT, "CreateSubresourceSurface", [(UINT, "index"), Out(Pointer(ObjPointer(IDXGISurface2)), "ppSurface")]),
]


IDXGISurface2.methods += [
    StdMethod(HRESULT, "GetResource", [(REFIID, "riid"), Out(Pointer(ObjPointer(Void)), "ppParentResource"), Out(Pointer(UINT), "pSubresourceIndex")]),
]

dxgi.addInterfaces([
    IDXGIResource1,
])

########NEW FILE########
__FILENAME__ = dxgiformat
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from winapi import *


DXGI_FORMAT = Enum("DXGI_FORMAT", [
    "DXGI_FORMAT_UNKNOWN",
    "DXGI_FORMAT_R32G32B32A32_TYPELESS",
    "DXGI_FORMAT_R32G32B32A32_FLOAT",
    "DXGI_FORMAT_R32G32B32A32_UINT",
    "DXGI_FORMAT_R32G32B32A32_SINT",
    "DXGI_FORMAT_R32G32B32_TYPELESS",
    "DXGI_FORMAT_R32G32B32_FLOAT",
    "DXGI_FORMAT_R32G32B32_UINT",
    "DXGI_FORMAT_R32G32B32_SINT",
    "DXGI_FORMAT_R16G16B16A16_TYPELESS",
    "DXGI_FORMAT_R16G16B16A16_FLOAT",
    "DXGI_FORMAT_R16G16B16A16_UNORM",
    "DXGI_FORMAT_R16G16B16A16_UINT",
    "DXGI_FORMAT_R16G16B16A16_SNORM",
    "DXGI_FORMAT_R16G16B16A16_SINT",
    "DXGI_FORMAT_R32G32_TYPELESS",
    "DXGI_FORMAT_R32G32_FLOAT",
    "DXGI_FORMAT_R32G32_UINT",
    "DXGI_FORMAT_R32G32_SINT",
    "DXGI_FORMAT_R32G8X24_TYPELESS",
    "DXGI_FORMAT_D32_FLOAT_S8X24_UINT",
    "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS",
    "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT",
    "DXGI_FORMAT_R10G10B10A2_TYPELESS",
    "DXGI_FORMAT_R10G10B10A2_UNORM",
    "DXGI_FORMAT_R10G10B10A2_UINT",
    "DXGI_FORMAT_R11G11B10_FLOAT",
    "DXGI_FORMAT_R8G8B8A8_TYPELESS",
    "DXGI_FORMAT_R8G8B8A8_UNORM",
    "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB",
    "DXGI_FORMAT_R8G8B8A8_UINT",
    "DXGI_FORMAT_R8G8B8A8_SNORM",
    "DXGI_FORMAT_R8G8B8A8_SINT",
    "DXGI_FORMAT_R16G16_TYPELESS",
    "DXGI_FORMAT_R16G16_FLOAT",
    "DXGI_FORMAT_R16G16_UNORM",
    "DXGI_FORMAT_R16G16_UINT",
    "DXGI_FORMAT_R16G16_SNORM",
    "DXGI_FORMAT_R16G16_SINT",
    "DXGI_FORMAT_R32_TYPELESS",
    "DXGI_FORMAT_D32_FLOAT",
    "DXGI_FORMAT_R32_FLOAT",
    "DXGI_FORMAT_R32_UINT",
    "DXGI_FORMAT_R32_SINT",
    "DXGI_FORMAT_R24G8_TYPELESS",
    "DXGI_FORMAT_D24_UNORM_S8_UINT",
    "DXGI_FORMAT_R24_UNORM_X8_TYPELESS",
    "DXGI_FORMAT_X24_TYPELESS_G8_UINT",
    "DXGI_FORMAT_R8G8_TYPELESS",
    "DXGI_FORMAT_R8G8_UNORM",
    "DXGI_FORMAT_R8G8_UINT",
    "DXGI_FORMAT_R8G8_SNORM",
    "DXGI_FORMAT_R8G8_SINT",
    "DXGI_FORMAT_R16_TYPELESS",
    "DXGI_FORMAT_R16_FLOAT",
    "DXGI_FORMAT_D16_UNORM",
    "DXGI_FORMAT_R16_UNORM",
    "DXGI_FORMAT_R16_UINT",
    "DXGI_FORMAT_R16_SNORM",
    "DXGI_FORMAT_R16_SINT",
    "DXGI_FORMAT_R8_TYPELESS",
    "DXGI_FORMAT_R8_UNORM",
    "DXGI_FORMAT_R8_UINT",
    "DXGI_FORMAT_R8_SNORM",
    "DXGI_FORMAT_R8_SINT",
    "DXGI_FORMAT_A8_UNORM",
    "DXGI_FORMAT_R1_UNORM",
    "DXGI_FORMAT_R9G9B9E5_SHAREDEXP",
    "DXGI_FORMAT_R8G8_B8G8_UNORM",
    "DXGI_FORMAT_G8R8_G8B8_UNORM",
    "DXGI_FORMAT_BC1_TYPELESS",
    "DXGI_FORMAT_BC1_UNORM",
    "DXGI_FORMAT_BC1_UNORM_SRGB",
    "DXGI_FORMAT_BC2_TYPELESS",
    "DXGI_FORMAT_BC2_UNORM",
    "DXGI_FORMAT_BC2_UNORM_SRGB",
    "DXGI_FORMAT_BC3_TYPELESS",
    "DXGI_FORMAT_BC3_UNORM",
    "DXGI_FORMAT_BC3_UNORM_SRGB",
    "DXGI_FORMAT_BC4_TYPELESS",
    "DXGI_FORMAT_BC4_UNORM",
    "DXGI_FORMAT_BC4_SNORM",
    "DXGI_FORMAT_BC5_TYPELESS",
    "DXGI_FORMAT_BC5_UNORM",
    "DXGI_FORMAT_BC5_SNORM",
    "DXGI_FORMAT_B5G6R5_UNORM",
    "DXGI_FORMAT_B5G5R5A1_UNORM",
    "DXGI_FORMAT_B8G8R8A8_UNORM",
    "DXGI_FORMAT_B8G8R8X8_UNORM",
    "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM",
    "DXGI_FORMAT_B8G8R8A8_TYPELESS",
    "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB",
    "DXGI_FORMAT_B8G8R8X8_TYPELESS",
    "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB",
    "DXGI_FORMAT_BC6H_TYPELESS",
    "DXGI_FORMAT_BC6H_UF16",
    "DXGI_FORMAT_BC6H_SF16",
    "DXGI_FORMAT_BC7_TYPELESS",
    "DXGI_FORMAT_BC7_UNORM",
    "DXGI_FORMAT_BC7_UNORM_SRGB",
])


########NEW FILE########
__FILENAME__ = dxgitype
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from dxgiformat import *


HRESULT = MAKE_HRESULT([
    "DXGI_STATUS_OCCLUDED",
    "DXGI_STATUS_CLIPPED",
    "DXGI_STATUS_NO_REDIRECTION",
    "DXGI_STATUS_NO_DESKTOP_ACCESS",
    "DXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE",
    "DXGI_STATUS_MODE_CHANGED",
    "DXGI_STATUS_MODE_CHANGE_IN_PROGRESS",
    "DXGI_ERROR_INVALID_CALL",
    "DXGI_ERROR_NOT_FOUND",
    "DXGI_ERROR_MORE_DATA",
    "DXGI_ERROR_UNSUPPORTED",
    "DXGI_ERROR_DEVICE_REMOVED",
    "DXGI_ERROR_DEVICE_HUNG",
    "DXGI_ERROR_DEVICE_RESET",
    "DXGI_ERROR_WAS_STILL_DRAWING",
    "DXGI_ERROR_FRAME_STATISTICS_DISJOINT",
    "DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE",
    "DXGI_ERROR_DRIVER_INTERNAL_ERROR",
    "DXGI_ERROR_NONEXCLUSIVE",
    "DXGI_ERROR_NOT_CURRENTLY_AVAILABLE",
    "DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED",
    "DXGI_ERROR_REMOTE_OUTOFMEMORY",
])


DXGI_RGB = Struct("DXGI_RGB", [
    (Float, "Red"),
    (Float, "Green"),
    (Float, "Blue"),
])

DXGI_GAMMA_CONTROL = Struct("DXGI_GAMMA_CONTROL", [
    (DXGI_RGB, "Scale"),
    (DXGI_RGB, "Offset"),
    (Array(DXGI_RGB, 1025), "GammaCurve"),
])

DXGI_GAMMA_CONTROL_CAPABILITIES = Struct("DXGI_GAMMA_CONTROL_CAPABILITIES", [
    (BOOL, "ScaleAndOffsetSupported"),
    (Float, "MaxConvertedValue"),
    (Float, "MinConvertedValue"),
    (UINT, "NumGammaControlPoints"),
    (Array(Float, 1025), "ControlPointPositions"),
])

DXGI_RATIONAL = Struct("DXGI_RATIONAL", [
    (UINT, "Numerator"),
    (UINT, "Denominator"),
])

DXGI_MODE_SCANLINE_ORDER = Enum("DXGI_MODE_SCANLINE_ORDER", [
    "DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED",
    "DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE",
    "DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST",
    "DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST",
])

DXGI_MODE_SCALING = Enum("DXGI_MODE_SCALING", [
    "DXGI_MODE_SCALING_UNSPECIFIED",
    "DXGI_MODE_SCALING_CENTERED",
    "DXGI_MODE_SCALING_STRETCHED",
])

DXGI_MODE_ROTATION = Enum("DXGI_MODE_ROTATION", [
    "DXGI_MODE_ROTATION_UNSPECIFIED",
    "DXGI_MODE_ROTATION_IDENTITY",
    "DXGI_MODE_ROTATION_ROTATE90",
    "DXGI_MODE_ROTATION_ROTATE180",
    "DXGI_MODE_ROTATION_ROTATE270",
])

DXGI_MODE_DESC = Struct("DXGI_MODE_DESC", [
    (UINT, "Width"),
    (UINT, "Height"),
    (DXGI_RATIONAL, "RefreshRate"),
    (DXGI_FORMAT, "Format"),
    (DXGI_MODE_SCANLINE_ORDER, "ScanlineOrdering"),
    (DXGI_MODE_SCALING, "Scaling"),
])

DXGI_SAMPLE_DESC = Struct("DXGI_SAMPLE_DESC", [
    (UINT, "Count"),
    (UINT, "Quality"),
])


########NEW FILE########
__FILENAME__ = eglapi
##########################################################################
#
# Copyright 2011 LunarG, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""EGL API description."""


from stdapi import *
from gltypes import *
from eglenum import *

EGLNativeDisplayType = Opaque("EGLNativeDisplayType")
EGLNativeWindowType = Opaque("EGLNativeWindowType")
EGLNativePixmapType = Opaque("EGLNativePixmapType")

EGLDisplay = Opaque("EGLDisplay")
EGLConfig = Opaque("EGLConfig")
EGLContext = Opaque("EGLContext")
EGLSurface = Opaque("EGLSurface")

EGLClientBuffer = Opaque("EGLClientBuffer")

EGLBoolean = Enum("EGLBoolean", [
    "EGL_FALSE",
    "EGL_TRUE",
])

EGLint = Alias("EGLint", Int32)

# an alias of EGLenum
EGLint_enum = Alias("EGLint", EGLenum)
EGLattrib = EGLint_enum

# EGL_KHR_image_base
EGLImageKHR = Opaque("EGLImageKHR")

# EGL_KHR_reusable_sync
EGLSyncKHR = Opaque("EGLSyncKHR")
EGLTimeKHR = Alias("EGLTimeKHR", UInt64)

# EGL_NV_sync
EGLSyncNV = Alias("EGLSyncNV", EGLSyncKHR)
EGLTimeNV = Alias("EGLTimeNV", EGLTimeKHR)

# EGL_HI_clientpixmap
EGLClientPixmapHI = Struct("struct EGLClientPixmapHI", [
  (OpaquePointer(Void), "pData"),
  (EGLint, "iWidth"),
  (EGLint, "iHeight"),
  (EGLint, "iStride"),
])

# EGL_NV_system_time
EGLuint64NV = Alias("EGLuint64NV", UInt64)

eglapi = Module("EGL")

EGLSurfaceFlags = Flags(Int, [
    'EGL_MULTISAMPLE_RESOLVE_BOX_BIT',
    'EGL_PBUFFER_BIT',
    'EGL_PIXMAP_BIT',
    'EGL_SWAP_BEHAVIOR_PRESERVED_BIT',
    'EGL_VG_ALPHA_FORMAT_PRE_BIT',
    'EGL_VG_COLORSPACE_LINEAR_BIT',
    'EGL_WINDOW_BIT'
])

EGLConformantFlags = Flags(Int, [
    'EGL_OPENGL_BIT',
    'EGL_OPENGL_ES_BIT',
    'EGL_OPENGL_ES2_BIT',
    'EGL_OPENGL_ES3_BIT_KHR',
    'EGL_OPENVG_BIT',
])

EGLVGAlphaFormat = FakeEnum(Int, ['EGL_VG_ALPHA_FORMAT_NONPRE', 'EGL_VG_ALPHA_FORMAT_PRE'])
EGLVGColorspace = FakeEnum(Int, ['EGL_VG_COLORSPACE_sRGB', 'EGL_VG_COLORSPACE_LINEAR'])
EGLTextureFormat = FakeEnum(Int, ['EGL_NO_TEXTURE', 'EGL_TEXTURE_RGB', 'EGL_TEXTURE_RGBA'])
EGLTextureTarget = FakeEnum(Int, ['EGL_TEXTURE_2D', 'EGL_NO_TEXTURE'])

def EGLAttribArray(values):
    return AttribArray(Const(EGLint_enum), values, terminator = 'EGL_NONE')

EGLConfigAttribs = EGLAttribArray([
    ('EGL_ALPHA_MASK_SIZE', UInt),
    ('EGL_ALPHA_SIZE', UInt),
    ('EGL_BIND_TO_TEXTURE_RGB', EGLBoolean),
    ('EGL_BIND_TO_TEXTURE_RGBA', EGLBoolean),
    ('EGL_BLUE_SIZE', UInt),
    ('EGL_BUFFER_SIZE', UInt),
    ('EGL_COLOR_BUFFER_TYPE', FakeEnum(Int, ['EGL_RGB_BUFFER', 'EGL_LUMINANCE_BUFFER'])),
    ('EGL_CONFIG_CAVEAT', FakeEnum(Int, ['EGL_DONT_CARE', 'EGL_NONE', 'EGL_SLOW_CONFIG', 'EGL_NON_CONFORMANT_CONFIG'])),
    ('EGL_CONFIG_ID', Int),
    ('EGL_CONFORMANT', EGLConformantFlags),
    ('EGL_DEPTH_SIZE', Int),
    ('EGL_GREEN_SIZE', UInt),
    ('EGL_LEVEL', Int),
    ('EGL_LUMINANCE_SIZE', UInt),
    ('EGL_MATCH_NATIVE_PIXMAP', Int),
    ('EGL_NATIVE_RENDERABLE', FakeEnum(Int, ['EGL_DONT_CARE', 'EGL_TRUE', 'EGL_FALSE'])),
    ('EGL_MAX_SWAP_INTERVAL', Int),
    ('EGL_MIN_SWAP_INTERVAL', Int),
    ('EGL_RED_SIZE', UInt),
    ('EGL_SAMPLE_BUFFERS', Int),
    ('EGL_SAMPLES', Int),
    ('EGL_STENCIL_SIZE', UInt),
    ('EGL_RENDERABLE_TYPE', EGLConformantFlags),
    ('EGL_SURFACE_TYPE', EGLSurfaceFlags),
    ('EGL_TRANSPARENT_TYPE', FakeEnum(Int, ['EGL_NONE', 'EGL_TRANSPARENT_RGB'])),
    ('EGL_TRANSPARENT_RED_VALUE', Int),
    ('EGL_TRANSPARENT_GREEN_VALUE', Int),
    ('EGL_TRANSPARENT_BLUE_VALUE ', Int)
])

EGLWindowsSurfaceAttribs = EGLAttribArray([
    ('EGL_RENDER_BUFFER', FakeEnum(Int, ['EGL_SINGLE_BUFFER', 'EGL_BACK_BUFFER'])),
    ('EGL_VG_ALPHA_FORMAT', EGLVGAlphaFormat),
    ('EGL_VG_COLORSPACE', EGLVGColorspace)])

EGLPixmapSurfaceAttribs = EGLAttribArray([
    ('EGL_VG_ALPHA_FORMAT', EGLVGAlphaFormat),
    ('EGL_VG_COLORSPACE', EGLVGColorspace)
])

EGLPbufferAttribs = EGLAttribArray([
    ('EGL_HEIGHT', Int),
    ('EGL_LARGEST_PBUFFER', EGLBoolean),
    ('EGL_MIPMAP_TEXTURE', UInt),
    ('EGL_TEXTURE_FORMAT', EGLTextureFormat),
    ('EGL_TEXTURE_TARGET', EGLTextureTarget),
    ('EGL_VG_ALPHA_FORMAT', EGLVGAlphaFormat),
    ('EGL_VG_COLORSPACE', EGLVGColorspace),
    ('EGL_WIDTH', Int)
])

EGLPbufferFromClientBufferAttribs = EGLAttribArray([
    ('EGL_MIPMAP_TEXTURE', EGLBoolean),
    ('EGL_TEXTURE_FORMAT', EGLTextureFormat),
    ('EGL_TEXTURE_TARGET', EGLTextureTarget)
])

EGLContextAttribs = EGLAttribArray([
    ('EGL_CONTEXT_OPENGL_ROBUST_ACCESS_EXT', EGLBoolean),
    ('EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT', EGLenum),
    ('EGL_CONTEXT_MAJOR_VERSION_KHR', Int), # Alias for EGL_CONTEXT_CLIENT_VERSION
    ('EGL_CONTEXT_MINOR_VERSION_KHR', Int),
    ('EGL_CONTEXT_FLAGS_KHR', Flags(Int, [
        'EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR',
        'EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR',
        'EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR',
    ])),
    ('EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR', Flags(Int, [
        'EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR',
        'EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR',
    ])),
    ('EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR', EGLenum),
])

EGLDrmImageMesaAttribs = EGLAttribArray([
    ('EGL_DRM_BUFFER_FORMAT_MESA', FakeEnum(Int, ['EGL_DRM_BUFFER_FORMAT_ARGB32_MESA'])),
    ('EGL_DRM_BUFFER_USE_MESA', Flags(Int, ['EGL_DRM_BUFFER_USE_SCANOUT_MESA', 'EGL_DRM_BUFFER_USE_SHARE_MESA']))
])

EGLLockSurfaceKHRAttribs = EGLAttribArray([
    ('EGL_MAP_PRESERVE_PIXELS_KHR', EGLBoolean),
    ('EGL_LOCK_USAGE_HINT_KHR', Flags(Int, ['EGL_READ_SURFACE_BIT_KHR', 'EGL_WRITE_SURFACE_BIT_KHR']))
])

EGLFenceSyncNVAttribs = EGLAttribArray([
    ('EGL_SYNC_STATUS_NV', Flags(Int, ['EGL_SIGNALED_NV', 'EGL_UNSIGNALED_NV']))
])

EGLProc = Opaque("__eglMustCastToProperFunctionPointerType")

def GlFunction(*args, **kwargs):
    kwargs.setdefault('call', 'GL_APIENTRY')
    return Function(*args, **kwargs)

eglapi.addFunctions([
    # EGL 1.4
    Function(EGLint_enum, "eglGetError", [], sideeffects=False),

    Function(EGLDisplay, "eglGetDisplay", [(EGLNativeDisplayType, "display_id")]),
    Function(EGLBoolean, "eglInitialize", [(EGLDisplay, "dpy"), Out(Pointer(EGLint), "major"), Out(Pointer(EGLint), "minor")]),
    Function(EGLBoolean, "eglTerminate", [(EGLDisplay, "dpy")]),

    Function(ConstCString, "eglQueryString", [(EGLDisplay, "dpy"), (EGLint_enum, "name")], sideeffects=False),

    Function(EGLBoolean, "eglGetConfigs", [(EGLDisplay, "dpy"), Out(Array(EGLConfig, "config_size"), "configs"), (EGLint, "config_size"), Out(Pointer(EGLint), "num_config")]),
    Function(EGLBoolean, "eglChooseConfig", [(EGLDisplay, "dpy"), (EGLConfigAttribs, "attrib_list"), Out(Array(EGLConfig, "config_size"), "configs"), (EGLint, "config_size"), Out(Pointer(EGLint), "num_config")]),
    Function(EGLBoolean, "eglGetConfigAttrib", [(EGLDisplay, "dpy"), (EGLConfig, "config"), (EGLattrib, "attribute"), Out(Pointer(EGLint), "value")], sideeffects=False),

    Function(EGLSurface, "eglCreateWindowSurface", [(EGLDisplay, "dpy"), (EGLConfig, "config"), (EGLNativeWindowType, "win"), (EGLWindowsSurfaceAttribs, "attrib_list")]),
    Function(EGLSurface, "eglCreatePbufferSurface", [(EGLDisplay, "dpy"), (EGLConfig, "config"), (EGLPbufferAttribs, "attrib_list")]),
    Function(EGLSurface, "eglCreatePixmapSurface", [(EGLDisplay, "dpy"), (EGLConfig, "config"), (EGLNativePixmapType, "pixmap"), (EGLPixmapSurfaceAttribs, "attrib_list")]),
    Function(EGLBoolean, "eglDestroySurface", [(EGLDisplay, "dpy"), (EGLSurface, "surface")]),
    Function(EGLBoolean, "eglQuerySurface", [(EGLDisplay, "dpy"), (EGLSurface, "surface"), (EGLattrib, "attribute"), Out(Pointer(EGLint), "value")], sideeffects=False),

    Function(EGLBoolean, "eglBindAPI", [(EGLenum, "api")]),
    Function(EGLenum, "eglQueryAPI", [], sideeffects=False),

    Function(EGLBoolean, "eglWaitClient", []),

    Function(EGLBoolean, "eglReleaseThread", []),

    Function(EGLSurface, "eglCreatePbufferFromClientBuffer", [(EGLDisplay, "dpy"), (EGLenum, "buftype"), (EGLClientBuffer, "buffer"), (EGLConfig, "config"), (EGLPbufferFromClientBufferAttribs, "attrib_list")]),

    Function(EGLBoolean, "eglSurfaceAttrib", [(EGLDisplay, "dpy"), (EGLSurface, "surface"), (EGLattrib, "attribute"), (EGLint, "value")]),
    Function(EGLBoolean, "eglBindTexImage", [(EGLDisplay, "dpy"), (EGLSurface, "surface"), (EGLattrib, "buffer")]),
    Function(EGLBoolean, "eglReleaseTexImage", [(EGLDisplay, "dpy"), (EGLSurface, "surface"), (EGLattrib, "buffer")]),

    Function(EGLBoolean, "eglSwapInterval", [(EGLDisplay, "dpy"), (EGLint, "interval")]),

    Function(EGLContext, "eglCreateContext", [(EGLDisplay, "dpy"), (EGLConfig, "config"), (EGLContext, "share_context"), (EGLContextAttribs, "attrib_list")]),
    Function(EGLBoolean, "eglDestroyContext", [(EGLDisplay, "dpy"), (EGLContext, "ctx")]),
    Function(EGLBoolean, "eglMakeCurrent", [(EGLDisplay, "dpy"), (EGLSurface, "draw"), (EGLSurface, "read"), (EGLContext, "ctx")]),

    Function(EGLContext, "eglGetCurrentContext", [], sideeffects=False),
    Function(EGLSurface, "eglGetCurrentSurface", [(EGLattrib, "readdraw")], sideeffects=False),
    Function(EGLDisplay, "eglGetCurrentDisplay", [], sideeffects=False),

    Function(EGLBoolean, "eglQueryContext", [(EGLDisplay, "dpy"), (EGLContext, "ctx"), (EGLattrib, "attribute"), Out(Pointer(EGLint), "value")], sideeffects=False),

    Function(EGLBoolean, "eglWaitGL", []),
    Function(EGLBoolean, "eglWaitNative", [(EGLattrib, "engine")]),
    Function(EGLBoolean, "eglSwapBuffers", [(EGLDisplay, "dpy"), (EGLSurface, "surface")]),
    Function(EGLBoolean, "eglCopyBuffers", [(EGLDisplay, "dpy"), (EGLSurface, "surface"), (EGLNativePixmapType, "target")]),

    Function(EGLProc, "eglGetProcAddress", [(ConstCString, "procname")]),

    # EGL_KHR_lock_surface
    # EGL_KHR_lock_surface2
    Function(EGLBoolean, "eglLockSurfaceKHR", [(EGLDisplay, "display"), (EGLSurface, "surface"), (EGLLockSurfaceKHRAttribs, "attrib_list")]),
    Function(EGLBoolean, "eglUnlockSurfaceKHR", [(EGLDisplay, "display"), (EGLSurface, "surface")]),

    # EGL_KHR_image_base
    Function(EGLImageKHR, "eglCreateImageKHR", [(EGLDisplay, "dpy"), (EGLContext, "ctx"), (EGLenum, "target"), (EGLClientBuffer, "buffer"), (EGLAttribArray([('EGL_IMAGE_PRESERVED_KHR', EGLBoolean)]), "attrib_list")]),
    Function(EGLBoolean, "eglDestroyImageKHR", [(EGLDisplay, "dpy"), (EGLImageKHR, "image")]),

    # EGL_KHR_fence_sync
    # EGL_KHR_reusable_sync
    Function(EGLSyncKHR, "eglCreateSyncKHR", [(EGLDisplay, "dpy"), (EGLenum, "type"), (EGLAttribArray([]), "attrib_list")]),
    Function(EGLBoolean, "eglDestroySyncKHR", [(EGLDisplay, "dpy"), (EGLSyncKHR, "sync")]),
    Function(EGLint, "eglClientWaitSyncKHR", [(EGLDisplay, "dpy"), (EGLSyncKHR, "sync"), (EGLint, "flags"), (EGLTimeKHR, "timeout")]),
    Function(EGLBoolean, "eglSignalSyncKHR", [(EGLDisplay, "dpy"), (EGLSyncKHR, "sync"), (EGLenum, "mode")]),
    Function(EGLBoolean, "eglGetSyncAttribKHR", [(EGLDisplay, "dpy"), (EGLSyncKHR, "sync"), (EGLattrib, "attribute"), Out(Pointer(EGLint), "value")], sideeffects=False),

    # EGL_NV_sync
    Function(EGLSyncNV, "eglCreateFenceSyncNV", [(EGLDisplay, "dpy"), (EGLenum, "condition"), (EGLFenceSyncNVAttribs, "attrib_list")]),
    Function(EGLBoolean, "eglDestroySyncNV", [(EGLSyncNV, "sync")]),
    Function(EGLBoolean, "eglFenceNV", [(EGLSyncNV, "sync")]),
    Function(EGLint, "eglClientWaitSyncNV", [(EGLSyncNV, "sync"), (EGLint, "flags"), (EGLTimeNV, "timeout")]),
    Function(EGLBoolean, "eglSignalSyncNV", [(EGLSyncNV, "sync"), (EGLenum, "mode")]),
    Function(EGLBoolean, "eglGetSyncAttribNV", [(EGLSyncNV, "sync"), (EGLattrib, "attribute"), Out(Pointer(EGLint), "value")], sideeffects=False),

    # EGL_HI_clientpixmap
    Function(EGLSurface, "eglCreatePixmapSurfaceHI", [(EGLDisplay, "dpy"), (EGLConfig, "config"), (Pointer(EGLClientPixmapHI), "pixmap")]),

    # EGL_MESA_drm_image
    Function(EGLImageKHR, "eglCreateDRMImageMESA", [(EGLDisplay, "dpy"), (EGLDrmImageMesaAttribs, "attrib_list")]),
    Function(EGLBoolean, "eglExportDRMImageMESA", [(EGLDisplay, "dpy"), (EGLImageKHR, "image"), Out(Pointer(EGLint), "name"), Out(Pointer(EGLint), "handle"), Out(Pointer(EGLint), "stride")]),

    # EGL_NV_post_sub_buffer
    Function(EGLBoolean, "eglPostSubBufferNV", [(EGLDisplay, "dpy"), (EGLSurface, "surface"), (EGLint, "x"), (EGLint, "y"), (EGLint, "width"), (EGLint, "height")]),

    # EGL_ANGLE_query_surface_pointer
    Function(EGLBoolean, "eglQuerySurfacePointerANGLE", [(EGLDisplay, "dpy"), (EGLSurface, "surface"), (EGLattrib, "attribute"), Out(Pointer(OpaquePointer(Void)), "value")], sideeffects=False),

    # EGL_NV_system_time
    Function(EGLuint64NV, "eglGetSystemTimeFrequencyNV", [], sideeffects=False),
    Function(EGLuint64NV, "eglGetSystemTimeNV", [], sideeffects=False),

    # GL_OES_EGL_image
    GlFunction(Void, "glEGLImageTargetTexture2DOES", [(GLenum, "target"), (EGLImageKHR, "image")]),
    GlFunction(Void, "glEGLImageTargetRenderbufferStorageOES", [(GLenum, "target"), (EGLImageKHR, "image")]),
])

########NEW FILE########
__FILENAME__ = eglenum
##########################################################################
#
# Copyright 2013 VMware, Inc.
# Copyright 2011 LunarG, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""EGL enum description"""


from stdapi import *

# Most of the following content was produced in a semi-automated fashion by
# the scripts/eglenum.sed sed script.
EGLenum = Enum("EGLenum", [
    "EGL_DISPLAY_SCALING",		# 0x2710
    "EGL_SUCCESS",		# 0x3000
    "EGL_NOT_INITIALIZED",		# 0x3001
    "EGL_BAD_ACCESS",		# 0x3002
    "EGL_BAD_ALLOC",		# 0x3003
    "EGL_BAD_ATTRIBUTE",		# 0x3004
    "EGL_BAD_CONFIG",		# 0x3005
    "EGL_BAD_CONTEXT",		# 0x3006
    "EGL_BAD_CURRENT_SURFACE",		# 0x3007
    "EGL_BAD_DISPLAY",		# 0x3008
    "EGL_BAD_MATCH",		# 0x3009
    "EGL_BAD_NATIVE_PIXMAP",		# 0x300A
    "EGL_BAD_NATIVE_WINDOW",		# 0x300B
    "EGL_BAD_PARAMETER",		# 0x300C
    "EGL_BAD_SURFACE",		# 0x300D
    "EGL_CONTEXT_LOST",		# 0x300E
    "EGL_BUFFER_SIZE",		# 0x3020
    "EGL_ALPHA_SIZE",		# 0x3021
    "EGL_BLUE_SIZE",		# 0x3022
    "EGL_GREEN_SIZE",		# 0x3023
    "EGL_RED_SIZE",		# 0x3024
    "EGL_DEPTH_SIZE",		# 0x3025
    "EGL_STENCIL_SIZE",		# 0x3026
    "EGL_CONFIG_CAVEAT",		# 0x3027
    "EGL_CONFIG_ID",		# 0x3028
    "EGL_LEVEL",		# 0x3029
    "EGL_MAX_PBUFFER_HEIGHT",		# 0x302A
    "EGL_MAX_PBUFFER_PIXELS",		# 0x302B
    "EGL_MAX_PBUFFER_WIDTH",		# 0x302C
    "EGL_NATIVE_RENDERABLE",		# 0x302D
    "EGL_NATIVE_VISUAL_ID",		# 0x302E
    "EGL_NATIVE_VISUAL_TYPE",		# 0x302F
    "EGL_SAMPLES",		# 0x3031
    "EGL_SAMPLE_BUFFERS",		# 0x3032
    "EGL_SURFACE_TYPE",		# 0x3033
    "EGL_TRANSPARENT_TYPE",		# 0x3034
    "EGL_TRANSPARENT_BLUE_VALUE",		# 0x3035
    "EGL_TRANSPARENT_GREEN_VALUE",		# 0x3036
    "EGL_TRANSPARENT_RED_VALUE",		# 0x3037
    "EGL_NONE",		# 0x3038
    "EGL_BIND_TO_TEXTURE_RGB",		# 0x3039
    "EGL_BIND_TO_TEXTURE_RGBA",		# 0x303A
    "EGL_MIN_SWAP_INTERVAL",		# 0x303B
    "EGL_MAX_SWAP_INTERVAL",		# 0x303C
    "EGL_LUMINANCE_SIZE",		# 0x303D
    "EGL_ALPHA_MASK_SIZE",		# 0x303E
    "EGL_COLOR_BUFFER_TYPE",		# 0x303F
    "EGL_RENDERABLE_TYPE",		# 0x3040
    "EGL_MATCH_NATIVE_PIXMAP",		# 0x3041
    "EGL_CONFORMANT",		# 0x3042
    "EGL_MATCH_FORMAT_KHR",		# 0x3043
    "EGL_SLOW_CONFIG",		# 0x3050
    "EGL_NON_CONFORMANT_CONFIG",		# 0x3051
    "EGL_TRANSPARENT_RGB",		# 0x3052
    "EGL_VENDOR",		# 0x3053
    "EGL_VERSION",		# 0x3054
    "EGL_EXTENSIONS",		# 0x3055
    "EGL_HEIGHT",		# 0x3056
    "EGL_WIDTH",		# 0x3057
    "EGL_LARGEST_PBUFFER",		# 0x3058
    "EGL_DRAW",		# 0x3059
    "EGL_READ",		# 0x305A
    "EGL_CORE_NATIVE_ENGINE",		# 0x305B
    "EGL_NO_TEXTURE",		# 0x305C
    "EGL_TEXTURE_RGB",		# 0x305D
    "EGL_TEXTURE_RGBA",		# 0x305E
    "EGL_TEXTURE_2D",		# 0x305F
    "EGL_Y_INVERTED_NOK",		# 0x307F
    "EGL_TEXTURE_FORMAT",		# 0x3080
    "EGL_TEXTURE_TARGET",		# 0x3081
    "EGL_MIPMAP_TEXTURE",		# 0x3082
    "EGL_MIPMAP_LEVEL",		# 0x3083
    "EGL_BACK_BUFFER",		# 0x3084
    "EGL_SINGLE_BUFFER",		# 0x3085
    "EGL_RENDER_BUFFER",		# 0x3086
    "EGL_COLORSPACE",		# 0x3087
    "EGL_ALPHA_FORMAT",		# 0x3088
    "EGL_COLORSPACE_sRGB",		# 0x3089
    "EGL_COLORSPACE_LINEAR",		# 0x308A
    "EGL_ALPHA_FORMAT_NONPRE",		# 0x308B
    "EGL_ALPHA_FORMAT_PRE",		# 0x308C
    "EGL_CLIENT_APIS",		# 0x308D
    "EGL_RGB_BUFFER",		# 0x308E
    "EGL_LUMINANCE_BUFFER",		# 0x308F
    "EGL_HORIZONTAL_RESOLUTION",		# 0x3090
    "EGL_VERTICAL_RESOLUTION",		# 0x3091
    "EGL_PIXEL_ASPECT_RATIO",		# 0x3092
    "EGL_SWAP_BEHAVIOR",		# 0x3093
    "EGL_BUFFER_PRESERVED",		# 0x3094
    "EGL_BUFFER_DESTROYED",		# 0x3095
    "EGL_OPENVG_IMAGE",		# 0x3096
    "EGL_CONTEXT_CLIENT_TYPE",		# 0x3097
    "EGL_CONTEXT_CLIENT_VERSION",		# 0x3098
    "EGL_MULTISAMPLE_RESOLVE",		# 0x3099
    "EGL_MULTISAMPLE_RESOLVE_DEFAULT",		# 0x309A
    "EGL_MULTISAMPLE_RESOLVE_BOX",		# 0x309B
    "EGL_CL_EVENT_HANDLE",		# 0x309C
    "EGL_GL_COLORSPACE",		# 0x309D
    "EGL_OPENGL_ES_API",		# 0x30A0
    "EGL_OPENVG_API",		# 0x30A1
    "EGL_OPENGL_API",		# 0x30A2
    "EGL_NATIVE_PIXMAP_KHR",		# 0x30B0
    "EGL_GL_TEXTURE_2D",		# 0x30B1
    "EGL_GL_TEXTURE_3D",		# 0x30B2
    "EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X",		# 0x30B3
    "EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X",		# 0x30B4
    "EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y",		# 0x30B5
    "EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y",		# 0x30B6
    "EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z",		# 0x30B7
    "EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z",		# 0x30B8
    "EGL_GL_RENDERBUFFER",		# 0x30B9
    "EGL_VG_PARENT_IMAGE_KHR",		# 0x30BA
    "EGL_GL_TEXTURE_LEVEL",		# 0x30BC
    "EGL_GL_TEXTURE_ZOFFSET",		# 0x30BD
    "EGL_POST_SUB_BUFFER_SUPPORTED_NV",		# 0x30BE
    "EGL_CONTEXT_OPENGL_ROBUST_ACCESS_EXT",		# 0x30BF
    "EGL_FORMAT_RGB_565_EXACT_KHR",		# 0x30C0
    "EGL_FORMAT_RGB_565_KHR",		# 0x30C1
    "EGL_FORMAT_RGBA_8888_EXACT_KHR",		# 0x30C2
    "EGL_FORMAT_RGBA_8888_KHR",		# 0x30C3
    "EGL_MAP_PRESERVE_PIXELS_KHR",		# 0x30C4
    "EGL_LOCK_USAGE_HINT_KHR",		# 0x30C5
    "EGL_BITMAP_POINTER_KHR",		# 0x30C6
    "EGL_BITMAP_PITCH_KHR",		# 0x30C7
    "EGL_BITMAP_ORIGIN_KHR",		# 0x30C8
    "EGL_BITMAP_PIXEL_RED_OFFSET_KHR",		# 0x30C9
    "EGL_BITMAP_PIXEL_GREEN_OFFSET_KHR",		# 0x30CA
    "EGL_BITMAP_PIXEL_BLUE_OFFSET_KHR",		# 0x30CB
    "EGL_BITMAP_PIXEL_ALPHA_OFFSET_KHR",		# 0x30CC
    "EGL_BITMAP_PIXEL_LUMINANCE_OFFSET_KHR",		# 0x30CD
    "EGL_LOWER_LEFT_KHR",		# 0x30CE
    "EGL_UPPER_LEFT_KHR",		# 0x30CF
    "EGL_IMAGE_PRESERVED_KHR",		# 0x30D2
    #"EGL_SHARED_IMAGE_NOK",		# 0x30DA
    "EGL_COVERAGE_BUFFERS_NV",		# 0x30E0
    "EGL_COVERAGE_SAMPLES_NV",		# 0x30E1
    "EGL_DEPTH_ENCODING_NV",		# 0x30E2
    "EGL_DEPTH_ENCODING_NONLINEAR_NV",		# 0x30E3
    "EGL_SYNC_PRIOR_COMMANDS_COMPLETE_NV",		# 0x30E6
    "EGL_SYNC_STATUS_NV",		# 0x30E7
    "EGL_SIGNALED_NV",		# 0x30E8
    "EGL_UNSIGNALED_NV",		# 0x30E9
    "EGL_ALREADY_SIGNALED_NV",		# 0x30EA
    "EGL_TIMEOUT_EXPIRED_NV",		# 0x30EB
    "EGL_CONDITION_SATISFIED_NV",		# 0x30EC
    "EGL_SYNC_TYPE_NV",		# 0x30ED
    "EGL_SYNC_CONDITION_NV",		# 0x30EE
    "EGL_SYNC_FENCE_NV",		# 0x30EF
    "EGL_SYNC_PRIOR_COMMANDS_COMPLETE",		# 0x30F0
    "EGL_SYNC_STATUS",		# 0x30F1
    "EGL_SIGNALED",		# 0x30F2
    "EGL_UNSIGNALED",		# 0x30F3
    "EGL_TIMEOUT_EXPIRED",		# 0x30F5
    "EGL_CONDITION_SATISFIED",		# 0x30F6
    "EGL_SYNC_TYPE",		# 0x30F7
    "EGL_SYNC_CONDITION",		# 0x30F8
    "EGL_SYNC_FENCE",		# 0x30F9
    "EGL_SYNC_REUSABLE_KHR",		# 0x30FA
    "EGL_CONTEXT_MINOR_VERSION",		# 0x30FB
    "EGL_CONTEXT_FLAGS_KHR",		# 0x30FC
    "EGL_CONTEXT_OPENGL_PROFILE_MASK",		# 0x30FD
    "EGL_SYNC_CL_EVENT",		# 0x30FE
    "EGL_SYNC_CL_EVENT_COMPLETE",		# 0x30FF
    "EGL_CONTEXT_PRIORITY_LEVEL_IMG",		# 0x3100
    "EGL_CONTEXT_PRIORITY_HIGH_IMG",		# 0x3101
    "EGL_CONTEXT_PRIORITY_MEDIUM_IMG",		# 0x3102
    "EGL_CONTEXT_PRIORITY_LOW_IMG",		# 0x3103
    "EGL_BITMAP_PIXEL_SIZE_KHR",		# 0x3110
    "EGL_COVERAGE_SAMPLE_RESOLVE_NV",		# 0x3131
    "EGL_COVERAGE_SAMPLE_RESOLVE_DEFAULT_NV",		# 0x3132
    "EGL_COVERAGE_SAMPLE_RESOLVE_NONE_NV",		# 0x3133
    "EGL_MULTIVIEW_VIEW_COUNT_EXT",		# 0x3134
    "EGL_AUTO_STEREO_NV",		# 0x3136
    "EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT",		# 0x3138
    "EGL_BUFFER_AGE_EXT",		# 0x313D
    "EGL_NATIVE_BUFFER_ANDROID",		# 0x3140
    "EGL_PLATFORM_ANDROID_KHR",		# 0x3141
    "EGL_RECORDABLE_ANDROID",		# 0x3142
    "EGL_SYNC_NATIVE_FENCE_ANDROID",		# 0x3144
    "EGL_SYNC_NATIVE_FENCE_FD_ANDROID",		# 0x3145
    "EGL_SYNC_NATIVE_FENCE_SIGNALED_ANDROID",		# 0x3146
    "EGL_FRAMEBUFFER_TARGET_ANDROID",		# 0x3147
    "EGL_CONTEXT_OPENGL_DEBUG",		# 0x31B0
    "EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE",		# 0x31B1
    "EGL_CONTEXT_OPENGL_ROBUST_ACCESS",		# 0x31B2
    "EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR",		# 0x31BD
    "EGL_NO_RESET_NOTIFICATION",		# 0x31BE
    "EGL_LOSE_CONTEXT_ON_RESET",		# 0x31BF
    "EGL_DRM_BUFFER_FORMAT_MESA",		# 0x31D0
    "EGL_DRM_BUFFER_USE_MESA",		# 0x31D1
    "EGL_DRM_BUFFER_FORMAT_ARGB32_MESA",		# 0x31D2
    "EGL_DRM_BUFFER_MESA",		# 0x31D3
    "EGL_DRM_BUFFER_STRIDE_MESA",		# 0x31D4
    "EGL_PLATFORM_X11_KHR",		# 0x31D5
    "EGL_PLATFORM_X11_SCREEN_KHR",		# 0x31D6
    "EGL_PLATFORM_GBM_KHR",		# 0x31D7
    "EGL_PLATFORM_WAYLAND_KHR",		# 0x31D8
    "EGL_STREAM_FIFO_LENGTH_KHR",		# 0x31FC
    "EGL_STREAM_TIME_NOW_KHR",		# 0x31FD
    "EGL_STREAM_TIME_CONSUMER_KHR",		# 0x31FE
    "EGL_STREAM_TIME_PRODUCER_KHR",		# 0x31FF
    "EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE",		# 0x3200
    "EGL_CONSUMER_LATENCY_USEC_KHR",		# 0x3210
    "EGL_PRODUCER_FRAME_KHR",		# 0x3212
    "EGL_CONSUMER_FRAME_KHR",		# 0x3213
    "EGL_STREAM_STATE_KHR",		# 0x3214
    "EGL_STREAM_STATE_CREATED_KHR",		# 0x3215
    "EGL_STREAM_STATE_CONNECTING_KHR",		# 0x3216
    "EGL_STREAM_STATE_EMPTY_KHR",		# 0x3217
    "EGL_STREAM_STATE_NEW_FRAME_AVAILABLE_KHR",		# 0x3218
    "EGL_STREAM_STATE_OLD_FRAME_AVAILABLE_KHR",		# 0x3219
    "EGL_STREAM_STATE_DISCONNECTED_KHR",		# 0x321A
    "EGL_BAD_STREAM_KHR",		# 0x321B
    "EGL_BAD_STATE_KHR",		# 0x321C
    #"EGL_BUFFER_COUNT_NV",		# 0x321D
    "EGL_CONSUMER_ACQUIRE_TIMEOUT_USEC_KHR",		# 0x321E
    "EGL_SYNC_NEW_FRAME_NV",		# 0x321F
    "EGL_LINUX_DMA_BUF_EXT",		# 0x3270
    "EGL_LINUX_DRM_FOURCC_EXT",		# 0x3271
    "EGL_DMA_BUF_PLANE0_FD_EXT",		# 0x3272
    "EGL_DMA_BUF_PLANE0_OFFSET_EXT",		# 0x3273
    "EGL_DMA_BUF_PLANE0_PITCH_EXT",		# 0x3274
    "EGL_DMA_BUF_PLANE1_FD_EXT",		# 0x3275
    "EGL_DMA_BUF_PLANE1_OFFSET_EXT",		# 0x3276
    "EGL_DMA_BUF_PLANE1_PITCH_EXT",		# 0x3277
    "EGL_DMA_BUF_PLANE2_FD_EXT",		# 0x3278
    "EGL_DMA_BUF_PLANE2_OFFSET_EXT",		# 0x3279
    "EGL_DMA_BUF_PLANE2_PITCH_EXT",		# 0x327A
    "EGL_YUV_COLOR_SPACE_HINT_EXT",		# 0x327B
    "EGL_SAMPLE_RANGE_HINT_EXT",		# 0x327C
    "EGL_YUV_CHROMA_HORIZONTAL_SITING_HINT_EXT",		# 0x327D
    "EGL_YUV_CHROMA_VERTICAL_SITING_HINT_EXT",		# 0x327E
    "EGL_ITU_REC601_EXT",		# 0x327F
    "EGL_ITU_REC709_EXT",		# 0x3280
    "EGL_ITU_REC2020_EXT",		# 0x3281
    "EGL_YUV_FULL_RANGE_EXT",		# 0x3282
    "EGL_YUV_NARROW_RANGE_EXT",		# 0x3283
    "EGL_YUV_CHROMA_SITING_0_EXT",		# 0x3284
    "EGL_YUV_CHROMA_SITING_0_5_EXT",		# 0x3285
    "EGL_DISCARD_SAMPLES_ARM",		# 0x3286
    "EGL_PROTECTED_CONTENT_EXT",		# 0x32C0
    "EGL_COLOR_FORMAT_HI",		# 0x8F70
    "EGL_COLOR_RGB_HI",		# 0x8F71
    "EGL_COLOR_RGBA_HI",		# 0x8F72
    "EGL_COLOR_ARGB_HI",		# 0x8F73
    "EGL_CLIENT_PIXMAP_POINTER_HI",		# 0x8F74
    #"EGL_FOREVER",		# 0xFFFFFFFFFFFFFFFF
])

########NEW FILE########
__FILENAME__ = glapi
##########################################################################
#
# Copyright 2011 Jose Fonseca
# Copyright 2008-2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""GL API description.

Most of these were automatically generated from Khronos OpenGL spec files by
the specs/scripts/glspec.py script, and then manually edited to cover the
corner cases correctly.

"""


from stdapi import *
from gltypes import *
import glparams


def GlFunction(*args, **kwargs):
    kwargs.setdefault('call', 'APIENTRY')
    return Function(*args, **kwargs)


def InGlString(charType, length, argName):
    # Helper function to describe input strings, where string length can be
    # passed as argument.
    lengthExpr = '((%s) >= 0 ? (%s) : strlen(%s))' % (length, length, argName)
    return In(String(Const(charType), lengthExpr), argName)

def OutGlString(charType, lengthPtr, argName):
    # Helper function to describe output strings, where string length can be
    # returned as a pointer.
    lengthExpr = '((%s) ? *(%s) : strlen(%s))' % (lengthPtr, lengthPtr, argName)
    return Out(String(charType, lengthExpr), argName)


glapi = Module('GL')


glapi.addFunctions([
    # GL_VERSION_1_0
    GlFunction(Void, "glCullFace", [(GLenum, "mode")]),
    GlFunction(Void, "glFrontFace", [(GLenum, "mode")]),
    GlFunction(Void, "glHint", [(GLenum, "target"), (GLenum, "mode")]),
    GlFunction(Void, "glLineWidth", [(GLfloat, "width")]),
    GlFunction(Void, "glPointSize", [(GLfloat, "size")]),
    GlFunction(Void, "glPolygonMode", [(GLenum, "face"), (GLenum, "mode")]),
    GlFunction(Void, "glScissor", [(GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glTexParameterf", [(GLenum, "target"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glTexParameterfv", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTexParameteri", [(GLenum, "target"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glTexParameteriv", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTexImage1D", [(GLenum, "target"), (GLint, "level"), (GLenum_int, "internalformat"), (GLsizei, "width"), (GLint, "border"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTexImage1D_size(format, type, width)"), "pixels")]),
    GlFunction(Void, "glTexImage2D", [(GLenum, "target"), (GLint, "level"), (GLenum_int, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLint, "border"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTexImage2D_size(format, type, width, height)"), "pixels")]),
    GlFunction(Void, "glDrawBuffer", [(GLenum, "mode")]),
    GlFunction(Void, "glClear", [(GLbitfield_attrib, "mask")]),
    GlFunction(Void, "glClearColor", [(GLfloat, "red"), (GLfloat, "green"), (GLfloat, "blue"), (GLfloat, "alpha")]),
    GlFunction(Void, "glClearStencil", [(GLint, "s")]),
    GlFunction(Void, "glClearDepth", [(GLdouble, "depth")]),
    GlFunction(Void, "glStencilMask", [(GLuint, "mask")]),
    GlFunction(Void, "glColorMask", [(GLboolean, "red"), (GLboolean, "green"), (GLboolean, "blue"), (GLboolean, "alpha")]),
    GlFunction(Void, "glDepthMask", [(GLboolean, "flag")]),
    GlFunction(Void, "glDisable", [(GLenum, "cap")]),
    GlFunction(Void, "glEnable", [(GLenum, "cap")]),
    GlFunction(Void, "glFinish", []),
    GlFunction(Void, "glFlush", []),
    GlFunction(Void, "glBlendFunc", [(GLenum, "sfactor"), (GLenum, "dfactor")]),
    GlFunction(Void, "glLogicOp", [(GLenum, "opcode")]),
    GlFunction(Void, "glStencilFunc", [(GLenum, "func"), (GLint, "ref"), (GLuint, "mask")]),
    GlFunction(Void, "glStencilOp", [(GLenum, "fail"), (GLenum, "zfail"), (GLenum, "zpass")]),
    GlFunction(Void, "glDepthFunc", [(GLenum, "func")]),
    GlFunction(Void, "glPixelStoref", [(GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glPixelStorei", [(GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glReadBuffer", [(GLenum, "mode")]),
    GlFunction(Void, "glReadPixels", [(GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLenum, "type"), Out(GLpointer, "pixels")]),
    GlFunction(Void, "glGetBooleanv", [(GLenum, "pname"), Out(Array(GLboolean, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetDoublev", [(GLenum, "pname"), Out(Array(GLdouble, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(GLenum_error, "glGetError", [], sideeffects=False),
    GlFunction(Void, "glGetFloatv", [(GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetIntegerv", [(GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(String(Const(GLubyte)), "glGetString", [(GLenum, "name")], sideeffects=False),
    GlFunction(Void, "glGetTexImage", [(GLenum, "target"), (GLint, "level"), (GLenum, "format"), (GLenum, "type"), Out(GLpointer, "pixels")]),
    GlFunction(Void, "glGetTexParameterfv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTexParameteriv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTexLevelParameterfv", [(GLenum, "target"), (GLint, "level"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTexLevelParameteriv", [(GLenum, "target"), (GLint, "level"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(GLboolean, "glIsEnabled", [(GLenum, "cap")], sideeffects=False),
    GlFunction(Void, "glDepthRange", [(GLdouble, "zNear"), (GLdouble, "zFar")]),
    GlFunction(Void, "glViewport", [(GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),

    # GL_VERSION_1_0_DEPRECATED
    GlFunction(Void, "glNewList", [(GLlist, "list"), (GLenum, "mode")]),
    GlFunction(Void, "glEndList", []),
    GlFunction(Void, "glCallList", [(GLlist, "list")]),
    GlFunction(Void, "glCallLists", [(GLsizei, "n"), (GLenum, "type"), (Blob(Const(GLvoid), "_glCallLists_size(n, type)"), "lists")]),
    GlFunction(Void, "glDeleteLists", [(GLlist, "list"), (GLsizei, "range")]),
    GlFunction(Handle("list", GLuint, "range"), "glGenLists", [(GLsizei, "range")]),
    GlFunction(Void, "glListBase", [(GLuint, "base")]),
    GlFunction(Void, "glBegin", [(GLenum_mode, "mode")]),
    GlFunction(Void, "glBitmap", [(GLsizei, "width"), (GLsizei, "height"), (GLfloat, "xorig"), (GLfloat, "yorig"), (GLfloat, "xmove"), (GLfloat, "ymove"), (Blob(Const(GLubyte), "_glBitmap_size(width, height)"), "bitmap")]),
    GlFunction(Void, "glColor3b", [(GLbyte, "red"), (GLbyte, "green"), (GLbyte, "blue")]),
    GlFunction(Void, "glColor3bv", [(Array(Const(GLbyte), 3), "v")]),
    GlFunction(Void, "glColor3d", [(GLdouble, "red"), (GLdouble, "green"), (GLdouble, "blue")]),
    GlFunction(Void, "glColor3dv", [(Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glColor3f", [(GLfloat, "red"), (GLfloat, "green"), (GLfloat, "blue")]),
    GlFunction(Void, "glColor3fv", [(Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glColor3i", [(GLint, "red"), (GLint, "green"), (GLint, "blue")]),
    GlFunction(Void, "glColor3iv", [(Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glColor3s", [(GLshort, "red"), (GLshort, "green"), (GLshort, "blue")]),
    GlFunction(Void, "glColor3sv", [(Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glColor3ub", [(GLubyte, "red"), (GLubyte, "green"), (GLubyte, "blue")]),
    GlFunction(Void, "glColor3ubv", [(Array(Const(GLubyte), 3), "v")]),
    GlFunction(Void, "glColor3ui", [(GLuint, "red"), (GLuint, "green"), (GLuint, "blue")]),
    GlFunction(Void, "glColor3uiv", [(Array(Const(GLuint), 3), "v")]),
    GlFunction(Void, "glColor3us", [(GLushort, "red"), (GLushort, "green"), (GLushort, "blue")]),
    GlFunction(Void, "glColor3usv", [(Array(Const(GLushort), 3), "v")]),
    GlFunction(Void, "glColor4b", [(GLbyte, "red"), (GLbyte, "green"), (GLbyte, "blue"), (GLbyte, "alpha")]),
    GlFunction(Void, "glColor4bv", [(Array(Const(GLbyte), 4), "v")]),
    GlFunction(Void, "glColor4d", [(GLdouble, "red"), (GLdouble, "green"), (GLdouble, "blue"), (GLdouble, "alpha")]),
    GlFunction(Void, "glColor4dv", [(Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glColor4f", [(GLfloat, "red"), (GLfloat, "green"), (GLfloat, "blue"), (GLfloat, "alpha")]),
    GlFunction(Void, "glColor4fv", [(Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glColor4i", [(GLint, "red"), (GLint, "green"), (GLint, "blue"), (GLint, "alpha")]),
    GlFunction(Void, "glColor4iv", [(Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glColor4s", [(GLshort, "red"), (GLshort, "green"), (GLshort, "blue"), (GLshort, "alpha")]),
    GlFunction(Void, "glColor4sv", [(Array(Const(GLshort), 4), "v")]),
    GlFunction(Void, "glColor4ub", [(GLubyte, "red"), (GLubyte, "green"), (GLubyte, "blue"), (GLubyte, "alpha")]),
    GlFunction(Void, "glColor4ubv", [(Array(Const(GLubyte), 4), "v")]),
    GlFunction(Void, "glColor4ui", [(GLuint, "red"), (GLuint, "green"), (GLuint, "blue"), (GLuint, "alpha")]),
    GlFunction(Void, "glColor4uiv", [(Array(Const(GLuint), 4), "v")]),
    GlFunction(Void, "glColor4us", [(GLushort, "red"), (GLushort, "green"), (GLushort, "blue"), (GLushort, "alpha")]),
    GlFunction(Void, "glColor4usv", [(Array(Const(GLushort), 4), "v")]),
    GlFunction(Void, "glEdgeFlag", [(GLboolean, "flag")]),
    GlFunction(Void, "glEdgeFlagv", [(Pointer(Const(GLboolean)), "flag")]),
    GlFunction(Void, "glEnd", []),
    GlFunction(Void, "glIndexd", [(GLdouble, "c")]),
    GlFunction(Void, "glIndexdv", [(Pointer(Const(GLdouble)), "c")]),
    GlFunction(Void, "glIndexf", [(GLfloat, "c")]),
    GlFunction(Void, "glIndexfv", [(Pointer(Const(GLfloat)), "c")]),
    GlFunction(Void, "glIndexi", [(GLint, "c")]),
    GlFunction(Void, "glIndexiv", [(Pointer(Const(GLint)), "c")]),
    GlFunction(Void, "glIndexs", [(GLshort, "c")]),
    GlFunction(Void, "glIndexsv", [(Pointer(Const(GLshort)), "c")]),
    GlFunction(Void, "glNormal3b", [(GLbyte, "nx"), (GLbyte, "ny"), (GLbyte, "nz")]),
    GlFunction(Void, "glNormal3bv", [(Array(Const(GLbyte), 3), "v")]),
    GlFunction(Void, "glNormal3d", [(GLdouble, "nx"), (GLdouble, "ny"), (GLdouble, "nz")]),
    GlFunction(Void, "glNormal3dv", [(Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glNormal3f", [(GLfloat, "nx"), (GLfloat, "ny"), (GLfloat, "nz")]),
    GlFunction(Void, "glNormal3fv", [(Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glNormal3i", [(GLint, "nx"), (GLint, "ny"), (GLint, "nz")]),
    GlFunction(Void, "glNormal3iv", [(Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glNormal3s", [(GLshort, "nx"), (GLshort, "ny"), (GLshort, "nz")]),
    GlFunction(Void, "glNormal3sv", [(Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glRasterPos2d", [(GLdouble, "x"), (GLdouble, "y")]),
    GlFunction(Void, "glRasterPos2dv", [(Array(Const(GLdouble), 2), "v")]),
    GlFunction(Void, "glRasterPos2f", [(GLfloat, "x"), (GLfloat, "y")]),
    GlFunction(Void, "glRasterPos2fv", [(Array(Const(GLfloat), 2), "v")]),
    GlFunction(Void, "glRasterPos2i", [(GLint, "x"), (GLint, "y")]),
    GlFunction(Void, "glRasterPos2iv", [(Array(Const(GLint), 2), "v")]),
    GlFunction(Void, "glRasterPos2s", [(GLshort, "x"), (GLshort, "y")]),
    GlFunction(Void, "glRasterPos2sv", [(Array(Const(GLshort), 2), "v")]),
    GlFunction(Void, "glRasterPos3d", [(GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glRasterPos3dv", [(Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glRasterPos3f", [(GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glRasterPos3fv", [(Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glRasterPos3i", [(GLint, "x"), (GLint, "y"), (GLint, "z")]),
    GlFunction(Void, "glRasterPos3iv", [(Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glRasterPos3s", [(GLshort, "x"), (GLshort, "y"), (GLshort, "z")]),
    GlFunction(Void, "glRasterPos3sv", [(Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glRasterPos4d", [(GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glRasterPos4dv", [(Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glRasterPos4f", [(GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glRasterPos4fv", [(Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glRasterPos4i", [(GLint, "x"), (GLint, "y"), (GLint, "z"), (GLint, "w")]),
    GlFunction(Void, "glRasterPos4iv", [(Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glRasterPos4s", [(GLshort, "x"), (GLshort, "y"), (GLshort, "z"), (GLshort, "w")]),
    GlFunction(Void, "glRasterPos4sv", [(Array(Const(GLshort), 4), "v")]),
    GlFunction(Void, "glRectd", [(GLdouble, "x1"), (GLdouble, "y1"), (GLdouble, "x2"), (GLdouble, "y2")]),
    GlFunction(Void, "glRectdv", [(Array(Const(GLdouble), 2), "v1"), (Array(Const(GLdouble), 2), "v2")]),
    GlFunction(Void, "glRectf", [(GLfloat, "x1"), (GLfloat, "y1"), (GLfloat, "x2"), (GLfloat, "y2")]),
    GlFunction(Void, "glRectfv", [(Array(Const(GLfloat), 2), "v1"), (Array(Const(GLfloat), 2), "v2")]),
    GlFunction(Void, "glRecti", [(GLint, "x1"), (GLint, "y1"), (GLint, "x2"), (GLint, "y2")]),
    GlFunction(Void, "glRectiv", [(Array(Const(GLint), 2), "v1"), (Array(Const(GLint), 2), "v2")]),
    GlFunction(Void, "glRects", [(GLshort, "x1"), (GLshort, "y1"), (GLshort, "x2"), (GLshort, "y2")]),
    GlFunction(Void, "glRectsv", [(Array(Const(GLshort), 2), "v1"), (Array(Const(GLshort), 2), "v2")]),
    GlFunction(Void, "glTexCoord1d", [(GLdouble, "s")]),
    GlFunction(Void, "glTexCoord1dv", [(Pointer(Const(GLdouble)), "v")]),
    GlFunction(Void, "glTexCoord1f", [(GLfloat, "s")]),
    GlFunction(Void, "glTexCoord1fv", [(Pointer(Const(GLfloat)), "v")]),
    GlFunction(Void, "glTexCoord1i", [(GLint, "s")]),
    GlFunction(Void, "glTexCoord1iv", [(Pointer(Const(GLint)), "v")]),
    GlFunction(Void, "glTexCoord1s", [(GLshort, "s")]),
    GlFunction(Void, "glTexCoord1sv", [(Pointer(Const(GLshort)), "v")]),
    GlFunction(Void, "glTexCoord2d", [(GLdouble, "s"), (GLdouble, "t")]),
    GlFunction(Void, "glTexCoord2dv", [(Array(Const(GLdouble), 2), "v")]),
    GlFunction(Void, "glTexCoord2f", [(GLfloat, "s"), (GLfloat, "t")]),
    GlFunction(Void, "glTexCoord2fv", [(Array(Const(GLfloat), 2), "v")]),
    GlFunction(Void, "glTexCoord2i", [(GLint, "s"), (GLint, "t")]),
    GlFunction(Void, "glTexCoord2iv", [(Array(Const(GLint), 2), "v")]),
    GlFunction(Void, "glTexCoord2s", [(GLshort, "s"), (GLshort, "t")]),
    GlFunction(Void, "glTexCoord2sv", [(Array(Const(GLshort), 2), "v")]),
    GlFunction(Void, "glTexCoord3d", [(GLdouble, "s"), (GLdouble, "t"), (GLdouble, "r")]),
    GlFunction(Void, "glTexCoord3dv", [(Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glTexCoord3f", [(GLfloat, "s"), (GLfloat, "t"), (GLfloat, "r")]),
    GlFunction(Void, "glTexCoord3fv", [(Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glTexCoord3i", [(GLint, "s"), (GLint, "t"), (GLint, "r")]),
    GlFunction(Void, "glTexCoord3iv", [(Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glTexCoord3s", [(GLshort, "s"), (GLshort, "t"), (GLshort, "r")]),
    GlFunction(Void, "glTexCoord3sv", [(Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glTexCoord4d", [(GLdouble, "s"), (GLdouble, "t"), (GLdouble, "r"), (GLdouble, "q")]),
    GlFunction(Void, "glTexCoord4dv", [(Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glTexCoord4f", [(GLfloat, "s"), (GLfloat, "t"), (GLfloat, "r"), (GLfloat, "q")]),
    GlFunction(Void, "glTexCoord4fv", [(Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glTexCoord4i", [(GLint, "s"), (GLint, "t"), (GLint, "r"), (GLint, "q")]),
    GlFunction(Void, "glTexCoord4iv", [(Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glTexCoord4s", [(GLshort, "s"), (GLshort, "t"), (GLshort, "r"), (GLshort, "q")]),
    GlFunction(Void, "glTexCoord4sv", [(Array(Const(GLshort), 4), "v")]),
    GlFunction(Void, "glVertex2d", [(GLdouble, "x"), (GLdouble, "y")]),
    GlFunction(Void, "glVertex2dv", [(Array(Const(GLdouble), 2), "v")]),
    GlFunction(Void, "glVertex2f", [(GLfloat, "x"), (GLfloat, "y")]),
    GlFunction(Void, "glVertex2fv", [(Array(Const(GLfloat), 2), "v")]),
    GlFunction(Void, "glVertex2i", [(GLint, "x"), (GLint, "y")]),
    GlFunction(Void, "glVertex2iv", [(Array(Const(GLint), 2), "v")]),
    GlFunction(Void, "glVertex2s", [(GLshort, "x"), (GLshort, "y")]),
    GlFunction(Void, "glVertex2sv", [(Array(Const(GLshort), 2), "v")]),
    GlFunction(Void, "glVertex3d", [(GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glVertex3dv", [(Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glVertex3f", [(GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glVertex3fv", [(Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glVertex3i", [(GLint, "x"), (GLint, "y"), (GLint, "z")]),
    GlFunction(Void, "glVertex3iv", [(Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glVertex3s", [(GLshort, "x"), (GLshort, "y"), (GLshort, "z")]),
    GlFunction(Void, "glVertex3sv", [(Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glVertex4d", [(GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glVertex4dv", [(Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glVertex4f", [(GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glVertex4fv", [(Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glVertex4i", [(GLint, "x"), (GLint, "y"), (GLint, "z"), (GLint, "w")]),
    GlFunction(Void, "glVertex4iv", [(Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glVertex4s", [(GLshort, "x"), (GLshort, "y"), (GLshort, "z"), (GLshort, "w")]),
    GlFunction(Void, "glVertex4sv", [(Array(Const(GLshort), 4), "v")]),
    GlFunction(Void, "glClipPlane", [(GLenum, "plane"), (Array(Const(GLdouble), 4), "equation")]),
    GlFunction(Void, "glColorMaterial", [(GLenum, "face"), (GLenum, "mode")]),
    GlFunction(Void, "glFogf", [(GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glFogfv", [(GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glFogi", [(GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glFogiv", [(GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glLightf", [(GLenum, "light"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glLightfv", [(GLenum, "light"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glLighti", [(GLenum, "light"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glLightiv", [(GLenum, "light"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glLightModelf", [(GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glLightModelfv", [(GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glLightModeli", [(GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glLightModeliv", [(GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glLineStipple", [(GLint, "factor"), (GLushort, "pattern")]),
    GlFunction(Void, "glMaterialf", [(GLenum, "face"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glMaterialfv", [(GLenum, "face"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glMateriali", [(GLenum, "face"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glMaterialiv", [(GLenum, "face"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glPolygonStipple", [(Array(Const(GLubyte), "_glPolygonStipple_size()"), "mask")]),
    GlFunction(Void, "glShadeModel", [(GLenum, "mode")]),
    GlFunction(Void, "glTexEnvf", [(GLenum, "target"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glTexEnvfv", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTexEnvi", [(GLenum, "target"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glTexEnviv", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTexGend", [(GLenum, "coord"), (GLenum, "pname"), (GLdouble, "param")]),
    GlFunction(Void, "glTexGendv", [(GLenum, "coord"), (GLenum, "pname"), (Array(Const(GLdouble), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTexGenf", [(GLenum, "coord"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glTexGenfv", [(GLenum, "coord"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTexGeni", [(GLenum, "coord"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glTexGeniv", [(GLenum, "coord"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glFeedbackBuffer", [(GLsizei, "size"), (GLenum, "type"), Out(Array(GLfloat, "size"), "buffer")]),
    GlFunction(Void, "glSelectBuffer", [(GLsizei, "size"), Out(Array(GLuint, "size"), "buffer")]),
    GlFunction(Alias("GLint", GLenum), "glRenderMode", [(GLenum, "mode")]),
    GlFunction(Void, "glInitNames", []),
    GlFunction(Void, "glLoadName", [(GLuint, "name")]),
    GlFunction(Void, "glPassThrough", [(GLfloat, "token")]),
    GlFunction(Void, "glPopName", []),
    GlFunction(Void, "glPushName", [(GLuint, "name")]),
    GlFunction(Void, "glClearAccum", [(GLfloat, "red"), (GLfloat, "green"), (GLfloat, "blue"), (GLfloat, "alpha")]),
    GlFunction(Void, "glClearIndex", [(GLfloat, "c")]),
    GlFunction(Void, "glIndexMask", [(GLuint, "mask")]),
    GlFunction(Void, "glAccum", [(GLenum, "op"), (GLfloat, "value")]),
    GlFunction(Void, "glPopAttrib", []),
    GlFunction(Void, "glPushAttrib", [(GLbitfield_attrib, "mask")]),
    GlFunction(Void, "glMap1d", [(GLenum, "target"), (GLdouble, "u1"), (GLdouble, "u2"), (GLint, "stride"), (GLint, "order"), (Array(Const(GLdouble), "_glMap1d_size(target, stride, order)"), "points")]),
    GlFunction(Void, "glMap1f", [(GLenum, "target"), (GLfloat, "u1"), (GLfloat, "u2"), (GLint, "stride"), (GLint, "order"), (Array(Const(GLfloat), "_glMap1f_size(target, stride, order)"), "points")]),
    GlFunction(Void, "glMap2d", [(GLenum, "target"), (GLdouble, "u1"), (GLdouble, "u2"), (GLint, "ustride"), (GLint, "uorder"), (GLdouble, "v1"), (GLdouble, "v2"), (GLint, "vstride"), (GLint, "vorder"), (Array(Const(GLdouble), "_glMap2d_size(target, ustride, uorder, vstride, vorder)"), "points")]),
    GlFunction(Void, "glMap2f", [(GLenum, "target"), (GLfloat, "u1"), (GLfloat, "u2"), (GLint, "ustride"), (GLint, "uorder"), (GLfloat, "v1"), (GLfloat, "v2"), (GLint, "vstride"), (GLint, "vorder"), (Array(Const(GLfloat), "_glMap2f_size(target, ustride, uorder, vstride, vorder)"), "points")]),
    GlFunction(Void, "glMapGrid1d", [(GLint, "un"), (GLdouble, "u1"), (GLdouble, "u2")]),
    GlFunction(Void, "glMapGrid1f", [(GLint, "un"), (GLfloat, "u1"), (GLfloat, "u2")]),
    GlFunction(Void, "glMapGrid2d", [(GLint, "un"), (GLdouble, "u1"), (GLdouble, "u2"), (GLint, "vn"), (GLdouble, "v1"), (GLdouble, "v2")]),
    GlFunction(Void, "glMapGrid2f", [(GLint, "un"), (GLfloat, "u1"), (GLfloat, "u2"), (GLint, "vn"), (GLfloat, "v1"), (GLfloat, "v2")]),
    GlFunction(Void, "glEvalCoord1d", [(GLdouble, "u")]),
    GlFunction(Void, "glEvalCoord1dv", [(Pointer(Const(GLdouble)), "u")]),
    GlFunction(Void, "glEvalCoord1f", [(GLfloat, "u")]),
    GlFunction(Void, "glEvalCoord1fv", [(Pointer(Const(GLfloat)), "u")]),
    GlFunction(Void, "glEvalCoord2d", [(GLdouble, "u"), (GLdouble, "v")]),
    GlFunction(Void, "glEvalCoord2dv", [(Array(Const(GLdouble), 2), "u")]),
    GlFunction(Void, "glEvalCoord2f", [(GLfloat, "u"), (GLfloat, "v")]),
    GlFunction(Void, "glEvalCoord2fv", [(Array(Const(GLfloat), 2), "u")]),
    GlFunction(Void, "glEvalMesh1", [(GLenum, "mode"), (GLint, "i1"), (GLint, "i2")]),
    GlFunction(Void, "glEvalPoint1", [(GLint, "i")]),
    GlFunction(Void, "glEvalMesh2", [(GLenum, "mode"), (GLint, "i1"), (GLint, "i2"), (GLint, "j1"), (GLint, "j2")]),
    GlFunction(Void, "glEvalPoint2", [(GLint, "i"), (GLint, "j")]),
    GlFunction(Void, "glAlphaFunc", [(GLenum, "func"), (GLfloat, "ref")]),
    GlFunction(Void, "glPixelZoom", [(GLfloat, "xfactor"), (GLfloat, "yfactor")]),
    GlFunction(Void, "glPixelTransferf", [(GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glPixelTransferi", [(GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glPixelMapfv", [(GLenum, "map"), (GLsizei, "mapsize"), (Array(Const(GLfloat), "mapsize"), "values")]),
    GlFunction(Void, "glPixelMapuiv", [(GLenum, "map"), (GLsizei, "mapsize"), (Array(Const(GLuint), "mapsize"), "values")]),
    GlFunction(Void, "glPixelMapusv", [(GLenum, "map"), (GLsizei, "mapsize"), (Array(Const(GLushort), "mapsize"), "values")]),
    GlFunction(Void, "glCopyPixels", [(GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "type")]),
    GlFunction(Void, "glDrawPixels", [(GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glDrawPixels_size(format, type, width, height)"), "pixels")]),
    GlFunction(Void, "glGetClipPlane", [(GLenum, "plane"), Out(Array(GLdouble, 4), "equation")], sideeffects=False),
    GlFunction(Void, "glGetLightfv", [(GLenum, "light"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetLightiv", [(GLenum, "light"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMapdv", [(GLenum, "target"), (GLenum, "query"), Out(Pointer(GLdouble), "v")], sideeffects=False),
    GlFunction(Void, "glGetMapfv", [(GLenum, "target"), (GLenum, "query"), Out(Pointer(GLfloat), "v")], sideeffects=False),
    GlFunction(Void, "glGetMapiv", [(GLenum, "target"), (GLenum, "query"), Out(Pointer(GLint), "v")], sideeffects=False),
    GlFunction(Void, "glGetMaterialfv", [(GLenum, "face"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMaterialiv", [(GLenum, "face"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetPixelMapfv", [(GLenum, "map"), Out(Pointer(GLfloat), "values")]),
    GlFunction(Void, "glGetPixelMapuiv", [(GLenum, "map"), Out(Pointer(GLuint), "values")]),
    GlFunction(Void, "glGetPixelMapusv", [(GLenum, "map"), Out(Pointer(GLushort), "values")]),
    GlFunction(Void, "glGetPolygonStipple", [Out(OpaquePointer(GLubyte), "mask")]),
    GlFunction(Void, "glGetTexEnvfv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTexEnviv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTexGendv", [(GLenum, "coord"), (GLenum, "pname"), Out(Array(GLdouble, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTexGenfv", [(GLenum, "coord"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTexGeniv", [(GLenum, "coord"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(GLboolean, "glIsList", [(GLlist, "list")], sideeffects=False),
    GlFunction(Void, "glFrustum", [(GLdouble, "left"), (GLdouble, "right"), (GLdouble, "bottom"), (GLdouble, "top"), (GLdouble, "zNear"), (GLdouble, "zFar")]),
    GlFunction(Void, "glLoadIdentity", []),
    GlFunction(Void, "glLoadMatrixf", [(Array(Const(GLfloat), 16), "m")]),
    GlFunction(Void, "glLoadMatrixd", [(Array(Const(GLdouble), 16), "m")]),
    GlFunction(Void, "glMatrixMode", [(GLenum, "mode")]),
    GlFunction(Void, "glMultMatrixf", [(Array(Const(GLfloat), 16), "m")]),
    GlFunction(Void, "glMultMatrixd", [(Array(Const(GLdouble), 16), "m")]),
    GlFunction(Void, "glOrtho", [(GLdouble, "left"), (GLdouble, "right"), (GLdouble, "bottom"), (GLdouble, "top"), (GLdouble, "zNear"), (GLdouble, "zFar")]),
    GlFunction(Void, "glPopMatrix", []),
    GlFunction(Void, "glPushMatrix", []),
    GlFunction(Void, "glRotated", [(GLdouble, "angle"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glRotatef", [(GLfloat, "angle"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glScaled", [(GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glScalef", [(GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glTranslated", [(GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glTranslatef", [(GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),

    # GL_VERSION_1_1
    GlFunction(Void, "glDrawArrays", [(GLenum_mode, "mode"), (GLint, "first"), (GLsizei, "count")]),
    GlFunction(Void, "glDrawElements", [(GLenum_mode, "mode"), (GLsizei, "count"), (GLenum, "type"), (GLindexBuffer("count", "type"), "indices")]),
    GlFunction(Void, "glGetPointerv", [(GLenum, "pname"), Out(Pointer(GLpointer), "params")], sideeffects=False),
    GlFunction(Void, "glPolygonOffset", [(GLfloat, "factor"), (GLfloat, "units")]),
    GlFunction(Void, "glCopyTexImage1D", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLint, "border")]),
    GlFunction(Void, "glCopyTexImage2D", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height"), (GLint, "border")]),
    GlFunction(Void, "glCopyTexSubImage1D", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "x"), (GLint, "y"), (GLsizei, "width")]),
    GlFunction(Void, "glCopyTexSubImage2D", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glTexSubImage1D", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLsizei, "width"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTexSubImage1D_size(format, type, width)"), "pixels")]),
    GlFunction(Void, "glTexSubImage2D", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTexSubImage2D_size(format, type, width, height)"), "pixels")]),
    GlFunction(Void, "glBindTexture", [(GLenum, "target"), (GLtexture, "texture")]),
    GlFunction(Void, "glDeleteTextures", [(GLsizei, "n"), (Array(Const(GLtexture), "n"), "textures")]),
    GlFunction(Void, "glGenTextures", [(GLsizei, "n"), Out(Array(GLtexture, "n"), "textures")]),
    GlFunction(GLboolean, "glIsTexture", [(GLtexture, "texture")], sideeffects=False),

    # GL_VERSION_1_1_DEPRECATED
    GlFunction(Void, "glArrayElement", [(GLint, "i")]),
    GlFunction(Void, "glColorPointer", [(size_bgra, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glDisableClientState", [(GLenum, "array")]),
    GlFunction(Void, "glEdgeFlagPointer", [(GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glEnableClientState", [(GLenum, "array")]),
    GlFunction(Void, "glIndexPointer", [(GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glInterleavedArrays", [(GLenum, "format"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glNormalPointer", [(GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glTexCoordPointer", [(GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glVertexPointer", [(GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(GLboolean, "glAreTexturesResident", [(GLsizei, "n"), (Array(Const(GLtexture), "n"), "textures"), Out(Array(GLboolean, "n"), "residences")], sideeffects=False),
    GlFunction(Void, "glPrioritizeTextures", [(GLsizei, "n"), (Array(Const(GLtexture), "n"), "textures"), (Array(Const(GLclampf), "n"), "priorities")]),
    GlFunction(Void, "glIndexub", [(GLubyte, "c")]),
    GlFunction(Void, "glIndexubv", [(Pointer(Const(GLubyte)), "c")]),
    GlFunction(Void, "glPopClientAttrib", []),
    GlFunction(Void, "glPushClientAttrib", [(GLbitfield_client_attrib, "mask")]),

    # GL_VERSION_1_2
    GlFunction(Void, "glBlendColor", [(GLfloat, "red"), (GLfloat, "green"), (GLfloat, "blue"), (GLfloat, "alpha")]),
    GlFunction(Void, "glBlendEquation", [(GLenum, "mode")]),
    GlFunction(Void, "glDrawRangeElements", [(GLenum_mode, "mode"), (GLuint, "start"), (GLuint, "end"), (GLsizei, "count"), (GLenum, "type"), (GLindexBuffer("count", "type"), "indices")]),
    GlFunction(Void, "glTexImage3D", [(GLenum, "target"), (GLint, "level"), (GLenum_int, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLint, "border"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTexImage3D_size(format, type, width, height, depth)"), "pixels")]),
    GlFunction(Void, "glTexSubImage3D", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTexSubImage3D_size(format, type, width, height, depth)"), "pixels")]),
    GlFunction(Void, "glCopyTexSubImage3D", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),

    # GL_VERSION_1_2_DEPRECATED
    GlFunction(Void, "glColorTable", [(GLenum, "target"), (GLenum, "internalformat"), (GLsizei, "width"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glColorTable_size(format, type, width)"), "table")]),
    GlFunction(Void, "glColorTableParameterfv", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glColorTableParameteriv", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glCopyColorTable", [(GLenum, "target"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width")]),
    GlFunction(Void, "glGetColorTable", [(GLenum, "target"), (GLenum, "format"), (GLenum, "type"), Out(OpaqueBlob(GLvoid, "_glGetColorTable_size(target, format, type)"), "table")], sideeffects=False),
    GlFunction(Void, "glGetColorTableParameterfv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetColorTableParameteriv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glColorSubTable", [(GLenum, "target"), (GLsizei, "start"), (GLsizei, "count"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glColorSubTable_size(format, type, count)"), "data")]),
    GlFunction(Void, "glCopyColorSubTable", [(GLenum, "target"), (GLsizei, "start"), (GLint, "x"), (GLint, "y"), (GLsizei, "width")]),
    GlFunction(Void, "glConvolutionFilter1D", [(GLenum, "target"), (GLenum, "internalformat"), (GLsizei, "width"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glConvolutionFilter1D_size(format, type, width)"), "image")]),
    GlFunction(Void, "glConvolutionFilter2D", [(GLenum, "target"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glConvolutionFilter2D_size(format, type, width, height)"), "image")]),
    GlFunction(Void, "glConvolutionParameterf", [(GLenum, "target"), (GLenum, "pname"), (GLfloat, "params")]),
    GlFunction(Void, "glConvolutionParameterfv", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glConvolutionParameteri", [(GLenum, "target"), (GLenum, "pname"), (GLint, "params")]),
    GlFunction(Void, "glConvolutionParameteriv", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glCopyConvolutionFilter1D", [(GLenum, "target"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width")]),
    GlFunction(Void, "glCopyConvolutionFilter2D", [(GLenum, "target"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glGetConvolutionFilter", [(GLenum, "target"), (GLenum, "format"), (GLenum, "type"), Out(OpaqueBlob(GLvoid, "_glGetConvolutionFilter_size(target, format, type)"), "image")]),
    GlFunction(Void, "glGetConvolutionParameterfv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetConvolutionParameteriv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetSeparableFilter", [(GLenum, "target"), (GLenum, "format"), (GLenum, "type"), Out(OpaqueBlob(GLvoid, "_glGetSeparableFilter_size(target, format, type)"), "row"), Out(OpaqueBlob(GLvoid, "_glGetSeparableFilter_size(target, format, type)"), "column"), Out(GLpointer, "span")]),
    GlFunction(Void, "glSeparableFilter2D", [(GLenum, "target"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glConvolutionFilter1D_size(format, type, width)"), "row"), (Blob(Const(GLvoid), "_glConvolutionFilter1D_size(format, type, height)"), "column")]),
    GlFunction(Void, "glGetHistogram", [(GLenum, "target"), (GLboolean, "reset"), (GLenum, "format"), (GLenum, "type"), Out(OpaqueBlob(GLvoid, "_glGetHistogram_size(target, format, type)"), "values")]),
    GlFunction(Void, "glGetHistogramParameterfv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetHistogramParameteriv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMinmax", [(GLenum, "target"), (GLboolean, "reset"), (GLenum, "format"), (GLenum, "type"), Out(OpaqueBlob(GLvoid, "_glGetMinmax_size(target, format, type)"), "values")]),
    GlFunction(Void, "glGetMinmaxParameterfv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMinmaxParameteriv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glHistogram", [(GLenum, "target"), (GLsizei, "width"), (GLenum, "internalformat"), (GLboolean, "sink")]),
    GlFunction(Void, "glMinmax", [(GLenum, "target"), (GLenum, "internalformat"), (GLboolean, "sink")]),
    GlFunction(Void, "glResetHistogram", [(GLenum, "target")]),
    GlFunction(Void, "glResetMinmax", [(GLenum, "target")]),

    # GL_VERSION_1_3
    GlFunction(Void, "glActiveTexture", [(GLenum, "texture")]),
    GlFunction(Void, "glSampleCoverage", [(GLfloat, "value"), (GLboolean, "invert")]),
    GlFunction(Void, "glCompressedTexImage3D", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLint, "border"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glCompressedTexImage2D", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLint, "border"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glCompressedTexImage1D", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLint, "border"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glCompressedTexSubImage3D", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLenum, "format"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glCompressedTexSubImage2D", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glCompressedTexSubImage1D", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLsizei, "width"), (GLenum, "format"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glGetCompressedTexImage", [(GLenum, "target"), (GLint, "level"), Out(OpaqueBlob(GLvoid, "_glGetCompressedTexImage_size(target, level)"), "img")]),

    # GL_VERSION_1_3_DEPRECATED
    GlFunction(Void, "glClientActiveTexture", [(GLenum, "texture")]),
    GlFunction(Void, "glMultiTexCoord1d", [(GLenum, "target"), (GLdouble, "s")]),
    GlFunction(Void, "glMultiTexCoord1dv", [(GLenum, "target"), (Pointer(Const(GLdouble)), "v")]),
    GlFunction(Void, "glMultiTexCoord1f", [(GLenum, "target"), (GLfloat, "s")]),
    GlFunction(Void, "glMultiTexCoord1fv", [(GLenum, "target"), (Pointer(Const(GLfloat)), "v")]),
    GlFunction(Void, "glMultiTexCoord1i", [(GLenum, "target"), (GLint, "s")]),
    GlFunction(Void, "glMultiTexCoord1iv", [(GLenum, "target"), (Pointer(Const(GLint)), "v")]),
    GlFunction(Void, "glMultiTexCoord1s", [(GLenum, "target"), (GLshort, "s")]),
    GlFunction(Void, "glMultiTexCoord1sv", [(GLenum, "target"), (Pointer(Const(GLshort)), "v")]),
    GlFunction(Void, "glMultiTexCoord2d", [(GLenum, "target"), (GLdouble, "s"), (GLdouble, "t")]),
    GlFunction(Void, "glMultiTexCoord2dv", [(GLenum, "target"), (Array(Const(GLdouble), 2), "v")]),
    GlFunction(Void, "glMultiTexCoord2f", [(GLenum, "target"), (GLfloat, "s"), (GLfloat, "t")]),
    GlFunction(Void, "glMultiTexCoord2fv", [(GLenum, "target"), (Array(Const(GLfloat), 2), "v")]),
    GlFunction(Void, "glMultiTexCoord2i", [(GLenum, "target"), (GLint, "s"), (GLint, "t")]),
    GlFunction(Void, "glMultiTexCoord2iv", [(GLenum, "target"), (Array(Const(GLint), 2), "v")]),
    GlFunction(Void, "glMultiTexCoord2s", [(GLenum, "target"), (GLshort, "s"), (GLshort, "t")]),
    GlFunction(Void, "glMultiTexCoord2sv", [(GLenum, "target"), (Array(Const(GLshort), 2), "v")]),
    GlFunction(Void, "glMultiTexCoord3d", [(GLenum, "target"), (GLdouble, "s"), (GLdouble, "t"), (GLdouble, "r")]),
    GlFunction(Void, "glMultiTexCoord3dv", [(GLenum, "target"), (Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glMultiTexCoord3f", [(GLenum, "target"), (GLfloat, "s"), (GLfloat, "t"), (GLfloat, "r")]),
    GlFunction(Void, "glMultiTexCoord3fv", [(GLenum, "target"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glMultiTexCoord3i", [(GLenum, "target"), (GLint, "s"), (GLint, "t"), (GLint, "r")]),
    GlFunction(Void, "glMultiTexCoord3iv", [(GLenum, "target"), (Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glMultiTexCoord3s", [(GLenum, "target"), (GLshort, "s"), (GLshort, "t"), (GLshort, "r")]),
    GlFunction(Void, "glMultiTexCoord3sv", [(GLenum, "target"), (Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glMultiTexCoord4d", [(GLenum, "target"), (GLdouble, "s"), (GLdouble, "t"), (GLdouble, "r"), (GLdouble, "q")]),
    GlFunction(Void, "glMultiTexCoord4dv", [(GLenum, "target"), (Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glMultiTexCoord4f", [(GLenum, "target"), (GLfloat, "s"), (GLfloat, "t"), (GLfloat, "r"), (GLfloat, "q")]),
    GlFunction(Void, "glMultiTexCoord4fv", [(GLenum, "target"), (Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glMultiTexCoord4i", [(GLenum, "target"), (GLint, "s"), (GLint, "t"), (GLint, "r"), (GLint, "q")]),
    GlFunction(Void, "glMultiTexCoord4iv", [(GLenum, "target"), (Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glMultiTexCoord4s", [(GLenum, "target"), (GLshort, "s"), (GLshort, "t"), (GLshort, "r"), (GLshort, "q")]),
    GlFunction(Void, "glMultiTexCoord4sv", [(GLenum, "target"), (Array(Const(GLshort), 4), "v")]),
    GlFunction(Void, "glLoadTransposeMatrixf", [(Array(Const(GLfloat), 16), "m")]),
    GlFunction(Void, "glLoadTransposeMatrixd", [(Array(Const(GLdouble), 16), "m")]),
    GlFunction(Void, "glMultTransposeMatrixf", [(Array(Const(GLfloat), 16), "m")]),
    GlFunction(Void, "glMultTransposeMatrixd", [(Array(Const(GLdouble), 16), "m")]),

    # GL_VERSION_1_4
    GlFunction(Void, "glBlendFuncSeparate", [(GLenum, "sfactorRGB"), (GLenum, "dfactorRGB"), (GLenum, "sfactorAlpha"), (GLenum, "dfactorAlpha")]),
    GlFunction(Void, "glMultiDrawArrays", [(GLenum_mode, "mode"), (Array(Const(GLint), "drawcount"), "first"), (Array(Const(GLsizei), "drawcount"), "count"), (GLsizei, "drawcount")]),
    GlFunction(Void, "glMultiDrawElements", [(GLenum_mode, "mode"), (Array(Const(GLsizei), "drawcount"), "count"), (GLenum, "type"), (Array(Const(GLindexBuffer("count[{i}]", "type")), "drawcount"), "indices"), (GLsizei, "drawcount")]),
    GlFunction(Void, "glPointParameterf", [(GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glPointParameterfv", [(GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glPointParameteri", [(GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glPointParameteriv", [(GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),

    # GL_VERSION_1_4_DEPRECATED
    GlFunction(Void, "glFogCoordf", [(GLfloat, "coord")]),
    GlFunction(Void, "glFogCoordfv", [(Pointer(Const(GLfloat)), "coord")]),
    GlFunction(Void, "glFogCoordd", [(GLdouble, "coord")]),
    GlFunction(Void, "glFogCoorddv", [(Pointer(Const(GLdouble)), "coord")]),
    GlFunction(Void, "glFogCoordPointer", [(GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glSecondaryColor3b", [(GLbyte, "red"), (GLbyte, "green"), (GLbyte, "blue")]),
    GlFunction(Void, "glSecondaryColor3bv", [(Array(Const(GLbyte), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3d", [(GLdouble, "red"), (GLdouble, "green"), (GLdouble, "blue")]),
    GlFunction(Void, "glSecondaryColor3dv", [(Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3f", [(GLfloat, "red"), (GLfloat, "green"), (GLfloat, "blue")]),
    GlFunction(Void, "glSecondaryColor3fv", [(Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3i", [(GLint, "red"), (GLint, "green"), (GLint, "blue")]),
    GlFunction(Void, "glSecondaryColor3iv", [(Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3s", [(GLshort, "red"), (GLshort, "green"), (GLshort, "blue")]),
    GlFunction(Void, "glSecondaryColor3sv", [(Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3ub", [(GLubyte, "red"), (GLubyte, "green"), (GLubyte, "blue")]),
    GlFunction(Void, "glSecondaryColor3ubv", [(Array(Const(GLubyte), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3ui", [(GLuint, "red"), (GLuint, "green"), (GLuint, "blue")]),
    GlFunction(Void, "glSecondaryColor3uiv", [(Array(Const(GLuint), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3us", [(GLushort, "red"), (GLushort, "green"), (GLushort, "blue")]),
    GlFunction(Void, "glSecondaryColor3usv", [(Array(Const(GLushort), 3), "v")]),
    GlFunction(Void, "glSecondaryColorPointer", [(size_bgra, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glWindowPos2d", [(GLdouble, "x"), (GLdouble, "y")]),
    GlFunction(Void, "glWindowPos2dv", [(Array(Const(GLdouble), 2), "v")]),
    GlFunction(Void, "glWindowPos2f", [(GLfloat, "x"), (GLfloat, "y")]),
    GlFunction(Void, "glWindowPos2fv", [(Array(Const(GLfloat), 2), "v")]),
    GlFunction(Void, "glWindowPos2i", [(GLint, "x"), (GLint, "y")]),
    GlFunction(Void, "glWindowPos2iv", [(Array(Const(GLint), 2), "v")]),
    GlFunction(Void, "glWindowPos2s", [(GLshort, "x"), (GLshort, "y")]),
    GlFunction(Void, "glWindowPos2sv", [(Array(Const(GLshort), 2), "v")]),
    GlFunction(Void, "glWindowPos3d", [(GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glWindowPos3dv", [(Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glWindowPos3f", [(GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glWindowPos3fv", [(Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glWindowPos3i", [(GLint, "x"), (GLint, "y"), (GLint, "z")]),
    GlFunction(Void, "glWindowPos3iv", [(Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glWindowPos3s", [(GLshort, "x"), (GLshort, "y"), (GLshort, "z")]),
    GlFunction(Void, "glWindowPos3sv", [(Array(Const(GLshort), 3), "v")]),

    # GL_VERSION_1_5
    GlFunction(Void, "glGenQueries", [(GLsizei, "n"), Out(Array(GLquery, "n"), "ids")]),
    GlFunction(Void, "glDeleteQueries", [(GLsizei, "n"), (Array(Const(GLquery), "n"), "ids")]),
    GlFunction(GLboolean, "glIsQuery", [(GLquery, "id")], sideeffects=False),
    GlFunction(Void, "glBeginQuery", [(GLenum, "target"), (GLquery, "id")]),
    GlFunction(Void, "glEndQuery", [(GLenum, "target")]),
    GlFunction(Void, "glGetQueryiv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetQueryObjectiv", [(GLquery, "id"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetQueryObjectuiv", [(GLquery, "id"), (GLenum, "pname"), Out(Array(GLuint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glBindBuffer", [(GLenum, "target"), (GLbuffer, "buffer")]),
    GlFunction(Void, "glDeleteBuffers", [(GLsizei, "n"), (Array(Const(GLbuffer), "n"), "buffer")]),
    GlFunction(Void, "glGenBuffers", [(GLsizei, "n"), Out(Array(GLbuffer, "n"), "buffer")]),
    GlFunction(GLboolean, "glIsBuffer", [(GLbuffer, "buffer")], sideeffects=False),
    GlFunction(Void, "glBufferData", [(GLenum, "target"), (GLsizeiptr, "size"), (Blob(Const(GLvoid), "size"), "data"), (GLenum, "usage")]),
    GlFunction(Void, "glBufferSubData", [(GLenum, "target"), (GLintptr, "offset"), (GLsizeiptr, "size"), (Blob(Const(GLvoid), "size"), "data")]),
    GlFunction(Void, "glGetBufferSubData", [(GLenum, "target"), (GLintptr, "offset"), (GLsizeiptr, "size"), Out(OpaqueBlob(GLvoid, "size"), "data")], sideeffects=False),
    GlFunction(GLmap, "glMapBuffer", [(GLenum, "target"), (GLenum, "access")]),
    GlFunction(GLboolean, "glUnmapBuffer", [(GLenum, "target")]),
    GlFunction(Void, "glGetBufferParameteriv", [(GLenum, "target"), (GLenum, "pname"), (Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetBufferPointerv", [(GLenum, "target"), (GLenum, "pname"), Out(Pointer(GLpointer), "params")], sideeffects=False),

    # GL_VERSION_2_0
    GlFunction(Void, "glBlendEquationSeparate", [(GLenum, "modeRGB"), (GLenum, "modeAlpha")]),
    GlFunction(Void, "glDrawBuffers", [(GLsizei, "n"), (Array(Const(GLenum), "n"), "bufs")]),
    GlFunction(Void, "glStencilOpSeparate", [(GLenum, "face"), (GLenum, "sfail"), (GLenum, "dpfail"), (GLenum, "dppass")]),
    GlFunction(Void, "glStencilFuncSeparate", [(GLenum, "face"), (GLenum, "func"), (GLint, "ref"), (GLuint, "mask")]),
    GlFunction(Void, "glStencilMaskSeparate", [(GLenum, "face"), (GLuint, "mask")]),
    GlFunction(Void, "glAttachShader", [(GLprogram, "program"), (GLshader, "shader")]),
    GlFunction(Void, "glBindAttribLocation", [(GLprogram, "program"), (GLuint, "index"), (GLstringConst, "name")]),
    GlFunction(Void, "glCompileShader", [(GLshader, "shader")]),
    GlFunction(GLprogram, "glCreateProgram", []),
    GlFunction(GLshader, "glCreateShader", [(GLenum, "type")]),
    GlFunction(Void, "glDeleteProgram", [(GLprogram, "program")]),
    GlFunction(Void, "glDeleteShader", [(GLshader, "shader")]),
    GlFunction(Void, "glDetachShader", [(GLprogram, "program"), (GLshader, "shader")]),
    GlFunction(Void, "glDisableVertexAttribArray", [(GLuint, "index")]),
    GlFunction(Void, "glEnableVertexAttribArray", [(GLuint, "index")]),
    GlFunction(Void, "glGetActiveAttrib", [(GLprogram, "program"), (GLuint, "index"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), Out(Pointer(GLint), "size"), Out(Pointer(GLenum), "type"), OutGlString(GLchar, "length", "name")], sideeffects=False),
    GlFunction(Void, "glGetActiveUniform", [(GLprogram, "program"), (GLuint, "index"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), Out(Pointer(GLint), "size"), Out(Pointer(GLenum), "type"), OutGlString(GLchar, "length", "name")], sideeffects=False),
    GlFunction(Void, "glGetAttachedShaders", [(GLprogram, "program"), (GLsizei, "maxCount"), Out(Pointer(GLsizei), "count"), Out(Array(GLuint, "(count ? *count : maxCount)"), "obj")], sideeffects=False),
    GlFunction(GLint, "glGetAttribLocation", [(GLprogram, "program"), (GLstringConst, "name")]),
    GlFunction(Void, "glGetProgramiv", [(GLprogram, "program"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramInfoLog", [(GLprogram, "program"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), OutGlString(GLchar, "length", "infoLog")], sideeffects=False),
    GlFunction(Void, "glGetShaderiv", [(GLshader, "shader"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetShaderInfoLog", [(GLshader, "shader"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), OutGlString(GLchar, "length", "infoLog")], sideeffects=False),
    GlFunction(Void, "glGetShaderSource", [(GLshader, "shader"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), OutGlString(GLchar, "length", "source")], sideeffects=False),
    GlFunction(GLlocation, "glGetUniformLocation", [(GLprogram, "program"), (GLstringConst, "name")]),
    GlFunction(Void, "glGetUniformfv", [(GLprogram, "program"), (GLlocation, "location"), Out(OpaquePointer(GLfloat), "params")], sideeffects=False),
    GlFunction(Void, "glGetUniformiv", [(GLprogram, "program"), (GLlocation, "location"), Out(OpaquePointer(GLint), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribdv", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLdouble, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribfv", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribiv", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribPointerv", [(GLuint, "index"), (GLenum, "pname"), Out(Pointer(GLpointer), "pointer")], sideeffects=False),
    GlFunction(GLboolean, "glIsProgram", [(GLprogram, "program")], sideeffects=False),
    GlFunction(GLboolean, "glIsShader", [(GLshader, "shader")], sideeffects=False),
    GlFunction(Void, "glLinkProgram", [(GLprogram, "program")]),
    GlFunction(Void, "glShaderSource", [(GLshader, "shader"), (GLsizei, "count"), (Array(Const(String(Const(GLchar), "_glShaderSource_length(string, length, {i})")), "count"), "string"), (Array(Const(GLint), "count"), "length")]),
    GlFunction(Void, "glUseProgram", [(GLprogram, "program")]),
    GlFunction(Void, "glUniform1f", [(GLlocation, "location"), (GLfloat, "v0")]),
    GlFunction(Void, "glUniform2f", [(GLlocation, "location"), (GLfloat, "v0"), (GLfloat, "v1")]),
    GlFunction(Void, "glUniform3f", [(GLlocation, "location"), (GLfloat, "v0"), (GLfloat, "v1"), (GLfloat, "v2")]),
    GlFunction(Void, "glUniform4f", [(GLlocation, "location"), (GLfloat, "v0"), (GLfloat, "v1"), (GLfloat, "v2"), (GLfloat, "v3")]),
    GlFunction(Void, "glUniform1i", [(GLlocation, "location"), (GLint, "v0")]),
    GlFunction(Void, "glUniform2i", [(GLlocation, "location"), (GLint, "v0"), (GLint, "v1")]),
    GlFunction(Void, "glUniform3i", [(GLlocation, "location"), (GLint, "v0"), (GLint, "v1"), (GLint, "v2")]),
    GlFunction(Void, "glUniform4i", [(GLlocation, "location"), (GLint, "v0"), (GLint, "v1"), (GLint, "v2"), (GLint, "v3")]),
    GlFunction(Void, "glUniform1fv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count"), "value")]),
    GlFunction(Void, "glUniform2fv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*2"), "value")]),
    GlFunction(Void, "glUniform3fv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*3"), "value")]),
    GlFunction(Void, "glUniform4fv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*4"), "value")]),
    GlFunction(Void, "glUniform1iv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count"), "value")]),
    GlFunction(Void, "glUniform2iv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*2"), "value")]),
    GlFunction(Void, "glUniform3iv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*3"), "value")]),
    GlFunction(Void, "glUniform4iv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*4"), "value")]),
    GlFunction(Void, "glUniformMatrix2fv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*2*2"), "value")]),
    GlFunction(Void, "glUniformMatrix3fv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*3*3"), "value")]),
    GlFunction(Void, "glUniformMatrix4fv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*4*4"), "value")]),
    GlFunction(Void, "glValidateProgram", [(GLprogram, "program")]),
    GlFunction(Void, "glVertexAttrib1d", [(GLuint, "index"), (GLdouble, "x")]),
    GlFunction(Void, "glVertexAttrib1dv", [(GLuint, "index"), (Pointer(Const(GLdouble)), "v")]),
    GlFunction(Void, "glVertexAttrib1f", [(GLuint, "index"), (GLfloat, "x")]),
    GlFunction(Void, "glVertexAttrib1fv", [(GLuint, "index"), (Pointer(Const(GLfloat)), "v")]),
    GlFunction(Void, "glVertexAttrib1s", [(GLuint, "index"), (GLshort, "x")]),
    GlFunction(Void, "glVertexAttrib1sv", [(GLuint, "index"), (Pointer(Const(GLshort)), "v")]),
    GlFunction(Void, "glVertexAttrib2d", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y")]),
    GlFunction(Void, "glVertexAttrib2dv", [(GLuint, "index"), (Array(Const(GLdouble), 2), "v")]),
    GlFunction(Void, "glVertexAttrib2f", [(GLuint, "index"), (GLfloat, "x"), (GLfloat, "y")]),
    GlFunction(Void, "glVertexAttrib2fv", [(GLuint, "index"), (Array(Const(GLfloat), 2), "v")]),
    GlFunction(Void, "glVertexAttrib2s", [(GLuint, "index"), (GLshort, "x"), (GLshort, "y")]),
    GlFunction(Void, "glVertexAttrib2sv", [(GLuint, "index"), (Array(Const(GLshort), 2), "v")]),
    GlFunction(Void, "glVertexAttrib3d", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glVertexAttrib3dv", [(GLuint, "index"), (Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glVertexAttrib3f", [(GLuint, "index"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glVertexAttrib3fv", [(GLuint, "index"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glVertexAttrib3s", [(GLuint, "index"), (GLshort, "x"), (GLshort, "y"), (GLshort, "z")]),
    GlFunction(Void, "glVertexAttrib3sv", [(GLuint, "index"), (Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glVertexAttrib4Nbv", [(GLuint, "index"), (Array(Const(GLbyte), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4Niv", [(GLuint, "index"), (Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4Nsv", [(GLuint, "index"), (Array(Const(GLshort), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4Nub", [(GLuint, "index"), (GLubyte, "x"), (GLubyte, "y"), (GLubyte, "z"), (GLubyte, "w")]),
    GlFunction(Void, "glVertexAttrib4Nubv", [(GLuint, "index"), (Array(Const(GLubyte), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4Nuiv", [(GLuint, "index"), (Array(Const(GLuint), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4Nusv", [(GLuint, "index"), (Array(Const(GLushort), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4bv", [(GLuint, "index"), (Array(Const(GLbyte), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4d", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glVertexAttrib4dv", [(GLuint, "index"), (Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4f", [(GLuint, "index"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glVertexAttrib4fv", [(GLuint, "index"), (Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4iv", [(GLuint, "index"), (Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4s", [(GLuint, "index"), (GLshort, "x"), (GLshort, "y"), (GLshort, "z"), (GLshort, "w")]),
    GlFunction(Void, "glVertexAttrib4sv", [(GLuint, "index"), (Array(Const(GLshort), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4ubv", [(GLuint, "index"), (Array(Const(GLubyte), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4uiv", [(GLuint, "index"), (Array(Const(GLuint), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4usv", [(GLuint, "index"), (Array(Const(GLushort), 4), "v")]),
    GlFunction(Void, "glVertexAttribPointer", [(GLuint, "index"), (size_bgra, "size"), (GLenum, "type"), (GLboolean, "normalized"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),

    # GL_VERSION_2_1
    GlFunction(Void, "glUniformMatrix2x3fv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*2*3"), "value")]),
    GlFunction(Void, "glUniformMatrix3x2fv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*3*2"), "value")]),
    GlFunction(Void, "glUniformMatrix2x4fv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*2*4"), "value")]),
    GlFunction(Void, "glUniformMatrix4x2fv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*4*2"), "value")]),
    GlFunction(Void, "glUniformMatrix3x4fv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*3*4"), "value")]),
    GlFunction(Void, "glUniformMatrix4x3fv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*4*3"), "value")]),

    # GL_VERSION_3_0
    GlFunction(Void, "glColorMaski", [(GLuint, "index"), (GLboolean, "r"), (GLboolean, "g"), (GLboolean, "b"), (GLboolean, "a")]),
    GlFunction(Void, "glGetBooleani_v", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLboolean, "_gl_param_size(target)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetIntegeri_v", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLint, "_gl_param_size(target)"), "data")], sideeffects=False),
    GlFunction(Void, "glEnablei", [(GLenum, "target"), (GLuint, "index")]),
    GlFunction(Void, "glDisablei", [(GLenum, "target"), (GLuint, "index")]),
    GlFunction(GLboolean, "glIsEnabledi", [(GLenum, "target"), (GLuint, "index")], sideeffects=False),
    GlFunction(Void, "glBeginTransformFeedback", [(GLenum_mode, "primitiveMode")]),
    GlFunction(Void, "glEndTransformFeedback", []),
    GlFunction(Void, "glBindBufferRange", [(GLenum, "target"), (GLuint, "index"), (GLbuffer, "buffer"), (GLintptr, "offset"), (GLsizeiptr, "size")]),
    GlFunction(Void, "glBindBufferBase", [(GLenum, "target"), (GLuint, "index"), (GLbuffer, "buffer")]),
    GlFunction(Void, "glTransformFeedbackVaryings", [(GLprogram, "program"), (GLsizei, "count"), (Array(Const(GLstringConst), "count"), "varyings"), (GLenum, "bufferMode")]),
    GlFunction(Void, "glGetTransformFeedbackVarying", [(GLprogram, "program"), (GLuint, "index"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), Out(Pointer(GLsizei), "size"), Out(Pointer(GLenum), "type"), OutGlString(GLchar, "length", "name")], sideeffects=False),
    GlFunction(Void, "glClampColor", [(GLenum, "target"), (GLenum, "clamp")]),
    GlFunction(Void, "glBeginConditionalRender", [(GLquery, "id"), (GLenum, "mode")]),
    GlFunction(Void, "glEndConditionalRender", []),
    GlFunction(Void, "glVertexAttribIPointer", [(GLuint, "index"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glGetVertexAttribIiv", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribIuiv", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLuint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glVertexAttribI1i", [(GLuint, "index"), (GLint, "x")]),
    GlFunction(Void, "glVertexAttribI2i", [(GLuint, "index"), (GLint, "x"), (GLint, "y")]),
    GlFunction(Void, "glVertexAttribI3i", [(GLuint, "index"), (GLint, "x"), (GLint, "y"), (GLint, "z")]),
    GlFunction(Void, "glVertexAttribI4i", [(GLuint, "index"), (GLint, "x"), (GLint, "y"), (GLint, "z"), (GLint, "w")]),
    GlFunction(Void, "glVertexAttribI1ui", [(GLuint, "index"), (GLuint, "x")]),
    GlFunction(Void, "glVertexAttribI2ui", [(GLuint, "index"), (GLuint, "x"), (GLuint, "y")]),
    GlFunction(Void, "glVertexAttribI3ui", [(GLuint, "index"), (GLuint, "x"), (GLuint, "y"), (GLuint, "z")]),
    GlFunction(Void, "glVertexAttribI4ui", [(GLuint, "index"), (GLuint, "x"), (GLuint, "y"), (GLuint, "z"), (GLuint, "w")]),
    GlFunction(Void, "glVertexAttribI1iv", [(GLuint, "index"), (Pointer(Const(GLint)), "v")]),
    GlFunction(Void, "glVertexAttribI2iv", [(GLuint, "index"), (Array(Const(GLint), 2), "v")]),
    GlFunction(Void, "glVertexAttribI3iv", [(GLuint, "index"), (Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glVertexAttribI4iv", [(GLuint, "index"), (Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glVertexAttribI1uiv", [(GLuint, "index"), (Pointer(Const(GLuint)), "v")]),
    GlFunction(Void, "glVertexAttribI2uiv", [(GLuint, "index"), (Array(Const(GLuint), 2), "v")]),
    GlFunction(Void, "glVertexAttribI3uiv", [(GLuint, "index"), (Array(Const(GLuint), 3), "v")]),
    GlFunction(Void, "glVertexAttribI4uiv", [(GLuint, "index"), (Array(Const(GLuint), 4), "v")]),
    GlFunction(Void, "glVertexAttribI4bv", [(GLuint, "index"), (Array(Const(GLbyte), 4), "v")]),
    GlFunction(Void, "glVertexAttribI4sv", [(GLuint, "index"), (Array(Const(GLshort), 4), "v")]),
    GlFunction(Void, "glVertexAttribI4ubv", [(GLuint, "index"), (Array(Const(GLubyte), 4), "v")]),
    GlFunction(Void, "glVertexAttribI4usv", [(GLuint, "index"), (Array(Const(GLushort), 4), "v")]),
    GlFunction(Void, "glGetUniformuiv", [(GLprogram, "program"), (GLlocation, "location"), Out(OpaqueArray(GLuint, "_glGetUniformuiv_size(program, location)"), "params")], sideeffects=False),
    GlFunction(Void, "glBindFragDataLocation", [(GLprogram, "program"), (GLuint, "color"), (GLstringConst, "name")]),
    GlFunction(GLlocation, "glGetFragDataLocation", [(GLprogram, "program"), (GLstringConst, "name")]),
    GlFunction(Void, "glUniform1ui", [(GLlocation, "location"), (GLuint, "v0")]),
    GlFunction(Void, "glUniform2ui", [(GLlocation, "location"), (GLuint, "v0"), (GLuint, "v1")]),
    GlFunction(Void, "glUniform3ui", [(GLlocation, "location"), (GLuint, "v0"), (GLuint, "v1"), (GLuint, "v2")]),
    GlFunction(Void, "glUniform4ui", [(GLlocation, "location"), (GLuint, "v0"), (GLuint, "v1"), (GLuint, "v2"), (GLuint, "v3")]),
    GlFunction(Void, "glUniform1uiv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count"), "value")]),
    GlFunction(Void, "glUniform2uiv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count*2"), "value")]),
    GlFunction(Void, "glUniform3uiv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count*3"), "value")]),
    GlFunction(Void, "glUniform4uiv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count*4"), "value")]),
    GlFunction(Void, "glTexParameterIiv", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTexParameterIuiv", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLuint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glGetTexParameterIiv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTexParameterIuiv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLuint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glClearBufferiv", [(GLenum, "buffer"), (GLint, "drawbuffer"), (Array(Const(GLint), "_glClearBuffer_size(buffer)"), "value")]),
    GlFunction(Void, "glClearBufferuiv", [(GLenum, "buffer"), (GLint, "drawbuffer"), (Array(Const(GLuint), "_glClearBuffer_size(buffer)"), "value")]),
    GlFunction(Void, "glClearBufferfv", [(GLenum, "buffer"), (GLint, "drawbuffer"), (Array(Const(GLfloat), "_glClearBuffer_size(buffer)"), "value")]),
    GlFunction(Void, "glClearBufferfi", [(GLenum, "buffer"), (GLint, "drawbuffer"), (GLfloat, "depth"), (GLint, "stencil")]),
    GlFunction(String(Const(GLubyte)), "glGetStringi", [(GLenum, "name"), (GLuint, "index")], sideeffects=False),

    # GL_VERSION_3_1
    GlFunction(Void, "glDrawArraysInstanced", [(GLenum_mode, "mode"), (GLint, "first"), (GLsizei, "count"), (GLsizei, "primcount")]),
    GlFunction(Void, "glDrawElementsInstanced", [(GLenum_mode, "mode"), (GLsizei, "count"), (GLenum, "type"), (GLindexBuffer("count", "type"), "indices"), (GLsizei, "primcount")]),
    GlFunction(Void, "glTexBuffer", [(GLenum, "target"), (GLenum, "internalformat"), (GLbuffer, "buffer")]),
    GlFunction(Void, "glPrimitiveRestartIndex", [(GLuint, "index")]),

    # GL_VERSION_3_2
    GlFunction(Void, "glGetInteger64i_v", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLint64, "_gl_param_size(target)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetBufferParameteri64v", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint64, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glFramebufferTexture", [(GLenum, "target"), (GLenum, "attachment"), (GLtexture, "texture"), (GLint, "level")]),

    # GL_VERSION_3_3
    GlFunction(Void, "glVertexAttribDivisor", [(GLuint, "index"), (GLuint, "divisor")]),

    # GL_VERSION_4_0
    GlFunction(Void, "glMinSampleShading", [(GLfloat, "value")]),
    GlFunction(Void, "glBlendEquationi", [(GLuint, "buf"), (GLenum, "mode")]),
    GlFunction(Void, "glBlendEquationSeparatei", [(GLuint, "buf"), (GLenum, "modeRGB"), (GLenum, "modeAlpha")]),
    GlFunction(Void, "glBlendFunci", [(GLuint, "buf"), (GLenum, "src"), (GLenum, "dst")]),
    GlFunction(Void, "glBlendFuncSeparatei", [(GLuint, "buf"), (GLenum, "srcRGB"), (GLenum, "dstRGB"), (GLenum, "srcAlpha"), (GLenum, "dstAlpha")]),

    # GL_ARB_multitexture
    GlFunction(Void, "glActiveTextureARB", [(GLenum, "texture")]),
    GlFunction(Void, "glClientActiveTextureARB", [(GLenum, "texture")]),
    GlFunction(Void, "glMultiTexCoord1dARB", [(GLenum, "target"), (GLdouble, "s")]),
    GlFunction(Void, "glMultiTexCoord1dvARB", [(GLenum, "target"), (Pointer(Const(GLdouble)), "v")]),
    GlFunction(Void, "glMultiTexCoord1fARB", [(GLenum, "target"), (GLfloat, "s")]),
    GlFunction(Void, "glMultiTexCoord1fvARB", [(GLenum, "target"), (Pointer(Const(GLfloat)), "v")]),
    GlFunction(Void, "glMultiTexCoord1iARB", [(GLenum, "target"), (GLint, "s")]),
    GlFunction(Void, "glMultiTexCoord1ivARB", [(GLenum, "target"), (Pointer(Const(GLint)), "v")]),
    GlFunction(Void, "glMultiTexCoord1sARB", [(GLenum, "target"), (GLshort, "s")]),
    GlFunction(Void, "glMultiTexCoord1svARB", [(GLenum, "target"), (Pointer(Const(GLshort)), "v")]),
    GlFunction(Void, "glMultiTexCoord2dARB", [(GLenum, "target"), (GLdouble, "s"), (GLdouble, "t")]),
    GlFunction(Void, "glMultiTexCoord2dvARB", [(GLenum, "target"), (Array(Const(GLdouble), 2), "v")]),
    GlFunction(Void, "glMultiTexCoord2fARB", [(GLenum, "target"), (GLfloat, "s"), (GLfloat, "t")]),
    GlFunction(Void, "glMultiTexCoord2fvARB", [(GLenum, "target"), (Array(Const(GLfloat), 2), "v")]),
    GlFunction(Void, "glMultiTexCoord2iARB", [(GLenum, "target"), (GLint, "s"), (GLint, "t")]),
    GlFunction(Void, "glMultiTexCoord2ivARB", [(GLenum, "target"), (Array(Const(GLint), 2), "v")]),
    GlFunction(Void, "glMultiTexCoord2sARB", [(GLenum, "target"), (GLshort, "s"), (GLshort, "t")]),
    GlFunction(Void, "glMultiTexCoord2svARB", [(GLenum, "target"), (Array(Const(GLshort), 2), "v")]),
    GlFunction(Void, "glMultiTexCoord3dARB", [(GLenum, "target"), (GLdouble, "s"), (GLdouble, "t"), (GLdouble, "r")]),
    GlFunction(Void, "glMultiTexCoord3dvARB", [(GLenum, "target"), (Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glMultiTexCoord3fARB", [(GLenum, "target"), (GLfloat, "s"), (GLfloat, "t"), (GLfloat, "r")]),
    GlFunction(Void, "glMultiTexCoord3fvARB", [(GLenum, "target"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glMultiTexCoord3iARB", [(GLenum, "target"), (GLint, "s"), (GLint, "t"), (GLint, "r")]),
    GlFunction(Void, "glMultiTexCoord3ivARB", [(GLenum, "target"), (Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glMultiTexCoord3sARB", [(GLenum, "target"), (GLshort, "s"), (GLshort, "t"), (GLshort, "r")]),
    GlFunction(Void, "glMultiTexCoord3svARB", [(GLenum, "target"), (Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glMultiTexCoord4dARB", [(GLenum, "target"), (GLdouble, "s"), (GLdouble, "t"), (GLdouble, "r"), (GLdouble, "q")]),
    GlFunction(Void, "glMultiTexCoord4dvARB", [(GLenum, "target"), (Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glMultiTexCoord4fARB", [(GLenum, "target"), (GLfloat, "s"), (GLfloat, "t"), (GLfloat, "r"), (GLfloat, "q")]),
    GlFunction(Void, "glMultiTexCoord4fvARB", [(GLenum, "target"), (Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glMultiTexCoord4iARB", [(GLenum, "target"), (GLint, "s"), (GLint, "t"), (GLint, "r"), (GLint, "q")]),
    GlFunction(Void, "glMultiTexCoord4ivARB", [(GLenum, "target"), (Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glMultiTexCoord4sARB", [(GLenum, "target"), (GLshort, "s"), (GLshort, "t"), (GLshort, "r"), (GLshort, "q")]),
    GlFunction(Void, "glMultiTexCoord4svARB", [(GLenum, "target"), (Array(Const(GLshort), 4), "v")]),

    # GL_ARB_transpose_matrix
    GlFunction(Void, "glLoadTransposeMatrixfARB", [(Array(Const(GLfloat), 16), "m")]),
    GlFunction(Void, "glLoadTransposeMatrixdARB", [(Array(Const(GLdouble), 16), "m")]),
    GlFunction(Void, "glMultTransposeMatrixfARB", [(Array(Const(GLfloat), 16), "m")]),
    GlFunction(Void, "glMultTransposeMatrixdARB", [(Array(Const(GLdouble), 16), "m")]),

    # GL_ARB_multisample
    GlFunction(Void, "glSampleCoverageARB", [(GLfloat, "value"), (GLboolean, "invert")]),

    # GL_ARB_texture_compression
    GlFunction(Void, "glCompressedTexImage3DARB", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLint, "border"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glCompressedTexImage2DARB", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLint, "border"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glCompressedTexImage1DARB", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLint, "border"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glCompressedTexSubImage3DARB", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLenum, "format"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glCompressedTexSubImage2DARB", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glCompressedTexSubImage1DARB", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLsizei, "width"), (GLenum, "format"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glGetCompressedTexImageARB", [(GLenum, "target"), (GLint, "level"), Out(GLpointer, "img")]),

    # GL_ARB_point_parameters
    GlFunction(Void, "glPointParameterfARB", [(GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glPointParameterfvARB", [(GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),

    # GL_ARB_vertex_blend
    GlFunction(Void, "glWeightbvARB", [(GLint, "size"), (Array(Const(GLbyte), "size"), "weights")]),
    GlFunction(Void, "glWeightsvARB", [(GLint, "size"), (Array(Const(GLshort), "size"), "weights")]),
    GlFunction(Void, "glWeightivARB", [(GLint, "size"), (Array(Const(GLint), "size"), "weights")]),
    GlFunction(Void, "glWeightfvARB", [(GLint, "size"), (Array(Const(GLfloat), "size"), "weights")]),
    GlFunction(Void, "glWeightdvARB", [(GLint, "size"), (Array(Const(GLdouble), "size"), "weights")]),
    GlFunction(Void, "glWeightubvARB", [(GLint, "size"), (Array(Const(GLubyte), "size"), "weights")]),
    GlFunction(Void, "glWeightusvARB", [(GLint, "size"), (Array(Const(GLushort), "size"), "weights")]),
    GlFunction(Void, "glWeightuivARB", [(GLint, "size"), (Array(Const(GLuint), "size"), "weights")]),
    GlFunction(Void, "glWeightPointerARB", [(GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glVertexBlendARB", [(GLint, "count")]),

    # GL_ARB_matrix_palette
    GlFunction(Void, "glCurrentPaletteMatrixARB", [(GLint, "index")]),
    GlFunction(Void, "glMatrixIndexubvARB", [(GLint, "size"), (Array(Const(GLubyte), "size"), "indices")]),
    GlFunction(Void, "glMatrixIndexusvARB", [(GLint, "size"), (Array(Const(GLushort), "size"), "indices")]),
    GlFunction(Void, "glMatrixIndexuivARB", [(GLint, "size"), (Array(Const(GLuint), "size"), "indices")]),
    GlFunction(Void, "glMatrixIndexPointerARB", [(GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),

    # GL_ARB_window_pos
    GlFunction(Void, "glWindowPos2dARB", [(GLdouble, "x"), (GLdouble, "y")]),
    GlFunction(Void, "glWindowPos2dvARB", [(Array(Const(GLdouble), 2), "v")]),
    GlFunction(Void, "glWindowPos2fARB", [(GLfloat, "x"), (GLfloat, "y")]),
    GlFunction(Void, "glWindowPos2fvARB", [(Array(Const(GLfloat), 2), "v")]),
    GlFunction(Void, "glWindowPos2iARB", [(GLint, "x"), (GLint, "y")]),
    GlFunction(Void, "glWindowPos2ivARB", [(Array(Const(GLint), 2), "v")]),
    GlFunction(Void, "glWindowPos2sARB", [(GLshort, "x"), (GLshort, "y")]),
    GlFunction(Void, "glWindowPos2svARB", [(Array(Const(GLshort), 2), "v")]),
    GlFunction(Void, "glWindowPos3dARB", [(GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glWindowPos3dvARB", [(Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glWindowPos3fARB", [(GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glWindowPos3fvARB", [(Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glWindowPos3iARB", [(GLint, "x"), (GLint, "y"), (GLint, "z")]),
    GlFunction(Void, "glWindowPos3ivARB", [(Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glWindowPos3sARB", [(GLshort, "x"), (GLshort, "y"), (GLshort, "z")]),
    GlFunction(Void, "glWindowPos3svARB", [(Array(Const(GLshort), 3), "v")]),

    # GL_ARB_vertex_program
    GlFunction(Void, "glVertexAttrib1dARB", [(GLuint, "index"), (GLdouble, "x")]),
    GlFunction(Void, "glVertexAttrib1dvARB", [(GLuint, "index"), (Pointer(Const(GLdouble)), "v")]),
    GlFunction(Void, "glVertexAttrib1fARB", [(GLuint, "index"), (GLfloat, "x")]),
    GlFunction(Void, "glVertexAttrib1fvARB", [(GLuint, "index"), (Pointer(Const(GLfloat)), "v")]),
    GlFunction(Void, "glVertexAttrib1sARB", [(GLuint, "index"), (GLshort, "x")]),
    GlFunction(Void, "glVertexAttrib1svARB", [(GLuint, "index"), (Pointer(Const(GLshort)), "v")]),
    GlFunction(Void, "glVertexAttrib2dARB", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y")]),
    GlFunction(Void, "glVertexAttrib2dvARB", [(GLuint, "index"), (Array(Const(GLdouble), 2), "v")]),
    GlFunction(Void, "glVertexAttrib2fARB", [(GLuint, "index"), (GLfloat, "x"), (GLfloat, "y")]),
    GlFunction(Void, "glVertexAttrib2fvARB", [(GLuint, "index"), (Array(Const(GLfloat), 2), "v")]),
    GlFunction(Void, "glVertexAttrib2sARB", [(GLuint, "index"), (GLshort, "x"), (GLshort, "y")]),
    GlFunction(Void, "glVertexAttrib2svARB", [(GLuint, "index"), (Array(Const(GLshort), 2), "v")]),
    GlFunction(Void, "glVertexAttrib3dARB", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glVertexAttrib3dvARB", [(GLuint, "index"), (Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glVertexAttrib3fARB", [(GLuint, "index"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glVertexAttrib3fvARB", [(GLuint, "index"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glVertexAttrib3sARB", [(GLuint, "index"), (GLshort, "x"), (GLshort, "y"), (GLshort, "z")]),
    GlFunction(Void, "glVertexAttrib3svARB", [(GLuint, "index"), (Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glVertexAttrib4NbvARB", [(GLuint, "index"), (Array(Const(GLbyte), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4NivARB", [(GLuint, "index"), (Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4NsvARB", [(GLuint, "index"), (Array(Const(GLshort), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4NubARB", [(GLuint, "index"), (GLubyte, "x"), (GLubyte, "y"), (GLubyte, "z"), (GLubyte, "w")]),
    GlFunction(Void, "glVertexAttrib4NubvARB", [(GLuint, "index"), (Array(Const(GLubyte), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4NuivARB", [(GLuint, "index"), (Array(Const(GLuint), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4NusvARB", [(GLuint, "index"), (Array(Const(GLushort), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4bvARB", [(GLuint, "index"), (Array(Const(GLbyte), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4dARB", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glVertexAttrib4dvARB", [(GLuint, "index"), (Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4fARB", [(GLuint, "index"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glVertexAttrib4fvARB", [(GLuint, "index"), (Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4ivARB", [(GLuint, "index"), (Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4sARB", [(GLuint, "index"), (GLshort, "x"), (GLshort, "y"), (GLshort, "z"), (GLshort, "w")]),
    GlFunction(Void, "glVertexAttrib4svARB", [(GLuint, "index"), (Array(Const(GLshort), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4ubvARB", [(GLuint, "index"), (Array(Const(GLubyte), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4uivARB", [(GLuint, "index"), (Array(Const(GLuint), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4usvARB", [(GLuint, "index"), (Array(Const(GLushort), 4), "v")]),
    GlFunction(Void, "glVertexAttribPointerARB", [(GLuint, "index"), (size_bgra, "size"), (GLenum, "type"), (GLboolean, "normalized"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glEnableVertexAttribArrayARB", [(GLuint, "index")]),
    GlFunction(Void, "glDisableVertexAttribArrayARB", [(GLuint, "index")]),
    GlFunction(Void, "glProgramStringARB", [(GLenum, "target"), (GLenum, "format"), (GLsizei, "len"), (String(Const(Void), "len"), "string")]),
    GlFunction(Void, "glBindProgramARB", [(GLenum, "target"), (GLprogramARB, "program")]),
    GlFunction(Void, "glDeleteProgramsARB", [(GLsizei, "n"), (Array(Const(GLprogramARB), "n"), "programs")]),
    GlFunction(Void, "glGenProgramsARB", [(GLsizei, "n"), Out(Array(GLprogramARB, "n"), "programs")]),
    GlFunction(Void, "glProgramEnvParameter4dARB", [(GLenum, "target"), (GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glProgramEnvParameter4dvARB", [(GLenum, "target"), (GLuint, "index"), (Array(Const(GLdouble), 4), "params")]),
    GlFunction(Void, "glProgramEnvParameter4fARB", [(GLenum, "target"), (GLuint, "index"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glProgramEnvParameter4fvARB", [(GLenum, "target"), (GLuint, "index"), (Array(Const(GLfloat), 4), "params")]),
    GlFunction(Void, "glProgramLocalParameter4dARB", [(GLenum, "target"), (GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glProgramLocalParameter4dvARB", [(GLenum, "target"), (GLuint, "index"), (Array(Const(GLdouble), 4), "params")]),
    GlFunction(Void, "glProgramLocalParameter4fARB", [(GLenum, "target"), (GLuint, "index"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glProgramLocalParameter4fvARB", [(GLenum, "target"), (GLuint, "index"), (Array(Const(GLfloat), 4), "params")]),
    GlFunction(Void, "glGetProgramEnvParameterdvARB", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLdouble, 4), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramEnvParameterfvARB", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLfloat, 4), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramLocalParameterdvARB", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLdouble, 4), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramLocalParameterfvARB", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLfloat, 4), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramivARB", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramStringARB", [(GLenum, "target"), (GLenum, "pname"), Out(GLpointer, "string")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribdvARB", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLdouble, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribfvARB", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribivARB", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribPointervARB", [(GLuint, "index"), (GLenum, "pname"), Out(Pointer(GLpointer), "pointer")], sideeffects=False),
    GlFunction(GLboolean, "glIsProgramARB", [(GLprogramARB, "program")], sideeffects=False),

    # GL_ARB_vertex_buffer_object
    GlFunction(Void, "glBindBufferARB", [(GLenum, "target"), (GLbuffer, "buffer")]),
    GlFunction(Void, "glDeleteBuffersARB", [(GLsizei, "n"), (Array(Const(GLbuffer), "n"), "buffers")]),
    GlFunction(Void, "glGenBuffersARB", [(GLsizei, "n"), Out(Array(GLbuffer, "n"), "buffers")]),
    GlFunction(GLboolean, "glIsBufferARB", [(GLbuffer, "buffer")], sideeffects=False),
    GlFunction(Void, "glBufferDataARB", [(GLenum, "target"), (GLsizeiptrARB, "size"), (Blob(Const(GLvoid), "size"), "data"), (GLenum, "usage")]),
    GlFunction(Void, "glBufferSubDataARB", [(GLenum, "target"), (GLintptrARB, "offset"), (GLsizeiptrARB, "size"), (Blob(Const(GLvoid), "size"), "data")]),
    GlFunction(Void, "glGetBufferSubDataARB", [(GLenum, "target"), (GLintptrARB, "offset"), (GLsizeiptrARB, "size"), Out(OpaqueBlob(GLvoid, "size"), "data")], sideeffects=False),
    GlFunction(GLmap, "glMapBufferARB", [(GLenum, "target"), (GLenum, "access")]),
    GlFunction(GLboolean, "glUnmapBufferARB", [(GLenum, "target")]),
    GlFunction(Void, "glGetBufferParameterivARB", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetBufferPointervARB", [(GLenum, "target"), (GLenum, "pname"), Out(Pointer(GLpointer), "params")], sideeffects=False),

    # GL_ARB_occlusion_query
    GlFunction(Void, "glGenQueriesARB", [(GLsizei, "n"), Out(Array(GLquery, "n"), "ids")]),
    GlFunction(Void, "glDeleteQueriesARB", [(GLsizei, "n"), (Array(Const(GLquery), "n"), "ids")]),
    GlFunction(GLboolean, "glIsQueryARB", [(GLquery, "id")], sideeffects=False),
    GlFunction(Void, "glBeginQueryARB", [(GLenum, "target"), (GLquery, "id")]),
    GlFunction(Void, "glEndQueryARB", [(GLenum, "target")]),
    GlFunction(Void, "glGetQueryivARB", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetQueryObjectivARB", [(GLquery, "id"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetQueryObjectuivARB", [(GLquery, "id"), (GLenum, "pname"), Out(Array(GLuint, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_ARB_shader_objects
    GlFunction(Void, "glDeleteObjectARB", [(GLhandleARB, "obj")]),
    GlFunction(GLhandleARB, "glGetHandleARB", [(GLenum, "pname")], sideeffects=False),
    GlFunction(Void, "glDetachObjectARB", [(GLhandleARB, "containerObj"), (GLhandleARB, "attachedObj")]),
    GlFunction(GLhandleARB, "glCreateShaderObjectARB", [(GLenum, "shaderType")]),
    GlFunction(Void, "glShaderSourceARB", [(GLhandleARB, "shaderObj"), (GLsizei, "count"), (Const(Array(String(Const(GLcharARB), "_glShaderSource_length(string, length, {i})"), "count")), "string"), (Array(Const(GLint), "count"), "length")]),
    GlFunction(Void, "glCompileShaderARB", [(GLhandleARB, "shaderObj")]),
    GlFunction(GLhandleARB, "glCreateProgramObjectARB", []),
    GlFunction(Void, "glAttachObjectARB", [(GLhandleARB, "containerObj"), (GLhandleARB, "obj")]),
    GlFunction(Void, "glLinkProgramARB", [(GLhandleARB, "programObj")]),
    GlFunction(Void, "glUseProgramObjectARB", [(GLhandleARB, "programObj")]),
    GlFunction(Void, "glValidateProgramARB", [(GLhandleARB, "programObj")]),
    GlFunction(Void, "glUniform1fARB", [(GLlocationARB, "location"), (GLfloat, "v0")]),
    GlFunction(Void, "glUniform2fARB", [(GLlocationARB, "location"), (GLfloat, "v0"), (GLfloat, "v1")]),
    GlFunction(Void, "glUniform3fARB", [(GLlocationARB, "location"), (GLfloat, "v0"), (GLfloat, "v1"), (GLfloat, "v2")]),
    GlFunction(Void, "glUniform4fARB", [(GLlocationARB, "location"), (GLfloat, "v0"), (GLfloat, "v1"), (GLfloat, "v2"), (GLfloat, "v3")]),
    GlFunction(Void, "glUniform1iARB", [(GLlocationARB, "location"), (GLint, "v0")]),
    GlFunction(Void, "glUniform2iARB", [(GLlocationARB, "location"), (GLint, "v0"), (GLint, "v1")]),
    GlFunction(Void, "glUniform3iARB", [(GLlocationARB, "location"), (GLint, "v0"), (GLint, "v1"), (GLint, "v2")]),
    GlFunction(Void, "glUniform4iARB", [(GLlocationARB, "location"), (GLint, "v0"), (GLint, "v1"), (GLint, "v2"), (GLint, "v3")]),
    GlFunction(Void, "glUniform1fvARB", [(GLlocationARB, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count"), "value")]),
    GlFunction(Void, "glUniform2fvARB", [(GLlocationARB, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*2"), "value")]),
    GlFunction(Void, "glUniform3fvARB", [(GLlocationARB, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*3"), "value")]),
    GlFunction(Void, "glUniform4fvARB", [(GLlocationARB, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*4"), "value")]),
    GlFunction(Void, "glUniform1ivARB", [(GLlocationARB, "location"), (GLsizei, "count"), (Array(Const(GLint), "count"), "value")]),
    GlFunction(Void, "glUniform2ivARB", [(GLlocationARB, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*2"), "value")]),
    GlFunction(Void, "glUniform3ivARB", [(GLlocationARB, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*3"), "value")]),
    GlFunction(Void, "glUniform4ivARB", [(GLlocationARB, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*4"), "value")]),
    GlFunction(Void, "glUniformMatrix2fvARB", [(GLlocationARB, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*2*2"), "value")]),
    GlFunction(Void, "glUniformMatrix3fvARB", [(GLlocationARB, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*3*3"), "value")]),
    GlFunction(Void, "glUniformMatrix4fvARB", [(GLlocationARB, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*4*4"), "value")]),
    GlFunction(Void, "glGetObjectParameterfvARB", [(GLhandleARB, "obj"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetObjectParameterivARB", [(GLhandleARB, "obj"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetInfoLogARB", [(GLhandleARB, "obj"), (GLsizei, "maxLength"), Out(Pointer(GLsizei), "length"), OutGlString(GLcharARB, "length", "infoLog")], sideeffects=False),
    GlFunction(Void, "glGetAttachedObjectsARB", [(GLhandleARB, "containerObj"), (GLsizei, "maxCount"), Out(Pointer(GLsizei), "count"), Out(Array(GLhandleARB, "(count ? *count : maxCount)"), "obj")], sideeffects=False),
    GlFunction(GLlocationARB, "glGetUniformLocationARB", [(GLhandleARB, "programObj"), (GLstringConstARB, "name")]),
    GlFunction(Void, "glGetActiveUniformARB", [(GLhandleARB, "programObj"), (GLuint, "index"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), Out(Pointer(GLint), "size"), Out(Pointer(GLenum), "type"), OutGlString(GLcharARB, "length", "name")], sideeffects=False),
    GlFunction(Void, "glGetUniformfvARB", [(GLhandleARB, "programObj"), (GLlocationARB, "location"), Out(OpaquePointer(GLfloat), "params")], sideeffects=False),
    GlFunction(Void, "glGetUniformivARB", [(GLhandleARB, "programObj"), (GLlocationARB, "location"), Out(OpaquePointer(GLint), "params")], sideeffects=False),
    GlFunction(Void, "glGetShaderSourceARB", [(GLhandleARB, "obj"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), OutGlString(GLcharARB, "length", "source")], sideeffects=False),

    # GL_ARB_vertex_shader
    GlFunction(Void, "glBindAttribLocationARB", [(GLhandleARB, "programObj"), (GLuint, "index"), (GLstringConstARB, "name")]),
    GlFunction(Void, "glGetActiveAttribARB", [(GLhandleARB, "programObj"), (GLuint, "index"), (GLsizei, "maxLength"), Out(Pointer(GLsizei), "length"), Out(Pointer(GLint), "size"), Out(Pointer(GLenum), "type"), OutGlString(GLcharARB, "length", "name")], sideeffects=False),
    GlFunction(GLint, "glGetAttribLocationARB", [(GLhandleARB, "programObj"), (GLstringConstARB, "name")]),

    # GL_ARB_draw_buffers
    GlFunction(Void, "glDrawBuffersARB", [(GLsizei, "n"), (Array(Const(GLenum), "n"), "bufs")]),

    # GL_ARB_color_buffer_float
    GlFunction(Void, "glClampColorARB", [(GLenum, "target"), (GLenum, "clamp")]),

    # GL_ARB_draw_instanced
    GlFunction(Void, "glDrawArraysInstancedARB", [(GLenum_mode, "mode"), (GLint, "first"), (GLsizei, "count"), (GLsizei, "primcount")]),
    GlFunction(Void, "glDrawElementsInstancedARB", [(GLenum_mode, "mode"), (GLsizei, "count"), (GLenum, "type"), (GLindexBuffer("count", "type"), "indices"), (GLsizei, "primcount")]),

    # GL_ARB_framebuffer_object
    GlFunction(GLboolean, "glIsRenderbuffer", [(GLrenderbuffer, "renderbuffer")], sideeffects=False),
    GlFunction(Void, "glBindRenderbuffer", [(GLenum, "target"), (GLrenderbuffer, "renderbuffer")]),
    GlFunction(Void, "glDeleteRenderbuffers", [(GLsizei, "n"), (Array(Const(GLrenderbuffer), "n"), "renderbuffers")]),
    GlFunction(Void, "glGenRenderbuffers", [(GLsizei, "n"), Out(Array(GLrenderbuffer, "n"), "renderbuffers")]),
    GlFunction(Void, "glRenderbufferStorage", [(GLenum, "target"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glGetRenderbufferParameteriv", [(GLenum, "target"), (GLenum, "pname"), (Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(GLboolean, "glIsFramebuffer", [(GLframebuffer, "framebuffer")], sideeffects=False),
    GlFunction(Void, "glBindFramebuffer", [(GLenum, "target"), (GLframebuffer, "framebuffer")]),
    GlFunction(Void, "glDeleteFramebuffers", [(GLsizei, "n"), (Array(Const(GLframebuffer), "n"), "framebuffers")]),
    GlFunction(Void, "glGenFramebuffers", [(GLsizei, "n"), Out(Array(GLframebuffer, "n"), "framebuffers")]),
    GlFunction(GLenum, "glCheckFramebufferStatus", [(GLenum, "target")]),
    GlFunction(Void, "glFramebufferTexture1D", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "textarget"), (GLtexture, "texture"), (GLint, "level")]),
    GlFunction(Void, "glFramebufferTexture2D", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "textarget"), (GLtexture, "texture"), (GLint, "level")]),
    GlFunction(Void, "glFramebufferTexture3D", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "textarget"), (GLtexture, "texture"), (GLint, "level"), (GLint, "zoffset")]),
    GlFunction(Void, "glFramebufferRenderbuffer", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "renderbuffertarget"), (GLrenderbuffer, "renderbuffer")]),
    GlFunction(Void, "glGetFramebufferAttachmentParameteriv", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGenerateMipmap", [(GLenum, "target")]),
    GlFunction(Void, "glBlitFramebuffer", [(GLint, "srcX0"), (GLint, "srcY0"), (GLint, "srcX1"), (GLint, "srcY1"), (GLint, "dstX0"), (GLint, "dstY0"), (GLint, "dstX1"), (GLint, "dstY1"), (GLbitfield_attrib, "mask"), (GLenum, "filter")]),
    GlFunction(Void, "glRenderbufferStorageMultisample", [(GLenum, "target"), (GLsizei, "samples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glFramebufferTextureLayer", [(GLenum, "target"), (GLenum, "attachment"), (GLtexture, "texture"), (GLint, "level"), (GLint, "layer")]),

    # GL_ARB_geometry_shader4
    GlFunction(Void, "glProgramParameteriARB", [(GLprogram, "program"), (GLenum, "pname"), (GLint, "value")]),
    GlFunction(Void, "glFramebufferTextureARB", [(GLenum, "target"), (GLenum, "attachment"), (GLtexture, "texture"), (GLint, "level")]),
    GlFunction(Void, "glFramebufferTextureLayerARB", [(GLenum, "target"), (GLenum, "attachment"), (GLtexture, "texture"), (GLint, "level"), (GLint, "layer")]),
    GlFunction(Void, "glFramebufferTextureFaceARB", [(GLenum, "target"), (GLenum, "attachment"), (GLtexture, "texture"), (GLint, "level"), (GLenum, "face")]),

    # GL_ARB_instanced_arrays
    GlFunction(Void, "glVertexAttribDivisorARB", [(GLuint, "index"), (GLuint, "divisor")]),

    # GL_ARB_map_buffer_range
    GlFunction(GLmap, "glMapBufferRange", [(GLenum, "target"), (GLintptr, "offset"), (GLsizeiptr, "length"), (GLbitfield_access, "access")]),
    GlFunction(Void, "glFlushMappedBufferRange", [(GLenum, "target"), (GLintptr, "offset"), (GLsizeiptr, "length")]),

    # GL_ARB_texture_buffer_object
    GlFunction(Void, "glTexBufferARB", [(GLenum, "target"), (GLenum, "internalformat"), (GLbuffer, "buffer")]),

    # GL_ARB_vertex_array_object
    GlFunction(Void, "glBindVertexArray", [(GLarray, "array")]),
    GlFunction(Void, "glDeleteVertexArrays", [(GLsizei, "n"), (Array(Const(GLarray), "n"), "arrays")]),
    GlFunction(Void, "glGenVertexArrays", [(GLsizei, "n"), Out(Array(GLarray, "n"), "arrays")]),
    GlFunction(GLboolean, "glIsVertexArray", [(GLarray, "array")], sideeffects=False),

    # GL_ARB_uniform_buffer_object
    GlFunction(Void, "glGetUniformIndices", [(GLprogram, "program"), (GLsizei, "uniformCount"), (Array(Const(GLstringConst), "uniformCount"), "uniformNames"), Out(Array(GLuint, "uniformCount"), "uniformIndices")], sideeffects=False),
    GlFunction(Void, "glGetActiveUniformsiv", [(GLprogram, "program"), (GLsizei, "uniformCount"), (Array(Const(GLuint), "uniformCount"), "uniformIndices"), (GLenum, "pname"), Out(OpaqueArray(GLint, "_glGetActiveUniformsiv_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetActiveUniformName", [(GLprogram, "program"), (GLuint, "uniformIndex"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), OutGlString(GLchar, "length", "uniformName")], sideeffects=False),
    GlFunction(GLuniformBlock, "glGetUniformBlockIndex", [(GLprogram, "program"), (GLstringConst, "uniformBlockName")]),
    GlFunction(Void, "glGetActiveUniformBlockiv", [(GLprogram, "program"), (GLuniformBlock, "uniformBlockIndex"), (GLenum, "pname"), Out(OpaqueArray(GLint, "_glGetActiveUniformBlockiv_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetActiveUniformBlockName", [(GLprogram, "program"), (GLuniformBlock, "uniformBlockIndex"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), OutGlString(GLchar, "length", "uniformBlockName")], sideeffects=False),
    GlFunction(Void, "glUniformBlockBinding", [(GLprogram, "program"), (GLuniformBlock, "uniformBlockIndex"), (GLuint, "uniformBlockBinding")]),

    # GL_ARB_copy_buffer
    GlFunction(Void, "glCopyBufferSubData", [(GLenum, "readTarget"), (GLenum, "writeTarget"), (GLintptr, "readOffset"), (GLintptr, "writeOffset"), (GLsizeiptr, "size")]),

    # GL_ARB_draw_elements_base_vertex
    GlFunction(Void, "glDrawElementsBaseVertex", [(GLenum_mode, "mode"), (GLsizei, "count"), (GLenum, "type"), (GLindexBuffer("count", "type"), "indices"), (GLint, "basevertex")]),
    GlFunction(Void, "glDrawRangeElementsBaseVertex", [(GLenum_mode, "mode"), (GLuint, "start"), (GLuint, "end"), (GLsizei, "count"), (GLenum, "type"), (GLindexBuffer("count", "type"), "indices"), (GLint, "basevertex")]),
    GlFunction(Void, "glDrawElementsInstancedBaseVertex", [(GLenum_mode, "mode"), (GLsizei, "count"), (GLenum, "type"), (GLindexBuffer("count", "type"), "indices"), (GLsizei, "primcount"), (GLint, "basevertex")]),
    GlFunction(Void, "glMultiDrawElementsBaseVertex", [(GLenum_mode, "mode"), (Array(Const(GLsizei), "drawcount"), "count"), (GLenum, "type"), (Array(Const(GLindexBuffer("count[{i}]", "type")), "drawcount"), "indices"), (GLsizei, "drawcount"), (Array(Const(GLint), "drawcount"), "basevertex")]),

    # GL_ARB_provoking_vertex
    GlFunction(Void, "glProvokingVertex", [(GLenum, "mode")]),

    # GL_ARB_sync
    GlFunction(GLsync, "glFenceSync", [(GLenum, "condition"), (GLbitfield, "flags")]),
    GlFunction(GLboolean, "glIsSync", [(GLsync, "sync")], sideeffects=False),
    GlFunction(Void, "glDeleteSync", [(GLsync, "sync")]),
    GlFunction(GLenum, "glClientWaitSync", [(GLsync, "sync"), (GLbitfield_sync_flush, "flags"), (GLuint64, "timeout")]),
    GlFunction(Void, "glWaitSync", [(GLsync, "sync"), (GLbitfield, "flags"), (GLuint64, "timeout")]),
    GlFunction(Void, "glGetInteger64v", [(GLenum, "pname"), Out(Array(GLint64, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetSynciv", [(GLsync, "sync"), (GLenum, "pname"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), Out(Array(GLint, "(length ? *length : bufSize)"), "values")], sideeffects=False),

    # GL_ARB_texture_multisample
    GlFunction(Void, "glTexImage2DMultisample", [(GLenum, "target"), (GLsizei, "samples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLboolean, "fixedsamplelocations")]),
    GlFunction(Void, "glTexImage3DMultisample", [(GLenum, "target"), (GLsizei, "samples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLboolean, "fixedsamplelocations")]),
    GlFunction(Void, "glGetMultisamplefv", [(GLenum, "pname"), (GLuint, "index"), Out(Array(GLfloat, "_gl_param_size(pname)"), "val")], sideeffects=False),
    GlFunction(Void, "glSampleMaski", [(GLuint, "index"), (GLbitfield, "mask")]),

    # GL_ARB_draw_buffers_blend
    GlFunction(Void, "glBlendEquationiARB", [(GLuint, "buf"), (GLenum, "mode")]),
    GlFunction(Void, "glBlendEquationSeparateiARB", [(GLuint, "buf"), (GLenum, "modeRGB"), (GLenum, "modeAlpha")]),
    GlFunction(Void, "glBlendFunciARB", [(GLuint, "buf"), (GLenum, "src"), (GLenum, "dst")]),
    GlFunction(Void, "glBlendFuncSeparateiARB", [(GLuint, "buf"), (GLenum, "srcRGB"), (GLenum, "dstRGB"), (GLenum, "srcAlpha"), (GLenum, "dstAlpha")]),

    # GL_ARB_sample_shading
    GlFunction(Void, "glMinSampleShadingARB", [(GLfloat, "value")]),

    # GL_ARB_shading_language_include
    GlFunction(Void, "glNamedStringARB", [(GLenum, "type"), (GLint, "namelen"), InGlString(GLchar, "namelen", "name"), (GLint, "stringlen"), InGlString(GLchar, "stringlen", "string")]),
    GlFunction(Void, "glDeleteNamedStringARB", [(GLint, "namelen"), InGlString(GLchar, "namelen", "name")]),
    GlFunction(Void, "glCompileShaderIncludeARB", [(GLshader, "shader"), (GLsizei, "count"), (Array(Const(String(Const(GLchar), "_glShaderSource_length(path, length, {i})")), "count"), "path"), (Array(Const(GLint), "count"), "length")]),
    GlFunction(GLboolean, "glIsNamedStringARB", [(GLint, "namelen"), InGlString(GLchar, "namelen", "name")], sideeffects=False),
    GlFunction(Void, "glGetNamedStringARB", [(GLint, "namelen"), InGlString(GLchar, "namelen", "name"), (GLsizei, "bufSize"), Out(Pointer(GLint), "stringlen"), OutGlString(GLchar, "stringlen", "string")], sideeffects=False),
    GlFunction(Void, "glGetNamedStringivARB", [(GLint, "namelen"), InGlString(GLchar, "namelen", "name"), (GLenum, "pname"), Out(OpaqueArray(GLint, "_glGetNamedStringivARB_size(pname)"), "params")], sideeffects=False),

    # GL_ARB_blend_func_extended
    GlFunction(Void, "glBindFragDataLocationIndexed", [(GLprogram, "program"), (GLuint, "colorNumber"), (GLuint, "index"), (GLstringConst, "name")]),
    GlFunction(GLint, "glGetFragDataIndex", [(GLprogram, "program"), (GLstringConst, "name")], sideeffects=False),

    # GL_ARB_sampler_objects
    GlFunction(Void, "glGenSamplers", [(GLsizei, "count"), Out(Array(GLsampler, "count"), "samplers")]),
    GlFunction(Void, "glDeleteSamplers", [(GLsizei, "count"), (Array(Const(GLsampler), "count"), "samplers")]),
    GlFunction(GLboolean, "glIsSampler", [(GLsampler, "sampler")], sideeffects=False),
    GlFunction(Void, "glBindSampler", [(GLuint, "unit"), (GLsampler, "sampler")]),
    GlFunction(Void, "glSamplerParameteri", [(GLsampler, "sampler"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glSamplerParameteriv", [(GLsampler, "sampler"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "param")]),
    GlFunction(Void, "glSamplerParameterf", [(GLsampler, "sampler"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glSamplerParameterfv", [(GLsampler, "sampler"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "param")]),
    GlFunction(Void, "glSamplerParameterIiv", [(GLsampler, "sampler"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "param")]),
    GlFunction(Void, "glSamplerParameterIuiv", [(GLsampler, "sampler"), (GLenum, "pname"), (Array(Const(GLuint), "_gl_param_size(pname)"), "param")]),
    GlFunction(Void, "glGetSamplerParameteriv", [(GLsampler, "sampler"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetSamplerParameterIiv", [(GLsampler, "sampler"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetSamplerParameterfv", [(GLsampler, "sampler"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetSamplerParameterIuiv", [(GLsampler, "sampler"), (GLenum, "pname"), Out(Array(GLuint, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_ARB_timer_query
    GlFunction(Void, "glQueryCounter", [(GLquery, "id"), (GLenum, "target")]),
    GlFunction(Void, "glGetQueryObjecti64v", [(GLquery, "id"), (GLenum, "pname"), Out(Array(GLint64, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetQueryObjectui64v", [(GLquery, "id"), (GLenum, "pname"), Out(Array(GLuint64, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_ARB_vertex_type_2_10_10_10_rev
    GlFunction(Void, "glVertexP2ui", [(GLenum, "type"), (GLuint, "value")]),
    GlFunction(Void, "glVertexP2uiv", [(GLenum, "type"), (Pointer(Const(GLuint)), "value")]),
    GlFunction(Void, "glVertexP3ui", [(GLenum, "type"), (GLuint, "value")]),
    GlFunction(Void, "glVertexP3uiv", [(GLenum, "type"), (Pointer(Const(GLuint)), "value")]),
    GlFunction(Void, "glVertexP4ui", [(GLenum, "type"), (GLuint, "value")]),
    GlFunction(Void, "glVertexP4uiv", [(GLenum, "type"), (Pointer(Const(GLuint)), "value")]),
    GlFunction(Void, "glTexCoordP1ui", [(GLenum, "type"), (GLuint, "coords")]),
    GlFunction(Void, "glTexCoordP1uiv", [(GLenum, "type"), (Pointer(Const(GLuint)), "coords")]),
    GlFunction(Void, "glTexCoordP2ui", [(GLenum, "type"), (GLuint, "coords")]),
    GlFunction(Void, "glTexCoordP2uiv", [(GLenum, "type"), (Pointer(Const(GLuint)), "coords")]),
    GlFunction(Void, "glTexCoordP3ui", [(GLenum, "type"), (GLuint, "coords")]),
    GlFunction(Void, "glTexCoordP3uiv", [(GLenum, "type"), (Pointer(Const(GLuint)), "coords")]),
    GlFunction(Void, "glTexCoordP4ui", [(GLenum, "type"), (GLuint, "coords")]),
    GlFunction(Void, "glTexCoordP4uiv", [(GLenum, "type"), (Pointer(Const(GLuint)), "coords")]),
    GlFunction(Void, "glMultiTexCoordP1ui", [(GLenum, "texture"), (GLenum, "type"), (GLuint, "coords")]),
    GlFunction(Void, "glMultiTexCoordP1uiv", [(GLenum, "texture"), (GLenum, "type"), (Pointer(Const(GLuint)), "coords")]),
    GlFunction(Void, "glMultiTexCoordP2ui", [(GLenum, "texture"), (GLenum, "type"), (GLuint, "coords")]),
    GlFunction(Void, "glMultiTexCoordP2uiv", [(GLenum, "texture"), (GLenum, "type"), (Pointer(Const(GLuint)), "coords")]),
    GlFunction(Void, "glMultiTexCoordP3ui", [(GLenum, "texture"), (GLenum, "type"), (GLuint, "coords")]),
    GlFunction(Void, "glMultiTexCoordP3uiv", [(GLenum, "texture"), (GLenum, "type"), (Pointer(Const(GLuint)), "coords")]),
    GlFunction(Void, "glMultiTexCoordP4ui", [(GLenum, "texture"), (GLenum, "type"), (GLuint, "coords")]),
    GlFunction(Void, "glMultiTexCoordP4uiv", [(GLenum, "texture"), (GLenum, "type"), (Pointer(Const(GLuint)), "coords")]),
    GlFunction(Void, "glNormalP3ui", [(GLenum, "type"), (GLuint, "coords")]),
    GlFunction(Void, "glNormalP3uiv", [(GLenum, "type"), (Pointer(Const(GLuint)), "coords")]),
    GlFunction(Void, "glColorP3ui", [(GLenum, "type"), (GLuint, "color")]),
    GlFunction(Void, "glColorP3uiv", [(GLenum, "type"), (Pointer(Const(GLuint)), "color")]),
    GlFunction(Void, "glColorP4ui", [(GLenum, "type"), (GLuint, "color")]),
    GlFunction(Void, "glColorP4uiv", [(GLenum, "type"), (Pointer(Const(GLuint)), "color")]),
    GlFunction(Void, "glSecondaryColorP3ui", [(GLenum, "type"), (GLuint, "color")]),
    GlFunction(Void, "glSecondaryColorP3uiv", [(GLenum, "type"), (Pointer(Const(GLuint)), "color")]),
    GlFunction(Void, "glVertexAttribP1ui", [(GLuint, "index"), (GLenum, "type"), (GLboolean, "normalized"), (GLuint, "value")]),
    GlFunction(Void, "glVertexAttribP1uiv", [(GLuint, "index"), (GLenum, "type"), (GLboolean, "normalized"), (Pointer(Const(GLuint)), "value")]),
    GlFunction(Void, "glVertexAttribP2ui", [(GLuint, "index"), (GLenum, "type"), (GLboolean, "normalized"), (GLuint, "value")]),
    GlFunction(Void, "glVertexAttribP2uiv", [(GLuint, "index"), (GLenum, "type"), (GLboolean, "normalized"), (Pointer(Const(GLuint)), "value")]),
    GlFunction(Void, "glVertexAttribP3ui", [(GLuint, "index"), (GLenum, "type"), (GLboolean, "normalized"), (GLuint, "value")]),
    GlFunction(Void, "glVertexAttribP3uiv", [(GLuint, "index"), (GLenum, "type"), (GLboolean, "normalized"), (Pointer(Const(GLuint)), "value")]),
    GlFunction(Void, "glVertexAttribP4ui", [(GLuint, "index"), (GLenum, "type"), (GLboolean, "normalized"), (GLuint, "value")]),
    GlFunction(Void, "glVertexAttribP4uiv", [(GLuint, "index"), (GLenum, "type"), (GLboolean, "normalized"), (Pointer(Const(GLuint)), "value")]),

    # GL_ARB_draw_indirect
    GlFunction(Void, "glDrawArraysIndirect", [(GLenum_mode, "mode"), (GLpointerConst, "indirect")]),
    GlFunction(Void, "glDrawElementsIndirect", [(GLenum_mode, "mode"), (GLenum, "type"), (GLpointerConst, "indirect")]),

    # GL_ARB_gpu_shader_fp64
    GlFunction(Void, "glUniform1d", [(GLlocation, "location"), (GLdouble, "x")]),
    GlFunction(Void, "glUniform2d", [(GLlocation, "location"), (GLdouble, "x"), (GLdouble, "y")]),
    GlFunction(Void, "glUniform3d", [(GLlocation, "location"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glUniform4d", [(GLlocation, "location"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glUniform1dv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLdouble), "count"), "value")]),
    GlFunction(Void, "glUniform2dv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLdouble), "count*2"), "value")]),
    GlFunction(Void, "glUniform3dv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLdouble), "count*3"), "value")]),
    GlFunction(Void, "glUniform4dv", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLdouble), "count*4"), "value")]),
    GlFunction(Void, "glUniformMatrix2dv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*2*2"), "value")]),
    GlFunction(Void, "glUniformMatrix3dv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*3*3"), "value")]),
    GlFunction(Void, "glUniformMatrix4dv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*4*4"), "value")]),
    GlFunction(Void, "glUniformMatrix2x3dv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*2*3"), "value")]),
    GlFunction(Void, "glUniformMatrix2x4dv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*2*4"), "value")]),
    GlFunction(Void, "glUniformMatrix3x2dv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*3*2"), "value")]),
    GlFunction(Void, "glUniformMatrix3x4dv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*3*4"), "value")]),
    GlFunction(Void, "glUniformMatrix4x2dv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*4*2"), "value")]),
    GlFunction(Void, "glUniformMatrix4x3dv", [(GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*4*3"), "value")]),
    GlFunction(Void, "glGetUniformdv", [(GLprogram, "program"), (GLlocation, "location"), Out(OpaqueArray(GLdouble, "_glGetUniformdv_size(location)"), "params")], sideeffects=False),

    # GL_ARB_shader_subroutine
    GlFunction(GLlocation, "glGetSubroutineUniformLocation", [(GLprogram, "program"), (GLenum, "shadertype"), (GLstringConst, "name")]),
    GlFunction(GLuint, "glGetSubroutineIndex", [(GLprogram, "program"), (GLenum, "shadertype"), (GLstringConst, "name")]),
    GlFunction(Void, "glGetActiveSubroutineUniformiv", [(GLprogram, "program"), (GLenum, "shadertype"), (GLuint, "index"), (GLenum, "pname"), Out(OpaqueArray(GLint, "_glGetActiveSubroutineUniformiv_size(pname)"), "values")], sideeffects=False),
    GlFunction(Void, "glGetActiveSubroutineUniformName", [(GLprogram, "program"), (GLenum, "shadertype"), (GLuint, "index"), (GLsizei, "bufsize"), Out(Pointer(GLsizei), "length"), OutGlString(GLchar, "length", "name")], sideeffects=False),
    GlFunction(Void, "glGetActiveSubroutineName", [(GLprogram, "program"), (GLenum, "shadertype"), (GLuint, "index"), (GLsizei, "bufsize"), Out(Pointer(GLsizei), "length"), OutGlString(GLchar, "length", "name")], sideeffects=False),
    GlFunction(Void, "glUniformSubroutinesuiv", [(GLenum, "shadertype"), (GLsizei, "count"), (Array(Const(GLuint), "count"), "indices")]),
    GlFunction(Void, "glGetUniformSubroutineuiv", [(GLenum, "shadertype"), (GLlocation, "location"), Out(Pointer(GLuint), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramStageiv", [(GLprogram, "program"), (GLenum, "shadertype"), (GLenum, "pname"), Out(Pointer(GLint), "values")], sideeffects=False),

    # GL_ARB_tessellation_shader
    GlFunction(Void, "glPatchParameteri", [(GLenum, "pname"), (GLint, "value")]),
    GlFunction(Void, "glPatchParameterfv", [(GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "values")]),

    # GL_ARB_transform_feedback2
    GlFunction(Void, "glBindTransformFeedback", [(GLenum, "target"), (GLfeedback, "id")]),
    GlFunction(Void, "glDeleteTransformFeedbacks", [(GLsizei, "n"), (Array(Const(GLfeedback), "n"), "ids")]),
    GlFunction(Void, "glGenTransformFeedbacks", [(GLsizei, "n"), Out(Array(GLfeedback, "n"), "ids")]),
    GlFunction(GLboolean, "glIsTransformFeedback", [(GLfeedback, "id")], sideeffects=False),
    GlFunction(Void, "glPauseTransformFeedback", []),
    GlFunction(Void, "glResumeTransformFeedback", []),
    GlFunction(Void, "glDrawTransformFeedback", [(GLenum_mode, "mode"), (GLfeedback, "id")]),

    # GL_ARB_transform_feedback3
    GlFunction(Void, "glDrawTransformFeedbackStream", [(GLenum_mode, "mode"), (GLfeedback, "id"), (GLuint, "stream")]),
    GlFunction(Void, "glBeginQueryIndexed", [(GLenum, "target"), (GLuint, "index"), (GLfeedback, "id")]),
    GlFunction(Void, "glEndQueryIndexed", [(GLenum, "target"), (GLuint, "index")]),
    GlFunction(Void, "glGetQueryIndexediv", [(GLenum, "target"), (GLuint, "index"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_ARB_ES2_compatibility
    GlFunction(Void, "glReleaseShaderCompiler", []),
    GlFunction(Void, "glShaderBinary", [(GLsizei, "count"), (Array(Const(GLuint), "count"), "shaders"), (GLenum, "binaryformat"), (Blob(Const(GLvoid), "length"), "binary"), (GLsizei, "length")]),
    GlFunction(Void, "glGetShaderPrecisionFormat", [(GLenum, "shadertype"), (GLenum, "precisiontype"), Out(Array(GLint, 2), "range"), Out(Array(GLint, 2), "precision")], sideeffects=False),
    GlFunction(Void, "glDepthRangef", [(GLfloat, "n"), (GLfloat, "f")]),
    GlFunction(Void, "glClearDepthf", [(GLfloat, "d")]),

    # GL_ARB_get_program_binary
    GlFunction(Void, "glGetProgramBinary", [(GLprogram, "program"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), Out(Pointer(GLenum), "binaryFormat"), Out(OpaqueArray(GLvoid, "_glGetProgramBinary_size(length)"), "binary")], sideeffects=False),
    GlFunction(Void, "glProgramBinary", [(GLprogram, "program"), (GLenum, "binaryFormat"), (Blob(Const(GLvoid), "length"), "binary"), (GLsizei, "length")]),
    GlFunction(Void, "glProgramParameteri", [(GLprogram, "program"), (GLenum, "pname"), (GLint, "value")]),

    # GL_ARB_separate_shader_objects
    GlFunction(Void, "glUseProgramStages", [(GLpipeline, "pipeline"), (GLbitfield_shader, "stages"), (GLprogram, "program")]),
    GlFunction(Void, "glActiveShaderProgram", [(GLpipeline, "pipeline"), (GLprogram, "program")]),
    GlFunction(GLprogram, "glCreateShaderProgramv", [(GLenum, "type"), (GLsizei, "count"), (Array(Const(GLstringConst), "count"), "strings")]),
    GlFunction(Void, "glBindProgramPipeline", [(GLpipeline, "pipeline")]),
    GlFunction(Void, "glDeleteProgramPipelines", [(GLsizei, "n"), (Array(Const(GLuint), "n"), "pipelines")]),
    GlFunction(Void, "glGenProgramPipelines", [(GLsizei, "n"), Out(Array(GLpipeline, "n"), "pipelines")]),
    GlFunction(GLboolean, "glIsProgramPipeline", [(GLpipeline, "pipeline")], sideeffects=False),
    GlFunction(Void, "glGetProgramPipelineiv", [(GLpipeline, "pipeline"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glProgramUniform1i", [(GLprogram, "program"), (GLlocation, "location"), (GLint, "v0")]),
    GlFunction(Void, "glProgramUniform1iv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count"), "value")]),
    GlFunction(Void, "glProgramUniform1f", [(GLprogram, "program"), (GLlocation, "location"), (GLfloat, "v0")]),
    GlFunction(Void, "glProgramUniform1fv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count"), "value")]),
    GlFunction(Void, "glProgramUniform1d", [(GLprogram, "program"), (GLlocation, "location"), (GLdouble, "v0")]),
    GlFunction(Void, "glProgramUniform1dv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLdouble), "count"), "value")]),
    GlFunction(Void, "glProgramUniform1ui", [(GLprogram, "program"), (GLlocation, "location"), (GLuint, "v0")]),
    GlFunction(Void, "glProgramUniform1uiv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count"), "value")]),
    GlFunction(Void, "glProgramUniform2i", [(GLprogram, "program"), (GLlocation, "location"), (GLint, "v0"), (GLint, "v1")]),
    GlFunction(Void, "glProgramUniform2iv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*2"), "value")]),
    GlFunction(Void, "glProgramUniform2f", [(GLprogram, "program"), (GLlocation, "location"), (GLfloat, "v0"), (GLfloat, "v1")]),
    GlFunction(Void, "glProgramUniform2fv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*2"), "value")]),
    GlFunction(Void, "glProgramUniform2d", [(GLprogram, "program"), (GLlocation, "location"), (GLdouble, "v0"), (GLdouble, "v1")]),
    GlFunction(Void, "glProgramUniform2dv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLdouble), "count*2"), "value")]),
    GlFunction(Void, "glProgramUniform2ui", [(GLprogram, "program"), (GLlocation, "location"), (GLuint, "v0"), (GLuint, "v1")]),
    GlFunction(Void, "glProgramUniform2uiv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count*2"), "value")]),
    GlFunction(Void, "glProgramUniform3i", [(GLprogram, "program"), (GLlocation, "location"), (GLint, "v0"), (GLint, "v1"), (GLint, "v2")]),
    GlFunction(Void, "glProgramUniform3iv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*3"), "value")]),
    GlFunction(Void, "glProgramUniform3f", [(GLprogram, "program"), (GLlocation, "location"), (GLfloat, "v0"), (GLfloat, "v1"), (GLfloat, "v2")]),
    GlFunction(Void, "glProgramUniform3fv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*3"), "value")]),
    GlFunction(Void, "glProgramUniform3d", [(GLprogram, "program"), (GLlocation, "location"), (GLdouble, "v0"), (GLdouble, "v1"), (GLdouble, "v2")]),
    GlFunction(Void, "glProgramUniform3dv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLdouble), "count*3"), "value")]),
    GlFunction(Void, "glProgramUniform3ui", [(GLprogram, "program"), (GLlocation, "location"), (GLuint, "v0"), (GLuint, "v1"), (GLuint, "v2")]),
    GlFunction(Void, "glProgramUniform3uiv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count*3"), "value")]),
    GlFunction(Void, "glProgramUniform4i", [(GLprogram, "program"), (GLlocation, "location"), (GLint, "v0"), (GLint, "v1"), (GLint, "v2"), (GLint, "v3")]),
    GlFunction(Void, "glProgramUniform4iv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*4"), "value")]),
    GlFunction(Void, "glProgramUniform4f", [(GLprogram, "program"), (GLlocation, "location"), (GLfloat, "v0"), (GLfloat, "v1"), (GLfloat, "v2"), (GLfloat, "v3")]),
    GlFunction(Void, "glProgramUniform4fv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*4"), "value")]),
    GlFunction(Void, "glProgramUniform4d", [(GLprogram, "program"), (GLlocation, "location"), (GLdouble, "v0"), (GLdouble, "v1"), (GLdouble, "v2"), (GLdouble, "v3")]),
    GlFunction(Void, "glProgramUniform4dv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLdouble), "count*4"), "value")]),
    GlFunction(Void, "glProgramUniform4ui", [(GLprogram, "program"), (GLlocation, "location"), (GLuint, "v0"), (GLuint, "v1"), (GLuint, "v2"), (GLuint, "v3")]),
    GlFunction(Void, "glProgramUniform4uiv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix2fv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*2*2"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix3fv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*3*3"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix4fv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*4*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix2dv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*2*2"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix3dv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*3*3"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix4dv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*4*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix2x3fv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*2*3"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix3x2fv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*3*2"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix2x4fv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*2*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix4x2fv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*4*2"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix3x4fv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*3*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix4x3fv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*4*3"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix2x3dv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*2*3"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix3x2dv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*3*2"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix2x4dv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*2*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix4x2dv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*4*2"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix3x4dv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*3*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix4x3dv", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*4*3"), "value")]),
    GlFunction(Void, "glValidateProgramPipeline", [(GLpipeline, "pipeline")]),
    GlFunction(Void, "glGetProgramPipelineInfoLog", [(GLpipeline, "pipeline"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), OutGlString(GLchar, "length", "infoLog")], sideeffects=False),

    # GL_ARB_vertex_attrib_64bit
    GlFunction(Void, "glVertexAttribL1d", [(GLuint, "index"), (GLdouble, "x")]),
    GlFunction(Void, "glVertexAttribL2d", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y")]),
    GlFunction(Void, "glVertexAttribL3d", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glVertexAttribL4d", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glVertexAttribL1dv", [(GLuint, "index"), (Pointer(Const(GLdouble)), "v")]),
    GlFunction(Void, "glVertexAttribL2dv", [(GLuint, "index"), (Array(Const(GLdouble), 2), "v")]),
    GlFunction(Void, "glVertexAttribL3dv", [(GLuint, "index"), (Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glVertexAttribL4dv", [(GLuint, "index"), (Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glVertexAttribLPointer", [(GLuint, "index"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glGetVertexAttribLdv", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLdouble, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_ARB_viewport_array
    GlFunction(Void, "glViewportArrayv", [(GLuint, "first"), (GLsizei, "count"), (Array(Const(GLfloat), "count*4"), "v")]),
    GlFunction(Void, "glViewportIndexedf", [(GLuint, "index"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "w"), (GLfloat, "h")]),
    GlFunction(Void, "glViewportIndexedfv", [(GLuint, "index"), (Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glScissorArrayv", [(GLuint, "first"), (GLsizei, "count"), (Array(Const(GLint), "count*4"), "v")]),
    GlFunction(Void, "glScissorIndexed", [(GLuint, "index"), (GLint, "left"), (GLint, "bottom"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glScissorIndexedv", [(GLuint, "index"), (Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glDepthRangeArrayv", [(GLuint, "first"), (GLsizei, "count"), (Array(Const(GLdouble), "count*2"), "v")]),
    GlFunction(Void, "glDepthRangeIndexed", [(GLuint, "index"), (GLdouble, "n"), (GLdouble, "f")]),
    GlFunction(Void, "glGetFloati_v", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLfloat, "_gl_param_size(target)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetDoublei_v", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLdouble, "_gl_param_size(target)"), "data")], sideeffects=False),

    # GL_ARB_cl_event
    #GlFunction(GLsync, "glCreateSyncFromCLeventARB", [(OpaquePointer("struct _cl_context"), "context"), (OpaquePointer("struct _cl_event"), "event"), (GLbitfield, "flags")]),

    # GL_ARB_debug_output
    GlFunction(Void, "glDebugMessageControlARB", [(GLenum, "source"), (GLenum, "type"), (GLenum, "severity"), (GLsizei, "count"), (Array(Const(GLuint), "count"), "ids"), (GLboolean, "enabled")], sideeffects=True),
    GlFunction(Void, "glDebugMessageInsertARB", [(GLenum, "source"), (GLenum, "type"), (GLuint, "id"), (GLenum, "severity"), (GLsizei, "length"), InGlString(GLchar, "length", "buf")], sideeffects=True),
    GlFunction(Void, "glDebugMessageCallbackARB", [(GLDEBUGPROCARB, "callback"), (GLpointerConst, "userParam")], sideeffects=False),
    GlFunction(GLuint, "glGetDebugMessageLogARB", [(GLuint, "count"), (GLsizei, "bufsize"), Out(Array(GLenum, "count"), "sources"), Out(Array(GLenum, "count"), "types"), Out(Array(GLuint, "count"), "ids"), Out(Array(GLenum, "count"), "severities"), Out(Array(GLsizei, "count"), "lengths"), Out(String(GLchar, "_glGetDebugMessageLog_length(messageLog, lengths, _result)"), "messageLog")], sideeffects=False, fail=0),

    # GL_ARB_robustness
    GlFunction(GLenum, "glGetGraphicsResetStatusARB", [], sideeffects=False),
    GlFunction(Void, "glGetnMapdvARB", [(GLenum, "target"), (GLenum, "query"), (GLsizei, "bufSize"), Out(Array(GLdouble, "bufSize"), "v")], sideeffects=False),
    GlFunction(Void, "glGetnMapfvARB", [(GLenum, "target"), (GLenum, "query"), (GLsizei, "bufSize"), Out(Array(GLfloat, "bufSize"), "v")], sideeffects=False),
    GlFunction(Void, "glGetnMapivARB", [(GLenum, "target"), (GLenum, "query"), (GLsizei, "bufSize"), Out(Array(GLint, "bufSize"), "v")], sideeffects=False),
    GlFunction(Void, "glGetnPixelMapfvARB", [(GLenum, "map"), (GLsizei, "bufSize"), Out(Array(GLfloat, "bufSize"), "values")]),
    GlFunction(Void, "glGetnPixelMapuivARB", [(GLenum, "map"), (GLsizei, "bufSize"), Out(Array(GLuint, "bufSize"), "values")]),
    GlFunction(Void, "glGetnPixelMapusvARB", [(GLenum, "map"), (GLsizei, "bufSize"), Out(Array(GLushort, "bufSize"), "values")]),
    GlFunction(Void, "glGetnPolygonStippleARB", [(GLsizei, "bufSize"), Out(OpaqueBlob(GLubyte, "bufSize"), "pattern")]),
    GlFunction(Void, "glGetnColorTableARB", [(GLenum, "target"), (GLenum, "format"), (GLenum, "type"), (GLsizei, "bufSize"), Out(OpaqueBlob(GLvoid, "bufSize"), "table")], sideeffects=False),
    GlFunction(Void, "glGetnConvolutionFilterARB", [(GLenum, "target"), (GLenum, "format"), (GLenum, "type"), (GLsizei, "bufSize"), Out(OpaqueBlob(GLvoid, "bufSize"), "image")]),
    GlFunction(Void, "glGetnSeparableFilterARB", [(GLenum, "target"), (GLenum, "format"), (GLenum, "type"), (GLsizei, "rowBufSize"), Out(OpaqueBlob(GLvoid, "rowBufSize"), "row"), (GLsizei, "columnBufSize"), Out(OpaqueBlob(GLvoid, "columnBufSize"), "column"), Out(GLpointer, "span")]),
    GlFunction(Void, "glGetnHistogramARB", [(GLenum, "target"), (GLboolean, "reset"), (GLenum, "format"), (GLenum, "type"), (GLsizei, "bufSize"), Out(OpaqueBlob(GLvoid, "bufSize"), "values")]),
    GlFunction(Void, "glGetnMinmaxARB", [(GLenum, "target"), (GLboolean, "reset"), (GLenum, "format"), (GLenum, "type"), (GLsizei, "bufSize"), Out(OpaqueBlob(GLvoid, "bufSize"), "values")]),
    GlFunction(Void, "glGetnTexImageARB", [(GLenum, "target"), (GLint, "level"), (GLenum, "format"), (GLenum, "type"), (GLsizei, "bufSize"), Out(OpaqueBlob(GLvoid, "bufSize"), "img")]),
    GlFunction(Void, "glReadnPixelsARB", [(GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLenum, "type"), (GLsizei, "bufSize"), Out(OpaqueBlob(GLvoid, "bufSize"), "data")]),
    GlFunction(Void, "glGetnCompressedTexImageARB", [(GLenum, "target"), (GLint, "lod"), (GLsizei, "bufSize"), Out(OpaqueBlob(GLvoid, "bufSize"), "img")]),
    GlFunction(Void, "glGetnUniformfvARB", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "bufSize"), Out(Array(GLfloat, "bufSize"), "params")], sideeffects=False),
    GlFunction(Void, "glGetnUniformivARB", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "bufSize"), Out(Array(GLint, "bufSize"), "params")], sideeffects=False),
    GlFunction(Void, "glGetnUniformuivARB", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "bufSize"), Out(Array(GLuint, "bufSize"), "params")], sideeffects=False),
    GlFunction(Void, "glGetnUniformdvARB", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "bufSize"), Out(Array(GLdouble, "bufSize"), "params")], sideeffects=False),

    # GL_ARB_base_instance
    GlFunction(Void, "glDrawArraysInstancedBaseInstance", [(GLenum_mode, "mode"), (GLint, "first"), (GLsizei, "count"), (GLsizei, "primcount"), (GLuint, "baseinstance")]),
    GlFunction(Void, "glDrawElementsInstancedBaseInstance", [(GLenum_mode, "mode"), (GLsizei, "count"), (GLenum, "type"), (GLindexBuffer("count", "type"), "indices"), (GLsizei, "primcount"), (GLuint, "baseinstance")]),
    GlFunction(Void, "glDrawElementsInstancedBaseVertexBaseInstance", [(GLenum_mode, "mode"), (GLsizei, "count"), (GLenum, "type"), (GLindexBuffer("count", "type"), "indices"), (GLsizei, "primcount"), (GLint, "basevertex"), (GLuint, "baseinstance")]),

    # GL_ARB_transform_feedback_instanced
    GlFunction(Void, "glDrawTransformFeedbackInstanced", [(GLenum_mode, "mode"), (GLfeedback, "id"), (GLsizei, "primcount")]),
    GlFunction(Void, "glDrawTransformFeedbackStreamInstanced", [(GLenum_mode, "mode"), (GLfeedback, "id"), (GLuint, "stream"), (GLsizei, "primcount")]),

    # GL_ARB_internalformat_query
    GlFunction(Void, "glGetInternalformativ", [(GLenum, "target"), (GLenum, "internalformat"), (GLenum, "pname"), (GLsizei, "bufSize"), Out(Array(GLint, "bufSize"), "params")], sideeffects=False),

    # GL_ARB_shader_atomic_counters
    GlFunction(Void, "glGetActiveAtomicCounterBufferiv", [(GLprogram, "program"), (GLuint, "bufferIndex"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_ARB_shader_image_load_store
    GlFunction(Void, "glBindImageTexture", [(GLuint, "unit"), (GLtexture, "texture"), (GLint, "level"), (GLboolean, "layered"), (GLint, "layer"), (GLenum, "access"), (GLenum, "format")]),
    GlFunction(Void, "glMemoryBarrier", [(GLbitfield_barrier, "barriers")]),

    # GL_ARB_texture_storage
    GlFunction(Void, "glTexStorage1D", [(GLenum, "target"), (GLsizei, "levels"), (GLenum, "internalformat"), (GLsizei, "width")]),
    GlFunction(Void, "glTexStorage2D", [(GLenum, "target"), (GLsizei, "levels"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glTexStorage3D", [(GLenum, "target"), (GLsizei, "levels"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth")]),
    GlFunction(Void, "glTextureStorage1DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLsizei, "levels"), (GLenum, "internalformat"), (GLsizei, "width")]),
    GlFunction(Void, "glTextureStorage2DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLsizei, "levels"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glTextureStorage3DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLsizei, "levels"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth")]),

    # GL_KHR_debug
    GlFunction(Void, "glDebugMessageControl", [(GLenum, "source"), (GLenum, "type"), (GLenum, "severity"), (GLsizei, "count"), (Array(Const(GLuint), "count"), "ids"), (GLboolean, "enabled")], sideeffects=True),
    GlFunction(Void, "glDebugMessageInsert", [(GLenum, "source"), (GLenum, "type"), (GLuint, "id"), (GLenum, "severity"), (GLsizei, "length"), InGlString(GLchar, "length", "buf")], sideeffects=True),
    GlFunction(Void, "glDebugMessageCallback", [(GLDEBUGPROC, "callback"), (OpaquePointer(Const(Void)), "userParam")], sideeffects=False),
    GlFunction(GLuint, "glGetDebugMessageLog", [(GLuint, "count"), (GLsizei, "bufsize"), Out(Array(GLenum, "count"), "sources"), Out(Array(GLenum, "count"), "types"), Out(Array(GLuint, "count"), "ids"), Out(Array(GLenum, "count"), "severities"), Out(Array(GLsizei, "count"), "lengths"), Out(String(GLchar, "_glGetDebugMessageLog_length(messageLog, lengths, _result)"), "messageLog")], sideeffects=False, fail=0),
    GlFunction(Void, "glPushDebugGroup", [(GLenum, "source"), (GLuint, "id"), (GLsizei, "length"), InGlString(GLchar, "length", "message")], sideeffects=True),
    GlFunction(Void, "glPopDebugGroup", [], sideeffects=True),
    GlFunction(Void, "glObjectLabel", [(GLenum, "identifier"), (GLuint, "name"), (GLsizei, "length"), InGlString(GLchar, "length", "label")], sideeffects=True),
    GlFunction(Void, "glGetObjectLabel", [(GLenum, "identifier"), (GLuint, "name"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), OutGlString(GLchar, "length", "label")], sideeffects=False),
    GlFunction(Void, "glObjectPtrLabel", [(OpaquePointer(Const(Void)), "ptr"), (GLsizei, "length"), InGlString(GLchar, "length", "label")], sideeffects=True),
    GlFunction(Void, "glGetObjectPtrLabel", [(OpaquePointer(Const(Void)), "ptr"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), OutGlString(GLchar, "length", "label")], sideeffects=False),

    # GL_ARB_clear_buffer_object
    GlFunction(Void, "glClearBufferData", [(GLenum, "target"), (GLenum, "internalformat"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(Void), "_glClearBufferData_size(format, type)"), "data")]),
    GlFunction(Void, "glClearBufferSubData", [(GLenum, "target"), (GLenum, "internalformat"), (GLintptr, "offset"), (GLsizeiptr, "size"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(Void), "_glClearBufferData_size(format, type)"), "data")]),
    GlFunction(Void, "glClearNamedBufferDataEXT", [(GLbuffer, "buffer"), (GLenum, "internalformat"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(Void), "_glClearBufferData_size(format, type)"), "data")]),
    GlFunction(Void, "glClearNamedBufferSubDataEXT", [(GLbuffer, "buffer"), (GLenum, "internalformat"), (GLsizeiptr, "offset"), (GLsizeiptr, "size"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(Void), "_glClearBufferData_size(format, type)"), "data")]),

    # GL_ARB_compute_shader
    GlFunction(Void, "glDispatchCompute", [(GLuint, "num_groups_x"), (GLuint, "num_groups_y"), (GLuint, "num_groups_z")]),
    GlFunction(Void, "glDispatchComputeIndirect", [(GLintptr, "indirect")]),

    # GL_ARB_copy_image
    GlFunction(Void, "glCopyImageSubData", [(GLname("srcTarget"), "srcName"), (GLenum, "srcTarget"), (GLint, "srcLevel"), (GLint, "srcX"), (GLint, "srcY"), (GLint, "srcZ"), (GLname("dstTarget"), "dstName"), (GLenum, "dstTarget"), (GLint, "dstLevel"), (GLint, "dstX"), (GLint, "dstY"), (GLint, "dstZ"), (GLsizei, "srcWidth"), (GLsizei, "srcHeight"), (GLsizei, "srcDepth")]),

    # GL_ARB_texture_view
    GlFunction(Void, "glTextureView", [(GLtexture, "texture"), (GLenum, "target"), (GLtexture, "origtexture"), (GLenum, "internalformat"), (GLuint, "minlevel"), (GLuint, "numlevels"), (GLuint, "minlayer"), (GLuint, "numlayers")]),

    # GL_ARB_vertex_attrib_binding
    GlFunction(Void, "glBindVertexBuffer", [(GLuint, "bindingindex"), (GLbuffer, "buffer"), (GLintptr, "offset"), (GLsizei, "stride")]),
    GlFunction(Void, "glVertexAttribFormat", [(GLuint, "attribindex"), (GLint, "size"), (GLenum, "type"), (GLboolean, "normalized"), (GLuint, "relativeoffset")]),
    GlFunction(Void, "glVertexAttribIFormat", [(GLuint, "attribindex"), (GLint, "size"), (GLenum, "type"), (GLuint, "relativeoffset")]),
    GlFunction(Void, "glVertexAttribLFormat", [(GLuint, "attribindex"), (GLint, "size"), (GLenum, "type"), (GLuint, "relativeoffset")]),
    GlFunction(Void, "glVertexAttribBinding", [(GLuint, "attribindex"), (GLuint, "bindingindex")]),
    GlFunction(Void, "glVertexBindingDivisor", [(GLuint, "bindingindex"), (GLuint, "divisor")]),
    GlFunction(Void, "glVertexArrayBindVertexBufferEXT", [(GLarray, "vaobj"), (GLuint, "bindingindex"), (GLbuffer, "buffer"), (GLintptr, "offset"), (GLsizei, "stride")]),
    GlFunction(Void, "glVertexArrayVertexAttribFormatEXT", [(GLarray, "vaobj"), (GLuint, "attribindex"), (GLint, "size"), (GLenum, "type"), (GLboolean, "normalized"), (GLuint, "relativeoffset")]),
    GlFunction(Void, "glVertexArrayVertexAttribIFormatEXT", [(GLarray, "vaobj"), (GLuint, "attribindex"), (GLint, "size"), (GLenum, "type"), (GLuint, "relativeoffset")]),
    GlFunction(Void, "glVertexArrayVertexAttribLFormatEXT", [(GLarray, "vaobj"), (GLuint, "attribindex"), (GLint, "size"), (GLenum, "type"), (GLuint, "relativeoffset")]),
    GlFunction(Void, "glVertexArrayVertexAttribBindingEXT", [(GLarray, "vaobj"), (GLuint, "attribindex"), (GLuint, "bindingindex")]),
    GlFunction(Void, "glVertexArrayVertexBindingDivisorEXT", [(GLarray, "vaobj"), (GLuint, "bindingindex"), (GLuint, "divisor")]),

    # GL_ARB_framebuffer_no_attachments
    GlFunction(Void, "glFramebufferParameteri", [(GLenum, "target"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glGetFramebufferParameteriv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glNamedFramebufferParameteriEXT", [(GLframebuffer, "framebuffer"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glGetNamedFramebufferParameterivEXT", [(GLframebuffer, "framebuffer"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_ARB_internalformat_query2
    GlFunction(Void, "glGetInternalformati64v", [(GLenum, "target"), (GLenum, "internalformat"), (GLenum, "pname"), (GLsizei, "bufSize"), Out(Array(GLint64, "bufSize"), "params")], sideeffects=False),

    # GL_ARB_invalidate_subdata
    GlFunction(Void, "glInvalidateTexSubImage", [(GLtexture, "texture"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth")]),
    GlFunction(Void, "glInvalidateTexImage", [(GLtexture, "texture"), (GLint, "level")]),
    GlFunction(Void, "glInvalidateBufferSubData", [(GLbuffer, "buffer"), (GLintptr, "offset"), (GLsizeiptr, "length")]),
    GlFunction(Void, "glInvalidateBufferData", [(GLbuffer, "buffer")]),
    GlFunction(Void, "glInvalidateFramebuffer", [(GLenum, "target"), (GLsizei, "numAttachments"), (Array(Const(GLenum), "numAttachments"), "attachments")]),
    GlFunction(Void, "glInvalidateSubFramebuffer", [(GLenum, "target"), (GLsizei, "numAttachments"), (Array(Const(GLenum), "numAttachments"), "attachments"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),

    # GL_ARB_multi_draw_indirect
    GlFunction(Void, "glMultiDrawArraysIndirect", [(GLenum, "mode"), (OpaqueArray(Const(Void), "_glMultiDrawArraysIndirect_size(drawcount, stride)"), "indirect"), (GLsizei, "drawcount"), (GLsizei, "stride")]),
    GlFunction(Void, "glMultiDrawElementsIndirect", [(GLenum, "mode"), (GLenum, "type"), (OpaqueArray(Const(Void), "_glMultiDrawElementsIndirect_size(drawcount, stride)"), "indirect"), (GLsizei, "drawcount"), (GLsizei, "stride")]),

    # GL_ARB_program_interface_query
    GlFunction(Void, "glGetProgramInterfaceiv", [(GLprogram, "program"), (GLenum, "programInterface"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(GLuint, "glGetProgramResourceIndex", [(GLprogram, "program"), (GLenum, "programInterface"), (OpaqueArray(Const(GLchar), "_glGetProgramResourceIndex_size(name)"), "name")], sideeffects=False),
    GlFunction(Void, "glGetProgramResourceName", [(GLprogram, "program"), (GLenum, "programInterface"), (GLuint, "index"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), OutGlString(GLchar, "length", "name")], sideeffects=False),
    GlFunction(Void, "glGetProgramResourceiv", [(GLprogram, "program"), (GLenum, "programInterface"), (GLuint, "index"), (GLsizei, "propCount"), (Array(Const(GLenum), "propCount"), "props"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), Out(Array(GLint, "bufSize"), "params")], sideeffects=False),
    GlFunction(GLlocation, "glGetProgramResourceLocation", [(GLprogram, "program"), (GLenum, "programInterface"), (GLstringConst, "name")], sideeffects=False),
    GlFunction(GLlocation, "glGetProgramResourceLocationIndex", [(GLprogram, "program"), (GLenum, "programInterface"), (GLstringConst, "name")], sideeffects=False),

    # GL_ARB_shader_storage_buffer_object
    GlFunction(Void, "glShaderStorageBlockBinding", [(GLprogram, "program"), (GLuint, "storageBlockIndex"), (GLuint, "storageBlockBinding")]),

    # GL_ARB_texture_buffer_range
    GlFunction(Void, "glTexBufferRange", [(GLenum, "target"), (GLenum, "internalformat"), (GLbuffer, "buffer"), (GLintptr, "offset"), (GLsizeiptr, "size")]),
    GlFunction(Void, "glTextureBufferRangeEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLenum, "internalformat"), (GLbuffer, "buffer"), (GLintptr, "offset"), (GLsizeiptr, "size")]),

    # GL_ARB_texture_storage_multisample
    GlFunction(Void, "glTexStorage2DMultisample", [(GLenum, "target"), (GLsizei, "samples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLboolean, "fixedsamplelocations")]),
    GlFunction(Void, "glTexStorage3DMultisample", [(GLenum, "target"), (GLsizei, "samples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLboolean, "fixedsamplelocations")]),
    GlFunction(Void, "glTextureStorage2DMultisampleEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLsizei, "samples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLboolean, "fixedsamplelocations")]),
    GlFunction(Void, "glTextureStorage3DMultisampleEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLsizei, "samples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLboolean, "fixedsamplelocations")]),

    # GL_ARB_multi_bind
    GlFunction(Void, "glBindBuffersBase", [(GLenum, "target"), (GLuint, "first"), (GLsizei, "count"), (Array(Const(GLbuffer), "count"), "buffers")]),
    GlFunction(Void, "glBindBuffersRange", [(GLenum, "target"), (GLuint, "first"), (GLsizei, "count"), (Array(Const(GLbuffer), "count"), "buffers"), (Array(Const(GLintptr), "count"), "offsets"), (Array(Const(GLsizeiptr), "count"), "sizes")]),

    GlFunction(Void, "glBindImageTextures", [ (GLuint, "first"), (GLsizei, "count"), (Array(Const(GLtexture), "count"), "textures")]),
    GlFunction(Void, "glBindSamplers", [ (GLuint, "first"), (GLsizei, "count"), (Array(Const(GLsampler), "count"), "samplers")]),
    GlFunction(Void, "glBindTextures", [ (GLuint, "first"), (GLsizei, "count"), (Array(Const(GLtexture), "count"), "textures")]),
    GlFunction(Void, "glBindVertexBuffers", [ (GLuint, "first"), (GLsizei, "count"), (Array(Const(GLbuffer), "count"), "buffers"), (Array(Const(GLintptr), "count"), "offsets"), (Array(Const(GLsizei), "count"), "strides")]),

    # GL_ARB_buffer_storage
    GlFunction(Void, "glBufferStorage", [ (GLenum, "target"), (GLsizeiptr, "size"), (Blob(Const(GLvoid), "size"), "data"), (GLbitfield_storage, "flags")]),
    GlFunction(Void, "glNamedBufferStorageEXT", [ (GLbuffer, "buffer"), (GLsizeiptr, "size"), (Blob(Const(GLvoid), "size"), "data"), (GLbitfield_storage, "flags")]),

    # GL_ARB_clear_texture
    GlFunction(Void, "glClearTexImage", [ (GLtexture, "texture"), (GLint, "level"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glClearBufferData_size(format, type)"), "data")]),
    GlFunction(Void, "glClearTexSubImage", [ (GLtexture, "texture"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glClearBufferData_size(format, type)"), "data")]),

    # GL_EXT_blend_color
    GlFunction(Void, "glBlendColorEXT", [(GLfloat, "red"), (GLfloat, "green"), (GLfloat, "blue"), (GLfloat, "alpha")]),

    # GL_EXT_polygon_offset
    GlFunction(Void, "glPolygonOffsetEXT", [(GLfloat, "factor"), (GLfloat, "bias")]),

    # GL_EXT_texture3D
    GlFunction(Void, "glTexImage3DEXT", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLint, "border"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTexImage3D_size(format, type, width, height, depth)"), "pixels")]),
    GlFunction(Void, "glTexSubImage3DEXT", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTexSubImage3D_size(format, type, width, height, depth)"), "pixels")]),

    # GL_SGIS_texture_filter4
    GlFunction(Void, "glGetTexFilterFuncSGIS", [(GLenum, "target"), (GLenum, "filter"), Out(OpaqueArray(GLfloat, "_glGetTexFilterFuncSGIS_size(target, filter)"), "weights")], sideeffects=False),
    GlFunction(Void, "glTexFilterFuncSGIS", [(GLenum, "target"), (GLenum, "filter"), (GLsizei, "n"), (Array(Const(GLfloat), "n"), "weights")]),

    # GL_EXT_subtexture
    GlFunction(Void, "glTexSubImage1DEXT", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLsizei, "width"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTexSubImage1D_size(format, type, width)"), "pixels")]),
    GlFunction(Void, "glTexSubImage2DEXT", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTexSubImage2D_size(format, type, width, height)"), "pixels")]),

    # GL_EXT_copy_texture
    GlFunction(Void, "glCopyTexImage1DEXT", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLint, "border")]),
    GlFunction(Void, "glCopyTexImage2DEXT", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height"), (GLint, "border")]),
    GlFunction(Void, "glCopyTexSubImage1DEXT", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "x"), (GLint, "y"), (GLsizei, "width")]),
    GlFunction(Void, "glCopyTexSubImage2DEXT", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glCopyTexSubImage3DEXT", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),

    # GL_EXT_histogram
    GlFunction(Void, "glGetHistogramEXT", [(GLenum, "target"), (GLboolean, "reset"), (GLenum, "format"), (GLenum, "type"), Out(OpaqueBlob(GLvoid, "_glGetHistogramEXT_size(target, format, type)"), "values")], sideeffects=False),
    GlFunction(Void, "glGetHistogramParameterfvEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetHistogramParameterivEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMinmaxEXT", [(GLenum, "target"), (GLboolean, "reset"), (GLenum, "format"), (GLenum, "type"), Out(OpaqueBlob(GLvoid, "_glGetMinmaxEXT_size(target, format, type)"), "values")], sideeffects=False),
    GlFunction(Void, "glGetMinmaxParameterfvEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMinmaxParameterivEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glHistogramEXT", [(GLenum, "target"), (GLsizei, "width"), (GLenum, "internalformat"), (GLboolean, "sink")]),
    GlFunction(Void, "glMinmaxEXT", [(GLenum, "target"), (GLenum, "internalformat"), (GLboolean, "sink")]),
    GlFunction(Void, "glResetHistogramEXT", [(GLenum, "target")]),
    GlFunction(Void, "glResetMinmaxEXT", [(GLenum, "target")]),

    # GL_EXT_convolution
    GlFunction(Void, "glConvolutionFilter1DEXT", [(GLenum, "target"), (GLenum, "internalformat"), (GLsizei, "width"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glConvolutionFilter1D_size(format, type, width)"), "image")]),
    GlFunction(Void, "glConvolutionFilter2DEXT", [(GLenum, "target"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glConvolutionFilter2D_size(format, type, width, height)"), "image")]),
    GlFunction(Void, "glConvolutionParameterfEXT", [(GLenum, "target"), (GLenum, "pname"), (GLfloat, "params")]),
    GlFunction(Void, "glConvolutionParameterfvEXT", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glConvolutionParameteriEXT", [(GLenum, "target"), (GLenum, "pname"), (GLint, "params")]),
    GlFunction(Void, "glConvolutionParameterivEXT", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glCopyConvolutionFilter1DEXT", [(GLenum, "target"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width")]),
    GlFunction(Void, "glCopyConvolutionFilter2DEXT", [(GLenum, "target"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glGetConvolutionFilterEXT", [(GLenum, "target"), (GLenum, "format"), (GLenum, "type"), Out(OpaqueBlob(GLvoid, "_glGetConvolutionFilterEXT_size(target, format, type)"), "image")], sideeffects=False),
    GlFunction(Void, "glGetConvolutionParameterfvEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetConvolutionParameterivEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetSeparableFilterEXT", [(GLenum, "target"), (GLenum, "format"), (GLenum, "type"), Out(OpaqueBlob(GLvoid, "_glGetSeparableFilterEXT_size(target, format, type)"), "row"), Out(OpaqueBlob(GLvoid, "_glGetSeparableFilterEXT_size(target, format, type)"), "column"), Out(OpaqueBlob(GLvoid, "_glGetSeparableFilterEXT_size(target, format, type)"), "span")], sideeffects=False),
    GlFunction(Void, "glSeparableFilter2DEXT", [(GLenum, "target"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glConvolutionFilter1D_size(format, type, width)"), "row"), (Blob(Const(GLvoid), "_glConvolutionFilter1D_size(format, type, height)"), "column")]),

    # GL_SGI_color_table
    GlFunction(Void, "glColorTableSGI", [(GLenum, "target"), (GLenum, "internalformat"), (GLsizei, "width"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glColorTable_size(format, type, width)"), "table")]),
    GlFunction(Void, "glColorTableParameterfvSGI", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glColorTableParameterivSGI", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glCopyColorTableSGI", [(GLenum, "target"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width")]),
    GlFunction(Void, "glGetColorTableSGI", [(GLenum, "target"), (GLenum, "format"), (GLenum, "type"), Out(OpaqueBlob(GLvoid, "_glGetColorTableSGI_size(target, format, type)"), "table")], sideeffects=False),
    GlFunction(Void, "glGetColorTableParameterfvSGI", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetColorTableParameterivSGI", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_SGIX_pixel_texture
    GlFunction(Void, "glPixelTexGenSGIX", [(GLenum, "mode")]),

    # GL_SGIS_pixel_texture
    GlFunction(Void, "glPixelTexGenParameteriSGIS", [(GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glPixelTexGenParameterivSGIS", [(GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glPixelTexGenParameterfSGIS", [(GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glPixelTexGenParameterfvSGIS", [(GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glGetPixelTexGenParameterivSGIS", [(GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetPixelTexGenParameterfvSGIS", [(GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_SGIS_texture4D
    GlFunction(Void, "glTexImage4DSGIS", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLsizei, "size4d"), (GLint, "border"), (GLenum, "format"), (GLenum, "type"), (OpaqueBlob(Const(GLvoid), "_glTexImage4DSGIS_size(format, type, width, height, depth, size4d)"), "pixels")]),
    GlFunction(Void, "glTexSubImage4DSGIS", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLint, "woffset"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLsizei, "size4d"), (GLenum, "format"), (GLenum, "type"), (OpaqueBlob(Const(GLvoid), "_glTexSubImage4DSGIS_size(format, type, width, height, depth, size4d)"), "pixels")]),

    # GL_EXT_texture_object
    GlFunction(GLboolean, "glAreTexturesResidentEXT", [(GLsizei, "n"), (Array(Const(GLtexture), "n"), "textures"), Out(Array(GLboolean, "n"), "residences")], sideeffects=False),
    GlFunction(Void, "glBindTextureEXT", [(GLenum, "target"), (GLtexture, "texture")]),
    GlFunction(Void, "glDeleteTexturesEXT", [(GLsizei, "n"), (Array(Const(GLtexture), "n"), "textures")]),
    GlFunction(Void, "glGenTexturesEXT", [(GLsizei, "n"), Out(Array(GLtexture, "n"), "textures")]),
    GlFunction(GLboolean, "glIsTextureEXT", [(GLtexture, "texture")], sideeffects=False),
    GlFunction(Void, "glPrioritizeTexturesEXT", [(GLsizei, "n"), (Array(Const(GLtexture), "n"), "textures"), (Array(Const(GLclampf), "n"), "priorities")]),

    # GL_SGIS_detail_texture
    GlFunction(Void, "glDetailTexFuncSGIS", [(GLenum, "target"), (GLsizei, "n"), (Array(Const(GLfloat), "n*2"), "points")]),
    GlFunction(Void, "glGetDetailTexFuncSGIS", [(GLenum, "target"), Out(OpaqueArray(GLfloat, "_glGetDetailTexFuncSGIS_size(target)"), "points")], sideeffects=False),

    # GL_SGIS_sharpen_texture
    GlFunction(Void, "glSharpenTexFuncSGIS", [(GLenum, "target"), (GLsizei, "n"), (Array(Const(GLfloat), "n*2"), "points")]),
    GlFunction(Void, "glGetSharpenTexFuncSGIS", [(GLenum, "target"), Out(OpaqueArray(GLfloat, "_glGetSharpenTexFuncSGIS_size(target)"), "points")], sideeffects=False),

    # GL_SGIS_multisample
    GlFunction(Void, "glSampleMaskSGIS", [(GLclampf, "value"), (GLboolean, "invert")]),
    GlFunction(Void, "glSamplePatternSGIS", [(GLenum, "pattern")]),

    # GL_EXT_vertex_array
    GlFunction(Void, "glArrayElementEXT", [(GLint, "i")]),
    GlFunction(Void, "glColorPointerEXT", [(size_bgra, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLsizei, "count"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glDrawArraysEXT", [(GLenum_mode, "mode"), (GLint, "first"), (GLsizei, "count")]),
    GlFunction(Void, "glEdgeFlagPointerEXT", [(GLsizei, "stride"), (GLsizei, "count"), (OpaquePointer(Const(GLboolean)), "pointer")]),
    GlFunction(Void, "glGetPointervEXT", [(GLenum, "pname"), Out(Pointer(GLpointer), "params")], sideeffects=False),
    GlFunction(Void, "glIndexPointerEXT", [(GLenum, "type"), (GLsizei, "stride"), (GLsizei, "count"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glNormalPointerEXT", [(GLenum, "type"), (GLsizei, "stride"), (GLsizei, "count"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glTexCoordPointerEXT", [(GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLsizei, "count"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glVertexPointerEXT", [(GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLsizei, "count"), (GLpointerConst, "pointer")]),

    # GL_EXT_blend_minmax
    GlFunction(Void, "glBlendEquationEXT", [(GLenum, "mode")]),

    # GL_SGIX_sprite
    GlFunction(Void, "glSpriteParameterfSGIX", [(GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glSpriteParameterfvSGIX", [(GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glSpriteParameteriSGIX", [(GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glSpriteParameterivSGIX", [(GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),

    # GL_EXT_point_parameters
    GlFunction(Void, "glPointParameterfEXT", [(GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glPointParameterfvEXT", [(GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),

    # GL_SGIS_point_parameters
    GlFunction(Void, "glPointParameterfSGIS", [(GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glPointParameterfvSGIS", [(GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),

    # GL_SGIX_instruments
    GlFunction(GLint, "glGetInstrumentsSGIX", [], sideeffects=False),
    GlFunction(Void, "glInstrumentsBufferSGIX", [(GLsizei, "size"), (OpaqueArray(GLint, "size"), "buffer")]),
    GlFunction(GLint, "glPollInstrumentsSGIX", [Out(Pointer(GLint), "marker_p")]),
    GlFunction(Void, "glReadInstrumentsSGIX", [(GLint, "marker")]),
    GlFunction(Void, "glStartInstrumentsSGIX", []),
    GlFunction(Void, "glStopInstrumentsSGIX", [(GLint, "marker")]),

    # GL_SGIX_framezoom
    GlFunction(Void, "glFrameZoomSGIX", [(GLint, "factor")]),

    # GL_SGIX_tag_sample_buffer
    GlFunction(Void, "glTagSampleBufferSGIX", []),

    # GL_SGIX_polynomial_ffd
    GlFunction(Void, "glDeformationMap3dSGIX", [(GLenum, "target"), (GLdouble, "u1"), (GLdouble, "u2"), (GLint, "ustride"), (GLint, "uorder"), (GLdouble, "v1"), (GLdouble, "v2"), (GLint, "vstride"), (GLint, "vorder"), (GLdouble, "w1"), (GLdouble, "w2"), (GLint, "wstride"), (GLint, "worder"), (OpaqueArray(Const(GLdouble), "_glDeformationMap3dSGIX_size(target, ustride, uorder, vstride, vorder, wstride, worder)"), "points")]),
    GlFunction(Void, "glDeformationMap3fSGIX", [(GLenum, "target"), (GLfloat, "u1"), (GLfloat, "u2"), (GLint, "ustride"), (GLint, "uorder"), (GLfloat, "v1"), (GLfloat, "v2"), (GLint, "vstride"), (GLint, "vorder"), (GLfloat, "w1"), (GLfloat, "w2"), (GLint, "wstride"), (GLint, "worder"), (OpaqueArray(Const(GLfloat), "_glDeformationMap3fSGIX_size(target, ustride, uorder, vstride, vorder, wstride, worder)"), "points")]),
    GlFunction(Void, "glDeformSGIX", [(GLbitfield, "mask")]),
    GlFunction(Void, "glLoadIdentityDeformationMapSGIX", [(GLbitfield, "mask")]),

    # GL_SGIX_reference_plane
    GlFunction(Void, "glReferencePlaneSGIX", [(Array(Const(GLdouble), 4), "equation")]),

    # GL_SGIX_flush_raster
    GlFunction(Void, "glFlushRasterSGIX", []),

    # GL_SGIS_fog_function
    GlFunction(Void, "glFogFuncSGIS", [(GLsizei, "n"), (Array(Const(GLfloat), "n*2"), "points")]),
    GlFunction(Void, "glGetFogFuncSGIS", [Out(OpaqueArray(GLfloat, "_glGetFogFuncSGIS_size()"), "points")], sideeffects=False),

    # GL_HP_image_transform
    GlFunction(Void, "glImageTransformParameteriHP", [(GLenum, "target"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glImageTransformParameterfHP", [(GLenum, "target"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glImageTransformParameterivHP", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glImageTransformParameterfvHP", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glGetImageTransformParameterivHP", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetImageTransformParameterfvHP", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_EXT_color_subtable
    GlFunction(Void, "glColorSubTableEXT", [(GLenum, "target"), (GLsizei, "start"), (GLsizei, "count"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glColorSubTable_size(format, type, count)"), "data")]),
    GlFunction(Void, "glCopyColorSubTableEXT", [(GLenum, "target"), (GLsizei, "start"), (GLint, "x"), (GLint, "y"), (GLsizei, "width")]),

    # GL_PGI_misc_hints
    GlFunction(Void, "glHintPGI", [(GLenum, "target"), (GLint, "mode")]),

    # GL_EXT_paletted_texture
    GlFunction(Void, "glColorTableEXT", [(GLenum, "target"), (GLenum, "internalformat"), (GLsizei, "width"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glColorTable_size(format, type, width)"), "table")]),
    GlFunction(Void, "glGetColorTableEXT", [(GLenum, "target"), (GLenum, "format"), (GLenum, "type"), Out(OpaqueBlob(GLvoid, "_glGetColorTableEXT_size(target, format, type)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetColorTableParameterivEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetColorTableParameterfvEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_SGIX_list_priority
    GlFunction(Void, "glGetListParameterfvSGIX", [(GLlist, "list"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetListParameterivSGIX", [(GLlist, "list"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glListParameterfSGIX", [(GLlist, "list"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glListParameterfvSGIX", [(GLlist, "list"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glListParameteriSGIX", [(GLlist, "list"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glListParameterivSGIX", [(GLlist, "list"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),

    # GL_EXT_index_material
    GlFunction(Void, "glIndexMaterialEXT", [(GLenum, "face"), (GLenum, "mode")]),

    # GL_EXT_index_func
    GlFunction(Void, "glIndexFuncEXT", [(GLenum, "func"), (GLclampf, "ref")]),

    # GL_EXT_compiled_vertex_array
    GlFunction(Void, "glLockArraysEXT", [(GLint, "first"), (GLsizei, "count")]),
    GlFunction(Void, "glUnlockArraysEXT", []),

    # GL_EXT_cull_vertex
    GlFunction(Void, "glCullParameterdvEXT", [(GLenum, "pname"), (Array(GLdouble, 4), "params")]),
    GlFunction(Void, "glCullParameterfvEXT", [(GLenum, "pname"), (Array(GLfloat, 4), "params")]),

    # GL_SGIX_fragment_lighting
    GlFunction(Void, "glFragmentColorMaterialSGIX", [(GLenum, "face"), (GLenum, "mode")]),
    GlFunction(Void, "glFragmentLightfSGIX", [(GLenum, "light"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glFragmentLightfvSGIX", [(GLenum, "light"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glFragmentLightiSGIX", [(GLenum, "light"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glFragmentLightivSGIX", [(GLenum, "light"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glFragmentLightModelfSGIX", [(GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glFragmentLightModelfvSGIX", [(GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glFragmentLightModeliSGIX", [(GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glFragmentLightModelivSGIX", [(GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glFragmentMaterialfSGIX", [(GLenum, "face"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glFragmentMaterialfvSGIX", [(GLenum, "face"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glFragmentMaterialiSGIX", [(GLenum, "face"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glFragmentMaterialivSGIX", [(GLenum, "face"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glGetFragmentLightfvSGIX", [(GLenum, "light"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetFragmentLightivSGIX", [(GLenum, "light"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetFragmentMaterialfvSGIX", [(GLenum, "face"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetFragmentMaterialivSGIX", [(GLenum, "face"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glLightEnviSGIX", [(GLenum, "pname"), (GLint, "param")]),

    # GL_EXT_draw_range_elements
    GlFunction(Void, "glDrawRangeElementsEXT", [(GLenum_mode, "mode"), (GLuint, "start"), (GLuint, "end"), (GLsizei, "count"), (GLenum, "type"), (GLindexBuffer("count", "type"), "indices")]),

    # GL_EXT_light_texture
    GlFunction(Void, "glApplyTextureEXT", [(GLenum, "mode")]),
    GlFunction(Void, "glTextureLightEXT", [(GLenum, "pname")]),
    GlFunction(Void, "glTextureMaterialEXT", [(GLenum, "face"), (GLenum, "mode")]),

    # GL_SGIX_async
    GlFunction(Void, "glAsyncMarkerSGIX", [(GLuint, "marker")]),
    GlFunction(GLint, "glFinishAsyncSGIX", [Out(Pointer(GLuint), "markerp")]),
    GlFunction(GLint, "glPollAsyncSGIX", [Out(Pointer(GLuint), "markerp")]),
    GlFunction(GLuint, "glGenAsyncMarkersSGIX", [(GLsizei, "range")]),
    GlFunction(Void, "glDeleteAsyncMarkersSGIX", [(GLuint, "marker"), (GLsizei, "range")]),
    GlFunction(GLboolean, "glIsAsyncMarkerSGIX", [(GLuint, "marker")], sideeffects=False),

    # GL_INTEL_parallel_arrays
    GlFunction(Void, "glVertexPointervINTEL", [(GLint, "size"), (GLenum, "type"), (OpaqueArray(GLpointerConst, "size"), "pointer")]),
    GlFunction(Void, "glNormalPointervINTEL", [(GLenum, "type"), (OpaqueArray(GLpointerConst, "size"), "pointer")]),
    GlFunction(Void, "glColorPointervINTEL", [(size_bgra, "size"), (GLenum, "type"), (OpaqueArray(GLpointerConst, "size"), "pointer")]),
    GlFunction(Void, "glTexCoordPointervINTEL", [(GLint, "size"), (GLenum, "type"), (OpaqueArray(GLpointerConst, "size"), "pointer")]),

    # GL_EXT_pixel_transform
    GlFunction(Void, "glPixelTransformParameteriEXT", [(GLenum, "target"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glPixelTransformParameterfEXT", [(GLenum, "target"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glPixelTransformParameterivEXT", [(GLenum, "target"), (GLenum, "pname"), (Pointer(Const(GLint)), "params")]),
    GlFunction(Void, "glPixelTransformParameterfvEXT", [(GLenum, "target"), (GLenum, "pname"), (Pointer(Const(GLfloat)), "params")]),
    GlFunction(Void, "glGetPixelTransformParameterivEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetPixelTransformParameterfvEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_EXT_secondary_color
    GlFunction(Void, "glSecondaryColor3bEXT", [(GLbyte, "red"), (GLbyte, "green"), (GLbyte, "blue")]),
    GlFunction(Void, "glSecondaryColor3bvEXT", [(Array(Const(GLbyte), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3dEXT", [(GLdouble, "red"), (GLdouble, "green"), (GLdouble, "blue")]),
    GlFunction(Void, "glSecondaryColor3dvEXT", [(Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3fEXT", [(GLfloat, "red"), (GLfloat, "green"), (GLfloat, "blue")]),
    GlFunction(Void, "glSecondaryColor3fvEXT", [(Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3iEXT", [(GLint, "red"), (GLint, "green"), (GLint, "blue")]),
    GlFunction(Void, "glSecondaryColor3ivEXT", [(Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3sEXT", [(GLshort, "red"), (GLshort, "green"), (GLshort, "blue")]),
    GlFunction(Void, "glSecondaryColor3svEXT", [(Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3ubEXT", [(GLubyte, "red"), (GLubyte, "green"), (GLubyte, "blue")]),
    GlFunction(Void, "glSecondaryColor3ubvEXT", [(Array(Const(GLubyte), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3uiEXT", [(GLuint, "red"), (GLuint, "green"), (GLuint, "blue")]),
    GlFunction(Void, "glSecondaryColor3uivEXT", [(Array(Const(GLuint), 3), "v")]),
    GlFunction(Void, "glSecondaryColor3usEXT", [(GLushort, "red"), (GLushort, "green"), (GLushort, "blue")]),
    GlFunction(Void, "glSecondaryColor3usvEXT", [(Array(Const(GLushort), 3), "v")]),
    GlFunction(Void, "glSecondaryColorPointerEXT", [(size_bgra, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),

    # GL_EXT_texture_perturb_normal
    GlFunction(Void, "glTextureNormalEXT", [(GLenum, "mode")]),

    # GL_EXT_multi_draw_arrays
    GlFunction(Void, "glMultiDrawArraysEXT", [(GLenum_mode, "mode"), (Array(Const(GLint), "primcount"), "first"), (Array(Const(GLsizei), "primcount"), "count"), (GLsizei, "primcount")]),
    GlFunction(Void, "glMultiDrawElementsEXT", [(GLenum_mode, "mode"), (Array(Const(GLsizei), "primcount"), "count"), (GLenum, "type"), (Array(Const(GLindexBuffer("count[{i}]", "type")), "primcount"), "indices"), (GLsizei, "primcount")]),

    # GL_EXT_fog_coord
    GlFunction(Void, "glFogCoordfEXT", [(GLfloat, "coord")]),
    GlFunction(Void, "glFogCoordfvEXT", [(Pointer(Const(GLfloat)), "coord")]),
    GlFunction(Void, "glFogCoorddEXT", [(GLdouble, "coord")]),
    GlFunction(Void, "glFogCoorddvEXT", [(Pointer(Const(GLdouble)), "coord")]),
    GlFunction(Void, "glFogCoordPointerEXT", [(GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),

    # GL_EXT_coordinate_frame
    GlFunction(Void, "glTangent3bEXT", [(GLbyte, "tx"), (GLbyte, "ty"), (GLbyte, "tz")]),
    GlFunction(Void, "glTangent3bvEXT", [(Array(Const(GLbyte), 3), "v")]),
    GlFunction(Void, "glTangent3dEXT", [(GLdouble, "tx"), (GLdouble, "ty"), (GLdouble, "tz")]),
    GlFunction(Void, "glTangent3dvEXT", [(Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glTangent3fEXT", [(GLfloat, "tx"), (GLfloat, "ty"), (GLfloat, "tz")]),
    GlFunction(Void, "glTangent3fvEXT", [(Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glTangent3iEXT", [(GLint, "tx"), (GLint, "ty"), (GLint, "tz")]),
    GlFunction(Void, "glTangent3ivEXT", [(Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glTangent3sEXT", [(GLshort, "tx"), (GLshort, "ty"), (GLshort, "tz")]),
    GlFunction(Void, "glTangent3svEXT", [(Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glBinormal3bEXT", [(GLbyte, "bx"), (GLbyte, "by"), (GLbyte, "bz")]),
    GlFunction(Void, "glBinormal3bvEXT", [(Array(Const(GLbyte), 3), "v")]),
    GlFunction(Void, "glBinormal3dEXT", [(GLdouble, "bx"), (GLdouble, "by"), (GLdouble, "bz")]),
    GlFunction(Void, "glBinormal3dvEXT", [(Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glBinormal3fEXT", [(GLfloat, "bx"), (GLfloat, "by"), (GLfloat, "bz")]),
    GlFunction(Void, "glBinormal3fvEXT", [(Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glBinormal3iEXT", [(GLint, "bx"), (GLint, "by"), (GLint, "bz")]),
    GlFunction(Void, "glBinormal3ivEXT", [(Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glBinormal3sEXT", [(GLshort, "bx"), (GLshort, "by"), (GLshort, "bz")]),
    GlFunction(Void, "glBinormal3svEXT", [(Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glTangentPointerEXT", [(GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glBinormalPointerEXT", [(GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),

    # GL_SUNX_constant_data
    GlFunction(Void, "glFinishTextureSUNX", []),

    # GL_SUN_global_alpha
    GlFunction(Void, "glGlobalAlphaFactorbSUN", [(GLbyte, "factor")]),
    GlFunction(Void, "glGlobalAlphaFactorsSUN", [(GLshort, "factor")]),
    GlFunction(Void, "glGlobalAlphaFactoriSUN", [(GLint, "factor")]),
    GlFunction(Void, "glGlobalAlphaFactorfSUN", [(GLfloat, "factor")]),
    GlFunction(Void, "glGlobalAlphaFactordSUN", [(GLdouble, "factor")]),
    GlFunction(Void, "glGlobalAlphaFactorubSUN", [(GLubyte, "factor")]),
    GlFunction(Void, "glGlobalAlphaFactorusSUN", [(GLushort, "factor")]),
    GlFunction(Void, "glGlobalAlphaFactoruiSUN", [(GLuint, "factor")]),

    # GL_SUN_triangle_list
    GlFunction(Void, "glReplacementCodeuiSUN", [(GLuint, "code")]),
    GlFunction(Void, "glReplacementCodeusSUN", [(GLushort, "code")]),
    GlFunction(Void, "glReplacementCodeubSUN", [(GLubyte, "code")]),
    GlFunction(Void, "glReplacementCodeuivSUN", [(OpaqueArray(Const(GLuint), "_glReplacementCodeuivSUN_size()"), "code")]),
    GlFunction(Void, "glReplacementCodeusvSUN", [(OpaqueArray(Const(GLushort), "_glReplacementCodeusvSUN_size()"), "code")]),
    GlFunction(Void, "glReplacementCodeubvSUN", [(OpaqueArray(Const(GLubyte), "_glReplacementCodeubvSUN_size()"), "code")]),
    GlFunction(Void, "glReplacementCodePointerSUN", [(GLenum, "type"), (GLsizei, "stride"), (OpaquePointer(GLpointerConst), "pointer")]),

    # GL_SUN_vertex
    GlFunction(Void, "glColor4ubVertex2fSUN", [(GLubyte, "r"), (GLubyte, "g"), (GLubyte, "b"), (GLubyte, "a"), (GLfloat, "x"), (GLfloat, "y")]),
    GlFunction(Void, "glColor4ubVertex2fvSUN", [(Array(Const(GLubyte), 4), "c"), (Array(Const(GLfloat), 2), "v")]),
    GlFunction(Void, "glColor4ubVertex3fSUN", [(GLubyte, "r"), (GLubyte, "g"), (GLubyte, "b"), (GLubyte, "a"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glColor4ubVertex3fvSUN", [(Array(Const(GLubyte), 4), "c"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glColor3fVertex3fSUN", [(GLfloat, "r"), (GLfloat, "g"), (GLfloat, "b"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glColor3fVertex3fvSUN", [(Array(Const(GLfloat), 3), "c"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glNormal3fVertex3fSUN", [(GLfloat, "nx"), (GLfloat, "ny"), (GLfloat, "nz"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glNormal3fVertex3fvSUN", [(Array(Const(GLfloat), 3), "n"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glColor4fNormal3fVertex3fSUN", [(GLfloat, "r"), (GLfloat, "g"), (GLfloat, "b"), (GLfloat, "a"), (GLfloat, "nx"), (GLfloat, "ny"), (GLfloat, "nz"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glColor4fNormal3fVertex3fvSUN", [(Array(Const(GLfloat), 4), "c"), (Array(Const(GLfloat), 3), "n"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glTexCoord2fVertex3fSUN", [(GLfloat, "s"), (GLfloat, "t"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glTexCoord2fVertex3fvSUN", [(Array(Const(GLfloat), 2), "tc"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glTexCoord4fVertex4fSUN", [(GLfloat, "s"), (GLfloat, "t"), (GLfloat, "p"), (GLfloat, "q"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glTexCoord4fVertex4fvSUN", [(Array(Const(GLfloat), 4), "tc"), (Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glTexCoord2fColor4ubVertex3fSUN", [(GLfloat, "s"), (GLfloat, "t"), (GLubyte, "r"), (GLubyte, "g"), (GLubyte, "b"), (GLubyte, "a"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glTexCoord2fColor4ubVertex3fvSUN", [(Array(Const(GLfloat), 2), "tc"), (Array(Const(GLubyte), 4), "c"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glTexCoord2fColor3fVertex3fSUN", [(GLfloat, "s"), (GLfloat, "t"), (GLfloat, "r"), (GLfloat, "g"), (GLfloat, "b"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glTexCoord2fColor3fVertex3fvSUN", [(Array(Const(GLfloat), 2), "tc"), (Array(Const(GLfloat), 3), "c"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glTexCoord2fNormal3fVertex3fSUN", [(GLfloat, "s"), (GLfloat, "t"), (GLfloat, "nx"), (GLfloat, "ny"), (GLfloat, "nz"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glTexCoord2fNormal3fVertex3fvSUN", [(Array(Const(GLfloat), 2), "tc"), (Array(Const(GLfloat), 3), "n"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glTexCoord2fColor4fNormal3fVertex3fSUN", [(GLfloat, "s"), (GLfloat, "t"), (GLfloat, "r"), (GLfloat, "g"), (GLfloat, "b"), (GLfloat, "a"), (GLfloat, "nx"), (GLfloat, "ny"), (GLfloat, "nz"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glTexCoord2fColor4fNormal3fVertex3fvSUN", [(Array(Const(GLfloat), 2), "tc"), (Array(Const(GLfloat), 4), "c"), (Array(Const(GLfloat), 3), "n"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glTexCoord4fColor4fNormal3fVertex4fSUN", [(GLfloat, "s"), (GLfloat, "t"), (GLfloat, "p"), (GLfloat, "q"), (GLfloat, "r"), (GLfloat, "g"), (GLfloat, "b"), (GLfloat, "a"), (GLfloat, "nx"), (GLfloat, "ny"), (GLfloat, "nz"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glTexCoord4fColor4fNormal3fVertex4fvSUN", [(Array(Const(GLfloat), 4), "tc"), (Array(Const(GLfloat), 4), "c"), (Array(Const(GLfloat), 3), "n"), (Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glReplacementCodeuiVertex3fSUN", [(GLuint, "rc"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glReplacementCodeuiVertex3fvSUN", [(Pointer(Const(GLuint)), "rc"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glReplacementCodeuiColor4ubVertex3fSUN", [(GLuint, "rc"), (GLubyte, "r"), (GLubyte, "g"), (GLubyte, "b"), (GLubyte, "a"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glReplacementCodeuiColor4ubVertex3fvSUN", [(Pointer(Const(GLuint)), "rc"), (Array(Const(GLubyte), 4), "c"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glReplacementCodeuiColor3fVertex3fSUN", [(GLuint, "rc"), (GLfloat, "r"), (GLfloat, "g"), (GLfloat, "b"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glReplacementCodeuiColor3fVertex3fvSUN", [(Pointer(Const(GLuint)), "rc"), (Array(Const(GLfloat), 3), "c"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glReplacementCodeuiNormal3fVertex3fSUN", [(GLuint, "rc"), (GLfloat, "nx"), (GLfloat, "ny"), (GLfloat, "nz"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glReplacementCodeuiNormal3fVertex3fvSUN", [(Pointer(Const(GLuint)), "rc"), (Array(Const(GLfloat), 3), "n"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glReplacementCodeuiColor4fNormal3fVertex3fSUN", [(GLuint, "rc"), (GLfloat, "r"), (GLfloat, "g"), (GLfloat, "b"), (GLfloat, "a"), (GLfloat, "nx"), (GLfloat, "ny"), (GLfloat, "nz"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glReplacementCodeuiColor4fNormal3fVertex3fvSUN", [(Pointer(Const(GLuint)), "rc"), (Array(Const(GLfloat), 4), "c"), (Array(Const(GLfloat), 3), "n"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glReplacementCodeuiTexCoord2fVertex3fSUN", [(GLuint, "rc"), (GLfloat, "s"), (GLfloat, "t"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glReplacementCodeuiTexCoord2fVertex3fvSUN", [(Pointer(Const(GLuint)), "rc"), (Array(Const(GLfloat), 2), "tc"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN", [(GLuint, "rc"), (GLfloat, "s"), (GLfloat, "t"), (GLfloat, "nx"), (GLfloat, "ny"), (GLfloat, "nz"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN", [(Pointer(Const(GLuint)), "rc"), (Array(Const(GLfloat), 2), "tc"), (Array(Const(GLfloat), 3), "n"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN", [(GLuint, "rc"), (GLfloat, "s"), (GLfloat, "t"), (GLfloat, "r"), (GLfloat, "g"), (GLfloat, "b"), (GLfloat, "a"), (GLfloat, "nx"), (GLfloat, "ny"), (GLfloat, "nz"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN", [(Pointer(Const(GLuint)), "rc"), (Array(Const(GLfloat), 2), "tc"), (Array(Const(GLfloat), 4), "c"), (Array(Const(GLfloat), 3), "n"), (Array(Const(GLfloat), 3), "v")]),

    # GL_EXT_blend_func_separate
    GlFunction(Void, "glBlendFuncSeparateEXT", [(GLenum, "sfactorRGB"), (GLenum, "dfactorRGB"), (GLenum, "sfactorAlpha"), (GLenum, "dfactorAlpha")]),

    # GL_INGR_blend_func_separate
    GlFunction(Void, "glBlendFuncSeparateINGR", [(GLenum, "sfactorRGB"), (GLenum, "dfactorRGB"), (GLenum, "sfactorAlpha"), (GLenum, "dfactorAlpha")]),

    # GL_EXT_vertex_weighting
    GlFunction(Void, "glVertexWeightfEXT", [(GLfloat, "weight")]),
    GlFunction(Void, "glVertexWeightfvEXT", [(Pointer(Const(GLfloat)), "weight")]),
    GlFunction(Void, "glVertexWeightPointerEXT", [(GLsizei, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),

    # GL_NV_vertex_array_range
    GlFunction(Void, "glFlushVertexArrayRangeNV", []),
    GlFunction(Void, "glVertexArrayRangeNV", [(GLsizei, "length"), (GLpointerConst, "pointer")]),

    # GL_NV_register_combiners
    GlFunction(Void, "glCombinerParameterfvNV", [(GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glCombinerParameterfNV", [(GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glCombinerParameterivNV", [(GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glCombinerParameteriNV", [(GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glCombinerInputNV", [(GLenum, "stage"), (GLenum, "portion"), (GLenum, "variable"), (GLenum, "input"), (GLenum, "mapping"), (GLenum, "componentUsage")]),
    GlFunction(Void, "glCombinerOutputNV", [(GLenum, "stage"), (GLenum, "portion"), (GLenum, "abOutput"), (GLenum, "cdOutput"), (GLenum, "sumOutput"), (GLenum, "scale"), (GLenum, "bias"), (GLboolean, "abDotProduct"), (GLboolean, "cdDotProduct"), (GLboolean, "muxSum")]),
    GlFunction(Void, "glFinalCombinerInputNV", [(GLenum, "variable"), (GLenum, "input"), (GLenum, "mapping"), (GLenum, "componentUsage")]),
    GlFunction(Void, "glGetCombinerInputParameterfvNV", [(GLenum, "stage"), (GLenum, "portion"), (GLenum, "variable"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetCombinerInputParameterivNV", [(GLenum, "stage"), (GLenum, "portion"), (GLenum, "variable"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetCombinerOutputParameterfvNV", [(GLenum, "stage"), (GLenum, "portion"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetCombinerOutputParameterivNV", [(GLenum, "stage"), (GLenum, "portion"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetFinalCombinerInputParameterfvNV", [(GLenum, "variable"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetFinalCombinerInputParameterivNV", [(GLenum, "variable"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_NV_path_rendering
    GlFunction(GLuint, "glGenPathsNV", [(GLsizei, "range")]),
    GlFunction(Void, "glDeletePathsNV", [(GLuint, "path"), (GLsizei, "range")]),
    GlFunction(GLboolean, "glIsPathNV", [(GLuint, "path")]),
    GlFunction(Void, "glPathCommandsNV", [(GLuint, "path"), (GLsizei, "numCommands"), (Array(Const(GLubyte), "numCommands"), "commands"), (GLsizei, "numCoords"), (GLenum, "coordType"), (Blob(Const(GLvoid), "_glPath_coords_size(numCoords, coordType)"), "coords")]),
    GlFunction(Void, "glPathCoordsNV", [(GLuint, "path"), (GLsizei, "numCoords"), (GLenum, "coordType"), (Blob(Const(GLvoid), "_glPath_coords_size(numCoords, coordType)"), "coords")]),
    GlFunction(Void, "glPathSubCommandsNV", [(GLuint, "path"), (GLsizei, "commandStart"), (GLsizei, "commandsToDelete"), (GLsizei, "numCommands"), (Array(Const(GLubyte), "numCommands"), "commands"), (GLsizei, "numCoords"), (GLenum, "coordType"), (Blob(Const(GLvoid), "_glPath_coords_size(numCoords, coordType)"), "coords")]),
    GlFunction(Void, "glPathSubCoordsNV", [(GLuint, "path"), (GLsizei, "coordStart"), (GLsizei, "numCoords"), (GLenum, "coordType"), (Blob(Const(GLvoid), "_glPath_coords_size(numCoords, coordType)"), "coords")]),
    GlFunction(Void, "glPathStringNV", [(GLuint, "path"), (GLenum, "format"), (GLsizei, "length"), (Blob(Const(GLvoid), "length"), "pathString")]),
    GlFunction(Void, "glPathGlyphsNV", [(GLuint, "firstPathName"), (GLenum, "fontTarget"), (Blob(Const(GLvoid), "_glPath_fontName_size(fontTarget, fontName)"), "fontName"), (GLbitfield_fontStyle, "fontStyle"), (GLsizei, "numGlyphs"), (GLenum, "type"), (Blob(Const(GLvoid), "_glPath_chardcodes_size(numGlyphs, type)"), "charcodes"), (GLenum, "handleMissingGlyphs"), (GLuint, "pathParameterTemplate"), (GLfloat, "emScale")]),
    GlFunction(Void, "glPathGlyphRangeNV", [(GLuint, "firstPathName"), (GLenum, "fontTarget"), (Blob(Const(GLvoid), "_glPath_fontName_size(fontTarget, fontName)"), "fontName"), (GLbitfield_fontStyle, "fontStyle"), (GLuint, "firstGlyph"), (GLsizei, "numGlyphs"), (GLenum, "handleMissingGlyphs"), (GLuint, "pathParameterTemplate"), (GLfloat, "emScale")]),
    GlFunction(Void, "glWeightPathsNV", [(GLuint, "resultPath"), (GLsizei, "numPaths"), (Array(Const(GLuint), "numPaths"), "paths"), (Array(Const(GLfloat), "numPaths"), "weights")]),
    GlFunction(Void, "glCopyPathNV", [(GLuint, "resultPath"), (GLuint, "srcPath")]),
    GlFunction(Void, "glInterpolatePathsNV", [(GLuint, "resultPath"), (GLuint, "pathA"), (GLuint, "pathB"), (GLfloat, "weight")]),
    GlFunction(Void, "glTransformPathNV", [(GLuint, "resultPath"), (GLuint, "srcPath"), (GLenum, "transformType"), (Array(Const(GLfloat), "_gl_transformType_size(transformType)"), "transformValues")]),
    GlFunction(Void, "glPathParameterivNV", [(GLuint, "path"), (GLenum, "pname"), (Array(Const(GLint), "_gl_PathParameter_size(pname)"), "value")]),
    GlFunction(Void, "glPathParameteriNV", [(GLuint, "path"), (GLenum, "pname"), (GLint, "value")]),
    GlFunction(Void, "glPathParameterfvNV", [(GLuint, "path"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_PathParameter_size(pname)"), "value")]),
    GlFunction(Void, "glPathParameterfNV", [(GLuint, "path"), (GLenum, "pname"), (GLfloat, "value")]),
    GlFunction(Void, "glPathDashArrayNV", [(GLuint, "path"), (GLsizei, "dashCount"), (Array(Const(GLfloat), "dashCount"), "dashArray")]),
    GlFunction(Void, "glPathStencilFuncNV", [(GLenum, "func"), (GLint, "ref"), (GLuint, "mask")]),
    GlFunction(Void, "glPathStencilDepthOffsetNV", [(GLfloat, "factor"), (GLfloat, "units")]),
    GlFunction(Void, "glStencilFillPathNV", [(GLuint, "path"), (GLenum, "fillMode"), (GLuint, "mask")]),
    GlFunction(Void, "glStencilStrokePathNV", [(GLuint, "path"), (GLint, "reference"), (GLuint, "mask")]),
    GlFunction(Void, "glStencilFillPathInstancedNV", [(GLsizei, "numPaths"), (GLenum, "pathNameType"), (Blob(Const(GLvoid), "_gl_Paths_size(numPaths, pathNameType, paths)"), "paths"), (GLuint, "pathBase"), (GLenum, "fillMode"), (GLuint, "mask"), (GLenum, "transformType"), (Array(Const(GLfloat), "_gl_transformType_size(numPaths, transformType)"), "transformValues")]),
    GlFunction(Void, "glStencilStrokePathInstancedNV", [(GLsizei, "numPaths"), (GLenum, "pathNameType"), (Blob(Const(GLvoid), "_gl_Paths_size(numPaths, pathNameType, paths)"), "paths"), (GLuint, "pathBase"), (GLint, "reference"), (GLuint, "mask"), (GLenum, "transformType"), (Array(Const(GLfloat), "_gl_transformType_size(numPaths, transformType)"), "transformValues")]),
    GlFunction(Void, "glPathCoverDepthFuncNV", [(GLenum, "zfunc")]),
    GlFunction(Void, "glPathColorGenNV", [(GLenum, "color"), (GLenum, "genMode"), (GLenum, "colorFormat"), (Array(Const(GLfloat), "_gl_PathColorGen_size(genMode, colorFormat)"), "coeffs")]),
    GlFunction(Void, "glPathTexGenNV", [(GLenum, "texCoordSet"), (GLenum, "genMode"), (GLint, "components"), (Array(Const(GLfloat), "_gl_PathTexGen_size(genMode, components)"), "coeffs")]),
    GlFunction(Void, "glPathFogGenNV", [(GLenum, "genMode")]),
    GlFunction(Void, "glCoverFillPathNV", [(GLuint, "path"), (GLenum, "coverMode")]),
    GlFunction(Void, "glCoverStrokePathNV", [(GLuint, "path"), (GLenum, "coverMode")]),
    GlFunction(Void, "glCoverFillPathInstancedNV", [(GLsizei, "numPaths"), (GLenum, "pathNameType"), (Blob(Const(GLvoid), "_gl_Paths_size(numPaths, pathNameType, paths)"), "paths"), (GLuint, "pathBase"), (GLenum, "coverMode"), (GLenum, "transformType"), (Array(Const(GLfloat), "_gl_transformType_size(numPaths, transformType)"), "transformValues")]),
    GlFunction(Void, "glCoverStrokePathInstancedNV", [(GLsizei, "numPaths"), (GLenum, "pathNameType"), (Blob(Const(GLvoid), "_gl_Paths_size(numPaths, pathNameType, paths)"), "paths"), (GLuint, "pathBase"), (GLenum, "coverMode"), (GLenum, "transformType"), (Array(Const(GLfloat), "_gl_transformType_size(numPaths, transformType)"), "transformValues")]),
    GlFunction(Void, "glGetPathParameterivNV", [(GLuint, "path"), (GLenum, "pname"), Out(Array(GLint, "_gl_GetPathParameter_size(pname)"), "value")], sideeffects=False),
    GlFunction(Void, "glGetPathParameterfvNV", [(GLuint, "path"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_GetPathParameter_size(pname)"), "value")], sideeffects=False),
    GlFunction(Void, "glGetPathCommandsNV", [(GLuint, "path"), Out(Pointer(GLubyte), "commands")], sideeffects=False),
    GlFunction(Void, "glGetPathCoordsNV", [(GLuint, "path"), Out(Pointer(GLfloat), "coords")], sideeffects=False),
    GlFunction(Void, "glGetPathDashArrayNV", [(GLuint, "path"), Out(Pointer(GLfloat), "dashArray")], sideeffects=False),
    GlFunction(Void, "glGetPathMetricsNV", [(GLbitfield_metricQueryMask, "metricQueryMask"), (GLsizei, "numPaths"), (GLenum, "pathNameType"), (Blob(Const(GLvoid), "_gl_Paths_size(numPaths, pathNameType, paths)"), "paths"), (GLuint, "pathBase"), (GLsizei, "stride"), Out(Pointer(GLfloat), "metrics")], sideeffects=False),
    GlFunction(Void, "glGetPathMetricRangeNV", [(GLbitfield_metricQueryMask, "metricQueryMask"), (GLuint, "firstPathName"), (GLsizei, "numPaths"), (GLsizei, "stride"), Out(Pointer(GLfloat), "metrics")], sideeffects=False),
    GlFunction(Void, "glGetPathSpacingNV", [(GLenum, "pathListMode"), (GLsizei, "numPaths"), (GLenum, "pathNameType"), (Blob(Const(GLvoid), "_gl_Paths_size(numPaths, pathNameType, paths)"), "paths"), (GLuint, "pathBase"), (GLfloat, "advanceScale"), (GLfloat, "kerningScale"), (GLenum, "transformType"), Out(Array(GLfloat, "_gl_GetPathSpacing(numPaths,transformType)"),  "returnedSpacing")]),
    GlFunction(Void, "glGetPathColorGenivNV", [(GLenum, "color"), (GLenum, "pname"), Out(Pointer(GLint), "value")], sideeffects=False),
    GlFunction(Void, "glGetPathColorGenfvNV", [(GLenum, "color"), (GLenum, "pname"), Out(Pointer(GLfloat), "value")], sideeffects=False),
    GlFunction(Void, "glGetPathTexGenivNV", [(GLenum, "texCoordSet"), (GLenum, "pname"), Out(Pointer(GLint), "value")], sideeffects=False),
    GlFunction(Void, "glGetPathTexGenfvNV", [(GLenum, "texCoordSet"), (GLenum, "pname"), Out(Pointer(GLfloat), "value")], sideeffects=False),
    GlFunction(GLboolean, "glIsPointInFillPathNV", [(GLuint, "path"), (GLuint, "mask"), (GLfloat, "x"), (GLfloat, "y")], sideeffects=False),
    GlFunction(GLboolean, "glIsPointInStrokePathNV", [(GLuint, "path"), (GLfloat, "x"), (GLfloat, "y")], sideeffects=False),
    GlFunction(GLfloat, "glGetPathLengthNV", [(GLuint, "path"), (GLsizei, "startSegment"), (GLsizei, "numSegments")]),
    GlFunction(GLboolean, "glPointAlongPathNV", [(GLuint, "path"), (GLsizei, "startSegment"), (GLsizei, "numSegments"), (GLfloat, "distance"), Out(Array(GLfloat,1), "x"), Out(Array(GLfloat,1), "y"), Out(Array(GLfloat,1), "tangentX"), Out(Array(GLfloat,1), "tangentY")], sideeffects=False),

    # GL_MESA_resize_buffers
    GlFunction(Void, "glResizeBuffersMESA", []),

    # GL_MESA_window_pos
    GlFunction(Void, "glWindowPos2dMESA", [(GLdouble, "x"), (GLdouble, "y")]),
    GlFunction(Void, "glWindowPos2dvMESA", [(Array(Const(GLdouble), 2), "v")]),
    GlFunction(Void, "glWindowPos2fMESA", [(GLfloat, "x"), (GLfloat, "y")]),
    GlFunction(Void, "glWindowPos2fvMESA", [(Array(Const(GLfloat), 2), "v")]),
    GlFunction(Void, "glWindowPos2iMESA", [(GLint, "x"), (GLint, "y")]),
    GlFunction(Void, "glWindowPos2ivMESA", [(Array(Const(GLint), 2), "v")]),
    GlFunction(Void, "glWindowPos2sMESA", [(GLshort, "x"), (GLshort, "y")]),
    GlFunction(Void, "glWindowPos2svMESA", [(Array(Const(GLshort), 2), "v")]),
    GlFunction(Void, "glWindowPos3dMESA", [(GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glWindowPos3dvMESA", [(Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glWindowPos3fMESA", [(GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glWindowPos3fvMESA", [(Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glWindowPos3iMESA", [(GLint, "x"), (GLint, "y"), (GLint, "z")]),
    GlFunction(Void, "glWindowPos3ivMESA", [(Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glWindowPos3sMESA", [(GLshort, "x"), (GLshort, "y"), (GLshort, "z")]),
    GlFunction(Void, "glWindowPos3svMESA", [(Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glWindowPos4dMESA", [(GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glWindowPos4dvMESA", [(Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glWindowPos4fMESA", [(GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glWindowPos4fvMESA", [(Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glWindowPos4iMESA", [(GLint, "x"), (GLint, "y"), (GLint, "z"), (GLint, "w")]),
    GlFunction(Void, "glWindowPos4ivMESA", [(Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glWindowPos4sMESA", [(GLshort, "x"), (GLshort, "y"), (GLshort, "z"), (GLshort, "w")]),
    GlFunction(Void, "glWindowPos4svMESA", [(Array(Const(GLshort), 4), "v")]),

    # GL_IBM_multimode_draw_arrays
    GlFunction(Void, "glMultiModeDrawArraysIBM", [(Array(Const(GLenum), "primcount"), "mode"), (Array(Const(GLint), "primcount"), "first"), (Array(Const(GLsizei), "primcount"), "count"), (GLsizei, "primcount"), (GLint, "modestride")]),
    GlFunction(Void, "glMultiModeDrawElementsIBM", [(Array(Const(GLenum), "primcount"), "mode"), (Array(Const(GLsizei), "primcount"), "count"), (GLenum, "type"), (Array(Const(GLindexBuffer("count[{i}]", "type")), "primcount"), "indices"), (GLsizei, "primcount"), (GLint, "modestride")]),

    # GL_IBM_vertex_array_lists
    GlFunction(Void, "glColorPointerListIBM", [(size_bgra, "size"), (GLenum, "type"), (GLint, "stride"), (OpaquePointer(GLpointerConst), "pointer"), (GLint, "ptrstride")]),
    GlFunction(Void, "glSecondaryColorPointerListIBM", [(size_bgra, "size"), (GLenum, "type"), (GLint, "stride"), (OpaquePointer(GLpointerConst), "pointer"), (GLint, "ptrstride")]),
    GlFunction(Void, "glEdgeFlagPointerListIBM", [(GLint, "stride"), (OpaquePointer(Opaque("const GLboolean *")), "pointer"), (GLint, "ptrstride")]),
    GlFunction(Void, "glFogCoordPointerListIBM", [(GLenum, "type"), (GLint, "stride"), (OpaquePointer(GLpointerConst), "pointer"), (GLint, "ptrstride")]),
    GlFunction(Void, "glIndexPointerListIBM", [(GLenum, "type"), (GLint, "stride"), (OpaquePointer(GLpointerConst), "pointer"), (GLint, "ptrstride")]),
    GlFunction(Void, "glNormalPointerListIBM", [(GLenum, "type"), (GLint, "stride"), (OpaquePointer(GLpointerConst), "pointer"), (GLint, "ptrstride")]),
    GlFunction(Void, "glTexCoordPointerListIBM", [(GLint, "size"), (GLenum, "type"), (GLint, "stride"), (OpaquePointer(GLpointerConst), "pointer"), (GLint, "ptrstride")]),
    GlFunction(Void, "glVertexPointerListIBM", [(GLint, "size"), (GLenum, "type"), (GLint, "stride"), (OpaquePointer(GLpointerConst), "pointer"), (GLint, "ptrstride")]),

    # GL_3DFX_tbuffer
    GlFunction(Void, "glTbufferMask3DFX", [(GLuint, "mask")]),

    # GL_EXT_multisample
    GlFunction(Void, "glSampleMaskEXT", [(GLclampf, "value"), (GLboolean, "invert")]),
    GlFunction(Void, "glSamplePatternEXT", [(GLenum, "pattern")]),

    # GL_SGIS_texture_color_mask
    GlFunction(Void, "glTextureColorMaskSGIS", [(GLboolean, "red"), (GLboolean, "green"), (GLboolean, "blue"), (GLboolean, "alpha")]),

    # GL_SGIX_igloo_interface
    GlFunction(Void, "glIglooInterfaceSGIX", [(GLenum, "pname"), (OpaqueBlob(Const(GLvoid), "_glIglooInterfaceSGIX_size(pname)"), "params")]),

    # GL_NV_fence
    GlFunction(Void, "glDeleteFencesNV", [(GLsizei, "n"), (Array(Const(GLfence), "n"), "fences")]),
    GlFunction(Void, "glGenFencesNV", [(GLsizei, "n"), Out(Array(GLfence, "n"), "fences")]),
    GlFunction(GLboolean, "glIsFenceNV", [(GLfence, "fence")], sideeffects=False),
    GlFunction(GLboolean, "glTestFenceNV", [(GLfence, "fence")]),
    GlFunction(Void, "glGetFenceivNV", [(GLfence, "fence"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glFinishFenceNV", [(GLfence, "fence")]),
    GlFunction(Void, "glSetFenceNV", [(GLfence, "fence"), (GLenum, "condition")]),

    # GL_NV_evaluators
    GlFunction(Void, "glMapControlPointsNV", [(GLenum, "target"), (GLuint, "index"), (GLenum, "type"), (GLsizei, "ustride"), (GLsizei, "vstride"), (GLint, "uorder"), (GLint, "vorder"), (GLboolean, "packed"), (OpaqueBlob(Const(GLvoid), "_glMapControlPointsNV_size(target, uorder, vorder)"), "points")]),
    GlFunction(Void, "glMapParameterivNV", [(GLenum, "target"), (GLenum, "pname"), (OpaqueArray(Const(GLint), "_glMapParameterivNV_size(target, pname)"), "params")]),
    GlFunction(Void, "glMapParameterfvNV", [(GLenum, "target"), (GLenum, "pname"), (OpaqueArray(Const(GLfloat), "_glMapParameterfvNV_size(target, pname)"), "params")]),
    GlFunction(Void, "glGetMapControlPointsNV", [(GLenum, "target"), (GLuint, "index"), (GLenum, "type"), (GLsizei, "ustride"), (GLsizei, "vstride"), (GLboolean, "packed"), Out(OpaqueBlob(GLvoid, "_glGetMapControlPointsNV_size(target)"), "points")], sideeffects=False),
    GlFunction(Void, "glGetMapParameterivNV", [(GLenum, "target"), (GLenum, "pname"), Out(OpaqueArray(GLint, "_glGetMapParameterivNV_size(target, pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMapParameterfvNV", [(GLenum, "target"), (GLenum, "pname"), Out(OpaqueArray(GLfloat, "_glGetMapParameterfvNV_size(target, pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMapAttribParameterivNV", [(GLenum, "target"), (GLuint, "index"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMapAttribParameterfvNV", [(GLenum, "target"), (GLuint, "index"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glEvalMapsNV", [(GLenum, "target"), (GLenum, "mode")]),

    # GL_NV_register_combiners2
    GlFunction(Void, "glCombinerStageParameterfvNV", [(GLenum, "stage"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glGetCombinerStageParameterfvNV", [(GLenum, "stage"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_NV_vertex_program
    GlFunction(GLboolean, "glAreProgramsResidentNV", [(GLsizei, "n"), (Array(Const(GLprogramARB), "n"), "ids"), Out(Array(GLboolean, "n"), "residences")], sideeffects=False),
    GlFunction(Void, "glBindProgramNV", [(GLenum, "target"), (GLprogramARB, "program")]),
    GlFunction(Void, "glDeleteProgramsNV", [(GLsizei, "n"), (Array(Const(GLprogramARB), "n"), "programs")]),
    GlFunction(Void, "glExecuteProgramNV", [(GLenum, "target"), (GLprogramARB, "id"), (Array(Const(GLfloat), 4), "params")]),
    GlFunction(Void, "glGenProgramsNV", [(GLsizei, "n"), Out(Array(GLprogramARB, "n"), "programs")]),
    GlFunction(Void, "glGetProgramParameterdvNV", [(GLenum, "target"), (GLuint, "index"), (GLenum, "pname"), Out(Array(GLdouble, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramParameterfvNV", [(GLenum, "target"), (GLuint, "index"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramivNV", [(GLprogramARB, "id"), (GLenum, "pname"), Out(Pointer(GLint), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramStringNV", [(GLprogramARB, "id"), (GLenum, "pname"), Out(Array(GLubyte, "_gl_param_size(pname)"), "program")], sideeffects=False),
    GlFunction(Void, "glGetTrackMatrixivNV", [(GLenum, "target"), (GLuint, "address"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribdvNV", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLdouble, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribfvNV", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribivNV", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribPointervNV", [(GLuint, "index"), (GLenum, "pname"), Out(Pointer(GLpointer), "pointer")], sideeffects=False),
    GlFunction(GLboolean, "glIsProgramNV", [(GLprogramARB, "program")], sideeffects=False),
    GlFunction(Void, "glLoadProgramNV", [(GLenum, "target"), (GLprogramARB, "id"), (GLsizei, "len"), (String(Const(GLubyte), "len"), "program")]),
    GlFunction(Void, "glProgramParameter4dNV", [(GLenum, "target"), (GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glProgramParameter4dvNV", [(GLenum, "target"), (GLuint, "index"), (Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glProgramParameter4fNV", [(GLenum, "target"), (GLuint, "index"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glProgramParameter4fvNV", [(GLenum, "target"), (GLuint, "index"), (Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glProgramParameters4dvNV", [(GLenum, "target"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLdouble), "count*4"), "v")]),
    GlFunction(Void, "glProgramParameters4fvNV", [(GLenum, "target"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLfloat), "count*4"), "v")]),
    GlFunction(Void, "glRequestResidentProgramsNV", [(GLsizei, "n"), (Array(Const(GLprogramARB), "n"), "programs")]),
    GlFunction(Void, "glTrackMatrixNV", [(GLenum, "target"), (GLuint, "address"), (GLenum, "matrix"), (GLenum, "transform")]),
    GlFunction(Void, "glVertexAttribPointerNV", [(GLuint, "index"), (size_bgra, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glVertexAttrib1dNV", [(GLuint, "index"), (GLdouble, "x")]),
    GlFunction(Void, "glVertexAttrib1dvNV", [(GLuint, "index"), (Pointer(Const(GLdouble)), "v")]),
    GlFunction(Void, "glVertexAttrib1fNV", [(GLuint, "index"), (GLfloat, "x")]),
    GlFunction(Void, "glVertexAttrib1fvNV", [(GLuint, "index"), (Pointer(Const(GLfloat)), "v")]),
    GlFunction(Void, "glVertexAttrib1sNV", [(GLuint, "index"), (GLshort, "x")]),
    GlFunction(Void, "glVertexAttrib1svNV", [(GLuint, "index"), (Pointer(Const(GLshort)), "v")]),
    GlFunction(Void, "glVertexAttrib2dNV", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y")]),
    GlFunction(Void, "glVertexAttrib2dvNV", [(GLuint, "index"), (Array(Const(GLdouble), 2), "v")]),
    GlFunction(Void, "glVertexAttrib2fNV", [(GLuint, "index"), (GLfloat, "x"), (GLfloat, "y")]),
    GlFunction(Void, "glVertexAttrib2fvNV", [(GLuint, "index"), (Array(Const(GLfloat), 2), "v")]),
    GlFunction(Void, "glVertexAttrib2sNV", [(GLuint, "index"), (GLshort, "x"), (GLshort, "y")]),
    GlFunction(Void, "glVertexAttrib2svNV", [(GLuint, "index"), (Array(Const(GLshort), 2), "v")]),
    GlFunction(Void, "glVertexAttrib3dNV", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glVertexAttrib3dvNV", [(GLuint, "index"), (Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glVertexAttrib3fNV", [(GLuint, "index"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glVertexAttrib3fvNV", [(GLuint, "index"), (Array(Const(GLfloat), 3), "v")]),
    GlFunction(Void, "glVertexAttrib3sNV", [(GLuint, "index"), (GLshort, "x"), (GLshort, "y"), (GLshort, "z")]),
    GlFunction(Void, "glVertexAttrib3svNV", [(GLuint, "index"), (Array(Const(GLshort), 3), "v")]),
    GlFunction(Void, "glVertexAttrib4dNV", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glVertexAttrib4dvNV", [(GLuint, "index"), (Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4fNV", [(GLuint, "index"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glVertexAttrib4fvNV", [(GLuint, "index"), (Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4sNV", [(GLuint, "index"), (GLshort, "x"), (GLshort, "y"), (GLshort, "z"), (GLshort, "w")]),
    GlFunction(Void, "glVertexAttrib4svNV", [(GLuint, "index"), (Array(Const(GLshort), 4), "v")]),
    GlFunction(Void, "glVertexAttrib4ubNV", [(GLuint, "index"), (GLubyte, "x"), (GLubyte, "y"), (GLubyte, "z"), (GLubyte, "w")]),
    GlFunction(Void, "glVertexAttrib4ubvNV", [(GLuint, "index"), (Array(Const(GLubyte), 4), "v")]),
    GlFunction(Void, "glVertexAttribs1dvNV", [(GLuint, "index"), (GLsizei, "count"), (Array(Const(GLdouble), "count"), "v")]),
    GlFunction(Void, "glVertexAttribs1fvNV", [(GLuint, "index"), (GLsizei, "count"), (Array(Const(GLfloat), "count"), "v")]),
    GlFunction(Void, "glVertexAttribs1svNV", [(GLuint, "index"), (GLsizei, "count"), (Array(Const(GLshort), "count"), "v")]),
    GlFunction(Void, "glVertexAttribs2dvNV", [(GLuint, "index"), (GLsizei, "count"), (Array(Const(GLdouble), "count*2"), "v")]),
    GlFunction(Void, "glVertexAttribs2fvNV", [(GLuint, "index"), (GLsizei, "count"), (Array(Const(GLfloat), "count*2"), "v")]),
    GlFunction(Void, "glVertexAttribs2svNV", [(GLuint, "index"), (GLsizei, "count"), (Array(Const(GLshort), "count*2"), "v")]),
    GlFunction(Void, "glVertexAttribs3dvNV", [(GLuint, "index"), (GLsizei, "count"), (Array(Const(GLdouble), "count*3"), "v")]),
    GlFunction(Void, "glVertexAttribs3fvNV", [(GLuint, "index"), (GLsizei, "count"), (Array(Const(GLfloat), "count*3"), "v")]),
    GlFunction(Void, "glVertexAttribs3svNV", [(GLuint, "index"), (GLsizei, "count"), (Array(Const(GLshort), "count*3"), "v")]),
    GlFunction(Void, "glVertexAttribs4dvNV", [(GLuint, "index"), (GLsizei, "count"), (Array(Const(GLdouble), "count*4"), "v")]),
    GlFunction(Void, "glVertexAttribs4fvNV", [(GLuint, "index"), (GLsizei, "count"), (Array(Const(GLfloat), "count*4"), "v")]),
    GlFunction(Void, "glVertexAttribs4svNV", [(GLuint, "index"), (GLsizei, "count"), (Array(Const(GLshort), "count*4"), "v")]),
    GlFunction(Void, "glVertexAttribs4ubvNV", [(GLuint, "index"), (GLsizei, "count"), (Array(Const(GLubyte), "count*4"), "v")]),

    # GL_ATI_envmap_bumpmap
    GlFunction(Void, "glTexBumpParameterivATI", [(GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "param")]),
    GlFunction(Void, "glTexBumpParameterfvATI", [(GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "param")]),
    GlFunction(Void, "glGetTexBumpParameterivATI", [(GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "param")], sideeffects=False),
    GlFunction(Void, "glGetTexBumpParameterfvATI", [(GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "param")], sideeffects=False),

    # GL_ATI_fragment_shader
    GlFunction(Handle("fragmentShaderATI", GLuint, "range"), "glGenFragmentShadersATI", [(GLuint, "range")]),
    GlFunction(Void, "glBindFragmentShaderATI", [(GLfragmentShaderATI, "id")]),
    GlFunction(Void, "glDeleteFragmentShaderATI", [(GLfragmentShaderATI, "id")]),
    GlFunction(Void, "glBeginFragmentShaderATI", []),
    GlFunction(Void, "glEndFragmentShaderATI", []),
    GlFunction(Void, "glPassTexCoordATI", [(GLuint, "dst"), (GLuint, "coord"), (GLenum, "swizzle")]),
    GlFunction(Void, "glSampleMapATI", [(GLuint, "dst"), (GLuint, "interp"), (GLenum, "swizzle")]),
    GlFunction(Void, "glColorFragmentOp1ATI", [(GLenum, "op"), (GLuint, "dst"), (GLuint, "dstMask"), (GLuint, "dstMod"), (GLuint, "arg1"), (GLuint, "arg1Rep"), (GLuint, "arg1Mod")]),
    GlFunction(Void, "glColorFragmentOp2ATI", [(GLenum, "op"), (GLuint, "dst"), (GLuint, "dstMask"), (GLuint, "dstMod"), (GLuint, "arg1"), (GLuint, "arg1Rep"), (GLuint, "arg1Mod"), (GLuint, "arg2"), (GLuint, "arg2Rep"), (GLuint, "arg2Mod")]),
    GlFunction(Void, "glColorFragmentOp3ATI", [(GLenum, "op"), (GLuint, "dst"), (GLuint, "dstMask"), (GLuint, "dstMod"), (GLuint, "arg1"), (GLuint, "arg1Rep"), (GLuint, "arg1Mod"), (GLuint, "arg2"), (GLuint, "arg2Rep"), (GLuint, "arg2Mod"), (GLuint, "arg3"), (GLuint, "arg3Rep"), (GLuint, "arg3Mod")]),
    GlFunction(Void, "glAlphaFragmentOp1ATI", [(GLenum, "op"), (GLuint, "dst"), (GLuint, "dstMod"), (GLuint, "arg1"), (GLuint, "arg1Rep"), (GLuint, "arg1Mod")]),
    GlFunction(Void, "glAlphaFragmentOp2ATI", [(GLenum, "op"), (GLuint, "dst"), (GLuint, "dstMod"), (GLuint, "arg1"), (GLuint, "arg1Rep"), (GLuint, "arg1Mod"), (GLuint, "arg2"), (GLuint, "arg2Rep"), (GLuint, "arg2Mod")]),
    GlFunction(Void, "glAlphaFragmentOp3ATI", [(GLenum, "op"), (GLuint, "dst"), (GLuint, "dstMod"), (GLuint, "arg1"), (GLuint, "arg1Rep"), (GLuint, "arg1Mod"), (GLuint, "arg2"), (GLuint, "arg2Rep"), (GLuint, "arg2Mod"), (GLuint, "arg3"), (GLuint, "arg3Rep"), (GLuint, "arg3Mod")]),
    GlFunction(Void, "glSetFragmentShaderConstantATI", [(GLuint, "dst"), (Array(Const(GLfloat), 4), "value")]),

    # GL_ATI_pn_triangles
    GlFunction(Void, "glPNTrianglesiATI", [(GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glPNTrianglesfATI", [(GLenum, "pname"), (GLfloat, "param")]),

    # GL_ATI_vertex_array_object
    GlFunction(GLuint, "glNewObjectBufferATI", [(GLsizei, "size"), (Blob(Const(GLvoid), "size"), "pointer"), (GLenum, "usage")]),
    GlFunction(GLboolean, "glIsObjectBufferATI", [(GLuint, "buffer")], sideeffects=False),
    GlFunction(Void, "glUpdateObjectBufferATI", [(GLuint, "buffer"), (GLuint, "offset"), (GLsizei, "size"), (Blob(Const(GLvoid), "size"), "pointer"), (GLenum, "preserve")]),
    GlFunction(Void, "glGetObjectBufferfvATI", [(GLuint, "buffer"), (GLenum, "pname"), Out(Pointer(GLfloat), "params")], sideeffects=False),
    GlFunction(Void, "glGetObjectBufferivATI", [(GLuint, "buffer"), (GLenum, "pname"), Out(Pointer(GLint), "params")], sideeffects=False),
    GlFunction(Void, "glFreeObjectBufferATI", [(GLuint, "buffer")]),
    GlFunction(Void, "glArrayObjectATI", [(GLenum, "array"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLuint, "buffer"), (GLuint, "offset")]),
    GlFunction(Void, "glGetArrayObjectfvATI", [(GLenum, "array"), (GLenum, "pname"), Out(Pointer(GLfloat), "params")], sideeffects=False),
    GlFunction(Void, "glGetArrayObjectivATI", [(GLenum, "array"), (GLenum, "pname"), Out(Pointer(GLint), "params")], sideeffects=False),
    GlFunction(Void, "glVariantArrayObjectATI", [(GLuint, "id"), (GLenum, "type"), (GLsizei, "stride"), (GLuint, "buffer"), (GLuint, "offset")]),
    GlFunction(Void, "glGetVariantArrayObjectfvATI", [(GLuint, "id"), (GLenum, "pname"), Out(Pointer(GLfloat), "params")], sideeffects=False),
    GlFunction(Void, "glGetVariantArrayObjectivATI", [(GLuint, "id"), (GLenum, "pname"), Out(Pointer(GLint), "params")], sideeffects=False),

    # GL_EXT_vertex_shader
    GlFunction(Void, "glBeginVertexShaderEXT", []),
    GlFunction(Void, "glEndVertexShaderEXT", []),
    GlFunction(Void, "glBindVertexShaderEXT", [(GLuint, "id")]),
    GlFunction(GLuint, "glGenVertexShadersEXT", [(GLuint, "range")]),
    GlFunction(Void, "glDeleteVertexShaderEXT", [(GLuint, "id")]),
    GlFunction(Void, "glShaderOp1EXT", [(GLenum, "op"), (GLuint, "res"), (GLuint, "arg1")]),
    GlFunction(Void, "glShaderOp2EXT", [(GLenum, "op"), (GLuint, "res"), (GLuint, "arg1"), (GLuint, "arg2")]),
    GlFunction(Void, "glShaderOp3EXT", [(GLenum, "op"), (GLuint, "res"), (GLuint, "arg1"), (GLuint, "arg2"), (GLuint, "arg3")]),
    GlFunction(Void, "glSwizzleEXT", [(GLuint, "res"), (GLuint, "in"), (GLenum, "outX"), (GLenum, "outY"), (GLenum, "outZ"), (GLenum, "outW")]),
    GlFunction(Void, "glWriteMaskEXT", [(GLuint, "res"), (GLuint, "in"), (GLenum, "outX"), (GLenum, "outY"), (GLenum, "outZ"), (GLenum, "outW")]),
    GlFunction(Void, "glInsertComponentEXT", [(GLuint, "res"), (GLuint, "src"), (GLuint, "num")]),
    GlFunction(Void, "glExtractComponentEXT", [(GLuint, "res"), (GLuint, "src"), (GLuint, "num")]),
    GlFunction(GLuint, "glGenSymbolsEXT", [(GLenum, "datatype"), (GLenum, "storagetype"), (GLenum, "range"), (GLuint, "components")]),
    GlFunction(Void, "glSetInvariantEXT", [(GLuint, "id"), (GLenum, "type"), (OpaqueBlob(Const(GLvoid), "_glSetInvariantEXT_size(id, type)"), "addr")]),
    GlFunction(Void, "glSetLocalConstantEXT", [(GLuint, "id"), (GLenum, "type"), (OpaqueBlob(Const(GLvoid), "_glSetLocalConstantEXT_size(id, type)"), "addr")]),
    GlFunction(Void, "glVariantbvEXT", [(GLuint, "id"), (OpaqueArray(Const(GLbyte), "_glVariantbvEXT_size(id)"), "addr")]),
    GlFunction(Void, "glVariantsvEXT", [(GLuint, "id"), (OpaqueArray(Const(GLshort), "_glVariantsvEXT_size(id)"), "addr")]),
    GlFunction(Void, "glVariantivEXT", [(GLuint, "id"), (OpaqueArray(Const(GLint), "_glVariantivEXT_size(id)"), "addr")]),
    GlFunction(Void, "glVariantfvEXT", [(GLuint, "id"), (OpaqueArray(Const(GLfloat), "_glVariantfvEXT_size(id)"), "addr")]),
    GlFunction(Void, "glVariantdvEXT", [(GLuint, "id"), (OpaqueArray(Const(GLdouble), "_glVariantdvEXT_size(id)"), "addr")]),
    GlFunction(Void, "glVariantubvEXT", [(GLuint, "id"), (OpaqueArray(Const(GLubyte), "_glVariantubvEXT_size(id)"), "addr")]),
    GlFunction(Void, "glVariantusvEXT", [(GLuint, "id"), (OpaqueArray(Const(GLushort), "_glVariantusvEXT_size(id)"), "addr")]),
    GlFunction(Void, "glVariantuivEXT", [(GLuint, "id"), (OpaqueArray(Const(GLuint), "_glVariantuivEXT_size(id)"), "addr")]),
    GlFunction(Void, "glVariantPointerEXT", [(GLuint, "id"), (GLenum, "type"), (GLuint, "stride"), (OpaqueBlob(Const(GLvoid), "_glVariantPointerEXT_size(id, type, stride)"), "addr")]),
    GlFunction(Void, "glEnableVariantClientStateEXT", [(GLuint, "id")]),
    GlFunction(Void, "glDisableVariantClientStateEXT", [(GLuint, "id")]),
    GlFunction(GLuint, "glBindLightParameterEXT", [(GLenum, "light"), (GLenum, "value")]),
    GlFunction(GLuint, "glBindMaterialParameterEXT", [(GLenum, "face"), (GLenum, "value")]),
    GlFunction(GLuint, "glBindTexGenParameterEXT", [(GLenum, "unit"), (GLenum, "coord"), (GLenum, "value")]),
    GlFunction(GLuint, "glBindTextureUnitParameterEXT", [(GLenum, "unit"), (GLenum, "value")]),
    GlFunction(GLuint, "glBindParameterEXT", [(GLenum, "value")]),
    GlFunction(GLboolean, "glIsVariantEnabledEXT", [(GLuint, "id"), (GLenum, "cap")], sideeffects=False),
    GlFunction(Void, "glGetVariantBooleanvEXT", [(GLuint, "id"), (GLenum, "value"), Out(OpaqueArray(GLboolean, "_glGetVariantBooleanvEXT_size(id)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetVariantIntegervEXT", [(GLuint, "id"), (GLenum, "value"), Out(OpaqueArray(GLint, "_glGetVariantIntegervEXT_size(id)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetVariantFloatvEXT", [(GLuint, "id"), (GLenum, "value"), Out(OpaqueArray(GLfloat, "_glGetVariantFloatvEXT_size(id)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetVariantPointervEXT", [(GLuint, "id"), (GLenum, "value"), Out(OpaqueArray(GLpointer, "_glGetVariantPointervEXT_size(id)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetInvariantBooleanvEXT", [(GLuint, "id"), (GLenum, "value"), Out(OpaqueArray(GLboolean, "_glGetInvariantBooleanvEXT_size(id)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetInvariantIntegervEXT", [(GLuint, "id"), (GLenum, "value"), Out(OpaqueArray(GLint, "_glGetInvariantIntegervEXT_size(id)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetInvariantFloatvEXT", [(GLuint, "id"), (GLenum, "value"), Out(OpaqueArray(GLfloat, "_glGetInvariantFloatvEXT_size(id)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetLocalConstantBooleanvEXT", [(GLuint, "id"), (GLenum, "value"), Out(OpaqueArray(GLboolean, "_glGetLocalConstantBooleanvEXT_size(id)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetLocalConstantIntegervEXT", [(GLuint, "id"), (GLenum, "value"), Out(OpaqueArray(GLint, "_glGetLocalConstantIntegervEXT_size(id)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetLocalConstantFloatvEXT", [(GLuint, "id"), (GLenum, "value"), Out(OpaqueArray(GLfloat, "_glGetLocalConstantFloatvEXT_size(id)"), "data")], sideeffects=False),

    # GL_ATI_vertex_streams
    GlFunction(Void, "glVertexStream1sATI", [(GLenum, "stream"), (GLshort, "x")]),
    GlFunction(Void, "glVertexStream1svATI", [(GLenum, "stream"), (Pointer(Const(GLshort)), "coords")]),
    GlFunction(Void, "glVertexStream1iATI", [(GLenum, "stream"), (GLint, "x")]),
    GlFunction(Void, "glVertexStream1ivATI", [(GLenum, "stream"), (Pointer(Const(GLint)), "coords")]),
    GlFunction(Void, "glVertexStream1fATI", [(GLenum, "stream"), (GLfloat, "x")]),
    GlFunction(Void, "glVertexStream1fvATI", [(GLenum, "stream"), (Pointer(Const(GLfloat)), "coords")]),
    GlFunction(Void, "glVertexStream1dATI", [(GLenum, "stream"), (GLdouble, "x")]),
    GlFunction(Void, "glVertexStream1dvATI", [(GLenum, "stream"), (Pointer(Const(GLdouble)), "coords")]),
    GlFunction(Void, "glVertexStream2sATI", [(GLenum, "stream"), (GLshort, "x"), (GLshort, "y")]),
    GlFunction(Void, "glVertexStream2svATI", [(GLenum, "stream"), (Array(Const(GLshort), 2), "coords")]),
    GlFunction(Void, "glVertexStream2iATI", [(GLenum, "stream"), (GLint, "x"), (GLint, "y")]),
    GlFunction(Void, "glVertexStream2ivATI", [(GLenum, "stream"), (Array(Const(GLint), 2), "coords")]),
    GlFunction(Void, "glVertexStream2fATI", [(GLenum, "stream"), (GLfloat, "x"), (GLfloat, "y")]),
    GlFunction(Void, "glVertexStream2fvATI", [(GLenum, "stream"), (Array(Const(GLfloat), 2), "coords")]),
    GlFunction(Void, "glVertexStream2dATI", [(GLenum, "stream"), (GLdouble, "x"), (GLdouble, "y")]),
    GlFunction(Void, "glVertexStream2dvATI", [(GLenum, "stream"), (Array(Const(GLdouble), 2), "coords")]),
    GlFunction(Void, "glVertexStream3sATI", [(GLenum, "stream"), (GLshort, "x"), (GLshort, "y"), (GLshort, "z")]),
    GlFunction(Void, "glVertexStream3svATI", [(GLenum, "stream"), (Array(Const(GLshort), 3), "coords")]),
    GlFunction(Void, "glVertexStream3iATI", [(GLenum, "stream"), (GLint, "x"), (GLint, "y"), (GLint, "z")]),
    GlFunction(Void, "glVertexStream3ivATI", [(GLenum, "stream"), (Array(Const(GLint), 3), "coords")]),
    GlFunction(Void, "glVertexStream3fATI", [(GLenum, "stream"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glVertexStream3fvATI", [(GLenum, "stream"), (Array(Const(GLfloat), 3), "coords")]),
    GlFunction(Void, "glVertexStream3dATI", [(GLenum, "stream"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glVertexStream3dvATI", [(GLenum, "stream"), (Array(Const(GLdouble), 3), "coords")]),
    GlFunction(Void, "glVertexStream4sATI", [(GLenum, "stream"), (GLshort, "x"), (GLshort, "y"), (GLshort, "z"), (GLshort, "w")]),
    GlFunction(Void, "glVertexStream4svATI", [(GLenum, "stream"), (Array(Const(GLshort), 4), "coords")]),
    GlFunction(Void, "glVertexStream4iATI", [(GLenum, "stream"), (GLint, "x"), (GLint, "y"), (GLint, "z"), (GLint, "w")]),
    GlFunction(Void, "glVertexStream4ivATI", [(GLenum, "stream"), (Array(Const(GLint), 4), "coords")]),
    GlFunction(Void, "glVertexStream4fATI", [(GLenum, "stream"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glVertexStream4fvATI", [(GLenum, "stream"), (Array(Const(GLfloat), 4), "coords")]),
    GlFunction(Void, "glVertexStream4dATI", [(GLenum, "stream"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glVertexStream4dvATI", [(GLenum, "stream"), (Array(Const(GLdouble), 4), "coords")]),
    GlFunction(Void, "glNormalStream3bATI", [(GLenum, "stream"), (GLbyte, "nx"), (GLbyte, "ny"), (GLbyte, "nz")]),
    GlFunction(Void, "glNormalStream3bvATI", [(GLenum, "stream"), (Array(Const(GLbyte), 3), "coords")]),
    GlFunction(Void, "glNormalStream3sATI", [(GLenum, "stream"), (GLshort, "nx"), (GLshort, "ny"), (GLshort, "nz")]),
    GlFunction(Void, "glNormalStream3svATI", [(GLenum, "stream"), (Array(Const(GLshort), 3), "coords")]),
    GlFunction(Void, "glNormalStream3iATI", [(GLenum, "stream"), (GLint, "nx"), (GLint, "ny"), (GLint, "nz")]),
    GlFunction(Void, "glNormalStream3ivATI", [(GLenum, "stream"), (Array(Const(GLint), 3), "coords")]),
    GlFunction(Void, "glNormalStream3fATI", [(GLenum, "stream"), (GLfloat, "nx"), (GLfloat, "ny"), (GLfloat, "nz")]),
    GlFunction(Void, "glNormalStream3fvATI", [(GLenum, "stream"), (Array(Const(GLfloat), 3), "coords")]),
    GlFunction(Void, "glNormalStream3dATI", [(GLenum, "stream"), (GLdouble, "nx"), (GLdouble, "ny"), (GLdouble, "nz")]),
    GlFunction(Void, "glNormalStream3dvATI", [(GLenum, "stream"), (Array(Const(GLdouble), 3), "coords")]),
    GlFunction(Void, "glClientActiveVertexStreamATI", [(GLenum, "stream")]),
    GlFunction(Void, "glVertexBlendEnviATI", [(GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glVertexBlendEnvfATI", [(GLenum, "pname"), (GLfloat, "param")]),

    # GL_ATI_element_array
    GlFunction(Void, "glElementPointerATI", [(GLenum, "type"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glDrawElementArrayATI", [(GLenum_mode, "mode"), (GLsizei, "count")]),
    GlFunction(Void, "glDrawRangeElementArrayATI", [(GLenum_mode, "mode"), (GLuint, "start"), (GLuint, "end"), (GLsizei, "count")]),

    # GL_SUN_mesh_array
    GlFunction(Void, "glDrawMeshArraysSUN", [(GLenum_mode, "mode"), (GLint, "first"), (GLsizei, "count"), (GLsizei, "width")]),

    # GL_NV_occlusion_query
    GlFunction(Void, "glGenOcclusionQueriesNV", [(GLsizei, "n"), Out(Array(GLquery, "n"), "ids")]),
    GlFunction(Void, "glDeleteOcclusionQueriesNV", [(GLsizei, "n"), (Array(Const(GLquery), "n"), "ids")]),
    GlFunction(GLboolean, "glIsOcclusionQueryNV", [(GLquery, "id")], sideeffects=False),
    GlFunction(Void, "glBeginOcclusionQueryNV", [(GLquery, "id")]),
    GlFunction(Void, "glEndOcclusionQueryNV", []),
    GlFunction(Void, "glGetOcclusionQueryivNV", [(GLquery, "id"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetOcclusionQueryuivNV", [(GLquery, "id"), (GLenum, "pname"), Out(Array(GLuint, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_NV_point_sprite
    GlFunction(Void, "glPointParameteriNV", [(GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glPointParameterivNV", [(GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),

    # GL_EXT_stencil_two_side
    GlFunction(Void, "glActiveStencilFaceEXT", [(GLenum, "face")]),

    # GL_APPLE_element_array
    GlFunction(Void, "glElementPointerAPPLE", [(GLenum, "type"), (Blob(Const(GLvoid), "type"), "pointer")]),
    GlFunction(Void, "glDrawElementArrayAPPLE", [(GLenum_mode, "mode"), (GLint, "first"), (GLsizei, "count")]),
    GlFunction(Void, "glDrawRangeElementArrayAPPLE", [(GLenum_mode, "mode"), (GLuint, "start"), (GLuint, "end"), (GLint, "first"), (GLsizei, "count")]),
    GlFunction(Void, "glMultiDrawElementArrayAPPLE", [(GLenum_mode, "mode"), (Array(Const(GLint), "primcount"), "first"), (Array(Const(GLsizei), "primcount"), "count"), (GLsizei, "primcount")]),
    GlFunction(Void, "glMultiDrawRangeElementArrayAPPLE", [(GLenum_mode, "mode"), (GLuint, "start"), (GLuint, "end"), (Array(Const(GLint), "primcount"), "first"), (Array(Const(GLsizei), "primcount"), "count"), (GLsizei, "primcount")]),

    # GL_APPLE_fence
    GlFunction(Void, "glGenFencesAPPLE", [(GLsizei, "n"), Out(Array(GLfence, "n"), "fences")]),
    GlFunction(Void, "glDeleteFencesAPPLE", [(GLsizei, "n"), (Array(Const(GLfence), "n"), "fences")]),
    GlFunction(Void, "glSetFenceAPPLE", [(GLfence, "fence")]),
    GlFunction(GLboolean, "glIsFenceAPPLE", [(GLfence, "fence")], sideeffects=False),
    GlFunction(GLboolean, "glTestFenceAPPLE", [(GLfence, "fence")]),
    GlFunction(Void, "glFinishFenceAPPLE", [(GLfence, "fence")]),
    GlFunction(GLboolean, "glTestObjectAPPLE", [(GLenum, "object"), (GLuint, "name")]), # XXX: name needs swizzling
    GlFunction(Void, "glFinishObjectAPPLE", [(GLenum, "object"), (GLint, "name")]), # XXX: name needs swizzling

    # GL_APPLE_vertex_array_object
    GlFunction(Void, "glBindVertexArrayAPPLE", [(GLarrayAPPLE, "array")]),
    GlFunction(Void, "glDeleteVertexArraysAPPLE", [(GLsizei, "n"), (Array(Const(GLarrayAPPLE), "n"), "arrays")]),
    GlFunction(Void, "glGenVertexArraysAPPLE", [(GLsizei, "n"), Out(Array(GLarrayAPPLE, "n"), "arrays")]),
    GlFunction(GLboolean, "glIsVertexArrayAPPLE", [(GLarrayAPPLE, "array")], sideeffects=False),

    # GL_APPLE_vertex_array_range
    GlFunction(Void, "glVertexArrayRangeAPPLE", [(GLsizei, "length"), (GLpointer, "pointer")]),
    GlFunction(Void, "glFlushVertexArrayRangeAPPLE", [(GLsizei, "length"), (GLpointer, "pointer")]),
    GlFunction(Void, "glVertexArrayParameteriAPPLE", [(GLenum, "pname"), (GLint, "param")]),

    # GL_APPLE_flush_render
    GlFunction(Void, "glFlushRenderAPPLE", []),
    GlFunction(Void, "glFinishRenderAPPLE", []),
    GlFunction(Void, "glSwapAPPLE", []),

    # GL_ATI_draw_buffers
    GlFunction(Void, "glDrawBuffersATI", [(GLsizei, "n"), (Array(Const(GLenum), "n"), "bufs")]),

    # GL_NV_fragment_program
    GlFunction(Void, "glProgramNamedParameter4fNV", [(GLprogramARB, "id"), (GLsizei, "len"), (String(Const(GLubyte), "len"), "name"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glProgramNamedParameter4dNV", [(GLprogramARB, "id"), (GLsizei, "len"), (String(Const(GLubyte), "len"), "name"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glProgramNamedParameter4fvNV", [(GLprogramARB, "id"), (GLsizei, "len"), (String(Const(GLubyte), "len"), "name"), (Array(Const(GLfloat), 4), "v")]),
    GlFunction(Void, "glProgramNamedParameter4dvNV", [(GLprogramARB, "id"), (GLsizei, "len"), (String(Const(GLubyte), "len"), "name"), (Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glGetProgramNamedParameterdvNV", [(GLprogramARB, "id"), (GLsizei, "len"), (String(Const(GLubyte), "len"), "name"), Out(Array(GLdouble, 4), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramNamedParameterfvNV", [(GLprogramARB, "id"), (GLsizei, "len"), (String(Const(GLubyte), "len"), "name"), Out(Array(GLfloat, 4), "params")], sideeffects=False),

    # GL_NV_half_float
    GlFunction(Void, "glVertex2hNV", [(GLhalfNV, "x"), (GLhalfNV, "y")]),
    GlFunction(Void, "glVertex2hvNV", [(Array(Const(GLhalfNV), 2), "v")]),
    GlFunction(Void, "glVertex3hNV", [(GLhalfNV, "x"), (GLhalfNV, "y"), (GLhalfNV, "z")]),
    GlFunction(Void, "glVertex3hvNV", [(Array(Const(GLhalfNV), 3), "v")]),
    GlFunction(Void, "glVertex4hNV", [(GLhalfNV, "x"), (GLhalfNV, "y"), (GLhalfNV, "z"), (GLhalfNV, "w")]),
    GlFunction(Void, "glVertex4hvNV", [(Array(Const(GLhalfNV), 4), "v")]),
    GlFunction(Void, "glNormal3hNV", [(GLhalfNV, "nx"), (GLhalfNV, "ny"), (GLhalfNV, "nz")]),
    GlFunction(Void, "glNormal3hvNV", [(Array(Const(GLhalfNV), 3), "v")]),
    GlFunction(Void, "glColor3hNV", [(GLhalfNV, "red"), (GLhalfNV, "green"), (GLhalfNV, "blue")]),
    GlFunction(Void, "glColor3hvNV", [(Array(Const(GLhalfNV), 3), "v")]),
    GlFunction(Void, "glColor4hNV", [(GLhalfNV, "red"), (GLhalfNV, "green"), (GLhalfNV, "blue"), (GLhalfNV, "alpha")]),
    GlFunction(Void, "glColor4hvNV", [(Array(Const(GLhalfNV), 4), "v")]),
    GlFunction(Void, "glTexCoord1hNV", [(GLhalfNV, "s")]),
    GlFunction(Void, "glTexCoord1hvNV", [(Pointer(Const(GLhalfNV)), "v")]),
    GlFunction(Void, "glTexCoord2hNV", [(GLhalfNV, "s"), (GLhalfNV, "t")]),
    GlFunction(Void, "glTexCoord2hvNV", [(Array(Const(GLhalfNV), 2), "v")]),
    GlFunction(Void, "glTexCoord3hNV", [(GLhalfNV, "s"), (GLhalfNV, "t"), (GLhalfNV, "r")]),
    GlFunction(Void, "glTexCoord3hvNV", [(Array(Const(GLhalfNV), 3), "v")]),
    GlFunction(Void, "glTexCoord4hNV", [(GLhalfNV, "s"), (GLhalfNV, "t"), (GLhalfNV, "r"), (GLhalfNV, "q")]),
    GlFunction(Void, "glTexCoord4hvNV", [(Array(Const(GLhalfNV), 4), "v")]),
    GlFunction(Void, "glMultiTexCoord1hNV", [(GLenum, "target"), (GLhalfNV, "s")]),
    GlFunction(Void, "glMultiTexCoord1hvNV", [(GLenum, "target"), (Pointer(Const(GLhalfNV)), "v")]),
    GlFunction(Void, "glMultiTexCoord2hNV", [(GLenum, "target"), (GLhalfNV, "s"), (GLhalfNV, "t")]),
    GlFunction(Void, "glMultiTexCoord2hvNV", [(GLenum, "target"), (Array(Const(GLhalfNV), 2), "v")]),
    GlFunction(Void, "glMultiTexCoord3hNV", [(GLenum, "target"), (GLhalfNV, "s"), (GLhalfNV, "t"), (GLhalfNV, "r")]),
    GlFunction(Void, "glMultiTexCoord3hvNV", [(GLenum, "target"), (Array(Const(GLhalfNV), 3), "v")]),
    GlFunction(Void, "glMultiTexCoord4hNV", [(GLenum, "target"), (GLhalfNV, "s"), (GLhalfNV, "t"), (GLhalfNV, "r"), (GLhalfNV, "q")]),
    GlFunction(Void, "glMultiTexCoord4hvNV", [(GLenum, "target"), (Array(Const(GLhalfNV), 4), "v")]),
    GlFunction(Void, "glFogCoordhNV", [(GLhalfNV, "fog")]),
    GlFunction(Void, "glFogCoordhvNV", [(Pointer(Const(GLhalfNV)), "fog")]),
    GlFunction(Void, "glSecondaryColor3hNV", [(GLhalfNV, "red"), (GLhalfNV, "green"), (GLhalfNV, "blue")]),
    GlFunction(Void, "glSecondaryColor3hvNV", [(Array(Const(GLhalfNV), 3), "v")]),
    GlFunction(Void, "glVertexWeighthNV", [(GLhalfNV, "weight")]),
    GlFunction(Void, "glVertexWeighthvNV", [(Pointer(Const(GLhalfNV)), "weight")]),
    GlFunction(Void, "glVertexAttrib1hNV", [(GLuint, "index"), (GLhalfNV, "x")]),
    GlFunction(Void, "glVertexAttrib1hvNV", [(GLuint, "index"), (Pointer(Const(GLhalfNV)), "v")]),
    GlFunction(Void, "glVertexAttrib2hNV", [(GLuint, "index"), (GLhalfNV, "x"), (GLhalfNV, "y")]),
    GlFunction(Void, "glVertexAttrib2hvNV", [(GLuint, "index"), (Array(Const(GLhalfNV), 2), "v")]),
    GlFunction(Void, "glVertexAttrib3hNV", [(GLuint, "index"), (GLhalfNV, "x"), (GLhalfNV, "y"), (GLhalfNV, "z")]),
    GlFunction(Void, "glVertexAttrib3hvNV", [(GLuint, "index"), (Array(Const(GLhalfNV), 3), "v")]),
    GlFunction(Void, "glVertexAttrib4hNV", [(GLuint, "index"), (GLhalfNV, "x"), (GLhalfNV, "y"), (GLhalfNV, "z"), (GLhalfNV, "w")]),
    GlFunction(Void, "glVertexAttrib4hvNV", [(GLuint, "index"), (Array(Const(GLhalfNV), 4), "v")]),
    GlFunction(Void, "glVertexAttribs1hvNV", [(GLuint, "index"), (GLsizei, "n"), (Array(Const(GLhalfNV), "n"), "v")]),
    GlFunction(Void, "glVertexAttribs2hvNV", [(GLuint, "index"), (GLsizei, "n"), (Array(Const(GLhalfNV), "n"), "v")]),
    GlFunction(Void, "glVertexAttribs3hvNV", [(GLuint, "index"), (GLsizei, "n"), (Array(Const(GLhalfNV), "n"), "v")]),
    GlFunction(Void, "glVertexAttribs4hvNV", [(GLuint, "index"), (GLsizei, "n"), (Array(Const(GLhalfNV), "n"), "v")]),

    # GL_NV_pixel_data_range
    GlFunction(Void, "glPixelDataRangeNV", [(GLenum, "target"), (GLsizei, "length"), (OpaqueBlob(Const(GLvoid), "length"), "pointer")]),
    GlFunction(Void, "glFlushPixelDataRangeNV", [(GLenum, "target")]),

    # GL_NV_primitive_restart
    GlFunction(Void, "glPrimitiveRestartNV", []),
    GlFunction(Void, "glPrimitiveRestartIndexNV", [(GLuint, "index")]),

    # GL_ATI_map_object_buffer
    GlFunction(GLmap, "glMapObjectBufferATI", [(GLbuffer, "buffer")]),
    GlFunction(Void, "glUnmapObjectBufferATI", [(GLbuffer, "buffer")]),

    # GL_ATI_separate_stencil
    GlFunction(Void, "glStencilOpSeparateATI", [(GLenum, "face"), (GLenum, "sfail"), (GLenum, "dpfail"), (GLenum, "dppass")]),
    GlFunction(Void, "glStencilFuncSeparateATI", [(GLenum, "frontfunc"), (GLenum, "backfunc"), (GLint, "ref"), (GLuint, "mask")]),

    # GL_ATI_vertex_attrib_array_object
    GlFunction(Void, "glVertexAttribArrayObjectATI", [(GLuint, "index"), (GLint, "size"), (GLenum, "type"), (GLboolean, "normalized"), (GLsizei, "stride"), (GLuint, "buffer"), (GLuint, "offset")]),
    GlFunction(Void, "glGetVertexAttribArrayObjectfvATI", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLfloat, "pname"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribArrayObjectivATI", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLint, "pname"), "params")], sideeffects=False),

    # GL_EXT_depth_bounds_test
    GlFunction(Void, "glDepthBoundsEXT", [(GLclampd, "zmin"), (GLclampd, "zmax")]),

    # GL_EXT_blend_equation_separate
    GlFunction(Void, "glBlendEquationSeparateEXT", [(GLenum, "modeRGB"), (GLenum, "modeAlpha")]),

    # GL_EXT_framebuffer_object
    GlFunction(GLboolean, "glIsRenderbufferEXT", [(GLrenderbuffer, "renderbuffer")], sideeffects=False),
    GlFunction(Void, "glBindRenderbufferEXT", [(GLenum, "target"), (GLrenderbuffer, "renderbuffer")]),
    GlFunction(Void, "glDeleteRenderbuffersEXT", [(GLsizei, "n"), (Array(Const(GLrenderbuffer), "n"), "renderbuffers")]),
    GlFunction(Void, "glGenRenderbuffersEXT", [(GLsizei, "n"), Out(Array(GLrenderbuffer, "n"), "renderbuffers")]),
    GlFunction(Void, "glRenderbufferStorageEXT", [(GLenum, "target"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glGetRenderbufferParameterivEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(GLboolean, "glIsFramebufferEXT", [(GLframebuffer, "framebuffer")], sideeffects=False),
    GlFunction(Void, "glBindFramebufferEXT", [(GLenum, "target"), (GLframebuffer, "framebuffer")]),
    GlFunction(Void, "glDeleteFramebuffersEXT", [(GLsizei, "n"), (Array(Const(GLframebuffer), "n"), "framebuffers")]),
    GlFunction(Void, "glGenFramebuffersEXT", [(GLsizei, "n"), Out(Array(GLframebuffer, "n"), "framebuffers")]),
    GlFunction(GLenum, "glCheckFramebufferStatusEXT", [(GLenum, "target")]),
    GlFunction(Void, "glFramebufferTexture1DEXT", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "textarget"), (GLtexture, "texture"), (GLint, "level")]),
    GlFunction(Void, "glFramebufferTexture2DEXT", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "textarget"), (GLtexture, "texture"), (GLint, "level")]),
    GlFunction(Void, "glFramebufferTexture3DEXT", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "textarget"), (GLtexture, "texture"), (GLint, "level"), (GLint, "zoffset")]),
    GlFunction(Void, "glFramebufferRenderbufferEXT", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "renderbuffertarget"), (GLrenderbuffer, "renderbuffer")]),
    GlFunction(Void, "glGetFramebufferAttachmentParameterivEXT", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGenerateMipmapEXT", [(GLenum, "target")]),

    # GL_GREMEDY_string_marker
    GlFunction(Void, "glStringMarkerGREMEDY", [(GLsizei, "len"), (String(Const(GLvoid), "len > 0 ? len : strlen((const char *)string)"), "string")], sideeffects=True),

    # GL_EXT_stencil_clear_tag
    GlFunction(Void, "glStencilClearTagEXT", [(GLsizei, "stencilTagBits"), (GLuint, "stencilClearTag")]),

    # GL_EXT_framebuffer_blit
    GlFunction(Void, "glBlitFramebufferEXT", [(GLint, "srcX0"), (GLint, "srcY0"), (GLint, "srcX1"), (GLint, "srcY1"), (GLint, "dstX0"), (GLint, "dstY0"), (GLint, "dstX1"), (GLint, "dstY1"), (GLbitfield_attrib, "mask"), (GLenum, "filter")]),

    # GL_EXT_framebuffer_multisample
    GlFunction(Void, "glRenderbufferStorageMultisampleEXT", [(GLenum, "target"), (GLsizei, "samples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),

    # GL_EXT_timer_query
    GlFunction(Void, "glGetQueryObjecti64vEXT", [(GLquery, "id"), (GLenum, "pname"), Out(Array(GLint64EXT, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetQueryObjectui64vEXT", [(GLquery, "id"), (GLenum, "pname"), Out(Array(GLuint64EXT, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_EXT_gpu_program_parameters
    GlFunction(Void, "glProgramEnvParameters4fvEXT", [(GLenum, "target"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLfloat), "count*4"), "params")]),
    GlFunction(Void, "glProgramLocalParameters4fvEXT", [(GLenum, "target"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLfloat), "count*4"), "params")]),

    # GL_APPLE_flush_buffer_range
    GlFunction(Void, "glBufferParameteriAPPLE", [(GLenum, "target"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glFlushMappedBufferRangeAPPLE", [(GLenum, "target"), (GLintptr, "offset"), (GLsizeiptr, "size")]),

    # GL_NV_gpu_program4
    GlFunction(Void, "glProgramLocalParameterI4iNV", [(GLenum, "target"), (GLuint, "index"), (GLint, "x"), (GLint, "y"), (GLint, "z"), (GLint, "w")]),
    GlFunction(Void, "glProgramLocalParameterI4ivNV", [(GLenum, "target"), (GLuint, "index"), (Array(Const(GLint), 4), "params")]),
    GlFunction(Void, "glProgramLocalParametersI4ivNV", [(GLenum, "target"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLint), "count*4"), "params")]),
    GlFunction(Void, "glProgramLocalParameterI4uiNV", [(GLenum, "target"), (GLuint, "index"), (GLuint, "x"), (GLuint, "y"), (GLuint, "z"), (GLuint, "w")]),
    GlFunction(Void, "glProgramLocalParameterI4uivNV", [(GLenum, "target"), (GLuint, "index"), (Array(Const(GLuint), 4), "params")]),
    GlFunction(Void, "glProgramLocalParametersI4uivNV", [(GLenum, "target"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLuint), "count*4"), "params")]),
    GlFunction(Void, "glProgramEnvParameterI4iNV", [(GLenum, "target"), (GLuint, "index"), (GLint, "x"), (GLint, "y"), (GLint, "z"), (GLint, "w")]),
    GlFunction(Void, "glProgramEnvParameterI4ivNV", [(GLenum, "target"), (GLuint, "index"), (Array(Const(GLint), 4), "params")]),
    GlFunction(Void, "glProgramEnvParametersI4ivNV", [(GLenum, "target"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLint), "count*4"), "params")]),
    GlFunction(Void, "glProgramEnvParameterI4uiNV", [(GLenum, "target"), (GLuint, "index"), (GLuint, "x"), (GLuint, "y"), (GLuint, "z"), (GLuint, "w")]),
    GlFunction(Void, "glProgramEnvParameterI4uivNV", [(GLenum, "target"), (GLuint, "index"), (Array(Const(GLuint), 4), "params")]),
    GlFunction(Void, "glProgramEnvParametersI4uivNV", [(GLenum, "target"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLuint), "count*4"), "params")]),
    GlFunction(Void, "glGetProgramLocalParameterIivNV", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLint, 4), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramLocalParameterIuivNV", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLuint, 4), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramEnvParameterIivNV", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLint, 4), "params")], sideeffects=False),
    GlFunction(Void, "glGetProgramEnvParameterIuivNV", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLuint, 4), "params")], sideeffects=False),

    # GL_NV_geometry_program4
    GlFunction(Void, "glProgramVertexLimitNV", [(GLenum, "target"), (GLint, "limit")]),
    GlFunction(Void, "glFramebufferTextureEXT", [(GLenum, "target"), (GLenum, "attachment"), (GLtexture, "texture"), (GLint, "level")]),
    GlFunction(Void, "glFramebufferTextureLayerEXT", [(GLenum, "target"), (GLenum, "attachment"), (GLtexture, "texture"), (GLint, "level"), (GLint, "layer")]),
    GlFunction(Void, "glFramebufferTextureFaceEXT", [(GLenum, "target"), (GLenum, "attachment"), (GLtexture, "texture"), (GLint, "level"), (GLenum, "face")]),

    # GL_EXT_geometry_shader4
    GlFunction(Void, "glProgramParameteriEXT", [(GLprogram, "program"), (GLenum, "pname"), (GLint, "value")]),

    # GL_NV_vertex_program4
    GlFunction(Void, "glVertexAttribI1iEXT", [(GLuint, "index"), (GLint, "x")]),
    GlFunction(Void, "glVertexAttribI2iEXT", [(GLuint, "index"), (GLint, "x"), (GLint, "y")]),
    GlFunction(Void, "glVertexAttribI3iEXT", [(GLuint, "index"), (GLint, "x"), (GLint, "y"), (GLint, "z")]),
    GlFunction(Void, "glVertexAttribI4iEXT", [(GLuint, "index"), (GLint, "x"), (GLint, "y"), (GLint, "z"), (GLint, "w")]),
    GlFunction(Void, "glVertexAttribI1uiEXT", [(GLuint, "index"), (GLuint, "x")]),
    GlFunction(Void, "glVertexAttribI2uiEXT", [(GLuint, "index"), (GLuint, "x"), (GLuint, "y")]),
    GlFunction(Void, "glVertexAttribI3uiEXT", [(GLuint, "index"), (GLuint, "x"), (GLuint, "y"), (GLuint, "z")]),
    GlFunction(Void, "glVertexAttribI4uiEXT", [(GLuint, "index"), (GLuint, "x"), (GLuint, "y"), (GLuint, "z"), (GLuint, "w")]),
    GlFunction(Void, "glVertexAttribI1ivEXT", [(GLuint, "index"), (Pointer(Const(GLint)), "v")]),
    GlFunction(Void, "glVertexAttribI2ivEXT", [(GLuint, "index"), (Array(Const(GLint), 2), "v")]),
    GlFunction(Void, "glVertexAttribI3ivEXT", [(GLuint, "index"), (Array(Const(GLint), 3), "v")]),
    GlFunction(Void, "glVertexAttribI4ivEXT", [(GLuint, "index"), (Array(Const(GLint), 4), "v")]),
    GlFunction(Void, "glVertexAttribI1uivEXT", [(GLuint, "index"), (Pointer(Const(GLuint)), "v")]),
    GlFunction(Void, "glVertexAttribI2uivEXT", [(GLuint, "index"), (Array(Const(GLuint), 2), "v")]),
    GlFunction(Void, "glVertexAttribI3uivEXT", [(GLuint, "index"), (Array(Const(GLuint), 3), "v")]),
    GlFunction(Void, "glVertexAttribI4uivEXT", [(GLuint, "index"), (Array(Const(GLuint), 4), "v")]),
    GlFunction(Void, "glVertexAttribI4bvEXT", [(GLuint, "index"), (Array(Const(GLbyte), 4), "v")]),
    GlFunction(Void, "glVertexAttribI4svEXT", [(GLuint, "index"), (Array(Const(GLshort), 4), "v")]),
    GlFunction(Void, "glVertexAttribI4ubvEXT", [(GLuint, "index"), (Array(Const(GLubyte), 4), "v")]),
    GlFunction(Void, "glVertexAttribI4usvEXT", [(GLuint, "index"), (Array(Const(GLushort), 4), "v")]),
    GlFunction(Void, "glVertexAttribIPointerEXT", [(GLuint, "index"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glGetVertexAttribIivEXT", [(GLuint, "index"), (GLenum, "pname"), Out(Pointer(GLint), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribIuivEXT", [(GLuint, "index"), (GLenum, "pname"), Out(Pointer(GLuint), "params")], sideeffects=False),

    # GL_EXT_gpu_shader4
    GlFunction(Void, "glGetUniformuivEXT", [(GLprogram, "program"), (GLlocation, "location"), Out(OpaqueArray(GLuint, "_glGetUniformuivEXT_size(program, location)"), "params")], sideeffects=False),
    GlFunction(Void, "glBindFragDataLocationEXT", [(GLprogram, "program"), (GLuint, "color"), (GLstringConst, "name")]),
    GlFunction(GLlocation, "glGetFragDataLocationEXT", [(GLprogram, "program"), (GLstringConst, "name")]),
    GlFunction(Void, "glUniform1uiEXT", [(GLlocation, "location"), (GLuint, "v0")]),
    GlFunction(Void, "glUniform2uiEXT", [(GLlocation, "location"), (GLuint, "v0"), (GLuint, "v1")]),
    GlFunction(Void, "glUniform3uiEXT", [(GLlocation, "location"), (GLuint, "v0"), (GLuint, "v1"), (GLuint, "v2")]),
    GlFunction(Void, "glUniform4uiEXT", [(GLlocation, "location"), (GLuint, "v0"), (GLuint, "v1"), (GLuint, "v2"), (GLuint, "v3")]),
    GlFunction(Void, "glUniform1uivEXT", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count"), "value")]),
    GlFunction(Void, "glUniform2uivEXT", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count*2"), "value")]),
    GlFunction(Void, "glUniform3uivEXT", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count*3"), "value")]),
    GlFunction(Void, "glUniform4uivEXT", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count*4"), "value")]),

    # GL_EXT_draw_instanced
    GlFunction(Void, "glDrawArraysInstancedEXT", [(GLenum_mode, "mode"), (GLint, "start"), (GLsizei, "count"), (GLsizei, "primcount")]),
    GlFunction(Void, "glDrawElementsInstancedEXT", [(GLenum_mode, "mode"), (GLsizei, "count"), (GLenum, "type"), (GLindexBuffer("count", "type"), "indices"), (GLsizei, "primcount")]),

    # GL_EXT_texture_buffer_object
    GlFunction(Void, "glTexBufferEXT", [(GLenum, "target"), (GLenum, "internalformat"), (GLbuffer, "buffer")]),

    # GL_NV_depth_buffer_float
    GlFunction(Void, "glDepthRangedNV", [(GLdouble, "zNear"), (GLdouble, "zFar")]),
    GlFunction(Void, "glClearDepthdNV", [(GLdouble, "depth")]),
    GlFunction(Void, "glDepthBoundsdNV", [(GLdouble, "zmin"), (GLdouble, "zmax")]),

    # GL_NV_framebuffer_multisample_coverage
    GlFunction(Void, "glRenderbufferStorageMultisampleCoverageNV", [(GLenum, "target"), (GLsizei, "coverageSamples"), (GLsizei, "colorSamples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),

    # GL_NV_parameter_buffer_object
    GlFunction(Void, "glProgramBufferParametersfvNV", [(GLenum, "target"), (GLbuffer, "buffer"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLfloat), "count"), "params")]),
    GlFunction(Void, "glProgramBufferParametersIivNV", [(GLenum, "target"), (GLbuffer, "buffer"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLint), "count"), "params")]),
    GlFunction(Void, "glProgramBufferParametersIuivNV", [(GLenum, "target"), (GLbuffer, "buffer"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLuint), "count"), "params")]),

    # GL_EXT_draw_buffers2
    GlFunction(Void, "glColorMaskIndexedEXT", [(GLuint, "index"), (GLboolean, "r"), (GLboolean, "g"), (GLboolean, "b"), (GLboolean, "a")]),
    GlFunction(Void, "glGetBooleanIndexedvEXT", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLboolean, "_gl_param_size(target)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetIntegerIndexedvEXT", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLint, "_gl_param_size(target)"), "data")], sideeffects=False),
    GlFunction(Void, "glEnableIndexedEXT", [(GLenum, "target"), (GLuint, "index")]),
    GlFunction(Void, "glDisableIndexedEXT", [(GLenum, "target"), (GLuint, "index")]),
    GlFunction(GLboolean, "glIsEnabledIndexedEXT", [(GLenum, "target"), (GLuint, "index")], sideeffects=False),

    # GL_NV_transform_feedback
    GlFunction(Void, "glBeginTransformFeedbackNV", [(GLenum_mode, "primitiveMode")]),
    GlFunction(Void, "glEndTransformFeedbackNV", []),
    GlFunction(Void, "glTransformFeedbackAttribsNV", [(GLuint, "count"), (Array(Const(GLint), "count*3"), "attribs"), (GLenum, "bufferMode")]),
    GlFunction(Void, "glBindBufferRangeNV", [(GLenum, "target"), (GLuint, "index"), (GLbuffer, "buffer"), (GLintptr, "offset"), (GLsizeiptr, "size")]),
    GlFunction(Void, "glBindBufferOffsetNV", [(GLenum, "target"), (GLuint, "index"), (GLbuffer, "buffer"), (GLintptr, "offset")]),
    GlFunction(Void, "glBindBufferBaseNV", [(GLenum, "target"), (GLuint, "index"), (GLbuffer, "buffer")]),
    GlFunction(Void, "glTransformFeedbackVaryingsNV", [(GLprogram, "program"), (GLsizei, "count"), (Array(Const(GLint), "count"), "locations"), (GLenum, "bufferMode")]),
    GlFunction(Void, "glActiveVaryingNV", [(GLprogram, "program"), (GLstringConst, "name")]),
    GlFunction(GLlocation, "glGetVaryingLocationNV", [(GLprogram, "program"), (GLstringConst, "name")]),
    GlFunction(Void, "glGetActiveVaryingNV", [(GLprogram, "program"), (GLuint, "index"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), Out(Pointer(GLsizei), "size"), Out(Pointer(GLenum), "type"), OutGlString(GLchar, "length", "name")], sideeffects=False),
    GlFunction(Void, "glGetTransformFeedbackVaryingNV", [(GLprogram, "program"), (GLuint, "index"), Out(Pointer(GLlocation), "location")], sideeffects=False),
    GlFunction(Void, "glTransformFeedbackStreamAttribsNV", [(GLsizei, "count"), (Array(Const(GLint), "count"), "attribs"), (GLsizei, "nbuffers"), (Array(Const(GLint), "nbuffers"), "bufstreams"), (GLenum, "bufferMode")]),

    # GL_EXT_bindable_uniform
    GlFunction(Void, "glUniformBufferEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLbuffer, "buffer")]),
    GlFunction(GLint, "glGetUniformBufferSizeEXT", [(GLprogram, "program"), (GLlocation, "location")]),
    GlFunction(GLintptr, "glGetUniformOffsetEXT", [(GLprogram, "program"), (GLlocation, "location")]),

    # GL_EXT_texture_integer
    GlFunction(Void, "glTexParameterIivEXT", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTexParameterIuivEXT", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLuint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glGetTexParameterIivEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTexParameterIuivEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLuint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glClearColorIiEXT", [(GLint, "red"), (GLint, "green"), (GLint, "blue"), (GLint, "alpha")]),
    GlFunction(Void, "glClearColorIuiEXT", [(GLuint, "red"), (GLuint, "green"), (GLuint, "blue"), (GLuint, "alpha")]),

    # GL_GREMEDY_frame_terminator
    GlFunction(Void, "glFrameTerminatorGREMEDY", []),

    # GL_NV_conditional_render
    GlFunction(Void, "glBeginConditionalRenderNV", [(GLquery, "id"), (GLenum, "mode")]),
    GlFunction(Void, "glEndConditionalRenderNV", []),

    # GL_NV_present_video
    GlFunction(Void, "glPresentFrameKeyedNV", [(GLuint, "video_slot"), (GLuint64EXT, "minPresentTime"), (GLuint, "beginPresentTimeId"), (GLuint, "presentDurationId"), (GLenum, "type"), (GLenum, "target0"), (GLuint, "fill0"), (GLuint, "key0"), (GLenum, "target1"), (GLuint, "fill1"), (GLuint, "key1")]),
    GlFunction(Void, "glPresentFrameDualFillNV", [(GLuint, "video_slot"), (GLuint64EXT, "minPresentTime"), (GLuint, "beginPresentTimeId"), (GLuint, "presentDurationId"), (GLenum, "type"), (GLenum, "target0"), (GLuint, "fill0"), (GLenum, "target1"), (GLuint, "fill1"), (GLenum, "target2"), (GLuint, "fill2"), (GLenum, "target3"), (GLuint, "fill3")]),
    GlFunction(Void, "glGetVideoivNV", [(GLuint, "video_slot"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVideouivNV", [(GLuint, "video_slot"), (GLenum, "pname"), Out(Array(GLuint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVideoi64vNV", [(GLuint, "video_slot"), (GLenum, "pname"), Out(Array(GLint64EXT, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVideoui64vNV", [(GLuint, "video_slot"), (GLenum, "pname"), Out(Array(GLuint64EXT, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_EXT_transform_feedback
    GlFunction(Void, "glBeginTransformFeedbackEXT", [(GLenum_mode, "primitiveMode")]),
    GlFunction(Void, "glEndTransformFeedbackEXT", []),
    GlFunction(Void, "glBindBufferRangeEXT", [(GLenum, "target"), (GLuint, "index"), (GLbuffer, "buffer"), (GLintptr, "offset"), (GLsizeiptr, "size")]),
    GlFunction(Void, "glBindBufferOffsetEXT", [(GLenum, "target"), (GLuint, "index"), (GLbuffer, "buffer"), (GLintptr, "offset")]),
    GlFunction(Void, "glBindBufferBaseEXT", [(GLenum, "target"), (GLuint, "index"), (GLbuffer, "buffer")]),
    GlFunction(Void, "glTransformFeedbackVaryingsEXT", [(GLprogram, "program"), (GLsizei, "count"), (Array(Const(GLstringConst), "count"), "varyings"), (GLenum, "bufferMode")]),
    GlFunction(Void, "glGetTransformFeedbackVaryingEXT", [(GLprogram, "program"), (GLuint, "index"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), Out(Pointer(GLsizei), "size"), Out(Pointer(GLenum), "type"), OutGlString(GLchar, "length", "name")], sideeffects=False),

    # GL_EXT_direct_state_access
    GlFunction(Void, "glClientAttribDefaultEXT", [(GLbitfield_client_attrib, "mask")]),
    GlFunction(Void, "glPushClientAttribDefaultEXT", [(GLbitfield_client_attrib, "mask")]),
    GlFunction(Void, "glMatrixLoadfEXT", [(GLenum, "mode"), (Array(Const(GLfloat), 16), "m")]),
    GlFunction(Void, "glMatrixLoaddEXT", [(GLenum, "mode"), (Array(Const(GLdouble), 16), "m")]),
    GlFunction(Void, "glMatrixMultfEXT", [(GLenum, "mode"), (Array(Const(GLfloat), 16), "m")]),
    GlFunction(Void, "glMatrixMultdEXT", [(GLenum, "mode"), (Array(Const(GLdouble), 16), "m")]),
    GlFunction(Void, "glMatrixLoadIdentityEXT", [(GLenum, "mode")]),
    GlFunction(Void, "glMatrixRotatefEXT", [(GLenum, "mode"), (GLfloat, "angle"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glMatrixRotatedEXT", [(GLenum, "mode"), (GLdouble, "angle"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glMatrixScalefEXT", [(GLenum, "mode"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glMatrixScaledEXT", [(GLenum, "mode"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glMatrixTranslatefEXT", [(GLenum, "mode"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    GlFunction(Void, "glMatrixTranslatedEXT", [(GLenum, "mode"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glMatrixFrustumEXT", [(GLenum, "mode"), (GLdouble, "left"), (GLdouble, "right"), (GLdouble, "bottom"), (GLdouble, "top"), (GLdouble, "zNear"), (GLdouble, "zFar")]),
    GlFunction(Void, "glMatrixOrthoEXT", [(GLenum, "mode"), (GLdouble, "left"), (GLdouble, "right"), (GLdouble, "bottom"), (GLdouble, "top"), (GLdouble, "zNear"), (GLdouble, "zFar")]),
    GlFunction(Void, "glMatrixPopEXT", [(GLenum, "mode")]),
    GlFunction(Void, "glMatrixPushEXT", [(GLenum, "mode")]),
    GlFunction(Void, "glMatrixLoadTransposefEXT", [(GLenum, "mode"), (Array(Const(GLfloat), 16), "m")]),
    GlFunction(Void, "glMatrixLoadTransposedEXT", [(GLenum, "mode"), (Array(Const(GLdouble), 16), "m")]),
    GlFunction(Void, "glMatrixMultTransposefEXT", [(GLenum, "mode"), (Array(Const(GLfloat), 16), "m")]),
    GlFunction(Void, "glMatrixMultTransposedEXT", [(GLenum, "mode"), (Array(Const(GLdouble), 16), "m")]),
    GlFunction(Void, "glTextureParameterfEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glTextureParameterfvEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTextureParameteriEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glTextureParameterivEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTextureImage1DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLenum_int, "internalformat"), (GLsizei, "width"), (GLint, "border"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTextureImage1DEXT_size(format, type, width)"), "pixels")]),
    GlFunction(Void, "glTextureImage2DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLenum_int, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLint, "border"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTextureImage2DEXT_size(format, type, width, height)"), "pixels")]),
    GlFunction(Void, "glTextureSubImage1DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLsizei, "width"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTextureSubImage1DEXT_size(format, type, width)"), "pixels")]),
    GlFunction(Void, "glTextureSubImage2DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTextureSubImage2DEXT_size(format, type, width, height)"), "pixels")]),
    GlFunction(Void, "glCopyTextureImage1DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLint, "border")]),
    GlFunction(Void, "glCopyTextureImage2DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height"), (GLint, "border")]),
    GlFunction(Void, "glCopyTextureSubImage1DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "x"), (GLint, "y"), (GLsizei, "width")]),
    GlFunction(Void, "glCopyTextureSubImage2DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glGetTextureImageEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLenum, "format"), (GLenum, "type"), Out(OpaqueBlob(GLvoid, "_glGetTextureImageEXT_size(target, level, format, type)"), "pixels")]),
    GlFunction(Void, "glGetTextureParameterfvEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTextureParameterivEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTextureLevelParameterfvEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTextureLevelParameterivEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glTextureImage3DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLenum_int, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLint, "border"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTextureImage3DEXT_size(format, type, width, height, depth)"), "pixels")]),
    GlFunction(Void, "glTextureSubImage3DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTextureSubImage3DEXT_size(format, type, width, height, depth)"), "pixels")]),
    GlFunction(Void, "glCopyTextureSubImage3DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glMultiTexParameterfEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glMultiTexParameterfvEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glMultiTexParameteriEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glMultiTexParameterivEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glMultiTexImage1DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLenum_int, "internalformat"), (GLsizei, "width"), (GLint, "border"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glMultiTexImage1DEXT_size(format, type, width)"), "pixels")]),
    GlFunction(Void, "glMultiTexImage2DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLenum_int, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLint, "border"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glMultiTexImage2DEXT_size(format, type, width, height)"), "pixels")]),
    GlFunction(Void, "glMultiTexSubImage1DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLsizei, "width"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glMultiTexSubImage1DEXT_size(format, type, width)"), "pixels")]),
    GlFunction(Void, "glMultiTexSubImage2DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glMultiTexSubImage2DEXT_size(format, type, width, height)"), "pixels")]),
    GlFunction(Void, "glCopyMultiTexImage1DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLint, "border")]),
    GlFunction(Void, "glCopyMultiTexImage2DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height"), (GLint, "border")]),
    GlFunction(Void, "glCopyMultiTexSubImage1DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "x"), (GLint, "y"), (GLsizei, "width")]),
    GlFunction(Void, "glCopyMultiTexSubImage2DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glGetMultiTexImageEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLenum, "format"), (GLenum, "type"), Out(OpaqueBlob(GLvoid, "_glGetMultiTexImageEXT_size(target, level, format, type)"), "pixels")]),
    GlFunction(Void, "glGetMultiTexParameterfvEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMultiTexParameterivEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMultiTexLevelParameterfvEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMultiTexLevelParameterivEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glMultiTexImage3DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLenum_int, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLint, "border"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glMultiTexImage3DEXT_size(format, type, width, height, depth)"), "pixels")]),
    GlFunction(Void, "glMultiTexSubImage3DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glMultiTexSubImage3DEXT_size(format, type, width, height, depth)"), "pixels")]),
    GlFunction(Void, "glCopyMultiTexSubImage3DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glBindMultiTextureEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLtexture, "texture")]),
    GlFunction(Void, "glEnableClientStateIndexedEXT", [(GLenum, "array"), (GLuint, "index")]),
    GlFunction(Void, "glDisableClientStateIndexedEXT", [(GLenum, "array"), (GLuint, "index")]),
    GlFunction(Void, "glEnableClientStateiEXT", [(GLenum, "array"), (GLuint, "index")]),
    GlFunction(Void, "glDisableClientStateiEXT", [(GLenum, "array"), (GLuint, "index")]),
    GlFunction(Void, "glMultiTexCoordPointerEXT", [(GLenum, "texunit"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glMultiTexEnvfEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glMultiTexEnvfvEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glMultiTexEnviEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glMultiTexEnvivEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glMultiTexGendEXT", [(GLenum, "texunit"), (GLenum, "coord"), (GLenum, "pname"), (GLdouble, "param")]),
    GlFunction(Void, "glMultiTexGendvEXT", [(GLenum, "texunit"), (GLenum, "coord"), (GLenum, "pname"), (Array(Const(GLdouble), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glMultiTexGenfEXT", [(GLenum, "texunit"), (GLenum, "coord"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glMultiTexGenfvEXT", [(GLenum, "texunit"), (GLenum, "coord"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glMultiTexGeniEXT", [(GLenum, "texunit"), (GLenum, "coord"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glMultiTexGenivEXT", [(GLenum, "texunit"), (GLenum, "coord"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glGetMultiTexEnvfvEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMultiTexEnvivEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMultiTexGendvEXT", [(GLenum, "texunit"), (GLenum, "coord"), (GLenum, "pname"), Out(Array(GLdouble, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMultiTexGenfvEXT", [(GLenum, "texunit"), (GLenum, "coord"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMultiTexGenivEXT", [(GLenum, "texunit"), (GLenum, "coord"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetFloatIndexedvEXT", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLfloat, "_gl_param_size(target)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetDoubleIndexedvEXT", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLdouble, "_gl_param_size(target)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetPointerIndexedvEXT", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLpointer, "_gl_param_size(target)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetFloati_vEXT", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLfloat, "_gl_param_size(target)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetDoublei_vEXT", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLdouble, "_gl_param_size(target)"), "data")], sideeffects=False),
    GlFunction(Void, "glGetPointeri_vEXT", [(GLenum, "target"), (GLuint, "index"), Out(Array(GLpointer, "_gl_param_size(target)"), "data")], sideeffects=False),
    GlFunction(Void, "glCompressedTextureImage3DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLint, "border"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "bits")]),
    GlFunction(Void, "glCompressedTextureImage2DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLint, "border"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "bits")]),
    GlFunction(Void, "glCompressedTextureImage1DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLint, "border"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "bits")]),
    GlFunction(Void, "glCompressedTextureSubImage3DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLenum, "format"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "bits")]),
    GlFunction(Void, "glCompressedTextureSubImage2DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "bits")]),
    GlFunction(Void, "glCompressedTextureSubImage1DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLsizei, "width"), (GLenum, "format"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "bits")]),
    GlFunction(Void, "glGetCompressedTextureImageEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLint, "lod"), Out(OpaqueBlob(GLvoid, "_glGetCompressedTextureImageEXT_size(target, lod)"), "img")]),
    GlFunction(Void, "glCompressedMultiTexImage3DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLint, "border"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "bits")]),
    GlFunction(Void, "glCompressedMultiTexImage2DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLint, "border"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "bits")]),
    GlFunction(Void, "glCompressedMultiTexImage1DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLint, "border"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "bits")]),
    GlFunction(Void, "glCompressedMultiTexSubImage3DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLenum, "format"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "bits")]),
    GlFunction(Void, "glCompressedMultiTexSubImage2DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLenum, "format"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "bits")]),
    GlFunction(Void, "glCompressedMultiTexSubImage1DEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLsizei, "width"), (GLenum, "format"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "bits")]),
    GlFunction(Void, "glGetCompressedMultiTexImageEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLint, "lod"), Out(OpaqueBlob(GLvoid, "_glGetCompressedMultiTexImageEXT_size(target, lod)"), "img")]),
    GlFunction(Void, "glNamedProgramStringEXT", [(GLprogram, "program"), (GLenum, "target"), (GLenum, "format"), (GLsizei, "len"), (String(Const(GLvoid), "len"), "string")]),
    GlFunction(Void, "glNamedProgramLocalParameter4dEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glNamedProgramLocalParameter4dvEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), (Array(Const(GLdouble), 4), "params")]),
    GlFunction(Void, "glNamedProgramLocalParameter4fEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    GlFunction(Void, "glNamedProgramLocalParameter4fvEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), (Array(Const(GLfloat), 4), "params")]),
    GlFunction(Void, "glGetNamedProgramLocalParameterdvEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), Out(Array(GLdouble, 4), "params")], sideeffects=False),
    GlFunction(Void, "glGetNamedProgramLocalParameterfvEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), Out(Array(GLfloat, 4), "params")], sideeffects=False),
    GlFunction(Void, "glGetNamedProgramivEXT", [(GLprogram, "program"), (GLenum, "target"), (GLenum, "pname"), Out(Pointer(GLint), "params")], sideeffects=False),
    GlFunction(Void, "glGetNamedProgramStringEXT", [(GLprogram, "program"), (GLenum, "target"), (GLenum, "pname"), Out(OpaqueBlob(GLvoid, "_glGetNamedProgramStringEXT_size(program,pname)"), "string")], sideeffects=False),
    GlFunction(Void, "glNamedProgramLocalParameters4fvEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLfloat), "count*4"), "params")]),
    GlFunction(Void, "glNamedProgramLocalParameterI4iEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), (GLint, "x"), (GLint, "y"), (GLint, "z"), (GLint, "w")]),
    GlFunction(Void, "glNamedProgramLocalParameterI4ivEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), (Array(Const(GLint), 4), "params")]),
    GlFunction(Void, "glNamedProgramLocalParametersI4ivEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLint), "count*4"), "params")]),
    GlFunction(Void, "glNamedProgramLocalParameterI4uiEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), (GLuint, "x"), (GLuint, "y"), (GLuint, "z"), (GLuint, "w")]),
    GlFunction(Void, "glNamedProgramLocalParameterI4uivEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), (Array(Const(GLuint), 4), "params")]),
    GlFunction(Void, "glNamedProgramLocalParametersI4uivEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), (GLsizei, "count"), (Array(Const(GLuint), "count*4"), "params")]),
    GlFunction(Void, "glGetNamedProgramLocalParameterIivEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), Out(Array(GLint, 4), "params")], sideeffects=False),
    GlFunction(Void, "glGetNamedProgramLocalParameterIuivEXT", [(GLprogram, "program"), (GLenum, "target"), (GLuint, "index"), Out(Array(GLuint, 4), "params")], sideeffects=False),
    GlFunction(Void, "glTextureParameterIivEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTextureParameterIuivEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLenum, "pname"), (Array(Const(GLuint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glGetTextureParameterIivEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTextureParameterIuivEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLenum, "pname"), Out(Array(GLuint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glMultiTexParameterIivEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glMultiTexParameterIuivEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), (Array(Const(GLuint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glGetMultiTexParameterIivEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMultiTexParameterIuivEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "pname"), Out(Array(GLuint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glProgramUniform1fEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLfloat, "v0")]),
    GlFunction(Void, "glProgramUniform2fEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLfloat, "v0"), (GLfloat, "v1")]),
    GlFunction(Void, "glProgramUniform3fEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLfloat, "v0"), (GLfloat, "v1"), (GLfloat, "v2")]),
    GlFunction(Void, "glProgramUniform4fEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLfloat, "v0"), (GLfloat, "v1"), (GLfloat, "v2"), (GLfloat, "v3")]),
    GlFunction(Void, "glProgramUniform1iEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLint, "v0")]),
    GlFunction(Void, "glProgramUniform2iEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLint, "v0"), (GLint, "v1")]),
    GlFunction(Void, "glProgramUniform3iEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLint, "v0"), (GLint, "v1"), (GLint, "v2")]),
    GlFunction(Void, "glProgramUniform4iEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLint, "v0"), (GLint, "v1"), (GLint, "v2"), (GLint, "v3")]),
    GlFunction(Void, "glProgramUniform1fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count"), "value")]),
    GlFunction(Void, "glProgramUniform2fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*2"), "value")]),
    GlFunction(Void, "glProgramUniform3fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*3"), "value")]),
    GlFunction(Void, "glProgramUniform4fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*4"), "value")]),
    GlFunction(Void, "glProgramUniform1ivEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count"), "value")]),
    GlFunction(Void, "glProgramUniform2ivEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*2"), "value")]),
    GlFunction(Void, "glProgramUniform3ivEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*3"), "value")]),
    GlFunction(Void, "glProgramUniform4ivEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix2fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*2*2"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix3fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*3*3"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix4fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*4*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix2x3fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*2*3"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix3x2fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*3*2"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix2x4fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*2*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix4x2fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*4*2"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix3x4fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*3*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix4x3fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*4*3"), "value")]),
    GlFunction(Void, "glProgramUniform1uiEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLuint, "v0")]),
    GlFunction(Void, "glProgramUniform2uiEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLuint, "v0"), (GLuint, "v1")]),
    GlFunction(Void, "glProgramUniform3uiEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLuint, "v0"), (GLuint, "v1"), (GLuint, "v2")]),
    GlFunction(Void, "glProgramUniform4uiEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLuint, "v0"), (GLuint, "v1"), (GLuint, "v2"), (GLuint, "v3")]),
    GlFunction(Void, "glProgramUniform1uivEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count"), "value")]),
    GlFunction(Void, "glProgramUniform2uivEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count*2"), "value")]),
    GlFunction(Void, "glProgramUniform3uivEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count*3"), "value")]),
    GlFunction(Void, "glProgramUniform4uivEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint), "count*4"), "value")]),
    GlFunction(Void, "glNamedBufferDataEXT", [(GLbuffer, "buffer"), (GLsizeiptr, "size"), (Blob(Const(GLvoid), "size"), "data"), (GLenum, "usage")]),
    GlFunction(Void, "glNamedBufferSubDataEXT", [(GLbuffer, "buffer"), (GLintptr, "offset"), (GLsizeiptr, "size"), (Blob(Const(GLvoid), "size"), "data")]),
    GlFunction(GLmap, "glMapNamedBufferEXT", [(GLbuffer, "buffer"), (GLenum, "access")]),
    GlFunction(GLboolean, "glUnmapNamedBufferEXT", [(GLbuffer, "buffer")]),
    GlFunction(GLmap, "glMapNamedBufferRangeEXT", [(GLbuffer, "buffer"), (GLintptr, "offset"), (GLsizeiptr, "length"), (GLbitfield_access, "access")]),
    GlFunction(Void, "glFlushMappedNamedBufferRangeEXT", [(GLbuffer, "buffer"), (GLintptr, "offset"), (GLsizeiptr, "length")]),
    GlFunction(Void, "glNamedCopyBufferSubDataEXT", [(GLbuffer, "readBuffer"), (GLbuffer, "writeBuffer"), (GLintptr, "readOffset"), (GLintptr, "writeOffset"), (GLsizeiptr, "size")]),
    GlFunction(Void, "glGetNamedBufferParameterivEXT", [(GLbuffer, "buffer"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetNamedBufferPointervEXT", [(GLbuffer, "buffer"), (GLenum, "pname"), Out(Pointer(GLpointer), "params")], sideeffects=False),
    GlFunction(Void, "glGetNamedBufferSubDataEXT", [(GLbuffer, "buffer"), (GLintptr, "offset"), (GLsizeiptr, "size"), Out(OpaqueBlob(GLvoid, "size"), "data")], sideeffects=False),
    GlFunction(Void, "glTextureBufferEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLenum, "internalformat"), (GLbuffer, "buffer")]),
    GlFunction(Void, "glMultiTexBufferEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLenum, "internalformat"), (GLbuffer, "buffer")]),
    GlFunction(Void, "glNamedRenderbufferStorageEXT", [(GLrenderbuffer, "renderbuffer"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glGetNamedRenderbufferParameterivEXT", [(GLrenderbuffer, "renderbuffer"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(GLenum, "glCheckNamedFramebufferStatusEXT", [(GLframebuffer, "framebuffer"), (GLenum, "target")]),
    GlFunction(Void, "glNamedFramebufferTexture1DEXT", [(GLframebuffer, "framebuffer"), (GLenum, "attachment"), (GLenum, "textarget"), (GLtexture, "texture"), (GLint, "level")]),
    GlFunction(Void, "glNamedFramebufferTexture2DEXT", [(GLframebuffer, "framebuffer"), (GLenum, "attachment"), (GLenum, "textarget"), (GLtexture, "texture"), (GLint, "level")]),
    GlFunction(Void, "glNamedFramebufferTexture3DEXT", [(GLframebuffer, "framebuffer"), (GLenum, "attachment"), (GLenum, "textarget"), (GLtexture, "texture"), (GLint, "level"), (GLint, "zoffset")]),
    GlFunction(Void, "glNamedFramebufferRenderbufferEXT", [(GLframebuffer, "framebuffer"), (GLenum, "attachment"), (GLenum, "renderbuffertarget"), (GLrenderbuffer, "renderbuffer")]),
    GlFunction(Void, "glGetNamedFramebufferAttachmentParameterivEXT", [(GLframebuffer, "framebuffer"), (GLenum, "attachment"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGenerateTextureMipmapEXT", [(GLtexture, "texture"), (GLenum, "target")]),
    GlFunction(Void, "glGenerateMultiTexMipmapEXT", [(GLenum, "texunit"), (GLenum, "target")]),
    GlFunction(Void, "glFramebufferDrawBufferEXT", [(GLframebuffer, "framebuffer"), (GLenum, "mode")]),
    GlFunction(Void, "glFramebufferDrawBuffersEXT", [(GLframebuffer, "framebuffer"), (GLsizei, "n"), (Array(Const(GLenum), "n"), "bufs")]),
    GlFunction(Void, "glFramebufferReadBufferEXT", [(GLframebuffer, "framebuffer"), (GLenum, "mode")]),
    GlFunction(Void, "glGetFramebufferParameterivEXT", [(GLframebuffer, "framebuffer"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glNamedRenderbufferStorageMultisampleEXT", [(GLrenderbuffer, "renderbuffer"), (GLsizei, "samples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glNamedRenderbufferStorageMultisampleCoverageEXT", [(GLrenderbuffer, "renderbuffer"), (GLsizei, "coverageSamples"), (GLsizei, "colorSamples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glNamedFramebufferTextureEXT", [(GLframebuffer, "framebuffer"), (GLenum, "attachment"), (GLtexture, "texture"), (GLint, "level")]),
    GlFunction(Void, "glNamedFramebufferTextureLayerEXT", [(GLframebuffer, "framebuffer"), (GLenum, "attachment"), (GLtexture, "texture"), (GLint, "level"), (GLint, "layer")]),
    GlFunction(Void, "glNamedFramebufferTextureFaceEXT", [(GLframebuffer, "framebuffer"), (GLenum, "attachment"), (GLtexture, "texture"), (GLint, "level"), (GLenum, "face")]),
    GlFunction(Void, "glTextureRenderbufferEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLrenderbuffer, "renderbuffer")]),
    GlFunction(Void, "glMultiTexRenderbufferEXT", [(GLenum, "texunit"), (GLenum, "target"), (GLrenderbuffer, "renderbuffer")]),
    GlFunction(Void, "glProgramUniform1dEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLdouble, "x")]),
    GlFunction(Void, "glProgramUniform2dEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLdouble, "x"), (GLdouble, "y")]),
    GlFunction(Void, "glProgramUniform3dEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glProgramUniform4dEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glProgramUniform1dvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLdouble), "count"), "value")]),
    GlFunction(Void, "glProgramUniform2dvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLdouble), "count*2"), "value")]),
    GlFunction(Void, "glProgramUniform3dvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLdouble), "count*3"), "value")]),
    GlFunction(Void, "glProgramUniform4dvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLdouble), "count*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix2dvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*2*2"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix3dvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*3*3"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix4dvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*4*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix2x3dvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*2*3"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix2x4dvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*2*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix3x2dvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*3*2"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix3x4dvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*3*4"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix4x2dvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*4*2"), "value")]),
    GlFunction(Void, "glProgramUniformMatrix4x3dvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLdouble), "count*4*3"), "value")]),
    GlFunction(Void, "glVertexArrayVertexOffsetEXT", [(GLarray, "vaobj"), (GLuint, "buffer"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLintptr, "offset")]),
    GlFunction(Void, "glVertexArrayColorOffsetEXT", [(GLarray, "vaobj"), (GLuint, "buffer"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLintptr, "offset")]),
    GlFunction(Void, "glVertexArrayEdgeFlagOffsetEXT", [(GLarray, "vaobj"), (GLuint, "buffer"), (GLsizei, "stride"), (GLintptr, "offset")]),
    GlFunction(Void, "glVertexArrayIndexOffsetEXT", [(GLarray, "vaobj"), (GLuint, "buffer"), (GLenum, "type"), (GLsizei, "stride"), (GLintptr, "offset")]),
    GlFunction(Void, "glVertexArrayNormalOffsetEXT", [(GLarray, "vaobj"), (GLuint, "buffer"), (GLenum, "type"), (GLsizei, "stride"), (GLintptr, "offset")]),
    GlFunction(Void, "glVertexArrayTexCoordOffsetEXT", [(GLarray, "vaobj"), (GLuint, "buffer"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLintptr, "offset")]),
    GlFunction(Void, "glVertexArrayMultiTexCoordOffsetEXT", [(GLarray, "vaobj"), (GLuint, "buffer"), (GLenum, "texunit"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLintptr, "offset")]),
    GlFunction(Void, "glVertexArrayFogCoordOffsetEXT", [(GLarray, "vaobj"), (GLuint, "buffer"), (GLenum, "type"), (GLsizei, "stride"), (GLintptr, "offset")]),
    GlFunction(Void, "glVertexArraySecondaryColorOffsetEXT", [(GLarray, "vaobj"), (GLuint, "buffer"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLintptr, "offset")]),
    GlFunction(Void, "glVertexArrayVertexAttribOffsetEXT", [(GLarray, "vaobj"), (GLuint, "buffer"), (GLuint, "index"), (GLint, "size"), (GLenum, "type"), (GLboolean, "normalized"), (GLsizei, "stride"), (GLintptr, "offset")]),
    GlFunction(Void, "glVertexArrayVertexAttribIOffsetEXT", [(GLarray, "vaobj"), (GLuint, "buffer"), (GLuint, "index"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLintptr, "offset")]),
    GlFunction(Void, "glEnableVertexArrayEXT", [(GLarray, "vaobj"), (GLenum, "array")]),
    GlFunction(Void, "glDisableVertexArrayEXT", [(GLarray, "vaobj"), (GLenum, "array")]),
    GlFunction(Void, "glEnableVertexArrayAttribEXT", [(GLarray, "vaobj"), (GLuint, "index")]),
    GlFunction(Void, "glDisableVertexArrayAttribEXT", [(GLarray, "vaobj"), (GLuint, "index")]),
    GlFunction(Void, "glGetVertexArrayIntegervEXT", [(GLarray, "vaobj"), (GLenum, "pname"), Out(Pointer(GLint), "param")], sideeffects=False),
    GlFunction(Void, "glGetVertexArrayPointervEXT", [(GLarray, "vaobj"), (GLenum, "pname"), Out(Pointer(GLpointer), "param")], sideeffects=False),
    GlFunction(Void, "glGetVertexArrayIntegeri_vEXT", [(GLarray, "vaobj"), (GLuint, "index"), (GLenum, "pname"), Out(Pointer(GLint), "param")], sideeffects=False),
    GlFunction(Void, "glGetVertexArrayPointeri_vEXT", [(GLarray, "vaobj"), (GLuint, "index"), (GLenum, "pname"), Out(Pointer(GLpointer), "param")], sideeffects=False),

    # GL_NV_explicit_multisample
    GlFunction(Void, "glGetMultisamplefvNV", [(GLenum, "pname"), (GLuint, "index"), Out(Array(GLfloat, 2), "val")], sideeffects=False),
    GlFunction(Void, "glSampleMaskIndexedNV", [(GLuint, "index"), (GLbitfield, "mask")]),
    GlFunction(Void, "glTexRenderbufferNV", [(GLenum, "target"), (GLrenderbuffer, "renderbuffer")]),

    # GL_NV_transform_feedback2
    GlFunction(Void, "glBindTransformFeedbackNV", [(GLenum, "target"), (GLfeedback, "id")]),
    GlFunction(Void, "glDeleteTransformFeedbacksNV", [(GLsizei, "n"), (Array(Const(GLfeedback), "n"), "ids")]),
    GlFunction(Void, "glGenTransformFeedbacksNV", [(GLsizei, "n"), Out(Array(GLfeedback, "n"), "ids")]),
    GlFunction(GLboolean, "glIsTransformFeedbackNV", [(GLfeedback, "id")], sideeffects=False),
    GlFunction(Void, "glPauseTransformFeedbackNV", []),
    GlFunction(Void, "glResumeTransformFeedbackNV", []),
    GlFunction(Void, "glDrawTransformFeedbackNV", [(GLenum_mode, "mode"), (GLfeedback, "id")]),

    # GL_AMD_performance_monitor
    GlFunction(Void, "glGetPerfMonitorGroupsAMD", [Out(Pointer(GLint), "numGroups"), (GLsizei, "groupsSize"), Out(Array(GLuint, "groupsSize"), "groups")], sideeffects=False),
    GlFunction(Void, "glGetPerfMonitorCountersAMD", [(GLuint, "group"), Out(Pointer(GLint), "numCounters"), Out(Pointer(GLint), "maxActiveCounters"), (GLsizei, "counterSize"), Out(Array(GLuint, "counterSize"), "counters")], sideeffects=False),
    GlFunction(Void, "glGetPerfMonitorGroupStringAMD", [(GLuint, "group"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), OutGlString(GLchar, "length", "groupString")], sideeffects=False),
    GlFunction(Void, "glGetPerfMonitorCounterStringAMD", [(GLuint, "group"), (GLuint, "counter"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), OutGlString(GLchar, "length", "counterString")], sideeffects=False),
    GlFunction(Void, "glGetPerfMonitorCounterInfoAMD", [(GLuint, "group"), (GLuint, "counter"), (GLenum, "pname"), Out(GLperfMonitorCounterInfoAMD, "data")], sideeffects=False),
    GlFunction(Void, "glGenPerfMonitorsAMD", [(GLsizei, "n"), Out(Array(GLuint, "n"), "monitors")]),
    GlFunction(Void, "glDeletePerfMonitorsAMD", [(GLsizei, "n"), (Array(GLuint, "n"), "monitors")]),
    GlFunction(Void, "glSelectPerfMonitorCountersAMD", [(GLuint, "monitor"), (GLboolean, "enable"), (GLuint, "group"), (GLint, "numCounters"), (Array(GLuint, "numCounters"), "counterList")]),
    GlFunction(Void, "glBeginPerfMonitorAMD", [(GLuint, "monitor")]),
    GlFunction(Void, "glEndPerfMonitorAMD", [(GLuint, "monitor")]),
    GlFunction(Void, "glGetPerfMonitorCounterDataAMD", [(GLuint, "monitor"), (GLenum, "pname"), (GLsizei, "dataSize"), Out(Array(GLuint, "dataSize"), "data"), Out(Pointer(GLint), "bytesWritten")], sideeffects=False),

    # GL_AMD_vertex_shader_tesselator
    GlFunction(Void, "glTessellationFactorAMD", [(GLfloat, "factor")]),
    GlFunction(Void, "glTessellationModeAMD", [(GLenum, "mode")]),

    # GL_EXT_provoking_vertex
    GlFunction(Void, "glProvokingVertexEXT", [(GLenum, "mode")]),

    # GL_AMD_draw_buffers_blend
    GlFunction(Void, "glBlendFuncIndexedAMD", [(GLuint, "buf"), (GLenum, "src"), (GLenum, "dst")]),
    GlFunction(Void, "glBlendFuncSeparateIndexedAMD", [(GLuint, "buf"), (GLenum, "srcRGB"), (GLenum, "dstRGB"), (GLenum, "srcAlpha"), (GLenum, "dstAlpha")]),
    GlFunction(Void, "glBlendEquationIndexedAMD", [(GLuint, "buf"), (GLenum, "mode")]),
    GlFunction(Void, "glBlendEquationSeparateIndexedAMD", [(GLuint, "buf"), (GLenum, "modeRGB"), (GLenum, "modeAlpha")]),

    # GL_APPLE_texture_range
    GlFunction(Void, "glTextureRangeAPPLE", [(GLenum, "target"), (GLsizei, "length"), (Blob(Const(GLvoid), "length"), "pointer")]),
    GlFunction(Void, "glGetTexParameterPointervAPPLE", [(GLenum, "target"), (GLenum, "pname"), Out(Pointer(GLpointer), "params")], sideeffects=False),

    # GL_APPLE_vertex_program_evaluators
    GlFunction(Void, "glEnableVertexAttribAPPLE", [(GLuint, "index"), (GLenum, "pname")]),
    GlFunction(Void, "glDisableVertexAttribAPPLE", [(GLuint, "index"), (GLenum, "pname")]),
    GlFunction(GLboolean, "glIsVertexAttribEnabledAPPLE", [(GLuint, "index"), (GLenum, "pname")], sideeffects=False),
    GlFunction(Void, "glMapVertexAttrib1dAPPLE", [(GLuint, "index"), (GLuint, "size"), (GLdouble, "u1"), (GLdouble, "u2"), (GLint, "stride"), (GLint, "order"), (OpaqueArray(Const(GLdouble), "_glMapVertexAttrib1dAPPLE_size(size, stride, order)"), "points")]),
    GlFunction(Void, "glMapVertexAttrib1fAPPLE", [(GLuint, "index"), (GLuint, "size"), (GLfloat, "u1"), (GLfloat, "u2"), (GLint, "stride"), (GLint, "order"), (OpaqueArray(Const(GLfloat), "_glMapVertexAttrib1fAPPLE_size(size, stride, order)"), "points")]),
    GlFunction(Void, "glMapVertexAttrib2dAPPLE", [(GLuint, "index"), (GLuint, "size"), (GLdouble, "u1"), (GLdouble, "u2"), (GLint, "ustride"), (GLint, "uorder"), (GLdouble, "v1"), (GLdouble, "v2"), (GLint, "vstride"), (GLint, "vorder"), (OpaqueArray(Const(GLdouble), "_glMapVertexAttrib2dAPPLE_size(size, ustride, uorder, vstride, vorder)"), "points")]),
    GlFunction(Void, "glMapVertexAttrib2fAPPLE", [(GLuint, "index"), (GLuint, "size"), (GLfloat, "u1"), (GLfloat, "u2"), (GLint, "ustride"), (GLint, "uorder"), (GLfloat, "v1"), (GLfloat, "v2"), (GLint, "vstride"), (GLint, "vorder"), (OpaqueArray(Const(GLfloat), "_glMapVertexAttrib2fAPPLE_size(size, ustride, uorder, vstride, vorder)"), "points")]),

    # GL_APPLE_object_purgeable
    GlFunction(GLenum, "glObjectPurgeableAPPLE", [(GLenum, "objectType"), (GLuint, "name"), (GLenum, "option")]),
    GlFunction(GLenum, "glObjectUnpurgeableAPPLE", [(GLenum, "objectType"), (GLuint, "name"), (GLenum, "option")]),
    GlFunction(Void, "glGetObjectParameterivAPPLE", [(GLenum, "objectType"), (GLuint, "name"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_NV_video_capture
    GlFunction(Void, "glBeginVideoCaptureNV", [(GLuint, "video_capture_slot")]),
    GlFunction(Void, "glBindVideoCaptureStreamBufferNV", [(GLuint, "video_capture_slot"), (GLuint, "stream"), (GLenum, "frame_region"), (GLintptrARB, "offset")]),
    GlFunction(Void, "glBindVideoCaptureStreamTextureNV", [(GLuint, "video_capture_slot"), (GLuint, "stream"), (GLenum, "frame_region"), (GLenum, "target"), (GLuint, "texture")]),
    GlFunction(Void, "glEndVideoCaptureNV", [(GLuint, "video_capture_slot")]),
    GlFunction(Void, "glGetVideoCaptureivNV", [(GLuint, "video_capture_slot"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVideoCaptureStreamivNV", [(GLuint, "video_capture_slot"), (GLuint, "stream"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVideoCaptureStreamfvNV", [(GLuint, "video_capture_slot"), (GLuint, "stream"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVideoCaptureStreamdvNV", [(GLuint, "video_capture_slot"), (GLuint, "stream"), (GLenum, "pname"), Out(Array(GLdouble, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(GLenum, "glVideoCaptureNV", [(GLuint, "video_capture_slot"), Out(Pointer(GLuint), "sequence_num"), Out(Pointer(GLuint64EXT), "capture_time")]),
    GlFunction(Void, "glVideoCaptureStreamParameterivNV", [(GLuint, "video_capture_slot"), (GLuint, "stream"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glVideoCaptureStreamParameterfvNV", [(GLuint, "video_capture_slot"), (GLuint, "stream"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glVideoCaptureStreamParameterdvNV", [(GLuint, "video_capture_slot"), (GLuint, "stream"), (GLenum, "pname"), (Array(Const(GLdouble), "_gl_param_size(pname)"), "params")]),

    # GL_NV_copy_image
    GlFunction(Void, "glCopyImageSubDataNV", [(GLname("srcTarget"), "srcName"), (GLenum, "srcTarget"), (GLint, "srcLevel"), (GLint, "srcX"), (GLint, "srcY"), (GLint, "srcZ"), (GLname("dstTarget"), "dstName"), (GLenum, "dstTarget"), (GLint, "dstLevel"), (GLint, "dstX"), (GLint, "dstY"), (GLint, "dstZ"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth")]),

    # GL_EXT_separate_shader_objects
    GlFunction(Void, "glUseShaderProgramEXT", [(GLenum, "type"), (GLprogram, "program")]),
    GlFunction(Void, "glActiveProgramEXT", [(GLprogram, "program")]),
    GlFunction(GLprogram, "glCreateShaderProgramEXT", [(GLenum, "type"), (GLstringConst, "string")]),

    # GL_NV_shader_buffer_load
    GlFunction(Void, "glMakeBufferResidentNV", [(GLenum, "target"), (GLenum, "access")]),
    GlFunction(Void, "glMakeBufferNonResidentNV", [(GLenum, "target")]),
    GlFunction(GLboolean, "glIsBufferResidentNV", [(GLenum, "target")], sideeffects=False),
    GlFunction(Void, "glMakeNamedBufferResidentNV", [(GLbuffer, "buffer"), (GLenum, "access")]),
    GlFunction(Void, "glMakeNamedBufferNonResidentNV", [(GLbuffer, "buffer")]),
    GlFunction(GLboolean, "glIsNamedBufferResidentNV", [(GLbuffer, "buffer")], sideeffects=False),
    GlFunction(Void, "glGetBufferParameterui64vNV", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLuint64EXT, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetNamedBufferParameterui64vNV", [(GLbuffer, "buffer"), (GLenum, "pname"), Out(Array(GLuint64EXT, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetIntegerui64vNV", [(GLenum, "value"), Out(Array(GLuint64EXT, "_gl_param_size(value)"), "result")], sideeffects=False),
    GlFunction(Void, "glUniformui64NV", [(GLint, "location"), (GLuint64EXT, "value")]),
    GlFunction(Void, "glUniformui64vNV", [(GLint, "location"), (GLsizei, "count"), (Array(Const(GLuint64EXT), "count"), "value")]),
    GlFunction(Void, "glGetUniformui64vNV", [(GLprogram, "program"), (GLint, "location"), Out(OpaqueArray(GLuint64EXT, "_glGetUniformui64vNV_size(program, location)"), "params")], sideeffects=False),
    GlFunction(Void, "glProgramUniformui64NV", [(GLprogram, "program"), (GLint, "location"), (GLuint64EXT, "value")]),
    GlFunction(Void, "glProgramUniformui64vNV", [(GLprogram, "program"), (GLint, "location"), (GLsizei, "count"), (Array(Const(GLuint64EXT), "count"), "value")]),

    # GL_NV_vertex_buffer_unified_memory
    GlFunction(Void, "glBufferAddressRangeNV", [(GLenum, "pname"), (GLuint, "index"), (GLuint64EXT, "address"), (GLsizeiptr, "length")]),
    GlFunction(Void, "glVertexFormatNV", [(GLint, "size"), (GLenum, "type"), (GLsizei, "stride")]),
    GlFunction(Void, "glNormalFormatNV", [(GLenum, "type"), (GLsizei, "stride")]),
    GlFunction(Void, "glColorFormatNV", [(GLint, "size"), (GLenum, "type"), (GLsizei, "stride")]),
    GlFunction(Void, "glIndexFormatNV", [(GLenum, "type"), (GLsizei, "stride")]),
    GlFunction(Void, "glTexCoordFormatNV", [(GLint, "size"), (GLenum, "type"), (GLsizei, "stride")]),
    GlFunction(Void, "glEdgeFlagFormatNV", [(GLsizei, "stride")]),
    GlFunction(Void, "glSecondaryColorFormatNV", [(GLint, "size"), (GLenum, "type"), (GLsizei, "stride")]),
    GlFunction(Void, "glFogCoordFormatNV", [(GLenum, "type"), (GLsizei, "stride")]),
    GlFunction(Void, "glVertexAttribFormatNV", [(GLuint, "index"), (GLint, "size"), (GLenum, "type"), (GLboolean, "normalized"), (GLsizei, "stride")]),
    GlFunction(Void, "glVertexAttribIFormatNV", [(GLuint, "index"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride")]),
    GlFunction(Void, "glGetIntegerui64i_vNV", [(GLenum, "value"), (GLuint, "index"), Out(Array(GLuint64EXT, "_gl_param_size(value)"), "result")], sideeffects=False),

    # GL_NV_texture_barrier
    GlFunction(Void, "glTextureBarrierNV", []),

    # GL_EXT_shader_image_load_store
    GlFunction(Void, "glBindImageTextureEXT", [(GLuint, "index"), (GLtexture, "texture"), (GLint, "level"), (GLboolean, "layered"), (GLint, "layer"), (GLenum, "access"), (GLint, "format")]),
    GlFunction(Void, "glMemoryBarrierEXT", [(GLbitfield_barrier, "barriers")]),

    # GL_EXT_vertex_attrib_64bit
    GlFunction(Void, "glVertexAttribL1dEXT", [(GLuint, "index"), (GLdouble, "x")]),
    GlFunction(Void, "glVertexAttribL2dEXT", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y")]),
    GlFunction(Void, "glVertexAttribL3dEXT", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z")]),
    GlFunction(Void, "glVertexAttribL4dEXT", [(GLuint, "index"), (GLdouble, "x"), (GLdouble, "y"), (GLdouble, "z"), (GLdouble, "w")]),
    GlFunction(Void, "glVertexAttribL1dvEXT", [(GLuint, "index"), (Pointer(Const(GLdouble)), "v")]),
    GlFunction(Void, "glVertexAttribL2dvEXT", [(GLuint, "index"), (Array(Const(GLdouble), 2), "v")]),
    GlFunction(Void, "glVertexAttribL3dvEXT", [(GLuint, "index"), (Array(Const(GLdouble), 3), "v")]),
    GlFunction(Void, "glVertexAttribL4dvEXT", [(GLuint, "index"), (Array(Const(GLdouble), 4), "v")]),
    GlFunction(Void, "glVertexAttribLPointerEXT", [(GLuint, "index"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (Blob(Const(GLvoid), "size"), "pointer")]),
    GlFunction(Void, "glGetVertexAttribLdvEXT", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLdouble, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glVertexArrayVertexAttribLOffsetEXT", [(GLarray, "vaobj"), (GLuint, "buffer"), (GLuint, "index"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLintptr, "offset")]),

    # GL_NV_gpu_program5
    GlFunction(Void, "glProgramSubroutineParametersuivNV", [(GLenum, "target"), (GLsizei, "count"), (Array(Const(GLuint), "count"), "params")]),
    GlFunction(Void, "glGetProgramSubroutineParameteruivNV", [(GLenum, "target"), (GLuint, "index"), Out(Pointer(GLuint), "param")], sideeffects=False),

    # GL_NV_gpu_shader5
    GlFunction(Void, "glUniform1i64NV", [(GLint, "location"), (GLint64EXT, "x")]),
    GlFunction(Void, "glUniform2i64NV", [(GLint, "location"), (GLint64EXT, "x"), (GLint64EXT, "y")]),
    GlFunction(Void, "glUniform3i64NV", [(GLint, "location"), (GLint64EXT, "x"), (GLint64EXT, "y"), (GLint64EXT, "z")]),
    GlFunction(Void, "glUniform4i64NV", [(GLint, "location"), (GLint64EXT, "x"), (GLint64EXT, "y"), (GLint64EXT, "z"), (GLint64EXT, "w")]),
    GlFunction(Void, "glUniform1i64vNV", [(GLint, "location"), (GLsizei, "count"), (Array(Const(GLint64EXT), "count"), "value")]),
    GlFunction(Void, "glUniform2i64vNV", [(GLint, "location"), (GLsizei, "count"), (Array(Const(GLint64EXT), "count*2"), "value")]),
    GlFunction(Void, "glUniform3i64vNV", [(GLint, "location"), (GLsizei, "count"), (Array(Const(GLint64EXT), "count*3"), "value")]),
    GlFunction(Void, "glUniform4i64vNV", [(GLint, "location"), (GLsizei, "count"), (Array(Const(GLint64EXT), "count*4"), "value")]),
    GlFunction(Void, "glUniform1ui64NV", [(GLint, "location"), (GLuint64EXT, "x")]),
    GlFunction(Void, "glUniform2ui64NV", [(GLint, "location"), (GLuint64EXT, "x"), (GLuint64EXT, "y")]),
    GlFunction(Void, "glUniform3ui64NV", [(GLint, "location"), (GLuint64EXT, "x"), (GLuint64EXT, "y"), (GLuint64EXT, "z")]),
    GlFunction(Void, "glUniform4ui64NV", [(GLint, "location"), (GLuint64EXT, "x"), (GLuint64EXT, "y"), (GLuint64EXT, "z"), (GLuint64EXT, "w")]),
    GlFunction(Void, "glUniform1ui64vNV", [(GLint, "location"), (GLsizei, "count"), (Array(Const(GLuint64EXT), "count"), "value")]),
    GlFunction(Void, "glUniform2ui64vNV", [(GLint, "location"), (GLsizei, "count"), (Array(Const(GLuint64EXT), "count*2"), "value")]),
    GlFunction(Void, "glUniform3ui64vNV", [(GLint, "location"), (GLsizei, "count"), (Array(Const(GLuint64EXT), "count*3"), "value")]),
    GlFunction(Void, "glUniform4ui64vNV", [(GLint, "location"), (GLsizei, "count"), (Array(Const(GLuint64EXT), "count*4"), "value")]),
    GlFunction(Void, "glGetUniformi64vNV", [(GLuint, "program"), (GLint, "location"), Out(OpaqueArray(GLint64EXT, "_glGetUniformi64vNV_size(location)"), "params")], sideeffects=False),
    GlFunction(Void, "glProgramUniform1i64NV", [(GLuint, "program"), (GLint, "location"), (GLint64EXT, "x")]),
    GlFunction(Void, "glProgramUniform2i64NV", [(GLuint, "program"), (GLint, "location"), (GLint64EXT, "x"), (GLint64EXT, "y")]),
    GlFunction(Void, "glProgramUniform3i64NV", [(GLuint, "program"), (GLint, "location"), (GLint64EXT, "x"), (GLint64EXT, "y"), (GLint64EXT, "z")]),
    GlFunction(Void, "glProgramUniform4i64NV", [(GLuint, "program"), (GLint, "location"), (GLint64EXT, "x"), (GLint64EXT, "y"), (GLint64EXT, "z"), (GLint64EXT, "w")]),
    GlFunction(Void, "glProgramUniform1i64vNV", [(GLuint, "program"), (GLint, "location"), (GLsizei, "count"), (Array(Const(GLint64EXT), "count"), "value")]),
    GlFunction(Void, "glProgramUniform2i64vNV", [(GLuint, "program"), (GLint, "location"), (GLsizei, "count"), (Array(Const(GLint64EXT), "count*2"), "value")]),
    GlFunction(Void, "glProgramUniform3i64vNV", [(GLuint, "program"), (GLint, "location"), (GLsizei, "count"), (Array(Const(GLint64EXT), "count*3"), "value")]),
    GlFunction(Void, "glProgramUniform4i64vNV", [(GLuint, "program"), (GLint, "location"), (GLsizei, "count"), (Array(Const(GLint64EXT), "count*4"), "value")]),
    GlFunction(Void, "glProgramUniform1ui64NV", [(GLuint, "program"), (GLint, "location"), (GLuint64EXT, "x")]),
    GlFunction(Void, "glProgramUniform2ui64NV", [(GLuint, "program"), (GLint, "location"), (GLuint64EXT, "x"), (GLuint64EXT, "y")]),
    GlFunction(Void, "glProgramUniform3ui64NV", [(GLuint, "program"), (GLint, "location"), (GLuint64EXT, "x"), (GLuint64EXT, "y"), (GLuint64EXT, "z")]),
    GlFunction(Void, "glProgramUniform4ui64NV", [(GLuint, "program"), (GLint, "location"), (GLuint64EXT, "x"), (GLuint64EXT, "y"), (GLuint64EXT, "z"), (GLuint64EXT, "w")]),
    GlFunction(Void, "glProgramUniform1ui64vNV", [(GLuint, "program"), (GLint, "location"), (GLsizei, "count"), (Array(Const(GLuint64EXT), "count"), "value")]),
    GlFunction(Void, "glProgramUniform2ui64vNV", [(GLuint, "program"), (GLint, "location"), (GLsizei, "count"), (Array(Const(GLuint64EXT), "count*2"), "value")]),
    GlFunction(Void, "glProgramUniform3ui64vNV", [(GLuint, "program"), (GLint, "location"), (GLsizei, "count"), (Array(Const(GLuint64EXT), "count*3"), "value")]),
    GlFunction(Void, "glProgramUniform4ui64vNV", [(GLuint, "program"), (GLint, "location"), (GLsizei, "count"), (Array(Const(GLuint64EXT), "count*4"), "value")]),

    # GL_NV_vertex_attrib_integer_64bit
    GlFunction(Void, "glVertexAttribL1i64NV", [(GLuint, "index"), (GLint64EXT, "x")]),
    GlFunction(Void, "glVertexAttribL2i64NV", [(GLuint, "index"), (GLint64EXT, "x"), (GLint64EXT, "y")]),
    GlFunction(Void, "glVertexAttribL3i64NV", [(GLuint, "index"), (GLint64EXT, "x"), (GLint64EXT, "y"), (GLint64EXT, "z")]),
    GlFunction(Void, "glVertexAttribL4i64NV", [(GLuint, "index"), (GLint64EXT, "x"), (GLint64EXT, "y"), (GLint64EXT, "z"), (GLint64EXT, "w")]),
    GlFunction(Void, "glVertexAttribL1i64vNV", [(GLuint, "index"), (Pointer(Const(GLint64EXT)), "v")]),
    GlFunction(Void, "glVertexAttribL2i64vNV", [(GLuint, "index"), (Array(Const(GLint64EXT), 2), "v")]),
    GlFunction(Void, "glVertexAttribL3i64vNV", [(GLuint, "index"), (Array(Const(GLint64EXT), 3), "v")]),
    GlFunction(Void, "glVertexAttribL4i64vNV", [(GLuint, "index"), (Array(Const(GLint64EXT), 4), "v")]),
    GlFunction(Void, "glVertexAttribL1ui64NV", [(GLuint, "index"), (GLuint64EXT, "x")]),
    GlFunction(Void, "glVertexAttribL2ui64NV", [(GLuint, "index"), (GLuint64EXT, "x"), (GLuint64EXT, "y")]),
    GlFunction(Void, "glVertexAttribL3ui64NV", [(GLuint, "index"), (GLuint64EXT, "x"), (GLuint64EXT, "y"), (GLuint64EXT, "z")]),
    GlFunction(Void, "glVertexAttribL4ui64NV", [(GLuint, "index"), (GLuint64EXT, "x"), (GLuint64EXT, "y"), (GLuint64EXT, "z"), (GLuint64EXT, "w")]),
    GlFunction(Void, "glVertexAttribL1ui64vNV", [(GLuint, "index"), (Pointer(Const(GLuint64EXT)), "v")]),
    GlFunction(Void, "glVertexAttribL2ui64vNV", [(GLuint, "index"), (Array(Const(GLuint64EXT), 2), "v")]),
    GlFunction(Void, "glVertexAttribL3ui64vNV", [(GLuint, "index"), (Array(Const(GLuint64EXT), 3), "v")]),
    GlFunction(Void, "glVertexAttribL4ui64vNV", [(GLuint, "index"), (Array(Const(GLuint64EXT), 4), "v")]),
    GlFunction(Void, "glGetVertexAttribLi64vNV", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLint64EXT, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetVertexAttribLui64vNV", [(GLuint, "index"), (GLenum, "pname"), Out(Array(GLuint64EXT, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glVertexAttribLFormatNV", [(GLuint, "index"), (GLint, "size"), (GLenum, "type"), (GLsizei, "stride")]),

    # GL_AMD_name_gen_delete
    GlFunction(Void, "glGenNamesAMD", [(GLenum, "identifier"), (GLuint, "num"), Out(Array(GLuint, "num"), "names")]),
    GlFunction(Void, "glDeleteNamesAMD", [(GLenum, "identifier"), (GLuint, "num"), (Array(Const(GLuint), "num"), "names")]),
    GlFunction(GLboolean, "glIsNameAMD", [(GLenum, "identifier"), (GLuint, "name")], sideeffects=False),

    # GL_AMD_debug_output
    GlFunction(Void, "glDebugMessageEnableAMD", [(GLenum, "category"), (GLenum, "severity"), (GLsizei, "count"), (Array(Const(GLuint), "count"), "ids"), (GLboolean, "enabled")], sideeffects=True),
    GlFunction(Void, "glDebugMessageInsertAMD", [(GLenum, "category"), (GLenum, "severity"), (GLuint, "id"), (GLsizei, "length"), InGlString(GLchar, "length", "buf")], sideeffects=True),
    GlFunction(Void, "glDebugMessageCallbackAMD", [(GLDEBUGPROCAMD, "callback"), (GLpointer, "userParam")], sideeffects=False),
    GlFunction(GLuint, "glGetDebugMessageLogAMD", [(GLuint, "count"), (GLsizei, "bufsize"), Out(Array(GLenum, "count"), "categories"), Out(Array(GLuint, "count"), "severities"), Out(Array(GLuint, "count"), "ids"), Out(Array(GLsizei, "count"), "lengths"), Out(String(GLchar, "_glGetDebugMessageLog_length(message, lengths, _result)"), "message")], sideeffects=False, fail=0),

    # GL_NV_vdpau_interop
    GlFunction(Void, "glVDPAUInitNV", [(OpaquePointer(Const(GLvoid)), "vdpDevice"), (OpaquePointer(Const(GLvoid)), "getProcAddress")]),
    GlFunction(Void, "glVDPAUFiniNV", []),
    GlFunction(GLvdpauSurfaceNV, "glVDPAURegisterVideoSurfaceNV", [(OpaquePointer(Const(GLvoid)), "vdpSurface"), (GLenum, "target"), (GLsizei, "numTextureNames"), (Array(Const(GLtexture), "numTextureNames"), "textureNames")]),
    GlFunction(GLvdpauSurfaceNV, "glVDPAURegisterOutputSurfaceNV", [(OpaquePointer(Const(GLvoid)), "vdpSurface"), (GLenum, "target"), (GLsizei, "numTextureNames"), (Array(Const(GLtexture), "numTextureNames"), "textureNames")]),
    GlFunction(GLboolean, "glVDPAUIsSurfaceNV", [(GLvdpauSurfaceNV, "surface")], sideeffects=False),
    GlFunction(Void, "glVDPAUUnregisterSurfaceNV", [(GLvdpauSurfaceNV, "surface")]),
    GlFunction(Void, "glVDPAUGetSurfaceivNV", [(GLvdpauSurfaceNV, "surface"), (GLenum, "pname"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), Out(Array(GLint, "bufSize"), "values")]),
    GlFunction(Void, "glVDPAUSurfaceAccessNV", [(GLvdpauSurfaceNV, "surface"), (GLenum, "access")]),
    GlFunction(Void, "glVDPAUMapSurfacesNV", [(GLsizei, "numSurfaces"), (Array(Const(GLvdpauSurfaceNV), "numSurfaces"), "surfaces")]),
    GlFunction(Void, "glVDPAUUnmapSurfacesNV", [(GLsizei, "numSurface"), (Array(Const(GLvdpauSurfaceNV), "numSurface"), "surfaces")]),

    # GL_NV_texture_multisample
    GlFunction(Void, "glTexImage2DMultisampleCoverageNV", [(GLenum, "target"), (GLsizei, "coverageSamples"), (GLsizei, "colorSamples"), (GLint, "internalFormat"), (GLsizei, "width"), (GLsizei, "height"), (GLboolean, "fixedSampleLocations")]),
    GlFunction(Void, "glTexImage3DMultisampleCoverageNV", [(GLenum, "target"), (GLsizei, "coverageSamples"), (GLsizei, "colorSamples"), (GLint, "internalFormat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLboolean, "fixedSampleLocations")]),
    GlFunction(Void, "glTextureImage2DMultisampleNV", [(GLtexture, "texture"), (GLenum, "target"), (GLsizei, "samples"), (GLint, "internalFormat"), (GLsizei, "width"), (GLsizei, "height"), (GLboolean, "fixedSampleLocations")]),
    GlFunction(Void, "glTextureImage3DMultisampleNV", [(GLtexture, "texture"), (GLenum, "target"), (GLsizei, "samples"), (GLint, "internalFormat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLboolean, "fixedSampleLocations")]),
    GlFunction(Void, "glTextureImage2DMultisampleCoverageNV", [(GLtexture, "texture"), (GLenum, "target"), (GLsizei, "coverageSamples"), (GLsizei, "colorSamples"), (GLint, "internalFormat"), (GLsizei, "width"), (GLsizei, "height"), (GLboolean, "fixedSampleLocations")]),
    GlFunction(Void, "glTextureImage3DMultisampleCoverageNV", [(GLtexture, "texture"), (GLenum, "target"), (GLsizei, "coverageSamples"), (GLsizei, "colorSamples"), (GLint, "internalFormat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLboolean, "fixedSampleLocations")]),

    # GL_AMD_sample_positions
    GlFunction(Void, "glSetMultisamplefvAMD", [(GLenum, "pname"), (GLuint, "index"), (Array(Const(GLfloat), 2), "val")]),

    # GL_EXT_x11_sync_object
    GlFunction(GLsync, "glImportSyncEXT", [(GLenum, "external_sync_type"), (GLintptr, "external_sync"), (GLbitfield, "flags")]),

    # GL_AMD_multi_draw_indirect
    GlFunction(Void, "glMultiDrawArraysIndirectAMD", [(GLenum_mode, "mode"), (GLpointerConst, "indirect"), (GLsizei, "primcount"), (GLsizei, "stride")]),
    GlFunction(Void, "glMultiDrawElementsIndirectAMD", [(GLenum_mode, "mode"), (GLenum, "type"), (GLpointerConst, "indirect"), (GLsizei, "primcount"), (GLsizei, "stride")]),

    # GL_AMD_stencil_operation_extended
    GlFunction(Void, "glStencilOpValueAMD", [(GLenum, "face"), (GLuint, "value")]),

    # GL_NV_bindless_texture
    GlFunction(GLuint64, "glGetTextureHandleNV", [(GLtexture, "texture")]),
    GlFunction(GLuint64, "glGetTextureSamplerHandleNV", [(GLtexture, "texture"), (GLsampler, "sampler")]),
    GlFunction(Void, "glMakeTextureHandleResidentNV", [(GLuint64, "handle")]),
    GlFunction(Void, "glMakeTextureHandleNonResidentNV", [(GLuint64, "handle")]),
    GlFunction(GLuint64, "glGetImageHandleNV", [(GLtexture, "texture"), (GLint, "level"), (GLboolean, "layered"), (GLint, "layer"), (GLenum, "format")]),
    GlFunction(Void, "glMakeImageHandleResidentNV", [(GLuint64, "handle"), (GLenum, "access")]),
    GlFunction(Void, "glMakeImageHandleNonResidentNV", [(GLuint64, "handle")]),
    GlFunction(Void, "glUniformHandleui64NV", [(GLlocation, "location"), (GLuint64, "value")]),
    GlFunction(Void, "glUniformHandleui64vNV", [(GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint64), "count"), "value")]),
    GlFunction(Void, "glProgramUniformHandleui64NV", [(GLprogram, "program"), (GLlocation, "location"), (GLuint64, "value")]),
    GlFunction(Void, "glProgramUniformHandleui64vNV", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLuint64), "count"), "values")]),
    GlFunction(GLboolean, "glIsTextureHandleResidentNV", [(GLuint64, "handle")], sideeffects=False),
    GlFunction(GLboolean, "glIsImageHandleResidentNV", [(GLuint64, "handle")], sideeffects=False),

    # GL_NVX_conditional_render
    GlFunction(Void, "glBeginConditionalRenderNVX", [(GLquery, "id")]),
    GlFunction(Void, "glEndConditionalRenderNVX", []),

    # GL_AMD_sparse_texture
    GlFunction(Void, "glTexStorageSparseAMD", [(GLenum, "target"), (GLenum, "internalFormat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLsizei, "layers"), (GLbitfield_texStorageSparse, "flags")]),
    GlFunction(Void, "glTextureStorageSparseAMD", [(GLtexture, "texture"), (GLenum, "target"), (GLenum, "internalFormat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLsizei, "layers"), (GLbitfield_texStorageSparse, "flags")]),

    # GL_INTEL_map_texture
    # XXX: glMapTexture2DINTEL prototype in glext.h is busted
    #GlFunction(Void, "glSyncTextureINTEL", [(GLtexture, "texture")]),
    #GlFunction(Void, "glUnmapTexture2DINTEL", [(GLtexture, "texture"), (GLint, "level")]),
    #GlFunction(OpaquePointer(GLvoid), "glMapTexture2DINTEL", [(GLtexture, "texture"), (GLint, "level"), (GLbitfield, "access"), Out(Pointer(GLint), "stride"), Out(Pointer(GLenum), "layout")]),

    # GL_NV_draw_texture
    GlFunction(Void, "glDrawTextureNV", [(GLtexture, "texture"), (GLsampler, "sampler"), (GLfloat, "x0"), (GLfloat, "y0"), (GLfloat, "x1"), (GLfloat, "y1"), (GLfloat, "z"), (GLfloat, "s0"), (GLfloat, "t0"), (GLfloat, "s1"), (GLfloat, "t1")]),

    # GL_NV_framebuffer_blit
    GlFunction(Void, "glBlitFramebufferNV", [(GLint, "srcX0"), (GLint, "srcY0"), (GLint, "srcX1"), (GLint, "srcY1"), (GLint, "dstX0"), (GLint, "dstY0"), (GLint, "dstX1"), (GLint, "dstY1"), (GLbitfield_attrib, "mask"), (GLenum, "filter")]),

    # GL_NV_blend_equation_advanced
    GlFunction(Void, "glBlendParameteriNV", [(GLenum, "pname"), (GLint, "value")]),
    GlFunction(Void, "glBlendBarrierNV", []),

    # GL_EXT_debug_label
    GlFunction(Void, "glLabelObjectEXT", [(GLenum, "type"), (GLuint, "object"), (GLsizei, "length"), (GLstringConst, "label")]),
    GlFunction(Void, "glGetObjectLabelEXT", [(GLenum, "type"), (GLuint, "object"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), Out(GLstring, "label")], sideeffects=False),

    # GL_EXT_debug_marker
    GlFunction(Void, "glInsertEventMarkerEXT", [(GLsizei, "length"), (String(Const(GLchar), "length ? length : strlen(marker)"), "marker")], sideeffects=True),
    GlFunction(Void, "glPushGroupMarkerEXT", [(GLsizei, "length"), (String(Const(GLchar), "length ? length : strlen(marker)"), "marker")], sideeffects=True),
    GlFunction(Void, "glPopGroupMarkerEXT", [], sideeffects=True),

    # GL_KTX_buffer_region
    # XXX: http://www.west.net/~brittain/3dsmax2.htm does not mention EXT suffix
    GlFunction(GLregion, "glNewBufferRegion", [(GLenum, "type")]),
    GlFunction(Void, "glDeleteBufferRegion", [(GLregion, "region")]),
    GlFunction(Void, "glReadBufferRegion", [(GLregion, "region"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glDrawBufferRegion", [(GLregion, "region"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height"), (GLint, "xDest"), (GLint, "yDest")]),
    GlFunction(GLuint, "glBufferRegionEnabled", [], sideeffects=False),

    # GL_WIN_swap_hint
    GlFunction(Void, "glAddSwapHintRectWIN", [(GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),
])

########NEW FILE########
__FILENAME__ = glesapi
##########################################################################
#
# Copyright 2011 LunarG, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""GLES API description.
"""


from gltypes import *


GLfixed = Alias("GLfixed", Int32)
GLclampx = Alias("GLclampx", Int32)


def GlFunction(*args, **kwargs):
    kwargs.setdefault('call', 'GL_APIENTRY')
    return Function(*args, **kwargs)


glesapi = Module('GLES')


# OpenGL ES specific functions
glesapi.addFunctions([
    # GL_VERSION_ES_CM_1_1: GL_OES_single_precision
    GlFunction(Void, "glFrustumf", [(GLfloat, "left"), (GLfloat, "right"), (GLfloat, "bottom"), (GLfloat, "top"), (GLfloat, "zNear"), (GLfloat, "zFar")]),
    GlFunction(Void, "glOrthof", [(GLfloat, "left"), (GLfloat, "right"), (GLfloat, "bottom"), (GLfloat, "top"), (GLfloat, "zNear"), (GLfloat, "zFar")]),

    GlFunction(Void, "glClipPlanef", [(GLenum, "plane"), (Array(Const(GLfloat), 4), "equation")]),
    GlFunction(Void, "glGetClipPlanef", [(GLenum, "plane"), Out(Array(GLfloat, 4), "equation")], sideeffects=False),

    # GL_VERSION_ES_CM_1_1: GL_OES_fixed_point
    GlFunction(Void, "glAlphaFuncx", [(GLenum, "func"), (GLclampx, "ref")]),
    GlFunction(Void, "glClearColorx", [(GLclampx, "red"), (GLclampx, "green"), (GLclampx, "blue"), (GLclampx, "alpha")]),
    GlFunction(Void, "glClearDepthx", [(GLclampx, "depth")]),
    GlFunction(Void, "glColor4x", [(GLfixed, "red"), (GLfixed, "green"), (GLfixed, "blue"), (GLfixed, "alpha")]),
    GlFunction(Void, "glDepthRangex", [(GLclampx, "zNear"), (GLclampx, "zFar")]),
    GlFunction(Void, "glFogx", [(GLenum, "pname"), (GLfixed, "param")]),
    GlFunction(Void, "glFogxv", [(GLenum, "pname"), (Array(Const(GLfixed), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glFrustumx", [(GLfixed, "left"), (GLfixed, "right"), (GLfixed, "bottom"), (GLfixed, "top"), (GLfixed, "zNear"), (GLfixed, "zFar")]),
    GlFunction(Void, "glLightModelx", [(GLenum, "pname"), (GLfixed, "param")]),
    GlFunction(Void, "glLightModelxv", [(GLenum, "pname"), (Array(Const(GLfixed), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glLightx", [(GLenum, "light"), (GLenum, "pname"), (GLfixed, "param")]),
    GlFunction(Void, "glLightxv", [(GLenum, "light"), (GLenum, "pname"), (Array(Const(GLfixed), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glLineWidthx", [(GLfixed, "width")]),
    GlFunction(Void, "glLoadMatrixx", [(Array(Const(GLfixed), 16), "m")]),
    GlFunction(Void, "glMaterialx", [(GLenum, "face"), (GLenum, "pname"), (GLfixed, "param")]),
    GlFunction(Void, "glMaterialxv", [(GLenum, "face"), (GLenum, "pname"), (Array(Const(GLfixed), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glMultMatrixx", [(Array(Const(GLfixed), 16), "m")]),
    GlFunction(Void, "glMultiTexCoord4x", [(GLenum, "target"), (GLfixed, "s"), (GLfixed, "t"), (GLfixed, "r"), (GLfixed, "q")]),
    GlFunction(Void, "glNormal3x", [(GLfixed, "nx"), (GLfixed, "ny"), (GLfixed, "nz")]),
    GlFunction(Void, "glOrthox", [(GLfixed, "left"), (GLfixed, "right"), (GLfixed, "bottom"), (GLfixed, "top"), (GLfixed, "zNear"), (GLfixed, "zFar")]),
    GlFunction(Void, "glPointSizex", [(GLfixed, "size")]),
    GlFunction(Void, "glPolygonOffsetx", [(GLfixed, "factor"), (GLfixed, "units")]),
    GlFunction(Void, "glRotatex", [(GLfixed, "angle"), (GLfixed, "x"), (GLfixed, "y"), (GLfixed, "z")]),
    GlFunction(Void, "glSampleCoveragex", [(GLclampx, "value"), (GLboolean, "invert")]),
    GlFunction(Void, "glScalex", [(GLfixed, "x"), (GLfixed, "y"), (GLfixed, "z")]),
    GlFunction(Void, "glTexEnvx", [(GLenum, "target"), (GLenum, "pname"), (GLfixed, "param")]),
    GlFunction(Void, "glTexEnvxv", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLfixed), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTexParameterx", [(GLenum, "target"), (GLenum, "pname"), (GLfixed, "param")]),
    GlFunction(Void, "glTranslatex", [(GLfixed, "x"), (GLfixed, "y"), (GLfixed, "z")]),

    GlFunction(Void, "glClipPlanex", [(GLenum, "plane"), (Array(Const(GLfixed), 4), "equation")]),
    GlFunction(Void, "glGetClipPlanex", [(GLenum, "plane"), Out(Array(GLfixed, 4), "equation")], sideeffects=False),
    GlFunction(Void, "glGetFixedv", [(GLenum, "pname"), Out(Array(GLfixed, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetLightxv", [(GLenum, "light"), (GLenum, "pname"), Out(Array(GLfixed, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetMaterialxv", [(GLenum, "face"), (GLenum, "pname"), Out(Array(GLfixed, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTexEnvxv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfixed, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTexParameterxv", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLfixed, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glPointParameterx", [(GLenum, "pname"), (GLfixed, "param")]),
    GlFunction(Void, "glPointParameterxv", [(GLenum, "pname"), (Array(Const(GLfixed), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTexParameterxv", [(GLenum, "target"), (GLenum, "pname"), (Array(Const(GLfixed), "_gl_param_size(pname)"), "params")]),

    # GL_ES_VERSION_2_0

    # all functions are already defined in OpenGL thanks to
    # GL_ARB_ES2_compatibility

    # GL_OES_blend_equation_separate
    GlFunction(Void, "glBlendEquationSeparateOES", [(GLenum, "modeRGB"), (GLenum, "modeAlpha")]),

    # GL_OES_blend_func_separate
    GlFunction(Void, "glBlendFuncSeparateOES", [(GLenum, "sfactorRGB"), (GLenum, "dfactorRGB"), (GLenum, "sfactorAlpha"), (GLenum, "dfactorAlpha")]),

    # GL_OES_blend_subtract
    GlFunction(Void, "glBlendEquationOES", [(GLenum, "mode")]),

    # GL_OES_framebuffer_object
    GlFunction(GLboolean, "glIsRenderbufferOES", [(GLrenderbuffer, "renderbuffer")], sideeffects=False),
    GlFunction(Void, "glBindRenderbufferOES", [(GLenum, "target"), (GLrenderbuffer, "renderbuffer")]),
    GlFunction(Void, "glDeleteRenderbuffersOES", [(GLsizei, "n"), (Array(Const(GLrenderbuffer), "n"), "renderbuffers")]),
    GlFunction(Void, "glGenRenderbuffersOES", [(GLsizei, "n"), Out(Array(GLrenderbuffer, "n"), "renderbuffers")]),
    GlFunction(Void, "glRenderbufferStorageOES", [(GLenum, "target"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glGetRenderbufferParameterivOES", [(GLenum, "target"), (GLenum, "pname"), (Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(GLboolean, "glIsFramebufferOES", [(GLframebuffer, "framebuffer")], sideeffects=False),
    GlFunction(Void, "glBindFramebufferOES", [(GLenum, "target"), (GLframebuffer, "framebuffer")]),
    GlFunction(Void, "glDeleteFramebuffersOES", [(GLsizei, "n"), (Array(Const(GLframebuffer), "n"), "framebuffers")]),
    GlFunction(Void, "glGenFramebuffersOES", [(GLsizei, "n"), Out(Array(GLframebuffer, "n"), "framebuffers")]),
    GlFunction(GLenum, "glCheckFramebufferStatusOES", [(GLenum, "target")]),
    GlFunction(Void, "glFramebufferTexture2DOES", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "textarget"), (GLtexture, "texture"), (GLint, "level")]),
    GlFunction(Void, "glFramebufferRenderbufferOES", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "renderbuffertarget"), (GLuint, "renderbuffer")]),
    GlFunction(Void, "glGetFramebufferAttachmentParameterivOES", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGenerateMipmapOES", [(GLenum, "target")]),

    # GL_OES_matrix_palette
    GlFunction(Void, "glCurrentPaletteMatrixOES", [(GLuint, "index")]),
    GlFunction(Void, "glLoadPaletteFromModelViewMatrixOES", []),
    GlFunction(Void, "glMatrixIndexPointerOES", [(GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),
    GlFunction(Void, "glWeightPointerOES", [(GLint, "size"), (GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "pointer")]),

    # GL_OES_point_size_array
    GlFunction(Void, "glPointSizePointerOES", [(GLenum, "type"), (GLsizei, "stride"), (GLpointerConst, "ptr")]),

    # GL_OES_query_matrix
    GlFunction(GLbitfield, "glQueryMatrixxOES", [(Array(GLfixed, 16), "mantissa"), (Array(GLint, 16), "exponent")]),

    # GL_OES_texture_cube_map
    GlFunction(Void, "glTexGenfOES", [(GLenum, "coord"), (GLenum, "pname"), (GLfloat, "param")]),
    GlFunction(Void, "glTexGenfvOES", [(GLenum, "coord"), (GLenum, "pname"), (Array(Const(GLfloat), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTexGeniOES", [(GLenum, "coord"), (GLenum, "pname"), (GLint, "param")]),
    GlFunction(Void, "glTexGenivOES", [(GLenum, "coord"), (GLenum, "pname"), (Array(Const(GLint), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glTexGenxOES", [(GLenum, "coord"), (GLenum, "pname"), (GLfixed, "param")]),
    GlFunction(Void, "glTexGenxvOES", [(GLenum, "coord"), (GLenum, "pname"), (Array(Const(GLfixed), "_gl_param_size(pname)"), "params")]),
    GlFunction(Void, "glGetTexGenfvOES", [(GLenum, "coord"), (GLenum, "pname"), Out(Array(GLfloat, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTexGenivOES", [(GLenum, "coord"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetTexGenxvOES", [(GLenum, "coord"), (GLenum, "pname"), Out(Array(GLfixed, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_OES_mapbuffer
    GlFunction(Void, "glGetBufferPointervOES", [(GLenum, "target"), (GLenum, "pname"), Out(Pointer(GLpointer), "params")], sideeffects=False),
    GlFunction(GLmap, "glMapBufferOES", [(GLenum, "target"), (GLenum, "access")]),
    GlFunction(GLboolean, "glUnmapBufferOES", [(GLenum, "target")]),

    # GL_OES_texture_3D
    GlFunction(Void, "glTexImage3DOES", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLint, "border"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTexImage3D_size(format, type, width, height, depth)"), "pixels")]),
    GlFunction(Void, "glTexSubImage3DOES", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLenum, "format"), (GLenum, "type"), (Blob(Const(GLvoid), "_glTexSubImage3D_size(format, type, width, height, depth)"), "pixels")]),
    GlFunction(Void, "glCopyTexSubImage3DOES", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLint, "x"), (GLint, "y"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glCompressedTexImage3DOES", [(GLenum, "target"), (GLint, "level"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLint, "border"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glCompressedTexSubImage3DOES", [(GLenum, "target"), (GLint, "level"), (GLint, "xoffset"), (GLint, "yoffset"), (GLint, "zoffset"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth"), (GLenum, "format"), (GLsizei, "imageSize"), (Blob(Const(GLvoid), "imageSize"), "data")]),
    GlFunction(Void, "glFramebufferTexture3DOES", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "textarget"), (GLtexture, "texture"), (GLint, "level"), (GLint, "zoffset")]),

    # GL_OES_get_program_binary
    GlFunction(Void, "glGetProgramBinaryOES", [(GLprogram, "program"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), Out(Pointer(GLenum), "binaryFormat"), Out(OpaqueBlob(GLvoid, "length ? *length : bufSize"), "binary")], sideeffects=False),
    GlFunction(Void, "glProgramBinaryOES", [(GLprogram, "program"), (GLenum, "binaryFormat"), (Blob(Const(GLvoid), "length"), "binary"), (GLsizei, "length")]),

    # GL_OES_draw_texture
    GlFunction(Void, "glDrawTexfOES", [(GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "width"), (GLfloat, "height")]),
    GlFunction(Void, "glDrawTexfvOES", [(Array(Const(GLfloat), 4), "coords")]),
    GlFunction(Void, "glDrawTexiOES", [(GLint, "x"), (GLint, "y"), (GLint, "z"), (GLint, "width"), (GLint, "height")]),
    GlFunction(Void, "glDrawTexivOES", [(Array(Const(GLint), 4), "coords")]),
    GlFunction(Void, "glDrawTexsOES", [(GLshort, "x"), (GLshort, "y"), (GLshort, "z"), (GLshort, "width"), (GLshort, "height")]),
    GlFunction(Void, "glDrawTexsvOES", [(Array(Const(GLshort), 4), "coords")]),

    # GL_EXT_discard_framebuffer
    GlFunction(Void, "glDiscardFramebufferEXT", [(GLenum, "target"), (GLsizei, "numAttachments"), (Array(Const(GLenum), "numAttachments"), "attachments")]),

    # GL_OES_vertex_array_object
    GlFunction(Void, "glBindVertexArrayOES", [(GLarray, "array")]),
    GlFunction(Void, "glDeleteVertexArraysOES", [(GLsizei, "n"), (Array(Const(GLarray), "n"), "arrays")]),
    GlFunction(Void, "glGenVertexArraysOES", [(GLsizei, "n"), Out(Array(GLarray, "n"), "arrays")]),
    GlFunction(GLboolean, "glIsVertexArrayOES", [(GLarray, "array")], sideeffects=False),

    # GL_NV_coverage_sample
    GlFunction(Void, "glCoverageMaskNV", [(GLboolean, "mask")]),
    GlFunction(Void, "glCoverageOperationNV", [(GLenum, "operation")]),

    # GL_IMG_multisampled_render_to_texture
    GlFunction(Void, "glRenderbufferStorageMultisampleIMG", [(GLenum, "target"), (GLsizei, "samples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glFramebufferTexture2DMultisampleIMG", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "textarget"), (GLtexture, "texture"), (GLint, "level"), (GLsizei, "samples")]),

    # GL_APPLE_framebuffer_multisample
    GlFunction(Void, "glRenderbufferStorageMultisampleAPPLE", [(GLenum, "target"), (GLsizei, "samples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glResolveMultisampleFramebufferAPPLE", []),

    # GL_ANGLE_framebuffer_blit
    GlFunction(Void, "glBlitFramebufferANGLE", [(GLint, "srcX0"), (GLint, "srcY0"), (GLint, "srcX1"), (GLint, "srcY1"), (GLint, "dstX0"), (GLint, "dstY0"), (GLint, "dstX1"), (GLint, "dstY1"), (GLbitfield_attrib, "mask"), (GLenum, "filter")]),

    # GL_ANGLE_framebuffer_multisample
    GlFunction(Void, "glRenderbufferStorageMultisampleANGLE", [(GLenum, "target"), (GLsizei, "samples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),

    # GL_NV_draw_buffers
    GlFunction(Void, "glDrawBuffersNV", [(GLsizei, "n"), (Array(Const(GLenum), "n"), "bufs")]),

    # GL_NV_read_buffer
    GlFunction(Void, "glReadBufferNV", [(GLenum, "mode")]),

    # GL_EXT_occlusion_query_boolean
    GlFunction(Void, "glGenQueriesEXT", [(GLsizei, "n"), Out(Array(GLquery, "n"), "ids")]),
    GlFunction(Void, "glDeleteQueriesEXT", [(GLsizei, "n"), (Array(Const(GLquery), "n"), "ids")]),
    GlFunction(GLboolean, "glIsQueryEXT", [(GLquery, "id")], sideeffects=False),
    GlFunction(Void, "glBeginQueryEXT", [(GLenum, "target"), (GLquery, "id")]),
    GlFunction(Void, "glEndQueryEXT", [(GLenum, "target")]),
    GlFunction(Void, "glGetQueryivEXT", [(GLenum, "target"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    GlFunction(Void, "glGetQueryObjectuivEXT", [(GLquery, "id"), (GLenum, "pname"), Out(Array(GLuint, "_gl_param_size(pname)"), "params")], sideeffects=False),

    # GL_EXT_separate_shader_objects
    GlFunction(Void, "glUseProgramStagesEXT", [(GLpipeline, "pipeline"), (GLbitfield_shader, "stages"), (GLprogram, "program")]),
    GlFunction(Void, "glActiveShaderProgramEXT", [(GLpipeline, "pipeline"), (GLprogram, "program")]),
    GlFunction(GLprogram, "glCreateShaderProgramvEXT", [(GLenum, "type"), (GLsizei, "count"), (Const(Array(GLstringConst, "count")), "strings")]),
    GlFunction(Void, "glBindProgramPipelineEXT", [(GLpipeline, "pipeline")]),
    GlFunction(Void, "glDeleteProgramPipelinesEXT", [(GLsizei, "n"), (Array(Const(GLuint), "n"), "pipelines")]),
    GlFunction(Void, "glGenProgramPipelinesEXT", [(GLsizei, "n"), Out(Array(GLpipeline, "n"), "pipelines")]),
    GlFunction(GLboolean, "glIsProgramPipelineEXT", [(GLpipeline, "pipeline")], sideeffects=False),
    #GlFunction(Void, "glProgramParameteriEXT", [(GLprogram, "program"), (GLenum, "pname"), (GLint, "value")]),
    GlFunction(Void, "glGetProgramPipelineivEXT", [(GLpipeline, "pipeline"), (GLenum, "pname"), Out(Array(GLint, "_gl_param_size(pname)"), "params")], sideeffects=False),
    #GlFunction(Void, "glProgramUniform1iEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLint, "x")]),
    #GlFunction(Void, "glProgramUniform2iEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLint, "x"), (GLint, "y")]),
    #GlFunction(Void, "glProgramUniform3iEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLint, "x"), (GLint, "y"), (GLint, "z")]),
    #GlFunction(Void, "glProgramUniform4iEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLint, "x"), (GLint, "y"), (GLint, "z"), (GLint, "w")]),
    #GlFunction(Void, "glProgramUniform1fEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLfloat, "x")]),
    #GlFunction(Void, "glProgramUniform2fEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLfloat, "x"), (GLfloat, "y")]),
    #GlFunction(Void, "glProgramUniform3fEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z")]),
    #GlFunction(Void, "glProgramUniform4fEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLfloat, "x"), (GLfloat, "y"), (GLfloat, "z"), (GLfloat, "w")]),
    #GlFunction(Void, "glProgramUniform1ivEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count"), "value")]),
    #GlFunction(Void, "glProgramUniform2ivEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*2"), "value")]),
    #GlFunction(Void, "glProgramUniform3ivEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*3"), "value")]),
    #GlFunction(Void, "glProgramUniform4ivEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLint), "count*4"), "value")]),
    #GlFunction(Void, "glProgramUniform1fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count"), "value")]),
    #GlFunction(Void, "glProgramUniform2fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*2"), "value")]),
    #GlFunction(Void, "glProgramUniform3fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*3"), "value")]),
    #GlFunction(Void, "glProgramUniform4fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (Array(Const(GLfloat), "count*4"), "value")]),
    #GlFunction(Void, "glProgramUniformMatrix2fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*2*2"), "value")]),
    #GlFunction(Void, "glProgramUniformMatrix3fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*3*3"), "value")]),
    #GlFunction(Void, "glProgramUniformMatrix4fvEXT", [(GLprogram, "program"), (GLlocation, "location"), (GLsizei, "count"), (GLboolean, "transpose"), (Array(Const(GLfloat), "count*4*4"), "value")]),
    GlFunction(Void, "glValidateProgramPipelineEXT", [(GLpipeline, "pipeline")]),
    GlFunction(Void, "glGetProgramPipelineInfoLogEXT", [(GLpipeline, "pipeline"), (GLsizei, "bufSize"), Out(Pointer(GLsizei), "length"), Out(GLstring, "infoLog")], sideeffects=False),

    # GL_EXT_multisampled_render_to_texture
    #GlFunction(Void, "glRenderbufferStorageMultisampleEXT", [(GLenum, "target"), (GLsizei, "samples"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glFramebufferTexture2DMultisampleEXT", [(GLenum, "target"), (GLenum, "attachment"), (GLenum, "textarget"), (GLtexture, "texture"), (GLint, "level"), (GLsizei, "samples")]),

    # GL_EXT_texture_storage
    GlFunction(Void, "glTexStorage1DEXT", [(GLenum, "target"), (GLsizei, "levels"), (GLenum, "internalformat"), (GLsizei, "width")]),
    GlFunction(Void, "glTexStorage2DEXT", [(GLenum, "target"), (GLsizei, "levels"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    GlFunction(Void, "glTexStorage3DEXT", [(GLenum, "target"), (GLsizei, "levels"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth")]),
    #GlFunction(Void, "glTextureStorage1DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLsizei, "levels"), (GLenum, "internalformat"), (GLsizei, "width")]),
    #GlFunction(Void, "glTextureStorage2DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLsizei, "levels"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height")]),
    #GlFunction(Void, "glTextureStorage3DEXT", [(GLtexture, "texture"), (GLenum, "target"), (GLsizei, "levels"), (GLenum, "internalformat"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth")]),
])

########NEW FILE########
__FILENAME__ = glparams
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


'''Describe GL parameters.'''


from stdapi import *

from gltypes import *


# Shorthands for the types
X = None # To be determined, merely an enum
B = GLboolean
I = GLint
I64 = GLint64
E = GLenum
F = GLfloat
D = GLdouble
P = OpaquePointer(Void)
S = CString
H = GLhandleARB

# A underscore prefix (e.g., _glGet) is used to skip automatic code generation
# for parameters that are obtained through other ways.

parameters = [
    # (functions, type, count, name) # value
    ("",	X,	1,	"GL_ZERO"),	# 0x0000
    ("",	X,	1,	"GL_ONE"),	# 0x0001

    # These are enumerated separately in GLenum_mode
    #("",	X,	1,	"GL_POINTS"),	# 0x0000
    #("",	X,	1,	"GL_LINES"),	# 0x0001
    #("",	X,	1,	"GL_LINE_LOOP"),	# 0x0002
    #("",	X,	1,	"GL_LINE_STRIP"),	# 0x0003
    #("",	X,	1,	"GL_TRIANGLES"),	# 0x0004
    #("",	X,	1,	"GL_TRIANGLE_STRIP"),	# 0x0005
    #("",	X,	1,	"GL_TRIANGLE_FAN"),	# 0x0006
    #("",	X,	1,	"GL_QUADS"),	# 0x0007
    #("",	X,	1,	"GL_QUAD_STRIP"),	# 0x0008
    #("",	X,	1,	"GL_POLYGON"),	# 0x0009
    #("",	X,	1,	"GL_LINES_ADJACENCY"),	# 0x000A
    #("",	X,	1,	"GL_LINE_STRIP_ADJACENCY"),	# 0x000B
    #("",	X,	1,	"GL_TRIANGLES_ADJACENCY"),	# 0x000C
    #("",	X,	1,	"GL_TRIANGLE_STRIP_ADJACENCY"),	# 0x000D
    #("",	X,	1,	"GL_PATCHES"),	# 0x000E

    ("",	X,	1,	"GL_RESTART_PATH_NV"),	# 0x00F0
    ("",	X,	1,	"GL_DUP_FIRST_CUBIC_CURVE_TO_NV"),	# 0x00F2
    ("",	X,	1,	"GL_DUP_LAST_CUBIC_CURVE_TO_NV"),	# 0x00F4
    ("",	X,	1,	"GL_RECT_NV"),	# 0x00F6
    ("",	X,	1,	"GL_CIRCULAR_CCW_ARC_TO_NV"),	# 0x00F8
    ("",	X,	1,	"GL_CIRCULAR_CW_ARC_TO_NV"),	# 0x00FA
    ("",	X,	1,	"GL_CIRCULAR_TANGENT_ARC_TO_NV"),	# 0x00FC
    ("",	X,	1,	"GL_ARC_TO_NV"),	# 0x00FE
    ("",	X,	1,	"GL_RELATIVE_ARC_TO_NV"),	# 0x00FF

    ("",	X,	1,	"GL_ACCUM"),	# 0x0100
    ("",	X,	1,	"GL_LOAD"),	# 0x0101
    ("",	X,	1,	"GL_RETURN"),	# 0x0102
    ("",	X,	1,	"GL_MULT"),	# 0x0103
    ("",	X,	1,	"GL_ADD"),	# 0x0104
    ("",	X,	1,	"GL_NEVER"),	# 0x0200
    ("",	X,	1,	"GL_LESS"),	# 0x0201
    ("",	X,	1,	"GL_EQUAL"),	# 0x0202
    ("",	X,	1,	"GL_LEQUAL"),	# 0x0203
    ("",	X,	1,	"GL_GREATER"),	# 0x0204
    ("",	X,	1,	"GL_NOTEQUAL"),	# 0x0205
    ("",	X,	1,	"GL_GEQUAL"),	# 0x0206
    ("",	X,	1,	"GL_ALWAYS"),	# 0x0207
    ("",	X,	1,	"GL_SRC_COLOR"),	# 0x0300
    ("",	X,	1,	"GL_ONE_MINUS_SRC_COLOR"),	# 0x0301
    ("",	X,	1,	"GL_SRC_ALPHA"),	# 0x0302
    ("",	X,	1,	"GL_ONE_MINUS_SRC_ALPHA"),	# 0x0303
    ("",	X,	1,	"GL_DST_ALPHA"),	# 0x0304
    ("",	X,	1,	"GL_ONE_MINUS_DST_ALPHA"),	# 0x0305
    ("",	X,	1,	"GL_DST_COLOR"),	# 0x0306
    ("",	X,	1,	"GL_ONE_MINUS_DST_COLOR"),	# 0x0307
    ("",	X,	1,	"GL_SRC_ALPHA_SATURATE"),	# 0x0308
    ("",	X,	1,	"GL_FRONT_LEFT"),	# 0x0400
    ("",	X,	1,	"GL_FRONT_RIGHT"),	# 0x0401
    ("",	X,	1,	"GL_BACK_LEFT"),	# 0x0402
    ("",	X,	1,	"GL_BACK_RIGHT"),	# 0x0403
    ("",	X,	1,	"GL_FRONT"),	# 0x0404
    ("",	X,	1,	"GL_BACK"),	# 0x0405
    ("",	X,	1,	"GL_LEFT"),	# 0x0406
    ("",	X,	1,	"GL_RIGHT"),	# 0x0407
    ("",	X,	1,	"GL_FRONT_AND_BACK"),	# 0x0408
    ("",	X,	1,	"GL_AUX0"),	# 0x0409
    ("",	X,	1,	"GL_AUX1"),	# 0x040A
    ("",	X,	1,	"GL_AUX2"),	# 0x040B
    ("",	X,	1,	"GL_AUX3"),	# 0x040C
    ("",	X,	1,	"GL_INVALID_ENUM"),	# 0x0500
    ("",	X,	1,	"GL_INVALID_VALUE"),	# 0x0501
    ("",	X,	1,	"GL_INVALID_OPERATION"),	# 0x0502
    ("",	X,	1,	"GL_STACK_OVERFLOW"),	# 0x0503
    ("",	X,	1,	"GL_STACK_UNDERFLOW"),	# 0x0504
    ("",	X,	1,	"GL_OUT_OF_MEMORY"),	# 0x0505
    ("",	X,	1,	"GL_INVALID_FRAMEBUFFER_OPERATION"),	# 0x0506
    ("",	X,	1,	"GL_2D"),	# 0x0600
    ("",	X,	1,	"GL_3D"),	# 0x0601
    ("",	X,	1,	"GL_3D_COLOR"),	# 0x0602
    ("",	X,	1,	"GL_3D_COLOR_TEXTURE"),	# 0x0603
    ("",	X,	1,	"GL_4D_COLOR_TEXTURE"),	# 0x0604
    ("",	X,	1,	"GL_PASS_THROUGH_TOKEN"),	# 0x0700
    ("",	X,	1,	"GL_POINT_TOKEN"),	# 0x0701
    ("",	X,	1,	"GL_LINE_TOKEN"),	# 0x0702
    ("",	X,	1,	"GL_POLYGON_TOKEN"),	# 0x0703
    ("",	X,	1,	"GL_BITMAP_TOKEN"),	# 0x0704
    ("",	X,	1,	"GL_DRAW_PIXEL_TOKEN"),	# 0x0705
    ("",	X,	1,	"GL_COPY_PIXEL_TOKEN"),	# 0x0706
    ("",	X,	1,	"GL_LINE_RESET_TOKEN"),	# 0x0707
    ("",	X,	1,	"GL_EXP"),	# 0x0800
    ("",	X,	1,	"GL_EXP2"),	# 0x0801
    ("",	X,	1,	"GL_CW"),	# 0x0900
    ("",	X,	1,	"GL_CCW"),	# 0x0901
    ("",	X,	1,	"GL_COEFF"),	# 0x0A00
    ("",	X,	1,	"GL_ORDER"),	# 0x0A01
    ("",	X,	1,	"GL_DOMAIN"),	# 0x0A02
    ("glGet",	F,	4,	"GL_CURRENT_COLOR"),	# 0x0B00
    ("glGet",	F,	1,	"GL_CURRENT_INDEX"),	# 0x0B01
    ("glGet",	F,	3,	"GL_CURRENT_NORMAL"),	# 0x0B02
    ("glGet",	F,	4,	"GL_CURRENT_TEXTURE_COORDS"),	# 0x0B03
    ("glGet",	F,	4,	"GL_CURRENT_RASTER_COLOR"),	# 0x0B04
    ("glGet",	F,	1,	"GL_CURRENT_RASTER_INDEX"),	# 0x0B05
    ("glGet",	F,	4,	"GL_CURRENT_RASTER_TEXTURE_COORDS"),	# 0x0B06
    ("glGet",	F,	4,	"GL_CURRENT_RASTER_POSITION"),	# 0x0B07
    ("glGet",	I,	1,	"GL_CURRENT_RASTER_POSITION_VALID"),	# 0x0B08
    ("glGet",	F,	1,	"GL_CURRENT_RASTER_DISTANCE"),	# 0x0B09
    ("glGet",	B,	1,	"GL_POINT_SMOOTH"),	# 0x0B10
    ("glGet",	F,	1,	"GL_POINT_SIZE"),	# 0x0B11
    ("glGet",	F,	2,	"GL_POINT_SIZE_RANGE"),	# 0x0B12
    ("glGet",	F,	1,	"GL_POINT_SIZE_GRANULARITY"),	# 0x0B13
    ("glGet",	B,	1,	"GL_LINE_SMOOTH"),	# 0x0B20
    ("glGet",	F,	1,	"GL_LINE_WIDTH"),	# 0x0B21
    ("glGet",	F,	2,	"GL_LINE_WIDTH_RANGE"),	# 0x0B22
    ("glGet",	F,	1,	"GL_LINE_WIDTH_GRANULARITY"),	# 0x0B23
    ("glGet",	B,	1,	"GL_LINE_STIPPLE"),	# 0x0B24
    ("glGet",	I,	1,	"GL_LINE_STIPPLE_PATTERN"),	# 0x0B25
    ("glGet",	I,	1,	"GL_LINE_STIPPLE_REPEAT"),	# 0x0B26
    ("glGet",	E,	1,	"GL_LIST_MODE"),	# 0x0B30
    ("glGet",	I,	1,	"GL_MAX_LIST_NESTING"),	# 0x0B31
    ("glGet",	I,	1,	"GL_LIST_BASE"),	# 0x0B32
    ("glGet",	I,	1,	"GL_LIST_INDEX"),	# 0x0B33
    ("glGet",	E,	2,	"GL_POLYGON_MODE"),	# 0x0B40
    ("glGet",	B,	1,	"GL_POLYGON_SMOOTH"),	# 0x0B41
    ("glGet",	B,	1,	"GL_POLYGON_STIPPLE"),	# 0x0B42
    ("glGet",	B,	1,	"GL_EDGE_FLAG"),	# 0x0B43
    ("glGet",	B,	1,	"GL_CULL_FACE"),	# 0x0B44
    ("glGet",	E,	1,	"GL_CULL_FACE_MODE"),	# 0x0B45
    ("glGet",	E,	1,	"GL_FRONT_FACE"),	# 0x0B46
    ("glGet",	B,	1,	"GL_LIGHTING"),	# 0x0B50
    ("glGet",	B,	1,	"GL_LIGHT_MODEL_LOCAL_VIEWER"),	# 0x0B51
    ("glGet",	B,	1,	"GL_LIGHT_MODEL_TWO_SIDE"),	# 0x0B52
    ("glGet",	F,	4,	"GL_LIGHT_MODEL_AMBIENT"),	# 0x0B53
    ("glGet",	E,	1,	"GL_SHADE_MODEL"),	# 0x0B54
    ("glGet",	E,	1,	"GL_COLOR_MATERIAL_FACE"),	# 0x0B55
    ("glGet",	E,	1,	"GL_COLOR_MATERIAL_PARAMETER"),	# 0x0B56
    ("glGet",	B,	1,	"GL_COLOR_MATERIAL"),	# 0x0B57
    ("glGet",	B,	1,	"GL_FOG"),	# 0x0B60
    ("glGet",	I,	1,	"GL_FOG_INDEX"),	# 0x0B61
    ("glGet",	F,	1,	"GL_FOG_DENSITY"),	# 0x0B62
    ("glGet",	F,	1,	"GL_FOG_START"),	# 0x0B63
    ("glGet",	F,	1,	"GL_FOG_END"),	# 0x0B64
    ("glGet",	E,	1,	"GL_FOG_MODE"),	# 0x0B65
    ("glGet",	F,	4,	"GL_FOG_COLOR"),	# 0x0B66
    ("glGet",	F,	2,	"GL_DEPTH_RANGE"),	# 0x0B70
    ("glGet",	B,	1,	"GL_DEPTH_TEST"),	# 0x0B71
    ("glGet",	B,	1,	"GL_DEPTH_WRITEMASK"),	# 0x0B72
    ("glGet",	F,	1,	"GL_DEPTH_CLEAR_VALUE"),	# 0x0B73
    ("glGet",	E,	1,	"GL_DEPTH_FUNC"),	# 0x0B74
    ("glGet",	F,	4,	"GL_ACCUM_CLEAR_VALUE"),	# 0x0B80
    ("glGet",	B,	1,	"GL_STENCIL_TEST"),	# 0x0B90
    ("glGet",	I,	1,	"GL_STENCIL_CLEAR_VALUE"),	# 0x0B91
    ("glGet",	E,	1,	"GL_STENCIL_FUNC"),	# 0x0B92
    ("glGet",	I,	1,	"GL_STENCIL_VALUE_MASK"),	# 0x0B93
    ("glGet",	E,	1,	"GL_STENCIL_FAIL"),	# 0x0B94
    ("glGet",	E,	1,	"GL_STENCIL_PASS_DEPTH_FAIL"),	# 0x0B95
    ("glGet",	E,	1,	"GL_STENCIL_PASS_DEPTH_PASS"),	# 0x0B96
    ("glGet",	I,	1,	"GL_STENCIL_REF"),	# 0x0B97
    ("glGet",	I,	1,	"GL_STENCIL_WRITEMASK"),	# 0x0B98
    ("glGet",	E,	1,	"GL_MATRIX_MODE"),	# 0x0BA0
    ("glGet",	B,	1,	"GL_NORMALIZE"),	# 0x0BA1
    ("glGet",	I,	4,	"GL_VIEWPORT"),	# 0x0BA2
    ("glGet",	I,	1,	"GL_MODELVIEW_STACK_DEPTH"),	# 0x0BA3
    ("glGet",	I,	1,	"GL_PROJECTION_STACK_DEPTH"),	# 0x0BA4
    ("glGet",	I,	1,	"GL_TEXTURE_STACK_DEPTH"),	# 0x0BA5
    ("glGet",	F,	16,	"GL_MODELVIEW_MATRIX"),	# 0x0BA6
    ("glGet",	F,	16,	"GL_PROJECTION_MATRIX"),	# 0x0BA7
    ("glGet",	F,	16,	"GL_TEXTURE_MATRIX"),	# 0x0BA8
    ("glGet",	I,	1,	"GL_ATTRIB_STACK_DEPTH"),	# 0x0BB0
    ("glGet",	I,	1,	"GL_CLIENT_ATTRIB_STACK_DEPTH"),	# 0x0BB1
    ("glGet",	B,	1,	"GL_ALPHA_TEST"),	# 0x0BC0
    ("glGet",	E,	1,	"GL_ALPHA_TEST_FUNC"),	# 0x0BC1
    ("glGet",	F,	1,	"GL_ALPHA_TEST_REF"),	# 0x0BC2
    ("glGet",	B,	1,	"GL_DITHER"),	# 0x0BD0
    ("glGet",	E,	1,	"GL_BLEND_DST"),	# 0x0BE0
    ("glGet",	E,	1,	"GL_BLEND_SRC"),	# 0x0BE1
    ("glGet",	B,	1,	"GL_BLEND"),	# 0x0BE2
    ("glGet",	E,	1,	"GL_LOGIC_OP_MODE"),	# 0x0BF0
    ("glGet",	B,	1,	"GL_INDEX_LOGIC_OP"),	# 0x0BF1
    ("glGet",	B,	1,	"GL_COLOR_LOGIC_OP"),	# 0x0BF2
    ("glGet",	I,	1,	"GL_AUX_BUFFERS"),	# 0x0C00
    ("glGet",	E,	1,	"GL_DRAW_BUFFER"),	# 0x0C01
    ("glGet",	E,	1,	"GL_READ_BUFFER"),	# 0x0C02
    ("glGet",	I,	4,	"GL_SCISSOR_BOX"),	# 0x0C10
    ("glGet",	B,	1,	"GL_SCISSOR_TEST"),	# 0x0C11
    ("glGet",	I,	1,	"GL_INDEX_CLEAR_VALUE"),	# 0x0C20
    ("glGet",	I,	1,	"GL_INDEX_WRITEMASK"),	# 0x0C21
    ("glGet",	F,	4,	"GL_COLOR_CLEAR_VALUE"),	# 0x0C22
    ("glGet",	B,	4,	"GL_COLOR_WRITEMASK"),	# 0x0C23
    ("glGet",	B,	1,	"GL_INDEX_MODE"),	# 0x0C30
    ("glGet",	B,	1,	"GL_RGBA_MODE"),	# 0x0C31
    ("glGet",	B,	1,	"GL_DOUBLEBUFFER"),	# 0x0C32
    ("glGet",	B,	1,	"GL_STEREO"),	# 0x0C33
    ("glGet",	E,	1,	"GL_RENDER_MODE"),	# 0x0C40
    ("glGet",	E,	1,	"GL_PERSPECTIVE_CORRECTION_HINT"),	# 0x0C50
    ("glGet",	E,	1,	"GL_POINT_SMOOTH_HINT"),	# 0x0C51
    ("glGet",	E,	1,	"GL_LINE_SMOOTH_HINT"),	# 0x0C52
    ("glGet",	E,	1,	"GL_POLYGON_SMOOTH_HINT"),	# 0x0C53
    ("glGet",	E,	1,	"GL_FOG_HINT"),	# 0x0C54
    ("glGet",	B,	1,	"GL_TEXTURE_GEN_S"),	# 0x0C60
    ("glGet",	B,	1,	"GL_TEXTURE_GEN_T"),	# 0x0C61
    ("glGet",	B,	1,	"GL_TEXTURE_GEN_R"),	# 0x0C62
    ("glGet",	B,	1,	"GL_TEXTURE_GEN_Q"),	# 0x0C63
    ("",	X,	1,	"GL_PIXEL_MAP_I_TO_I"),	# 0x0C70
    ("",	X,	1,	"GL_PIXEL_MAP_S_TO_S"),	# 0x0C71
    ("",	X,	1,	"GL_PIXEL_MAP_I_TO_R"),	# 0x0C72
    ("",	X,	1,	"GL_PIXEL_MAP_I_TO_G"),	# 0x0C73
    ("",	X,	1,	"GL_PIXEL_MAP_I_TO_B"),	# 0x0C74
    ("",	X,	1,	"GL_PIXEL_MAP_I_TO_A"),	# 0x0C75
    ("",	X,	1,	"GL_PIXEL_MAP_R_TO_R"),	# 0x0C76
    ("",	X,	1,	"GL_PIXEL_MAP_G_TO_G"),	# 0x0C77
    ("",	X,	1,	"GL_PIXEL_MAP_B_TO_B"),	# 0x0C78
    ("",	X,	1,	"GL_PIXEL_MAP_A_TO_A"),	# 0x0C79
    ("glGet",	I,	1,	"GL_PIXEL_MAP_I_TO_I_SIZE"),	# 0x0CB0
    ("glGet",	I,	1,	"GL_PIXEL_MAP_S_TO_S_SIZE"),	# 0x0CB1
    ("glGet",	I,	1,	"GL_PIXEL_MAP_I_TO_R_SIZE"),	# 0x0CB2
    ("glGet",	I,	1,	"GL_PIXEL_MAP_I_TO_G_SIZE"),	# 0x0CB3
    ("glGet",	I,	1,	"GL_PIXEL_MAP_I_TO_B_SIZE"),	# 0x0CB4
    ("glGet",	I,	1,	"GL_PIXEL_MAP_I_TO_A_SIZE"),	# 0x0CB5
    ("glGet",	I,	1,	"GL_PIXEL_MAP_R_TO_R_SIZE"),	# 0x0CB6
    ("glGet",	I,	1,	"GL_PIXEL_MAP_G_TO_G_SIZE"),	# 0x0CB7
    ("glGet",	I,	1,	"GL_PIXEL_MAP_B_TO_B_SIZE"),	# 0x0CB8
    ("glGet",	I,	1,	"GL_PIXEL_MAP_A_TO_A_SIZE"),	# 0x0CB9
    ("glGet",	B,	1,	"GL_UNPACK_SWAP_BYTES"),	# 0x0CF0
    ("glGet",	B,	1,	"GL_UNPACK_LSB_FIRST"),	# 0x0CF1
    ("glGet",	I,	1,	"GL_UNPACK_ROW_LENGTH"),	# 0x0CF2
    ("glGet",	I,	1,	"GL_UNPACK_SKIP_ROWS"),	# 0x0CF3
    ("glGet",	I,	1,	"GL_UNPACK_SKIP_PIXELS"),	# 0x0CF4
    ("glGet",	I,	1,	"GL_UNPACK_ALIGNMENT"),	# 0x0CF5
    ("glGet",	B,	1,	"GL_PACK_SWAP_BYTES"),	# 0x0D00
    ("glGet",	B,	1,	"GL_PACK_LSB_FIRST"),	# 0x0D01
    ("glGet",	I,	1,	"GL_PACK_ROW_LENGTH"),	# 0x0D02
    ("glGet",	I,	1,	"GL_PACK_SKIP_ROWS"),	# 0x0D03
    ("glGet",	I,	1,	"GL_PACK_SKIP_PIXELS"),	# 0x0D04
    ("glGet",	I,	1,	"GL_PACK_ALIGNMENT"),	# 0x0D05
    ("glGet",	B,	1,	"GL_MAP_COLOR"),	# 0x0D10
    ("glGet",	B,	1,	"GL_MAP_STENCIL"),	# 0x0D11
    ("glGet",	I,	1,	"GL_INDEX_SHIFT"),	# 0x0D12
    ("glGet",	I,	1,	"GL_INDEX_OFFSET"),	# 0x0D13
    ("glGet",	F,	1,	"GL_RED_SCALE"),	# 0x0D14
    ("glGet",	F,	1,	"GL_RED_BIAS"),	# 0x0D15
    ("glGet",	F,	1,	"GL_ZOOM_X"),	# 0x0D16
    ("glGet",	F,	1,	"GL_ZOOM_Y"),	# 0x0D17
    ("glGet",	F,	1,	"GL_GREEN_SCALE"),	# 0x0D18
    ("glGet",	F,	1,	"GL_GREEN_BIAS"),	# 0x0D19
    ("glGet",	F,	1,	"GL_BLUE_SCALE"),	# 0x0D1A
    ("glGet",	F,	1,	"GL_BLUE_BIAS"),	# 0x0D1B
    ("glGet,glGetTexEnv",	F,	1,	"GL_ALPHA_SCALE"),	# 0x0D1C
    ("glGet",	F,	1,	"GL_ALPHA_BIAS"),	# 0x0D1D
    ("glGet",	F,	1,	"GL_DEPTH_SCALE"),	# 0x0D1E
    ("glGet",	F,	1,	"GL_DEPTH_BIAS"),	# 0x0D1F
    ("glGet",	I,	1,	"GL_MAX_EVAL_ORDER"),	# 0x0D30
    ("glGet",	I,	1,	"GL_MAX_LIGHTS"),	# 0x0D31
    ("glGet",	I,	1,	"GL_MAX_CLIP_DISTANCES"),	# 0x0D32
    ("glGet",	I,	1,	"GL_MAX_TEXTURE_SIZE"),	# 0x0D33
    ("glGet",	I,	1,	"GL_MAX_PIXEL_MAP_TABLE"),	# 0x0D34
    ("glGet",	I,	1,	"GL_MAX_ATTRIB_STACK_DEPTH"),	# 0x0D35
    ("glGet",	I,	1,	"GL_MAX_MODELVIEW_STACK_DEPTH"),	# 0x0D36
    ("glGet",	I,	1,	"GL_MAX_NAME_STACK_DEPTH"),	# 0x0D37
    ("glGet",	I,	1,	"GL_MAX_PROJECTION_STACK_DEPTH"),	# 0x0D38
    ("glGet",	I,	1,	"GL_MAX_TEXTURE_STACK_DEPTH"),	# 0x0D39
    ("glGet",	F,	2,	"GL_MAX_VIEWPORT_DIMS"),	# 0x0D3A
    ("glGet",	I,	1,	"GL_MAX_CLIENT_ATTRIB_STACK_DEPTH"),	# 0x0D3B
    ("glGet",	I,	1,	"GL_SUBPIXEL_BITS"),	# 0x0D50
    ("glGet",	I,	1,	"GL_INDEX_BITS"),	# 0x0D51
    ("glGet",	I,	1,	"GL_RED_BITS"),	# 0x0D52
    ("glGet",	I,	1,	"GL_GREEN_BITS"),	# 0x0D53
    ("glGet",	I,	1,	"GL_BLUE_BITS"),	# 0x0D54
    ("glGet",	I,	1,	"GL_ALPHA_BITS"),	# 0x0D55
    ("glGet",	I,	1,	"GL_DEPTH_BITS"),	# 0x0D56
    ("glGet",	I,	1,	"GL_STENCIL_BITS"),	# 0x0D57
    ("glGet",	I,	1,	"GL_ACCUM_RED_BITS"),	# 0x0D58
    ("glGet",	I,	1,	"GL_ACCUM_GREEN_BITS"),	# 0x0D59
    ("glGet",	I,	1,	"GL_ACCUM_BLUE_BITS"),	# 0x0D5A
    ("glGet",	I,	1,	"GL_ACCUM_ALPHA_BITS"),	# 0x0D5B
    ("glGet",	I,	1,	"GL_NAME_STACK_DEPTH"),	# 0x0D70
    ("glGet",	B,	1,	"GL_AUTO_NORMAL"),	# 0x0D80
    ("glGet",	B,	1,	"GL_MAP1_COLOR_4"),	# 0x0D90
    ("glGet",	B,	1,	"GL_MAP1_INDEX"),	# 0x0D91
    ("glGet",	B,	1,	"GL_MAP1_NORMAL"),	# 0x0D92
    ("glGet",	B,	1,	"GL_MAP1_TEXTURE_COORD_1"),	# 0x0D93
    ("glGet",	B,	1,	"GL_MAP1_TEXTURE_COORD_2"),	# 0x0D94
    ("glGet",	B,	1,	"GL_MAP1_TEXTURE_COORD_3"),	# 0x0D95
    ("glGet",	B,	1,	"GL_MAP1_TEXTURE_COORD_4"),	# 0x0D96
    ("glGet",	B,	1,	"GL_MAP1_VERTEX_3"),	# 0x0D97
    ("glGet",	B,	1,	"GL_MAP1_VERTEX_4"),	# 0x0D98
    ("glGet",	B,	1,	"GL_MAP2_COLOR_4"),	# 0x0DB0
    ("glGet",	B,	1,	"GL_MAP2_INDEX"),	# 0x0DB1
    ("glGet",	B,	1,	"GL_MAP2_NORMAL"),	# 0x0DB2
    ("glGet",	B,	1,	"GL_MAP2_TEXTURE_COORD_1"),	# 0x0DB3
    ("glGet",	B,	1,	"GL_MAP2_TEXTURE_COORD_2"),	# 0x0DB4
    ("glGet",	B,	1,	"GL_MAP2_TEXTURE_COORD_3"),	# 0x0DB5
    ("glGet",	B,	1,	"GL_MAP2_TEXTURE_COORD_4"),	# 0x0DB6
    ("glGet",	B,	1,	"GL_MAP2_VERTEX_3"),	# 0x0DB7
    ("glGet",	B,	1,	"GL_MAP2_VERTEX_4"),	# 0x0DB8
    ("glGet",	F,	2,	"GL_MAP1_GRID_DOMAIN"),	# 0x0DD0
    ("glGet",	I,	1,	"GL_MAP1_GRID_SEGMENTS"),	# 0x0DD1
    ("glGet",	F,	4,	"GL_MAP2_GRID_DOMAIN"),	# 0x0DD2
    ("glGet",	I,	2,	"GL_MAP2_GRID_SEGMENTS"),	# 0x0DD3
    ("_glGet",	B,	1,	"GL_TEXTURE_1D"),	# 0x0DE0
    ("_glGet",	B,	1,	"GL_TEXTURE_2D"),	# 0x0DE1
    ("glGet",	P,	1,	"GL_FEEDBACK_BUFFER_POINTER"),	# 0x0DF0
    ("glGet",	I,	1,	"GL_FEEDBACK_BUFFER_SIZE"),	# 0x0DF1
    ("glGet",	E,	1,	"GL_FEEDBACK_BUFFER_TYPE"),	# 0x0DF2
    ("glGet",	P,	1,	"GL_SELECTION_BUFFER_POINTER"),	# 0x0DF3
    ("glGet",	I,	1,	"GL_SELECTION_BUFFER_SIZE"),	# 0x0DF4
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_WIDTH"),	# 0x1000
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_HEIGHT"),	# 0x1001
    ("glGetTexLevelParameter",	E,	1,	"GL_TEXTURE_INTERNAL_FORMAT"),	# 0x1003
    ("glGetTexParameter,glGetSamplerParameter",	F,	4,	"GL_TEXTURE_BORDER_COLOR"),	# 0x1004
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_BORDER"),	# 0x1005
    ("",	X,	1,	"GL_DONT_CARE"),	# 0x1100
    ("",	X,	1,	"GL_FASTEST"),	# 0x1101
    ("",	X,	1,	"GL_NICEST"),	# 0x1102
    ("glGetLight,glGetMaterial",	F,	4,	"GL_AMBIENT"),	# 0x1200
    ("glGetLight,glGetMaterial",	F,	4,	"GL_DIFFUSE"),	# 0x1201
    ("glGetLight,glGetMaterial",	F,	4,	"GL_SPECULAR"),	# 0x1202
    ("glGetLight",	F,	4,	"GL_POSITION"),	# 0x1203
    ("glGetLight",	F,	3,	"GL_SPOT_DIRECTION"),	# 0x1204
    ("glGetLight",	F,	1,	"GL_SPOT_EXPONENT"),	# 0x1205
    ("glGetLight",	F,	1,	"GL_SPOT_CUTOFF"),	# 0x1206
    ("glGetLight",	F,	1,	"GL_CONSTANT_ATTENUATION"),	# 0x1207
    ("glGetLight",	F,	1,	"GL_LINEAR_ATTENUATION"),	# 0x1208
    ("glGetLight",	F,	1,	"GL_QUADRATIC_ATTENUATION"),	# 0x1209
    ("",	X,	1,	"GL_COMPILE"),	# 0x1300
    ("",	X,	1,	"GL_COMPILE_AND_EXECUTE"),	# 0x1301
    ("",	X,	1,	"GL_BYTE"),	# 0x1400
    ("",	X,	1,	"GL_UNSIGNED_BYTE"),	# 0x1401
    ("",	X,	1,	"GL_SHORT"),	# 0x1402
    ("",	X,	1,	"GL_UNSIGNED_SHORT"),	# 0x1403
    ("",	X,	1,	"GL_INT"),	# 0x1404
    ("",	X,	1,	"GL_UNSIGNED_INT"),	# 0x1405
    ("",	X,	1,	"GL_FLOAT"),	# 0x1406
    ("",	X,	1,	"GL_2_BYTES"),	# 0x1407
    ("",	X,	1,	"GL_3_BYTES"),	# 0x1408
    ("",	X,	1,	"GL_4_BYTES"),	# 0x1409
    ("",	X,	1,	"GL_DOUBLE"),	# 0x140A
    ("",	X,	1,	"GL_HALF_FLOAT"),	# 0x140B
    ("",	X,	1,	"GL_FIXED"),	# 0x140C
    ("",	X,	1,	"GL_INT64_NV"),	# 0x140E
    ("",	X,	1,	"GL_UNSIGNED_INT64_ARB"),	# 0x140F
    ("",	X,	1,	"GL_CLEAR"),	# 0x1500
    ("",	X,	1,	"GL_AND"),	# 0x1501
    ("",	X,	1,	"GL_AND_REVERSE"),	# 0x1502
    ("",	X,	1,	"GL_COPY"),	# 0x1503
    ("",	X,	1,	"GL_AND_INVERTED"),	# 0x1504
    ("",	X,	1,	"GL_NOOP"),	# 0x1505
    ("",	X,	1,	"GL_XOR"),	# 0x1506
    ("",	X,	1,	"GL_OR"),	# 0x1507
    ("",	X,	1,	"GL_NOR"),	# 0x1508
    ("",	X,	1,	"GL_EQUIV"),	# 0x1509
    ("",	X,	1,	"GL_INVERT"),	# 0x150A
    ("",	X,	1,	"GL_OR_REVERSE"),	# 0x150B
    ("",	X,	1,	"GL_COPY_INVERTED"),	# 0x150C
    ("",	X,	1,	"GL_OR_INVERTED"),	# 0x150D
    ("",	X,	1,	"GL_NAND"),	# 0x150E
    ("",	X,	1,	"GL_SET"),	# 0x150F
    ("glGetMaterial",	F,	4,	"GL_EMISSION"),	# 0x1600
    ("glGetMaterial",	F,	1,	"GL_SHININESS"),	# 0x1601
    ("",	F,	4,	"GL_AMBIENT_AND_DIFFUSE"),	# 0x1602
    ("glGetMaterial",	F,	3,	"GL_COLOR_INDEXES"),	# 0x1603
    ("",	X,	1,	"GL_MODELVIEW"),	# 0x1700
    ("",	X,	1,	"GL_PROJECTION"),	# 0x1701
    ("",	X,	1,	"GL_TEXTURE"),	# 0x1702
    ("",	X,	1,	"GL_COLOR"),	# 0x1800
    ("",	X,	1,	"GL_DEPTH"),	# 0x1801
    ("",	X,	1,	"GL_STENCIL"),	# 0x1802
    ("",	X,	1,	"GL_COLOR_INDEX"),	# 0x1900
    ("",	X,	1,	"GL_STENCIL_INDEX"),	# 0x1901
    ("",	X,	1,	"GL_DEPTH_COMPONENT"),	# 0x1902
    ("",	X,	1,	"GL_RED"),	# 0x1903
    ("",	X,	1,	"GL_GREEN"),	# 0x1904
    ("",	X,	1,	"GL_BLUE"),	# 0x1905
    ("",	X,	1,	"GL_ALPHA"),	# 0x1906
    ("",	X,	1,	"GL_RGB"),	# 0x1907
    ("",	X,	1,	"GL_RGBA"),	# 0x1908
    ("",	X,	1,	"GL_LUMINANCE"),	# 0x1909
    ("",	X,	1,	"GL_LUMINANCE_ALPHA"),	# 0x190A
    ("",	X,	1,	"GL_BITMAP"),	# 0x1A00
    ("",	X,	1,	"GL_POINT"),	# 0x1B00
    ("",	X,	1,	"GL_LINE"),	# 0x1B01
    ("",	X,	1,	"GL_FILL"),	# 0x1B02
    ("",	X,	1,	"GL_RENDER"),	# 0x1C00
    ("",	X,	1,	"GL_FEEDBACK"),	# 0x1C01
    ("",	X,	1,	"GL_SELECT"),	# 0x1C02
    ("",	X,	1,	"GL_FLAT"),	# 0x1D00
    ("",	X,	1,	"GL_SMOOTH"),	# 0x1D01
    ("",	X,	1,	"GL_KEEP"),	# 0x1E00
    ("",	X,	1,	"GL_REPLACE"),	# 0x1E01
    ("",	X,	1,	"GL_INCR"),	# 0x1E02
    ("",	X,	1,	"GL_DECR"),	# 0x1E03
    ("glGet",	S,	1,	"GL_VENDOR"),	# 0x1F00
    ("glGet",	S,	1,	"GL_RENDERER"),	# 0x1F01
    ("glGet",	S,	1,	"GL_VERSION"),	# 0x1F02
    ("glGet",	S,	1,	"GL_EXTENSIONS"),	# 0x1F03
    ("",	X,	1,	"GL_S"),	# 0x2000
    ("",	X,	1,	"GL_T"),	# 0x2001
    ("",	X,	1,	"GL_R"),	# 0x2002
    ("",	X,	1,	"GL_Q"),	# 0x2003
    ("",	X,	1,	"GL_MODULATE"),	# 0x2100
    ("",	X,	1,	"GL_DECAL"),	# 0x2101
    ("glGetTexEnv",	E,	1,	"GL_TEXTURE_ENV_MODE"),	# 0x2200
    ("glGetTexEnv",	F,	4,	"GL_TEXTURE_ENV_COLOR"),	# 0x2201
    ("",	X,	1,	"GL_TEXTURE_ENV"),	# 0x2300
    ("",	X,	1,	"GL_EYE_LINEAR"),	# 0x2400
    ("",	X,	1,	"GL_OBJECT_LINEAR"),	# 0x2401
    ("",	X,	1,	"GL_SPHERE_MAP"),	# 0x2402
    ("glGetTexGen",	E,	1,	"GL_TEXTURE_GEN_MODE"),	# 0x2500
    ("glGetTexGen",	F,	4,	"GL_OBJECT_PLANE"),	# 0x2501
    ("glGetTexGen",	F,	4,	"GL_EYE_PLANE"),	# 0x2502
    ("",	X,	1,	"GL_NEAREST"),	# 0x2600
    ("",	X,	1,	"GL_LINEAR"),	# 0x2601
    ("",	X,	1,	"GL_NEAREST_MIPMAP_NEAREST"),	# 0x2700
    ("",	X,	1,	"GL_LINEAR_MIPMAP_NEAREST"),	# 0x2701
    ("",	X,	1,	"GL_NEAREST_MIPMAP_LINEAR"),	# 0x2702
    ("",	X,	1,	"GL_LINEAR_MIPMAP_LINEAR"),	# 0x2703
    ("glGetTexParameter,glGetSamplerParameter",	E,	1,	"GL_TEXTURE_MAG_FILTER"),	# 0x2800
    ("glGetTexParameter,glGetSamplerParameter",	E,	1,	"GL_TEXTURE_MIN_FILTER"),	# 0x2801
    ("glGetTexParameter,glGetSamplerParameter",	E,	1,	"GL_TEXTURE_WRAP_S"),	# 0x2802
    ("glGetTexParameter,glGetSamplerParameter",	E,	1,	"GL_TEXTURE_WRAP_T"),	# 0x2803
    ("",	X,	1,	"GL_CLAMP"),	# 0x2900
    ("",	X,	1,	"GL_REPEAT"),	# 0x2901
    ("glGet",	F,	1,	"GL_POLYGON_OFFSET_UNITS"),	# 0x2A00
    ("glGet",	B,	1,	"GL_POLYGON_OFFSET_POINT"),	# 0x2A01
    ("glGet",	B,	1,	"GL_POLYGON_OFFSET_LINE"),	# 0x2A02
    ("",	X,	1,	"GL_R3_G3_B2"),	# 0x2A10
    ("",	X,	1,	"GL_V2F"),	# 0x2A20
    ("",	X,	1,	"GL_V3F"),	# 0x2A21
    ("",	X,	1,	"GL_C4UB_V2F"),	# 0x2A22
    ("",	X,	1,	"GL_C4UB_V3F"),	# 0x2A23
    ("",	X,	1,	"GL_C3F_V3F"),	# 0x2A24
    ("",	X,	1,	"GL_N3F_V3F"),	# 0x2A25
    ("",	X,	1,	"GL_C4F_N3F_V3F"),	# 0x2A26
    ("",	X,	1,	"GL_T2F_V3F"),	# 0x2A27
    ("",	X,	1,	"GL_T4F_V4F"),	# 0x2A28
    ("",	X,	1,	"GL_T2F_C4UB_V3F"),	# 0x2A29
    ("",	X,	1,	"GL_T2F_C3F_V3F"),	# 0x2A2A
    ("",	X,	1,	"GL_T2F_N3F_V3F"),	# 0x2A2B
    ("",	X,	1,	"GL_T2F_C4F_N3F_V3F"),	# 0x2A2C
    ("",	X,	1,	"GL_T4F_C4F_N3F_V4F"),	# 0x2A2D
    ("glGet",	B,	1,	"GL_CLIP_DISTANCE0"),	# 0x3000
    ("glGet",	B,	1,	"GL_CLIP_DISTANCE1"),	# 0x3001
    ("glGet",	B,	1,	"GL_CLIP_DISTANCE2"),	# 0x3002
    ("glGet",	B,	1,	"GL_CLIP_DISTANCE3"),	# 0x3003
    ("glGet",	B,	1,	"GL_CLIP_DISTANCE4"),	# 0x3004
    ("glGet",	B,	1,	"GL_CLIP_DISTANCE5"),	# 0x3005
    ("glGet",	B,	1,	"GL_CLIP_DISTANCE6"),	# 0x3006
    ("glGet",	B,	1,	"GL_CLIP_DISTANCE7"),	# 0x3007
    ("_glGet",	B,	1,	"GL_LIGHT0"),	# 0x4000
    ("_glGet",	B,	1,	"GL_LIGHT1"),	# 0x4001
    ("_glGet",	B,	1,	"GL_LIGHT2"),	# 0x4002
    ("_glGet",	B,	1,	"GL_LIGHT3"),	# 0x4003
    ("_glGet",	B,	1,	"GL_LIGHT4"),	# 0x4004
    ("_glGet",	B,	1,	"GL_LIGHT5"),	# 0x4005
    ("_glGet",	B,	1,	"GL_LIGHT6"),	# 0x4006
    ("_glGet",	B,	1,	"GL_LIGHT7"),	# 0x4007
    ("",	X,	1,	"GL_ABGR_EXT"),	# 0x8000
    ("",	X,	1,	"GL_CONSTANT_COLOR"),	# 0x8001
    ("",	X,	1,	"GL_ONE_MINUS_CONSTANT_COLOR"),	# 0x8002
    ("",	X,	1,	"GL_CONSTANT_ALPHA"),	# 0x8003
    ("",	X,	1,	"GL_ONE_MINUS_CONSTANT_ALPHA"),	# 0x8004
    ("glGet",	F,	4,	"GL_BLEND_COLOR"),	# 0x8005
    ("",	X,	1,	"GL_FUNC_ADD"),	# 0x8006
    ("",	X,	1,	"GL_MIN"),	# 0x8007
    ("",	X,	1,	"GL_MAX"),	# 0x8008
    ("glGet",	E,	1,	"GL_BLEND_EQUATION"),	# 0x8009
    ("",	X,	1,	"GL_FUNC_SUBTRACT"),	# 0x800A
    ("",	X,	1,	"GL_FUNC_REVERSE_SUBTRACT"),	# 0x800B
    ("",	X,	1,	"GL_CMYK_EXT"),	# 0x800C
    ("",	X,	1,	"GL_CMYKA_EXT"),	# 0x800D
    ("glGet",	I,	1,	"GL_PACK_CMYK_HINT_EXT"),	# 0x800E
    ("glGet",	I,	1,	"GL_UNPACK_CMYK_HINT_EXT"),	# 0x800F
    ("glGet",	B,	1,	"GL_CONVOLUTION_1D"),	# 0x8010
    ("glGet",	B,	1,	"GL_CONVOLUTION_2D"),	# 0x8011
    ("glGet",	B,	1,	"GL_SEPARABLE_2D"),	# 0x8012
    ("glGetConvolutionParameter",	E,	1,	"GL_CONVOLUTION_BORDER_MODE"),	# 0x8013
    ("glGetConvolutionParameter",	F,	4,	"GL_CONVOLUTION_FILTER_SCALE"),	# 0x8014
    ("glGetConvolutionParameter",	F,	4,	"GL_CONVOLUTION_FILTER_BIAS"),	# 0x8015
    ("",	X,	1,	"GL_REDUCE"),	# 0x8016
    ("glGetConvolutionParameter",	E,	1,	"GL_CONVOLUTION_FORMAT"),	# 0x8017
    ("glGetConvolutionParameter",	I,	1,	"GL_CONVOLUTION_WIDTH"),	# 0x8018
    ("glGetConvolutionParameter",	I,	1,	"GL_CONVOLUTION_HEIGHT"),	# 0x8019
    ("glGetConvolutionParameter",	I,	1,	"GL_MAX_CONVOLUTION_WIDTH"),	# 0x801A
    ("glGetConvolutionParameter",	I,	1,	"GL_MAX_CONVOLUTION_HEIGHT"),	# 0x801B
    ("glGet",	F,	1,	"GL_POST_CONVOLUTION_RED_SCALE"),	# 0x801C
    ("glGet",	F,	1,	"GL_POST_CONVOLUTION_GREEN_SCALE"),	# 0x801D
    ("glGet",	F,	1,	"GL_POST_CONVOLUTION_BLUE_SCALE"),	# 0x801E
    ("glGet",	F,	1,	"GL_POST_CONVOLUTION_ALPHA_SCALE"),	# 0x801F
    ("glGet",	F,	1,	"GL_POST_CONVOLUTION_RED_BIAS"),	# 0x8020
    ("glGet",	F,	1,	"GL_POST_CONVOLUTION_GREEN_BIAS"),	# 0x8021
    ("glGet",	F,	1,	"GL_POST_CONVOLUTION_BLUE_BIAS"),	# 0x8022
    ("glGet",	F,	1,	"GL_POST_CONVOLUTION_ALPHA_BIAS"),	# 0x8023
    ("glGet",	B,	1,	"GL_HISTOGRAM"),	# 0x8024
    ("",	X,	1,	"GL_PROXY_HISTOGRAM"),	# 0x8025
    ("glGetHistogramParameter",	I,	1,	"GL_HISTOGRAM_WIDTH"),	# 0x8026
    ("glGetHistogramParameter",	E,	1,	"GL_HISTOGRAM_FORMAT"),	# 0x8027
    ("glGetHistogramParameter",	I,	1,	"GL_HISTOGRAM_RED_SIZE"),	# 0x8028
    ("glGetHistogramParameter",	I,	1,	"GL_HISTOGRAM_GREEN_SIZE"),	# 0x8029
    ("glGetHistogramParameter",	I,	1,	"GL_HISTOGRAM_BLUE_SIZE"),	# 0x802A
    ("glGetHistogramParameter",	I,	1,	"GL_HISTOGRAM_ALPHA_SIZE"),	# 0x802B
    ("glGetHistogramParameter",	I,	1,	"GL_HISTOGRAM_LUMINANCE_SIZE"),	# 0x802C
    ("glGetHistogramParameter",	B,	1,	"GL_HISTOGRAM_SINK"),	# 0x802D
    ("glGet",	B,	1,	"GL_MINMAX"),	# 0x802E
    ("glGetMinMaxParameter",	E,	1,	"GL_MINMAX_FORMAT"),	# 0x802F
    ("glGetMinMaxParameter",	B,	1,	"GL_MINMAX_SINK"),	# 0x8030
    ("",	X,	1,	"GL_TABLE_TOO_LARGE"),	# 0x8031
    ("",	X,	1,	"GL_UNSIGNED_BYTE_3_3_2"),	# 0x8032
    ("",	X,	1,	"GL_UNSIGNED_SHORT_4_4_4_4"),	# 0x8033
    ("",	X,	1,	"GL_UNSIGNED_SHORT_5_5_5_1"),	# 0x8034
    ("",	X,	1,	"GL_UNSIGNED_INT_8_8_8_8"),	# 0x8035
    ("",	X,	1,	"GL_UNSIGNED_INT_10_10_10_2"),	# 0x8036
    ("glGet",	B,	1,	"GL_POLYGON_OFFSET_FILL"),	# 0x8037
    ("glGet",	F,	1,	"GL_POLYGON_OFFSET_FACTOR"),	# 0x8038
    ("glGet",	F,	1,	"GL_POLYGON_OFFSET_BIAS_EXT"),	# 0x8039
    ("glGet",	B,	1,	"GL_RESCALE_NORMAL"),	# 0x803A
    ("",	X,	1,	"GL_ALPHA4"),	# 0x803B
    ("",	X,	1,	"GL_ALPHA8"),	# 0x803C
    ("",	X,	1,	"GL_ALPHA12"),	# 0x803D
    ("",	X,	1,	"GL_ALPHA16"),	# 0x803E
    ("",	X,	1,	"GL_LUMINANCE4"),	# 0x803F
    ("",	X,	1,	"GL_LUMINANCE8"),	# 0x8040
    ("",	X,	1,	"GL_LUMINANCE12"),	# 0x8041
    ("",	X,	1,	"GL_LUMINANCE16"),	# 0x8042
    ("",	X,	1,	"GL_LUMINANCE4_ALPHA4"),	# 0x8043
    ("",	X,	1,	"GL_LUMINANCE6_ALPHA2"),	# 0x8044
    ("",	X,	1,	"GL_LUMINANCE8_ALPHA8"),	# 0x8045
    ("",	X,	1,	"GL_LUMINANCE12_ALPHA4"),	# 0x8046
    ("",	X,	1,	"GL_LUMINANCE12_ALPHA12"),	# 0x8047
    ("",	X,	1,	"GL_LUMINANCE16_ALPHA16"),	# 0x8048
    ("",	X,	1,	"GL_INTENSITY"),	# 0x8049
    ("",	X,	1,	"GL_INTENSITY4"),	# 0x804A
    ("",	X,	1,	"GL_INTENSITY8"),	# 0x804B
    ("",	X,	1,	"GL_INTENSITY12"),	# 0x804C
    ("",	X,	1,	"GL_INTENSITY16"),	# 0x804D
    ("",	X,	1,	"GL_RGB2_EXT"),	# 0x804E
    ("",	X,	1,	"GL_RGB4"),	# 0x804F
    ("",	X,	1,	"GL_RGB5"),	# 0x8050
    ("",	X,	1,	"GL_RGB8"),	# 0x8051
    ("",	X,	1,	"GL_RGB10"),	# 0x8052
    ("",	X,	1,	"GL_RGB12"),	# 0x8053
    ("",	X,	1,	"GL_RGB16"),	# 0x8054
    ("",	X,	1,	"GL_RGBA2"),	# 0x8055
    ("",	X,	1,	"GL_RGBA4"),	# 0x8056
    ("",	X,	1,	"GL_RGB5_A1"),	# 0x8057
    ("",	X,	1,	"GL_RGBA8"),	# 0x8058
    ("",	X,	1,	"GL_RGB10_A2"),	# 0x8059
    ("",	X,	1,	"GL_RGBA12"),	# 0x805A
    ("",	X,	1,	"GL_RGBA16"),	# 0x805B
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_RED_SIZE"),	# 0x805C
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_GREEN_SIZE"),	# 0x805D
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_BLUE_SIZE"),	# 0x805E
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_ALPHA_SIZE"),	# 0x805F
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_LUMINANCE_SIZE"),	# 0x8060
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_INTENSITY_SIZE"),	# 0x8061
    ("",	X,	1,	"GL_REPLACE_EXT"),	# 0x8062
    ("",	X,	1,	"GL_PROXY_TEXTURE_1D"),	# 0x8063
    ("",	X,	1,	"GL_PROXY_TEXTURE_2D"),	# 0x8064
    ("",	X,	1,	"GL_TEXTURE_TOO_LARGE_EXT"),	# 0x8065
    ("glGetTexParameter",	F,	1,	"GL_TEXTURE_PRIORITY"),	# 0x8066
    ("glGetTexParameter",	B,	1,	"GL_TEXTURE_RESIDENT"),	# 0x8067
    ("_glGet",	I,	1,	"GL_TEXTURE_BINDING_1D"),	# 0x8068
    ("_glGet",	I,	1,	"GL_TEXTURE_BINDING_2D"),	# 0x8069
    ("_glGet",	I,	1,	"GL_TEXTURE_BINDING_3D"),	# 0x806A
    ("glGet",	I,	1,	"GL_PACK_SKIP_IMAGES"),	# 0x806B
    ("glGet",	F,	1,	"GL_PACK_IMAGE_HEIGHT"),	# 0x806C
    ("glGet",	I,	1,	"GL_UNPACK_SKIP_IMAGES"),	# 0x806D
    ("glGet",	F,	1,	"GL_UNPACK_IMAGE_HEIGHT"),	# 0x806E
    ("glGet",	B,	1,	"GL_TEXTURE_3D"),	# 0x806F
    ("",	X,	1,	"GL_PROXY_TEXTURE_3D"),	# 0x8070
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_DEPTH"),	# 0x8071
    ("glGetTexParameter,glGetSamplerParameter",	E,	1,	"GL_TEXTURE_WRAP_R"),	# 0x8072
    ("glGet",	I,	1,	"GL_MAX_3D_TEXTURE_SIZE"),	# 0x8073
    ("glGet",	B,	1,	"GL_VERTEX_ARRAY"),	# 0x8074
    ("glGet",	B,	1,	"GL_NORMAL_ARRAY"),	# 0x8075
    ("glGet",	B,	1,	"GL_COLOR_ARRAY"),	# 0x8076
    ("glGet",	B,	1,	"GL_INDEX_ARRAY"),	# 0x8077
    ("glGet",	B,	1,	"GL_TEXTURE_COORD_ARRAY"),	# 0x8078
    ("glGet",	B,	1,	"GL_EDGE_FLAG_ARRAY"),	# 0x8079
    ("glGet",	I,	1,	"GL_VERTEX_ARRAY_SIZE"),	# 0x807A
    ("glGet",	E,	1,	"GL_VERTEX_ARRAY_TYPE"),	# 0x807B
    ("glGet",	I,	1,	"GL_VERTEX_ARRAY_STRIDE"),	# 0x807C
    ("glGet",	I,	1,	"GL_VERTEX_ARRAY_COUNT_EXT"),	# 0x807D
    ("glGet",	E,	1,	"GL_NORMAL_ARRAY_TYPE"),	# 0x807E
    ("glGet",	I,	1,	"GL_NORMAL_ARRAY_STRIDE"),	# 0x807F
    ("glGet",	I,	1,	"GL_NORMAL_ARRAY_COUNT_EXT"),	# 0x8080
    ("glGet",	I,	1,	"GL_COLOR_ARRAY_SIZE"),	# 0x8081
    ("glGet",	E,	1,	"GL_COLOR_ARRAY_TYPE"),	# 0x8082
    ("glGet",	I,	1,	"GL_COLOR_ARRAY_STRIDE"),	# 0x8083
    ("glGet",	I,	1,	"GL_COLOR_ARRAY_COUNT_EXT"),	# 0x8084
    ("glGet",	E,	1,	"GL_INDEX_ARRAY_TYPE"),	# 0x8085
    ("glGet",	I,	1,	"GL_INDEX_ARRAY_STRIDE"),	# 0x8086
    ("glGet",	I,	1,	"GL_INDEX_ARRAY_COUNT_EXT"),	# 0x8087
    ("glGet",	I,	1,	"GL_TEXTURE_COORD_ARRAY_SIZE"),	# 0x8088
    ("glGet",	E,	1,	"GL_TEXTURE_COORD_ARRAY_TYPE"),	# 0x8089
    ("glGet",	I,	1,	"GL_TEXTURE_COORD_ARRAY_STRIDE"),	# 0x808A
    ("glGet",	I,	1,	"GL_TEXTURE_COORD_ARRAY_COUNT_EXT"),	# 0x808B
    ("glGet",	I,	1,	"GL_EDGE_FLAG_ARRAY_STRIDE"),	# 0x808C
    ("glGet",	I,	1,	"GL_EDGE_FLAG_ARRAY_COUNT_EXT"),	# 0x808D
    ("glGet",	P,	1,	"GL_VERTEX_ARRAY_POINTER"),	# 0x808E
    ("glGet",	P,	1,	"GL_NORMAL_ARRAY_POINTER"),	# 0x808F
    ("glGet",	P,	1,	"GL_COLOR_ARRAY_POINTER"),	# 0x8090
    ("glGet",	P,	1,	"GL_INDEX_ARRAY_POINTER"),	# 0x8091
    ("glGet",	P,	1,	"GL_TEXTURE_COORD_ARRAY_POINTER"),	# 0x8092
    ("glGet",	P,	1,	"GL_EDGE_FLAG_ARRAY_POINTER"),	# 0x8093
    ("glGet",	I,	1,	"GL_INTERLACE_SGIX"),	# 0x8094
    ("",	X,	1,	"GL_DETAIL_TEXTURE_2D_SGIS"),	# 0x8095
    ("glGet",	I,	1,	"GL_DETAIL_TEXTURE_2D_BINDING_SGIS"),	# 0x8096
    ("",	X,	1,	"GL_LINEAR_DETAIL_SGIS"),	# 0x8097
    ("",	X,	1,	"GL_LINEAR_DETAIL_ALPHA_SGIS"),	# 0x8098
    ("",	X,	1,	"GL_LINEAR_DETAIL_COLOR_SGIS"),	# 0x8099
    ("",	X,	1,	"GL_DETAIL_TEXTURE_LEVEL_SGIS"),	# 0x809A
    ("",	X,	1,	"GL_DETAIL_TEXTURE_MODE_SGIS"),	# 0x809B
    ("",	X,	1,	"GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS"),	# 0x809C
    ("glGet",	I,	1,	"GL_MULTISAMPLE"),	# 0x809D
    ("glGet",	I,	1,	"GL_SAMPLE_ALPHA_TO_COVERAGE"),	# 0x809E
    ("glGet",	I,	1,	"GL_SAMPLE_ALPHA_TO_ONE"),	# 0x809F
    ("glGet",	I,	1,	"GL_SAMPLE_COVERAGE"),	# 0x80A0
    ("",	X,	1,	"GL_1PASS_EXT"),	# 0x80A1
    ("",	X,	1,	"GL_2PASS_0_EXT"),	# 0x80A2
    ("",	X,	1,	"GL_2PASS_1_EXT"),	# 0x80A3
    ("",	X,	1,	"GL_4PASS_0_EXT"),	# 0x80A4
    ("",	X,	1,	"GL_4PASS_1_EXT"),	# 0x80A5
    ("",	X,	1,	"GL_4PASS_2_EXT"),	# 0x80A6
    ("",	X,	1,	"GL_4PASS_3_EXT"),	# 0x80A7
    ("glGet",	I,	1,	"GL_SAMPLE_BUFFERS"),	# 0x80A8
    ("glGet",	I,	1,	"GL_SAMPLES"),	# 0x80A9
    ("glGet",	F,	1,	"GL_SAMPLE_COVERAGE_VALUE"),	# 0x80AA
    ("glGet",	I,	1,	"GL_SAMPLE_COVERAGE_INVERT"),	# 0x80AB
    ("glGet",	I,	1,	"GL_SAMPLE_PATTERN_EXT"),	# 0x80AC
    ("",	X,	1,	"GL_LINEAR_SHARPEN_SGIS"),	# 0x80AD
    ("",	X,	1,	"GL_LINEAR_SHARPEN_ALPHA_SGIS"),	# 0x80AE
    ("",	X,	1,	"GL_LINEAR_SHARPEN_COLOR_SGIS"),	# 0x80AF
    ("",	X,	1,	"GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS"),	# 0x80B0
    ("glGet",	F,	16,	"GL_COLOR_MATRIX"),	# 0x80B1
    ("glGet",	I,	1,	"GL_COLOR_MATRIX_STACK_DEPTH"),	# 0x80B2
    ("glGet",	I,	1,	"GL_MAX_COLOR_MATRIX_STACK_DEPTH"),	# 0x80B3
    ("glGet",	F,	1,	"GL_POST_COLOR_MATRIX_RED_SCALE"),	# 0x80B4
    ("glGet",	F,	1,	"GL_POST_COLOR_MATRIX_GREEN_SCALE"),	# 0x80B5
    ("glGet",	F,	1,	"GL_POST_COLOR_MATRIX_BLUE_SCALE"),	# 0x80B6
    ("glGet",	F,	1,	"GL_POST_COLOR_MATRIX_ALPHA_SCALE"),	# 0x80B7
    ("glGet",	F,	1,	"GL_POST_COLOR_MATRIX_RED_BIAS"),	# 0x80B8
    ("glGet",	F,	1,	"GL_POST_COLOR_MATRIX_GREEN_BIAS"),	# 0x80B9
    ("glGet",	F,	1,	"GL_POST_COLOR_MATRIX_BLUE_BIAS"),	# 0x80BA
    ("glGet",	F,	1,	"GL_POST_COLOR_MATRIX_ALPHA_BIAS"),	# 0x80BB
    ("glGet",	I,	1,	"GL_TEXTURE_COLOR_TABLE_SGI"),	# 0x80BC
    ("",	X,	1,	"GL_PROXY_TEXTURE_COLOR_TABLE_SGI"),	# 0x80BD
    ("",	X,	1,	"GL_TEXTURE_ENV_BIAS_SGIX"),	# 0x80BE
    ("glGetTexParameter",	F,	1,	"GL_TEXTURE_COMPARE_FAIL_VALUE_ARB"),	# 0x80BF
    ("glGet",	E,	1,	"GL_BLEND_DST_RGB"),	# 0x80C8
    ("glGet",	E,	1,	"GL_BLEND_SRC_RGB"),	# 0x80C9
    ("glGet",	E,	1,	"GL_BLEND_DST_ALPHA"),	# 0x80CA
    ("glGet",	E,	1,	"GL_BLEND_SRC_ALPHA"),	# 0x80CB
    ("",	X,	1,	"GL_422_EXT"),	# 0x80CC
    ("",	X,	1,	"GL_422_REV_EXT"),	# 0x80CD
    ("",	X,	1,	"GL_422_AVERAGE_EXT"),	# 0x80CE
    ("",	X,	1,	"GL_422_REV_AVERAGE_EXT"),	# 0x80CF
    ("glGet",	B,	1,	"GL_COLOR_TABLE"),	# 0x80D0
    ("glGet",	I,	1,	"GL_POST_CONVOLUTION_COLOR_TABLE"),	# 0x80D1
    ("glGet",	I,	1,	"GL_POST_COLOR_MATRIX_COLOR_TABLE"),	# 0x80D2
    ("",	X,	1,	"GL_PROXY_COLOR_TABLE"),	# 0x80D3
    ("",	X,	1,	"GL_PROXY_POST_CONVOLUTION_COLOR_TABLE"),	# 0x80D4
    ("",	X,	1,	"GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE"),	# 0x80D5
    ("glGetColorTableParameter",	F,	4,	"GL_COLOR_TABLE_SCALE"),	# 0x80D6
    ("glGetColorTableParameter",	F,	4,	"GL_COLOR_TABLE_BIAS"),	# 0x80D7
    ("glGetColorTableParameter",	E,	1,	"GL_COLOR_TABLE_FORMAT"),	# 0x80D8
    ("glGetColorTableParameter",	I,	1,	"GL_COLOR_TABLE_WIDTH"),	# 0x80D9
    ("glGetColorTableParameter",	I,	1,	"GL_COLOR_TABLE_RED_SIZE"),	# 0x80DA
    ("glGetColorTableParameter",	I,	1,	"GL_COLOR_TABLE_GREEN_SIZE"),	# 0x80DB
    ("glGetColorTableParameter",	I,	1,	"GL_COLOR_TABLE_BLUE_SIZE"),	# 0x80DC
    ("glGetColorTableParameter",	I,	1,	"GL_COLOR_TABLE_ALPHA_SIZE"),	# 0x80DD
    ("glGetColorTableParameter",	I,	1,	"GL_COLOR_TABLE_LUMINANCE_SIZE"),	# 0x80DE
    ("glGetColorTableParameter",	I,	1,	"GL_COLOR_TABLE_INTENSITY_SIZE"),	# 0x80DF
    ("",	X,	1,	"GL_BGR"),	# 0x80E0
    ("",	X,	1,	"GL_BGRA"),	# 0x80E1
    ("",	X,	1,	"GL_COLOR_INDEX1_EXT"),	# 0x80E2
    ("",	X,	1,	"GL_COLOR_INDEX2_EXT"),	# 0x80E3
    ("",	X,	1,	"GL_COLOR_INDEX4_EXT"),	# 0x80E4
    ("",	X,	1,	"GL_COLOR_INDEX8_EXT"),	# 0x80E5
    ("",	X,	1,	"GL_COLOR_INDEX12_EXT"),	# 0x80E6
    ("",	X,	1,	"GL_COLOR_INDEX16_EXT"),	# 0x80E7
    ("glGet",	I,	1,	"GL_MAX_ELEMENTS_VERTICES"),	# 0x80E8
    ("glGet",	I,	1,	"GL_MAX_ELEMENTS_INDICES"),	# 0x80E9
    ("",	X,	1,	"GL_PHONG_WIN"),	# 0x80EA
    ("",	X,	1,	"GL_PHONG_HINT_WIN"),	# 0x80EB
    ("",	X,	1,	"GL_FOG_SPECULAR_TEXTURE_WIN"),	# 0x80EC
    ("_glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_INDEX_SIZE_EXT"),	# 0x80ED
    ("",	X,	1,	"GL_PARAMETER_BUFFER_ARB"),	# 0x80EE
    ("",	X,	1,	"GL_PARAMETER_BUFFER_BINDING_ARB"),	# 0x80EF
    ("glGet",	E,	1,	"GL_CLIP_VOLUME_CLIPPING_HINT_EXT"),	# 0x80F0
    ("",	X,	1,	"GL_DUAL_ALPHA4_SGIS"),	# 0x8110
    ("",	X,	1,	"GL_DUAL_ALPHA8_SGIS"),	# 0x8111
    ("",	X,	1,	"GL_DUAL_ALPHA12_SGIS"),	# 0x8112
    ("",	X,	1,	"GL_DUAL_ALPHA16_SGIS"),	# 0x8113
    ("",	X,	1,	"GL_DUAL_LUMINANCE4_SGIS"),	# 0x8114
    ("",	X,	1,	"GL_DUAL_LUMINANCE8_SGIS"),	# 0x8115
    ("",	X,	1,	"GL_DUAL_LUMINANCE12_SGIS"),	# 0x8116
    ("",	X,	1,	"GL_DUAL_LUMINANCE16_SGIS"),	# 0x8117
    ("",	X,	1,	"GL_DUAL_INTENSITY4_SGIS"),	# 0x8118
    ("",	X,	1,	"GL_DUAL_INTENSITY8_SGIS"),	# 0x8119
    ("",	X,	1,	"GL_DUAL_INTENSITY12_SGIS"),	# 0x811A
    ("",	X,	1,	"GL_DUAL_INTENSITY16_SGIS"),	# 0x811B
    ("",	X,	1,	"GL_DUAL_LUMINANCE_ALPHA4_SGIS"),	# 0x811C
    ("",	X,	1,	"GL_DUAL_LUMINANCE_ALPHA8_SGIS"),	# 0x811D
    ("",	X,	1,	"GL_QUAD_ALPHA4_SGIS"),	# 0x811E
    ("",	X,	1,	"GL_QUAD_ALPHA8_SGIS"),	# 0x811F
    ("",	X,	1,	"GL_QUAD_LUMINANCE4_SGIS"),	# 0x8120
    ("",	X,	1,	"GL_QUAD_LUMINANCE8_SGIS"),	# 0x8121
    ("",	X,	1,	"GL_QUAD_INTENSITY4_SGIS"),	# 0x8122
    ("",	X,	1,	"GL_QUAD_INTENSITY8_SGIS"),	# 0x8123
    ("",	X,	1,	"GL_DUAL_TEXTURE_SELECT_SGIS"),	# 0x8124
    ("",	X,	1,	"GL_QUAD_TEXTURE_SELECT_SGIS"),	# 0x8125
    ("glGet",	F,	1,	"GL_POINT_SIZE_MIN"),	# 0x8126
    ("glGet",	F,	1,	"GL_POINT_SIZE_MAX"),	# 0x8127
    ("glGet",	F,	1,	"GL_POINT_FADE_THRESHOLD_SIZE"),	# 0x8128
    ("glGet",	F,	3,	"GL_POINT_DISTANCE_ATTENUATION"),	# 0x8129
    ("",	X,	1,	"GL_FOG_FUNC_SGIS"),	# 0x812A
    ("glGet",	I,	1,	"GL_FOG_FUNC_POINTS_SGIS"),	# 0x812B
    ("glGet",	I,	1,	"GL_MAX_FOG_FUNC_POINTS_SGIS"),	# 0x812C
    ("",	X,	1,	"GL_CLAMP_TO_BORDER"),	# 0x812D
    ("",	X,	1,	"GL_TEXTURE_MULTI_BUFFER_HINT_SGIX"),	# 0x812E
    ("",	X,	1,	"GL_CLAMP_TO_EDGE"),	# 0x812F
    ("glGet",	I,	1,	"GL_PACK_SKIP_VOLUMES_SGIS"),	# 0x8130
    ("glGet",	I,	1,	"GL_PACK_IMAGE_DEPTH_SGIS"),	# 0x8131
    ("glGet",	I,	1,	"GL_UNPACK_SKIP_VOLUMES_SGIS"),	# 0x8132
    ("glGet",	I,	1,	"GL_UNPACK_IMAGE_DEPTH_SGIS"),	# 0x8133
    ("glGet",	I,	1,	"GL_TEXTURE_4D_SGIS"),	# 0x8134
    ("",	X,	1,	"GL_PROXY_TEXTURE_4D_SGIS"),	# 0x8135
    ("",	X,	1,	"GL_TEXTURE_4DSIZE_SGIS"),	# 0x8136
    ("",	X,	1,	"GL_TEXTURE_WRAP_Q_SGIS"),	# 0x8137
    ("glGet",	I,	1,	"GL_MAX_4D_TEXTURE_SIZE_SGIS"),	# 0x8138
    ("glGet",	I,	1,	"GL_PIXEL_TEX_GEN_SGIX"),	# 0x8139
    ("glGetTexParameter,glGetSamplerParameter",	F,	1,	"GL_TEXTURE_MIN_LOD"),	# 0x813A
    ("glGetTexParameter,glGetSamplerParameter",	F,	1,	"GL_TEXTURE_MAX_LOD"),	# 0x813B
    ("glGetTexParameter",	F,	1,	"GL_TEXTURE_BASE_LEVEL"),	# 0x813C
    ("glGetTexParameter",	F,	1,	"GL_TEXTURE_MAX_LEVEL"),	# 0x813D
    ("glGet",	I,	1,	"GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX"),	# 0x813E
    ("glGet",	I,	1,	"GL_PIXEL_TILE_CACHE_INCREMENT_SGIX"),	# 0x813F
    ("glGet",	I,	1,	"GL_PIXEL_TILE_WIDTH_SGIX"),	# 0x8140
    ("glGet",	I,	1,	"GL_PIXEL_TILE_HEIGHT_SGIX"),	# 0x8141
    ("glGet",	I,	1,	"GL_PIXEL_TILE_GRID_WIDTH_SGIX"),	# 0x8142
    ("glGet",	I,	1,	"GL_PIXEL_TILE_GRID_HEIGHT_SGIX"),	# 0x8143
    ("glGet",	I,	1,	"GL_PIXEL_TILE_GRID_DEPTH_SGIX"),	# 0x8144
    ("glGet",	I,	1,	"GL_PIXEL_TILE_CACHE_SIZE_SGIX"),	# 0x8145
    ("",	X,	1,	"GL_FILTER4_SGIS"),	# 0x8146
    ("",	X,	1,	"GL_TEXTURE_FILTER4_SIZE_SGIS"),	# 0x8147
    ("glGet",	I,	1,	"GL_SPRITE_SGIX"),	# 0x8148
    ("glGet",	I,	1,	"GL_SPRITE_MODE_SGIX"),	# 0x8149
    ("glGet",	F,	3,	"GL_SPRITE_AXIS_SGIX"),	# 0x814A
    ("glGet",	F,	3,	"GL_SPRITE_TRANSLATION_SGIX"),	# 0x814B
    ("",	X,	1,	"GL_SPRITE_AXIAL_SGIX"),	# 0x814C
    ("",	X,	1,	"GL_SPRITE_OBJECT_ALIGNED_SGIX"),	# 0x814D
    ("",	X,	1,	"GL_SPRITE_EYE_ALIGNED_SGIX"),	# 0x814E
    ("glGet",	I,	1,	"GL_TEXTURE_4D_BINDING_SGIS"),	# 0x814F
    ("",	X,	1,	"GL_IGNORE_BORDER_HP"),	# 0x8150
    ("",	X,	1,	"GL_CONSTANT_BORDER"),	# 0x8151
    ("",	X,	1,	"GL_REPLICATE_BORDER"),	# 0x8153
    ("glGetConvolutionParameter",	F,	4,	"GL_CONVOLUTION_BORDER_COLOR"),	# 0x8154
    ("",	X,	1,	"GL_IMAGE_SCALE_X_HP"),	# 0x8155
    ("",	X,	1,	"GL_IMAGE_SCALE_Y_HP"),	# 0x8156
    ("",	X,	1,	"GL_IMAGE_TRANSLATE_X_HP"),	# 0x8157
    ("",	X,	1,	"GL_IMAGE_TRANSLATE_Y_HP"),	# 0x8158
    ("",	X,	1,	"GL_IMAGE_ROTATE_ANGLE_HP"),	# 0x8159
    ("",	X,	1,	"GL_IMAGE_ROTATE_ORIGIN_X_HP"),	# 0x815A
    ("",	X,	1,	"GL_IMAGE_ROTATE_ORIGIN_Y_HP"),	# 0x815B
    ("",	X,	1,	"GL_IMAGE_MAG_FILTER_HP"),	# 0x815C
    ("",	X,	1,	"GL_IMAGE_MIN_FILTER_HP"),	# 0x815D
    ("",	X,	1,	"GL_IMAGE_CUBIC_WEIGHT_HP"),	# 0x815E
    ("",	X,	1,	"GL_CUBIC_HP"),	# 0x815F
    ("",	X,	1,	"GL_AVERAGE_HP"),	# 0x8160
    ("",	X,	1,	"GL_IMAGE_TRANSFORM_2D_HP"),	# 0x8161
    ("",	X,	1,	"GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP"),	# 0x8162
    ("",	X,	1,	"GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP"),	# 0x8163
    ("_glGet",	B,	1,	"GL_OCCLUSION_TEST_HP"),	# 0x8165
    ("_glGet",	B,	1,	"GL_OCCLUSION_TEST_RESULT_HP"),	# 0x8166
    ("",	X,	1,	"GL_TEXTURE_LIGHTING_MODE_HP"),	# 0x8167
    ("",	X,	1,	"GL_TEXTURE_POST_SPECULAR_HP"),	# 0x8168
    ("",	X,	1,	"GL_TEXTURE_PRE_SPECULAR_HP"),	# 0x8169
    ("",	X,	1,	"GL_LINEAR_CLIPMAP_LINEAR_SGIX"),	# 0x8170
    ("glGetTexParameter",	I,	2,	"GL_TEXTURE_CLIPMAP_CENTER_SGIX"),	# 0x8171
    ("glGetTexParameter",	F,	1,	"GL_TEXTURE_CLIPMAP_FRAME_SGIX"),	# 0x8172
    ("glGetTexParameter",	I,	2,	"GL_TEXTURE_CLIPMAP_OFFSET_SGIX"),	# 0x8173
    ("glGetTexParameter",	I,	3,	"GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX"),	# 0x8174
    ("",	X,	1,	"GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX"),	# 0x8175
    ("",	I,	1,	"GL_TEXTURE_CLIPMAP_DEPTH_SGIX"),	# 0x8176
    ("glGet",	I,	1,	"GL_MAX_CLIPMAP_DEPTH_SGIX"),	# 0x8177
    ("glGet",	I,	1,	"GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX"),	# 0x8178
    ("glGetTexParameter",	F,	1,	"GL_POST_TEXTURE_FILTER_BIAS_SGIX"),	# 0x8179
    ("glGetTexParameter",	F,	1,	"GL_POST_TEXTURE_FILTER_SCALE_SGIX"),	# 0x817A
    ("glGet",	F,	2,	"GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX"),	# 0x817B
    ("glGet",	F,	2,	"GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX"),	# 0x817C
    ("glGet",	I,	1,	"GL_REFERENCE_PLANE_SGIX"),	# 0x817D
    ("glGet",	F,	4,	"GL_REFERENCE_PLANE_EQUATION_SGIX"),	# 0x817E
    ("glGet",	I,	1,	"GL_IR_INSTRUMENT1_SGIX"),	# 0x817F
    ("",	X,	1,	"GL_INSTRUMENT_BUFFER_POINTER_SGIX"),	# 0x8180
    ("glGet",	I,	1,	"GL_INSTRUMENT_MEASUREMENTS_SGIX"),	# 0x8181
    ("",	X,	1,	"GL_LIST_PRIORITY_SGIX"),	# 0x8182
    ("glGet",	I,	1,	"GL_CALLIGRAPHIC_FRAGMENT_SGIX"),	# 0x8183
    ("",	X,	1,	"GL_PIXEL_TEX_GEN_Q_CEILING_SGIX"),	# 0x8184
    ("",	X,	1,	"GL_PIXEL_TEX_GEN_Q_ROUND_SGIX"),	# 0x8185
    ("",	X,	1,	"GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX"),	# 0x8186
    ("",	X,	1,	"GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX"),	# 0x8187
    ("",	X,	1,	"GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX"),	# 0x8188
    ("",	X,	1,	"GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX"),	# 0x8189
    ("",	X,	1,	"GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX"),	# 0x818A
    ("glGet",	I,	1,	"GL_FRAMEZOOM_SGIX"),	# 0x818B
    ("glGet",	I,	1,	"GL_FRAMEZOOM_FACTOR_SGIX"),	# 0x818C
    ("glGet",	I,	1,	"GL_MAX_FRAMEZOOM_FACTOR_SGIX"),	# 0x818D
    ("glGetTexParameter",	F,	1,	"GL_TEXTURE_LOD_BIAS_S_SGIX"),	# 0x818E
    ("glGetTexParameter",	F,	1,	"GL_TEXTURE_LOD_BIAS_T_SGIX"),	# 0x818F
    ("glGetTexParameter",	F,	1,	"GL_TEXTURE_LOD_BIAS_R_SGIX"),	# 0x8190
    ("glGetTexParameter",	B,	1,	"GL_GENERATE_MIPMAP"),	# 0x8191
    ("glGet",	E,	1,	"GL_GENERATE_MIPMAP_HINT"),	# 0x8192
    ("",	X,	1,	"GL_GEOMETRY_DEFORMATION_SGIX"),	# 0x8194
    ("",	X,	1,	"GL_TEXTURE_DEFORMATION_SGIX"),	# 0x8195
    ("glGet",	I,	1,	"GL_DEFORMATIONS_MASK_SGIX"),	# 0x8196
    ("",	X,	1,	"GL_MAX_DEFORMATION_ORDER_SGIX"),	# 0x8197
    ("glGet",	I,	1,	"GL_FOG_OFFSET_SGIX"),	# 0x8198
    ("glGet",	F,	4,	"GL_FOG_OFFSET_VALUE_SGIX"),	# 0x8199
    ("glGetTexParameter",	B,	1,	"GL_TEXTURE_COMPARE_SGIX"),	# 0x819A
    ("glGetTexParameter",	E,	1,	"GL_TEXTURE_COMPARE_OPERATOR_SGIX"),	# 0x819B
    ("",	X,	1,	"GL_TEXTURE_LEQUAL_R_SGIX"),	# 0x819C
    ("",	X,	1,	"GL_TEXTURE_GEQUAL_R_SGIX"),	# 0x819D
    ("",	X,	1,	"GL_DEPTH_COMPONENT16"),	# 0x81A5
    ("",	X,	1,	"GL_DEPTH_COMPONENT24"),	# 0x81A6
    ("",	X,	1,	"GL_DEPTH_COMPONENT32"),	# 0x81A7
    ("glGet",	I,	1,	"GL_ARRAY_ELEMENT_LOCK_FIRST_EXT"),	# 0x81A8
    ("glGet",	I,	1,	"GL_ARRAY_ELEMENT_LOCK_COUNT_EXT"),	# 0x81A9
    ("glGet",	B,	1,	"GL_CULL_VERTEX_EXT"),	# 0x81AA
    ("glGet",	F,	4,	"GL_CULL_VERTEX_EYE_POSITION_EXT"),	# 0x81AB
    ("glGet",	F,	4,	"GL_CULL_VERTEX_OBJECT_POSITION_EXT"),	# 0x81AC
    ("",	X,	1,	"GL_IUI_V2F_EXT"),	# 0x81AD
    ("",	X,	1,	"GL_IUI_V3F_EXT"),	# 0x81AE
    ("",	X,	1,	"GL_IUI_N3F_V2F_EXT"),	# 0x81AF
    ("",	X,	1,	"GL_IUI_N3F_V3F_EXT"),	# 0x81B0
    ("",	X,	1,	"GL_T2F_IUI_V2F_EXT"),	# 0x81B1
    ("",	X,	1,	"GL_T2F_IUI_V3F_EXT"),	# 0x81B2
    ("",	X,	1,	"GL_T2F_IUI_N3F_V2F_EXT"),	# 0x81B3
    ("",	X,	1,	"GL_T2F_IUI_N3F_V3F_EXT"),	# 0x81B4
    ("",	X,	1,	"GL_INDEX_TEST_EXT"),	# 0x81B5
    ("",	X,	1,	"GL_INDEX_TEST_FUNC_EXT"),	# 0x81B6
    ("",	X,	1,	"GL_INDEX_TEST_REF_EXT"),	# 0x81B7
    ("",	X,	1,	"GL_INDEX_MATERIAL_EXT"),	# 0x81B8
    ("",	X,	1,	"GL_INDEX_MATERIAL_PARAMETER_EXT"),	# 0x81B9
    ("",	X,	1,	"GL_INDEX_MATERIAL_FACE_EXT"),	# 0x81BA
    ("",	X,	1,	"GL_YCRCB_422_SGIX"),	# 0x81BB
    ("",	X,	1,	"GL_YCRCB_444_SGIX"),	# 0x81BC
    ("",	X,	1,	"GL_WRAP_BORDER_SUN"),	# 0x81D4
    ("",	X,	1,	"GL_UNPACK_CONSTANT_DATA_SUNX"),	# 0x81D5
    ("",	X,	1,	"GL_TEXTURE_CONSTANT_DATA_SUNX"),	# 0x81D6
    ("",	X,	1,	"GL_TRIANGLE_LIST_SUN"),	# 0x81D7
    ("",	X,	1,	"GL_REPLACEMENT_CODE_SUN"),	# 0x81D8
    ("",	X,	1,	"GL_GLOBAL_ALPHA_SUN"),	# 0x81D9
    ("",	X,	1,	"GL_GLOBAL_ALPHA_FACTOR_SUN"),	# 0x81DA
    ("glGet",	B,	4,	"GL_TEXTURE_COLOR_WRITEMASK_SGIS"),	# 0x81EF
    ("",	X,	1,	"GL_EYE_DISTANCE_TO_POINT_SGIS"),	# 0x81F0
    ("",	X,	1,	"GL_OBJECT_DISTANCE_TO_POINT_SGIS"),	# 0x81F1
    ("",	X,	1,	"GL_EYE_DISTANCE_TO_LINE_SGIS"),	# 0x81F2
    ("",	X,	1,	"GL_OBJECT_DISTANCE_TO_LINE_SGIS"),	# 0x81F3
    ("",	X,	1,	"GL_EYE_POINT_SGIS"),	# 0x81F4
    ("",	X,	1,	"GL_OBJECT_POINT_SGIS"),	# 0x81F5
    ("",	X,	1,	"GL_EYE_LINE_SGIS"),	# 0x81F6
    ("",	X,	1,	"GL_OBJECT_LINE_SGIS"),	# 0x81F7
    ("glGet",	E,	1,	"GL_LIGHT_MODEL_COLOR_CONTROL"),	# 0x81F8
    ("",	X,	1,	"GL_SINGLE_COLOR"),	# 0x81F9
    ("",	X,	1,	"GL_SEPARATE_SPECULAR_COLOR"),	# 0x81FA
    ("",	X,	1,	"GL_SHARED_TEXTURE_PALETTE_EXT"),	# 0x81FB
    ("",	X,	1,	"GL_FOG_SCALE_SGIX"),	# 0x81FC
    ("",	X,	1,	"GL_FOG_SCALE_VALUE_SGIX"),	# 0x81FD
    ("",	X,	1,	"GL_TEXT_FRAGMENT_SHADER_ATI"),	# 0x8200
    ("glGetFramebufferAttachmentParameter",	E,	1,	"GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"),	# 0x8210
    ("glGetFramebufferAttachmentParameter",	E,	1,	"GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"),	# 0x8211
    ("glGetFramebufferAttachmentParameter",	I,	1,	"GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE"),	# 0x8212
    ("glGetFramebufferAttachmentParameter",	I,	1,	"GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"),	# 0x8213
    ("glGetFramebufferAttachmentParameter",	I,	1,	"GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"),	# 0x8214
    ("glGetFramebufferAttachmentParameter",	I,	1,	"GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"),	# 0x8215
    ("glGetFramebufferAttachmentParameter",	I,	1,	"GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"),	# 0x8216
    ("glGetFramebufferAttachmentParameter",	I,	1,	"GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"),	# 0x8217
    ("",	X,	1,	"GL_FRAMEBUFFER_DEFAULT"),	# 0x8218
    ("",	X,	1,	"GL_FRAMEBUFFER_UNDEFINED"),	# 0x8219
    ("",	X,	1,	"GL_DEPTH_STENCIL_ATTACHMENT"),	# 0x821A
    ("glGet",	I,	1,	"GL_MAJOR_VERSION"),	# 0x821B
    ("glGet",	I,	1,	"GL_MINOR_VERSION"),	# 0x821C
    ("glGet",	I,	1,	"GL_NUM_EXTENSIONS"),	# 0x821D
    ("glGet",	I,	1,	"GL_CONTEXT_FLAGS"),	# 0x821E
    ("glGetBufferParameter",	B,	1,	"GL_BUFFER_IMMUTABLE_STORAGE"),	# 0x821F
    ("glGetBufferParameter",	I,	1,	"GL_BUFFER_STORAGE_FLAGS"),	# 0x8220
    ("",	X,	1,	"GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED"),	# 0x8221
    ("",	X,	1,	"GL_INDEX"),	# 0x8222
    ("",	X,	1,	"GL_COMPRESSED_RED"),	# 0x8225
    ("",	X,	1,	"GL_COMPRESSED_RG"),	# 0x8226
    ("",	X,	1,	"GL_RG"),	# 0x8227
    ("",	X,	1,	"GL_RG_INTEGER"),	# 0x8228
    ("",	X,	1,	"GL_R8"),	# 0x8229
    ("",	X,	1,	"GL_R16"),	# 0x822A
    ("",	X,	1,	"GL_RG8"),	# 0x822B
    ("",	X,	1,	"GL_RG16"),	# 0x822C
    ("",	X,	1,	"GL_R16F"),	# 0x822D
    ("",	X,	1,	"GL_R32F"),	# 0x822E
    ("",	X,	1,	"GL_RG16F"),	# 0x822F
    ("",	X,	1,	"GL_RG32F"),	# 0x8230
    ("",	X,	1,	"GL_R8I"),	# 0x8231
    ("",	X,	1,	"GL_R8UI"),	# 0x8232
    ("",	X,	1,	"GL_R16I"),	# 0x8233
    ("",	X,	1,	"GL_R16UI"),	# 0x8234
    ("",	X,	1,	"GL_R32I"),	# 0x8235
    ("",	X,	1,	"GL_R32UI"),	# 0x8236
    ("",	X,	1,	"GL_RG8I"),	# 0x8237
    ("",	X,	1,	"GL_RG8UI"),	# 0x8238
    ("",	X,	1,	"GL_RG16I"),	# 0x8239
    ("",	X,	1,	"GL_RG16UI"),	# 0x823A
    ("",	X,	1,	"GL_RG32I"),	# 0x823B
    ("",	X,	1,	"GL_RG32UI"),	# 0x823C
    ("",	X,	1,	"GL_SYNC_CL_EVENT_ARB"),	# 0x8240
    ("",	X,	1,	"GL_SYNC_CL_EVENT_COMPLETE_ARB"),	# 0x8241
    ("glGet",	B,	1,	"GL_DEBUG_OUTPUT_SYNCHRONOUS"),	# 0x8242
    ("glGet",	I,	1,	"GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH"),	# 0x8243
    ("glGet",	P,	1,	"GL_DEBUG_CALLBACK_FUNCTION"),	# 0x8244
    ("glGet",	P,	1,	"GL_DEBUG_CALLBACK_USER_PARAM"),	# 0x8245
    ("",	X,	1,	"GL_DEBUG_SOURCE_API"),	# 0x8246
    ("",	X,	1,	"GL_DEBUG_SOURCE_WINDOW_SYSTEM"),	# 0x8247
    ("",	X,	1,	"GL_DEBUG_SOURCE_SHADER_COMPILER"),	# 0x8248
    ("",	X,	1,	"GL_DEBUG_SOURCE_THIRD_PARTY"),	# 0x8249
    ("",	X,	1,	"GL_DEBUG_SOURCE_APPLICATION"),	# 0x824A
    ("",	X,	1,	"GL_DEBUG_SOURCE_OTHER"),	# 0x824B
    ("",	X,	1,	"GL_DEBUG_TYPE_ERROR"),	# 0x824C
    ("",	X,	1,	"GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR"),	# 0x824D
    ("",	X,	1,	"GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR"),	# 0x824E
    ("",	X,	1,	"GL_DEBUG_TYPE_PORTABILITY"),	# 0x824F
    ("",	X,	1,	"GL_DEBUG_TYPE_PERFORMANCE"),	# 0x8250
    ("",	X,	1,	"GL_DEBUG_TYPE_OTHER"),	# 0x8251
    ("",	X,	1,	"GL_LOSE_CONTEXT_ON_RESET_ARB"),	# 0x8252
    ("",	X,	1,	"GL_GUILTY_CONTEXT_RESET_ARB"),	# 0x8253
    ("",	X,	1,	"GL_INNOCENT_CONTEXT_RESET_ARB"),	# 0x8254
    ("",	X,	1,	"GL_UNKNOWN_CONTEXT_RESET_ARB"),	# 0x8255
    ("glGet",	E,	1,	"GL_RESET_NOTIFICATION_STRATEGY_ARB"),	# 0x8256
    ("",	X,	1,	"GL_PROGRAM_BINARY_RETRIEVABLE_HINT"),	# 0x8257
    ("",	X,	1,	"GL_PROGRAM_SEPARABLE"),	# 0x8258
    ("glGet",	I,	1,	"GL_ACTIVE_PROGRAM"),	# 0x8259
    ("glGet",	I,	1,	"GL_PROGRAM_PIPELINE_BINDING"),	# 0x825A
    ("glGet",	I,	1,	"GL_MAX_VIEWPORTS"),	# 0x825B
    ("glGet",	I,	1,	"GL_VIEWPORT_SUBPIXEL_BITS"),	# 0x825C
    ("glGet",	F,	2,	"GL_VIEWPORT_BOUNDS_RANGE"),	# 0x825D
    ("glGet",	E,	1,	"GL_LAYER_PROVOKING_VERTEX"),	# 0x825E
    ("glGet",	E,	1,	"GL_VIEWPORT_INDEX_PROVOKING_VERTEX"),	# 0x825F
    ("",	X,	1,	"GL_UNDEFINED_VERTEX"),	# 0x8260
    ("",	X,	1,	"GL_NO_RESET_NOTIFICATION_ARB"),	# 0x8261
    ("glGet",	I,	1,	"GL_MAX_COMPUTE_SHARED_MEMORY_SIZE"),	# 0x8262
    ("glGet",	I,	1,	"GL_MAX_COMPUTE_UNIFORM_COMPONENTS"),	# 0x8263
    ("glGet",	I,	1,	"GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS"),	# 0x8264
    ("glGet",	I,	1,	"GL_MAX_COMPUTE_ATOMIC_COUNTERS"),	# 0x8265
    ("glGet",	I,	1,	"GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS"),	# 0x8266
    ("",	X,	1,	"GL_COMPUTE_WORK_GROUP_SIZE"),	# 0x8267
    ("",	X,	1,	"GL_DEBUG_TYPE_MARKER"),	# 0x8268
    ("",	X,	1,	"GL_DEBUG_TYPE_PUSH_GROUP"),	# 0x8269
    ("",	X,	1,	"GL_DEBUG_TYPE_POP_GROUP"),	# 0x826A
    ("",	X,	1,	"GL_DEBUG_SEVERITY_NOTIFICATION"),	# 0x826B
    ("glGet",	I,	1,	"GL_MAX_DEBUG_GROUP_STACK_DEPTH"),	# 0x826C
    ("glGet",	I,	1,	"GL_DEBUG_GROUP_STACK_DEPTH"),	# 0x826D
    ("glGet",	I,	1,	"GL_MAX_UNIFORM_LOCATIONS"),	# 0x826E
    ("",	B,	1,	"GL_INTERNALFORMAT_SUPPORTED"),	# 0x826F
    ("",	E,	1,	"GL_INTERNALFORMAT_PREFERRED"),	# 0x8270
    ("",	I,	1,	"GL_INTERNALFORMAT_RED_SIZE"),	# 0x8271
    ("",	I,	1,	"GL_INTERNALFORMAT_GREEN_SIZE"),	# 0x8272
    ("",	I,	1,	"GL_INTERNALFORMAT_BLUE_SIZE"),	# 0x8273
    ("",	I,	1,	"GL_INTERNALFORMAT_ALPHA_SIZE"),	# 0x8274
    ("",	I,	1,	"GL_INTERNALFORMAT_DEPTH_SIZE"),	# 0x8275
    ("",	I,	1,	"GL_INTERNALFORMAT_STENCIL_SIZE"),	# 0x8276
    ("",	I,	1,	"GL_INTERNALFORMAT_SHARED_SIZE"),	# 0x8277
    ("",	E,	1,	"GL_INTERNALFORMAT_RED_TYPE"),	# 0x8278
    ("",	E,	1,	"GL_INTERNALFORMAT_GREEN_TYPE"),	# 0x8279
    ("",	E,	1,	"GL_INTERNALFORMAT_BLUE_TYPE"),	# 0x827A
    ("",	E,	1,	"GL_INTERNALFORMAT_ALPHA_TYPE"),	# 0x827B
    ("",	E,	1,	"GL_INTERNALFORMAT_DEPTH_TYPE"),	# 0x827C
    ("",	E,	1,	"GL_INTERNALFORMAT_STENCIL_TYPE"),	# 0x827D
    ("",	I,	1,	"GL_MAX_WIDTH"),	# 0x827E
    ("",	I,	1,	"GL_MAX_HEIGHT"),	# 0x827F
    ("",	I,	1,	"GL_MAX_DEPTH"),	# 0x8280
    ("",	I,	1,	"GL_MAX_LAYERS"),	# 0x8281
    ("",	I,	1,	"GL_MAX_COMBINED_DIMENSIONS"),	# 0x8282
    ("",	B,	1,	"GL_COLOR_COMPONENTS"),	# 0x8283
    ("",	B,	1,	"GL_DEPTH_COMPONENTS"),	# 0x8284
    ("",	B,	1,	"GL_STENCIL_COMPONENTS"),	# 0x8285
    ("",	B,	1,	"GL_COLOR_RENDERABLE"),	# 0x8286
    ("",	B,	1,	"GL_DEPTH_RENDERABLE"),	# 0x8287
    ("",	B,	1,	"GL_STENCIL_RENDERABLE"),	# 0x8288
    ("",	E,	1,	"GL_FRAMEBUFFER_RENDERABLE"),	# 0x8289
    ("",	E,	1,	"GL_FRAMEBUFFER_RENDERABLE_LAYERED"),	# 0x828A
    ("",	E,	1,	"GL_FRAMEBUFFER_BLEND"),	# 0x828B
    ("",	E,	1,	"GL_READ_PIXELS"),	# 0x828C
    ("",	E,	1,	"GL_READ_PIXELS_FORMAT"),	# 0x828D
    ("",	E,	1,	"GL_READ_PIXELS_TYPE"),	# 0x828E
    ("",	E,	1,	"GL_TEXTURE_IMAGE_FORMAT"),	# 0x828F
    ("",	E,	1,	"GL_TEXTURE_IMAGE_TYPE"),	# 0x8290
    ("",	E,	1,	"GL_GET_TEXTURE_IMAGE_FORMAT"),	# 0x8291
    ("",	E,	1,	"GL_GET_TEXTURE_IMAGE_TYPE"),	# 0x8292
    ("",	B,	1,	"GL_MIPMAP"),	# 0x8293
    ("",	E,	1,	"GL_MANUAL_GENERATE_MIPMAP"),	# 0x8294
    ("",	E,	1,	"GL_AUTO_GENERATE_MIPMAP"),	# 0x8295
    ("",	E,	1,	"GL_COLOR_ENCODING"),	# 0x8296
    ("",	E,	1,	"GL_SRGB_READ"),	# 0x8297
    ("",	E,	1,	"GL_SRGB_WRITE"),	# 0x8298
    ("",	E,	1,	"GL_SRGB_DECODE_ARB"),	# 0x8299
    ("",	E,	1,	"GL_FILTER"),	# 0x829A
    ("",	E,	1,	"GL_VERTEX_TEXTURE"),	# 0x829B
    ("",	E,	1,	"GL_TESS_CONTROL_TEXTURE"),	# 0x829C
    ("",	E,	1,	"GL_TESS_EVALUATION_TEXTURE"),	# 0x829D
    ("",	E,	1,	"GL_GEOMETRY_TEXTURE"),	# 0x829E
    ("",	E,	1,	"GL_FRAGMENT_TEXTURE"),	# 0x829F
    ("",	E,	1,	"GL_COMPUTE_TEXTURE"),	# 0x82A0
    ("",	E,	1,	"GL_TEXTURE_SHADOW"),	# 0x82A1
    ("",	E,	1,	"GL_TEXTURE_GATHER"),	# 0x82A2
    ("",	E,	1,	"GL_TEXTURE_GATHER_SHADOW"),	# 0x82A3
    ("",	E,	1,	"GL_SHADER_IMAGE_LOAD"),	# 0x82A4
    ("",	E,	1,	"GL_SHADER_IMAGE_STORE"),	# 0x82A5
    ("",	E,	1,	"GL_SHADER_IMAGE_ATOMIC"),	# 0x82A6
    ("",	I,	1,	"GL_IMAGE_TEXEL_SIZE"),	# 0x82A7
    ("",	E,	1,	"GL_IMAGE_COMPATIBILITY_CLASS"),	# 0x82A8
    ("",	E,	1,	"GL_IMAGE_PIXEL_FORMAT"),	# 0x82A9
    ("",	E,	1,	"GL_IMAGE_PIXEL_TYPE"),	# 0x82AA
    ("",	E,	1,	"GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST"),	# 0x82AC
    ("",	E,	1,	"GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST"),	# 0x82AD
    ("",	E,	1,	"GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE"),	# 0x82AE
    ("",	E,	1,	"GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE"),	# 0x82AF
    ("",	I,	1,	"GL_TEXTURE_COMPRESSED_BLOCK_WIDTH"),	# 0x82B1
    ("",	I,	1,	"GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT"),	# 0x82B2
    ("",	I,	1,	"GL_TEXTURE_COMPRESSED_BLOCK_SIZE"),	# 0x82B3
    ("",	E,	1,	"GL_CLEAR_BUFFER"),	# 0x82B4
    ("",	E,	1,	"GL_TEXTURE_VIEW"),	# 0x82B5
    ("",	E,	1,	"GL_VIEW_COMPATIBILITY_CLASS"),	# 0x82B6
    ("",	X,	1,	"GL_FULL_SUPPORT"),	# 0x82B7
    ("",	X,	1,	"GL_CAVEAT_SUPPORT"),	# 0x82B8
    ("",	X,	1,	"GL_IMAGE_CLASS_4_X_32"),	# 0x82B9
    ("",	X,	1,	"GL_IMAGE_CLASS_2_X_32"),	# 0x82BA
    ("",	X,	1,	"GL_IMAGE_CLASS_1_X_32"),	# 0x82BB
    ("",	X,	1,	"GL_IMAGE_CLASS_4_X_16"),	# 0x82BC
    ("",	X,	1,	"GL_IMAGE_CLASS_2_X_16"),	# 0x82BD
    ("",	X,	1,	"GL_IMAGE_CLASS_1_X_16"),	# 0x82BE
    ("",	X,	1,	"GL_IMAGE_CLASS_4_X_8"),	# 0x82BF
    ("",	X,	1,	"GL_IMAGE_CLASS_2_X_8"),	# 0x82C0
    ("",	X,	1,	"GL_IMAGE_CLASS_1_X_8"),	# 0x82C1
    ("",	X,	1,	"GL_IMAGE_CLASS_11_11_10"),	# 0x82C2
    ("",	X,	1,	"GL_IMAGE_CLASS_10_10_10_2"),	# 0x82C3
    ("",	X,	1,	"GL_VIEW_CLASS_128_BITS"),	# 0x82C4
    ("",	X,	1,	"GL_VIEW_CLASS_96_BITS"),	# 0x82C5
    ("",	X,	1,	"GL_VIEW_CLASS_64_BITS"),	# 0x82C6
    ("",	X,	1,	"GL_VIEW_CLASS_48_BITS"),	# 0x82C7
    ("",	X,	1,	"GL_VIEW_CLASS_32_BITS"),	# 0x82C8
    ("",	X,	1,	"GL_VIEW_CLASS_24_BITS"),	# 0x82C9
    ("",	X,	1,	"GL_VIEW_CLASS_16_BITS"),	# 0x82CA
    ("",	X,	1,	"GL_VIEW_CLASS_8_BITS"),	# 0x82CB
    ("",	X,	1,	"GL_VIEW_CLASS_S3TC_DXT1_RGB"),	# 0x82CC
    ("",	X,	1,	"GL_VIEW_CLASS_S3TC_DXT1_RGBA"),	# 0x82CD
    ("",	X,	1,	"GL_VIEW_CLASS_S3TC_DXT3_RGBA"),	# 0x82CE
    ("",	X,	1,	"GL_VIEW_CLASS_S3TC_DXT5_RGBA"),	# 0x82CF
    ("",	X,	1,	"GL_VIEW_CLASS_RGTC1_RED"),	# 0x82D0
    ("",	X,	1,	"GL_VIEW_CLASS_RGTC2_RG"),	# 0x82D1
    ("",	X,	1,	"GL_VIEW_CLASS_BPTC_UNORM"),	# 0x82D2
    ("",	X,	1,	"GL_VIEW_CLASS_BPTC_FLOAT"),	# 0x82D3
    ("glGetVertexAttrib",	I,	1,	"GL_VERTEX_ATTRIB_BINDING"),	# 0x82D4
    ("glGetVertexAttrib",	I,	1,	"GL_VERTEX_ATTRIB_RELATIVE_OFFSET"),	# 0x82D5
    ("",	I,	1,	"GL_VERTEX_BINDING_DIVISOR"),	# 0x82D6
    ("",	I,	1,	"GL_VERTEX_BINDING_OFFSET"),	# 0x82D7
    ("",	I,	1,	"GL_VERTEX_BINDING_STRIDE"),	# 0x82D8
    ("glGet",	I,	1,	"GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET"),	# 0x82D9
    ("glGet",	I,	1,	"GL_MAX_VERTEX_ATTRIB_BINDINGS"),	# 0x82DA
    ("glGetTexParameter",	I,	1,	"GL_TEXTURE_VIEW_MIN_LEVEL"),	# 0x82DB
    ("glGetTexParameter",	I,	1,	"GL_TEXTURE_VIEW_NUM_LEVELS"),	# 0x82DC
    ("glGetTexParameter",	I,	1,	"GL_TEXTURE_VIEW_MIN_LAYER"),	# 0x82DD
    ("glGetTexParameter",	I,	1,	"GL_TEXTURE_VIEW_NUM_LAYERS"),	# 0x82DE
    ("glGetTexParameter",	I,	1,	"GL_TEXTURE_IMMUTABLE_LEVELS"),	# 0x82DF
    ("",	X,	1,	"GL_BUFFER"),	# 0x82E0
    ("",	X,	1,	"GL_SHADER"),	# 0x82E1
    ("",	X,	1,	"GL_PROGRAM"),	# 0x82E2
    ("",	X,	1,	"GL_QUERY"),	# 0x82E3
    ("",	X,	1,	"GL_PROGRAM_PIPELINE"),	# 0x82E4
    ("",	X,	1,	"GL_MAX_VERTEX_ATTRIB_STRIDE"),	# 0x82E5
    ("",	X,	1,	"GL_SAMPLER"),	# 0x82E6
    ("",	X,	1,	"GL_DISPLAY_LIST"),	# 0x82E7
    ("glGet",	I,	1,	"GL_MAX_LABEL_LENGTH"),	# 0x82E8
    ("",	X,	1,	"GL_NUM_SHADING_LANGUAGE_VERSIONS"),	# 0x82E9
    ("",	X,	1,	"GL_DEPTH_PASS_INSTRUMENT_SGIX"),	# 0x8310
    ("",	X,	1,	"GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX"),	# 0x8311
    ("",	X,	1,	"GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX"),	# 0x8312
    #("",	X,	1,	"GL_FRAGMENTS_INSTRUMENT_SGIX"),	# 0x8313
    #("",	X,	1,	"GL_FRAGMENTS_INSTRUMENT_COUNTERS_SGIX"),	# 0x8314
    #("",	X,	1,	"GL_FRAGMENTS_INSTRUMENT_MAX_SGIX"),	# 0x8315
    ("glGet",	I,	1,	"GL_CONVOLUTION_HINT_SGIX"),	# 0x8316
    ("",	X,	1,	"GL_YCRCB_SGIX"),	# 0x8318
    ("",	X,	1,	"GL_YCRCBA_SGIX"),	# 0x8319
    #("",	X,	1,	"GL_UNPACK_COMPRESSED_SIZE_SGIX"),	# 0x831A
    #("",	X,	1,	"GL_PACK_MAX_COMPRESSED_SIZE_SGIX"),	# 0x831B
    #("",	X,	1,	"GL_PACK_COMPRESSED_SIZE_SGIX"),	# 0x831C
    #("",	X,	1,	"GL_SLIM8U_SGIX"),	# 0x831D
    #("",	X,	1,	"GL_SLIM10U_SGIX"),	# 0x831E
    #("",	X,	1,	"GL_SLIM12S_SGIX"),	# 0x831F
    ("",	X,	1,	"GL_ALPHA_MIN_SGIX"),	# 0x8320
    ("",	X,	1,	"GL_ALPHA_MAX_SGIX"),	# 0x8321
    ("",	X,	1,	"GL_SCALEBIAS_HINT_SGIX"),	# 0x8322
    ("",	X,	1,	"GL_ASYNC_MARKER_SGIX"),	# 0x8329
    ("glGet",	I,	1,	"GL_PIXEL_TEX_GEN_MODE_SGIX"),	# 0x832B
    ("",	X,	1,	"GL_ASYNC_HISTOGRAM_SGIX"),	# 0x832C
    ("",	X,	1,	"GL_MAX_ASYNC_HISTOGRAM_SGIX"),	# 0x832D
    ("",	X,	1,	"GL_PIXEL_TRANSFORM_2D_EXT"),	# 0x8330
    ("",	X,	1,	"GL_PIXEL_MAG_FILTER_EXT"),	# 0x8331
    ("",	X,	1,	"GL_PIXEL_MIN_FILTER_EXT"),	# 0x8332
    ("",	X,	1,	"GL_PIXEL_CUBIC_WEIGHT_EXT"),	# 0x8333
    ("",	X,	1,	"GL_CUBIC_EXT"),	# 0x8334
    ("",	X,	1,	"GL_AVERAGE_EXT"),	# 0x8335
    ("",	X,	1,	"GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT"),	# 0x8336
    ("",	X,	1,	"GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT"),	# 0x8337
    ("",	X,	1,	"GL_PIXEL_TRANSFORM_2D_MATRIX_EXT"),	# 0x8338
    ("",	X,	1,	"GL_FRAGMENT_MATERIAL_EXT"),	# 0x8349
    ("",	X,	1,	"GL_FRAGMENT_NORMAL_EXT"),	# 0x834A
    ("",	X,	1,	"GL_FRAGMENT_COLOR_EXT"),	# 0x834C
    ("",	X,	1,	"GL_ATTENUATION_EXT"),	# 0x834D
    ("",	X,	1,	"GL_SHADOW_ATTENUATION_EXT"),	# 0x834E
    ("glGet",	I,	1,	"GL_TEXTURE_APPLICATION_MODE_EXT"),	# 0x834F
    ("glGet",	I,	1,	"GL_TEXTURE_LIGHT_EXT"),	# 0x8350
    ("glGet",	I,	1,	"GL_TEXTURE_MATERIAL_FACE_EXT"),	# 0x8351
    ("glGet",	I,	1,	"GL_TEXTURE_MATERIAL_PARAMETER_EXT"),	# 0x8352
    ("glGet",	I,	1,	"GL_PIXEL_TEXTURE_SGIS"),	# 0x8353
    ("glGet",	I,	1,	"GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS"),	# 0x8354
    ("glGet",	I,	1,	"GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS"),	# 0x8355
    ("glGet",	I,	1,	"GL_PIXEL_GROUP_COLOR_SGIS"),	# 0x8356
    #("",	X,	1,	"GL_LINE_QUALITY_HINT_SGIX"),	# 0x835B
    ("",	X,	1,	"GL_ASYNC_TEX_IMAGE_SGIX"),	# 0x835C
    ("",	X,	1,	"GL_ASYNC_DRAW_PIXELS_SGIX"),	# 0x835D
    ("",	X,	1,	"GL_ASYNC_READ_PIXELS_SGIX"),	# 0x835E
    ("",	X,	1,	"GL_MAX_ASYNC_TEX_IMAGE_SGIX"),	# 0x835F
    ("",	X,	1,	"GL_MAX_ASYNC_DRAW_PIXELS_SGIX"),	# 0x8360
    ("",	X,	1,	"GL_MAX_ASYNC_READ_PIXELS_SGIX"),	# 0x8361
    ("",	X,	1,	"GL_UNSIGNED_BYTE_2_3_3_REV"),	# 0x8362
    ("",	X,	1,	"GL_UNSIGNED_SHORT_5_6_5"),	# 0x8363
    ("",	X,	1,	"GL_UNSIGNED_SHORT_5_6_5_REV"),	# 0x8364
    ("",	X,	1,	"GL_UNSIGNED_SHORT_4_4_4_4_REV"),	# 0x8365
    ("",	X,	1,	"GL_UNSIGNED_SHORT_1_5_5_5_REV"),	# 0x8366
    ("",	X,	1,	"GL_UNSIGNED_INT_8_8_8_8_REV"),	# 0x8367
    ("",	X,	1,	"GL_UNSIGNED_INT_2_10_10_10_REV"),	# 0x8368
    ("glGetTexParameter",	F,	1,	"GL_TEXTURE_MAX_CLAMP_S_SGIX"),	# 0x8369
    ("glGetTexParameter",	F,	1,	"GL_TEXTURE_MAX_CLAMP_T_SGIX"),	# 0x836A
    ("glGetTexParameter",	F,	1,	"GL_TEXTURE_MAX_CLAMP_R_SGIX"),	# 0x836B
    ("",	X,	1,	"GL_MIRRORED_REPEAT"),	# 0x8370
    ("",	X,	1,	"GL_RGB_S3TC"),	# 0x83A0
    ("",	X,	1,	"GL_RGB4_S3TC"),	# 0x83A1
    ("",	X,	1,	"GL_RGBA_S3TC"),	# 0x83A2
    ("",	X,	1,	"GL_RGBA4_S3TC"),	# 0x83A3
    ("",	X,	1,	"GL_RGBA_DXT5_S3TC"),	# 0x83A4
    ("",	X,	1,	"GL_RGBA4_DXT5_S3TC"),	# 0x83A5
    ("",	X,	1,	"GL_VERTEX_PRECLIP_SGIX"),	# 0x83EE
    ("",	X,	1,	"GL_VERTEX_PRECLIP_HINT_SGIX"),	# 0x83EF
    ("",	X,	1,	"GL_COMPRESSED_RGB_S3TC_DXT1_EXT"),	# 0x83F0
    ("",	X,	1,	"GL_COMPRESSED_RGBA_S3TC_DXT1_EXT"),	# 0x83F1
    ("",	X,	1,	"GL_COMPRESSED_RGBA_S3TC_DXT3_EXT"),	# 0x83F2
    ("",	X,	1,	"GL_COMPRESSED_RGBA_S3TC_DXT5_EXT"),	# 0x83F3
    ("",	X,	1,	"GL_PARALLEL_ARRAYS_INTEL"),	# 0x83F4
    ("",	X,	1,	"GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL"),	# 0x83F5
    ("",	X,	1,	"GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL"),	# 0x83F6
    ("",	X,	1,	"GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL"),	# 0x83F7
    ("",	X,	1,	"GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL"),	# 0x83F8
    ("",	X,	1,	"GL_PERFQUERY_DONOT_FLUSH_INTEL"),	# 0x83F9
    ("",	X,	1,	"GL_PERFQUERY_FLUSH_INTEL"),	# 0x83FA
    ("",	X,	1,	"GL_PERFQUERY_WAIT_INTEL"),	# 0x83FB
    ("",	X,	1,	"GL_TEXTURE_MEMORY_LAYOUT_INTEL"),	# 0x83FF
    ("glGet",	I,	1,	"GL_FRAGMENT_LIGHTING_SGIX"),	# 0x8400
    ("glGet",	I,	1,	"GL_FRAGMENT_COLOR_MATERIAL_SGIX"),	# 0x8401
    ("glGet",	I,	1,	"GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX"),	# 0x8402
    ("glGet",	I,	1,	"GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX"),	# 0x8403
    ("glGet",	I,	1,	"GL_MAX_FRAGMENT_LIGHTS_SGIX"),	# 0x8404
    ("glGet",	I,	1,	"GL_MAX_ACTIVE_LIGHTS_SGIX"),	# 0x8405
    ("glGet",	I,	1,	"GL_CURRENT_RASTER_NORMAL_SGIX"),	# 0x8406
    ("glGet",	I,	1,	"GL_LIGHT_ENV_MODE_SGIX"),	# 0x8407
    ("glGet",	I,	1,	"GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX"),	# 0x8408
    ("glGet",	I,	1,	"GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX"),	# 0x8409
    ("glGet",	F,	4,	"GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX"),	# 0x840A
    ("glGet",	I,	1,	"GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX"),	# 0x840B
    ("glGet",	I,	1,	"GL_FRAGMENT_LIGHT0_SGIX"),	# 0x840C
    ("",	X,	1,	"GL_FRAGMENT_LIGHT1_SGIX"),	# 0x840D
    ("",	X,	1,	"GL_FRAGMENT_LIGHT2_SGIX"),	# 0x840E
    ("",	X,	1,	"GL_FRAGMENT_LIGHT3_SGIX"),	# 0x840F
    ("",	X,	1,	"GL_FRAGMENT_LIGHT4_SGIX"),	# 0x8410
    ("",	X,	1,	"GL_FRAGMENT_LIGHT5_SGIX"),	# 0x8411
    ("",	X,	1,	"GL_FRAGMENT_LIGHT6_SGIX"),	# 0x8412
    ("",	X,	1,	"GL_FRAGMENT_LIGHT7_SGIX"),	# 0x8413
    ("",	X,	1,	"GL_PACK_RESAMPLE_SGIX"),	# 0x842C
    ("",	X,	1,	"GL_UNPACK_RESAMPLE_SGIX"),	# 0x842D
    ("",	X,	1,	"GL_RESAMPLE_REPLICATE_SGIX"),	# 0x842E
    ("",	X,	1,	"GL_RESAMPLE_ZERO_FILL_SGIX"),	# 0x842F
    ("",	X,	1,	"GL_RESAMPLE_DECIMATE_SGIX"),	# 0x8430
    ("",	X,	1,	"GL_TANGENT_ARRAY_EXT"),	# 0x8439
    ("",	X,	1,	"GL_BINORMAL_ARRAY_EXT"),	# 0x843A
    ("",	X,	1,	"GL_CURRENT_TANGENT_EXT"),	# 0x843B
    ("",	X,	1,	"GL_CURRENT_BINORMAL_EXT"),	# 0x843C
    ("glGet",	E,	1,	"GL_TANGENT_ARRAY_TYPE_EXT"),	# 0x843E
    ("",	X,	1,	"GL_TANGENT_ARRAY_STRIDE_EXT"),	# 0x843F
    ("glGet",	E,	1,	"GL_BINORMAL_ARRAY_TYPE_EXT"),	# 0x8440
    ("",	X,	1,	"GL_BINORMAL_ARRAY_STRIDE_EXT"),	# 0x8441
    ("glGet",	P,	1,	"GL_TANGENT_ARRAY_POINTER_EXT"),	# 0x8442
    ("glGet",	P,	1,	"GL_BINORMAL_ARRAY_POINTER_EXT"),	# 0x8443
    ("",	X,	1,	"GL_MAP1_TANGENT_EXT"),	# 0x8444
    ("",	X,	1,	"GL_MAP2_TANGENT_EXT"),	# 0x8445
    ("",	X,	1,	"GL_MAP1_BINORMAL_EXT"),	# 0x8446
    ("",	X,	1,	"GL_MAP2_BINORMAL_EXT"),	# 0x8447
    ("",	X,	1,	"GL_NEAREST_CLIPMAP_NEAREST_SGIX"),	# 0x844D
    ("",	X,	1,	"GL_NEAREST_CLIPMAP_LINEAR_SGIX"),	# 0x844E
    ("",	X,	1,	"GL_LINEAR_CLIPMAP_NEAREST_SGIX"),	# 0x844F
    ("glGet",	E,	1,	"GL_FOG_COORD_SRC"),	# 0x8450
    ("",	X,	1,	"GL_FOG_COORD"),	# 0x8451
    ("",	X,	1,	"GL_FRAGMENT_DEPTH"),	# 0x8452
    ("glGet",	F,	1,	"GL_CURRENT_FOG_COORD"),	# 0x8453
    ("glGet",	E,	1,	"GL_FOG_COORD_ARRAY_TYPE"),	# 0x8454
    ("glGet",	I,	1,	"GL_FOG_COORD_ARRAY_STRIDE"),	# 0x8455
    ("",	X,	1,	"GL_FOG_COORD_ARRAY_POINTER"),	# 0x8456
    ("glGet",	B,	1,	"GL_FOG_COORD_ARRAY"),	# 0x8457
    ("glGet",	B,	1,	"GL_COLOR_SUM"),	# 0x8458
    ("glGet",	F,	4,	"GL_CURRENT_SECONDARY_COLOR"),	# 0x8459
    ("glGet",	I,	1,	"GL_SECONDARY_COLOR_ARRAY_SIZE"),	# 0x845A
    ("glGet",	E,	1,	"GL_SECONDARY_COLOR_ARRAY_TYPE"),	# 0x845B
    ("glGet",	I,	1,	"GL_SECONDARY_COLOR_ARRAY_STRIDE"),	# 0x845C
    ("",	X,	1,	"GL_SECONDARY_COLOR_ARRAY_POINTER"),	# 0x845D
    ("glGet",	B,	1,	"GL_SECONDARY_COLOR_ARRAY"),	# 0x845E
    ("",	X,	1,	"GL_CURRENT_RASTER_SECONDARY_COLOR"),	# 0x845F
    ("glGet",	F,	2,	"GL_ALIASED_POINT_SIZE_RANGE"),	# 0x846D
    ("glGet",	F,	2,	"GL_ALIASED_LINE_WIDTH_RANGE"),	# 0x846E
    ("",	X,	1,	"GL_SCREEN_COORDINATES_REND"),	# 0x8490
    ("",	X,	1,	"GL_INVERTED_SCREEN_W_REND"),	# 0x8491
    ("",	X,	1,	"GL_TEXTURE0"),	# 0x84C0
    ("",	X,	1,	"GL_TEXTURE1"),	# 0x84C1
    ("",	X,	1,	"GL_TEXTURE2"),	# 0x84C2
    ("",	X,	1,	"GL_TEXTURE3"),	# 0x84C3
    ("",	X,	1,	"GL_TEXTURE4"),	# 0x84C4
    ("",	X,	1,	"GL_TEXTURE5"),	# 0x84C5
    ("",	X,	1,	"GL_TEXTURE6"),	# 0x84C6
    ("",	X,	1,	"GL_TEXTURE7"),	# 0x84C7
    ("",	X,	1,	"GL_TEXTURE8"),	# 0x84C8
    ("",	X,	1,	"GL_TEXTURE9"),	# 0x84C9
    ("",	X,	1,	"GL_TEXTURE10"),	# 0x84CA
    ("",	X,	1,	"GL_TEXTURE11"),	# 0x84CB
    ("",	X,	1,	"GL_TEXTURE12"),	# 0x84CC
    ("",	X,	1,	"GL_TEXTURE13"),	# 0x84CD
    ("",	X,	1,	"GL_TEXTURE14"),	# 0x84CE
    ("",	X,	1,	"GL_TEXTURE15"),	# 0x84CF
    ("",	X,	1,	"GL_TEXTURE16"),	# 0x84D0
    ("",	X,	1,	"GL_TEXTURE17"),	# 0x84D1
    ("",	X,	1,	"GL_TEXTURE18"),	# 0x84D2
    ("",	X,	1,	"GL_TEXTURE19"),	# 0x84D3
    ("",	X,	1,	"GL_TEXTURE20"),	# 0x84D4
    ("",	X,	1,	"GL_TEXTURE21"),	# 0x84D5
    ("",	X,	1,	"GL_TEXTURE22"),	# 0x84D6
    ("",	X,	1,	"GL_TEXTURE23"),	# 0x84D7
    ("",	X,	1,	"GL_TEXTURE24"),	# 0x84D8
    ("",	X,	1,	"GL_TEXTURE25"),	# 0x84D9
    ("",	X,	1,	"GL_TEXTURE26"),	# 0x84DA
    ("",	X,	1,	"GL_TEXTURE27"),	# 0x84DB
    ("",	X,	1,	"GL_TEXTURE28"),	# 0x84DC
    ("",	X,	1,	"GL_TEXTURE29"),	# 0x84DD
    ("",	X,	1,	"GL_TEXTURE30"),	# 0x84DE
    ("",	X,	1,	"GL_TEXTURE31"),	# 0x84DF
    ("glGet",	E,	1,	"GL_ACTIVE_TEXTURE"),	# 0x84E0
    ("glGet",	E,	1,	"GL_CLIENT_ACTIVE_TEXTURE"),	# 0x84E1
    ("glGet",	I,	1,	"GL_MAX_TEXTURE_UNITS"),	# 0x84E2
    ("glGet",	F,	16,	"GL_TRANSPOSE_MODELVIEW_MATRIX"),	# 0x84E3
    ("glGet",	F,	16,	"GL_TRANSPOSE_PROJECTION_MATRIX"),	# 0x84E4
    ("glGet",	F,	16,	"GL_TRANSPOSE_TEXTURE_MATRIX"),	# 0x84E5
    ("glGet",	F,	16,	"GL_TRANSPOSE_COLOR_MATRIX"),	# 0x84E6
    ("",	X,	1,	"GL_SUBTRACT"),	# 0x84E7
    ("glGet",	I,	1,	"GL_MAX_RENDERBUFFER_SIZE"),	# 0x84E8
    ("",	X,	1,	"GL_COMPRESSED_ALPHA"),	# 0x84E9
    ("",	X,	1,	"GL_COMPRESSED_LUMINANCE"),	# 0x84EA
    ("",	X,	1,	"GL_COMPRESSED_LUMINANCE_ALPHA"),	# 0x84EB
    ("",	X,	1,	"GL_COMPRESSED_INTENSITY"),	# 0x84EC
    ("",	X,	1,	"GL_COMPRESSED_RGB"),	# 0x84ED
    ("",	X,	1,	"GL_COMPRESSED_RGBA"),	# 0x84EE
    ("glGet",	E,	1,	"GL_TEXTURE_COMPRESSION_HINT"),	# 0x84EF
    ("glGetActiveUniformBlock",	B,	1,	"GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER"),	# 0x84F0
    ("glGetActiveUniformBlock",	B,	1,	"GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER"),	# 0x84F1
    ("",	X,	1,	"GL_ALL_COMPLETED_NV"),	# 0x84F2
    ("",	X,	1,	"GL_FENCE_STATUS_NV"),	# 0x84F3
    ("",	X,	1,	"GL_FENCE_CONDITION_NV"),	# 0x84F4
    ("_glGet",	B,	1,	"GL_TEXTURE_RECTANGLE"),	# 0x84F5
    ("_glGet",	I,	1,	"GL_TEXTURE_BINDING_RECTANGLE"),	# 0x84F6
    ("",	X,	1,	"GL_PROXY_TEXTURE_RECTANGLE"),	# 0x84F7
    ("glGet",	I,	1,	"GL_MAX_RECTANGLE_TEXTURE_SIZE"),	# 0x84F8
    ("",	X,	1,	"GL_DEPTH_STENCIL"),	# 0x84F9
    ("",	X,	1,	"GL_UNSIGNED_INT_24_8"),	# 0x84FA
    ("glGet",	F,	1,	"GL_MAX_TEXTURE_LOD_BIAS"),	# 0x84FD
    ("glGetTexParameter",	F,	1,	"GL_TEXTURE_MAX_ANISOTROPY_EXT"),	# 0x84FE
    ("glGet",	F,	1,	"GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT"),	# 0x84FF
    ("",	X,	1,	"GL_TEXTURE_FILTER_CONTROL"),	# 0x8500
    ("glGetTexParameter,glGetTexEnv",	F,	1,	"GL_TEXTURE_LOD_BIAS"),	# 0x8501
    ("",	X,	1,	"GL_MODELVIEW1_STACK_DEPTH_EXT"),	# 0x8502
    ("",	X,	1,	"GL_COMBINE4_NV"),	# 0x8503
    ("glGet",	F,	1,	"GL_MAX_SHININESS_NV"),	# 0x8504
    ("glGet",	F,	1,	"GL_MAX_SPOT_EXPONENT_NV"),	# 0x8505
    ("",	X,	1,	"GL_MODELVIEW1_MATRIX_EXT"),	# 0x8506
    ("",	X,	1,	"GL_INCR_WRAP"),	# 0x8507
    ("",	X,	1,	"GL_DECR_WRAP"),	# 0x8508
    ("",	X,	1,	"GL_VERTEX_WEIGHTING_EXT"),	# 0x8509
    ("",	X,	1,	"GL_MODELVIEW1_ARB"),	# 0x850A
    ("",	X,	1,	"GL_CURRENT_VERTEX_WEIGHT_EXT"),	# 0x850B
    ("",	X,	1,	"GL_VERTEX_WEIGHT_ARRAY_EXT"),	# 0x850C
    ("",	X,	1,	"GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT"),	# 0x850D
    ("glGet",	E,	1,	"GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT"),	# 0x850E
    ("",	X,	1,	"GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT"),	# 0x850F
    ("",	X,	1,	"GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT"),	# 0x8510
    ("",	X,	1,	"GL_NORMAL_MAP"),	# 0x8511
    ("",	X,	1,	"GL_REFLECTION_MAP"),	# 0x8512
    ("_glGet",	B,	1,	"GL_TEXTURE_CUBE_MAP"),	# 0x8513
    ("_glGet",	I,	1,	"GL_TEXTURE_BINDING_CUBE_MAP"),	# 0x8514
    ("",	X,	1,	"GL_TEXTURE_CUBE_MAP_POSITIVE_X"),	# 0x8515
    ("",	X,	1,	"GL_TEXTURE_CUBE_MAP_NEGATIVE_X"),	# 0x8516
    ("",	X,	1,	"GL_TEXTURE_CUBE_MAP_POSITIVE_Y"),	# 0x8517
    ("",	X,	1,	"GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"),	# 0x8518
    ("",	X,	1,	"GL_TEXTURE_CUBE_MAP_POSITIVE_Z"),	# 0x8519
    ("",	X,	1,	"GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"),	# 0x851A
    ("",	X,	1,	"GL_PROXY_TEXTURE_CUBE_MAP"),	# 0x851B
    ("glGet",	I,	1,	"GL_MAX_CUBE_MAP_TEXTURE_SIZE"),	# 0x851C
    ("_glGet",	B,	1,	"GL_VERTEX_ARRAY_RANGE_NV"),	# 0x851D
    ("_glGet",	I,	1,	"GL_VERTEX_ARRAY_RANGE_LENGTH_NV"),	# 0x851E
    ("_glGet",	B,	1,	"GL_VERTEX_ARRAY_RANGE_VALID_NV"),	# 0x851F
    ("_glGet",	I,	1,	"GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV"),	# 0x8520
    ("_glGet",	P,	1,	"GL_VERTEX_ARRAY_RANGE_POINTER_NV"),	# 0x8521
    ("",	X,	1,	"GL_REGISTER_COMBINERS_NV"),	# 0x8522
    ("",	X,	1,	"GL_VARIABLE_A_NV"),	# 0x8523
    ("",	X,	1,	"GL_VARIABLE_B_NV"),	# 0x8524
    ("",	X,	1,	"GL_VARIABLE_C_NV"),	# 0x8525
    ("",	X,	1,	"GL_VARIABLE_D_NV"),	# 0x8526
    ("",	X,	1,	"GL_VARIABLE_E_NV"),	# 0x8527
    ("",	X,	1,	"GL_VARIABLE_F_NV"),	# 0x8528
    ("",	X,	1,	"GL_VARIABLE_G_NV"),	# 0x8529
    ("glGet",	F,	4,	"GL_CONSTANT_COLOR0_NV"),	# 0x852A
    ("glGet",	F,	4,	"GL_CONSTANT_COLOR1_NV"),	# 0x852B
    ("",	X,	1,	"GL_PRIMARY_COLOR_NV"),	# 0x852C
    ("",	X,	1,	"GL_SECONDARY_COLOR_NV"),	# 0x852D
    ("",	X,	1,	"GL_SPARE0_NV"),	# 0x852E
    ("",	X,	1,	"GL_SPARE1_NV"),	# 0x852F
    ("",	X,	1,	"GL_DISCARD_NV"),	# 0x8530
    ("",	X,	1,	"GL_E_TIMES_F_NV"),	# 0x8531
    ("",	X,	1,	"GL_SPARE0_PLUS_SECONDARY_COLOR_NV"),	# 0x8532
    ("",	X,	1,	"GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV"),	# 0x8533
    ("glGet",	E,	1,	"GL_MULTISAMPLE_FILTER_HINT_NV"),	# 0x8534
    ("",	X,	1,	"GL_PER_STAGE_CONSTANTS_NV"),	# 0x8535
    ("",	X,	1,	"GL_UNSIGNED_IDENTITY_NV"),	# 0x8536
    ("",	X,	1,	"GL_UNSIGNED_INVERT_NV"),	# 0x8537
    ("",	X,	1,	"GL_EXPAND_NORMAL_NV"),	# 0x8538
    ("",	X,	1,	"GL_EXPAND_NEGATE_NV"),	# 0x8539
    ("",	X,	1,	"GL_HALF_BIAS_NORMAL_NV"),	# 0x853A
    ("",	X,	1,	"GL_HALF_BIAS_NEGATE_NV"),	# 0x853B
    ("",	X,	1,	"GL_SIGNED_IDENTITY_NV"),	# 0x853C
    ("",	X,	1,	"GL_SIGNED_NEGATE_NV"),	# 0x853D
    ("",	X,	1,	"GL_SCALE_BY_TWO_NV"),	# 0x853E
    ("",	X,	1,	"GL_SCALE_BY_FOUR_NV"),	# 0x853F
    ("",	X,	1,	"GL_SCALE_BY_ONE_HALF_NV"),	# 0x8540
    ("",	X,	1,	"GL_BIAS_BY_NEGATIVE_ONE_HALF_NV"),	# 0x8541
    ("",	X,	1,	"GL_COMBINER_INPUT_NV"),	# 0x8542
    ("",	X,	1,	"GL_COMBINER_MAPPING_NV"),	# 0x8543
    ("",	X,	1,	"GL_COMBINER_COMPONENT_USAGE_NV"),	# 0x8544
    ("",	X,	1,	"GL_COMBINER_AB_DOT_PRODUCT_NV"),	# 0x8545
    ("",	X,	1,	"GL_COMBINER_CD_DOT_PRODUCT_NV"),	# 0x8546
    ("",	X,	1,	"GL_COMBINER_MUX_SUM_NV"),	# 0x8547
    ("",	X,	1,	"GL_COMBINER_SCALE_NV"),	# 0x8548
    ("",	X,	1,	"GL_COMBINER_BIAS_NV"),	# 0x8549
    ("",	X,	1,	"GL_COMBINER_AB_OUTPUT_NV"),	# 0x854A
    ("",	X,	1,	"GL_COMBINER_CD_OUTPUT_NV"),	# 0x854B
    ("",	X,	1,	"GL_COMBINER_SUM_OUTPUT_NV"),	# 0x854C
    ("glGet",	I,	1,	"GL_MAX_GENERAL_COMBINERS_NV"),	# 0x854D
    ("glGet",	I,	1,	"GL_NUM_GENERAL_COMBINERS_NV"),	# 0x854E
    ("glGet",	B,	1,	"GL_COLOR_SUM_CLAMP_NV"),	# 0x854F
    ("",	X,	1,	"GL_COMBINER0_NV"),	# 0x8550
    ("",	X,	1,	"GL_COMBINER1_NV"),	# 0x8551
    ("",	X,	1,	"GL_COMBINER2_NV"),	# 0x8552
    ("",	X,	1,	"GL_COMBINER3_NV"),	# 0x8553
    ("",	X,	1,	"GL_COMBINER4_NV"),	# 0x8554
    ("",	X,	1,	"GL_COMBINER5_NV"),	# 0x8555
    ("",	X,	1,	"GL_COMBINER6_NV"),	# 0x8556
    ("",	X,	1,	"GL_COMBINER7_NV"),	# 0x8557
    ("",	X,	1,	"GL_PRIMITIVE_RESTART_NV"),	# 0x8558
    ("",	X,	1,	"GL_PRIMITIVE_RESTART_INDEX_NV"),	# 0x8559
    ("glGet",	E,	1,	"GL_FOG_DISTANCE_MODE_NV"),	# 0x855A
    ("",	X,	1,	"GL_EYE_RADIAL_NV"),	# 0x855B
    ("",	X,	1,	"GL_EYE_PLANE_ABSOLUTE_NV"),	# 0x855C
    ("",	X,	1,	"GL_EMBOSS_LIGHT_NV"),	# 0x855D
    ("",	X,	1,	"GL_EMBOSS_CONSTANT_NV"),	# 0x855E
    ("",	X,	1,	"GL_EMBOSS_MAP_NV"),	# 0x855F
    ("",	X,	1,	"GL_RED_MIN_CLAMP_INGR"),	# 0x8560
    ("",	X,	1,	"GL_GREEN_MIN_CLAMP_INGR"),	# 0x8561
    ("",	X,	1,	"GL_BLUE_MIN_CLAMP_INGR"),	# 0x8562
    ("",	X,	1,	"GL_ALPHA_MIN_CLAMP_INGR"),	# 0x8563
    ("",	X,	1,	"GL_RED_MAX_CLAMP_INGR"),	# 0x8564
    ("",	X,	1,	"GL_GREEN_MAX_CLAMP_INGR"),	# 0x8565
    ("",	X,	1,	"GL_BLUE_MAX_CLAMP_INGR"),	# 0x8566
    ("",	X,	1,	"GL_ALPHA_MAX_CLAMP_INGR"),	# 0x8567
    ("",	X,	1,	"GL_INTERLACE_READ_INGR"),	# 0x8568
    ("",	X,	1,	"GL_COMBINE"),	# 0x8570
    ("glGetTexEnv",	E,	1,	"GL_COMBINE_RGB"),	# 0x8571
    ("glGetTexEnv",	E,	1,	"GL_COMBINE_ALPHA"),	# 0x8572
    ("glGetTexEnv",	F,	1,	"GL_RGB_SCALE"),	# 0x8573
    ("",	X,	1,	"GL_ADD_SIGNED"),	# 0x8574
    ("",	X,	1,	"GL_INTERPOLATE"),	# 0x8575
    ("",	X,	1,	"GL_CONSTANT"),	# 0x8576
    ("",	X,	1,	"GL_PRIMARY_COLOR"),	# 0x8577
    ("",	X,	1,	"GL_PREVIOUS"),	# 0x8578
    ("glGetTexEnv",	E,	1,	"GL_SRC0_RGB"),	# 0x8580
    ("glGetTexEnv",	E,	1,	"GL_SRC1_RGB"),	# 0x8581
    ("glGetTexEnv",	E,	1,	"GL_SRC2_RGB"),	# 0x8582
    ("glGetTexEnv",	E,	1,	"GL_SOURCE3_RGB_NV"),	# 0x8583
    ("glGetTexEnv",	E,	1,	"GL_SRC0_ALPHA"),	# 0x8588
    ("glGetTexEnv",	E,	1,	"GL_SRC1_ALPHA"),	# 0x8589
    ("glGetTexEnv",	E,	1,	"GL_SRC2_ALPHA"),	# 0x858A
    ("glGetTexEnv",	E,	1,	"GL_SOURCE3_ALPHA_NV"),	# 0x858B
    ("glGetTexEnv",	E,	1,	"GL_OPERAND0_RGB"),	# 0x8590
    ("glGetTexEnv",	E,	1,	"GL_OPERAND1_RGB"),	# 0x8591
    ("glGetTexEnv",	E,	1,	"GL_OPERAND2_RGB"),	# 0x8592
    ("glGetTexEnv",	E,	1,	"GL_OPERAND3_RGB_NV"),	# 0x8593
    ("glGetTexEnv",	E,	1,	"GL_OPERAND0_ALPHA"),	# 0x8598
    ("glGetTexEnv",	E,	1,	"GL_OPERAND1_ALPHA"),	# 0x8599
    ("glGetTexEnv",	E,	1,	"GL_OPERAND2_ALPHA"),	# 0x859A
    ("glGetTexEnv",	E,	1,	"GL_OPERAND3_ALPHA_NV"),	# 0x859B
    ("",	X,	1,	"GL_PACK_SUBSAMPLE_RATE_SGIX"),	# 0x85A0
    ("",	X,	1,	"GL_UNPACK_SUBSAMPLE_RATE_SGIX"),	# 0x85A1
    ("",	X,	1,	"GL_PIXEL_SUBSAMPLE_4444_SGIX"),	# 0x85A2
    ("",	X,	1,	"GL_PIXEL_SUBSAMPLE_2424_SGIX"),	# 0x85A3
    ("",	X,	1,	"GL_PIXEL_SUBSAMPLE_4242_SGIX"),	# 0x85A4
    ("",	X,	1,	"GL_PERTURB_EXT"),	# 0x85AE
    ("",	X,	1,	"GL_TEXTURE_NORMAL_EXT"),	# 0x85AF
    ("",	X,	1,	"GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE"),	# 0x85B0
    ("",	X,	1,	"GL_TRANSFORM_HINT_APPLE"),	# 0x85B1
    ("",	X,	1,	"GL_UNPACK_CLIENT_STORAGE_APPLE"),	# 0x85B2
    ("",	X,	1,	"GL_BUFFER_OBJECT_APPLE"),	# 0x85B3
    ("",	X,	1,	"GL_STORAGE_CLIENT_APPLE"),	# 0x85B4
    ("glGet",	I,	1,	"GL_VERTEX_ARRAY_BINDING"),	# 0x85B5
    ("glGetTexParameter",	X,	1,	"GL_TEXTURE_RANGE_LENGTH_APPLE"),	# 0x85B7
    ("",	P,	1,	"GL_TEXTURE_RANGE_POINTER_APPLE"),	# 0x85B8
    ("",	X,	1,	"GL_YCBCR_422_APPLE"),	# 0x85B9
    ("",	X,	1,	"GL_UNSIGNED_SHORT_8_8_APPLE"),	# 0x85BA
    ("",	X,	1,	"GL_UNSIGNED_SHORT_8_8_REV_APPLE"),	# 0x85BB
    ("glGetTexParameter",	E,	1,	"GL_TEXTURE_STORAGE_HINT_APPLE"),	# 0x85BC
    ("",	X,	1,	"GL_STORAGE_PRIVATE_APPLE"),	# 0x85BD
    ("",	X,	1,	"GL_STORAGE_CACHED_APPLE"),	# 0x85BE
    ("",	X,	1,	"GL_STORAGE_SHARED_APPLE"),	# 0x85BF
    ("",	X,	1,	"GL_REPLACEMENT_CODE_ARRAY_SUN"),	# 0x85C0
    ("glGet",	E,	1,	"GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN"),	# 0x85C1
    ("",	X,	1,	"GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN"),	# 0x85C2
    ("",	X,	1,	"GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN"),	# 0x85C3
    ("",	X,	1,	"GL_R1UI_V3F_SUN"),	# 0x85C4
    ("",	X,	1,	"GL_R1UI_C4UB_V3F_SUN"),	# 0x85C5
    ("",	X,	1,	"GL_R1UI_C3F_V3F_SUN"),	# 0x85C6
    ("",	X,	1,	"GL_R1UI_N3F_V3F_SUN"),	# 0x85C7
    ("",	X,	1,	"GL_R1UI_C4F_N3F_V3F_SUN"),	# 0x85C8
    ("",	X,	1,	"GL_R1UI_T2F_V3F_SUN"),	# 0x85C9
    ("",	X,	1,	"GL_R1UI_T2F_N3F_V3F_SUN"),	# 0x85CA
    ("",	X,	1,	"GL_R1UI_T2F_C4F_N3F_V3F_SUN"),	# 0x85CB
    ("",	X,	1,	"GL_SLICE_ACCUM_SUN"),	# 0x85CC
    ("",	X,	1,	"GL_QUAD_MESH_SUN"),	# 0x8614
    ("",	X,	1,	"GL_TRIANGLE_MESH_SUN"),	# 0x8615
    ("_glGet",	B,	1,	"GL_VERTEX_PROGRAM_ARB"),	# 0x8620
    ("",	X,	1,	"GL_VERTEX_STATE_PROGRAM_NV"),	# 0x8621
    ("glGetVertexAttrib",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY_ENABLED"),	# 0x8622
    ("glGetVertexAttrib",	I,	1,	"GL_VERTEX_ATTRIB_ARRAY_SIZE"),	# 0x8623
    ("glGetVertexAttrib",	I,	1,	"GL_VERTEX_ATTRIB_ARRAY_STRIDE"),	# 0x8624
    ("glGetVertexAttrib",	E,	1,	"GL_VERTEX_ATTRIB_ARRAY_TYPE"),	# 0x8625
    ("glGetVertexAttrib",	D,	4,	"GL_CURRENT_VERTEX_ATTRIB"),	# 0x8626
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_LENGTH_ARB"),	# 0x8627
    ("",	S,	1,	"GL_PROGRAM_STRING_ARB"),	# 0x8628
    ("",	X,	1,	"GL_MODELVIEW_PROJECTION_NV"),	# 0x8629
    ("",	X,	1,	"GL_IDENTITY_NV"),	# 0x862A
    ("",	X,	1,	"GL_INVERSE_NV"),	# 0x862B
    ("",	X,	1,	"GL_TRANSPOSE_NV"),	# 0x862C
    ("",	X,	1,	"GL_INVERSE_TRANSPOSE_NV"),	# 0x862D
    ("glGet",	I,	1,	"GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB"),	# 0x862E
    ("glGet",	I,	1,	"GL_MAX_PROGRAM_MATRICES_ARB"),	# 0x862F
    ("",	X,	1,	"GL_MATRIX0_NV"),	# 0x8630
    ("",	X,	1,	"GL_MATRIX1_NV"),	# 0x8631
    ("",	X,	1,	"GL_MATRIX2_NV"),	# 0x8632
    ("",	X,	1,	"GL_MATRIX3_NV"),	# 0x8633
    ("",	X,	1,	"GL_MATRIX4_NV"),	# 0x8634
    ("",	X,	1,	"GL_MATRIX5_NV"),	# 0x8635
    ("",	X,	1,	"GL_MATRIX6_NV"),	# 0x8636
    ("",	X,	1,	"GL_MATRIX7_NV"),	# 0x8637
    ("glGet",	I,	1,	"GL_CURRENT_MATRIX_STACK_DEPTH_ARB"),	# 0x8640
    ("glGet",	F,	16,	"GL_CURRENT_MATRIX_ARB"),	# 0x8641
    ("glGet",	B,	1,	"GL_PROGRAM_POINT_SIZE"),	# 0x8642
    ("glGet",	B,	1,	"GL_VERTEX_PROGRAM_TWO_SIDE"),	# 0x8643
    ("",	X,	1,	"GL_PROGRAM_PARAMETER_NV"),	# 0x8644
    ("glGetVertexAttrib",	P,	1,	"GL_VERTEX_ATTRIB_ARRAY_POINTER"),	# 0x8645
    ("glGetProgramNV",	I,	1,	"GL_PROGRAM_TARGET_NV"),	# 0x8646
    ("glGetProgramNV",	B,	1,	"GL_PROGRAM_RESIDENT_NV"),	# 0x8647
    ("",	X,	1,	"GL_TRACK_MATRIX_NV"),	# 0x8648
    ("",	X,	1,	"GL_TRACK_MATRIX_TRANSFORM_NV"),	# 0x8649
    ("glGet",	I,	1,	"GL_VERTEX_PROGRAM_BINDING_NV"),	# 0x864A
    ("glGet",	I,	1,	"GL_PROGRAM_ERROR_POSITION_ARB"),	# 0x864B
    ("",	X,	1,	"GL_OFFSET_TEXTURE_RECTANGLE_NV"),	# 0x864C
    ("",	X,	1,	"GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV"),	# 0x864D
    ("",	X,	1,	"GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV"),	# 0x864E
    ("glGet",	B,	1,	"GL_DEPTH_CLAMP"),	# 0x864F
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY0_NV"),	# 0x8650
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY1_NV"),	# 0x8651
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY2_NV"),	# 0x8652
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY3_NV"),	# 0x8653
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY4_NV"),	# 0x8654
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY5_NV"),	# 0x8655
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY6_NV"),	# 0x8656
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY7_NV"),	# 0x8657
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY8_NV"),	# 0x8658
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY9_NV"),	# 0x8659
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY10_NV"),	# 0x865A
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY11_NV"),	# 0x865B
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY12_NV"),	# 0x865C
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY13_NV"),	# 0x865D
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY14_NV"),	# 0x865E
    ("_glGet",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY15_NV"),	# 0x865F
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB0_4_NV"),	# 0x8660
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB1_4_NV"),	# 0x8661
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB2_4_NV"),	# 0x8662
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB3_4_NV"),	# 0x8663
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB4_4_NV"),	# 0x8664
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB5_4_NV"),	# 0x8665
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB6_4_NV"),	# 0x8666
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB7_4_NV"),	# 0x8667
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB8_4_NV"),	# 0x8668
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB9_4_NV"),	# 0x8669
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB10_4_NV"),	# 0x866A
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB11_4_NV"),	# 0x866B
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB12_4_NV"),	# 0x866C
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB13_4_NV"),	# 0x866D
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB14_4_NV"),	# 0x866E
    ("",	X,	1,	"GL_MAP1_VERTEX_ATTRIB15_4_NV"),	# 0x866F
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB0_4_NV"),	# 0x8670
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB1_4_NV"),	# 0x8671
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB2_4_NV"),	# 0x8672
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB3_4_NV"),	# 0x8673
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB4_4_NV"),	# 0x8674
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB5_4_NV"),	# 0x8675
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB6_4_NV"),	# 0x8676
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_BINDING_ARB"),	# 0x8677
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB8_4_NV"),	# 0x8678
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB9_4_NV"),	# 0x8679
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB10_4_NV"),	# 0x867A
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB11_4_NV"),	# 0x867B
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB12_4_NV"),	# 0x867C
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB13_4_NV"),	# 0x867D
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB14_4_NV"),	# 0x867E
    ("",	X,	1,	"GL_MAP2_VERTEX_ATTRIB15_4_NV"),	# 0x867F
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_COMPRESSED_IMAGE_SIZE"),	# 0x86A0
    ("glGetTexLevelParameter",	B,	1,	"GL_TEXTURE_COMPRESSED"),	# 0x86A1
    ("glGet",	I,	1,	"GL_NUM_COMPRESSED_TEXTURE_FORMATS"),	# 0x86A2
    ("glGet",	E,	'_glGetInteger(GL_NUM_COMPRESSED_TEXTURE_FORMATS)',	"GL_COMPRESSED_TEXTURE_FORMATS"),	# 0x86A3
    ("glGet",	I,	1,	"GL_MAX_VERTEX_UNITS_ARB"),	# 0x86A4
    ("glGet",	I,	1,	"GL_ACTIVE_VERTEX_UNITS_ARB"),	# 0x86A5
    ("glGet",	B,	1,	"GL_WEIGHT_SUM_UNITY_ARB"),	# 0x86A6
    ("glGet",	B,	1,	"GL_VERTEX_BLEND_ARB"),	# 0x86A7
    ("glGet",	F,	1,	"GL_CURRENT_WEIGHT_ARB"),	# 0x86A8
    ("glGet",	E,	1,	"GL_WEIGHT_ARRAY_TYPE_ARB"),	# 0x86A9
    ("glGet",	I,	1,	"GL_WEIGHT_ARRAY_STRIDE_ARB"),	# 0x86AA
    ("glGet",	I,	1,	"GL_WEIGHT_ARRAY_SIZE_ARB"),	# 0x86AB
    ("glGet",	P,	1,	"GL_WEIGHT_ARRAY_POINTER_ARB"),	# 0x86AC
    ("glGet",	B,	1,	"GL_WEIGHT_ARRAY_ARB"),	# 0x86AD
    ("",	X,	1,	"GL_DOT3_RGB"),	# 0x86AE
    ("",	X,	1,	"GL_DOT3_RGBA"),	# 0x86AF
    ("",	X,	1,	"GL_COMPRESSED_RGB_FXT1_3DFX"),	# 0x86B0
    ("",	X,	1,	"GL_COMPRESSED_RGBA_FXT1_3DFX"),	# 0x86B1
    ("",	X,	1,	"GL_MULTISAMPLE_3DFX"),	# 0x86B2
    ("",	X,	1,	"GL_SAMPLE_BUFFERS_3DFX"),	# 0x86B3
    ("",	X,	1,	"GL_SAMPLES_3DFX"),	# 0x86B4
    ("",	X,	1,	"GL_EVAL_2D_NV"),	# 0x86C0
    ("",	X,	1,	"GL_EVAL_TRIANGULAR_2D_NV"),	# 0x86C1
    ("",	X,	1,	"GL_MAP_TESSELLATION_NV"),	# 0x86C2
    ("",	X,	1,	"GL_MAP_ATTRIB_U_ORDER_NV"),	# 0x86C3
    ("",	X,	1,	"GL_MAP_ATTRIB_V_ORDER_NV"),	# 0x86C4
    ("",	X,	1,	"GL_EVAL_FRACTIONAL_TESSELLATION_NV"),	# 0x86C5
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB0_NV"),	# 0x86C6
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB1_NV"),	# 0x86C7
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB2_NV"),	# 0x86C8
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB3_NV"),	# 0x86C9
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB4_NV"),	# 0x86CA
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB5_NV"),	# 0x86CB
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB6_NV"),	# 0x86CC
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB7_NV"),	# 0x86CD
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB8_NV"),	# 0x86CE
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB9_NV"),	# 0x86CF
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB10_NV"),	# 0x86D0
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB11_NV"),	# 0x86D1
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB12_NV"),	# 0x86D2
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB13_NV"),	# 0x86D3
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB14_NV"),	# 0x86D4
    ("",	X,	1,	"GL_EVAL_VERTEX_ATTRIB15_NV"),	# 0x86D5
    ("",	X,	1,	"GL_MAX_MAP_TESSELLATION_NV"),	# 0x86D6
    ("",	X,	1,	"GL_MAX_RATIONAL_EVAL_ORDER_NV"),	# 0x86D7
    ("",	X,	1,	"GL_MAX_PROGRAM_PATCH_ATTRIBS_NV"),	# 0x86D8
    ("glGetTexEnv",	E,	1,	"GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV"),	# 0x86D9
    ("",	X,	1,	"GL_UNSIGNED_INT_S8_S8_8_8_NV"),	# 0x86DA
    ("",	X,	1,	"GL_UNSIGNED_INT_8_8_S8_S8_REV_NV"),	# 0x86DB
    ("",	X,	1,	"GL_DSDT_MAG_INTENSITY_NV"),	# 0x86DC
    ("",	X,	1,	"GL_SHADER_CONSISTENT_NV"),	# 0x86DD
    ("",	X,	1,	"GL_TEXTURE_SHADER_NV"),	# 0x86DE
    ("glGetTexEnv",	E,	1,	"GL_SHADER_OPERATION_NV"),	# 0x86DF
    ("glGetTexEnv",	E,	4,	"GL_CULL_MODES_NV"),	# 0x86E0
    ("glGetTexEnv",	F,	4,	"GL_OFFSET_TEXTURE_MATRIX_NV"),	# 0x86E1
    ("glGetTexEnv",	F,	1,	"GL_OFFSET_TEXTURE_SCALE_NV"),	# 0x86E2
    ("glGetTexEnv",	F,	1,	"GL_OFFSET_TEXTURE_BIAS_NV"),	# 0x86E3
    ("glGetTexEnv",	E,	1,	"GL_PREVIOUS_TEXTURE_INPUT_NV"),	# 0x86E4
    ("glGetTexEnv",	F,	3,	"GL_CONST_EYE_NV"),	# 0x86E5
    ("",	X,	1,	"GL_PASS_THROUGH_NV"),	# 0x86E6
    ("",	X,	1,	"GL_CULL_FRAGMENT_NV"),	# 0x86E7
    ("",	X,	1,	"GL_OFFSET_TEXTURE_2D_NV"),	# 0x86E8
    ("",	X,	1,	"GL_DEPENDENT_AR_TEXTURE_2D_NV"),	# 0x86E9
    ("",	X,	1,	"GL_DEPENDENT_GB_TEXTURE_2D_NV"),	# 0x86EA
    ("",	X,	1,	"GL_SURFACE_STATE_NV"),	# 0x86EB
    ("",	X,	1,	"GL_DOT_PRODUCT_NV"),	# 0x86EC
    ("",	X,	1,	"GL_DOT_PRODUCT_DEPTH_REPLACE_NV"),	# 0x86ED
    ("",	X,	1,	"GL_DOT_PRODUCT_TEXTURE_2D_NV"),	# 0x86EE
    ("",	X,	1,	"GL_DOT_PRODUCT_TEXTURE_3D_NV"),	# 0x86EF
    ("",	X,	1,	"GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV"),	# 0x86F0
    ("",	X,	1,	"GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV"),	# 0x86F1
    ("",	X,	1,	"GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV"),	# 0x86F2
    ("",	X,	1,	"GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV"),	# 0x86F3
    ("",	X,	1,	"GL_HILO_NV"),	# 0x86F4
    ("",	X,	1,	"GL_DSDT_NV"),	# 0x86F5
    ("",	X,	1,	"GL_DSDT_MAG_NV"),	# 0x86F6
    ("",	X,	1,	"GL_DSDT_MAG_VIB_NV"),	# 0x86F7
    ("",	X,	1,	"GL_HILO16_NV"),	# 0x86F8
    ("",	X,	1,	"GL_SIGNED_HILO_NV"),	# 0x86F9
    ("",	X,	1,	"GL_SIGNED_HILO16_NV"),	# 0x86FA
    ("",	X,	1,	"GL_SIGNED_RGBA_NV"),	# 0x86FB
    ("",	X,	1,	"GL_SIGNED_RGBA8_NV"),	# 0x86FC
    ("",	X,	1,	"GL_SURFACE_REGISTERED_NV"),	# 0x86FD
    ("",	X,	1,	"GL_SIGNED_RGB_NV"),	# 0x86FE
    ("",	X,	1,	"GL_SIGNED_RGB8_NV"),	# 0x86FF
    ("",	X,	1,	"GL_SURFACE_MAPPED_NV"),	# 0x8700
    ("",	X,	1,	"GL_SIGNED_LUMINANCE_NV"),	# 0x8701
    ("",	X,	1,	"GL_SIGNED_LUMINANCE8_NV"),	# 0x8702
    ("",	X,	1,	"GL_SIGNED_LUMINANCE_ALPHA_NV"),	# 0x8703
    ("",	X,	1,	"GL_SIGNED_LUMINANCE8_ALPHA8_NV"),	# 0x8704
    ("",	X,	1,	"GL_SIGNED_ALPHA_NV"),	# 0x8705
    ("",	X,	1,	"GL_SIGNED_ALPHA8_NV"),	# 0x8706
    ("",	X,	1,	"GL_SIGNED_INTENSITY_NV"),	# 0x8707
    ("",	X,	1,	"GL_SIGNED_INTENSITY8_NV"),	# 0x8708
    ("",	X,	1,	"GL_DSDT8_NV"),	# 0x8709
    ("",	X,	1,	"GL_DSDT8_MAG8_NV"),	# 0x870A
    ("",	X,	1,	"GL_DSDT8_MAG8_INTENSITY8_NV"),	# 0x870B
    ("",	X,	1,	"GL_SIGNED_RGB_UNSIGNED_ALPHA_NV"),	# 0x870C
    ("",	X,	1,	"GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV"),	# 0x870D
    ("",	X,	1,	"GL_HI_SCALE_NV"),	# 0x870E
    ("",	X,	1,	"GL_LO_SCALE_NV"),	# 0x870F
    ("",	X,	1,	"GL_DS_SCALE_NV"),	# 0x8710
    ("",	X,	1,	"GL_DT_SCALE_NV"),	# 0x8711
    ("",	X,	1,	"GL_MAGNITUDE_SCALE_NV"),	# 0x8712
    ("",	X,	1,	"GL_VIBRANCE_SCALE_NV"),	# 0x8713
    ("",	X,	1,	"GL_HI_BIAS_NV"),	# 0x8714
    ("",	X,	1,	"GL_LO_BIAS_NV"),	# 0x8715
    ("",	X,	1,	"GL_DS_BIAS_NV"),	# 0x8716
    ("",	X,	1,	"GL_DT_BIAS_NV"),	# 0x8717
    ("",	X,	1,	"GL_MAGNITUDE_BIAS_NV"),	# 0x8718
    ("",	X,	1,	"GL_VIBRANCE_BIAS_NV"),	# 0x8719
    ("",	X,	1,	"GL_TEXTURE_BORDER_VALUES_NV"),	# 0x871A
    ("",	X,	1,	"GL_TEXTURE_HI_SIZE_NV"),	# 0x871B
    ("",	X,	1,	"GL_TEXTURE_LO_SIZE_NV"),	# 0x871C
    ("",	X,	1,	"GL_TEXTURE_DS_SIZE_NV"),	# 0x871D
    ("",	X,	1,	"GL_TEXTURE_DT_SIZE_NV"),	# 0x871E
    ("",	X,	1,	"GL_TEXTURE_MAG_SIZE_NV"),	# 0x871F
    ("_glGet",	F,	16,	"GL_MODELVIEW2_ARB"),	# 0x8722
    ("_glGet",	F,	16,	"GL_MODELVIEW3_ARB"),	# 0x8723
    ("_glGet",	F,	16,	"GL_MODELVIEW4_ARB"),	# 0x8724
    ("_glGet",	F,	16,	"GL_MODELVIEW5_ARB"),	# 0x8725
    ("_glGet",	F,	16,	"GL_MODELVIEW6_ARB"),	# 0x8726
    ("_glGet",	F,	16,	"GL_MODELVIEW7_ARB"),	# 0x8727
    ("_glGet",	F,	16,	"GL_MODELVIEW8_ARB"),	# 0x8728
    ("_glGet",	F,	16,	"GL_MODELVIEW9_ARB"),	# 0x8729
    ("_glGet",	F,	16,	"GL_MODELVIEW10_ARB"),	# 0x872A
    ("_glGet",	F,	16,	"GL_MODELVIEW11_ARB"),	# 0x872B
    ("_glGet",	F,	16,	"GL_MODELVIEW12_ARB"),	# 0x872C
    ("_glGet",	F,	16,	"GL_MODELVIEW13_ARB"),	# 0x872D
    ("_glGet",	F,	16,	"GL_MODELVIEW14_ARB"),	# 0x872E
    ("_glGet",	F,	16,	"GL_MODELVIEW15_ARB"),	# 0x872F
    ("_glGet",	F,	16,	"GL_MODELVIEW16_ARB"),	# 0x8730
    ("_glGet",	F,	16,	"GL_MODELVIEW17_ARB"),	# 0x8731
    ("_glGet",	F,	16,	"GL_MODELVIEW18_ARB"),	# 0x8732
    ("_glGet",	F,	16,	"GL_MODELVIEW19_ARB"),	# 0x8733
    ("_glGet",	F,	16,	"GL_MODELVIEW20_ARB"),	# 0x8734
    ("_glGet",	F,	16,	"GL_MODELVIEW21_ARB"),	# 0x8735
    ("_glGet",	F,	16,	"GL_MODELVIEW22_ARB"),	# 0x8736
    ("_glGet",	F,	16,	"GL_MODELVIEW23_ARB"),	# 0x8737
    ("_glGet",	F,	16,	"GL_MODELVIEW24_ARB"),	# 0x8738
    ("_glGet",	F,	16,	"GL_MODELVIEW25_ARB"),	# 0x8739
    ("_glGet",	F,	16,	"GL_MODELVIEW26_ARB"),	# 0x873A
    ("_glGet",	F,	16,	"GL_MODELVIEW27_ARB"),	# 0x873B
    ("_glGet",	F,	16,	"GL_MODELVIEW28_ARB"),	# 0x873C
    ("_glGet",	F,	16,	"GL_MODELVIEW29_ARB"),	# 0x873D
    ("_glGet",	F,	16,	"GL_MODELVIEW30_ARB"),	# 0x873E
    ("_glGet",	F,	16,	"GL_MODELVIEW31_ARB"),	# 0x873F
    ("",	X,	1,	"GL_DOT3_RGB_EXT"),	# 0x8740
    # XXX: GL_DOT3_RGBA_EXT == GL_PROGRAM_BINARY_LENGTH, but you can't glGet GL_DOT3_RGBA_EXT
    ("glGetProgram",	I,	1,	"GL_PROGRAM_BINARY_LENGTH"),	# 0x8741,
    ("",	X,	1,	"GL_MIRROR_CLAMP_ATI"),	# 0x8742
    ("",	X,	1,	"GL_MIRROR_CLAMP_TO_EDGE"),		# 0x8743
    ("",	X,	1,	"GL_MODULATE_ADD_ATI"),	# 0x8744
    ("",	X,	1,	"GL_MODULATE_SIGNED_ADD_ATI"),	# 0x8745
    ("",	X,	1,	"GL_MODULATE_SUBTRACT_ATI"),	# 0x8746
    ("",	X,	1,	"GL_SET_AMD"),	# 0x874A
    ("",	X,	1,	"GL_REPLACE_VALUE_AMD"),	# 0x874B
    ("",	X,	1,	"GL_STENCIL_OP_VALUE_AMD"),	# 0x874C
    ("",	X,	1,	"GL_STENCIL_BACK_OP_VALUE_AMD"),	# 0x874D
    ("glGetVertexAttrib",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY_LONG"),	# 0x874E
    ("",	X,	1,	"GL_OCCLUSION_QUERY_EVENT_MASK_AMD"),	# 0x874F
    #("",	X,	1,	"GL_DEPTH_STENCIL_MESA"),	# 0x8750
    #("",	X,	1,	"GL_UNSIGNED_INT_24_8_MESA"),	# 0x8751
    #("",	X,	1,	"GL_UNSIGNED_INT_8_24_REV_MESA"),	# 0x8752
    #("",	X,	1,	"GL_UNSIGNED_SHORT_15_1_MESA"),	# 0x8753
    #("",	X,	1,	"GL_UNSIGNED_SHORT_1_15_REV_MESA"),	# 0x8754
    #("",	X,	1,	"GL_TRACE_MASK_MESA"),	# 0x8755
    #("",	X,	1,	"GL_TRACE_NAME_MESA"),	# 0x8756
    ("",	X,	1,	"GL_YCBCR_MESA"),	# 0x8757
    ("glGet",	B,	1,	"GL_PACK_INVERT_MESA"),	# 0x8758
    ("",	X,	1,	"GL_TEXTURE_1D_STACK_MESAX"),	# 0x8759
    ("",	X,	1,	"GL_TEXTURE_2D_STACK_MESAX"),	# 0x875A
    ("",	X,	1,	"GL_PROXY_TEXTURE_1D_STACK_MESAX"),	# 0x875B
    ("",	X,	1,	"GL_PROXY_TEXTURE_2D_STACK_MESAX"),	# 0x875C
    ("",	X,	1,	"GL_TEXTURE_1D_STACK_BINDING_MESAX"),	# 0x875D
    ("",	X,	1,	"GL_TEXTURE_2D_STACK_BINDING_MESAX"),	# 0x875E
    ("",	X,	1,	"GL_STATIC_ATI"),	# 0x8760
    ("",	X,	1,	"GL_DYNAMIC_ATI"),	# 0x8761
    ("",	X,	1,	"GL_PRESERVE_ATI"),	# 0x8762
    ("",	X,	1,	"GL_DISCARD_ATI"),	# 0x8763
    ("glGetBufferParameter",	I,	1,	"GL_BUFFER_SIZE"),	# 0x8764
    ("glGetBufferParameter",	E,	1,	"GL_BUFFER_USAGE"),	# 0x8765
    ("",	X,	1,	"GL_ARRAY_OBJECT_BUFFER_ATI"),	# 0x8766
    ("",	X,	1,	"GL_ARRAY_OBJECT_OFFSET_ATI"),	# 0x8767
    ("",	X,	1,	"GL_ELEMENT_ARRAY_ATI"),	# 0x8768
    ("glGet",	E,	1,	"GL_ELEMENT_ARRAY_TYPE_ATI"),	# 0x8769
    ("",	X,	1,	"GL_ELEMENT_ARRAY_POINTER_ATI"),	# 0x876A
    ("",	X,	1,	"GL_MAX_VERTEX_STREAMS_ATI"),	# 0x876B
    ("",	X,	1,	"GL_VERTEX_STREAM0_ATI"),	# 0x876C
    ("",	X,	1,	"GL_VERTEX_STREAM1_ATI"),	# 0x876D
    ("",	X,	1,	"GL_VERTEX_STREAM2_ATI"),	# 0x876E
    ("",	X,	1,	"GL_VERTEX_STREAM3_ATI"),	# 0x876F
    ("",	X,	1,	"GL_VERTEX_STREAM4_ATI"),	# 0x8770
    ("",	X,	1,	"GL_VERTEX_STREAM5_ATI"),	# 0x8771
    ("",	X,	1,	"GL_VERTEX_STREAM6_ATI"),	# 0x8772
    ("",	X,	1,	"GL_VERTEX_STREAM7_ATI"),	# 0x8773
    ("",	X,	1,	"GL_VERTEX_SOURCE_ATI"),	# 0x8774
    ("",	X,	1,	"GL_BUMP_ROT_MATRIX_ATI"),	# 0x8775
    ("",	X,	1,	"GL_BUMP_ROT_MATRIX_SIZE_ATI"),	# 0x8776
    ("",	X,	1,	"GL_BUMP_NUM_TEX_UNITS_ATI"),	# 0x8777
    ("",	X,	1,	"GL_BUMP_TEX_UNITS_ATI"),	# 0x8778
    ("",	X,	1,	"GL_DUDV_ATI"),	# 0x8779
    ("",	X,	1,	"GL_DU8DV8_ATI"),	# 0x877A
    ("",	X,	1,	"GL_BUMP_ENVMAP_ATI"),	# 0x877B
    ("glGetTexEnv",	E,	1,	"GL_BUMP_TARGET_ATI"),	# 0x877C
    ("",	X,	1,	"GL_VERTEX_SHADER_EXT"),	# 0x8780
    ("glGet",	I,	1,	"GL_VERTEX_SHADER_BINDING_EXT"),	# 0x8781
    ("",	X,	1,	"GL_OP_INDEX_EXT"),	# 0x8782
    ("",	X,	1,	"GL_OP_NEGATE_EXT"),	# 0x8783
    ("",	X,	1,	"GL_OP_DOT3_EXT"),	# 0x8784
    ("",	X,	1,	"GL_OP_DOT4_EXT"),	# 0x8785
    ("",	X,	1,	"GL_OP_MUL_EXT"),	# 0x8786
    ("",	X,	1,	"GL_OP_ADD_EXT"),	# 0x8787
    ("",	X,	1,	"GL_OP_MADD_EXT"),	# 0x8788
    ("",	X,	1,	"GL_OP_FRAC_EXT"),	# 0x8789
    ("",	X,	1,	"GL_OP_MAX_EXT"),	# 0x878A
    ("",	X,	1,	"GL_OP_MIN_EXT"),	# 0x878B
    ("",	X,	1,	"GL_OP_SET_GE_EXT"),	# 0x878C
    ("",	X,	1,	"GL_OP_SET_LT_EXT"),	# 0x878D
    ("",	X,	1,	"GL_OP_CLAMP_EXT"),	# 0x878E
    ("",	X,	1,	"GL_OP_FLOOR_EXT"),	# 0x878F
    ("",	X,	1,	"GL_OP_ROUND_EXT"),	# 0x8790
    ("",	X,	1,	"GL_OP_EXP_BASE_2_EXT"),	# 0x8791
    ("",	X,	1,	"GL_OP_LOG_BASE_2_EXT"),	# 0x8792
    ("",	X,	1,	"GL_OP_POWER_EXT"),	# 0x8793
    ("",	X,	1,	"GL_OP_RECIP_EXT"),	# 0x8794
    ("",	X,	1,	"GL_OP_RECIP_SQRT_EXT"),	# 0x8795
    ("",	X,	1,	"GL_OP_SUB_EXT"),	# 0x8796
    ("",	X,	1,	"GL_OP_CROSS_PRODUCT_EXT"),	# 0x8797
    ("",	X,	1,	"GL_OP_MULTIPLY_MATRIX_EXT"),	# 0x8798
    ("",	X,	1,	"GL_OP_MOV_EXT"),	# 0x8799
    ("",	X,	1,	"GL_OUTPUT_VERTEX_EXT"),	# 0x879A
    ("",	X,	1,	"GL_OUTPUT_COLOR0_EXT"),	# 0x879B
    ("",	X,	1,	"GL_OUTPUT_COLOR1_EXT"),	# 0x879C
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD0_EXT"),	# 0x879D
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD1_EXT"),	# 0x879E
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD2_EXT"),	# 0x879F
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD3_EXT"),	# 0x87A0
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD4_EXT"),	# 0x87A1
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD5_EXT"),	# 0x87A2
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD6_EXT"),	# 0x87A3
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD7_EXT"),	# 0x87A4
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD8_EXT"),	# 0x87A5
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD9_EXT"),	# 0x87A6
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD10_EXT"),	# 0x87A7
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD11_EXT"),	# 0x87A8
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD12_EXT"),	# 0x87A9
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD13_EXT"),	# 0x87AA
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD14_EXT"),	# 0x87AB
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD15_EXT"),	# 0x87AC
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD16_EXT"),	# 0x87AD
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD17_EXT"),	# 0x87AE
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD18_EXT"),	# 0x87AF
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD19_EXT"),	# 0x87B0
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD20_EXT"),	# 0x87B1
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD21_EXT"),	# 0x87B2
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD22_EXT"),	# 0x87B3
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD23_EXT"),	# 0x87B4
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD24_EXT"),	# 0x87B5
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD25_EXT"),	# 0x87B6
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD26_EXT"),	# 0x87B7
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD27_EXT"),	# 0x87B8
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD28_EXT"),	# 0x87B9
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD29_EXT"),	# 0x87BA
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD30_EXT"),	# 0x87BB
    ("",	X,	1,	"GL_OUTPUT_TEXTURE_COORD31_EXT"),	# 0x87BC
    ("",	X,	1,	"GL_OUTPUT_FOG_EXT"),	# 0x87BD
    ("",	X,	1,	"GL_SCALAR_EXT"),	# 0x87BE
    ("",	X,	1,	"GL_VECTOR_EXT"),	# 0x87BF
    ("",	X,	1,	"GL_MATRIX_EXT"),	# 0x87C0
    ("",	X,	1,	"GL_VARIANT_EXT"),	# 0x87C1
    ("",	X,	1,	"GL_INVARIANT_EXT"),	# 0x87C2
    ("",	X,	1,	"GL_LOCAL_CONSTANT_EXT"),	# 0x87C3
    ("",	X,	1,	"GL_LOCAL_EXT"),	# 0x87C4
    ("",	X,	1,	"GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT"),	# 0x87C5
    ("",	X,	1,	"GL_MAX_VERTEX_SHADER_VARIANTS_EXT"),	# 0x87C6
    ("",	X,	1,	"GL_MAX_VERTEX_SHADER_INVARIANTS_EXT"),	# 0x87C7
    ("",	X,	1,	"GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT"),	# 0x87C8
    ("",	X,	1,	"GL_MAX_VERTEX_SHADER_LOCALS_EXT"),	# 0x87C9
    ("",	X,	1,	"GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT"),	# 0x87CA
    ("",	X,	1,	"GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT"),	# 0x87CB
    ("",	X,	1,	"GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT"),	# 0x87CC
    ("",	X,	1,	"GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT"),	# 0x87CD
    ("",	X,	1,	"GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT"),	# 0x87CE
    ("",	X,	1,	"GL_VERTEX_SHADER_INSTRUCTIONS_EXT"),	# 0x87CF
    ("",	X,	1,	"GL_VERTEX_SHADER_VARIANTS_EXT"),	# 0x87D0
    ("",	X,	1,	"GL_VERTEX_SHADER_INVARIANTS_EXT"),	# 0x87D1
    ("",	X,	1,	"GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT"),	# 0x87D2
    ("",	X,	1,	"GL_VERTEX_SHADER_LOCALS_EXT"),	# 0x87D3
    ("",	X,	1,	"GL_VERTEX_SHADER_OPTIMIZED_EXT"),	# 0x87D4
    ("",	X,	1,	"GL_X_EXT"),	# 0x87D5
    ("",	X,	1,	"GL_Y_EXT"),	# 0x87D6
    ("",	X,	1,	"GL_Z_EXT"),	# 0x87D7
    ("",	X,	1,	"GL_W_EXT"),	# 0x87D8
    ("",	X,	1,	"GL_NEGATIVE_X_EXT"),	# 0x87D9
    ("",	X,	1,	"GL_NEGATIVE_Y_EXT"),	# 0x87DA
    ("",	X,	1,	"GL_NEGATIVE_Z_EXT"),	# 0x87DB
    ("",	X,	1,	"GL_NEGATIVE_W_EXT"),	# 0x87DC
    ("",	X,	1,	"GL_ZERO_EXT"),	# 0x87DD
    ("",	X,	1,	"GL_ONE_EXT"),	# 0x87DE
    ("",	X,	1,	"GL_NEGATIVE_ONE_EXT"),	# 0x87DF
    ("",	X,	1,	"GL_NORMALIZED_RANGE_EXT"),	# 0x87E0
    ("",	X,	1,	"GL_FULL_RANGE_EXT"),	# 0x87E1
    ("",	X,	1,	"GL_CURRENT_VERTEX_EXT"),	# 0x87E2
    ("",	X,	1,	"GL_MVP_MATRIX_EXT"),	# 0x87E3
    ("",	X,	1,	"GL_VARIANT_VALUE_EXT"),	# 0x87E4
    ("",	X,	1,	"GL_VARIANT_DATATYPE_EXT"),	# 0x87E5
    ("",	X,	1,	"GL_VARIANT_ARRAY_STRIDE_EXT"),	# 0x87E6
    ("glGet",	E,	1,	"GL_VARIANT_ARRAY_TYPE_EXT"),	# 0x87E7
    ("",	X,	1,	"GL_VARIANT_ARRAY_EXT"),	# 0x87E8
    ("",	X,	1,	"GL_VARIANT_ARRAY_POINTER_EXT"),	# 0x87E9
    ("",	X,	1,	"GL_INVARIANT_VALUE_EXT"),	# 0x87EA
    ("",	X,	1,	"GL_INVARIANT_DATATYPE_EXT"),	# 0x87EB
    ("",	X,	1,	"GL_LOCAL_CONSTANT_VALUE_EXT"),	# 0x87EC
    ("",	X,	1,	"GL_LOCAL_CONSTANT_DATATYPE_EXT"),	# 0x87ED
    ("",	X,	1,	"GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD"),	# 0x87EE
    ("",	X,	1,	"GL_PN_TRIANGLES_ATI"),	# 0x87F0
    ("",	X,	1,	"GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI"),	# 0x87F1
    ("",	X,	1,	"GL_PN_TRIANGLES_POINT_MODE_ATI"),	# 0x87F2
    ("",	X,	1,	"GL_PN_TRIANGLES_NORMAL_MODE_ATI"),	# 0x87F3
    ("",	X,	1,	"GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI"),	# 0x87F4
    ("",	X,	1,	"GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI"),	# 0x87F5
    ("",	X,	1,	"GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI"),	# 0x87F6
    ("",	X,	1,	"GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI"),	# 0x87F7
    ("",	X,	1,	"GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI"),	# 0x87F8
    ("",	X,	1,	"GL_3DC_X_AMD"),	# 0x87F9
    ("",	X,	1,	"GL_3DC_XY_AMD"),	# 0x87FA
    ("",	X,	1,	"GL_VBO_FREE_MEMORY_ATI"),	# 0x87FB
    ("",	X,	1,	"GL_TEXTURE_FREE_MEMORY_ATI"),	# 0x87FC
    ("",	X,	1,	"GL_RENDERBUFFER_FREE_MEMORY_ATI"),	# 0x87FD
    ("glGet",	I,	1,	"GL_NUM_PROGRAM_BINARY_FORMATS"),	# 0x87FE
    ("glGet",	E,	"_glGetInteger(GL_NUM_PROGRAM_BINARY_FORMATS)",	"GL_PROGRAM_BINARY_FORMATS"),	# 0x87FF
    ("glGet",	E,	1,	"GL_STENCIL_BACK_FUNC"),	# 0x8800
    ("glGet",	E,	1,	"GL_STENCIL_BACK_FAIL"),	# 0x8801
    ("glGet",	E,	1,	"GL_STENCIL_BACK_PASS_DEPTH_FAIL"),	# 0x8802
    ("glGet",	E,	1,	"GL_STENCIL_BACK_PASS_DEPTH_PASS"),	# 0x8803
    ("_glGet",	B,	1,	"GL_FRAGMENT_PROGRAM_ARB"),	# 0x8804
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_ALU_INSTRUCTIONS_ARB"),	# 0x8805
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_TEX_INSTRUCTIONS_ARB"),	# 0x8806
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_TEX_INDIRECTIONS_ARB"),	# 0x8807
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB"),	# 0x8808
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB"),	# 0x8809
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB"),	# 0x880A
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB"),	# 0x880B
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB"),	# 0x880C
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB"),	# 0x880D
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB"),	# 0x880E
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB"),	# 0x880F
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB"),	# 0x8810
    ("",	X,	1,	"GL_RGBA32F"),	# 0x8814
    ("",	X,	1,	"GL_RGB32F"),	# 0x8815
    ("",	X,	1,	"GL_ALPHA32F_ARB"),	# 0x8816
    ("",	X,	1,	"GL_INTENSITY32F_ARB"),	# 0x8817
    ("",	X,	1,	"GL_LUMINANCE32F_ARB"),	# 0x8818
    ("",	X,	1,	"GL_LUMINANCE_ALPHA32F_ARB"),	# 0x8819
    ("",	X,	1,	"GL_RGBA16F"),	# 0x881A
    ("",	X,	1,	"GL_RGB16F"),	# 0x881B
    ("",	X,	1,	"GL_ALPHA16F_ARB"),	# 0x881C
    ("",	X,	1,	"GL_INTENSITY16F_ARB"),	# 0x881D
    ("",	X,	1,	"GL_LUMINANCE16F_ARB"),	# 0x881E
    ("",	X,	1,	"GL_LUMINANCE_ALPHA16F_ARB"),	# 0x881F
    ("glGet",	B,	1,	"GL_RGBA_FLOAT_MODE_ARB"),	# 0x8820
    ("glGet",	I,	1,	"GL_MAX_DRAW_BUFFERS"),	# 0x8824
    ("glGet",	E,	1,	"GL_DRAW_BUFFER0"),	# 0x8825
    ("glGet",	E,	1,	"GL_DRAW_BUFFER1"),	# 0x8826
    ("glGet",	E,	1,	"GL_DRAW_BUFFER2"),	# 0x8827
    ("glGet",	E,	1,	"GL_DRAW_BUFFER3"),	# 0x8828
    ("glGet",	E,	1,	"GL_DRAW_BUFFER4"),	# 0x8829
    ("glGet",	E,	1,	"GL_DRAW_BUFFER5"),	# 0x882A
    ("glGet",	E,	1,	"GL_DRAW_BUFFER6"),	# 0x882B
    ("glGet",	E,	1,	"GL_DRAW_BUFFER7"),	# 0x882C
    ("glGet",	E,	1,	"GL_DRAW_BUFFER8"),	# 0x882D
    ("glGet",	E,	1,	"GL_DRAW_BUFFER9"),	# 0x882E
    ("glGet",	E,	1,	"GL_DRAW_BUFFER10"),	# 0x882F
    ("glGet",	E,	1,	"GL_DRAW_BUFFER11"),	# 0x8830
    ("glGet",	E,	1,	"GL_DRAW_BUFFER12"),	# 0x8831
    ("glGet",	E,	1,	"GL_DRAW_BUFFER13"),	# 0x8832
    ("glGet",	E,	1,	"GL_DRAW_BUFFER14"),	# 0x8833
    ("glGet",	E,	1,	"GL_DRAW_BUFFER15"),	# 0x8834
    ("",	X,	1,	"GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI"),	# 0x8835
    #("",	X,	1,	"GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI"),	# 0x8837
    ("glGet",	E,	1,	"GL_BLEND_EQUATION_ALPHA"),	# 0x883D
    ("",	X,	1,	"GL_SUBSAMPLE_DISTANCE_AMD"),	# 0x883F
    ("glGet",	B,	1,	"GL_MATRIX_PALETTE_ARB"),	# 0x8840
    ("glGet",	I,	1,	"GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB"),	# 0x8841
    ("glGet",	I,	1,	"GL_MAX_PALETTE_MATRICES_ARB"),	# 0x8842
    ("glGet",	I,	1,	"GL_CURRENT_PALETTE_MATRIX_ARB"),	# 0x8843
    ("glGet",	B,	1,	"GL_MATRIX_INDEX_ARRAY_ARB"),	# 0x8844
    ("glGet",	I,	1,	"GL_CURRENT_MATRIX_INDEX_ARB"),	# 0x8845
    ("glGet",	I,	1,	"GL_MATRIX_INDEX_ARRAY_SIZE_ARB"),	# 0x8846
    ("glGet",	E,	1,	"GL_MATRIX_INDEX_ARRAY_TYPE_ARB"),	# 0x8847
    ("glGet",	I,	1,	"GL_MATRIX_INDEX_ARRAY_STRIDE_ARB"),	# 0x8848
    ("glGet",	P,	1,	"GL_MATRIX_INDEX_ARRAY_POINTER_ARB"),	# 0x8849
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_DEPTH_SIZE"),	# 0x884A
    ("glGetTexParameter",	E,	1,	"GL_DEPTH_TEXTURE_MODE"),	# 0x884B
    ("glGetTexParameter,glGetSamplerParameter",	E,	1,	"GL_TEXTURE_COMPARE_MODE"),	# 0x884C
    ("glGetTexParameter,glGetSamplerParameter",	E,	1,	"GL_TEXTURE_COMPARE_FUNC"),	# 0x884D
    ("",	X,	1,	"GL_COMPARE_REF_TO_TEXTURE"),	# 0x884E
    ("glGet,glGetTexParameter,glGetSamplerParameter",	B,	1,	"GL_TEXTURE_CUBE_MAP_SEAMLESS"),	# 0x884F
    ("",	X,	1,	"GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV"),	# 0x8850
    ("",	X,	1,	"GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV"),	# 0x8851
    ("",	X,	1,	"GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV"),	# 0x8852
    ("",	X,	1,	"GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV"),	# 0x8853
    ("",	X,	1,	"GL_OFFSET_HILO_TEXTURE_2D_NV"),	# 0x8854
    ("",	X,	1,	"GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV"),	# 0x8855
    ("",	X,	1,	"GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV"),	# 0x8856
    ("",	X,	1,	"GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV"),	# 0x8857
    ("",	X,	1,	"GL_DEPENDENT_HILO_TEXTURE_2D_NV"),	# 0x8858
    ("",	X,	1,	"GL_DEPENDENT_RGB_TEXTURE_3D_NV"),	# 0x8859
    ("",	X,	1,	"GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV"),	# 0x885A
    ("",	X,	1,	"GL_DOT_PRODUCT_PASS_THROUGH_NV"),	# 0x885B
    ("",	X,	1,	"GL_DOT_PRODUCT_TEXTURE_1D_NV"),	# 0x885C
    ("",	X,	1,	"GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV"),	# 0x885D
    ("",	X,	1,	"GL_HILO8_NV"),	# 0x885E
    ("",	X,	1,	"GL_SIGNED_HILO8_NV"),	# 0x885F
    ("",	X,	1,	"GL_FORCE_BLUE_TO_ONE_NV"),	# 0x8860
    ("glGet",	B,	1,	"GL_POINT_SPRITE"),	# 0x8861
    ("glGetTexEnv",	B,	1,	"GL_COORD_REPLACE"),	# 0x8862
    ("glGet",	E,	1,	"GL_POINT_SPRITE_R_MODE_NV"),	# 0x8863
    ("glGetQuery",	I,	1,	"GL_QUERY_COUNTER_BITS"),	# 0x8864
    ("glGetQuery",	I,	1,	"GL_CURRENT_QUERY"),	# 0x8865
    ("glGetQueryObject",	I,	1,	"GL_QUERY_RESULT"),	# 0x8866
    ("glGetQueryObject",	B,	1,	"GL_QUERY_RESULT_AVAILABLE"),	# 0x8867
    ("",	X,	1,	"GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV"),	# 0x8868
    ("glGet",	I,	1,	"GL_MAX_VERTEX_ATTRIBS"),	# 0x8869
    ("glGetVertexAttrib",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"),	# 0x886A
    ("glGet",	I,	1,	"GL_MAX_TESS_CONTROL_INPUT_COMPONENTS"),	# 0x886C
    ("glGet",	I,	1,	"GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS"),	# 0x886D
    ("",	X,	1,	"GL_DEPTH_STENCIL_TO_RGBA_NV"),	# 0x886E
    ("",	X,	1,	"GL_DEPTH_STENCIL_TO_BGRA_NV"),	# 0x886F
    ("",	X,	1,	"GL_FRAGMENT_PROGRAM_NV"),	# 0x8870
    ("glGet",	I,	1,	"GL_MAX_TEXTURE_COORDS"),	# 0x8871
    ("glGet",	I,	1,	"GL_MAX_TEXTURE_IMAGE_UNITS"),	# 0x8872
    ("glGet",	I,	1,	"GL_FRAGMENT_PROGRAM_BINDING_NV"),	# 0x8873
    ("glGet",	S,	1,	"GL_PROGRAM_ERROR_STRING_ARB"),	# 0x8874
    ("",	X,	1,	"GL_PROGRAM_FORMAT_ASCII_ARB"),	# 0x8875
    ("glGetProgramARB",	E,	1,	"GL_PROGRAM_FORMAT_ARB"),	# 0x8876
    ("",	X,	1,	"GL_WRITE_PIXEL_DATA_RANGE_NV"),	# 0x8878
    ("",	X,	1,	"GL_READ_PIXEL_DATA_RANGE_NV"),	# 0x8879
    ("",	X,	1,	"GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV"),	# 0x887A
    ("",	X,	1,	"GL_READ_PIXEL_DATA_RANGE_LENGTH_NV"),	# 0x887B
    ("",	X,	1,	"GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV"),	# 0x887C
    ("",	X,	1,	"GL_READ_PIXEL_DATA_RANGE_POINTER_NV"),	# 0x887D
    ("",	X,	1,	"GL_GEOMETRY_SHADER_INVOCATIONS"),	# 0x887F
    ("",	X,	1,	"GL_FLOAT_R_NV"),	# 0x8880
    ("",	X,	1,	"GL_FLOAT_RG_NV"),	# 0x8881
    ("",	X,	1,	"GL_FLOAT_RGB_NV"),	# 0x8882
    ("",	X,	1,	"GL_FLOAT_RGBA_NV"),	# 0x8883
    ("",	X,	1,	"GL_FLOAT_R16_NV"),	# 0x8884
    ("",	X,	1,	"GL_FLOAT_R32_NV"),	# 0x8885
    ("",	X,	1,	"GL_FLOAT_RG16_NV"),	# 0x8886
    ("",	X,	1,	"GL_FLOAT_RG32_NV"),	# 0x8887
    ("",	X,	1,	"GL_FLOAT_RGB16_NV"),	# 0x8888
    ("",	X,	1,	"GL_FLOAT_RGB32_NV"),	# 0x8889
    ("",	X,	1,	"GL_FLOAT_RGBA16_NV"),	# 0x888A
    ("",	X,	1,	"GL_FLOAT_RGBA32_NV"),	# 0x888B
    ("",	X,	1,	"GL_TEXTURE_FLOAT_COMPONENTS_NV"),	# 0x888C
    ("",	X,	1,	"GL_FLOAT_CLEAR_COLOR_VALUE_NV"),	# 0x888D
    ("",	X,	1,	"GL_FLOAT_RGBA_MODE_NV"),	# 0x888E
    ("glGetTexParameter",	E,	1,	"GL_TEXTURE_UNSIGNED_REMAP_MODE_NV"),	# 0x888F
    ("glGet",	B,	1,	"GL_DEPTH_BOUNDS_TEST_EXT"),	# 0x8890
    ("glGet",	F,	2,	"GL_DEPTH_BOUNDS_EXT"),	# 0x8891
    ("",	X,	1,	"GL_ARRAY_BUFFER"),	# 0x8892
    ("",	X,	1,	"GL_ELEMENT_ARRAY_BUFFER"),	# 0x8893
    ("glGet",	I,	1,	"GL_ARRAY_BUFFER_BINDING"),	# 0x8894
    ("glGet",	I,	1,	"GL_ELEMENT_ARRAY_BUFFER_BINDING"),	# 0x8895
    ("glGet",	I,	1,	"GL_VERTEX_ARRAY_BUFFER_BINDING"),	# 0x8896
    ("glGet",	I,	1,	"GL_NORMAL_ARRAY_BUFFER_BINDING"),	# 0x8897
    ("glGet",	I,	1,	"GL_COLOR_ARRAY_BUFFER_BINDING"),	# 0x8898
    ("glGet",	I,	1,	"GL_INDEX_ARRAY_BUFFER_BINDING"),	# 0x8899
    ("glGet",	I,	1,	"GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING"),	# 0x889A
    ("glGet",	I,	1,	"GL_EDGE_FLAG_ARRAY_BUFFER_BINDING"),	# 0x889B
    ("glGet",	I,	1,	"GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING"),	# 0x889C
    ("glGet",	I,	1,	"GL_FOG_COORD_ARRAY_BUFFER_BINDING"),	# 0x889D
    ("glGet",	I,	1,	"GL_WEIGHT_ARRAY_BUFFER_BINDING"),	# 0x889E
    ("glGetVertexAttrib",	I,	1,	"GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"),	# 0x889F
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_INSTRUCTIONS_ARB"),	# 0x88A0
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_INSTRUCTIONS_ARB"),	# 0x88A1
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB"),	# 0x88A2
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB"),	# 0x88A3
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_TEMPORARIES_ARB"),	# 0x88A4
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_TEMPORARIES_ARB"),	# 0x88A5
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_NATIVE_TEMPORARIES_ARB"),	# 0x88A6
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB"),	# 0x88A7
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_PARAMETERS_ARB"),	# 0x88A8
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_PARAMETERS_ARB"),	# 0x88A9
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_NATIVE_PARAMETERS_ARB"),	# 0x88AA
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB"),	# 0x88AB
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_ATTRIBS_ARB"),	# 0x88AC
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_ATTRIBS_ARB"),	# 0x88AD
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_NATIVE_ATTRIBS_ARB"),	# 0x88AE
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB"),	# 0x88AF
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_ADDRESS_REGISTERS_ARB"),	# 0x88B0
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB"),	# 0x88B1
    ("glGetProgramARB",	I,	1,	"GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB"),	# 0x88B2
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB"),	# 0x88B3
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB"),	# 0x88B4
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_ENV_PARAMETERS_ARB"),	# 0x88B5
    ("glGetProgramARB",	B,	1,	"GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB"),	# 0x88B6
    ("glGet",	F,	16,	"GL_TRANSPOSE_CURRENT_MATRIX_ARB"),	# 0x88B7
    ("",	X,	1,	"GL_READ_ONLY"),	# 0x88B8
    ("",	X,	1,	"GL_WRITE_ONLY"),	# 0x88B9
    ("",	X,	1,	"GL_READ_WRITE"),	# 0x88BA
    ("glGetBufferParameter",	E,	1,	"GL_BUFFER_ACCESS"),	# 0x88BB
    ("glGetBufferParameter",	B,	1,	"GL_BUFFER_MAPPED"),	# 0x88BC
    ("glGetBufferParameter",	P,	1,	"GL_BUFFER_MAP_POINTER"),	# 0x88BD
    ("",	X,	1,	"GL_WRITE_DISCARD_NV"),	# 0x88BE
    ("",	X,	1,	"GL_TIME_ELAPSED"),	# 0x88BF
    ("",	X,	1,	"GL_MATRIX0_ARB"),	# 0x88C0
    ("",	X,	1,	"GL_MATRIX1_ARB"),	# 0x88C1
    ("",	X,	1,	"GL_MATRIX2_ARB"),	# 0x88C2
    ("",	X,	1,	"GL_MATRIX3_ARB"),	# 0x88C3
    ("",	X,	1,	"GL_MATRIX4_ARB"),	# 0x88C4
    ("",	X,	1,	"GL_MATRIX5_ARB"),	# 0x88C5
    ("",	X,	1,	"GL_MATRIX6_ARB"),	# 0x88C6
    ("",	X,	1,	"GL_MATRIX7_ARB"),	# 0x88C7
    ("",	X,	1,	"GL_MATRIX8_ARB"),	# 0x88C8
    ("",	X,	1,	"GL_MATRIX9_ARB"),	# 0x88C9
    ("",	X,	1,	"GL_MATRIX10_ARB"),	# 0x88CA
    ("",	X,	1,	"GL_MATRIX11_ARB"),	# 0x88CB
    ("",	X,	1,	"GL_MATRIX12_ARB"),	# 0x88CC
    ("",	X,	1,	"GL_MATRIX13_ARB"),	# 0x88CD
    ("",	X,	1,	"GL_MATRIX14_ARB"),	# 0x88CE
    ("",	X,	1,	"GL_MATRIX15_ARB"),	# 0x88CF
    ("",	X,	1,	"GL_MATRIX16_ARB"),	# 0x88D0
    ("",	X,	1,	"GL_MATRIX17_ARB"),	# 0x88D1
    ("",	X,	1,	"GL_MATRIX18_ARB"),	# 0x88D2
    ("",	X,	1,	"GL_MATRIX19_ARB"),	# 0x88D3
    ("",	X,	1,	"GL_MATRIX20_ARB"),	# 0x88D4
    ("",	X,	1,	"GL_MATRIX21_ARB"),	# 0x88D5
    ("",	X,	1,	"GL_MATRIX22_ARB"),	# 0x88D6
    ("",	X,	1,	"GL_MATRIX23_ARB"),	# 0x88D7
    ("",	X,	1,	"GL_MATRIX24_ARB"),	# 0x88D8
    ("",	X,	1,	"GL_MATRIX25_ARB"),	# 0x88D9
    ("",	X,	1,	"GL_MATRIX26_ARB"),	# 0x88DA
    ("",	X,	1,	"GL_MATRIX27_ARB"),	# 0x88DB
    ("",	X,	1,	"GL_MATRIX28_ARB"),	# 0x88DC
    ("",	X,	1,	"GL_MATRIX29_ARB"),	# 0x88DD
    ("",	X,	1,	"GL_MATRIX30_ARB"),	# 0x88DE
    ("",	X,	1,	"GL_MATRIX31_ARB"),	# 0x88DF
    ("",	X,	1,	"GL_STREAM_DRAW"),	# 0x88E0
    ("",	X,	1,	"GL_STREAM_READ"),	# 0x88E1
    ("",	X,	1,	"GL_STREAM_COPY"),	# 0x88E2
    ("",	X,	1,	"GL_STATIC_DRAW"),	# 0x88E4
    ("",	X,	1,	"GL_STATIC_READ"),	# 0x88E5
    ("",	X,	1,	"GL_STATIC_COPY"),	# 0x88E6
    ("",	X,	1,	"GL_DYNAMIC_DRAW"),	# 0x88E8
    ("",	X,	1,	"GL_DYNAMIC_READ"),	# 0x88E9
    ("",	X,	1,	"GL_DYNAMIC_COPY"),	# 0x88EA
    ("",	X,	1,	"GL_PIXEL_PACK_BUFFER"),	# 0x88EB
    ("",	X,	1,	"GL_PIXEL_UNPACK_BUFFER"),	# 0x88EC
    ("glGet",	I,	1,	"GL_PIXEL_PACK_BUFFER_BINDING"),	# 0x88ED
    ("",	X,	1,	"GL_ETC1_SRGB8_NV"),	# 0x88EE
    ("glGet",	I,	1,	"GL_PIXEL_UNPACK_BUFFER_BINDING"),	# 0x88EF
    ("",	X,	1,	"GL_DEPTH24_STENCIL8"),	# 0x88F0
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_STENCIL_SIZE"),	# 0x88F1
    ("",	X,	1,	"GL_STENCIL_TAG_BITS_EXT"),	# 0x88F2
    ("",	X,	1,	"GL_STENCIL_CLEAR_TAG_VALUE_EXT"),	# 0x88F3
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV"),	# 0x88F4
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_CALL_DEPTH_NV"),	# 0x88F5
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_IF_DEPTH_NV"),	# 0x88F6
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_LOOP_DEPTH_NV"),	# 0x88F7
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_LOOP_COUNT_NV"),	# 0x88F8
    ("",	X,	1,	"GL_SRC1_COLOR"),	# 0x88F9
    ("",	X,	1,	"GL_ONE_MINUS_SRC1_COLOR"),	# 0x88FA
    ("",	X,	1,	"GL_ONE_MINUS_SRC1_ALPHA"),	# 0x88FB
    ("glGet",	I,	1,	"GL_MAX_DUAL_SOURCE_DRAW_BUFFERS"),	# 0x88FC
    ("glGetVertexAttrib",	B,	1,	"GL_VERTEX_ATTRIB_ARRAY_INTEGER"),	# 0x88FD
    ("glGetVertexAttrib",	I,	1,	"GL_VERTEX_ATTRIB_ARRAY_DIVISOR"),	# 0x88FE
    ("glGet",	I,	1,	"GL_MAX_ARRAY_TEXTURE_LAYERS"),	# 0x88FF
    ("glGet",	F,	1,	"GL_MIN_PROGRAM_TEXEL_OFFSET"),	# 0x8904
    ("glGet",	F,	1,	"GL_MAX_PROGRAM_TEXEL_OFFSET"),	# 0x8905
    ("",	X,	1,	"GL_PROGRAM_ATTRIB_COMPONENTS_NV"),	# 0x8906
    ("",	X,	1,	"GL_PROGRAM_RESULT_COMPONENTS_NV"),	# 0x8907
    ("",	X,	1,	"GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV"),	# 0x8908
    ("",	X,	1,	"GL_MAX_PROGRAM_RESULT_COMPONENTS_NV"),	# 0x8909
    ("glGet",	B,	1,	"GL_STENCIL_TEST_TWO_SIDE_EXT"),	# 0x8910
    ("glGet",	E,	1,	"GL_ACTIVE_STENCIL_FACE_EXT"),	# 0x8911
    ("",	X,	1,	"GL_MIRROR_CLAMP_TO_BORDER_EXT"),	# 0x8912
    ("",	X,	1,	"GL_SAMPLES_PASSED"),	# 0x8914
    ("",	X,	1,	"GL_GEOMETRY_VERTICES_OUT"),	# 0x8916
    ("",	X,	1,	"GL_GEOMETRY_INPUT_TYPE"),	# 0x8917
    ("",	X,	1,	"GL_GEOMETRY_OUTPUT_TYPE"),	# 0x8918
    ("_glGet",	I,	1,	"GL_SAMPLER_BINDING"),	# 0x8919
    ("glGet",	B,	1,	"GL_CLAMP_VERTEX_COLOR"),	# 0x891A
    ("glGet",	B,	1,	"GL_CLAMP_FRAGMENT_COLOR"),	# 0x891B
    ("glGet",	B,	1,	"GL_CLAMP_READ_COLOR"),	# 0x891C
    ("",	X,	1,	"GL_FIXED_ONLY"),	# 0x891D
    ("",	X,	1,	"GL_TESS_CONTROL_PROGRAM_NV"),	# 0x891E
    ("",	X,	1,	"GL_TESS_EVALUATION_PROGRAM_NV"),	# 0x891F
    ("",	X,	1,	"GL_FRAGMENT_SHADER_ATI"),	# 0x8920
    ("",	X,	1,	"GL_REG_0_ATI"),	# 0x8921
    ("",	X,	1,	"GL_REG_1_ATI"),	# 0x8922
    ("",	X,	1,	"GL_REG_2_ATI"),	# 0x8923
    ("",	X,	1,	"GL_REG_3_ATI"),	# 0x8924
    ("",	X,	1,	"GL_REG_4_ATI"),	# 0x8925
    ("",	X,	1,	"GL_REG_5_ATI"),	# 0x8926
    ("",	X,	1,	"GL_REG_6_ATI"),	# 0x8927
    ("",	X,	1,	"GL_REG_7_ATI"),	# 0x8928
    ("",	X,	1,	"GL_REG_8_ATI"),	# 0x8929
    ("",	X,	1,	"GL_REG_9_ATI"),	# 0x892A
    ("",	X,	1,	"GL_REG_10_ATI"),	# 0x892B
    ("",	X,	1,	"GL_REG_11_ATI"),	# 0x892C
    ("",	X,	1,	"GL_REG_12_ATI"),	# 0x892D
    ("",	X,	1,	"GL_REG_13_ATI"),	# 0x892E
    ("",	X,	1,	"GL_REG_14_ATI"),	# 0x892F
    ("",	X,	1,	"GL_REG_15_ATI"),	# 0x8930
    ("",	X,	1,	"GL_REG_16_ATI"),	# 0x8931
    ("",	X,	1,	"GL_REG_17_ATI"),	# 0x8932
    ("",	X,	1,	"GL_REG_18_ATI"),	# 0x8933
    ("",	X,	1,	"GL_REG_19_ATI"),	# 0x8934
    ("",	X,	1,	"GL_REG_20_ATI"),	# 0x8935
    ("",	X,	1,	"GL_REG_21_ATI"),	# 0x8936
    ("",	X,	1,	"GL_REG_22_ATI"),	# 0x8937
    ("",	X,	1,	"GL_REG_23_ATI"),	# 0x8938
    ("",	X,	1,	"GL_REG_24_ATI"),	# 0x8939
    ("",	X,	1,	"GL_REG_25_ATI"),	# 0x893A
    ("",	X,	1,	"GL_REG_26_ATI"),	# 0x893B
    ("",	X,	1,	"GL_REG_27_ATI"),	# 0x893C
    ("",	X,	1,	"GL_REG_28_ATI"),	# 0x893D
    ("",	X,	1,	"GL_REG_29_ATI"),	# 0x893E
    ("",	X,	1,	"GL_REG_30_ATI"),	# 0x893F
    ("",	X,	1,	"GL_REG_31_ATI"),	# 0x8940
    ("",	X,	1,	"GL_CON_0_ATI"),	# 0x8941
    ("",	X,	1,	"GL_CON_1_ATI"),	# 0x8942
    ("",	X,	1,	"GL_CON_2_ATI"),	# 0x8943
    ("",	X,	1,	"GL_CON_3_ATI"),	# 0x8944
    ("",	X,	1,	"GL_CON_4_ATI"),	# 0x8945
    ("",	X,	1,	"GL_CON_5_ATI"),	# 0x8946
    ("",	X,	1,	"GL_CON_6_ATI"),	# 0x8947
    ("",	X,	1,	"GL_CON_7_ATI"),	# 0x8948
    ("",	X,	1,	"GL_CON_8_ATI"),	# 0x8949
    ("",	X,	1,	"GL_CON_9_ATI"),	# 0x894A
    ("",	X,	1,	"GL_CON_10_ATI"),	# 0x894B
    ("",	X,	1,	"GL_CON_11_ATI"),	# 0x894C
    ("",	X,	1,	"GL_CON_12_ATI"),	# 0x894D
    ("",	X,	1,	"GL_CON_13_ATI"),	# 0x894E
    ("",	X,	1,	"GL_CON_14_ATI"),	# 0x894F
    ("",	X,	1,	"GL_CON_15_ATI"),	# 0x8950
    ("",	X,	1,	"GL_CON_16_ATI"),	# 0x8951
    ("",	X,	1,	"GL_CON_17_ATI"),	# 0x8952
    ("",	X,	1,	"GL_CON_18_ATI"),	# 0x8953
    ("",	X,	1,	"GL_CON_19_ATI"),	# 0x8954
    ("",	X,	1,	"GL_CON_20_ATI"),	# 0x8955
    ("",	X,	1,	"GL_CON_21_ATI"),	# 0x8956
    ("",	X,	1,	"GL_CON_22_ATI"),	# 0x8957
    ("",	X,	1,	"GL_CON_23_ATI"),	# 0x8958
    ("",	X,	1,	"GL_CON_24_ATI"),	# 0x8959
    ("",	X,	1,	"GL_CON_25_ATI"),	# 0x895A
    ("",	X,	1,	"GL_CON_26_ATI"),	# 0x895B
    ("",	X,	1,	"GL_CON_27_ATI"),	# 0x895C
    ("",	X,	1,	"GL_CON_28_ATI"),	# 0x895D
    ("",	X,	1,	"GL_CON_29_ATI"),	# 0x895E
    ("",	X,	1,	"GL_CON_30_ATI"),	# 0x895F
    ("",	X,	1,	"GL_CON_31_ATI"),	# 0x8960
    ("",	X,	1,	"GL_MOV_ATI"),	# 0x8961
    ("",	X,	1,	"GL_ADD_ATI"),	# 0x8963
    ("",	X,	1,	"GL_MUL_ATI"),	# 0x8964
    ("",	X,	1,	"GL_SUB_ATI"),	# 0x8965
    ("",	X,	1,	"GL_DOT3_ATI"),	# 0x8966
    ("",	X,	1,	"GL_DOT4_ATI"),	# 0x8967
    ("",	X,	1,	"GL_MAD_ATI"),	# 0x8968
    ("",	X,	1,	"GL_LERP_ATI"),	# 0x8969
    ("",	X,	1,	"GL_CND_ATI"),	# 0x896A
    ("",	X,	1,	"GL_CND0_ATI"),	# 0x896B
    ("",	X,	1,	"GL_DOT2_ADD_ATI"),	# 0x896C
    ("",	X,	1,	"GL_SECONDARY_INTERPOLATOR_ATI"),	# 0x896D
    ("",	X,	1,	"GL_NUM_FRAGMENT_REGISTERS_ATI"),	# 0x896E
    ("",	X,	1,	"GL_NUM_FRAGMENT_CONSTANTS_ATI"),	# 0x896F
    ("",	X,	1,	"GL_NUM_PASSES_ATI"),	# 0x8970
    ("",	X,	1,	"GL_NUM_INSTRUCTIONS_PER_PASS_ATI"),	# 0x8971
    ("",	X,	1,	"GL_NUM_INSTRUCTIONS_TOTAL_ATI"),	# 0x8972
    ("",	X,	1,	"GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI"),	# 0x8973
    ("",	X,	1,	"GL_NUM_LOOPBACK_COMPONENTS_ATI"),	# 0x8974
    ("",	X,	1,	"GL_COLOR_ALPHA_PAIRING_ATI"),	# 0x8975
    ("",	X,	1,	"GL_SWIZZLE_STR_ATI"),	# 0x8976
    ("",	X,	1,	"GL_SWIZZLE_STQ_ATI"),	# 0x8977
    ("",	X,	1,	"GL_SWIZZLE_STR_DR_ATI"),	# 0x8978
    ("",	X,	1,	"GL_SWIZZLE_STQ_DQ_ATI"),	# 0x8979
    ("",	X,	1,	"GL_SWIZZLE_STRQ_ATI"),	# 0x897A
    ("",	X,	1,	"GL_SWIZZLE_STRQ_DQ_ATI"),	# 0x897B
    ("",	X,	1,	"GL_INTERLACE_OML"),	# 0x8980
    ("",	X,	1,	"GL_INTERLACE_READ_OML"),	# 0x8981
    ("",	X,	1,	"GL_FORMAT_SUBSAMPLE_24_24_OML"),	# 0x8982
    ("",	X,	1,	"GL_FORMAT_SUBSAMPLE_244_244_OML"),	# 0x8983
    ("",	X,	1,	"GL_PACK_RESAMPLE_OML"),	# 0x8984
    ("",	X,	1,	"GL_UNPACK_RESAMPLE_OML"),	# 0x8985
    ("",	X,	1,	"GL_RESAMPLE_REPLICATE_OML"),	# 0x8986
    ("",	X,	1,	"GL_RESAMPLE_ZERO_FILL_OML"),	# 0x8987
    ("",	X,	1,	"GL_RESAMPLE_AVERAGE_OML"),	# 0x8988
    ("",	X,	1,	"GL_RESAMPLE_DECIMATE_OML"),	# 0x8989
    ("",	X,	1,	"GL_POINT_SIZE_ARRAY_TYPE_OES"),	# 0x898A
    ("",	X,	1,	"GL_POINT_SIZE_ARRAY_STRIDE_OES"),	# 0x898B
    ("",	X,	1,	"GL_POINT_SIZE_ARRAY_POINTER_OES"),	# 0x898C
    ("",	X,	1,	"GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES"),	# 0x898D
    ("",	X,	1,	"GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES"),	# 0x898E
    ("",	X,	1,	"GL_TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES"),	# 0x898F
    ("",	X,	1,	"GL_VERTEX_ATTRIB_MAP1_APPLE"),	# 0x8A00
    ("",	X,	1,	"GL_VERTEX_ATTRIB_MAP2_APPLE"),	# 0x8A01
    ("",	X,	1,	"GL_VERTEX_ATTRIB_MAP1_SIZE_APPLE"),	# 0x8A02
    ("",	X,	1,	"GL_VERTEX_ATTRIB_MAP1_COEFF_APPLE"),	# 0x8A03
    ("",	X,	1,	"GL_VERTEX_ATTRIB_MAP1_ORDER_APPLE"),	# 0x8A04
    ("",	X,	1,	"GL_VERTEX_ATTRIB_MAP1_DOMAIN_APPLE"),	# 0x8A05
    ("",	X,	1,	"GL_VERTEX_ATTRIB_MAP2_SIZE_APPLE"),	# 0x8A06
    ("",	X,	1,	"GL_VERTEX_ATTRIB_MAP2_COEFF_APPLE"),	# 0x8A07
    ("",	X,	1,	"GL_VERTEX_ATTRIB_MAP2_ORDER_APPLE"),	# 0x8A08
    ("",	X,	1,	"GL_VERTEX_ATTRIB_MAP2_DOMAIN_APPLE"),	# 0x8A09
    ("",	X,	1,	"GL_DRAW_PIXELS_APPLE"),	# 0x8A0A
    ("",	X,	1,	"GL_FENCE_APPLE"),	# 0x8A0B
    ("",	X,	1,	"GL_ELEMENT_ARRAY_APPLE"),	# 0x8A0C
    ("glGet",	E,	1,	"GL_ELEMENT_ARRAY_TYPE_APPLE"),	# 0x8A0D
    ("",	X,	1,	"GL_ELEMENT_ARRAY_POINTER_APPLE"),	# 0x8A0E
    ("",	X,	1,	"GL_COLOR_FLOAT_APPLE"),	# 0x8A0F
    ("",	X,	1,	"GL_UNIFORM_BUFFER"),	# 0x8A11
    ("",	X,	1,	"GL_BUFFER_SERIALIZED_MODIFY_APPLE"),	# 0x8A12
    ("",	X,	1,	"GL_BUFFER_FLUSHING_UNMAP_APPLE"),	# 0x8A13
    ("",	X,	1,	"GL_AUX_DEPTH_STENCIL_APPLE"),	# 0x8A14
    ("",	X,	1,	"GL_PACK_ROW_BYTES_APPLE"),	# 0x8A15
    ("",	X,	1,	"GL_UNPACK_ROW_BYTES_APPLE"),	# 0x8A16
    ("",	X,	1,	"GL_RELEASED_APPLE"),	# 0x8A19
    ("",	X,	1,	"GL_VOLATILE_APPLE"),	# 0x8A1A
    ("",	X,	1,	"GL_RETAINED_APPLE"),	# 0x8A1B
    ("",	X,	1,	"GL_UNDEFINED_APPLE"),	# 0x8A1C
    ("",	X,	1,	"GL_PURGEABLE_APPLE"),	# 0x8A1D
    ("",	X,	1,	"GL_RGB_422_APPLE"),	# 0x8A1F
    ("glGet",	I,	1,	"GL_UNIFORM_BUFFER_BINDING"),	# 0x8A28
    ("glGet",	I,	1,	"GL_UNIFORM_BUFFER_START"),	# 0x8A29
    ("glGet",	I,	1,	"GL_UNIFORM_BUFFER_SIZE"),	# 0x8A2A
    ("glGet",	I,	1,	"GL_MAX_VERTEX_UNIFORM_BLOCKS"),	# 0x8A2B
    ("glGet",	I,	1,	"GL_MAX_GEOMETRY_UNIFORM_BLOCKS"),	# 0x8A2C
    ("glGet",	I,	1,	"GL_MAX_FRAGMENT_UNIFORM_BLOCKS"),	# 0x8A2D
    ("glGet",	I,	1,	"GL_MAX_COMBINED_UNIFORM_BLOCKS"),	# 0x8A2E
    ("glGet",	I,	1,	"GL_MAX_UNIFORM_BUFFER_BINDINGS"),	# 0x8A2F
    ("glGet",	I,	1,	"GL_MAX_UNIFORM_BLOCK_SIZE"),	# 0x8A30
    ("glGet",	I,	1,	"GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"),	# 0x8A31
    ("glGet",	I,	1,	"GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS"),	# 0x8A32
    ("glGet",	I,	1,	"GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"),	# 0x8A33
    ("glGet",	I,	1,	"GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT"),	# 0x8A34
    ("glGetProgram",	I,	1,	"GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH"),	# 0x8A35
    ("glGetProgram",	I,	1,	"GL_ACTIVE_UNIFORM_BLOCKS"),	# 0x8A36
    ("glGetActiveUniforms",	E,	1,	"GL_UNIFORM_TYPE"),	# 0x8A37
    ("glGetActiveUniforms",	I,	1,	"GL_UNIFORM_SIZE"),	# 0x8A38
    ("glGetActiveUniforms",	I,	1,	"GL_UNIFORM_NAME_LENGTH"),	# 0x8A39
    ("glGetActiveUniforms",	I,	1,	"GL_UNIFORM_BLOCK_INDEX"),	# 0x8A3A
    ("glGetActiveUniforms",	I,	1,	"GL_UNIFORM_OFFSET"),	# 0x8A3B
    ("glGetActiveUniforms",	I,	1,	"GL_UNIFORM_ARRAY_STRIDE"),	# 0x8A3C
    ("glGetActiveUniforms",	I,	1,	"GL_UNIFORM_MATRIX_STRIDE"),	# 0x8A3D
    ("glGetActiveUniforms",	B,	1,	"GL_UNIFORM_IS_ROW_MAJOR"),	# 0x8A3E
    ("glGetActiveUniformBlock",	I,	1,	"GL_UNIFORM_BLOCK_BINDING"),	# 0x8A3F
    ("glGetActiveUniformBlock",	I,	1,	"GL_UNIFORM_BLOCK_DATA_SIZE"),	# 0x8A40
    ("glGetActiveUniformBlock",	I,	1,	"GL_UNIFORM_BLOCK_NAME_LENGTH"),	# 0x8A41
    ("glGetActiveUniformBlock",	I,	1,	"GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS"),	# 0x8A42
    ("glGetActiveUniformBlock",	I,	1,	"GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"),	# 0x8A43
    ("glGetActiveUniformBlock",	B,	1,	"GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"),	# 0x8A44
    ("glGetActiveUniformBlock",	B,	1,	"GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER"),	# 0x8A45
    ("glGetActiveUniformBlock",	B,	1,	"GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"),	# 0x8A46
    ("glGetTexParameter",	E,	1,	"GL_TEXTURE_SRGB_DECODE_EXT"),	# 0x8A48
    ("",	X,	1,	"GL_DECODE_EXT"),	# 0x8A49
    ("",	X,	1,	"GL_SKIP_DECODE_EXT"),	# 0x8A4A
    ("",	X,	1,	"GL_PROGRAM_PIPELINE_OBJECT_EXT"),	# 0x8A4F
    ("",	X,	1,	"GL_RGB_RAW_422_APPLE"),	# 0x8A51
    ("",	X,	1,	"GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT"),	# 0x8A52
    ("",	X,	1,	"GL_SYNC_OBJECT_APPLE"),	# 0x8A53
    ("",	X,	1,	"GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT"),	# 0x8A54
    ("",	X,	1,	"GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT"),	# 0x8A55
    ("",	X,	1,	"GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT"),	# 0x8A56
    ("",	X,	1,	"GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT"),	# 0x8A57
    ("glGetProgramPipeline",	I,	1,	"GL_FRAGMENT_SHADER"),	# 0x8B30
    ("glGetProgramPipeline",	I,	1,	"GL_VERTEX_SHADER"),	# 0x8B31
    ("",	H,	1,	"GL_PROGRAM_OBJECT_ARB"),	# 0x8B40
    ("",	X,	1,	"GL_SHADER_OBJECT_ARB"),	# 0x8B48
    ("glGet",	I,	1,	"GL_MAX_FRAGMENT_UNIFORM_COMPONENTS"),	# 0x8B49
    ("glGet",	I,	1,	"GL_MAX_VERTEX_UNIFORM_COMPONENTS"),	# 0x8B4A
    ("glGet",	I,	1,	"GL_MAX_VARYING_COMPONENTS"),	# 0x8B4B
    ("glGet",	I,	1,	"GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS"),	# 0x8B4C
    ("glGet",	I,	1,	"GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS"),	# 0x8B4D
    ("",	E,	1,	"GL_OBJECT_TYPE_ARB"),	# 0x8B4E
    ("glGetShader",	E,	1,	"GL_SHADER_TYPE"),	# 0x8B4F
    ("",	X,	1,	"GL_FLOAT_VEC2"),	# 0x8B50
    ("",	X,	1,	"GL_FLOAT_VEC3"),	# 0x8B51
    ("",	X,	1,	"GL_FLOAT_VEC4"),	# 0x8B52
    ("",	X,	1,	"GL_INT_VEC2"),	# 0x8B53
    ("",	X,	1,	"GL_INT_VEC3"),	# 0x8B54
    ("",	X,	1,	"GL_INT_VEC4"),	# 0x8B55
    ("",	X,	1,	"GL_BOOL"),	# 0x8B56
    ("",	X,	1,	"GL_BOOL_VEC2"),	# 0x8B57
    ("",	X,	1,	"GL_BOOL_VEC3"),	# 0x8B58
    ("",	X,	1,	"GL_BOOL_VEC4"),	# 0x8B59
    ("",	X,	1,	"GL_FLOAT_MAT2"),	# 0x8B5A
    ("",	X,	1,	"GL_FLOAT_MAT3"),	# 0x8B5B
    ("",	X,	1,	"GL_FLOAT_MAT4"),	# 0x8B5C
    ("",	X,	1,	"GL_SAMPLER_1D"),	# 0x8B5D
    ("",	X,	1,	"GL_SAMPLER_2D"),	# 0x8B5E
    ("",	X,	1,	"GL_SAMPLER_3D"),	# 0x8B5F
    ("",	X,	1,	"GL_SAMPLER_CUBE"),	# 0x8B60
    ("",	X,	1,	"GL_SAMPLER_1D_SHADOW"),	# 0x8B61
    ("",	X,	1,	"GL_SAMPLER_2D_SHADOW"),	# 0x8B62
    ("",	X,	1,	"GL_SAMPLER_2D_RECT"),	# 0x8B63
    ("",	X,	1,	"GL_SAMPLER_2D_RECT_SHADOW"),	# 0x8B64
    ("",	X,	1,	"GL_FLOAT_MAT2x3"),	# 0x8B65
    ("",	X,	1,	"GL_FLOAT_MAT2x4"),	# 0x8B66
    ("",	X,	1,	"GL_FLOAT_MAT3x2"),	# 0x8B67
    ("",	X,	1,	"GL_FLOAT_MAT3x4"),	# 0x8B68
    ("",	X,	1,	"GL_FLOAT_MAT4x2"),	# 0x8B69
    ("",	X,	1,	"GL_FLOAT_MAT4x3"),	# 0x8B6A
    ("glGetShader,glGetProgram",	B,	1,	"GL_DELETE_STATUS"),	# 0x8B80
    ("glGetShader,glGetProgram",	B,	1,	"GL_COMPILE_STATUS"),	# 0x8B81
    ("glGetShader,glGetProgram",	B,	1,	"GL_LINK_STATUS"),	# 0x8B82
    ("glGetShader,glGetProgram",	B,	1,	"GL_VALIDATE_STATUS"),	# 0x8B83
    ("glGetShader,glGetProgram",	I,	1,	"GL_INFO_LOG_LENGTH"),	# 0x8B84
    ("glGetProgram",	I,	1,	"GL_ATTACHED_SHADERS"),	# 0x8B85
    ("glGetProgram",	I,	1,	"GL_ACTIVE_UNIFORMS"),	# 0x8B86
    ("glGetProgram",	I,	1,	"GL_ACTIVE_UNIFORM_MAX_LENGTH"),	# 0x8B87
    ("glGetShader",	I,	1,	"GL_SHADER_SOURCE_LENGTH"),	# 0x8B88
    ("glGetProgram",	I,	1,	"GL_ACTIVE_ATTRIBUTES"),	# 0x8B89
    ("glGetProgram",	I,	1,	"GL_ACTIVE_ATTRIBUTE_MAX_LENGTH"),	# 0x8B8A
    ("",	X,	1,	"GL_FRAGMENT_SHADER_DERIVATIVE_HINT"),	# 0x8B8B
    ("glGet",	S,	1,	"GL_SHADING_LANGUAGE_VERSION"),	# 0x8B8C
    ("glGet",	I,	1,	"GL_CURRENT_PROGRAM"),	# 0x8B8D
    ("",	X,	1,	"GL_PALETTE4_RGB8_OES"),	# 0x8B90
    ("",	X,	1,	"GL_PALETTE4_RGBA8_OES"),	# 0x8B91
    ("",	X,	1,	"GL_PALETTE4_R5_G6_B5_OES"),	# 0x8B92
    ("",	X,	1,	"GL_PALETTE4_RGBA4_OES"),	# 0x8B93
    ("",	X,	1,	"GL_PALETTE4_RGB5_A1_OES"),	# 0x8B94
    ("",	X,	1,	"GL_PALETTE8_RGB8_OES"),	# 0x8B95
    ("",	X,	1,	"GL_PALETTE8_RGBA8_OES"),	# 0x8B96
    ("",	X,	1,	"GL_PALETTE8_R5_G6_B5_OES"),	# 0x8B97
    ("",	X,	1,	"GL_PALETTE8_RGBA4_OES"),	# 0x8B98
    ("",	X,	1,	"GL_PALETTE8_RGB5_A1_OES"),	# 0x8B99
    ("glGet",	E,	1,	"GL_IMPLEMENTATION_COLOR_READ_TYPE"),	# 0x8B9A
    ("glGet",	E,	1,	"GL_IMPLEMENTATION_COLOR_READ_FORMAT"),	# 0x8B9B
    ("",	X,	1,	"GL_POINT_SIZE_ARRAY_OES"),	# 0x8B9C
    ("glGetTexParameter",	I,	4,	"GL_TEXTURE_CROP_RECT_OES"),	# 0x8B9D
    ("",	X,	1,	"GL_MATRIX_INDEX_ARRAY_BUFFER_BINDING_OES"),	# 0x8B9E
    ("",	X,	1,	"GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES"),	# 0x8B9F
    #("",	X,	1,	"GL_FRAGMENT_PROGRAM_POSITION_MESA"),	# 0x8BB0
    #("",	X,	1,	"GL_FRAGMENT_PROGRAM_CALLBACK_MESA"),	# 0x8BB1
    #("",	X,	1,	"GL_FRAGMENT_PROGRAM_CALLBACK_FUNC_MESA"),	# 0x8BB2
    #("",	X,	1,	"GL_FRAGMENT_PROGRAM_CALLBACK_DATA_MESA"),	# 0x8BB3
    #("",	X,	1,	"GL_VERTEX_PROGRAM_CALLBACK_MESA"),	# 0x8BB4
    #("",	X,	1,	"GL_VERTEX_PROGRAM_POSITION_MESA"),	# 0x8BB4
    #("",	X,	1,	"GL_VERTEX_PROGRAM_CALLBACK_FUNC_MESA"),	# 0x8BB6
    #("",	X,	1,	"GL_VERTEX_PROGRAM_CALLBACK_DATA_MESA"),	# 0x8BB7
    ("",	X,	1,	"GL_COUNTER_TYPE_AMD"),	# 0x8BC0
    ("",	X,	1,	"GL_COUNTER_RANGE_AMD"),	# 0x8BC1
    ("",	X,	1,	"GL_UNSIGNED_INT64_AMD"),	# 0x8BC2
    ("",	X,	1,	"GL_PERCENTAGE_AMD"),	# 0x8BC3
    ("",	X,	1,	"GL_PERFMON_RESULT_AVAILABLE_AMD"),	# 0x8BC4
    ("",	X,	1,	"GL_PERFMON_RESULT_SIZE_AMD"),	# 0x8BC5
    ("",	X,	1,	"GL_PERFMON_RESULT_AMD"),	# 0x8BC6
    #("",	X,	1,	"GL_TEXTURE_WIDTH_QCOM"),	# 0x8BD2
    #("",	X,	1,	"GL_TEXTURE_HEIGHT_QCOM"),	# 0x8BD3
    #("",	X,	1,	"GL_TEXTURE_DEPTH_QCOM"),	# 0x8BD4
    #("",	X,	1,	"GL_TEXTURE_INTERNAL_FORMAT_QCOM"),	# 0x8BD5
    #("",	X,	1,	"GL_TEXTURE_FORMAT_QCOM"),	# 0x8BD6
    #("",	X,	1,	"GL_TEXTURE_TYPE_QCOM"),	# 0x8BD7
    #("",	X,	1,	"GL_TEXTURE_IMAGE_VALID_QCOM"),	# 0x8BD8
    #("",	X,	1,	"GL_TEXTURE_NUM_LEVELS_QCOM"),	# 0x8BD9
    #("",	X,	1,	"GL_TEXTURE_TARGET_QCOM"),	# 0x8BDA
    #("",	X,	1,	"GL_TEXTURE_OBJECT_VALID_QCOM"),	# 0x8BDB
    #("",	X,	1,	"GL_STATE_RESTORE"),	# 0x8BDC
    #("",	X,	1,	"GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG"),	# 0x8C00
    #("",	X,	1,	"GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG"),	# 0x8C01
    #("",	X,	1,	"GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"),	# 0x8C02
    #("",	X,	1,	"GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"),	# 0x8C03
    #("",	X,	1,	"GL_MODULATE_COLOR_IMG"),	# 0x8C04
    #("",	X,	1,	"GL_RECIP_ADD_SIGNED_ALPHA_IMG"),	# 0x8C05
    #("",	X,	1,	"GL_TEXTURE_ALPHA_MODULATE_IMG"),	# 0x8C06
    #("",	X,	1,	"GL_FACTOR_ALPHA_MODULATE_IMG"),	# 0x8C07
    #("",	X,	1,	"GL_FRAGMENT_ALPHA_MODULATE_IMG"),	# 0x8C08
    #("",	X,	1,	"GL_ADD_BLEND_IMG"),	# 0x8C09
    #("",	X,	1,	"GL_SGX_BINARY_IMG"),	# 0x8C0A
    ("glGetTexLevelParameter",	E,	1,	"GL_TEXTURE_RED_TYPE"),	# 0x8C10
    ("glGetTexLevelParameter",	E,	1,	"GL_TEXTURE_GREEN_TYPE"),	# 0x8C11
    ("glGetTexLevelParameter",	E,	1,	"GL_TEXTURE_BLUE_TYPE"),	# 0x8C12
    ("glGetTexLevelParameter",	E,	1,	"GL_TEXTURE_ALPHA_TYPE"),	# 0x8C13
    ("glGetTexLevelParameter",	E,	1,	"GL_TEXTURE_LUMINANCE_TYPE"),	# 0x8C14
    ("glGetTexLevelParameter",	E,	1,	"GL_TEXTURE_INTENSITY_TYPE"),	# 0x8C15
    ("glGetTexLevelParameter",	E,	1,	"GL_TEXTURE_DEPTH_TYPE"),	# 0x8C16
    ("",	X,	1,	"GL_UNSIGNED_NORMALIZED"),	# 0x8C17
    ("",	X,	1,	"GL_TEXTURE_1D_ARRAY"),	# 0x8C18
    ("",	X,	1,	"GL_PROXY_TEXTURE_1D_ARRAY"),	# 0x8C19
    ("",	X,	1,	"GL_TEXTURE_2D_ARRAY"),	# 0x8C1A
    ("",	X,	1,	"GL_PROXY_TEXTURE_2D_ARRAY"),	# 0x8C1B
    ("_glGet",	I,	1,	"GL_TEXTURE_BINDING_1D_ARRAY"),	# 0x8C1C
    ("_glGet",	I,	1,	"GL_TEXTURE_BINDING_2D_ARRAY"),	# 0x8C1D
    ("",	X,	1,	"GL_GEOMETRY_PROGRAM_NV"),	# 0x8C26
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_OUTPUT_VERTICES_NV"),	# 0x8C27
    ("glGetProgramARB",	I,	1,	"GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV"),	# 0x8C28
    ("glGet",	I,	1,	"GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS"),	# 0x8C29
    ("glGet",	I,	1,	"GL_TEXTURE_BUFFER"),	# 0x8C2A
    ("glGet",	I,	1,	"GL_MAX_TEXTURE_BUFFER_SIZE"),	# 0x8C2B
    ("glGet",	I,	1,	"GL_TEXTURE_BINDING_BUFFER"),	# 0x8C2C
    ("glGet",	I,	1,	"GL_TEXTURE_BUFFER_DATA_STORE_BINDING"),	# 0x8C2D
    ("glGet",	E,	1,	"GL_TEXTURE_BUFFER_FORMAT_ARB"),	# 0x8C2E
    ("",	B,	1,	"GL_ANY_SAMPLES_PASSED"),	# 0x8C2F
    ("",	X,	1,	"GL_SAMPLE_SHADING"),	# 0x8C36
    ("",	X,	1,	"GL_MIN_SAMPLE_SHADING_VALUE"),	# 0x8C37
    ("",	X,	1,	"GL_R11F_G11F_B10F"),	# 0x8C3A
    ("",	X,	1,	"GL_UNSIGNED_INT_10F_11F_11F_REV"),	# 0x8C3B
    ("",	X,	1,	"GL_RGBA_SIGNED_COMPONENTS_EXT"),	# 0x8C3C
    ("",	X,	1,	"GL_RGB9_E5"),	# 0x8C3D
    ("",	X,	1,	"GL_UNSIGNED_INT_5_9_9_9_REV"),	# 0x8C3E
    ("",	X,	1,	"GL_TEXTURE_SHARED_SIZE"),	# 0x8C3F
    ("",	X,	1,	"GL_SRGB"),	# 0x8C40
    ("",	X,	1,	"GL_SRGB8"),	# 0x8C41
    ("",	X,	1,	"GL_SRGB_ALPHA"),	# 0x8C42
    ("",	X,	1,	"GL_SRGB8_ALPHA8"),	# 0x8C43
    ("",	X,	1,	"GL_SLUMINANCE_ALPHA"),	# 0x8C44
    ("",	X,	1,	"GL_SLUMINANCE8_ALPHA8"),	# 0x8C45
    ("",	X,	1,	"GL_SLUMINANCE"),	# 0x8C46
    ("",	X,	1,	"GL_SLUMINANCE8"),	# 0x8C47
    ("",	X,	1,	"GL_COMPRESSED_SRGB"),	# 0x8C48
    ("",	X,	1,	"GL_COMPRESSED_SRGB_ALPHA"),	# 0x8C49
    ("",	X,	1,	"GL_COMPRESSED_SLUMINANCE"),	# 0x8C4A
    ("",	X,	1,	"GL_COMPRESSED_SLUMINANCE_ALPHA"),	# 0x8C4B
    ("",	X,	1,	"GL_COMPRESSED_SRGB_S3TC_DXT1_EXT"),	# 0x8C4C
    ("",	X,	1,	"GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"),	# 0x8C4D
    ("",	X,	1,	"GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"),	# 0x8C4E
    ("",	X,	1,	"GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"),	# 0x8C4F
    ("",	X,	1,	"GL_COMPRESSED_LUMINANCE_LATC1_EXT"),	# 0x8C70
    ("",	X,	1,	"GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT"),	# 0x8C71
    ("",	X,	1,	"GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT"),	# 0x8C72
    ("",	X,	1,	"GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT"),	# 0x8C73
    ("",	X,	1,	"GL_TESS_CONTROL_PROGRAM_PARAMETER_BUFFER_NV"),	# 0x8C74
    ("",	X,	1,	"GL_TESS_EVALUATION_PROGRAM_PARAMETER_BUFFER_NV"),	# 0x8C75
    ("glGetProgram",	I,	1,	"GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH"),	# 0x8C76
    ("",	X,	1,	"GL_BACK_PRIMARY_COLOR_NV"),	# 0x8C77
    ("",	X,	1,	"GL_BACK_SECONDARY_COLOR_NV"),	# 0x8C78
    ("",	X,	1,	"GL_TEXTURE_COORD_NV"),	# 0x8C79
    ("",	X,	1,	"GL_CLIP_DISTANCE_NV"),	# 0x8C7A
    ("",	X,	1,	"GL_VERTEX_ID_NV"),	# 0x8C7B
    ("",	X,	1,	"GL_PRIMITIVE_ID_NV"),	# 0x8C7C
    ("",	X,	1,	"GL_GENERIC_ATTRIB_NV"),	# 0x8C7D
    ("",	X,	1,	"GL_TRANSFORM_FEEDBACK_ATTRIBS_NV"),	# 0x8C7E
    ("glGetProgram",	E,	1,	"GL_TRANSFORM_FEEDBACK_BUFFER_MODE"),	# 0x8C7F
    ("glGet",	I,	1,	"GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"),	# 0x8C80
    ("",	X,	1,	"GL_ACTIVE_VARYINGS_NV"),	# 0x8C81
    ("",	X,	1,	"GL_ACTIVE_VARYING_MAX_LENGTH_NV"),	# 0x8C82
    ("glGetProgram",	I,	1,	"GL_TRANSFORM_FEEDBACK_VARYINGS"),	# 0x8C83
    ("",	I,	1,	"GL_TRANSFORM_FEEDBACK_BUFFER_START"),	# 0x8C84
    ("",	I,	1,	"GL_TRANSFORM_FEEDBACK_BUFFER_SIZE"),	# 0x8C85
    ("",	X,	1,	"GL_TRANSFORM_FEEDBACK_RECORD_NV"),	# 0x8C86
    ("",	X,	1,	"GL_PRIMITIVES_GENERATED"),	# 0x8C87
    ("",	X,	1,	"GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"),	# 0x8C88
    ("glGet",	B,	1,	"GL_RASTERIZER_DISCARD"),	# 0x8C89
    ("glGet",	I,	1,	"GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"),	# 0x8C8A
    ("glGet",	I,	1,	"GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"),	# 0x8C8B
    ("",	X,	1,	"GL_INTERLEAVED_ATTRIBS"),	# 0x8C8C
    ("",	X,	1,	"GL_SEPARATE_ATTRIBS"),	# 0x8C8D
    ("",	X,	1,	"GL_TRANSFORM_FEEDBACK_BUFFER"),	# 0x8C8E
    ("glGet",	I,	1,	"GL_TRANSFORM_FEEDBACK_BUFFER_BINDING"),	# 0x8C8F
    ("",	X,	1,	"GL_ATC_RGB_AMD"),	# 0x8C92
    ("",	X,	1,	"GL_ATC_RGBA_EXPLICIT_ALPHA_AMD"),	# 0x8C93
    ("glGet",	E,	1,	"GL_POINT_SPRITE_COORD_ORIGIN"),	# 0x8CA0
    ("",	X,	1,	"GL_LOWER_LEFT"),	# 0x8CA1
    ("",	X,	1,	"GL_UPPER_LEFT"),	# 0x8CA2
    ("",	X,	1,	"GL_STENCIL_BACK_REF"),	# 0x8CA3
    ("",	X,	1,	"GL_STENCIL_BACK_VALUE_MASK"),	# 0x8CA4
    ("",	X,	1,	"GL_STENCIL_BACK_WRITEMASK"),	# 0x8CA5
    ("glGet",	I,	1,	"GL_DRAW_FRAMEBUFFER_BINDING"),	# 0x8CA6
    ("glGet",	I,	1,	"GL_RENDERBUFFER_BINDING"),	# 0x8CA7
    ("",	I,	1,	"GL_READ_FRAMEBUFFER"),	# 0x8CA8
    ("",	I,	1,	"GL_DRAW_FRAMEBUFFER"),	# 0x8CA9
    ("glGet",	I,	1,	"GL_READ_FRAMEBUFFER_BINDING"),	# 0x8CAA
    ("glGetRenderbufferParameter",	I,	1,	"GL_RENDERBUFFER_SAMPLES"),	# 0x8CAB
    ("",	X,	1,	"GL_DEPTH_COMPONENT32F"),	# 0x8CAC
    ("",	X,	1,	"GL_DEPTH32F_STENCIL8"),	# 0x8CAD
    ("glGetFramebufferAttachmentParameter",	E,	1,	"GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"),	# 0x8CD0
    ("glGetFramebufferAttachmentParameter",	I,	1,	"GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"),	# 0x8CD1
    ("glGetFramebufferAttachmentParameter",	I,	1,	"GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"),	# 0x8CD2
    ("glGetFramebufferAttachmentParameter",	E,	1,	"GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"),	# 0x8CD3
    ("glGetFramebufferAttachmentParameter",	I,	1,	"GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"),	# 0x8CD4
    ("",	X,	1,	"GL_FRAMEBUFFER_COMPLETE"),	# 0x8CD5
    ("",	X,	1,	"GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT"),	# 0x8CD6
    ("",	X,	1,	"GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"),	# 0x8CD7
    ("",	X,	1,	"GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT"),	# 0x8CD9
    ("",	X,	1,	"GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT"),	# 0x8CDA
    ("",	X,	1,	"GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER"),	# 0x8CDB
    ("",	X,	1,	"GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER"),	# 0x8CDC
    ("",	X,	1,	"GL_FRAMEBUFFER_UNSUPPORTED"),	# 0x8CDD
    ("glGet",	I,	1,	"GL_MAX_COLOR_ATTACHMENTS"),	# 0x8CDF
    ("",	X,	1,	"GL_COLOR_ATTACHMENT0"),	# 0x8CE0
    ("",	X,	1,	"GL_COLOR_ATTACHMENT1"),	# 0x8CE1
    ("",	X,	1,	"GL_COLOR_ATTACHMENT2"),	# 0x8CE2
    ("",	X,	1,	"GL_COLOR_ATTACHMENT3"),	# 0x8CE3
    ("",	X,	1,	"GL_COLOR_ATTACHMENT4"),	# 0x8CE4
    ("",	X,	1,	"GL_COLOR_ATTACHMENT5"),	# 0x8CE5
    ("",	X,	1,	"GL_COLOR_ATTACHMENT6"),	# 0x8CE6
    ("",	X,	1,	"GL_COLOR_ATTACHMENT7"),	# 0x8CE7
    ("",	X,	1,	"GL_COLOR_ATTACHMENT8"),	# 0x8CE8
    ("",	X,	1,	"GL_COLOR_ATTACHMENT9"),	# 0x8CE9
    ("",	X,	1,	"GL_COLOR_ATTACHMENT10"),	# 0x8CEA
    ("",	X,	1,	"GL_COLOR_ATTACHMENT11"),	# 0x8CEB
    ("",	X,	1,	"GL_COLOR_ATTACHMENT12"),	# 0x8CEC
    ("",	X,	1,	"GL_COLOR_ATTACHMENT13"),	# 0x8CED
    ("",	X,	1,	"GL_COLOR_ATTACHMENT14"),	# 0x8CEE
    ("",	X,	1,	"GL_COLOR_ATTACHMENT15"),	# 0x8CEF
    ("",	X,	1,	"GL_DEPTH_ATTACHMENT"),	# 0x8D00
    ("",	X,	1,	"GL_STENCIL_ATTACHMENT"),	# 0x8D20
    ("",	X,	1,	"GL_FRAMEBUFFER"),	# 0x8D40
    ("",	X,	1,	"GL_RENDERBUFFER"),	# 0x8D41
    ("glGetRenderbufferParameter",	I,	1,	"GL_RENDERBUFFER_WIDTH"),	# 0x8D42
    ("glGetRenderbufferParameter",	I,	1,	"GL_RENDERBUFFER_HEIGHT"),	# 0x8D43
    ("glGetRenderbufferParameter",	E,	1,	"GL_RENDERBUFFER_INTERNAL_FORMAT"),	# 0x8D44
    ("",	X,	1,	"GL_STENCIL_INDEX1"),	# 0x8D46
    ("",	X,	1,	"GL_STENCIL_INDEX4"),	# 0x8D47
    ("",	X,	1,	"GL_STENCIL_INDEX8"),	# 0x8D48
    ("",	X,	1,	"GL_STENCIL_INDEX16"),	# 0x8D49
    ("glGetRenderbufferParameter",	I,	1,	"GL_RENDERBUFFER_RED_SIZE"),	# 0x8D50
    ("glGetRenderbufferParameter",	I,	1,	"GL_RENDERBUFFER_GREEN_SIZE"),	# 0x8D51
    ("glGetRenderbufferParameter",	I,	1,	"GL_RENDERBUFFER_BLUE_SIZE"),	# 0x8D52
    ("glGetRenderbufferParameter",	I,	1,	"GL_RENDERBUFFER_ALPHA_SIZE"),	# 0x8D53
    ("glGetRenderbufferParameter",	I,	1,	"GL_RENDERBUFFER_DEPTH_SIZE"),	# 0x8D54
    ("glGetRenderbufferParameter",	I,	1,	"GL_RENDERBUFFER_STENCIL_SIZE"),	# 0x8D55
    ("",	X,	1,	"GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"),	# 0x8D56
    ("glGet",	I,	1,	"GL_MAX_SAMPLES"),	# 0x8D57
    ("",	X,	1,	"GL_TEXTURE_GEN_STR_OES"),	# 0x8D60
    ("",	X,	1,	"GL_HALF_FLOAT_OES"),	# 0x8D61
    ("",	X,	1,	"GL_RGB565_OES"),	# 0x8D62
    ("",	X,	1,	"GL_ETC1_RGB8_OES"),	# 0x8D64
    ("",	X,	1,	"GL_TEXTURE_EXTERNAL_OES"),	# 0x8D65
    ("",	X,	1,	"GL_SAMPLER_EXTERNAL_OES"),	# 0x8D66
    ("",	X,	1,	"GL_TEXTURE_BINDING_EXTERNAL_OES"),	# 0x8D67
    ("",	X,	1,	"GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES"),	# 0x8D68
    ("glGet",	B,	1,	"GL_PRIMITIVE_RESTART_FIXED_INDEX"),	# 0x8D69
    ("",	B,	1,	"GL_ANY_SAMPLES_PASSED_CONSERVATIVE"),	# 0x8D6A
    ("glGet",	I,	1,	"GL_MAX_ELEMENT_INDEX"),	# 0x8D6B
    ("",	X,	1,	"GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT"),	# 0x8D6C
    ("",	X,	1,	"GL_RGBA32UI"),	# 0x8D70
    ("",	X,	1,	"GL_RGB32UI"),	# 0x8D71
    ("",	X,	1,	"GL_ALPHA32UI_EXT"),	# 0x8D72
    ("",	X,	1,	"GL_INTENSITY32UI_EXT"),	# 0x8D73
    ("",	X,	1,	"GL_LUMINANCE32UI_EXT"),	# 0x8D74
    ("",	X,	1,	"GL_LUMINANCE_ALPHA32UI_EXT"),	# 0x8D75
    ("",	X,	1,	"GL_RGBA16UI"),	# 0x8D76
    ("",	X,	1,	"GL_RGB16UI"),	# 0x8D77
    ("",	X,	1,	"GL_ALPHA16UI_EXT"),	# 0x8D78
    ("",	X,	1,	"GL_INTENSITY16UI_EXT"),	# 0x8D79
    ("",	X,	1,	"GL_LUMINANCE16UI_EXT"),	# 0x8D7A
    ("",	X,	1,	"GL_LUMINANCE_ALPHA16UI_EXT"),	# 0x8D7B
    ("",	X,	1,	"GL_RGBA8UI"),	# 0x8D7C
    ("",	X,	1,	"GL_RGB8UI"),	# 0x8D7D
    ("",	X,	1,	"GL_ALPHA8UI_EXT"),	# 0x8D7E
    ("",	X,	1,	"GL_INTENSITY8UI_EXT"),	# 0x8D7F
    ("",	X,	1,	"GL_LUMINANCE8UI_EXT"),	# 0x8D80
    ("",	X,	1,	"GL_LUMINANCE_ALPHA8UI_EXT"),	# 0x8D81
    ("",	X,	1,	"GL_RGBA32I"),	# 0x8D82
    ("",	X,	1,	"GL_RGB32I"),	# 0x8D83
    ("",	X,	1,	"GL_ALPHA32I_EXT"),	# 0x8D84
    ("",	X,	1,	"GL_INTENSITY32I_EXT"),	# 0x8D85
    ("",	X,	1,	"GL_LUMINANCE32I_EXT"),	# 0x8D86
    ("",	X,	1,	"GL_LUMINANCE_ALPHA32I_EXT"),	# 0x8D87
    ("",	X,	1,	"GL_RGBA16I"),	# 0x8D88
    ("",	X,	1,	"GL_RGB16I"),	# 0x8D89
    ("",	X,	1,	"GL_ALPHA16I_EXT"),	# 0x8D8A
    ("",	X,	1,	"GL_INTENSITY16I_EXT"),	# 0x8D8B
    ("",	X,	1,	"GL_LUMINANCE16I_EXT"),	# 0x8D8C
    ("",	X,	1,	"GL_LUMINANCE_ALPHA16I_EXT"),	# 0x8D8D
    ("",	X,	1,	"GL_RGBA8I"),	# 0x8D8E
    ("",	X,	1,	"GL_RGB8I"),	# 0x8D8F
    ("",	X,	1,	"GL_ALPHA8I_EXT"),	# 0x8D90
    ("",	X,	1,	"GL_INTENSITY8I_EXT"),	# 0x8D91
    ("",	X,	1,	"GL_LUMINANCE8I_EXT"),	# 0x8D92
    ("",	X,	1,	"GL_LUMINANCE_ALPHA8I_EXT"),	# 0x8D93
    ("",	X,	1,	"GL_RED_INTEGER"),	# 0x8D94
    ("",	X,	1,	"GL_GREEN_INTEGER"),	# 0x8D95
    ("",	X,	1,	"GL_BLUE_INTEGER"),	# 0x8D96
    ("",	X,	1,	"GL_ALPHA_INTEGER"),	# 0x8D97
    ("",	X,	1,	"GL_RGB_INTEGER"),	# 0x8D98
    ("",	X,	1,	"GL_RGBA_INTEGER"),	# 0x8D99
    ("",	X,	1,	"GL_BGR_INTEGER"),	# 0x8D9A
    ("",	X,	1,	"GL_BGRA_INTEGER"),	# 0x8D9B
    ("",	X,	1,	"GL_LUMINANCE_INTEGER_EXT"),	# 0x8D9C
    ("",	X,	1,	"GL_LUMINANCE_ALPHA_INTEGER_EXT"),	# 0x8D9D
    ("glGet",	B,	1,	"GL_RGBA_INTEGER_MODE_EXT"),	# 0x8D9E
    ("",	X,	1,	"GL_INT_2_10_10_10_REV"),	# 0x8D9F
    ("",	X,	1,	"GL_MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV"),	# 0x8DA0
    ("",	X,	1,	"GL_MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV"),	# 0x8DA1
    ("",	X,	1,	"GL_VERTEX_PROGRAM_PARAMETER_BUFFER_NV"),	# 0x8DA2
    ("",	X,	1,	"GL_GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV"),	# 0x8DA3
    ("",	X,	1,	"GL_FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV"),	# 0x8DA4
    ("",	X,	1,	"GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV"),	# 0x8DA5
    ("",	X,	1,	"GL_MAX_PROGRAM_GENERIC_RESULTS_NV"),	# 0x8DA6
    ("glGetFramebufferAttachmentParameter",	B,	1,	"GL_FRAMEBUFFER_ATTACHMENT_LAYERED"),	# 0x8DA7
    ("",	X,	1,	"GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS"),	# 0x8DA8
    ("",	X,	1,	"GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB"),	# 0x8DA9
    ("",	X,	1,	"GL_LAYER_NV"),	# 0x8DAA
    ("",	X,	1,	"GL_DEPTH_COMPONENT32F_NV"),	# 0x8DAB
    ("",	X,	1,	"GL_DEPTH32F_STENCIL8_NV"),	# 0x8DAC
    ("",	X,	1,	"GL_FLOAT_32_UNSIGNED_INT_24_8_REV"),	# 0x8DAD
    ("",	X,	1,	"GL_SHADER_INCLUDE_ARB"),	# 0x8DAE
    ("",	X,	1,	"GL_DEPTH_BUFFER_FLOAT_MODE_NV"),	# 0x8DAF
    ("glGet",	B,	1,	"GL_FRAMEBUFFER_SRGB"),	# 0x8DB9
    ("glGet",	B,	1,	"GL_FRAMEBUFFER_SRGB_CAPABLE_EXT"),	# 0x8DBA
    ("",	X,	1,	"GL_COMPRESSED_RED_RGTC1"),	# 0x8DBB
    ("",	X,	1,	"GL_COMPRESSED_SIGNED_RED_RGTC1"),	# 0x8DBC
    ("",	X,	1,	"GL_COMPRESSED_RG_RGTC2"),	# 0x8DBD
    ("",	X,	1,	"GL_COMPRESSED_SIGNED_RG_RGTC2"),	# 0x8DBE
    ("",	X,	1,	"GL_SAMPLER_1D_ARRAY"),	# 0x8DC0
    ("",	X,	1,	"GL_SAMPLER_2D_ARRAY"),	# 0x8DC1
    ("",	X,	1,	"GL_SAMPLER_BUFFER"),	# 0x8DC2
    ("",	X,	1,	"GL_SAMPLER_1D_ARRAY_SHADOW"),	# 0x8DC3
    ("",	X,	1,	"GL_SAMPLER_2D_ARRAY_SHADOW"),	# 0x8DC4
    ("",	X,	1,	"GL_SAMPLER_CUBE_SHADOW"),	# 0x8DC5
    ("",	X,	1,	"GL_UNSIGNED_INT_VEC2"),	# 0x8DC6
    ("",	X,	1,	"GL_UNSIGNED_INT_VEC3"),	# 0x8DC7
    ("",	X,	1,	"GL_UNSIGNED_INT_VEC4"),	# 0x8DC8
    ("",	X,	1,	"GL_INT_SAMPLER_1D"),	# 0x8DC9
    ("",	X,	1,	"GL_INT_SAMPLER_2D"),	# 0x8DCA
    ("",	X,	1,	"GL_INT_SAMPLER_3D"),	# 0x8DCB
    ("",	X,	1,	"GL_INT_SAMPLER_CUBE"),	# 0x8DCC
    ("",	X,	1,	"GL_INT_SAMPLER_2D_RECT"),	# 0x8DCD
    ("",	X,	1,	"GL_INT_SAMPLER_1D_ARRAY"),	# 0x8DCE
    ("",	X,	1,	"GL_INT_SAMPLER_2D_ARRAY"),	# 0x8DCF
    ("",	X,	1,	"GL_INT_SAMPLER_BUFFER"),	# 0x8DD0
    ("",	X,	1,	"GL_UNSIGNED_INT_SAMPLER_1D"),	# 0x8DD1
    ("",	X,	1,	"GL_UNSIGNED_INT_SAMPLER_2D"),	# 0x8DD2
    ("",	X,	1,	"GL_UNSIGNED_INT_SAMPLER_3D"),	# 0x8DD3
    ("",	X,	1,	"GL_UNSIGNED_INT_SAMPLER_CUBE"),	# 0x8DD4
    ("",	X,	1,	"GL_UNSIGNED_INT_SAMPLER_2D_RECT"),	# 0x8DD5
    ("",	X,	1,	"GL_UNSIGNED_INT_SAMPLER_1D_ARRAY"),	# 0x8DD6
    ("",	X,	1,	"GL_UNSIGNED_INT_SAMPLER_2D_ARRAY"),	# 0x8DD7
    ("",	X,	1,	"GL_UNSIGNED_INT_SAMPLER_BUFFER"),	# 0x8DD8
    ("glGetProgramPipeline",	I,	1,	"GL_GEOMETRY_SHADER"),	# 0x8DD9
    ("glGetProgram",	I,	1,	"GL_GEOMETRY_VERTICES_OUT_ARB"),	# 0x8DDA
    ("glGetProgram",	E,	1,	"GL_GEOMETRY_INPUT_TYPE_ARB"),	# 0x8DDB
    ("glGetProgram",	E,	1,	"GL_GEOMETRY_OUTPUT_TYPE_ARB"),	# 0x8DDC
    ("glGet",	I,	1,	"GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB"),	# 0x8DDD
    ("glGet",	I,	1,	"GL_MAX_VERTEX_VARYING_COMPONENTS_ARB"),	# 0x8DDE
    ("glGet",	I,	1,	"GL_MAX_GEOMETRY_UNIFORM_COMPONENTS"),	# 0x8DDF
    ("glGet",	I,	1,	"GL_MAX_GEOMETRY_OUTPUT_VERTICES"),	# 0x8DE0
    ("glGet",	I,	1,	"GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS"),	# 0x8DE1
    ("",	X,	1,	"GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT"),	# 0x8DE2
    ("",	X,	1,	"GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT"),	# 0x8DE3
    ("",	X,	1,	"GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT"),	# 0x8DE4
    ("",	X,	1,	"GL_ACTIVE_SUBROUTINES"),	# 0x8DE5
    ("",	X,	1,	"GL_ACTIVE_SUBROUTINE_UNIFORMS"),	# 0x8DE6
    ("glGet",	I,	1,	"GL_MAX_SUBROUTINES"),	# 0x8DE7
    ("glGet",	I,	1,	"GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS"),	# 0x8DE8
    ("glGetNamedString",	X,	1,	"GL_NAMED_STRING_LENGTH_ARB"),	# 0x8DE9
    ("glGetNamedString",	E,	1,	"GL_NAMED_STRING_TYPE_ARB"),	# 0x8DEA
    ("glGet",	I,	1,	"GL_MAX_BINDABLE_UNIFORM_SIZE_EXT"),	# 0x8DED
    ("",	X,	1,	"GL_UNIFORM_BUFFER_EXT"),	# 0x8DEE
    ("glGet",	I,	1,	"GL_UNIFORM_BUFFER_BINDING_EXT"),	# 0x8DEF
    ("",	X,	1,	"GL_LOW_FLOAT"),	# 0x8DF0
    ("",	X,	1,	"GL_MEDIUM_FLOAT"),	# 0x8DF1
    ("",	X,	1,	"GL_HIGH_FLOAT"),	# 0x8DF2
    ("",	X,	1,	"GL_LOW_INT"),	# 0x8DF3
    ("",	X,	1,	"GL_MEDIUM_INT"),	# 0x8DF4
    ("",	X,	1,	"GL_HIGH_INT"),	# 0x8DF5
    ("",	X,	1,	"GL_UNSIGNED_INT_10_10_10_2_OES"),	# 0x8DF6
    ("",	X,	1,	"GL_INT_10_10_10_2_OES"),	# 0x8DF7
    ("",	X,	1,	"GL_SHADER_BINARY_FORMATS"),	# 0x8DF8
    ("glGet",	I,	1,	"GL_NUM_SHADER_BINARY_FORMATS"),	# 0x8DF9
    ("glGet",	B,	1,	"GL_SHADER_COMPILER"),	# 0x8DFA
    ("glGet",	I,	1,	"GL_MAX_VERTEX_UNIFORM_VECTORS"),	# 0x8DFB
    ("glGet",	I,	1,	"GL_MAX_VARYING_VECTORS"),	# 0x8DFC
    ("glGet",	I,	1,	"GL_MAX_FRAGMENT_UNIFORM_VECTORS"),	# 0x8DFD
    ("",	X,	1,	"GL_RENDERBUFFER_COLOR_SAMPLES_NV"),	# 0x8E10
    ("",	X,	1,	"GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV"),	# 0x8E11
    ("",	X,	1,	"GL_MULTISAMPLE_COVERAGE_MODES_NV"),	# 0x8E12
    ("",	X,	1,	"GL_QUERY_WAIT"),	# 0x8E13
    ("",	X,	1,	"GL_QUERY_NO_WAIT"),	# 0x8E14
    ("",	X,	1,	"GL_QUERY_BY_REGION_WAIT"),	# 0x8E15
    ("",	X,	1,	"GL_QUERY_BY_REGION_NO_WAIT"),	# 0x8E16
    ("glGet",	I,	1,	"GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS"),	# 0x8E1E
    ("glGet",	I,	1,	"GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS"),	# 0x8E1F
    ("",	X,	1,	"GL_COLOR_SAMPLES_NV"),	# 0x8E20
    ("",	X,	1,	"GL_TRANSFORM_FEEDBACK"),	# 0x8E22
    ("glGet",	B,	1,	"GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED"),	# 0x8E23
    ("glGet",	B,	1,	"GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE"),	# 0x8E24
    ("glGet",	I,	1,	"GL_TRANSFORM_FEEDBACK_BINDING"),	# 0x8E25
    ("",	X,	1,	"GL_FRAME_NV"),	# 0x8E26
    ("",	X,	1,	"GL_FIELDS_NV"),	# 0x8E27
    ("",	X,	1,	"GL_TIMESTAMP"),	# 0x8E28
    ("",	X,	1,	"GL_NUM_FILL_STREAMS_NV"),	# 0x8E29
    ("",	X,	1,	"GL_PRESENT_TIME_NV"),	# 0x8E2A
    ("",	X,	1,	"GL_PRESENT_DURATION_NV"),	# 0x8E2B
    ("",	X,	1,	"GL_DEPTH_COMPONENT16_NONLINEAR_NV"),	# 0x8E2C
    ("",	X,	1,	"GL_PROGRAM_MATRIX_EXT"),	# 0x8E2D
    ("",	X,	1,	"GL_TRANSPOSE_PROGRAM_MATRIX_EXT"),	# 0x8E2E
    ("",	X,	1,	"GL_PROGRAM_MATRIX_STACK_DEPTH_EXT"),	# 0x8E2F
    ("glGetTexParameter",	E,	1,	"GL_TEXTURE_SWIZZLE_R"),	# 0x8E42
    ("glGetTexParameter",	E,	1,	"GL_TEXTURE_SWIZZLE_G"),	# 0x8E43
    ("glGetTexParameter",	E,	1,	"GL_TEXTURE_SWIZZLE_B"),	# 0x8E44
    ("glGetTexParameter",	E,	1,	"GL_TEXTURE_SWIZZLE_A"),	# 0x8E45
    ("glGetTexParameter",	E,	4,	"GL_TEXTURE_SWIZZLE_RGBA"),	# 0x8E46
    ("",	X,	1,	"GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS"),	# 0x8E47
    ("",	X,	1,	"GL_ACTIVE_SUBROUTINE_MAX_LENGTH"),	# 0x8E48
    ("",	X,	1,	"GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH"),	# 0x8E49
    ("",	I,	1,	"GL_NUM_COMPATIBLE_SUBROUTINES"),	# 0x8E4A
    ("",	I,	1,	"GL_COMPATIBLE_SUBROUTINES"),	# 0x8E4B
    ("glGet",	B,	1,	"GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION"),	# 0x8E4C
    ("",	X,	1,	"GL_FIRST_VERTEX_CONVENTION"),	# 0x8E4D
    ("",	X,	1,	"GL_LAST_VERTEX_CONVENTION"),	# 0x8E4E
    ("glGet",	E,	1,	"GL_PROVOKING_VERTEX"),	# 0x8E4F
    ("glGetMultisample",	I,	1,	"GL_SAMPLE_POSITION"),	# 0x8E50
    ("glGet",	B,	1,	"GL_SAMPLE_MASK"),	# 0x8E51
    ("glGet",	I,	1,	"GL_SAMPLE_MASK_VALUE"),	# 0x8E52
    ("",	X,	1,	"GL_TEXTURE_BINDING_RENDERBUFFER_NV"),	# 0x8E53
    ("glGet",	I,	1,	"GL_TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV"),	# 0x8E54
    ("",	X,	1,	"GL_TEXTURE_RENDERBUFFER_NV"),	# 0x8E55
    ("",	X,	1,	"GL_SAMPLER_RENDERBUFFER_NV"),	# 0x8E56
    ("",	X,	1,	"GL_INT_SAMPLER_RENDERBUFFER_NV"),	# 0x8E57
    ("",	X,	1,	"GL_UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV"),	# 0x8E58
    ("glGet",	I,	1,	"GL_MAX_SAMPLE_MASK_WORDS"),	# 0x8E59
    ("",	X,	1,	"GL_MAX_GEOMETRY_SHADER_INVOCATIONS"),	# 0x8E5A
    ("glGet",	F,	1,	"GL_MIN_FRAGMENT_INTERPOLATION_OFFSET"),	# 0x8E5B
    ("glGet",	F,	1,	"GL_MAX_FRAGMENT_INTERPOLATION_OFFSET"),	# 0x8E5C
    ("glGet",	I,	1,	"GL_FRAGMENT_INTERPOLATION_OFFSET_BITS"),	# 0x8E5D
    ("",	X,	1,	"GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET"),	# 0x8E5E
    ("",	X,	1,	"GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET"),	# 0x8E5F
    ("glGet",	I,	1,	"GL_MAX_TRANSFORM_FEEDBACK_BUFFERS"),	# 0x8E70
    ("glGet",	I,	1,	"GL_MAX_VERTEX_STREAMS"),	# 0x8E71
    ("glGet",	I,	1,	"GL_PATCH_VERTICES"),	# 0x8E72
    ("glGet",	F,	2,	"GL_PATCH_DEFAULT_INNER_LEVEL"),	# 0x8E73
    ("glGet",	F,	4,	"GL_PATCH_DEFAULT_OUTER_LEVEL"),	# 0x8E74
    ("glGet",	X,	1,	"GL_TESS_CONTROL_OUTPUT_VERTICES"),	# 0x8E75
    ("glGet",	E,	1,	"GL_TESS_GEN_MODE"),	# 0x8E76
    ("glGet",	E,	1,	"GL_TESS_GEN_SPACING"),	# 0x8E77
    ("glGet",	E,	1,	"GL_TESS_GEN_VERTEX_ORDER"),	# 0x8E78
    ("glGet",	E,	1,	"GL_TESS_GEN_POINT_MODE"),	# 0x8E79
    ("",	X,	1,	"GL_ISOLINES"),	# 0x8E7A
    ("",	X,	1,	"GL_FRACTIONAL_ODD"),	# 0x8E7B
    ("",	X,	1,	"GL_FRACTIONAL_EVEN"),	# 0x8E7C
    ("glGet",	I,	1,	"GL_MAX_PATCH_VERTICES"),	# 0x8E7D
    ("glGet",	I,	1,	"GL_MAX_TESS_GEN_LEVEL"),	# 0x8E7E
    ("glGet",	I,	1,	"GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS"),	# 0x8E7F
    ("glGet",	I,	1,	"GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS"),	# 0x8E80
    ("glGet",	I,	1,	"GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS"),	# 0x8E81
    ("glGet",	I,	1,	"GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS"),	# 0x8E82
    ("glGet",	I,	1,	"GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS"),	# 0x8E83
    ("glGet",	I,	1,	"GL_MAX_TESS_PATCH_COMPONENTS"),	# 0x8E84
    ("glGet",	I,	1,	"GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS"),	# 0x8E85
    ("glGet",	I,	1,	"GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS"),	# 0x8E86
    ("glGetProgramPipeline",	I,	1,	"GL_TESS_EVALUATION_SHADER"),	# 0x8E87
    ("glGetProgramPipeline",	I,	1,	"GL_TESS_CONTROL_SHADER"),	# 0x8E88
    ("glGet",	I,	1,	"GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS"),	# 0x8E89
    ("glGet",	I,	1,	"GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS"),	# 0x8E8A
    ("",	X,	1,	"GL_COMPRESSED_RGBA_BPTC_UNORM_ARB"),	# 0x8E8C
    ("",	X,	1,	"GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB"),	# 0x8E8D
    ("",	X,	1,	"GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB"),	# 0x8E8E
    ("",	X,	1,	"GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB"),	# 0x8E8F
    #("",	X,	1,	"GL_COVERAGE_COMPONENT_NV"),	# 0x8ED0
    #("",	X,	1,	"GL_COVERAGE_COMPONENT4_NV"),	# 0x8ED1
    #("",	X,	1,	"GL_COVERAGE_ATTACHMENT_NV"),	# 0x8ED2
    #("",	X,	1,	"GL_COVERAGE_BUFFERS_NV"),	# 0x8ED3
    #("",	X,	1,	"GL_COVERAGE_SAMPLES_NV"),	# 0x8ED4
    #("",	X,	1,	"GL_COVERAGE_ALL_FRAGMENTS_NV"),	# 0x8ED5
    #("",	X,	1,	"GL_COVERAGE_EDGE_FRAGMENTS_NV"),	# 0x8ED6
    #("",	X,	1,	"GL_COVERAGE_AUTOMATIC_NV"),	# 0x8ED7
    ("GetBufferParameter",	I64,	1,	"GL_BUFFER_GPU_ADDRESS_NV"),	# 0x8F1D
    ("",	X,	1,	"GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV"),	# 0x8F1E
    ("",	X,	1,	"GL_ELEMENT_ARRAY_UNIFIED_NV"),	# 0x8F1F
    ("",	X,	1,	"GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV"),	# 0x8F20
    ("",	X,	1,	"GL_VERTEX_ARRAY_ADDRESS_NV"),	# 0x8F21
    ("",	X,	1,	"GL_NORMAL_ARRAY_ADDRESS_NV"),	# 0x8F22
    ("",	X,	1,	"GL_COLOR_ARRAY_ADDRESS_NV"),	# 0x8F23
    ("",	X,	1,	"GL_INDEX_ARRAY_ADDRESS_NV"),	# 0x8F24
    ("",	X,	1,	"GL_TEXTURE_COORD_ARRAY_ADDRESS_NV"),	# 0x8F25
    ("",	X,	1,	"GL_EDGE_FLAG_ARRAY_ADDRESS_NV"),	# 0x8F26
    ("",	X,	1,	"GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV"),	# 0x8F27
    ("",	X,	1,	"GL_FOG_COORD_ARRAY_ADDRESS_NV"),	# 0x8F28
    ("",	X,	1,	"GL_ELEMENT_ARRAY_ADDRESS_NV"),	# 0x8F29
    ("",	X,	1,	"GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV"),	# 0x8F2A
    ("",	X,	1,	"GL_VERTEX_ARRAY_LENGTH_NV"),	# 0x8F2B
    ("",	X,	1,	"GL_NORMAL_ARRAY_LENGTH_NV"),	# 0x8F2C
    ("",	X,	1,	"GL_COLOR_ARRAY_LENGTH_NV"),	# 0x8F2D
    ("",	X,	1,	"GL_INDEX_ARRAY_LENGTH_NV"),	# 0x8F2E
    ("",	X,	1,	"GL_TEXTURE_COORD_ARRAY_LENGTH_NV"),	# 0x8F2F
    ("",	X,	1,	"GL_EDGE_FLAG_ARRAY_LENGTH_NV"),	# 0x8F30
    ("",	X,	1,	"GL_SECONDARY_COLOR_ARRAY_LENGTH_NV"),	# 0x8F31
    ("",	X,	1,	"GL_FOG_COORD_ARRAY_LENGTH_NV"),	# 0x8F32
    ("",	X,	1,	"GL_ELEMENT_ARRAY_LENGTH_NV"),	# 0x8F33
    ("",	X,	1,	"GL_GPU_ADDRESS_NV"),	# 0x8F34
    ("",	X,	1,	"GL_MAX_SHADER_BUFFER_ADDRESS_NV"),	# 0x8F35
    ("glGet",	I,	1,	"GL_COPY_READ_BUFFER"),	# 0x8F36
    ("glGet",	I,	1,	"GL_COPY_WRITE_BUFFER"),	# 0x8F37
    ("glGet",	I,	1,	"GL_MAX_IMAGE_UNITS"),	# 0x8F38
    ("glGet",	I,	1,	"GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS"),	# 0x8F39
    ("",	X,	1,	"GL_IMAGE_BINDING_NAME"),	# 0x8F3A
    ("",	X,	1,	"GL_IMAGE_BINDING_LEVEL"),	# 0x8F3B
    ("",	X,	1,	"GL_IMAGE_BINDING_LAYERED"),	# 0x8F3C
    ("",	X,	1,	"GL_IMAGE_BINDING_LAYER"),	# 0x8F3D
    ("",	X,	1,	"GL_IMAGE_BINDING_ACCESS"),	# 0x8F3E
    ("",	X,	1,	"GL_DRAW_INDIRECT_BUFFER"),	# 0x8F3F
    ("",	X,	1,	"GL_DRAW_INDIRECT_UNIFIED_NV"),	# 0x8F40
    ("",	X,	1,	"GL_DRAW_INDIRECT_ADDRESS_NV"),	# 0x8F41
    ("",	X,	1,	"GL_DRAW_INDIRECT_LENGTH_NV"),	# 0x8F42
    ("glGet",	I,	1,	"GL_DRAW_INDIRECT_BUFFER_BINDING"),	# 0x8F43
    ("",	X,	1,	"GL_MAX_PROGRAM_SUBROUTINE_PARAMETERS_NV"),	# 0x8F44
    ("",	X,	1,	"GL_MAX_PROGRAM_SUBROUTINE_NUM_NV"),	# 0x8F45
    ("",	X,	1,	"GL_DOUBLE_MAT2"),	# 0x8F46
    ("",	X,	1,	"GL_DOUBLE_MAT3"),	# 0x8F47
    ("",	X,	1,	"GL_DOUBLE_MAT4"),	# 0x8F48
    ("",	X,	1,	"GL_DOUBLE_MAT2x3"),	# 0x8F49
    ("",	X,	1,	"GL_DOUBLE_MAT2x4"),	# 0x8F4A
    ("",	X,	1,	"GL_DOUBLE_MAT3x2"),	# 0x8F4B
    ("",	X,	1,	"GL_DOUBLE_MAT3x4"),	# 0x8F4C
    ("",	X,	1,	"GL_DOUBLE_MAT4x2"),	# 0x8F4D
    ("",	X,	1,	"GL_DOUBLE_MAT4x3"),	# 0x8F4E
    ("",	X,	1,	"GL_MALI_SHADER_BINARY_ARM"),	# 0x8F60
    ("",	X,	1,	"GL_RED_SNORM"),	# 0x8F90
    ("",	X,	1,	"GL_RG_SNORM"),	# 0x8F91
    ("",	X,	1,	"GL_RGB_SNORM"),	# 0x8F92
    ("",	X,	1,	"GL_RGBA_SNORM"),	# 0x8F93
    ("",	X,	1,	"GL_R8_SNORM"),	# 0x8F94
    ("",	X,	1,	"GL_RG8_SNORM"),	# 0x8F95
    ("",	X,	1,	"GL_RGB8_SNORM"),	# 0x8F96
    ("",	X,	1,	"GL_RGBA8_SNORM"),	# 0x8F97
    ("",	X,	1,	"GL_R16_SNORM"),	# 0x8F98
    ("",	X,	1,	"GL_RG16_SNORM"),	# 0x8F99
    ("",	X,	1,	"GL_RGB16_SNORM"),	# 0x8F9A
    ("",	X,	1,	"GL_RGBA16_SNORM"),	# 0x8F9B
    ("",	X,	1,	"GL_SIGNED_NORMALIZED"),	# 0x8F9C
    ("glGet",	B,	1,	"GL_PRIMITIVE_RESTART"),	# 0x8F9D
    ("glGet",	I,	1,	"GL_PRIMITIVE_RESTART_INDEX"),	# 0x8F9E
    ("",	X,	1,	"GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB"),	# 0x8F9F
    ("",	X,	1,	"GL_PERFMON_GLOBAL_MODE_QCOM"),	# 0x8FA0
    ("",	X,	1,	"GL_BINNING_CONTROL_HINT_QCOM"),	# 0x8FB0
    ("",	X,	1,	"GL_CPU_OPTIMIZED_QCOM"),	# 0x8FB1
    ("",	X,	1,	"GL_GPU_OPTIMIZED_QCOM"),	# 0x8FB2
    ("",	X,	1,	"GL_RENDER_DIRECT_TO_FRAMEBUFFER_QCOM"),	# 0x8FB3
    ("",	X,	1,	"GL_GPU_DISJOINT_EXT"),	# 0x8FBB
    ("",	X,	1,	"GL_SHADER_BINARY_VIV"),	# 0x8FC4
    ("",	X,	1,	"GL_INT8_NV"),	# 0x8FE0
    ("",	X,	1,	"GL_INT8_VEC2_NV"),	# 0x8FE1
    ("",	X,	1,	"GL_INT8_VEC3_NV"),	# 0x8FE2
    ("",	X,	1,	"GL_INT8_VEC4_NV"),	# 0x8FE3
    ("",	X,	1,	"GL_INT16_NV"),	# 0x8FE4
    ("",	X,	1,	"GL_INT16_VEC2_NV"),	# 0x8FE5
    ("",	X,	1,	"GL_INT16_VEC3_NV"),	# 0x8FE6
    ("",	X,	1,	"GL_INT16_VEC4_NV"),	# 0x8FE7
    ("",	X,	1,	"GL_INT64_VEC2_NV"),	# 0x8FE9
    ("",	X,	1,	"GL_INT64_VEC3_NV"),	# 0x8FEA
    ("",	X,	1,	"GL_INT64_VEC4_NV"),	# 0x8FEB
    ("",	X,	1,	"GL_UNSIGNED_INT8_NV"),	# 0x8FEC
    ("",	X,	1,	"GL_UNSIGNED_INT8_VEC2_NV"),	# 0x8FED
    ("",	X,	1,	"GL_UNSIGNED_INT8_VEC3_NV"),	# 0x8FEE
    ("",	X,	1,	"GL_UNSIGNED_INT8_VEC4_NV"),	# 0x8FEF
    ("",	X,	1,	"GL_UNSIGNED_INT16_NV"),	# 0x8FF0
    ("",	X,	1,	"GL_UNSIGNED_INT16_VEC2_NV"),	# 0x8FF1
    ("",	X,	1,	"GL_UNSIGNED_INT16_VEC3_NV"),	# 0x8FF2
    ("",	X,	1,	"GL_UNSIGNED_INT16_VEC4_NV"),	# 0x8FF3
    ("",	X,	1,	"GL_UNSIGNED_INT64_VEC2_NV"),	# 0x8FF5
    ("",	X,	1,	"GL_UNSIGNED_INT64_VEC3_NV"),	# 0x8FF6
    ("",	X,	1,	"GL_UNSIGNED_INT64_VEC4_NV"),	# 0x8FF7
    ("",	X,	1,	"GL_FLOAT16_NV"),	# 0x8FF8
    ("",	X,	1,	"GL_FLOAT16_VEC2_NV"),	# 0x8FF9
    ("",	X,	1,	"GL_FLOAT16_VEC3_NV"),	# 0x8FFA
    ("",	X,	1,	"GL_FLOAT16_VEC4_NV"),	# 0x8FFB
    ("",	X,	1,	"GL_DOUBLE_VEC2"),	# 0x8FFC
    ("",	X,	1,	"GL_DOUBLE_VEC3"),	# 0x8FFD
    ("",	X,	1,	"GL_DOUBLE_VEC4"),	# 0x8FFE
    ("",	X,	1,	"GL_SAMPLER_BUFFER_AMD"),	# 0x9001
    ("",	X,	1,	"GL_INT_SAMPLER_BUFFER_AMD"),	# 0x9002
    ("",	X,	1,	"GL_UNSIGNED_INT_SAMPLER_BUFFER_AMD"),	# 0x9003
    ("",	X,	1,	"GL_TESSELLATION_MODE_AMD"),	# 0x9004
    ("",	X,	1,	"GL_TESSELLATION_FACTOR_AMD"),	# 0x9005
    ("",	X,	1,	"GL_DISCRETE_AMD"),	# 0x9006
    ("",	X,	1,	"GL_CONTINUOUS_AMD"),	# 0x9007
    ("_glGet",	B,	1,	"GL_TEXTURE_CUBE_MAP_ARRAY"),	# 0x9009
    ("_glGet",	I,	1,	"GL_TEXTURE_BINDING_CUBE_MAP_ARRAY"),	# 0x900A
    ("",	X,	1,	"GL_PROXY_TEXTURE_CUBE_MAP_ARRAY"),	# 0x900B
    ("",	X,	1,	"GL_SAMPLER_CUBE_MAP_ARRAY"),	# 0x900C
    ("",	X,	1,	"GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW"),	# 0x900D
    ("",	X,	1,	"GL_INT_SAMPLER_CUBE_MAP_ARRAY"),	# 0x900E
    ("",	X,	1,	"GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY"),	# 0x900F
    ("",	X,	1,	"GL_ALPHA_SNORM"),	# 0x9010
    ("",	X,	1,	"GL_LUMINANCE_SNORM"),	# 0x9011
    ("",	X,	1,	"GL_LUMINANCE_ALPHA_SNORM"),	# 0x9012
    ("",	X,	1,	"GL_INTENSITY_SNORM"),	# 0x9013
    ("",	X,	1,	"GL_ALPHA8_SNORM"),	# 0x9014
    ("",	X,	1,	"GL_LUMINANCE8_SNORM"),	# 0x9015
    ("",	X,	1,	"GL_LUMINANCE8_ALPHA8_SNORM"),	# 0x9016
    ("",	X,	1,	"GL_INTENSITY8_SNORM"),	# 0x9017
    ("",	X,	1,	"GL_ALPHA16_SNORM"),	# 0x9018
    ("",	X,	1,	"GL_LUMINANCE16_SNORM"),	# 0x9019
    ("",	X,	1,	"GL_LUMINANCE16_ALPHA16_SNORM"),	# 0x901A
    ("",	X,	1,	"GL_INTENSITY16_SNORM"),	# 0x901B
    ("",	X,	1,	"GL_FACTOR_MIN_AMD"),	# 0x901C
    ("",	X,	1,	"GL_FACTOR_MAX_AMD"),	# 0x901D
    ("",	B,	1,	"GL_DEPTH_CLAMP_NEAR_AMD"),	# 0x901E
    ("",	B,	1,	"GL_DEPTH_CLAMP_FAR_AMD"),	# 0x901F
    ("",	X,	1,	"GL_VIDEO_BUFFER_NV"),	# 0x9020
    ("glGet",	I,	1,	"GL_VIDEO_BUFFER_BINDING_NV"),	# 0x9021
    ("",	X,	1,	"GL_FIELD_UPPER_NV"),	# 0x9022
    ("",	X,	1,	"GL_FIELD_LOWER_NV"),	# 0x9023
    ("",	X,	1,	"GL_NUM_VIDEO_CAPTURE_STREAMS_NV"),	# 0x9024
    ("",	X,	1,	"GL_NEXT_VIDEO_CAPTURE_BUFFER_STATUS_NV"),	# 0x9025
    ("",	X,	1,	"GL_VIDEO_CAPTURE_TO_422_SUPPORTED_NV"),	# 0x9026
    ("",	X,	1,	"GL_LAST_VIDEO_CAPTURE_STATUS_NV"),	# 0x9027
    ("",	X,	1,	"GL_VIDEO_BUFFER_PITCH_NV"),	# 0x9028
    ("",	X,	1,	"GL_VIDEO_COLOR_CONVERSION_MATRIX_NV"),	# 0x9029
    ("",	X,	1,	"GL_VIDEO_COLOR_CONVERSION_MAX_NV"),	# 0x902A
    ("",	X,	1,	"GL_VIDEO_COLOR_CONVERSION_MIN_NV"),	# 0x902B
    ("",	X,	1,	"GL_VIDEO_COLOR_CONVERSION_OFFSET_NV"),	# 0x902C
    ("",	X,	1,	"GL_VIDEO_BUFFER_INTERNAL_FORMAT_NV"),	# 0x902D
    ("",	X,	1,	"GL_PARTIAL_SUCCESS_NV"),	# 0x902E
    ("",	X,	1,	"GL_SUCCESS_NV"),	# 0x902F
    ("",	X,	1,	"GL_FAILURE_NV"),	# 0x9030
    ("",	X,	1,	"GL_YCBYCR8_422_NV"),	# 0x9031
    ("",	X,	1,	"GL_YCBAYCR8A_4224_NV"),	# 0x9032
    ("",	X,	1,	"GL_Z6Y10Z6CB10Z6Y10Z6CR10_422_NV"),	# 0x9033
    ("",	X,	1,	"GL_Z6Y10Z6CB10Z6A10Z6Y10Z6CR10Z6A10_4224_NV"),	# 0x9034
    ("",	X,	1,	"GL_Z4Y12Z4CB12Z4Y12Z4CR12_422_NV"),	# 0x9035
    ("",	X,	1,	"GL_Z4Y12Z4CB12Z4A12Z4Y12Z4CR12Z4A12_4224_NV"),	# 0x9036
    ("",	X,	1,	"GL_Z4Y12Z4CB12Z4CR12_444_NV"),	# 0x9037
    ("",	X,	1,	"GL_VIDEO_CAPTURE_FRAME_WIDTH_NV"),	# 0x9038
    ("",	X,	1,	"GL_VIDEO_CAPTURE_FRAME_HEIGHT_NV"),	# 0x9039
    ("",	X,	1,	"GL_VIDEO_CAPTURE_FIELD_UPPER_HEIGHT_NV"),	# 0x903A
    ("",	X,	1,	"GL_VIDEO_CAPTURE_FIELD_LOWER_HEIGHT_NV"),	# 0x903B
    ("",	X,	1,	"GL_VIDEO_CAPTURE_SURFACE_ORIGIN_NV"),	# 0x903C
    ("",	X,	1,	"GL_TEXTURE_COVERAGE_SAMPLES_NV"),	# 0x9045
    ("",	X,	1,	"GL_TEXTURE_COLOR_SAMPLES_NV"),	# 0x9046
    ("glGet",	I,	1,	"GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX"), # 0x9047
    ("glGet",	I,	1,	"GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX"), # 0x9048
    ("glGet",	I,	1,	"GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX"), # 0x9049
    ("glGet",	I,	1,	"GL_GPU_MEMORY_INFO_EVICTION_COUNT_NVX"), # 0x904A
    ("glGet",	I,	1,	"GL_GPU_MEMORY_INFO_EVICTED_MEMORY_NVX"), # 0x904B
    ("",	X,	1,	"GL_IMAGE_1D"),	# 0x904C
    ("",	X,	1,	"GL_IMAGE_2D"),	# 0x904D
    ("",	X,	1,	"GL_IMAGE_3D"),	# 0x904E
    ("",	X,	1,	"GL_IMAGE_2D_RECT"),	# 0x904F
    ("",	X,	1,	"GL_IMAGE_CUBE"),	# 0x9050
    ("",	X,	1,	"GL_IMAGE_BUFFER"),	# 0x9051
    ("",	X,	1,	"GL_IMAGE_1D_ARRAY"),	# 0x9052
    ("",	X,	1,	"GL_IMAGE_2D_ARRAY"),	# 0x9053
    ("",	X,	1,	"GL_IMAGE_CUBE_MAP_ARRAY"),	# 0x9054
    ("",	X,	1,	"GL_IMAGE_2D_MULTISAMPLE"),	# 0x9055
    ("",	X,	1,	"GL_IMAGE_2D_MULTISAMPLE_ARRAY"),	# 0x9056
    ("",	X,	1,	"GL_INT_IMAGE_1D"),	# 0x9057
    ("",	X,	1,	"GL_INT_IMAGE_2D"),	# 0x9058
    ("",	X,	1,	"GL_INT_IMAGE_3D"),	# 0x9059
    ("",	X,	1,	"GL_INT_IMAGE_2D_RECT"),	# 0x905A
    ("",	X,	1,	"GL_INT_IMAGE_CUBE"),	# 0x905B
    ("",	X,	1,	"GL_INT_IMAGE_BUFFER"),	# 0x905C
    ("",	X,	1,	"GL_INT_IMAGE_1D_ARRAY"),	# 0x905D
    ("",	X,	1,	"GL_INT_IMAGE_2D_ARRAY"),	# 0x905E
    ("",	X,	1,	"GL_INT_IMAGE_CUBE_MAP_ARRAY"),	# 0x905F
    ("",	X,	1,	"GL_INT_IMAGE_2D_MULTISAMPLE"),	# 0x9060
    ("",	X,	1,	"GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY"),	# 0x9061
    ("",	X,	1,	"GL_UNSIGNED_INT_IMAGE_1D"),	# 0x9062
    ("",	X,	1,	"GL_UNSIGNED_INT_IMAGE_2D"),	# 0x9063
    ("",	X,	1,	"GL_UNSIGNED_INT_IMAGE_3D"),	# 0x9064
    ("",	X,	1,	"GL_UNSIGNED_INT_IMAGE_2D_RECT"),	# 0x9065
    ("",	X,	1,	"GL_UNSIGNED_INT_IMAGE_CUBE"),	# 0x9066
    ("",	X,	1,	"GL_UNSIGNED_INT_IMAGE_BUFFER"),	# 0x9067
    ("",	X,	1,	"GL_UNSIGNED_INT_IMAGE_1D_ARRAY"),	# 0x9068
    ("",	X,	1,	"GL_UNSIGNED_INT_IMAGE_2D_ARRAY"),	# 0x9069
    ("",	X,	1,	"GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY"),	# 0x906A
    ("",	X,	1,	"GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE"),	# 0x906B
    ("",	X,	1,	"GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY"),	# 0x906C
    ("glGet",	I,	1,	"GL_MAX_IMAGE_SAMPLES"),	# 0x906D
    ("",	X,	1,	"GL_IMAGE_BINDING_FORMAT"),	# 0x906E
    ("",	X,	1,	"GL_RGB10_A2UI"),	# 0x906F
    ("",	X,	1,	"GL_PATH_FORMAT_SVG_NV"),	# 0x9070
    ("",	X,	1,	"GL_PATH_FORMAT_PS_NV"),	# 0x9071
    ("",	X,	1,	"GL_STANDARD_FONT_NAME_NV"),	# 0x9072
    ("",	X,	1,	"GL_SYSTEM_FONT_NAME_NV"),	# 0x9073
    ("",	X,	1,	"GL_FILE_NAME_NV"),	# 0x9074
    ("",	X,	1,	"GL_PATH_STROKE_WIDTH_NV"),	# 0x9075
    ("",	X,	1,	"GL_PATH_END_CAPS_NV"),	# 0x9076
    ("",	X,	1,	"GL_PATH_INITIAL_END_CAP_NV"),	# 0x9077
    ("",	X,	1,	"GL_PATH_TERMINAL_END_CAP_NV"),	# 0x9078
    ("",	X,	1,	"GL_PATH_JOIN_STYLE_NV"),	# 0x9079
    ("",	X,	1,	"GL_PATH_MITER_LIMIT_NV"),	# 0x907A
    ("",	X,	1,	"GL_PATH_DASH_CAPS_NV"),	# 0x907B
    ("",	X,	1,	"GL_PATH_INITIAL_DASH_CAP_NV"),	# 0x907C
    ("",	X,	1,	"GL_PATH_TERMINAL_DASH_CAP_NV"),	# 0x907D
    ("",	X,	1,	"GL_PATH_DASH_OFFSET_NV"),	# 0x907E
    ("",	X,	1,	"GL_PATH_CLIENT_LENGTH_NV"),	# 0x907F
    ("",	X,	1,	"GL_PATH_FILL_MODE_NV"),	# 0x9080
    ("",	X,	1,	"GL_PATH_FILL_MASK_NV"),	# 0x9081
    ("",	X,	1,	"GL_PATH_FILL_COVER_MODE_NV"),	# 0x9082
    ("",	X,	1,	"GL_PATH_STROKE_COVER_MODE_NV"),	# 0x9083
    ("",	X,	1,	"GL_PATH_STROKE_MASK_NV"),	# 0x9084
    ("",	X,	1,	"GL_PATH_SAMPLE_QUALITY_NV"),	# 0x9085
    ("",	X,	1,	"GL_PATH_STROKE_OVERSAMPLE_COUNT_NV"),	# 0x9087
    ("",	X,	1,	"GL_COUNT_UP_NV"),	# 0x9088
    ("",	X,	1,	"GL_COUNT_DOWN_NV"),	# 0x9089
    ("",	X,	1,	"GL_PATH_OBJECT_BOUNDING_BOX_NV"),	# 0x908A
    ("",	X,	1,	"GL_CONVEX_HULL_NV"),	# 0x908B
    ("",	X,	1,	"GL_MULTI_HULLS_NV"),	# 0x908C
    ("",	X,	1,	"GL_BOUNDING_BOX_NV"),	# 0x908D
    ("",	X,	1,	"GL_TRANSLATE_X_NV"),	# 0x908E
    ("",	X,	1,	"GL_TRANSLATE_Y_NV"),	# 0x908F
    ("",	X,	1,	"GL_TRANSLATE_2D_NV"),	# 0x9090
    ("",	X,	1,	"GL_TRANSLATE_3D_NV"),	# 0x9091
    ("",	X,	1,	"GL_AFFINE_2D_NV"),	# 0x9092
    ("",	X,	1,	"GL_PROJECTIVE_2D_NV"),	# 0x9093
    ("",	X,	1,	"GL_AFFINE_3D_NV"),	# 0x9094
    ("",	X,	1,	"GL_PROJECTIVE_3D_NV"),	# 0x9095
    ("",	X,	1,	"GL_TRANSPOSE_AFFINE_2D_NV"),	# 0x9096
    ("",	X,	1,	"GL_TRANSPOSE_PROJECTIVE_2D_NV"),	# 0x9097
    ("",	X,	1,	"GL_TRANSPOSE_AFFINE_3D_NV"),	# 0x9098
    ("",	X,	1,	"GL_TRANSPOSE_PROJECTIVE_3D_NV"),	# 0x9099
    ("",	X,	1,	"GL_UTF8_NV"),	# 0x909A
    ("",	X,	1,	"GL_UTF16_NV"),	# 0x909B
    ("",	X,	1,	"GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV"),	# 0x909C
    ("",	X,	1,	"GL_PATH_COMMAND_COUNT_NV"),	# 0x909D
    ("",	X,	1,	"GL_PATH_COORD_COUNT_NV"),	# 0x909E
    ("",	X,	1,	"GL_PATH_DASH_ARRAY_COUNT_NV"),	# 0x909F
    ("",	X,	1,	"GL_PATH_COMPUTED_LENGTH_NV"),	# 0x90A0
    ("",	X,	1,	"GL_PATH_FILL_BOUNDING_BOX_NV"),	# 0x90A1
    ("",	X,	1,	"GL_PATH_STROKE_BOUNDING_BOX_NV"),	# 0x90A2
    ("",	X,	1,	"GL_SQUARE_NV"),	# 0x90A3
    ("",	X,	1,	"GL_ROUND_NV"),	# 0x90A4
    ("",	X,	1,	"GL_TRIANGULAR_NV"),	# 0x90A5
    ("",	X,	1,	"GL_BEVEL_NV"),	# 0x90A6
    ("",	X,	1,	"GL_MITER_REVERT_NV"),	# 0x90A7
    ("",	X,	1,	"GL_MITER_TRUNCATE_NV"),	# 0x90A8
    ("",	X,	1,	"GL_SKIP_MISSING_GLYPH_NV"),	# 0x90A9
    ("",	X,	1,	"GL_USE_MISSING_GLYPH_NV"),	# 0x90AA
    ("",	X,	1,	"GL_PATH_ERROR_POSITION_NV"),	# 0x90AB
    ("",	X,	1,	"GL_PATH_FOG_GEN_MODE_NV"),	# 0x90AC
    ("",	X,	1,	"GL_ACCUM_ADJACENT_PAIRS_NV"),	# 0x90AD
    ("",	X,	1,	"GL_ADJACENT_PAIRS_NV"),	# 0x90AE
    ("",	X,	1,	"GL_FIRST_TO_REST_NV"),	# 0x90AF
    ("",	X,	1,	"GL_PATH_GEN_MODE_NV"),	# 0x90B0
    ("",	X,	1,	"GL_PATH_GEN_COEFF_NV"),	# 0x90B1
    ("",	X,	1,	"GL_PATH_GEN_COLOR_FORMAT_NV"),	# 0x90B2
    ("",	X,	1,	"GL_PATH_GEN_COMPONENTS_NV"),	# 0x90B3
    ("",	X,	1,	"GL_PATH_DASH_OFFSET_RESET_NV"),	# 0x90B4
    ("",	X,	1,	"GL_MOVE_TO_RESETS_NV"),	# 0x90B5
    ("",	X,	1,	"GL_MOVE_TO_CONTINUES_NV"),	# 0x90B6
    ("",	X,	1,	"GL_PATH_STENCIL_FUNC_NV"),	# 0x90B7
    ("",	X,	1,	"GL_PATH_STENCIL_REF_NV"),	# 0x90B8
    ("",	X,	1,	"GL_PATH_STENCIL_VALUE_MASK_NV"),	# 0x90B9
    ("",	X,	1,	"GL_SCALED_RESOLVE_FASTEST_EXT"),	# 0x90BA
    ("",	X,	1,	"GL_SCALED_RESOLVE_NICEST_EXT"),	# 0x90BB
    ("",	X,	1,	"GL_MIN_MAP_BUFFER_ALIGNMENT"),	# 0x90BC
    ("",	X,	1,	"GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV"),	# 0x90BD
    ("",	X,	1,	"GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV"),	# 0x90BE
    ("",	X,	1,	"GL_PATH_COVER_DEPTH_FUNC_NV"),	# 0x90BF
    ("",	X,	1,	"GL_IMAGE_FORMAT_COMPATIBILITY_TYPE"),	# 0x90C7
    ("",	X,	1,	"GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE"),	# 0x90C8
    ("",	X,	1,	"GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS"),	# 0x90C9
    ("glGet",	I,	1,	"GL_MAX_VERTEX_IMAGE_UNIFORMS"),	# 0x90CA
    ("glGet",	I,	1,	"GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS"),	# 0x90CB
    ("glGet",	I,	1,	"GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS"),	# 0x90CC
    ("glGet",	I,	1,	"GL_MAX_GEOMETRY_IMAGE_UNIFORMS"),	# 0x90CD
    ("glGet",	I,	1,	"GL_MAX_FRAGMENT_IMAGE_UNIFORMS"),	# 0x90CE
    ("glGet",	I,	1,	"GL_MAX_COMBINED_IMAGE_UNIFORMS"),	# 0x90CF
    ("",	X,	1,	"GL_MAX_DEEP_3D_TEXTURE_WIDTH_HEIGHT_NV"),	# 0x90D0
    ("",	X,	1,	"GL_MAX_DEEP_3D_TEXTURE_DEPTH_NV"),	# 0x90D1
    ("",	I,	1,	"GL_SHADER_STORAGE_BUFFER"),	# 0x90D2
    ("",	I,	1,	"GL_SHADER_STORAGE_BUFFER_BINDING"),	# 0x90D3
    ("",	I,	1,	"GL_SHADER_STORAGE_BUFFER_START"),	# 0x90D4
    ("",	I,	1,	"GL_SHADER_STORAGE_BUFFER_SIZE"),	# 0x90D5
    ("",	I,	1,	"GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS"),	# 0x90D6
    ("",	I,	1,	"GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS"),	# 0x90D7
    ("",	I,	1,	"GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS"),	# 0x90D8
    ("",	I,	1,	"GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS"),	# 0x90D9
    ("",	I,	1,	"GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS"),	# 0x90DA
    ("glGet",	I,	1,	"GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS"),	# 0x90DB
    ("",	I,	1,	"GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS"),	# 0x90DC
    ("",	I,	1,	"GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS"),	# 0x90DD
    ("",	I,	1,	"GL_MAX_SHADER_STORAGE_BLOCK_SIZE"),	# 0x90DE
    ("",	X,	1,	"GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT"),	# 0x90DF
    ("",	X,	1,	"GL_SYNC_X11_FENCE_EXT"),	# 0x90E1
    ("glGetTexParameter",	E,	1,	"GL_DEPTH_STENCIL_TEXTURE_MODE"),	# 0x90EA
    ("glGet",	I,	1,	"GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS"),	# 0x90EB
    ("",	X,	1,	"GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER"),	# 0x90EC
    ("",	X,	1,	"GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER"),	# 0x90ED
    ("",	X,	1,	"GL_DISPATCH_INDIRECT_BUFFER"),	# 0x90EE
    ("glGet",	I,	1,	"GL_DISPATCH_INDIRECT_BUFFER_BINDING"),	# 0x90EF
    ("",	X,	1,	"GL_COLOR_ATTACHMENT_EXT"),	# 0x90F0
    ("",	X,	1,	"GL_MULTIVIEW_EXT"),	# 0x90F1
    ("",	X,	1,	"GL_MAX_MULTIVIEW_BUFFERS_EXT"),	# 0x90F2
    ("",	X,	1,	"GL_CONTEXT_ROBUST_ACCESS_EXT"),	# 0x90F3
    ("",	X,	1,	"GL_COMPUTE_PROGRAM_NV"),	# 0x90FB
    ("",	X,	1,	"GL_COMPUTE_PROGRAM_PARAMETER_BUFFER_NV"),	# 0x90FC
    ("",	X,	1,	"GL_TEXTURE_2D_MULTISAMPLE"),	# 0x9100
    ("",	X,	1,	"GL_PROXY_TEXTURE_2D_MULTISAMPLE"),	# 0x9101
    ("",	X,	1,	"GL_TEXTURE_2D_MULTISAMPLE_ARRAY"),	# 0x9102
    ("",	X,	1,	"GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY"),	# 0x9103
    ("_glGet",	B,	1,	"GL_TEXTURE_BINDING_2D_MULTISAMPLE"),	# 0x9104
    ("_glGet",	I,	1,	"GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY"),	# 0x9105
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_SAMPLES"),	# 0x9106
    ("glGetTexLevelParameter",	B,	1,	"GL_TEXTURE_FIXED_SAMPLE_LOCATIONS"),	# 0x9107
    ("",	X,	1,	"GL_SAMPLER_2D_MULTISAMPLE"),	# 0x9108
    ("",	X,	1,	"GL_INT_SAMPLER_2D_MULTISAMPLE"),	# 0x9109
    ("",	X,	1,	"GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE"),	# 0x910A
    ("",	X,	1,	"GL_SAMPLER_2D_MULTISAMPLE_ARRAY"),	# 0x910B
    ("",	X,	1,	"GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY"),	# 0x910C
    ("",	X,	1,	"GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY"),	# 0x910D
    ("glGet",	I,	1,	"GL_MAX_COLOR_TEXTURE_SAMPLES"),	# 0x910E
    ("glGet",	I,	1,	"GL_MAX_DEPTH_TEXTURE_SAMPLES"),	# 0x910F
    ("glGet",	I,	1,	"GL_MAX_INTEGER_SAMPLES"),	# 0x9110
    ("_glGet",	I64,	1,	"GL_MAX_SERVER_WAIT_TIMEOUT"),	# 0x9111
    ("",	X,	1,	"GL_OBJECT_TYPE"),	# 0x9112
    ("",	X,	1,	"GL_SYNC_CONDITION"),	# 0x9113
    ("",	X,	1,	"GL_SYNC_STATUS"),	# 0x9114
    ("",	X,	1,	"GL_SYNC_FLAGS"),	# 0x9115
    ("",	X,	1,	"GL_SYNC_FENCE"),	# 0x9116
    ("",	X,	1,	"GL_SYNC_GPU_COMMANDS_COMPLETE"),	# 0x9117
    ("",	X,	1,	"GL_UNSIGNALED"),	# 0x9118
    ("",	X,	1,	"GL_SIGNALED"),	# 0x9119
    ("",	X,	1,	"GL_ALREADY_SIGNALED"),	# 0x911A
    ("",	X,	1,	"GL_TIMEOUT_EXPIRED"),	# 0x911B
    ("",	X,	1,	"GL_CONDITION_SATISFIED"),	# 0x911C
    ("",	X,	1,	"GL_WAIT_FAILED"),	# 0x911D
    ("glGetBufferParameter",	I,	1,	"GL_BUFFER_ACCESS_FLAGS"),	# 0x911F
    ("glGetBufferParameter",	I,	1,	"GL_BUFFER_MAP_LENGTH"),	# 0x9120
    ("glGetBufferParameter",	I,	1,	"GL_BUFFER_MAP_OFFSET"),	# 0x9121
    ("glGet",	I,	1,	"GL_MAX_VERTEX_OUTPUT_COMPONENTS"),	# 0x9122
    ("glGet",	I,	1,	"GL_MAX_GEOMETRY_INPUT_COMPONENTS"),	# 0x9123
    ("glGet",	I,	1,	"GL_MAX_GEOMETRY_OUTPUT_COMPONENTS"),	# 0x9124
    ("glGet",	I,	1,	"GL_MAX_FRAGMENT_INPUT_COMPONENTS"),	# 0x9125
    ("glGet",	I,	1,	"GL_CONTEXT_PROFILE_MASK"),	# 0x9126
    ("glGet",	I,	1,	"GL_UNPACK_COMPRESSED_BLOCK_WIDTH"),	# 0x9127
    ("glGet",	I,	1,	"GL_UNPACK_COMPRESSED_BLOCK_HEIGHT"),	# 0x9128
    ("glGet",	I,	1,	"GL_UNPACK_COMPRESSED_BLOCK_DEPTH"),	# 0x9129
    ("glGet",	I,	1,	"GL_UNPACK_COMPRESSED_BLOCK_SIZE"),	# 0x912A
    ("glGet",	I,	1,	"GL_PACK_COMPRESSED_BLOCK_WIDTH"),	# 0x912B
    ("glGet",	I,	1,	"GL_PACK_COMPRESSED_BLOCK_HEIGHT"),	# 0x912C
    ("glGet",	I,	1,	"GL_PACK_COMPRESSED_BLOCK_DEPTH"),	# 0x912D
    ("glGet",	I,	1,	"GL_PACK_COMPRESSED_BLOCK_SIZE"),	# 0x912E
    ("glGetTexParameter",	B,	1,	"GL_TEXTURE_IMMUTABLE_FORMAT"),	# 0x912F
    ("",	X,	1,	"GL_SGX_PROGRAM_BINARY_IMG"),	# 0x9130
    ("",	X,	1,	"GL_RENDERBUFFER_SAMPLES_IMG"),	# 0x9133
    ("",	X,	1,	"GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG"),	# 0x9134
    ("",	X,	1,	"GL_MAX_SAMPLES_IMG"),	# 0x9135
    ("",	X,	1,	"GL_TEXTURE_SAMPLES_IMG"),	# 0x9136
    ("",	X,	1,	"GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG"),	# 0x9137
    ("",	X,	1,	"GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG"),	# 0x9138
    ("glGet",	I,	1,	"GL_MAX_DEBUG_MESSAGE_LENGTH"),	# 0x9143
    ("glGet",	I,	1,	"GL_MAX_DEBUG_LOGGED_MESSAGES"),	# 0x9144
    ("glGet",	I,	1,	"GL_DEBUG_LOGGED_MESSAGES"),	# 0x9145
    ("",	X,	1,	"GL_DEBUG_SEVERITY_HIGH"),	# 0x9146
    ("",	X,	1,	"GL_DEBUG_SEVERITY_MEDIUM"),	# 0x9147
    ("",	X,	1,	"GL_DEBUG_SEVERITY_LOW"),	# 0x9148
    ("",	X,	1,	"GL_DEBUG_CATEGORY_API_ERROR_AMD"),	# 0x9149
    ("",	X,	1,	"GL_DEBUG_CATEGORY_WINDOW_SYSTEM_AMD"),	# 0x914A
    ("",	X,	1,	"GL_DEBUG_CATEGORY_DEPRECATION_AMD"),	# 0x914B
    ("",	X,	1,	"GL_DEBUG_CATEGORY_UNDEFINED_BEHAVIOR_AMD"),	# 0x914C
    ("",	X,	1,	"GL_DEBUG_CATEGORY_PERFORMANCE_AMD"),	# 0x914D
    ("",	X,	1,	"GL_DEBUG_CATEGORY_SHADER_COMPILER_AMD"),	# 0x914E
    ("",	X,	1,	"GL_DEBUG_CATEGORY_APPLICATION_AMD"),	# 0x914F
    ("",	X,	1,	"GL_DEBUG_CATEGORY_OTHER_AMD"),	# 0x9150
    ("",	X,	1,	"GL_BUFFER_OBJECT_EXT"),	# 0x9151
    ("",	X,	1,	"GL_PERFORMANCE_MONITOR_AMD"),	# 0x9152
    ("",	X,	1,	"GL_QUERY_OBJECT_EXT"),	# 0x9153
    ("",	X,	1,	"GL_VERTEX_ARRAY_OBJECT_EXT"),	# 0x9154
    ("",	X,	1,	"GL_SAMPLER_OBJECT_AMD"),	# 0x9155
    ("",	X,	1,	"GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD"),	# 0x9160
    ("",	X,	1,	"GL_QUERY_BUFFER"),	# 0x9192
    ("",	X,	1,	"GL_QUERY_BUFFER_BINDING"),	# 0x9193
    ("",	X,	1,	"GL_QUERY_RESULT_NO_WAIT"),	# 0x9194
    ("",	X,	1,	"GL_VIRTUAL_PAGE_SIZE_X_AMD"),	# 0x9195
    ("",	X,	1,	"GL_VIRTUAL_PAGE_SIZE_Y_AMD"),	# 0x9196
    ("",	X,	1,	"GL_VIRTUAL_PAGE_SIZE_Z_AMD"),	# 0x9197
    ("",	X,	1,	"GL_MAX_SPARSE_TEXTURE_SIZE_AMD"),	# 0x9198
    ("",	X,	1,	"GL_MAX_SPARSE_3D_TEXTURE_SIZE_AMD"),	# 0x9199
    ("",	X,	1,	"GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS"),	# 0x919A
    ("",	X,	1,	"GL_MIN_SPARSE_LEVEL_AMD"),	# 0x919B
    ("",	X,	1,	"GL_MIN_LOD_WARNING_AMD"),	# 0x919C
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_BUFFER_OFFSET"),	# 0x919D
    ("glGetTexLevelParameter",	I,	1,	"GL_TEXTURE_BUFFER_SIZE"),	# 0x919E
    ("glGet",	I,	1,	"GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT"),	# 0x919F
    ("",	X,	1,	"GL_VERTEX_ELEMENT_SWIZZLE_AMD"),	# 0x91A4
    ("",	X,	1,	"GL_VERTEX_ID_SWIZZLE_AMD"),	# 0x91A5
    ("",	X,	1,	"GL_TEXTURE_SPARSE_ARB"),	# 0x91A6
    ("",	X,	1,	"GL_VIRTUAL_PAGE_SIZE_INDEX_ARB"),	# 0x91A7
    ("",	X,	1,	"GL_NUM_VIRTUAL_PAGE_SIZES_ARB"),	# 0x91A8
    ("",	X,	1,	"GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_ARB"),	# 0x91A9
    ("glGetProgramPipeline",	I,	1,	"GL_COMPUTE_SHADER"),	# 0x91B9
    ("glGet",	I,	1,	"GL_MAX_COMPUTE_UNIFORM_BLOCKS"),	# 0x91BB
    ("glGet",	I,	1,	"GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS"),	# 0x91BC
    ("glGet",	I,	1,	"GL_MAX_COMPUTE_IMAGE_UNIFORMS"),	# 0x91BD
    ("glGet",	I,	3,	"GL_MAX_COMPUTE_WORK_GROUP_COUNT"),	# 0x91BE
    ("glGet",	I,	3,	"GL_MAX_COMPUTE_WORK_GROUP_SIZE"),	# 0x91BF
    #("",	X,	1,	"GL_UNPACK_FLIP_Y_WEBGL"),	# 0x9240
    #("",	X,	1,	"GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL"),	# 0x9241
    #("",	X,	1,	"GL_CONTEXT_LOST_WEBGL"),	# 0x9242
    #("",	X,	1,	"GL_UNPACK_COLORSPACE_CONVERSION_WEBGL"),	# 0x9243
    #("",	X,	1,	"GL_BROWSER_DEFAULT_WEBGL"),	# 0x9244
    ("",	X,	1,	"GL_SHADER_BINARY_DMP"),	# 0x9250
    #("",	X,	1,	"GL_GCCSO_SHADER_BINARY_FJ"),	# 0x9260
    ("",	X,	1,	"GL_COMPRESSED_R11_EAC"),	# 0x9270
    ("",	X,	1,	"GL_COMPRESSED_SIGNED_R11_EAC"),	# 0x9271
    ("",	X,	1,	"GL_COMPRESSED_RG11_EAC"),	# 0x9272
    ("",	X,	1,	"GL_COMPRESSED_SIGNED_RG11_EAC"),	# 0x9273
    ("",	X,	1,	"GL_COMPRESSED_RGB8_ETC2"),	# 0x9274
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ETC2"),	# 0x9275
    ("",	X,	1,	"GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"),	# 0x9276
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"),	# 0x9277
    ("",	X,	1,	"GL_COMPRESSED_RGBA8_ETC2_EAC"),	# 0x9278
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"),	# 0x9279
    ("",	X,	1,	"GL_BLEND_PREMULTIPLIED_SRC_NV"),	# 0x9280
    ("",	X,	1,	"GL_BLEND_OVERLAP_NV"),	# 0x9281
    ("",	X,	1,	"GL_UNCORRELATED_NV"),	# 0x9282
    ("",	X,	1,	"GL_DISJOINT_NV"),	# 0x9283
    ("",	X,	1,	"GL_CONJOINT_NV"),	# 0x9284
    ("",	X,	1,	"GL_BLEND_ADVANCED_COHERENT_NV"),	# 0x9285
    ("",	X,	1,	"GL_SRC_NV"),	# 0x9286
    ("",	X,	1,	"GL_DST_NV"),	# 0x9287
    ("",	X,	1,	"GL_SRC_OVER_NV"),	# 0x9288
    ("",	X,	1,	"GL_DST_OVER_NV"),	# 0x9289
    ("",	X,	1,	"GL_SRC_IN_NV"),	# 0x928A
    ("",	X,	1,	"GL_DST_IN_NV"),	# 0x928B
    ("",	X,	1,	"GL_SRC_OUT_NV"),	# 0x928C
    ("",	X,	1,	"GL_DST_OUT_NV"),	# 0x928D
    ("",	X,	1,	"GL_SRC_ATOP_NV"),	# 0x928E
    ("",	X,	1,	"GL_DST_ATOP_NV"),	# 0x928F
    ("",	X,	1,	"GL_PLUS_NV"),	# 0x9291
    ("",	X,	1,	"GL_PLUS_DARKER_NV"),	# 0x9292
    ("",	X,	1,	"GL_MULTIPLY_NV"),	# 0x9294
    ("",	X,	1,	"GL_SCREEN_NV"),	# 0x9295
    ("",	X,	1,	"GL_OVERLAY_NV"),	# 0x9296
    ("",	X,	1,	"GL_DARKEN_NV"),	# 0x9297
    ("",	X,	1,	"GL_LIGHTEN_NV"),	# 0x9298
    ("",	X,	1,	"GL_COLORDODGE_NV"),	# 0x9299
    ("",	X,	1,	"GL_COLORBURN_NV"),	# 0x929A
    ("",	X,	1,	"GL_HARDLIGHT_NV"),	# 0x929B
    ("",	X,	1,	"GL_SOFTLIGHT_NV"),	# 0x929C
    ("",	X,	1,	"GL_DIFFERENCE_NV"),	# 0x929E
    ("",	X,	1,	"GL_MINUS_NV"),	# 0x929F
    ("",	X,	1,	"GL_EXCLUSION_NV"),	# 0x92A0
    ("",	X,	1,	"GL_CONTRAST_NV"),	# 0x92A1
    ("",	X,	1,	"GL_INVERT_RGB_NV"),	# 0x92A3
    ("",	X,	1,	"GL_LINEARDODGE_NV"),	# 0x92A4
    ("",	X,	1,	"GL_LINEARBURN_NV"),	# 0x92A5
    ("",	X,	1,	"GL_VIVIDLIGHT_NV"),	# 0x92A6
    ("",	X,	1,	"GL_LINEARLIGHT_NV"),	# 0x92A7
    ("",	X,	1,	"GL_PINLIGHT_NV"),	# 0x92A8
    ("",	X,	1,	"GL_HARDMIX_NV"),	# 0x92A9
    ("",	X,	1,	"GL_HSL_HUE_NV"),	# 0x92AD
    ("",	X,	1,	"GL_HSL_SATURATION_NV"),	# 0x92AE
    ("",	X,	1,	"GL_HSL_COLOR_NV"),	# 0x92AF
    ("",	X,	1,	"GL_HSL_LUMINOSITY_NV"),	# 0x92B0
    ("",	X,	1,	"GL_PLUS_CLAMPED_NV"),	# 0x92B1
    ("",	X,	1,	"GL_PLUS_CLAMPED_ALPHA_NV"),	# 0x92B2
    ("",	X,	1,	"GL_MINUS_CLAMPED_NV"),	# 0x92B3
    ("",	X,	1,	"GL_INVERT_OVG_NV"),	# 0x92B4
    ("",	X,	1,	"GL_ATOMIC_COUNTER_BUFFER"),	# 0x92C0
    ("",	X,	1,	"GL_ATOMIC_COUNTER_BUFFER_BINDING"),	# 0x92C1
    ("",	X,	1,	"GL_ATOMIC_COUNTER_BUFFER_START"),	# 0x92C2
    ("",	X,	1,	"GL_ATOMIC_COUNTER_BUFFER_SIZE"),	# 0x92C3
    ("",	X,	1,	"GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE"),	# 0x92C4
    ("",	X,	1,	"GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS"),	# 0x92C5
    ("",	X,	1,	"GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES"),	# 0x92C6
    ("",	X,	1,	"GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER"),	# 0x92C7
    ("",	X,	1,	"GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER"),	# 0x92C8
    ("",	X,	1,	"GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER"),	# 0x92C9
    ("",	X,	1,	"GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER"),	# 0x92CA
    ("",	X,	1,	"GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER"),	# 0x92CB
    ("glGet",	I,	1,	"GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS"),	# 0x92CC
    ("glGet",	I,	1,	"GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS"),	# 0x92CD
    ("glGet",	I,	1,	"GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS"),	# 0x92CE
    ("glGet",	I,	1,	"GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS"),	# 0x92CF
    ("glGet",	I,	1,	"GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS"),	# 0x92D0
    ("glGet",	I,	1,	"GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS"),	# 0x92D1
    ("",	X,	1,	"GL_MAX_VERTEX_ATOMIC_COUNTERS"),	# 0x92D2
    ("",	X,	1,	"GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS"),	# 0x92D3
    ("",	X,	1,	"GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS"),	# 0x92D4
    ("",	X,	1,	"GL_MAX_GEOMETRY_ATOMIC_COUNTERS"),	# 0x92D5
    ("",	X,	1,	"GL_MAX_FRAGMENT_ATOMIC_COUNTERS"),	# 0x92D6
    ("",	X,	1,	"GL_MAX_COMBINED_ATOMIC_COUNTERS"),	# 0x92D7
    ("",	X,	1,	"GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE"),	# 0x92D8
    ("",	X,	1,	"GL_ACTIVE_ATOMIC_COUNTER_BUFFERS"),	# 0x92D9
    ("",	X,	1,	"GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX"),	# 0x92DA
    ("",	X,	1,	"GL_UNSIGNED_INT_ATOMIC_COUNTER"),	# 0x92DB
    ("",	X,	1,	"GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS"),	# 0x92DC
    ("glGet",	B,	1,	"GL_DEBUG_OUTPUT"),	# 0x92E0
    ("",	X,	1,	"GL_UNIFORM"),	# 0x92E1
    ("",	X,	1,	"GL_UNIFORM_BLOCK"),	# 0x92E2
    ("",	X,	1,	"GL_PROGRAM_INPUT"),	# 0x92E3
    ("",	X,	1,	"GL_PROGRAM_OUTPUT"),	# 0x92E4
    ("",	X,	1,	"GL_BUFFER_VARIABLE"),	# 0x92E5
    ("",	X,	1,	"GL_SHADER_STORAGE_BLOCK"),	# 0x92E6
    ("",	I,	1,	"GL_IS_PER_PATCH"),	# 0x92E7
    ("",	X,	1,	"GL_VERTEX_SUBROUTINE"),	# 0x92E8
    ("",	X,	1,	"GL_TESS_CONTROL_SUBROUTINE"),	# 0x92E9
    ("",	X,	1,	"GL_TESS_EVALUATION_SUBROUTINE"),	# 0x92EA
    ("",	X,	1,	"GL_GEOMETRY_SUBROUTINE"),	# 0x92EB
    ("",	X,	1,	"GL_FRAGMENT_SUBROUTINE"),	# 0x92EC
    ("",	X,	1,	"GL_COMPUTE_SUBROUTINE"),	# 0x92ED
    ("",	X,	1,	"GL_VERTEX_SUBROUTINE_UNIFORM"),	# 0x92EE
    ("",	X,	1,	"GL_TESS_CONTROL_SUBROUTINE_UNIFORM"),	# 0x92EF
    ("",	X,	1,	"GL_TESS_EVALUATION_SUBROUTINE_UNIFORM"),	# 0x92F0
    ("",	X,	1,	"GL_GEOMETRY_SUBROUTINE_UNIFORM"),	# 0x92F1
    ("",	X,	1,	"GL_FRAGMENT_SUBROUTINE_UNIFORM"),	# 0x92F2
    ("",	X,	1,	"GL_COMPUTE_SUBROUTINE_UNIFORM"),	# 0x92F3
    ("",	X,	1,	"GL_TRANSFORM_FEEDBACK_VARYING"),	# 0x92F4
    ("",	I,	1,	"GL_ACTIVE_RESOURCES"),	# 0x92F5
    ("",	I,	1,	"GL_MAX_NAME_LENGTH"),	# 0x92F6
    ("",	I,	1,	"GL_MAX_NUM_ACTIVE_VARIABLES"),	# 0x92F7
    ("",	I,	1,	"GL_MAX_NUM_COMPATIBLE_SUBROUTINES"),	# 0x92F8
    ("",	I,	1,	"GL_NAME_LENGTH"),	# 0x92F9
    ("",	I,	1,	"GL_TYPE"),	# 0x92FA
    ("",	I,	1,	"GL_ARRAY_SIZE"),	# 0x92FB
    ("",	I,	1,	"GL_OFFSET"),	# 0x92FC
    ("",	I,	1,	"GL_BLOCK_INDEX"),	# 0x92FD
    ("",	I,	1,	"GL_ARRAY_STRIDE"),	# 0x92FE
    ("",	I,	1,	"GL_MATRIX_STRIDE"),	# 0x92FF
    ("",	I,	1,	"GL_IS_ROW_MAJOR"),	# 0x9300
    ("",	I,	1,	"GL_ATOMIC_COUNTER_BUFFER_INDEX"),	# 0x9301
    ("",	I,	1,	"GL_BUFFER_BINDING"),	# 0x9302
    ("",	I,	1,	"GL_BUFFER_DATA_SIZE"),	# 0x9303
    ("",	I,	1,	"GL_NUM_ACTIVE_VARIABLES"),	# 0x9304
    ("",	I,	1,	"GL_ACTIVE_VARIABLES"),	# 0x9305
    ("",	I,	1,	"GL_REFERENCED_BY_VERTEX_SHADER"),	# 0x9306
    ("",	I,	1,	"GL_REFERENCED_BY_TESS_CONTROL_SHADER"),	# 0x9307
    ("",	I,	1,	"GL_REFERENCED_BY_TESS_EVALUATION_SHADER"),	# 0x9308
    ("",	I,	1,	"GL_REFERENCED_BY_GEOMETRY_SHADER"),	# 0x9309
    ("",	I,	1,	"GL_REFERENCED_BY_FRAGMENT_SHADER"),	# 0x930A
    ("",	I,	1,	"GL_REFERENCED_BY_COMPUTE_SHADER"),	# 0x930B
    ("",	I,	1,	"GL_TOP_LEVEL_ARRAY_SIZE"),	# 0x930C
    ("",	I,	1,	"GL_TOP_LEVEL_ARRAY_STRIDE"),	# 0x930D
    ("",	I,	1,	"GL_LOCATION"),	# 0x930E
    ("",	I,	1,	"GL_LOCATION_INDEX"),	# 0x930F
    ("",	I,	1,	"GL_FRAMEBUFFER_DEFAULT_WIDTH"),	# 0x9310
    ("",	I,	1,	"GL_FRAMEBUFFER_DEFAULT_HEIGHT"),	# 0x9311
    ("",	I,	1,	"GL_FRAMEBUFFER_DEFAULT_LAYERS"),	# 0x9312
    ("",	I,	1,	"GL_FRAMEBUFFER_DEFAULT_SAMPLES"),	# 0x9313
    ("",	B,	1,	"GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS"),	# 0x9314
    ("glGet",	I,	1,	"GL_MAX_FRAMEBUFFER_WIDTH"),	# 0x9315
    ("glGet",	I,	1,	"GL_MAX_FRAMEBUFFER_HEIGHT"),	# 0x9316
    ("glGet",	I,	1,	"GL_MAX_FRAMEBUFFER_LAYERS"),	# 0x9317
    ("glGet",	I,	1,	"GL_MAX_FRAMEBUFFER_SAMPLES"),	# 0x9318
    ("",	X,	1,	"GL_MAX_COMPUTE_VARIABLE_GROUP_INVOCATIONS_ARB"),	# 0x9344
    ("",	X,	1,	"GL_MAX_COMPUTE_VARIABLE_GROUP_SIZE_ARB"),	# 0x9345
    ("",	X,	1,	"GL_LOCATION_COMPONENT"),		# 0x934A
    ("",	X,	1,	"GL_TRANSFORM_FEEDBACK_BUFFER_INDEX"),	# 0x934B
    ("",	X,	1,	"GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE"),	# 0x934C
    ("",	X,	1,	"GL_CLEAR_TEXTURE"),			# 0x9365
    ("",	X,	1,	"GL_NUM_SAMPLE_COUNTS"),	# 0x9380
    ("",	X,	1,	"GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE"),	# 0x93A0
    ("",	X,	1,	"GL_BGRA8_EXT"),	# 0x93A1
    ("",	X,	1,	"GL_TEXTURE_USAGE_ANGLE"),	# 0x93A2
    ("",	X,	1,	"GL_FRAMEBUFFER_ATTACHMENT_ANGLE"),	# 0x93A3
    ("",	X,	1,	"GL_PACK_REVERSE_ROW_ORDER_ANGLE"),	# 0x93A4
    ("",	X,	1,	"GL_PROGRAM_BINARY_ANGLE"),	# 0x93A6
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_4x4_KHR"),	# 0x93B0
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_5x4_KHR"),	# 0x93B1
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_5x5_KHR"),	# 0x93B2
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_6x5_KHR"),	# 0x93B3
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_6x6_KHR"),	# 0x93B4
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_8x5_KHR"),	# 0x93B5
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_8x6_KHR"),	# 0x93B6
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_8x8_KHR"),	# 0x93B7
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_10x5_KHR"),	# 0x93B8
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_10x6_KHR"),	# 0x93B9
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_10x8_KHR"),	# 0x93BA
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_10x10_KHR"),	# 0x93BB
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_12x10_KHR"),	# 0x93BC
    ("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_12x12_KHR"),	# 0x93BD
    #("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_3x3x3_OES"),	# 0x93C0
    #("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_4x3x3_OES"),	# 0x93C1
    #("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_4x4x3_OES"),	# 0x93C2
    #("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_4x4x4_OES"),	# 0x93C3
    #("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_5x4x4_OES"),	# 0x93C4
    #("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_5x5x4_OES"),	# 0x93C5
    #("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_5x5x5_OES"),	# 0x93C6
    #("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_6x5x5_OES"),	# 0x93C7
    #("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_6x6x5_OES"),	# 0x93C8
    #("",	X,	1,	"GL_COMPRESSED_RGBA_ASTC_6x6x6_OES"),	# 0x93C9
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"),	# 0x93D0
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"),	# 0x93D1
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"),	# 0x93D2
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"),	# 0x93D3
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"),	# 0x93D4
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"),	# 0x93D5
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"),	# 0x93D6
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"),	# 0x93D7
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"),	# 0x93D8
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"),	# 0x93D9
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"),	# 0x93DA
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"),	# 0x93DB
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"),	# 0x93DC
    ("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"),	# 0x93DD
    #("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES"),	# 0x93E0
    #("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES"),	# 0x93E1
    #("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES"),	# 0x93E2
    #("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES"),	# 0x93E3
    #("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES"),	# 0x93E4
    #("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES"),	# 0x93E5
    #("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES"),	# 0x93E6
    #("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES"),	# 0x93E7
    #("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES"),	# 0x93E8
    #("",	X,	1,	"GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES"),	# 0x93E9
    ("",	X,	1,	"GL_PERFQUERY_COUNTER_EVENT_INTEL"),	# 0x94F0
    ("",	X,	1,	"GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL"),	# 0x94F1
    ("",	X,	1,	"GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL"),	# 0x94F2
    ("",	X,	1,	"GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL"),	# 0x94F3
    ("",	X,	1,	"GL_PERFQUERY_COUNTER_RAW_INTEL"),	# 0x94F4
    ("",	X,	1,	"GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL"),	# 0x94F5
    ("",	X,	1,	"GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL"),	# 0x94F8
    ("",	X,	1,	"GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL"),	# 0x94F9
    ("",	X,	1,	"GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL"),	# 0x94FA
    ("",	X,	1,	"GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL"),	# 0x94FB
    ("",	X,	1,	"GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL"),	# 0x94FC
    ("",	X,	1,	"GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL"),	# 0x94FD
    ("",	X,	1,	"GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL"),	# 0x94FE
    ("",	X,	1,	"GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL"),	# 0x94FF
    ("",	X,	1,	"GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL"),	# 0x9500
    ("_glGet",	B,	1,	"GL_RASTER_POSITION_UNCLIPPED_IBM"),	# 0x19262
    ("",	X,	1,	"GL_PREFER_DOUBLEBUFFER_HINT_PGI"),	# 0x1A1F8
    ("",	X,	1,	"GL_CONSERVE_MEMORY_HINT_PGI"),	# 0x1A1FD
    ("",	X,	1,	"GL_RECLAIM_MEMORY_HINT_PGI"),	# 0x1A1FE
    ("",	X,	1,	"GL_NATIVE_GRAPHICS_HANDLE_PGI"),	# 0x1A202
    ("",	X,	1,	"GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI"),	# 0x1A203
    ("",	X,	1,	"GL_NATIVE_GRAPHICS_END_HINT_PGI"),	# 0x1A204
    ("",	X,	1,	"GL_ALWAYS_FAST_HINT_PGI"),	# 0x1A20C
    ("",	X,	1,	"GL_ALWAYS_SOFT_HINT_PGI"),	# 0x1A20D
    ("",	X,	1,	"GL_ALLOW_DRAW_OBJ_HINT_PGI"),	# 0x1A20E
    ("",	X,	1,	"GL_ALLOW_DRAW_WIN_HINT_PGI"),	# 0x1A20F
    ("",	X,	1,	"GL_ALLOW_DRAW_FRG_HINT_PGI"),	# 0x1A210
    ("",	X,	1,	"GL_ALLOW_DRAW_MEM_HINT_PGI"),	# 0x1A211
    ("",	X,	1,	"GL_STRICT_DEPTHFUNC_HINT_PGI"),	# 0x1A216
    ("",	X,	1,	"GL_STRICT_LIGHTING_HINT_PGI"),	# 0x1A217
    ("",	X,	1,	"GL_STRICT_SCISSOR_HINT_PGI"),	# 0x1A218
    ("",	X,	1,	"GL_FULL_STIPPLE_HINT_PGI"),	# 0x1A219
    ("",	X,	1,	"GL_CLIP_NEAR_HINT_PGI"),	# 0x1A220
    ("",	X,	1,	"GL_CLIP_FAR_HINT_PGI"),	# 0x1A221
    ("",	X,	1,	"GL_WIDE_LINE_HINT_PGI"),	# 0x1A222
    ("",	X,	1,	"GL_BACK_NORMALS_HINT_PGI"),	# 0x1A223
    ("",	X,	1,	"GL_VERTEX_DATA_HINT_PGI"),	# 0x1A22A
    ("",	X,	1,	"GL_VERTEX_CONSISTENT_HINT_PGI"),	# 0x1A22B
    ("",	X,	1,	"GL_MATERIAL_SIDE_HINT_PGI"),	# 0x1A22C
    ("",	X,	1,	"GL_MAX_VERTEX_HINT_PGI"),	# 0x1A22D
    ("",	X,	1,	"GL_CULL_VERTEX_IBM"),	# 0x103050
    ("",	X,	1,	"GL_ALL_STATIC_DATA_IBM"),	# 0x103060
    ("",	X,	1,	"GL_STATIC_VERTEX_ARRAY_IBM"),	# 0x103061
    ("",	X,	1,	"GL_VERTEX_ARRAY_LIST_IBM"),	# 0x103070
    ("",	X,	1,	"GL_NORMAL_ARRAY_LIST_IBM"),	# 0x103071
    ("",	X,	1,	"GL_COLOR_ARRAY_LIST_IBM"),	# 0x103072
    ("",	X,	1,	"GL_INDEX_ARRAY_LIST_IBM"),	# 0x103073
    ("",	X,	1,	"GL_TEXTURE_COORD_ARRAY_LIST_IBM"),	# 0x103074
    ("",	X,	1,	"GL_EDGE_FLAG_ARRAY_LIST_IBM"),	# 0x103075
    ("",	X,	1,	"GL_FOG_COORDINATE_ARRAY_LIST_IBM"),	# 0x103076
    ("",	X,	1,	"GL_SECONDARY_COLOR_ARRAY_LIST_IBM"),	# 0x103077
    ("",	X,	1,	"GL_VERTEX_ARRAY_LIST_STRIDE_IBM"),	# 0x103080
    ("",	X,	1,	"GL_NORMAL_ARRAY_LIST_STRIDE_IBM"),	# 0x103081
    ("",	X,	1,	"GL_COLOR_ARRAY_LIST_STRIDE_IBM"),	# 0x103082
    ("",	X,	1,	"GL_INDEX_ARRAY_LIST_STRIDE_IBM"),	# 0x103083
    ("",	X,	1,	"GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM"),	# 0x103084
    ("",	X,	1,	"GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM"),	# 0x103085
    ("",	X,	1,	"GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM"),	# 0x103086
    ("",	X,	1,	"GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM"),	# 0x103087
    ("",	X,	1,	"GL_INVALID_INDEX"),	# 0xFFFFFFFFu
    #("",	X,	1,	"GL_TIMEOUT_IGNORED"),	# 0xFFFFFFFFFFFFFFFFull
]


# Add all enums to GLenum type descriptor
for _function, _type, _count, _name in parameters:
    GLenum.values.append(_name)


########NEW FILE########
__FILENAME__ = gltypes
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


'''Describe GL types.'''


import platform

from stdapi import *


GLboolean = Enum("GLboolean", [
    "GL_TRUE",
    "GL_FALSE",
])

GLvoid = Alias("GLvoid", Void)
GLbyte = Alias("GLbyte", SChar)
GLshort = Alias("GLshort", Short)
GLint = Alias("GLint", Int)
GLint64 = Alias("GLint64", Int64)
GLubyte = Alias("GLubyte", UChar)
GLushort = Alias("GLushort", UShort)
GLuint = Alias("GLuint", UInt)
GLuint64 = Alias("GLuint64", UInt64)
GLsizei = Alias("GLsizei", Int)
GLintptr = Alias("GLintptr", Int)
GLsizeiptr = Alias("GLsizeiptr", Int)
GLfloat = Alias("GLfloat", Float)
GLclampf = Alias("GLclampf", Float)
GLdouble = Alias("GLdouble", Double)
GLclampd = Alias("GLclampd", Double)
GLchar = Alias("GLchar", Char)

GLcharARB = Alias("GLcharARB", SChar)
GLintptrARB = Alias("GLintptrARB", Int)
GLsizeiptrARB = Alias("GLsizeiptrARB", Int)
GLhandleARB = Handle("handleARB", Alias("GLhandleARB", UInt))
GLhalfARB = Alias("GLhalfARB", UShort)
GLhalfNV = Alias("GLhalfNV", UShort)
GLint64EXT = Alias("GLint64EXT", Int64)
GLuint64EXT = Alias("GLuint64EXT", UInt64)
GLDEBUGPROC = Opaque("GLDEBUGPROC")
GLDEBUGPROCARB = Opaque("GLDEBUGPROCARB")
GLDEBUGPROCAMD = Opaque("GLDEBUGPROCAMD")

GLstring = String(GLchar)
GLstringConst = String(Const(GLchar))
GLstringARB = String(GLcharARB)
GLstringConstARB = String(Const(GLcharARB))

GLpointer = OpaquePointer(GLvoid)
GLpointerConst = OpaquePointer(Const(GLvoid))

GLlist = Handle("list", GLuint)
GLtexture = Handle("texture", GLuint)
GLbuffer = Handle("buffer", GLuint)
GLquery = Handle("query", GLuint)
GLfenceNV = Handle("fenceNV", GLuint)
GLprogram = Handle("program", GLuint)
GLshader = Handle("shader", GLuint)

# Share the same mapping table for uniform locations of both core and
# GL_ARB_shader_objects programs.  For a combination of reasons:
#
# - all OpenGL implementations appear to alias the names for both kind of
#   programs;
#
# - most applications will use only one kind of shader programs;
#
# - some applications actually mix glUniformXxx calls with
#   GL_ARB_shader_objects programs and glUniformXxxARB calls with core
#   programs, and therefore, rely on a joint implementation.
#
# We use GLhandleARB as program key, since it is wider (void *) on MacOSX.
#
GLlocation = Handle("location", GLint, key=('program', GLhandleARB))
GLlocationARB = Handle("location", GLint, key=('programObj', GLhandleARB))

# TODO: Symbolic representation of GL_INVALID_INDEX
GLuniformBlock = Handle("location", GLuint, key=('program', GLprogram))

contextKey = ('reinterpret_cast<uintptr_t>(glretrace::getCurrentContext())', UIntPtr)

GLprogramARB = Handle("programARB", GLuint)
GLframebuffer = Handle("framebuffer", GLuint)
GLrenderbuffer = Handle("renderbuffer", GLuint)
GLfragmentShaderATI = Handle("fragmentShaderATI", GLuint)
GLarray = Handle("array", GLuint, key=contextKey) # per-context
GLarrayAPPLE = Handle("arrayAPPLE", GLuint) # shared
GLregion = Handle("region", GLuint)
GLpipeline = Handle("pipeline", GLuint)
GLsampler = Handle("sampler", GLuint)
GLfeedback = Handle("feedback", GLuint)
GLfence = Handle("fence", GLuint)

# GL mappings are pointers to linear memory regions.
#
# The map length is not always available in the function prototype, and must be
# reconstructed from other state.
GLmap = LinearPointer(GLvoid, "length")

GLsync = Handle("sync", IntPointer("GLsync"))

GLenum = Enum("GLenum", [
    # Parameters are added later from glparams.py's parameter table
])

# Some functions take GLenum disguised as GLint, and need special treatment so
# that symbolic names are traced correctly.
GLenum_int = Alias("GLint", GLenum)

GLenum_mode = FakeEnum(GLenum, [
    "GL_POINTS",                         # 0x0000
    "GL_LINES",                          # 0x0001
    "GL_LINE_LOOP",                      # 0x0002
    "GL_LINE_STRIP",                     # 0x0003
    "GL_TRIANGLES",                      # 0x0004
    "GL_TRIANGLE_STRIP",                 # 0x0005
    "GL_TRIANGLE_FAN",                   # 0x0006
    "GL_QUADS",                          # 0x0007
    "GL_QUAD_STRIP",                     # 0x0008
    "GL_POLYGON",                        # 0x0009
    "GL_LINES_ADJACENCY",                # 0x000A
    "GL_LINE_STRIP_ADJACENCY",           # 0x000B
    "GL_TRIANGLES_ADJACENCY",            # 0x000C
    "GL_TRIANGLE_STRIP_ADJACENCY",       # 0x000D
    "GL_PATCHES",                        # 0x000E
])

GLenum_error = FakeEnum(GLenum, [
    "GL_NO_ERROR",                       # 0x0
    "GL_INVALID_ENUM",                   # 0x0500
    "GL_INVALID_VALUE",                  # 0x0501
    "GL_INVALID_OPERATION",              # 0x0502
    "GL_STACK_OVERFLOW",                 # 0x0503
    "GL_STACK_UNDERFLOW",                # 0x0504
    "GL_OUT_OF_MEMORY",                  # 0x0505
    "GL_INVALID_FRAMEBUFFER_OPERATION",  # 0x0506
    "GL_TABLE_TOO_LARGE",                # 0x8031
])

GLbitfield = Alias("GLbitfield", UInt)

GLbitfield_attrib = Flags(GLbitfield, [
    "GL_ALL_ATTRIB_BITS",     # 0x000FFFFF
    "GL_CURRENT_BIT",         # 0x00000001
    "GL_POINT_BIT",           # 0x00000002
    "GL_LINE_BIT",            # 0x00000004
    "GL_POLYGON_BIT",         # 0x00000008
    "GL_POLYGON_STIPPLE_BIT", # 0x00000010
    "GL_PIXEL_MODE_BIT",      # 0x00000020
    "GL_LIGHTING_BIT",        # 0x00000040
    "GL_FOG_BIT",             # 0x00000080
    "GL_DEPTH_BUFFER_BIT",    # 0x00000100
    "GL_ACCUM_BUFFER_BIT",    # 0x00000200
    "GL_STENCIL_BUFFER_BIT",  # 0x00000400
    "GL_VIEWPORT_BIT",        # 0x00000800
    "GL_TRANSFORM_BIT",       # 0x00001000
    "GL_ENABLE_BIT",          # 0x00002000
    "GL_COLOR_BUFFER_BIT",    # 0x00004000
    "GL_HINT_BIT",            # 0x00008000
    "GL_EVAL_BIT",            # 0x00010000
    "GL_LIST_BIT",            # 0x00020000
    "GL_TEXTURE_BIT",         # 0x00040000
    "GL_SCISSOR_BIT",         # 0x00080000
    "GL_MULTISAMPLE_BIT",     # 0x20000000
])

GLbitfield_client_attrib = Flags(GLbitfield, [
    "GL_CLIENT_ALL_ATTRIB_BITS",  # 0xFFFFFFFF
    "GL_CLIENT_PIXEL_STORE_BIT",  # 0x00000001
    "GL_CLIENT_VERTEX_ARRAY_BIT", # 0x00000002
])

GLbitfield_shader = Flags(GLbitfield, [
    "GL_ALL_SHADER_BITS",                        # 0xFFFFFFFF
    "GL_VERTEX_SHADER_BIT",                      # 0x00000001
    "GL_FRAGMENT_SHADER_BIT",                    # 0x00000002
    "GL_GEOMETRY_SHADER_BIT",                    # 0x00000004
    "GL_TESS_CONTROL_SHADER_BIT",                # 0x00000008
    "GL_TESS_EVALUATION_SHADER_BIT",             # 0x00000010
    "GL_COMPUTE_SHADER_BIT",                     # 0x00000020
])

GLbitfield_access = Flags(GLbitfield, [
    "GL_MAP_READ_BIT",                # 0x0001
    "GL_MAP_WRITE_BIT",               # 0x0002
    "GL_MAP_INVALIDATE_RANGE_BIT",    # 0x0004
    "GL_MAP_INVALIDATE_BUFFER_BIT",   # 0x0008
    "GL_MAP_FLUSH_EXPLICIT_BIT",      # 0x0010
    "GL_MAP_UNSYNCHRONIZED_BIT",      # 0x0020
    "GL_MAP_PERSISTENT_BIT",          # 0x0040
    "GL_MAP_COHERENT_BIT",            # 0x0080
])

GLbitfield_storage = Flags(GLbitfield, [
    "GL_MAP_READ_BIT",                # 0x0001 (existing)
    "GL_MAP_WRITE_BIT",               # 0x0002 (existing)
    "GL_MAP_PERSISTENT_BIT",          # 0x0040
    "GL_MAP_COHERENT_BIT",            # 0x0080
    "GL_DYNAMIC_STORAGE_BIT",         # 0x0100
    "GL_CLIENT_STORAGE_BIT",          # 0x0200
])

GLbitfield_sync_flush = Flags(GLbitfield, [
    "GL_SYNC_FLUSH_COMMANDS_BIT",				# 0x00000001
])

GLbitfield_barrier = Flags(GLbitfield, [
    "GL_ALL_BARRIER_BITS",                      # 0xFFFFFFFF
    "GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT",       # 0x00000001
    "GL_ELEMENT_ARRAY_BARRIER_BIT",             # 0x00000002
    "GL_UNIFORM_BARRIER_BIT",                   # 0x00000004
    "GL_TEXTURE_FETCH_BARRIER_BIT",             # 0x00000008
    "GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV",   # 0x00000010
    "GL_SHADER_IMAGE_ACCESS_BARRIER_BIT",       # 0x00000020
    "GL_COMMAND_BARRIER_BIT",                   # 0x00000040
    "GL_PIXEL_BUFFER_BARRIER_BIT",              # 0x00000080
    "GL_TEXTURE_UPDATE_BARRIER_BIT",            # 0x00000100
    "GL_BUFFER_UPDATE_BARRIER_BIT",             # 0x00000200
    "GL_FRAMEBUFFER_BARRIER_BIT",               # 0x00000400
    "GL_TRANSFORM_FEEDBACK_BARRIER_BIT",        # 0x00000800
    "GL_ATOMIC_COUNTER_BARRIER_BIT",            # 0x00001000
    "GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT",      # 0x00004000
    "GL_QUERY_BUFFER_BARRIER_BIT",              # 0x00008000
])

GLbitfield_metricQueryMask = Flags(GLbitfield, [
    "GL_GLYPH_WIDTH_BIT_NV",                    # 0x01
    "GL_GLYPH_HEIGHT_BIT_NV",                   # 0x02
    "GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV",     # 0x04
    "GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV",     # 0x08
    "GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV", # 0x10
    "GL_GLYPH_VERTICAL_BEARING_X_BIT_NV",       # 0x20
    "GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV",       # 0x40
    "GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV", # 0x80
    "GL_GLYPH_HAS_KERNING_BIT_NV",              # 0x100
    "GL_FONT_X_MIN_BOUNDS_BIT_NV",              # 0x00010000
    "GL_FONT_Y_MIN_BOUNDS_BIT_NV",              # 0x00020000
    "GL_FONT_X_MAX_BOUNDS_BIT_NV",              # 0x00040000
    "GL_FONT_Y_MAX_BOUNDS_BIT_NV",              # 0x00080000
    "GL_FONT_UNITS_PER_EM_BIT_NV",              # 0x00100000
    "GL_FONT_ASCENDER_BIT_NV",                  # 0x00200000
    "GL_FONT_DESCENDER_BIT_NV",                 # 0x00400000
    "GL_FONT_HEIGHT_BIT_NV",                    # 0x00800000
    "GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV",         # 0x01000000
    "GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV",        # 0x02000000
    "GL_FONT_UNDERLINE_POSITION_BIT_NV",        # 0x04000000
    "GL_FONT_UNDERLINE_THICKNESS_BIT_NV",       # 0x08000000
    "GL_FONT_HAS_KERNING_BIT_NV",               # 0x10000000
])

GLbitfield_fontStyle = Flags(GLbitfield, [
    "GL_BOLD_BIT_NV",                           # 0x01
    "GL_ITALIC_BIT_NV",                         # 0x02
])


# GL_ARB_vertex_array_bgra
size_bgra = FakeEnum(GLint, [
    "GL_BGRA",
])


def GLindexBuffer(countExpr, typeExpr):
    # Indices arguments are polymorphic:
    # - offsets when element array buffer is bound
    # - or a blob otherwise.
    sizeExpr = '%s*_gl_type_size(%s)' % (countExpr, typeExpr)
    return Polymorphic('_element_array_buffer_binding()', [
            ('0', Blob(Const(GLvoid), sizeExpr)),
        ],
        IntPointer("const GLvoid *"), 
        contextLess=False,
    )

# Polymorphic object name
def GLname(targetExpr):
    return Polymorphic(targetExpr, [
        ('GL_BUFFER', GLbuffer),
        ('GL_SHADER', GLshader),
        ('GL_PROGRAM', GLprogram),
        ('GL_VERTEX_ARRAY', GLarray),
        ('GL_QUERY', GLquery),
        ('GL_PROGRAM_PIPELINE', GLpipeline),
        ('GL_TRANSFORM_FEEDBACK', GLuint),
        ('GL_SAMPLER', GLsampler),
        ('GL_TEXTURE', GLtexture),
        ('GL_TEXTURE_1D', GLtexture),
        ('GL_TEXTURE_1D_ARRAY', GLtexture),
        ('GL_TEXTURE_2D', GLtexture),
        ('GL_TEXTURE_2D_MULTISAMPLE', GLtexture),
        ('GL_TEXTURE_2D_ARRAY', GLtexture),
        ('GL_TEXTURE_RECTANGLE', GLtexture),
        ('GL_TEXTURE_CUBE_MAP', GLtexture),
        ('GL_TEXTURE_CUBE_MAP_POSITIVE_X', GLtexture),
        ('GL_TEXTURE_CUBE_MAP_NEGATIVE_X', GLtexture),
        ('GL_TEXTURE_CUBE_MAP_POSITIVE_Y', GLtexture),
        ('GL_TEXTURE_CUBE_MAP_NEGATIVE_Y', GLtexture),
        ('GL_TEXTURE_CUBE_MAP_POSITIVE_Z', GLtexture),
        ('GL_TEXTURE_CUBE_MAP_NEGATIVE_Z', GLtexture),
        ('GL_TEXTURE_CUBE_MAP_ARRAY', GLtexture),
        ('GL_TEXTURE_3D', GLtexture),
        ('GL_RENDERBUFFER', GLrenderbuffer),
        ('GL_FRAMEBUFFER', GLframebuffer),
        ('GL_DISPLAY_LIST', GLlist),
        ('GL_FENCE_APPLE', GLfence),
        ('GL_DRAW_PIXELS_APPLE', GLuint), # GL_APPLE_fence
    ], GLuint)


# GL_AMD_performance_monitor
GLperfMonitorCounterInfoAMD = Polymorphic('pname', [
        ('GL_COUNTER_TYPE_AMD', Pointer(GLenum)),
        ('GL_PERCENTAGE_AMD', Pointer(Float)),
        ('GL_COUNTER_RANGE_AMD', Array(Float, 2)),
    ],
    OpaquePointer(GLvoid),
)

# GL_AMD_sparse_texture
GLbitfield_texStorageSparse = Flags(GLbitfield, [
    'GL_TEXTURE_STORAGE_SPARSE_BIT_AMD', # 0x00000001
])

# GL_NV_vdpau_interop
GLvdpauSurfaceNV = Alias('GLvdpauSurfaceNV', GLintptr)

########NEW FILE########
__FILENAME__ = glxapi
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""GLX API description."""


from stdapi import *
from glapi import *

VisualID = Alias("VisualID", UInt32)
Display = Opaque("Display *")
Visual = Opaque("Visual *")
Font = Alias("Font", UInt32)
Pixmap = Alias("Pixmap", UInt32)
Window = Alias("Window", UInt32)
Colormap = Alias("Colormap", UInt32)

GLXContext = Opaque("GLXContext")
GLXPixmap = Alias("GLXPixmap", UInt32)
GLXDrawable = Alias("GLXDrawable", UInt32)
GLXFBConfig = Opaque("GLXFBConfig")
GLXFBConfigSGIX = Opaque("GLXFBConfigSGIX")
GLXFBConfigID = Alias("GLXFBConfigID", UInt32)
GLXContextID = Alias("GLXContextID", UInt32)
GLXWindow = Alias("GLXWindow", UInt32)
GLXPbuffer = Alias("GLXPbuffer", UInt32)
GLXPbufferSGIX = Alias("GLXPbufferSGIX", UInt32)
GLXVideoSourceSGIX = Alias("GLXVideoSourceSGIX", UInt32)
GLXVideoDeviceNV = Alias("GLXVideoDeviceNV", UInt32)
GLXVideoCaptureDeviceNV = Alias("GLXVideoCaptureDeviceNV", UInt32)

XVisualInfo = Struct("XVisualInfo", [
  (Visual, "visual"),
  (VisualID, "visualid"),
  (Int, "screen"),
  (Int, "depth"),
  (Int, "c_class"),
  (ULong, "red_mask"),
  (ULong, "green_mask"),
  (ULong, "blue_mask"),
  (Int, "colormap_size"),
  (Int, "bits_per_rgb"),
])

Bool = FakeEnum(Int, [
    "False",
    "True",
])

GLXEnum = FakeEnum(Int, [
    #"GLX_USE_GL", 		# 1
    "GLX_BUFFER_SIZE", 		# 2
    "GLX_LEVEL", 		# 3
    "GLX_RGBA", 		# 4
    "GLX_DOUBLEBUFFER", 	# 5
    "GLX_STEREO", 		# 6
    "GLX_AUX_BUFFERS", 		# 7
    "GLX_RED_SIZE", 		# 8
    "GLX_GREEN_SIZE", 		# 9
    "GLX_BLUE_SIZE", 		# 10
    "GLX_ALPHA_SIZE", 		# 11
    "GLX_DEPTH_SIZE", 		# 12
    "GLX_STENCIL_SIZE", 	# 13
    "GLX_ACCUM_RED_SIZE", 	# 14
    "GLX_ACCUM_GREEN_SIZE", 	# 15
    "GLX_ACCUM_BLUE_SIZE", 	# 16
    "GLX_ACCUM_ALPHA_SIZE", 	# 17

    "GLX_CONFIG_CAVEAT",		# 0x0020
    "GLX_X_VISUAL_TYPE",		# 0x0022
    "GLX_TRANSPARENT_TYPE",		# 0x0023
    "GLX_TRANSPARENT_INDEX_VALUE",		# 0x0024
    "GLX_TRANSPARENT_RED_VALUE",		# 0x0025
    "GLX_TRANSPARENT_GREEN_VALUE",		# 0x0026
    "GLX_TRANSPARENT_BLUE_VALUE",		# 0x0027
    "GLX_TRANSPARENT_ALPHA_VALUE",		# 0x0028
    "GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX",		# 0x0050
    "GLX_BAD_HYPERPIPE_CONFIG_SGIX",		# 0x005B
    "GLX_BAD_HYPERPIPE_SGIX",		# 0x005C
    "GLX_GPU_VENDOR_AMD",		# 0x1F00
    "GLX_GPU_RENDERER_STRING_AMD",		# 0x1F01
    "GLX_GPU_OPENGL_VERSION_STRING_AMD",		# 0x1F02
    "GLX_CONTEXT_MAJOR_VERSION_ARB",		# 0x2091
    "GLX_CONTEXT_MINOR_VERSION_ARB",		# 0x2092
    "GLX_CONTEXT_FLAGS_ARB",		# 0x2094
    "GLX_CONTEXT_ALLOW_BUFFER_BYTE_ORDER_MISMATCH_ARB",		# 0x2095
    "GLX_FLOAT_COMPONENTS_NV",		# 0x20B0
    "GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT",		# 0x20B1
    "GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB",		# 0x20B2
    "GLX_COLOR_SAMPLES_NV",		# 0x20B3
    "GLX_RGBA_FLOAT_TYPE_ARB",		# 0x20B9
    "GLX_VIDEO_OUT_COLOR_NV",		# 0x20C3
    "GLX_VIDEO_OUT_ALPHA_NV",		# 0x20C4
    "GLX_VIDEO_OUT_DEPTH_NV",		# 0x20C5
    "GLX_VIDEO_OUT_COLOR_AND_ALPHA_NV",		# 0x20C6
    "GLX_VIDEO_OUT_COLOR_AND_DEPTH_NV",		# 0x20C7
    "GLX_VIDEO_OUT_FRAME_NV",		# 0x20C8
    "GLX_VIDEO_OUT_FIELD_1_NV",		# 0x20C9
    "GLX_VIDEO_OUT_FIELD_2_NV",		# 0x20CA
    "GLX_VIDEO_OUT_STACKED_FIELDS_1_2_NV",		# 0x20CB
    "GLX_VIDEO_OUT_STACKED_FIELDS_2_1_NV",		# 0x20CC
    "GLX_DEVICE_ID_NV",		# 0x20CD
    "GLX_UNIQUE_ID_NV",		# 0x20CE
    "GLX_NUM_VIDEO_CAPTURE_SLOTS_NV",		# 0x20CF
    "GLX_BIND_TO_TEXTURE_RGB_EXT",		# 0x20D0
    "GLX_BIND_TO_TEXTURE_RGBA_EXT",		# 0x20D1
    "GLX_BIND_TO_MIPMAP_TEXTURE_EXT",		# 0x20D2
    "GLX_BIND_TO_TEXTURE_TARGETS_EXT",		# 0x20D3
    "GLX_Y_INVERTED_EXT",		# 0x20D4
    "GLX_TEXTURE_FORMAT_EXT",		# 0x20D5
    "GLX_TEXTURE_TARGET_EXT",		# 0x20D6
    "GLX_MIPMAP_TEXTURE_EXT",		# 0x20D7
    "GLX_TEXTURE_FORMAT_NONE_EXT",		# 0x20D8
    "GLX_TEXTURE_FORMAT_RGB_EXT",		# 0x20D9
    "GLX_TEXTURE_FORMAT_RGBA_EXT",		# 0x20DA
    "GLX_TEXTURE_1D_EXT",		# 0x20DB
    "GLX_TEXTURE_2D_EXT",		# 0x20DC
    "GLX_TEXTURE_RECTANGLE_EXT",		# 0x20DD
    "GLX_FRONT_LEFT_EXT",		# 0x20DE
    "GLX_FRONT_RIGHT_EXT",		# 0x20DF
    "GLX_BACK_LEFT_EXT",		# 0x20E0
    "GLX_BACK_RIGHT_EXT",		# 0x20E1
    "GLX_AUX0_EXT",		# 0x20E2
    "GLX_AUX1_EXT",		# 0x20E3
    "GLX_AUX2_EXT",		# 0x20E4
    "GLX_AUX3_EXT",		# 0x20E5
    "GLX_AUX4_EXT",		# 0x20E6
    "GLX_AUX5_EXT",		# 0x20E7
    "GLX_AUX6_EXT",		# 0x20E8
    "GLX_AUX7_EXT",		# 0x20E9
    "GLX_AUX8_EXT",		# 0x20EA
    "GLX_AUX9_EXT",		# 0x20EB
    "GLX_NUM_VIDEO_SLOTS_NV",		# 0x20F0
    "GLX_SWAP_INTERVAL_EXT",		# 0x20F1
    "GLX_MAX_SWAP_INTERVAL_EXT",		# 0x20F2
    "GLX_LATE_SWAPS_TEAR_EXT",		# 0x20F3
    "GLX_BACK_BUFFER_AGE_EXT",		# 0x20F4
    "GLX_STEREO_TREE_EXT",		# 0x20F5
    "GLX_GPU_FASTEST_TARGET_GPUS_AMD",		# 0x21A2
    "GLX_GPU_RAM_AMD",		# 0x21A3
    "GLX_GPU_CLOCK_AMD",		# 0x21A4
    "GLX_GPU_NUM_PIPES_AMD",		# 0x21A5
    "GLX_GPU_NUM_SIMD_AMD",		# 0x21A6
    "GLX_GPU_NUM_RB_AMD",		# 0x21A7
    "GLX_GPU_NUM_SPI_AMD",		# 0x21A8
    "GLX_NONE",		# 0x8000
    "GLX_SLOW_CONFIG",		# 0x8001
    "GLX_TRUE_COLOR",		# 0x8002
    "GLX_DIRECT_COLOR",		# 0x8003
    "GLX_PSEUDO_COLOR",		# 0x8004
    "GLX_STATIC_COLOR",		# 0x8005
    "GLX_GRAY_SCALE",		# 0x8006
    "GLX_STATIC_GRAY",		# 0x8007
    "GLX_TRANSPARENT_RGB",		# 0x8008
    "GLX_TRANSPARENT_INDEX",		# 0x8009
    "GLX_SHARE_CONTEXT_EXT",		# 0x800A
    "GLX_VISUAL_ID",		# 0x800B
    "GLX_SCREEN",		# 0x800C
    "GLX_NON_CONFORMANT_CONFIG",		# 0x800D
    "GLX_DRAWABLE_TYPE",		# 0x8010
    "GLX_RENDER_TYPE",		# 0x8011
    "GLX_X_RENDERABLE",		# 0x8012
    "GLX_FBCONFIG_ID",		# 0x8013
    "GLX_RGBA_TYPE",		# 0x8014
    "GLX_COLOR_INDEX_TYPE",		# 0x8015
    "GLX_MAX_PBUFFER_WIDTH",		# 0x8016
    "GLX_MAX_PBUFFER_HEIGHT",		# 0x8017
    "GLX_MAX_PBUFFER_PIXELS",		# 0x8018
    "GLX_OPTIMAL_PBUFFER_WIDTH_SGIX",		# 0x8019
    "GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX",		# 0x801A
    "GLX_PRESERVED_CONTENTS",		# 0x801B
    "GLX_LARGEST_PBUFFER",		# 0x801C
    "GLX_WIDTH",		# 0x801D
    "GLX_HEIGHT",		# 0x801E
    "GLX_EVENT_MASK",		# 0x801F
    "GLX_DAMAGED",		# 0x8020
    "GLX_SAVED",		# 0x8021
    "GLX_WINDOW",		# 0x8022
    "GLX_PBUFFER",		# 0x8023
    #"GLX_DIGITAL_MEDIA_PBUFFER_SGIX",		# 0x8024
    "GLX_BLENDED_RGBA_SGIS",		# 0x8025
    "GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS",		# 0x8026
    "GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS",		# 0x8027
    "GLX_VISUAL_SELECT_GROUP_SGIX",		# 0x8028
    "GLX_HYPERPIPE_ID_SGIX",		# 0x8030
    "GLX_PBUFFER_HEIGHT",		# 0x8040
    "GLX_PBUFFER_WIDTH",		# 0x8041
    "GLX_SAMPLE_BUFFERS_3DFX",		# 0x8050
    "GLX_SAMPLES_3DFX",		# 0x8051
    "GLX_SWAP_METHOD_OML",		# 0x8060
    "GLX_SWAP_EXCHANGE_OML",		# 0x8061
    "GLX_SWAP_COPY_OML",		# 0x8062
    "GLX_SWAP_UNDEFINED_OML",		# 0x8063
    "GLX_EXCHANGE_COMPLETE_INTEL",		# 0x8180
    "GLX_COPY_COMPLETE_INTEL",		# 0x8181
    "GLX_FLIP_COMPLETE_INTEL",		# 0x8182
    "GLX_RENDERER_VENDOR_ID_MESA",		# 0x8183
    "GLX_RENDERER_DEVICE_ID_MESA",		# 0x8184
    "GLX_RENDERER_VERSION_MESA",		# 0x8185
    "GLX_RENDERER_ACCELERATED_MESA",		# 0x8186
    "GLX_RENDERER_VIDEO_MEMORY_MESA",		# 0x8187
    "GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA",		# 0x8188
    "GLX_RENDERER_PREFERRED_PROFILE_MESA",		# 0x8189
    "GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA",		# 0x818A
    "GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA",		# 0x818B
    "GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA",		# 0x818C
    "GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA",		# 0x818D
    "GLX_RENDERER_ID_MESA",		# 0x818E
    "GLX_LOSE_CONTEXT_ON_RESET_ARB",		# 0x8252
    "GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB",		# 0x8256
    "GLX_NO_RESET_NOTIFICATION_ARB",		# 0x8261
    "GLX_CONTEXT_PROFILE_MASK_ARB",		# 0x9126
    "GLX_SAMPLE_BUFFERS",		# 0x186A0
    "GLX_SAMPLES",		# 0x186A1
    "GLX_DONT_CARE",		# 0xFFFFFFFF
])

GLXError = FakeEnum(Int, [
    "GLX_BAD_SCREEN",
    "GLX_BAD_ATTRIBUTE",
    "GLX_NO_EXTENSION",
    "GLX_BAD_VISUAL",
    "GLX_BAD_CONTEXT",
    "GLX_BAD_VALUE",
    "GLX_BAD_ENUM",
])

GLXname = FakeEnum(Int, [
    "GLX_VENDOR",
    "GLX_VERSION",
    "GLX_EXTENSIONS",
])

GLXbuffer = Flags(Int, [
    "GLX_WINDOW_BIT",
    "GLX_PIXMAP_BIT",
    "GLX_PBUFFER_BIT",
    "GLX_AUX_BUFFERS_BIT",
    "GLX_FRONT_LEFT_BUFFER_BIT",
    "GLX_FRONT_RIGHT_BUFFER_BIT",
    "GLX_BACK_LEFT_BUFFER_BIT",
    "GLX_BACK_RIGHT_BUFFER_BIT",
    "GLX_DEPTH_BUFFER_BIT",
    "GLX_STENCIL_BUFFER_BIT",
    "GLX_ACCUM_BUFFER_BIT",
])

GLXbuffer = Flags(Int, [
    "GLX_RGBA_BIT",
    "GLX_COLOR_INDEX_BIT",
    "GLX_PBUFFER_CLOBBER_MASK",
])

UnusedAttribs = AttribArray(Const(GLXEnum), [])

GLXCommonSizeAttribs = [
    ('GLX_RED_SIZE', UInt),
    ('GLX_GREEN_SIZE', UInt),
    ('GLX_BLUE_SIZE', UInt),
    ('GLX_ALPHA_SIZE', UInt),
    ('GLX_DEPTH_SIZE', UInt),
    ('GLX_STENCIL_SIZE', UInt),
    ('GLX_ACCUM_RED_SIZE', UInt),
    ('GLX_ACCUM_GREEN_SIZE', UInt),
    ('GLX_ACCUM_BLUE_SIZE', UInt),
    ('GLX_ACCUM_ALPHA_SIZE', UInt)
]

GLXVisualAttribs = AttribArray(GLXEnum, GLXCommonSizeAttribs + [
    ('GLX_USE_GL', None),
    ('GLX_BUFFER_SIZE', UInt),
    ('GLX_LEVEL', Int),
    ('GLX_RGBA', None),
    ('GLX_DOUBLEBUFFER', None),
    ('GLX_STEREO', None),
    ('GLX_AUX_BUFFERS', UInt),
    ('GLX_SAMPLE_BUFFERS', UInt),
    ('GLX_SAMPLES', UInt)],
)

GLXFBConfigCommonAttribs = GLXCommonSizeAttribs + [
    ('GLX_BUFFER_SIZE', UInt),
    ('GLX_LEVEL', Int),
    ('GLX_DOUBLEBUFFER', Bool),
    ('GLX_STEREO', Bool),
    ('GLX_AUX_BUFFERS', UInt),
    ('GLX_SAMPLE_BUFFERS', UInt),
    ('GLX_SAMPLES', UInt),
    ('GLX_RENDER_TYPE', Flags(Int, ["GLX_RGBA_BIT", "GLX_COLOR_INDEX_BIT"])),
    ('GLX_DRAWABLE_TYPE', Flags(Int, ["GLX_WINDOW_BIT", "GLX_PIXMAP_BIT", "GLX_PBUFFER_BIT"])),
    ('GLX_X_RENDERABLE', Bool),
    ('GLX_X_VISUAL_TYPE', FakeEnum(Int, ["GLX_TRUE_COLOR", "GLX_DIRECT_COLOR", "GLX_PSEUDO_COLOR", "GLX_STATIC_COLOR"])),
    ('GLX_CONFIG_CAVEAT', FakeEnum(Int, ["GLX_NONE", "GLX_SLOW_CONFIG", "GLX_NON_CONFORMANT_CONFIG"])),
    ('GLX_TRANSPARENT_TYPE', FakeEnum(Int, ["GLX_NONE", "GLX_TRANSPARENT_RGB", "GLX_TRANSPARENT_INDEX"])),
    ('GLX_TRANSPARENT_INDEX_VALUE', Int),
    ('GLX_TRANSPARENT_RED_VALUE', Int),
    ('GLX_TRANSPARENT_GREEN_VALUE', Int),
    ('GLX_TRANSPARENT_BLUE_VALUE', Int),
    ('GLX_TRANSPARENT_ALPHA_VALUE', Int)
]

GLXFBConfigGLXAttribs = GLXFBConfigCommonAttribs + [
    ('GLX_FBCONFIG_ID', Int), # an XID, can we do better than int?
    ('GLX_MAX_PBUFFER_WIDTH', Int),
    ('GLX_MAX_PBUFFER_HEIGHT', Int),
    ('GLX_MAX_PBUFFER_PIXELS', Int),
    ('GLX_VISUAL_ID', Int)  # another XID
]

GLXFBConfigAttribs = AttribArray(Const(GLXEnum), GLXFBConfigGLXAttribs)
GLXFBConfigSGIXAttribs = AttribArray(GLXEnum, GLXFBConfigCommonAttribs)

GLXContextARBAttribs = AttribArray(Const(GLXEnum), [
    ('GLX_RENDER_TYPE', Flags(Int, ["GLX_RGBA_BIT", "GLX_COLOR_INDEX_BIT"])),
    ('GLX_CONTEXT_MAJOR_VERSION_ARB', Int),
    ('GLX_CONTEXT_MINOR_VERSION_ARB', Int),
    ('GLX_CONTEXT_FLAGS_ARB', Flags(Int, ["GLX_CONTEXT_DEBUG_BIT_ARB", "GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB", "GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB"])),
    ('GLX_CONTEXT_PROFILE_MASK_ARB', Flags(Int, ["GLX_CONTEXT_CORE_PROFILE_BIT_ARB", "GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB"])),
    ('GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB', GLXEnum),
])

GLXPbufferAttribs = AttribArray(Const(GLXEnum), [
    ('GLX_PBUFFER_WIDTH', Int),
    ('GLX_PBUFFER_HEIGHT', Int),
    ('GLX_LARGEST_PBUFFER', Bool),
    ('GLX_PRESERVED_CONTENTS', Bool)
])

GLXPbufferSGIXAttribs = AttribArray(GLXEnum, [
    ('GLX_PRESERVED_CONTENTS_SGIX', Bool),
    ('GLX_LARGEST_PBUFFER', Bool),
    #('GLX_DIGITAL_MEDIA_PBUFFER_SGIX', Bool),
])

glxapi = Module("GLX")

PROC = Opaque("__GLXextFuncPtr")

glxapi.addFunctions([
    # GLX
    Function(Pointer(XVisualInfo), "glXChooseVisual", [(Display, "dpy"), (Int, "screen"), (GLXVisualAttribs, "attribList")]),
    Function(GLXContext, "glXCreateContext", [(Display, "dpy"), (Pointer(XVisualInfo), "vis"), (GLXContext, "shareList"), (Bool, "direct")]),
    Function(Void, "glXDestroyContext",  [(Display, "dpy"), (GLXContext, "ctx")]),
    Function(Bool, "glXMakeCurrent", [(Display, "dpy"), (GLXDrawable, "drawable"), (GLXContext, "ctx")]),
    Function(Void, "glXCopyContext", [(Display, "dpy"), (GLXContext, "src"), (GLXContext, "dst"),
                                      (ULong, "mask")]),
    Function(Void, "glXSwapBuffers", [(Display, "dpy"), (GLXDrawable, "drawable")]),
    Function(GLXPixmap, "glXCreateGLXPixmap", [(Display, "dpy"), (Pointer(XVisualInfo), "visual"),
                                               (Pixmap, "pixmap")]),
    Function(Void, "glXDestroyGLXPixmap", [(Display, "dpy"), (GLXPixmap, "pixmap")]),
    Function(Bool, "glXQueryExtension", [(Display, "dpy"), Out(Pointer(Int), "errorb"), Out(Pointer(Int), "event")]),
    Function(Bool, "glXQueryVersion", [(Display, "dpy"), Out(Pointer(Int), "maj"), Out(Pointer(Int), "min")]),
    Function(Bool, "glXIsDirect", [(Display, "dpy"), (GLXContext, "ctx")]),
    Function(GLXError, "glXGetConfig", [(Display, "dpy"), (Pointer(XVisualInfo), "visual"),
                                    (GLXEnum, "attrib"), Out(Pointer(Int), "value")]),
    Function(GLXContext, "glXGetCurrentContext", [], sideeffects=False),
    Function(GLXDrawable, "glXGetCurrentDrawable", [], sideeffects=False),
    Function(Void, "glXWaitGL", []),
    Function(Void, "glXWaitX", []),
    Function(Void, "glXUseXFont", [(Font, "font"), (Int, "first"), (Int, "count"), (Int, "list")]),

    # GLX 1.1 and later
    Function((ConstCString), "glXQueryExtensionsString", [(Display, "dpy"), (Int, "screen")], sideeffects=False),
    Function((ConstCString), "glXQueryServerString",  [(Display, "dpy"), (Int, "screen"), (GLXname, "name")], sideeffects=False),
    Function((ConstCString), "glXGetClientString", [(Display, "dpy"), (GLXname, "name")], sideeffects=False),

    # GLX 1.2 and later
    Function(Display, "glXGetCurrentDisplay", [], sideeffects=False),

    # GLX 1.3 and later
    Function(Array(GLXFBConfig, "*nitems"), "glXChooseFBConfig", [(Display, "dpy"), (Int, "screen"), (GLXFBConfigAttribs, "attribList"), Out(Pointer(Int), "nitems")]),
    Function(Int, "glXGetFBConfigAttrib", [(Display, "dpy"), (GLXFBConfig, "config"), (GLXEnum, "attribute"), Out(Pointer(Int), "value")]),
    Function(Array(GLXFBConfig, "*nelements"), "glXGetFBConfigs", [(Display, "dpy"), (Int, "screen"), 
                                                                   Out(Pointer(Int), "nelements")]),
    Function(Pointer(XVisualInfo), "glXGetVisualFromFBConfig", [(Display, "dpy"),
                                                                (GLXFBConfig, "config")]),
    Function(GLXWindow, "glXCreateWindow", [(Display, "dpy"), (GLXFBConfig, "config"),
                                            (Window, "win"), (UnusedAttribs, "attribList")]),
    Function(Void, "glXDestroyWindow", [(Display, "dpy"), (GLXWindow, "window")]),
    Function(GLXPixmap, "glXCreatePixmap", [(Display, "dpy"), (GLXFBConfig, "config"),
                                            (Pixmap, "pixmap"), (UnusedAttribs, "attribList")]),
    Function(Void, "glXDestroyPixmap", [(Display, "dpy"), (GLXPixmap, "pixmap")]),
    Function(GLXPbuffer, "glXCreatePbuffer", [(Display, "dpy"), (GLXFBConfig, "config"),
                                              (GLXPbufferAttribs, "attribList")]),
    Function(Void, "glXDestroyPbuffer", [(Display, "dpy"), (GLXPbuffer, "pbuf")]),
    Function(Void, "glXQueryDrawable", [(Display, "dpy"), (GLXDrawable, "draw"), (GLXEnum, "attribute"),
                                        Out(Pointer(UInt), "value")]),
    Function(GLXContext, "glXCreateNewContext", [(Display, "dpy"), (GLXFBConfig, "config"),
                                                 (GLXEnum, "renderType"), (GLXContext, "shareList"),
                                                 (Bool, "direct")]),
    Function(Bool, "glXMakeContextCurrent", [(Display, "dpy"), (GLXDrawable, "draw"),
                                             (GLXDrawable, "read"), (GLXContext, "ctx")]),
    Function(GLXDrawable, "glXGetCurrentReadDrawable", []),
    Function(Int, "glXQueryContext", [(Display, "dpy"), (GLXContext, "ctx"), (GLXEnum, "attribute"),
                                      Out(Pointer(Int), "value")]),
    Function(Void, "glXSelectEvent", [(Display, "dpy"), (GLXDrawable, "drawable"),
                                      (ULong, "mask")]),
    Function(Void, "glXGetSelectedEvent", [(Display, "dpy"), (GLXDrawable, "drawable"),
                                           Out(Pointer(ULong), "mask")]),

    # GLX_ARB_create_context
    Function(GLXContext, "glXCreateContextAttribsARB", [(Display, "dpy"), (GLXFBConfig, "config"),
                                                        (GLXContext, "share_context"), (Bool, "direct"),
                                                        (GLXContextARBAttribs,  "attrib_list")]),

    # GLX_SGI_swap_control
    Function(Int, "glXSwapIntervalSGI", [(Int, "interval")]),

    # GLX_SGI_video_sync
    Function(Int, "glXGetVideoSyncSGI", [(OpaquePointer(UInt), "count")]),
    Function(Int, "glXWaitVideoSyncSGI", [(Int, "divisor"), (Int, "remainder"), (OpaquePointer(UInt), "count")]),

    # GLX_SGI_make_current_read
    Function(Bool, "glXMakeCurrentReadSGI", [(Display, "dpy"), (GLXDrawable, "draw"), (GLXDrawable, "read"), (GLXContext, "ctx")]),
    Function(GLXDrawable, "glXGetCurrentReadDrawableSGI", []),

    # GLX_SGIX_video_source
    #Function(GLXVideoSourceSGIX, "glXCreateGLXVideoSourceSGIX", [(Display, "display"), (Int, "screen"), (VLServer, "server"), (VLPath, "path"), (Int, "nodeClass"), (VLNode, "drainNode")]),
    #Function(Void, "glXDestroyGLXVideoSourceSGIX", [(Display, "dpy"), (GLXVideoSourceSGIX, "glxvideosource")]),

    # GLX_EXT_import_context
    Function(Display, "glXGetCurrentDisplayEXT", []),
    Function(Int, "glXQueryContextInfoEXT", [(Display, "dpy"), (GLXContext, "context"), (Int, "attribute"), (OpaquePointer(Int), "value")]),
    Function(GLXContextID, "glXGetContextIDEXT", [(Const(GLXContext), "context")]),
    Function(GLXContext, "glXImportContextEXT", [(Display, "dpy"), (GLXContextID, "contextID")]),
    Function(Void, "glXFreeContextEXT", [(Display, "dpy"), (GLXContext, "context")]),

    # GLX_SGIX_fbconfig
    Function(Int, "glXGetFBConfigAttribSGIX", [(Display, "dpy"), (GLXFBConfigSGIX, "config"), (Int, "attribute"), Out(Pointer(Int), "value")]),
    Function(OpaquePointer(GLXFBConfigSGIX), "glXChooseFBConfigSGIX", [(Display, "dpy"), (Int, "screen"), (GLXFBConfigSGIXAttribs, "attrib_list"), Out(Pointer(Int), "nelements")]),
    Function(GLXPixmap, "glXCreateGLXPixmapWithConfigSGIX", [(Display, "dpy"), (GLXFBConfigSGIX, "config"), (Pixmap, "pixmap")]),
    Function(GLXContext, "glXCreateContextWithConfigSGIX", [(Display, "dpy"), (GLXFBConfigSGIX, "config"), (Int, "render_type"), (GLXContext, "share_list"), (Bool, "direct")]),
    Function(Pointer(XVisualInfo), "glXGetVisualFromFBConfigSGIX", [(Display, "dpy"), (GLXFBConfigSGIX, "config")]),
    Function(GLXFBConfigSGIX, "glXGetFBConfigFromVisualSGIX", [(Display, "dpy"), Out(Pointer(XVisualInfo), "vis")]),

    # GLX_SGIX_pbuffer
    Function(GLXPbufferSGIX, "glXCreateGLXPbufferSGIX", [(Display, "dpy"), (GLXFBConfigSGIX, "config"), (UInt, "width"), (UInt, "height"), (GLXPbufferSGIXAttribs, "attrib_list")]),
    Function(Void, "glXDestroyGLXPbufferSGIX", [(Display, "dpy"), (GLXPbufferSGIX, "pbuf")]),
    Function(Int, "glXQueryGLXPbufferSGIX", [(Display, "dpy"), (GLXPbufferSGIX, "pbuf"), (Int, "attribute"), Out(Pointer(UInt), "value")]),
    Function(Void, "glXSelectEventSGIX", [(Display, "dpy"), (GLXDrawable, "drawable"), (ULong, "mask")]),
    Function(Void, "glXGetSelectedEventSGIX", [(Display, "dpy"), (GLXDrawable, "drawable"), Out(Pointer(ULong), "mask")]),

    # GLX_SGI_cushion
    Function(Void, "glXCushionSGI", [(Display, "dpy"), (Window, "window"), (Float, "cushion")]),

    # GLX_SGIX_video_resize
    Function(Int, "glXBindChannelToWindowSGIX", [(Display, "display"), (Int, "screen"), (Int, "channel"), (Window, "window")]),
    Function(Int, "glXChannelRectSGIX", [(Display, "display"), (Int, "screen"), (Int, "channel"), (Int, "x"), (Int, "y"), (Int, "w"), (Int, "h")]),
    Function(Int, "glXQueryChannelRectSGIX", [(Display, "display"), (Int, "screen"), (Int, "channel"), (OpaquePointer(Int), "dx"), (OpaquePointer(Int), "dy"), (OpaquePointer(Int), "dw"), (OpaquePointer(Int), "dh")]),
    Function(Int, "glXQueryChannelDeltasSGIX", [(Display, "display"), (Int, "screen"), (Int, "channel"), (OpaquePointer(Int), "x"), (OpaquePointer(Int), "y"), (OpaquePointer(Int), "w"), (OpaquePointer(Int), "h")]),
    Function(Int, "glXChannelRectSyncSGIX", [(Display, "display"), (Int, "screen"), (Int, "channel"), (GLenum, "synctype")]),

    # GLX_SGIX_dmbuffer
    #Function(Bool, "glXAssociateDMPbufferSGIX", [(Display, "dpy"), (GLXPbufferSGIX, "pbuffer"), (OpaquePointer(DMparams), "params"), (DMbuffer, "dmbuffer")]),

    # GLX_SGIX_swap_group
    Function(Void, "glXJoinSwapGroupSGIX", [(Display, "dpy"), (GLXDrawable, "drawable"), (GLXDrawable, "member")]),

    # GLX_SGIX_swap_barrier
    Function(Void, "glXBindSwapBarrierSGIX", [(Display, "dpy"), (GLXDrawable, "drawable"), (Int, "barrier")]),
    Function(Bool, "glXQueryMaxSwapBarriersSGIX", [(Display, "dpy"), (Int, "screen"), (OpaquePointer(Int), "max")]),

    # GLX_SUN_get_transparent_index
    #Function(Status, "glXGetTransparentIndexSUN", [(Display, "dpy"), (Window, "overlay"), (Window, "underlay"), (OpaquePointer(Long), "pTransparentIndex")]),

    # GLX_MESA_copy_sub_buffer
    Function(Void, "glXCopySubBufferMESA", [(Display, "dpy"), (GLXDrawable, "drawable"), (Int, "x"), (Int, "y"), (Int, "width"), (Int, "height")]),

    # GLX_MESA_pixmap_colormap
    Function(GLXPixmap, "glXCreateGLXPixmapMESA", [(Display, "dpy"), (Pointer(XVisualInfo), "visual"), (Pixmap, "pixmap"), (Colormap, "cmap")]),

    # GLX_MESA_release_buffers
    Function(Bool, "glXReleaseBuffersMESA", [(Display, "dpy"), (GLXDrawable, "drawable")]),

    # GLX_MESA_set_3dfx_mode
    Function(Bool, "glXSet3DfxModeMESA", [(Int, "mode")]),

    # GLX_MESA_swap_control
    Function(Int, "glXSwapIntervalMESA", [(UInt, "interval")]),
    Function(Int, "glXGetSwapIntervalMESA", [], sideeffects=False),

    # GLX_OML_sync_control
    Function(Bool, "glXGetSyncValuesOML", [(Display, "dpy"), (GLXDrawable, "drawable"), (OpaquePointer(Int64), "ust"), (OpaquePointer(Int64), "msc"), (OpaquePointer(Int64), "sbc")]),
    Function(Bool, "glXGetMscRateOML", [(Display, "dpy"), (GLXDrawable, "drawable"), (OpaquePointer(Int32), "numerator"), (OpaquePointer(Int32), "denominator")]),
    Function(Int64, "glXSwapBuffersMscOML", [(Display, "dpy"), (GLXDrawable, "drawable"), (Int64, "target_msc"), (Int64, "divisor"), (Int64, "remainder")]),
    Function(Bool, "glXWaitForMscOML", [(Display, "dpy"), (GLXDrawable, "drawable"), (Int64, "target_msc"), (Int64, "divisor"), (Int64, "remainder"), (OpaquePointer(Int64), "ust"), (OpaquePointer(Int64), "msc"), (OpaquePointer(Int64), "sbc")]),
    Function(Bool, "glXWaitForSbcOML", [(Display, "dpy"), (GLXDrawable, "drawable"), (Int64, "target_sbc"), (OpaquePointer(Int64), "ust"), (OpaquePointer(Int64), "msc"), (OpaquePointer(Int64), "sbc")]),

    # GLX_SGIX_hyperpipe
    #Function(OpaquePointer(GLXHyperpipeNetworkSGIX), "glXQueryHyperpipeNetworkSGIX", [(Display, "dpy"), (OpaquePointer(Int), "npipes")]),
    #Function(Int, "glXHyperpipeConfigSGIX", [(Display, "dpy"), (Int, "networkId"), (Int, "npipes"), (OpaquePointer(GLXHyperpipeConfigSGIX), "cfg"), (OpaquePointer(Int), "hpId")]),
    #Function(OpaquePointer(GLXHyperpipeConfigSGIX), "glXQueryHyperpipeConfigSGIX", [(Display, "dpy"), (Int, "hpId"), (OpaquePointer(Int), "npipes")]),
    #Function(Int, "glXDestroyHyperpipeConfigSGIX", [(Display, "dpy"), (Int, "hpId")]),
    #Function(Int, "glXBindHyperpipeSGIX", [(Display, "dpy"), (Int, "hpId")]),
    #Function(Int, "glXQueryHyperpipeBestAttribSGIX", [(Display, "dpy"), (Int, "timeSlice"), (Int, "attrib"), (Int, "size"), (OpaquePointer(Void), "attribList"), (OpaquePointer(Void), "returnAttribList")]),
    #Function(Int, "glXHyperpipeAttribSGIX", [(Display, "dpy"), (Int, "timeSlice"), (Int, "attrib"), (Int, "size"), (OpaquePointer(Void), "attribList")]),
    #Function(Int, "glXQueryHyperpipeAttribSGIX", [(Display, "dpy"), (Int, "timeSlice"), (Int, "attrib"), (Int, "size"), (OpaquePointer(Void), "returnAttribList")]),

    # GLX_MESA_agp_offset
    Function(UInt, "glXGetAGPOffsetMESA", [(OpaquePointer(Const(Void)), "pointer")]),
    
    # EXT_texture_from_pixmap
    Function(Void, "glXBindTexImageEXT", [(Display, "display"), (GLXDrawable, "drawable"), (GLXEnum, "buffer"), (GLXFBConfigAttribs, "attrib_list")]),
    Function(Void, "glXReleaseTexImageEXT", [(Display, "display"), (GLXDrawable, "drawable"), (GLXEnum, "buffer")]),

    # GLX_NV_present_video
    Function(Array(UInt, "(nelements ? *nelements : 0)"), "glXEnumerateVideoDevicesNV", [(Display, "dpy"), (Int, "screen"), Out(Pointer(Int), "nelements")]),
    Function(Int, "glXBindVideoDeviceNV", [(Display, "dpy"), (UInt, "video_slot"), (UInt, "video_device"), (UnusedAttribs, "attrib_list")]),

    # GLX_NV_video_output
    Function(Int, "glXGetVideoDeviceNV", [(Display, "dpy"), (Int, "screen"), (Int, "numVideoDevices"), Out(Array(GLXVideoDeviceNV, "numVideoDevices"), "pVideoDevice")]),
    Function(Int, "glXReleaseVideoDeviceNV", [(Display, "dpy"), (Int, "screen"), (GLXVideoDeviceNV, "VideoDevice")]),
    Function(Int, "glXBindVideoImageNV", [(Display, "dpy"), (GLXVideoDeviceNV, "VideoDevice"), (GLXPbuffer, "pbuf"), (Int, "iVideoBuffer")]),
    Function(Int, "glXReleaseVideoImageNV", [(Display, "dpy"), (GLXPbuffer, "pbuf")]),
    Function(Int, "glXSendPbufferToVideoNV", [(Display, "dpy"), (GLXPbuffer, "pbuf"), (Int, "iBufferType"), Out(Pointer(ULong), "pulCounterPbuffer"), (GLboolean, "bBlock")]),
    Function(Int, "glXGetVideoInfoNV", [(Display, "dpy"), (Int, "screen"), (GLXVideoDeviceNV, "VideoDevice"), Out(Pointer(ULong), "pulCounterOutputPbuffer"), Out(Pointer(ULong), "pulCounterOutputVideo")], sideeffects=False),

    # GLX_NV_swap_group
    Function(Bool, "glXJoinSwapGroupNV", [(Display, "dpy"), (GLXDrawable, "drawable"), (GLuint, "group")]),
    Function(Bool, "glXBindSwapBarrierNV", [(Display, "dpy"), (GLuint, "group"), (GLuint, "barrier")]),
    Function(Bool, "glXQuerySwapGroupNV", [(Display, "dpy"), (GLXDrawable, "drawable"), (OpaquePointer(GLuint), "group"), (OpaquePointer(GLuint), "barrier")]),
    Function(Bool, "glXQueryMaxSwapGroupsNV", [(Display, "dpy"), (Int, "screen"), (OpaquePointer(GLuint), "maxGroups"), (OpaquePointer(GLuint), "maxBarriers")]),
    Function(Bool, "glXQueryFrameCountNV", [(Display, "dpy"), (Int, "screen"), (OpaquePointer(GLuint), "count")]),
    Function(Bool, "glXResetFrameCountNV", [(Display, "dpy"), (Int, "screen")]),

    # GLX_NV_video_capture
    Function(Int, "glXBindVideoCaptureDeviceNV", [(Display, "dpy"), (UInt, "video_capture_slot"), (GLXVideoCaptureDeviceNV, "device")]),
    Function(Array(GLXVideoCaptureDeviceNV, "(nelements ? *nelements : 0)"), "glXEnumerateVideoCaptureDevicesNV", [(Display, "dpy"), (Int, "screen"), Out(Pointer(Int), "nelements")]),
    Function(Void, "glXLockVideoCaptureDeviceNV", [(Display, "dpy"), (GLXVideoCaptureDeviceNV, "device")]),
    Function(Int, "glXQueryVideoCaptureDeviceNV", [(Display, "dpy"), (GLXVideoCaptureDeviceNV, "device"), (Int, "attribute"), Out(Pointer(Int), "value")], sideeffects=False),
    Function(Void, "glXReleaseVideoCaptureDeviceNV", [(Display, "dpy"), (GLXVideoCaptureDeviceNV, "device")]),

    # GLX_EXT_swap_control
    Function(Void, "glXSwapIntervalEXT", [(Display, "dpy"), (GLXDrawable, "drawable"), (Int, "interval")]),

    # GLX_NV_copy_image
    Function(Void, "glXCopyImageSubDataNV", [(Display, "dpy"), (GLXContext, "srcCtx"), (GLuint, "srcName"), (GLenum, "srcTarget"), (GLint, "srcLevel"), (GLint, "srcX"), (GLint, "srcY"), (GLint, "srcZ"), (GLXContext, "dstCtx"), (GLuint, "dstName"), (GLenum, "dstTarget"), (GLint, "dstLevel"), (GLint, "dstX"), (GLint, "dstY"), (GLint, "dstZ"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth")]),

    # GLX_NV_vertex_array_range
    Function(OpaquePointer(Void), "glXAllocateMemoryNV", [(GLsizei, "size"), (GLfloat, "readfreq"), (GLfloat, "writefreq"), (GLfloat, "priority")]),
    Function(Void, "glXFreeMemoryNV", [(OpaquePointer(Void), "pointer")]),

    # Must be last
    Function(PROC, "glXGetProcAddressARB", [(String(Const(GLubyte)), "procName")]),
    Function(PROC, "glXGetProcAddress", [(String(Const(GLubyte)), "procName")]),
])


# To prevent collision with stdapi.Bool
del Bool

########NEW FILE########
__FILENAME__ = c2api
#!/usr/bin/env python
##########################################################################
#
# Copyright 2011 Jose Fonseca
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


'''Script to parse C declarations and spew API definitions.
'''


import sys
import re
import optparse


class DeclParser:

    token_re = re.compile(r'(\d[x0-9a-fA-F.UL]*|\w+|\s+|"[^"]*"|.)')

    multi_comment_re = re.compile(r'/\*.*?\*/', flags = re.DOTALL)
    single_comment_re = re.compile(r'//.*',)

    def __init__(self):
        self.tokens = []

    def has_side_effects(self, name):
        return True


    def tokenize(self, s):
        s = self.multi_comment_re.sub('', s)
        s = self.single_comment_re.sub('', s)
        self.tokens = self.token_re.split(s)
        self.tokens = [token for token in self.tokens if self.filter_token(token)]

    def filter_token(self, token):
        if not token or token.isspace():
            return False
        if token.startswith('AVAILABLE_') or token.startswith('DEPRECATED_'):
            return False
        if token in ['FAR']:
            return False
        return True

    def lookahead(self, index = 0):
        try:
            return self.tokens[index]
        except KeyError:
            return None

    def match(self, *ref_tokens):
        return self.lookahead() in ref_tokens

    def consume(self, *ref_tokens):
        if not self.tokens:
            raise Exception('unexpected EOF')
        token = self.tokens.pop(0)
        if ref_tokens and token not in ref_tokens:
            raise Exception('token mismatch', token, ref_tokens)
        return token

    def eof(self):
        return not self.tokens


    def parse(self, s):
        self.tokenize(s)

        while not self.eof():
            #print self.tokens[0:10]
            self.parse_declaration()

    def parse_declaration(self):
        self.parse_tags()
        if self.match('#'):
            self.parse_define()
        elif self.match('enum'):
            self.parse_enum()
        elif self.match('class', 'interface'):
            self.parse_interface(self.lookahead())
        elif self.match('mask'):
            self.parse_value('mask', 'Flags')
        elif self.match('struct'):
            self.parse_struct()
        elif self.match('value'):
            self.parse_value('value', 'FakeEnum')
        elif self.match('typedef'):
            self.parse_typedef()
        else:
            self.parse_prototype()
        if not self.eof() and self.match(';'):
            self.consume(';')

    def parse_typedef(self):
        self.consume('typedef')
        if self.lookahead(2) in (';', ','):
            base_type = self.consume()
            while True:
                type = base_type
                if self.match('*'):
                    self.consume()
                    type = 'Pointer(%s)' % type
                name = self.consume()
                print '%s = Alias("%s", %s)' % (name, name, type)
                if self.match(','):
                    self.consume()
                else:
                    break
        else:
            self.parse_declaration()
            self.consume()

    def parse_enum(self):
        self.consume('enum')
        name = self.consume()
        self.consume('{')

        print '%s = Enum("%s", [' % (name, name)

        #value = 0
        while self.lookahead() != '}':
            name = self.consume()
            if self.match('='):
                self.consume('=')
                value = self.consume()
            if self.match(','):
                self.consume(',')
            tags = self.parse_tags()
            #print '    "%s",\t# %s' % (name, value) 
            print '    "%s",' % (name,) 
            #value += 1
        self.consume('}')

        print '])'
        print

    def parse_value(self, ref_token, constructor):
        self.consume(ref_token)
        type = self.consume()
        name = self.consume()
        self.consume('{')

        print '%s = %s(%s, [' % (name, constructor, type)

        while self.lookahead() != '}':
            name, value = self.parse_define()
        self.consume('}')

        print '])'
        print

    def parse_define(self):
        self.consume('#')
        self.consume('define')
        name = self.consume()
        value = self.consume()
        #print '    "%s",\t# %s' % (name, value) 
        print '    "%s",' % (name,) 
        return name, value

    def parse_struct(self):
        self.consume('struct')
        name = self.consume()

        print '%s = Struct("%s", [' % (name, name)
        for type, name in self.parse_members():
            print '    (%s, "%s"),' % (type, name)
        print '])'
        print

    def parse_union(self):
        self.consume('union')
        if not self.match('{'):
            name = self.consume()
        else:
            name = None
        members = self.parse_members()
        return 'Union("%s", [%s])' % (name, ', '.join('%s, "%s"' % member for member in members))

    def parse_members(self):
        members = []
        self.consume('{')
        while self.lookahead() != '}':
            type, name = self.parse_named_type()

            if self.match(':'):
                self.consume()
                self.consume()

            if self.match(','):
                self.consume(',')
            self.consume(';')
            members.append((type, name))
        self.consume('}')
        return members

    def parse_interface(self, ref_token):
        self.consume(ref_token)
        name = self.consume()
        if self.match(';'):
            return
        self.consume(':')
        if self.lookahead() in ('public', 'protected'):
            self.consume()
        base = self.consume()
        self.consume('{')

        print '%s = Interface("%s", %s)' % (name, name, base)
        print '%s.methods += [' % (name,)

        while self.lookahead() != '}':
            if self.lookahead() in ('public', 'private'):
                self.consume()
                self.consume(':')
            else:
                self.parse_prototype('Method')
                self.consume(';')
        self.consume('}')

        print ']'
        print

    def parse_prototype(self, creator = 'Function'):
        if self.match('extern', 'virtual'):
            self.consume()

        ret = self.parse_type()

        if self.match('__stdcall', 'WINAPI', 'STDMETHODCALLTYPE'):
            self.consume()
            creator = 'Std' + creator

        name = self.consume()
        extra = ''
        if not self.has_side_effects(name):
            extra += ', sideeffects=False'
        name = name

        self.consume('(')
        args = []
        if self.match('void') and self.tokens[1] == ')':
            self.consume()
        while self.lookahead() != ')':
            arg = self.parse_arg()
            args.append(arg)
            if self.match(','):
                self.consume()
        self.consume(')')
        if self.match('const', 'CONST'):
            self.consume()
            extra = ', const=True' + extra

        if self.lookahead() == '=':
            self.consume()
            self.consume('0')
        
        print '    %s(%s, "%s", [%s]%s),' % (creator, ret, name, ', '.join(args), extra)

    def parse_arg(self):
        tags = self.parse_tags()

        type, name = self.parse_named_type()

        arg = '(%s, "%s")' % (type, name)
        if 'out' in tags or 'inout' in tags:
            arg = 'Out' + arg

        if self.match('='):
            self.consume()
            while not self.match(',', ')'):
                self.consume()

        return arg

    def parse_tags(self):
        tags = []
        if self.match('['):
            self.consume()
            while not self.match(']'):
                tag = self.consume()
                tags.append(tag)
            self.consume(']')
            if tags[0] == 'annotation':
                assert tags[1] == '('
                assert tags[3] == ')'
                tags = tags[2]
                assert tags[0] == '"'
                assert tags[-1] == '"'
                tags = tags[1:-1]
                tags = parse_sal_annotation(tags)
        token = self.lookahead()
        if token[0] == '_' and (token[1] == '_' or token[-1] == '_'):
            # Parse __in, __out, etc tags
            tag = self.consume()
            if self.match('('):
                tag += self.consume()
                while not self.match(')'):
                    tag += self.consume()
                tag += self.consume(')')
            tags.extend(self.parse_sal_annotation(tag))
        return tags

    def parse_sal_annotation(self, tags):
        try:
            tags, args = tags.split('(')
        except ValueError:
            pass
        assert tags[0] == '_'
        if tags[1] == '_':
            tags = tags[2:]
        if tags[-1] == '_':
            tags = tags[1:-1]
        tags = tags.lower()
        tags = tags.split('_')
        return tags

    def parse_named_type(self):
        type = self.parse_type()
        
        if self.match(',', ';', '}', ')'):
            name = None
        else:
            name = self.consume()
            if self.match('['):
                self.consume()
                length = ''
                while not self.match(']'):
                    length += self.consume()
                self.consume(']')
                try:
                    int(length)
                except ValueError:
                    length = '"%s"' % length
                type = 'Array(%s, %s)' % (type, length)
        return type, name

    int_tokens = ('unsigned', 'signed', 'int', 'long', 'short', 'char')

    type_table = {
        'float':    'Float',
        'double':   'Double',
        'int8_t':   'Int8',
        'uint8_t':  'UInt8',
        'int16_t':  'Int16',
        'uint16_t': 'UInt16',
        'int32_t':  'Int32',
        'uint32_t': 'UInt32',
        'int64_t' : 'Int64',
        'uint64_t': 'UInt64',
    }

    def parse_type(self):
        const = False
        if self.match('const', 'CONST'):
            self.consume()
            const = True
        if self.match('void'):
            self.consume()
            type = 'Void'
        elif self.match('union'):
            type = self.parse_union()
        elif self.match(*self.int_tokens):
            unsigned = False
            signed = False
            long = 0
            short = 0
            char = False
            while self.match(*self.int_tokens):
                token = self.consume()
                if token == 'unsigned':
                    unsigned = True
                if token == 'signed':
                    signed = True
                if token == 'long':
                    long += 1
                if token == 'short':
                    short += 1
                if token == 'char':
                    char = False
            if char:
                type = 'Char'
                if signed:
                    type = 'S' + type
            elif short:
                type = 'Short'
            elif long:
                type = 'Long' * long
            else:
                type = 'Int'
            if unsigned:
                type = 'U' + type
        else:
            token = self.consume()
            type = self.type_table.get(token, token)
        if const:
            type = 'Const(%s)' % type
        while True:
            if self.match('*'):
                self.consume('*')
                type = 'Pointer(%s)' % type
            elif self.match('const', 'CONST'):
                self.consume()
                type = 'Const(%s)' % type
            else:
                break
        return type


def main():
    args = sys.argv[1:]

    parser = DeclParser()
    if args:
        for arg in args:
            parser.parse(open(arg, 'rt').read())
    else:
        parser.parse(sys.stdin.read())
    

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = spec2api
#!/usr/bin/env python
##########################################################################
#
# Copyright 2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""Parser for OpenGL .spec files in http://www.opengl.org/registry/."""


import sys
import re
import optparse


def stderr(x):
    sys.stderr.write(str(x) + '\n')


class Parser:

    def __init__(self, stream):
        pass


class LineParser:
    """Base class for parsers that read line-based formats."""

    def __init__(self, stream):
        self._stream = stream
        self._line = None
        self._eof = False
        # read lookahead
        self.readline()
    
    def parse(self):
        raise NotImplementedError

    def readline(self):
        line = self._stream.readline()
        if not line:
            self._line = ''
            self._eof = True
        self._line = line.rstrip('\r\n')

    def lookahead(self):
        assert self._line is not None
        return self._line

    def consume(self):
        assert self._line is not None
        line = self._line
        self.readline()
        return line

    def eof(self):
        assert self._line is not None
        return self._eof
    
    def skip_whitespace(self):
        while not self.eof() and self.match_whitespace() or self.match_comment():
            self.consume()

    def match_whitespace(self):
        line = self.lookahead()
        return not line.strip()

    def match_comment(self):
        return False


class TypemapParser(LineParser):

    def parse(self):
        typemap = {}
        self.skip_whitespace()
        while not self.eof():
            line = self.consume()
            fields = [field.strip() for field in line.split(',')]
            src = fields[0]
            dst = fields[3]
            if dst != '*':
                typemap[src] = dst
            self.skip_whitespace()
        return typemap
    
    def match_comment(self):
        line = self.lookahead()
        return line.startswith('#')


class SpecParser(LineParser):

    property_re = re.compile(r'^\w+:')
    prototype_re = re.compile(r'^(\w+)\((.*)\)$')

    def __init__(self, stream, prefix='', typemap = None):
        LineParser.__init__(self, stream)
        if typemap is None:
            self.typemap = {}
        else:
            self.typemap = typemap
        self.prefix = prefix
        self.category = None

    def parse(self):
        self.skip_whitespace()
        while not self.eof():
            line = self.lookahead()
            if self.property_re.match(line):
                self.parse_property()
            elif self.prototype_re.match(line):
                self.parse_prototype()
            else:
                self.consume()
            self.skip_whitespace()

    def parse_property(self):
        line = self.consume()
        name, value = line.split(':', 1)
        if name == 'category':
            values = value.split()
            #self.prefix = values[0]

    get_function_re = re.compile(r'^(Get|Is|Are)[A-Z]\w+')

    def parse_prototype(self):
        line = self.consume()
        mo = self.prototype_re.match(line)
        function_name, arg_names = mo.groups()
        arg_names = [arg_name.strip() for arg_name in arg_names.split(',') if arg_name.strip()]
        
        extra = ''
        if self.get_function_re.match(function_name):
            extra += ', sideeffects=False'
        function_name = self.prefix + function_name

        ret_type = 'Void'
        arg_types = {}
        category = None
        line = self.lookahead()
        while line.startswith('\t'):
            fields = line.split(None, 2)
            if fields[0] == 'return':
                ret_type = self.parse_type(fields[1])
            elif fields[0] == 'param':
                arg_name, arg_type = fields[1:3]
                arg_types[fields[1]] = self.parse_arg(function_name, arg_name, arg_type)
            elif fields[0] == 'category':
                category = fields[1]
            else:
                pass
            self.consume()
            line = self.lookahead()
        self.consume()
        args = [arg_types[arg_name] for arg_name in arg_names]

        if category is not None:
            if category == self.prefix:
                category = self.prefix.upper()
            else:
                category = self.prefix.upper() + '_' + category
            if category != self.category:
                if self.category is not None:
                    print
                print '    # %s' % category
                self.category = category

        if self.prefix == 'wgl':
            constructor = 'StdFunction'
        else:
            constructor = 'GlFunction'

        print '    %s(%s, "%s", [%s]%s),' % (constructor, ret_type, function_name, ', '.join(args), extra)

    array_re = re.compile(r'^array\s+\[(.*)\]$')

    string_typemap = {
        'GLchar': 'GLstring',
        'GLcharARB': 'GLstringARB',
    }

    def parse_arg(self, function_name, arg_name, arg_type):
        orig_type, inout, kind = arg_type.split(' ', 2)

        base_type = self.parse_type(orig_type)

        if kind == 'value':
            arg_type = base_type
        elif kind == 'reference':
            if inout == 'in':
                base_type = 'Const(%s)' % base_type
            arg_type = 'Pointer(%s)' % base_type
        elif kind.startswith("array"):
            if inout == 'in':
                base_type = 'Const(%s)' % base_type

            arg_type = 'OpaquePointer(%s)' % base_type

            if base_type in ('Void', 'void', 'GLvoid'):
                constructor = 'Blob'
            else:
                constructor = 'Array'

            mo = self.array_re.match(kind)
            if mo:
                length = mo.group(1).strip()
                if length == '':
                    try:
                        arg_type = self.string_typemap[base_type]
                    except KeyError:
                        pass
                elif length == '1':
                    arg_type = 'Pointer(%s)' % base_type
                elif length.find("COMPSIZE") == -1:
                    try:
                        int(length)
                    except ValueError:
                        length = '"%s"' % length
                    arg_type = '%s(%s, %s)' % (constructor, base_type, length)
                else:
                    if length == "COMPSIZE(pname)":
                        length = "_gl_param_size(pname)"
                        arg_type = '%s(%s, "%s")' % (constructor, base_type, length)
                    else:
                        length = length.replace("COMPSIZE", "_%s_size" % function_name)
                        length = length.replace("/", ", ")
                        arg_type = 'Opaque%s(%s, "%s")' % (constructor, base_type, length)
        else:
            assert False
        
        arg = '(%s, "%s")' % (arg_type, arg_name)
        if inout == 'out':
            arg = 'Out' + arg
        return arg

    semantic_typemap = {
        'String': 'CString',
        'Texture': 'GLtexture',
    }

    post_typemap = {
        'void': 'Void',
        'int': 'Int',
        'float': 'Float',
    }

    def parse_type(self, type):
        try:
            return self.semantic_typemap[type]
        except KeyError:
            pass
        type = self.typemap.get(type, type)
        type = self.post_typemap.get(type, type)
        return type

    def match_comment(self):
        line = self.lookahead()
        return line.startswith('#')


def main():
    prefix = sys.argv[1]

    parser = TypemapParser(open(sys.argv[2], 'rt'))
    typemap = parser.parse()

    for arg in sys.argv[3:]:
        parser = SpecParser(open(arg, 'rt'), prefix=prefix, typemap=typemap)
        parser.parse()
    

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = txt2api
#!/usr/bin/env python
##########################################################################
#
# Copyright 2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""Parser for OpenGL .txt extensions specification."""


import sys
import re
import optparse
from urllib2 import urlopen


def stderr(x):
    sys.stderr.write(str(x) + '\n')


class Parser:

    def __init__(self, stream):
        pass


class LineParser:
    """Base class for parsers that read line-based formats."""

    def __init__(self, stream):
        self._stream = stream
        self._line = None
        self._eof = False
        # read lookahead
        self.readline()
    
    def parse(self):
        raise NotImplementedError

    def readline(self):
        line = self._stream.readline()
        if not line:
            self._line = ''
            self._eof = True
        self._line = line.rstrip('\r\n')

    def lookahead(self):
        assert self._line is not None
        return self._line

    def consume(self):
        assert self._line is not None
        line = self._line
        self.readline()
        return line

    def eof(self):
        assert self._line is not None
        return self._eof
    
    def skip_whitespace(self):
        while not self.eof() and self.match_whitespace() or self.match_comment():
            self.consume()

    def match_whitespace(self):
        line = self.lookahead()
        return not line.strip()

    def match_comment(self):
        return False


class TxtParser(LineParser):

    section_re = re.compile(r'^([A-Z]\w+)( \w+)*$')

    property_re = re.compile(r'^\w+:')
    prototype_re = re.compile(r'^(\w+)\((.*)\)$')

    comment_start_re = re.compile(r'^/\*')
    comment_end_re = re.compile(r'.*\*/$')

    def __init__(self, stream, prefix=''):
        LineParser.__init__(self, stream)
        self.prefix = prefix

    def parse(self):
        while  not self.eof():
            while not self.eof():
                line = self.lookahead()
                if self.eof():
                    return
                mo = self.section_re.match(line)
                if mo:
                    break
                self.consume()
            line = self.consume()
            self.parse_section(line)
        print

    def parse_section(self, name):
        if name == 'Name Strings':
            self.parse_strings()
        if name == 'New Procedures and Functions':
            self.parse_procs()

    def parse_strings(self):
        while not self.eof():
            line = self.lookahead()
            if not line.strip():
                self.consume()
                continue
            if not line.startswith(' '):
                break
            self.consume()
            name = line.strip()
            if name.startswith('EGL_'):
                self.prefix = ''
            print '    # %s' % name

    def skip_c_comments(self):
        while not self.eof():
            line = self.lookahead().strip()
            mo = self.comment_start_re.match(line)
            if not mo:
                return
            while not self.eof():
                self.consume()
                mo = self.comment_end_re.match(line)
                if mo:
                    return
                line = self.lookahead().strip()

    def parse_procs(self):
        lines = []
        while not self.eof():
            self.skip_c_comments()
            line = self.lookahead()
            if not line.strip():
                self.consume()
                continue
            if not line[0].isspace():
                break
            self.consume()
            lines.append(line.strip())
            if line[-1] in (';', ')'):
                prototype = ' '.join(lines)
                self.parse_proc(prototype)
                lines = []

    token_re = re.compile(r'(\w+|\s+|.)')
    get_function_re = re.compile(r'^Get[A-Z]\w+')

    def parse_proc(self, prototype):
        #print prototype
        tokens = self.token_re.split(prototype)
        self.tokens = [token for token in tokens if token.strip()]
        #print self.tokens

        ret = self.parse_type()

        name = self.tokens.pop(0)
        extra = ''
        if self.get_function_re.match(name):
            extra += ', sideeffects=False'
        name = self.prefix + name

        assert self.tokens.pop(0) == '('
        args = []
        while self.tokens[0] != ')':
            arg = self.parse_arg()
            args.append(arg)
            if self.tokens[0] == ',':
                self.tokens.pop(0)
        print '    GlFunction(%s, "%s", [%s]%s),' % (ret, name, ', '.join(args), extra)

    def parse_arg(self):
        type = self.parse_type()
        if self.tokens[0] == ')':
            assert type == 'Void'
            return ''
        name = self.tokens.pop(0)
        if self.tokens[0] == '[':
            self.tokens.pop(0)
            n = int(self.tokens.pop(0))
            assert self.tokens.pop(0) == ']'
            type = 'Array(%s, %d)' % (type, n)
        return '(%s, "%s")' % (type, name)

    def parse_type(self):
        token = self.tokens.pop(0)
        if token == 'const':
            return 'Const(%s)' % self.parse_type()
        if token == 'void':
            type = 'Void'
        else:
            type = self.prefix.upper() + token
        while self.tokens[0] == '*':
            type = 'OpaquePointer(%s)' % type
            self.tokens.pop(0)
        return type


def main():
    optparser = optparse.OptionParser(
        usage="\n\t%prog [options] [URL|TXT] ...")
    optparser.add_option(
        '-p', '--prefix', metavar='STRING',
        type="string", dest="prefix", default='gl',
        help="function prefix [default: %default]")

    (options, args) = optparser.parse_args(sys.argv[1:])

    for arg in args:
        if arg.startswith('http://') or arg.startswith('https://'):
            stream = urlopen(arg, 'rt')
        else:
            stream = open(arg, 'rt')
        parser = TxtParser(stream, prefix = options.prefix)
        parser.parse()
    

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = xml2api
#!/usr/bin/env python
##########################################################################
#
# Copyright 2014 VMware, Inc
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


#
# Script to half-generate *api.py based on Khronos' *.xml
#


import sys
import xml.etree.ElementTree as ET

import c2api



def getType(node):
    ptype = node.find('ptype')
    if ptype is None:
        typeText = node.text.strip()
    else:
        typeText = ptype.text

    parser = c2api.DeclParser()
    parser.tokenize(typeText + ';')

    return parser.parse_type()


for arg in sys.argv[1:]:
    tree = ET.parse(arg)
    root = tree.getroot()

    prototypes = {}

    for commands in root.findall('commands'):
        namespace = commands.get('namespace')
        for command in commands.findall('command'):
            proto = command.find('proto')
            retType = getType(proto)
            functionName = proto.find('name').text

            args = []
            for param in command.findall('param'):
                argType = getType(param)
                argName = param.find('name').text
                if argName.lower() == 'hdc':
                    argName = 'hDC'
                arg = '(%s, "%s")' % (argType, argName)
                args.append(arg)

            if namespace == 'WGL':
                constructor = 'StdFunction'
            else:
                constructor = 'GlFunction'

            prototype = '%s(%s, "%s", [%s])' % (constructor, retType, functionName, ', '.join(args))
            prototypes[functionName] = prototype

    for feature in root.findall('feature'):
        print '    # %s' % feature.get('name')
        require = feature.find('require')
        for command in require.findall('command'):
            functionName = command.get('name')
            prototype = prototypes[functionName]
            print '    %s,' % prototype
        print

    extensions = root.find('extensions')
    for extension in extensions.findall('extension'):
        print '    # %s' % extension.get('name')
        require = extension.find('require')
        for command in require.findall('command'):
            functionName = command.get('name')
            prototype = prototypes[functionName]
            print '    %s,' % prototype
        print


########NEW FILE########
__FILENAME__ = xml2enum
#!/usr/bin/env python
##########################################################################
#
# Copyright 2014 VMware, Inc
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


#
# Script to half-generate *enum.py based on Khronos' *.xml
#


import sys
import xml.etree.ElementTree as ET


for arg in sys.argv[1:]:
    tree = ET.parse(arg)
    root = tree.getroot()


    params = {}
    for enums in root.findall('enums'):
        if enums.attrib.get('type') == 'bitmask':
            continue

        for enum in enums.findall('enum'):
            name = enum.attrib['name']
            value = enum.attrib['value']

            if value.isdigit():
                value = int(value)
            elif value.startswith('0x'):
                value = int(value, 16)
            else:
                continue

            params.setdefault(value, name)


    values = params.keys()
    values.sort()
    for value in values:
        name = params[value]
        print '    "%s",\t\t# 0x%04X' % (name, value)

########NEW FILE########
__FILENAME__ = xml2glparams
#!/usr/bin/env python
##########################################################################
#
# Copyright 2014 VMware, Inc
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


#
# Script to half-generate glparams.py based on Khronos' gl.xml
#


import sys
import xml.etree.ElementTree as ET


for arg in sys.argv[1:]:
    tree = ET.parse(arg)
    root = tree.getroot()


    params = {}
    for enums in root.findall('enums'):
        if enums.attrib.get('type') == 'bitmask':
            continue

        for enum in enums.findall('enum'):
            name = enum.attrib['name']
            value = enum.attrib['value']

            if value.isdigit():
                value = int(value)
            elif value.startswith('0x'):
                value = int(value, 16)
            else:
                continue

            params.setdefault(value, name)


    values = params.keys()
    values.sort()
    for value in values:
        name = params[value]
        print '    ("",\tX,\t1,\t"%s"),\t# 0x%04X' % (name, value)

########NEW FILE########
__FILENAME__ = stdapi
##########################################################################
#
# Copyright 2008-2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""C basic types"""


import debug


class Type:
    """Base class for all types."""

    __tags = set()

    def __init__(self, expr, tag = None):
        self.expr = expr

        # Generate a default tag, used when naming functions that will operate
        # on this type, so it should preferrably be something representative of
        # the type.
        if tag is None:
            if expr is not None:
                tag = ''.join([c for c in expr if c.isalnum() or c in '_'])
            else:
                tag = 'anonynoums'
        else:
            for c in tag:
                assert c.isalnum() or c in '_'

        # Ensure it is unique.
        if tag in Type.__tags:
            suffix = 1
            while tag + str(suffix) in Type.__tags:
                suffix += 1
            tag += str(suffix)

        assert tag not in Type.__tags
        Type.__tags.add(tag)

        self.tag = tag

    def __str__(self):
        """Return the C/C++ type expression for this type."""
        return self.expr

    def visit(self, visitor, *args, **kwargs):
        raise NotImplementedError

    def mutable(self):
        '''Return a mutable version of this type.

        Convenience wrapper around MutableRebuilder.'''
        visitor = MutableRebuilder()
        return visitor.visit(self)


class _Void(Type):
    """Singleton void type."""

    def __init__(self):
        Type.__init__(self, "void")

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitVoid(self, *args, **kwargs)

Void = _Void()


class Literal(Type):
    """Class to describe literal types.

    Types which are not defined in terms of other types, such as integers and
    floats."""

    def __init__(self, expr, kind):
        Type.__init__(self, expr)
        self.kind = kind

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitLiteral(self, *args, **kwargs)


Bool = Literal("bool", "Bool")
SChar = Literal("signed char", "SInt")
UChar = Literal("unsigned char", "UInt")
Short = Literal("short", "SInt")
Int = Literal("int", "SInt")
Long = Literal("long", "SInt")
LongLong = Literal("long long", "SInt")
UShort = Literal("unsigned short", "UInt")
UInt = Literal("unsigned int", "UInt")
ULong = Literal("unsigned long", "UInt")
ULongLong = Literal("unsigned long long", "UInt")
Float = Literal("float", "Float")
Double = Literal("double", "Double")
SizeT = Literal("size_t", "UInt")

Char = Literal("char", "SInt")
WChar = Literal("wchar_t", "SInt")

Int8 = Literal("int8_t", "SInt")
UInt8 = Literal("uint8_t", "UInt")
Int16 = Literal("int16_t", "SInt")
UInt16 = Literal("uint16_t", "UInt")
Int32 = Literal("int32_t", "SInt")
UInt32 = Literal("uint32_t", "UInt")
Int64 = Literal("int64_t", "SInt")
UInt64 = Literal("uint64_t", "UInt")

IntPtr = Literal("intptr_t", "SInt")
UIntPtr = Literal("uintptr_t", "UInt")

class Const(Type):

    def __init__(self, type):
        # While "const foo" and "foo const" are synonymous, "const foo *" and
        # "foo * const" are not quite the same, and some compilers do enforce
        # strict const correctness.
        if type.expr.startswith("const ") or '*' in type.expr:
            expr = type.expr + " const"
        else:
            # The most legible
            expr = "const " + type.expr

        Type.__init__(self, expr, 'C' + type.tag)

        self.type = type

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitConst(self, *args, **kwargs)


class Pointer(Type):

    def __init__(self, type):
        Type.__init__(self, type.expr + " *", 'P' + type.tag)
        self.type = type

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitPointer(self, *args, **kwargs)


class IntPointer(Type):
    '''Integer encoded as a pointer.'''

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitIntPointer(self, *args, **kwargs)


class ObjPointer(Type):
    '''Pointer to an object.'''

    def __init__(self, type):
        Type.__init__(self, type.expr + " *", 'P' + type.tag)
        self.type = type

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitObjPointer(self, *args, **kwargs)


class LinearPointer(Type):
    '''Pointer to a linear range of memory.'''

    def __init__(self, type, size = None):
        Type.__init__(self, type.expr + " *", 'P' + type.tag)
        self.type = type
        self.size = size

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitLinearPointer(self, *args, **kwargs)


class Reference(Type):
    '''C++ references.'''

    def __init__(self, type):
        Type.__init__(self, type.expr + " &", 'R' + type.tag)
        self.type = type

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitReference(self, *args, **kwargs)


class Handle(Type):

    def __init__(self, name, type, range=None, key=None):
        Type.__init__(self, type.expr, 'P' + type.tag)
        self.name = name
        self.type = type
        self.range = range
        self.key = key

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitHandle(self, *args, **kwargs)


def ConstPointer(type):
    return Pointer(Const(type))


class Enum(Type):

    __id = 0

    def __init__(self, name, values):
        Type.__init__(self, name)

        self.id = Enum.__id
        Enum.__id += 1

        self.values = list(values)

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitEnum(self, *args, **kwargs)


def FakeEnum(type, values):
    return Enum(type.expr, values)


class Bitmask(Type):

    __id = 0

    def __init__(self, type, values):
        Type.__init__(self, type.expr)

        self.id = Bitmask.__id
        Bitmask.__id += 1

        self.type = type
        self.values = values

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitBitmask(self, *args, **kwargs)

Flags = Bitmask


class Array(Type):

    def __init__(self, type, length):
        Type.__init__(self, type.expr + " *")
        self.type = type
        self.length = length

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitArray(self, *args, **kwargs)


class AttribArray(Type):

    def __init__(self, baseType, valueTypes, terminator = '0'):
        self.baseType = baseType
        Type.__init__(self, (Pointer(self.baseType)).expr)
        self.valueTypes = valueTypes
        self.terminator = terminator
        self.hasKeysWithoutValues = False
        for key, value in valueTypes:
            if value is None:
                self.hasKeysWithoutValues = True

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitAttribArray(self, *args, **kwargs)


class Blob(Type):

    def __init__(self, type, size):
        Type.__init__(self, type.expr + ' *')
        self.type = type
        self.size = size

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitBlob(self, *args, **kwargs)


class Struct(Type):

    __id = 0

    def __init__(self, name, members):
        Type.__init__(self, name)

        self.id = Struct.__id
        Struct.__id += 1

        self.name = name
        self.members = members

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitStruct(self, *args, **kwargs)


def Union(kindExpr, kindTypes, contextLess=True):
    switchTypes = []
    for kindCase, kindType, kindMemberName in kindTypes:
        switchType = Struct(None, [(kindType, kindMemberName)])
        switchTypes.append((kindCase, switchType))
    return Polymorphic(kindExpr, switchTypes, contextLess=contextLess)


class Alias(Type):

    def __init__(self, expr, type):
        Type.__init__(self, expr)
        self.type = type

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitAlias(self, *args, **kwargs)

class Arg:

    def __init__(self, type, name, input=True, output=False):
        self.type = type
        self.name = name
        self.input = input
        self.output = output
        self.index = None

    def __str__(self):
        return '%s %s' % (self.type, self.name)


def In(type, name):
    return Arg(type, name, input=True, output=False)

def Out(type, name):
    return Arg(type, name, input=False, output=True)

def InOut(type, name):
    return Arg(type, name, input=True, output=True)


class Function:

    def __init__(self, type, name, args, call = '', fail = None, sideeffects=True, internal=False):
        self.type = type
        self.name = name

        self.args = []
        index = 0
        for arg in args:
            if not isinstance(arg, Arg):
                if isinstance(arg, tuple):
                    arg_type, arg_name = arg
                else:
                    arg_type = arg
                    arg_name = "arg%u" % index
                arg = Arg(arg_type, arg_name)
            arg.index = index
            index += 1
            self.args.append(arg)

        self.call = call
        self.fail = fail
        self.sideeffects = sideeffects
        self.internal = internal

    def prototype(self, name=None):
        if name is not None:
            name = name.strip()
        else:
            name = self.name
        s = name
        if self.call:
            s = self.call + ' ' + s
        if name.startswith('*'):
            s = '(' + s + ')'
        s = self.type.expr + ' ' + s
        s += "("
        if self.args:
            s += ", ".join(["%s %s" % (arg.type, arg.name) for arg in self.args])
        else:
            s += "void"
        s += ")"
        return s

    def argNames(self):
        return [arg.name for arg in self.args]

    def getArgByName(self, name):
        for arg in self.args:
            if arg.name == name:
                return arg
        return None


def StdFunction(*args, **kwargs):
    kwargs.setdefault('call', '__stdcall')
    return Function(*args, **kwargs)


def FunctionPointer(type, name, args, **kwargs):
    # XXX: We should probably treat function pointers (callbacks or not) in a generic fashion
    return Opaque(name)


class Interface(Type):

    def __init__(self, name, base=None):
        Type.__init__(self, name)
        self.name = name
        self.base = base
        self.methods = []

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitInterface(self, *args, **kwargs)

    def getMethodByName(self, name):
        for method in self.iterMethods():
            if method.name == name:
                return method
        return None

    def iterMethods(self):
        if self.base is not None:
            for method in self.base.iterMethods():
                yield method
        for method in self.methods:
            yield method
        raise StopIteration

    def iterBases(self):
        iface = self
        while iface is not None:
            yield iface
            iface = iface.base
        raise StopIteration

    def hasBase(self, *bases):
        for iface in self.iterBases():
            if iface in bases:
                return True
        return False

    def iterBaseMethods(self):
        if self.base is not None:
            for iface, method in self.base.iterBaseMethods():
                yield iface, method
        for method in self.methods:
            yield self, method
        raise StopIteration


class Method(Function):

    def __init__(self, type, name, args, call = '', const=False, sideeffects=True):
        assert call == '__stdcall'
        Function.__init__(self, type, name, args, call = call, sideeffects=sideeffects)
        for index in range(len(self.args)):
            self.args[index].index = index + 1
        self.const = const

    def prototype(self, name=None):
        s = Function.prototype(self, name)
        if self.const:
            s += ' const'
        return s


def StdMethod(*args, **kwargs):
    kwargs.setdefault('call', '__stdcall')
    return Method(*args, **kwargs)


class String(Type):
    '''Human-legible character string.'''

    def __init__(self, type = Char, length = None, wide = False):
        assert isinstance(type, Type)
        Type.__init__(self, type.expr + ' *')
        self.type = type
        self.length = length
        self.wide = wide

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitString(self, *args, **kwargs)


class Opaque(Type):
    '''Opaque pointer.'''

    def __init__(self, expr):
        Type.__init__(self, expr)

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitOpaque(self, *args, **kwargs)


def OpaquePointer(type, *args):
    return Opaque(type.expr + ' *')

def OpaqueArray(type, size):
    return Opaque(type.expr + ' *')

def OpaqueBlob(type, size):
    return Opaque(type.expr + ' *')


class Polymorphic(Type):

    def __init__(self, switchExpr, switchTypes, defaultType=None, contextLess=True):
        if defaultType is None:
            Type.__init__(self, None)
            contextLess = False
        else:
            Type.__init__(self, defaultType.expr)
        self.switchExpr = switchExpr
        self.switchTypes = switchTypes
        self.defaultType = defaultType
        self.contextLess = contextLess

    def visit(self, visitor, *args, **kwargs):
        return visitor.visitPolymorphic(self, *args, **kwargs)

    def iterSwitch(self):
        cases = []
        types = []

        if self.defaultType is not None:
            cases.append(['default'])
            types.append(self.defaultType)

        for expr, type in self.switchTypes:
            case = 'case %s' % expr
            try:
                i = types.index(type)
            except ValueError:
                cases.append([case])
                types.append(type)
            else:
                cases[i].append(case)

        return zip(cases, types)


def EnumPolymorphic(enumName, switchExpr, switchTypes, defaultType, contextLess=True):
    enumValues = [expr for expr, type in switchTypes]
    enum = Enum(enumName, enumValues)
    polymorphic = Polymorphic(switchExpr, switchTypes, defaultType, contextLess)
    return enum, polymorphic


class Visitor:
    '''Abstract visitor for the type hierarchy.'''

    def visit(self, type, *args, **kwargs):
        return type.visit(self, *args, **kwargs)

    def visitVoid(self, void, *args, **kwargs):
        raise NotImplementedError

    def visitLiteral(self, literal, *args, **kwargs):
        raise NotImplementedError

    def visitString(self, string, *args, **kwargs):
        raise NotImplementedError

    def visitConst(self, const, *args, **kwargs):
        raise NotImplementedError

    def visitStruct(self, struct, *args, **kwargs):
        raise NotImplementedError

    def visitArray(self, array, *args, **kwargs):
        raise NotImplementedError

    def visitAttribArray(self, array, *args, **kwargs):
        raise NotImplementedError

    def visitBlob(self, blob, *args, **kwargs):
        raise NotImplementedError

    def visitEnum(self, enum, *args, **kwargs):
        raise NotImplementedError

    def visitBitmask(self, bitmask, *args, **kwargs):
        raise NotImplementedError

    def visitPointer(self, pointer, *args, **kwargs):
        raise NotImplementedError

    def visitIntPointer(self, pointer, *args, **kwargs):
        raise NotImplementedError

    def visitObjPointer(self, pointer, *args, **kwargs):
        raise NotImplementedError

    def visitLinearPointer(self, pointer, *args, **kwargs):
        raise NotImplementedError

    def visitReference(self, reference, *args, **kwargs):
        raise NotImplementedError

    def visitHandle(self, handle, *args, **kwargs):
        raise NotImplementedError

    def visitAlias(self, alias, *args, **kwargs):
        raise NotImplementedError

    def visitOpaque(self, opaque, *args, **kwargs):
        raise NotImplementedError

    def visitInterface(self, interface, *args, **kwargs):
        raise NotImplementedError

    def visitPolymorphic(self, polymorphic, *args, **kwargs):
        raise NotImplementedError
        #return self.visit(polymorphic.defaultType, *args, **kwargs)


class OnceVisitor(Visitor):
    '''Visitor that guarantees that each type is visited only once.'''

    def __init__(self):
        self.__visited = set()

    def visit(self, type, *args, **kwargs):
        if type not in self.__visited:
            self.__visited.add(type)
            return type.visit(self, *args, **kwargs)
        return None


class Rebuilder(Visitor):
    '''Visitor which rebuild types as it visits them.

    By itself it is a no-op -- it is intended to be overwritten.
    '''

    def visitVoid(self, void):
        return void

    def visitLiteral(self, literal):
        return literal

    def visitString(self, string):
        string_type = self.visit(string.type)
        if string_type is string.type:
            return string
        else:
            return String(string_type, string.length, string.wide)

    def visitConst(self, const):
        const_type = self.visit(const.type)
        if const_type is const.type:
            return const
        else:
            return Const(const_type)

    def visitStruct(self, struct):
        members = [(self.visit(type), name) for type, name in struct.members]
        return Struct(struct.name, members)

    def visitArray(self, array):
        type = self.visit(array.type)
        return Array(type, array.length)

    def visitBlob(self, blob):
        type = self.visit(blob.type)
        return Blob(type, blob.size)

    def visitEnum(self, enum):
        return enum

    def visitBitmask(self, bitmask):
        type = self.visit(bitmask.type)
        return Bitmask(type, bitmask.values)

    def visitPointer(self, pointer):
        pointer_type = self.visit(pointer.type)
        if pointer_type is pointer.type:
            return pointer
        else:
            return Pointer(pointer_type)

    def visitIntPointer(self, pointer):
        return pointer

    def visitObjPointer(self, pointer):
        pointer_type = self.visit(pointer.type)
        if pointer_type is pointer.type:
            return pointer
        else:
            return ObjPointer(pointer_type)

    def visitLinearPointer(self, pointer):
        pointer_type = self.visit(pointer.type)
        if pointer_type is pointer.type:
            return pointer
        else:
            return LinearPointer(pointer_type)

    def visitReference(self, reference):
        reference_type = self.visit(reference.type)
        if reference_type is reference.type:
            return reference
        else:
            return Reference(reference_type)

    def visitHandle(self, handle):
        handle_type = self.visit(handle.type)
        if handle_type is handle.type:
            return handle
        else:
            return Handle(handle.name, handle_type, range=handle.range, key=handle.key)

    def visitAlias(self, alias):
        alias_type = self.visit(alias.type)
        if alias_type is alias.type:
            return alias
        else:
            return Alias(alias.expr, alias_type)

    def visitOpaque(self, opaque):
        return opaque

    def visitInterface(self, interface, *args, **kwargs):
        return interface

    def visitPolymorphic(self, polymorphic):
        switchExpr = polymorphic.switchExpr
        switchTypes = [(expr, self.visit(type)) for expr, type in polymorphic.switchTypes]
        if polymorphic.defaultType is None:
            defaultType = None
        else:
            defaultType = self.visit(polymorphic.defaultType)
        return Polymorphic(switchExpr, switchTypes, defaultType, polymorphic.contextLess)


class MutableRebuilder(Rebuilder):
    '''Type visitor which derives a mutable type.'''

    def visitString(self, string):
        return string

    def visitConst(self, const):
        # Strip out const qualifier
        return const.type

    def visitAlias(self, alias):
        # Tear the alias on type changes
        type = self.visit(alias.type)
        if type is alias.type:
            return alias
        return type

    def visitReference(self, reference):
        # Strip out references
        return reference.type


class Traverser(Visitor):
    '''Visitor which all types.'''

    def visitVoid(self, void, *args, **kwargs):
        pass

    def visitLiteral(self, literal, *args, **kwargs):
        pass

    def visitString(self, string, *args, **kwargs):
        pass

    def visitConst(self, const, *args, **kwargs):
        self.visit(const.type, *args, **kwargs)

    def visitStruct(self, struct, *args, **kwargs):
        for type, name in struct.members:
            self.visit(type, *args, **kwargs)

    def visitArray(self, array, *args, **kwargs):
        self.visit(array.type, *args, **kwargs)

    def visitAttribArray(self, attribs, *args, **kwargs):
        for key, valueType in attribs.valueTypes:
            if valueType is not None:
                self.visit(valueType, *args, **kwargs)

    def visitBlob(self, array, *args, **kwargs):
        pass

    def visitEnum(self, enum, *args, **kwargs):
        pass

    def visitBitmask(self, bitmask, *args, **kwargs):
        self.visit(bitmask.type, *args, **kwargs)

    def visitPointer(self, pointer, *args, **kwargs):
        self.visit(pointer.type, *args, **kwargs)

    def visitIntPointer(self, pointer, *args, **kwargs):
        pass

    def visitObjPointer(self, pointer, *args, **kwargs):
        self.visit(pointer.type, *args, **kwargs)

    def visitLinearPointer(self, pointer, *args, **kwargs):
        self.visit(pointer.type, *args, **kwargs)

    def visitReference(self, reference, *args, **kwargs):
        self.visit(reference.type, *args, **kwargs)

    def visitHandle(self, handle, *args, **kwargs):
        self.visit(handle.type, *args, **kwargs)

    def visitAlias(self, alias, *args, **kwargs):
        self.visit(alias.type, *args, **kwargs)

    def visitOpaque(self, opaque, *args, **kwargs):
        pass

    def visitInterface(self, interface, *args, **kwargs):
        if interface.base is not None:
            self.visit(interface.base, *args, **kwargs)
        for method in interface.iterMethods():
            for arg in method.args:
                self.visit(arg.type, *args, **kwargs)
            self.visit(method.type, *args, **kwargs)

    def visitPolymorphic(self, polymorphic, *args, **kwargs):
        for expr, type in polymorphic.switchTypes:
            self.visit(type, *args, **kwargs)
        if polymorphic.defaultType is not None:
            self.visit(polymorphic.defaultType, *args, **kwargs)


class Collector(Traverser):
    '''Visitor which collects all unique types as it traverses them.'''

    def __init__(self):
        self.__visited = set()
        self.types = []

    def visit(self, type):
        if type in self.__visited:
            return
        self.__visited.add(type)
        Visitor.visit(self, type)
        self.types.append(type)


class ExpanderMixin:
    '''Mixin class that provides a bunch of methods to expand C expressions
    from the specifications.'''

    __structs = None
    __indices = None

    def expand(self, expr):
        # Expand a C expression, replacing certain variables
        if not isinstance(expr, basestring):
            return expr
        variables = {}

        if self.__structs is not None:
            variables['self'] = '(%s)' % self.__structs[0]
        if self.__indices is not None:
            variables['i'] = self.__indices[0]

        expandedExpr = expr.format(**variables)
        if expandedExpr != expr and 0:
            sys.stderr.write("  %r -> %r\n" % (expr, expandedExpr))
        return expandedExpr

    def visitMember(self, member, structInstance, *args, **kwargs):
        memberType, memberName = member
        if memberName is None:
            # Anonymous structure/union member
            memberInstance = structInstance
        else:
            memberInstance = '(%s).%s' % (structInstance, memberName)
        self.__structs = (structInstance, self.__structs)
        try:
            return self.visit(memberType, memberInstance, *args, **kwargs)
        finally:
            _, self.__structs = self.__structs

    def visitElement(self, elementIndex, elementType, *args, **kwargs):
        self.__indices = (elementIndex, self.__indices)
        try:
            return self.visit(elementType, *args, **kwargs)
        finally:
            _, self.__indices = self.__indices


class Module:
    '''A collection of functions.'''

    def __init__(self, name = None):
        self.name = name
        self.headers = []
        self.functions = []
        self.interfaces = []

    def addFunctions(self, functions):
        self.functions.extend(functions)

    def addInterfaces(self, interfaces):
        self.interfaces.extend(interfaces)

    def mergeModule(self, module):
        self.headers.extend(module.headers)
        self.functions.extend(module.functions)
        self.interfaces.extend(module.interfaces)

    def getFunctionByName(self, name):
        for function in self.functions:
            if function.name == name:
                return function
        return None


class API:
    '''API abstraction.

    Essentially, a collection of types, functions, and interfaces.
    '''

    def __init__(self, modules = None):
        self.modules = []
        if modules is not None:
            self.modules.extend(modules)

    def getAllTypes(self):
        collector = Collector()
        for module in self.modules:
            for function in module.functions:
                for arg in function.args:
                    collector.visit(arg.type)
                collector.visit(function.type)
            for interface in module.interfaces:
                collector.visit(interface)
                for method in interface.iterMethods():
                    for arg in method.args:
                        collector.visit(arg.type)
                    collector.visit(method.type)
        return collector.types

    def getAllFunctions(self):
        functions = []
        for module in self.modules:
            functions.extend(module.functions)
        return functions

    def getAllInterfaces(self):
        types = self.getAllTypes()
        interfaces = [type for type in types if isinstance(type, Interface)]
        for module in self.modules:
            for interface in module.interfaces:
                if interface not in interfaces:
                    interfaces.append(interface)
        return interfaces

    def addModule(self, module):
        self.modules.append(module)

    def getFunctionByName(self, name):
        for module in self.modules:
            for function in module.functions:
                if function.name == name:
                    return function
        return None


# C string (i.e., zero terminated)
CString = String(Char)
WString = String(WChar, wide=True)
ConstCString = String(Const(Char))
ConstWString = String(Const(WChar), wide=True)

########NEW FILE########
__FILENAME__ = wglapi
##########################################################################
#
# Copyright 2008-2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""WGL API description"""


from glapi import *
from winapi import *
from wglenum import *


wglapi = Module("WGL")


HGLRC = Alias("HGLRC", HANDLE)
PROC = Opaque("PROC")

PFD = Flags(DWORD, [
    "PFD_DOUBLEBUFFER",
    "PFD_STEREO",
    "PFD_DRAW_TO_WINDOW",
    "PFD_DRAW_TO_BITMAP",
    "PFD_SUPPORT_GDI",
    "PFD_SUPPORT_OPENGL",
    "PFD_GENERIC_FORMAT",
    "PFD_NEED_PALETTE",
    "PFD_NEED_SYSTEM_PALETTE",
    "PFD_SWAP_EXCHANGE",
    "PFD_SWAP_COPY",
    "PFD_SWAP_LAYER_BUFFERS",
    "PFD_GENERIC_ACCELERATED",
    "PFD_SUPPORT_DIRECTDRAW",
    "PFD_SUPPORT_COMPOSITION",
    "PFD_DEPTH_DONTCARE",
    "PFD_DOUBLEBUFFER_DONTCARE",
    "PFD_STEREO_DONTCARE",
])

PIXELFORMATDESCRIPTOR = Struct("PIXELFORMATDESCRIPTOR", [
    (WORD, "nSize"),
    (WORD, "nVersion"),
    (PFD, "dwFlags"),
    (BYTE, "iPixelType"),
    (BYTE, "cColorBits"),
    (BYTE, "cRedBits"),
    (BYTE, "cRedShift"),
    (BYTE, "cGreenBits"),
    (BYTE, "cGreenShift"),
    (BYTE, "cBlueBits"),
    (BYTE, "cBlueShift"),
    (BYTE, "cAlphaBits"),
    (BYTE, "cAlphaShift"),
    (BYTE, "cAccumBits"),
    (BYTE, "cAccumRedBits"),
    (BYTE, "cAccumGreenBits"),
    (BYTE, "cAccumBlueBits"),
    (BYTE, "cAccumAlphaBits"),
    (BYTE, "cDepthBits"),
    (BYTE, "cStencilBits"),
    (BYTE, "cAuxBuffers"),
    (BYTE, "iLayerType"),
    (BYTE, "bReserved"),
    (DWORD, "dwLayerMask"),
    (DWORD, "dwVisibleMask"),
    (DWORD, "dwDamageMask"),
])

POINTFLOAT = Struct("POINTFLOAT", [
    (FLOAT, "x"),
    (FLOAT, "y"),
])

GLYPHMETRICSFLOAT = Struct("GLYPHMETRICSFLOAT", [
    (FLOAT, "gmfBlackBoxX"),
    (FLOAT, "gmfBlackBoxY"),
    (POINTFLOAT, "gmfptGlyphOrigin"),
    (FLOAT, "gmfCellIncX"),
    (FLOAT, "gmfCellIncY"),
])
LPGLYPHMETRICSFLOAT = Pointer(GLYPHMETRICSFLOAT)

COLORREF = Alias("COLORREF", DWORD)


LAYERPLANEDESCRIPTOR = Struct("LAYERPLANEDESCRIPTOR", [
    (WORD, "nSize"),
    (WORD, "nVersion"),
    (DWORD, "dwFlags"),
    (BYTE, "iPixelType"),
    (BYTE, "cColorBits"),
    (BYTE, "cRedBits"),
    (BYTE, "cRedShift"),
    (BYTE, "cGreenBits"),
    (BYTE, "cGreenShift"),
    (BYTE, "cBlueBits"),
    (BYTE, "cBlueShift"),
    (BYTE, "cAlphaBits"),
    (BYTE, "cAlphaShift"),
    (BYTE, "cAccumBits"),
    (BYTE, "cAccumRedBits"),
    (BYTE, "cAccumGreenBits"),
    (BYTE, "cAccumBlueBits"),
    (BYTE, "cAccumAlphaBits"),
    (BYTE, "cDepthBits"),
    (BYTE, "cStencilBits"),
    (BYTE, "cAuxBuffers"),
    (BYTE, "iLayerPlane"),
    (BYTE, "bReserved"),
    (COLORREF, "crTransparent"),
])
LPLAYERPLANEDESCRIPTOR = Pointer(LAYERPLANEDESCRIPTOR)

WGLSWAP = Struct("WGLSWAP", [
    (HDC, "hdc"),
    (UINT, "uiFlags"),
])

WGLContextAttribs = AttribArray(Const(WGLenum), [
    ('WGL_CONTEXT_MAJOR_VERSION_ARB', Int),
    ('WGL_CONTEXT_MINOR_VERSION_ARB', Int),
    ('WGL_CONTEXT_LAYER_PLANE_ARB', Int),
    ('WGL_CONTEXT_FLAGS_ARB', Flags(Int, ["WGL_CONTEXT_DEBUG_BIT_ARB", "WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB"])),
    ('WGL_CONTEXT_PROFILE_MASK_ARB', Flags(Int, ["WGL_CONTEXT_CORE_PROFILE_BIT_ARB", "WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB"]))
])

WGLPixelFormatAttribsList = [
    ('WGL_DRAW_TO_WINDOW_ARB', BOOL),
    ('WGL_DRAW_TO_BITMAP_ARB', BOOL),
    ('WGL_ACCELERATION_ARB', FakeEnum(Int, ['WGL_NO_ACCELERATION_ARB', 'WGL_GENERIC_ACCELERATION_ARB', 'WGL_FULL_ACCELERATION_ARB'])),
    ('WGL_NEED_PALETTE_ARB', BOOL),
    ('WGL_NEED_SYSTEM_PALETTE_ARB', BOOL),
    ('WGL_SWAP_LAYER_BUFFERS_ARB', BOOL),
    ('WGL_SWAP_METHOD_ARB', FakeEnum(Int, ['WGL_SWAP_EXCHANGE_ARB', 'WGL_SWAP_COPY_ARB', 'WGL_SWAP_UNDEFINED_ARB'])),
    ('WGL_NUMBER_OVERLAYS_ARB', Int),
    ('WGL_NUMBER_UNDERLAYS_ARB', Int),
    ('WGL_TRANSPARENT_EXT', BOOL),
    ('WGL_TRANSPARENT_VALUE_EXT', Int),
    ('WGL_SHARE_DEPTH_ARB', BOOL),
    ('WGL_SHARE_STENCIL_ARB', BOOL),
    ('WGL_SHARE_ACCUM_ARB', BOOL),
    ('WGL_SUPPORT_GDI_ARB', BOOL),
    ('WGL_SUPPORT_OPENGL_ARB', BOOL),
    ('WGL_DOUBLE_BUFFER_ARB', BOOL),
    ('WGL_STEREO_ARB', BOOL),
    ('WGL_PIXEL_TYPE_ARB', FakeEnum(Int, ['WGL_TYPE_RGBA_ARB', 'WGL_TYPE_COLORINDEX_ARB'])),
    ('WGL_COLOR_BITS_ARB', Int),
    ('WGL_RED_BITS_ARB', Int),
    ('WGL_RED_SHIFT_EXT', Int),
    ('WGL_GREEN_BITS_ARB', Int),
    ('WGL_GREEN_SHIFT_EXT', Int),
    ('WGL_BLUE_BITS_ARB', Int),
    ('WGL_BLUE_SHIFT_EXT', Int),
    ('WGL_ALPHA_BITS_ARB', Int),
    ('WGL_ALPHA_SHIFT_EXT', Int),
    ('WGL_ACCUM_BITS_ARB', Int),
    ('WGL_ACCUM_RED_BITS_ARB', Int),
    ('WGL_ACCUM_GREEN_BITS_ARB', Int),
    ('WGL_ACCUM_BLUE_BITS_ARB', Int),
    ('WGL_ACCUM_ALPHA_BITS_ARB', Int),
    ('WGL_DEPTH_BITS_ARB', Int),
    ('WGL_STENCIL_BITS_ARB', Int),
    ('WGL_AUX_BUFFERS_ARB', Int),
    ('WGL_SAMPLE_BUFFERS_ARB', Int),
    ('WGL_SAMPLES_ARB', Int),
]

WGLPixelFormatAttribs = AttribArray(Const(WGLenum), WGLPixelFormatAttribsList)
WGLPixelFormatFloatAttribs = AttribArray(Const(FLOAT), WGLPixelFormatAttribsList)

WGLCreatePbufferARBAttribs = AttribArray(Const(WGLenum), [
    ('WGL_PBUFFER_LARGEST_ARB', Int)
])

CubeFaceEnum = FakeEnum(Int, [
    'WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB',
    'WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB',
    'WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB',
    'WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB',
    'WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB',
    'WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB'
])

WGLSetPbufferARBAttribs = AttribArray(Const(WGLenum), [
    ('WGL_MIPMAP_LEVEL_ARB', Int),
    ('WGL_CUBE_MAP_FACE_ARB', CubeFaceEnum)
])

HPBUFFERARB = Alias("HPBUFFERARB", HANDLE)
HPBUFFEREXT = Alias("HPBUFFEREXT", HANDLE)
HPVIDEODEV = Alias("HPVIDEODEV", HANDLE)
HVIDEOOUTPUTDEVICENV = Alias("HVIDEOOUTPUTDEVICENV", HANDLE)
HVIDEOINPUTDEVICENV = Alias("HVIDEOINPUTDEVICENV", HANDLE)
HGPUNV = Alias("HGPUNV", HANDLE)

GPU_DEVICE = Struct("_GPU_DEVICE", [
    (DWORD, "cb"),
    (CString, "DeviceName"),
    (CString, "DeviceString"),
    (DWORD, "Flags"),
    (RECT, "rcVirtualScreen"),
])


wglapi.addFunctions([
    # WGL
    StdFunction(HGLRC, "wglCreateContext", [(HDC, "hdc")]),
    StdFunction(BOOL, "wglDeleteContext", [(HGLRC, "hglrc")]),
    StdFunction(HGLRC, "wglGetCurrentContext", [], sideeffects=False),
    StdFunction(BOOL, "wglMakeCurrent", [(HDC, "hdc"), (HGLRC, "hglrc")]),
    StdFunction(BOOL, "wglCopyContext", [(HGLRC, "hglrcSrc"), (HGLRC, "hglrcDst"), (UINT, "mask")]),
    StdFunction(Int, "wglChoosePixelFormat", [(HDC, "hdc"), (Pointer(Const(PIXELFORMATDESCRIPTOR)), "ppfd")]), 
    StdFunction(Int, "wglDescribePixelFormat", [(HDC, "hdc"), (Int, "iPixelFormat"), (UINT, "nBytes"), Out(Pointer(PIXELFORMATDESCRIPTOR), "ppfd")]),
    StdFunction(HDC, "wglGetCurrentDC", [], sideeffects=False),
    StdFunction(PROC, "wglGetDefaultProcAddress", [(LPCSTR, "lpszProc")], sideeffects=False),
    StdFunction(Int, "wglGetPixelFormat", [(HDC, "hdc")], sideeffects=False),
    StdFunction(BOOL, "wglSetPixelFormat", [(HDC, "hdc"), (Int, "iPixelFormat"), (Pointer(Const(PIXELFORMATDESCRIPTOR)), "ppfd")]),
    StdFunction(BOOL, "wglSwapBuffers", [(HDC, "hdc")]),
    StdFunction(BOOL, "wglShareLists", [(HGLRC, "hglrc1"), (HGLRC, "hglrc2")]),
    StdFunction(HGLRC, "wglCreateLayerContext", [(HDC, "hdc"), (Int, "iLayerPlane")]),
    StdFunction(BOOL, "wglDescribeLayerPlane", [(HDC, "hdc"), (Int, "iPixelFormat"), (Int, "iLayerPlane"), (UINT, "nBytes"), Out(Pointer(LAYERPLANEDESCRIPTOR), "plpd")]),
    StdFunction(Int, "wglSetLayerPaletteEntries", [(HDC, "hdc"), (Int, "iLayerPlane"), (Int, "iStart"), (Int, "cEntries"), (Array(Const(COLORREF), "cEntries"), "pcr")]),
    StdFunction(Int, "wglGetLayerPaletteEntries", [(HDC, "hdc"), (Int, "iLayerPlane"), (Int, "iStart"), (Int, "cEntries"), Out(Array(COLORREF, "cEntries"), "pcr")], sideeffects=False),
    StdFunction(BOOL, "wglRealizeLayerPalette", [(HDC, "hdc"), (Int, "iLayerPlane"), (BOOL, "bRealize")]),
    StdFunction(BOOL, "wglSwapLayerBuffers", [(HDC, "hdc"), (UINT, "fuPlanes")]),
    StdFunction(BOOL, "wglUseFontBitmapsA", [(HDC, "hdc"), (DWORD, "first"), (DWORD, "count"), (DWORD, "listBase")]),
    StdFunction(BOOL, "wglUseFontBitmapsW", [(HDC, "hdc"), (DWORD, "first"), (DWORD, "count"), (DWORD, "listBase")]),
    StdFunction(DWORD, "wglSwapMultipleBuffers", [(UINT, "n"), (Array(Const(WGLSWAP), "n"), "ps")]),
    StdFunction(BOOL, "wglUseFontOutlinesA", [(HDC, "hdc"), (DWORD, "first"), (DWORD, "count"), (DWORD, "listBase"), (FLOAT, "deviation"), (FLOAT, "extrusion"), (Int, "format"), (LPGLYPHMETRICSFLOAT, "lpgmf")]),
    StdFunction(BOOL, "wglUseFontOutlinesW", [(HDC, "hdc"), (DWORD, "first"), (DWORD, "count"), (DWORD, "listBase"), (FLOAT, "deviation"), (FLOAT, "extrusion"), (Int, "format"), (LPGLYPHMETRICSFLOAT, "lpgmf")]),

    # WGL_ARB_buffer_region
    StdFunction(HANDLE, "wglCreateBufferRegionARB", [(HDC, "hDC"), (Int, "iLayerPlane"), (UINT, "uType")]),
    StdFunction(VOID, "wglDeleteBufferRegionARB", [(HANDLE, "hRegion")]),
    StdFunction(BOOL, "wglSaveBufferRegionARB", [(HANDLE, "hRegion"), (Int, "x"), (Int, "y"), (Int, "width"), (Int, "height")]),
    StdFunction(BOOL, "wglRestoreBufferRegionARB", [(HANDLE, "hRegion"), (Int, "x"), (Int, "y"), (Int, "width"), (Int, "height"), (Int, "xSrc"), (Int, "ySrc")]),

    # WGL_ARB_extensions_string
    StdFunction(ConstCString, "wglGetExtensionsStringARB", [(HDC, "hdc")], sideeffects=False),

    # WGL_ARB_pixel_format
    StdFunction(BOOL, "wglGetPixelFormatAttribivARB", [(HDC, "hdc"), (Int, "iPixelFormat"), (Int, "iLayerPlane"), (UINT, "nAttributes"), (Array(WGLenum, "nAttributes"), "piAttributes"), Out(Array(Int, "nAttributes"), "piValues")], sideeffects=False),
    StdFunction(BOOL, "wglGetPixelFormatAttribfvARB", [(HDC, "hdc"), (Int, "iPixelFormat"), (Int, "iLayerPlane"), (UINT, "nAttributes"), (Array(WGLenum, "nAttributes"), "piAttributes"), Out(Array(FLOAT, "nAttributes"), "pfValues")], sideeffects=False),
    StdFunction(BOOL, "wglChoosePixelFormatARB", [(HDC, "hdc"), (WGLPixelFormatAttribs, "piAttribIList"), (WGLPixelFormatFloatAttribs, "pfAttribFList"), (UINT, "nMaxFormats"), Out(Array(Int, "(*nNumFormats)"), "piFormats"), Out(Pointer(UINT), "nNumFormats")]),

    # WGL_ARB_make_current_read
    StdFunction(BOOL, "wglMakeContextCurrentARB", [(HDC, "hDrawDC"), (HDC, "hReadDC"), (HGLRC, "hglrc")]),
    StdFunction(HDC, "wglGetCurrentReadDCARB", [], sideeffects=False),

    # WGL_ARB_pbuffer
    StdFunction(HPBUFFERARB, "wglCreatePbufferARB", [(HDC, "hDC"), (Int, "iPixelFormat"), (Int, "iWidth"), (Int, "iHeight"), (WGLCreatePbufferARBAttribs, "piAttribList")]),
    StdFunction(HDC, "wglGetPbufferDCARB", [(HPBUFFERARB, "hPbuffer")]),
    StdFunction(Int, "wglReleasePbufferDCARB", [(HPBUFFERARB, "hPbuffer"), (HDC, "hDC")]),
    StdFunction(BOOL, "wglDestroyPbufferARB", [(HPBUFFERARB, "hPbuffer")]),
    StdFunction(BOOL, "wglQueryPbufferARB", [(HPBUFFERARB, "hPbuffer"), (WGLenum, "iAttribute"), Out(Pointer(Int), "piValue")], sideeffects=False),

    # WGL_ARB_render_texture
    StdFunction(BOOL, "wglBindTexImageARB", [(HPBUFFERARB, "hPbuffer"), (Int, "iBuffer")]),
    StdFunction(BOOL, "wglReleaseTexImageARB", [(HPBUFFERARB, "hPbuffer"), (Int, "iBuffer")]),
    StdFunction(BOOL, "wglSetPbufferAttribARB", [(HPBUFFERARB, "hPbuffer"), (WGLSetPbufferARBAttribs, "piAttribList")]),

    # WGL_ARB_create_context
    StdFunction(HGLRC, "wglCreateContextAttribsARB", [(HDC, "hDC"), (HGLRC, "hShareContext"), (WGLContextAttribs, "attribList")]),

    # WGL_EXT_display_color_table
    StdFunction(GLboolean, "wglCreateDisplayColorTableEXT", [(GLushort, "id")]),
    StdFunction(GLboolean, "wglLoadDisplayColorTableEXT", [(Array(Const(GLushort), "length"), "table"), (GLuint, "length")]),
    StdFunction(GLboolean, "wglBindDisplayColorTableEXT", [(GLushort, "id")]),
    StdFunction(VOID, "wglDestroyDisplayColorTableEXT", [(GLushort, "id")]),

    # WGL_EXT_extensions_string
    StdFunction(ConstCString, "wglGetExtensionsStringEXT", [], sideeffects=False),

    # WGL_EXT_make_current_read
    StdFunction(BOOL, "wglMakeContextCurrentEXT", [(HDC, "hDrawDC"), (HDC, "hReadDC"), (HGLRC, "hglrc")]),
    StdFunction(HDC, "wglGetCurrentReadDCEXT", [], sideeffects=False),

    # WGL_EXT_pbuffer
    StdFunction(HPBUFFEREXT, "wglCreatePbufferEXT", [(HDC, "hDC"), (Int, "iPixelFormat"), (Int, "iWidth"), (Int, "iHeight"), (WGLCreatePbufferARBAttribs, "piAttribList")]),
    StdFunction(HDC, "wglGetPbufferDCEXT", [(HPBUFFEREXT, "hPbuffer")], sideeffects=False),
    StdFunction(Int, "wglReleasePbufferDCEXT", [(HPBUFFEREXT, "hPbuffer"), (HDC, "hDC")]),
    StdFunction(BOOL, "wglDestroyPbufferEXT", [(HPBUFFEREXT, "hPbuffer")]),
    StdFunction(BOOL, "wglQueryPbufferEXT", [(HPBUFFEREXT, "hPbuffer"), (WGLenum, "iAttribute"), Out(Pointer(Int), "piValue")], sideeffects=False),

    # WGL_EXT_pixel_format
    StdFunction(BOOL, "wglGetPixelFormatAttribivEXT", [(HDC, "hdc"), (Int, "iPixelFormat"), (Int, "iLayerPlane"), (UINT, "nAttributes"), (Array(WGLenum, "nAttributes"), "piAttributes"), Out(Array(Int, "nAttributes"), "piValues")], sideeffects=False),
    StdFunction(BOOL, "wglGetPixelFormatAttribfvEXT", [(HDC, "hdc"), (Int, "iPixelFormat"), (Int, "iLayerPlane"), (UINT, "nAttributes"), (Array(WGLenum, "nAttributes"), "piAttributes"), Out(Array(FLOAT, "nAttributes"), "pfValues")], sideeffects=False),
    StdFunction(BOOL, "wglChoosePixelFormatEXT", [(HDC, "hdc"), (WGLPixelFormatAttribs, "piAttribIList"), (WGLPixelFormatFloatAttribs, "pfAttribFList"), (UINT, "nMaxFormats"), Out(Array(Int, "*nNumFormats"), "piFormats"), Out(Pointer(UINT), "nNumFormats")]),

    # WGL_EXT_swap_control
    StdFunction(BOOL, "wglSwapIntervalEXT", [(Int, "interval")]),
    StdFunction(Int, "wglGetSwapIntervalEXT", [], sideeffects=False),

    # WGL_NV_vertex_array_range
    StdFunction(OpaquePointer(Void), "wglAllocateMemoryNV", [(GLsizei, "size"), (GLfloat, "readfreq"), (GLfloat, "writefreq"), (GLfloat, "priority")]),
    StdFunction(Void, "wglFreeMemoryNV", [(OpaquePointer(Void), "pointer")]),

    # WGL_OML_sync_control
    StdFunction(BOOL, "wglGetSyncValuesOML", [(HDC, "hdc"), Out(Pointer(INT64), "ust"), Out(Pointer(INT64), "msc"), Out(Pointer(INT64), "sbc")], sideeffects=False),
    StdFunction(BOOL, "wglGetMscRateOML", [(HDC, "hdc"), Out(Pointer(INT32), "numerator"), Out(Pointer(INT32), "denominator")], sideeffects=False),
    StdFunction(INT64, "wglSwapBuffersMscOML", [(HDC, "hdc"), (INT64, "target_msc"), (INT64, "divisor"), (INT64, "remainder")]),
    StdFunction(INT64, "wglSwapLayerBuffersMscOML", [(HDC, "hdc"), (Int, "fuPlanes"), (INT64, "target_msc"), (INT64, "divisor"), (INT64, "remainder")]),
    StdFunction(BOOL, "wglWaitForMscOML", [(HDC, "hdc"), (INT64, "target_msc"), (INT64, "divisor"), (INT64, "remainder"), Out(Pointer(INT64), "ust"), Out(Pointer(INT64), "msc"), Out(Pointer(INT64), "sbc")]),
    StdFunction(BOOL, "wglWaitForSbcOML", [(HDC, "hdc"), (INT64, "target_sbc"), Out(Pointer(INT64), "ust"), Out(Pointer(INT64), "msc"), Out(Pointer(INT64), "sbc")]),

    # WGL_I3D_digital_video_control
    StdFunction(BOOL, "wglGetDigitalVideoParametersI3D", [(HDC, "hDC"), (Int, "iAttribute"), Out(OpaqueArray(Int, "_wglGetDigitalVideoParametersI3D_size(iAttribute)"), "piValue")], sideeffects=False),
    StdFunction(BOOL, "wglSetDigitalVideoParametersI3D", [(HDC, "hDC"), (Int, "iAttribute"), (OpaqueArray(Const(Int), "_wglSetDigitalVideoParametersI3D_size(iAttribute)"), "piValue")]),

    # WGL_I3D_gamma
    StdFunction(BOOL, "wglGetGammaTableParametersI3D", [(HDC, "hDC"), (Int, "iAttribute"), Out(OpaqueArray(Int, "_wglGetGammaTableParametersI3D_size(iAttribute)"), "piValue")], sideeffects=False),
    StdFunction(BOOL, "wglSetGammaTableParametersI3D", [(HDC, "hDC"), (Int, "iAttribute"), (OpaqueArray(Const(Int), "_wglSetGammaTableParametersI3D_size(iAttribute)"), "piValue")]),
    StdFunction(BOOL, "wglGetGammaTableI3D", [(HDC, "hDC"), (Int, "iEntries"), Out(Array(USHORT, "iEntries"), "puRed"), Out(Array(USHORT, "iEntries"), "puGreen"), Out(Array(USHORT, "iEntries"), "puBlue")], sideeffects=False),
    StdFunction(BOOL, "wglSetGammaTableI3D", [(HDC, "hDC"), (Int, "iEntries"), (Array(Const(USHORT), "iEntries"), "puRed"), (Array(Const(USHORT), "iEntries"), "puGreen"), (Array(Const(USHORT), "iEntries"), "puBlue")]),

    # WGL_I3D_genlock
    StdFunction(BOOL, "wglEnableGenlockI3D", [(HDC, "hDC")]),
    StdFunction(BOOL, "wglDisableGenlockI3D", [(HDC, "hDC")]),
    StdFunction(BOOL, "wglIsEnabledGenlockI3D", [(HDC, "hDC"), Out(Pointer(BOOL), "pFlag")], sideeffects=False),
    StdFunction(BOOL, "wglGenlockSourceI3D", [(HDC, "hDC"), (UINT, "uSource")]),
    StdFunction(BOOL, "wglGetGenlockSourceI3D", [(HDC, "hDC"), Out(Pointer(UINT), "uSource")], sideeffects=False),
    StdFunction(BOOL, "wglGenlockSourceEdgeI3D", [(HDC, "hDC"), (UINT, "uEdge")]),
    StdFunction(BOOL, "wglGetGenlockSourceEdgeI3D", [(HDC, "hDC"), Out(Pointer(UINT), "uEdge")], sideeffects=False),
    StdFunction(BOOL, "wglGenlockSampleRateI3D", [(HDC, "hDC"), (UINT, "uRate")]),
    StdFunction(BOOL, "wglGetGenlockSampleRateI3D", [(HDC, "hDC"), Out(Pointer(UINT), "uRate")], sideeffects=False),
    StdFunction(BOOL, "wglGenlockSourceDelayI3D", [(HDC, "hDC"), (UINT, "uDelay")]),
    StdFunction(BOOL, "wglGetGenlockSourceDelayI3D", [(HDC, "hDC"), Out(Pointer(UINT), "uDelay")], sideeffects=False),
    StdFunction(BOOL, "wglQueryGenlockMaxSourceDelayI3D", [(HDC, "hDC"), Out(Pointer(UINT), "uMaxLineDelay"), Out(Pointer(UINT), "uMaxPixelDelay")]),

    # WGL_I3D_image_buffer
    StdFunction(LPVOID, "wglCreateImageBufferI3D", [(HDC, "hDC"), (DWORD, "dwSize"), (UINT, "uFlags")]),
    StdFunction(BOOL, "wglDestroyImageBufferI3D", [(HDC, "hDC"), (LPVOID, "pAddress")]),
    StdFunction(BOOL, "wglAssociateImageBufferEventsI3D", [(HDC, "hDC"), (Array(Const(HANDLE), "count"), "pEvent"), (Array(Const(LPVOID), "count"), "pAddress"), (Array(Const(DWORD), "count"), "pSize"), (UINT, "count")]),
    StdFunction(BOOL, "wglReleaseImageBufferEventsI3D", [(HDC, "hDC"), (Array(Const(LPVOID), "count"), "pAddress"), (UINT, "count")]),

    # WGL_I3D_swap_frame_lock
    StdFunction(BOOL, "wglEnableFrameLockI3D", []),
    StdFunction(BOOL, "wglDisableFrameLockI3D", []),
    StdFunction(BOOL, "wglIsEnabledFrameLockI3D", [Out(Pointer(BOOL), "pFlag")], sideeffects=False),
    StdFunction(BOOL, "wglQueryFrameLockMasterI3D", [Out(Pointer(BOOL), "pFlag")]),

    # WGL_I3D_swap_frame_usage
    StdFunction(BOOL, "wglGetFrameUsageI3D", [Out(Pointer(Float), "pUsage")], sideeffects=False),
    StdFunction(BOOL, "wglBeginFrameTrackingI3D", []),
    StdFunction(BOOL, "wglEndFrameTrackingI3D", []),
    StdFunction(BOOL, "wglQueryFrameTrackingI3D", [Out(Pointer(DWORD), "pFrameCount"), Out(Pointer(DWORD), "pMissedFrames"), Out(Pointer(Float), "pLastMissedUsage")]),

    # WGL_3DL_stereo_control
    StdFunction(BOOL, "wglSetStereoEmitterState3DL", [(HDC, "hDC"), (UINT, "uState")]),

    # WGL_NV_present_video
    StdFunction(Int, "wglEnumerateVideoDevicesNV", [(HDC, "hDC"), Out(OpaquePointer(HVIDEOOUTPUTDEVICENV), "phDeviceList")]),
    StdFunction(BOOL, "wglBindVideoDeviceNV", [(HDC, "hDC"), (UInt, "uVideoSlot"), (HVIDEOOUTPUTDEVICENV, "hVideoDevice"), (OpaqueArray(Const(Int), "_wglBindVideoDeviceNV_size()"), "piAttribList")]),
    StdFunction(BOOL, "wglQueryCurrentContextNV", [(Int, "iAttribute"), Out(OpaqueArray(Int, "_wglQueryCurrentContextNV_size()"), "piValue")]),

    # WGL_NV_video_output
    StdFunction(BOOL, "wglGetVideoDeviceNV", [(HDC, "hDC"), (Int, "numDevices"), Out(Pointer(HPVIDEODEV), "hVideoDevice")], sideeffects=False),
    StdFunction(BOOL, "wglReleaseVideoDeviceNV", [(HPVIDEODEV, "hVideoDevice")]),
    StdFunction(BOOL, "wglBindVideoImageNV", [(HPVIDEODEV, "hVideoDevice"), (HPBUFFERARB, "hPbuffer"), (Int, "iVideoBuffer")]),
    StdFunction(BOOL, "wglReleaseVideoImageNV", [(HPBUFFERARB, "hPbuffer"), (Int, "iVideoBuffer")]),
    StdFunction(BOOL, "wglSendPbufferToVideoNV", [(HPBUFFERARB, "hPbuffer"), (Int, "iBufferType"), Out(Pointer(ULong), "pulCounterPbuffer"), (BOOL, "bBlock")]),
    StdFunction(BOOL, "wglGetVideoInfoNV", [(HPVIDEODEV, "hpVideoDevice"), Out(Pointer(ULong), "pulCounterOutputPbuffer"), Out(Pointer(ULong), "pulCounterOutputVideo")], sideeffects=False),

    # WGL_NV_swap_group
    StdFunction(BOOL, "wglJoinSwapGroupNV", [(HDC, "hDC"), (GLuint, "group")]),
    StdFunction(BOOL, "wglBindSwapBarrierNV", [(GLuint, "group"), (GLuint, "barrier")]),
    StdFunction(BOOL, "wglQuerySwapGroupNV", [(HDC, "hDC"), Out(Pointer(GLuint), "group"), Out(Pointer(GLuint), "barrier")]),
    StdFunction(BOOL, "wglQueryMaxSwapGroupsNV", [(HDC, "hDC"), Out(Pointer(GLuint), "maxGroups"), Out(Pointer(GLuint), "maxBarriers")]),
    StdFunction(BOOL, "wglQueryFrameCountNV", [(HDC, "hDC"), Out(Pointer(GLuint), "count")]),
    StdFunction(BOOL, "wglResetFrameCountNV", [(HDC, "hDC")]),

    # WGL_NV_gpu_affinity
    StdFunction(BOOL, "wglEnumGpusNV", [(UINT, "iGpuIndex"), Out(Pointer(HGPUNV), "phGpu")]),
    StdFunction(BOOL, "wglEnumGpuDevicesNV", [(HGPUNV, "hGpu"), (UINT, "iDeviceIndex"), Out(Pointer(GPU_DEVICE), "lpGpuDevice")]),
    StdFunction(HDC, "wglCreateAffinityDCNV", [(OpaqueArray(Const(HGPUNV), "_wglCreateAffinityDCNV_size()"), "phGpuList")]),
    StdFunction(BOOL, "wglEnumGpusFromAffinityDCNV", [(HDC, "hAffinityDC"), (UINT, "iGpuIndex"), Out(Pointer(HGPUNV), "hGpu")]),
    StdFunction(BOOL, "wglDeleteDCNV", [(HDC, "hdc")]),

    # WGL_AMD_gpu_association
    StdFunction(UINT, "wglGetGPUIDsAMD", [(UINT, "maxCount"), Out(Array(UINT, "maxCount"), "ids")], sideeffects=False),
    StdFunction(INT, "wglGetGPUInfoAMD", [(UINT, "id"), (Int, "property"), (GLenum, "dataType"), (UINT, "size"), Out(OpaqueBlob(Void, "_wglGetGPUInfoAMD_size(dataType,size)"), "data")], sideeffects=False),
    StdFunction(UINT, "wglGetContextGPUIDAMD", [(HGLRC, "hglrc")], sideeffects=False),
    StdFunction(HGLRC, "wglCreateAssociatedContextAMD", [(UINT, "id")]),
    StdFunction(HGLRC, "wglCreateAssociatedContextAttribsAMD", [(UINT, "id"), (HGLRC, "hShareContext"), (OpaqueArray(Const(Int), "_wglCreateAssociatedContextAttribsAMD_size()"), "attribList")]),
    StdFunction(BOOL, "wglDeleteAssociatedContextAMD", [(HGLRC, "hglrc")]),
    StdFunction(BOOL, "wglMakeAssociatedContextCurrentAMD", [(HGLRC, "hglrc")]),
    StdFunction(HGLRC, "wglGetCurrentAssociatedContextAMD", [], sideeffects=False),
    StdFunction(VOID, "wglBlitContextFramebufferAMD", [(HGLRC, "dstCtx"), (GLint, "srcX0"), (GLint, "srcY0"), (GLint, "srcX1"), (GLint, "srcY1"), (GLint, "dstX0"), (GLint, "dstY0"), (GLint, "dstX1"), (GLint, "dstY1"), (GLbitfield, "mask"), (GLenum, "filter")]),

    # WGL_NV_video_capture
    StdFunction(BOOL, "wglBindVideoCaptureDeviceNV", [(UINT, "uVideoSlot"), (HVIDEOINPUTDEVICENV, "hDevice")]),
    StdFunction(UINT, "wglEnumerateVideoCaptureDevicesNV", [(HDC, "hDc"), Out(Pointer(HVIDEOINPUTDEVICENV), "phDeviceList")]),
    StdFunction(BOOL, "wglLockVideoCaptureDeviceNV", [(HDC, "hDc"), (HVIDEOINPUTDEVICENV, "hDevice")]),
    StdFunction(BOOL, "wglQueryVideoCaptureDeviceNV", [(HDC, "hDc"), (HVIDEOINPUTDEVICENV, "hDevice"), (Int, "iAttribute"), Out(Pointer(Int), "piValue")]),
    StdFunction(BOOL, "wglReleaseVideoCaptureDeviceNV", [(HDC, "hDc"), (HVIDEOINPUTDEVICENV, "hDevice")]),

    # WGL_NV_copy_image
    StdFunction(BOOL, "wglCopyImageSubDataNV", [(HGLRC, "hSrcRC"), (GLuint, "srcName"), (GLenum, "srcTarget"), (GLint, "srcLevel"), (GLint, "srcX"), (GLint, "srcY"), (GLint, "srcZ"), (HGLRC, "hDstRC"), (GLuint, "dstName"), (GLenum, "dstTarget"), (GLint, "dstLevel"), (GLint, "dstX"), (GLint, "dstY"), (GLint, "dstZ"), (GLsizei, "width"), (GLsizei, "height"), (GLsizei, "depth")]),

    # WGL_NV_DX_interop
    StdFunction(BOOL, "wglDXSetResourceShareHandleNV", [(OpaquePointer(Void), "dxObject"), (HANDLE, "shareHandle")]),
    StdFunction(HANDLE, "wglDXOpenDeviceNV", [(OpaquePointer(Void), "dxDevice")]),
    StdFunction(BOOL, "wglDXCloseDeviceNV", [(HANDLE, "hDevice")]),
    StdFunction(HANDLE, "wglDXRegisterObjectNV", [(HANDLE, "hDevice"), (OpaquePointer(Void), "dxObject"), (GLuint, "name"), (GLenum, "type"), (GLenum, "access")]),
    StdFunction(BOOL, "wglDXUnregisterObjectNV", [(HANDLE, "hDevice"), (HANDLE, "hObject")]),
    StdFunction(BOOL, "wglDXObjectAccessNV", [(HANDLE, "hObject"), (GLenum, "access")]),
    StdFunction(BOOL, "wglDXLockObjectsNV", [(HANDLE, "hDevice"), (GLint, "count"), Out(Array(HANDLE, "count"), "hObjects")]),
    StdFunction(BOOL, "wglDXUnlockObjectsNV", [(HANDLE, "hDevice"), (GLint, "count"), Out(Array(HANDLE, "count"), "hObjects")]),

    # must be last
    StdFunction(PROC, "wglGetProcAddress", [(LPCSTR, "lpszProc")]),
])

########NEW FILE########
__FILENAME__ = wglenum
##########################################################################
#
# Copyright 2008-2011 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""WGL enum description"""


from stdapi import *

WGLenum = FakeEnum(Int, [
    "WGL_GPU_VENDOR_AMD",		# 0x1F00
    "WGL_GPU_RENDERER_STRING_AMD",		# 0x1F01
    "WGL_GPU_OPENGL_VERSION_STRING_AMD",		# 0x1F02
    "WGL_NUMBER_PIXEL_FORMATS_ARB",		# 0x2000
    "WGL_DRAW_TO_WINDOW_ARB",		# 0x2001
    "WGL_DRAW_TO_BITMAP_ARB",		# 0x2002
    "WGL_ACCELERATION_ARB",		# 0x2003
    "WGL_NEED_PALETTE_ARB",		# 0x2004
    "WGL_NEED_SYSTEM_PALETTE_ARB",		# 0x2005
    "WGL_SWAP_LAYER_BUFFERS_ARB",		# 0x2006
    "WGL_SWAP_METHOD_ARB",		# 0x2007
    "WGL_NUMBER_OVERLAYS_ARB",		# 0x2008
    "WGL_NUMBER_UNDERLAYS_ARB",		# 0x2009
    "WGL_TRANSPARENT_ARB",		# 0x200A
    "WGL_TRANSPARENT_VALUE_EXT",		# 0x200B
    "WGL_SHARE_DEPTH_ARB",		# 0x200C
    "WGL_SHARE_STENCIL_ARB",		# 0x200D
    "WGL_SHARE_ACCUM_ARB",		# 0x200E
    "WGL_SUPPORT_GDI_ARB",		# 0x200F
    "WGL_SUPPORT_OPENGL_ARB",		# 0x2010
    "WGL_DOUBLE_BUFFER_ARB",		# 0x2011
    "WGL_STEREO_ARB",		# 0x2012
    "WGL_PIXEL_TYPE_ARB",		# 0x2013
    "WGL_COLOR_BITS_ARB",		# 0x2014
    "WGL_RED_BITS_ARB",		# 0x2015
    "WGL_RED_SHIFT_ARB",		# 0x2016
    "WGL_GREEN_BITS_ARB",		# 0x2017
    "WGL_GREEN_SHIFT_ARB",		# 0x2018
    "WGL_BLUE_BITS_ARB",		# 0x2019
    "WGL_BLUE_SHIFT_ARB",		# 0x201A
    "WGL_ALPHA_BITS_ARB",		# 0x201B
    "WGL_ALPHA_SHIFT_ARB",		# 0x201C
    "WGL_ACCUM_BITS_ARB",		# 0x201D
    "WGL_ACCUM_RED_BITS_ARB",		# 0x201E
    "WGL_ACCUM_GREEN_BITS_ARB",		# 0x201F
    "WGL_ACCUM_BLUE_BITS_ARB",		# 0x2020
    "WGL_ACCUM_ALPHA_BITS_ARB",		# 0x2021
    "WGL_DEPTH_BITS_ARB",		# 0x2022
    "WGL_STENCIL_BITS_ARB",		# 0x2023
    "WGL_AUX_BUFFERS_ARB",		# 0x2024
    "WGL_NO_ACCELERATION_ARB",		# 0x2025
    "WGL_GENERIC_ACCELERATION_ARB",		# 0x2026
    "WGL_FULL_ACCELERATION_ARB",		# 0x2027
    "WGL_SWAP_EXCHANGE_ARB",		# 0x2028
    "WGL_SWAP_COPY_ARB",		# 0x2029
    "WGL_SWAP_UNDEFINED_ARB",		# 0x202A
    "WGL_TYPE_RGBA_ARB",		# 0x202B
    "WGL_TYPE_COLORINDEX_ARB",		# 0x202C
    "WGL_DRAW_TO_PBUFFER_ARB",		# 0x202D
    "WGL_MAX_PBUFFER_PIXELS_ARB",		# 0x202E
    "WGL_MAX_PBUFFER_WIDTH_ARB",		# 0x202F
    "WGL_MAX_PBUFFER_HEIGHT_ARB",		# 0x2030
    "WGL_OPTIMAL_PBUFFER_WIDTH_EXT",		# 0x2031
    "WGL_OPTIMAL_PBUFFER_HEIGHT_EXT",		# 0x2032
    "WGL_PBUFFER_LARGEST_ARB",		# 0x2033
    "WGL_PBUFFER_WIDTH_ARB",		# 0x2034
    "WGL_PBUFFER_HEIGHT_ARB",		# 0x2035
    "WGL_PBUFFER_LOST_ARB",		# 0x2036
    "WGL_TRANSPARENT_RED_VALUE_ARB",		# 0x2037
    "WGL_TRANSPARENT_GREEN_VALUE_ARB",		# 0x2038
    "WGL_TRANSPARENT_BLUE_VALUE_ARB",		# 0x2039
    "WGL_TRANSPARENT_ALPHA_VALUE_ARB",		# 0x203A
    "WGL_TRANSPARENT_INDEX_VALUE_ARB",		# 0x203B
    "WGL_DEPTH_FLOAT_EXT",		# 0x2040
    "WGL_SAMPLE_BUFFERS_ARB",		# 0x2041
    "WGL_SAMPLES_ARB",		# 0x2042
    "ERROR_INVALID_PIXEL_TYPE_ARB",		# 0x2043
    "WGL_GENLOCK_SOURCE_MULTIVIEW_I3D",		# 0x2044
    "WGL_GENLOCK_SOURCE_EXTERNAL_SYNC_I3D",		# 0x2045
    "WGL_GENLOCK_SOURCE_EXTERNAL_FIELD_I3D",		# 0x2046
    "WGL_GENLOCK_SOURCE_EXTERNAL_TTL_I3D",		# 0x2047
    "WGL_GENLOCK_SOURCE_DIGITAL_SYNC_I3D",		# 0x2048
    "WGL_GENLOCK_SOURCE_DIGITAL_FIELD_I3D",		# 0x2049
    "WGL_GENLOCK_SOURCE_EDGE_FALLING_I3D",		# 0x204A
    "WGL_GENLOCK_SOURCE_EDGE_RISING_I3D",		# 0x204B
    "WGL_GENLOCK_SOURCE_EDGE_BOTH_I3D",		# 0x204C
    "WGL_GAMMA_TABLE_SIZE_I3D",		# 0x204E
    "WGL_GAMMA_EXCLUDE_DESKTOP_I3D",		# 0x204F
    "WGL_DIGITAL_VIDEO_CURSOR_ALPHA_FRAMEBUFFER_I3D",		# 0x2050
    "WGL_DIGITAL_VIDEO_CURSOR_ALPHA_VALUE_I3D",		# 0x2051
    "WGL_DIGITAL_VIDEO_CURSOR_INCLUDED_I3D",		# 0x2052
    "WGL_DIGITAL_VIDEO_GAMMA_CORRECTED_I3D",		# 0x2053
    "ERROR_INCOMPATIBLE_DEVICE_CONTEXTS_ARB",		# 0x2054
    "WGL_STEREO_EMITTER_ENABLE_3DL",		# 0x2055
    "WGL_STEREO_EMITTER_DISABLE_3DL",		# 0x2056
    "WGL_STEREO_POLARITY_NORMAL_3DL",		# 0x2057
    "WGL_STEREO_POLARITY_INVERT_3DL",		# 0x2058
    "WGL_SAMPLE_BUFFERS_3DFX",		# 0x2060
    "WGL_SAMPLES_3DFX",		# 0x2061
    "WGL_BIND_TO_TEXTURE_RGB_ARB",		# 0x2070
    "WGL_BIND_TO_TEXTURE_RGBA_ARB",		# 0x2071
    "WGL_TEXTURE_FORMAT_ARB",		# 0x2072
    "WGL_TEXTURE_TARGET_ARB",		# 0x2073
    "WGL_MIPMAP_TEXTURE_ARB",		# 0x2074
    "WGL_TEXTURE_RGB_ARB",		# 0x2075
    "WGL_TEXTURE_RGBA_ARB",		# 0x2076
    "WGL_NO_TEXTURE_ARB",		# 0x2077
    "WGL_TEXTURE_CUBE_MAP_ARB",		# 0x2078
    "WGL_TEXTURE_1D_ARB",		# 0x2079
    "WGL_TEXTURE_2D_ARB",		# 0x207A
    "WGL_MIPMAP_LEVEL_ARB",		# 0x207B
    "WGL_CUBE_MAP_FACE_ARB",		# 0x207C
    "WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB",		# 0x207D
    "WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB",		# 0x207E
    "WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB",		# 0x207F
    "WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB",		# 0x2080
    "WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB",		# 0x2081
    "WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB",		# 0x2082
    "WGL_FRONT_LEFT_ARB",		# 0x2083
    "WGL_FRONT_RIGHT_ARB",		# 0x2084
    "WGL_BACK_LEFT_ARB",		# 0x2085
    "WGL_BACK_RIGHT_ARB",		# 0x2086
    "WGL_AUX0_ARB",		# 0x2087
    "WGL_AUX1_ARB",		# 0x2088
    "WGL_AUX2_ARB",		# 0x2089
    "WGL_AUX3_ARB",		# 0x208A
    "WGL_AUX4_ARB",		# 0x208B
    "WGL_AUX5_ARB",		# 0x208C
    "WGL_AUX6_ARB",		# 0x208D
    "WGL_AUX7_ARB",		# 0x208E
    "WGL_AUX8_ARB",		# 0x208F
    "WGL_AUX9_ARB",		# 0x2090
    "WGL_CONTEXT_MAJOR_VERSION_ARB",		# 0x2091
    "WGL_CONTEXT_MINOR_VERSION_ARB",		# 0x2092
    "WGL_CONTEXT_LAYER_PLANE_ARB",		# 0x2093
    "WGL_CONTEXT_FLAGS_ARB",		# 0x2094
    "ERROR_INVALID_VERSION_ARB",		# 0x2095
    "ERROR_INVALID_PROFILE_ARB",		# 0x2096
    "WGL_BIND_TO_TEXTURE_RECTANGLE_RGB_NV",		# 0x20A0
    "WGL_BIND_TO_TEXTURE_RECTANGLE_RGBA_NV",		# 0x20A1
    "WGL_TEXTURE_RECTANGLE_NV",		# 0x20A2
    "WGL_BIND_TO_TEXTURE_DEPTH_NV",		# 0x20A3
    "WGL_BIND_TO_TEXTURE_RECTANGLE_DEPTH_NV",		# 0x20A4
    "WGL_DEPTH_TEXTURE_FORMAT_NV",		# 0x20A5
    "WGL_TEXTURE_DEPTH_COMPONENT_NV",		# 0x20A6
    "WGL_DEPTH_COMPONENT_NV",		# 0x20A7
    "WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT",		# 0x20A8
    "WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB",		# 0x20A9
    "WGL_FLOAT_COMPONENTS_NV",		# 0x20B0
    "WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV",		# 0x20B1
    "WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV",		# 0x20B2
    "WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV",		# 0x20B3
    "WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV",		# 0x20B4
    "WGL_TEXTURE_FLOAT_R_NV",		# 0x20B5
    "WGL_TEXTURE_FLOAT_RG_NV",		# 0x20B6
    "WGL_TEXTURE_FLOAT_RGB_NV",		# 0x20B7
    "WGL_TEXTURE_FLOAT_RGBA_NV",		# 0x20B8
    "WGL_COLOR_SAMPLES_NV",		# 0x20B9
    "WGL_BIND_TO_VIDEO_RGB_NV",		# 0x20C0
    "WGL_BIND_TO_VIDEO_RGBA_NV",		# 0x20C1
    "WGL_BIND_TO_VIDEO_RGB_AND_DEPTH_NV",		# 0x20C2
    "WGL_VIDEO_OUT_COLOR_NV",		# 0x20C3
    "WGL_VIDEO_OUT_ALPHA_NV",		# 0x20C4
    "WGL_VIDEO_OUT_DEPTH_NV",		# 0x20C5
    "WGL_VIDEO_OUT_COLOR_AND_ALPHA_NV",		# 0x20C6
    "WGL_VIDEO_OUT_COLOR_AND_DEPTH_NV",		# 0x20C7
    "WGL_VIDEO_OUT_FRAME",		# 0x20C8
    "WGL_VIDEO_OUT_FIELD_1",		# 0x20C9
    "WGL_VIDEO_OUT_FIELD_2",		# 0x20CA
    "WGL_VIDEO_OUT_STACKED_FIELDS_1_2",		# 0x20CB
    "WGL_VIDEO_OUT_STACKED_FIELDS_2_1",		# 0x20CC
    "WGL_UNIQUE_ID_NV",		# 0x20CE
    "WGL_NUM_VIDEO_CAPTURE_SLOTS_NV",		# 0x20CF
    "ERROR_INCOMPATIBLE_AFFINITY_MASKS_NV",		# 0x20D0
    "ERROR_MISSING_AFFINITY_MASK_NV",		# 0x20D1
    "WGL_NUM_VIDEO_SLOTS_NV",		# 0x20F0
    "WGL_TYPE_RGBA_FLOAT_ARB",		# 0x21A0
    "WGL_GPU_FASTEST_TARGET_GPUS_AMD",		# 0x21A2
    "WGL_GPU_RAM_AMD",		# 0x21A3
    "WGL_GPU_CLOCK_AMD",		# 0x21A4
    "WGL_GPU_NUM_PIPES_AMD",		# 0x21A5
    "WGL_GPU_NUM_SIMD_AMD",		# 0x21A6
    "WGL_GPU_NUM_RB_AMD",		# 0x21A7
    "WGL_GPU_NUM_SPI_AMD",		# 0x21A8
    "WGL_LOSE_CONTEXT_ON_RESET_ARB",		# 0x8252
    "WGL_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB",		# 0x8256
    "WGL_NO_RESET_NOTIFICATION_ARB",		# 0x8261
    "WGL_CONTEXT_PROFILE_MASK_ARB",		# 0x9126
])

########NEW FILE########
__FILENAME__ = winapi
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""Win32 API type description."""


from stdapi import *


SHORT = Alias("SHORT", Short)
USHORT = Alias("USHORT", UShort)
INT = Alias("INT", Int)
UINT = Alias("UINT", UInt)
LONG = Alias("LONG", Long)
ULONG = Alias("ULONG", ULong)
LONGLONG = Alias("LONGLONG", LongLong)
FLOAT = Alias("FLOAT", Float)

INT8 = Alias("INT8", Int8)
UINT8 = Alias("UINT8", UInt8)
INT16 = Alias("INT16", Int16)
UINT16 = Alias("UINT16", UInt16)
INT32 = Alias("INT32", Int32)
UINT32 = Alias("UINT32", UInt32)
INT64 = Alias("INT64", Int64)
UINT64 = Alias("UINT64", UInt64)

BYTE = Alias("BYTE", UInt8)
WORD = Alias("WORD", UInt16)
DWORD = Alias("DWORD", UInt32)

UCHAR = Alias("UCHAR", UChar)
WCHAR = Alias("WCHAR", Short)

BOOL = Enum("BOOL", [
    "FALSE",
    "TRUE",
])

LPLONG = Pointer(LONG)
LPWORD = Pointer(WORD)
LPDWORD = Pointer(DWORD)
LPBOOL = Pointer(BOOL)

LPSTR = CString
LPCSTR = ConstCString
LPWSTR = WString
LPCWSTR = ConstWString

LARGE_INTEGER = Struct("LARGE_INTEGER", [
    (LONGLONG, 'QuadPart'),
])

SIZE_T = Alias("SIZE_T", SizeT)

VOID = Void
PVOID = OpaquePointer(VOID)
LPVOID = PVOID
LPCVOID = OpaquePointer(Const(VOID))

def DECLARE_HANDLE(expr):
    return Handle(expr, IntPointer(expr))

HANDLE = DECLARE_HANDLE("HANDLE")
HWND = DECLARE_HANDLE("HWND")
HDC = DECLARE_HANDLE("HDC")
HMONITOR = DECLARE_HANDLE("HMONITOR")

GUID = Struct("GUID", [
    (DWORD, "Data1"),
    (WORD, "Data2"),
    (WORD, "Data3"),
    (Array(BYTE, 8), "Data4"),
])
LPGUID = Pointer(GUID)

REFGUID = Alias("REFGUID", Reference(GUID))

IID = Alias("IID", GUID)
REFIID = Alias("REFIID", Reference(IID))

CLSID = Alias("CLSID", GUID)
REFCLSID = Alias("REFCLSID", Reference(CLSID))

LUID = Struct("LUID", [
    (DWORD, "LowPart"),
    (LONG, "HighPart"),
])

POINT = Struct("POINT", (
  (LONG, "x"),
  (LONG, "y"),
)) 
LPPOINT = Pointer(POINT)

SIZE = Struct("SIZE", (
  (LONG, "cx"),
  (LONG, "cy"),
)) 
LPSIZE = Pointer(SIZE)

RECT = Struct("RECT", (
  (LONG, "left"),
  (LONG, "top"),
  (LONG, "right"), 
  (LONG, "bottom"), 
)) 
LPRECT = Pointer(RECT)

PALETTEENTRY = Struct("PALETTEENTRY", (
  (BYTE, "peRed"),
  (BYTE, "peGreen"),
  (BYTE, "peBlue"), 
  (BYTE, "peFlags"), 
)) 
LPPALETTEENTRY = Pointer(PALETTEENTRY)


RGNDATAHEADER = Struct("RGNDATAHEADER", [
    (DWORD, "dwSize"),
    (DWORD, "iType"),
    (DWORD, "nCount"),
    (DWORD, "nRgnSize"),
    (RECT, "rcBound"),
])

RGNDATA = Struct("RGNDATA", [
    (RGNDATAHEADER, "rdh"),
    #(Char, "Buffer[1]"),
])
LPRGNDATA = Pointer(RGNDATA)

HMODULE = IntPointer("HMODULE")

FILETIME = Struct("FILETIME", [
    (DWORD, "dwLowDateTime"),
    (DWORD, "dwHighDateTime"),
])

COLORREF = Alias("COLORREF", DWORD)

LOGFONTW = Struct("LOGFONTW", [
    (LONG, "lfHeight"),
    (LONG, "lfWidth"),
    (LONG, "lfEscapement"),
    (LONG, "lfOrientation"),
    (LONG, "lfWeight"),
    (BYTE, "lfItalic"),
    (BYTE, "lfUnderline"),
    (BYTE, "lfStrikeOut"),
    (BYTE, "lfCharSet"),
    (BYTE, "lfOutPrecision"),
    (BYTE, "lfClipPrecision"),
    (BYTE, "lfQuality"),
    (BYTE, "lfPitchAndFamily"),
    (WString, "lfFaceName"),
])

SECURITY_ATTRIBUTES = Struct("SECURITY_ATTRIBUTES", [
    (DWORD, "nLength"),
    (LPVOID, "lpSecurityDescriptor"),
    (BOOL, "bInheritHandle"),
])

# http://msdn.microsoft.com/en-us/library/ff485842.aspx
# http://msdn.microsoft.com/en-us/library/windows/desktop/ms681381.aspx
def MAKE_HRESULT(errors, ok = "S_OK", false = "S_FALSE"):
    values = [ok, false]
    values.extend(errors)
    values.extend([
        "E_PENDING", # 0x8000000A
        "E_NOTIMPL", # 0x80004001
        "E_NOINTERFACE", # 0x80004002
        "E_POINTER", # 0x80004003
        "E_ABORT", # 0x80004004
        "E_FAIL", # 0x80004005
        "E_UNEXPECTED", # 0x8000FFFF
        "E_ACCESSDENIED", # 0x80070005
        "E_HANDLE", # 0x80070006
        "E_OUTOFMEMORY", # 0x8007000E
        "E_INVALIDARG", # 0x80070057
    ])
    return Enum("HRESULT", values)

HRESULT = MAKE_HRESULT([])


IUnknown = Interface("IUnknown")

IUnknown.methods = (
	StdMethod(HRESULT, "QueryInterface", ((REFIID, "riid"), Out(Pointer(ObjPointer(Void)), "ppvObj"))),
	StdMethod(ULONG, "AddRef", ()),
	StdMethod(ULONG, "Release", ()),
)



########NEW FILE########
__FILENAME__ = cgltrace
##########################################################################
#
# Copyright 2011 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""CGL tracing generator."""


from gltrace import GlTracer
from specs.stdapi import Module, API
from specs.glapi import glapi
from specs.cglapi import cglapi


class CglTracer(GlTracer):

    def isFunctionPublic(self, function):
        # all OpenGL symbols are visible on MacOSX
        return True

    def traceFunctionImplBody(self, function):
        if function.name == 'CGLReleaseContext':
            # Unlike other GL APIs like EGL or GLX, CGL will make the context
            # not current if it's the current context.
            print '    if (_CGLGetContextRetainCount(ctx) == 1) {'
            print '        if (gltrace::releaseContext((uintptr_t)ctx)) {'
            print '            if (_CGLGetCurrentContext() == ctx) {'
            print '                gltrace::clearContext();'
            print '            }'
            print '        }'
            print '    }'

        if function.name == 'CGLDestroyContext':
            # The same rule applies here about the  as for CGLReleaseContext.
            print '    if (gltrace::releaseContext((uintptr_t)ctx)) {'
            print '        if (_CGLGetCurrentContext() == ctx) {'
            print '            gltrace::clearContext();'
            print '        }'
            print '    }'

        GlTracer.traceFunctionImplBody(self, function)

        if function.name == 'CGLCreateContext':
            print '    if (_result == kCGLNoError) {'
            print '        gltrace::createContext((uintptr_t)*ctx);'
            print '    }'

        if function.name == 'CGLSetCurrentContext':
            print '    if (_result == kCGLNoError) {'
            print '        if (ctx != NULL) {'
            print '            gltrace::setContext((uintptr_t)ctx);'
            print '        } else {'
            print '            gltrace::clearContext();'
            print '        }'
            print '    }'

        if function.name == 'CGLRetainContext':
            print '    gltrace::retainContext((uintptr_t)ctx);'


if __name__ == '__main__':
    print
    print '#include <stdlib.h>'
    print '#include <string.h>'
    print
    print '#include "trace_writer_local.hpp"'
    print
    print '// To validate our prototypes'
    print '#define GL_GLEXT_PROTOTYPES'
    print
    print '#include "glproc.hpp"'
    print '#include "glsize.hpp"'
    print

    module = Module()
    module.mergeModule(cglapi)
    module.mergeModule(glapi)
    api = API()
    api.addModule(module)
    tracer = CglTracer()
    tracer.traceApi(api)

    print r'''

PUBLIC
void * gll_noop = 0;

'''

########NEW FILE########
__FILENAME__ = d2d1trace
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from dlltrace import DllTracer
from specs.stdapi import API
from specs.dwrite import dwrite
from specs.d2d1 import d2d1


if __name__ == '__main__':
    print '#define INITGUID'
    print
    print '#include "trace_writer_local.hpp"'
    print '#include "os.hpp"'
    print
    print '#define DWRITE_EXPORT WINAPI'
    print
    print '#include "d2dimports.hpp"'
    print

    api = API()
    api.addModule(d2d1)
    api.addModule(dwrite)
    tracer = DllTracer()
    tracer.traceApi(api)

########NEW FILE########
__FILENAME__ = d3d8trace
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from dlltrace import DllTracer
from specs.stdapi import API
from specs.d3d8 import d3d8, D3DSHADER8


class D3D8Tracer(DllTracer):

    def serializeArgValue(self, function, arg):
        # Dump shaders as strings
        if arg.type is D3DSHADER8:
            print '    DumpShader(trace::localWriter, %s);' % (arg.name)
            return

        DllTracer.serializeArgValue(self, function, arg)

    def enumWrapperInterfaceVariables(self, interface):
        variables = DllTracer.enumWrapperInterfaceVariables(self, interface)
        
        # Add additional members to track locks
        if interface.getMethodByName('Lock') is not None or \
           interface.getMethodByName('LockRect') is not None or \
           interface.getMethodByName('LockBox') is not None:
            variables += [
                ('size_t', '_MappedSize', '0'),
                ('VOID *', 'm_pbData', '0'),
            ]

        return variables

    def implementWrapperInterfaceMethodBody(self, interface, base, method):
        if method.name in ('Unlock', 'UnlockRect', 'UnlockBox'):
            print '    if (_MappedSize && m_pbData) {'
            self.emit_memcpy('(LPBYTE)m_pbData', '(LPBYTE)m_pbData', '_MappedSize')
            print '    }'

        DllTracer.implementWrapperInterfaceMethodBody(self, interface, base, method)

        if method.name in ('Lock', 'LockRect', 'LockBox'):
            # FIXME: handle recursive locks
            print '    if (SUCCEEDED(_result) && !(Flags & D3DLOCK_READONLY)) {'
            print '        _getMapInfo(_this, %s, m_pbData, _MappedSize);' % ', '.join(method.argNames()[:-1])
            print '    } else {'
            print '        m_pbData = NULL;'
            print '        _MappedSize = 0;'
            print '    }'


if __name__ == '__main__':
    print '#define INITGUID'
    print
    print '#include "trace_writer_local.hpp"'
    print '#include "os.hpp"'
    print
    print '#include "d3d8imports.hpp"'
    print '#include "d3d8size.hpp"'
    print '#include "d3d9shader.hpp"'
    print

    api = API()
    api.addModule(d3d8)
    tracer = D3D8Tracer()
    tracer.traceApi(api)

########NEW FILE########
__FILENAME__ = d3d9trace
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from dlltrace import DllTracer
from specs.stdapi import API, Pointer, ObjPointer
from specs.d3d9 import d3d9, D3DSHADER9, IDirect3DSwapChain9Ex

import specs.d3d9dxva2


class D3D9Tracer(DllTracer):

    def serializeArgValue(self, function, arg):
        # Dump shaders as strings
        if arg.type is D3DSHADER9:
            print '    DumpShader(trace::localWriter, %s);' % (arg.name)
            return

        DllTracer.serializeArgValue(self, function, arg)

    def wrapArg(self, function, arg):
        # Correctly handle the wrapping of IDirect3DSwapChain9Ex objects
        if function.name in ('GetSwapChain', 'CreateAdditionalSwapChain') \
           and self.interface.name == 'IDirect3DDevice9Ex' \
           and arg.name == 'pSwapChain':
            self.wrapValue(Pointer(ObjPointer(IDirect3DSwapChain9Ex)), '((IDirect3DSwapChain9Ex**)pSwapChain)')
            return

        DllTracer.wrapArg(self, function, arg)

    def enumWrapperInterfaceVariables(self, interface):
        variables = DllTracer.enumWrapperInterfaceVariables(self, interface)
        
        # Add additional members to track locks
        if interface.getMethodByName('Lock') is not None or \
           interface.getMethodByName('LockRect') is not None or \
           interface.getMethodByName('LockBox') is not None:
            variables += [
                ('size_t', '_MappedSize', '0'),
                ('VOID *', 'm_pbData', '0'),
            ]

        return variables

    def implementWrapperInterfaceMethodBody(self, interface, base, method):
        if method.name in ('Unlock', 'UnlockRect', 'UnlockBox'):
            print '    if (_MappedSize && m_pbData) {'
            self.emit_memcpy('(LPBYTE)m_pbData', '(LPBYTE)m_pbData', '_MappedSize')
            print '    }'

        DllTracer.implementWrapperInterfaceMethodBody(self, interface, base, method)

        if method.name in ('Lock', 'LockRect', 'LockBox'):
            # FIXME: handle recursive locks
            print '    if (SUCCEEDED(_result) && !(Flags & D3DLOCK_READONLY)) {'
            print '        _getMapInfo(_this, %s, m_pbData, _MappedSize);' % ', '.join(method.argNames()[:-1])
            print '    } else {'
            print '        m_pbData = NULL;'
            print '        _MappedSize = 0;'
            print '    }'


if __name__ == '__main__':
    print '#define INITGUID'
    print
    print '#include "trace_writer_local.hpp"'
    print '#include "os.hpp"'
    print
    print '#include "d3d9imports.hpp"'
    print '#include "d3d9size.hpp"'
    print '#include "d3d9shader.hpp"'
    print '#include "dxvaint.h"'
    print

    api = API()
    api.addModule(d3d9)
    tracer = D3D9Tracer()
    tracer.traceApi(api)

########NEW FILE########
__FILENAME__ = ddrawtrace
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


from dlltrace import DllTracer
from specs.stdapi import API
from specs.d3d import ddraw, interfaces


if __name__ == '__main__':
    print '#define INITGUID'
    print '#include <windows.h>'
    print '#include <ddraw.h>'
    print '#include <d3d.h>'
    print
    print '''

#ifndef DDBLT_EXTENDED_FLAGS
#define DDBLT_EXTENDED_FLAGS 0x40000000l
#endif

#ifndef DDBLT_EXTENDED_LINEAR_CONTENT
#define DDBLT_EXTENDED_LINEAR_CONTENT 0x00000004l
#endif

#ifndef D3DLIGHT_PARALLELPOINT
#define D3DLIGHT_PARALLELPOINT (D3DLIGHTTYPE)4
#endif

#ifndef D3DLIGHT_GLSPOT
#define D3DLIGHT_GLSPOT (D3DLIGHTTYPE)5
#endif

'''
    print '#include "trace_writer_local.hpp"'
    print '#include "os.hpp"'
    print

    api = API()
    api.addModule(ddraw)
    tracer = DllTracer()
    tracer.traceApi(api)

########NEW FILE########
__FILENAME__ = dlltrace
##########################################################################
#
# Copyright 2008-2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""Trace code generation for Windows DLLs."""


import ntpath

from trace import Tracer
from dispatch import Dispatcher
from specs.stdapi import API


class DllDispatcher(Dispatcher):

    def dispatchModule(self, module):
        tag = module.name.upper()
        print r'HMODULE g_h%sModule = NULL;' % (tag,)
        print r''
        print r'static PROC'
        print r'_get%sProcAddress(LPCSTR lpProcName) {' % tag
        print r'    if (!g_h%sModule) {' % tag
        print r'        char szDll[MAX_PATH] = {0};'
        print r'        if (!GetSystemDirectoryA(szDll, MAX_PATH)) {'
        print r'            return NULL;'
        print r'        }'
        print r'        strcat(szDll, "\\\\%s.dll");' % module.name
        print r'        g_h%sModule = LoadLibraryA(szDll);' % tag
        print r'        if (!g_h%sModule) {' % tag
        print r'            return NULL;'
        print r'        }'
        print r'    }'
        print r'    return GetProcAddress(g_h%sModule, lpProcName);' % tag
        print r'}'
        print r''

        Dispatcher.dispatchModule(self, module)

    def getProcAddressName(self, module, function):
        assert self.isFunctionPublic(module, function)
        return '_get%sProcAddress' % (module.name.upper())


class DllTracer(Tracer):

    def header(self, api):

        for module in api.modules:
            dispatcher = DllDispatcher()
            dispatcher.dispatchModule(module)

        Tracer.header(self, api)

########NEW FILE########
__FILENAME__ = dxgitrace
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


import sys
from dlltrace import DllTracer
from trace import getWrapperInterfaceName
from specs import stdapi
from specs.stdapi import API
from specs import dxgi
from specs import d3d10
from specs import d3d10_1
from specs import d3d11


class D3DCommonTracer(DllTracer):

    def serializeArgValue(self, function, arg):
        # Dump shaders as strings
        if isinstance(arg.type, stdapi.Blob) and arg.name.startswith('pShaderBytecode'):
            print '    DumpShader(trace::localWriter, %s, %s);' % (arg.name, arg.type.size)
            return

        # Serialize the swapchain dimensions
        if function.name == 'CreateSwapChain' and arg.name == 'pDesc' \
           or arg.name == 'pSwapChainDesc':
            print r'    DXGI_SWAP_CHAIN_DESC *_pSwapChainDesc = NULL;'
            print r'    DXGI_SWAP_CHAIN_DESC _SwapChainDesc;'
            print r'    if (%s) {' % arg.name
            print r'        _SwapChainDesc = *%s;' % arg.name
            if function.name != 'CreateSwapChain' or not self.interface.name.endswith('DWM'):
                # Obtain size from the window
                print r'        RECT _rect;'
                print r'        if (GetClientRect(%s->OutputWindow, &_rect)) {' % arg.name
                print r'            if (%s->BufferDesc.Width == 0) {' % arg.name
                print r'                _SwapChainDesc.BufferDesc.Width = _rect.right  - _rect.left;'
                print r'            }'
                print r'            if (%s->BufferDesc.Height == 0) {' % arg.name
                print r'                _SwapChainDesc.BufferDesc.Height = _rect.bottom - _rect.top;'
                print r'            }'
                print r'        }'
            else:
                # Obtain size from the output
                print r'        DXGI_OUTPUT_DESC _OutputDesc;'
                print r'        if (SUCCEEDED(pOutput->GetDesc(&_OutputDesc))) {'
                print r'            _SwapChainDesc.BufferDesc.Width  = _OutputDesc.DesktopCoordinates.right  - _OutputDesc.DesktopCoordinates.left;'
                print r'            _SwapChainDesc.BufferDesc.Height = _OutputDesc.DesktopCoordinates.bottom - _OutputDesc.DesktopCoordinates.top;'
                print r'        }'
            print r'        _pSwapChainDesc = &_SwapChainDesc;'
            print r'    }'
            self.serializeValue(arg.type, '_pSwapChainDesc')
            return

        DllTracer.serializeArgValue(self, function, arg)

    # Interfaces that need book-keeping for maps
    mapInterfaces = (
        dxgi.IDXGISurface,
        d3d10.ID3D10Resource,
        d3d11.ID3D11Resource,
    )
    
    def enumWrapperInterfaceVariables(self, interface):
        variables = DllTracer.enumWrapperInterfaceVariables(self, interface)
        
        # Add additional members to track maps
        if interface.hasBase(*self.mapInterfaces):
            variables += [
                ('_MAP_DESC', '_MapDesc', None),
            ]

        return variables

    def implementWrapperInterfaceMethodBody(self, interface, base, method):
        if method.name in ('Map', 'Unmap'):
            # On D3D11 Map/Unmap is not a resource method, but a context method instead.
            resourceArg = method.getArgByName('pResource')
            if resourceArg is None:
                pResource = 'this'
            else:
                wrapperInterfaceName = getWrapperInterfaceName(resourceArg.type.type)
                print '    %s * _pResource = static_cast<%s*>(%s);' % (wrapperInterfaceName, wrapperInterfaceName, resourceArg.name)
                pResource = '_pResource'

        if method.name == 'Unmap':
            print '    _MAP_DESC _MapDesc = %s->_MapDesc;' % pResource
            #print r'    os::log("%%p -> %%p+%%lu\n", %s,_MapDesc.pData, (unsigned long)_MapDesc.Size);' % pResource
            print '    if (_MapDesc.Size && _MapDesc.pData) {'
            self.emit_memcpy('_MapDesc.pData', '_MapDesc.pData', '_MapDesc.Size')
            print '    }'

        DllTracer.implementWrapperInterfaceMethodBody(self, interface, base, method)

        if method.name == 'Map':
            # NOTE: recursive locks are explicitely forbidden
            print '    _MAP_DESC _MapDesc;'
            print '    if (SUCCEEDED(_result)) {'
            print '        _getMapDesc(_this, %s, _MapDesc);' % ', '.join(method.argNames())
            print '    } else {'
            print '        _MapDesc.pData = NULL;'
            print '        _MapDesc.Size = 0;'
            print '    }'
            #print r'    os::log("%%p <- %%p+%%lu\n", %s,_MapDesc.pData, (unsigned long)_MapDesc.Size);' % pResource
            print '    %s->_MapDesc = _MapDesc;' % pResource


if __name__ == '__main__':
    print '#define INITGUID'
    print
    print '#include "trace_writer_local.hpp"'
    print '#include "os.hpp"'
    print
    print '#include "d3dcommonshader.hpp"'
    print

    moduleNames = sys.argv[1:]

    api = API()
    
    if moduleNames:
        api.addModule(dxgi.dxgi)
    
    if 'd3d10' in moduleNames:
        if 'd3d10_1' in moduleNames:
            print r'#include "d3d10_1imports.hpp"'
            api.addModule(d3d10_1.d3d10_1)
        else:
            print r'#include "d3d10imports.hpp"'
        print r'#include "d3d10size.hpp"'
        api.addModule(d3d10.d3d10)

    if 'd3d11' in moduleNames:
        print r'#include "d3d11imports.hpp"'
        if 'd3d11_1' in moduleNames:
            print '#include <d3d11_1.h>'
            from specs import d3d11_1
        print r'#include "d3d11size.hpp"'
        api.addModule(d3d11.d3d11)

    tracer = D3DCommonTracer()
    tracer.traceApi(api)

########NEW FILE########
__FILENAME__ = egltrace
##########################################################################
#
# Copyright 2011 LunarG, Inc.
# All Rights Reserved.
#
# Based on glxtrace.py, which has
#
#   Copyright 2011 Jose Fonseca
#   Copyright 2008-2010 VMware, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""EGL tracing generator."""


from gltrace import GlTracer
from specs.stdapi import Module, API
from specs.glapi import glapi
from specs.eglapi import eglapi
from specs.glesapi import glesapi


class EglTracer(GlTracer):

    def isFunctionPublic(self, function):
        # The symbols visible in libEGL.so can vary, so expose them all
        return True

    getProcAddressFunctionNames = [
        "eglGetProcAddress",
    ]

    def traceFunctionImplBody(self, function):
        GlTracer.traceFunctionImplBody(self, function)

        if function.name == 'eglCreateContext':
            print '    if (_result != EGL_NO_CONTEXT)'
            print '        gltrace::createContext((uintptr_t)_result);'

        if function.name == 'eglMakeCurrent':
            print '    if (_result) {'
            print '        // update the profile'
            print '        if (ctx != EGL_NO_CONTEXT) {'
            print '            EGLint api = EGL_OPENGL_ES_API, version = 1;'
            print '            gltrace::setContext((uintptr_t)ctx);'
            print '            gltrace::Context *tr = gltrace::getContext();'
            print '            _eglQueryContext(dpy, ctx, EGL_CONTEXT_CLIENT_TYPE, &api);'
            print '            _eglQueryContext(dpy, ctx, EGL_CONTEXT_CLIENT_VERSION, &version);'
            print '            if (api == EGL_OPENGL_API)'
            print '                tr->profile = gltrace::PROFILE_COMPAT;'
            print '            else if (version == 1)'
            print '                tr->profile = gltrace::PROFILE_ES1;'
            print '            else'
            print '                tr->profile = gltrace::PROFILE_ES2;'
            print '        } else {'
            print '            gltrace::clearContext();'
            print '        }'
            print '    }'

        if function.name == 'eglDestroyContext':
            print '    if (_result) {'
            print '        gltrace::releaseContext((uintptr_t)ctx);'
            print '    }'

        if function.name == 'glEGLImageTargetTexture2DOES':
            print '    image_info *info = _EGLImageKHR_get_image_info(target, image);'
            print '    if (info) {'
            print '        GLint level = 0;'
            print '        GLint internalformat = info->internalformat;'
            print '        GLsizei width = info->width;'
            print '        GLsizei height = info->height;'
            print '        GLint border = 0;'
            print '        GLenum format = info->format;'
            print '        GLenum type = info->type;'
            print '        const GLvoid * pixels = info->pixels;'
            self.emitFakeTexture2D()
            print '        _EGLImageKHR_free_image_info(info);'
            print '    }'


if __name__ == '__main__':
    print '#include <stdlib.h>'
    print '#include <string.h>'
    print
    print '#include "trace_writer_local.hpp"'
    print
    print '// To validate our prototypes'
    print '#define GL_GLEXT_PROTOTYPES'
    print '#define EGL_EGLEXT_PROTOTYPES'
    print
    print '#include "dlopen.hpp"'
    print '#include "glproc.hpp"'
    print '#include "glsize.hpp"'
    print '#include "eglsize.hpp"'
    print
    
    module = Module()
    module.mergeModule(eglapi)
    module.mergeModule(glapi)
    module.mergeModule(glesapi)
    api = API()
    api.addModule(module)
    tracer = EglTracer()
    tracer.traceApi(api)

    print r'''



/*
 * Several applications, such as Quake3, use dlopen("libGL.so.1"), but
 * LD_PRELOAD does not intercept symbols obtained via dlopen/dlsym, therefore
 * we need to intercept the dlopen() call here, and redirect to our wrapper
 * shared object.
 */
extern "C" PUBLIC
void * dlopen(const char *filename, int flag)
{
    bool intercept = false;

    if (filename) {
        intercept =
            strcmp(filename, "libEGL.so") == 0 ||
            strcmp(filename, "libEGL.so.1") == 0 ||
            strcmp(filename, "libGLESv1_CM.so") == 0 ||
            strcmp(filename, "libGLESv1_CM.so.1") == 0 ||
            strcmp(filename, "libGLESv2.so") == 0 ||
            strcmp(filename, "libGLESv2.so.2") == 0 ||
            strcmp(filename, "libGL.so") == 0 ||
            strcmp(filename, "libGL.so.1") == 0;

        if (intercept) {
            os::log("apitrace: redirecting dlopen(\"%s\", 0x%x)\n", filename, flag);

            /* The current dispatch implementation relies on core entry-points to be globally available, so force this.
             *
             * TODO: A better approach would be note down the entry points here and
             * use them latter. Another alternative would be to reopen the library
             * with RTLD_NOLOAD | RTLD_GLOBAL.
             */
            flag &= ~RTLD_LOCAL;
            flag |= RTLD_GLOBAL;
        }
    }

    void *handle = _dlopen(filename, flag);

    if (intercept) {
        // Get the file path for our shared object, and use it instead
        static int dummy = 0xdeedbeef;
        Dl_info info;
        if (dladdr(&dummy, &info)) {
            handle = _dlopen(info.dli_fname, flag);
        } else {
            os::log("apitrace: warning: dladdr() failed\n");
        }
    }

    return handle;
}


#if defined(ANDROID)

/*
 * Undocumented Android extensions used by Dalvik which have bound information
 * passed to it, but is currently ignored, so probably unreliable.
 *
 * See:
 * https://github.com/android/platform_frameworks_base/blob/master/opengl/libs/GLES_CM/gl.cpp
 */

extern "C" PUBLIC
void APIENTRY glColorPointerBounds(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer, GLsizei count) {
    (void)count;
    glColorPointer(size, type, stride, pointer);
}

extern "C" PUBLIC
void APIENTRY glNormalPointerBounds(GLenum type, GLsizei stride, const GLvoid * pointer, GLsizei count) {
    (void)count;
    glNormalPointer(type, stride, pointer);
}

extern "C" PUBLIC
void APIENTRY glTexCoordPointerBounds(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer, GLsizei count) {
    (void)count;
    glTexCoordPointer(size, type, stride, pointer);
}

extern "C" PUBLIC
void APIENTRY glVertexPointerBounds(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer, GLsizei count) {
    (void)count;
    glVertexPointer(size, type, stride, pointer);
}

extern "C" PUBLIC
void GL_APIENTRY glPointSizePointerOESBounds(GLenum type, GLsizei stride, const GLvoid *pointer, GLsizei count) {
    (void)count;
    glPointSizePointerOES(type, stride, pointer);
}

extern "C" PUBLIC
void APIENTRY glMatrixIndexPointerOESBounds(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer, GLsizei count) {
    (void)count;
    glMatrixIndexPointerOES(size, type, stride, pointer);
}

extern "C" PUBLIC
void APIENTRY glWeightPointerOESBounds(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer, GLsizei count) {
    (void)count;
    glWeightPointerOES(size, type, stride, pointer);
}

/*
 * There is also a glVertexAttribPointerBounds in
 * https://github.com/android/platform_frameworks_base/blob/master/opengl/tools/glgen/stubs/gles11/GLES20cHeader.cpp
 * but is it not exported.
 */

#endif /* ANDROID */


'''

########NEW FILE########
__FILENAME__ = gltrace
##########################################################################
#
# Copyright 2008-2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""GL tracing generator."""


from trace import Tracer
from dispatch import function_pointer_type, function_pointer_value
import specs.stdapi as stdapi
import specs.glapi as glapi
import specs.glparams as glparams
from specs.glxapi import glxapi


class TypeGetter(stdapi.Visitor):
    '''Determine which glGet*v function that matches the specified type.'''

    def __init__(self, prefix = 'glGet', long_suffix = True, ext_suffix = ''):
        self.prefix = prefix
        self.long_suffix = long_suffix
        self.ext_suffix = ext_suffix

    def visitConst(self, const):
        return self.visit(const.type)

    def visitAlias(self, alias):
        if alias.expr == 'GLboolean':
            if self.long_suffix:
                suffix = 'Booleanv'
                arg_type = alias.expr
            else:
                suffix = 'iv'
                arg_type = 'GLint'
        elif alias.expr == 'GLdouble':
            if self.long_suffix:
                suffix = 'Doublev'
                arg_type = alias.expr
            else:
                suffix = 'dv'
                arg_type = alias.expr
        elif alias.expr == 'GLfloat':
            if self.long_suffix:
                suffix = 'Floatv'
                arg_type = alias.expr
            else:
                suffix = 'fv'
                arg_type = alias.expr
        elif alias.expr in ('GLint', 'GLuint', 'GLsizei'):
            if self.long_suffix:
                suffix = 'Integerv'
                arg_type = 'GLint'
            else:
                suffix = 'iv'
                arg_type = 'GLint'
        else:
            print alias.expr
            assert False
        function_name = self.prefix + suffix + self.ext_suffix
        return function_name, arg_type
    
    def visitEnum(self, enum):
        return self.visit(glapi.GLint)

    def visitBitmask(self, bitmask):
        return self.visit(glapi.GLint)

    def visitOpaque(self, pointer):
        return self.prefix + 'Pointerv' + self.ext_suffix, 'GLvoid *'


class GlTracer(Tracer):

    arrays = [
        ("Vertex", "VERTEX"),
        ("Normal", "NORMAL"),
        ("Color", "COLOR"),
        ("Index", "INDEX"),
        ("TexCoord", "TEXTURE_COORD"),
        ("EdgeFlag", "EDGE_FLAG"),
        ("FogCoord", "FOG_COORD"),
        ("SecondaryColor", "SECONDARY_COLOR"),
    ]
    arrays.reverse()

    # arrays available in PROFILE_ES1
    arrays_es1 = ("Vertex", "Normal", "Color", "TexCoord")

    def header(self, api):
        Tracer.header(self, api)

        print '#include <algorithm>'
        print
        print '#include "gltrace.hpp"'
        print
        
        # Which glVertexAttrib* variant to use
        print 'enum vertex_attrib {'
        print '    VERTEX_ATTRIB,'
        print '    VERTEX_ATTRIB_ARB,'
        print '    VERTEX_ATTRIB_NV,'
        print '};'
        print
        print 'static vertex_attrib _get_vertex_attrib(void) {'
        print '    gltrace::Context *ctx = gltrace::getContext();'
        print '    if (ctx->user_arrays_arb || ctx->user_arrays_nv) {'
        print '        GLboolean _vertex_program = GL_FALSE;'
        print '        _glGetBooleanv(GL_VERTEX_PROGRAM_ARB, &_vertex_program);'
        print '        if (_vertex_program) {'
        print '            if (ctx->user_arrays_nv) {'
        print '                GLint _vertex_program_binding_nv = _glGetInteger(GL_VERTEX_PROGRAM_BINDING_NV);'
        print '                if (_vertex_program_binding_nv) {'
        print '                    return VERTEX_ATTRIB_NV;'
        print '                }'
        print '            }'
        print '            return VERTEX_ATTRIB_ARB;'
        print '        }'
        print '    }'
        print '    return VERTEX_ATTRIB;'
        print '}'
        print

        self.defineShadowBufferHelper()

        # Whether we need user arrays
        print 'static inline bool _need_user_arrays(void)'
        print '{'
        print '    gltrace::Context *ctx = gltrace::getContext();'
        print '    if (!ctx->user_arrays) {'
        print '        return false;'
        print '    }'
        print

        for camelcase_name, uppercase_name in self.arrays:
            # in which profile is the array available?
            profile_check = 'ctx->profile == gltrace::PROFILE_COMPAT'
            if camelcase_name in self.arrays_es1:
                profile_check = '(' + profile_check + ' || ctx->profile == gltrace::PROFILE_ES1)';

            function_name = 'gl%sPointer' % camelcase_name
            enable_name = 'GL_%s_ARRAY' % uppercase_name
            binding_name = 'GL_%s_ARRAY_BUFFER_BINDING' % uppercase_name
            print '    // %s' % function_name
            print '  if (%s) {' % profile_check
            self.array_prolog(api, uppercase_name)
            print '    if (_glIsEnabled(%s)) {' % enable_name
            print '        GLint _binding = _glGetInteger(%s);' % binding_name
            print '        if (!_binding) {'
            self.array_cleanup(api, uppercase_name)
            print '            return true;'
            print '        }'
            print '    }'
            self.array_epilog(api, uppercase_name)
            print '  }'
            print

        print '    // ES1 does not support generic vertex attributes'
        print '    if (ctx->profile == gltrace::PROFILE_ES1)'
        print '        return false;'
        print
        print '    vertex_attrib _vertex_attrib = _get_vertex_attrib();'
        print
        print '    // glVertexAttribPointer'
        print '    if (_vertex_attrib == VERTEX_ATTRIB) {'
        print '        GLint _max_vertex_attribs = _glGetInteger(GL_MAX_VERTEX_ATTRIBS);'
        print '        for (GLint index = 0; index < _max_vertex_attribs; ++index) {'
        print '            GLint _enabled = 0;'
        print '            _glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_ENABLED, &_enabled);'
        print '            if (_enabled) {'
        print '                GLint _binding = 0;'
        print '                _glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, &_binding);'
        print '                if (!_binding) {'
        print '                    return true;'
        print '                }'
        print '            }'
        print '        }'
        print '    }'
        print
        print '    // glVertexAttribPointerARB'
        print '    if (_vertex_attrib == VERTEX_ATTRIB_ARB) {'
        print '        GLint _max_vertex_attribs = _glGetInteger(GL_MAX_VERTEX_ATTRIBS_ARB);'
        print '        for (GLint index = 0; index < _max_vertex_attribs; ++index) {'
        print '            GLint _enabled = 0;'
        print '            _glGetVertexAttribivARB(index, GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB, &_enabled);'
        print '            if (_enabled) {'
        print '                GLint _binding = 0;'
        print '                _glGetVertexAttribivARB(index, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB, &_binding);'
        print '                if (!_binding) {'
        print '                    return true;'
        print '                }'
        print '            }'
        print '        }'
        print '    }'
        print
        print '    // glVertexAttribPointerNV'
        print '    if (_vertex_attrib == VERTEX_ATTRIB_NV) {'
        print '        for (GLint index = 0; index < 16; ++index) {'
        print '            GLboolean _enabled = _glIsEnabled(GL_VERTEX_ATTRIB_ARRAY0_NV);'
        print '            if (_enabled) {'
        print '                return true;'
        print '            }'
        print '        }'
        print '    }'
        print

        print '    return false;'
        print '}'
        print

        print 'static void _trace_user_arrays(GLuint count);'
        print

        print '// whether glLockArraysEXT() has ever been called'
        print 'static bool _checkLockArraysEXT = false;'
        print

        # Buffer mappings
        print '// whether glMapBufferRange(GL_MAP_WRITE_BIT) has ever been called'
        print 'static bool _checkBufferMapRange = false;'
        print
        print '// whether glBufferParameteriAPPLE(GL_BUFFER_FLUSHING_UNMAP_APPLE, GL_FALSE) has ever been called'
        print 'static bool _checkBufferFlushingUnmapAPPLE = false;'
        print
        # Buffer mapping information, necessary for old Mesa 2.1 drivers which
        # do not support glGetBufferParameteriv(GL_BUFFER_ACCESS_FLAGS/GL_BUFFER_MAP_LENGTH)
        print 'struct buffer_mapping {'
        print '    void *map;'
        print '    GLint length;'
        print '    bool write;'
        print '    bool explicit_flush;'
        print '};'
        print
        for target in self.buffer_targets:
            print 'struct buffer_mapping _%s_mapping;' % target.lower();
        print
        print 'static inline struct buffer_mapping *'
        print 'get_buffer_mapping(GLenum target) {'
        print '    switch (target) {'
        for target in self.buffer_targets:
            print '    case GL_%s:' % target
            print '        return & _%s_mapping;' % target.lower()
        print '    default:'
        print '        os::log("apitrace: warning: unknown buffer target 0x%04X\\n", target);'
        print '        return NULL;'
        print '    }'
        print '}'
        print

        # Generate a helper function to determine whether a parameter name
        # refers to a symbolic value or not
        print 'static bool'
        print 'is_symbolic_pname(GLenum pname) {'
        print '    switch (pname) {'
        for function, type, count, name in glparams.parameters:
            if type is glapi.GLenum:
                print '    case %s:' % name
        print '        return true;'
        print '    default:'
        print '        return false;'
        print '    }'
        print '}'
        print
        
        # Generate a helper function to determine whether a parameter value is
        # potentially symbolic or not; i.e., if the value can be represented in
        # an enum or not
        print 'template<class T>'
        print 'static inline bool'
        print 'is_symbolic_param(T param) {'
        print '    return static_cast<T>(static_cast<GLenum>(param)) == param;'
        print '}'
        print

        # Generate a helper function to know how many elements a parameter has
        print 'static size_t'
        print '_gl_param_size(GLenum pname) {'
        print '    switch (pname) {'
        for function, type, count, name in glparams.parameters:
            if type is not None:
                print '    case %s: return %s;' % (name, count)
        print '    default:'
        print r'        os::log("apitrace: warning: %s: unknown GLenum 0x%04X\n", __FUNCTION__, pname);'
        print '        return 1;'
        print '    }'
        print '}'
        print

        # states such as GL_UNPACK_ROW_LENGTH are not available in GLES
        print 'static inline bool'
        print 'can_unpack_subimage(void) {'
        print '    gltrace::Context *ctx = gltrace::getContext();'
        print '    return (ctx->profile == gltrace::PROFILE_COMPAT);'
        print '}'
        print

    getProcAddressFunctionNames = []

    def traceApi(self, api):
        if self.getProcAddressFunctionNames:
            # Generate a function to wrap proc addresses
            getProcAddressFunction = api.getFunctionByName(self.getProcAddressFunctionNames[0])
            argType = getProcAddressFunction.args[0].type
            retType = getProcAddressFunction.type
            
            print 'static %s _wrapProcAddress(%s procName, %s procPtr);' % (retType, argType, retType)
            print
            
            Tracer.traceApi(self, api)
            
            print 'static %s _wrapProcAddress(%s procName, %s procPtr) {' % (retType, argType, retType)

            # Provide fallback functions to missing debug functions
            print '    if (!procPtr) {'
            else_ = ''
            for function_name in self.debug_functions:
                if self.api.getFunctionByName(function_name):
                    print '        %sif (strcmp("%s", (const char *)procName) == 0) {' % (else_, function_name)
                    print '            return (%s)&%s;' % (retType, function_name)
                    print '        }'
                else_ = 'else '
            print '        %s{' % else_
            print '            return NULL;'
            print '        }'
            print '    }'

            for function in api.getAllFunctions():
                ptype = function_pointer_type(function)
                pvalue = function_pointer_value(function)
                print '    if (strcmp("%s", (const char *)procName) == 0) {' % function.name
                print '        %s = (%s)procPtr;' % (pvalue, ptype)
                print '        return (%s)&%s;' % (retType, function.name,)
                print '    }'
            print '    os::log("apitrace: warning: unknown function \\"%s\\"\\n", (const char *)procName);'
            print '    return procPtr;'
            print '}'
            print
        else:
            Tracer.traceApi(self, api)

    def defineShadowBufferHelper(self):
        print 'void _shadow_glGetBufferSubData(GLenum target, GLintptr offset,'
        print '                                GLsizeiptr size, GLvoid *data)'
        print '{'
        print '    gltrace::Context *ctx = gltrace::getContext();'
        print '    if (!ctx->needsShadowBuffers() || target != GL_ELEMENT_ARRAY_BUFFER) {'
        print '        _glGetBufferSubData(target, offset, size, data);'
        print '        return;'
        print '    }'
        print
        print '    GLint buffer_binding = _glGetInteger(GL_ELEMENT_ARRAY_BUFFER_BINDING);'
        print '    if (buffer_binding > 0) {'
        print '        gltrace::Buffer & buf = ctx->buffers[buffer_binding];'
        print '        buf.getSubData(offset, size, data);'
        print '    }'
        print '}'

    def shadowBufferMethod(self, method):
        # Emit code to fetch the shadow buffer, and invoke a method
        print '    gltrace::Context *ctx = gltrace::getContext();'
        print '    if (ctx->needsShadowBuffers() && target == GL_ELEMENT_ARRAY_BUFFER) {'
        print '        GLint buffer_binding = _glGetInteger(GL_ELEMENT_ARRAY_BUFFER_BINDING);'
        print '        if (buffer_binding > 0) {'
        print '            gltrace::Buffer & buf = ctx->buffers[buffer_binding];'
        print '            buf.' + method + ';'
        print '        }'
        print '    }'
        print

    def shadowBufferProlog(self, function):
        if function.name == 'glBufferData':
            self.shadowBufferMethod('bufferData(size, data)')

        if function.name == 'glBufferSubData':
            self.shadowBufferMethod('bufferSubData(offset, size, data)')

        if function.name == 'glDeleteBuffers':
            print '    gltrace::Context *ctx = gltrace::getContext();'
            print '    if (ctx->needsShadowBuffers()) {'
            print '        for (GLsizei i = 0; i < n; i++) {'
            print '            ctx->buffers.erase(buffer[i]);'
            print '        }'
            print '    }'

    array_pointer_function_names = set((
        "glVertexPointer",
        "glNormalPointer",
        "glColorPointer",
        "glIndexPointer",
        "glTexCoordPointer",
        "glEdgeFlagPointer",
        "glFogCoordPointer",
        "glSecondaryColorPointer",
        
        "glInterleavedArrays",

        "glVertexPointerEXT",
        "glNormalPointerEXT",
        "glColorPointerEXT",
        "glIndexPointerEXT",
        "glTexCoordPointerEXT",
        "glEdgeFlagPointerEXT",
        "glFogCoordPointerEXT",
        "glSecondaryColorPointerEXT",

        "glVertexAttribPointer",
        "glVertexAttribPointerARB",
        "glVertexAttribPointerNV",
        "glVertexAttribIPointer",
        "glVertexAttribIPointerEXT",
        "glVertexAttribLPointer",
        "glVertexAttribLPointerEXT",
        
        #"glMatrixIndexPointerARB",
    ))

    draw_function_names = set((
        'glDrawArrays',
        'glDrawElements',
        'glDrawRangeElements',
        'glMultiDrawArrays',
        'glMultiDrawElements',
        'glDrawArraysInstanced',
        "glDrawArraysInstancedBaseInstance",
        'glDrawElementsInstanced',
        'glDrawArraysInstancedARB',
        'glDrawElementsInstancedARB',
        'glDrawElementsBaseVertex',
        'glDrawRangeElementsBaseVertex',
        'glDrawElementsInstancedBaseVertex',
        "glDrawElementsInstancedBaseInstance",
        "glDrawElementsInstancedBaseVertexBaseInstance",
        'glMultiDrawElementsBaseVertex',
        'glDrawArraysIndirect',
        'glDrawElementsIndirect',
        'glMultiDrawArraysIndirect',
        'glMultiDrawArraysIndirectAMD',
        'glMultiDrawElementsIndirect',
        'glMultiDrawElementsIndirectAMD',
        'glDrawArraysEXT',
        'glDrawRangeElementsEXT',
        'glDrawRangeElementsEXT_size',
        'glMultiDrawArraysEXT',
        'glMultiDrawElementsEXT',
        'glMultiModeDrawArraysIBM',
        'glMultiModeDrawElementsIBM',
        'glDrawArraysInstancedEXT',
        'glDrawElementsInstancedEXT',
    ))

    interleaved_formats = [
         'GL_V2F',
         'GL_V3F',
         'GL_C4UB_V2F',
         'GL_C4UB_V3F',
         'GL_C3F_V3F',
         'GL_N3F_V3F',
         'GL_C4F_N3F_V3F',
         'GL_T2F_V3F',
         'GL_T4F_V4F',
         'GL_T2F_C4UB_V3F',
         'GL_T2F_C3F_V3F',
         'GL_T2F_N3F_V3F',
         'GL_T2F_C4F_N3F_V3F',
         'GL_T4F_C4F_N3F_V4F',
    ]

    def traceFunctionImplBody(self, function):
        # Defer tracing of user array pointers...
        if function.name in self.array_pointer_function_names:
            print '    GLint _array_buffer = _glGetInteger(GL_ARRAY_BUFFER_BINDING);'
            print '    if (!_array_buffer) {'
            print '        gltrace::Context *ctx = gltrace::getContext();'
            print '        ctx->user_arrays = true;'
            if function.name == "glVertexAttribPointerARB":
                print '        ctx->user_arrays_arb = true;'
            if function.name == "glVertexAttribPointerNV":
                print '        ctx->user_arrays_nv = true;'
            self.invokeFunction(function)

            # And also break down glInterleavedArrays into the individual calls
            if function.name == 'glInterleavedArrays':
                print

                # Initialize the enable flags
                for camelcase_name, uppercase_name in self.arrays:
                    flag_name = '_' + uppercase_name.lower()
                    print '        GLboolean %s = GL_FALSE;' % flag_name
                print

                # Switch for the interleaved formats
                print '        switch (format) {'
                for format in self.interleaved_formats:
                    print '            case %s:' % format
                    for camelcase_name, uppercase_name in self.arrays:
                        flag_name = '_' + uppercase_name.lower()
                        if format.find('_' + uppercase_name[0]) >= 0:
                            print '                %s = GL_TRUE;' % flag_name
                    print '                break;'
                print '            default:'
                print '               return;'
                print '        }'
                print

                # Emit fake glEnableClientState/glDisableClientState flags
                for camelcase_name, uppercase_name in self.arrays:
                    flag_name = '_' + uppercase_name.lower()
                    enable_name = 'GL_%s_ARRAY' % uppercase_name

                    # Emit a fake function
                    print '        {'
                    print '            static const trace::FunctionSig &_sig = %s ? _glEnableClientState_sig : _glDisableClientState_sig;' % flag_name
                    print '            unsigned _call = trace::localWriter.beginEnter(&_sig);'
                    print '            trace::localWriter.beginArg(0);'
                    self.serializeValue(glapi.GLenum, enable_name)
                    print '            trace::localWriter.endArg();'
                    print '            trace::localWriter.endEnter();'
                    print '            trace::localWriter.beginLeave(_call);'
                    print '            trace::localWriter.endLeave();'
                    print '        }'

            print '        return;'
            print '    }'

        # ... to the draw calls
        if function.name in self.draw_function_names:
            print '    if (_need_user_arrays()) {'
            arg_names = ', '.join([arg.name for arg in function.args[1:]])
            print '        GLuint _count = _%s_count(%s);' % (function.name, arg_names)
            # Some apps, in particular Quake3, can tell the driver to lock more
            # vertices than those actually required for the draw call.
            print '        if (_checkLockArraysEXT) {'
            print '            GLuint _locked_count = _glGetInteger(GL_ARRAY_ELEMENT_LOCK_FIRST_EXT)'
            print '                                 + _glGetInteger(GL_ARRAY_ELEMENT_LOCK_COUNT_EXT);'
            print '            _count = std::max(_count, _locked_count);'
            print '        }'
            print '        _trace_user_arrays(_count);'
            print '    }'
        if function.name == 'glLockArraysEXT':
            print '        _checkLockArraysEXT = true;'
        
        # Emit a fake memcpy on buffer uploads
        if function.name == 'glBufferParameteriAPPLE':
            print '    if (pname == GL_BUFFER_FLUSHING_UNMAP_APPLE && param == GL_FALSE) {'
            print '        _checkBufferFlushingUnmapAPPLE = true;'
            print '    }'
        if function.name in ('glUnmapBuffer', 'glUnmapBufferARB'):
            if function.name.endswith('ARB'):
                suffix = 'ARB'
            else:
                suffix = ''
            print '    GLint access = 0;'
            print '    _glGetBufferParameteriv%s(target, GL_BUFFER_ACCESS, &access);' % suffix
            print '    if (access != GL_READ_ONLY) {'
            print '        GLvoid *map = NULL;'
            print '        _glGetBufferPointerv%s(target, GL_BUFFER_MAP_POINTER, &map);'  % suffix
            print '        if (map) {'
            print '            GLint length = -1;'
            print '            bool flush = true;'
            print '            if (_checkBufferMapRange) {'
            print '                _glGetBufferParameteriv%s(target, GL_BUFFER_MAP_LENGTH, &length);' % suffix
            print '                GLint access_flags = 0;'
            print '                _glGetBufferParameteriv(target, GL_BUFFER_ACCESS_FLAGS, &access_flags);'
            print '                flush = flush && !(access_flags & GL_MAP_FLUSH_EXPLICIT_BIT);'
            print '                if (length == -1) {'
            print '                    // Mesa drivers refuse GL_BUFFER_MAP_LENGTH without GL 3.0 up-to'
            print '                    // http://cgit.freedesktop.org/mesa/mesa/commit/?id=ffee498fb848b253a7833373fe5430f8c7ca0c5f'
            print '                    static bool warned = false;'
            print '                    if (!warned) {'
            print '                        os::log("apitrace: warning: glGetBufferParameteriv%s(GL_BUFFER_MAP_LENGTH) failed\\n");' % suffix
            print '                        warned = true;'
            print '                    }'
            print '                    struct buffer_mapping *mapping = get_buffer_mapping(target);'
            print '                    if (mapping) {'
            print '                        length = mapping->length;'
            print '                        flush = flush && !mapping->explicit_flush;'
            print '                    } else {'
            print '                        length = 0;'
            print '                        flush = false;'
            print '                    }'
            print '                }'
            print '            } else {'
            print '                length = 0;'
            print '                _glGetBufferParameteriv%s(target, GL_BUFFER_SIZE, &length);' % suffix
            print '            }'
            print '            if (_checkBufferFlushingUnmapAPPLE) {'
            print '                GLint flushing_unmap = GL_TRUE;'
            print '                _glGetBufferParameteriv%s(target, GL_BUFFER_FLUSHING_UNMAP_APPLE, &flushing_unmap);' % suffix
            print '                flush = flush && flushing_unmap;'
            print '            }'
            print '            if (flush && length > 0) {'
            self.emit_memcpy('map', 'map', 'length')
            print '            }'
            print '        }'
            print '    }'
        if function.name == 'glUnmapBufferOES':
            print '    GLint access = 0;'
            print '    _glGetBufferParameteriv(target, GL_BUFFER_ACCESS_OES, &access);'
            print '    if (access == GL_WRITE_ONLY_OES) {'
            print '        GLvoid *map = NULL;'
            print '        _glGetBufferPointervOES(target, GL_BUFFER_MAP_POINTER_OES, &map);'
            print '        GLint size = 0;'
            print '        _glGetBufferParameteriv(target, GL_BUFFER_SIZE, &size);'
            print '        if (map && size > 0) {'
            self.emit_memcpy('map', 'map', 'size')
            self.shadowBufferMethod('bufferSubData(0, size, map)')
            print '        }'
            print '    }'
        if function.name == 'glUnmapNamedBufferEXT':
            print '    GLint access_flags = 0;'
            print '    _glGetNamedBufferParameterivEXT(buffer, GL_BUFFER_ACCESS_FLAGS, &access_flags);'
            print '    if ((access_flags & GL_MAP_WRITE_BIT) && !(access_flags & GL_MAP_FLUSH_EXPLICIT_BIT)) {'
            print '        GLvoid *map = NULL;'
            print '        _glGetNamedBufferPointervEXT(buffer, GL_BUFFER_MAP_POINTER, &map);'
            print '        GLint length = 0;'
            print '        _glGetNamedBufferParameterivEXT(buffer, GL_BUFFER_MAP_LENGTH, &length);'
            print '        if (map && length > 0) {'
            self.emit_memcpy('map', 'map', 'length')
            print '        }'
            print '    }'
        if function.name == 'glFlushMappedBufferRange':
            print '    GLvoid *map = NULL;'
            print '    _glGetBufferPointerv(target, GL_BUFFER_MAP_POINTER, &map);'
            print '    if (map && length > 0) {'
            self.emit_memcpy('(char *)map + offset', '(const char *)map + offset', 'length')
            print '    }'
        if function.name == 'glFlushMappedBufferRangeAPPLE':
            print '    GLvoid *map = NULL;'
            print '    _glGetBufferPointerv(target, GL_BUFFER_MAP_POINTER, &map);'
            print '    if (map && size > 0) {'
            self.emit_memcpy('(char *)map + offset', '(const char *)map + offset', 'size')
            print '    }'
        if function.name == 'glFlushMappedNamedBufferRangeEXT':
            print '    GLvoid *map = NULL;'
            print '    _glGetNamedBufferPointervEXT(buffer, GL_BUFFER_MAP_POINTER, &map);'
            print '    if (map && length > 0) {'
            self.emit_memcpy('(char *)map + offset', '(const char *)map + offset', 'length')
            print '    }'

        # FIXME: We don't support coherent/pinned memory mappings
        # See https://github.com/apitrace/apitrace/issues/232
        if function.name in ('glBufferStorage', 'glNamedBufferStorageEXT'):
            print r'    if (flags & GL_MAP_COHERENT_BIT) {'
            print r'        os::log("apitrace: warning: coherent mappings not fully supported\n");'
            print r'    }'
        if function.name in ('glBufferData', 'glBufferDataARB'):
            print r'    if (target == GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD) {'
            print r'        os::log("apitrace: warning: GL_AMD_pinned_memory not fully supported\n");'
            print r'    }'

        # Don't leave vertex attrib locations to chance.  Instead emit fake
        # glBindAttribLocation calls to ensure that the same locations will be
        # used when retracing.  Trying to remap locations after the fact would
        # be an herculian task given that vertex attrib locations appear in
        # many entry-points, including non-shader related ones.
        if function.name == 'glLinkProgram':
            Tracer.invokeFunction(self, function)
            print '    GLint active_attributes = 0;'
            print '    _glGetProgramiv(program, GL_ACTIVE_ATTRIBUTES, &active_attributes);'
            print '    for (GLint attrib = 0; attrib < active_attributes; ++attrib) {'
            print '        GLint size = 0;'
            print '        GLenum type = 0;'
            print '        GLchar name[256];'
            # TODO: Use ACTIVE_ATTRIBUTE_MAX_LENGTH instead of 256
            print '        _glGetActiveAttrib(program, attrib, sizeof name, NULL, &size, &type, name);'
            print "        if (name[0] != 'g' || name[1] != 'l' || name[2] != '_') {"
            print '            GLint location = _glGetAttribLocation(program, name);'
            print '            if (location >= 0) {'
            bind_function = glapi.glapi.getFunctionByName('glBindAttribLocation')
            self.fake_call(bind_function, ['program', 'location', 'name'])
            print '            }'
            print '        }'
            print '    }'
        if function.name == 'glLinkProgramARB':
            Tracer.invokeFunction(self, function)
            print '    GLint active_attributes = 0;'
            print '    _glGetObjectParameterivARB(programObj, GL_OBJECT_ACTIVE_ATTRIBUTES_ARB, &active_attributes);'
            print '    for (GLint attrib = 0; attrib < active_attributes; ++attrib) {'
            print '        GLint size = 0;'
            print '        GLenum type = 0;'
            print '        GLcharARB name[256];'
            # TODO: Use ACTIVE_ATTRIBUTE_MAX_LENGTH instead of 256
            print '        _glGetActiveAttribARB(programObj, attrib, sizeof name, NULL, &size, &type, name);'
            print "        if (name[0] != 'g' || name[1] != 'l' || name[2] != '_') {"
            print '            GLint location = _glGetAttribLocationARB(programObj, name);'
            print '            if (location >= 0) {'
            bind_function = glapi.glapi.getFunctionByName('glBindAttribLocationARB')
            self.fake_call(bind_function, ['programObj', 'location', 'name'])
            print '            }'
            print '        }'
            print '    }'

        self.shadowBufferProlog(function)

        Tracer.traceFunctionImplBody(self, function)

    # These entrypoints are only expected to be implemented by tools;
    # drivers will probably not implement them.
    marker_functions = [
        # GL_GREMEDY_string_marker
        'glStringMarkerGREMEDY',
        # GL_GREMEDY_frame_terminator
        'glFrameTerminatorGREMEDY',
        # GL_EXT_debug_marker
        'glInsertEventMarkerEXT',
        'glPushGroupMarkerEXT',
        'glPopGroupMarkerEXT',
    ]

    # These entrypoints may be implemented by drivers, but are also very useful
    # for debugging / analysis tools.
    debug_functions = [
        # GL_KHR_debug
        'glDebugMessageControl',
        'glDebugMessageInsert',
        'glDebugMessageCallback',
        'glGetDebugMessageLog',
        'glPushDebugGroup',
        'glPopDebugGroup',
        'glObjectLabel',
        'glGetObjectLabel',
        'glObjectPtrLabel',
        'glGetObjectPtrLabel',
        # GL_ARB_debug_output
        'glDebugMessageControlARB',
        'glDebugMessageInsertARB',
        'glDebugMessageCallbackARB',
        'glGetDebugMessageLogARB',
        # GL_AMD_debug_output
        'glDebugMessageEnableAMD',
        'glDebugMessageInsertAMD',
        'glDebugMessageCallbackAMD',
        'glGetDebugMessageLogAMD',
    ]

    def invokeFunction(self, function):
        if function.name in ('glLinkProgram', 'glLinkProgramARB'):
            # These functions have been dispatched already
            return

        Tracer.invokeFunction(self, function)

    def doInvokeFunction(self, function):
        # Same as invokeFunction() but called both when trace is enabled or disabled.
        #
        # Used to modify the behavior of GL entry-points.

        # Override GL extensions
        if function.name in ('glGetString', 'glGetIntegerv', 'glGetStringi'):
            Tracer.doInvokeFunction(self, function, prefix = 'gltrace::_', suffix = '_override')
            return

        # We implement GL_EXT_debug_marker, GL_GREMEDY_*, etc., and not the
        # driver
        if function.name in self.marker_functions:
            return

        # We may be faking KHR_debug, so ensure the pointer queries result is
        # always zeroed to prevent dereference of unitialized pointers
        if function.name == 'glGetPointerv':
            print '    if (params &&'
            print '        (pname == GL_DEBUG_CALLBACK_FUNCTION ||'
            print '         pname == GL_DEBUG_CALLBACK_USER_PARAM)) {'
            print '        *params = NULL;'
            print '    }'

        if function.name in self.getProcAddressFunctionNames:
            else_ = ''
            for marker_function in self.marker_functions:
                if self.api.getFunctionByName(marker_function):
                    print '    %sif (strcmp("%s", (const char *)%s) == 0) {' % (else_, marker_function, function.args[0].name)
                    print '        _result = (%s)&%s;' % (function.type, marker_function)
                    print '    }'
                else_ = 'else '
            print '    %s{' % else_
            Tracer.doInvokeFunction(self, function)

            # Replace function addresses with ours
            # XXX: Doing this here instead of wrapRet means that the trace will
            # contain the addresses of the wrapper functions, and not the real
            # functions, but in practice this should make no difference.
            if function.name in self.getProcAddressFunctionNames:
                print '    _result = _wrapProcAddress(%s, _result);' % (function.args[0].name,)

            print '    }'
            return

        Tracer.doInvokeFunction(self, function)

    buffer_targets = [
        'ARRAY_BUFFER',
        'ELEMENT_ARRAY_BUFFER',
        'PIXEL_PACK_BUFFER',
        'PIXEL_UNPACK_BUFFER',
        'UNIFORM_BUFFER',
        'TEXTURE_BUFFER',
        'TRANSFORM_FEEDBACK_BUFFER',
        'COPY_READ_BUFFER',
        'COPY_WRITE_BUFFER',
        'DRAW_INDIRECT_BUFFER',
        'ATOMIC_COUNTER_BUFFER',
    ]

    def wrapRet(self, function, instance):
        Tracer.wrapRet(self, function, instance)

        # Keep track of buffer mappings
        if function.name in ('glMapBuffer', 'glMapBufferARB'):
            print '    struct buffer_mapping *mapping = get_buffer_mapping(target);'
            print '    if (mapping) {'
            print '        mapping->map = %s;' % (instance)
            print '        mapping->length = 0;'
            print '        _glGetBufferParameteriv(target, GL_BUFFER_SIZE, &mapping->length);'
            print '        mapping->write = (access != GL_READ_ONLY);'
            print '        mapping->explicit_flush = false;'
            print '    }'
        if function.name == 'glMapBufferRange':
            print '    if (access & GL_MAP_WRITE_BIT) {'
            print '        _checkBufferMapRange = true;'
            print '    }'
            print '    struct buffer_mapping *mapping = get_buffer_mapping(target);'
            print '    if (mapping) {'
            print '        mapping->map = %s;' % (instance)
            print '        mapping->length = length;'
            print '        mapping->write = access & GL_MAP_WRITE_BIT;'
            print '        mapping->explicit_flush = access & GL_MAP_FLUSH_EXPLICIT_BIT;'
            print '    }'

    boolean_names = [
        'GL_FALSE',
        'GL_TRUE',
    ]

    def gl_boolean(self, value):
        return self.boolean_names[int(bool(value))]

    # Names of the functions that unpack from a pixel buffer object.  See the
    # ARB_pixel_buffer_object specification.
    unpack_function_names = set([
        'glBitmap',
        'glColorSubTable',
        'glColorTable',
        'glCompressedMultiTexImage1DEXT',
        'glCompressedMultiTexImage2DEXT',
        'glCompressedMultiTexImage3DEXT',
        'glCompressedMultiTexSubImage1DEXT',
        'glCompressedMultiTexSubImage2DEXT',
        'glCompressedMultiTexSubImage3DEXT',
        'glCompressedTexImage1D',
        'glCompressedTexImage1DARB',
        'glCompressedTexImage2D',
        'glCompressedTexImage2DARB',
        'glCompressedTexImage3D',
        'glCompressedTexImage3DARB',
        'glCompressedTexSubImage1D',
        'glCompressedTexSubImage1DARB',
        'glCompressedTexSubImage2D',
        'glCompressedTexSubImage2DARB',
        'glCompressedTexSubImage3D',
        'glCompressedTexSubImage3DARB',
        'glCompressedTextureImage1DEXT',
        'glCompressedTextureImage2DEXT',
        'glCompressedTextureImage3DEXT',
        'glCompressedTextureSubImage1DEXT',
        'glCompressedTextureSubImage2DEXT',
        'glCompressedTextureSubImage3DEXT',
        'glConvolutionFilter1D',
        'glConvolutionFilter2D',
        'glDrawPixels',
        'glMultiTexImage1DEXT',
        'glMultiTexImage2DEXT',
        'glMultiTexImage3DEXT',
        'glMultiTexSubImage1DEXT',
        'glMultiTexSubImage2DEXT',
        'glMultiTexSubImage3DEXT',
        'glPixelMapfv',
        'glPixelMapuiv',
        'glPixelMapusv',
        'glPolygonStipple',
        'glSeparableFilter2D',
        'glTexImage1D',
        'glTexImage1DEXT',
        'glTexImage2D',
        'glTexImage2DEXT',
        'glTexImage3D',
        'glTexImage3DEXT',
        'glTexSubImage1D',
        'glTexSubImage1DEXT',
        'glTexSubImage2D',
        'glTexSubImage2DEXT',
        'glTexSubImage3D',
        'glTexSubImage3DEXT',
        'glTextureImage1DEXT',
        'glTextureImage2DEXT',
        'glTextureImage3DEXT',
        'glTextureSubImage1DEXT',
        'glTextureSubImage2DEXT',
        'glTextureSubImage3DEXT',
    ])

    def serializeArgValue(self, function, arg):
        # Recognize offsets instead of blobs when a PBO is bound
        if function.name in self.unpack_function_names \
           and (isinstance(arg.type, stdapi.Blob) \
                or (isinstance(arg.type, stdapi.Const) \
                    and isinstance(arg.type.type, stdapi.Blob))):
            print '    {'
            print '        gltrace::Context *ctx = gltrace::getContext();'
            print '        GLint _unpack_buffer = 0;'
            print '        if (ctx->profile == gltrace::PROFILE_COMPAT)'
            print '            _glGetIntegerv(GL_PIXEL_UNPACK_BUFFER_BINDING, &_unpack_buffer);'
            print '        if (_unpack_buffer) {'
            print '            trace::localWriter.writePointer((uintptr_t)%s);' % arg.name
            print '        } else {'
            Tracer.serializeArgValue(self, function, arg)
            print '        }'
            print '    }'
            return

        # Several GL state functions take GLenum symbolic names as
        # integer/floats; so dump the symbolic name whenever possible
        if function.name.startswith('gl') \
           and arg.type in (glapi.GLint, glapi.GLfloat, glapi.GLdouble) \
           and arg.name == 'param':
            assert arg.index > 0
            assert function.args[arg.index - 1].name == 'pname'
            assert function.args[arg.index - 1].type == glapi.GLenum
            print '    if (is_symbolic_pname(pname) && is_symbolic_param(%s)) {' % arg.name
            self.serializeValue(glapi.GLenum, arg.name)
            print '    } else {'
            Tracer.serializeArgValue(self, function, arg)
            print '    }'
            return

        Tracer.serializeArgValue(self, function, arg)

    def footer(self, api):
        Tracer.footer(self, api)

        # A simple state tracker to track the pointer values
        # update the state
        print 'static void _trace_user_arrays(GLuint count)'
        print '{'
        print '    gltrace::Context *ctx = gltrace::getContext();'
        print

        # Temporarily unbind the array buffer
        print '    GLint _array_buffer = _glGetInteger(GL_ARRAY_BUFFER_BINDING);'
        print '    if (_array_buffer) {'
        self.fake_glBindBuffer(api, 'GL_ARRAY_BUFFER', '0')
        print '    }'
        print

        for camelcase_name, uppercase_name in self.arrays:
            # in which profile is the array available?
            profile_check = 'ctx->profile == gltrace::PROFILE_COMPAT'
            if camelcase_name in self.arrays_es1:
                profile_check = '(' + profile_check + ' || ctx->profile == gltrace::PROFILE_ES1)';

            function_name = 'gl%sPointer' % camelcase_name
            enable_name = 'GL_%s_ARRAY' % uppercase_name
            binding_name = 'GL_%s_ARRAY_BUFFER_BINDING' % uppercase_name
            function = api.getFunctionByName(function_name)

            print '    // %s' % function.prototype()
            print '  if (%s) {' % profile_check
            self.array_trace_prolog(api, uppercase_name)
            self.array_prolog(api, uppercase_name)
            print '    if (_glIsEnabled(%s)) {' % enable_name
            print '        GLint _binding = _glGetInteger(%s);' % binding_name
            print '        if (!_binding) {'

            # Get the arguments via glGet*
            for arg in function.args:
                arg_get_enum = 'GL_%s_ARRAY_%s' % (uppercase_name, arg.name.upper())
                arg_get_function, arg_type = TypeGetter().visit(arg.type)
                print '            %s %s = 0;' % (arg_type, arg.name)
                print '            _%s(%s, &%s);' % (arg_get_function, arg_get_enum, arg.name)
            
            arg_names = ', '.join([arg.name for arg in function.args[:-1]])
            print '            size_t _size = _%s_size(%s, count);' % (function.name, arg_names)

            # Emit a fake function
            self.array_trace_intermezzo(api, uppercase_name)
            print '            unsigned _call = trace::localWriter.beginEnter(&_%s_sig);' % (function.name,)
            for arg in function.args:
                assert not arg.output
                print '            trace::localWriter.beginArg(%u);' % (arg.index,)
                if arg.name != 'pointer':
                    self.serializeValue(arg.type, arg.name)
                else:
                    print '            trace::localWriter.writeBlob((const void *)%s, _size);' % (arg.name)
                print '            trace::localWriter.endArg();'
            
            print '            trace::localWriter.endEnter();'
            print '            trace::localWriter.beginLeave(_call);'
            print '            trace::localWriter.endLeave();'
            print '        }'
            print '    }'
            self.array_epilog(api, uppercase_name)
            self.array_trace_epilog(api, uppercase_name)
            print '  }'
            print

        # Samething, but for glVertexAttribPointer*
        #
        # Some variants of glVertexAttribPointer alias conventional and generic attributes:
        # - glVertexAttribPointer: no
        # - glVertexAttribPointerARB: implementation dependent
        # - glVertexAttribPointerNV: yes
        #
        # This means that the implementations of these functions do not always
        # alias, and they need to be considered independently.
        #
        print '    // ES1 does not support generic vertex attributes'
        print '    if (ctx->profile == gltrace::PROFILE_ES1)'
        print '        return;'
        print
        print '    vertex_attrib _vertex_attrib = _get_vertex_attrib();'
        print
        for suffix in ['', 'ARB', 'NV']:
            if suffix:
                SUFFIX = '_' + suffix
            else:
                SUFFIX = suffix
            function_name = 'glVertexAttribPointer' + suffix
            function = api.getFunctionByName(function_name)

            print '    // %s' % function.prototype()
            print '    if (_vertex_attrib == VERTEX_ATTRIB%s) {' % SUFFIX
            if suffix == 'NV':
                print '        GLint _max_vertex_attribs = 16;'
            else:
                print '        GLint _max_vertex_attribs = _glGetInteger(GL_MAX_VERTEX_ATTRIBS);'
            print '        for (GLint index = 0; index < _max_vertex_attribs; ++index) {'
            print '            GLint _enabled = 0;'
            if suffix == 'NV':
                print '            _glGetIntegerv(GL_VERTEX_ATTRIB_ARRAY0_NV + index, &_enabled);'
            else:
                print '            _glGetVertexAttribiv%s(index, GL_VERTEX_ATTRIB_ARRAY_ENABLED%s, &_enabled);' % (suffix, SUFFIX)
            print '            if (_enabled) {'
            print '                GLint _binding = 0;'
            if suffix != 'NV':
                # It doesn't seem possible to use VBOs with NV_vertex_program.
                print '                _glGetVertexAttribiv%s(index, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING%s, &_binding);' % (suffix, SUFFIX)
            print '                if (!_binding) {'

            # Get the arguments via glGet*
            for arg in function.args[1:]:
                if suffix == 'NV':
                    arg_get_enum = 'GL_ATTRIB_ARRAY_%s%s' % (arg.name.upper(), SUFFIX)
                else:
                    arg_get_enum = 'GL_VERTEX_ATTRIB_ARRAY_%s%s' % (arg.name.upper(), SUFFIX)
                arg_get_function, arg_type = TypeGetter('glGetVertexAttrib', False, suffix).visit(arg.type)
                print '                    %s %s = 0;' % (arg_type, arg.name)
                print '                    _%s(index, %s, &%s);' % (arg_get_function, arg_get_enum, arg.name)
            
            arg_names = ', '.join([arg.name for arg in function.args[1:-1]])
            print '                    size_t _size = _%s_size(%s, count);' % (function.name, arg_names)

            # Emit a fake function
            print '                    unsigned _call = trace::localWriter.beginEnter(&_%s_sig);' % (function.name,)
            for arg in function.args:
                assert not arg.output
                print '                    trace::localWriter.beginArg(%u);' % (arg.index,)
                if arg.name != 'pointer':
                    self.serializeValue(arg.type, arg.name)
                else:
                    print '                    trace::localWriter.writeBlob((const void *)%s, _size);' % (arg.name)
                print '                    trace::localWriter.endArg();'
            
            print '                    trace::localWriter.endEnter();'
            print '                    trace::localWriter.beginLeave(_call);'
            print '                    trace::localWriter.endLeave();'
            print '                }'
            print '            }'
            print '        }'
            print '    }'
            print

        # Restore the original array_buffer
        print '    if (_array_buffer) {'
        self.fake_glBindBuffer(api, 'GL_ARRAY_BUFFER', '_array_buffer')
        print '    }'
        print

        print '}'
        print

    #
    # Hooks for glTexCoordPointer, which is identical to the other array
    # pointers except the fact that it is indexed by glClientActiveTexture.
    #

    def array_prolog(self, api, uppercase_name):
        if uppercase_name == 'TEXTURE_COORD':
            print '    GLint client_active_texture = _glGetInteger(GL_CLIENT_ACTIVE_TEXTURE);'
            print '    GLint max_texture_coords = 0;'
            print '    if (ctx->profile == gltrace::PROFILE_COMPAT)'
            print '        _glGetIntegerv(GL_MAX_TEXTURE_COORDS, &max_texture_coords);'
            print '    else'
            print '        _glGetIntegerv(GL_MAX_TEXTURE_UNITS, &max_texture_coords);'
            print '    for (GLint unit = 0; unit < max_texture_coords; ++unit) {'
            print '        GLint texture = GL_TEXTURE0 + unit;'
            print '        _glClientActiveTexture(texture);'

    def array_trace_prolog(self, api, uppercase_name):
        if uppercase_name == 'TEXTURE_COORD':
            print '    bool client_active_texture_dirty = false;'

    def array_epilog(self, api, uppercase_name):
        if uppercase_name == 'TEXTURE_COORD':
            print '    }'
        self.array_cleanup(api, uppercase_name)

    def array_cleanup(self, api, uppercase_name):
        if uppercase_name == 'TEXTURE_COORD':
            print '    _glClientActiveTexture(client_active_texture);'
        
    def array_trace_intermezzo(self, api, uppercase_name):
        if uppercase_name == 'TEXTURE_COORD':
            print '    if (texture != client_active_texture || client_active_texture_dirty) {'
            print '        client_active_texture_dirty = true;'
            self.fake_glClientActiveTexture_call(api, "texture");
            print '    }'

    def array_trace_epilog(self, api, uppercase_name):
        if uppercase_name == 'TEXTURE_COORD':
            print '    if (client_active_texture_dirty) {'
            self.fake_glClientActiveTexture_call(api, "client_active_texture");
            print '    }'

    def fake_glBindBuffer(self, api, target, buffer):
        function = api.getFunctionByName('glBindBuffer')
        self.fake_call(function, [target, buffer])

    def fake_glClientActiveTexture_call(self, api, texture):
        function = api.getFunctionByName('glClientActiveTexture')
        self.fake_call(function, [texture])

    def emitFakeTexture2D(self):
        function = glapi.glapi.getFunctionByName('glTexImage2D')
        instances = function.argNames()
        print '        unsigned _fake_call = trace::localWriter.beginEnter(&_%s_sig);' % (function.name,)
        for arg in function.args:
            assert not arg.output
            self.serializeArg(function, arg)
        print '        trace::localWriter.endEnter();'
        print '        trace::localWriter.beginLeave(_fake_call);'
        print '        trace::localWriter.endLeave();'












########NEW FILE########
__FILENAME__ = glxtrace
##########################################################################
#
# Copyright 2011 Jose Fonseca
# Copyright 2008-2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""GLX tracing generator."""


from gltrace import GlTracer
from specs.stdapi import Module, API
from specs.glapi import glapi
from specs.glxapi import glxapi
from specs.glesapi import glesapi


class GlxTracer(GlTracer):

    def isFunctionPublic(self, function):
        # The symbols visible in libGL.so can vary, so expose them all
        return True

    getProcAddressFunctionNames = [
        "glXGetProcAddress",
        "glXGetProcAddressARB",
    ]

    createContextFunctionNames = [
        'glXCreateContext',
        'glXCreateContextAttribsARB',
        'glXCreateContextWithConfigSGIX',
        'glXCreateNewContext',
    ]

    destroyContextFunctionNames = [
        'glXDestroyContext',
    ]

    makeCurrentFunctionNames = [
        'glXMakeCurrent',
        'glXMakeContextCurrent',
        'glXMakeCurrentReadSGI',
    ]

    def traceFunctionImplBody(self, function):
        if function.name in self.destroyContextFunctionNames:
            print '    gltrace::releaseContext((uintptr_t)ctx);'

        GlTracer.traceFunctionImplBody(self, function)

        if function.name in self.createContextFunctionNames:
            print '    if (_result != NULL)'
            print '        gltrace::createContext((uintptr_t)_result);'

        if function.name in self.makeCurrentFunctionNames:
            print '    if (_result) {'
            print '        if (ctx != NULL)'
            print '            gltrace::setContext((uintptr_t)ctx);'
            print '        else'
            print '            gltrace::clearContext();'
            print '    }'

        if function.name == 'glXBindTexImageEXT':
            # FIXME: glXBindTexImageEXT gets called frequently, so we should
            # avoid recording the same data over and over again somehow, e.g.:
            # - get the pixels before and after glXBindTexImageEXT, and only
            #   emit emitFakeTexture2D when it changes
            # - keep a global hash of the pixels
            # FIXME: Handle mipmaps
            print r'''
                unsigned glx_target = 0;
                _glXQueryDrawable(display, drawable, GLX_TEXTURE_TARGET_EXT, &glx_target);
                GLenum target;
                switch (glx_target) {
                // FIXME
                //case GLX_TEXTURE_1D_EXT:
                //    target = GL_TEXTURE_1D;
                //    break;
                case GLX_TEXTURE_2D_EXT:
                    target = GL_TEXTURE_2D;
                    break;
                case GLX_TEXTURE_RECTANGLE_EXT:
                    target = GL_TEXTURE_RECTANGLE;
                    break;
                default:
                    os::log("apitrace: warning: %s: unsupported GLX_TEXTURE_TARGET_EXT 0x%u\n", __FUNCTION__, glx_target);
                    target = GL_NONE;
                    break;
                }
                GLint level = 0;
                GLint internalformat = GL_NONE;
                _glGetTexLevelParameteriv(target, level, GL_TEXTURE_INTERNAL_FORMAT, &internalformat);
                // XXX: GL_TEXTURE_INTERNAL_FORMAT cannot be trusted on NVIDIA
                // -- it sometimes returns GL_BGRA, even though GL_BGR/BGRA is
                // not a valid internal format.
                switch (internalformat) {
                case GL_BGR:
                    internalformat = GL_RGB;
                    break;
                case GL_BGRA:
                    internalformat = GL_RGBA;
                    break;
                }
                GLint width = 0;
                _glGetTexLevelParameteriv(target, level, GL_TEXTURE_WIDTH, &width);
                GLint height = 0;
                _glGetTexLevelParameteriv(target, level, GL_TEXTURE_HEIGHT, &height);
                GLint border = 0;
                // XXX: We always use GL_RGBA format to read the pixels because:
                // - some implementations (Mesa) seem to return bogus results
                //   for GLX_TEXTURE_FORMAT_EXT
                // - hardware usually stores GL_RGB with 32bpp, so it should be
                //   faster to read/write
                // - it is more robust against GL_(UN)PACK_ALIGNMENT state
                //   changes
                // The drawback is that traces will be slightly bigger.
                GLenum format = GL_RGBA;
                GLenum type = GL_UNSIGNED_BYTE;
                if (target && internalformat && height && width) {
                    // FIXME: This assumes (UN)PACK state (in particular
                    // GL_(UN)PACK_ROW_LENGTH) is set to its defaults. We
                    // really should temporarily reset the state here (and emit
                    // according fake calls) to cope when its not. At very
                    // least we need a heads up warning that this will cause
                    // problems.
                    GLint alignment = 4;
                    GLint row_stride = _align(width * 4, alignment);
                    GLvoid * pixels = malloc(height * row_stride);
                    _glGetTexImage(target, level, format, type, pixels);
            '''
            self.emitFakeTexture2D()
            print r'''
                    free(pixels);
                }
            '''


if __name__ == '__main__':
    print
    print '#include <stdlib.h>'
    print '#include <string.h>'
    print
    print '#include "trace_writer_local.hpp"'
    print
    print '// To validate our prototypes'
    print '#define GL_GLEXT_PROTOTYPES'
    print '#define GLX_GLXEXT_PROTOTYPES'
    print
    print '#include "dlopen.hpp"'
    print '#include "glproc.hpp"'
    print '#include "glsize.hpp"'
    print

    module = Module()
    module.mergeModule(glxapi)
    module.mergeModule(glapi)
    module.mergeModule(glesapi)
    api = API()
    api.addModule(module)
    tracer = GlxTracer()
    tracer.traceApi(api)

    print r'''


/*
 * Several applications, such as Quake3, use dlopen("libGL.so.1"), but
 * LD_PRELOAD does not intercept symbols obtained via dlopen/dlsym, therefore
 * we need to intercept the dlopen() call here, and redirect to our wrapper
 * shared object.
 */
extern "C" PUBLIC
void * dlopen(const char *filename, int flag)
{
    void *handle;

    handle = _dlopen(filename, flag);

    const char * libgl_filename = getenv("TRACE_LIBGL");

    if (filename && handle && !libgl_filename) {
        if (0) {
            os::log("apitrace: warning: dlopen(\"%s\", 0x%x)\n", filename, flag);
        }

        // FIXME: handle absolute paths and other versions
        if (strcmp(filename, "libGL.so") == 0 ||
            strcmp(filename, "libGL.so.1") == 0) {

            // Use the true libGL.so handle instead of RTLD_NEXT from now on
            _libGlHandle = handle;

            // Get the file path for our shared object, and use it instead
            static int dummy = 0xdeedbeef;
            Dl_info info;
            if (dladdr(&dummy, &info)) {
                os::log("apitrace: redirecting dlopen(\"%s\", 0x%x)\n", filename, flag);
                handle = _dlopen(info.dli_fname, flag);
            } else {
                os::log("apitrace: warning: dladdr() failed\n");
            }
        }
    }

    return handle;
}



'''

########NEW FILE########
__FILENAME__ = trace
##########################################################################
#
# Copyright 2008-2010 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/

"""Common trace code generation."""


# Adjust path
import os.path
import sys
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))


import specs.stdapi as stdapi


def getWrapperInterfaceName(interface):
    return "Wrap" + interface.expr



class ComplexValueSerializer(stdapi.OnceVisitor):
    '''Type visitors which generates serialization functions for
    complex types.
    
    Simple types are serialized inline.
    '''

    def __init__(self, serializer):
        stdapi.OnceVisitor.__init__(self)
        self.serializer = serializer

    def visitVoid(self, literal):
        pass

    def visitLiteral(self, literal):
        pass

    def visitString(self, string):
        pass

    def visitConst(self, const):
        self.visit(const.type)

    def visitStruct(self, struct):
        print 'static const char * _struct%s_members[%u] = {' % (struct.tag, len(struct.members))
        for type, name,  in struct.members:
            if name is None:
                print '    "",'
            else:
                print '    "%s",' % (name,)
        print '};'
        print 'static const trace::StructSig _struct%s_sig = {' % (struct.tag,)
        if struct.name is None:
            structName = '""'
        else:
            structName = '"%s"' % struct.name
        print '    %u, %s, %u, _struct%s_members' % (struct.id, structName, len(struct.members), struct.tag)
        print '};'
        print

    def visitArray(self, array):
        self.visit(array.type)

    def visitAttribArray(self, array):
        pass

    def visitBlob(self, array):
        pass

    def visitEnum(self, enum):
        print 'static const trace::EnumValue _enum%s_values[] = {' % (enum.tag)
        for value in enum.values:
            print '    {"%s", %s},' % (value, value)
        print '};'
        print
        print 'static const trace::EnumSig _enum%s_sig = {' % (enum.tag)
        print '    %u, %u, _enum%s_values' % (enum.id, len(enum.values), enum.tag)
        print '};'
        print

    def visitBitmask(self, bitmask):
        print 'static const trace::BitmaskFlag _bitmask%s_flags[] = {' % (bitmask.tag)
        for value in bitmask.values:
            print '    {"%s", %s},' % (value, value)
        print '};'
        print
        print 'static const trace::BitmaskSig _bitmask%s_sig = {' % (bitmask.tag)
        print '    %u, %u, _bitmask%s_flags' % (bitmask.id, len(bitmask.values), bitmask.tag)
        print '};'
        print

    def visitPointer(self, pointer):
        self.visit(pointer.type)

    def visitIntPointer(self, pointer):
        pass

    def visitObjPointer(self, pointer):
        self.visit(pointer.type)

    def visitLinearPointer(self, pointer):
        self.visit(pointer.type)

    def visitHandle(self, handle):
        self.visit(handle.type)

    def visitReference(self, reference):
        self.visit(reference.type)

    def visitAlias(self, alias):
        self.visit(alias.type)

    def visitOpaque(self, opaque):
        pass

    def visitInterface(self, interface):
        pass

    def visitPolymorphic(self, polymorphic):
        if not polymorphic.contextLess:
            return
        print 'static void _write__%s(int selector, %s const & value) {' % (polymorphic.tag, polymorphic.expr)
        print '    switch (selector) {'
        for cases, type in polymorphic.iterSwitch():
            for case in cases:
                print '    %s:' % case
            self.serializer.visit(type, 'static_cast<%s>(value)' % (type,))
            print '        break;'
        print '    }'
        print '}'
        print


class ValueSerializer(stdapi.Visitor, stdapi.ExpanderMixin):
    '''Visitor which generates code to serialize any type.
    
    Simple types are serialized inline here, whereas the serialization of
    complex types is dispatched to the serialization functions generated by
    ComplexValueSerializer visitor above.
    '''

    def visitLiteral(self, literal, instance):
        print '    trace::localWriter.write%s(%s);' % (literal.kind, instance)

    def visitString(self, string, instance):
        if not string.wide:
            cast = 'const char *'
            suffix = 'String'
        else:
            cast = 'const wchar_t *'
            suffix = 'WString'
        if cast != string.expr:
            # reinterpret_cast is necessary for GLubyte * <=> char *
            instance = 'reinterpret_cast<%s>(%s)' % (cast, instance)
        if string.length is not None:
            length = ', %s' % self.expand(string.length)
        else:
            length = ''
        print '    trace::localWriter.write%s(%s%s);' % (suffix, instance, length)

    def visitConst(self, const, instance):
        self.visit(const.type, instance)

    def visitStruct(self, struct, instance):
        print '    trace::localWriter.beginStruct(&_struct%s_sig);' % (struct.tag,)
        for member in struct.members:
            self.visitMember(member, instance)
        print '    trace::localWriter.endStruct();'

    def visitArray(self, array, instance):
        length = '_c' + array.type.tag
        index = '_i' + array.type.tag
        array_length = self.expand(array.length)
        print '    if (%s) {' % instance
        print '        size_t %s = %s > 0 ? %s : 0;' % (length, array_length, array_length)
        print '        trace::localWriter.beginArray(%s);' % length
        print '        for (size_t %s = 0; %s < %s; ++%s) {' % (index, index, length, index)
        print '            trace::localWriter.beginElement();'
        self.visitElement(index, array.type, '(%s)[%s]' % (instance, index))
        print '            trace::localWriter.endElement();'
        print '        }'
        print '        trace::localWriter.endArray();'
        print '    } else {'
        print '        trace::localWriter.writeNull();'
        print '    }'

    def visitAttribArray(self, array, instance):
        # For each element, decide if it is a key or a value (which depends on the previous key).
        # If it is a value, store it as the right type - usually int, some bitfield, or some enum.
        # It is currently assumed that an unknown key means that it is followed by an int value.

        # determine the array length which must be passed to writeArray() up front
        count = '_c' + array.baseType.tag
        print '    {'
        print '    int %s;' % count
        print '    for (%(c)s = 0; %(array)s && %(array)s[%(c)s] != %(terminator)s; %(c)s += 2) {' \
              % {'c': count, 'array': instance, 'terminator': array.terminator}
        if array.hasKeysWithoutValues:
            print '        switch (int(%(array)s[%(c)s])) {' % {'array': instance, 'c': count}
            for key, valueType in array.valueTypes:
                if valueType is None:
                    print '        case %s:' % key
            print '            %s--;' % count # the next value is a key again and checked if it's the terminator
            print '            break;'
            print '        }'
        print '    }'
        print '    %(c)s += %(array)s ? 1 : 0;' % {'c': count, 'array': instance}
        print '    trace::localWriter.beginArray(%s);' % count

        # for each key / key-value pair write the key and the value, if the key requires one

        index = '_i' + array.baseType.tag
        print '    for (int %(i)s = 0; %(i)s < %(count)s; %(i)s++) {' % {'i': index, 'count': count}
        print '        trace::localWriter.beginElement();'
        self.visit(array.baseType, "%(array)s[%(i)s]" % {'array': instance, 'i': index})
        print '        trace::localWriter.endElement();'
        print '        if (%(i)s + 1 >= %(count)s) {' % {'i': index, 'count': count}
        print '            break;'
        print '        }'
        print '        switch (int(%(array)s[%(i)s++])) {' % {'array': instance, 'i': index}
        # write generic value the usual way
        for key, valueType in array.valueTypes:
            if valueType is not None:
                print '        case %s:' % key
                print '            trace::localWriter.beginElement();'
                self.visitElement(index, valueType, '(%(array)s)[%(i)s]' % {'array': instance, 'i': index})
                print '            trace::localWriter.endElement();'
                print '            break;'
        # known key with no value, just decrease the index so we treat the next value as a key
        if array.hasKeysWithoutValues:
            for key, valueType in array.valueTypes:
                if valueType is None:
                    print '        case %s:' % key
            print '            %s--;' % index
            print '            break;'
        # unknown key, write an int value
        print '        default:'
        print '            trace::localWriter.beginElement();'
        print '            os::log("apitrace: warning: %s: unknown key 0x%04X, interpreting value as int\\n", ' + \
                           '__FUNCTION__, int(%(array)s[%(i)s - 1]));'  % {'array': instance, 'i': index}
        print '            trace::localWriter.writeSInt(%(array)s[%(i)s]);' % {'array': instance, 'i': index}
        print '            trace::localWriter.endElement();'
        print '            break;'
        print '        }'
        print '    }'
        print '    trace::localWriter.endArray();'
        print '    }'


    def visitBlob(self, blob, instance):
        print '    trace::localWriter.writeBlob(%s, %s);' % (instance, self.expand(blob.size))

    def visitEnum(self, enum, instance):
        print '    trace::localWriter.writeEnum(&_enum%s_sig, %s);' % (enum.tag, instance)

    def visitBitmask(self, bitmask, instance):
        print '    trace::localWriter.writeBitmask(&_bitmask%s_sig, %s);' % (bitmask.tag, instance)

    def visitPointer(self, pointer, instance):
        print '    if (%s) {' % instance
        print '        trace::localWriter.beginArray(1);'
        print '        trace::localWriter.beginElement();'
        self.visit(pointer.type, "*" + instance)
        print '        trace::localWriter.endElement();'
        print '        trace::localWriter.endArray();'
        print '    } else {'
        print '        trace::localWriter.writeNull();'
        print '    }'

    def visitIntPointer(self, pointer, instance):
        print '    trace::localWriter.writePointer((uintptr_t)%s);' % instance

    def visitObjPointer(self, pointer, instance):
        print '    trace::localWriter.writePointer((uintptr_t)%s);' % instance

    def visitLinearPointer(self, pointer, instance):
        print '    trace::localWriter.writePointer((uintptr_t)%s);' % instance

    def visitReference(self, reference, instance):
        self.visit(reference.type, instance)

    def visitHandle(self, handle, instance):
        self.visit(handle.type, instance)

    def visitAlias(self, alias, instance):
        self.visit(alias.type, instance)

    def visitOpaque(self, opaque, instance):
        print '    trace::localWriter.writePointer((uintptr_t)%s);' % instance

    def visitInterface(self, interface, instance):
        assert False

    def visitPolymorphic(self, polymorphic, instance):
        if polymorphic.contextLess:
            print '    _write__%s(%s, %s);' % (polymorphic.tag, polymorphic.switchExpr, instance)
        else:
            switchExpr = self.expand(polymorphic.switchExpr)
            print '    switch (%s) {' % switchExpr
            for cases, type in polymorphic.iterSwitch():
                for case in cases:
                    print '    %s:' % case
                caseInstance = instance
                if type.expr is not None:
                    caseInstance = 'static_cast<%s>(%s)' % (type, caseInstance)
                self.visit(type, caseInstance)
                print '        break;'
            if polymorphic.defaultType is None:
                print r'    default:'
                print r'        os::log("apitrace: warning: %%s: unexpected polymorphic case %%i\n", __FUNCTION__, (int)%s);' % (switchExpr,)
                print r'        trace::localWriter.writeNull();'
                print r'        break;'
            print '    }'


class WrapDecider(stdapi.Traverser):
    '''Type visitor which will decide wheter this type will need wrapping or not.
    
    For complex types (arrays, structures), we need to know this before hand.
    '''

    def __init__(self):
        self.needsWrapping = False

    def visitLinearPointer(self, void):
        pass

    def visitInterface(self, interface):
        self.needsWrapping = True


class ValueWrapper(stdapi.Traverser, stdapi.ExpanderMixin):
    '''Type visitor which will generate the code to wrap an instance.
    
    Wrapping is necessary mostly for interfaces, however interface pointers can
    appear anywhere inside complex types.
    '''

    def visitStruct(self, struct, instance):
        for member in struct.members:
            self.visitMember(member, instance)

    def visitArray(self, array, instance):
        array_length = self.expand(array.length)
        print "    if (%s) {" % instance
        print "        for (size_t _i = 0, _s = %s; _i < _s; ++_i) {" % array_length
        self.visitElement('_i', array.type, instance + "[_i]")
        print "        }"
        print "    }"

    def visitPointer(self, pointer, instance):
        print "    if (%s) {" % instance
        self.visit(pointer.type, "*" + instance)
        print "    }"
    
    def visitObjPointer(self, pointer, instance):
        elem_type = pointer.type.mutable()
        if isinstance(elem_type, stdapi.Interface):
            self.visitInterfacePointer(elem_type, instance)
        elif isinstance(elem_type, stdapi.Alias) and isinstance(elem_type.type, stdapi.Interface):
            self.visitInterfacePointer(elem_type.type, instance)
        else:
            self.visitPointer(pointer, instance)
    
    def visitInterface(self, interface, instance):
        raise NotImplementedError

    def visitInterfacePointer(self, interface, instance):
        print "    if (%s) {" % instance
        print "        %s = %s::_Create(__FUNCTION__, %s);" % (instance, getWrapperInterfaceName(interface), instance)
        print "    }"
    
    def visitPolymorphic(self, type, instance):
        # XXX: There might be polymorphic values that need wrapping in the future
        raise NotImplementedError


class ValueUnwrapper(ValueWrapper):
    '''Reverse of ValueWrapper.'''

    allocated = False

    def visitStruct(self, struct, instance):
        if not self.allocated:
            # Argument is constant. We need to create a non const
            print '    {'
            print "        %s * _t = static_cast<%s *>(alloca(sizeof *_t));" % (struct, struct)
            print '        *_t = %s;' % (instance,)
            assert instance.startswith('*')
            print '        %s = _t;' % (instance[1:],)
            instance = '*_t'
            self.allocated = True
            try:
                return ValueWrapper.visitStruct(self, struct, instance)
            finally:
                print '    }'
        else:
            return ValueWrapper.visitStruct(self, struct, instance)

    def visitArray(self, array, instance):
        if self.allocated or isinstance(instance, stdapi.Interface):
            return ValueWrapper.visitArray(self, array, instance)
        array_length = self.expand(array.length)
        elem_type = array.type.mutable()
        print "    if (%s && %s) {" % (instance, array_length)
        print "        %s * _t = static_cast<%s *>(alloca(%s * sizeof *_t));" % (elem_type, elem_type, array_length)
        print "        for (size_t _i = 0, _s = %s; _i < _s; ++_i) {" % array_length
        print "            _t[_i] = %s[_i];" % instance 
        self.allocated = True
        self.visit(array.type, "_t[_i]")
        print "        }"
        print "        %s = _t;" % instance
        print "    }"

    def visitInterfacePointer(self, interface, instance):
        print r'    if (%s) {' % instance
        print r'        const %s *pWrapper = static_cast<const %s*>(%s);' % (getWrapperInterfaceName(interface), getWrapperInterfaceName(interface), instance)
        print r'        if (pWrapper && pWrapper->m_dwMagic == 0xd8365d6c) {'
        print r'            %s = pWrapper->m_pInstance;' % (instance,)
        print r'        } else {'
        print r'            os::log("apitrace: warning: %%s: unexpected %%s pointer\n", __FUNCTION__, "%s");' % interface.name
        print r'        }'
        print r'    }'


class Tracer:
    '''Base class to orchestrate the code generation of API tracing.'''

    # 0-3 are reserved to memcpy, malloc, free, and realloc
    __id = 4

    def __init__(self):
        self.api = None

    def serializerFactory(self):
        '''Create a serializer.
        
        Can be overriden by derived classes to inject their own serialzer.
        '''

        return ValueSerializer()

    def traceApi(self, api):
        self.api = api

        self.header(api)

        # Includes
        for module in api.modules:
            for header in module.headers:
                print header
        print

        # Generate the serializer functions
        types = api.getAllTypes()
        visitor = ComplexValueSerializer(self.serializerFactory())
        map(visitor.visit, types)
        print

        # Interfaces wrapers
        self.traceInterfaces(api)

        # Function wrappers
        self.interface = None
        self.base = None
        for function in api.getAllFunctions():
            self.traceFunctionDecl(function)
        for function in api.getAllFunctions():
            self.traceFunctionImpl(function)
        print

        self.footer(api)

    def header(self, api):
        print '#ifdef _WIN32'
        print '#  include <malloc.h> // alloca'
        print '#  ifndef alloca'
        print '#    define alloca _alloca'
        print '#  endif'
        print '#else'
        print '#  include <alloca.h> // alloca'
        print '#endif'
        print
        print
        print 'static std::map<void *, void *> g_WrappedObjects;'

    def footer(self, api):
        pass

    def traceFunctionDecl(self, function):
        # Per-function declarations

        if not function.internal:
            if function.args:
                print 'static const char * _%s_args[%u] = {%s};' % (function.name, len(function.args), ', '.join(['"%s"' % arg.name for arg in function.args]))
            else:
                print 'static const char ** _%s_args = NULL;' % (function.name,)
            print 'static const trace::FunctionSig _%s_sig = {%u, "%s", %u, _%s_args};' % (function.name, self.getFunctionSigId(), function.name, len(function.args), function.name)
            print

    def getFunctionSigId(self):
        id = Tracer.__id
        Tracer.__id += 1
        return id

    def isFunctionPublic(self, function):
        return True

    def traceFunctionImpl(self, function):
        if self.isFunctionPublic(function):
            print 'extern "C" PUBLIC'
        else:
            print 'extern "C" PRIVATE'
        print function.prototype() + ' {'
        if function.type is not stdapi.Void:
            print '    %s _result;' % function.type

        self.traceFunctionImplBody(function)
        if function.type is not stdapi.Void:
            print '    return _result;'
        print '}'
        print

    def traceFunctionImplBody(self, function):
        if not function.internal:
            print '    unsigned _call = trace::localWriter.beginEnter(&_%s_sig);' % (function.name,)
            for arg in function.args:
                if not arg.output:
                    self.unwrapArg(function, arg)
            for arg in function.args:
                if not arg.output:
                    self.serializeArg(function, arg)
            print '    trace::localWriter.endEnter();'
        self.invokeFunction(function)
        if not function.internal:
            print '    trace::localWriter.beginLeave(_call);'
            print '    if (%s) {' % self.wasFunctionSuccessful(function)
            for arg in function.args:
                if arg.output:
                    self.serializeArg(function, arg)
                    self.wrapArg(function, arg)
            print '    }'
            if function.type is not stdapi.Void:
                self.serializeRet(function, "_result")
            if function.type is not stdapi.Void:
                self.wrapRet(function, "_result")
            print '    trace::localWriter.endLeave();'

    def invokeFunction(self, function):
        self.doInvokeFunction(function)

    def doInvokeFunction(self, function, prefix='_', suffix=''):
        # Same as invokeFunction() but called both when trace is enabled or disabled.
        if function.type is stdapi.Void:
            result = ''
        else:
            result = '_result = '
        dispatch = prefix + function.name + suffix
        print '    %s%s(%s);' % (result, dispatch, ', '.join([str(arg.name) for arg in function.args]))

    def wasFunctionSuccessful(self, function):
        if function.type is stdapi.Void:
            return 'true'
        if str(function.type) == 'HRESULT':
            return 'SUCCEEDED(_result)'
        return 'true'

    def serializeArg(self, function, arg):
        print '    trace::localWriter.beginArg(%u);' % (arg.index,)
        self.serializeArgValue(function, arg)
        print '    trace::localWriter.endArg();'

    def serializeArgValue(self, function, arg):
        self.serializeValue(arg.type, arg.name)

    def wrapArg(self, function, arg):
        assert not isinstance(arg.type, stdapi.ObjPointer)

        from specs.winapi import REFIID
        riid = None
        for other_arg in function.args:
            if not other_arg.output and other_arg.type is REFIID:
                riid = other_arg
        if riid is not None \
           and isinstance(arg.type, stdapi.Pointer) \
           and isinstance(arg.type.type, stdapi.ObjPointer):
            self.wrapIid(function, riid, arg)
            return

        self.wrapValue(arg.type, arg.name)

    def unwrapArg(self, function, arg):
        self.unwrapValue(arg.type, arg.name)

    def serializeRet(self, function, instance):
        print '    trace::localWriter.beginReturn();'
        self.serializeValue(function.type, instance)
        print '    trace::localWriter.endReturn();'

    def serializeValue(self, type, instance):
        serializer = self.serializerFactory()
        serializer.visit(type, instance)

    def wrapRet(self, function, instance):
        self.wrapValue(function.type, instance)

    def needsWrapping(self, type):
        visitor = WrapDecider()
        visitor.visit(type)
        return visitor.needsWrapping

    def wrapValue(self, type, instance):
        if self.needsWrapping(type):
            visitor = ValueWrapper()
            visitor.visit(type, instance)

    def unwrapValue(self, type, instance):
        if self.needsWrapping(type):
            visitor = ValueUnwrapper()
            visitor.visit(type, instance)

    def traceInterfaces(self, api):
        interfaces = api.getAllInterfaces()
        if not interfaces:
            return
        map(self.declareWrapperInterface, interfaces)
        self.implementIidWrapper(api)
        map(self.implementWrapperInterface, interfaces)
        print

    def declareWrapperInterface(self, interface):
        print "class %s : public %s " % (getWrapperInterfaceName(interface), interface.name)
        print "{"
        print "private:"
        print "    %s(%s * pInstance);" % (getWrapperInterfaceName(interface), interface.name)
        print "    virtual ~%s();" % getWrapperInterfaceName(interface)
        print "public:"
        print "    static %s* _Create(const char *functionName, %s * pInstance);" % (getWrapperInterfaceName(interface), interface.name)
        print
        for method in interface.iterMethods():
            print "    " + method.prototype() + ";"
        print
        #print "private:"
        for type, name, value in self.enumWrapperInterfaceVariables(interface):
            print '    %s %s;' % (type, name)
        for i in range(64):
            print r'    virtual void _dummy%i(void) const {' % i
            print r'        os::log("error: %s: unexpected virtual method\n");' % interface.name
            print r'        os::abort();'
            print r'    }'
        print "};"
        print

    def enumWrapperInterfaceVariables(self, interface):
        return [
            ("DWORD", "m_dwMagic", "0xd8365d6c"),
            ("%s *" % interface.name, "m_pInstance", "pInstance"),
            ("void *", "m_pVtbl", "*(void **)pInstance"),
            ("UINT", "m_NumMethods", len(list(interface.iterBaseMethods()))),
        ] 

    def implementWrapperInterface(self, interface):
        self.interface = interface

        # Private constructor
        print '%s::%s(%s * pInstance) {' % (getWrapperInterfaceName(interface), getWrapperInterfaceName(interface), interface.name)
        for type, name, value in self.enumWrapperInterfaceVariables(interface):
            if value is not None:
                print '    %s = %s;' % (name, value)
        print '}'
        print

        # Public constructor
        print '%s *%s::_Create(const char *functionName, %s * pInstance) {' % (getWrapperInterfaceName(interface), getWrapperInterfaceName(interface), interface.name)
        print r'    std::map<void *, void *>::const_iterator it = g_WrappedObjects.find(pInstance);'
        print r'    if (it != g_WrappedObjects.end()) {'
        print r'        Wrap%s *pWrapper = (Wrap%s *)it->second;' % (interface.name, interface.name)
        print r'        assert(pWrapper);'
        print r'        assert(pWrapper->m_dwMagic == 0xd8365d6c);'
        print r'        assert(pWrapper->m_pInstance == pInstance);'
        print r'        if (pWrapper->m_pVtbl == *(void **)pInstance &&'
        print r'            pWrapper->m_NumMethods >= %s) {' % len(list(interface.iterBaseMethods()))
        #print r'            os::log("%s: fetched pvObj=%p pWrapper=%p pVtbl=%p\n", functionName, pInstance, pWrapper, pWrapper->m_pVtbl);'
        print r'            return pWrapper;'
        print r'        }'
        print r'    }'
        print r'    Wrap%s *pWrapper = new Wrap%s(pInstance);' % (interface.name, interface.name)
        #print r'    os::log("%%s: created %s pvObj=%%p pWrapper=%%p pVtbl=%%p\n", functionName, pInstance, pWrapper, pWrapper->m_pVtbl);' % interface.name
        print r'    g_WrappedObjects[pInstance] = pWrapper;'
        print r'    return pWrapper;'
        print '}'
        print

        # Destructor
        print '%s::~%s() {' % (getWrapperInterfaceName(interface), getWrapperInterfaceName(interface))
        #print r'        os::log("%s::Release: deleted pvObj=%%p pWrapper=%%p pVtbl=%%p\n", m_pInstance, this, m_pVtbl);' % interface.name
        print r'        g_WrappedObjects.erase(m_pInstance);'
        print '}'
        print
        
        for base, method in interface.iterBaseMethods():
            self.base = base
            self.implementWrapperInterfaceMethod(interface, base, method)

        print

    def implementWrapperInterfaceMethod(self, interface, base, method):
        print method.prototype(getWrapperInterfaceName(interface) + '::' + method.name) + ' {'

        if False:
            print r'    os::log("%%s(%%p -> %%p)\n", "%s", this, m_pInstance);' % (getWrapperInterfaceName(interface) + '::' + method.name)

        if method.type is not stdapi.Void:
            print '    %s _result;' % method.type
    
        self.implementWrapperInterfaceMethodBody(interface, base, method)
    
        if method.type is not stdapi.Void:
            print '    return _result;'
        print '}'
        print

    def implementWrapperInterfaceMethodBody(self, interface, base, method):
        assert not method.internal

        print '    static const char * _args[%u] = {%s};' % (len(method.args) + 1, ', '.join(['"this"'] + ['"%s"' % arg.name for arg in method.args]))
        print '    static const trace::FunctionSig _sig = {%u, "%s", %u, _args};' % (self.getFunctionSigId(), interface.name + '::' + method.name, len(method.args) + 1)

        print '    %s *_this = static_cast<%s *>(m_pInstance);' % (base, base)

        print '    unsigned _call = trace::localWriter.beginEnter(&_sig);'
        print '    trace::localWriter.beginArg(0);'
        print '    trace::localWriter.writePointer((uintptr_t)m_pInstance);'
        print '    trace::localWriter.endArg();'
        for arg in method.args:
            if not arg.output:
                self.unwrapArg(method, arg)
        for arg in method.args:
            if not arg.output:
                self.serializeArg(method, arg)
        print '    trace::localWriter.endEnter();'
        
        self.invokeMethod(interface, base, method)

        print '    trace::localWriter.beginLeave(_call);'

        print '    if (%s) {' % self.wasFunctionSuccessful(method)
        for arg in method.args:
            if arg.output:
                self.serializeArg(method, arg)
                self.wrapArg(method, arg)
        print '    }'

        if method.type is not stdapi.Void:
            self.serializeRet(method, '_result')
        if method.type is not stdapi.Void:
            self.wrapRet(method, '_result')

        if method.name == 'Release':
            assert method.type is not stdapi.Void
            print r'    if (!_result) {'
            print r'        delete this;'
            print r'    }'
        
        print '    trace::localWriter.endLeave();'

    def implementIidWrapper(self, api):
        print r'static void'
        print r'warnIID(const char *functionName, REFIID riid, const char *reason) {'
        print r'    os::log("apitrace: warning: %s: %s IID {0x%08lX,0x%04X,0x%04X,{0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X}}\n",'
        print r'            functionName, reason,'
        print r'            riid.Data1, riid.Data2, riid.Data3,'
        print r'            riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);'
        print r'}'
        print 
        print r'static void'
        print r'wrapIID(const char *functionName, REFIID riid, void * * ppvObj) {'
        print r'    if (!ppvObj || !*ppvObj) {'
        print r'        return;'
        print r'    }'
        else_ = ''
        for iface in api.getAllInterfaces():
            print r'    %sif (riid == IID_%s) {' % (else_, iface.name)
            print r'        *ppvObj = Wrap%s::_Create(functionName, (%s *) *ppvObj);' % (iface.name, iface.name)
            print r'    }'
            else_ = 'else '
        print r'    %s{' % else_
        print r'        warnIID(functionName, riid, "unknown");'
        print r'    }'
        print r'}'
        print

    def wrapIid(self, function, riid, out):
        # Cast output arg to `void **` if necessary
        out_name = out.name
        obj_type = out.type.type.type
        if not obj_type is stdapi.Void:
            assert isinstance(obj_type, stdapi.Interface)
            out_name = 'reinterpret_cast<void * *>(%s)' % out_name

        print r'    if (%s && *%s) {' % (out.name, out.name)
        functionName = function.name
        else_ = ''
        if self.interface is not None:
            functionName = self.interface.name + '::' + functionName
            print r'        if (*%s == m_pInstance &&' % (out_name,)
            print r'            (%s)) {' % ' || '.join('%s == IID_%s' % (riid.name, iface.name) for iface in self.interface.iterBases())
            print r'            *%s = this;' % (out_name,)
            print r'        }'
            else_ = 'else '
        print r'        %s{' % else_
        print r'             wrapIID("%s", %s, %s);' % (functionName, riid.name, out_name)
        print r'        }'
        print r'    }'

    def invokeMethod(self, interface, base, method):
        if method.type is stdapi.Void:
            result = ''
        else:
            result = '_result = '
        print '    %s_this->%s(%s);' % (result, method.name, ', '.join([str(arg.name) for arg in method.args]))
    
    def emit_memcpy(self, dest, src, length):
        print '        unsigned _call = trace::localWriter.beginEnter(&trace::memcpy_sig, true);'
        print '        trace::localWriter.beginArg(0);'
        print '        trace::localWriter.writePointer((uintptr_t)%s);' % dest
        print '        trace::localWriter.endArg();'
        print '        trace::localWriter.beginArg(1);'
        print '        trace::localWriter.writeBlob(%s, %s);' % (src, length)
        print '        trace::localWriter.endArg();'
        print '        trace::localWriter.beginArg(2);'
        print '        trace::localWriter.writeUInt(%s);' % length
        print '        trace::localWriter.endArg();'
        print '        trace::localWriter.endEnter();'
        print '        trace::localWriter.beginLeave(_call);'
        print '        trace::localWriter.endLeave();'
    
    def fake_call(self, function, args):
        print '            unsigned _fake_call = trace::localWriter.beginEnter(&_%s_sig);' % (function.name,)
        for arg, instance in zip(function.args, args):
            assert not arg.output
            print '            trace::localWriter.beginArg(%u);' % (arg.index,)
            self.serializeValue(arg.type, instance)
            print '            trace::localWriter.endArg();'
        print '            trace::localWriter.endEnter();'
        print '            trace::localWriter.beginLeave(_fake_call);'
        print '            trace::localWriter.endLeave();'
       

########NEW FILE########
__FILENAME__ = wgltrace
##########################################################################
#
# Copyright 2008-2009 VMware, Inc.
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
##########################################################################/


"""WGL tracing code generator."""


from gltrace import GlTracer
from specs.stdapi import Module, API, Void
from specs.glapi import glapi
from specs.wglapi import wglapi


class WglTracer(GlTracer):

    getProcAddressFunctionNames = [
        "wglGetProcAddress",
    ]

    createContextFunctionNames = [
        'wglCreateContext',
        'wglCreateContextAttribsARB',
        'wglCreateLayerContext',
    ]

    destroyContextFunctionNames = [
        'wglDeleteContext',
    ]

    makeCurrentFunctionNames = [
        'wglMakeCurrent',
        'wglMakeContextCurrentARB',
        'wglMakeContextCurrentEXT',
    ]

    def traceFunctionImplBody(self, function):
        if function.name.startswith('wgl'):
            # When implementing WGL extensions OpenGL ICDs often have no
            # alternative to calling back into OPENGL32.DLL's wgl* entry points
            # due to lack of extensibility in the ICD interface.  These
            # internal calls are not only visually confusing but can actually
            # cause problems when tracing, and replaying.  A particularly nasty
            # case is wglCreateContextAttribsARB which ends up calling
            # wglCreateContext/wglCreateLayerContext to obtain a HGLRC that's
            # recognizable by OPENGL32.DLL.  Therefore we need to detect and
            # dispatch internal calls, without further ado.
            print r'    if (_reentrant) {'
            self.invokeFunction(function)
            if function.type is not Void:
                print '    return _result;'
            print r'    }'
            print r'    ReentryScope _reentry;'
            print r'    (void)_reentry;'
            print

        if function.name in self.destroyContextFunctionNames:
            # Unlike other GL APIs like EGL or GLX, WGL will make the context
            # inactive if it's currently the active context.
            print '    if (_wglGetCurrentContext() == hglrc) {'
            print '        gltrace::clearContext();'
            print '    }'
            print '    gltrace::releaseContext((uintptr_t)hglrc);'

        GlTracer.traceFunctionImplBody(self, function)

        if function.name in self.createContextFunctionNames:
            print '    if (_result)'
            print '        gltrace::createContext((uintptr_t)_result);'

        if function.name in self.makeCurrentFunctionNames:
            print '    if (_result) {'
            print '        if (hglrc != NULL)'
            print '            gltrace::setContext((uintptr_t)hglrc);'
            print '        else'
            print '            gltrace::clearContext();'
            print '    }'


if __name__ == '__main__':
    print
    print '#define _GDI32_'
    print
    print '#include <string.h>'
    print '#include <windows.h>'
    print
    print '#include "trace_writer_local.hpp"'
    print '#include "os.hpp"'
    print
    print '// To validate our prototypes'
    print '#define GL_GLEXT_PROTOTYPES'
    print '#define WGL_GLXEXT_PROTOTYPES'
    print
    print '#include "glproc.hpp"'
    print '#include "glsize.hpp"'
    print
    print 'static OS_THREAD_SPECIFIC(uintptr_t) _reentrant;'
    print
    print '// Helper class to track reentries in function scope.'
    print 'struct ReentryScope {'
    print 'inline ReentryScope() { _reentrant = 1; }'
    print 'inline ~ReentryScope() { _reentrant = 0; }'
    print '};'
    print
    module = Module()
    module.mergeModule(glapi)
    module.mergeModule(wglapi)
    api = API()
    api.addModule(module)
    tracer = WglTracer()
    tracer.traceApi(api)

########NEW FILE########
