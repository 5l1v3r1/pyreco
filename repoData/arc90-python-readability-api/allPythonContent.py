__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Readability API Python Library documentation build configuration file, created by
# sphinx-quickstart on Tue May 28 14:41:33 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Readability API Python Library'
copyright = u'2013, Readability, LLC'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.2.5'
# The full version, including alpha/beta/rc tags.
release = '0.2.5'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'ReadabilityAPIPythonLibrarydoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'ReadabilityAPIPythonLibrary.tex', u'Readability API Python Library Documentation',
   u'Readability, LLC', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'readabilityapipythonlibrary', u'Readability API Python Library Documentation',
     [u'Readability, LLC'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'ReadabilityAPIPythonLibrary', u'Readability API Python Library Documentation',
   u'Readability, LLC', 'ReadabilityAPIPythonLibrary', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = auth
# -*- coding: utf-8 -*-

"""
readability.auth
~~~~~~~~~~~~~~~~

This module provides the xauth functionality for the Readability
HTTP API.

"""

import logging
import oauth2
import urllib
from cgi import parse_qsl


logger = logging.getLogger(__name__)
DEFAULT_BASE_URL_TEMPLATE = 'https://readability.com/api/rest/v1/{0}'
ACCESS_TOKEN_URL = 'oauth/access_token/'


def xauth(consumer_key, consumer_secret, username, password,
    base_url_template=DEFAULT_BASE_URL_TEMPLATE):
    """
    Returns an OAuth token that can be used with clients.ReaderClient.

    :param consumer_key:  Readability consumer key
    :param consumer_secret: Readability consumer secret
    :param username: A username
    :param password: A password
    :param base_url_template: Template for generating Readability API urls.

    """
    # fetch oauth token from server
    consumer = oauth2.Consumer(consumer_key, consumer_secret)
    client = oauth2.Client(consumer)
    client.add_credentials(username, password)
    client.authorizations

    params = {}
    params['x_auth_username'] = username
    params['x_auth_password'] = password
    params['x_auth_mode'] = 'client_auth'

    client.set_signature_method = oauth2.SignatureMethod_HMAC_SHA1()
    url = base_url_template.format(ACCESS_TOKEN_URL)

    logger.debug('POST to %s.', url)

    r, content = client.request(
        url, method='POST', body=urllib.urlencode(params))

    token = dict(parse_qsl(content))
    try:
        token = (token['oauth_token'], token['oauth_token_secret'])
    except KeyError:
        raise Exception('Invalid Credentials.')

    return token

########NEW FILE########
__FILENAME__ = clients
# -*- coding: utf-8 -*-

"""
readability.clients
~~~~~~~~~~~~~~~~~~~

This module provies a client for the Reader API.

"""

import json
import logging
import urllib

import oauth2
import httplib2

from .utils import filter_args_to_dict


logger = logging.getLogger(__name__)
DEFAULT_READER_URL_TEMPLATE = 'https://www.readability.com/api/rest/v1/{0}'
DEFAULT_PARSER_URL_TEMPLATE = 'https://www.readability.com/api/content/v1/{0}'
ACCEPTED_BOOKMARK_FILTERS = [
    'added_since',
    'added_until',
    'archive',
    'archived_since',
    'archived_until',
    'domain',
    'favorite',
    'only_deleted',
    'opened_since',
    'opened_until',
    'page',
    'per_page',
    'tags',
    'updated_since',
    'updated_until',
]


class BaseClient(object):
    """
    A base class for Readability clients.
    """
    def _create_response(self, response, content):
        """
        Modify the httplib2.Repsonse object to return.

        Add two attributes to it:

        1) `raw_content` - this is the untouched content returned from the
        server.

        2) `content` - this is a serialized response using `json.loads`.

        If the response was an error of any kind, the reponse content
        will be:

        ::
            {'error_message': <message from server>}

        The above will also be ran through `json.loads`.

        :param response: Repsonse received from API
        :param content: Content received from API

        """
        response.raw_content = content
        try:
            content = json.loads(content)
        except ValueError:
            # didn't get json output. Assuming it's a string
            if response.status >= 400:
                content = {'error_message': content}
            else:
                content = {'message': content}
        response.content = content

        return response


class ReaderClient(BaseClient):
    """
    Client for interacting with the Readability Reader API.

    Docs can be found at `http://www.readability.com/developers/api/reader`.
    """
    def __init__(self, consumer_key, consumer_secret, token_key, token_secret,
        base_url_template=DEFAULT_READER_URL_TEMPLATE):
        """
        Initialize the ReadeClient.

        :param consumer_key: Reader API key
        :param consumer_secret: Reader API secret
        :param token_key: Readability user token key
        :param token_secret: Readability user token secret
        :param base_url_template (optional): Template used to build URL to
            which requests will be sent. This shouldn't need to be passed as the
            main purpose for it is testing environments that the user probably
            doesn't have access to (staging, local dev, etc).
        """
        self.base_url_template = base_url_template
        self.token = oauth2.Token(token_key, token_secret)
        self.consumer = oauth2.Consumer(consumer_key, consumer_secret)
        self.oauth_client = oauth2.Client(self.consumer, self.token)

    def get(self, url):
        """
        Make a HTTP GET request to the Reader API.

        :param url: url to which to make a GET request.
        """
        logger.debug('Making GET request to %s', url)
        return self._create_response(
            *self.oauth_client.request(url, method='GET'))

    def post(self, url, post_params=None):
        """
        Make a HTTP POST request to the Reader API.

        :param url: url to which to make a POST request.
        :param post_params: parameters to be sent in the request's body.
        """
        params = urllib.urlencode(post_params)
        logger.debug('Making POST request to %s with body %s', url, params)
        return self._create_response(
            *self.oauth_client.request(url, method='POST', body=params))

    def delete(self, url):
        """
        Make a HTTP DELETE request to the Readability API.

        :param url: The url to which to send a DELETE request.
        """
        logger.debug('Making DELETE request to %s', url)
        return self._create_response(
            *self.oauth_client.request(url, method='DELETE'))

    def _generate_url(self, resource, query_params=None):
        """
        Generate a Readability URL to the given resource.

        :param resource: the path to the resource that the request should
            go to.
        :param query_params (optional): a dict of query params that should
            be added to the url.
        """
        if query_params:
            resource = '{0}?{1}'.format(
                resource, urllib.urlencode(query_params))

        return self.base_url_template.format(resource)

    def get_article(self, article_id):
        """
        Get a single article represented by `article_id`.

        :param article_id: ID of the article to retrieve.
        """
        url = self._generate_url('articles/{0}'.format(article_id))
        return self.get(url)

    def get_bookmarks(self, **filters):
        """
        Get Bookmarks for the current user.

        Filters:

        :param archive: Filter Bookmarks returned by archived status.
        :param favorite: Filter Bookmarks returned by favorite status.
        :param domain: Filter Bookmarks returned by a domain.
        :param added_since: Filter bookmarks by date added (since this date).
        :param added_until: Filter bookmarks by date added (until this date).
        :param opened_since: Filter bookmarks by date opened (since this date).
        :param opened_until: Filter bookmarks by date opened (until this date).
        :param archived_since: Filter bookmarks by date archived (since this date.)
        :param archived_until: Filter bookmarks by date archived (until this date.)
        :param updated_since: Filter bookmarks by date updated (since this date.)
        :param updated_until: Filter bookmarks by date updated (until this date.)
        :param page: What page of results to return. Default is 1.
        :param per_page: How many results to return per page. Default is 20, max is 50.
        :param only_deleted: Return only bookmarks that this user has deleted.
        :param tags: Comma separated string of tags to filter bookmarks.
        """
        filter_dict = filter_args_to_dict(filters, ACCEPTED_BOOKMARK_FILTERS)
        url = self._generate_url('bookmarks', query_params=filter_dict)
        return self.get(url)

    def get_bookmark(self, bookmark_id):
        """
        Get a single bookmark represented by `bookmark_id`.

        The requested bookmark must belong to the current user.

        :param bookmark_id: ID of the bookmark to retrieve.
        """
        url = self._generate_url('bookmarks/{0}'.format(bookmark_id))
        return self.get(url)

    def add_bookmark(self, url, favorite=False, archive=False):
        """
        Adds given bookmark.
        """
        rdb_url = self._generate_url('bookmarks')
        params = dict(url=url, favorite=int(favorite), archive=int(archive))
        return self.post(rdb_url, params)

    def update_bookmark(self, bookmark_id, favorite=None, archive=None, read_percent=None):
        """
        Updates given bookmark. The requested bookmark must belong to the
        current user.

        :param bookmark_id: ID of the bookmark to update.
        :param favorite (optional): Whether this article is favorited or not.
        :param archive (optional): Whether this article is archived or not.
        :param read_percent (optional): The read progress made in this article,
            where 1.0 means the bottom and 0.0 means the very top.
        """
        rdb_url = self._generate_url('bookmarks/{0}'.format(bookmark_id))
        params = {}
        if favorite is not None:
            params['favorite'] = 1 if favorite == True else 0
        if archive is not None:
            params['archive'] = 1 if archive == True else 0
        if read_percent is not None:
            try:
                params['read_percent'] = float(read_percent)
            except ValueError:
                pass
        return self.post(rdb_url, params)

    def favorite_bookmark(self, bookmark_id):
        """
        Favorites given bookmark. The requested bookmark must belong to the
        current user.

        :param bookmark_id: ID of the bookmark to favorite.
        """
        return self.update_bookmark(bookmark_id, favorite=True)

    def archive_bookmark(self, bookmark_id):
        """
        Archives given bookmark. The requested bookmark must belong to the
        current user.

        :param bookmark_id: ID of the bookmark to archive.
        """
        return self.update_bookmark(bookmark_id, archive=True)

    def set_read_percent_of_bookmark(self, bookmark_id, read_percent):
        """
        Set read progress of given bookmark. The requested bookmark must
        belong to the current user.

        :param bookmark_id: ID of the bookmark to update.
        :param read_percent: The read progress made in this article,
          where 1.0 means the bottom and 0.0 means the very top.
        """
        return self.update_bookmark(bookmark_id, read_percent=read_percent)

    def delete_bookmark(self, bookmark_id):
        """
        Delete a single bookmark represented by `bookmark_id`.

        The requested bookmark must belong to the current user.

        :param bookmark_id: ID of the bookmark to delete.
        """
        url = self._generate_url('bookmarks/{0}'.format(bookmark_id))
        return self.delete(url)

    def get_bookmark_tags(self, bookmark_id):
        """
        Retrieve tags that have been applied to a bookmark.

        The requested bookmark must belong to the current user.

        :param bookmark_id: ID of the bookmark to delete.
        """
        url = self._generate_url('bookmarks/{0}/tags'.format(bookmark_id))
        return self.get(url)

    def add_tags_to_bookmark(self, bookmark_id, tags):
        """
        Add tags to to a bookmark.

        The identified bookmark must belong to the current user.

        :param bookmark_id: ID of the bookmark to delete.
        :param tags: Comma separated tags to be applied.
        """
        url = self._generate_url('bookmarks/{0}/tags'.format(bookmark_id))
        params = dict(tags=tags)
        return self.post(url, params)

    def delete_tag_from_bookmark(self, bookmark_id, tag_id):
        """
        Remove a single tag from a bookmark.

        The identified bookmark must belong to the current user.

        :param bookmark_id: ID of the bookmark to delete.
        """
        url = self._generate_url('bookmarks/{0}/tags/{1}'.format(
            bookmark_id, tag_id))
        return self.delete(url)

    def get_tag(self, tag_id):
        """
        Get a single tag represented by `tag_id`.

        The requested tag must belong to the current user.

        :param tag_id: ID fo the tag to retrieve.
        """
        url = self._generate_url('tags/{0}'.format(tag_id))
        return self.get(url)

    def get_tags(self):
        """
        Get all tags belonging to the current user.
        """
        url = self._generate_url('tags')
        return self.get(url)

    def get_user(self):
        """
        Retrives the current user.
        """
        url = self._generate_url('users/_current')
        return self.get(url)


class ParserClient(BaseClient):
    """
    Client for interacting with the Readability Parser API.

    Docs can be found at `http://www.readability.com/developers/api/parser`.
    """
    def __init__(self, token, base_url_template=DEFAULT_PARSER_URL_TEMPLATE):
        """
        Initialize client.

        :param token: parser API token.
        :param base_url_template (optional): Template used to build URL to
            which requests will be sent. This shouldn't need to be passed as the
            main purpose for it is testing environments that the user probably
            doesn't have access to (staging, local dev, etc).
        """
        logger.debug('Initializing ParserClient with base url template %s',
            base_url_template)

        self.token = token
        self.base_url_template = base_url_template

    def get(self, url):
        """
        Make an HTTP GET request to the Parser API.

        :param url: url to which to make the request
        """
        logger.debug('Making GET request to %s', url)
        http = httplib2.Http()
        return self._create_response(*http.request(url, 'GET'))

    def head(self, url):
        """
        Make an HTTP HEAD request to the Parser API.

        :param url: url to which to make the request
        """
        logger.debug('Making HEAD request to %s', url)
        http = httplib2.Http()
        return self._create_response(*http.request(url, 'HEAD'))

    def post(self, url, post_params=None):
        """
        Make an HTTP POST request to the Parser API.

        :param url: url to which to make the request
        :param post_params: POST data to send along. Expected to be a dict.
        """
        post_params['token'] = self.token
        params = urllib.urlencode(post_params)
        logger.debug('Making POST request to %s with body %s', url, params)
        http = httplib2.Http()
        return self._create_response(*http.request(url, 'POST', body=params))

    def _generate_url(self, resource, query_params=None):
        """
        Build the url to resource.

        :param resource: Name of the resource that is being called. Options are
        `''` (empty string) for root resource, `'parser'`, `'confidence'`.
        :param query_params: Data to be passed as query parameters.
        """
        if query_params:
            # extra & is for the token to be added
            resource = '{0}?{1}&'.format(
                resource, urllib.urlencode(query_params))
        else:
            # if we don't have query parameters, setup the url with the
            # resource name and question mark so that we can add the token
            # easier
            resource = '{0}?'.format(resource)

        # add token
        resource = '{0}token={1}'.format(resource, self.token)

        # apply base url template and return
        return self.base_url_template.format(resource)

    def get_root(self):
        """
        Send a GET request to the root resource of the Parser API.
        """
        url = self._generate_url('')
        return self.get(url)

    def get_article_content(self, url=None, article_id=None, max_pages=25):
        """
        Send a GET request to the `parser` endpoint of the parser API to get
        article content.

        The article can be identified by either a URL or an id that exists
        in Readability.

        Note that either the `url` or `article_id` param should be passed.

        :param url (optional): The url of an article whose content is wanted.
        :param article_id (optional): The id of an article in the Readability
            system whose content is wanted.
        :param max_pages: The maximum number of pages to parse and combine.
            The default is 25.
        """
        query_params = {}
        if url is not None:
            query_params['url'] = url
        if article_id is not None:
            query_params['article_id'] = article_id
        query_params['max_pages'] = max_pages
        url = self._generate_url('parser', query_params=query_params)
        return self.get(url)

    def post_article_content(self, content, url, max_pages=25):
        """
        POST content to be parsed to the Parser API.

        Note: Even when POSTing content, a url must still be provided.

        :param content: the content to be parsed
        :param url: the url that represents the content
        :param max_pages (optional): the maximum number of pages to parse
            and combine. Default is 25.
        """
        params = {
            'doc': content,
            'url': url,
            'max_pages': max_pages
        }
        url = self._generate_url('parser')
        return self.post(url, post_params=params)

    def get_article_status(self, url=None, article_id=None):
        """
        Send a HEAD request to the `parser` endpoint to the parser API to
        get the articles status.

        Returned is a `httplib2.Response` object. The id and status for the
        article can be extracted from the `X-Article-Id` and `X-Article-Status`
        headers.

        Note that either the `url` or `article_id` param should be passed.

        :param url (optional): The url of an article whose content is wanted.
        :param article_id (optional): The id of an article in the Readability
            system whose content is wanted.
        """
        query_params = {}
        if url is not None:
            query_params['url'] = url
        if article_id is not None:
            query_params['article_id'] = article_id
        url = self._generate_url('parser', query_params=query_params)
        return self.head(url)

    def get_confidence(self, url=None, article_id=None):
        """
        Send a GET request to the `confidence` endpoint of the Parser API.

        Note that either the `url` or `article_id` param should be passed.

        :param url (optional): The url of an article whose content is wanted.
        :param article_id (optional): The id of an article in the Readability
            system whose content is wanted.
        """
        query_params = {}
        if url is not None:
            query_params['url'] = url
        if article_id is not None:
            query_params['article_id'] = article_id
        url = self._generate_url('confidence', query_params=query_params)
        return self.get(url)

########NEW FILE########
__FILENAME__ = settings_template
CONSUMER_KEY = ''
CONSUMER_SECRET = ''

USERNAME = ''
PASSWORD = ''

PARSER_TOKEN = ''

########NEW FILE########
__FILENAME__ = test_auth
# -*- coding: utf-8 -*-

from unittest import TestCase


from readability import xauth
from readability.tests.settings import \
        CONSUMER_KEY, CONSUMER_SECRET, PASSWORD, USERNAME


class XAuthTestCase(TestCase):
    """
    Test XAuth functionality.
    """
    def test_bad_base_url(self):
        """
        If given a bad base url template, the request to the
        ACCESS_TOKEN_URL should fail and an exception be raised.
        """
        token = None
        with self.assertRaises(Exception):
            token = xauth(CONSUMER_KEY, CONSUMER_SECRET, USERNAME, PASSWORD,
                base_url_template='https://arc90.com/{0}')
        self.assertEqual(token, None)

    def test_bad_consumer_key(self):
        """
        If given a bad consumer key, the `xauth` method should raise
        an exception.
        """
        token = None
        with self.assertRaises(Exception):
            token = \
                xauth('bad consumer key', CONSUMER_SECRET, USERNAME, PASSWORD)
        self.assertEqual(token, None)

    def test_bad_consumer_secret(self):
        """
        If given a bad consumer key, the `xauth` method should raise
        an exception.
        """
        token = None
        with self.assertRaises(Exception):
            token = \
                xauth(CONSUMER_KEY, 'bad consumer secret', USERNAME, PASSWORD)
        self.assertEqual(token, None)

    def test_bad_username(self):
        """
        If given a bad username, an exception should be raised.
        """
        token = None
        with self.assertRaises(Exception):
            token = \
                xauth(CONSUMER_KEY, CONSUMER_SECRET, 'bad username', PASSWORD)
        self.assertEqual(token, None)

    def test_bad_password(self):
        """
        If given a bad password, an exception should be raised.
        """
        token = None
        with self.assertRaises(Exception):
            token = \
                xauth(CONSUMER_KEY, CONSUMER_SECRET, USERNAME, 'badpassword')
        self.assertEqual(token, None)

    def test_successful_auth(self):
        """
        Test getting a token with proper creds
        """
        token = xauth(CONSUMER_KEY, CONSUMER_SECRET, USERNAME, PASSWORD)
        self.assertEqual(len(token), 2)

########NEW FILE########
__FILENAME__ = test_clients
# -*- coding: utf-8 -*-

from unittest import TestCase

from readability import xauth, ParserClient, ReaderClient
from readability.clients import DEFAULT_PARSER_URL_TEMPLATE
from readability.tests.settings import \
        CONSUMER_KEY, CONSUMER_SECRET, PARSER_TOKEN, PASSWORD, USERNAME


class ReaderClientNoBookmarkTest(TestCase):
    """
    Tests for the Readability ReaderClient class that need no bookmarks.
    """
    def setUp(self):
        """
        Need to get a token for each test.
        """
        token_pair = xauth(CONSUMER_KEY, CONSUMER_SECRET, USERNAME, PASSWORD)
        self.token_key = token_pair[0]
        self.token_secret = token_pair[1]

        self.reader_client = ReaderClient(CONSUMER_KEY, CONSUMER_SECRET,
            self.token_key, self.token_secret)

    def test_get_article(self):
        """
        Test the `get_article` method.
        """
        article_id = 'lun3elns'
        response = self.reader_client.get_article(article_id)
        self.assertEqual(response.status, 200)
        self.assertTrue(isinstance(response.content, dict))

        # spot check some keys
        some_expected_keys = set(['direction', 'title', 'url', 'excerpt',
            'content', 'processed', 'short_url', 'date_published'])
        keys_set = set(response.content.keys())
        self.assertTrue(some_expected_keys.issubset(keys_set))

    def test_get_article_404(self):
        """
        Try getting an article that doesn't exist.
        """
        article_id = 1
        response = self.reader_client.get_article(article_id)
        self.assertEqual(response.status, 404)
        self.assertTrue(isinstance(response.content, dict))
        self.assertTrue('error_message' in response.content)

    def test_get_user(self):
        """
        Test getting user data
        """
        user_response = self.reader_client.get_user()
        self.assertEqual(user_response.status, 200)
        some_expected_keys = set(['username', 'first_name', 'last_name',
            'date_joined', 'email_into_address'])
        received_keys = set(user_response.content.keys())
        self.assertTrue(some_expected_keys.issubset(received_keys))

    def _test_get_tags(self):
        """
        Test getting tags.
        """
        tag_response = self.reader_client.get_tags()
        self.assertEqual(tag_response.status, 200)
        self.assertTrue('tags' in tag_response.content)
        self.assertTrue(len(tag_response.content['tags']) > 0)


class ReaderClientSingleBookmarkTest(TestCase):
    """
    Tests that only need one bookmark
    """
    def setUp(self):
        """
        Get a client and add a bookmark
        """
        token_pair = xauth(CONSUMER_KEY, CONSUMER_SECRET, USERNAME, PASSWORD)
        self.token_key = token_pair[0]
        self.token_secret = token_pair[1]

        self.reader_client = ReaderClient(CONSUMER_KEY, CONSUMER_SECRET,
            self.token_key, self.token_secret)

        self.url = 'http://www.theatlantic.com/technology/archive/2013/01/the-never-before-told-story-of-the-worlds-first-computer-art-its-a-sexy-dame/267439/'
        add_response = self.reader_client.add_bookmark(self.url)
        self.assertEqual(add_response.status, 202)

    def tearDown(self):
        """
        Remove all added bookmarks.
        """
        for bm in self.reader_client.get_bookmarks().content['bookmarks']:
            del_response = self.reader_client.delete_bookmark(bm['id'])
            self.assertEqual(del_response.status, 204)

    def test_get_bookmark(self):
        """
        Test getting one bookmark by id
        """
        bookmark_id = self._get_bookmark_data()['id']

        bm_response = self.reader_client.get_bookmark(bookmark_id)
        self.assertEqual(bm_response.status, 200)
        some_expected_keys = set(['article', 'user_id', 'favorite', 'id'])
        received_keys = set(bm_response.content.keys())
        self.assertTrue(some_expected_keys.issubset(received_keys))

    def test_archive_bookmark(self):
        """
        Test archiving a bookmark. The ``archive_bookmark`` method is just
        a convenient wrapper around the ``update_bookmark`` method but
        we'll go ahead and test it anyway.
        """
        bm_data = self._get_bookmark_data()

    def test_bookmark_tag_functionality(self):
        """
        Test adding, fetching and deleting tags on a bookmark.
        """
        bookmark_id = self._get_bookmark_data()['id']

        # test getting empty tags
        tag_response = self.reader_client.get_bookmark_tags(bookmark_id)
        self.assertEqual(tag_response.status, 200)
        self.assertEqual(len(tag_response.content['tags']), 0)

        # test adding tags
        tags = ['tag', 'another tag']
        tag_string = ', '.join(tags)
        tag_add_response = \
            self.reader_client.add_tags_to_bookmark(bookmark_id, tag_string)
        self.assertEqual(tag_add_response.status, 202)

        # re-fetch tags. should have 2
        retag_response = self.reader_client.get_bookmark_tags(bookmark_id)
        self.assertEqual(retag_response.status, 200)
        self.assertEqual(len(retag_response.content['tags']), 2)
        for tag in retag_response.content['tags']:
            self.assertTrue(tag['text'] in tags)

        # test getting tags for user
        user_tag_resp = self.reader_client.get_tags()
        self.assertEqual(user_tag_resp.status, 200)
        self.assertEqual(len(user_tag_resp.content['tags']), 2)
        for tag in user_tag_resp.content['tags']:
            self.assertTrue(tag['text'] in tags)

            # test getting a single tag while we're here
            single_tag_resp = self.reader_client.get_tag(tag['id'])
            self.assertEqual(single_tag_resp.status, 200)
            self.assertTrue('applied_count' in single_tag_resp.content)
            self.assertTrue('id' in single_tag_resp.content)
            self.assertTrue('text' in single_tag_resp.content)

        # delete tags
        for tag in retag_response.content['tags']:
            del_response = self.reader_client.delete_tag_from_bookmark(
                bookmark_id, tag['id'])
            self.assertEqual(del_response.status, 204)

        # check that tags are gone
        tag_response = self.reader_client.get_bookmark_tags(bookmark_id)
        self.assertEqual(tag_response.status, 200)
        self.assertEqual(len(tag_response.content['tags']), 0)

    def _get_bookmark_data(self):
        """
        Convenience method to get a single bookmark's data.
        """
        bm_response = self.reader_client.get_bookmarks()
        self.assertEqual(bm_response.status, 200)
        self.assertTrue(len(bm_response.content['bookmarks']) > 0)
        return bm_response.content['bookmarks'][0]


class ReaderClientMultipleBookmarkTest(TestCase):
    """
    Tests for bookmark functionality
    """
    def setUp(self):
        """
        Add a few bookmarks.
        """
        token_pair = xauth(CONSUMER_KEY, CONSUMER_SECRET, USERNAME, PASSWORD)
        self.token_key = token_pair[0]
        self.token_secret = token_pair[1]

        self.reader_client = ReaderClient(CONSUMER_KEY, CONSUMER_SECRET,
            self.token_key, self.token_secret)

        self.urls = [
            'http://www.theatlantic.com/technology/archive/2013/01/the-never-before-told-story-of-the-worlds-first-computer-art-its-a-sexy-dame/267439/',
            'http://www.theatlantic.com/business/archive/2013/01/why-smart-poor-students-dont-apply-to-selective-colleges-and-how-to-fix-it/272490/',
        ]

        self.favorite_urls = [
            'http://www.theatlantic.com/sexes/archive/2013/01/the-lonely-existence-of-mel-feit-mens-rights-advocate/267413/',
            'http://www.theatlantic.com/technology/archive/2013/01/women-in-combat-an-idea-whose-time-has-come-aided-by-technology/272483/'
        ]

        self.archive_urls = [
            'http://www.theatlantic.com/business/archive/2013/01/what-economics-can-and-cant-tell-us-about-the-legacy-of-legal-abortion/267459/',
            'http://www.theatlantic.com/business/archive/2013/01/5-ways-to-understand-just-how-absurd-spains-26-unemployment-rate-is/272502/'
        ]

        self.all_urls = self.urls + self.favorite_urls + self.archive_urls

        for url in self.urls:
            add_response = self.reader_client.add_bookmark(url)
            self.assertEqual(add_response.status, 202)

        for url in self.favorite_urls:
            add_response = self.reader_client.add_bookmark(url, favorite=True)
            self.assertEqual(add_response.status, 202)

        for url in self.archive_urls:
            add_response = self.reader_client.add_bookmark(url, archive=True)
            self.assertEqual(add_response.status, 202)

    def test_get_bookmarks(self):
        """
        Test getting all bookmarks
        """
        bm_response = self.reader_client.get_bookmarks()
        self.assertEqual(bm_response.status, 200)
        self.assertEqual(
            len(bm_response.content['bookmarks']), len(self.all_urls))

        # test favorite bookmarks
        bm_response = self.reader_client.get_bookmarks(favorite=True)
        self.assertEqual(bm_response.status, 200)
        self.assertEqual(
            len(bm_response.content['bookmarks']), len(self.favorite_urls))
        for bm in bm_response.content['bookmarks']:
            self.assertTrue(bm['article']['url'] in self.favorite_urls)

        # test archive bookmarks
        bm_response = self.reader_client.get_bookmarks(archive=True)
        self.assertEqual(bm_response.status, 200)
        self.assertEqual(
            len(bm_response.content['bookmarks']), len(self.archive_urls))
        for bm in bm_response.content['bookmarks']:
            self.assertTrue(bm['article']['url'] in self.archive_urls)

    def tearDown(self):
        """
        Remove all added bookmarks.
        """
        for bm in self.reader_client.get_bookmarks().content['bookmarks']:
            del_response = self.reader_client.delete_bookmark(bm['id'])
            self.assertEqual(del_response.status, 204)


class ParserClientTest(TestCase):
    """
    Test case for the Parser Client
    """
    def setUp(self):
        self.parser_client = ParserClient(PARSER_TOKEN)
        self.test_url = 'https://en.wikipedia.org/wiki/Mark_Twain'

    def test_generate_url(self):
        """
        Test the clients ability to generate urls to endpoints.
        """
        # test root resource
        expected_url = DEFAULT_PARSER_URL_TEMPLATE.format('')
        expected_url = '{0}?token={1}'.format(expected_url, PARSER_TOKEN)
        generated_url = self.parser_client._generate_url('')
        self.assertEqual(generated_url, expected_url)

        expected_url = DEFAULT_PARSER_URL_TEMPLATE.format('parser')
        params = {'url': 'http://www.beanis.biz/blog.html'}
        expected_url = '{0}?url=http%3A%2F%2Fwww.beanis.biz%2Fblog.html&token={1}'.format(
            expected_url, PARSER_TOKEN)

        generated_url = self.parser_client._generate_url(
            'parser', query_params=params)
        self.assertEqual(generated_url, expected_url)

    def test_get_root(self):
        """
        Test the client's ability to hit the root endpoint.
        """
        response = self.parser_client.get_root()

        expected_keys = set(['resources', ])
        self.assertEqual(set(response.content.keys()), expected_keys)

    def test_get_confidence(self):
        """
        Test the client's ability to hit the confidence endpoint.
        """
        # hit without an article_id or url. Should get an error.
        response = self.parser_client.get_confidence()
        self.assertEqual(response.status, 400)

        expected_keys = set(['url', 'confidence'])

        response = self.parser_client.get_confidence(url=self.test_url)
        self.assertEqual(response.status, 200)
        self.assertEqual(set(response.content.keys()), expected_keys)
        # confidence for wikipedia should be over .5
        self.assertTrue(response.content['confidence'] >= .5)

    def test_get_article_status(self):
        """
        Test the client's ability to hit the parser endpoint with a HEAD
        """
        # hit without an article_id or url. Should get an error.
        response = self.parser_client.get_confidence()
        self.assertEqual(response.status, 400)

        response = self.parser_client.get_article_status(url=self.test_url)
        self.assertEqual(response.status, 200)
        self.assertTrue(response.get('x-article-status') is not None)
        self.assertTrue(response.get('x-article-id') is not None)

    def test_get_article_content(self):
        """
        Test the client's ability to hit the parser endpoint with a GET
        """
        # test with incorrect params
        response = self.parser_client.get_article_content()
        self.assertEqual(response.status, 400)

        response = self.parser_client.get_article_content(url=self.test_url)
        self.assertEqual(response.status, 200)

        some_expected_keys = set(['content', 'domain', 'author', 'word_count',
            'title', 'total_pages'])
        self.assertTrue(
            some_expected_keys.issubset(set(response.content.keys())))

    def test_post_article_content(self):
        """
        Test the client's ability to hit the parser endpoint with a POST
        request.
        """
        # I'm sorry...
        content = """
        <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
        <html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Readability v1 Parser API</title><style type="text/css">
                            body {
                                font-family: sans-serif;
                                font: 0.8em/1.4 Arial, sans-serif;
                                margin: 2em 6em;
                                width: 65em;
                            }
                            pre {
                                font-family: Courier, monospace;
                                font-weight: 500;
                                font-size: 0.8em;
                                background-color: #eef;
                                padding: 1em;
                            }
                            .methods {
                                background-color: #e4e4e4;
                                margin-top: .4em;
                                padding: .6em;
                            }
                            .methods h4 {
                                border-bottom: 1px solid #fff;
                                padding: .1em 0;
                                margin-bottom: .4em;
                                color: #0b3c97;
                                font-size: 1.1em;
                            }
                            .methods h6 {
                                color: #666;
                                text-transform: lowercase;
                                margin: .6em 0 .3em;
                            }
                            .resource {
                                margin-bottom: 2em;
                                margin-top: .4em;
                            }
                            .resource h3 {
                                margin-bottom: .4em;
                                font-size: 1.4em;
                                color: #ff5700;
                            }
                            h1 {
                                font-size: 2.5em;
                            }
                            h2 {
                                border-bottom: 1px solid black;
                                margin-top: 1em;
                                color: #666;
                                margin-bottom: 0.5em;
                                font-size: 2em;
                            }
                            h3 {
                                font-size: 1.75em;
                                margin: 0.6em 0;
                            }
                            h4 {
                                color: #666;
                                margin: 0;
                                padding: 0.3em 0;
                                border-bottom: 2px solid white;
                            }
                            h6 {
                                font-size: 1.1em;
                                color: #99a;
                                margin: 0.5em 0em 0.25em 0em;
                            }
                            dd {
                                margin-left: 1em;
                            }
                            tt {
                                font-size: 1.2em;
                            }
                            table {
                                margin-bottom: 0.5em;
                                width: 100%;
                                border-collapse: collapse;
                            }
                            th {
                                text-align: left;
                                font-weight: normal;
                                color: black;
                                border-bottom: 1px solid black;
                                padding: 3px 6px;
                            }
                            td {
                                padding: 3px 6px;
                                vertical-align: top;
                                background-color: f6f6ff;
                                font-size: 0.85em;
                            }
                            td p {
                                margin: 0px;
                            }
                            ul {
                                padding-left: 1.75em;
                            }
                            p + ul, p + ol, p + dl {
                                margin-top: 0em;
                            }
                            .optional {
                                font-weight: normal;
                                opacity: 0.75;
                            }
                        </style><link href="prettify/prettify.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="prettify/prettify.js"></script></head><body onload="prettyPrint()"><h1>Readability v1 Parser API</h1>
                <section>
                    <h2 id="authentication">Authentication</h2>
                    <p>
                        Requests to the Parser API are not signed like an OAuth
                        request.  The Parser token is simply passed as a POST or GET
                        parameter depending on the request type. Be careful not to
                        reveal this token, requests directly to the Parser API should
                        not be made on the client device but rather proxied to keep the
                        API token secure.
                    </p>
                </section>

                <section>
                    <h2 id="quick-start">Quick Start</h2>
                    <p class="section-intro">
                                Here's how to pull an article's content from the Readability Parser API:
                    </p>
                    <h4>Request</h4>
                    <pre>GET /api/content/v1/parser?url=http://blog.readability.com/2011/02/step-up-be-heard-readability-ideas/&amp;token=1b830931777ac7c2ac954e9f0d67df437175e66e</pre>
                    <h4>Response</h4>
                    <pre>
        HTTP/1.0 200 OK
        {
            "content" &lt;div class=\"article-text\"&gt;\n&lt;p&gt;I'm idling outside Diamante's, [snip] ...&lt;/p&gt;&lt;/div&gt;",
            "domain": "www.gq.com",
            "author": "Rafi Kohan",
            "url": "http://www.gq.com/sports/profiles/201202/david-diamante-interview-cigar-lounge-brooklyn-new-jersey-nets?currentPage=all",
            "short_url": "http://rdd.me/g3jcb1sr",
            "title": "Blowing Smoke with Boxing's Big Voice",
            "excerpt": "I'm idling outside Diamante's, a cigar lounge in Fort Greene, waiting for David Diamante, and soon I smell him coming. It's late January but warm. A motorcycle growls down the Brooklyn side street,&amp;hellip;",
            "direction": "ltr",
            "word_count": 2892,
            "total_pages": 1,
            "date_published": null,
            "dek": "Announcer &lt;strong&gt;David Diamante&lt;/strong&gt;, the new voice of the New Jersey (soon Brooklyn) Nets, has been calling boxing matches for years. On the side, he owns a cigar lounge in the heart of Brooklyn. We talk with Diamante about his new gig and the fine art of cigars",
            "lead_image_url": "http://www.gq.com/images/entertainment/2012/02/david-diamante/diamante-628.jpg",
            "next_page_id": null,
            "rendered_pages": 1
        }
        </pre>
                </section>

                <section>
                    <h2 id="data-formats">Data Formats</h2>
                    <p>
                        All requests are, by default, provided as JSON. You may also pass "?format=xml" in the URL to convert this into XML data to be consumed.
                    </p>
                </section>

            <h3>Resources, Representations &amp; Errors</h3><ul><li><a href="#resources">Resources</a><ul><li><a href="#idp3728">https://readability.com/api/content/v1/</a></li><li><a href="#idp4080">https://readability.com/api/content/v1/parser</a></li><li><a href="#idp39744">https://readability.com/api/content/v1/confidence</a></li></ul></li><li><a href="#representations">Representations</a><ul><li><a href="#https://readability.com/api/content/v1#rootRepresentation">Example root representation. (application/json)</a></li><li><a href="#https://readability.com/api/content/v1#articleRepresentation">Example article representation. (application/json)</a></li><li><a href="#https://readability.com/api/content/v1#confidenceRepresentation">Example confidence representation. (application/json)</a></li><li><a href="#https://readability.com/api/content/v1#confidenceRepresentationJsonp">Example confidence representation as jsonp. (application/json)</a></li></ul></li><li><a href="#faults">Errors</a><ul><li><a href="#https://readability.com/api/content/v1#error_400">400 Bad Request (application/json)</a></li><li><a href="#https://readability.com/api/content/v1#error_401">401 Authorization Required (application/json)</a></li><li><a href="#https://readability.com/api/content/v1#error_500">500 Internal Server Error (application/json)</a></li><li><a href="#https://readability.com/api/content/v1#error_404">404 Not Found (application/json)</a></li></ul></li></ul><h2 id="resources">Resources</h2><div class="resource"><h3 id="idp3728">/</h3><h6>Methods</h6><div class="methods"><div class="method"><h4 id="idp5008">GET</h4>
                            Retrieve the base API URI - information about subresources.
                        <h6>request header parameters</h6><table><tr><th style="width: 25%">parameter</th><th style="width: 20%">value</th><th>description</th></tr><tr><td><p><strong>Authorization</strong></p></td><td><p><em><a href="" title=""></a></em><small> (required)</small></p></td><td></td></tr></table><p><em>available response representations:</em></p><ul><li><a href="#https://readability.com/api/content/v1#rootRepresentation">Example root representation. (application/json)</a></li></ul></div></div></div><div class="resource"><h3 id="idp4080">/parser?token<span class="optional">&amp;url</span><span class="optional">&amp;id</span><span class="optional">&amp;max_pages</span></h3><h6>Methods</h6><div class="methods"><div class="method"><h4 id="idp36384">GET</h4>
                            Parse an article
                        <h6>request query parameters</h6><table><tr><th style="width: 25%">parameter</th><th style="width: 20%">value</th><th>description</th></tr><tr><td><p><strong>token</strong></p></td><td><p><em><a href="http://www.w3.org/TR/xmlschema-2/#string">string</a></em><small> (required)</small></p></td><td></td></tr><tr><td><p><strong>url</strong></p></td><td><p><em><a href="http://www.w3.org/TR/xmlschema-2/#string">string</a></em></p></td><td>The URL of an article to return the content for.</td></tr><tr><td><p><strong>id</strong></p></td><td><p><em><a href="http://www.w3.org/TR/xmlschema-2/#string">string</a></em></p></td><td>The ID of an article to return the content for.</td></tr><tr><td><p><strong>max_pages</strong></p></td><td><p><em><a href="http://www.w3.org/TR/xmlschema-2/#integer">integer</a></em></p></td><td>The maximum number of pages to parse and combine. Default is 25.</td></tr></table><p><em>available response representations:</em></p><ul><li><a href="#https://readability.com/api/content/v1#articleRepresentation">Example article representation. (application/json)</a></li></ul><p><em>potential faults:</em></p><ul><li><a href="#https://readability.com/api/content/v1#error_400">400 Bad Request (application/json)</a></li><li><a href="#https://readability.com/api/content/v1#error_401">401 Authorization Required (application/json)</a></li><li><a href="#https://readability.com/api/content/v1#error_500">500 Internal Server Error (application/json)</a></li></ul></div><div class="method"><h4 id="idp63552">HEAD</h4>
                            <p>
                                Retrieve the Content Status of an article. This is useful if you want to save yourself from POSTing a large html document. You can do a HEAD request on the resource, and check for the status of the article in the X-Article-Status header. <strong>Additionally, if we've never seen the article before, we'll return a 404, which also means you should POST.</strong>
                            </p>
                        <h6>request query parameters</h6><table><tr><th style="width: 25%">parameter</th><th style="width: 20%">value</th><th>description</th></tr><tr><td><p><strong>token</strong></p></td><td><p><em><a href="http://www.w3.org/TR/xmlschema-2/#string">string</a></em><small> (required)</small></p></td><td></td></tr><tr><td><p><strong>url</strong></p></td><td><p><em><a href="http://www.w3.org/TR/xmlschema-2/#string">string</a></em></p></td><td>The URL of an article to check.</td></tr><tr><td><p><strong>id</strong></p></td><td><p><em><a href="http://www.w3.org/TR/xmlschema-2/#string">string</a></em></p></td><td>The ID of an article to check.</td></tr></table><h6>response header parameters</h6><table><tr><th style="width: 25%">parameter</th><th style="width: 20%">value</th><th>description</th></tr><tr><td><p><strong>X-Article-Id</strong></p></td><td><p><em><a href="http://www.w3.org/TR/xmlschema-2/#string">string</a></em></p></td><td>
                                <p>The ID of the article within Readablity.</p>
                            </td></tr><tr><td><p><strong>X-Article-Status</strong></p></td><td><p><em><a href="http://www.w3.org/TR/xmlschema-2/#string">string</a></em></p></td><td>
                                <p>The status of the content in Readability. One of:</p>
                                <dl>
                                <dt>INVALID</dt>
                                <dd>We were unable to parse this URL for some reason. <em>Recommendation: Fail</em></dd>
                                <dt>UNRETRIEVED</dt>
                                <dd>We know of this article, but have not yet retrieved its content, or the cache has expired. <em>Recommendation: POST content to us</em></dd>
                                <dt>PROVIDED_BY_USER</dt>
                                <dd>We have retrieved the content for this URL from at least one user. <em>Recommendation: POST content to us</em></dd>
                                <dt>VALIDATED_BY_USERS</dt>
                                <dd>We have retrieved the content for this URL from multiple users, and have validated it. <em>Recommendation: GET the content from us.</em></dd>
                                <dt>FETCHED</dt>
                                <dd>We fetched the content for this URL manually, and it has been cached. <em>Recommendation:GET the content from us.</em></dd>
                                </dl>
                            </td></tr></table><p><em>potential faults:</em></p><ul><li><a href="#https://readability.com/api/content/v1#error_400">400 Bad Request (application/json)</a></li><li><a href="#https://readability.com/api/content/v1#error_401">401 Authorization Required (application/json)</a></li><li><a href="#https://readability.com/api/content/v1#error_404">404 Not Found (application/json)</a></li><li><a href="#https://readability.com/api/content/v1#error_500">500 Internal Server Error (application/json)</a></li></ul></div></div></div><div class="resource"><h3 id="idp39744">/confidence?url<span class="optional">&amp;callback</span></h3><h6>Methods</h6><div class="methods"><div class="method"><h4 id="idp89296">GET</h4>Detect the confidence with which Readability could parse a given URL. Does not require a token.<h6>request query parameters</h6><table><tr><th style="width: 25%">parameter</th><th style="width: 20%">value</th><th>description</th></tr><tr><td><p><strong>url</strong></p></td><td><p><em><a href="http://www.w3.org/TR/xmlschema-2/#string">string</a></em><small> (required)</small></p></td><td>The URL of an article to return the confidence for.</td></tr><tr><td><p><strong>callback</strong></p></td><td><p><em><a href="http://www.w3.org/TR/xmlschema-2/#string">string</a></em></p></td><td>The jsonp callback function name.</td></tr></table><p><em>available response representations:</em></p><ul><li><a href="#https://readability.com/api/content/v1#confidenceRepresentation">Example confidence representation. (application/json)</a></li><li><a href="#https://readability.com/api/content/v1#confidenceRepresentationJsonp">Example confidence representation as jsonp. (application/json)</a></li></ul><p><em>potential faults:</em></p><ul><li><a href="#https://readability.com/api/content/v1#error_400">400 Bad Request (application/json)</a></li><li><a href="#https://readability.com/api/content/v1#error_500">500 Internal Server Error (application/json)</a></li></ul></div></div></div><h2 id="representations">Representations</h2><h3 id="https://readability.com/api/content/v1#rootRepresentation">Example root representation. (application/json)</h3>
                    <pre xmlns="http://research.sun.com/wadl/2006/10" class="prettyprint">
        {
            "resources": {
                "parser": {
                    "description": "The Content Parser Resource",
                    "href": "/api/content/v1/parser"
                }
            }
        }
                    </pre>
                <h3 id="https://readability.com/api/content/v1#articleRepresentation">Example article representation. (application/json)</h3>
                    <pre xmlns="http://research.sun.com/wadl/2006/10" class="prettyprint">
        {
            "content" &lt;div class=\"article-text\"&gt;\n&lt;p&gt;I'm idling outside Diamante's, [snip] ...&lt;/p&gt;&lt;/div&gt;",
            "domain": "www.gq.com",
            "author": "Rafi Kohan",
            "url": "http://www.gq.com/sports/profiles/201202/david-diamante-interview-cigar-lounge-brooklyn-new-jersey-nets?currentPage=all",
            "short_url": "http://rdd.me/g3jcb1sr",
            "title": "Blowing Smoke with Boxing's Big Voice",
            "excerpt": "I'm idling outside Diamante's, a cigar lounge in Fort Greene, waiting for David Diamante, and soon I smell him coming. It's late January but warm. A motorcycle growls down the Brooklyn side street,&amp;hellip;",
            "direction": "ltr",
            "word_count": 2892,
            "total_pages": 1,
            "date_published": null,
            "dek": "Announcer &lt;strong&gt;David Diamante&lt;/strong&gt;, the new voice of the New Jersey (soon Brooklyn) Nets, has been calling boxing matches for years. On the side, he owns a cigar lounge in the heart of Brooklyn. We talk with Diamante about his new gig and the fine art of cigars",
            "lead_image_url": "http://www.gq.com/images/entertainment/2012/02/david-diamante/diamante-628.jpg",
            "next_page_id": null,
            "rendered_pages": 1
        }

        </pre>
                <h3 id="https://readability.com/api/content/v1#confidenceRepresentation">Example confidence representation. (application/json)</h3>
                    <pre xmlns="http://research.sun.com/wadl/2006/10" class="prettyprint">
        {
            "url": "http://www.gq.com/article/12",
            "confidence": .7
        }

        </pre>
                <h3 id="https://readability.com/api/content/v1#confidenceRepresentationJsonp">Example confidence representation as jsonp. (application/json)</h3>
                    <pre xmlns="http://research.sun.com/wadl/2006/10" class="prettyprint">
        callback({
            "url": "http://www.gq.com/article/12",
            "confidence": .7
        });

        </pre>
                <h2 id="faults">Errors</h2><h3 id="https://readability.com/api/content/v1#error_400">400 Bad Request (application/json)</h3>
                    The server could not understand your request. Verify that request parameters (and content, if any) are valid.
                <h3 id="https://readability.com/api/content/v1#error_401">401 Authorization Required (application/json)</h3>
                    <p>
                        Authentication failed or was not provided. Verify that you have sent valid ixDirectory credentials via HTTP Basic.
                    </p>
                    <p>A 'Www-Authenticate' challenge header will be sent with this type of error response.</p>
                <h3 id="https://readability.com/api/content/v1#error_500">500 Internal Server Error (application/json)</h3>
                    An unknown error has occurred.
                <h3 id="https://readability.com/api/content/v1#error_404">404 Not Found (application/json)</h3>
                    The resource that you requested does not exist.
                </body></html>
        """
        url = 'http://readability.com/developers/api/parser#https://readability.com/api/content/v1#test_suite'
        response = self.parser_client.post_article_content(content, url)
        self.assertEqual(response.status, 200)
        # should have gotten back content that is shorter than original
        self.assertTrue(len(content) > len(response.content['content']))

########NEW FILE########
__FILENAME__ = test_utils
# -*- coding: utf-8 -*-

from datetime import datetime
from unittest import TestCase

from readability.utils import \
    cast_datetime_filter, cast_integer_filter, filter_args_to_dict


class CastDatetimeFilterTestCase(TestCase):
    """
    Tests for the `cast_datetime_filter` function.
    """
    def test_int(self):
        """
        Pass an int. Should raise a `ValueError`
        """
        with self.assertRaises(ValueError):
            cast_datetime_filter(1)

    def test_non_iso_string(self):
        """
        Pass a string that's not in ISO format. Should get a string back
        that's in ISO format.
        """
        date_string = '08-03-2010'
        expected_iso = cast_datetime_filter(date_string)
        self.assertEqual(expected_iso, '2010-08-03T00:00:00')

    def test_datetime_object(self):
        """
        Pass a datetime object. Should get a string back in ISO format.
        """
        now = datetime.now()
        expected_output = now.isoformat()
        actual_output = cast_datetime_filter(now)
        self.assertEqual(actual_output, expected_output)


class CastIntegerFilter(TestCase):
    """
    Test for the `cast_integer_filter` function.
    """
    def test_int(self):
        """
        Pass an int. Should get it back.
        """
        value_to_cast = 1
        output = cast_integer_filter(value_to_cast)
        self.assertEqual(value_to_cast, output)

    def test_false(self):
        """
        Pass a boolean False. Should get a 0 back.
        """
        output = cast_integer_filter(False)
        expected_output = 0
        self.assertEqual(output, expected_output)

    def test_true(self):
        """
        Pass a boolean True. Should get a 1 back.
        """
        output = cast_integer_filter(True)
        expected_output = 1
        self.assertEqual(output, expected_output)

    def test_numeric_string(self):
        """
        Pass a numeric string. Should get the integer version back.
        """
        numeric_string = '123'
        expected_output = 123
        output = cast_integer_filter(numeric_string)
        self.assertEqual(expected_output, output)


class FilterArgsToDictTestCase(TestCase):
    """
    Test for the `filter_args_to_dict` function.
    """
    def test_all_bad_filter_keys(self):
        """
        Pass a dict who's keys are not in the acceptable filter list.

        Should get an empty dict back.
        """
        filters = {
            'date_deleted': '08-08-2010',
            'date_updated': '08-08-2011',
            'liked': 1
        }

        acceptable_filters = ['favorite', 'archive']
        expected_empty = filter_args_to_dict(filters, acceptable_filters)
        self.assertEqual(expected_empty, {})

    def test_some_bad_filter_keys(self):
        """
        Pass a mixture of good and bad filter keys.
        """
        filters = {
            'favorite': True,
            'archive': False
        }
        bad_filters = {
            'date_deleted': '08-08-2010',
            'date_updated': '08-08-2011',
            'liked': 1
        }
        acceptable_filter_keys = filters.keys()

        # add bad filters to filters dict
        filters.update(bad_filters)
        filter_dict = filter_args_to_dict(filters, acceptable_filter_keys)
        self.assertEqual(set(filter_dict.keys()), set(acceptable_filter_keys))

    def test_casting_of_integer_filters(self):
        """
        Pass keys that correspond to integer filters.
        """
        filters = {
            'favorite': True,
            'archive': False
        }
        acceptable_filter_keys = filters.keys()
        filter_dict = filter_args_to_dict(filters, acceptable_filter_keys)
        self.assertEqual(set(filter_dict.keys()), set(acceptable_filter_keys))
        self.assertEqual(filter_dict['favorite'], 1)
        self.assertEqual(filter_dict['archive'], 0)

    def test_casting_of_datetime_filters(self):
        """
        Pass keys that correspond to datetime filters.
        """
        now = datetime.now()
        filters = {
            'archived_since': '08-08-2010',
            'favorited_since': now
        }
        acceptable_filter_keys = filters.keys()
        filter_dict = filter_args_to_dict(filters, acceptable_filter_keys)
        self.assertEqual(set(filter_dict.keys()), set(acceptable_filter_keys))
        self.assertEqual(filter_dict['archived_since'], '2010-08-08T00:00:00')
        self.assertEqual(filter_dict['favorited_since'], now.isoformat())

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-

"""
readability.utils
~~~~~~~~~~~~~~~~~

This module provides various utils to the rest of the package.

"""

import logging

from datetime import datetime

from dateutil.parser import parse as parse_datetime


logger = logging.getLogger(__name__)


# map of filter names to a data type. This is used to map names to a
# casting function when needed.
filter_type_map = {
    'added_since': 'datetime',
    'added_until': 'datetime',
    'archive': 'int',
    'archived_since': 'datetime',
    'archived_until': 'datetime',
    'exclude_accessibility': 'string',
    'favorite': 'int',
    'favorited_since': 'datetime',
    'favorited_until': 'datetime',
    'domain': 'string',
    'only_delete': 'int',
    'opened_since': 'datetime',
    'opened_until': 'datetime',
    'order': 'string',
    'page': 'int',
    'per_page': 'int',
    'tags': 'string',
    'updated_since': 'datetime',
    'updated_until': 'datetime',
}


def cast_datetime_filter(value):
    """Cast a datetime filter value.

    :param value: string representation of a value that needs to be casted to
        a `datetime` object.

    """
    if isinstance(value, basestring):
        dtime = parse_datetime(value)

    elif isinstance(value, datetime):
        dtime = value
    else:
        raise ValueError('Received value of type {0}'.format(type(value)))

    return dtime.isoformat()


def cast_integer_filter(value):
    """Cast an integer filter value.

    Theses are usually booleans in Python but they need to be sent as
    1s and 0s to the API.

    :param value: boolean value that needs to be casted to an int
    """
    return int(value)


def filter_args_to_dict(filter_dict, accepted_filter_keys=[]):
    """Cast and validate filter args.

    :param filter_dict: Filter kwargs
    :param accepted_filter_keys: List of keys that are acceptable to use.

    """
    out_dict = {}
    for k, v in filter_dict.items():
        # make sure that the filter k is acceptable
        # and that there is a value associated with the key
        if k not in accepted_filter_keys or v is None:
            logger.debug(
                'Filter was not in accepted_filter_keys or value is None.')
            # skip it
            continue
        filter_type = filter_type_map.get(k, None)

        if filter_type is None:
            logger.debug('Filter key not foud in map.')
            # hmm, this was an acceptable filter type but not in the map...
            # Going to skip it.
            continue

        # map of casting funcitons to filter types
        filter_cast_map = {
            'int': cast_integer_filter,
            'datetime': cast_datetime_filter
        }
        cast_function = filter_cast_map.get(filter_type, None)

        # if we get a cast function, call it with v. If not, just use v.
        if cast_function:
            out_value = cast_function(v)
        else:
            out_value = v
        out_dict[k] = out_value

    return out_dict

########NEW FILE########
