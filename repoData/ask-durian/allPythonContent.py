__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
import sys
import os

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
sys.path.insert(0, "../")
import durian

from django.conf import settings
if not settings.configured:
    settings.configure()

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings.
# They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'durian'
copyright = u'2009, Opera Softare (WebTeam)'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = ".".join(map(str, durian.VERSION[0:2]))
# The full version, including alpha/beta/rc tags.
release = durian.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['.build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'trac'

#html_translator_class = "djangodocs.DjangoHTMLTranslator"


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
#html_style = 'agogo.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['.static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_use_modindex = True

# If false, no index is generated.
html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'duriandoc'


# Options for LaTeX output
# ------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class
# [howto/manual]).
latex_documents = [
  ('index', 'durian.tex', ur'durian Documentation',
   ur'Ask Solem', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

html_theme = "nature"
html_theme_path = ["_theme"]

########NEW FILE########
__FILENAME__ = applyxrefs
"""Adds xref targets to the top of files."""

import sys
import os

testing = False

DONT_TOUCH = (
        './index.txt',
        )


def target_name(fn):
    if fn.endswith('.txt'):
        fn = fn[:-4]
    return '_' + fn.lstrip('./').replace('/', '-')


def process_file(fn, lines):
    lines.insert(0, '\n')
    lines.insert(0, '.. %s:\n' % target_name(fn))
    try:
        f = open(fn, 'w')
    except IOError:
        print("Can't open %s for writing. Not touching it." % fn)
        return
    try:
        f.writelines(lines)
    except IOError:
        print("Can't write to %s. Not touching it." % fn)
    finally:
        f.close()


def has_target(fn):
    try:
        f = open(fn, 'r')
    except IOError:
        print("Can't open %s. Not touching it." % fn)
        return (True, None)
    readok = True
    try:
        lines = f.readlines()
    except IOError:
        print("Can't read %s. Not touching it." % fn)
        readok = False
    finally:
        f.close()
        if not readok:
            return (True, None)

    #print fn, len(lines)
    if len(lines) < 1:
        print("Not touching empty file %s." % fn)
        return (True, None)
    if lines[0].startswith('.. _'):
        return (True, None)
    return (False, lines)


def main(argv=None):
    if argv is None:
        argv = sys.argv

    if len(argv) == 1:
        argv.extend('.')

    files = []
    for root in argv[1:]:
        for (dirpath, dirnames, filenames) in os.walk(root):
            files.extend([(dirpath, f) for f in filenames])
    files.sort()
    files = [os.path.join(p, fn) for p, fn in files if fn.endswith('.txt')]
    #print files

    for fn in files:
        if fn in DONT_TOUCH:
            print("Skipping blacklisted file %s." % fn)
            continue

        target_found, lines = has_target(fn)
        if not target_found:
            if testing:
                print '%s: %s' % (fn, lines[0]),
            else:
                print "Adding xref to %s" % fn
                process_file(fn, lines)
        else:
            print "Skipping %s: already has a xref" % fn

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = literals_to_xrefs
"""
Runs through a reST file looking for old-style literals, and helps replace them
with new-style references.
"""

import re
import sys
import shelve

refre = re.compile(r'``([^`\s]+?)``')

ROLES = (
    'attr',
    'class',
    "djadmin",
    'data',
    'exc',
    'file',
    'func',
    'lookup',
    'meth',
    'mod',
    "djadminopt",
    "ref",
    "setting",
    "term",
    "tfilter",
    "ttag",

    # special
    "skip",
)

ALWAYS_SKIP = [
    "NULL",
    "True",
    "False",
]


def fixliterals(fname):
    data = open(fname).read()

    last = 0
    new = []
    storage = shelve.open("/tmp/literals_to_xref.shelve")
    lastvalues = storage.get("lastvalues", {})

    for m in refre.finditer(data):

        new.append(data[last:m.start()])
        last = m.end()

        line_start = data.rfind("\n", 0, m.start())
        line_end = data.find("\n", m.end())
        prev_start = data.rfind("\n", 0, line_start)
        next_end = data.find("\n", line_end + 1)

        # Skip always-skip stuff
        if m.group(1) in ALWAYS_SKIP:
            new.append(m.group(0))
            continue

        # skip when the next line is a title
        next_line = data[m.end():next_end].strip()
        if next_line[0] in "!-/:-@[-`{-~" and \
                all(c == next_line[0] for c in next_line):
            new.append(m.group(0))
            continue

        sys.stdout.write("\n"+"-"*80+"\n")
        sys.stdout.write(data[prev_start+1:m.start()])
        sys.stdout.write(colorize(m.group(0), fg="red"))
        sys.stdout.write(data[m.end():next_end])
        sys.stdout.write("\n\n")

        replace_type = None
        while replace_type is None:
            replace_type = raw_input(
                colorize("Replace role: ", fg="yellow")).strip().lower()
            if replace_type and replace_type not in ROLES:
                replace_type = None

        if replace_type == "":
            new.append(m.group(0))
            continue

        if replace_type == "skip":
            new.append(m.group(0))
            ALWAYS_SKIP.append(m.group(1))
            continue

        default = lastvalues.get(m.group(1), m.group(1))
        if default.endswith("()") and \
                replace_type in ("class", "func", "meth"):
            default = default[:-2]
        replace_value = raw_input(
            colorize("Text <target> [", fg="yellow") + default + \
                    colorize("]: ", fg="yellow")).strip()
        if not replace_value:
            replace_value = default
        new.append(":%s:`%s`" % (replace_type, replace_value))
        lastvalues[m.group(1)] = replace_value

    new.append(data[last:])
    open(fname, "w").write("".join(new))

    storage["lastvalues"] = lastvalues
    storage.close()


def colorize(text='', opts=(), **kwargs):
    """
    Returns your text, enclosed in ANSI graphics codes.

    Depends on the keyword arguments 'fg' and 'bg', and the contents of
    the opts tuple/list.

    Returns the RESET code if no parameters are given.

    Valid colors:
        'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'

    Valid options:
        'bold'
        'underscore'
        'blink'
        'reverse'
        'conceal'
        'noreset' - string will not be auto-terminated with the RESET code

    Examples:
        colorize('hello', fg='red', bg='blue', opts=('blink',))
        colorize()
        colorize('goodbye', opts=('underscore',))
        print colorize('first line', fg='red', opts=('noreset',))
        print 'this should be red too'
        print colorize('and so should this')
        print 'this should not be red'
    """
    color_names = ('black', 'red', 'green', 'yellow',
                   'blue', 'magenta', 'cyan', 'white')
    foreground = dict([(color_names[x], '3%s' % x) for x in range(8)])
    background = dict([(color_names[x], '4%s' % x) for x in range(8)])

    RESET = '0'
    opt_dict = {'bold': '1',
                'underscore': '4',
                'blink': '5',
                'reverse': '7',
                'conceal': '8'}

    text = str(text)
    code_list = []
    if text == '' and len(opts) == 1 and opts[0] == 'reset':
        return '\x1b[%sm' % RESET
    for k, v in kwargs.iteritems():
        if k == 'fg':
            code_list.append(foreground[v])
        elif k == 'bg':
            code_list.append(background[v])
    for o in opts:
        if o in opt_dict:
            code_list.append(opt_dict[o])
    if 'noreset' not in opts:
        text = text + '\x1b[%sm' % RESET
    return ('\x1b[%sm' % ';'.join(code_list)) + text

if __name__ == '__main__':
    try:
        fixliterals(sys.argv[1])
    except (KeyboardInterrupt, SystemExit):
        print

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from durian.models import Listener

admin.site.register(Listener)

########NEW FILE########
__FILENAME__ = event
from durian.models import Listener
from celery.utils import get_full_cls_name, gen_unique_id
from durian.tasks import WebhookSignal
from durian.forms import HookConfigForm, create_match_forms
from durian.match.strategy import deepmatch
from durian.match import mtuplelist_to_matchdict
from functools import partial as curry


class Hook(object):
    """A Web Hook Event.

    :keyword name: See :attr:`name`.
    :keyword provides_args: See :attr:`provides_args`.
    :keyword config_form: See :attr:`config_form`.
    :keyword timeout: See :attr:`timeout`.
    :keyword async: See :attr:`async`.
    :keyword retry: See :attr:`retry`.
    :keyword max_retries: See :attr:`max_retries`.
    :keyword fail_silently: See :attr:`fail_silently`.
    :keyword task_cls: See :attr:`task_cls`.
    :keyword match_forms: See :attr:`match_forms`

    .. attribute:: name

        The name of the hook.

        If not provided this will be automatically generated using the class
        module and name, if you want to use this feature you can't use
        relative imports.

    .. attribute:: provides_args

        The list of arguments the event provides. This is the standard
        list of arguments you are going to pass on to :meth:`send`, used to
        generate the filter events form (:attr:`match_forms`).

    .. attribute:: config_form

        A Django form to save configuration for listeners attaching to this
        form. The default form is :class:`durian.forms.HookConfigForm`, which
        has the URL field.

    .. attribute:: timeout

        The timeout in seconds before we give up trying to dispatch the
        event to a listener URL.

    .. attribute:: async

        If ``True``, signals are dispatched to celery workers via a mesage.
        Otherwise dispatch happens locally (not a good idea in production).

    .. attribute:: retry

        Retry the task if it fails.

    .. attribute:: max_retries

        Maximum number of retries before we give up.

    .. attribute:: fail_silently

        Fail silently if the dispatch gives an HTTP error.

    .. attribute:: task_cls

        The :class:`celery.task.base.Task` class to use for dispatching
        the event.

    .. attribute:: match_forms

        A list of forms to create an event filter. This is automatically
        generated based on the :attr:`provides_args` attribute.

    """

    name = None
    verbose_name = None
    task_cls = WebhookSignal
    timeout = 4
    async = True
    retry = False
    max_retries = 3
    fail_silently = False
    config_form = HookConfigForm
    provides_args = set()
    match_forms = None

    def __init__(self, name=None, verbose_name=None, task_cls=None,
            timeout=None, async=None, retry=None, max_retries=None,
            fail_silently=False, config_form=None, provides_args=None,
            match_forms=None, **kwargs):
        self.name = name or self.name or get_full_cls_name(self.__class__)
        self.verbose_name = verbose_name or self.verbose_name or self.name
        self.task_cls = task_cls or self.task_cls
        if timeout is not None:
            self.timeout = timeout
        if async is not None:
            self.async = async
        if retry is not None:
            self.retry = retry
        if max_retries is not None:
            self.max_retries = max_retries
        if fail_silently is not None:
            self.fail_silently = fail_silently
        self.provides_args = set(provides_args) or self.provides_args
        self.config_form = config_form or self.config_form
        form_name = "%sConfigForm" % self.name.capitalize()
        self.match_forms = match_forms or self.match_forms or \
                            create_match_forms(form_name, self.provides_args)

    def send(self, sender, **payload):
        """Send signal and dispatch to all listeners.

        :param sender: The sender of the signal. Either a specific object
            or ``None``.

        :param payload: The data to pass on to listeners. Usually the keys
            described in :attr:`provides_args` and any additional keys you'd
            want to provide.

        """
        payload = self.prepare_payload(sender, payload)
        apply_ = curry(self._send_signal, sender, payload)
        return map(apply_, self.get_listeners(sender, payload))

    def _send_signal(self, sender, payload, target):
        applier = self.get_applier()
        return applier(args=[target.url, payload], kwargs=self.task_keywords)

    def event_filter(self, sender, payload, match):
        """How we filter events.

        :param sender: The sender of the signal.

        :param payload: The signal data.

        :param match: The match dictionary, or ``None``.

        """
        if not match:
            return True
        return deepmatch(match, payload)

    def get_match_forms(self, **kwargs):
        """Initialize the match forms with data recived by a request.

        :returns: A list of instantiated match forms.

        """
        return [match_form(**kwargs)
                    for match_form in self.match_forms.values()]

    def apply_match_forms(self, data):
        """With data recieved by request, convert to a list of match
        tuples."""
        mtuplelist = [match_form(data).field_to_mtuple()
                         for match_form in self.match_forms.values()]
        return mtuplelist_to_matchdict(mtuplelist)

    def get_listeners(self, sender, payload):
        """Get a list of all the listeners who wants this signal."""
        possible_targets = Listener.objects.filter(hook=self.name)
        return [target for target in possible_targets
                    if self.event_filter(sender, payload, target.match)]

    def get_applier(self, async=None):
        """Get the current apply method. Asynchronous or synchronous."""
        async = async or self.async
        method = "apply_async" if async else "apply"
        sender = getattr(self.task_cls, method)
        return sender

    def prepare_payload(self, sender, payload):
        """Prepare the payload for dispatching.

        You can add any additional formatting of the payload here.

        """
        return payload

    def add_listener_by_form(self, form, match=None):
        """Add listener with an instantiated :attr:`config_form`.

        :param form: An instance of :attr:`config_form`.
        :param match: Optional event filter match dict.

        """
        if not hasattr(form, "cleaned_data"):
            form.is_valid()
        config = dict(form.cleaned_data)
        url = config.pop("url")
        return Listener.objects.create(hook=self.name, url=url,
                                       match=match, config=config)

    def add_listener(self, url, match={}, **config):
        """Add listener for this signal.

        :param url: The url the listener is listening on.
        :keyword match: The even filter match dict.
        :keyword \*\*config: Hook specific listener configuration.

        """
        return Listener.objects.create(hook=self, url=url, match=match,
                                       **dict(config))

    def listener(self, form):
        """Create a new listener."""
        return IntermediateListener(self, form)

    @property
    def task_keywords(self):
        """The keyword arguments sent to the celery task."""
        return {"retry": self.retry,
                "max_retries": self.max_retries,
                "fail_silently": self.fail_silently,
                "timeout": self.timeout}


class SignalHook(Hook):
    """Hook attached to a Django signal."""
    signal = None
    _dispatch_uid = None

    def __init__(self, signal=None, **kwargs):
        self.signal = signal

        # Signal receivers must have a unique id, by default
        # they're generated by the reciver name and the sender,
        # but since it's possible to have different recieves for the
        # same instance, we need to generate our own unique id.
        if not self.__class__._dispatch_uid:
            self.__class__._dispatch_uid = gen_unique_id()

        super(SignalHook, self).__init__(**kwargs)

    def connect(self, sender):
        self.signal.connect(self.send, sender=sender,
                            dispatch_uid=self.__class__._dispatch_uid)

    def disconnect(self, sender):
        self.signal.disconnect(self.send, sender=sender,
                               dispatch_uid=self.__class__._dispatch_uid)


class ModelHook(SignalHook):
    """
        >>> from django.db import signals
        >>> from django.contrib.auth.models import User

        >>> hook = ModelHook(User, signals.post_save,
        ...                  name="user-post-save",
        ...                  provides_args=["username", "is_admin"])
        >>> joe = User.objects.get(username="joe")
        >>> joe.is_admin = True
        >>> joe.save()

    """
    model = None

    def __init__(self, model=None, **kwargs):
        super(ModelHook, self).__init__(**kwargs)
        self.model = model or self.model
        if not self.model:
            raise NotImplementedError("ModelHook requires a model.")
        if self.signal:
            self.connect()
        if not self.provides_args:
            self.provides_args = self.get_model_default_fields()

    def get_model_default_fields(self):
        return [field.name
                    for field in self.model._meta.fields
                        if field.name != self.model._meta.pk.name]

    def prepare_payload(self, sender, payload):
        instance = payload.pop("instance")
        payload.pop("signal", None)
        model_data = dict((field_name, getattr(instance, field_name, None))
                                for field_name in self.provides_args)
        model_data.update(payload)
        return model_data

    def connect(self):
        super(ModelHook, self).connect(self.model)

    def disconnect(self):
        super(ModelHook, self).disconnect(self.model)


class IntermediateListener(object):

    def __init__(self, hook, form):
        self.hook = hook
        self.form = form
        self.conditions = None

    def match(self, **match):
        self.conditions = match
        return self

    def save(self):
        return self.hook.add_listener_by_form(self.form, self.conditions)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.utils.translation import ugettext_lazy as _
from durian.match import mtuplelist_to_matchdict, MATCHABLE_CHOICES
from durian.registry import hooks


class HookConfigForm(forms.Form):
    """Form for the default hook config.

    By default listeners only needs an URL, if you want custom configuration
    keys you can subclass this form and use that as the hooks
    :attr:`durian.event.Hook.config_form` attribute.

    """
    url = forms.URLField(label=_(u"Listener URL"), required=True)

    def save(self):
        return dict(self.cleaned_data)


def create_select_hook_form(*args, **kwargs):
    """Dynamically create a form that has a ``ChoiceField`` listing all the
    hook types registered in the hook registry."""

    class SelectHookForm(forms.Form):
        type = forms.ChoiceField(choices=hooks.as_choices())

    return SelectHookForm(*args, **kwargs)


class BaseMatchForm(forms.Form):
    """Base class for match forms.

    Supports converting the form to a match tuple.

    """
    _condition_for = None

    def __init__(self, *args, **kwargs):
        self._condition_for = kwargs.pop("condition_for", self._condition_for)
        super(BaseMatchForm, self).__init__(*args, **kwargs)

    def field_to_mtuple(self):
        """Convert the form to a match tuple."""
        if not hasattr(self, "cleaned_data"):
            if not self.is_valid():
                # FIXME
                raise Exception("FORM IS NOT VALID: %s" % self.errors)

        field = self._condition_for
        return (field,
                self.cleaned_data["%s_cond" % field],
                self.cleaned_data["%s_query" % field])

    def save(self):
        return self.field_to_mtuple()


def create_match_forms(name, provides_args):
    """With a list of supported arguments, generate a list of match
    forms for these.

    E.g. if the supported arguments is ``["name", "address"]``, it will
    generate forms like these::

        Name: SELECT:[any|exact|starts with|ends with|contains] [ query ]
        Address: SELECT:[any|exact|starts with|ends with|contains] [ query ]

    When these form are feeded with data they can be converted to a match
    dict like:

        >>> {"name": Startswith("foo"), "address": Endswith("New York")}

    """

    def gen_field_for_name(name):
        return {"%s_cond" % name: forms.ChoiceField(label=name,
                                              choices=MATCHABLE_CHOICES,
                                              widget=forms.Select()),
                "%s_query" % name: forms.CharField(label="",
                                                   required=False,
                                                   initial=""),
        }

    def gen_form_for_field(field):
        dict_ = gen_field_for_name(field)
        dict_["_condition_for"] = field
        return type(name + field, (BaseMatchForm, ), dict_)

    return dict((field, gen_form_for_field(field))
                    for field in provides_args)

########NEW FILE########
__FILENAME__ = able
import re
import operator


class Matchable(object):
    """Base matchable class.

    :param value: See :attr:`value`.

    Matchables are used to modify the way a value is tested for equality.

    Subclasses of :class:`Matchable` must implement the :meth:`__eq__` method.

    .. attribute:: value

        The value to match against.

    """

    def __init__(self, value):
        self.value = value

    def __ne__(self, other):
        return not self.__eq__(other)

    def __eq__(self, other):
        raise NotImplementedError("Matchable objects must define __eq__")

    def __repr__(self):
        return '%s("%s")' % (self.__class__.__name__, self.value)


class Any(Matchable):
    """Matchable always matching anything."""

    def __init__(self, value):
        value = value or ""
        super(Any, self).__init__(value)

    def __eq__(self, other):
        return True


class Is(Matchable):
    """Matchable checking for strict equality.

    That is, the values must be identical.
    (same as the regular ``==`` operator.)

    """

    def __eq__(self, other):
        return operator.eq(self.value, other)


class Startswith(Matchable):
    """Matchable checking if the matched string starts with the matchee.

    Same as ``other.startswith(value)``.

    """

    def __eq__(self, other):
        return other.startswith(self.value)


class Endswith(Matchable):
    """Matchable checking if the matched string ends with the matchee.

    Same as ``other.endswith(value)``.

    """

    def __eq__(self, other):
        return other.endswith(self.value)


class Contains(Matchable):
    """Matchable checking if the matched string contains the matchee.

    Same as ``other.find(value)``.

    """

    def __eq__(self, other):
        return other.find(self.value) != -1


class Like(Matchable):
    """Matchable checking if the matched string matches a regular
    expression."""

    def __init__(self, value):
        super(Like, self).__init__(value)
        self.pattern = re.compile(self.value)

    def __eq__(self, other):
        return bool(self.pattern.search(other))

########NEW FILE########
__FILENAME__ = strategy
from collections import deque


def deepmatch(needle, haystack):
    """With a needle dictionary, recursively match all its keys to
    the haystack dictionary."""
    stream = deque([(needle, haystack)])

    while True:
        atom_left, atom_right = stream.pop()
        for key, value in atom_left.items():
            if isinstance(value, dict):
                if key not in atom_right:
                    return False
                stream.append((value, atom_right[key]))
            else:
                if atom_right.get(key) != value:
                    return False
        if not stream:
            break
    return True

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as _
from celery.fields import PickledObjectField
from celery.serialization import pickle


class Listener(models.Model):
    hook = models.CharField(_("hook"), max_length=255,
                            help_text=_("Connects to hook"))
    url = models.URLField(verify_exists=False,
                          help_text=_("The URL I'm listening at."))
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    config = PickledObjectField(_("configuration"), default=pickle.dumps({}),
                                help_text=_("Hook specific configuration."))
    match = PickledObjectField(_(u"conditions"), default=pickle.dumps({}),
                                help_text=_("Hook specific event filter"))

    class Meta:
        verbose_name = _("listener")
        verbose_name_plural = _("listeners")

    def __unicode__(self):
        return "%s match:%s config:%s" % (
                self.url, self.match, self.config)

########NEW FILE########
__FILENAME__ = registry
"""durian.registry"""
from celery.exceptions import NotRegistered, AlreadyRegistered
from UserDict import UserDict
from inspect import isclass


class HookRegistry(UserDict):
    """Global hook registry."""

    AlreadyRegistered = AlreadyRegistered
    NotRegistered = NotRegistered

    def __init__(self):
        self.data = {}

    def register(self, hook):
        """Register a hook in the hook registry.

        :param hook: The hook to register.

        :raises AlreadyRegistered: if the task is already registered.

        """
        # instantiate class if not already.
        hook = hook() if isclass(hook) else hook

        name = hook.name
        if name in self.data:
            raise self.AlreadyRegistered(
                    "Hook with name %s is already registered." % name)

        self.data[name] = hook

    def unregister(self, name):
        """Unregister hook by name.

        :param name: name of the hook to unregister, or a
            :class:`durian.event.Hook` class with a valid ``name`` attribute.

        :raises celery.exceptions.NotRegistered: if the hook has not
            been registered.

        """
        if hasattr(name, "name"):
            name = name.name
        if name not in self.data:
            raise self.NotRegistered(
                    "Hook with name %s is not registered." % name)
        del self.data[name]

    def get_all(self):
        """Get all hooks."""
        return self.data

    def get_hook(self, name):
        """Get hook by name."""
        return self.data[name]

    def as_choices(self):
        """Return the hook registry as a choices tuple for use
        within Django models and forms."""
        dict_types = dict((type.name, type)
                        for type in self.data.values())
        sorted_names = sorted(dict_types.keys())
        return [(type.name, type.verbose_name.capitalize())
                    for name, type in dict_types.items()]

"""
.. data:: hooks

    The global hook registry.

"""
hooks = HookRegistry()

########NEW FILE########
__FILENAME__ = tasks
from celery.task.base import Task
from celery.registry import tasks
from celery.exceptions import MaxRetriesExceededError
from anyjson import serialize


class WebhookSignal(Task):
    """The default web hook action. Simply sends the payload to the
    listener URL as POST data.

    Task arguments

        * url
            The listener destination URL to send payload to.

        * payload
            The payload to send to the listener.

    """
    name = "durian.tasks.WebhookSignal"
    ignore_result = True

    def run(self, url, payload, **kwargs):
        import urllib2
        import socket

        orig_timeout = socket.getdefaulttimeout()
        retry = kwargs.get("retry", False)
        fail_silently = kwargs.get("fail_silently", False)
        self.max_retries = kwargs.get("max_retries", self.max_retries)
        timeout = kwargs.get("timeout", orig_timeout)

        socket.setdefaulttimeout(timeout)
        try:
            urllib2.urlopen(url, serialize(payload))
        except urllib2.URLError, exc:
            if self.retry:
                try:
                    self.retry(args=[url, payload], kwargs=kwargs, exc=exc)
                except MaxRetriesExceededError:
                    if self.fail_silently:
                        return
                    raise
            else:
                if fail_silently:
                    return
                raise
        finally:
            socket.setdefaulttimeout(orig_timeout)

########NEW FILE########
__FILENAME__ = test_hooks
import unittest
from durian.event import Hook, ModelHook, IntermediateListener
from durian.registry import hooks
from durian.forms import BaseMatchForm
from durian.models import Listener
from celery.registry import tasks
from durian.tasks import WebhookSignal
from durian import match
from django.contrib.auth.models import User
from django.db.models import signals
from django.dispatch import Signal


class TestWebhookSignal(WebhookSignal):
    name = "__durian__.unittest.TestWebhookSignal"
    ignore_result = True
    scratchpad = {}

    def run(self, url, payload, **kwargs):
        self.__class__.scratchpad[url] = payload


testhook = Hook(name="__durian__.unittest.testhook",
                provides_args=["name", "address", "phone", "email"],
                task_cls=TestWebhookSignal,
                async=False)
hooks.register(testhook)

testmhook = ModelHook(model=User, signal=signals.post_save,
                name="__durian__.unittest.testmhook",
                provides_args=["username", "email", "first_name",
                               "last_name"],
                task_cls=TestWebhookSignal,
                async=False)
hooks.register(testmhook)


class TestHook(unittest.TestCase):

    def test_in_registry(self):
        in_reg = hooks.get("__durian__.unittest.testhook")
        self.assertTrue(in_reg)
        self.assertTrue(isinstance(in_reg, Hook))

    def test_match_forms(self):
        mforms = testhook.match_forms
        for field in testhook.provides_args:
            self.assertTrue(field in mforms)
            mform = mforms[field]()
            self.assertTrue(isinstance(mform, BaseMatchForm))
            self.assertTrue("%s_cond" % field in mform.base_fields)
            self.assertTrue("%s_query" % field in mform.base_fields)

        matchdict = testhook.apply_match_forms({
                    "name_cond": match.CONDITION_EXACT,
                    "name_query": "George Constanza",
                    "address_cond": match.CONDITION_ENDSWITH,
                    "address_query": "New York City",
                    "phone_cond": match.CONDITION_STARTSWITH,
                    "phone_query": "212",
                    "email_cond": match.CONDITION_CONTAINS,
                    "email_query": "@vandelay"})

        self.assertTrue(isinstance(matchdict.get("name"), match.Is))
        self.assertTrue(isinstance(matchdict.get("address"), match.Endswith))
        self.assertTrue(isinstance(matchdict.get("phone"), match.Startswith))
        self.assertTrue(isinstance(matchdict.get("email"), match.Contains))

        self.assertTrue(match.deepmatch(matchdict, {
            "name": "George Constanza",
            "address": "Border Lane, New York City",
            "phone": "212 555 88 23",
            "email": "george@vandelay.com",
        }))

    def test_trigger_event(self):
        url = "http://where.joe/listens"
        form = testhook.config_form({"url": url})
        listener = testhook.listener(form).match(name="Joe").save()
        self.assertTrue(isinstance(listener, Listener))

        lis = Listener.objects.filter(url=url)
        self.assertTrue(lis.count())
        self.assertTrue(lis[0].url == url)

        testhook.send(sender=self,
                        name="Joe", address="foo", phone="123",
                        email="joe@example.com")

        self.assertTrue(TestWebhookSignal.scratchpad.get(url))
        del(TestWebhookSignal.scratchpad[url])

        testhook.send(sender=self,
                        name="Simon", address="bar", phone="456",
                        email="simon@example.com")
        self.assertFalse(TestWebhookSignal.scratchpad.get(url))


class TestModelHook(unittest.TestCase):

    def test_trigger_event(self):
            url = "http://where.joe/mlistens"
            form = testmhook.config_form({"url": url})
            self.assertTrue(testmhook)
            a = testmhook.listener(form)
            self.assertTrue(isinstance(a, IntermediateListener))
            self.assertTrue(callable(a.match))
            self.assertTrue(testmhook.listener(form).match(username="joe"))
            listener = testmhook.listener(form).match(username="joe").save()
            self.assertTrue(isinstance(listener, Listener))

            lis = Listener.objects.filter(url=url)
            self.assertTrue(lis.count())
            self.assertTrue(lis[0].url == url)

            u = User.objects.create_user(username="joe",
                    email="joe@example.com", password="joe")

            scratch = TestWebhookSignal.scratchpad.get(url)
            self.assertTrue(scratch)
            self.assertTrue(scratch["created"])
            self.assertEquals(scratch["username"], "joe")
            self.assertEquals(scratch["email"], "joe@example.com")
            self.assertFalse(scratch.get("password"))
            del(TestWebhookSignal.scratchpad[url])

            u.last_name = "Example"
            u.save()

            scratch = TestWebhookSignal.scratchpad.get(url)
            self.assertTrue(scratch)
            self.assertEquals(scratch["created"], False)
            self.assertEquals(scratch["username"], "joe")
            self.assertEquals(scratch["email"], "joe@example.com")
            self.assertEquals(scratch["last_name"], "Example")
            self.assertFalse(scratch.get("password"))
            del(TestWebhookSignal.scratchpad[url])

########NEW FILE########
__FILENAME__ = test_match
from durian.match.strategy import deepmatch
from durian.match.able import Is, Like, Startswith, Endswith, Contains
from durian.match import mtuplelist_to_matchdict
from durian import match
import unittest


class TestMtuplelist(unittest.TestCase):

    def test_conversion(self):
        mtuplelist = [("name", match.CONDITION_ENDSWITH, "Constanza"),
                      ("zipcode", match.CONDITION_STARTSWITH, "70"),
                      ("address", match.CONDITION_EXACT, "Milkyway"),
                      ("work", match.CONDITION_CONTAINS, "andeley"),
                      ("zoo", match.CONDITION_PASS, "zoo")]
        matchdict = mtuplelist_to_matchdict(mtuplelist)
        self.assertFalse(matchdict.get("zoo"))
        self.assertTrue(isinstance(matchdict.get("name"), Endswith))
        self.assertEquals(matchdict["name"].value, "Constanza")
        self.assertTrue(isinstance(matchdict.get("zipcode"), Startswith))
        self.assertEquals(matchdict["zipcode"].value, "70")
        self.assertTrue(isinstance(matchdict.get("address"), Is))
        self.assertEquals(matchdict["address"].value, "Milkyway")
        self.assertTrue(isinstance(matchdict.get("work"), Contains))
        self.assertEquals(matchdict["work"].value, "andeley")

        matches = {"name": "George Constanza",
                   "zipcode": "70312",
                   "address": "Milkyway",
                   "work": "Vandeley Industries"}

        notmatches = {"name": "Jerry Seinfeld",
                      "zipcode": "70314",
                      "address": "Milkyway",
                      "work": "Comedian"}

        self.assertTrue(deepmatch(matches, matchdict))
        self.assertFalse(deepmatch(notmatches, matchdict))


class TestStrategy(unittest.TestCase):

    def test_deepmatch(self):
        self.assertTrue(deepmatch({"name": Like("Constanza")},
                                  {"name": "George Constanza"}))
        self.assertFalse(deepmatch({"name": Like("Seinfeld")},
                                   {"name": "George Constanza"}))
        self.assertTrue(deepmatch({"name": Startswith("George")},
                                  {"name": "George Constanza"}))
        self.assertFalse(deepmatch({"name": Startswith("Cosmo")},
                                   {"name": "George Constanza"}))
        self.assertTrue(deepmatch({"name": {
                                    "first_name": Startswith("El"),
                                    "last_name": Endswith("es"),
                                  }},
                                  {"name": {
                                    "first_name": "Elaine",
                                    "last_name": "Benes",
                                  }}))
        x = {
            "foo": "xuzzy",
            "baz": "xxx",
            "mooze": {
                "a": "b",
                "c": {
                    "d": "e",
                }
            }
        }
        self.assertTrue(deepmatch(x, x))
        self.assertFalse(deepmatch(x, {"foo": "xuzzy",
                                       "baz": "xxx",
                                       "mooze": {
                                           "a": "b",
                                           "c": {
                                                "x": "y",
                                            }
                                       }
                                  }))
        self.assertTrue(deepmatch({"foo": "bar"}, {"foo": "bar"}))
        self.assertFalse(deepmatch({"foo": 1}, {"foo": "1"}))
        self.assertFalse(deepmatch({"foo": "bar", "baz": {"x": "x"}},
                                   {"foo": "bar"}))

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, url, include
from durian import views


class DurianSite(object):
    namespace = "durian"
    app_name = "durian"

    def __init__(self, namespace=None, app_name=None):
        self.namespace = namespace or self.namespace
        self.app_name = app_name or self.app_name

    @property
    def urlpatterns(self):
        return patterns("",
            url(r'^select/', views.select, name="select"),
            url(r'^create/', views.create, name="create"),
            url(r'^debug/', views.debug, name="debug"),
        )

    @property
    def urls(self):
        return (self.urlpatterns, "durian", "durian")


durian = DurianSite()
urlpatterns = durian.urlpatterns

########NEW FILE########
__FILENAME__ = views
import sys
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.http import HttpResponse, HttpResponseRedirect
from django.http import HttpResponseNotAllowed
from django.utils.translation import ugettext as _
from anyjson import deserialize
from durian.forms import create_select_hook_form
from durian.registry import hooks


def send(request, hook_type):
    """Trigger hook by sending payload as POST data."""

    if request.method != "POST":
        return HttpResponseNotAllowed(_("Method not allowed: %s") % (
            request.method))

    payload = dict(request.POST.copy())
    sender = request.META

    hook = get_hook_or_404(hook_type)
    hook.send(sender=sender, **payload)


def select(request, template_name="durian/select_hook.html"):
    """Select hook to create."""
    context = RequestContext(request)
    context["title"] = _("Select event")
    context["select_hook_form"] = create_select_hook_form()
    return render_to_response(template_name, context_instance=context)


def get_hook_or_404(hook_type):
    """Get hook by type in the registry or raise HTTP 404."""
    if hook_type not in hooks:
        raise Http404(_("Unknown hook type: %s" % hook_type))
    return hooks[hook_type]


def create(request, template_name="durian/create_hook.html"):
    """View to create a new hook."""
    context = RequestContext(request)
    if request.method == "POST":
        hook = get_hook_or_404(request.POST["type"])
        config_form = hook.config_form(request.POST)
        if config_form.is_valid():
            matchdict = hook.apply_match_forms(request.POST)
            hook.add_listener_by_form(config_form, match=matchdict)
            return HttpResponse("Listener Created!")
    else:
        hook = get_hook_or_404(request.GET["type"])
        config_form = hook.config_form()

    match_forms = hook.get_match_forms()
    context["title"] = _("Create %s Listener" % (
                                hook.verbose_name.capitalize()))
    context["hook_type"] = hook.name
    context["hook_name"] = hook.verbose_name
    context["match_forms"] = match_forms
    context["config_form"] = config_form
    return render_to_response(template_name, context_instance=context)


def debug(request):
    """Simple listener destination URL to dump out the payload and
    request to stderr."""
    sys.stderr.write(str(request.get_full_path()) + "\n")
    sys.stderr.write(str(request.raw_post_data) + "\n")
    sys.stderr.write(str(request.POST) + "\n")
    sys.stderr.write(str(deserialize(request.raw_post_data)) + "\n")
    return HttpResponse("Thanks!")

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.db.models import signals
from django.utils.translation import ugettext_lazy as _
from durian.event import ModelHook
from durian.registry import hooks


class Person(models.Model):
    name = models.CharField(_(u"name"), blank=False, max_length=200)
    address = models.CharField(_(u"address"), max_length=200)
    secret = models.CharField(_(u"secret"), max_length=200)


class PersonHook(ModelHook):
    name = "person"
    model = Person
    signal = signals.post_save
    provides_args = ["name", "address"]
    async = False
hooks.register(PersonHook)

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates two different styles of tests (one doctest and one
unittest). These will both pass when you run "manage.py test".

Replace these with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):

    def test_basic_addition(self):
        """Tests that 1 + 1 always equals 2."""
        self.failUnlessEqual(1 + 1, 2)

__test__ = {"doctest": """
Another way to test that 1 + 1 is equal to 2.

>>> 1 + 1 == 2
True
"""}

########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write(
            "Error: Can't find the file 'settings.py' in the " + \
            "directory containing %r. It appears you've" % __file__ + \
            "customized things.\nYou'll have to run " + \
            "django-admin.py, passing it your settings module.\n" + \
            "(If the file settings.py does indeed exist, it's " + \
            "causing an ImportError somehow.)\n")
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Django settings for durianproject project.

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

MANAGERS = ADMINS

DATABASE_ENGINE = 'sqlite3'
DATABASE_NAME = 'durianproject.sqlite'
DATABASE_USER = ''
DATABASE_PASSWORD = ''
DATABASE_HOST = ''
DATABASE_PORT = ''

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = ''

# URL prefix for admin media -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/media/", "/media/".
ADMIN_MEDIA_PREFIX = '/media/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = '+s)c0psuin+78$f2(k7)bxglr-i+_wy*lz)))48m@_1(zgogho'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.load_template_source',
    'django.template.loaders.app_directories.load_template_source',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
)

ROOT_URLCONF = 'durianproject.urls'

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.admin',
    'celery',
    'durian',
    'durianapp',
)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, url, include
from durian.urls import durian
from django.contrib import admin
from django.conf import settings
admin.autodiscover()

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    url(r'^durian/', durian.urls),
    url(r'^admin/', admin.site.urls),
    url(r"%s(?P<path>.*)$" % settings.MEDIA_URL[1:],
        "django.views.static.serve", {
        "document_root": settings.MEDIA_ROOT}),
)

########NEW FILE########
__FILENAME__ = hook
from durian.models import Listener
from django import forms
from durian.forms import HookConfigForm
from durian.event import Hook
from durian.registry import hooks


# SIMPLE HOOK 

class MyHook(Hook):
    name = "myhook"
hooks.register(MyHook())


def install_listener():
    l = Listener(url="http://localhost:8000/durian/debug/",
             hook=MyHook.name)
    l.save()

# HOOK SENT EVERY TIME USER "ask" COMMITS A CHANGE

# This form is needed to add a listener, so the correct username/password
# is sent when sending updates to twitter.

class TwitterCommitHookConfigForm(HookConfigForm):
    username = forms.CharField(label=_(u"username"))
    password = forms.CharField(label=_(u"password"), required=True, 
                               widget=forms.PasswordInput())
    digest = forms.BooleanField(widget=forms.CheckboxInput())
    active = forms.BooleanField(widget=forms.CheckboxInput())


# This is the hook itself.
class TwitterCommitHook(Hook):
    name = "myuserhook"
    config_form = TwitterCommitHookConfigForm
    providing_args = ["username", "password", "digest", "active"]
hooks.register(TwitterCommitHook)


# This is the function triggering the hook
def commit_change(self, commit_msg, user, revision):

    # ...Do what happens regularly at a commit...

    TwitterCommitHook().send(sender=commit_change, user=user, revision=revision,
                             commit_msg=commit_msg)



# Now let's register a listener.

from celeryhook.match import Startswith
hook = TwitterCommitHook()
form = hook.config_form({"username": "ask", "password": "foo"})
hook.listener(form).match(commit_msg=Startswith("Important change"),
                          username="ask").save()






# A Django view registering a listener.
def add_twitter_hook(request, template_name="myapp/twitterhook.html"):
    hook = TwitterCommitHook()
    context = RequestContext()
    if request.method == "POST":
        form = hook.config_form(request.POST)
        if form.is_valid():
            hook.add_listener_by_form(form)
    else:
        form = hook.config_form()

    context["form"] = form

    return render_to_response(template_name, context_instance=context)


# ### MODEL HOOK


from django.db import signals
from django.contrib.auth.models import User
from durian.event import ModelHook


userhook = ModelHook(name="user-post-save",
                     model=User,
                     signal=signals.post_save,
                     provides_args=["username", "is_admin"])

# send event when Joe is changed
userhook.listener(
    url="http://where.joe/is/listening").match(
        username="joe").save()

# send event when any user is changed.
userhook.listener(url="http://where.joe/is/listening").save()

# Send event when Joe is admin
userhook.listener(
    url="http://where.joe/is/listening").match(
        username="joe", is_admin=True).save()




joe = User.objects.get(username="joe")
joe.is_admin = True
joe.save()


A hook that sends events to twitter
-----------------------------------


In ``myapp/tasks.py``:

    >>> from celery.task import Task
    >>> from celery.registry import tasks

    >>> class TwitterUpdateTask(WebhookSignal):
    ...     name = "myapp.tasks.TwitterWebhookSignal"
    ... 
    ...     def run(self, username, password, message, \*\*kwargs):
    ...         import twitter
    ...         api = twitter.Api(username=username, password=password)
    ...         api.PostUpdate(message)
    >>> tasks.register(TwitterUpdateTask)


In ``myapp/hooks.py``:

    >>> from durian.event import Hook
    >>> from durian.registry import hooks
    >>> from durian.forms import BaseHookConfigForm
    >>> from django.utils.translation import _
    >>> from django import forms

    >>> class TwitterHookConfigForm(HookConfigForm):
    ...     username = forms.CharField(label=_("twitter username"),
    ...                                required=True)
    ...     password = forms.CharField(label=_("twitter password"),
    ...                                widget=forms.PasswordInput())


    >>> class TwitterHook(Hook):
    ...     name = "Twitter"
    ...     task_cls = TwitterUpdateTask
    ...     config_form = TwitterHookConfigForm
    ...
    ...     def 




########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write(
            "Error: Can't find the file 'settings.py' in the directory \
            containing %r. It appears you've customized things.\n\
            You'll have to run django-admin.py, passing it your settings\
            module.\n(If the file settings.py does indeed exist, it's\
            causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Django settings for testproj project.

import os
import sys
# import source code dir
sys.path.insert(0, os.path.join(os.getcwd(), os.pardir))

SITE_ID = 301

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ROOT_URLCONF = "urls"

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

TEST_RUNNER = "celery.tests.runners.run_tests"
TEST_APPS = (
    "durian",
)

AMQP_SERVER = "localhost"
AMQP_PORT = 5672
AMQP_VHOST = "/"
AMQP_USER = "guest"
AMQP_PASSWORD = "guest"

TT_HOST = "localhost"
TT_PORT = 1978

CELERY_AMQP_EXCHANGE = "testdurian"
CELERY_AMQP_ROUTING_KEY = "testdurian"
CELERY_AMQP_CONSUMER_QUEUE = "testdurian"

MANAGERS = ADMINS

DATABASE_ENGINE = 'sqlite3'
DATABASE_NAME = 'testdb.sqlite'
DATABASE_USER = ''
DATABASE_PASSWORD = ''
DATABASE_HOST = ''
DATABASE_PORT = ''

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'celery',
    'durian',
)

try:
    import test_extensions
except ImportError:
    pass
else:
    pass
    #INSTALLED_APPS += ("test_extensions", )

SEND_CELERY_TASK_ERROR_EMAILS = False

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    # Example:
    # (r'^testproj/', include('testproj.foo.urls')),

    # Uncomment the admin/doc line below and add 'django.contrib.admindocs'
    # to INSTALLED_APPS to enable admin documentation:
    # (r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # (r'^admin/(.*)', admin.site.root),
)

########NEW FILE########
