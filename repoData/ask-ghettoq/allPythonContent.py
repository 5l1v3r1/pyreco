__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
import sys
import os

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
sys.path.insert(0, "../")
import ghettoq

from django.conf import settings
if not settings.configured:
    settings.configure()

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings.
# They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'ghettoq'
copyright = u'2009, Opera Softare (WebTeam)'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = ".".join(map(str, ghettoq.VERSION[0:2]))
# The full version, including alpha/beta/rc tags.
release = ghettoq.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['.build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'trac'

#html_translator_class = "djangodocs.DjangoHTMLTranslator"


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
#html_style = 'agogo.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['.static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_use_modindex = True

# If false, no index is generated.
html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'ghettoqdoc'


# Options for LaTeX output
# ------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class
# [howto/manual]).
latex_documents = [
  ('index', 'ghettoq.tex', ur'ghettoq Documentation',
   ur'Ask Solem', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

html_theme = "nature"
html_theme_path = ["_theme"]

########NEW FILE########
__FILENAME__ = applyxrefs
"""Adds xref targets to the top of files."""

import sys
import os

testing = False

DONT_TOUCH = (
        './index.txt',
        )


def target_name(fn):
    if fn.endswith('.txt'):
        fn = fn[:-4]
    return '_' + fn.lstrip('./').replace('/', '-')


def process_file(fn, lines):
    lines.insert(0, '\n')
    lines.insert(0, '.. %s:\n' % target_name(fn))
    try:
        f = open(fn, 'w')
    except IOError:
        print("Can't open %s for writing. Not touching it." % fn)
        return
    try:
        f.writelines(lines)
    except IOError:
        print("Can't write to %s. Not touching it." % fn)
    finally:
        f.close()


def has_target(fn):
    try:
        f = open(fn, 'r')
    except IOError:
        print("Can't open %s. Not touching it." % fn)
        return (True, None)
    readok = True
    try:
        lines = f.readlines()
    except IOError:
        print("Can't read %s. Not touching it." % fn)
        readok = False
    finally:
        f.close()
        if not readok:
            return (True, None)

    #print fn, len(lines)
    if len(lines) < 1:
        print("Not touching empty file %s." % fn)
        return (True, None)
    if lines[0].startswith('.. _'):
        return (True, None)
    return (False, lines)


def main(argv=None):
    if argv is None:
        argv = sys.argv

    if len(argv) == 1:
        argv.extend('.')

    files = []
    for root in argv[1:]:
        for (dirpath, dirnames, filenames) in os.walk(root):
            files.extend([(dirpath, f) for f in filenames])
    files.sort()
    files = [os.path.join(p, fn) for p, fn in files if fn.endswith('.txt')]
    #print files

    for fn in files:
        if fn in DONT_TOUCH:
            print("Skipping blacklisted file %s." % fn)
            continue

        target_found, lines = has_target(fn)
        if not target_found:
            if testing:
                print '%s: %s' % (fn, lines[0]),
            else:
                print "Adding xref to %s" % fn
                process_file(fn, lines)
        else:
            print "Skipping %s: already has a xref" % fn

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = literals_to_xrefs
"""
Runs through a reST file looking for old-style literals, and helps replace them
with new-style references.
"""

import re
import sys
import shelve

refre = re.compile(r'``([^`\s]+?)``')

ROLES = (
    'attr',
    'class',
    "djadmin",
    'data',
    'exc',
    'file',
    'func',
    'lookup',
    'meth',
    'mod',
    "djadminopt",
    "ref",
    "setting",
    "term",
    "tfilter",
    "ttag",

    # special
    "skip",
)

ALWAYS_SKIP = [
    "NULL",
    "True",
    "False",
]


def fixliterals(fname):
    data = open(fname).read()

    last = 0
    new = []
    storage = shelve.open("/tmp/literals_to_xref.shelve")
    lastvalues = storage.get("lastvalues", {})

    for m in refre.finditer(data):

        new.append(data[last:m.start()])
        last = m.end()

        line_start = data.rfind("\n", 0, m.start())
        line_end = data.find("\n", m.end())
        prev_start = data.rfind("\n", 0, line_start)
        next_end = data.find("\n", line_end + 1)

        # Skip always-skip stuff
        if m.group(1) in ALWAYS_SKIP:
            new.append(m.group(0))
            continue

        # skip when the next line is a title
        next_line = data[m.end():next_end].strip()
        if next_line[0] in "!-/:-@[-`{-~" and \
                all(c == next_line[0] for c in next_line):
            new.append(m.group(0))
            continue

        sys.stdout.write("\n"+"-"*80+"\n")
        sys.stdout.write(data[prev_start+1:m.start()])
        sys.stdout.write(colorize(m.group(0), fg="red"))
        sys.stdout.write(data[m.end():next_end])
        sys.stdout.write("\n\n")

        replace_type = None
        while replace_type is None:
            replace_type = raw_input(
                colorize("Replace role: ", fg="yellow")).strip().lower()
            if replace_type and replace_type not in ROLES:
                replace_type = None

        if replace_type == "":
            new.append(m.group(0))
            continue

        if replace_type == "skip":
            new.append(m.group(0))
            ALWAYS_SKIP.append(m.group(1))
            continue

        default = lastvalues.get(m.group(1), m.group(1))
        if default.endswith("()") and \
                replace_type in ("class", "func", "meth"):
            default = default[:-2]
        replace_value = raw_input(
            colorize("Text <target> [", fg="yellow") + default + \
                    colorize("]: ", fg="yellow")).strip()
        if not replace_value:
            replace_value = default
        new.append(":%s:`%s`" % (replace_type, replace_value))
        lastvalues[m.group(1)] = replace_value

    new.append(data[last:])
    open(fname, "w").write("".join(new))

    storage["lastvalues"] = lastvalues
    storage.close()

#
# The following is taken from django.utils.termcolors and is copied here to
# avoid the dependancy.
#


def colorize(text='', opts=(), **kwargs):
    """
    Returns your text, enclosed in ANSI graphics codes.

    Depends on the keyword arguments 'fg' and 'bg', and the contents of
    the opts tuple/list.

    Returns the RESET code if no parameters are given.

    Valid colors:
        'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'

    Valid options:
        'bold'
        'underscore'
        'blink'
        'reverse'
        'conceal'
        'noreset' - string will not be auto-terminated with the RESET code

    Examples:
        colorize('hello', fg='red', bg='blue', opts=('blink',))
        colorize()
        colorize('goodbye', opts=('underscore',))
        print colorize('first line', fg='red', opts=('noreset',))
        print 'this should be red too'
        print colorize('and so should this')
        print 'this should not be red'
    """
    color_names = ('black', 'red', 'green', 'yellow',
                   'blue', 'magenta', 'cyan', 'white')
    foreground = dict([(color_names[x], '3%s' % x) for x in range(8)])
    background = dict([(color_names[x], '4%s' % x) for x in range(8)])

    RESET = '0'
    opt_dict = {'bold': '1',
                'underscore': '4',
                'blink': '5',
                'reverse': '7',
                'conceal': '8'}

    text = str(text)
    code_list = []
    if text == '' and len(opts) == 1 and opts[0] == 'reset':
        return '\x1b[%sm' % RESET
    for k, v in kwargs.iteritems():
        if k == 'fg':
            code_list.append(foreground[v])
        elif k == 'bg':
            code_list.append(background[v])
    for o in opts:
        if o in opt_dict:
            code_list.append(opt_dict[o])
    if 'noreset' not in opts:
        text = text + '\x1b[%sm' % RESET
    return ('\x1b[%sm' % ';'.join(code_list)) + text

if __name__ == '__main__':
    try:
        fixliterals(sys.argv[1])
    except (KeyboardInterrupt, SystemExit):
        print

########NEW FILE########
__FILENAME__ = base
from ghettoq import messaging


class BaseBackend(object):

    def __init__(self, host=None, port=None, user=None, password=None,
            database=None, timeout=None):
        self.host = host
        self.port = port
        self.user = user
        self.password = password
        self.database = database
        self.timeout = timeout
        self.connection = None

    def Queue(self, name):
        return messaging.Queue(self, name)

    def QueueSet(self, names):
        return messaging.QueueSet(self, names)

    @property
    def client(self):
        if self.connection is None:
            self.connection = self.establish_connection()
        return self.connection

    def close(self):
        pass

########NEW FILE########
__FILENAME__ = beanstalk
from itertools import ifilter
from Queue import Empty

from beanstalkc import Connection
from ghettoq.backends.base import BaseBackend

DEFAULT_HOST = 'localhost'
DEFAULT_PORT = 11300


class BeanstalkBackend(BaseBackend):

    def _parse_job(self, job):
        item, dest = None, None
        if job:
            try:
                item = job.body
                dest = job.stats()['tube']
            except:
                job.bury()
            else:
                job.delete()
        else:
            raise Empty
        return item, dest

    def establish_connection(self):
        self.host = self.host or DEFAULT_HOST
        self.port = self.port or DEFAULT_PORT
        return Connection(host=self.host, port=self.port)

    def put(self, queue, message, priority=0, **kwargs):
        self.client.use(queue)
        self.client.put(message, priority=priority)

    def get(self, queue):
        if not queue:
            raise Empty
        if queue not in self.client.watching():
            self.client.watch(queue)

        ignore = ifilter(lambda q: q!= queue, self.client.watching())
        map(self.client.ignore, ignore)

        job = self.client.reserve(timeout=1)
        item, dest = self._parse_job(job)
        return item

    def get_many(self, queues, timeout=None):
        if not queues:
            raise Empty

        # timeout of None will cause beanstalk to timeout waiting
        # for a new request
        if timeout is None:
            timeout = 1

        to_watch = ifilter(lambda q: q not in self.client.watching(), queues)
        map(self.client.watch, to_watch)

        job = self.client.reserve(timeout=timeout)
        return self._parse_job(job)

    def purge(self, queue):
        if queue not in self.client.watching(): 
            self.client.watch(queue) 
            ignore = ifilter(lambda q: q!= queue, self.client.watching()) 
            map(self.client.ignore, ignore) 
            count = 0 
            while True: 
                job = self.client.reserve(timeout=1) 
                if job: 
                    job.delete() 
                    count += 1
                else: 
                    break 
            return count 

########NEW FILE########
__FILENAME__ = couch_db
from Queue import Empty

import couchdb
import uuid
from ghettoq.backends.base import BaseBackend

__author__ = "David Clymer <david@zettazebra.com>"

DEFAULT_HOST = '127.0.0.1'
DEFAULT_PORT = 5984
DEFAULT_DATABASE = 'ghettoq'

def create_message_view(db):
    from couchdb import design
    view = design.ViewDefinition('ghettoq', 'messages', """
        function (doc) {
          if (doc.queue && doc.payload)
            emit(doc.queue, doc);
        }
        """)
    if not view.get_doc(db):
        view.sync(db)

class CouchdbBackend(BaseBackend):

    def __init__(self, host=None, port=None, user=None, password=None,
                 database=None, timeout=None, ssl=False):

        self.ssl = ssl
        if not database or database == '/':
            database = DEFAULT_DATABASE
        self.view_created = False
        super(CouchdbBackend, self).__init__(host or DEFAULT_HOST,
                                             port or DEFAULT_PORT,
                                             user, password,
                                             database or DEFAULT_DATABASE,
                                             timeout)

    def establish_connection(self):
        if self.ssl:
            proto = 'https'
        else:
            proto = 'http'

        server = couchdb.Server('%s://%s:%s/' % (proto, self.host, self.port))
        try:
            return server.create(self.database)
        except couchdb.PreconditionFailed:
            return server[self.database]

    def put(self, queue, message, **kwargs):
        self.client.save({'_id': uuid.uuid4().hex, 'queue': queue, 'payload': message})

    def _get(self, queue, **kwargs):
        # If the message view is not yet set up, we'll need it now.
        if not self.view_created:
            create_message_view(self.client)
            self.view_created = True

        if not queue:
            raise Empty
        return self.client.view('ghettoq/messages', key=queue, **kwargs)

    def get(self, queue):
        result = self._get(queue, limit=1)
        if not result:
            raise Empty

        item = result.rows[0].value
        self.client.delete(item)
        return item['payload']

    def purge(self, queue):
        result = self._get(queue)
        for item in result:
            self.client.delete(item.value)
        return len(result)

########NEW FILE########
__FILENAME__ = database
from ghettoq.models import Queue
from ghettoq.backends.base import BaseBackend


class DatabaseBackend(BaseBackend):

    def __init__(self, *args, **kwargs):
        from django.conf import settings
        if not settings.configured:
            settings.configure(DEBUG=False,
                               DATABASE_HOST=self.host,
                               DATABASE_PORT=self.port,
                               DATABASE_NAME=self.database,
                               DATABASE_USER=self.user,
                               DATABASE_PASSWORD=self.password)
        super(DatabaseBackend, self).__init__(*args, **kwargs)

    def establish_connection(self):
        pass

    def put(self, queue, message, **kwargs):
        Queue.objects.publish(queue, message)

    def get(self, queue):
        self.refresh_connection()
        return Queue.objects.fetch(queue)

    def purge(self, queue):
        return Queue.objects.purge(queue)

    def refresh_connection(self):
        from django.db import connection
        connection.close()

########NEW FILE########
__FILENAME__ = mongodb
from pymongo.connection import Connection
from pymongo.errors import OperationFailure

from ghettoq.backends.base import BaseBackend
from ghettoq.messaging import Empty

__author__ = "Flavio [FlaPer87] Percoco Premoli <flaper87@flaper87.org>"

DEFAULT_HOST = "127.0.0.1"
DEFAULT_PORT = 27017


class MongodbBackend(BaseBackend):

    def establish_connection(self):
        self.port = self.port or DEFAULT_PORT
        self.host = self.host or DEFAULT_HOST
        self.connection = Connection(host=self.host, port=self.port)
        dbname = self.database
        if not dbname or dbname == "/":
            dbname = "ghettoq"
        self.database = getattr(self.connection, dbname)
        col = self.database.messages
        col.ensure_index([("queue", 1)])
        return col

    def put(self, queue, message, **kwargs):
        self.client.insert({"payload": message, "queue": queue})

    def get(self, queue):
        try:
            msg = self.client.database.command("findandmodify",
                        "messages", query={"queue": queue}, remove=True)
        except OperationFailure:
            raise Empty("Empty queue")
        return msg["value"]["payload"]

    def purge(self, queue):
        return self.client.remove({"queue": queue})

########NEW FILE########
__FILENAME__ = pyredis
from Queue import Empty

from redis import Redis
from ghettoq.backends.base import BaseBackend

DEFAULT_PORT = 6379
DEFAULT_DB = 0


class RedisBackend(BaseBackend):

    def __init__(self, host=None, port=None, user=None, password=None,
            database=None, timeout=None):

        if not isinstance(database, int):
            if not database or database == "/":
                database = DEFAULT_DB
            elif database.startswith('/'):
                database = database[1:]
            try:
                database = int(database)
            except ValueError:
                raise AttributeError(
                    "Database name must be integer between 0 "
                    "and database_count - 1")

        super(RedisBackend, self).__init__(host, port, user, password,
                                           database, timeout)

    def establish_connection(self):
        self.port = int(self.port or DEFAULT_PORT)
        return Redis(host=self.host, port=self.port, db=self.database,
                     password=self.password)

    def put(self, queue, message, **kwargs):
        self.client.lpush(queue, message)

    def get(self, queue):
        if not queue:
            raise Empty

        try:
            dest, item = self.client.brpop([queue], timeout=1)
        except TypeError:
            raise Empty

        return item

    def get_many(self, queues, timeout=None):
        if not queues:
            raise Empty

        try:
            dest, item = self.client.brpop(queues, timeout=1)
        except TypeError:
            raise Empty

        return item, dest

    def purge(self, queue):
        size = self.client.llen(queue)
        self.client.delete(queue)
        return size

    def close(self):
        if self.connection is not None:
            try:
                self.connection.bgsave()
            except ResponseError:
                pass
            try:
                self.connection.connection.disconnect()
            except (AttributeError, ResponseError):
                pass

########NEW FILE########
__FILENAME__ = managers
# Partially stolen from Django Queue Service
# (http://code.google.com/p/django-queue-service)
from django.db import models


class QueueManager(models.Manager):

    def publish(self, queue_name, payload):
        queue, created = self.get_or_create(name=queue_name)
        queue.messages.create(payload=payload)

    def fetch(self, queue_name):
        try:
            queue = self.get(name=queue_name)
        except self.model.DoesNotExist:
            return

        return queue.messages.pop()

    def purge(self, queue_name):
        try:
            queue = self.get(name=queue_name)
        except self.model.DoesNotExist:
            return

        messages = queue.messages.all()
        count = messages.count()
        messages.delete()
        return count


class MessageManager(models.Manager):

    def pop(self):
        try:
            resultset = self.filter(visible=True).order_by('sent_at', 'id')
            result = resultset[0:1].get()
            result.visible = False
            result.save()
            return result.payload
        except self.model.DoesNotExist:
            pass

    def cleanup(self):
        self.filter(visible=False).delete()

########NEW FILE########
__FILENAME__ = messaging
from Queue import Empty
from itertools import cycle


class Queue(object):

    def __init__(self, backend, name):
        self.name = name
        self.backend = backend

    def put(self, payload, priority=0):
        self.backend.put(self.name, payload, priority=priority)

    def get(self):
        payload = self.backend.get(self.name)
        if payload is not None:
            return payload
        raise Empty

    def purge(self):
        return self.backend.purge(self.name)

    def __repr__(self):
        return "<Queue: %s>" % repr(self.name)


class QueueSet(object):
    """A set of queues that operates as one."""

    def __init__(self, backend, queues):
        self.backend = backend
        self.queue_names = list(queues)

        self._get_many = getattr(self.backend, "get_many", None)
        self.get = self._emulated
        if self._get_many:
            self.get = self._native

        # attributes below are only used in emulation mode.

        # queues could be a PriorityQueue as well to support
        # priorities.
        self.queues = map(self.backend.Queue, self.queue_names)

        # an infinite cycle through all the queues.
        self.cycle = cycle(self.queues)

        # A set of all the queue names, so we can match when we've
        # tried all of them.
        self.all = frozenset(self.queue_names)

    def _native(self, timeout=None):
        return self._get_many(self.queue_names, timeout=timeout)

    def _emulated(self, timeout=None):
        """Get the next message avaiable in the queue.

        :returns: The message and the name of the queue it came from as
            a tuple.
        :raises Empty: If there are no more items in any of the queues.

        """

        # A set of queues we've already tried.
        tried = set()

        while True:
            # Get the next queue in the cycle, and try to get an item off it.
            try:
                queue = self.cycle.next()
            except StopIteration:
                raise Empty("No queues registered")
            try:
                item = queue.get()
            except Empty:
                # raises Empty when we've tried all of them.
                tried.add(queue.name)
                if tried == self.all:
                    raise
            else:
                return item, queue.name

    def __repr__(self):
        return "<QueueSet: %s>" % repr(self.queue_names)

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as _
from ghettoq.managers import QueueManager, MessageManager


class Queue(models.Model):
    name = models.CharField(_("name"), max_length=200, unique=True)

    objects = QueueManager()

    class Meta:
        verbose_name = _("queue")
        verbose_name_plural = _("queues")


class Message(models.Model):
    visible = models.BooleanField(default=True, db_index=True)
    sent_at = models.DateTimeField(null=True, blank=True, db_index=True,
                auto_now_add=True)
    payload = models.TextField(_("payload"), null=False)
    queue = models.ForeignKey(Queue, related_name="messages")

    objects = MessageManager()

    class Meta:
        verbose_name = _("message")
        verbose_name_plural = _("messages")

########NEW FILE########
__FILENAME__ = simple
from ghettoq.backends import Connection
from ghettoq.messaging import Empty

########NEW FILE########
__FILENAME__ = taproot
import atexit
import socket
import sys

from itertools import count
from time import time, sleep

from anyjson import serialize, deserialize
from carrot.backends.base import BaseBackend, BaseMessage
from carrot.utils import gen_unique_id

from ghettoq.backends import Connection
from ghettoq.messaging import Empty as QueueEmpty


try:
    from collections import OrderedDict
except ImportError:
    from odict import odict as OrderedDict


class QualityOfService(object):

    def __init__(self, backend, resource, prefetch_count=None,
            interval=None):
        self.backend = backend
        self.resource = resource
        self.prefetch_count = prefetch_count
        self.interval = interval
        self._delivered = OrderedDict()
        self._restored_once = False
        atexit.register(self.restore_unacked_once)

    def can_consume(self):
        return len(self._delivered) > self.prefetch_count

    def append(self, message, queue_name, delivery_tag):
        self._delivered[delivery_tag] = message, queue_name

    def ack(self, delivery_tag):
        self._delivered.pop(delivery_tag, None)

    def restore_unacked(self):
        for delivery_tag, delivered in self._delivered.items():
            message, queue_name = delivered
            send = self.backend.prepare_message(message.body, 2, 10,
                                                message.content_type,
                                                message.content_encoding)
            send["destination"] = queue_name
            self.resource.put(queue_name, serialize(send))
        self._delivered = OrderedDict()

    def requeue(self, delivery_tag):
        try:
            message, queue_name = self._delivered.pop(delivery_tag)
        except KeyError:
            pass
        self.resource.put(queue_name, message)

    def restore_unacked_once(self):
        if not self._restored_once:
            if self._delivered:
                sys.stderr.write(
                    "Restoring unacknowledged messages: %s\n" % (
                        self._delivered))
            self.restore_unacked()
            if self._delivered:
                sys.stderr.write("UNRESTORED MESSAGES: %s\n" % (
                    self._delivered))


class Message(BaseMessage):

    def __init__(self, backend, payload, **kwargs):
        self.backend = backend

        payload = deserialize(payload)
        kwargs["body"] = payload.get("body").encode("utf-8")
        kwargs["delivery_tag"] = payload.get("delivery_tag")
        kwargs["content_type"] = payload.get("content-type")
        kwargs["content_encoding"] = payload.get("content-encoding")
        kwargs["priority"] = payload.get("priority")
        self.destination = payload.get("destination")

        super(Message, self).__init__(backend, **kwargs)

    def reject(self):
        raise NotImplementedError(
            "The GhettoQ backend does not implement basic.reject")


class MultiBackend(BaseBackend):
    Message = Message
    default_port = None
    type = None
    interval = 1
    polling = True
    _prefetch_count = None
    _consumers = {}
    _callbacks = {}

    def __init__(self, connection, **kwargs):
        if not self.type:
            raise NotImplementedError(
                        "MultiBackends must have the type attribute")
        self.connection = connection
        self._channel = None
        self._qos_manager = None

    def establish_connection(self):
        conninfo = self.connection
        conn = Connection(self.type, host=conninfo.hostname,
                                     user=conninfo.userid,
                                     password=conninfo.password,
                                     database=conninfo.virtual_host,
                                     port=conninfo.port)
        conn.drain_events = self.drain_events
        return conn

    def close_connection(self, connection):
        connection.close()

    def queue_exists(self, queue):
        return True

    def queue_purge(self, queue, **kwargs):
        return self.channel.Queue(queue).purge()

    def _poll(self, resource, timeout=None):
        time_elapsed = 0.0
        while True:
            time_start = time()
            if self.qos_manager.can_consume():
                try:
                    return resource.get()
                except QueueEmpty:
                    pass
            time_elapsed += (time() - time_start)
            if timeout and time_elapsed >= timeout:
                raise socket.timeout("Operation timed out.")
            if self.polling:
                sleep(self.interval)
                time_elapsed += self.interval

    def declare_consumer(self, queue, no_ack, callback, consumer_tag,
                         **kwargs):
        self._consumers[consumer_tag] = queue
        self._callbacks[queue] = callback

    def drain_events(self, timeout=None):
        queueset = self.channel.QueueSet(self._consumers.values())
        payload, queue = self._poll(queueset, timeout=timeout)

        if not queue or queue not in self._callbacks:
            return

        self._callbacks[queue](payload)

    def consume(self, limit=None):
        for total_message_count in count():
            if limit and total_message_count >= limit:
                raise StopIteration

            self.drain_events()

            yield True

    def queue_declare(self, queue, *args, **kwargs):
        pass

    def get(self, queue, **kwargs):
        try:
            payload = self.channel.Queue(queue).get()
        except QueueEmpty:
            return None
        else:
            return self.message_to_python(payload)

    def ack(self, delivery_tag):
        self.qos_manager.ack(delivery_tag)

    def requeue(self, delivery_tag):
        self.qos_manager.requeue(delivery_tag)

    def message_to_python(self, raw_message):
        message = self.Message(backend=self, payload=raw_message)
        self.qos_manager.append(message, message.destination,
                                message.delivery_tag)
        return message

    def prepare_message(self, message_data, delivery_mode, priority=0,
            content_type=None, content_encoding=None):
        return {"body": message_data,
                "delivery_tag": gen_unique_id(),
                "priority": priority or 0,
                "content-encoding": content_encoding,
                "content-type": content_type}

    def publish(self, message, exchange, routing_key, **kwargs):
        message["destination"] = exchange
        self.channel.Queue(exchange).put(serialize(message),
                                         priority=message["priority"])

    def cancel(self, consumer_tag):
        if not self._channel:
            return
        queue = self._consumers.pop(consumer_tag, None)
        self._callbacks.pop(queue, None)

    def close(self):
        for consumer_tag in self._consumers.keys():
            self.cancel(consumer_tag)
        if self._channel:
            self._channel.close()
        self._channel = None

    def basic_qos(self, prefetch_size, prefetch_count, apply_global=False):
        self._prefetch_count = prefetch_count

    @property
    def channel(self):
        if not self._channel:
            # Need one connection per channel.
            # AMQP has multiplexing, but Redis does not.
            self._channel = self.establish_connection()
        return self._channel

    @property
    def qos_manager(self):
        if self._qos_manager is None:
            self._qos_manager = QualityOfService(self, self.channel)

        # Update prefetch count / interval
        self._qos_manager.prefetch_count = self._prefetch_count
        self._qos_manager.interval = self.interval

        return self._qos_manager


class Redis(MultiBackend):
    type = "Redis"
    polling = False


class Database(MultiBackend):
    type = "database"


class MongoDB(MultiBackend):
    type = "mongodb"


class Beanstalk(MultiBackend):
    type = "Beanstalk"
    polling = False


class CouchDB(MultiBackend):
    type = "couchdb"

########NEW FILE########
__FILENAME__ = runners
from django.conf import settings
from django.test.simple import run_tests as django_test_runner


def run_tests(test_labels, verbosity=1, interactive=True, extra_tests=None,
        **kwargs):
    """ Test runner that only runs tests for the apps
    listed in ``settings.TEST_APPS``.
    """
    extra_tests = extra_tests or []
    app_labels = getattr(settings, "TEST_APPS", test_labels)
    return django_test_runner(app_labels,
                              verbosity=verbosity, interactive=interactive,
                              extra_tests=extra_tests, **kwargs)

########NEW FILE########
__FILENAME__ = test_beanstalk
import unittest

from anyjson import serialize, deserialize

from ghettoq.simple import Connection, Empty


def create_connection():
    return Connection("beanstalk", host="localhost")


class TestBeanstalkBackend(unittest.TestCase):

    def test_empty_raises_Empty(self):
        conn = create_connection()
        q = conn.Queue("testing")

        self.assertRaises(Empty, q.get)

    def test_put__get(self):
        conn = create_connection()
        q = conn.Queue("testing")
        q.put(serialize({"name": "George Constanza"}))

        self.assertEquals(deserialize(q.get()),
                {"name": "George Constanza"})

    def test_empty_queueset_raises_Empty(self):
        conn = create_connection()
        a, b, c, = conn.Queue("a"), conn.Queue("b"), conn.Queue("c")
        queueset = conn.QueueSet(queue.name for queue in (a, b, c))
        for queue in a, b, c:
            self.assertRaises(Empty, queue.get)
        self.assertRaises(Empty, queueset.get)

########NEW FILE########
__FILENAME__ = test_couchdb
import unittest

from anyjson import serialize, deserialize

from ghettoq.simple import Connection, Empty


def create_connection(database):
    return Connection("couchdb", host="localhost", database=database)


class TestCouchDbBackend(unittest.TestCase):

    def test_empty_raises_Empty(self):
        conn = create_connection("database")
        q = conn.Queue("testing")

        self.assertRaises(Empty, q.get)

    def test_queue_is_empty_after_purge(self):
        conn = create_connection("database")
        q = conn.Queue("test_queue")
        q.put(serialize({"name": "George Constanza"}))
        q.put(serialize({"name": "George Constanza"}))
        q.purge()

        self.assertRaises(Empty, q.get)

    def test_put_and_get(self):
        conn = create_connection("database")
        q = conn.Queue("testing")
        q.put(serialize({"name": "George Constanza"}))

        self.assertEquals(deserialize(q.get()),
                {"name": "George Constanza"})

    def test_empty_queset_raises_Empty(self):
        conn = create_connection("database")
        a, b, c, = conn.Queue("a"), conn.Queue("b"), conn.Queue("c")
        queueset = conn.QueueSet(queue.name for queue in (a, b, c))
        for queue in a, b, c:
            self.assertRaises(Empty, queue.get)
        self.assertRaises(Empty, queueset.get)

########NEW FILE########
__FILENAME__ = test_database
import unittest

from anyjson import serialize, deserialize

from ghettoq.simple import Connection, Empty


def create_connection(database):
    return Connection(database)


class TestDatabaseBackend(unittest.TestCase):

    def test_basic(self):
        conn = Connection("database")
        q = conn.Queue("testing")

        self.assertRaises(Empty, q.get)
        q.put(serialize({"name": "George Constanza"}))

        self.assertEquals(deserialize(q.get()),
                {"name": "George Constanza"})

    def test_empty_raises_Empty(self):
        conn = create_connection("database")
        q = conn.Queue("testing")

        self.assertRaises(Empty, q.get)

    def test_queue_is_empty_after_purge(self):
        conn = create_connection("database")
        q = conn.Queue("test_queue")
        q.put(serialize({"name": "George Constanza"}))
        q.put(serialize({"name": "George Constanza"}))
        q.purge()

        self.assertRaises(Empty, q.get)

    def test_put__get(self):
        conn = create_connection("database")
        q = conn.Queue("testing")
        q.put(serialize({"name": "George Constanza"}))

        self.assertEquals(deserialize(q.get()),
                {"name": "George Constanza"})

    def test_empty_queueset_raises_Empty(self):
        conn = create_connection("database")
        a, b, c, = conn.Queue("a"), conn.Queue("b"), conn.Queue("c")
        queueset = conn.QueueSet(queue.name for queue in (a, b, c))
        for queue in a, b, c:
            self.assertRaises(Empty, queue.get)
        self.assertRaises(Empty, queueset.get)

########NEW FILE########
__FILENAME__ = test_mongodb
import unittest

from anyjson import serialize, deserialize

from ghettoq.simple import Connection, Empty


def create_connection(database):
    return Connection("mongodb", host="localhost", database=database)


class TestMongoDbBackend(unittest.TestCase):

    def test_empty_raises_Empty(self):
        conn = create_connection("database")
        q = conn.Queue("testing")

        self.assertRaises(Empty, q.get)

    def test_queue_is_empty_after_purge(self):
        conn = create_connection("database")
        q = conn.Queue("test_queue")
        q.put(serialize({"name": "George Constanza"}))
        q.put(serialize({"name": "George Constanza"}))
        q.purge()

        self.assertRaises(Empty, q.get)

    def test_put_and_get(self):
        conn = create_connection("database")
        q = conn.Queue("testing")
        q.put(serialize({"name": "George Constanza"}))

        self.assertEquals(deserialize(q.get()),
                {"name": "George Constanza"})

    def test_empty_queset_raises_Empty(self):
        conn = create_connection("database")
        a, b, c, = conn.Queue("a"), conn.Queue("b"), conn.Queue("c")
        queueset = conn.QueueSet(queue.name for queue in (a, b, c))
        for queue in a, b, c:
            self.assertRaises(Empty, queue.get)
        self.assertRaises(Empty, queueset.get)

########NEW FILE########
__FILENAME__ = test_redis
import unittest

from anyjson import serialize, deserialize

from ghettoq.simple import Connection, Empty


def create_connection(database):
    return Connection("redis", host="localhost", database=database)


class TestRedisBackend(unittest.TestCase):

    def test_default_database_is_set_correctly(self):
        conn1 = create_connection("")
        conn2 = create_connection("/")
        conn3 = create_connection("")
        conn4 = create_connection(None)

        self.assertEquals(conn1.database, 0)
        self.assertEquals(conn2.database, 0)
        self.assertEquals(conn3.database, 0)
        self.assertEquals(conn4.database, 0)

    def test_database_name_is_set_correctly(self):
        conn1 = create_connection("1")
        conn2 = create_connection("/2")
        conn3 = create_connection(3)

        self.assertEquals(conn1.database, 1)
        self.assertEquals(conn2.database, 2)
        self.assertEquals(conn3.database, 3)

    def test_invalid_database_name_raises_AttributeError(self):
        self.assertRaises(AttributeError, create_connection, "string")
        self.assertRaises(AttributeError, create_connection, "1string")
        self.assertRaises(AttributeError, create_connection, "/string")

    def test_empty_raises_Empty(self):
        conn = create_connection(1)
        q = conn.Queue("testing")

        self.assertRaises(Empty, q.get)

    def test_queue_is_empty_after_purge(self):
        conn = create_connection(1)
        q = conn.Queue("test_queue")
        q.put(serialize({"name": "George Constanza"}))
        q.put(serialize({"name": "George Constanza"}))
        q.purge()

        self.assertRaises(Empty, q.get)

    def test_put__get(self):
        conn = create_connection(1)
        q = conn.Queue("testing")
        q.put(serialize({"name": "George Constanza"}))

        self.assertEquals(deserialize(q.get()),
                {"name": "George Constanza"})

    def test_empty_queueset_raises_Empty(self):
        conn = create_connection(1)
        a, b, c, = conn.Queue("a"), conn.Queue("b"), conn.Queue("c")
        queueset = conn.QueueSet(queue.name for queue in (a, b, c))
        for queue in a, b, c:
            self.assertRaises(Empty, queue.get)
        self.assertRaises(Empty, queueset.get)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write(
            "Error: Can't find the file 'settings.py' in the directory \
            containing %r. It appears you've customized things.\n\
            You'll have to run django-admin.py, passing it your settings\
            module.\n(If the file settings.py does indeed exist, it's\
            causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Django settings for testproj project.

import os
import sys
# import source code dir
sys.path.insert(0, os.path.join(os.getcwd(), os.pardir))

SITE_ID = 1069932

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ROOT_URLCONF = "urls"

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

TEST_RUNNER = "ghettoq.tests.runners.run_tests"
TEST_APPS = (
    "ghettoq",
)

MANAGERS = ADMINS

DATABASE_ENGINE = 'sqlite3'
DATABASE_NAME = 'testdb.sqlite'
DATABASE_USER = ''
DATABASE_PASSWORD = ''

# Database
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.%s' % DATABASE_ENGINE,
        'NAME': DATABASE_NAME,
        'USER': '',
        'PASSWORD': '',
        'HOST': '',
        'PORT': '',
    },
}

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'ghettoq',
)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    # Example:
    # (r'^testproj/', include('testproj.foo.urls')),

    # Uncomment the admin/doc line below and add 'django.contrib.admindocs'
    # to INSTALLED_APPS to enable admin documentation:
    # (r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # (r'^admin/(.*)', admin.site.root),
)

########NEW FILE########
